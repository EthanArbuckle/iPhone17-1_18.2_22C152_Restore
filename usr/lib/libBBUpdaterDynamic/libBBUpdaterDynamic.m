void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  uint64_t v9;

  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  v12[3] = *MEMORY[0x263EF8340];
  memset(v12, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!result)
  {
    if (v12[0] == 0x2000000000000010) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2;
    }
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  unint64_t v32 = 0;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }
  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if (result) {
        break;
      }
      if (a2 <= v13) {
        return 2;
      }
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3) {
          goto LABEL_58;
        }
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24 * v13 + 8)) {
          break;
        }
        uint64_t result = 2;
        if (v18)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1)) {
            continue;
          }
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4) {
          goto LABEL_59;
        }
        *(_OWORD *)v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        unint64_t v10 = v32;
        unint64_t v12 = v33;
        goto LABEL_47;
      }
    }
    if (result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        v25 = (__int16 *)(a3 + 24 * v13 + 16);
        unint64_t v26 = a2 - (unint64_t)v13;
        uint64_t result = 0;
        while (1)
        {
          __int16 v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0;
    }
    else {
      return 3;
    }
  }
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  v10[2] = *MEMORY[0x263EF8340];
  v10[0] = 0;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3;
  }
  v4 = *(unsigned char **)result;
  if (*(void *)result == -1) {
    goto LABEL_68;
  }
  v5 = &v4[v3];
  v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    unint64_t v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      unint64_t v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0;
            }
LABEL_34:
            uint64_t result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3;
      }
      unint64_t v15 = 0;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (unsigned char *)-1)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        unsigned int v24 = *v14++;
        unint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          char v26 = v25;
          uint64_t result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            unint64_t v27 = v22;
          }
          else {
            unint64_t v27 = v15;
          }
          BOOL v10 = (unint64_t)v5 >= v23;
          unint64_t v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28) {
            goto LABEL_69;
          }
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3;
  }
  unint64_t v8 = 0;
  uint64_t result = 3;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 == (unsigned __int8 *)-1) {
      goto LABEL_68;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    unint64_t v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3;
      }
      goto LABEL_20;
    }
  }
  return result;
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,ctu::Http::case_insensitive_key_comparer,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,ctu::Http::case_insensitive_key_comparer,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,ctu::Http::case_insensitive_key_comparer,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1, *(void *)(a2 + 8));
    if (*(char *)(a2 + 79) < 0)
    {
      operator delete(*(void **)(a2 + 56));
      if ((*(char *)(a2 + 55) & 0x80000000) == 0)
      {
LABEL_4:
        v4 = (void *)a2;
LABEL_6:
        operator delete(v4);
        return;
      }
    }
    else if ((*(char *)(a2 + 55) & 0x80000000) == 0)
    {
      goto LABEL_4;
    }
    operator delete(*(void **)(a2 + 32));
    v4 = (void *)a2;
    goto LABEL_6;
  }
}

uint64_t DERDecodeSeqInit(uint64_t a1, void *a2, void *a3)
{
  v8[3] = *MEMORY[0x263EF8340];
  memset(v8, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!result)
  {
    unint64_t v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        unint64_t v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          uint64_t result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

std::regex_iterator<std::__wrap_iter<const char *>, char> *__cdecl std::regex_iterator<std::__wrap_iter<char const*>,char,std::regex_traits<char>>::regex_iterator(std::regex_iterator<std::__wrap_iter<const char *>, char> *this, std::__wrap_iter<const char *> __a, std::__wrap_iter<const char *> __b, const std::regex_iterator<std::__wrap_iter<const char *>, char>::regex_type *__re, std::regex_constants::match_flag_type __m)
{
  __int16 v5 = __m;
  this->__begin_ = __a;
  this->__end_ = __b;
  this->__pregex_ = __re;
  this->__flags_ = __m;
  *(_OWORD *)&this->__match_.__matches_.__begin_ = 0u;
  p_match = &this->__match_;
  this->__match_.__prefix_.first.__i_ = 0;
  this->__match_.__prefix_.second.__i_ = 0;
  this->__match_.__prefix_.matched = 0;
  this->__match_.__suffix_.first.__i_ = 0;
  this->__match_.__suffix_.second.__i_ = 0;
  this->__match_.__suffix_.matched = 0;
  this->__match_.__ready_ = 0;
  this->__match_.__position_start_.__i_ = 0;
  *(_OWORD *)&this->__match_.__matches_.__end_cap_.__value_ = 0u;
  *(std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>> *)((char *)&this->__match_.__unmatched_.std::pair<std::__wrap_iter<const char *>, std::__wrap_iter<const char *>>
                                                                               + 1) = 0u;
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v13 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v15 = 0xAAAAAAAAAAAAAA00;
  long long v17 = v10;
  uint64_t v14 = 0;
  long long v16 = 0uLL;
  LOBYTE(v17) = 0;
  BYTE8(v17) = 0;
  uint64_t v18 = 0;
  memset(__p, 0, sizeof(__p));
  std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>((uint64_t)__re, (std::sub_match<const char *> *)__a.__i_, (std::sub_match<const char *> *)__b.__i_, (std::vector<std::csub_match> *)__p, __m);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:ne180100]<char const*,std::allocator<std::sub_match<char const*>>>(&p_match->__matches_, (uint64_t)__a.__i_, (std::sub_match<std::__wrap_iter<const char *>> *)__b.__i_, (uint64_t *)__p, (v5 & 0x800) != 0);
  if (*(void *)__p)
  {
    *(void *)&__p[8] = *(void *)__p;
    operator delete(*(void **)__p);
  }
  return this;
}

void sub_21DE8C94C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
  {
    operator delete(__p);
    long long v13 = *v11;
    if (!*v11) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    long long v13 = *v11;
    if (!*v11) {
      goto LABEL_3;
    }
  }
  *(void *)(v10 + 40) = v13;
  operator delete(v13);
  _Unwind_Resume(exception_object);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(uint64_t a1, std::sub_match<const char *> *a2, std::sub_match<const char *> *a3, std::vector<std::csub_match> *this, int a5)
{
  if ((a5 & 0x80) != 0) {
    int v9 = a5 & 0xFFA;
  }
  else {
    int v9 = a5;
  }
  int v10 = *(_DWORD *)(a1 + 28);
  this[1].__begin_ = a3;
  unint64_t v11 = (const std::vector<std::csub_match>::value_type *)&this[1];
  this[1].__end_ = a3;
  LOBYTE(this[1].__end_cap_.__value_) = 0;
  std::vector<std::sub_match<char const*>>::assign(this, (v10 + 1), (std::vector<std::csub_match>::const_reference)&this[1]);
  this[2].__begin_ = a2;
  this[2].__end_ = a2;
  LOBYTE(this[2].__end_cap_.__value_) = 0;
  *(std::pair<const char *, const char *> *)&this[3].__begin_ = v11->std::pair<const char *, const char *>;
  LOBYTE(this[3].__end_cap_.__value_) = this[1].__end_cap_.__value_;
  if ((v9 & 0x800) == 0) {
    this[4].__end_ = a2;
  }
  LOBYTE(this[4].__begin_) = 1;
  if ((*(_WORD *)(a1 + 24) & 0x1F0) == 0)
  {
    if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1, (const char *)a2, (const char *)a3, (uint64_t *)this, v9, (v9 & 0x800) == 0))goto LABEL_28; {
    goto LABEL_13;
    }
  }
  if (*(_DWORD *)(a1 + 28))
  {
    if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(a1, (const char *)a2, (const char *)a3, (uint64_t *)this, v9, (v9 & 0x800) == 0))goto LABEL_28; {
LABEL_13:
    }
    if (a2 != a3 && (v9 & 0x40) == 0)
    {
      int v12 = v9 | 0x80;
      for (i = (char *)&a2->first + 1; i != (const char *)a3; ++i)
      {
        std::vector<std::sub_match<char const*>>::assign(this, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3), v11);
        if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0)
        {
          if (*(_DWORD *)(a1 + 28))
          {
            if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(a1, i, (const char *)a3, (uint64_t *)this, v12, 0))goto LABEL_28; {
          }
            }
          else if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(a1, (uint64_t)i, (uint64_t)a3, (uint64_t *)this, v12, 0))
          {
            goto LABEL_28;
          }
        }
        else if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1, i, (const char *)a3, (uint64_t *)this, v12, 0))
        {
          goto LABEL_28;
        }
        std::vector<std::sub_match<char const*>>::assign(this, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3), v11);
      }
      std::vector<std::sub_match<char const*>>::assign(this, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3), v11);
      if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0)
      {
        if (*(_DWORD *)(a1 + 28))
        {
          if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(a1, (const char *)a3, (const char *)a3, (uint64_t *)this, v12, 0))goto LABEL_28; {
        }
          }
        else if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(a1, (uint64_t)a3, (uint64_t)a3, (uint64_t *)this, v12, 0))
        {
          goto LABEL_28;
        }
      }
      else if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1, (const char *)a3, (const char *)a3, (uint64_t *)this, v12, 0))
      {
        goto LABEL_28;
      }
    }
    uint64_t result = 0;
    this->__end_ = this->__begin_;
    return result;
  }
  if ((std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(a1, (uint64_t)a2, (uint64_t)a3, (uint64_t *)this, v9, (v9 & 0x800) == 0) & 1) == 0)goto LABEL_13; {
LABEL_28:
  }
  if (this->__end_ == this->__begin_) {
    std::vector<std::csub_match>::pointer begin = (std::vector<std::csub_match>::pointer)v11;
  }
  else {
    std::vector<std::csub_match>::pointer begin = this->__begin_;
  }
  first = (std::sub_match<const char *> *)begin->first;
  this[2].__end_ = (std::vector<std::csub_match>::pointer)begin->first;
  LOBYTE(this[2].__end_cap_.__value_) = this[2].__begin_ != first;
  second = (std::sub_match<const char *> *)begin->second;
  this[3].__begin_ = second;
  LOBYTE(this[3].__end_cap_.__value_) = second != this[3].__end_;
  return 1;
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  v48 = 0;
  v49 = 0;
  unint64_t v50 = 0;
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    return 0;
  }
  __x.second = a3;
  *(void *)&__x.matched = 0xAAAAAAAAAAAAAA00;
  __x.first = a3;
  *(_DWORD *)v46 = 0;
  memset(&v46[8], 0, 85);
  v49 = std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((void **)&v48, (uint64_t)v46);
  if (*(void *)&v46[56])
  {
    *(void *)&v46[64] = *(void *)&v46[56];
    operator delete(*(void **)&v46[56]);
  }
  if (*(void *)&v46[32])
  {
    *(void *)&v46[40] = *(void *)&v46[32];
    operator delete(*(void **)&v46[32]);
  }
  long long v13 = v49;
  *((_DWORD *)v49 - 24) = 0;
  *((void *)v13 - 11) = a2;
  *((void *)v13 - 10) = a2;
  *((void *)v13 - 9) = a3;
  uint64_t v14 = *((void *)v13 - 8);
  unint64_t v15 = *(unsigned int *)(a1 + 28);
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)v13 - 7) - v14) >> 3);
  if (v15 <= v16)
  {
    if (v15 < v16) {
      *((void *)v13 - 7) = v14 + 24 * v15;
    }
  }
  else
  {
    std::vector<std::sub_match<char const*>>::__append((std::vector<std::csub_match> *)(v13 - 64), v15 - v16, &__x);
    long long v13 = v49;
  }
  uint64_t v18 = *((void *)v13 - 5);
  unint64_t v19 = *(unsigned int *)(a1 + 32);
  unint64_t v20 = (*((void *)v13 - 4) - v18) >> 4;
  if (v19 <= v20)
  {
    if (v19 < v20) {
      *((void *)v13 - 4) = v18 + 16 * v19;
    }
  }
  else
  {
    std::vector<std::pair<unsigned long,char const*>>::__append((std::vector<std::pair<unsigned long, const char *>> *)(v13 - 40), v19 - v20);
    long long v13 = v49;
  }
  *((void *)v13 - 2) = v6;
  *((_DWORD *)v13 - 2) = a5;
  *(v13 - 4) = a6;
  unsigned int v21 = 1;
  while (2)
  {
    if ((v21 & 0xFFF) == 0 && (int)(v21 >> 12) >= (int)a3 - (int)a2) {
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)12>();
    }
    uint64_t v23 = *((void *)v13 - 2);
    if (v23) {
      (*(void (**)(uint64_t, char *))(*(void *)v23 + 16))(v23, v13 - 96);
    }
    switch(*((_DWORD *)v13 - 24))
    {
      case 0xFFFFFC18:
        unsigned int v24 = (const char *)*((void *)v13 - 10);
        if ((a5 & 0x20) != 0 && v24 == a2 || (a5 & 0x1000) != 0 && v24 != a3) {
          goto LABEL_27;
        }
        uint64_t v37 = *a4;
        *(void *)uint64_t v37 = a2;
        *(void *)(v37 + 8) = v24;
        *(unsigned char *)(v37 + 16) = 1;
        uint64_t v38 = *((void *)v13 - 8);
        uint64_t v39 = *((void *)v13 - 7) - v38;
        if (v39)
        {
          unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * (v39 >> 3);
          v41 = (unsigned char *)(v38 + 16);
          unsigned int v42 = 1;
          do
          {
            uint64_t v43 = v37 + 24 * v42;
            *(_OWORD *)uint64_t v43 = *((_OWORD *)v41 - 1);
            char v44 = *v41;
            v41 += 24;
            *(unsigned char *)(v43 + 16) = v44;
          }
          while (v40 > v42++);
        }
        uint64_t v17 = 1;
        unint64_t v22 = v48;
        if (!v48) {
          return v17;
        }
        goto LABEL_38;
      case 0xFFFFFC1D:
      case 0xFFFFFC1E:
      case 0xFFFFFC21:
        goto LABEL_17;
      case 0xFFFFFC1F:
LABEL_27:
        BOOL v25 = v49;
        char v26 = (void *)*((void *)v49 - 5);
        if (v26)
        {
          *((void *)v49 - 4) = v26;
          operator delete(v26);
        }
        unint64_t v27 = (void *)*((void *)v25 - 8);
        if (v27)
        {
          *((void *)v25 - 7) = v27;
          operator delete(v27);
        }
        v49 = v25 - 96;
        goto LABEL_17;
      case 0xFFFFFC20:
        *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v46[64] = v28;
        *(_OWORD *)&v46[80] = v28;
        *(_OWORD *)&v46[32] = v28;
        *(_OWORD *)&v46[48] = v28;
        *(_OWORD *)v46 = v28;
        *(_OWORD *)&v46[16] = v28;
        std::__state<char>::__state((uint64_t)v46, (long long *)v13 - 6);
        (*(void (**)(void, uint64_t, char *))(**((void **)v13 - 2) + 24))(*((void *)v13 - 2), 1, v13 - 96);
        (*(void (**)(void, void, unsigned char *))(**(void **)&v46[80] + 24))(*(void *)&v46[80], 0, v46);
        v29 = v49;
        if ((unint64_t)v49 >= v50)
        {
          v49 = std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((void **)&v48, (uint64_t)v46);
          if (*(void *)&v46[56])
          {
            *(void *)&v46[64] = *(void *)&v46[56];
            operator delete(*(void **)&v46[56]);
          }
        }
        else
        {
          long long v30 = *(_OWORD *)&v46[16];
          *(_OWORD *)v49 = *(_OWORD *)v46;
          *((_OWORD *)v29 + 1) = v30;
          *((void *)v29 + 4) = 0;
          *((void *)v29 + 5) = 0;
          *((void *)v29 + 6) = 0;
          *((void *)v29 + 7) = 0;
          *((_OWORD *)v29 + 2) = *(_OWORD *)&v46[32];
          *((void *)v29 + 6) = *(void *)&v46[48];
          memset(&v46[32], 0, 24);
          *((void *)v29 + 8) = 0;
          *((void *)v29 + 9) = 0;
          *(_OWORD *)(v29 + 56) = *(_OWORD *)&v46[56];
          *((void *)v29 + 9) = *(void *)&v46[72];
          memset(&v46[56], 0, 24);
          uint64_t v31 = *(void *)&v46[80];
          *(void *)(v29 + 85) = *(void *)&v46[85];
          *((void *)v29 + 10) = v31;
          v49 = v29 + 96;
        }
        if (*(void *)&v46[32])
        {
          *(void *)&v46[40] = *(void *)&v46[32];
          operator delete(*(void **)&v46[32]);
        }
LABEL_17:
        unint64_t v22 = v48;
        long long v13 = v49;
        ++v21;
        if (v48 != v49) {
          continue;
        }
        uint64_t v17 = 0;
        if (v48)
        {
LABEL_38:
          unint64_t v32 = v49;
          unint64_t v33 = v22;
          if (v49 != v22)
          {
            do
            {
              uint64_t v34 = (void *)*((void *)v32 - 5);
              if (v34)
              {
                *((void *)v32 - 4) = v34;
                operator delete(v34);
              }
              v35 = (void *)*((void *)v32 - 8);
              if (v35)
              {
                *((void *)v32 - 7) = v35;
                operator delete(v35);
              }
              v32 -= 96;
            }
            while (v32 != v22);
            unint64_t v33 = v48;
          }
          v49 = v22;
          operator delete(v33);
        }
        break;
      default:
        std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)16>();
    }
    return v17;
  }
}

void sub_21DE8D0F8(_Unwind_Exception *a1)
{
  std::vector<std::__state<char>>::~vector[abi:ne180100]((void **)(v1 - 112));
  _Unwind_Resume(a1);
}

void sub_21DE8D10C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::__state<char>::~__state((uint64_t *)va);
  std::vector<std::__state<char>>::~vector[abi:ne180100]((void **)(v3 - 112));
  _Unwind_Resume(a1);
}

void sub_21DE8D154(_Unwind_Exception *a1)
{
  std::vector<std::__state<char>>::~vector[abi:ne180100]((void **)(v1 - 112));
  _Unwind_Resume(a1);
}

void sub_21DE8D168(_Unwind_Exception *a1)
{
  std::vector<std::__state<char>>::~vector[abi:ne180100]((void **)(v1 - 112));
  _Unwind_Resume(a1);
}

void std::__bracket_expression<char,std::regex_traits<char>>::__exec(const std::__bracket_expression<char, std::regex_traits<char>> *this, std::__bracket_expression<char, std::regex_traits<char>>::__state *a2)
{
  unint64_t v2 = a2;
  current = a2->__current_;
  last = a2->__last_;
  if (current == last)
  {
    uint64_t v25 = 0;
    BOOL negate = this->__negate_;
    goto LABEL_245;
  }
  if (!this->__might_have_digraph_ || current + 1 == last) {
    goto LABEL_34;
  }
  char v6 = *current;
  LOBYTE(__src) = *current;
  char v7 = current[1];
  HIBYTE(__src) = v7;
  if (this->__icase_)
  {
    LOBYTE(__src) = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, v6);
    HIBYTE(__src) = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, v7);
  }
  p_traits = &this->__traits_;
  std::regex_traits<char>::__lookup_collatename<char *>(&__src, (uint64_t)&this->__traits_, __p, (uint64_t)__p);
  if (SHIBYTE(__p[2]) < 0)
  {
    unint64_t v27 = __p[1];
    operator delete(__p[0]);
    if (v27) {
      goto LABEL_8;
    }
LABEL_34:
    BOOL negate = 0;
    uint64_t v25 = 1;
    unsigned __int8 v28 = *v2->__current_;
    LOBYTE(__src) = v28;
    if (!this->__icase_) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  if (!HIBYTE(__p[2])) {
    goto LABEL_34;
  }
LABEL_8:
  std::vector<std::pair<char, char>>::pointer begin = this->__digraphs_.__begin_;
  uint64_t v10 = (char *)this->__digraphs_.__end_ - (char *)begin;
  if (v10)
  {
    uint64_t v11 = v10 >> 1;
    if ((unint64_t)(v10 >> 1) <= 1) {
      uint64_t v11 = 1;
    }
    p_second = &begin->second;
    while (__src != *(p_second - 1) || HIBYTE(__src) != *p_second)
    {
      p_second += 2;
      if (!--v11) {
        goto LABEL_17;
      }
    }
    goto LABEL_227;
  }
LABEL_17:
  if (!this->__collate_ || this->__ranges_.__begin_ == this->__ranges_.__end_)
  {
    BOOL negate = 0;
    goto LABEL_167;
  }
  memset(v136, 170, sizeof(v136));
  __p[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  __p[2] = (void *)0x2AAAAAAAAAAAAAALL;
  __p[0] = (void *)0xAAAAAAAAAA00AAAALL;
  LOWORD(__p[0]) = __src;
  (*(void (**)(void **__return_ptr))(*(void *)this->__traits_.__col_ + 32))(v136);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  std::vector<std::pair<std::string, std::string>>::pointer v14 = this->__ranges_.__begin_;
  char v15 = HIBYTE(v136[2]);
  int64_t v16 = (char *)this->__ranges_.__end_ - (char *)v14;
  if (!v16)
  {
    BOOL v24 = 0;
    int v70 = 0;
    int v69 = 0;
    goto LABEL_164;
  }
  v128 = v2;
  uint64_t v17 = 0;
  unint64_t v18 = v16 / 48;
  if (SHIBYTE(v136[2]) >= 0) {
    unint64_t v19 = v136;
  }
  else {
    unint64_t v19 = (void **)v136[0];
  }
  char v20 = HIBYTE(v136[2]);
  if (SHIBYTE(v136[2]) >= 0) {
    unsigned int v21 = (void *)HIBYTE(v136[2]);
  }
  else {
    unsigned int v21 = v136[1];
  }
  if (v18 <= 1) {
    uint64_t v22 = 1;
  }
  else {
    uint64_t v22 = v16 / 48;
  }
  uint64_t v23 = (unsigned __int8 *)&v14->second.__r_.__value_.__r.__words[2] + 7;
  BOOL v24 = 1;
  do
  {
    int v59 = (char)*(v23 - 24);
    if (v59 >= 0) {
      v60 = (char *)(v23 - 47);
    }
    else {
      v60 = *(char **)(v23 - 47);
    }
    if (v59 >= 0) {
      size_t v61 = *(v23 - 24);
    }
    else {
      size_t v61 = *(void *)(v23 - 39);
    }
    if ((unint64_t)v21 >= v61) {
      size_t v62 = v61;
    }
    else {
      size_t v62 = (size_t)v21;
    }
    int v63 = memcmp(v60, v19, v62);
    if (v63)
    {
      if ((v63 & 0x80000000) == 0) {
        goto LABEL_98;
      }
    }
    else if (v61 > (unint64_t)v21)
    {
      goto LABEL_98;
    }
    int v64 = (char)*v23;
    if (v64 >= 0) {
      v65 = (char *)(v23 - 23);
    }
    else {
      v65 = *(char **)(v23 - 23);
    }
    if (v64 >= 0) {
      size_t v66 = *v23;
    }
    else {
      size_t v66 = *(void *)(v23 - 15);
    }
    if (v66 >= (unint64_t)v21) {
      size_t v67 = (size_t)v21;
    }
    else {
      size_t v67 = v66;
    }
    int v68 = memcmp(v19, v65, v67);
    if (v68)
    {
      if (v68 < 0)
      {
LABEL_123:
        int v69 = 1;
        int v70 = 5;
        goto LABEL_162;
      }
    }
    else if ((unint64_t)v21 <= v66)
    {
      goto LABEL_123;
    }
LABEL_98:
    BOOL v24 = ++v17 < v18;
    v23 += 48;
  }
  while (v22 != v17);
  int v70 = 0;
  int v69 = 0;
LABEL_162:
  unint64_t v2 = v128;
  p_traits = &this->__traits_;
  char v15 = v20;
LABEL_164:
  if (v15 < 0) {
    operator delete(v136[0]);
  }
  BOOL negate = v69;
  if (v24) {
    goto LABEL_207;
  }
LABEL_167:
  if (this->__equivalences_.__begin_ == this->__equivalences_.__end_) {
    goto LABEL_209;
  }
  int v133 = negate;
  v88 = v2;
  memset(__p, 170, sizeof(__p));
  std::regex_traits<char>::__transform_primary<char *>(&__src, (uint64_t)p_traits, __p, __p);
  std::vector<std::string>::pointer v89 = this->__equivalences_.__begin_;
  int v90 = SHIBYTE(__p[2]);
  int64_t v91 = (char *)this->__equivalences_.__end_ - (char *)v89;
  if (!v91) {
    goto LABEL_188;
  }
  unint64_t v92 = v91 / 24;
  v93 = __p[1];
  if (SHIBYTE(__p[2]) >= 0) {
    v94 = (void *)HIBYTE(__p[2]);
  }
  else {
    v94 = __p[1];
  }
  if (SHIBYTE(__p[2]) < 0)
  {
    int v135 = SHIBYTE(__p[2]);
    uint64_t v103 = 0;
    v104 = __p[0];
    if (v92 <= 1) {
      uint64_t v105 = 1;
    }
    else {
      uint64_t v105 = v91 / 24;
    }
    BOOL v97 = 1;
    do
    {
      std::string::size_type size = HIBYTE(v89->__r_.__value_.__r.__words[2]);
      int v107 = (char)size;
      if ((size & 0x80u) != 0) {
        std::string::size_type size = v89->__r_.__value_.__l.__size_;
      }
      if (v94 == (void *)size)
      {
        std::vector<std::string>::pointer v108 = v107 >= 0 ? v89 : (std::vector<std::string>::pointer)v89->__r_.__value_.__r.__words[0];
        if (!memcmp(v104, v108, (size_t)v93))
        {
          int v133 = 1;
          int v70 = 5;
          goto LABEL_203;
        }
      }
      BOOL v97 = ++v103 < v92;
      ++v89;
    }
    while (v105 != v103);
    int v70 = 0;
LABEL_203:
    unint64_t v2 = v88;
    int v90 = v135;
    goto LABEL_204;
  }
  if (!HIBYTE(__p[2]))
  {
    std::string::size_type v114 = HIBYTE(v89->__r_.__value_.__r.__words[2]);
    if ((v114 & 0x80u) != 0) {
      std::string::size_type v114 = v89->__r_.__value_.__l.__size_;
    }
    if (v114 != HIBYTE(__p[2]))
    {
      unint64_t v119 = 0;
      if (v92 <= 1) {
        uint64_t v120 = 1;
      }
      else {
        uint64_t v120 = v92;
      }
      uint64_t v121 = v120 - 1;
      v122 = &v89[1].__r_.__value_.__s.__data_[8];
      unint64_t v2 = v88;
      while (v121 != v119)
      {
        ++v119;
        unint64_t v123 = v122[15];
        unint64_t v125 = *(void *)v122;
        v122 += 24;
        unint64_t v124 = v125;
        if ((v123 & 0x80u) != 0) {
          unint64_t v123 = v124;
        }
        if (v94 == (void *)v123)
        {
          BOOL v97 = v119 < v92;
          int v133 = 1;
          int v70 = 5;
          goto LABEL_204;
        }
      }
      BOOL v97 = 0;
      int v70 = 0;
      goto LABEL_204;
    }
    unint64_t v2 = v88;
    BOOL negate = 1;
LABEL_208:
    uint64_t v25 = 2;
    goto LABEL_245;
  }
  uint64_t v95 = 0;
  uint64_t v96 = v92 <= 1 ? 1 : v91 / 24;
  BOOL v97 = 1;
  do
  {
    v98 = &v89[v95];
    v99 = (void *)HIBYTE(v98->__r_.__value_.__r.__words[2]);
    int v100 = (char)v99;
    if ((char)v99 < 0) {
      v99 = (void *)v98->__r_.__value_.__l.__size_;
    }
    if (v94 == v99)
    {
      if (v100 < 0) {
        v98 = (std::string *)v98->__r_.__value_.__r.__words[0];
      }
      v101 = __p;
      uint64_t v102 = HIBYTE(__p[2]);
      while (*(unsigned __int8 *)v101 == v98->__r_.__value_.__s.__data_[0])
      {
        v101 = (void **)((char *)v101 + 1);
        v98 = (std::string *)((char *)v98 + 1);
        if (!--v102)
        {
          int v133 = 1;
          int v70 = 5;
          unint64_t v2 = v88;
          goto LABEL_204;
        }
      }
    }
    BOOL v97 = ++v95 < v92;
  }
  while (v95 != v96);
LABEL_188:
  BOOL v97 = 0;
  int v70 = 0;
  unint64_t v2 = v88;
LABEL_204:
  if (v90 < 0) {
    operator delete(__p[0]);
  }
  BOOL negate = v133;
  if (!v97)
  {
LABEL_209:
    if ((char)__src < 0)
    {
      neg_std::regex_traits<char>::char_class_type mask = this->__neg_mask_;
    }
    else
    {
      std::regex_traits<char>::char_class_type mask = this->__mask_;
      tab = this->__traits_.__ct_->__tab_;
      std::ctype_base::mask v111 = tab[__src];
      if (((v111 & mask) != 0 || __src == 95 && (mask & 0x80) != 0)
        && (SHIBYTE(__src) & 0x80000000) == 0
        && ((tab[HIBYTE(__src)] & mask) != 0 || (mask & 0x80) != 0 && HIBYTE(__src) == 95))
      {
        goto LABEL_227;
      }
      neg_std::regex_traits<char>::char_class_type mask = this->__neg_mask_;
      if ((neg_mask & v111) != 0 || __src == 95 && (neg_mask & 0x80) != 0)
      {
LABEL_226:
        int v113 = negate;
LABEL_228:
        BOOL negate = v113;
        uint64_t v25 = 2;
        goto LABEL_245;
      }
    }
    if ((SHIBYTE(__src) & 0x80000000) == 0)
    {
      if ((this->__traits_.__ct_->__tab_[HIBYTE(__src)] & neg_mask) == 0)
      {
        int v113 = 1;
        if (HIBYTE(__src) != 95 || (neg_mask & 0x80) == 0) {
          goto LABEL_228;
        }
      }
      goto LABEL_226;
    }
LABEL_227:
    int v113 = 1;
    goto LABEL_228;
  }
LABEL_207:
  if (v70) {
    goto LABEL_208;
  }
  uint64_t v25 = 2;
  unsigned __int8 v28 = *v2->__current_;
  LOBYTE(__src) = v28;
  if (this->__icase_)
  {
LABEL_35:
    unsigned __int8 v28 = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, (char)v28);
    LOBYTE(__src) = v28;
  }
LABEL_36:
  std::vector<char>::pointer v29 = this->__chars_.__begin_;
  unint64_t v30 = this->__chars_.__end_ - v29;
  if (v30)
  {
    if (v30 <= 1) {
      unint64_t v30 = 1;
    }
    while (1)
    {
      int v31 = *v29++;
      if (v31 == v28) {
        break;
      }
      if (!--v30) {
        goto LABEL_41;
      }
    }
LABEL_244:
    BOOL negate = 1;
    goto LABEL_245;
  }
LABEL_41:
  std::regex_traits<char>::char_class_type v32 = this->__neg_mask_;
  if (v32 || this->__neg_chars_.__begin_ != this->__neg_chars_.__end_)
  {
    if ((v28 & 0x80) != 0 || (this->__traits_.__ct_->__tab_[v28] & v32) == 0)
    {
      int v34 = (v32 >> 7) & 1;
      char v33 = v28 == 95 ? v34 : 0;
    }
    else
    {
      char v33 = 1;
    }
    std::vector<char>::pointer end = this->__neg_chars_.__end_;
    std::vector<char>::pointer v36 = (std::vector<char>::pointer)memchr(this->__neg_chars_.__begin_, (char)v28, end - this->__neg_chars_.__begin_);
    uint64_t v37 = v36 ? v36 : end;
    if ((v33 & 1) == 0 && v37 == end) {
      goto LABEL_244;
    }
  }
  std::vector<std::pair<std::string, std::string>>::pointer v38 = this->__ranges_.__begin_;
  std::vector<std::pair<std::string, std::string>>::pointer v39 = this->__ranges_.__end_;
  if (v38 == v39) {
    goto LABEL_128;
  }
  memset(v136, 170, sizeof(v136));
  if (!this->__collate_)
  {
    unsigned int v40 = 1;
    HIBYTE(v136[2]) = 1;
    LOWORD(v136[0]) = v28;
    int64_t v41 = (char *)v39 - (char *)v38;
    if (v41) {
      goto LABEL_59;
    }
LABEL_155:
    BOOL v48 = 0;
    if ((v40 & 0x80) != 0) {
      goto LABEL_126;
    }
    goto LABEL_127;
  }
  __p[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  __p[2] = (void *)0x1AAAAAAAAAAAAAALL;
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  LOWORD(__p[0]) = v28;
  (*(void (**)(void **__return_ptr))(*(void *)this->__traits_.__col_ + 32))(v136);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  std::vector<std::pair<std::string, std::string>>::pointer v38 = this->__ranges_.__begin_;
  unsigned int v40 = HIBYTE(v136[2]);
  int64_t v41 = (char *)this->__ranges_.__end_ - (char *)v38;
  if (!v41) {
    goto LABEL_155;
  }
LABEL_59:
  uint64_t v134 = v25;
  BOOL v131 = negate;
  v129 = v2;
  uint64_t v42 = 0;
  unint64_t v43 = v41 / 48;
  char v126 = v40;
  if ((v40 & 0x80u) == 0) {
    char v44 = v136;
  }
  else {
    char v44 = (void **)v136[0];
  }
  if ((v40 & 0x80u) == 0) {
    v45 = (void *)v40;
  }
  else {
    v45 = v136[1];
  }
  if (v43 <= 1) {
    uint64_t v46 = 1;
  }
  else {
    uint64_t v46 = v41 / 48;
  }
  v47 = (unsigned __int8 *)&v38->second.__r_.__value_.__r.__words[2] + 7;
  BOOL v48 = 1;
  while (2)
  {
    int v49 = (char)*(v47 - 24);
    if (v49 >= 0) {
      unint64_t v50 = (char *)(v47 - 47);
    }
    else {
      unint64_t v50 = *(char **)(v47 - 47);
    }
    if (v49 >= 0) {
      size_t v51 = *(v47 - 24);
    }
    else {
      size_t v51 = *(void *)(v47 - 39);
    }
    if ((unint64_t)v45 >= v51) {
      size_t v52 = v51;
    }
    else {
      size_t v52 = (size_t)v45;
    }
    int v53 = memcmp(v50, v44, v52);
    if (v53)
    {
      if (v53 < 0) {
        goto LABEL_84;
      }
    }
    else if (v51 <= (unint64_t)v45)
    {
LABEL_84:
      int v54 = (char)*v47;
      if (v54 >= 0) {
        v55 = (char *)(v47 - 23);
      }
      else {
        v55 = *(char **)(v47 - 23);
      }
      if (v54 >= 0) {
        size_t v56 = *v47;
      }
      else {
        size_t v56 = *(void *)(v47 - 15);
      }
      if (v56 >= (unint64_t)v45) {
        size_t v57 = (size_t)v45;
      }
      else {
        size_t v57 = v56;
      }
      int v58 = memcmp(v44, v55, v57);
      if (v58)
      {
        if (v58 < 0)
        {
LABEL_95:
          BOOL negate = 1;
          unint64_t v2 = v129;
          uint64_t v25 = v134;
          if ((v126 & 0x80) == 0) {
            goto LABEL_127;
          }
          goto LABEL_126;
        }
      }
      else if ((unint64_t)v45 <= v56)
      {
        goto LABEL_95;
      }
    }
    BOOL v48 = ++v42 < v43;
    v47 += 48;
    if (v46 != v42) {
      continue;
    }
    break;
  }
  unint64_t v2 = v129;
  BOOL negate = v131;
  uint64_t v25 = v134;
  if ((v126 & 0x80) == 0) {
    goto LABEL_127;
  }
LABEL_126:
  operator delete(v136[0]);
LABEL_127:
  if (v48) {
    goto LABEL_245;
  }
LABEL_128:
  if (this->__equivalences_.__begin_ == this->__equivalences_.__end_)
  {
LABEL_239:
    if ((v28 & 0x80) != 0) {
      goto LABEL_245;
    }
    std::regex_traits<char>::char_class_type v115 = this->__mask_;
    if ((this->__traits_.__ct_->__tab_[v28] & v115) == 0)
    {
      int v116 = (v115 >> 7) & 1;
      if (v28 != 95) {
        int v116 = 0;
      }
      if (v116 != 1) {
        goto LABEL_245;
      }
    }
    goto LABEL_244;
  }
  memset(__p, 170, sizeof(__p));
  std::regex_traits<char>::__transform_primary<char *>(&__src, (uint64_t)&this->__traits_, (unsigned char *)&__src + 1, __p);
  std::vector<std::string>::pointer v71 = this->__equivalences_.__begin_;
  uint64_t v72 = HIBYTE(__p[2]);
  int64_t v73 = (char *)this->__equivalences_.__end_ - (char *)v71;
  if (!v73)
  {
    if ((HIBYTE(__p[2]) & 0x80) != 0) {
      operator delete(__p[0]);
    }
LABEL_238:
    unsigned __int8 v28 = __src;
    goto LABEL_239;
  }
  BOOL v132 = negate;
  v130 = v2;
  unint64_t v74 = 0;
  unint64_t v75 = v73 / 24;
  v76 = __p[0];
  v77 = __p[1];
  if (SHIBYTE(__p[2]) >= 0) {
    v78 = (void *)HIBYTE(__p[2]);
  }
  else {
    v78 = __p[1];
  }
  if (v75 <= 1) {
    uint64_t v79 = 1;
  }
  else {
    uint64_t v79 = v73 / 24;
  }
  BOOL v80 = 1;
  while (2)
  {
    v81 = &v71[v74];
    v82 = (void *)HIBYTE(v81->__r_.__value_.__r.__words[2]);
    int v83 = (char)v82;
    if ((char)v82 < 0) {
      v82 = (void *)v81->__r_.__value_.__l.__size_;
    }
    if (v78 != v82)
    {
LABEL_149:
      if (++v74 == v79)
      {
        if ((v72 & 0x80) != 0) {
LABEL_236:
        }
          operator delete(__p[0]);
        unint64_t v2 = v130;
        BOOL negate = v132;
        goto LABEL_238;
      }
      goto LABEL_153;
    }
    if (v83 >= 0) {
      v84 = &v71[v74];
    }
    else {
      v84 = (std::string *)v81->__r_.__value_.__r.__words[0];
    }
    if ((v72 & 0x80) == 0)
    {
      if (!v72)
      {
LABEL_157:
        unint64_t v2 = v130;
        BOOL negate = 1;
        if (!v80) {
          goto LABEL_238;
        }
        goto LABEL_245;
      }
      uint64_t v85 = 0;
      while (*((unsigned __int8 *)__p + v85) == v84->__r_.__value_.__s.__data_[v85])
      {
        if (v72 == ++v85) {
          goto LABEL_157;
        }
      }
      goto LABEL_149;
    }
    BOOL v127 = v80;
    v86 = v76;
    v87 = v77;
    if (memcmp(v76, v84, (size_t)v77))
    {
      ++v74;
      v77 = v87;
      v76 = v86;
      if (v74 == v79) {
        goto LABEL_236;
      }
LABEL_153:
      BOOL v80 = v74 < v75;
      continue;
    }
    break;
  }
  operator delete(__p[0]);
  unint64_t v2 = v130;
  BOOL negate = 1;
  if (!v127) {
    goto LABEL_238;
  }
LABEL_245:
  if (negate == this->__negate_)
  {
    first = 0;
    int v118 = -993;
  }
  else
  {
    v2->__current_ += v25;
    first = this->__first_;
    int v118 = -995;
  }
  v2->__do_ = v118;
  v2->__node_ = first;
}

void sub_21DE8DCBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__loop<char>::__exec(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 40);
  uint64_t v3 = *(void *)(a2 + 56);
  v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 != -991)
  {
    unint64_t *v4 = 0;
    if (!*(void *)(result + 32))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_28;
    }
    if (*(void *)(result + 24))
    {
      *(_DWORD *)a2 = -994;
      *(void *)(a2 + 80) = *(void *)(result + 8);
      *(void *)(v3 + 16 * v2 + 8) = *(void *)(a2 + 16);
      int v20 = *(_DWORD *)(result + 44);
      int v21 = *(_DWORD *)(result + 48);
      if (v20 == v21) {
        return result;
      }
      uint64_t v22 = (v21 - 1);
      uint64_t v23 = (v20 - 1);
      uint64_t v24 = *(void *)(a2 + 24);
      uint64_t v25 = *(void *)(a2 + 32);
      uint64_t v26 = v22 - v23;
      if ((unint64_t)(v22 - v23) >= 2)
      {
        uint64_t v27 = (v26 & 0xFFFFFFFFFFFFFFFELL) + v23;
        uint64_t v28 = v25 + 24 * v23 + 24;
        unint64_t v29 = v26 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          *(void *)(v28 - 24) = v24;
          *(void *)(v28 - 16) = v24;
          *(void *)uint64_t v28 = v24;
          *(void *)(v28 + 8) = v24;
          *(unsigned char *)(v28 - 8) = 0;
          *(unsigned char *)(v28 + 16) = 0;
          v28 += 48;
          v29 -= 2;
        }
        while (v29);
        if (v26 == (v26 & 0xFFFFFFFFFFFFFFFELL)) {
          return result;
        }
      }
      else
      {
        uint64_t v27 = v23;
      }
      uint64_t v30 = v22 - v27;
      int v31 = (unsigned char *)(v25 + 24 * v27 + 16);
      do
      {
        *((void *)v31 - 2) = v24;
        *((void *)v31 - 1) = v24;
        *int v31 = 0;
        v31 += 24;
        --v30;
      }
      while (v30);
      return result;
    }
LABEL_26:
    *(_DWORD *)a2 = -992;
    return result;
  }
  unint64_t v5 = *v4 + 1;
  unint64_t *v4 = v5;
  unint64_t v6 = *(void *)(result + 24);
  unint64_t v7 = *(void *)(result + 32);
  BOOL v8 = v5 < v7;
  if (v5 < v7 && v5 >= v6) {
    BOOL v8 = v5 < v7 && *(void *)(v3 + 16 * v2 + 8) != *(void *)(a2 + 16);
  }
  if (v8 && v5 >= v6) {
    goto LABEL_26;
  }
  *(_DWORD *)a2 = -994;
  if (!v8)
  {
LABEL_28:
    *(void *)(a2 + 80) = *(void *)(result + 16);
    return result;
  }
  *(void *)(a2 + 80) = *(void *)(result + 8);
  *(void *)(v3 + 16 * v2 + 8) = *(void *)(a2 + 16);
  int v12 = *(_DWORD *)(result + 44);
  int v13 = *(_DWORD *)(result + 48);
  if (v12 == v13) {
    return result;
  }
  uint64_t v14 = (v13 - 1);
  uint64_t v15 = (v12 - 1);
  uint64_t v16 = *(void *)(a2 + 24);
  uint64_t v17 = *(void *)(a2 + 32);
  uint64_t v18 = v14 - v15;
  if ((unint64_t)(v14 - v15) < 2)
  {
    uint64_t v19 = v15;
LABEL_39:
    uint64_t v34 = v14 - v19;
    v35 = (unsigned char *)(v17 + 24 * v19 + 16);
    do
    {
      *((void *)v35 - 2) = v16;
      *((void *)v35 - 1) = v16;
      unsigned char *v35 = 0;
      v35 += 24;
      --v34;
    }
    while (v34);
    return result;
  }
  uint64_t v19 = (v18 & 0xFFFFFFFFFFFFFFFELL) + v15;
  uint64_t v32 = v17 + 24 * v15 + 24;
  unint64_t v33 = v18 & 0xFFFFFFFFFFFFFFFELL;
  do
  {
    *(void *)(v32 - 24) = v16;
    *(void *)(v32 - 16) = v16;
    *(void *)uint64_t v32 = v16;
    *(void *)(v32 + 8) = v16;
    *(unsigned char *)(v32 - 8) = 0;
    *(unsigned char *)(v32 + 16) = 0;
    v32 += 48;
    v33 -= 2;
  }
  while (v33);
  if (v18 != (v18 & 0xFFFFFFFFFFFFFFFELL)) {
    goto LABEL_39;
  }
  return result;
}

uint64_t std::__alternate<char>::__exec_split(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 16;
  }
  *(void *)(a3 + 80) = *(void *)(result + v3);
  return result;
}

void std::vector<std::sub_match<char const*>>::assign(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __n, std::vector<std::csub_match>::const_reference __u)
{
  value = this->__end_cap_.__value_;
  std::vector<std::pair<char, char>>::pointer begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)begin) >> 3) < __n)
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_26;
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)value >> 3);
    std::vector<std::csub_match>::size_type v9 = 2 * v8;
    if (2 * v8 <= __n) {
      std::vector<std::csub_match>::size_type v9 = __n;
    }
    unint64_t v10 = v8 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v9;
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
LABEL_26:
    }
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    uint64_t v11 = v10;
    int v12 = (std::sub_match<const char *> *)operator new(24 * v10);
    this->__begin_ = v12;
    this->__end_ = v12;
    this->__end_cap_.__value_ = &v12[v11];
    std::vector<std::csub_match>::size_type v13 = 24 * __n;
    uint64_t v14 = &v12[__n];
    do
    {
      v12->std::pair<const char *, const char *> = __u->std::pair<const char *, const char *>;
      *(void *)&v12->matched = *(void *)&__u->matched;
      ++v12;
      v13 -= 24;
    }
    while (v13);
    goto LABEL_25;
  }
  std::vector<std::csub_match>::pointer end = this->__end_;
  unint64_t v16 = end - begin;
  if (v16 >= __n) {
    std::vector<std::csub_match>::size_type v17 = __n;
  }
  else {
    std::vector<std::csub_match>::size_type v17 = end - begin;
  }
  if (v17)
  {
    uint64_t v18 = begin;
    do
    {
      *v18++ = *__u;
      --v17;
    }
    while (v17);
  }
  if (__n <= v16)
  {
    uint64_t v14 = &begin[__n];
LABEL_25:
    this->__end_ = v14;
    return;
  }
  uint64_t v19 = &end[__n - v16];
  std::vector<std::csub_match>::size_type v20 = 24 * __n - 24 * v16;
  do
  {
    std::pair<const char *, const char *> v21 = __u->std::pair<const char *, const char *>;
    *(void *)&end->matched = *(void *)&__u->matched;
    end->std::pair<const char *, const char *> = v21;
    ++end;
    v20 -= 24;
  }
  while (v20);
  this->__end_ = v19;
}

void std::__alternate<char>::__exec(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

uint64_t std::__repeat_one_loop<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void std::vector<std::pair<unsigned long,char const*>>::__append(std::vector<std::pair<unsigned long, const char *>> *this, std::vector<std::pair<unsigned long, const char *>>::size_type __n)
{
  std::vector<std::csub_match>::pointer end = this->__end_;
  value = this->__end_cap_.__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      std::vector<std::pair<unsigned long, const char *>>::size_type v12 = 16 * __n;
      bzero(this->__end_, 16 * __n);
      std::vector<std::csub_match>::pointer end = (std::pair<unsigned long, const char *> *)((char *)end + v12);
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<std::pair<unsigned long, const char *>>::pointer begin = this->__begin_;
    uint64_t v7 = end - this->__begin_;
    unint64_t v8 = v7 + __n;
    if ((v7 + __n) >> 60) {
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = (char *)value - (char *)begin;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v11 = (char *)operator new(16 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    std::vector<std::csub_match>::size_type v13 = (std::pair<unsigned long, const char *> *)&v11[16 * v7];
    size_t v14 = __n;
    uint64_t v15 = (std::pair<unsigned long, const char *> *)&v11[16 * v10];
    bzero(v13, v14 * 16);
    unint64_t v16 = &v13[v14];
    if (end != begin)
    {
      do
      {
        v13[-1] = end[-1];
        --v13;
        --end;
      }
      while (end != begin);
      std::vector<std::csub_match>::pointer end = this->__begin_;
    }
    this->__begin_ = v13;
    this->__end_ = v16;
    this->__end_cap_.__value_ = v15;
    if (end)
    {
      operator delete(end);
    }
  }
}

void std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(std::locale *a1)
{
  uint64_t v1 = std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(a1);

  operator delete(v1);
}

uint64_t DEREncodeSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6, unint64_t a7, unint64_t *a8)
{
  v45[1] = *MEMORY[0x263EF8340];
  unint64_t v8 = ~a6;
  if (~a6 < a7) {
    goto LABEL_73;
  }
  unint64_t v11 = *a8;
  unint64_t v44 = a7;
  v45[0] = 0;
  if (v11 < a7) {
    goto LABEL_74;
  }
  uint64_t result = DEREncodeTag(a1, a6, &v44);
  if (result) {
    return result;
  }
  if (v44 > v8) {
    goto LABEL_73;
  }
  unint64_t v17 = a7 - v44;
  if (a7 < v44) {
    goto LABEL_75;
  }
  unint64_t v18 = a6 + a7;
  unint64_t v19 = a6 + v44;
  if (a6 + v44 < v18)
  {
    uint64_t result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v45);
    if (result) {
      return result;
    }
    unint64_t v44 = v17;
    if (v19 > a6 + v11 || v19 < a6 || v17 > a6 + v11 - v19) {
      goto LABEL_74;
    }
    unint64_t v42 = a6 + v11;
    unint64_t v20 = v45[0];
    uint64_t result = DEREncodeLengthSized(v45[0], v19, v17, (uint64_t *)&v44);
    if (result) {
      return result;
    }
    unint64_t v21 = v42;
    if (__CFADD__(v19, v44))
    {
LABEL_73:
      __break(0x5513u);
      goto LABEL_74;
    }
    unint64_t v22 = v17 - v44;
    if (v17 >= v44)
    {
      uint64_t v23 = (unsigned char *)(v19 + v44);
      if (!__CFADD__(v19 + v44, v20))
      {
        if ((unint64_t)&v23[v20] > v18) {
          return 7;
        }
        if (a4)
        {
          unint64_t v24 = 0;
          unint64_t v25 = a2 + a3;
          uint64_t v41 = 24 * a4;
          while (1)
          {
            if (v24 > ~a5) {
              goto LABEL_73;
            }
            unint64_t v26 = *(void *)(a5 + v24);
            if (v26 > ~a2) {
              goto LABEL_73;
            }
            uint64_t v27 = (const void **)(a2 + v26);
            __int16 v28 = *(_WORD *)(a5 + v24 + 16);
            if ((v28 & 0x200) != 0) {
              break;
            }
            if ((v28 & 1) == 0) {
              goto LABEL_29;
            }
            if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25) {
              goto LABEL_74;
            }
            if (v27[1])
            {
LABEL_29:
              unint64_t v44 = v22;
              if ((unint64_t)v23 > v21 || (unint64_t)v23 < a6 || v22 > v21 - (unint64_t)v23) {
                goto LABEL_74;
              }
              uint64_t result = DEREncodeTag(*(void *)(a5 + v24 + 8), (unint64_t)v23, &v44);
              if (result) {
                return result;
              }
              if (__CFADD__(v23, v44)) {
                goto LABEL_73;
              }
              unint64_t v30 = v22 - v44;
              if (v22 < v44) {
                goto LABEL_75;
              }
              if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25) {
                goto LABEL_74;
              }
              unint64_t v31 = (unint64_t)v27[1];
              v45[0] = v31;
              char v32 = 1;
              if ((v28 & 0x100) != 0 && v31 && *(char *)*v27 < 0)
              {
                char v32 = 0;
                v45[0] = ++v31;
              }
              unint64_t v33 = (unint64_t)&v23[v44];
              unint64_t v44 = v30;
              if (v33 > v42 || v33 < a6 || v30 > v42 - v33) {
                goto LABEL_74;
              }
              uint64_t result = DEREncodeLengthSized(v31, v33, v30, (uint64_t *)&v44);
              if (result) {
                return result;
              }
              unint64_t v34 = v44;
              if (__CFADD__(v33, v44)) {
                goto LABEL_73;
              }
              unint64_t v35 = v30 - v44;
              if (v30 < v44) {
                goto LABEL_75;
              }
              uint64_t v23 = (unsigned char *)(v33 + v44);
              if ((v32 & 1) == 0)
              {
                if (v23 == (unsigned char *)-1) {
                  goto LABEL_73;
                }
                if ((unint64_t)v23 >= v42 || (unint64_t)v23 < a6) {
                  goto LABEL_74;
                }
                *uint64_t v23 = 0;
                --v35;
                if (v30 == v34) {
                  goto LABEL_75;
                }
                ++v23;
              }
              if ((unint64_t)v23 > v42) {
                goto LABEL_74;
              }
              if ((unint64_t)v23 < a6) {
                goto LABEL_74;
              }
              size_t v36 = (size_t)v27[1];
              if (v36 > v42 - (unint64_t)v23) {
                goto LABEL_74;
              }
              uint64_t result = (uint64_t)memmove(v23, *v27, v36);
              unint64_t v21 = v42;
              unint64_t v37 = (unint64_t)v27[1];
              if (__CFADD__(v23, v37)) {
                goto LABEL_73;
              }
              unint64_t v22 = v35 - v37;
              if (v35 < v37) {
                goto LABEL_75;
              }
              goto LABEL_69;
            }
LABEL_70:
            v24 += 24;
            if (v41 == v24) {
              goto LABEL_71;
            }
          }
          if ((unint64_t)v27 < a2 || (unint64_t)(v27 + 2) > v25) {
            goto LABEL_74;
          }
          if ((unint64_t)v23 > v21) {
            goto LABEL_74;
          }
          if ((unint64_t)v23 < a6) {
            goto LABEL_74;
          }
          size_t v39 = (size_t)v27[1];
          if (v39 > v21 - (unint64_t)v23) {
            goto LABEL_74;
          }
          uint64_t result = (uint64_t)memmove(v23, *v27, v39);
          unint64_t v21 = v42;
          unint64_t v37 = (unint64_t)v27[1];
          if (__CFADD__(v23, v37)) {
            goto LABEL_73;
          }
          BOOL v40 = v22 >= v37;
          v22 -= v37;
          if (!v40) {
            goto LABEL_75;
          }
LABEL_69:
          v23 += v37;
          goto LABEL_70;
        }
LABEL_71:
        if ((unint64_t)&v23[-a6] <= *a8)
        {
          uint64_t result = 0;
          *a8 = (unint64_t)&v23[-a6];
          return result;
        }
LABEL_74:
        __break(0x5519u);
      }
      goto LABEL_73;
    }
LABEL_75:
    __break(0x5515u);
    return result;
  }
  return 7;
}

uint64_t DEREncodeTag(uint64_t result, unint64_t a2, unint64_t *a3)
{
  unint64_t v3 = result & 0x1FFFFFFFFFFFFFFFLL;
  if ((result & 0x1FFFFFFFFFFFFFFFuLL) < 0x1F)
  {
    if (*a3)
    {
      *(unsigned char *)a2 = HIBYTE(result) & 0xE0 | result;
      unint64_t v8 = 1;
      goto LABEL_17;
    }
    return 7;
  }
  unint64_t v4 = 0;
  unint64_t v5 = result & 0x1FFFFFFFFFFFFFFFLL;
  do
  {
    ++v4;
    BOOL v6 = v5 > 0x7F;
    v5 >>= 7;
  }
  while (v6);
  unint64_t v7 = *a3;
  if (v4 >= *a3) {
    return 7;
  }
  if (v4 >= ~a2 || (*(unsigned char *)a2 = HIBYTE(result) | 0x1F, a2 + v4 == -2))
  {
LABEL_20:
    __break(0x5513u);
    goto LABEL_21;
  }
  if (a2 + v4 >= a2)
  {
    unint64_t v8 = v4 + 1;
    *(unsigned char *)(a2 + v4) = result & 0x7F;
    if (v3 >= 0x80)
    {
      uint64_t v9 = (unsigned char *)(a2 + v4 - 1);
      unint64_t v10 = (unsigned char *)(a2 + v7);
      while (v9 != (unsigned char *)-2)
      {
        if (v9 >= v10 || (unint64_t)v9 < a2) {
          goto LABEL_21;
        }
        unint64_t v11 = v3 >> 14;
        v3 >>= 7;
        *v9-- = v3 | 0x80;
        if (!v11) {
          goto LABEL_17;
        }
      }
      goto LABEL_20;
    }
LABEL_17:
    if (v8 <= *a3)
    {
      uint64_t result = 0;
      *a3 = v8;
      return result;
    }
  }
LABEL_21:
  __break(0x5519u);
  return result;
}

unint64_t DEREncodeLengthSized(unint64_t result, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  if (result >= 0x80)
  {
    uint64_t v5 = 0;
    unint64_t v6 = result;
    do
    {
      --v5;
      BOOL v7 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v7);
    unint64_t v8 = -v5;
    uint64_t v9 = 7;
    if (-v5 < a3 && v8 <= 0x7E)
    {
      if (*a4)
      {
        uint64_t v4 = 1 - v5;
        *(unsigned char *)a2 = -(char)v5 | 0x80;
        if (v8 < ~a2)
        {
          unint64_t v10 = (unsigned char *)(a2 - v5);
          if (a2 - v5 != -2)
          {
            unint64_t v11 = (unsigned char *)(a2 + *a4);
            while (v10 != (unsigned char *)-1)
            {
              if (v10 >= v11 || (unint64_t)v10 < a2) {
                goto LABEL_23;
              }
              *v10-- = result;
              BOOL v7 = result > 0xFF;
              result >>= 8;
              if (!v7)
              {
                if (v8 >= *a4) {
                  goto LABEL_23;
                }
                goto LABEL_19;
              }
            }
          }
        }
        __break(0x5513u);
      }
      goto LABEL_23;
    }
    return v9;
  }
  if (!a3) {
    return 7;
  }
  if (*a4)
  {
    *(unsigned char *)a2 = result;
    if (*a4)
    {
      uint64_t v4 = 1;
LABEL_19:
      uint64_t v9 = 0;
      *a4 = v4;
      return v9;
    }
  }
LABEL_23:
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeItemSized(unint64_t a1, unint64_t a2, const void *a3, unint64_t a4, unint64_t a5, unint64_t *a6)
{
  v22[1] = *MEMORY[0x263EF8340];
  unint64_t v12 = *a6;
  unint64_t v13 = DERLengthOfItem(a1, a2);
  if (v13 > a5) {
    return 7;
  }
  unint64_t v15 = v13;
  if (v13 > *a6) {
    goto LABEL_20;
  }
  *a6 = v13;
  v22[0] = v13;
  if (v13 > v12) {
    goto LABEL_20;
  }
  uint64_t result = DEREncodeTag(a1, a4, (unint64_t *)v22);
  if (result) {
    return result;
  }
  uint64_t v16 = v22[0];
  if (__CFADD__(a4, v22[0]))
  {
LABEL_21:
    __break(0x5513u);
    goto LABEL_22;
  }
  BOOL v17 = v15 >= v22[0];
  unint64_t v18 = v15 - v22[0];
  if (!v17) {
    goto LABEL_22;
  }
  unint64_t v19 = a4 + v12;
  unint64_t v20 = a4 + v22[0];
  v22[0] = v18;
  if (a4 + v16 > a4 + v12 || v20 < a4 || v18 > v19 - v20) {
LABEL_20:
  }
    __break(0x5519u);
  uint64_t result = DEREncodeLengthSized(a2, v20, v18, v22);
  if (result) {
    return result;
  }
  if (__CFADD__(v20, v22[0])) {
    goto LABEL_21;
  }
  if (v18 < v22[0])
  {
LABEL_22:
    __break(0x5515u);
    return result;
  }
  unint64_t v21 = (void *)(v20 + v22[0]);
  if (v19 < v20 + v22[0] || (unint64_t)v21 < a4 || v19 - (v20 + v22[0]) < a2) {
    goto LABEL_20;
  }
  memmove(v21, a3, a2);
  return 0;
}

unint64_t DERLengthOfItem(unint64_t result, unint64_t a2)
{
  unint64_t v2 = result & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v3 = 1;
  if ((result & 0x1FFFFFFFFFFFFFFFLL) >= 0x1F)
  {
    do
    {
      ++v3;
      BOOL v4 = v2 > 0x7F;
      v2 >>= 7;
    }
    while (v4);
  }
  uint64_t v5 = 1;
  if (a2 >= 0x80)
  {
    unint64_t v6 = a2;
    do
    {
      ++v5;
      BOOL v4 = v6 > 0xFF;
      v6 >>= 8;
    }
    while (v4);
  }
  BOOL v7 = __CFADD__(v3, v5);
  uint64_t v8 = v3 + v5;
  if (v7 || (uint64_t result = v8 + a2, __CFADD__(v8, a2))) {
    __break(0x5500u);
  }
  return result;
}

void std::__empty_state<char>::~__empty_state(void (__cdecl ***__p)(std::__owns_one_state<char> *__hidden this))
{
  unint64_t v2 = __p[1];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }

  operator delete(__p);
}

void std::__alternate<char>::~__alternate(void (__cdecl ***__p)(std::__owns_one_state<char> *__hidden this))
{
  *__p = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_26CECCB68;
  unint64_t v2 = __p[2];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  uint64_t v3 = __p[1];
  if (v3) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  }

  operator delete(__p);
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, v4);
  if (!result)
  {
    if (HIDWORD(v4[0]))
    {
      return 7;
    }
    else
    {
      uint64_t result = 0;
      *a2 = v4[0];
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3;
  }
  uint64_t v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7;
    }
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0) {
      return 3;
    }
    if (v2 > 9) {
      return 7;
    }
  }
LABEL_10:
  unint64_t v5 = 0;
  do
  {
    unsigned int v6 = *v3++;
    unint64_t v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERLengthOfEncodedSequence(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  v5[1] = *MEMORY[0x263EF8340];
  v5[0] = 0;
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) < a2) {
    __break(0x5519u);
  }
  if (DERLengthOfEncodedSequenceFromObject(a1, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, v5)) {
    return 0;
  }
  else {
    return v5[0];
  }
}

unint64_t DERLengthOfEncodedSequenceFromObject(uint64_t a1, unint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t *a6)
{
  v17[1] = *MEMORY[0x263EF8340];
  v17[0] = 0;
  unint64_t result = DERContentLengthOfEncodedSequence(a2, a3, a4, a5, v17);
  if (!result)
  {
    unint64_t v9 = a1 & 0x1FFFFFFFFFFFFFFFLL;
    uint64_t v10 = 1;
    if ((a1 & 0x1FFFFFFFFFFFFFFFuLL) >= 0x1F)
    {
      do
      {
        ++v10;
        BOOL v11 = v9 > 0x7F;
        v9 >>= 7;
      }
      while (v11);
    }
    uint64_t v12 = 1;
    if (v17[0] >= 0x80uLL)
    {
      unint64_t v13 = v17[0];
      do
      {
        ++v12;
        BOOL v11 = v13 > 0xFF;
        v13 >>= 8;
      }
      while (v11);
    }
    BOOL v14 = __CFADD__(v10, v12);
    uint64_t v15 = v10 + v12;
    if (v14 || (BOOL v14 = __CFADD__(v15, v17[0]), v16 = v15 + v17[0], v14))
    {
      __break(0x5500u);
    }
    else
    {
      unint64_t result = 0;
      *a6 = v16;
    }
  }
  return result;
}

unint64_t DERContentLengthOfEncodedSequence(unint64_t result, unint64_t a2, int a3, uint64_t a4, void *a5)
{
  uint64_t v5 = 0;
  if (!a3)
  {
LABEL_38:
    unint64_t result = 0;
LABEL_40:
    *a5 = v5;
    return result;
  }
  unsigned int v6 = 0;
  unint64_t v7 = result + a2;
  while (24 * (unint64_t)v6 <= ~a4)
  {
    unint64_t v8 = *(void *)(a4 + 24 * v6);
    BOOL v9 = v8 > 0xFFFFFFFFFFFFFFEFLL || v8 + 16 > a2;
    if (v9)
    {
      uint64_t v5 = 0;
      unint64_t result = 7;
      goto LABEL_40;
    }
    if (v8 > ~result) {
      break;
    }
    uint64_t v10 = (unsigned __int8 **)(result + v8);
    __int16 v11 = *(_WORD *)(a4 + 24 * v6 + 16);
    if ((v11 & 0x200) == 0)
    {
      if (v11)
      {
        if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7) {
          goto LABEL_43;
        }
        if (!v10[1]) {
          goto LABEL_37;
        }
      }
      unint64_t v13 = *(void *)(a4 + 24 * v6 + 8) & 0x1FFFFFFFFFFFFFFFLL;
      uint64_t v14 = 1;
      if (v13 >= 0x1F)
      {
        do
        {
          ++v14;
          BOOL v9 = v13 > 0x7F;
          v13 >>= 7;
        }
        while (v9);
      }
      BOOL v15 = __CFADD__(v5, v14);
      uint64_t v16 = v5 + v14;
      if (v15) {
        goto LABEL_42;
      }
      if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7) {
        goto LABEL_43;
      }
      unint64_t v17 = (unint64_t)v10[1];
      if ((*(_WORD *)(a4 + 24 * v6 + 16) & 0x100) != 0)
      {
        if (v17)
        {
          v17 += (unint64_t)**v10 >> 7;
          goto LABEL_24;
        }
LABEL_25:
        uint64_t v18 = 1;
      }
      else
      {
LABEL_24:
        if (v17 < 0x80) {
          goto LABEL_25;
        }
        uint64_t v18 = 1;
        unint64_t v21 = v17;
        do
        {
          ++v18;
          BOOL v9 = v21 > 0xFF;
          v21 >>= 8;
        }
        while (v9);
      }
      BOOL v15 = __CFADD__(v16, v18);
      uint64_t v22 = v16 + v18;
      if (v15) {
        goto LABEL_42;
      }
      BOOL v15 = __CFADD__(v22, v17);
      uint64_t v5 = v22 + v17;
      if (v15) {
        goto LABEL_42;
      }
      goto LABEL_37;
    }
    if ((unint64_t)v10 < result || (unint64_t)(v10 + 2) > v7) {
      goto LABEL_43;
    }
    unint64_t v20 = v10[1];
    BOOL v15 = __CFADD__(v5, v20);
    v5 += (uint64_t)v20;
    if (v15) {
      goto LABEL_42;
    }
LABEL_37:
    if (++v6 == a3) {
      goto LABEL_38;
    }
  }
  __break(0x5513u);
LABEL_42:
  __break(0x5500u);
LABEL_43:
  __break(0x5519u);
  return result;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(std::basic_regex<char> *a1, char *a2, char *a3)
{
  std::vector<std::csub_match>::pointer end = a1->__end_;
  unint64_t v7 = a2;
  do
  {
    unint64_t v8 = (std::basic_regex<char> *)v7;
    unint64_t v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>((uint64_t)a1, v7, a3);
    if (v7 != (char *)v8) {
      continue;
    }
    BOOL v9 = a1->__end_;
    unsigned int marked_count = a1->__marked_count_;
    __int16 v11 = (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(a1, v8);
    if (v11 == v8) {
      break;
    }
    unint64_t v7 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>((uint64_t)a1, v11, (std::basic_regex<char> *)a3, v9, marked_count + 1, a1->__marked_count_ + 1);
  }
  while (v7 != (char *)v8);
  if (v8 == (std::basic_regex<char> *)a2)
  {
    uint64_t v12 = (std::__node<char> *)operator new(0x10uLL);
    unint64_t v13 = a1->__end_;
    first = v13->__first_;
    v12[1].__vftable = (std::__node<char>_vtbl *)first;
    v13->__first_ = v12;
    BOOL v15 = (std::__owns_one_state<char> *)a1->__end_->__first_;
    goto LABEL_8;
  }
LABEL_9:
  if (v8 != (std::basic_regex<char> *)a3)
  {
    if (LOBYTE(v8->__traits_.__loc_.__locale_) == 124)
    {
      uint64_t v16 = a1->__end_;
      unint64_t v17 = (std::basic_regex<char> *)((char *)&v8->__traits_.__loc_.__locale_ + 1);
      uint64_t v18 = (char *)&v8->__traits_.__loc_.__locale_ + 1;
      while (1)
      {
        unint64_t v8 = (std::basic_regex<char> *)v18;
        uint64_t v18 = std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>((uint64_t)a1, v18, a3);
        if (v18 == (char *)v8)
        {
          unint64_t v19 = a1->__end_;
          unsigned int v20 = a1->__marked_count_;
          unint64_t v21 = (std::basic_regex<char> *)std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(a1, v8);
          if (v21 == v8)
          {
LABEL_16:
            if (v8 == v17)
            {
              uint64_t v22 = (std::__node<char> *)operator new(0x10uLL);
              uint64_t v23 = a1->__end_;
              unint64_t v24 = v23->__first_;
              v22[1].__vftable = (std::__node<char>_vtbl *)v24;
              v23->__first_ = v22;
              a1->__end_ = (std::__owns_one_state<char> *)a1->__end_->__first_;
            }
            unint64_t v25 = (std::__node<char> *)operator new(0x18uLL);
            unint64_t v26 = v16->__first_;
            v25[1].__vftable = (std::__node<char>_vtbl *)end->__first_;
            v25[2].__vftable = (std::__node<char>_vtbl *)v26;
            v25->__vftable = (std::__node<char>_vtbl *)&unk_26CECCBE0;
            end->__first_ = v25;
            v16->__first_ = 0;
            uint64_t v27 = (std::__node<char> *)operator new(0x10uLL);
            __int16 v28 = a1->__end_->__first_;
            v27[1].__vftable = (std::__node<char>_vtbl *)v28;
            v16->__first_ = v27;
            a1->__end_->__first_ = 0;
            unint64_t v29 = (std::__node<char> *)operator new(0x10uLL);
            unint64_t v30 = v16->__first_;
            v29->__vftable = (std::__node<char>_vtbl *)&unk_26CECCC28;
            v29[1].__vftable = (std::__node<char>_vtbl *)v30;
            a1->__end_->__first_ = v29;
            BOOL v15 = (std::__owns_one_state<char> *)v16->__first_;
LABEL_8:
            a1->__end_ = v15;
            goto LABEL_9;
          }
          uint64_t v18 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>((uint64_t)a1, v21, (std::basic_regex<char> *)a3, v19, v20 + 1, a1->__marked_count_ + 1);
        }
        if (v18 == (char *)v8) {
          goto LABEL_16;
        }
      }
    }
    return (char *)v8;
  }
  return a3;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 == a3) {
      goto LABEL_20;
    }
    int v5 = a2[1];
    char v6 = v5 == 94;
    unint64_t v7 = v5 == 94 ? a2 + 2 : a2 + 1;
    unint64_t v8 = operator new(0xB0uLL);
    std::__bracket_expression<char,std::regex_traits<char>>::__bracket_expression[abi:ne180100]((uint64_t)v8, a1, *(void *)(*(void *)(a1 + 56) + 8), v6, *(_DWORD *)(a1 + 24) & 1, (*(_DWORD *)(a1 + 24) & 8) != 0);
    *(void *)(*(void *)(a1 + 56) + 8) = v8;
    *(void *)(a1 + 56) = v8;
    if (v7 == a3) {
      goto LABEL_20;
    }
    if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0 && *v7 == 93)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v8, 93);
      ++v7;
    }
    if (v7 == a3) {
      goto LABEL_20;
    }
    do
    {
      BOOL v9 = v7;
      unint64_t v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<char const*>(a1, v7, a3, (uint64_t)v8);
    }
    while (v7 != v9);
    if (v9 == a3) {
      goto LABEL_20;
    }
    if (*v9 == 45)
    {
      std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v8, 45);
      ++v9;
    }
    if (v9 == a3 || *v9 != 93) {
LABEL_20:
    }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
    return v9 + 1;
  }
  return a2;
}

void sub_21DE8F244(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_expression_term<char const*>(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  BOOL v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  int v5 = *a2;
  if (v5 == 93) {
    return v4;
  }
  char v6 = (char *)a4;
  int v9 = 0;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v40 = 0;
  if (a2 + 1 == a3 || v5 != 91)
  {
LABEL_38:
    int v24 = *(_DWORD *)(a1 + 24) & 0x1F0;
    goto LABEL_33;
  }
  int v10 = a2[1];
  if (v10 != 46)
  {
    if (v10 != 58)
    {
      if (v10 == 61)
      {
        char v6 = std::basic_regex<char,std::regex_traits<char>>::__parse_equivalence_class<char const*>(a1, a2 + 2, a3, a4);
        char v11 = 0;
        if ((SHIBYTE(v40) & 0x80000000) == 0) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }
      int v9 = 0;
      goto LABEL_38;
    }
    uint64_t v12 = a2 + 2;
    if (a3 - (v4 + 2) >= 2)
    {
      uint64_t v13 = 0;
      uint64_t v14 = (unsigned __int8 *)v4;
      if (v4[2] == 58) {
        goto LABEL_14;
      }
      do
      {
        do
        {
          if (a3 - v4 - 4 == v13) {
            goto LABEL_89;
          }
          uint64_t v14 = (unsigned __int8 *)&v4[++v13];
        }
        while (v4[v13 + 2] != 58);
LABEL_14:
        ;
      }
      while (v14[3] != 93);
      BOOL v15 = &v4[v13 + 2];
      if (v15 != a3)
      {
        int v16 = std::regex_traits<char>::__lookup_classname<char const*>(a1, v12, v15, *(_DWORD *)(a1 + 24) & 1);
        if (!v16) {
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)2>();
        }
        char v11 = 0;
        *((_DWORD *)v6 + 40) |= v16;
        char v6 = &v4[v13 + 4];
        if (SHIBYTE(v40) < 0) {
          goto LABEL_63;
        }
        goto LABEL_64;
      }
    }
LABEL_89:
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)5>();
  }
  unint64_t v17 = a2 + 2;
  if (a3 - (v4 + 2) < 2) {
    goto LABEL_89;
  }
  uint64_t v18 = a3 - v4 - 4;
  unint64_t v19 = v4 + 2;
  unsigned int v20 = v17 + 1;
  if (*v17 == 46) {
    goto LABEL_23;
  }
  do
  {
    do
    {
      if (!v18) {
        goto LABEL_89;
      }
      --v18;
      unint64_t v19 = v20;
      int v21 = *v20++;
    }
    while (v21 != 46);
LABEL_23:
    ;
  }
  while (*v20 != 93);
  if (v19 == a3) {
    goto LABEL_89;
  }
  std::regex_traits<char>::__lookup_collatename<char *>(v17, a1, v19, (uint64_t)&v41);
  if (SHIBYTE(v40) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v40 = v42;
  *(_OWORD *)__p = v41;
  uint64_t v22 = (char *)HIBYTE(v42);
  int v9 = SHIBYTE(v42);
  uint64_t v23 = *((void *)&v41 + 1);
  if (v42 < 0) {
    uint64_t v22 = (char *)__p[1];
  }
  if ((unint64_t)(v22 - 1) >= 2) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)1>();
  }
  BOOL v4 = v19 + 2;
  int v24 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if (v42 >= 0) {
    uint64_t v23 = HIBYTE(v42);
  }
  if (v23)
  {
    __int16 v28 = v4;
    if (v4 == a3) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
LABEL_33:
  if ((v24 | 0x40) != 0x40)
  {
    LOBYTE(v25) = *v4;
LABEL_57:
    if (v9 < 0)
    {
      unint64_t v34 = __p[0];
      __p[1] = (void *)1;
      *(unsigned char *)__p[0] = v25;
      v34[1] = 0;
      __int16 v28 = v4 + 1;
      if (v4 + 1 == a3) {
        goto LABEL_41;
      }
    }
    else
    {
      HIBYTE(v40) = 1;
      LOWORD(__p[0]) = v25;
      __int16 v28 = v4 + 1;
      if (v4 + 1 == a3) {
        goto LABEL_41;
      }
    }
    goto LABEL_40;
  }
  int v25 = *v4;
  if (v25 != 92) {
    goto LABEL_57;
  }
  unint64_t v26 = v4 + 1;
  if (v24) {
    uint64_t v27 = std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v26, a3, (uint64_t *)__p);
  }
  else {
    uint64_t v27 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>((std::basic_regex<char> *)a1, (unsigned __int8 *)v26, (unsigned __int8 *)a3, (uint64_t)__p, (uint64_t)v6);
  }
  __int16 v28 = v27;
  if (v27 == a3)
  {
LABEL_41:
    if (SHIBYTE(v40) < 0)
    {
      if (!__p[1]) {
        goto LABEL_62;
      }
      if (__p[1] != (void *)1)
      {
        unint64_t v30 = (void **)__p[0];
LABEL_61:
        std::__bracket_expression<char,std::regex_traits<char>>::__add_digraph[abi:ne180100]((uint64_t)v6, *(char *)v30, *((char *)v30 + 1));
LABEL_62:
        char v11 = 1;
        BOOL v4 = v28;
        if ((SHIBYTE(v40) & 0x80000000) == 0) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }
      unint64_t v30 = (void **)__p[0];
    }
    else
    {
      if (!HIBYTE(v40)) {
        goto LABEL_62;
      }
      unint64_t v30 = __p;
      if (HIBYTE(v40) != 1) {
        goto LABEL_61;
      }
    }
    std::__bracket_expression<char,std::regex_traits<char>>::__add_char[abi:ne180100]((uint64_t)v6, *(char *)v30);
    goto LABEL_62;
  }
LABEL_40:
  int v29 = *v28;
  if (v29 == 93) {
    goto LABEL_41;
  }
  unint64_t v31 = v28 + 1;
  if (v28 + 1 == a3 || v29 != 45 || *v31 == 93) {
    goto LABEL_41;
  }
  long long v41 = 0uLL;
  int64_t v42 = 0;
  BOOL v4 = v28 + 2;
  if (v28 + 2 == a3 || *v31 != 91 || *v4 != 46)
  {
    if ((v24 | 0x40) == 0x40)
    {
      LODWORD(v31) = *v31;
      if (v31 == 92)
      {
        if (v24) {
          char v32 = std::basic_regex<char,std::regex_traits<char>>::__parse_awk_escape<char const*>((std::basic_regex<char> *)a1, v28 + 2, a3, (uint64_t *)&v41);
        }
        else {
          char v32 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_class_escape<char const*>((std::basic_regex<char> *)a1, (unsigned __int8 *)v28 + 2, (unsigned __int8 *)a3, (uint64_t)&v41, (uint64_t)v6);
        }
        goto LABEL_79;
      }
    }
    else
    {
      LOBYTE(v31) = *v31;
    }
    HIBYTE(v42) = 1;
    LOWORD(v41) = v31;
    goto LABEL_80;
  }
  char v32 = std::basic_regex<char,std::regex_traits<char>>::__parse_collating_symbol<char const*>(a1, v28 + 3, a3, (uint64_t)&v41);
LABEL_79:
  BOOL v4 = v32;
LABEL_80:
  *(_OWORD *)unint64_t v37 = *(_OWORD *)__p;
  uint64_t v38 = v40;
  __p[1] = 0;
  uint64_t v40 = 0;
  __p[0] = 0;
  *(_OWORD *)unint64_t v35 = v41;
  uint64_t v36 = v42;
  long long v41 = 0uLL;
  int64_t v42 = 0;
  std::__bracket_expression<char,std::regex_traits<char>>::__add_range[abi:ne180100]((uint64_t)v6, (char *)v37, (uint64_t)v35);
  if (SHIBYTE(v36) < 0)
  {
    operator delete(v35[0]);
    if ((SHIBYTE(v38) & 0x80000000) == 0)
    {
LABEL_82:
      if ((SHIBYTE(v42) & 0x80000000) == 0) {
        goto LABEL_83;
      }
LABEL_87:
      operator delete((void *)v41);
      char v11 = 1;
      if (SHIBYTE(v40) < 0) {
        goto LABEL_63;
      }
      goto LABEL_64;
    }
  }
  else if ((SHIBYTE(v38) & 0x80000000) == 0)
  {
    goto LABEL_82;
  }
  operator delete(v37[0]);
  if (SHIBYTE(v42) < 0) {
    goto LABEL_87;
  }
LABEL_83:
  char v11 = 1;
  if (SHIBYTE(v40) < 0) {
LABEL_63:
  }
    operator delete(__p[0]);
LABEL_64:
  if (v11) {
    return v4;
  }
  return v6;
}

void sub_21DE8F760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (*(char *)(v28 - 49) < 0)
  {
    operator delete(*(void **)(v28 - 72));
    if (a28 < 0)
    {
LABEL_5:
      operator delete(__p);
      _Unwind_Resume(a1);
    }
  }
  else if (a28 < 0)
  {
    goto LABEL_5;
  }
  _Unwind_Resume(a1);
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>(uint64_t a1, std::basic_regex<char> *this, std::basic_regex<char> *a3, std::__owns_one_state<char> *a4, size_t __mexp_begin, size_t __mexp_end)
{
  if (this == a3) {
    return this;
  }
  int v6 = *(_DWORD *)(a1 + 24) & 0x1F0;
  int locale_low = SLOBYTE(this->__traits_.__loc_.__locale_);
  if (locale_low <= 62)
  {
    if (locale_low == 42)
    {
      unint64_t v8 = (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
      if (v6) {
        BOOL v20 = 1;
      }
      else {
        BOOL v20 = v8 == a3;
      }
      if (!v20 && LOBYTE(v8->__traits_.__loc_.__locale_) == 63)
      {
        int v9 = (char *)&this->__traits_.__loc_.__locale_ + 2;
        __mexp_std::vector<std::pair<unsigned long, const char *>>::pointer begin = __mexp_begin;
        __mexp_std::vector<std::csub_match>::pointer end = __mexp_end;
        size_t v10 = 0;
        goto LABEL_35;
      }
      __mexp_std::vector<std::pair<unsigned long, const char *>>::pointer begin = __mexp_begin;
      __mexp_std::vector<std::csub_match>::pointer end = __mexp_end;
      size_t v24 = 0;
      goto LABEL_44;
    }
    if (locale_low == 43)
    {
      unint64_t v8 = (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
      if (!v6 && v8 != a3 && LOBYTE(v8->__traits_.__loc_.__locale_) == 63)
      {
        int v9 = (char *)&this->__traits_.__loc_.__locale_ + 2;
        __mexp_std::vector<std::pair<unsigned long, const char *>>::pointer begin = __mexp_begin;
        __mexp_std::vector<std::csub_match>::pointer end = __mexp_end;
        size_t v10 = 1;
LABEL_35:
        std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v10, 0xFFFFFFFFFFFFFFFFLL, a4, __mexp_begin, __mexp_end, 0);
        return (std::basic_regex<char> *)v9;
      }
      __mexp_std::vector<std::pair<unsigned long, const char *>>::pointer begin = __mexp_begin;
      __mexp_std::vector<std::csub_match>::pointer end = __mexp_end;
      size_t v24 = 1;
      goto LABEL_44;
    }
    return this;
  }
  if (locale_low == 63)
  {
    int v21 = (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
    if (v6) {
      BOOL v22 = 1;
    }
    else {
      BOOL v22 = v21 == a3;
    }
    if (v22 || LOBYTE(v21->__traits_.__loc_.__locale_) != 63)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, 0, 1uLL, a4, __mexp_begin, __mexp_end, 1);
      return v21;
    }
    else
    {
      uint64_t v23 = (char *)&this->__traits_.__loc_.__locale_ + 2;
      std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, 0, 1uLL, a4, __mexp_begin, __mexp_end, 0);
      return (std::basic_regex<char> *)v23;
    }
  }
  else
  {
    if (locale_low != 123) {
      return this;
    }
    char v11 = (char *)&this->__traits_.__loc_.__locale_ + 1;
    if ((std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1) == a3) {
      goto LABEL_71;
    }
    int v12 = *v11;
    if ((v12 & 0xF8) != 0x30 && (v12 & 0xFE) != 0x38) {
      goto LABEL_71;
    }
    int v13 = v12 - 48;
    uint64_t v14 = (char *)&this->__traits_.__loc_.__locale_ + 2;
    if ((std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 2) == a3)
    {
LABEL_19:
      uint64_t v14 = (char *)a3;
    }
    else
    {
      while (1)
      {
        int v15 = *v14;
        if ((v15 & 0xF8) != 0x30 && (v15 & 0xFE) != 0x38) {
          break;
        }
        if (v13 >= 214748364) {
          goto LABEL_71;
        }
        int v13 = v15 + 10 * v13 - 48;
        if (++v14 == (char *)a3) {
          goto LABEL_19;
        }
      }
    }
    if (v14 == v11) {
      goto LABEL_71;
    }
    if (v14 == (char *)a3) {
      goto LABEL_72;
    }
    int v16 = *v14;
    if (v16 != 44)
    {
      if (v16 == 125)
      {
        unint64_t v17 = (std::basic_regex<char> *)(v14 + 1);
        if (v6 || v17 == a3 || LOBYTE(v17->__traits_.__loc_.__locale_) != 63)
        {
          std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v13, v13, a4, __mexp_begin, __mexp_end, 1);
          return v17;
        }
        else
        {
          uint64_t v18 = (unsigned __int8 *)(v14 + 2);
          std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v13, v13, a4, __mexp_begin, __mexp_end, 0);
          return (std::basic_regex<char> *)v18;
        }
      }
LABEL_71:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)8>();
    }
    int v25 = (std::basic_regex<char> *)(v14 + 1);
    if (v14 + 1 == (char *)a3) {
      goto LABEL_71;
    }
    int v26 = LOBYTE(v25->__traits_.__loc_.__locale_);
    if (v26 == 125)
    {
      unint64_t v8 = (std::basic_regex<char> *)(v14 + 2);
      if (!v6 && v8 != a3 && LOBYTE(v8->__traits_.__loc_.__locale_) == 63)
      {
        size_t v10 = v13;
        int v9 = v14 + 3;
        __mexp_std::vector<std::pair<unsigned long, const char *>>::pointer begin = __mexp_begin;
        __mexp_std::vector<std::csub_match>::pointer end = __mexp_end;
        goto LABEL_35;
      }
      size_t v24 = v13;
      __mexp_std::vector<std::pair<unsigned long, const char *>>::pointer begin = __mexp_begin;
      __mexp_std::vector<std::csub_match>::pointer end = __mexp_end;
LABEL_44:
      std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v24, 0xFFFFFFFFFFFFFFFFLL, a4, __mexp_begin, __mexp_end, 1);
      return v8;
    }
    if ((v26 & 0xF8) != 0x30 && (v26 & 0xFE) != 0x38) {
      goto LABEL_72;
    }
    int v27 = v26 - 48;
    uint64_t v28 = (std::basic_regex<char> *)(v14 + 2);
    if (v28 == a3)
    {
LABEL_60:
      uint64_t v28 = a3;
    }
    else
    {
      while (1)
      {
        int v29 = LOBYTE(v28->__traits_.__loc_.__locale_);
        if ((v29 & 0xF8) != 0x30 && (v29 & 0xFE) != 0x38) {
          break;
        }
        if (v27 >= 214748364) {
          goto LABEL_71;
        }
        int v27 = v29 + 10 * v27 - 48;
        uint64_t v28 = (std::basic_regex<char> *)((char *)v28 + 1);
        if (v28 == a3) {
          goto LABEL_60;
        }
      }
    }
    if (v28 == v25 || v28 == a3 || LOBYTE(v28->__traits_.__loc_.__locale_) != 125) {
LABEL_72:
    }
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)7>();
    if (v27 < v13) {
      goto LABEL_71;
    }
    unint64_t v30 = (std::basic_regex<char> *)((char *)&v28->__traits_.__loc_.__locale_ + 1);
    if (v6 || v30 == a3 || LOBYTE(v30->__traits_.__loc_.__locale_) != 63)
    {
      std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v13, v27, a4, __mexp_begin, __mexp_end, 1);
      return v30;
    }
    else
    {
      unint64_t v31 = (char *)&v28->__traits_.__loc_.__locale_ + 2;
      std::basic_regex<char,std::regex_traits<char>>::__push_loop((std::basic_regex<char> *)a1, v13, v27, a4, __mexp_begin, __mexp_end, 0);
      return (std::basic_regex<char> *)v31;
    }
  }
}

void std::basic_regex<char,std::regex_traits<char>>::__push_loop(std::basic_regex<char> *this, size_t __min, size_t __max, std::__owns_one_state<char> *__s, size_t __mexp_begin, size_t __mexp_end, BOOL __greedy)
{
  int v8 = __mexp_end;
  int v9 = __mexp_begin;
  uint64_t v14 = operator new(0x10uLL);
  std::vector<std::csub_match>::pointer end = this->__end_;
  first = end->__first_;
  v14[1] = first;
  end->__first_ = 0;
  unint64_t v17 = operator new(0x38uLL);
  unsigned int loop_count = this->__loop_count_;
  *((void *)v17 + 1) = __s->__first_;
  *((void *)v17 + 2) = v14;
  *(void *)unint64_t v17 = &unk_26CECCB08;
  *((void *)v17 + 3) = __min;
  *((void *)v17 + 4) = __max;
  *((_DWORD *)v17 + 10) = loop_count;
  *((_DWORD *)v17 + 11) = v9;
  *((_DWORD *)v17 + 12) = v8;
  *((unsigned char *)v17 + 52) = __greedy;
  __s->__first_ = 0;
  unint64_t v19 = (std::__node<char> *)operator new(0x10uLL);
  v19->__vftable = (std::__node<char>_vtbl *)&unk_26CECCB98;
  v19[1].__vftable = (std::__node<char>_vtbl *)v17;
  this->__end_->__first_ = v19;
  this->__end_ = (std::__owns_one_state<char> *)*((void *)v17 + 2);
  __s->__first_ = (std::__node<char> *)v17;
  this->__loop_count_ = loop_count + 1;
}

void sub_21DE8FCFC(_Unwind_Exception *a1)
{
  std::__loop<char>::~__loop(v1);
  _Unwind_Resume(a1);
}

void sub_21DE8FD10(_Unwind_Exception *a1)
{
  std::__empty_state<char>::~__empty_state(v1);
  _Unwind_Resume(a1);
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(uint64_t a1, char *a2, char *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v6 = *a2;
  if (v6 > 91)
  {
    if (v6 == 92)
    {
      if (a2 + 1 != a3)
      {
        int v14 = a2[1];
        if (v14 == 66)
        {
          int v15 = (char *)operator new(0x30uLL);
          uint64_t v23 = *(void *)(*(void *)(a1 + 56) + 8);
          *(void *)int v15 = &unk_26CECC7A8;
          *((void *)v15 + 1) = v23;
          std::locale::locale((std::locale *)v15 + 2, (const std::locale *)a1);
          *(_OWORD *)(v15 + 24) = *(_OWORD *)(a1 + 8);
          v15[40] = 1;
        }
        else
        {
          if (v14 != 98) {
            return a2;
          }
          int v15 = (char *)operator new(0x30uLL);
          uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8);
          *(void *)int v15 = &unk_26CECC7A8;
          *((void *)v15 + 1) = v16;
          std::locale::locale((std::locale *)v15 + 2, (const std::locale *)a1);
          *(_OWORD *)(v15 + 24) = *(_OWORD *)(a1 + 8);
          v15[40] = 0;
        }
        *(void *)(*(void *)(a1 + 56) + 8) = v15;
        *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8);
        return a2 + 2;
      }
      return a2;
    }
    if (v6 != 94) {
      return a2;
    }
    size_t v10 = operator new(0x18uLL);
    BOOL v11 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    uint64_t v12 = *(void *)(a1 + 56);
    v10[1] = *(void *)(v12 + 8);
    int v13 = &unk_26CECC718;
LABEL_14:
    *size_t v10 = v13;
    *((unsigned char *)v10 + 16) = v11;
    *(void *)(v12 + 8) = v10;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8);
    return a2 + 1;
  }
  if (v6 == 36)
  {
    size_t v10 = operator new(0x18uLL);
    BOOL v11 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    uint64_t v12 = *(void *)(a1 + 56);
    v10[1] = *(void *)(v12 + 8);
    int v13 = &unk_26CECC760;
    goto LABEL_14;
  }
  BOOL v8 = v6 == 40;
  unint64_t v7 = a2 + 1;
  BOOL v8 = !v8 || v7 == a3;
  if (v8) {
    return a2;
  }
  BOOL v8 = *v7 == 63;
  unint64_t v17 = a2 + 2;
  if (!v8 || v17 == a3) {
    return a2;
  }
  int v19 = *v17;
  if (v19 == 33)
  {
    *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v26.__loop_count_ = v24;
    *(_OWORD *)&v26.__start_.__cntrl_ = v24;
    *(_OWORD *)&v26.__traits_.__loc_.__locale_ = v24;
    *(_OWORD *)&v26.__traits_.__col_ = v24;
    std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v26);
    v26.__flags_ = *(_DWORD *)(a1 + 24);
    int v21 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(&v26, a2 + 3, a3);
    unsigned int marked_count = v26.__marked_count_;
    std::basic_regex<char,std::regex_traits<char>>::__push_lookahead((std::basic_regex<char> *)a1, &v26, 1, *(_DWORD *)(a1 + 28));
    *(_DWORD *)(a1 + 28) += marked_count;
    if (v21 == a3 || *v21 != 41) {
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
    }
    goto LABEL_32;
  }
  if (v19 != 61) {
    return a2;
  }
  *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v26.__loop_count_ = v20;
  *(_OWORD *)&v26.__start_.__cntrl_ = v20;
  *(_OWORD *)&v26.__traits_.__loc_.__locale_ = v20;
  *(_OWORD *)&v26.__traits_.__col_ = v20;
  std::basic_regex<char,std::regex_traits<char>>::basic_regex[abi:ne180100]((uint64_t)&v26);
  v26.__flags_ = *(_DWORD *)(a1 + 24);
  int v21 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(&v26, a2 + 3, a3);
  unsigned int v22 = v26.__marked_count_;
  std::basic_regex<char,std::regex_traits<char>>::__push_lookahead((std::basic_regex<char> *)a1, &v26, 0, *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 28) += v22;
  if (v21 == a3 || *v21 != 41) {
    std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
  }
LABEL_32:
  std::basic_regex<char,std::regex_traits<char>>::~basic_regex(&v26.__traits_.__loc_);
  return v21 + 1;
}

void sub_21DE90060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

void sub_21DE90074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

void sub_21DE90088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

void sub_21DE9009C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

unsigned __int8 *std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>(std::basic_regex<char> *this, std::basic_regex<char> *a2, std::basic_regex<char> *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    switch(LOBYTE(a2->__traits_.__loc_.__locale_))
    {
      case '(':
        if ((std::basic_regex<char> *)((char *)&a2->__traits_.__loc_.__locale_ + 1) == a3) {
          goto LABEL_32;
        }
        if ((std::basic_regex<char> *)((char *)&a2->__traits_.__loc_.__locale_ + 2) != a3
          && BYTE1(a2->__traits_.__loc_.__locale_) == 63
          && BYTE2(a2->__traits_.__loc_.__locale_) == 58)
        {
          p_open_count = &this->__open_count_;
          ++this->__open_count_;
          unint64_t v7 = std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(this, (char *)&a2->__traits_.__loc_.__locale_ + 3, (char *)a3);
          if (v7 == (char *)a3) {
            goto LABEL_32;
          }
          uint64_t v3 = (std::basic_regex<char> *)v7;
          if (*v7 != 41) {
            goto LABEL_32;
          }
        }
        else
        {
          if ((this->__flags_ & 2) != 0)
          {
            unsigned int marked_count = this->__marked_count_;
          }
          else
          {
            uint64_t v12 = (std::__node<char> *)operator new(0x18uLL);
            unsigned int marked_count = this->__marked_count_ + 1;
            this->__marked_count_ = marked_count;
            std::vector<std::csub_match>::pointer end = this->__end_;
            first = end->__first_;
            v12->__vftable = (std::__node<char>_vtbl *)&unk_26CECCA78;
            v12[1].__vftable = (std::__node<char>_vtbl *)first;
            LODWORD(v12[2].__vftable) = marked_count;
            end->__first_ = v12;
            this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
          }
          p_open_count = &this->__open_count_;
          ++this->__open_count_;
          uint64_t v16 = std::basic_regex<char,std::regex_traits<char>>::__parse_ecma_exp<char const*>(this, (char *)&v3->__traits_.__loc_.__locale_ + 1, (char *)a3);
          if (v16 == (char *)a3 || (uint64_t v3 = (std::basic_regex<char> *)v16, *v16 != 41)) {
LABEL_32:
          }
            std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)6>();
          if ((this->__flags_ & 2) == 0)
          {
            unint64_t v17 = (std::__node<char> *)operator new(0x18uLL);
            uint64_t v18 = this->__end_;
            int v19 = v18->__first_;
            v17->__vftable = (std::__node<char>_vtbl *)&unk_26CECCAC0;
            v17[1].__vftable = (std::__node<char>_vtbl *)v19;
            LODWORD(v17[2].__vftable) = marked_count;
            v18->__first_ = v17;
            this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
          }
        }
        --*p_open_count;
LABEL_29:
        uint64_t v3 = (std::basic_regex<char> *)((char *)v3 + 1);
        break;
      case ')':
      case ',':
      case '-':
      case '/':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case ':':
      case ';':
      case '<':
      case '=':
      case '>':
      case '@':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
        goto LABEL_20;
      case '*':
      case '+':
      case '?':
        goto LABEL_31;
      case '.':
        BOOL v8 = (std::__node<char> *)operator new(0x10uLL);
        int v9 = this->__end_;
        size_t v10 = v9->__first_;
        v8->__vftable = (std::__node<char>_vtbl *)&unk_26CECC838;
        v8[1].__vftable = (std::__node<char>_vtbl *)v10;
        v9->__first_ = v8;
        this->__end_ = (std::__owns_one_state<char> *)this->__end_->__first_;
        goto LABEL_29;
      case '[':
        return (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_bracket_expression<char const*>((uint64_t)this, (char *)a2, (char *)a3);
      case '\\':
        return std::basic_regex<char,std::regex_traits<char>>::__parse_atom_escape<char const*>(this, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
      default:
        if (LOBYTE(a2->__traits_.__loc_.__locale_) == 123) {
LABEL_31:
        }
          std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)11>();
LABEL_20:
        return (unsigned __int8 *)std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<char const*>(this, a2, a3);
    }
  }
  return (unsigned __int8 *)v3;
}

char *std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>(uint64_t a1, char *a2, char *a3)
{
  int v6 = operator new(8uLL);
  void *v6 = &unk_26CECC5C8;
  unint64_t v7 = operator new(0x10uLL);
  v7[1] = v6;
  BOOL v8 = operator new(0x20uLL);
  *BOOL v8 = &unk_26CECC620;
  v8[1] = 0;
  v8[2] = 0;
  v8[3] = v7;
  int v9 = *(std::__shared_weak_count **)(a1 + 48);
  *(void *)(a1 + 40) = v7;
  *(void *)(a1 + 48) = v8;
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    uint64_t v10 = *(void *)(a1 + 40);
    *(void *)(a1 + 56) = v10;
    unsigned int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
    if (v11 <= 0x3F) {
      goto LABEL_4;
    }
LABEL_9:
    if (v11 != 64)
    {
      if (v11 == 128)
      {
        return std::basic_regex<char,std::regex_traits<char>>::__parse_grep<char const*>(a1, a2, a3);
      }
      if (v11 == 256)
      {
        return (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_egrep<char const*>(a1, (std::basic_regex<char> *)a2, (std::basic_regex<char> *)a3);
      }
LABEL_31:
      std::__throw_regex_error[abi:ne180100]<(std::regex_constants::error_type)14>();
    }
LABEL_15:
    return (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_extended_reg_exp<char const*>(a1, (std::basic_regex<char> *)a2, (std::basic_regex<char> *)a3);
  }
  uint64_t v10 = *(void *)(a1 + 40);
  *(void *)(a1 + 56) = v10;
  unsigned int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if (v11 > 0x3F) {
    goto LABEL_9;
  }
LABEL_4:
  if (v11)
  {
    if (v11 == 16)
    {
      return std::basic_regex<char,std::regex_traits<char>>::__parse_basic_reg_exp<char const*>(a1, a2, a3);
    }
    if (v11 != 32) {
      goto LABEL_31;
    }
    goto LABEL_15;
  }
  int v13 = a2;
  while (1)
  {
    int v14 = (std::basic_regex<char> *)v13;
    int v13 = std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(a1, v13, a3);
    if (v13 == (char *)v14) {
      break;
    }
LABEL_19:
    if (v13 == (char *)v14) {
      goto LABEL_29;
    }
  }
  int v15 = *(std::__owns_one_state<char> **)(a1 + 56);
  int v16 = *(_DWORD *)(a1 + 28);
  unint64_t v17 = std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>((std::basic_regex<char> *)a1, v14, (std::basic_regex<char> *)a3);
  if (v17 != (unsigned __int8 *)v14)
  {
    int v13 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>(a1, (std::basic_regex<char> *)v17, (std::basic_regex<char> *)a3, v15, (v16 + 1), (*(_DWORD *)(a1 + 28) + 1));
    goto LABEL_19;
  }
LABEL_29:
  if (v14 == (std::basic_regex<char> *)a2)
  {
    uint64_t v18 = operator new(0x10uLL);
    uint64_t v19 = *(void *)(a1 + 56);
    uint64_t v20 = *(void *)(v19 + 8);
    v18[1] = v20;
    *(void *)(v19 + 8) = v18;
    uint64_t v21 = *(void *)(*(void *)(a1 + 56) + 8);
    goto LABEL_32;
  }
LABEL_33:
  if (v14 != (std::basic_regex<char> *)a3)
  {
    if (LOBYTE(v14->__traits_.__loc_.__locale_) == 124)
    {
      uint64_t v22 = *(void *)(a1 + 56);
      uint64_t v23 = (std::basic_regex<char> *)((char *)&v14->__traits_.__loc_.__locale_ + 1);
      long long v24 = (char *)&v14->__traits_.__loc_.__locale_ + 1;
      while (1)
      {
        int v14 = (std::basic_regex<char> *)v24;
        long long v24 = std::basic_regex<char,std::regex_traits<char>>::__parse_assertion<char const*>(a1, v24, a3);
        if (v24 == (char *)v14)
        {
          int v25 = *(std::__owns_one_state<char> **)(a1 + 56);
          int v26 = *(_DWORD *)(a1 + 28);
          int v27 = std::basic_regex<char,std::regex_traits<char>>::__parse_atom<char const*>((std::basic_regex<char> *)a1, v14, (std::basic_regex<char> *)a3);
          if (v27 == (unsigned __int8 *)v14)
          {
LABEL_40:
            if (v14 == v23)
            {
              uint64_t v28 = operator new(0x10uLL);
              uint64_t v29 = *(void *)(a1 + 56);
              uint64_t v30 = *(void *)(v29 + 8);
              v28[1] = v30;
              *(void *)(v29 + 8) = v28;
              *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8);
            }
            unint64_t v31 = operator new(0x18uLL);
            uint64_t v32 = *(void *)(v22 + 8);
            v31[1] = *(void *)(v10 + 8);
            v31[2] = v32;
            *unint64_t v31 = &unk_26CECCBE0;
            *(void *)(v10 + 8) = v31;
            *(void *)(v22 + 8) = 0;
            unint64_t v33 = operator new(0x10uLL);
            uint64_t v34 = *(void *)(*(void *)(a1 + 56) + 8);
            v33[1] = v34;
            *(void *)(v22 + 8) = v33;
            *(void *)(*(void *)(a1 + 56) + 8) = 0;
            unint64_t v35 = operator new(0x10uLL);
            uint64_t v36 = *(void *)(v22 + 8);
            void *v35 = &unk_26CECCC28;
            v35[1] = v36;
            *(void *)(*(void *)(a1 + 56) + 8) = v35;
            uint64_t v21 = *(void *)(v22 + 8);
LABEL_32:
            *(void *)(a1 + 56) = v21;
            goto LABEL_33;
          }
          long long v24 = (char *)std::basic_regex<char,std::regex_traits<char>>::__parse_ERE_dupl_symbol<char const*>(a1, (std::basic_regex<char> *)v27, (std::basic_regex<char> *)a3, v25, (v26 + 1), (*(_DWORD *)(a1 + 28) + 1));
        }
        if (v24 == (char *)v14) {
          goto LABEL_40;
        }
      }
    }
    return (char *)v14;
  }
  return a3;
}

std::basic_regex<char> *std::basic_regex<char,std::regex_traits<char>>::__parse_pattern_character<char const*>(std::basic_regex<char> *a1, std::basic_regex<char> *this, std::basic_regex<char> *a3)
{
  if (this == a3) {
    return this;
  }
  switch(LOBYTE(this->__traits_.__loc_.__locale_))
  {
    case '$':
    case '(':
    case ')':
    case '*':
    case '+':
    case '.':
    case '?':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '{':
    case '|':
    case '}':
      return this;
    default:
      std::basic_regex<char,std::regex_traits<char>>::__push_char(a1, (std::basic_regex<char>::value_type)this->__traits_.__loc_.__locale_);
      unint64_t result = (std::basic_regex<char> *)((char *)&this->__traits_.__loc_.__locale_ + 1);
      break;
  }
  return result;
}

void std::vector<BOOL>::reserve(uint64_t a1, unint64_t a2)
{
  if (a2 > *(void *)(a1 + 16) << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v3 = ((a2 - 1) >> 6) + 1;
    BOOL v4 = (uint64_t *)operator new(8 * v3);
    int v5 = *(void **)a1;
    unint64_t v6 = *(void *)(a1 + 8);
    int v7 = v6 & 0x3F;
    unint64_t v8 = (v6 - 1) >> 6;
    if (v6 < 0x41) {
      unint64_t v8 = 0;
    }
    v4[v8] = 0;
    if (v6 > 0x3F || (v6 & 0x3F) != 0)
    {
      int v9 = 0;
      int v10 = 0;
      unsigned int v11 = &v5[v6 >> 6];
      uint64_t v12 = v4;
      int v13 = v5;
      do
      {
        uint64_t v14 = 1 << v9;
        if ((*v13 >> v10)) {
          uint64_t v15 = *v12 | v14;
        }
        else {
          uint64_t v15 = *v12 & ~v14;
        }
        *uint64_t v12 = v15;
        v13 += v10 == 63;
        if (v10 == 63) {
          int v10 = 0;
        }
        else {
          ++v10;
        }
        v12 += v9 == 63;
        if (v9 == 63) {
          int v9 = 0;
        }
        else {
          ++v9;
        }
      }
      while (v10 != v7 || v13 != v11);
    }
    *(void *)a1 = v4;
    *(void *)(a1 + 16) = v3;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = this->__r_.__value_.__r.__words[2];
    unint64_t v8 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (__n > v8)
    {
      size_t v11 = 0x7FFFFFFFFFFFFFF7;
      if (0x7FFFFFFFFFFFFFF7 - (v10 & 0x7FFFFFFFFFFFFFFFLL) >= __n - v8)
      {
        int v9 = (std::string *)this->__r_.__value_.__r.__words[0];
        if (v8 > 0x3FFFFFFFFFFFFFF2)
        {
LABEL_15:
          int v7 = operator new(v11);
          memcpy(v7, __s, __n);
          if (v8 != 22) {
            operator delete(v9);
          }
          this->__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
          this->__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
LABEL_23:
          this->__r_.__value_.__l.__size_ = __n;
          goto LABEL_24;
        }
LABEL_8:
        std::string::size_type v12 = 2 * v8;
        if (__n > 2 * v8) {
          std::string::size_type v12 = __n;
        }
        uint64_t v13 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v13 = v12 | 7;
        }
        if (v12 >= 0x17) {
          size_t v11 = v13 + 1;
        }
        else {
          size_t v11 = 23;
        }
        goto LABEL_15;
      }
LABEL_25:
      std::string::__throw_length_error[abi:ne180100]();
    }
    unint64_t v6 = HIBYTE(v10);
    int v7 = (void *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    int v7 = this;
    if (__n > 0x16)
    {
      if (__n - 0x7FFFFFFFFFFFFFF7 >= 0x800000000000001FLL)
      {
        unint64_t v8 = 22;
        int v9 = this;
        goto LABEL_8;
      }
      goto LABEL_25;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    goto LABEL_23;
  }
  *((unsigned char *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
LABEL_24:
  *((unsigned char *)v7 + __n) = 0;
  return this;
}

double DERImg4DecodeFindInSequence(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v7 = 0;
  long long v8 = 0uLL;
  while (!DERDecodeSeqNext(a1, &v7))
  {
    if (v7 == a2)
    {
      double result = *(double *)&v8;
      *a3 = v8;
      return result;
    }
  }
  return result;
}

uint64_t DERImg4DecodeTagCompare(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 < 4) {
    return 0xFFFFFFFFLL;
  }
  if (v2 != 4) {
    return 1;
  }
  unsigned int v5 = 0;
  if (DERParseInteger((char **)a1, &v5)) {
    return 4294967294;
  }
  if (v5 < a2) {
    return 0xFFFFFFFFLL;
  }
  return v5 > a2;
}

uint64_t DERImg4DecodeManifest(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 5uLL, (uint64_t)&DERImg4ManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t DERImg4DecodeManifestCommon(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    if (!*a1 || !a1[1]) {
      return 0;
    }
    if (a2 >= 0x10000)
    {
      __break(0x5507u);
      return result;
    }
    uint64_t result = DERParseSequenceToObject((uint64_t)a1, (unsigned __int16)a2, a3, a4, 0xC0uLL, 0);
    if (!result)
    {
      if (DERImg4DecodeTagCompare(a4, a5)) {
        return 2;
      }
      unsigned int v9 = 0;
      uint64_t result = DERParseInteger((char **)(a4 + 16), &v9);
      if (result) {
        return result;
      }
      if (v9 > 2) {
        return 2;
      }
      return 0;
    }
  }
  return result;
}

uint64_t DERImg4DecodeUnsignedManifest(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t DERImg4DecodeCertificate(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 4uLL, (uint64_t)&DERImg4CertificateItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodeUnsignedCertificate(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodePropertyWithItem(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unsigned int v8 = 0;
  v9[0] = 0;
  v9[2] = 0;
  v9[1] = 22;
  v9[3] = 24;
  long long v10 = a3;
  uint64_t result = DERParseSequenceToObject(a1, 2u, (uint64_t)v9, a4, 0x30uLL, 0);
  if (!result)
  {
    uint64_t result = DERParseInteger((char **)a4, &v8);
    if (!result)
    {
      if ((v8 | 0xE000000000000000) == a2)
      {
        uint64_t result = 0;
        *(void *)(a4 + 16) = a2 | 0xE000000000000000;
        *(void *)(a4 + 40) = a3;
      }
      else
      {
        return 2;
      }
    }
  }
  return result;
}

void DERImg4DecodeFindPropertyInSequence(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  long long v8 = 0uLL;
  DERImg4DecodeFindInSequence(a1, a2, &v8);
  if (!v7) {
    DERImg4DecodePropertyWithItem((uint64_t)&v8, a2, a3, a4);
  }
}

void DERImg4DecodeFindProperty(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  v7[0] = 0;
  v7[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v7)) {
    DERImg4DecodeFindPropertyInSequence(v7, a2, a3, a4);
  }
}

void DERImg4DecodeParseManifestProperties(uint64_t a1, unint64_t a2, unint64_t a3)
{
}

void DERImg4DecodeParseManifestPropertiesInternal(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4)
{
  int v11 = 0;
  if (a1)
  {
    if (a2 | a3)
    {
      unint64_t v14 = 0;
      v15[0] = 0;
      v15[1] = 0;
      memset(v13, 0, sizeof(v13));
      memset(v12, 0, sizeof(v12));
      if (!DERDecodeItem(a1 + 264, &v14)
        && v14 == 0x2000000000000011
        && !DERParseInteger((char **)(a1 + 248), &v11))
      {
        unint64_t v8 = v11 == 2 ? 0x2000000000000010 : 0x2000000000000011;
        DERImg4DecodeFindProperty(v15, a4 | 0xE000000000000000, v8, (unint64_t)v13);
        if (!v9)
        {
          if (a2) {
            *(_OWORD *)a2 = *(_OWORD *)((char *)&v13[1] + 8);
          }
          DERImg4DecodeFindProperty((unint64_t *)&v13[1] + 1, 0xE00000004D414E50, 0x2000000000000011uLL, (unint64_t)v12);
          if (a3)
          {
            if (!v10) {
              *(_OWORD *)a3 = *(_OWORD *)((char *)&v12[1] + 8);
            }
          }
        }
      }
    }
  }
}

double Img4DecodeGetObjectProperty(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _OWORD *a5)
{
  v14[0] = 0;
  v14[1] = 0;
  double result = 0.0;
  memset(v13, 0, sizeof(v13));
  if (a1)
  {
    if (a5)
    {
      DERImg4DecodeParseManifestProperties(a1, (unint64_t)v14, 0);
      if (v10
        || (DERImg4DecodeFindProperty(v14, a2 | 0xE000000000000000, 0x2000000000000011uLL, (unint64_t)v13), v11)
        || (DERImg4DecodeFindProperty((unint64_t *)&v13[1] + 1, a3, a4, (unint64_t)a5), v12))
      {
        double result = 0.0;
        a5[1] = 0u;
        a5[2] = 0u;
        *a5 = 0u;
      }
    }
  }
  return result;
}

void Img4DecodeGetObjectPropertyData(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  if (a1 && a4 && a5)
  {
    Img4DecodeGetObjectProperty(a1, a2, a3 | 0xE000000000000000, 4uLL, &v9);
    if (v7)
    {
      uint64_t v8 = 0;
      *a4 = 0;
    }
    else
    {
      uint64_t v8 = v11;
      *a4 = *((void *)&v10 + 1);
    }
    *a5 = v8;
  }
}

uint64_t Img4DecodeInitManifest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Img4DecodeInitManifestCommon(a1, a2, 1, a3, 1229796429);
}

uint64_t Img4DecodeInitManifestCommon(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    uint64_t v15 = a1;
    uint64_t v16 = a2;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 112) = 0u;
    *(_OWORD *)(a4 + 128) = 0u;
    *(_OWORD *)(a4 + 144) = 0u;
    *(_OWORD *)(a4 + 160) = 0u;
    *(_OWORD *)(a4 + 176) = 0u;
    *(_OWORD *)(a4 + 192) = 0u;
    *(_OWORD *)(a4 + 208) = 0u;
    *(_OWORD *)(a4 + 224) = 0u;
    *(_OWORD *)(a4 + 240) = 0u;
    *(_OWORD *)(a4 + 256) = 0u;
    *(_OWORD *)(a4 + 272) = 0u;
    *(_OWORD *)(a4 + 288) = 0u;
    *(_OWORD *)(a4 + 304) = 0u;
    *(_OWORD *)(a4 + 320) = 0u;
    *(_OWORD *)(a4 + 336) = 0u;
    *(_OWORD *)(a4 + 352) = 0u;
    *(_OWORD *)(a4 + 368) = 0u;
    *(_OWORD *)(a4 + 384) = 0u;
    *(_OWORD *)(a4 + 400) = 0u;
    *(_OWORD *)(a4 + 416) = 0u;
    *(_OWORD *)(a4 + 432) = 0u;
    *(void *)(a4 + 448) = 0;
    if (a5 == 1229796419)
    {
      unint64_t v10 = a4 + 232;
      if (a3) {
        uint64_t result = DERImg4DecodeCertificate(&v15, v10);
      }
      else {
        uint64_t result = DERImg4DecodeUnsignedCertificate(&v15, v10);
      }
    }
    else
    {
      if (a5 != 1229796429) {
        return 2;
      }
      unint64_t v9 = a4 + 232;
      if (a3) {
        uint64_t result = DERImg4DecodeManifest(&v15, v9);
      }
      else {
        uint64_t result = DERImg4DecodeUnsignedManifest(&v15, v9);
      }
    }
    if (!result)
    {
      if (*(void *)(a4 + 264))
      {
        unint64_t v12 = 0;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = a1;
        uint64_t v16 = a2;
        uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)&v15, &v12, 0);
        if (!result)
        {
          *(void *)(a4 + 24) = a1;
          uint64_t v11 = v14 + v13 - a1;
          if (__CFADD__(v14, v13 - a1))
          {
            __break(0x5500u);
          }
          else
          {
            *(void *)(a4 + 32) = v11;
            if (v11 == a2) {
              return 0;
            }
            else {
              return 7;
            }
          }
        }
      }
      else
      {
        return 3;
      }
    }
  }
  return result;
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    unint64_t v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

unint64_t *DERParseSequenceContent(unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

uint64_t DEREncodeItem(unint64_t a1, unint64_t a2, const void *a3, unint64_t a4, unint64_t *a5)
{
  return DEREncodeItemSized(a1, a2, a3, a4, *a5, a5);
}

uint64_t DEREncodeSequence(uint64_t result, unint64_t a2, unsigned int a3, uint64_t a4, unint64_t a5, unint64_t *a6)
{
  if ((a2 | 0x7FFFFFFFFFFFFFFFLL) >= a2) {
    return DEREncodeSequenceFromObject(result, a2, ~a2 & 0x7FFFFFFFFFFFFFFFLL, a3, a4, a5, *a6, a6);
  }
  __break(0x5519u);
  return result;
}

BOOL AMFDRIsSupported()
{
  return (void)ExportTable != 0;
}

double AMFDRLoadLibrary()
{
  v0 = dlopen("/usr/lib/libFDR.dylib", 261);
  if (!v0)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_1();
    }
    goto LABEL_161;
  }
  uint64_t v1 = v0;
  *(void *)&ExportTable = dlsym(v0, "AMFDRCreateWithOptions");
  if (!(void)ExportTable)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_2();
    }
    goto LABEL_161;
  }
  *((void *)&ExportTable + 1) = dlsym(v1, "AMFDRCreatePermissionsString");
  if (!*((void *)&ExportTable + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_3();
    }
    goto LABEL_161;
  }
  qword_267D240F8 = (uint64_t)dlsym(v1, "AMFDRCreateInstanceString");
  if (!qword_267D240F8)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_4();
    }
    goto LABEL_161;
  }
  qword_267D24100 = (uint64_t)dlsym(v1, "AMFDRSetOption");
  if (!qword_267D24100)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_5();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24108 = dlsym(v1, "AMFDRSetSealingMap");
  if (!(void)xmmword_267D24108)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_6();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24108 + 1) = dlsym(v1, "AMFDRGetSealingMap");
  if (!*((void *)&xmmword_267D24108 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_7();
    }
    goto LABEL_161;
  }
  qword_267D24118 = (uint64_t)dlsym(v1, "AMFDRSetRecoveryVerifier");
  if (!qword_267D24118)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_8();
    }
    goto LABEL_161;
  }
  qword_267D24120 = (uint64_t)dlsym(v1, "AMFDRGetOptions");
  if (!qword_267D24120)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_9();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24128 = dlsym(v1, "AMFDRGetInfo");
  if (!(void)xmmword_267D24128)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_10();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24128 + 1) = dlsym(v1, "AMFDRGetCert");
  if (!*((void *)&xmmword_267D24128 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_11();
    }
    goto LABEL_161;
  }
  off_267D24138 = dlsym(v1, "AMFDRGetTrustError");
  if (!off_267D24138)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_12();
    }
    goto LABEL_161;
  }
  qword_267D24140 = (uint64_t)dlsym(v1, "AMFDRCopyClientId");
  if (!qword_267D24140)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_13();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24148 = dlsym(v1, "AMFDRCopyUnderlyingDictionary");
  if (!(void)xmmword_267D24148)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_14();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24148 + 1) = dlsym(v1, "AMFDRLogSetHandler");
  if (!*((void *)&xmmword_267D24148 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_15();
    }
    goto LABEL_161;
  }
  qword_267D24158 = (uint64_t)dlsym(v1, "AMFDRPerformManifestCheck");
  if (!qword_267D24158)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_16();
    }
    goto LABEL_161;
  }
  qword_267D24160 = (uint64_t)dlsym(v1, "AMFDRAppendPermissionsString");
  if (!qword_267D24160)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_17();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24168 = dlsym(v1, "AMFDRDataCopyDigest");
  if (!(void)xmmword_267D24168)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_18();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24168 + 1) = dlsym(v1, "AMFDRDataPresent");
  if (!*((void *)&xmmword_267D24168 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_19();
    }
    goto LABEL_161;
  }
  off_267D24178 = dlsym(v1, "AMFDRDataCopy");
  if (!off_267D24178)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_20();
    }
    goto LABEL_161;
  }
  qword_267D24180 = (uint64_t)dlsym(v1, "AMFDRDataMultiCopy");
  if (!qword_267D24180)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_21();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24188 = dlsym(v1, "AMFDRDataPut");
  if (!(void)xmmword_267D24188)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_22();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24188 + 1) = dlsym(v1, "AMFDRDataMultiPut");
  if (!*((void *)&xmmword_267D24188 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_23();
    }
    goto LABEL_161;
  }
  qword_267D24198 = (uint64_t)dlsym(v1, "AMFDRDataPrefetch");
  if (!qword_267D24198)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_24();
    }
    goto LABEL_161;
  }
  qword_267D241A0 = (uint64_t)dlsym(v1, "AMFDRDataExport");
  if (!qword_267D241A0)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_25();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D241A8 = dlsym(v1, "AMFDRDataMultiExport");
  if (!(void)xmmword_267D241A8)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_26();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D241A8 + 1) = dlsym(v1, "AMFDRDataDelete");
  if (!*((void *)&xmmword_267D241A8 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_27();
    }
    goto LABEL_161;
  }
  qword_267D241B8 = (uint64_t)dlsym(v1, "AMFDRDataMultiDelete");
  if (!qword_267D241B8)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_28();
    }
    goto LABEL_161;
  }
  qword_267D241C0 = (uint64_t)dlsym(v1, "AMFDRDataCopyTrustObject");
  if (!qword_267D241C0)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_29();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D241C8 = dlsym(v1, "AMFDRDataCopySslRoots");
  if (!(void)xmmword_267D241C8)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_30();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D241C8 + 1) = dlsym(v1, "AMFDRDataIterate");
  if (!*((void *)&xmmword_267D241C8 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_31();
    }
    goto LABEL_161;
  }
  qword_267D241D8 = (uint64_t)dlsym(v1, "AMFDRDataRecover");
  if (!qword_267D241D8)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_32();
    }
    goto LABEL_161;
  }
  qword_267D241E0 = (uint64_t)dlsym(v1, "AMFDRDataLocalCreateFullKey");
  if (!qword_267D241E0)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_33();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D241E8 = dlsym(v1, "AMFDRSealingMapCreateRecoveryPermissions");
  if (!(void)xmmword_267D241E8)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_34();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D241E8 + 1) = dlsym(v1, "AMFDRSealingMapRecoverCurrentDevice");
  if (!*((void *)&xmmword_267D241E8 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_35();
    }
    goto LABEL_161;
  }
  qword_267D241F8 = (uint64_t)dlsym(v1, "AMFDRSealingMapGetEntry");
  if (!qword_267D241F8)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_36();
    }
    goto LABEL_161;
  }
  qword_267D24200 = (uint64_t)dlsym(v1, "AMFDRSealingMapGetEntriesForDevice");
  if (!qword_267D24200)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_37();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24208 = dlsym(v1, "AMFDRSealingMapCopyInstanceWithIdentifiers");
  if (!(void)xmmword_267D24208)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_38();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24208 + 1) = dlsym(v1, "AMFDRSealingMapCopyRequiredIdentifiers");
  if (!*((void *)&xmmword_267D24208 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_39();
    }
    goto LABEL_161;
  }
  off_267D24218 = dlsym(v1, "AMFDRSealingMapCopyLocalData");
  if (!off_267D24218)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_40();
    }
    goto LABEL_161;
  }
  qword_267D24220 = (uint64_t)dlsym(v1, "AMFDRSealingMapCopyLocalDataForClass");
  if (!qword_267D24220)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_41();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24228 = dlsym(v1, "AMFDRSealingMapCopyLocalMinimalManifestForInstance");
  if (!(void)xmmword_267D24228)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_42();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24228 + 1) = dlsym(v1, "AMFDRSealingMapVerifySealing");
  if (!*((void *)&xmmword_267D24228 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_43();
    }
    goto LABEL_161;
  }
  qword_267D24238 = (uint64_t)dlsym(v1, "AMFDRSealingMapCreateAndPopulateSealedData");
  if (!qword_267D24238)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_44();
    }
    goto LABEL_161;
  }
  qword_267D24240 = (uint64_t)dlsym(v1, "AMFDRSealingMapVerifyAndCommitSealedData");
  if (!qword_267D24240)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_45();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24248 = dlsym(v1, "AMFDRSealedDataCreateSealingRequest");
  if (!(void)xmmword_267D24248)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_46();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24248 + 1) = dlsym(v1, "AMFDRSealedDataCreate");
  if (!*((void *)&xmmword_267D24248 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_47();
    }
    goto LABEL_161;
  }
  qword_267D24258 = (uint64_t)dlsym(v1, "AMFDRSealedDataPopulate");
  if (!qword_267D24258)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_48();
    }
    goto LABEL_161;
  }
  qword_267D24260 = (uint64_t)dlsym(v1, "AMFDRCopyDisposableKeys");
  if (!qword_267D24260)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_49();
    }
    goto LABEL_161;
  }
  *(void *)&xmmword_267D24268 = dlsym(v1, "AMFDRCopyDeviceKeys");
  if (!(void)xmmword_267D24268)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_50();
    }
    goto LABEL_161;
  }
  qword_267D24278 = (uint64_t)dlsym(v1, "AMFDRDataPutForSysCfgKey");
  if (!qword_267D24278)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_51();
    }
    goto LABEL_161;
  }
  *((void *)&xmmword_267D24268 + 1) = dlsym(v1, "AMFDRCreateLocalPending");
  if (!*((void *)&xmmword_267D24268 + 1))
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_52();
    }
    goto LABEL_161;
  }
  qword_267D24280 = (uint64_t)dlsym(v1, "AMFDRSealingMapSetMGCopyAnswer");
  if (!qword_267D24280)
  {
    if (os_log_type_enabled(MEMORY[0x263EF8438], OS_LOG_TYPE_ERROR)) {
      AMFDRLoadLibrary_cold_53();
    }
LABEL_161:
    double result = 0.0;
    xmmword_267D24268 = 0u;
    *(_OWORD *)&qword_267D24278 = 0u;
    xmmword_267D24248 = 0u;
    *(_OWORD *)&qword_267D24258 = 0u;
    xmmword_267D24228 = 0u;
    *(_OWORD *)&qword_267D24238 = 0u;
    xmmword_267D24208 = 0u;
    *(_OWORD *)&off_267D24218 = 0u;
    xmmword_267D241E8 = 0u;
    *(_OWORD *)&qword_267D241F8 = 0u;
    xmmword_267D241C8 = 0u;
    *(_OWORD *)&qword_267D241D8 = 0u;
    xmmword_267D241A8 = 0u;
    *(_OWORD *)&qword_267D241B8 = 0u;
    xmmword_267D24188 = 0u;
    *(_OWORD *)&qword_267D24198 = 0u;
    xmmword_267D24168 = 0u;
    *(_OWORD *)&off_267D24178 = 0u;
    xmmword_267D24148 = 0u;
    *(_OWORD *)&qword_267D24158 = 0u;
    xmmword_267D24128 = 0u;
    *(_OWORD *)&off_267D24138 = 0u;
    xmmword_267D24108 = 0u;
    *(_OWORD *)&qword_267D24118 = 0u;
    ExportTable = 0u;
    *(_OWORD *)&qword_267D240F8 = 0u;
  }
  return result;
}

uint64_t AMFDRCreateWithOptions(uint64_t a1, uint64_t a2)
{
  pthread_once(&ExportTableOnce, (void (*)(void))AMFDRLoadLibrary);
  unint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))ExportTable;
  if (!(void)ExportTable) {
    return 0;
  }

  return v4(a1, a2);
}

uint64_t AMFDRGetTrustError(uint64_t a1)
{
  pthread_once(&ExportTableOnce, (void (*)(void))AMFDRLoadLibrary);
  unint64_t v2 = (uint64_t (*)(uint64_t))off_267D24138;
  if (!off_267D24138) {
    return 0;
  }

  return v2(a1);
}

uint64_t AMFDRLogSetHandler(uint64_t a1)
{
  uint64_t result = pthread_once(&ExportTableOnce, (void (*)(void))AMFDRLoadLibrary);
  unint64_t v3 = (uint64_t (*)(uint64_t))*((void *)&xmmword_267D24148 + 1);
  if (*((void *)&xmmword_267D24148 + 1))
  {
    return v3(a1);
  }
  return result;
}

uint64_t AMFDRDataCopy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  pthread_once(&ExportTableOnce, (void (*)(void))AMFDRLoadLibrary);
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))off_267D24178;
  if (!off_267D24178) {
    return 0;
  }

  return v8(a1, a2, a3, a4);
}

uint64_t AMFDRSealingMapCopyLocalData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  pthread_once(&ExportTableOnce, (void (*)(void))AMFDRLoadLibrary);
  uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))off_267D24218;
  if (!off_267D24218) {
    return 0;
  }

  return v8(a1, a2, a3, a4);
}

void AMFDRLoadLibrary_cold_1()
{
  dlerror();
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load %s: %s\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_2()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_3()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_4()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_5()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_6()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_7()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_8()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_9()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_10()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_11()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_12()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_13()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_14()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_15()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_16()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_17()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_18()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_19()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_20()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_21()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_22()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_23()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_24()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_25()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_26()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_27()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_28()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_29()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_30()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_31()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_32()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_33()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_34()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_35()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_36()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_37()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_38()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_39()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_40()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_41()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_42()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_43()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_44()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_45()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_46()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_47()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_48()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_49()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_50()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_51()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_52()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

void AMFDRLoadLibrary_cold_53()
{
  OUTLINED_FUNCTION_1();
  OUTLINED_FUNCTION_0(&dword_21DE8A000, MEMORY[0x263EF8438], v0, "failed to load '%s' from '%s'\n", v1, v2, v3, v4, 2u);
}

const void **ctu::cf::CFSharedRef<void const>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void __clang_call_terminate(void *a1)
{
}

void **std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (v2[1])
    {
      TelephonyUtilTransportFree();
      uint64_t v3 = (void *)v2[1];
      if (v3) {
        operator delete(v3);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void ___ZN7support9transport3ARI9initLibTUEPKcjj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2 == 1)
  {
    int v7 = *(void **)(v2 + 104);
    char v25 = 1;
    uint64_t v8 = (support::log::buffer *)(*(uint64_t (**)(void *, uint64_t, void))(*v7 + 16))(v7, a2, **(void **)(v2 + 80));
    if (v8)
    {
      if (v7[17])
      {
        int v9 = 2;
        support::log::buffer::borrow(v8);
      }
      else
      {
        int v9 = 0;
      }
      if (v9 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
      {
        LOWORD(v26) = 0;
        uint64_t v18 = _os_log_send_and_compose_impl();
        if (v18)
        {
          uint64_t v14 = (char *)v18;
          v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
          std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = v15.__d_.__rep_;
          int v26 = &unk_26CEC9278;
          uint64_t v27 = v2 + 40;
          uint64_t v28 = &v25;
          p_std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = &rep;
          uint64_t v19 = v7 + 15;
          for (uint64_t i = v7[16]; (void *)i != v19; uint64_t i = *(void *)(i + 8))
            v15.__d_.__rep_ = (***(uint64_t (****)(void, void **, char *))(i + 16))(*(void *)(i + 16), &v26, v14);
          goto LABEL_29;
        }
      }
    }
  }
  else
  {
    int v3 = a2;
    if (a2)
    {
      unint64_t v10 = *(void **)(v2 + 104);
      char v25 = 1;
      uint64_t v11 = (support::log::buffer *)(*(uint64_t (**)(void *, uint64_t, void))(*v10 + 16))(v10, 1, **(void **)(v2 + 80));
      if (v11)
      {
        if (v10[17])
        {
          int v12 = 2;
          support::log::buffer::borrow(v11);
        }
        else
        {
          int v12 = 0;
        }
        if (v12 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
        {
          LODWORD(v26) = 67109120;
          HIDWORD(v26) = v3;
          uint64_t v21 = _os_log_send_and_compose_impl();
          if (v21)
          {
            uint64_t v14 = (char *)v21;
            v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
            std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = v15.__d_.__rep_;
            int v26 = &unk_26CEC9278;
            uint64_t v27 = v2 + 40;
            uint64_t v28 = &v25;
            p_std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = &rep;
            uint64_t v22 = v10 + 15;
            for (uint64_t j = v10[16]; (void *)j != v22; uint64_t j = *(void *)(j + 8))
              v15.__d_.__rep_ = (***(uint64_t (****)(void, void **, char *))(j + 16))(*(void *)(j + 16), &v26, v14);
            goto LABEL_29;
          }
        }
      }
    }
    else
    {
      uint64_t v4 = *(void **)(v2 + 104);
      char v25 = 1;
      unsigned int v5 = (support::log::buffer *)(*(uint64_t (**)(void *, uint64_t, void))(*v4 + 16))(v4, 1, **(void **)(v2 + 80));
      if (v5)
      {
        if (v4[17])
        {
          int v6 = 2;
          support::log::buffer::borrow(v5);
        }
        else
        {
          int v6 = 0;
        }
        if (v6 | os_log_type_enabled(**(os_log_t **)(v2 + 80), OS_LOG_TYPE_ERROR))
        {
          LOWORD(v26) = 0;
          uint64_t v13 = _os_log_send_and_compose_impl();
          if (v13)
          {
            uint64_t v14 = (char *)v13;
            v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
            std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = v15.__d_.__rep_;
            int v26 = &unk_26CEC9278;
            uint64_t v27 = v2 + 40;
            uint64_t v28 = &v25;
            p_std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = &rep;
            uint64_t v16 = v4 + 15;
            for (uint64_t k = v4[16]; (void *)k != v16; uint64_t k = *(void *)(k + 8))
              v15.__d_.__rep_ = (***(uint64_t (****)(void, void **, char *))(k + 16))(*(void *)(k + 16), &v26, v14);
LABEL_29:
            support::log::manager::release_log_buffer((support::log::manager *)v15.__d_.__rep_, v14);
          }
        }
      }
    }
  }
}

void support::transport::ARI::create(support::transport::ARI *this@<X0>, dispatch_queue_s *a2@<X1>, char a3@<W3>, uint64_t a4@<X4>, char **a5@<X8>)
{
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v110 = v11;
  long long v111 = v11;
  v109[1] = v11;
  v109[2] = v11;
  v109[0] = v11;
  v108.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x30uLL);
  *(_WORD *)&v106[50] = 0;
  *(_DWORD *)&v106[52] = 0;
  *(void *)&v106[56] = 0x8000000000000030;
  *(_OWORD *)&v108.__r_.__value_.__r.__words[1] = xmmword_21DFA8D90;
  strcpy(v108.__r_.__value_.__l.__data_, "com.apple.telephony.basebandservices.support");
  strcpy(v106, "services.supportony.basebandservcom.apple.teleph,");
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 10;
  strcpy((char *)&__p, "ari.create");
  support::log::client::client(v109, &v108, &__p, a4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v108.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((SHIBYTE(v108.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v108.__r_.__value_.__l.__data_);
LABEL_3:
  *a5 = (char *)0xAAAAAAAAAAAAAAAALL;
  int v12 = (char *)operator new(0x70uLL);
  *(void *)int v12 = &unk_26CEC9248;
  *((void *)v12 + 1) = 0;
  *((_DWORD *)v12 + 4) = 0;
  *((void *)v12 + 3) = 0;
  uint64_t v13 = (void **)(v12 + 24);
  uint64_t v14 = operator new(0x30uLL);
  *(void *)uint64_t v120 = v14;
  *(_OWORD *)&v120[8] = *(_OWORD *)&v106[48];
  *uint64_t v14 = *(_OWORD *)&v106[32];
  v14[1] = *(_OWORD *)&v106[16];
  *(_OWORD *)((char *)v14 + 28) = *(_OWORD *)v106;
  *((unsigned char *)v14 + 44) = 0;
  *((unsigned char *)&v117.__r_.__value_.__s + 23) = 3;
  LODWORD(v117.__r_.__value_.__l.__data_) = 6910561;
  support::log::client::client((void *)v12 + 4, (std::string *)v120, &v117, a4);
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v117.__r_.__value_.__l.__data_);
    if ((v120[23] & 0x80000000) == 0) {
      goto LABEL_5;
    }
LABEL_20:
    operator delete(*(void **)v120);
    goto LABEL_5;
  }
  if ((v120[23] & 0x80000000) != 0) {
    goto LABEL_20;
  }
LABEL_5:
  *(void *)&v106[48] = a5;
  *a5 = v12;
  std::chrono::system_clock::time_point v15 = getprogname();
  if (!strncmp(v15, "CommCenter", 0xAuLL)) {
    goto LABEL_24;
  }
  uint64_t v16 = getprogname();
  if (!strncmp(v16, "CommCenter-asan", 0xFuLL)) {
    goto LABEL_24;
  }
  unint64_t v17 = getprogname();
  if (!strncmp(v17, "basebandd", 9uLL)) {
    goto LABEL_24;
  }
  v120[23] = 10;
  strcpy(v120, "CommCenter");
  if (ctu::isProcessRunning())
  {
    int isProcessRunning = 1;
    if ((v120[23] & 0x80000000) != 0) {
      goto LABEL_10;
    }
LABEL_23:
    if (!isProcessRunning) {
      goto LABEL_11;
    }
    goto LABEL_24;
  }
  *((unsigned char *)&v117.__r_.__value_.__s + 23) = 9;
  strcpy((char *)&v117, "basebandd");
  int isProcessRunning = ctu::isProcessRunning();
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v117.__r_.__value_.__l.__data_);
    if ((v120[23] & 0x80000000) == 0) {
      goto LABEL_23;
    }
  }
  else if ((v120[23] & 0x80000000) == 0)
  {
    goto LABEL_23;
  }
LABEL_10:
  operator delete(*(void **)v120);
  if (!isProcessRunning)
  {
LABEL_11:
    strcpy((char *)&v125, "com.apple.ARITransport");
    *((unsigned char *)&v125.__r_.__value_.__s + 23) = 22;
    uint64_t v124 = 0;
    long long v122 = 0u;
    long long v123 = 0u;
    long long v121 = 0u;
    memset(v120, 0, sizeof(v120));
    if (!this || !*(unsigned char *)this)
    {
      v76 = (support::log::manager *)*((void *)v12 + 13);
      LOBYTE(v116) = 1;
      v77 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v76 + 16))(v76, 1, **((void **)v12 + 10));
      if (!v77) {
        goto LABEL_203;
      }
      if (*((void *)v76 + 17))
      {
        support::log::buffer::borrow(v77);
        int v78 = 2;
      }
      else
      {
        int v78 = 0;
      }
      if (!(v78 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))) {
        goto LABEL_203;
      }
      LOWORD(v117.__r_.__value_.__l.__data_) = 0;
      uint64_t v94 = _os_log_send_and_compose_impl();
      if (!v94) {
        goto LABEL_203;
      }
      goto LABEL_182;
    }
    size_t v19 = strlen((const char *)this);
    if (v19 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v20 = v19;
    if (v19 >= 0x17)
    {
      uint64_t v42 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v19 | 7) != 0x17) {
        uint64_t v42 = v19 | 7;
      }
      uint64_t v43 = v42 + 1;
      p_dst = (std::string *)operator new(v42 + 1);
      __dst.__r_.__value_.__l.__size_ = v20;
      __dst.__r_.__value_.__r.__words[2] = v43 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v19;
      p_dst = &__dst;
      if (!v19) {
        goto LABEL_73;
      }
    }
    memcpy(p_dst, this, v20);
LABEL_73:
    p_dst->__r_.__value_.__s.__data_[v20] = 0;
    unint64_t v44 = std::string::insert(&__dst, 0, ".", 1uLL);
    long long v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v117.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v117.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v46 = &v117;
    }
    else {
      uint64_t v46 = (std::string *)v117.__r_.__value_.__r.__words[0];
    }
    if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v117.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v117.__r_.__value_.__l.__size_;
    }
    std::string::append(&v125, (const std::string::value_type *)v46, size);
    if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v117.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    if ((v125.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      BOOL v48 = &v125;
    }
    else {
      BOOL v48 = (std::string *)v125.__r_.__value_.__r.__words[0];
    }
    dispatch_queue_t v49 = dispatch_queue_create((const char *)v48, 0);
    unint64_t v50 = *((void *)v12 + 1);
    *((void *)v12 + 1) = v49;
    if (v50)
    {
      dispatch_release(v50);
      dispatch_queue_t v49 = (dispatch_queue_t)*((void *)v12 + 1);
    }
    if (v49)
    {
      TelephonyBasebandPCITransportInitParameters();
      uint64_t v51 = *((void *)v12 + 1);
      *(_DWORD *)&v120[24] = a2;
      LODWORD(v121) = v121 | 1;
      *(_DWORD *)uint64_t v120 = 8;
      int v116 = 0;
      v117.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
      v117.__r_.__value_.__l.__size_ = 0x40000000;
      v117.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN7support9transport3ARI9initLibTUEPKcjj_block_invoke;
      int v118 = (std::string *)&__block_descriptor_tmp;
      unint64_t v119 = v12;
      *(void *)&v120[8] = v51;
      *(void *)&v120[16] = &v117;
      operator new(0x58uLL);
      if ((TelephonyBasebandPCITransportCreate() & 1) == 0)
      {
        v86 = (support::log::manager *)*((void *)v12 + 13);
        char v115 = 1;
        v87 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v86 + 16))(v86, 1, **((void **)v12 + 10));
        if (v87)
        {
          if (*((void *)v86 + 17))
          {
            support::log::buffer::borrow(v87);
            int v88 = 2;
          }
          else
          {
            int v88 = 0;
          }
          if (v88 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))
          {
            LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
            uint64_t v96 = _os_log_send_and_compose_impl();
            if (v96)
            {
              BOOL v97 = (char *)v96;
              std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = std::chrono::system_clock::now().__d_.__rep_;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_26CEC9278;
              __dst.__r_.__value_.__l.__size_ = (std::string::size_type)(v12 + 40);
              __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)&v115;
              p_std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = &rep;
              support::log::manager::message_delegates(v86, (const support::log::details *)&__dst, v97);
            }
          }
        }
LABEL_203:
        char v55 = 0;
        if ((SHIBYTE(v125.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_98;
        }
        goto LABEL_204;
      }
      size_t v52 = operator new(0x20uLL);
      *size_t v52 = 0u;
      v52[1] = 0u;
      int v116 = v52;
      if (KTLInitOptions())
      {
        if (KTLOpenChannel())
        {
          int v116 = 0;
          int v53 = *v13;
          *uint64_t v13 = v52;
          if (v53)
          {
            if (v53[1])
            {
              TelephonyUtilTransportFree();
              int v54 = (void *)v53[1];
              if (v54) {
                operator delete(v54);
              }
            }
            operator delete(v53);
          }
          char v55 = 1;
          if ((SHIBYTE(v125.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_98:
            if (v55) {
              goto LABEL_65;
            }
LABEL_205:
            __dst.__r_.__value_.__s.__data_[0] = 1;
            v101 = (support::log::manager *)*((void *)&v111 + 1);
            uint64_t v102 = (support::log::buffer *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)&v111 + 1)
                                                                                              + 16))(*((void *)&v111 + 1), 1, *(void *)v110);
            if (v102)
            {
              if (*((void *)v101 + 17))
              {
                support::log::buffer::borrow(v102);
                int v103 = 2;
              }
              else
              {
                int v103 = 0;
              }
              if (v103 | os_log_type_enabled(*(os_log_t *)v110, OS_LOG_TYPE_ERROR))
              {
                *(_WORD *)uint64_t v120 = 0;
                uint64_t v104 = _os_log_send_and_compose_impl();
                if (v104)
                {
                  uint64_t v105 = (char *)v104;
                  v117.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
                  *(void *)uint64_t v120 = &unk_26CEC9278;
                  *(void *)&v120[8] = (char *)v109 + 8;
                  *(void *)&v120[16] = &__dst;
                  *(void *)&v120[24] = &v117;
                  support::log::manager::message_delegates(v101, (const support::log::details *)v120, v105);
                }
              }
            }
            uint64_t v22 = *(void **)&v106[48];
            goto LABEL_213;
          }
LABEL_204:
          operator delete(v125.__r_.__value_.__l.__data_);
          if (v55) {
            goto LABEL_65;
          }
          goto LABEL_205;
        }
        std::vector<std::string>::pointer v89 = (support::log::manager *)*((void *)v12 + 13);
        char v115 = 1;
        unint64_t v92 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v89 + 16))(v89, 1, **((void **)v12 + 10));
        if (!v92) {
          goto LABEL_199;
        }
        if (*((void *)v89 + 17))
        {
          support::log::buffer::borrow(v92);
          int v93 = 2;
        }
        else
        {
          int v93 = 0;
        }
        if (!(v93 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))) {
          goto LABEL_199;
        }
        LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
        uint64_t v98 = _os_log_send_and_compose_impl();
        if (!v98) {
          goto LABEL_199;
        }
      }
      else
      {
        std::vector<std::string>::pointer v89 = (support::log::manager *)*((void *)v12 + 13);
        char v115 = 1;
        int v90 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v89 + 16))(v89, 1, **((void **)v12 + 10));
        if (!v90) {
          goto LABEL_199;
        }
        if (*((void *)v89 + 17))
        {
          support::log::buffer::borrow(v90);
          int v91 = 2;
        }
        else
        {
          int v91 = 0;
        }
        if (!(v91 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))) {
          goto LABEL_199;
        }
        LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
        uint64_t v98 = _os_log_send_and_compose_impl();
        if (!v98) {
          goto LABEL_199;
        }
      }
      v99 = (char *)v98;
      std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = std::chrono::system_clock::now().__d_.__rep_;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_26CEC9278;
      __dst.__r_.__value_.__l.__size_ = (std::string::size_type)(v12 + 40);
      __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)&v115;
      p_std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep = &rep;
      support::log::manager::message_delegates(v89, (const support::log::details *)&__dst, v99);
LABEL_199:
      int v116 = 0;
      if (*((void *)v52 + 1))
      {
        TelephonyUtilTransportFree();
        int v100 = (void *)*((void *)v52 + 1);
        if (v100) {
          operator delete(v100);
        }
      }
      operator delete(v52);
      goto LABEL_203;
    }
    v76 = (support::log::manager *)*((void *)v12 + 13);
    LOBYTE(v116) = 1;
    v84 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v76 + 16))(v76, 1, **((void **)v12 + 10));
    if (!v84) {
      goto LABEL_203;
    }
    if (*((void *)v76 + 17))
    {
      support::log::buffer::borrow(v84);
      int v85 = 2;
    }
    else
    {
      int v85 = 0;
    }
    if (!(v85 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))) {
      goto LABEL_203;
    }
    LOWORD(v117.__r_.__value_.__l.__data_) = 0;
    uint64_t v94 = _os_log_send_and_compose_impl();
    if (!v94) {
      goto LABEL_203;
    }
LABEL_182:
    uint64_t v95 = (char *)v94;
    __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
    v117.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_26CEC9278;
    v117.__r_.__value_.__l.__size_ = (std::string::size_type)(v12 + 40);
    v117.__r_.__value_.__r.__words[2] = (std::string::size_type)&v116;
    int v118 = &__dst;
    support::log::manager::message_delegates(v76, (const support::log::details *)&v117, v95);
    goto LABEL_203;
  }
LABEL_24:
  if ((a3 & 1) == 0)
  {
    __dst.__r_.__value_.__s.__data_[0] = 1;
    int v59 = (support::log::manager *)*((void *)&v111 + 1);
    uint64_t v22 = *(void **)&v106[48];
    v60 = (support::log::buffer *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)&v111 + 1) + 16))(*((void *)&v111 + 1), 1, *(void *)v110);
    if (!v60) {
      goto LABEL_213;
    }
    if (*((void *)v59 + 17))
    {
      support::log::buffer::borrow(v60);
      int v61 = 2;
    }
    else
    {
      int v61 = 0;
    }
    if (!(v61 | os_log_type_enabled(*(os_log_t *)v110, OS_LOG_TYPE_ERROR))) {
      goto LABEL_213;
    }
    *(_WORD *)uint64_t v120 = 0;
    uint64_t v79 = _os_log_send_and_compose_impl();
    if (!v79) {
      goto LABEL_213;
    }
    goto LABEL_136;
  }
  strcpy((char *)&v117, "com.apple.ARITransport");
  *((unsigned char *)&v117.__r_.__value_.__s + 23) = 22;
  uint64_t v22 = *(void **)&v106[48];
  if (!this || !*(unsigned char *)this)
  {
    size_t v56 = (support::log::manager *)*((void *)v12 + 13);
    v125.__r_.__value_.__s.__data_[0] = 1;
    size_t v57 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v56 + 16))(v56, 1, **((void **)v12 + 10));
    if (!v57) {
      goto LABEL_153;
    }
    if (*((void *)v56 + 17))
    {
      support::log::buffer::borrow(v57);
      int v58 = 2;
    }
    else
    {
      int v58 = 0;
    }
    if (!(v58 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))) {
      goto LABEL_153;
    }
    *(_WORD *)uint64_t v120 = 0;
    uint64_t v75 = _os_log_send_and_compose_impl();
    if (!v75) {
      goto LABEL_153;
    }
LABEL_152:
    v81 = (char *)v75;
    __dst.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
    *(void *)uint64_t v120 = &unk_26CEC9278;
    *(void *)&v120[8] = v12 + 40;
    *(void *)&v120[16] = &v125;
    *(void *)&v120[24] = &__dst;
    support::log::manager::message_delegates(v56, (const support::log::details *)v120, v81);
    goto LABEL_153;
  }
  size_t v23 = strlen((const char *)this);
  if (v23 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::string::size_type v24 = v23;
  if (v23 >= 0x17)
  {
    uint64_t v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17) {
      uint64_t v26 = v23 | 7;
    }
    uint64_t v27 = v26 + 1;
    char v25 = (std::string *)operator new(v26 + 1);
    __dst.__r_.__value_.__l.__size_ = v24;
    __dst.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
    uint64_t v22 = *(void **)&v106[48];
    goto LABEL_34;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v23;
  char v25 = &__dst;
  if (v23) {
LABEL_34:
  }
    memcpy(v25, this, v24);
  v25->__r_.__value_.__s.__data_[v24] = 0;
  uint64_t v28 = std::string::insert(&__dst, 0, ".", 1uLL);
  long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  *(void *)&v120[16] = *((void *)&v28->__r_.__value_.__l + 2);
  *(_OWORD *)uint64_t v120 = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  if (v120[23] >= 0) {
    uint64_t v30 = v120;
  }
  else {
    uint64_t v30 = *(const std::string::value_type **)v120;
  }
  if (v120[23] >= 0) {
    std::string::size_type v31 = v120[23];
  }
  else {
    std::string::size_type v31 = *(void *)&v120[8];
  }
  std::string::append(&v117, v30, v31);
  if ((v120[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)v120);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_43;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_43;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_43:
  if ((v117.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v32 = &v117;
  }
  else {
    uint64_t v32 = (std::string *)v117.__r_.__value_.__r.__words[0];
  }
  unint64_t v33 = (AriHost *)dispatch_queue_create((const char *)v32, 0);
  uint64_t v34 = *((void *)v12 + 1);
  *((void *)v12 + 1) = v33;
  if (v34)
  {
    dispatch_release(v34);
    unint64_t v33 = (AriHost *)*((void *)v12 + 1);
  }
  if (!v33)
  {
    size_t v56 = (support::log::manager *)*((void *)v12 + 13);
    v125.__r_.__value_.__s.__data_[0] = 1;
    int v64 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v56 + 16))(v56, 1, **((void **)v12 + 10));
    if (!v64) {
      goto LABEL_153;
    }
    if (*((void *)v56 + 17))
    {
      support::log::buffer::borrow(v64);
      int v65 = 2;
    }
    else
    {
      int v65 = 0;
    }
    if (!(v65 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))) {
      goto LABEL_153;
    }
    *(_WORD *)uint64_t v120 = 0;
    uint64_t v75 = _os_log_send_and_compose_impl();
    if (!v75) {
      goto LABEL_153;
    }
    goto LABEL_152;
  }
  if (AriHost::Init(v33))
  {
    size_t v56 = (support::log::manager *)*((void *)v12 + 13);
    v125.__r_.__value_.__s.__data_[0] = 1;
    size_t v66 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v56 + 16))(v56, 1, **((void **)v12 + 10));
    if (!v66) {
      goto LABEL_153;
    }
    if (*((void *)v56 + 17))
    {
      support::log::buffer::borrow(v66);
      int v67 = 2;
    }
    else
    {
      int v67 = 0;
    }
    if (!(v67 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))) {
      goto LABEL_153;
    }
    *(_WORD *)uint64_t v120 = 0;
    uint64_t v75 = _os_log_send_and_compose_impl();
    if (!v75) {
      goto LABEL_153;
    }
    goto LABEL_152;
  }
  if (!AriHost::RegisterClient(this, v12 + 16, *((int **)v12 + 1), a2))
  {
    unint64_t v35 = operator new(0x20uLL);
    _OWORD *v35 = 0u;
    v35[1] = 0u;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
    if (KTLInitOptions())
    {
      if (KTLOpenChannel())
      {
        __dst.__r_.__value_.__r.__words[0] = 0;
        uint64_t v36 = *v13;
        *uint64_t v13 = v35;
        if (v36)
        {
          if (v36[1])
          {
            TelephonyUtilTransportFree();
            int v37 = 0;
            int v38 = 0;
            size_t v39 = (void *)v36[1];
            if (!v39) {
              goto LABEL_62;
            }
            goto LABEL_56;
          }
          int v38 = 0;
          goto LABEL_62;
        }
        BOOL v40 = 1;
        if ((SHIBYTE(v117.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_64;
        }
LABEL_63:
        operator delete(v117.__r_.__value_.__l.__data_);
        goto LABEL_64;
      }
      int v70 = (support::log::manager *)*((void *)v12 + 13);
      LOBYTE(v116) = 1;
      int64_t v73 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v70 + 16))(v70, 1, **((void **)v12 + 10));
      if (v73)
      {
        if (*((void *)v70 + 17))
        {
          support::log::buffer::borrow(v73);
          int v74 = 2;
        }
        else
        {
          int v74 = 0;
        }
        if (v74 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v120 = 0;
          uint64_t v82 = _os_log_send_and_compose_impl();
          if (v82) {
            goto LABEL_162;
          }
        }
      }
    }
    else
    {
      int v70 = (support::log::manager *)*((void *)v12 + 13);
      LOBYTE(v116) = 1;
      std::vector<std::string>::pointer v71 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v70 + 16))(v70, 1, **((void **)v12 + 10));
      if (v71)
      {
        if (*((void *)v70 + 17))
        {
          support::log::buffer::borrow(v71);
          int v72 = 2;
        }
        else
        {
          int v72 = 0;
        }
        if (v72 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v120 = 0;
          uint64_t v82 = _os_log_send_and_compose_impl();
          if (v82)
          {
LABEL_162:
            int v83 = (char *)v82;
            v125.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
            *(void *)uint64_t v120 = &unk_26CEC9278;
            *(void *)&v120[8] = v12 + 40;
            *(void *)&v120[16] = &v116;
            *(void *)&v120[24] = &v125;
            support::log::manager::message_delegates(v70, (const support::log::details *)v120, v83);
          }
        }
      }
    }
    __dst.__r_.__value_.__r.__words[0] = 0;
    if (*((void *)v35 + 1))
    {
      TelephonyUtilTransportFree();
      size_t v39 = (void *)*((void *)v35 + 1);
      int v37 = 8;
      uint64_t v36 = v35;
      int v38 = 8;
      if (v39)
      {
LABEL_56:
        operator delete(v39);
        int v38 = v37;
      }
    }
    else
    {
      int v38 = 8;
      uint64_t v36 = v35;
    }
LABEL_62:
    operator delete(v36);
    BOOL v40 = v38 == 0;
    if ((SHIBYTE(v117.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_64;
    }
    goto LABEL_63;
  }
  size_t v56 = (support::log::manager *)*((void *)v12 + 13);
  v125.__r_.__value_.__s.__data_[0] = 1;
  int v68 = (support::log::buffer *)(*(uint64_t (**)(support::log::manager *, uint64_t, void))(*(void *)v56 + 16))(v56, 1, **((void **)v12 + 10));
  if (v68)
  {
    if (*((void *)v56 + 17))
    {
      support::log::buffer::borrow(v68);
      int v69 = 2;
    }
    else
    {
      int v69 = 0;
    }
    if (v69 | os_log_type_enabled(**((os_log_t **)v12 + 10), OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v120 = 0;
      uint64_t v75 = _os_log_send_and_compose_impl();
      if (v75) {
        goto LABEL_152;
      }
    }
  }
LABEL_153:
  BOOL v40 = 0;
  if (SHIBYTE(v117.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_63;
  }
LABEL_64:
  if (v40) {
    goto LABEL_65;
  }
  __dst.__r_.__value_.__s.__data_[0] = 1;
  int v59 = (support::log::manager *)*((void *)&v111 + 1);
  size_t v62 = (support::log::buffer *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)&v111 + 1) + 16))(*((void *)&v111 + 1), 1, *(void *)v110);
  if (!v62) {
    goto LABEL_213;
  }
  if (*((void *)v59 + 17))
  {
    support::log::buffer::borrow(v62);
    int v63 = 2;
  }
  else
  {
    int v63 = 0;
  }
  if (!(v63 | os_log_type_enabled(*(os_log_t *)v110, OS_LOG_TYPE_ERROR))) {
    goto LABEL_213;
  }
  *(_WORD *)uint64_t v120 = 0;
  uint64_t v79 = _os_log_send_and_compose_impl();
  if (!v79) {
    goto LABEL_213;
  }
LABEL_136:
  BOOL v80 = (char *)v79;
  v117.__r_.__value_.__l.__data_ = (std::string::pointer)std::chrono::system_clock::now().__d_.__rep_;
  *(void *)uint64_t v120 = &unk_26CEC9278;
  *(void *)&v120[8] = (char *)v109 + 8;
  *(void *)&v120[16] = &__dst;
  *(void *)&v120[24] = &v117;
  support::log::manager::message_delegates(v59, (const support::log::details *)v120, v80);
LABEL_213:
  *uint64_t v22 = 0;
  (*(void (**)(char *))(*(void *)v12 + 8))(v12);
LABEL_65:
  *(void *)&v109[0] = &unk_26CEC92A8;
  long long v41 = (std::__shared_weak_count *)v111;
  if ((void)v111)
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(v111 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }
}

void sub_21DE95A90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,void *a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57)
{
  std::unique_ptr<KTLOptions,support::transport::ARI::KTLOptionsDestructor>::~unique_ptr[abi:ne180100](&a51);
  if (*(char *)(v58 - 105) < 0) {
    operator delete(*(void **)(v58 - 128));
  }
  *a17 = 0;
  (*(void (**)(uint64_t))(*(void *)v57 + 8))(v57);
  support::log::client::~client((support::log::client *)&a31);
  _Unwind_Resume(a1);
}

void support::log::client::~client(support::log::client *this)
{
  *(void *)this = &unk_26CEC92A8;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void support::transport::ARI::~ARI(support::transport::ARI *this)
{
  *(void *)this = &unk_26CEC9248;
  if (*((void *)this + 3)) {
    KTLCloseChannel();
  }
  uint64_t v2 = (AriHost *)*((unsigned int *)this + 4);
  if (v2) {
    AriHost::DeregisterClient(v2);
  }
  *((void *)this + 4) = &unk_26CEC92A8;
  int v3 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = (void *)*((void *)this + 3);
    *((void *)this + 3) = 0;
    if (!v4) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v4 = (void *)*((void *)this + 3);
    *((void *)this + 3) = 0;
    if (!v4) {
      goto LABEL_12;
    }
  }
  if (v4[1])
  {
    TelephonyUtilTransportFree();
    unsigned int v5 = (void *)v4[1];
    if (v5) {
      operator delete(v5);
    }
  }
  operator delete(v4);
LABEL_12:
  int v6 = *((void *)this + 1);
  if (v6) {
    dispatch_release(v6);
  }
}

{
  void *v1;
  uint64_t vars8;

  support::transport::ARI::~ARI(this);

  operator delete(v1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_264489530, MEMORY[0x263F8C060]);
}

void sub_21DE95FB8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

void std::string::__throw_out_of_range[abi:ne180100]()
{
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_264489538, MEMORY[0x263F8C068]);
}

void sub_21DE96064(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C390] + 16);
  return result;
}

void support::log::client::~client(std::__shared_weak_count **this)
{
  uint64_t v1 = (support::log::client *)this;
  *this = (std::__shared_weak_count *)&unk_26CEC92A8;
  uint64_t v2 = this[8];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    this = (std::__shared_weak_count **)v1;
  }
  else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
  {
    __break(0xC471u);
  }
  operator delete(this);
}

uint64_t ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t __cxx_global_var_init()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

void BBUEURLoader::BBUEURLoader(BBUEURLoader *this, BBUFeedback *a2)
{
  BBULoader::BBULoader(this, a2);
  *(void *)int v3 = &unk_26CEC92D8;
  *((unsigned char *)v3 + 24) = 0;
  uint64_t v4 = (capabilities::updater *)capabilities::radio::chipID(v3);
  *((_DWORD *)this + 7) = v4;
  unsigned int v5 = (capabilities::updater *)capabilities::updater::loaderConnectAttempts(v4);
  *((_DWORD *)this + 8) = v5;
  *((_DWORD *)this + 9) = capabilities::updater::loaderCommandTimeout(v5);
  *((unsigned char *)this + 40) = 0;
}

uint64_t BBUEURLoader::getCommandTimeout(BBUEURLoader *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t BBUEURLoader::connect(uint64_t a1)
{
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v2 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
    _BBULog(9, 0, v2, "", "Connecting\n", v3, v4, v5, v19);
  }
LABEL_5:
  BBUFeedback::handleBeginQuickStep(*(BBUFeedback **)(a1 + 8), "Connecting to Loader");
  if (!*(_DWORD *)(a1 + 32))
  {
LABEL_17:
    uint64_t v13 = 3;
    goto LABEL_18;
  }
  int v6 = 0;
  while (1)
  {
    if ((ETLDLOADCommandCreateParametersRequest() & 1) == 0)
    {
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEURLoader.cpp", 0x42u, (ctu::LogMessageBuffer *)"Assertion failure(success)", v16, v17, v18, v19);
    }
    int v7 = ETLDLOADCommandSend();
    HDLCFrameFree();
    if (v7)
    {
      if (ETLDLOADCommandReceiveSmallWithFlags())
      {
        int v8 = ETLDLOADCommandParseParametersResponse();
        HDLCFrameFree();
        if (v8) {
          break;
        }
      }
    }
    if (++v6 >= *(_DWORD *)(a1 + 32)) {
      goto LABEL_17;
    }
  }
  *(_DWORD *)(a1 + 16) = 43690;
  *(_DWORD *)(a1 + 20) = 170;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) != 0) {
      goto LABEL_14;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) != 0)
    {
LABEL_14:
      if (gBBULogVerbosity >= 1)
      {
        int v9 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
        _BBULog(9, 1, v9, "", "Max write size %u, Protocol version %u\n", v10, v11, v12, *(_DWORD *)(a1 + 16));
      }
    }
  }
  uint64_t v13 = 0;
LABEL_18:
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v13);
  return v13;
}

void sub_21DE965B4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUEURLoader::getVersion(BBUFeedback **a1, uint64_t a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (!a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 75, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEURLoader.cpp", 0x77u, (ctu::LogMessageBuffer *)"Assertion failure(version && \"Invalid BBU loader verson.\")", v18, v19, v20, v25);
  }
  BBUFeedback::handleBeginQuickStep(a1[1], "Getting Version");
  int v28 = -1431655766;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  *(_OWORD *)__s = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  if ((ETLDLOADCommandCreateVersionRequest() & 1) == 0)
  {
    uint64_t v21 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v21, 75, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEURLoader.cpp", 0x89u, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Unable to load command to create BBU loader version.\")", v22, v23, v24, v25);
  }
  ETLDLOADCommandSend();
  if (ETLDLOADCommandReceiveSmallWithFlags())
  {
    int v5 = ETLDLOADCommandParseVersionResponse();
    if (v5) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = 3;
    }
  }
  else
  {
    int v5 = 0;
    uint64_t v6 = 3;
  }
  HDLCFrameFree();
  HDLCFrameFree();
  (*(void (**)(BBUFeedback *, uint64_t))(*(void *)a1[1] + 24))(a1[1], v6);
  if (v5)
  {
    size_t v7 = strlen(__s);
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    int v8 = (void *)v7;
    if (v7 >= 0x17)
    {
      uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v10 = v7 | 7;
      }
      uint64_t v11 = v10 + 1;
      int v9 = (void **)operator new(v10 + 1);
      __dst[1] = v8;
      unint64_t v27 = v11 | 0x8000000000000000;
      __dst[0] = v9;
    }
    else
    {
      HIBYTE(v27) = v7;
      int v9 = __dst;
      if (!v7)
      {
LABEL_17:
        *((unsigned char *)v8 + (void)v9) = 0;
        *a3 = BBULoaderVersion::createFromVersionString((uint64_t)__dst);
        if (SHIBYTE(v27) < 0) {
          operator delete(__dst[0]);
        }
        goto LABEL_19;
      }
    }
    memcpy(v9, __s, (size_t)v8);
    goto LABEL_17;
  }
LABEL_19:
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) == 0) {
      return v6;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) == 0) {
      return v6;
    }
  }
  if (gBBULogVerbosity >= 1)
  {
    uint64_t v12 = (const char *)(*((uint64_t (**)(BBUFeedback **))*a1 + 9))(a1);
    _BBULog(9, 1, v12, "", "Version is %s\n", v13, v14, v15, (char)__s);
  }
  return v6;
}

void sub_21DE96904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBUEURLoader::enableStepThroughImages(uint64_t this)
{
  *(unsigned char *)(this + 40) = 1;
  return this;
}

uint64_t BBUEURLoader::load(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEURLoader.cpp", 0xB7u, (ctu::LogMessageBuffer *)"Assertion failure(source && \"BBU Data source problem.\")", v33, v34, v35, v36);
LABEL_39:
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 32))(a3);
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3);
  size_t v7 = operator new[](*(unsigned int *)(a1 + 16));
  uint64_t v8 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v8 + 44)) {
    *(_DWORD *)(v8 + 40) = 1;
  }
  BYTE7(v39) = 7;
  strcpy((char *)__p, "Loading");
  (*(void (**)(uint64_t, void **, uint64_t, void))(*(void *)v8 + 32))(v8, __p, v5, v6 + v5);
  if (SBYTE7(v39) < 0)
  {
    operator delete(__p[0]);
    v43[0] = -1431655766;
    unsigned int v24 = *(_DWORD *)(a1 + 16);
    if (v24 >= v6) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v24;
    }
    if (v10) {
      goto LABEL_9;
    }
  }
  else
  {
    v43[0] = -1431655766;
    unsigned int v9 = *(_DWORD *)(a1 + 16);
    if (v9 >= v6) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v9;
    }
    if (v10)
    {
LABEL_9:
      uint64_t v11 = 0;
      double v12 = 1.0 / (double)v6;
      LODWORD(v13) = v5;
      unsigned int v37 = v6;
      while (1)
      {
        if ((*(unsigned int (**)(uint64_t, void *, uint64_t, int *, uint64_t))(*(void *)a3 + 16))(a3, v7, v10, v43, v11))
        {
          exception = __cxa_allocate_exception(0x210uLL);
          _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEURLoader.cpp", 0xF1u, (ctu::LogMessageBuffer *)"Assertion failure(ret == kBBUReturnSuccess)", v27, v28, v29, v36);
          goto LABEL_39;
        }
        char v42 = -86;
        __int16 v41 = -21846;
        *(_OWORD *)std::string __p = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        if ((ETLDLOADCommandCreateWriteRequest() & 1) == 0)
        {
          exception = __cxa_allocate_exception(0x210uLL);
          _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEURLoader.cpp", 0x100u, (ctu::LogMessageBuffer *)"Assertion failure(success)", v30, v31, v32, v36);
          goto LABEL_39;
        }
        if (ETLDLOADCommandSend()
          && ETLDLOADCommandReceiveSmallWithFlags()
          && ETLDLOADCommandParseACKNAKResponse())
        {
          if (v42)
          {
            uint64_t v15 = 0;
            char v16 = 1;
          }
          else
          {
            char v17 = ETLDLOADGetNAKReasonAsString();
            if (gBBULogMaskGet(void)::once == -1)
            {
              char v16 = 0;
              uint64_t v15 = 12;
              if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) != 0) {
                goto LABEL_27;
              }
            }
            else
            {
              char v23 = v17;
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
              char v17 = v23;
              char v16 = 0;
              uint64_t v15 = 12;
              if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) != 0)
              {
LABEL_27:
                if (gBBULogVerbosity >= 1)
                {
                  char v18 = v17;
                  uint64_t v19 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
                  _BBULog(9, 1, v19, "", "Response was NAK, Reason %s(%u)\n", v20, v21, v22, v18);
                  char v16 = 0;
                }
              }
            }
          }
        }
        else
        {
          char v16 = 0;
          uint64_t v15 = 3;
        }
        HDLCFrameFree();
        HDLCFrameFree();
        if (v16)
        {
          uint64_t v13 = (v13 + v10);
          uint64_t v11 = (v11 + v10);
          if ((v13 - v5) > 0x8000)
          {
            (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), v13);
            BBUFeedback::updateProgressBarItem(*(BBUFeedback **)(a1 + 8), (double)v11 * v12);
            LODWORD(v5) = v13;
          }
          v43[0] = -1431655766;
          unsigned int v14 = *(_DWORD *)(a1 + 16);
          uint64_t v10 = v14 >= v37 - v11 ? v37 - v11 : v14;
          if (v10) {
            continue;
          }
        }
        goto LABEL_36;
      }
    }
  }
  uint64_t v15 = 0;
LABEL_36:
  operator delete[](v7);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), v15);
  return v15;
}

void sub_21DE96DF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  __cxa_free_exception(v24);
  _Unwind_Resume(a1);
}

uint64_t BBUEURLoader::go(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BBUFeedback::handleBeginQuickStep(*(BBUFeedback **)(a1 + 8), "Launching");
  (*(void (**)(uint64_t))(*(void *)a3 + 32))(a3);
  if ((ETLDLOADCommandCreateGoRequest() & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEURLoader.cpp", 0x14Fu, (ctu::LogMessageBuffer *)"Assertion failure(success)", v7, v8, v9, v10);
  }
  if (ETLDLOADCommandSend() && ETLDLOADCommandReceiveSmallWithFlags()) {
    ETLDLOADCommandParseACKNAKResponse();
  }
  HDLCFrameFree();
  HDLCFrameFree();
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), 0);
  BBUFeedback::endProgressBarItem(*(BBUFeedback **)(a1 + 8));
  return 0;
}

void sub_21DE97060(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUEURLoader::queryChipInfo(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if ((ETLDLOADCommandCreateSerialNumberRequest() & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 100, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEURLoader.cpp", 0x184u, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Unable to load command to create serial number request.\")", v17, v18, v19, v20);
  }
  if (ETLDLOADCommandSend() && ETLDLOADCommandReceiveSmallWithFlags())
  {
    *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[14] = v5;
    v21[15] = v5;
    v21[12] = v5;
    v21[13] = v5;
    v21[10] = v5;
    v21[11] = v5;
    v21[8] = v5;
    v21[9] = v5;
    v21[6] = v5;
    v21[7] = v5;
    v21[4] = v5;
    v21[5] = v5;
    v21[2] = v5;
    v21[3] = v5;
    v21[0] = v5;
    v21[1] = v5;
    if (ETLDLOADCommandParseSerialNumberResponse())
    {
      uint64_t v6 = 357913941;
      char v7 = *(unsigned char *)(a1 + 24);
      uint64_t v8 = (unsigned __int8 *)v21;
      do
      {
        if (v7) {
          break;
        }
        int v9 = *v8++;
        char v7 = v9 != 0;
        *(unsigned char *)(a1 + 24) = v9 != 0;
        --v6;
      }
      while (v6);
      char v10 = BBUEURPersonalizationParameters::EURSerialNumber::createFromSerialNumber((BBUEURPersonalizationParameters::EURSerialNumber *)v21, (const unsigned __int8 *)0xAAAAAAAALL);
      uint64_t v11 = BBUEURPersonalizationParameters::EURChipID::createFromChipID((BBUEURPersonalizationParameters::EURChipID *)*(unsigned int *)(a1 + 28));
      double v12 = v11;
      if (v10 && v11)
      {
        (*(void (**)(void *, void *))(*a3 + 16))(a3, v10);
        uint64_t v13 = a3[2];
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
        uint64_t v14 = 0;
        a3[2] = v12;
        goto LABEL_19;
      }
      if (v10) {
        (*(void (**)(void *))(*v10 + 8))(v10);
      }
      if (v12) {
        (*(void (**)(void *))(*v12 + 8))(v12);
      }
    }
    uint64_t v14 = 3;
LABEL_19:
    HDLCFrameFree();
    goto LABEL_20;
  }
  uint64_t v14 = 3;
LABEL_20:
  HDLCFrameFree();
  return v14;
}

void sub_21DE972EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUEURLoader::isFused(BBUEURLoader *this)
{
  return *((unsigned __int8 *)this + 24);
}

const char *BBUEURLoader::getDebugName(BBUEURLoader *this)
{
  return "BBUEURLoader";
}

void BBUICE16Loader::BBUICE16Loader(BBUICE16Loader *this, BBUFeedback *a2)
{
  BBUICELoader::BBUICELoader(this, a2);
  *uint64_t v3 = &unk_26CEC9358;
  *(void *)((char *)v3 + 44) = 0x8000001388;
  v3[7] = 0;
  uint64_t v4 = v3 + 7;
  v3[8] = 0;
  v3[9] = 0;
  long long v5 = operator new(0x80uLL);
  void *v4 = v5;
  _OWORD *v5 = 0u;
  v5[1] = 0u;
  uint64_t v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  *((void *)this + 8) = v5 + 8;
  *((void *)this + 9) = v5 + 8;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 20) = 4096;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  uint64_t v6 = (char *)operator new(0x1000uLL);
  *((void *)this + 14) = v6;
  char v7 = v6 + 4096;
  *((void *)this + 16) = v6 + 4096;
  bzero(v6, 0x1000uLL);
  *((void *)this + 15) = v7;
  if ((TelephonyUtilRingBufferInitialize() & 1) == 0) {
    BBUFeedback::handleComment(*((BBUFeedback **)this + 1), "failed initializing ring buffer");
  }
}

void sub_21DE97408(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (!*v2) {
    _Unwind_Resume(exception_object);
  }
  *(void *)(v1 + 64) = v4;
  operator delete(v4);
  _Unwind_Resume(exception_object);
}

uint64_t BBUICE16Loader::connect(uint64_t a1)
{
  return 0;
}

uint64_t BBUICE16Loader::getVersion(uint64_t a1, uint64_t a2, void *a3)
{
  BBUFeedback::handleBeginQuickStep(*(BBUFeedback **)(a1 + 8), "Getting Version");
  if (!a3)
  {
    uint64_t v8 = 2;
    goto LABEL_21;
  }
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v25[7] = v5;
  v25[8] = v5;
  v25[5] = v5;
  v25[6] = v5;
  v25[3] = v5;
  v25[4] = v5;
  v25[1] = v5;
  v25[2] = v5;
  long long v24 = v5;
  v25[0] = v5;
  *(_OWORD *)std::string __p = v5;
  long long v23 = v5;
  long long v20 = v5;
  long long v21 = v5;
  long long v18 = v5;
  long long v19 = v5;
  long long v17 = v5;
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v17);
  std::ostream::operator<<();
  if ((BYTE8(v24) & 0x10) != 0)
  {
    uint64_t v9 = v24;
    if ((unint64_t)v24 < *((void *)&v21 + 1))
    {
      *(void *)&long long v24 = *((void *)&v21 + 1);
      uint64_t v9 = *((void *)&v21 + 1);
    }
    char v10 = (const void *)v21;
    size_t v6 = v9 - v21;
    if ((unint64_t)(v9 - v21) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_23;
    }
  }
  else
  {
    if ((BYTE8(v24) & 8) == 0)
    {
      size_t v6 = 0;
      HIBYTE(v16) = 0;
      char v7 = __dst;
      goto LABEL_16;
    }
    char v10 = (const void *)*((void *)&v19 + 1);
    size_t v6 = *((void *)&v20 + 1) - *((void *)&v19 + 1);
    if (*((void *)&v20 + 1) - *((void *)&v19 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_23:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v6 >= 0x17)
  {
    uint64_t v11 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v11 = v6 | 7;
    }
    uint64_t v12 = v11 + 1;
    char v7 = (void **)operator new(v11 + 1);
    __dst[1] = (void *)v6;
    unint64_t v16 = v12 | 0x8000000000000000;
    __dst[0] = v7;
  }
  else
  {
    HIBYTE(v16) = v6;
    char v7 = __dst;
    if (!v6) {
      goto LABEL_16;
    }
  }
  memmove(v7, v10, v6);
LABEL_16:
  *((unsigned char *)v7 + v6) = 0;
  *a3 = BBULoaderVersion::createFromVersionString((uint64_t)__dst);
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst[0]);
  }
  *(void *)&long long v17 = *MEMORY[0x263F8C2B8];
  uint64_t v13 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)&v17 + *(void *)(v17 - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  *(void *)&long long v18 = v13;
  *((void *)&v18 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x223C1DDF0](v25);
  uint64_t v8 = 0;
LABEL_21:
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), v8);
  return v8;
}

void sub_21DE97790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
    _Unwind_Resume(a1);
  }
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C328] + 104;
  *(void *)(a1 + 128) = MEMORY[0x263F8C328] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x263F8C328] + 64;
  *(void *)(a1 + 16) = MEMORY[0x263F8C328] + 64;
  long long v5 = (void *)MEMORY[0x263F8C2B8];
  uint64_t v6 = *(void *)(MEMORY[0x263F8C2B8] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x263F8C2B8] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x263F8C328] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_21DE97A8C(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x223C1DDF0](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B8];
  uint64_t v3 = *MEMORY[0x263F8C2B8];
  *(void *)a1 = *MEMORY[0x263F8C2B8];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x223C1DDF0](a1 + 128);
  return a1;
}

uint64_t BBUICE16Loader::queryChipInfo(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  unsigned int v43 = 0;
  uint64_t v6 = (unsigned __int8 *)operator new(0x60uLL);
  *(_OWORD *)uint64_t v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *, uint64_t, unsigned int *, void))(a2 + 40);
  if (!v7 || ((char v8 = v7(a2, 5, v6, 60, &v43, 0), v43 > 0x3B) ? (v9 = v8) : (v9 = 0), (v9 & 1) == 0))
  {
    uint64_t v22 = 3;
    goto LABEL_52;
  }
  uint64_t v10 = BBUICEPersonalizationParameters::ICEChipID::createFromChipID((BBUICEPersonalizationParameters::ICEChipID *)v6[2]);
  uint64_t v11 = *(void *)(a3 + 16);
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  *(void *)(a3 + 16) = v10;
  uint64_t v12 = BBUICEPersonalizationParameters::ICESerialNumber::createFromSerialNumber(v6 + 10, (const unsigned __int8 *)0x60);
  (*(void (**)(uint64_t, void *))(*(void *)a3 + 16))(a3, v12);
  uint64_t v13 = operator new(0x10uLL);
  *uint64_t v13 = &unk_26CECFF28;
  v13[1] = 0;
  v13[1] = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v6 + 22, 32);
  (*(void (**)(uint64_t, void *))(*(void *)a3 + 24))(a3, v13);
  if ((void)v44 == *(void *)(v6 + 22)
    && *((void *)&v44 + 1) == *(void *)(v6 + 30)
    && (void)v45 == *(void *)(v6 + 38)
    && *((void *)&v45 + 1) == *(void *)(v6 + 46))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      int v17 = 1;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) == 0) {
        goto LABEL_27;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      int v17 = 1;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) == 0) {
        goto LABEL_27;
      }
    }
    if (gBBULogVerbosity >= 1)
    {
      long long v23 = (const char *)(*(uint64_t (**)(void *))(*a1 + 72))(a1);
      _BBULog(9, 1, v23, "", "Detect as unfused BB\n", v24, v25, v26, v38);
    }
  }
  else
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      int v17 = 3;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) == 0) {
        goto LABEL_27;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      int v17 = 3;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) == 0) {
        goto LABEL_27;
      }
    }
    if (gBBULogVerbosity >= 1)
    {
      long long v18 = (const char *)(*(uint64_t (**)(void *))(*a1 + 72))(a1);
      _BBULog(9, 1, v18, "", "Detect as fused BB\n", v19, v20, v21, v38);
    }
  }
LABEL_27:
  int v27 = -559030611;
  *(_DWORD *)(a3 + 88) = v17;
  uint64_t v28 = (BBUFeedback *)a1[1];
  uint64_t v29 = *(void *)(a3 + 16);
  int v30 = -559030611;
  if (v29) {
    int v30 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 24))(v29);
  }
  uint64_t v31 = *(void *)(a3 + 32);
  if (!v31)
  {
    uint64_t v33 = "failed";
    uint64_t v34 = *(void *)(a3 + 40);
    if (v34) {
      goto LABEL_38;
    }
LABEL_43:
    uint64_t v35 = "failed";
    uint64_t v36 = *(void *)(a3 + 24);
    if (!v36) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }
  uint64_t v32 = v41;
  (*(void (**)(void **__return_ptr, void))(*(void *)v31 + 24))(v41, *(void *)(a3 + 32));
  if (v42 < 0) {
    uint64_t v32 = (void **)v41[0];
  }
  if (BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS == -1)
  {
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1) {
      goto LABEL_34;
    }
  }
  else
  {
    dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1) {
      goto LABEL_34;
    }
  }
  dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
LABEL_34:
  if (BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS) {
    uint64_t v33 = (const char *)v32;
  }
  else {
    uint64_t v33 = "<< SNUM >>";
  }
  uint64_t v34 = *(void *)(a3 + 40);
  if (!v34) {
    goto LABEL_43;
  }
LABEL_38:
  uint64_t v35 = (const char *)__p;
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v34 + 24))(__p, v34);
  if (v40 < 0) {
    uint64_t v35 = (const char *)__p[0];
  }
  uint64_t v36 = *(void *)(a3 + 24);
  if (!v36) {
    goto LABEL_45;
  }
LABEL_44:
  int v27 = (*(uint64_t (**)(uint64_t))(*(void *)v36 + 24))(v36);
LABEL_45:
  BBUFeedback::handleComment(v28, "CHIPID=0x%x SNUM=0x%s, PKHASH=0x%s CERTID=0x%x\n", v30, v33, v35, v27);
  if (v34 && v40 < 0) {
    operator delete(__p[0]);
  }
  if (v31 && v42 < 0) {
    operator delete(v41[0]);
  }
  uint64_t v22 = 0;
LABEL_52:
  operator delete(v6);
  return v22;
}

void sub_21DE9812C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (v26)
  {
    if (a25 < 0)
    {
      operator delete(__p);
      operator delete(v25);
      _Unwind_Resume(a1);
    }
  }
  operator delete(v25);
  _Unwind_Resume(a1);
}

uint64_t BBUICE16Loader::load(BBUFeedback **a1, void *a2, const void *a3)
{
  if (!a2 || !a3)
  {
    BBUFeedback::handleComment(a1[1], "invalid arguments transport:  %p, updateSource:  %p", a2, a3);
    return 2;
  }
  uint64_t v19 = 0;
  int v18 = -1;
  uint64_t v6 = (*(uint64_t (**)(const void *))(*(void *)a3 + 24))(a3);
  BBUFeedback::handleComment(a1[1], "Send PSI-RAM (%d bytes)", v6);
  uint64_t v7 = operator new[](v6);
  if ((*(unsigned int (**)(const void *, void *, uint64_t, char *, void))(*(void *)a3 + 16))(a3, v7, v6, (char *)&v19 + 4, 0))
  {
    BOOL v8 = 0;
  }
  else
  {
    BOOL v8 = HIDWORD(v19) == v6;
  }
  if (!v8)
  {
    BBUFeedback::handleComment(a1[1], "Error: copying PSI-RAM buffer.");
    operator delete[](v7);
    return 1;
  }
  uint64_t v10 = (uint64_t (*)(void *, void *, uint64_t, uint64_t *, uint64_t, int *, void))a2[4];
  if (v10)
  {
    int v11 = v10(a2, v7, v6, &v19, 10000, &v18, 0);
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_11;
    }
  }
  else
  {
    int v11 = 0;
    if (gBBULogMaskGet(void)::once == -1)
    {
LABEL_11:
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) != 0) {
        goto LABEL_12;
      }
      goto LABEL_16;
    }
  }
  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 2) != 0)
  {
LABEL_12:
    if (gBBULogVerbosity >= 1)
    {
      uint64_t v12 = (const char *)(*((uint64_t (**)(BBUFeedback **))*a1 + 9))(a1);
      unint64_t v16 = "failure";
      if (v11) {
        unint64_t v16 = "success";
      }
      _BBULog(9, 1, v12, "", "SendImage returned %s, amountWritten = %u, status = %u\n", v13, v14, v15, (char)v16);
    }
  }
LABEL_16:
  operator delete[](v7);
  if (v19 == v6) {
    int v17 = v11;
  }
  else {
    int v17 = 0;
  }
  if (v17 == 1 && (v18 == 1 || v18 == 16))
  {
    BBUFeedback::handleComment(a1[1], "Sent PSI sucessfully!");
    return 0;
  }
  else
  {
    BBUFeedback::handleComment(a1[1], "Failed to send PSI!");
    return 3;
  }
}

uint64_t BBUICE16Loader::go()
{
  return 0;
}

void BBUICE16Loader::~BBUICE16Loader(BBUICE16Loader *this)
{
  *(void *)this = &unk_26CEC9358;
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    *((void *)this + 15) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 7);
  if (v3)
  {
    *((void *)this + 8) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26CEC9358;
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    *((void *)this + 15) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 7);
  if (v3)
  {
    *((void *)this + 8) = v3;
    operator delete(v3);
  }

  operator delete(this);
}

uint64_t BBUICELoader::isFused(BBUICELoader *this)
{
  return *((unsigned __int8 *)this + 24);
}

const char *BBUICE16Loader::getDebugName(BBUICE16Loader *this)
{
  return "BBUICE16Loader";
}

uint64_t RecipeUtil::uninit(RecipeUtil *this)
{
  for (uint64_t i = (void **)*((void *)this + 9); i; uint64_t i = (void **)*((void *)this + 9))
  {
    uint64_t v12 = *i;
    *((void *)this + 9) = i[1];
    if (v12) {
      free(v12);
    }
    operator delete(i);
  }
  uint64_t v3 = (void *)*((void *)this + 13);
  if (v3)
  {
    operator delete[](v3);
    *((void *)this + 13) = 0;
  }
  long long v5 = (void **)((char *)this + 120);
  uint64_t v4 = (void *)*((void *)this + 15);
  *((void *)this + 17) = 0;
  if (v4)
  {
    if (!*((void *)this + 16)) {
      goto LABEL_9;
    }
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      free(*(void **)(*((void *)this + 15) + 8 * v6));
      unint64_t v6 = v7++;
    }
    while (*((void *)this + 16) > v6);
    uint64_t v4 = *v5;
    if (*v5) {
LABEL_9:
    }
      operator delete[](v4);
    void *v5 = 0;
    *((void *)this + 16) = 0;
  }
  uint64_t v10 = (void *)*((void *)this + 18);
  char v9 = (void *)((char *)this + 144);
  BOOL v8 = v10;
  if (v10)
  {
    operator delete[](v8);
    *char v9 = 0;
    v9[1] = 0;
  }
  return 0;
}

uint64_t RecipeUtil::_parseVariables(RecipeUtil *this)
{
  uint64_t v1 = 2147483656;
  uint64_t v2 = *(long long **)this;
  if (!*(void *)this) {
    return v1;
  }
  unint64_t v4 = *((void *)this + 1);
  if (!v4) {
    return v1;
  }
  uint64_t v5 = 268435461;
  unint64_t v6 = v4 - 54;
  if (v4 < 0x36) {
    return 268435461;
  }
  long long v8 = v2[1];
  long long v7 = v2[2];
  long long v9 = *v2;
  *(void *)((char *)this + 62) = *(void *)((char *)v2 + 46);
  *((_OWORD *)this + 2) = v8;
  *((_OWORD *)this + 3) = v7;
  *((_OWORD *)this + 1) = v9;
  if (*((_DWORD *)this + 4)) {
    return 2147483659;
  }
  if (v6 < 8)
  {
LABEL_37:
    if (v6)
    {
      uint64_t v5 = 2147483650;
      goto LABEL_46;
    }
    return 0;
  }
  uint64_t v10 = (unsigned int *)((char *)v2 + 54);
  while (2)
  {
    uint64_t v11 = v10[1];
    if (!v11)
    {
      uint64_t v5 = 2147483652;
      goto LABEL_46;
    }
    uint64_t v12 = v10 + 2;
    v6 -= 8;
    switch(*v10)
    {
      case 1u:
        if (*((void *)this + 9))
        {
          uint64_t v5 = 2147483657;
        }
        else
        {
          uint64_t v13 = operator new(0x10uLL);
          *((void *)this + 9) = v13;
          unsigned int v14 = v10[1];
          if (!v14) {
            goto LABEL_9;
          }
          uint64_t v15 = v13;
          unsigned int v16 = 0;
          while (v6 >= 0xC)
          {
            unint64_t v19 = v12[2];
            if (v6 < v19) {
              break;
            }
            size_t v20 = v19 + 12;
            uint64_t v21 = malloc(v19 + 12);
            *uint64_t v15 = v21;
            if (!v21)
            {
              uint64_t v5 = 2147483653;
              goto LABEL_46;
            }
            memcpy(v21, v12, v20);
            uint64_t v22 = v12[2];
            if (v16 < v14 - 1)
            {
              int v17 = operator new(0x10uLL);
              int v18 = v17;
            }
            else
            {
              int v17 = 0;
              int v18 = v15;
            }
            uint64_t v12 = (unsigned int *)((char *)v12 + v22 + 12);
            v6 -= v22 + 12;
            v15[1] = v17;
            ++v16;
            uint64_t v15 = v18;
            if (v14 == v16) {
              goto LABEL_9;
            }
          }
        }
        goto LABEL_46;
      case 2u:
        *((void *)this + 14) = v11;
        unint64_t v23 = 52 * v11;
        BOOL v24 = v6 >= v23;
        v6 -= v23;
        if (!v24) {
          goto LABEL_46;
        }
        if (*((void *)this + 13)) {
          goto LABEL_43;
        }
        uint64_t v25 = operator new[](52 * v11);
        *((void *)this + 13) = v25;
        memcpy(v25, v10 + 2, 52 * v11);
        uint64_t v12 = (unsigned int *)((char *)v12 + v23);
        goto LABEL_9;
      case 3u:
        if (v6 < 8) {
          goto LABEL_46;
        }
        if (*((void *)this + 15)) {
          goto LABEL_43;
        }
        uint64_t v26 = operator new[](8 * v11);
        unint64_t v27 = 0;
        *((void *)this + 15) = v26;
        while (1)
        {
          if (v6 < 8) {
            goto LABEL_46;
          }
          size_t v28 = 8 * v12[1] + 8;
          *(void *)(*((void *)this + 15) + 8 * v27) = malloc(v28);
          uint64_t v29 = *(void **)(*((void *)this + 15) + 8 * v27);
          if (!v29) {
            break;
          }
          memcpy(v29, v12, v28);
          uint64_t v12 = (unsigned int *)((char *)v12 + v28);
          v6 -= v28;
          ++v27;
          unint64_t v30 = v10[1];
          if (v27 >= v30)
          {
            *((void *)this + 16) = v30;
            goto LABEL_9;
          }
        }
        uint64_t v5 = 2147483662;
        goto LABEL_46;
      case 4u:
        BOOL v24 = v6 >= 8 * v11;
        v6 -= 8 * v11;
        if (!v24) {
          goto LABEL_46;
        }
        if (!*((void *)this + 18))
        {
          uint64_t v31 = operator new[](8 * v11);
          *((void *)this + 18) = v31;
          memcpy(v31, v10 + 2, 8 * v11);
          v12 += 2 * v11;
          *((void *)this + 19) = v11;
LABEL_9:
          uint64_t v10 = v12;
          if (v6 <= 7) {
            goto LABEL_37;
          }
          continue;
        }
LABEL_43:
        uint64_t v5 = 2147483656;
LABEL_46:
        RecipeUtil::uninit(this);
        return v5;
      default:
        uint64_t v5 = 2147483669;
        goto LABEL_46;
    }
  }
}

void BBUEUR13FirmwareVersion::BBUEUR13FirmwareVersion(BBUEUR13FirmwareVersion *this)
{
  uint64_t v2 = (const void *)BBUEUR13FirmwareVersion::kFirmwarePrefix;
  size_t v3 = strlen((const char *)BBUEUR13FirmwareVersion::kFirmwarePrefix);
  if (v3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v4 = v3;
  if (v3 >= 0x17)
  {
    uint64_t v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v6 = v3 | 7;
    }
    uint64_t v7 = v6 + 1;
    p_dst = (long long *)operator new(v6 + 1);
    *((void *)&__dst + 1) = v4;
    unint64_t v11 = v7 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_8;
  }
  HIBYTE(v11) = v3;
  p_dst = &__dst;
  if (v3) {
LABEL_8:
  }
    memmove(p_dst, v2, v4);
  *((unsigned char *)p_dst + v4) = 0;
  *(void *)this = &unk_26CECB2B8;
  *((_DWORD *)this + 5) = -1;
  *(_OWORD *)((char *)this + 24) = 0u;
  long long v8 = (std::string *)((char *)this + 72);
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  if (SHIBYTE(v11) < 0)
  {
    long long v9 = (void *)__dst;
    std::string::__init_copy_ctor_external(v8, (const std::string::value_type *)__dst, *((std::string::size_type *)&__dst + 1));
    *((_DWORD *)this + 4) = 0;
    *((void *)this + 1) = 0;
    operator delete(v9);
  }
  else
  {
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = __dst;
    *((void *)this + 11) = v11;
    *((void *)this + 1) = 0;
    *((_DWORD *)this + 4) = 0;
  }
  *(void *)this = &unk_26CEC93D8;
}

void sub_21DE98A60(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 71) < 0)
  {
    operator delete(*(void **)(v1 + 48));
    if ((*(char *)(v1 + 47) & 0x80000000) == 0)
    {
LABEL_3:
      operator delete(v2);
      _Unwind_Resume(a1);
    }
  }
  else if ((*(char *)(v1 + 47) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v3);
  operator delete(v2);
  _Unwind_Resume(a1);
}

void BBUEUR13FirmwareVersion::~BBUEUR13FirmwareVersion(void **this)
{
  *this = &unk_26CECB2B8;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 47) & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      operator delete(this[3]);
      return;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if (*((char *)this + 47) < 0) {
    goto LABEL_7;
  }
}

{
  BBUEUR13FirmwareVersion *v2;
  uint64_t vars8;

  *this = &unk_26CECB2B8;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 47) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if ((*((char *)this + 47) & 0x80000000) == 0)
  {
LABEL_4:
    uint64_t v2 = (BBUEUR13FirmwareVersion *)this;
    goto LABEL_6;
  }
LABEL_9:
  operator delete(this[3]);
  uint64_t v2 = (BBUEUR13FirmwareVersion *)this;

LABEL_6:
  operator delete(v2);
}

unint64_t BBUEUR13FirmwareVersion::getFirmwarePrefix@<X0>(void *a1@<X8>)
{
  size_t v3 = (const void *)BBUEUR13FirmwareVersion::kFirmwarePrefix;
  unint64_t result = strlen((const char *)BBUEUR13FirmwareVersion::kFirmwarePrefix);
  if (result >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = result;
  if (result >= 0x17)
  {
    uint64_t v6 = (result & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((result | 7) != 0x17) {
      uint64_t v6 = result | 7;
    }
    uint64_t v7 = v6 + 1;
    long long v8 = operator new(v6 + 1);
    a1[1] = v5;
    a1[2] = v7 | 0x8000000000000000;
    *a1 = v8;
    a1 = v8;
  }
  else
  {
    *((unsigned char *)a1 + 23) = result;
    if (!result)
    {
      *(unsigned char *)a1 = 0;
      return result;
    }
  }
  unint64_t result = (unint64_t)memmove(a1, v3, v5);
  *((unsigned char *)a1 + v5) = 0;
  return result;
}

void BBUpdaterController::BBUpdaterController(BBUpdaterController *this, const void *a2)
{
  *(void *)this = &unk_26CEC9448;
  *((void *)this + 1) = a2;
  size_t v4 = (char *)operator new(0x1D0uLL);
  *((void *)v4 + 2) = this;
  *(void *)size_t v4 = &unk_26CEC9738;
  *((_DWORD *)v4 + 6) = 0;
  size_t v5 = (capabilities::updater *)capabilities::updater::repersonalizeLimitCount((capabilities::updater *)v4);
  *((_DWORD *)v4 + 7) = v5;
  *(void *)size_t v4 = &unk_26CEC9610;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 72) = 0u;
  *((_WORD *)v4 + 50) = 0;
  *(_OWORD *)(v4 + 120) = 0u;
  *(_OWORD *)(v4 + 136) = 0u;
  *(_OWORD *)(v4 + 152) = 0u;
  *(_OWORD *)(v4 + 168) = 0u;
  *(_OWORD *)(v4 + 184) = 0u;
  *(_OWORD *)(v4 + 200) = 0u;
  *(_OWORD *)(v4 + 216) = 0u;
  *(_OWORD *)(v4 + 232) = 0u;
  *(_OWORD *)(v4 + 248) = 0u;
  *((void *)v4 + 57) = 0;
  *(_OWORD *)(v4 + 104) = 0u;
  *(_OWORD *)(v4 + 264) = 0u;
  *(_OWORD *)(v4 + 296) = 0u;
  *(_OWORD *)(v4 + 328) = 0u;
  *(_OWORD *)(v4 + 344) = 0u;
  *(_OWORD *)(v4 + 360) = 0u;
  *(_OWORD *)(v4 + 376) = 0u;
  *(_OWORD *)(v4 + 392) = 0u;
  *(_OWORD *)(v4 + 408) = 0u;
  *(_OWORD *)(v4 + 424) = 0u;
  *(_OWORD *)(v4 + 440) = 0u;
  *(_OWORD *)(v4 + 312) = 0u;
  *(_OWORD *)(v4 + 280) = 0u;
  *((void *)v4 + 18) = &unk_26CEC9768;
  *((_OWORD *)v4 + 11) = 0u;
  *((_OWORD *)v4 + 12) = 0u;
  *((_OWORD *)v4 + 13) = 0u;
  *(void *)(v4 + 236) = 0;
  *(void *)(v4 + 252) = 0;
  *(void *)(v4 + 244) = 0;
  *((void *)v4 + 33) = 0;
  *((_DWORD *)v4 + 68) = 0;
  *((void *)v4 + 37) = 0;
  *((void *)v4 + 36) = 0;
  *((void *)v4 + 35) = &unk_26CEC9838;
  *(_OWORD *)(v4 + 312) = 0u;
  *(_OWORD *)(v4 + 328) = 0u;
  *(_OWORD *)(v4 + 344) = 0u;
  *(_OWORD *)(v4 + 372) = 0u;
  *(_OWORD *)(v4 + 388) = 0u;
  *(_OWORD *)(v4 + 404) = 0u;
  unint64_t v6 = capabilities::updater::EUICCAttemptCount(v5);
  if (HIDWORD(v6))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 11, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0xF7u, (ctu::LogMessageBuffer *)"Assertion failure(capabilities::updater::EUICCAttemptCount() <= std::numeric_limits<unsigned>::max() && \"capabilities::updater::EUICCAttemptCount() returns too large a value\")", v42, v43, v44, v73);
  }
  uint64_t v7 = (capabilities::updater *)capabilities::updater::EUICCAttemptCount((capabilities::updater *)v6);
  *((_DWORD *)v4 + 95) = v7;
  *(void *)(v4 + 388) = 0;
  long long v8 = (capabilities::updater *)capabilities::updater::intermittentFailureRetryCount(v7);
  *((_DWORD *)v4 + 98) = v8;
  long long v9 = (capabilities::updater *)capabilities::updater::intermittentFailureRetryCount(v8);
  uint64_t v10 = (capabilities::updater *)capabilities::updater::intermittentFailureRetryCount(v9);
  *((_DWORD *)v4 + 98) = v10;
  *((void *)v4 + 50) = 0;
  unint64_t v11 = (capabilities::updater *)capabilities::updater::intermittentFailureRetryCount(v10);
  *((_DWORD *)v4 + 101) = v11;
  uint64_t v12 = (capabilities::updater *)capabilities::updater::intermittentFailureRetryCount(v11);
  *((_DWORD *)v4 + 101) = v12;
  uint64_t v13 = (capabilities::updater *)capabilities::updater::intermittentFailureRetryCount(v12);
  unsigned int v14 = (capabilities::updater *)capabilities::updater::intermittentFailureRetryCount(v13);
  *((_DWORD *)v4 + 101) = v14;
  *(void *)(v4 + 412) = 0;
  uint64_t v15 = (capabilities::updater *)capabilities::updater::loaderConnectAttempts(v14);
  *((_DWORD *)v4 + 104) = v15;
  *((_DWORD *)v4 + 76) = 0;
  *((_DWORD *)v4 + 91) = 0;
  *(void *)(v4 + 428) = 0;
  unsigned int v16 = (capabilities::updater *)capabilities::updater::manifestCheckRetryCount(v15);
  *((_DWORD *)v4 + 108) = v16;
  *((void *)v4 + 55) = 0;
  *((_DWORD *)v4 + 111) = capabilities::updater::initialStagePingAttemptCount(v16);
  *((void *)v4 + 56) = 0;
  *((_DWORD *)v4 + 114) = 0;
  *((void *)v4 + 4) = 0x700000000;
  *(void *)(v4 + 92) = 0x700000000;
  v4[233] = 1;
  v4[369] = 1;
  *((void *)this + 2) = v4;
  int v17 = operator new(0x20uLL);
  *int v17 = &unk_26CEC9908;
  v17[1] = 0;
  void v17[2] = 0;
  v17[3] = v4;
  *((void *)this + 4) = 0;
  int v18 = (CFMutableDictionaryRef *)((char *)this + 32);
  *((void *)this + 3) = v17;
  *((void *)this + 5) = 0;
  CFAllocatorRef v19 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  *((void *)this + 6) = TelephonyBasebandCreateController();
  size_t v20 = (BBUFeedback *)operator new(0x128uLL);
  BBUFeedback::BBUFeedback(v20, a2);
  *((_DWORD *)v20 + 46) = 1;
  *((void *)v20 + 35) = 0;
  *((void *)v20 + 36) = 0;
  *((_OWORD *)v20 + 12) = 0u;
  *((_OWORD *)v20 + 13) = 0u;
  *((_OWORD *)v20 + 14) = 0u;
  *((_WORD *)v20 + 120) = 0;
  *(void *)size_t v20 = &unk_26CECABC0;
  *((void *)this + 7) = v20;
  *((void *)this + 8) = BBUCommunication::create(*((capabilities::updater **)this + 6));
  uint64_t v22 = (BBUPersonalizationParameters *)BBUInitializer::create(*((BBUInitializer **)this + 7), v21);
  *((void *)this + 10) = 0;
  *((void *)this + 9) = v22;
  *((void *)this + 11) = 0;
  BBUPersonalizationParameters::create(v22);
  *(_OWORD *)((char *)this + 104) = 0u;
  *((void *)this + 12) = v23;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_WORD *)this + 120) = 0;
  *((void *)this + 31) = 0;
  *((unsigned char *)this + 242) = 0;
  *((_DWORD *)this + 85) = 0;
  *((unsigned char *)this + 344) = 0;
  *((unsigned char *)this + 256) = 0;
  *(_OWORD *)((char *)this + 260) = 0u;
  *(_OWORD *)((char *)this + 276) = 0u;
  *(_OWORD *)((char *)this + 292) = 0u;
  *(_OWORD *)((char *)this + 308) = 0u;
  *(_OWORD *)((char *)this + 321) = 0u;
  *((void *)this + 44) = 0x900000000;
  Mutable = CFDictionaryCreateMutable(v19, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v25 = (const void *)*((void *)this + 4);
  *((void *)this + 4) = Mutable;
  if (v25)
  {
    CFRelease(v25);
    Mutable = *v18;
  }
  if (Mutable) {
    uint64_t v26 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
  }
  else {
    uint64_t v26 = 0;
  }
  if (!v26)
  {
    long long v45 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v45, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x4Fu, (ctu::LogMessageBuffer *)"Assertion failure(fOutput)", v46, v47, v48, (char)v45);
  }
  int valuePtr = -1431655766;
  if (capabilities::radio::vendor(Mutable) == 2) {
    int v27 = 2;
  }
  else {
    int v27 = 3;
  }
  int valuePtr = v27;
  CFNumberRef v28 = CFNumberCreate(v19, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef cf = v28;
  if (v28) {
    uint64_t v29 = ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get;
  }
  else {
    uint64_t v29 = 0;
  }
  if (!v29)
  {
    dispatch_queue_t v49 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v49, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x67u, (ctu::LogMessageBuffer *)"Assertion failure(v)", v50, v51, v52, (char)v49);
    goto LABEL_41;
  }
  CFDictionarySetValue(*v18, @"VendorID", v28);
  unint64_t v30 = (const void *)*MEMORY[0x263EFFB38];
  CFDictionarySetValue(*v18, @"done", (const void *)*MEMORY[0x263EFFB38]);
  CFDictionarySetValue(*v18, @"attemptedToFuse", v30);
  if (*((void *)this + 6)) {
    uint64_t v31 = ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get;
  }
  else {
    uint64_t v31 = 0;
  }
  if (!v31)
  {
    int v53 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v53, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x6Eu, (ctu::LogMessageBuffer *)"Assertion failure(fBasebandController)", v54, v55, v56, (char)v53);
    goto LABEL_41;
  }
  uint64_t v32 = *((void *)this + 7);
  if (!v32)
  {
    uint64_t v57 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v57, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x6Fu, (ctu::LogMessageBuffer *)"Assertion failure(fFeedback)", v58, v59, v60, (char)v57);
    goto LABEL_41;
  }
  if (!*((void *)this + 9))
  {
    int v61 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v61, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x70u, (ctu::LogMessageBuffer *)"Assertion failure(fInitializer)", v62, v63, v64, (char)v61);
    goto LABEL_41;
  }
  if (!*((void *)this + 12))
  {
    int v65 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v65, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x71u, (ctu::LogMessageBuffer *)"Assertion failure(fPersonalizationParameters)", v66, v67, v68, (char)v65);
    goto LABEL_41;
  }
  if (!*((void *)this + 2))
  {
    int v69 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v69, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x72u, (ctu::LogMessageBuffer *)"Assertion failure(fFSM)", v70, v71, v72, (char)v69);
LABEL_41:
  }
  *((void *)this + 29) = 0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  uint64_t v34 = *(void **)(v32 + 16);
  uint64_t v33 = v32 + 16;
  std::__tree<std::__value_type<BBUFeedback::ProgressBarStages,double>,std::__map_value_compare<BBUFeedback::ProgressBarStages,std::__value_type<BBUFeedback::ProgressBarStages,double>,std::less<BBUFeedback::ProgressBarStages>,true>,std::allocator<std::__value_type<BBUFeedback::ProgressBarStages,double>>>::destroy(v33 - 8, v34);
  *(void *)(v33 - 8) = v33;
  *(void *)uint64_t v33 = 0;
  *(void *)(v33 + 8) = 0;
  *(_DWORD *)(v33 + 24) = 0;
  *(void *)(v33 + 32) = 0;
  BBULoader::addProgressBarTimes(*((uint64_t ***)this + 7), v35);
  unsigned int v37 = BBUProgrammer::addProgressBarTimes(*((uint64_t ***)this + 7), v36);
  uint64_t v38 = *((void *)this + 2);
  long long v39 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v39)
  {
    atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(v38 + 32) = 0x700000000;
    ++*(_DWORD *)(v38 + 452);
    ++*(_DWORD *)(v38 + 124);
    if (!atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }
  else
  {
    *(void *)(v38 + 32) = 0x700000000;
    ++*(_DWORD *)(v38 + 452);
    ++*(_DWORD *)(v38 + 124);
  }
  capabilities::diag::supportedInterfaces((capabilities::diag *)v37);
  if (capabilities::diag::operator&()) {
    int v40 = 8;
  }
  else {
    int v40 = 4;
  }
  *((_DWORD *)this + 89) = v40;
  *((unsigned char *)this + 355) = 0;
  if (cf) {
    CFRelease(cf);
  }
}

void sub_21DE99424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, const void **a10, const void *a11)
{
  __cxa_free_exception(a9);
  ctu::cf::CFSharedRef<__CFNumber const>::~CFSharedRef(&a11);
  BBUpdaterController::DebugOptions::~DebugOptions(v19);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v18);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v17);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v16);
  uint64_t v21 = v11[12];
  v11[12] = 0;
  if (v21)
  {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    uint64_t v22 = v11[11];
    v11[11] = 0;
    if (!v22)
    {
LABEL_3:
      uint64_t v23 = *v15;
      *uint64_t v15 = 0;
      if (!v23) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v22 = v11[11];
    v11[11] = 0;
    if (!v22) {
      goto LABEL_3;
    }
  }
  (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  uint64_t v23 = *v15;
  *uint64_t v15 = 0;
  if (!v23)
  {
LABEL_4:
    uint64_t v24 = v11[9];
    v11[9] = 0;
    if (!v24) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  uint64_t v24 = v11[9];
  v11[9] = 0;
  if (!v24)
  {
LABEL_5:
    uint64_t v25 = v11[8];
    v11[8] = 0;
    if (!v25) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  (*(void (**)(uint64_t))(*(void *)v24 + 16))(v24);
  uint64_t v25 = v11[8];
  v11[8] = 0;
  if (!v25)
  {
LABEL_6:
    uint64_t v26 = v11[7];
    v11[7] = 0;
    if (!v26) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_13:
  (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  uint64_t v26 = v11[7];
  v11[7] = 0;
  if (!v26)
  {
LABEL_8:
    ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef(a10);
    ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(v14);
    ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef(v13);
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v12);
    _Unwind_Resume(a1);
  }
LABEL_7:
  (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  goto LABEL_8;
}

uint64_t ctu::SharedRef<__TelephonyBasebandControllerHandle_tag,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__TelephonyBasebandControllerHandle_tag>::get(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(std::__shared_weak_count **)(result + 8);
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
      return v1;
    }
  }
  return result;
}

const void **ctu::cf::CFSharedRef<__CFNumber const>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void BBUpdaterController::DebugOptions::~DebugOptions(void **this)
{
  if (*((char *)this + 87) < 0)
  {
    operator delete(this[8]);
    if ((*((char *)this + 63) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 39) & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      operator delete(this[2]);
      return;
    }
  }
  else if ((*((char *)this + 63) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[5]);
  if (*((char *)this + 39) < 0) {
    goto LABEL_7;
  }
}

const void **ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void BBUpdaterController::~BBUpdaterController(BBUpdaterController *this)
{
  *(void *)this = &unk_26CEC9448;
  (*(void (**)(void, char *))(**((void **)this + 8) + 40))(*((void *)this + 8), (char *)this + 152);
  if (*((char *)this + 335) < 0)
  {
    operator delete(*((void **)this + 39));
    if ((*((char *)this + 311) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 287) & 0x80000000) == 0) {
        goto LABEL_4;
      }
LABEL_8:
      operator delete(*((void **)this + 33));
      uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 18);
      if (!v2) {
        goto LABEL_11;
      }
      goto LABEL_9;
    }
  }
  else if ((*((char *)this + 311) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)this + 36));
  if (*((char *)this + 287) < 0) {
    goto LABEL_8;
  }
LABEL_4:
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 18);
  if (!v2) {
    goto LABEL_11;
  }
LABEL_9:
  if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
LABEL_11:
  size_t v3 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  size_t v4 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
  }
  uint64_t v9 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  unint64_t v11 = (const void *)*((void *)this + 6);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = (const void *)*((void *)this + 5);
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v13 = (const void *)*((void *)this + 4);
  if (v13) {
    CFRelease(v13);
  }
  unsigned int v14 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v14)
  {
    if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

{
  void *v1;
  uint64_t vars8;

  BBUpdaterController::~BBUpdaterController(this);

  operator delete(v1);
}

uint64_t std::map<__CFString const*,BBUpdaterController::CmdInfo,BBUpdaterController::CFStringCompareFunctor,std::allocator<std::pair<__CFString const* const,BBUpdaterController::CmdInfo>>>::~map[abi:ne180100](uint64_t a1)
{
  return a1;
}

uint64_t BBUpdaterController::setOptions(uint64_t a1, int a2, const __CFDictionary *cf)
{
  __p[128] = *(void **)MEMORY[0x263EF8340];
  if (cf)
  {
    CFDictionaryRef v3 = cf;
    CFRetain(cf);
    uint64_t v5 = *(const void **)(a1 + 40);
    *(void *)(a1 + 40) = v3;
    if (v5)
    {
      CFRelease(v5);
      CFDictionaryRef v3 = *(const __CFDictionary **)(a1 + 40);
    }
    v69[0] = 0xAAAAAAAAAAAAAAAALL;
    v69[1] = 0xAAAAAAAAAAAAAAAALL;
    ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v69, v3);
    memset(v68, 170, sizeof(v68));
    HIBYTE(__p[2]) = 0;
    LOBYTE(__p[0]) = 0;
    ctu::cf::map_adapter::getString();
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
    uint64_t v6 = off_26AA89B50;
    if (!off_26AA89B50)
    {
      uint64_t v7 = (BBUPartitionManager *)operator new(0x18uLL);
      BBUPartitionManager::BBUPartitionManager(v7);
      uint64_t v8 = operator new(0x20uLL);
      *uint64_t v8 = &unk_26CECF498;
      v8[1] = 0;
      v8[2] = 0;
      v8[3] = v7;
      uint64_t v9 = (std::__shared_weak_count *)off_26AA89B58;
      off_26AA89B50 = v7;
      off_26AA89B58 = v8;
      if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      uint64_t v6 = off_26AA89B50;
    }
    uint64_t v10 = (std::__shared_weak_count *)off_26AA89B58;
    __p[0] = v6;
    __p[1] = off_26AA89B58;
    if (off_26AA89B58) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
    unint64_t v11 = (uint64_t *)v6[1];
    if (!v11) {
LABEL_19:
    }
      std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
    while (1)
    {
      while (1)
      {
        int v12 = *((_DWORD *)v11 + 8);
        if (v12 < 1) {
          break;
        }
        unint64_t v11 = (uint64_t *)*v11;
        if (!v11) {
          goto LABEL_19;
        }
      }
      if ((v12 & 0x80000000) == 0) {
        break;
      }
      unint64_t v11 = (uint64_t *)v11[1];
      if (!v11) {
        goto LABEL_19;
      }
    }
    uint64_t v13 = (void **)(v11 + 5);
    if (v11 + 5 != (uint64_t *)v68)
    {
      if (*((char *)v11 + 63) < 0)
      {
        if (SHIBYTE(v68[2]) >= 0) {
          unsigned int v14 = v68;
        }
        else {
          unsigned int v14 = (void **)v68[0];
        }
        if (SHIBYTE(v68[2]) >= 0) {
          size_t v15 = HIBYTE(v68[2]);
        }
        else {
          size_t v15 = (size_t)v68[1];
        }
        std::string::__assign_no_alias<false>(v13, v14, v15);
      }
      else if ((HIBYTE(v68[2]) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(v13, v68[0], (size_t)v68[1]);
      }
      else
      {
        *(_OWORD *)uint64_t v13 = *(_OWORD *)v68;
        v11[7] = (uint64_t)v68[2];
      }
    }
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    HIBYTE(__dst[2]) = 0;
    LOBYTE(__dst[0]) = 0;
    ctu::cf::map_adapter::getString();
    if (SHIBYTE(v68[2]) < 0) {
      operator delete(v68[0]);
    }
    *(_OWORD *)uint64_t v68 = *(_OWORD *)__p;
    v68[2] = __p[2];
    HIBYTE(__p[2]) = 0;
    LOBYTE(__p[0]) = 0;
    if (SHIBYTE(__dst[2]) < 0) {
      operator delete(__dst[0]);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
    uint64_t v16 = off_26AA89B50;
    if (!off_26AA89B50)
    {
      uint64_t v17 = (BBUPartitionManager *)operator new(0x18uLL);
      BBUPartitionManager::BBUPartitionManager(v17);
      uint64_t v18 = operator new(0x20uLL);
      *uint64_t v18 = &unk_26CECF498;
      v18[1] = 0;
      v18[2] = 0;
      v18[3] = v17;
      CFAllocatorRef v19 = (std::__shared_weak_count *)off_26AA89B58;
      off_26AA89B50 = v17;
      off_26AA89B58 = v18;
      if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
      uint64_t v16 = off_26AA89B50;
    }
    size_t v20 = (std::__shared_weak_count *)off_26AA89B58;
    __p[0] = v16;
    __p[1] = off_26AA89B58;
    if (off_26AA89B58) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
    uint64_t v21 = (uint64_t *)v16[1];
    if (!v21) {
LABEL_52:
    }
      std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
    while (1)
    {
      while (1)
      {
        int v22 = *((_DWORD *)v21 + 8);
        if (v22 < 2) {
          break;
        }
        uint64_t v21 = (uint64_t *)*v21;
        if (!v21) {
          goto LABEL_52;
        }
      }
      if (v22 == 1) {
        break;
      }
      uint64_t v21 = (uint64_t *)v21[1];
      if (!v21) {
        goto LABEL_52;
      }
    }
    uint64_t v23 = (void **)(v21 + 5);
    if (v21 + 5 != (uint64_t *)v68)
    {
      if (*((char *)v21 + 63) < 0)
      {
        if (SHIBYTE(v68[2]) >= 0) {
          uint64_t v24 = v68;
        }
        else {
          uint64_t v24 = (void **)v68[0];
        }
        if (SHIBYTE(v68[2]) >= 0) {
          size_t v25 = HIBYTE(v68[2]);
        }
        else {
          size_t v25 = (size_t)v68[1];
        }
        std::string::__assign_no_alias<false>(v23, v24, v25);
      }
      else if ((HIBYTE(v68[2]) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(v23, v68[0], (size_t)v68[1]);
      }
      else
      {
        *(_OWORD *)uint64_t v23 = *(_OWORD *)v68;
        v21[7] = (uint64_t)v68[2];
      }
    }
    if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
    __dst[0] = operator new(0x28uLL);
    *(_OWORD *)&__dst[1] = xmmword_21DFA8EB0;
    strcpy((char *)__dst[0], "/private/var/wireless/baseband_data");
    ctu::cf::map_adapter::getString();
    if (SHIBYTE(v68[2]) < 0) {
      operator delete(v68[0]);
    }
    *(_OWORD *)uint64_t v68 = *(_OWORD *)__p;
    v68[2] = __p[2];
    HIBYTE(__p[2]) = 0;
    LOBYTE(__p[0]) = 0;
    if (SHIBYTE(__dst[2]) < 0) {
      operator delete(__dst[0]);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
    uint64_t v26 = off_26AA89B50;
    if (!off_26AA89B50)
    {
      int v27 = (BBUPartitionManager *)operator new(0x18uLL);
      BBUPartitionManager::BBUPartitionManager(v27);
      CFNumberRef v28 = operator new(0x20uLL);
      *CFNumberRef v28 = &unk_26CECF498;
      v28[1] = 0;
      v28[2] = 0;
      v28[3] = v27;
      uint64_t v29 = (std::__shared_weak_count *)off_26AA89B58;
      off_26AA89B50 = v27;
      off_26AA89B58 = v28;
      if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
      uint64_t v26 = off_26AA89B50;
    }
    unint64_t v30 = (std::__shared_weak_count *)off_26AA89B58;
    __p[0] = v26;
    __p[1] = off_26AA89B58;
    if (off_26AA89B58) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
    uint64_t v31 = (uint64_t *)v26[1];
    if (!v31) {
LABEL_85:
    }
      std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
    while (1)
    {
      while (1)
      {
        int v32 = *((_DWORD *)v31 + 8);
        if (v32 < 3) {
          break;
        }
        uint64_t v31 = (uint64_t *)*v31;
        if (!v31) {
          goto LABEL_85;
        }
      }
      if (v32 == 2) {
        break;
      }
      uint64_t v31 = (uint64_t *)v31[1];
      if (!v31) {
        goto LABEL_85;
      }
    }
    uint64_t v33 = (void **)(v31 + 5);
    if (v31 + 5 != (uint64_t *)v68)
    {
      if (*((char *)v31 + 63) < 0)
      {
        if (SHIBYTE(v68[2]) >= 0) {
          uint64_t v34 = v68;
        }
        else {
          uint64_t v34 = (void **)v68[0];
        }
        if (SHIBYTE(v68[2]) >= 0) {
          size_t v35 = HIBYTE(v68[2]);
        }
        else {
          size_t v35 = (size_t)v68[1];
        }
        std::string::__assign_no_alias<false>(v33, v34, v35);
      }
      else if ((HIBYTE(v68[2]) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(v33, v68[0], (size_t)v68[1]);
      }
      else
      {
        *(_OWORD *)uint64_t v33 = *(_OWORD *)v68;
        v31[7] = (uint64_t)v68[2];
      }
    }
    if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
    CFDictionaryRef v36 = *(const __CFDictionary **)(a1 + 40);
    if (v36) {
      unsigned int v37 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
    }
    else {
      unsigned int v37 = 0;
    }
    uint64_t v38 = (void *)&unk_26AA8F000;
    long long v39 = (void *)&unk_26AA8F000;
    int v40 = (unsigned char *)&unk_26AA8F000;
    __int16 v41 = (unsigned char *)&unk_267D24000;
    if (!v37)
    {
LABEL_161:
      if (v38[407] == -1)
      {
        if (v39[408] == -1) {
          goto LABEL_163;
        }
      }
      else
      {
        dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
        if (v39[408] == -1)
        {
LABEL_163:
          if (v40[3288] | v41[1841]) {
            goto LABEL_170;
          }
          goto LABEL_164;
        }
      }
      dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
      if (v40[3288] | v41[1841]) {
        goto LABEL_170;
      }
LABEL_164:
      if (*(unsigned char *)(a1 + 344))
      {
        if (BBULogRegisterRemoteFSDelegate(void)::delegate)
        {
          sDelegate = (uint64_t (*)(const char *, const char *, char *))BBULogRegisterRemoteFSDelegate(void)::delegate;
          if (SHIBYTE(v68[2]) < 0) {
            goto LABEL_173;
          }
          goto LABEL_174;
        }
LABEL_172:
        if (SHIBYTE(v68[2]) < 0) {
LABEL_173:
        }
          operator delete(v68[0]);
LABEL_174:
        MEMORY[0x223C1D170](v69);
        return 1;
      }
LABEL_170:
      BBULogRegisterDelegates();
      __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
      __p[1] = (void *)0xAAAAAAAAAAAAAAAALL;
      (*(void (**)(void **__return_ptr))(**(void **)(a1 + 64) + 56))(__p);
      uint64_t v64 = *(void **)(a1 + 120);
      int v65 = *(std::__shared_weak_count **)(a1 + 128);
      *(_OWORD *)(a1 + 120) = *(_OWORD *)__p;
      __p[0] = v64;
      __p[1] = v65;
      if (v65 && !atomic_fetch_add(&v65->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
        std::__shared_weak_count::__release_weak(v65);
        if ((SHIBYTE(v68[2]) & 0x80000000) == 0) {
          goto LABEL_174;
        }
        goto LABEL_173;
      }
      goto LABEL_172;
    }
    value = (void *)0xAAAAAAAAAAAAAAAALL;
    if (!CFDictionaryGetValueIfPresent(v36, @"DebugArgs", (const void **)&value)
      || (CFTypeID v45 = CFGetTypeID(value), v45 != CFStringGetTypeID()))
    {
LABEL_154:
      if (v38[407] == -1)
      {
        if (v39[408] == -1) {
          goto LABEL_156;
        }
      }
      else
      {
        dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
        if (v39[408] == -1)
        {
LABEL_156:
          if (!(v40[3288] | v41[1841])) {
            goto LABEL_161;
          }
LABEL_157:
          if (*(void *)(a1 + 120))
          {
            if (gBBULogMaskGet(void)::once != -1) {
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            }
            _BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "enabling kernel IPC log\n", v42, v43, v44, v67);
            (*(void (**)(void))(**(void **)(a1 + 120) + 32))(*(void *)(a1 + 120));
          }
          goto LABEL_161;
        }
      }
      dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
      if (!(v40[3288] | v41[1841])) {
        goto LABEL_161;
      }
      goto LABEL_157;
    }
    memset(__dst, 170, sizeof(__dst));
    memset(__p, 170, 0x400uLL);
    CFStringGetCString((CFStringRef)value, (char *)__p, 1024, 0x8000100u);
    size_t v46 = strlen((const char *)__p);
    if (v46 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    uint64_t v47 = (void *)v46;
    if (v46 >= 0x17)
    {
      uint64_t v49 = (v46 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v46 | 7) != 0x17) {
        uint64_t v49 = v46 | 7;
      }
      uint64_t v50 = v49 + 1;
      uint64_t v48 = operator new(v49 + 1);
      __dst[1] = v47;
      __dst[2] = (void *)(v50 | 0x8000000000000000);
      __dst[0] = v48;
    }
    else
    {
      HIBYTE(__dst[2]) = v46;
      uint64_t v48 = __dst;
      if (!v46) {
        goto LABEL_115;
      }
    }
    memcpy(v48, __p, (size_t)v47);
LABEL_115:
    *((unsigned char *)v47 + (void)v48) = 0;
    uint64_t v51 = (void *)HIBYTE(__dst[2]);
    char v52 = HIBYTE(__dst[2]);
    if (SHIBYTE(__dst[2]) < 0) {
      uint64_t v51 = __dst[1];
    }
    if (v51)
    {
      memset(__p, 0, 24);
      BBUStringToArgv(__dst, __p);
      int v53 = (_DWORD *)MEMORY[0x263EF89F8];
      *MEMORY[0x263EF89E8] = 1;
      *int v53 = 1;
      uint64_t v54 = (const char **)MEMORY[0x263EF89E0];
      while (1)
      {
        while (1)
        {
          do
          {
            while (1)
            {
              while (1)
              {
                uint64_t v55 = getopt_long(((unint64_t)((char *)__p[1] - (char *)__p[0]) >> 3) - 1, (char *const *)__p[0], "hl:C:v:x:t:r:p:e:c:w:i:s:fUFD:nHSqPVB:N", (const option *)&BBUpdaterController::parseDebugArgs(void)::long_options, 0);
                if ((int)v55 > 117) {
                  break;
                }
                switch(v55)
                {
                  case 0x42:
                    int v61 = *v54;
                    if (!strncmp("none", *v54, 4uLL))
                    {
                      *(_DWORD *)(a1 + 340) = 0;
                    }
                    else if (!strncmp("feedback", v61, 8uLL))
                    {
                      *(_DWORD *)(a1 + 340) = 1;
                    }
                    else
                    {
                      *(_DWORD *)(a1 + 340) = 2 * (strncmp("oslog", v61, 5uLL) == 0);
                    }
                    break;
                  case 0x6C:
                    __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
                    unsigned int v56 = strtoul(*v54, &__endptr, 0);
                    if (!*__endptr)
                    {
                      uint64_t v57 = v56;
                      sLogInternalMasuint64_t k = v56;
                      if (gBBULogMaskGet(void)::once != -1) {
                        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                      }
                      *(void *)gBBULogMaskGet(void)::sBBULogMasuint64_t k = v57;
                    }
                    break;
                  case 0xFFFFFFFF:
                    if (__p[0])
                    {
                      __p[1] = __p[0];
                      operator delete(__p[0]);
                    }
                    char v52 = HIBYTE(__dst[2]);
                    int v40 = (unsigned __int8 *)&unk_26AA8F000;
                    __int16 v41 = (unsigned __int8 *)&unk_267D24000;
                    long long v39 = &unk_26AA8F000;
                    uint64_t v38 = &unk_26AA8F000;
                    goto LABEL_152;
                  default:
LABEL_120:
                    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "%s: Ignoring unknown/GM'd out option %c", "parseDebugArgs", v55);
                    break;
                }
              }
              if (v55 != 118) {
                break;
              }
              __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
              int v62 = strtoul(*v54, &__endptr, 0);
              if (!*__endptr) {
                gBBULogVerbosity = v62;
              }
            }
            if (v55 != 120) {
              goto LABEL_120;
            }
            __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
            unsigned int v58 = strtoul(*v54, &__endptr, 0);
          }
          while (*__endptr);
          unsigned int v59 = v58;
          if (gBBULogMaskGet(void)::once != -1) {
            break;
          }
          if (v58 >= 7 && (*(void *)gBBULogMaskGet(void)::sBBULogMask & 0x40) != 0) {
            goto LABEL_136;
          }
        }
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if (v59 >= 7 && (*(void *)gBBULogMaskGet(void)::sBBULogMask & 0x40) != 0) {
LABEL_136:
        }
          TelephonyUtilDebugSetFlags();
      }
    }
LABEL_152:
    if (v52 < 0) {
      operator delete(__dst[0]);
    }
    goto LABEL_154;
  }
  return 1;
}

void sub_21DE9A9C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (__p)
  {
    a28 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  MEMORY[0x223C1D170](&a17);
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get(uint64_t a1)
{
  return *(void *)a1;
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

uint64_t BBUpdaterController::execCommand(uint64_t a1, int a2, CFStringRef theString2, CFDictionaryRef *a4, CFTypeRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFTypeRef cf = 0;
  if (!theString2)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_107;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_107;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", a6, a7, a8, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_107:
    std::string::basic_string[abi:ne180100]<0>(v84, "null command");
    BBUpdaterCommon::BBUCreateCFError((CFErrorRef *)&cf, (uint64_t)v84, 2u, 0, v63, v64, v65, v66);
    if (v85 < 0)
    {
      operator delete(v84[0]);
      uint64_t v62 = 0;
      if (!a5) {
        return v62;
      }
      goto LABEL_128;
    }
    goto LABEL_125;
  }
  if (!a4)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_114;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_114;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", a6, a7, a8, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_114:
    std::string::basic_string[abi:ne180100]<0>(v82, "null output");
    BBUpdaterCommon::BBUCreateCFError((CFErrorRef *)&cf, (uint64_t)v82, 2u, 0, v67, v68, v69, v70);
    if (v83 < 0)
    {
      operator delete(v82[0]);
      uint64_t v62 = 0;
      if (!a5) {
        return v62;
      }
      goto LABEL_128;
    }
    goto LABEL_125;
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&_MergedGlobals_1, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&_MergedGlobals_1))
  {
    qword_26AA8E470 = 0;
    qword_26AA8E468 = 0;
    qword_26AA8E460 = (uint64_t)&qword_26AA8E468;
    __cxa_atexit((void (*)(void *))std::map<__CFString const*,BBUpdaterController::CmdInfo,BBUpdaterController::CFStringCompareFunctor,std::allocator<std::pair<__CFString const* const,BBUpdaterController::CmdInfo>>>::~map[abi:ne180100], &qword_26AA8E460, &dword_21DE8A000);
    __cxa_guard_release(&_MergedGlobals_1);
  }
  if (qword_26AA8E3B0 == -1)
  {
    uint64_t v12 = qword_26AA8E468;
    if (!qword_26AA8E468) {
      goto LABEL_118;
    }
  }
  else
  {
    dispatch_once(&qword_26AA8E3B0, &__block_literal_global);
    uint64_t v12 = qword_26AA8E468;
    if (!qword_26AA8E468) {
      goto LABEL_118;
    }
  }
  uint64_t v13 = &qword_26AA8E468;
  do
  {
    CFComparisonResult v14 = CFStringCompare(*(CFStringRef *)(v12 + 32), theString2, 0);
    size_t v15 = (uint64_t *)(v12 + 8);
    if (v14 >= kCFCompareEqualTo)
    {
      size_t v15 = (uint64_t *)v12;
      uint64_t v13 = (uint64_t *)v12;
    }
    uint64_t v12 = *v15;
  }
  while (*v15);
  if (v13 != &qword_26AA8E468 && (CFStringCompare(theString2, (CFStringRef)v13[4], 0) & 0x8000000000000000) == 0)
  {
    uint64_t v16 = *(BBUFeedback **)(a1 + 56);
    memset(block, 0, sizeof(block));
    ctu::cf::assign();
    memset(&__p, 0, sizeof(__p));
    BBUFeedback::handleBeginPhase(v16, "Command: %s", (const char *)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    (*(void (**)(void))(v13[6] + 16))();
    uint64_t v17 = *(void *)(a1 + 56);
    pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    uint64_t v18 = qword_26AA89AB0;
    if (qword_26AA89AB0)
    {
LABEL_28:
      uint64_t v26 = (std::__shared_weak_count *)off_26AA89AB8;
      v80[0] = v18;
      v80[1] = off_26AA89AB8;
      if (off_26AA89AB8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
      }
      pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
      unint64_t v92 = 0;
      int v93 = &v92;
      uint64_t v94 = 0x2000000000;
      int v95 = 0;
      p_p = &__p;
      __p.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
      __p.__r_.__value_.__l.__size_ = 1107296256;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8BBUError12getErrorCodeEv_block_invoke;
      std::vector<std::string>::pointer v89 = &__block_descriptor_tmp_4_0;
      int v90 = &v92;
      uint64_t v91 = v18;
      *(void *)blocuint64_t k = MEMORY[0x263EF8330];
      *(void *)&block[8] = 0x40000000;
      *(void *)&block[16] = ___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
      BOOL v97 = &__block_descriptor_tmp_13_0;
      uint64_t v98 = v18;
      p_p_p = &p_p;
      int v27 = *(NSObject **)(v18 + 16);
      if (*(void *)(v18 + 24)) {
        dispatch_async_and_wait(v27, block);
      }
      else {
        dispatch_sync(v27, block);
      }
      uint64_t v28 = *((unsigned int *)v93 + 6);
      _Block_object_dispose(&v92, 8);
      (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 16))(v17, v28);
      if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
        uint64_t v29 = *(unsigned __int8 *)(a1 + 335);
        if ((*(char *)(a1 + 335) & 0x80000000) == 0)
        {
LABEL_36:
          if (!v29) {
            goto LABEL_62;
          }
LABEL_40:
          unint64_t v30 = (char *)(a1 + 312);
          if (!ctu::fs::is_directory()) {
            goto LABEL_62;
          }
          BBUFeedback::handleBeginPhase(*(BBUFeedback **)(a1 + 56), "BB Booted");
          (*(void (**)(void, void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 0);
          uint64_t v31 = *(void *)(a1 + 56);
          int v32 = (char *)operator new(0x19uLL);
          uint64_t v33 = v32;
          *(void *)blocuint64_t k = v32;
          *(_OWORD *)&block[8] = xmmword_21DFA8EC0;
          strcpy(v32, "/bbupdate_profile.plist");
          if (*(char *)(a1 + 335) >= 0)
          {
            size_t v34 = *(unsigned __int8 *)(a1 + 335);
          }
          else
          {
            unint64_t v30 = *(char **)(a1 + 312);
            size_t v34 = *(void *)(a1 + 320);
          }
          if (v34 <= 1)
          {
            if (!v34)
            {
LABEL_58:
              *(_OWORD *)int v78 = *(_OWORD *)block;
              uint64_t v79 = *(void *)&block[16];
              memset(block, 0, sizeof(block));
              BBUProfiler::exportToFile((CFTypeRef *)(v31 + 80), (uint64_t)v78);
              if (SHIBYTE(v79) < 0) {
                operator delete(v78[0]);
              }
              if ((block[23] & 0x80000000) != 0) {
                operator delete(*(void **)block);
              }
LABEL_62:
              pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
              uint64_t v45 = qword_26AA89AB0;
              if (qword_26AA89AB0) {
                goto LABEL_76;
              }
              size_t v46 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
              uint64_t v47 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
              uint64_t v48 = dispatch_queue_create("BBUError", v47);
              v46->~__shared_weak_count = 0;
              v46->~__shared_weak_count_0 = 0;
              v46->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v48;
              if (v48)
              {
                uint64_t v49 = v48;
                dispatch_retain(v48);
                v46->__get_deleter = 0;
                dispatch_release(v49);
              }
              else
              {
                v46->__get_deleter = 0;
              }
              v46->__on_zero_shared_weauint64_t k = 0;
              v46[1].~__shared_weak_count = 0;
              v46[1].~__shared_weak_count_0 = 0;
              uint64_t v50 = (std::__shared_weak_count *)operator new(0x20uLL);
              v50->__shared_owners_ = 0;
              v50->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CEC9D68;
              v50->__shared_weak_owners_ = 0;
              v50[1].__vftable = v46;
              uint64_t v51 = (std::__shared_weak_count *)v46->~__shared_weak_count_0;
              if (v51)
              {
                if (v51->__shared_owners_ != -1)
                {
LABEL_72:
                  char v52 = (std::__shared_weak_count *)off_26AA89AB8;
                  qword_26AA89AB0 = (uint64_t)v46;
                  off_26AA89AB8 = v50;
                  if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
                    std::__shared_weak_count::__release_weak(v52);
                  }
                  uint64_t v45 = qword_26AA89AB0;
LABEL_76:
                  int v53 = (std::__shared_weak_count *)off_26AA89AB8;
                  if (off_26AA89AB8) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
                  }
                  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
                  unint64_t v92 = 0;
                  int v93 = &v92;
                  uint64_t v94 = 0x2000000000;
                  int v95 = 0;
                  __p.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
                  __p.__r_.__value_.__l.__size_ = 1107296256;
                  __p.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8BBUError12getErrorCodeEv_block_invoke;
                  std::vector<std::string>::pointer v89 = &__block_descriptor_tmp_4_0;
                  int v90 = &v92;
                  uint64_t v91 = v45;
                  v80[0] = &__p;
                  *(void *)blocuint64_t k = MEMORY[0x263EF8330];
                  *(void *)&block[8] = 0x40000000;
                  *(void *)&block[16] = ___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
                  BOOL v97 = &__block_descriptor_tmp_13_0;
                  uint64_t v98 = v45;
                  p_p_p = (std::string **)v80;
                  uint64_t v54 = *(NSObject **)(v45 + 16);
                  if (*(void *)(v45 + 24))
                  {
                    dispatch_async_and_wait(v54, block);
                    int v55 = *((_DWORD *)v93 + 6);
                    _Block_object_dispose(&v92, 8);
                    if (!v53) {
                      goto LABEL_83;
                    }
                  }
                  else
                  {
                    dispatch_sync(v54, block);
                    int v55 = *((_DWORD *)v93 + 6);
                    _Block_object_dispose(&v92, 8);
                    if (!v53) {
                      goto LABEL_83;
                    }
                  }
                  if (!atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
                    std::__shared_weak_count::__release_weak(v53);
                    if (v55)
                    {
LABEL_84:
                      pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
                      unsigned int v56 = (BBUError *)qword_26AA89AB0;
                      if (!qword_26AA89AB0)
                      {
                        uint64_t v57 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
                        unint64_t v92 = 0;
                        ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v57, "BBUError", QOS_CLASS_UTILITY, &v92);
                        if (v92) {
                          dispatch_release(v92);
                        }
                        v57->__on_zero_shared_weauint64_t k = 0;
                        v57[1].~__shared_weak_count = 0;
                        v57[1].~__shared_weak_count_0 = 0;
                        std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)block, v57);
                        long long v58 = *(_OWORD *)block;
                        *(_OWORD *)blocuint64_t k = 0uLL;
                        unsigned int v59 = (std::__shared_weak_count *)off_26AA89AB8;
                        *(_OWORD *)&qword_26AA89AB0 = v58;
                        if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
                          std::__shared_weak_count::__release_weak(v59);
                        }
                        uint64_t v60 = *(std::__shared_weak_count **)&block[8];
                        if (*(void *)&block[8]
                          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&block[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
                          std::__shared_weak_count::__release_weak(v60);
                        }
                        unsigned int v56 = (BBUError *)qword_26AA89AB0;
                      }
                      int v61 = (std::__shared_weak_count *)off_26AA89AB8;
                      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
                      __p.__r_.__value_.__l.__size_ = (std::string::size_type)off_26AA89AB8;
                      if (off_26AA89AB8) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
                      }
                      pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
                      BBUError::getCFError(v56, (__CFError **)&cf);
                      if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                        std::__shared_weak_count::__release_weak(v61);
                        uint64_t v62 = 0;
                        if (!a5) {
                          return v62;
                        }
                        goto LABEL_128;
                      }
                      goto LABEL_125;
                    }
LABEL_101:
                    uint64_t v62 = 1;
                    if (!a5) {
                      return v62;
                    }
                    goto LABEL_128;
                  }
LABEL_83:
                  if (v55) {
                    goto LABEL_84;
                  }
                  goto LABEL_101;
                }
                atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
                atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                v46->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v46;
                v46->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v50;
                std::__shared_weak_count::__release_weak(v51);
              }
              else
              {
                atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
                atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
                v46->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v46;
                v46->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v50;
              }
              if (!atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
                std::__shared_weak_count::__release_weak(v50);
              }
              goto LABEL_72;
            }
            long long v39 = &v32[v34];
            long long v40 = *(_OWORD *)v32;
            int v41 = *((_DWORD *)v32 + 4);
            __int16 v42 = *((_WORD *)v32 + 10);
            v39[22] = v32[22];
            *((_WORD *)v39 + 10) = v42;
            *((_DWORD *)v39 + 4) = v41;
            *(_OWORD *)long long v39 = v40;
            if (v32 + 23 <= v30 || v32 > v30) {
              size_t v44 = 0;
            }
            else {
              size_t v44 = v34;
            }
            memmove(v32, &v30[v44], v34);
            *(void *)&block[8] = v34 + 23;
            uint64_t v38 = &v33[v34 + 23];
          }
          else
          {
            if (v34 - 0x7FFFFFFFFFFFFFE0 < 0x8000000000000021) {
              std::string::__throw_length_error[abi:ne180100]();
            }
            uint64_t v35 = 48;
            if (v34 + 23 > 0x30) {
              uint64_t v35 = v34 + 23;
            }
            size_t v36 = (v35 | 7) + 1;
            unsigned int v37 = (char *)operator new(v36);
            memcpy(v37, v30, v34);
            qmemcpy(&v37[v34], "/bbupdate_profile.plist", 23);
            operator delete(v33);
            *(void *)&block[8] = v34 + 23;
            *(void *)&block[16] = v36 | 0x8000000000000000;
            *(void *)blocuint64_t k = v37;
            uint64_t v38 = &v37[v34 + 23];
          }
          *uint64_t v38 = 0;
          goto LABEL_58;
        }
      }
      else
      {
        uint64_t v29 = *(unsigned __int8 *)(a1 + 335);
        if ((*(char *)(a1 + 335) & 0x80000000) == 0) {
          goto LABEL_36;
        }
      }
      if (!*(void *)(a1 + 320)) {
        goto LABEL_62;
      }
      goto LABEL_40;
    }
    CFAllocatorRef v19 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
    size_t v20 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
    uint64_t v21 = dispatch_queue_create("BBUError", v20);
    v19->~__shared_weak_count = 0;
    v19->~__shared_weak_count_0 = 0;
    v19->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))v21;
    if (v21)
    {
      int v22 = v21;
      dispatch_retain(v21);
      v19->__get_deleter = 0;
      dispatch_release(v22);
    }
    else
    {
      v19->__get_deleter = 0;
    }
    v19->__on_zero_shared_weauint64_t k = 0;
    v19[1].~__shared_weak_count = 0;
    v19[1].~__shared_weak_count_0 = 0;
    uint64_t v23 = (std::__shared_weak_count *)operator new(0x20uLL);
    v23->__shared_owners_ = 0;
    v23->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CEC9D68;
    v23->__shared_weak_owners_ = 0;
    v23[1].__vftable = v19;
    uint64_t v24 = (std::__shared_weak_count *)v19->~__shared_weak_count_0;
    if (v24)
    {
      if (v24->__shared_owners_ != -1)
      {
LABEL_24:
        size_t v25 = (std::__shared_weak_count *)off_26AA89AB8;
        qword_26AA89AB0 = (uint64_t)v19;
        off_26AA89AB8 = v23;
        if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
        uint64_t v18 = qword_26AA89AB0;
        goto LABEL_28;
      }
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v19->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v19;
      v19->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v23;
      std::__shared_weak_count::__release_weak(v24);
    }
    else
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v23->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v19->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v19;
      v19->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v23;
    }
    if (!atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
    goto LABEL_24;
  }
LABEL_118:
  memset(block, 0, sizeof(block));
  ctu::cf::assign();
  strcpy((char *)&__p, "Unrecognized command");
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 21;
  *(_WORD *)((char *)&__p.__r_.__value_.__r.__words[2] + 5) = 0;
  uint64_t v75 = (void *)__p.__r_.__value_.__r.__words[0];
  std::string::size_type v76 = __p.__r_.__value_.__r.__words[2];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::__init_copy_ctor_external(&v81, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v81 = __p;
  }
  BBUpdaterCommon::BBUCreateCFError((CFErrorRef *)&cf, (uint64_t)&v81, 2u, 0, v71, v72, v73, v74);
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v81.__r_.__value_.__l.__data_);
    if ((v76 & 0x8000000000000000) != 0) {
      goto LABEL_127;
    }
  }
  else if ((v76 & 0x8000000000000000) != 0)
  {
LABEL_127:
    operator delete(v75);
    uint64_t v62 = 0;
    if (!a5) {
      return v62;
    }
    goto LABEL_128;
  }
LABEL_125:
  uint64_t v62 = 0;
  if (!a5) {
    return v62;
  }
LABEL_128:
  if (cf)
  {
    *a5 = CFRetain(cf);
    CFRelease(cf);
    CFTypeRef cf = 0;
    if (a4)
    {
      if (!*a4) {
        *a4 = CFDictionaryCreate(0, 0, 0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      }
    }
  }
  return v62;
}

void sub_21DE9BB6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_21DE9BB80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0) {
    operator delete(a26);
  }
  _Unwind_Resume(a1);
}

void sub_21DE9BB94(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,CFTypeRef cf)
{
  size_t v34 = *(NSObject **)(v31 - 208);
  if (v34) {
    dispatch_release(v34);
  }
  operator delete(v30);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  if (a2 == 2)
  {
    long long v40 = __cxa_begin_catch(a1);
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    BBUpdaterController::handleException((CFErrorRef *)&cf, (const char *)v40 + 8, *((_DWORD *)v40 + 130), v35, v36, v37, v38, v39);
  }
  else
  {
    if (a2 != 1) {
      JUMPOUT(0x21DE9BE50);
    }
    int v41 = __cxa_begin_catch(a1);
    if (cf)
    {
      CFRelease(cf);
      CFTypeRef cf = 0;
    }
    __int16 v42 = (const char *)(*(uint64_t (**)(void *))(*(void *)v41 + 16))(v41);
    BBUpdaterController::handleException((CFErrorRef *)&cf, v42, 0xBu, v43, v44, v45, v46, v47);
  }
  __cxa_end_catch();
  if (!v29) {
    JUMPOUT(0x21DE9BA88);
  }
  JUMPOUT(0x21DE9BA38);
}

void sub_21DE9BBB4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,CFErrorRef a32)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v33 - 153) < 0) {
    operator delete(*(void **)(v33 - 176));
  }
  if (a2 == 2)
  {
    int v41 = __cxa_begin_catch(a1);
    if (a32)
    {
      CFRelease(a32);
      a32 = 0;
    }
    BBUpdaterController::handleException(&a32, (const char *)v41 + 8, *((_DWORD *)v41 + 130), v36, v37, v38, v39, v40);
  }
  else
  {
    if (a2 != 1) {
      JUMPOUT(0x21DE9BE50);
    }
    __int16 v42 = __cxa_begin_catch(a1);
    if (a32)
    {
      CFRelease(a32);
      a32 = 0;
    }
    uint64_t v43 = (const char *)(*(uint64_t (**)(void *))(*(void *)v42 + 16))(v42);
    BBUpdaterController::handleException(&a32, v43, 0xBu, v44, v45, v46, v47, v48);
  }
  __cxa_end_catch();
  if (!v32) {
    JUMPOUT(0x21DE9BA88);
  }
  JUMPOUT(0x21DE9BA38);
}

void sub_21DE9BBF0(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1}::operator() const(BBUError*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_21DE9BC18(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,CFErrorRef a29)
{
  __cxa_end_catch();
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  if (a2 == 2)
  {
    uint64_t v37 = __cxa_begin_catch(a1);
    if (a29)
    {
      CFRelease(a29);
      a29 = 0;
    }
    BBUpdaterController::handleException(&a29, (const char *)v37 + 8, *((_DWORD *)v37 + 130), v32, v33, v34, v35, v36);
  }
  else
  {
    if (a2 != 1) {
      JUMPOUT(0x21DE9BE50);
    }
    uint64_t v38 = __cxa_begin_catch(a1);
    if (a29)
    {
      CFRelease(a29);
      a29 = 0;
    }
    uint64_t v39 = (const char *)(*(uint64_t (**)(void *))(*(void *)v38 + 16))(v38);
    BBUpdaterController::handleException(&a29, v39, 0xBu, v40, v41, v42, v43, v44);
  }
  __cxa_end_catch();
  if (!v29) {
    JUMPOUT(0x21DE9BA88);
  }
  JUMPOUT(0x21DE9BA38);
}

void sub_21DE9BC48(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1}::operator() const(BBUError*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_21DE9BC70(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,CFErrorRef a29)
{
  __cxa_end_catch();
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  if (a2 == 2)
  {
    uint64_t v37 = __cxa_begin_catch(a1);
    if (a29)
    {
      CFRelease(a29);
      a29 = 0;
    }
    BBUpdaterController::handleException(&a29, (const char *)v37 + 8, *((_DWORD *)v37 + 130), v32, v33, v34, v35, v36);
  }
  else
  {
    if (a2 != 1) {
      JUMPOUT(0x21DE9BE50);
    }
    uint64_t v38 = __cxa_begin_catch(a1);
    if (a29)
    {
      CFRelease(a29);
      a29 = 0;
    }
    uint64_t v39 = (const char *)(*(uint64_t (**)(void *))(*(void *)v38 + 16))(v38);
    BBUpdaterController::handleException(&a29, v39, 0xBu, v40, v41, v42, v43, v44);
  }
  __cxa_end_catch();
  if (!v29) {
    JUMPOUT(0x21DE9BA88);
  }
  JUMPOUT(0x21DE9BA38);
}

void sub_21DE9BCA0()
{
}

void sub_21DE9BCBC(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,CFErrorRef a29,uint64_t a30,char a31)
{
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a31);
  if (a2 == 2)
  {
    uint64_t v39 = __cxa_begin_catch(a1);
    if (a29)
    {
      CFRelease(a29);
      a29 = 0;
    }
    BBUpdaterController::handleException(&a29, (const char *)v39 + 8, *((_DWORD *)v39 + 130), v34, v35, v36, v37, v38);
  }
  else
  {
    if (a2 != 1) {
      JUMPOUT(0x21DE9BE50);
    }
    uint64_t v40 = __cxa_begin_catch(a1);
    if (a29)
    {
      CFRelease(a29);
      a29 = 0;
    }
    uint64_t v41 = (const char *)(*(uint64_t (**)(void *))(*(void *)v40 + 16))(v40);
    BBUpdaterController::handleException(&a29, v41, 0xBu, v42, v43, v44, v45, v46);
  }
  __cxa_end_catch();
  if (!v31) {
    JUMPOUT(0x21DE9BA88);
  }
  JUMPOUT(0x21DE9BA38);
}

void sub_21DE9BCFC(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,CFErrorRef a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(a31);
  }
  if (a2 == 2)
  {
    uint64_t v44 = __cxa_begin_catch(a1);
    if (a29)
    {
      CFRelease(a29);
      a29 = 0;
    }
    BBUpdaterController::handleException(&a29, (const char *)v44 + 8, *((_DWORD *)v44 + 130), v39, v40, v41, v42, v43);
  }
  else
  {
    if (a2 != 1) {
      JUMPOUT(0x21DE9BE50);
    }
    uint64_t v45 = __cxa_begin_catch(a1);
    if (a29)
    {
      CFRelease(a29);
      a29 = 0;
    }
    uint64_t v46 = (const char *)(*(uint64_t (**)(void *))(*(void *)v45 + 16))(v45);
    BBUpdaterController::handleException(&a29, v46, 0xBu, v47, v48, v49, v50, v51);
  }
  __cxa_end_catch();
  if (!v36) {
    JUMPOUT(0x21DE9BA88);
  }
  JUMPOUT(0x21DE9BA38);
}

void sub_21DE9BD34(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_21DE9BD40()
{
}

void sub_21DE9BDEC()
{
}

void sub_21DE9BDF8()
{
}

void sub_21DE9BE08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (v26 < 0) {
    operator delete(v25);
  }
  _Unwind_Resume(a1);
}

void sub_21DE9BE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0) {
    operator delete(a31);
  }
  _Unwind_Resume(a1);
}

void sub_21DE9BE3C()
{
  if (*(char *)(v0 - 153) < 0) {
    JUMPOUT(0x21DE9BE4CLL);
  }
  JUMPOUT(0x21DE9BE50);
}

__n128 std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>@<Q0>(const char *a1@<X0>, std::string *a2@<X1>, std::string *a3@<X8>)
{
  std::string::size_type v6 = strlen(a1);
  uint64_t v7 = (__n128 *)std::string::insert(a2, 0, a1, v6);
  __n128 result = *v7;
  *a3 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

void BBUpdaterController::handleException(CFErrorRef *a1, const char *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(25, 0xFFFFFFFFLL, "BBUpdaterController", "", "%s\n", a6, a7, a8, (char)a2);
  size_t v11 = strlen(a2);
  if (v11 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v16 = (void *)v11;
  if (v11 >= 0x17)
  {
    uint64_t v18 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v18 = v11 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v17 = (void **)operator new(v18 + 1);
    __dst[1] = v16;
    unint64_t v21 = v19 | 0x8000000000000000;
    __dst[0] = v17;
    goto LABEL_10;
  }
  HIBYTE(v21) = v11;
  uint64_t v17 = __dst;
  if (v11) {
LABEL_10:
  }
    memcpy(v17, a2, (size_t)v16);
  *((unsigned char *)v16 + (void)v17) = 0;
  BBUpdaterCommon::BBUCreateCFError(a1, (uint64_t)__dst, a3, 0, v12, v13, v14, v15);
  if (SHIBYTE(v21) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_21DE9C000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void BBUpdaterController::registerLogSink(BBUpdaterController *this, uint64_t a2, void (*a3)(void *, int, const char *))
{
  gBBULogSinkContext = a2;
  gBBULogSinkFunc = a3;
}

void BBUpdaterController::query(void *a1, int a2)
{
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource((BBUpdaterController *)a1, 0);
  uint64_t v8 = FirmwareDataSource;
  uint64_t v28 = FirmwareDataSource;
  if (a2 != 4)
  {
    if (a2 != 32)
    {
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x135u, (ctu::LogMessageBuffer *)"Assertion failure(false && \"Unrecognized BBU stage.\")", v23, v24, v25, v26);
    }
    if (!BBUpdaterController::shouldPerformEUICC((const __CFDictionary **)a1))
    {
      if (!v8) {
        return;
      }
      goto LABEL_27;
    }
    if (v8)
    {
      uint64_t v12 = (const void *)a1[5];
      cf.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
      if (v12) {
        CFRetain(v12);
      }
      uint64_t v13 = (__CFDictionary *)a1[4];
      CFMutableDictionaryRef v32 = v13;
      if (v13) {
        CFRetain(v13);
      }
      unsigned int updated = eUICC::UpdateOutput(a1 + 19, (const __CFDictionary **)&cf, &v32);
      if (v32) {
        CFRelease(v32);
      }
      if (cf.__r_.__value_.__r.__words[0]) {
        CFRelease(cf.__r_.__value_.__l.__data_);
      }
      if (!updated)
      {
        if (a1[4]
           ? ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get
           : 0)
        {
          goto LABEL_27;
        }
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
          goto LABEL_20;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
        {
LABEL_20:
          if (gBBULogVerbosity >= 6) {
            _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v14, v15, v16, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          }
        }
      }
      std::string::basic_string[abi:ne180100]<0>(&__p, "Failed to eUICC::updateOutput in BootedStage");
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v30, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string v30 = __p;
      }
      uint64_t v31 = updated;
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)a1, (uint64_t)&v30);
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      goto LABEL_27;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_40;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_40;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v9, v10, v11, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_40:
    unint64_t v21 = (char *)BBUStageAsString(32);
    std::string::basic_string[abi:ne180100]<0>(&cf, v21);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to get update source in ", &cf, &__p);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      std::string v30 = __p;
      goto LABEL_49;
    }
LABEL_48:
    std::string::__init_copy_ctor_external(&v30, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
LABEL_49:
    uint64_t v31 = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)a1, (uint64_t)&v30);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v30.__r_.__value_.__l.__data_);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_51:
        if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return;
        }
        goto LABEL_55;
      }
    }
    else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_51;
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_55:
    operator delete(cf.__r_.__value_.__l.__data_);
    return;
  }
  if (!FirmwareDataSource)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_34;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_34;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v5, v6, v7, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_34:
    size_t v20 = (char *)BBUStageAsString(4);
    std::string::basic_string[abi:ne180100]<0>(&cf, v20);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to get update source in ", &cf, &__p);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      std::string v30 = __p;
      goto LABEL_49;
    }
    goto LABEL_48;
  }
  BBUpdaterController::queryInfoSecondStageInternal((uint64_t)a1, 1, (uint64_t)&v28);
LABEL_27:
  uint64_t v19 = *(void (**)(BBUEUR10UpdateSource *))(*(void *)v8 + 16);

  v19(v8);
}

void sub_21DE9C524(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0)
  {
    operator delete(__p);
    if ((a17 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a17 & 0x80000000) == 0)
  {
LABEL_6:
    _Unwind_Resume(exception_object);
  }
  operator delete(a12);
  _Unwind_Resume(exception_object);
}

BBUEUR10UpdateSource *BBUpdaterController::getFirmwareDataSource(BBUpdaterController *this, int a2)
{
  CFDictionaryRef v4 = (const __CFDictionary *)*((void *)this + 5);
  if (v4) {
    uint64_t v5 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v5)
  {
    value[0] = (void *)0xAAAAAAAAAAAAAAAALL;
    if (CFDictionaryGetValueIfPresent(v4, @"firmwareData", (const void **)value))
    {
      CFTypeID v6 = CFGetTypeID(value[0]);
      if (v6 == CFDataGetTypeID())
      {
        CFDataRef v7 = (const __CFData *)value[0];
        if (value[0])
        {
          uint64_t v8 = (BBUZipFile *)operator new(0x98uLL);
          BBUZipFile::BBUZipFile(v8, v7);
          return BBUUpdateSource::createFromZipFile(v8, *((BBUZipFile **)this + 7), (BBUFeedback *)(*(_DWORD *)(*((void *)this + 12) + 88) == 3));
        }
      }
    }
  }
  if (!a2) {
    return 0;
  }
  memset(value, 170, 24);
  FirmwareFolder = (capabilities::radio *)BBUpdaterController::getFirmwareFolder(value, *((const __CFDictionary **)this + 5));
  uint64_t v12 = (void *)HIBYTE(value[2]);
  if (SHIBYTE(value[2]) < 0) {
    uint64_t v12 = value[1];
  }
  if (!v12)
  {
    capabilities::radio::personalizedFirmwarePath((uint64_t *)&v20, FirmwareFolder);
    if (SHIBYTE(value[2]) < 0)
    {
      operator delete(value[0]);
      value[2] = v21;
      *(_OWORD *)value = v20;
      int v13 = SHIBYTE(v21);
      if ((SHIBYTE(v21) & 0x80000000) == 0)
      {
LABEL_16:
        if (v13)
        {
          uint64_t v14 = value;
LABEL_22:
          BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Baseband fw path that is used: %s\n", (const char *)v14);
          goto LABEL_23;
        }
        goto LABEL_25;
      }
    }
    else
    {
      value[2] = v21;
      *(_OWORD *)value = v20;
      int v13 = SHIBYTE(v21);
      if ((SHIBYTE(v21) & 0x80000000) == 0) {
        goto LABEL_16;
      }
    }
    if (value[1])
    {
      uint64_t v14 = (void **)value[0];
      goto LABEL_22;
    }
LABEL_25:
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x55Fu, (ctu::LogMessageBuffer *)"Assertion failure(folder.empty() != true && \"Failed finding the bbfw path.\")", v16, v17, v18, v19);
  }
LABEL_23:
  uint64_t v9 = BBUUpdateSource::createFromFolder((long long *)value, *((void *)this + 7), *(_DWORD *)(*((void *)this + 12) + 88) == 3);
  if ((SHIBYTE(value[2]) & 0x80000000) == 0) {
    return (BBUEUR10UpdateSource *)v9;
  }
  operator delete(value[0]);
  return (BBUEUR10UpdateSource *)v9;
}

void sub_21DE9C880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  __cxa_free_exception(v18);
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t BBUpdaterController::parsePreflightArgs(BBUpdaterController *this)
{
  uint64_t result = *((void *)this + 5);
  if (result)
  {
    value = (void *)0xAAAAAAAAAAAAAAAALL;
    uint64_t result = CFDictionaryGetValueIfPresent((CFDictionaryRef)result, @"PreflightInfo", (const void **)&value);
    if (result)
    {
      CFTypeID v3 = CFGetTypeID(value);
      uint64_t result = CFDictionaryGetTypeID();
      if (v3 == result && !*((unsigned char *)this + 353))
      {
        BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Preflight detected");
        *((unsigned char *)this + 353) = 1;
        uint64_t result = (*(uint64_t (**)(void, void, void *))(**((void **)this + 9) + 80))(*((void *)this + 9), *((void *)this + 12), value);
        if (result)
        {
          exception = __cxa_allocate_exception(0x210uLL);
          _BBUException::_BBUException((uint64_t)exception, 11, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x8A0u, (ctu::LogMessageBuffer *)"Assertion failure(ret == kBBUReturnSuccess && \"Failed overriding preflight personalization parameters.\")", v5, v6, v7, v8);
        }
      }
    }
  }
  return result;
}

void sub_21DE9C9BC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUpdaterController::queryInfoFirstStageInternal(BBULoader **this, BBUFeedback *a2)
{
  CFTypeID v3 = BBULoader::create(this[7], a2);
  CFDictionaryRef v4 = this[10];
  this[10] = (BBULoader *)v3;
  if (v4)
  {
    (*(void (**)(BBULoader *))(*(void *)v4 + 8))(v4);
    CFTypeID v3 = (char *)this[10];
  }
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 11, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x811u, (ctu::LogMessageBuffer *)"Assertion failure(fLoader && \"Failed to reset and create BBULoader.\")", v28, v29, v30, v31);
  }
  int TransportNoEvents = BBUpdaterController::createTransportNoEvents((uint64_t)this, 1, 2);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0)
    {
LABEL_15:
      BOOL v9 = TransportNoEvents == 0;
LABEL_16:
      uint64_t v10 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
      int v11 = gBBULogVerbosity;
      if (!v9) {
        goto LABEL_9;
      }
      goto LABEL_17;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      goto LABEL_15;
    }
  }
  if (gBBULogVerbosity < 0) {
    goto LABEL_15;
  }
  _BBULog(13, 0, "BBUpdaterController", "", "createTransportNoEvents ret status is %d\n", v5, v6, v7, TransportNoEvents);
  BOOL v9 = TransportNoEvents == 0;
  if (gBBULogMaskGet(void)::once == -1) {
    goto LABEL_16;
  }
  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  uint64_t v10 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
  int v11 = gBBULogVerbosity;
  if (TransportNoEvents)
  {
LABEL_9:
    if ((v10 & 2) != 0 && v11 >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v5, v6, v7, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
    std::string::basic_string[abi:ne180100]<0>(&v32, "kBBUReturnFailCreateTransportFirst");
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to create transport: ", &v32, &v33);
    int v13 = capabilities::updater::loaderConnectAttempts(v12);
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v33;
    }
    int v35 = 50;
    int v36 = v13;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>((uint64_t)this, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_47:
        if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return 50;
        }
LABEL_51:
        operator delete(v32.__r_.__value_.__l.__data_);
        return 50;
      }
    }
    else if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_47;
    }
    operator delete(v33.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return 50;
    }
    goto LABEL_51;
  }
LABEL_17:
  if ((v10 & 0x2000) != 0 && (v11 & 0x80000000) == 0) {
    _BBULog(13, 0, "BBUpdaterController", "", "Querying first stage\n", v5, v6, v7, v31);
  }
  uint64_t v14 = (*(uint64_t (**)(BBULoader *, char *))(*(void *)this[10] + 16))(this[10], (char *)this + 152);
  if (v14)
  {
    uint64_t v23 = v14;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_36;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_36;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v15, v16, v17, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_36:
    std::string::basic_string[abi:ne180100]<0>(&v32, BBUReturnAsString::BBUReturnStrings[v23]);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to connect to loader: ", &v32, &v33);
    int v26 = capabilities::updater::loaderConnectAttempts(v25);
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v33;
    }
    int v35 = v23;
    int v36 = v26;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>((uint64_t)this, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_55:
        if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return v23;
        }
LABEL_59:
        operator delete(v32.__r_.__value_.__l.__data_);
        return v23;
      }
    }
    else if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_55;
    }
    operator delete(v33.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v23;
    }
    goto LABEL_59;
  }
  v33.__r_.__value_.__r.__words[0] = 0;
  (*(void (**)(BBULoader *, char *, std::string *))(*(void *)this[10] + 24))(this[10], (char *)this + 152, &v33);
  if (v33.__r_.__value_.__r.__words[0])
  {
    uint64_t v18 = this[7];
    (*(void (**)(std::string *__return_ptr))(*(void *)v33.__r_.__value_.__l.__data_ + 16))(&__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(v18, "Loader version: %s", (const char *)p_p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v33.__r_.__value_.__r.__words[0]) {
      (*(void (**)(std::string::size_type))(*(void *)v33.__r_.__value_.__l.__data_ + 8))(v33.__r_.__value_.__r.__words[0]);
    }
  }
  uint64_t v23 = (*(uint64_t (**)(BBULoader *, char *, BBULoader *))(*(void *)this[10] + 32))(this[10], (char *)this + 152, this[12]);
  if (!v23)
  {
    BBUFeedback::handleComment(this[7], "fusingState: %d", *((_DWORD *)this[12] + 22));
    return v23;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_40;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_40:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v20, v21, v22, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&v33, "Failed querying chip information in the first stage.");
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&__p, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v33;
  }
  int v35 = v23;
  int v36 = 0;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v33.__r_.__value_.__l.__data_);
  }
  return v23;
}

void sub_21DE9D038(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef v4 = *(int **)(a1 + 16);
  CFTypeID v3 = *(std::__shared_weak_count **)(a1 + 24);
  int v27 = v4;
  uint64_t v28 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v26 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)v4 + 24))(__p, v4);
  uint64_t v5 = (void **)__p[0];
  uint64_t v6 = (void **)((char *)__p[0] + 24 * v4[8]);
  if (__dst != v6)
  {
    char v7 = *((unsigned char *)v6 + 23);
    if (SHIBYTE(v26) < 0)
    {
      if (v7 >= 0) {
        BOOL v9 = (char *)__p[0] + 24 * v4[8];
      }
      else {
        BOOL v9 = (char *)*v6;
      }
      if (v7 >= 0) {
        size_t v10 = *((unsigned __int8 *)v6 + 23);
      }
      else {
        size_t v10 = (size_t)v6[1];
      }
      std::string::__assign_no_alias<false>(__dst, v9, v10);
    }
    else if ((*((unsigned char *)v6 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v6, (size_t)v6[1]);
    }
    else
    {
      long long v8 = *(_OWORD *)v6;
      uint64_t v26 = (uint64_t)v6[2];
      *(_OWORD *)long long __dst = v8;
    }
    uint64_t v5 = (void **)__p[0];
  }
  if (v5)
  {
    int v11 = (void **)__p[1];
    uint64_t v12 = v5;
    if (__p[1] != v5)
    {
      do
      {
        if (*((char *)v11 - 1) < 0) {
          operator delete(*(v11 - 3));
        }
        v11 -= 3;
      }
      while (v11 != v5);
      uint64_t v12 = (void **)__p[0];
    }
    __p[1] = v5;
    operator delete(v12);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFA9750 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v16 = __p;
    }
    else {
      LOBYTE(v16) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v13, v14, v15, (char)v16);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  uint64_t v17 = (uint64_t)v27;
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::is_event_handling_blocked_helper<BBUpdaterControllerFSM::eventError>((uint64_t)v27)
    && boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventError,BBUpdaterControllerFSM::eventError>(v17, a2))
  {
    int v18 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(v17 + 32) + 218])(v17, 0);
    if (!(((unsigned int (*)(uint64_t, uint64_t))_MergedGlobals_1[*(_DWORD *)(v17 + 36) + 218])(v17, 1) | v18))
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError>(v17, v17, *(_DWORD *)(v17 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError>(v17, v17, *(_DWORD *)(v17 + 36));
    }
    *(unsigned char *)(v17 + 100) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v17);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_45;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_45;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFA9750 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v19, v20, v21, (char)v22);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_45:
  if (SHIBYTE(v26) < 0) {
    operator delete(__dst[0]);
  }
  uint64_t v23 = v28;
  if (v28)
  {
    if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_21DE9D524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  if (a23 < 0)
  {
    operator delete(__p);
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a25);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a25);
  _Unwind_Resume(a1);
}

uint64_t BBUpdaterController::queryInfoSecondStageInternal(uint64_t a1, int a2, uint64_t a3)
{
  BOOL v9 = BBUProgrammer::create(*(capabilities::updater **)(a1 + 56), a1 + 152, *(void *)(a1 + 48));
  uint64_t v10 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = v9;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  if (*(void *)a3)
  {
    if (!BBUpdaterController::createTransportNoEvents(a1, 0, 4))
    {
      if (*(char *)(a1 + 311) < 0)
      {
        if (!*(void *)(a1 + 296))
        {
LABEL_8:
          uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 16))(*(void *)(a1 + 88));
          if (!v14)
          {
            if (!a2) {
              return 0;
            }
            int v26 = 0;
            uint64_t v18 = *(void *)(a1 + 96);
            if (*(_DWORD *)(v18 + 88) == 3)
            {
              uint64_t v19 = (*(unsigned int (**)(void))(**(void **)a3 + 48))() ^ 1;
              uint64_t v18 = *(void *)(a1 + 96);
            }
            else
            {
              uint64_t v19 = 0;
            }
            uint64_t v24 = (*(uint64_t (**)(void, void, uint64_t, int *, uint64_t, uint64_t))(**(void **)(a1 + 88)
                                                                                              + 32))(*(void *)(a1 + 88), 0, 1, &v26, v18, v19);
            if (!v24) {
              return v24;
            }
            if (gBBULogMaskGet(void)::once == -1)
            {
              if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
                goto LABEL_40;
              }
            }
            else
            {
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
              if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
                goto LABEL_40;
              }
            }
            if (gBBULogVerbosity >= 6) {
              _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v21, v22, v23, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
            }
LABEL_40:
            (*(void (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
            std::string::basic_string[abi:ne180100]<0>(&v27, BBUReturnAsString::BBUReturnStrings[v24]);
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Failed gathering personalization parameters @ second stage: ", &v27, &__p);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              std::string::__init_copy_ctor_external(&v29, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
            }
            else {
              std::string v29 = __p;
            }
            uint64_t v30 = v24;
            BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&v29);
            if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v29.__r_.__value_.__l.__data_);
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_64:
                if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
                  goto LABEL_68;
                }
                return v24;
              }
            }
            else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_64;
            }
            operator delete(__p.__r_.__value_.__l.__data_);
            if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
            {
LABEL_68:
              uint64_t v25 = (void *)v27.__r_.__value_.__r.__words[0];
              goto LABEL_69;
            }
            return v24;
          }
          uint64_t v24 = v14;
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
              goto LABEL_34;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
              goto LABEL_34;
            }
          }
          if (gBBULogVerbosity >= 6) {
            _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v15, v16, v17, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          }
LABEL_34:
          std::string::basic_string[abi:ne180100]<0>(&__p, "Failed connecting to programmer while querying information in the second stage.");
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&v29, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else {
            std::string v29 = __p;
          }
          uint64_t v30 = v24;
          BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&v29);
          if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v29.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            uint64_t v25 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_69:
            operator delete(v25);
            return v24;
          }
          return v24;
        }
      }
      else if (!*(unsigned char *)(a1 + 311))
      {
        goto LABEL_8;
      }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 88) + 56))(*(void *)(a1 + 88), a1 + 288);
      goto LABEL_8;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_28;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_28;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v11, v12, v13, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_28:
    std::string::basic_string[abi:ne180100]<0>(&v27, "kBBUReturnFailCreateTransportSecond");
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to create transport ", &v27, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v29, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v29 = __p;
    }
    uint64_t v30 = 51;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&v29);
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v29.__r_.__value_.__l.__data_);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_51:
        if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return 51;
        }
LABEL_55:
        operator delete(v27.__r_.__value_.__l.__data_);
        return 51;
      }
    }
    else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_51;
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v27.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return 51;
    }
    goto LABEL_55;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_20;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_20:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v6, v7, v8, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "Fail to get update source for queryInfoSecondStageInternal");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v29, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v29 = __p;
  }
  uint64_t v30 = 35;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&v29);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 35;
}

void sub_21DE9DC74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0)
  {
    operator delete(__p);
    if ((a18 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a18 & 0x80000000) == 0)
  {
LABEL_6:
    _Unwind_Resume(exception_object);
  }
  operator delete(a13);
  goto LABEL_6;
}

uint64_t BBUpdaterController::shouldPerformEUICC(const __CFDictionary **this)
{
  int v5 = capabilities::euicc::supportsLegacyUpdater((capabilities::euicc *)this);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(19, 0, "BBUpdaterController", "", "supports legacy eUICC update? %d\n", v2, v3, v4, v5);
  }
LABEL_5:
  if (!v5) {
    return 0;
  }
  CFDictionaryRef v6 = this[5];
  CFDictionaryRef v13 = v6;
  if (v6) {
    CFRetain(v6);
  }
  eUICC::Options::Options((uint64_t)v14, &v13);
  int v10 = v14[8];
  if (v16 < 0)
  {
    operator delete(__p);
    if (!v6) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (v6) {
LABEL_12:
  }
    CFRelease(v6);
LABEL_13:
  if (!v10) {
    return 1;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    uint64_t result = 0;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      return result;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t result = 0;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      return result;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    _BBULog(19, 0, "BBUpdaterController", "", "Skip eUICC options\n", v7, v8, v9, v12);
    return 0;
  }
  return result;
}

void sub_21DE9DEF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void BBUpdaterController::personalize(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 352) = 1;
  memset(&__p, 0, sizeof(__p));
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource((BBUpdaterController *)a1, 0);
  v129 = FirmwareDataSource;
  if (!FirmwareDataSource)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_110;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_110:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v4, v5, v6, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    uint64_t v102 = (char *)BBUStageAsString(a2);
    std::string::basic_string[abi:ne180100]<0>(&v131, v102);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to get update source in ", &v131, &v132);
    if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__dst, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
    }
    else {
      std::string __dst = v132;
    }
    unint64_t v134 = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&__dst);
    goto LABEL_116;
  }
  switch(a2)
  {
    case 2:
      uint64_t v8 = *(BBUFeedback **)(a1 + 56);
      BBUFeedback::handleComment(v8, "entering %s", "StageContext::PersonalizeStageFirst");
      uint64_t v9 = *((void *)v8 + 19);
      uint64_t v10 = *((void *)v8 + 18);
      if (v9 == v10) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = ((v9 - v10) << 7) - 1;
      }
      uint64_t v12 = *((void *)v8 + 22);
      unint64_t v13 = v12 + *((void *)v8 + 21);
      if (v11 == v13)
      {
        std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity((void *)v8 + 17);
        uint64_t v10 = *((void *)v8 + 18);
        uint64_t v12 = *((void *)v8 + 22);
        unint64_t v13 = *((void *)v8 + 21) + v12;
      }
      *(_DWORD *)(*(void *)(v10 + ((v13 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v13 & 0x3FF)) = 2;
      *((void *)v8 + 22) = v12 + 1;
      if (*(_DWORD *)(*(void *)(a1 + 96) + 88) != 3)
      {
        uint64_t v14 = (capabilities::updater *)(*(uint64_t (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource
                                                                                         + 80))(FirmwareDataSource);
        if (!v14)
        {
          if (capabilities::updater::shouldSkipRestoreForUnfused(v14))
          {
            BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Detecting unfused BB and skip restore");
            char v16 = *(int **)(a1 + 16);
            std::string::size_type v15 = *(void *)(a1 + 24);
            v131.__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
            v131.__r_.__value_.__l.__size_ = v15;
            if (v15) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
            }
            __dst.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
            __dst.__r_.__value_.__r.__words[2] = 0x7AAAAAAAAAAAAAALL;
            strcpy((char *)&__dst, "unknown");
            memset(&v132, 170, sizeof(v132));
            (*(void (**)(std::string *__return_ptr, int *))(*(void *)v16 + 24))(&v132, v16);
            std::string::size_type v17 = v132.__r_.__value_.__r.__words[0];
            std::string::size_type v18 = v132.__r_.__value_.__r.__words[0] + 24 * v16[8];
            if (&__dst != (std::string *)v18)
            {
              char v19 = *(unsigned char *)(v18 + 23);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              {
                if (v19 >= 0) {
                  std::vector<std::string>::pointer v89 = (void *)(v132.__r_.__value_.__r.__words[0] + 24 * v16[8]);
                }
                else {
                  std::vector<std::string>::pointer v89 = *(void **)v18;
                }
                if (v19 >= 0) {
                  size_t v90 = *(unsigned __int8 *)(v18 + 23);
                }
                else {
                  size_t v90 = *(void *)(v18 + 8);
                }
                std::string::__assign_no_alias<false>((void **)&__dst.__r_.__value_.__l.__data_, v89, v90);
              }
              else if ((*(unsigned char *)(v18 + 23) & 0x80) != 0)
              {
                std::string::__assign_no_alias<true>(&__dst, *(void **)v18, *(void *)(v18 + 8));
              }
              else
              {
                long long v20 = *(_OWORD *)v18;
                __dst.__r_.__value_.__r.__words[2] = *(void *)(v18 + 16);
                *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v20;
              }
              std::string::size_type v17 = v132.__r_.__value_.__r.__words[0];
            }
            if (v17)
            {
              std::string::size_type size = v132.__r_.__value_.__l.__size_;
              unint64_t v92 = (void *)v17;
              if (v132.__r_.__value_.__l.__size_ != v17)
              {
                do
                {
                  if (*(char *)(size - 1) < 0) {
                    operator delete(*(void **)(size - 24));
                  }
                  size -= 24;
                }
                while (size != v17);
                unint64_t v92 = (void *)v132.__r_.__value_.__r.__words[0];
              }
              v132.__r_.__value_.__l.__size_ = v17;
              operator delete(v92);
            }
            if (gBBULogMaskGet(void)::once == -1)
            {
              if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
                goto LABEL_95;
              }
            }
            else
            {
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
              if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
                goto LABEL_95;
              }
            }
            if ((gBBULogVerbosity & 0x80000000) == 0)
            {
              boost::core::demangle((boost::core *)&v132, (const char *)(0x800000021DFA98E1 & 0x7FFFFFFFFFFFFFFFLL));
              if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v96 = &v132;
              }
              else {
                LOBYTE(v96) = v132.__r_.__value_.__s.__data_[0];
              }
              _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v93, v94, v95, (char)v96);
              if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v132.__r_.__value_.__l.__data_);
              }
            }
LABEL_95:
            boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventSkipPersonalize>((uint64_t)v131.__r_.__value_.__l.__data_, (uint64_t)&cf, 1);
            if (gBBULogMaskGet(void)::once == -1)
            {
              if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
              {
LABEL_97:
                if ((gBBULogVerbosity & 0x80000000) == 0)
                {
                  boost::core::demangle((boost::core *)&v132, (const char *)(0x800000021DFA98E1 & 0x7FFFFFFFFFFFFFFFLL));
                  if ((v132.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    int v100 = &v132;
                  }
                  else {
                    LOBYTE(v100) = v132.__r_.__value_.__s.__data_[0];
                  }
                  _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v97, v98, v99, (char)v100);
                  if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(v132.__r_.__value_.__l.__data_);
                  }
                }
              }
            }
            else
            {
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
              if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
                goto LABEL_97;
              }
            }
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            v101 = (std::__shared_weak_count *)v131.__r_.__value_.__l.__size_;
            if (v131.__r_.__value_.__l.__size_
              && !atomic_fetch_add((atomic_ullong *volatile)(v131.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
              std::__shared_weak_count::__release_weak(v101);
            }
            goto LABEL_65;
          }
        }
      }
      unsigned int v88 = BBUpdaterController::performFirstStageInternal(a1, 1, &v129, &__p);
      if (!v88) {
        goto LABEL_65;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_182;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_182;
        }
      }
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v85, v86, v87, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
LABEL_182:
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&__dst, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = __p;
      }
      unint64_t v134 = v88;
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&__dst);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      goto LABEL_65;
    case 4:
      int v61 = *(BBUFeedback **)(a1 + 56);
      BBUFeedback::handleComment(v61, "entering %s", "StageContext::PersonalizeStageSecond");
      uint64_t v62 = *((void *)v61 + 19);
      uint64_t v63 = *((void *)v61 + 18);
      if (v62 == v63) {
        uint64_t v64 = 0;
      }
      else {
        uint64_t v64 = ((v62 - v63) << 7) - 1;
      }
      uint64_t v65 = *((void *)v61 + 22);
      unint64_t v66 = v65 + *((void *)v61 + 21);
      if (v64 == v66)
      {
        std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity((void *)v61 + 17);
        uint64_t v63 = *((void *)v61 + 18);
        uint64_t v65 = *((void *)v61 + 22);
        unint64_t v66 = *((void *)v61 + 21) + v65;
      }
      *(_DWORD *)(*(void *)(v63 + ((v66 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v66 & 0x3FF)) = 3;
      *((void *)v61 + 22) = v65 + 1;
      if (!*(void *)(a1 + 88))
      {
        exception = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)exception, 68, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x15Au, (ctu::LogMessageBuffer *)"Assertion failure(fProgrammer && \"Null programmer?\")", v120, v121, v122, v125);
LABEL_228:
      }
      unsigned int v70 = (*(uint64_t (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 80))(FirmwareDataSource);
      if (!v70)
      {
        uint64_t v71 = *(void *)(a1 + 96);
        if (v71)
        {
          uint64_t v72 = (*(uint64_t (**)(void))(**(void **)(v71 + 16) + 24))(*(void *)(v71 + 16));
          (*(void (**)(BBUEUR10UpdateSource *, uint64_t))(*(void *)FirmwareDataSource + 200))(FirmwareDataSource, v72);
          uint64_t v73 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 96) + 24) + 24))(*(void *)(*(void *)(a1 + 96) + 24));
          (*(void (**)(BBUEUR10UpdateSource *, uint64_t))(*(void *)FirmwareDataSource + 208))(FirmwareDataSource, v73);
        }
        unsigned int v77 = BBUpdaterController::performSecondStageInternal(a1, 1, (uint64_t *)&v129, &__p);
        if (!v77)
        {
          unsigned int v81 = BBUpdaterController::bootupInternal((BBULoader **)a1, (uint64_t *)&v129);
          if (!v81)
          {
            unsigned int v33 = BBUpdaterController::performPingInternal(a1, 0);
            if (!v33) {
              goto LABEL_63;
            }
            if (gBBULogMaskGet(void)::once == -1)
            {
              if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
                goto LABEL_176;
              }
            }
            else
            {
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
              if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
                goto LABEL_176;
              }
            }
            if (gBBULogVerbosity >= 6) {
              _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v82, v83, v84, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
            }
LABEL_176:
            std::string::basic_string[abi:ne180100]<0>(&v131, BBUReturnAsString::BBUReturnStrings[v33]);
            std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to ping baseband: ", &v131, &v132);
            unsigned int v38 = capabilities::updater::intermittentFailureRetryCount(v112);
            if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
              goto LABEL_215;
            }
            std::string __dst = v132;
LABEL_216:
            unint64_t v134 = __PAIR64__(v38, v33);
            BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>(a1, (uint64_t)&__dst);
LABEL_116:
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__dst.__r_.__value_.__l.__data_);
              if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_118:
                if ((SHIBYTE(v131.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_65;
                }
LABEL_122:
                operator delete(v131.__r_.__value_.__l.__data_);
                goto LABEL_65;
              }
            }
            else if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
              goto LABEL_118;
            }
            operator delete(v132.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v131.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_65;
            }
            goto LABEL_122;
          }
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
              goto LABEL_170;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
              goto LABEL_170;
            }
          }
          if (gBBULogVerbosity >= 6) {
            _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v78, v79, v80, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          }
LABEL_170:
          std::string::basic_string[abi:ne180100]<0>(&v131, BBUReturnAsString::BBUReturnStrings[v81]);
          std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to bootup baseband: ", &v131, &v132);
          unsigned int v111 = capabilities::updater::intermittentFailureRetryCount(v110);
          if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0)
          {
            unsigned int v114 = v111;
            std::string::__init_copy_ctor_external(&__dst, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
            unsigned int v111 = v114;
          }
          else
          {
            std::string __dst = v132;
          }
          unint64_t v134 = __PAIR64__(v111, v81);
          BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>(a1, (uint64_t)&__dst);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__dst.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_210:
              if ((SHIBYTE(v131.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_211:
                *(unsigned char *)(a1 + 354) = 1;
                goto LABEL_65;
              }
LABEL_214:
              operator delete(v131.__r_.__value_.__l.__data_);
              goto LABEL_211;
            }
          }
          else if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_210;
          }
          operator delete(v132.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v131.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_211;
          }
          goto LABEL_214;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_158;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_158;
          }
        }
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v74, v75, v76, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
LABEL_158:
        std::string::basic_string[abi:ne180100]<0>(&v126, BBUReturnAsString::BBUReturnStrings[v77]);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to perform second stage: ", &v126, &v127);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(": ", &v127, &cf);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v105 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v105 = __p.__r_.__value_.__l.__size_;
        }
        v106 = std::string::append(&cf, (const std::string::value_type *)p_p, v105);
        long long v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
        v131.__r_.__value_.__r.__words[2] = v106->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v131.__r_.__value_.__l.__data_ = v107;
        v106->__r_.__value_.__l.__size_ = 0;
        v106->__r_.__value_.__r.__words[2] = 0;
        v106->__r_.__value_.__r.__words[0] = 0;
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("\n", &v131, &v132);
        unsigned int v109 = capabilities::updater::intermittentFailureRetryCount(v108);
        if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0)
        {
          unsigned int v113 = v109;
          std::string::__init_copy_ctor_external(&__dst, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
          unsigned int v109 = v113;
        }
        else
        {
          std::string __dst = v132;
        }
        unint64_t v134 = __PAIR64__(v109, v77);
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>(a1, (uint64_t)&__dst);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__dst.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_195:
            if ((SHIBYTE(v131.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_196;
            }
            goto LABEL_202;
          }
        }
        else if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_195;
        }
        operator delete(v132.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v131.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_196:
          if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_197;
          }
          goto LABEL_203;
        }
LABEL_202:
        operator delete(v131.__r_.__value_.__l.__data_);
        if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_197:
          if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_198;
          }
          goto LABEL_204;
        }
LABEL_203:
        operator delete(cf.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v127.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_198:
          if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_65;
          }
LABEL_205:
          operator delete(v126.__r_.__value_.__l.__data_);
          goto LABEL_65;
        }
LABEL_204:
        operator delete(v127.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v126.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_65;
        }
        goto LABEL_205;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_133;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_133;
        }
      }
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v67, v68, v69, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
LABEL_133:
      std::string::basic_string[abi:ne180100]<0>(&v132, "Miss images for saveImages\n");
      if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&__dst, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v132;
      }
      unint64_t v134 = v70;
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&__dst);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v132.__r_.__value_.__l.__data_);
      }
      goto LABEL_65;
    case 8:
      uint64_t v21 = *(BBUFeedback **)(a1 + 56);
      BBUFeedback::handleComment(v21, "entering %s", "StageContext::PersonalizeBooted");
      uint64_t v22 = *((void *)v21 + 19);
      uint64_t v23 = *((void *)v21 + 18);
      if (v22 == v23) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = ((v22 - v23) << 7) - 1;
      }
      uint64_t v25 = *((void *)v21 + 22);
      unint64_t v26 = v25 + *((void *)v21 + 21);
      if (v24 == v26)
      {
        std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity((void *)v21 + 17);
        uint64_t v23 = *((void *)v21 + 18);
        uint64_t v25 = *((void *)v21 + 22);
        unint64_t v26 = *((void *)v21 + 21) + v25;
      }
      *(_DWORD *)(*(void *)(v23 + ((v26 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v26 & 0x3FF)) = 4;
      *((void *)v21 + 22) = v25 + 1;
      if (!(*(unsigned int (**)(void, void, uint64_t, uint64_t))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72), *(void *)(a1 + 48), 2, 1))
      {
        unsigned int v33 = BBUpdaterController::bootupInternal((BBULoader **)a1, (uint64_t *)&v129);
        if (!v33)
        {
          unsigned int v33 = BBUpdaterController::performPingInternal(a1, 0);
          if (!v33)
          {
LABEL_63:
            BBUpdaterController::performBootedStageInternal(a1, (uint64_t *)&v129);
            goto LABEL_65;
          }
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
              goto LABEL_29;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
              goto LABEL_29;
            }
          }
          if (gBBULogVerbosity >= 6) {
            _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v34, v35, v36, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          }
LABEL_29:
          std::string::basic_string[abi:ne180100]<0>(&v131, BBUReturnAsString::BBUReturnStrings[v33]);
          std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to ping baseband: ", &v131, &v132);
          unsigned int v38 = capabilities::updater::intermittentFailureRetryCount(v37);
          if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            std::string __dst = v132;
            goto LABEL_216;
          }
LABEL_215:
          unsigned int v115 = v38;
          std::string::__init_copy_ctor_external(&__dst, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
          unsigned int v38 = v115;
          goto LABEL_216;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_145;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_145;
          }
        }
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v30, v31, v32, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
LABEL_145:
        std::string::basic_string[abi:ne180100]<0>(&v131, BBUReturnAsString::BBUReturnStrings[v33]);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to bootup baseband: ", &v131, &v132);
        unsigned int v38 = capabilities::updater::intermittentFailureRetryCount(v103);
        if ((SHIBYTE(v132.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          std::string __dst = v132;
          goto LABEL_216;
        }
        goto LABEL_215;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_65;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_65;
        }
      }
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v27, v28, v29, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
      goto LABEL_65;
    case 32:
      uint64_t v39 = *(BBUFeedback **)(a1 + 56);
      BBUFeedback::handleComment(v39, "entering %s", "StageContext::PersonalizeEUICC");
      uint64_t v43 = *((void *)v39 + 19);
      uint64_t v44 = *((void *)v39 + 18);
      if (v43 == v44) {
        uint64_t v45 = 0;
      }
      else {
        uint64_t v45 = ((v43 - v44) << 7) - 1;
      }
      uint64_t v46 = *((void *)v39 + 22);
      unint64_t v47 = v46 + *((void *)v39 + 21);
      if (v45 == v47)
      {
        std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity((void *)v39 + 17);
        uint64_t v44 = *((void *)v39 + 18);
        uint64_t v46 = *((void *)v39 + 22);
        unint64_t v47 = *((void *)v39 + 21) + v46;
      }
      *(_DWORD *)(*(void *)(v44 + ((v47 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v47 & 0x3FF)) = 5;
      *((void *)v39 + 22) = v46 + 1;
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
          goto LABEL_40;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
          goto LABEL_40;
        }
      }
      if (gBBULogVerbosity >= 1) {
        _BBULog(19, 1, "BBUpdaterController", "", "perform eUICC update\n", v40, v41, v42, v124);
      }
LABEL_40:
      uint64_t v48 = *(const void **)(a1 + 40);
      cf.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
      if (v48) {
        CFRetain(v48);
      }
      unsigned int v52 = eUICC::Run((void *)(a1 + 152), (uint64_t)FirmwareDataSource, (const void **)&cf.__r_.__value_.__l.__data_);
      if (cf.__r_.__value_.__r.__words[0]) {
        CFRelease(cf.__r_.__value_.__l.__data_);
      }
      if (v52)
      {
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
            goto LABEL_137;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
          {
LABEL_137:
            if (gBBULogVerbosity >= 6) {
              _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v49, v50, v51, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
            }
          }
        }
        std::string::basic_string[abi:ne180100]<0>(&v131, BBUReturnAsString::BBUReturnStrings[v52]);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Failed performing eUICC: ", &v131, &v132);
        if (SHIBYTE(v132.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external(&__dst, v132.__r_.__value_.__l.__data_, v132.__r_.__value_.__l.__size_);
        }
        else {
          std::string __dst = v132;
        }
        unint64_t v134 = v52;
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&__dst);
        goto LABEL_116;
      }
      int v53 = *(const void **)(a1 + 40);
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v53;
      if (v53) {
        CFRetain(v53);
      }
      char v60 = eUICC::Done((const __CFDictionary **)&__dst);
      if (__dst.__r_.__value_.__r.__words[0]) {
        CFRelease(__dst.__r_.__value_.__l.__data_);
      }
      if (v60)
      {
        BBUpdaterController::getShouldFuseProvision(a1, (uint64_t)&v129, v54, v55, v56, v57, v58, v59);
        goto LABEL_65;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_151;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_151;
        }
      }
      if (gBBULogVerbosity > 5)
      {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v57, v58, v59, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        if (gBBULogMaskGet(void)::once != -1)
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
            goto LABEL_65;
          }
          goto LABEL_152;
        }
      }
LABEL_151:
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
        goto LABEL_65;
      }
LABEL_152:
      if (gBBULogVerbosity >= 1) {
        _BBULog(19, 1, "BBUpdaterController", "", "eUICC is not done yet, waiting\n", v57, v58, v59, v124);
      }
LABEL_65:
      BBUFeedback::exitStageContext(*(BBUFeedback **)(a1 + 56));
      if (FirmwareDataSource) {
        (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      return;
    default:
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x1CAu, (ctu::LogMessageBuffer *)"Assertion failure(false && \"Unrecognized BBU stage.\")", v117, v118, v119, v123);
      goto LABEL_228;
  }
}

void sub_21DE9F4D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a30)
  {
    (*(void (**)(uint64_t))(*(void *)a30 + 16))(a30);
    if ((a36 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a36 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t BBUpdaterController::performFirstStageInternal(uint64_t a1, int a2, void *a3, std::string *a4)
{
  uint64_t v8 = *(void *)(a1 + 96);
  if (v8)
  {
    uint64_t v9 = *a3;
    uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(v8 + 16) + 24))(*(void *)(v8 + 16));
    (*(void (**)(uint64_t, uint64_t))(*(void *)v9 + 200))(v9, v10);
    uint64_t v11 = *a3;
    uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 96) + 24) + 24))(*(void *)(*(void *)(a1 + 96) + 24));
    (*(void (**)(uint64_t, uint64_t))(*(void *)v11 + 208))(v11, v12);
  }
  uint64_t v13 = a2 ^ 1u;
  uint64_t v14 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a3 + 32))(*a3, v13);
  if (!v14)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_29;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_29:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v15, v16, v17, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::__assign_external(a4, "Firmware data does not contain programmer\n", 0x2AuLL);
    uint64_t v21 = 35;
    goto LABEL_24;
  }
  if (!*(void *)(a1 + 80))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 11, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x86Au, (ctu::LogMessageBuffer *)"Assertion failure(fLoader && \"No valid BBULoader!\")", v41, v42, v43, v44);
  }
  uint64_t v18 = v14;
  if (*(_DWORD *)(*(void *)(a1 + 96) + 88) == 3
    && ((*(uint64_t (**)(void))(*(void *)*a3 + 48))() & 1) == 0
    && (a2 & 1) == 0)
  {
    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Attempting to load an unpersonalized image on a fused radio\n");
    char v19 = *(BBUFeedback **)(a1 + 56);
    int v20 = (*(uint64_t (**)(void))(*(void *)*a3 + 48))();
    BBUFeedback::handleComment(v19, "hasManifestSource() = %d, personalize = %d\n", v20, 0);
    uint64_t v21 = 34;
    goto LABEL_24;
  }
  char v46 = 0;
  value = 0;
  CFDictionaryRef v22 = *(const __CFDictionary **)(a1 + 40);
  if (v22) {
    uint64_t v23 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    uint64_t v23 = 0;
  }
  if (!v23
    || !CFDictionaryGetValueIfPresent(v22, @"EraseEFS", (const void **)&value)
    || (uint64_t v24 = (BOOL *)value) == 0
    || (CFTypeID v25 = CFGetTypeID(value), v25 != CFBooleanGetTypeID())
    || (ctu::cf::assign((ctu::cf *)&v46, v24, v26), !v46)
    || BBUpdaterController::performFirstStageInternal(BOOL,std::unique_ptr<BBUUpdateSource> &,std::string &)::EFSErased == 1)
  {
    if (!*(unsigned char *)(a1 + 354))
    {
LABEL_21:
      uint64_t v31 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 80) + 40))(*(void *)(a1 + 80), a1 + 152, v18, v13);
      if (!v31)
      {
        uint64_t v21 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 80) + 48))(*(void *)(a1 + 80), a1 + 152, v18);
        if (!v21)
        {
          (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64), a1 + 152);
          goto LABEL_24;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
            goto LABEL_40;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
          {
LABEL_40:
            if (gBBULogVerbosity >= 6) {
              _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v35, v36, v37, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
            }
          }
        }
        std::string::__assign_external(a4, "Failed starting loader.", 0x17uLL);
        goto LABEL_24;
      }
      uint64_t v21 = v31;
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
          goto LABEL_34;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
        {
LABEL_34:
          if (gBBULogVerbosity >= 6) {
            _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v32, v33, v34, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          }
        }
      }
      if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0)
      {
        a4->__r_.__value_.__l.__size_ = 22;
        a4 = (std::string *)a4->__r_.__value_.__r.__words[0];
      }
      else
      {
        *((unsigned char *)&a4->__r_.__value_.__s + 23) = 22;
      }
      strcpy((char *)a4, "Failed loading loader.");
      goto LABEL_24;
    }
  }
  uint64_t v27 = (*(uint64_t (**)(void))(*(void *)*a3 + 176))();
  if (!v27)
  {
    BBUpdaterController::performFirstStageInternal(BOOL,std::unique_ptr<BBUUpdateSource> &,std::string &)::EFSErased = 1;
    *(unsigned char *)(a1 + 354) = 0;
    goto LABEL_21;
  }
  uint64_t v21 = v27;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_45;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_45:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v28, v29, v30, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  std::string::__assign_external(a4, "failed erasing baseband filesystem\n", 0x23uLL);
LABEL_24:
  uint64_t v38 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = 0;
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
  }
  return v21;
}

void sub_21DE9FF88(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUpdaterController::performSecondStageInternal(uint64_t a1, uint64_t a2, uint64_t *a3, std::string *a4)
{
  char v68 = 0;
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)*a3 + 128))();
  memset(&__p, 0, sizeof(__p));
  (*(void (**)(std::string *__return_ptr))(**(void **)(*(void *)(a1 + 96) + 32) + 24))(&value);
  uint64_t v9 = *a3;
  std::string __p = value;
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 40))(v9);
  uint64_t v11 = *a3;
  int v12 = *(_DWORD *)(*(void *)(a1 + 96) + 88);
  CFDictionaryRef v13 = *(const __CFDictionary **)(a1 + 40);
  if (v13) {
    uint64_t v14 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    uint64_t v14 = 0;
  }
  if (v14
    && (value.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL,
        CFDictionaryGetValueIfPresent(v13, @"apTicket", (const void **)&value.__r_.__value_.__l.__data_))
    && (CFTypeID v15 = CFGetTypeID(value.__r_.__value_.__l.__data_), v15 == CFDataGetTypeID()))
  {
    std::string::size_type v16 = value.__r_.__value_.__r.__words[0];
  }
  else
  {
    std::string::size_type v16 = 0;
  }
  uint64_t v17 = (capabilities::diag *)(*(uint64_t (**)(uint64_t, std::string *, uint64_t, BOOL, std::string::size_type, void))(*(void *)v11 + 168))(v11, &__p, v10, v12 == 3, v16, *(unsigned __int8 *)(a1 + 355));
  uint64_t v18 = (uint64_t)v17;
  if (v17) {
    goto LABEL_59;
  }
  if (BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS == -1)
  {
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1) {
      goto LABEL_12;
    }
LABEL_15:
    dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
    if (BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS) {
      goto LABEL_13;
    }
    goto LABEL_16;
  }
  dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
  if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS != -1) {
    goto LABEL_15;
  }
LABEL_12:
  if (BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS)
  {
LABEL_13:
    capabilities::diag::supportedInterfaces(v17);
    BOOL v19 = capabilities::diag::operator&() != 0;
    goto LABEL_25;
  }
LABEL_16:
  v65.__r_.__value_.__s.__data_[0] = 0;
  value.__r_.__value_.__r.__words[0] = 0;
  CFDictionaryRef v20 = *(const __CFDictionary **)(a1 + 40);
  if (v20) {
    uint64_t v21 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    uint64_t v21 = 0;
  }
  if (v21)
  {
    if (CFDictionaryGetValueIfPresent(v20, @"forceHSIC", (const void **)&value.__r_.__value_.__l.__data_))
    {
      CFDictionaryRef v22 = (BOOL *)value.__r_.__value_.__r.__words[0];
      if (value.__r_.__value_.__r.__words[0])
      {
        CFTypeID v23 = CFGetTypeID(value.__r_.__value_.__l.__data_);
        if (v23 == CFBooleanGetTypeID())
        {
          uint64_t v17 = (capabilities::diag *)ctu::cf::assign((ctu::cf *)&v65, v22, v24);
          if (v65.__r_.__value_.__s.__data_[0]) {
            goto LABEL_13;
          }
        }
      }
    }
  }
  BOOL v19 = 0;
LABEL_25:
  BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Setting DIAG over HSIC? %d", v19);
  CFTypeID v25 = *(unsigned char **)(a1 + 88);
  v25[64] = v19;
  uint64_t v26 = (*(uint64_t (**)(void))(*(void *)*a3 + 72))();
  uint64_t v27 = *(unsigned int *)(a1 + 260);
  LODWORD(v63) = 1;
  HIDWORD(v63) = BBUpdaterController::getNVRestoreSetting(*(BBUpdaterController **)(a1 + 40), v28, v29, v30, v31, v32, v33, v34);
  LOBYTE(v62) = 1;
  uint64_t v35 = (*(uint64_t (**)(unsigned char *, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int, char *, uint64_t))(*(void *)v25 + 40))(v25, v10, 0, a2, v8, v26, v27, 1, v62, &v68, v63);
  uint64_t v18 = v35;
  if (!a2)
  {
    if (!v35) {
      goto LABEL_55;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_39;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_39;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v36, v37, v38, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_39:
    (*(void (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
    if (v18 == 65) {
      uint64_t v43 = "Wrong firmware, doesn’t match hardware ID ";
    }
    else {
      uint64_t v43 = "Failed sending images ";
    }
    std::string::__assign_external(a4, v43);
    std::string::basic_string[abi:ne180100]<0>(&value, BBUReturnAsString::BBUReturnStrings[v18]);
    if ((value.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_std::string value = &value;
    }
    else {
      p_std::string value = (std::string *)value.__r_.__value_.__r.__words[0];
    }
    if ((value.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(value.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = value.__r_.__value_.__l.__size_;
    }
    std::string::append(a4, (const std::string::value_type *)p_value, size);
    if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(value.__r_.__value_.__l.__data_);
    }
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_87;
    }
LABEL_106:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
LABEL_87:
    if ((a4->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      LOBYTE(v57) = (_BYTE)a4;
    }
    else {
      std::string::size_type v57 = a4->__r_.__value_.__r.__words[0];
    }
LABEL_77:
    _BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "%s", v46, v47, v48, v57);
    goto LABEL_57;
  }
  if (v35)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_82;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_82;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v36, v37, v38, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_82:
    (*(void (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
    std::string::basic_string[abi:ne180100]<0>(&v65, BBUReturnAsString::BBUReturnStrings[v18]);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Failed personalizing in second stage ", &v65, &value);
    if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0) {
      operator delete(a4->__r_.__value_.__l.__data_);
    }
    *a4 = value;
    *((unsigned char *)&value.__r_.__value_.__s + 23) = 0;
    value.__r_.__value_.__s.__data_[0] = 0;
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v65.__r_.__value_.__l.__data_);
    }
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_87;
    }
    goto LABEL_106;
  }
  if (!v68) {
    goto LABEL_55;
  }
  uint64_t v39 = *a3;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 88) + 112))(&value);
  (*(void (**)(uint64_t, std::string *))(*(void *)v39 + 192))(v39, &value);
  std::string::size_type v40 = value.__r_.__value_.__r.__words[0];
  if (value.__r_.__value_.__r.__words[0])
  {
    std::string::size_type v41 = value.__r_.__value_.__l.__size_;
    uint64_t v42 = (void *)value.__r_.__value_.__r.__words[0];
    if (value.__r_.__value_.__l.__size_ != value.__r_.__value_.__r.__words[0])
    {
      do
      {
        if (*(char *)(v41 - 1) < 0) {
          operator delete(*(void **)(v41 - 24));
        }
        v41 -= 24;
      }
      while (v41 != v40);
      uint64_t v42 = (void *)value.__r_.__value_.__r.__words[0];
    }
    value.__r_.__value_.__l.__size_ = v40;
    operator delete(v42);
  }
  uint64_t v18 = (*(uint64_t (**)(void))(*(void *)*a3 + 136))();
  if (!v18)
  {
LABEL_55:
    uint64_t v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
    if (!v18)
    {
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64), a1 + 152);
      uint64_t v18 = 0;
      goto LABEL_57;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_66;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_66:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v52, v53, v54, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&v65, BBUReturnAsString::BBUReturnStrings[v18]);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Failed disconnecting programmer ", &v65, &value);
    if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0) {
      operator delete(a4->__r_.__value_.__l.__data_);
    }
    *a4 = value;
    *((unsigned char *)&value.__r_.__value_.__s + 23) = 0;
    value.__r_.__value_.__s.__data_[0] = 0;
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v65.__r_.__value_.__l.__data_);
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    if ((a4->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      LOBYTE(v57) = (_BYTE)a4;
    }
    else {
      std::string::size_type v57 = a4->__r_.__value_.__r.__words[0];
    }
    goto LABEL_77;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_94;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_94;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v49, v50, v51, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
  }
LABEL_94:
  (*(void (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
  std::string::basic_string[abi:ne180100]<0>(&v64, BBUReturnAsString::BBUReturnStrings[v18]);
  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Failed sending images ", &v64, &v65);
  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("\n", &v65, &value);
  if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0) {
    operator delete(a4->__r_.__value_.__l.__data_);
  }
  *a4 = value;
  *((unsigned char *)&value.__r_.__value_.__s + 23) = 0;
  value.__r_.__value_.__s.__data_[0] = 0;
  if ((SHIBYTE(v65.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v64.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_98;
    }
LABEL_104:
    operator delete(v64.__r_.__value_.__l.__data_);
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_99;
    }
LABEL_105:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    goto LABEL_99;
  }
  operator delete(v65.__r_.__value_.__l.__data_);
  if (SHIBYTE(v64.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_104;
  }
LABEL_98:
  if (gBBULogMaskGet(void)::once != -1) {
    goto LABEL_105;
  }
LABEL_99:
  if ((a4->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    LOBYTE(v61) = (_BYTE)a4;
  }
  else {
    std::string::size_type v61 = a4->__r_.__value_.__r.__words[0];
  }
  _BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "%s", v58, v59, v60, v61);
LABEL_57:
  uint64_t v55 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (v55) {
    (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
  }
LABEL_59:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  return v18;
}

void sub_21DEA0A9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0) {
    operator delete(a12);
  }
  if (a35 < 0)
  {
    operator delete(a30);
    if (v35) {
      goto LABEL_7;
    }
  }
  else if (v35)
  {
LABEL_7:
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(int **)(a1 + 16);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  uint64_t v27 = v4;
  uint64_t v28 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v26 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)v4 + 24))(__p, v4);
  uint64_t v5 = (void **)__p[0];
  uint64_t v6 = (void **)((char *)__p[0] + 24 * v4[8]);
  if (__dst != v6)
  {
    char v7 = *((unsigned char *)v6 + 23);
    if (SHIBYTE(v26) < 0)
    {
      if (v7 >= 0) {
        uint64_t v9 = (char *)__p[0] + 24 * v4[8];
      }
      else {
        uint64_t v9 = (char *)*v6;
      }
      if (v7 >= 0) {
        size_t v10 = *((unsigned __int8 *)v6 + 23);
      }
      else {
        size_t v10 = (size_t)v6[1];
      }
      std::string::__assign_no_alias<false>(__dst, v9, v10);
    }
    else if ((*((unsigned char *)v6 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v6, (size_t)v6[1]);
    }
    else
    {
      long long v8 = *(_OWORD *)v6;
      uint64_t v26 = (uint64_t)v6[2];
      *(_OWORD *)std::string __dst = v8;
    }
    uint64_t v5 = (void **)__p[0];
  }
  if (v5)
  {
    uint64_t v11 = (void **)__p[1];
    int v12 = v5;
    if (__p[1] != v5)
    {
      do
      {
        if (*((char *)v11 - 1) < 0) {
          operator delete(*(v11 - 3));
        }
        v11 -= 3;
      }
      while (v11 != v5);
      int v12 = (void **)__p[0];
    }
    __p[1] = v5;
    operator delete(v12);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFA9B00 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      std::string::size_type v16 = __p;
    }
    else {
      LOBYTE(v16) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v13, v14, v15, (char)v16);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  uint64_t v17 = (uint64_t)v27;
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::is_event_handling_blocked_helper<BBUpdaterControllerFSM::eventRetry>((uint64_t)v27)
    && boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventRetry,BBUpdaterControllerFSM::eventRetry>(v17, a2))
  {
    int v18 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(v17 + 32) + 240])(v17, 0);
    if (!(((unsigned int (*)(uint64_t, uint64_t))_MergedGlobals_1[*(_DWORD *)(v17 + 36) + 240])(v17, 1) | v18))
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>(v17, v17, *(_DWORD *)(v17 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>(v17, v17, *(_DWORD *)(v17 + 36));
    }
    *(unsigned char *)(v17 + 100) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v17);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_45;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_45;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFA9B00 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      CFDictionaryRef v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v19, v20, v21, (char)v22);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_45:
  if (SHIBYTE(v26) < 0) {
    operator delete(__dst[0]);
  }
  CFTypeID v23 = v28;
  if (v28)
  {
    if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

void sub_21DEA0F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  if (a23 < 0)
  {
    operator delete(__p);
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a25);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a25);
  _Unwind_Resume(a1);
}

__n128 std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>@<Q0>(char *__s@<X1>, std::string *a2@<X0>, std::string *a3@<X8>)
{
  std::string::size_type v6 = strlen(__s);
  char v7 = (__n128 *)std::string::append(a2, __s, v6);
  __n128 result = *v7;
  *a3 = *(std::string *)v7->n128_u8;
  v7->n128_u64[0] = 0;
  v7->n128_u64[1] = 0;
  v7[1].n128_u64[0] = 0;
  return result;
}

uint64_t BBUpdaterController::bootupInternal(BBULoader **a1, uint64_t *a2)
{
  memset(&v18, 0, sizeof(v18));
  uint64_t InfoFirstStageInternal = (*(uint64_t (**)(void))(*(void *)*a2 + 80))();
  if (InfoFirstStageInternal)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_12;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_12:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v4, v5, v6, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, "Miss images for bootupInternal\n");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v15, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v15 = __p;
    }
    int v16 = InfoFirstStageInternal;
    int v17 = 0;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)a1, (uint64_t)&v15);
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    goto LABEL_7;
  }
  BBUFeedback::handleBeginPhase(a1[7], "bootup");
  uint64_t InfoFirstStageInternal = BBUpdaterController::queryInfoFirstStageInternal(a1, v8);
  BBUFeedback::handleComment(a1[7], "queryInfoFirstStageInternal ret status is %d", InfoFirstStageInternal);
  if (!InfoFirstStageInternal)
  {
    uint64_t InfoFirstStageInternal = BBUpdaterController::pushImagesInternal((uint64_t)a1, a2, 0, &v18);
    if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v12 = &v18;
    }
    else {
      int v12 = (std::string *)v18.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(a1[7], "pushImagesInternal ret status is %d: %s\n", InfoFirstStageInternal, (const char *)v12);
    goto LABEL_7;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_7;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_7;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v9, v10, v11, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
  }
LABEL_7:
  (*(void (**)(BBULoader *, uint64_t))(*(void *)a1[7] + 16))(a1[7], InfoFirstStageInternal);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
  return InfoFirstStageInternal;
}

void sub_21DEA133C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBUpdaterController::performPingInternal(uint64_t a1, unint64_t a2)
{
  char v2 = a2;
  uint64_t v4 = HIDWORD(a2);
  uint64_t v5 = capabilities::updater::pingDelay((capabilities::updater *)a1);
  if (v2) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = v5;
  }
  if (v6 >= 1)
  {
    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Waiting %llu milliseconds before first ping", v6);
    if (v6 == 0x8637BD057A0) {
      int v7 = 0;
    }
    else {
      int v7 = -127;
    }
    if ((unint64_t)v6 > 0x8637BD057A0) {
      int v7 = 1;
    }
    if ((unint64_t)v6 < 0x8637BD057A0) {
      int v7 = -1;
    }
    BOOL v8 = v7 >= 0 || v7 == -127;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = 1000000 * v6;
    if (v8) {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v9 = 0x7FFFFFFFFFFFFFFFLL;
    }
    __ns[0].__rep_ = v9;
    std::this_thread::sleep_for (__ns);
  }
  uint64_t TransportNoEvents = BBUpdaterController::createTransportNoEvents(a1, 0, 8);
  if (TransportNoEvents)
  {
    uint64_t v21 = TransportNoEvents;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_25:
        if (gBBULogVerbosity >= 6)
        {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v11, v12, v13, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          if (gBBULogMaskGet(void)::once != -1) {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          }
        }
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_25;
      }
    }
    std::string::basic_string[abi:ne180100]<0>(__ns, BBUReturnAsString::BBUReturnStrings[v21]);
    if (v31 >= 0) {
      CFTypeID v25 = __ns;
    }
    else {
      LOBYTE(v25) = __ns[0].__rep_;
    }
    _BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "Fail to create transport %s\n", v22, v23, v24, (char)v25);
    if (v31 < 0) {
      operator delete((void *)__ns[0].__rep_);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    uint64_t v26 = qword_26AA89AB0;
    if (!qword_26AA89AB0)
    {
      BBUError::create_default_global((std::__shared_weak_count_vtbl **)__ns);
      std::shared_ptr<BBUError>::operator=[abi:ne180100]((uint64_t)&qword_26AA89AB0, (long long *)&__ns[0].__rep_);
      std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)__ns);
      uint64_t v26 = qword_26AA89AB0;
    }
    blocuint64_t k = v26;
    uint64_t v33 = off_26AA89AB8;
    if (off_26AA89AB8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    std::string::basic_string[abi:ne180100]<0>(__ns, "Fail to create transport\n");
    goto LABEL_48;
  }
  uint64_t v14 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 72) + 24))(*(void *)(a1 + 72), a1 + 152);
  if (!v14)
  {
    TelephonyBasebandGetReset();
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    char v31 = 17;
    *(_OWORD *)&__ns[0].__rep_ = *(_OWORD *)"kBBUReturnSuccess";
    __int16 v30 = str_4[16];
    _BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "BB ping return status: %s\n", v18, v19, v20, (char)__ns);
    if (v31 < 0) {
      operator delete((void *)__ns[0].__rep_);
    }
    return 0;
  }
  uint64_t v21 = v14;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_40:
      if (gBBULogVerbosity >= 6)
      {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v15, v16, v17, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
      }
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_40;
    }
  }
  _BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "Timeout on waiting for BB init status\n", v15, v16, v17, v28);
  pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  uint64_t v26 = qword_26AA89AB0;
  if (!qword_26AA89AB0)
  {
    BBUError::create_default_global((std::__shared_weak_count_vtbl **)__ns);
    std::shared_ptr<BBUError>::operator=[abi:ne180100]((uint64_t)&qword_26AA89AB0, (long long *)&__ns[0].__rep_);
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)__ns);
    uint64_t v26 = qword_26AA89AB0;
  }
  blocuint64_t k = v26;
  uint64_t v33 = off_26AA89AB8;
  if (off_26AA89AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  std::string::basic_string[abi:ne180100]<0>(__ns, "Timeout on waiting for BB init status\n");
LABEL_48:
  BBUError::addError(v26, (uint64_t)__ns, v21);
  if (v31 < 0) {
    operator delete((void *)__ns[0].__rep_);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&block);
  return v21;
}

void sub_21DEA1B64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
}

void BBUpdaterController::performBootedStageInternal(uint64_t a1, uint64_t *a2)
{
  if (!BBUpdaterController::shouldPerformEUICC((const __CFDictionary **)a1)) {
    goto LABEL_29;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      goto LABEL_6;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      goto LABEL_6;
    }
  }
  if (gBBULogVerbosity >= 1) {
    _BBULog(19, 1, "BBUpdaterController", "", "Running eUICC\n", v7, v8, v9, v42);
  }
LABEL_6:
  uint64_t v10 = *a2;
  uint64_t v11 = *(const void **)(a1 + 40);
  uint64_t v49 = v11;
  if (v11) {
    CFRetain(v11);
  }
  int v15 = eUICC::Run((void *)(a1 + 152), v10, &v49);
  if (v49) {
    CFRelease(v49);
  }
  if (v15)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_81;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_81;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v12, v13, v14, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_81:
    std::string::basic_string[abi:ne180100]<0>(&v45, BBUReturnAsString::BBUReturnStrings[v15]);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Failed running eUICC: ", &v45, &v50);
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, v50.__r_.__value_.__l.__data_, v50.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v50;
    }
    int v47 = v15;
    int v48 = 0;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_86:
        if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          return;
        }
        goto LABEL_90;
      }
    }
    else if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_86;
    }
    operator delete(v50.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_90:
    operator delete(v45.__r_.__value_.__l.__data_);
    return;
  }
  uint64_t v16 = *(const void **)(a1 + 40);
  CFTypeRef cf = v16;
  if (v16) {
    CFRetain(v16);
  }
  if (eUICC::Done((const __CFDictionary **)&cf))
  {
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_29;
  }
  int v17 = *(_DWORD *)(*(void *)(a1 + 96) + 88);
  if (cf) {
    CFRelease(cf);
  }
  if (v17 != 3)
  {
LABEL_29:
    int ShouldFuseProvision = BBUpdaterController::getShouldFuseProvision(a1, (uint64_t)a2, v4, v5, v6, v7, v8, v9);
    if (!ShouldFuseProvision) {
      return;
    }
    char v41 = ShouldFuseProvision;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_71;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_71:
        if (gBBULogVerbosity >= 6)
        {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v25, v26, v27, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          if (gBBULogMaskGet(void)::once != -1) {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          }
        }
      }
    }
    _BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "getShouldFuseProv %d\n", v25, v26, v27, v41);
    return;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      goto LABEL_23;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      goto LABEL_23;
    }
  }
  if (gBBULogVerbosity >= 1) {
    _BBULog(19, 1, "BBUpdaterController", "", "eUICC is not done yet\n", v7, v8, v9, v42);
  }
LABEL_23:
  uint64_t v19 = *(int **)(a1 + 16);
  std::string::size_type v18 = *(void *)(a1 + 24);
  v45.__r_.__value_.__r.__words[0] = (std::string::size_type)v19;
  v45.__r_.__value_.__l.__size_ = v18;
  if (v18) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
  }
  __p.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  __p.__r_.__value_.__r.__words[2] = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)&__p, "unknown");
  memset(&v50, 170, sizeof(v50));
  (*(void (**)(std::string *__return_ptr, int *))(*(void *)v19 + 24))(&v50, v19);
  std::string::size_type v20 = v50.__r_.__value_.__r.__words[0];
  std::string::size_type v21 = v50.__r_.__value_.__r.__words[0] + 24 * v19[8];
  if (&__p != (std::string *)v21)
  {
    char v22 = *(unsigned char *)(v21 + 23);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v22 >= 0) {
        char v28 = (void *)(v50.__r_.__value_.__r.__words[0] + 24 * v19[8]);
      }
      else {
        char v28 = *(void **)v21;
      }
      if (v22 >= 0) {
        size_t v29 = *(unsigned __int8 *)(v21 + 23);
      }
      else {
        size_t v29 = *(void *)(v21 + 8);
      }
      std::string::__assign_no_alias<false>((void **)&__p.__r_.__value_.__l.__data_, v28, v29);
    }
    else if ((*(unsigned char *)(v21 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(&__p, *(void **)v21, *(void *)(v21 + 8));
    }
    else
    {
      long long v23 = *(_OWORD *)v21;
      __p.__r_.__value_.__r.__words[2] = *(void *)(v21 + 16);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v23;
    }
    std::string::size_type v20 = v50.__r_.__value_.__r.__words[0];
  }
  if (v20)
  {
    std::string::size_type size = v50.__r_.__value_.__l.__size_;
    char v31 = (void *)v20;
    if (v50.__r_.__value_.__l.__size_ != v20)
    {
      do
      {
        if (*(char *)(size - 1) < 0) {
          operator delete(*(void **)(size - 24));
        }
        size -= 24;
      }
      while (size != v20);
      char v31 = (void *)v50.__r_.__value_.__r.__words[0];
    }
    v50.__r_.__value_.__l.__size_ = v20;
    operator delete(v31);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_56;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_56;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)&v50, (const char *)(0x800000021DFAA353 & 0x7FFFFFFFFFFFFFFFLL));
    if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v35 = &v50;
    }
    else {
      LOBYTE(v35) = v50.__r_.__value_.__s.__data_[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v32, v33, v34, (char)v35);
    if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v50.__r_.__value_.__l.__data_);
    }
  }
LABEL_56:
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventEUICC>((uint64_t)v45.__r_.__value_.__l.__data_, (uint64_t)&v43, 1);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
    {
LABEL_58:
      if ((gBBULogVerbosity & 0x80000000) == 0)
      {
        boost::core::demangle((boost::core *)&v50, (const char *)(0x800000021DFAA353 & 0x7FFFFFFFFFFFFFFFLL));
        if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v39 = &v50;
        }
        else {
          LOBYTE(v39) = v50.__r_.__value_.__s.__data_[0];
        }
        _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v36, v37, v38, (char)v39);
        if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v50.__r_.__value_.__l.__data_);
        }
      }
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
      goto LABEL_58;
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string::size_type v40 = (std::__shared_weak_count *)v45.__r_.__value_.__l.__size_;
  if (v45.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(v45.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
}

void sub_21DEA2364(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (*(char *)(v25 - 49) < 0)
  {
    operator delete(*(void **)(v25 - 72));
    if ((a19 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a19 & 0x80000000) == 0)
  {
LABEL_6:
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t BBUpdaterController::pushImagesInternal(uint64_t a1, uint64_t *a2, int a3, std::string *a4)
{
  if (capabilities::radio::supportsBasebandStateController((capabilities::radio *)a1)) {
    TelephonyBasebandSetBasebandState();
  }
  StageInternal = (capabilities::updater *)BBUpdaterController::performFirstStageInternal(a1, 0, a2, a4);
  if (StageInternal)
  {
    uint64_t v38 = (uint64_t)StageInternal;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_30;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_30;
      }
    }
    if (gBBULogVerbosity < 6) {
      goto LABEL_30;
    }
    goto LABEL_40;
  }
  if (capabilities::updater::supportsMHIBootLogger(StageInternal))
  {
    int v12 = *(_DWORD *)(a1 + 340);
    if (v12)
    {
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = (std::__shared_weak_count_vtbl *)operator new(0x90uLL);
      BBUBootLogger::BBUBootLogger((uint64_t)v14, v12, v13);
      __p.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
      __p.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
      std::shared_ptr<BBUBootLogger>::shared_ptr[abi:ne180100]<BBUBootLogger,std::shared_ptr<BBUBootLogger> ctu::SharedSynchronizable<BBUBootLogger>::make_shared_ptr<BBUBootLogger>(BBUBootLogger*)::{lambda(BBUBootLogger*)#1},void>((std::__shared_weak_count_vtbl **)&__p, v14);
      long long v15 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
      uint64_t v16 = *(std::__shared_weak_count **)(a1 + 144);
      *(_OWORD *)(a1 + 136) = v15;
      if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
      std::string::size_type size = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
      if (__p.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
      std::string::size_type v18 = *(BBUBootLogger **)(a1 + 136);
      if (v18) {
        BBUBootLogger::openTransport(v18);
      }
    }
  }
  StageInternal = (capabilities::updater *)BBUpdaterController::queryInfoSecondStageInternal(a1, 0, (uint64_t)a2);
  if (StageInternal)
  {
    uint64_t v38 = (uint64_t)StageInternal;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_30;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_30;
      }
    }
    if (gBBULogVerbosity < 6) {
      goto LABEL_30;
    }
LABEL_40:
    StageInternal = (capabilities::updater *)_BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v9, v10, v11, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    goto LABEL_30;
  }
  uint64_t v19 = *(void *)(a1 + 88);
  if (!v19)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 68, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0xA81u, (ctu::LogMessageBuffer *)"Assertion failure(fProgrammer && \"No valid BBU Programmer!\")", v46, v47, v48, v49);
  }
  int v20 = *(_DWORD *)(a1 + 356);
  *(unsigned char *)(v19 + 64) = v20 == 4;
  BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Preferred interface for DIAG? 0x%x", v20);
  if (!a3 || !capabilities::updater::shouldSkipRestoreForUnfused(v21)) {
    goto LABEL_27;
  }
  uint64_t v22 = *a2;
  (*(void (**)(std::string *__return_ptr))(**(void **)(a1 + 88) + 112))(&__p);
  (*(void (**)(uint64_t, std::string *))(*(void *)v22 + 192))(v22, &__p);
  std::string::size_type v23 = __p.__r_.__value_.__r.__words[0];
  if (__p.__r_.__value_.__r.__words[0])
  {
    std::string::size_type v24 = __p.__r_.__value_.__l.__size_;
    uint64_t v25 = (void *)__p.__r_.__value_.__r.__words[0];
    if (__p.__r_.__value_.__l.__size_ != __p.__r_.__value_.__r.__words[0])
    {
      do
      {
        if (*(char *)(v24 - 1) < 0) {
          operator delete(*(void **)(v24 - 24));
        }
        v24 -= 24;
      }
      while (v24 != v23);
      uint64_t v25 = (void *)__p.__r_.__value_.__r.__words[0];
    }
    __p.__r_.__value_.__l.__size_ = v23;
    operator delete(v25);
  }
  uint64_t v26 = (*(uint64_t (**)(void))(*(void *)*a2 + 136))();
  if (!v26)
  {
LABEL_27:
    uint64_t v30 = *(void *)(a1 + 96);
    if (v30)
    {
      uint64_t v31 = *a2;
      uint64_t v32 = (*(uint64_t (**)(void))(**(void **)(v30 + 16) + 24))(*(void *)(v30 + 16));
      (*(void (**)(uint64_t, uint64_t))(*(void *)v31 + 200))(v31, v32);
      uint64_t v33 = *a2;
      uint64_t v34 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 96) + 24) + 24))(*(void *)(*(void *)(a1 + 96) + 24));
      (*(void (**)(uint64_t, uint64_t))(*(void *)v33 + 208))(v33, v34);
    }
    StageInternal = (capabilities::updater *)BBUpdaterController::performSecondStageInternal(a1, 0, a2, a4);
    uint64_t v38 = 0;
    if (!StageInternal) {
      goto LABEL_30;
    }
    std::string::size_type v40 = StageInternal;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_43;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_43:
        if (gBBULogVerbosity >= 6) {
          StageInternal = (capabilities::updater *)_BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v35, v36, v37, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    uint64_t v38 = (uint64_t)v40;
    goto LABEL_30;
  }
  uint64_t v38 = v26;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_48;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_48:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v27, v28, v29, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  (*(void (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
  std::string::basic_string[abi:ne180100]<0>(&v50, BBUReturnAsString::BBUReturnStrings[v38]);
  std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Failed saving images ", &v50, &__p);
  if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0) {
    operator delete(a4->__r_.__value_.__l.__data_);
  }
  *a4 = __p;
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
  __p.__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  if ((a4->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    LOBYTE(v44) = (_BYTE)a4;
  }
  else {
    std::string::size_type v44 = a4->__r_.__value_.__r.__words[0];
  }
  StageInternal = (capabilities::updater *)_BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "%s", v41, v42, v43, v44);
LABEL_30:
  if (capabilities::radio::supportsBasebandStateController(StageInternal)) {
    TelephonyBasebandSetBasebandState();
  }
  return v38;
}

void sub_21DEA2BA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_21DEA2BDC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void BBUpdaterController::bootup(BBUpdaterController *this)
{
  char v2 = (BBUFeedback *)*((void *)this + 7);
  BBUFeedback::handleComment(v2, "entering %s", "StageContext::Boot");
  uint64_t v3 = *((void *)v2 + 19);
  uint64_t v4 = *((void *)v2 + 18);
  if (v3 == v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = ((v3 - v4) << 7) - 1;
  }
  uint64_t v6 = *((void *)v2 + 22);
  unint64_t v7 = v6 + *((void *)v2 + 21);
  if (v5 == v7)
  {
    std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity((void *)v2 + 17);
    uint64_t v4 = *((void *)v2 + 18);
    uint64_t v6 = *((void *)v2 + 22);
    unint64_t v7 = *((void *)v2 + 21) + v6;
  }
  *(_DWORD *)(*(void *)(v4 + ((v7 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v7 & 0x3FF)) = 1;
  *((void *)v2 + 22) = v6 + 1;
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(this, 1);
  int v12 = FirmwareDataSource;
  uint64_t v27 = FirmwareDataSource;
  if (!FirmwareDataSource)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_24;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_24:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v9, v10, v11, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&cf, "Fail to get update source for bootup\n");
    if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&value, cf.__r_.__value_.__l.__data_, cf.__r_.__value_.__l.__size_);
    }
    else {
      std::string value = cf;
    }
    uint64_t v26 = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&value);
    if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(value.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(cf.__r_.__value_.__l.__data_);
    }
    goto LABEL_19;
  }
  capabilities::diag::supportedInterfaces(FirmwareDataSource);
  if (capabilities::diag::operator&()) {
    *((_DWORD *)this + 89) = 1;
  }
  uint64_t v13 = (capabilities::updater *)BBUpdaterController::bootupInternal((BBULoader **)this, (uint64_t *)&v27);
  if (v13)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_19;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v14, v15, v16, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
  }
  else
  {
    if (!capabilities::updater::shouldWaitForReadyAfterBoot(v13)) {
      goto LABEL_18;
    }
    value.__r_.__value_.__r.__words[0] = 0;
    if (!CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 5), @"waitForReady", (const void **)&value.__r_.__value_.__l.__data_)|| !CFBooleanGetValue((CFBooleanRef)value.__r_.__value_.__l.__data_))
    {
      goto LABEL_18;
    }
    unint64_t v23 = 2863311360;
    cf.__r_.__value_.__r.__words[0] = 0;
    if (CFDictionaryGetValueIfPresent(*((CFDictionaryRef *)this + 5), @"waitForReadyDelayMilliseconds", (const void **)&cf.__r_.__value_.__l.__data_))
    {
      LOBYTE(v23) = 1;
      int v17 = (unsigned int *)cf.__r_.__value_.__r.__words[0];
      if (cf.__r_.__value_.__r.__words[0])
      {
        CFTypeID v18 = CFGetTypeID(cf.__r_.__value_.__l.__data_);
        if (v18 == CFNumberGetTypeID()) {
          ctu::cf::assign((ctu::cf *)((char *)&v23 + 4), v17, v19);
        }
      }
    }
    if (!BBUpdaterController::performPingInternal((uint64_t)this, v23))
    {
LABEL_18:
      CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 4), @"done", (const void *)*MEMORY[0x263EFFB40]);
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventContinue>(*((int **)this + 2), *((std::__shared_weak_count **)this + 3), (uint64_t)&value);
      goto LABEL_19;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_19;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_19;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v20, v21, v22, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
  }
LABEL_19:
  BBUFeedback::exitStageContext(*((BBUFeedback **)this + 7));
  if (v12) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)v12 + 16))(v12);
  }
}

void sub_21DEA302C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void BBUpdaterController::process_event<BBUpdaterControllerFSM::eventContinue>(int *a1, std::__shared_weak_count *a2, uint64_t a3)
{
  uint64_t v25 = a1;
  uint64_t v26 = a2;
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v24 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)a1 + 24))(__p, a1);
  uint64_t v5 = (void **)__p[0];
  uint64_t v6 = (void **)((char *)__p[0] + 24 * a1[8]);
  if (__dst != v6)
  {
    char v7 = *((unsigned char *)v6 + 23);
    if (SHIBYTE(v24) < 0)
    {
      if (v7 >= 0) {
        uint64_t v9 = (char *)__p[0] + 24 * a1[8];
      }
      else {
        uint64_t v9 = (char *)*v6;
      }
      if (v7 >= 0) {
        size_t v10 = *((unsigned __int8 *)v6 + 23);
      }
      else {
        size_t v10 = (size_t)v6[1];
      }
      std::string::__assign_no_alias<false>(__dst, v9, v10);
    }
    else if ((*((unsigned char *)v6 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v6, (size_t)v6[1]);
    }
    else
    {
      long long v8 = *(_OWORD *)v6;
      uint64_t v24 = (uint64_t)v6[2];
      *(_OWORD *)std::string __dst = v8;
    }
    uint64_t v5 = (void **)__p[0];
  }
  if (v5)
  {
    uint64_t v11 = (void **)__p[1];
    int v12 = v5;
    if (__p[1] != v5)
    {
      do
      {
        if (*((char *)v11 - 1) < 0) {
          operator delete(*(v11 - 3));
        }
        v11 -= 3;
      }
      while (v11 != v5);
      int v12 = (void **)__p[0];
    }
    __p[1] = v5;
    operator delete(v12);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFA9D01 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v16 = __p;
    }
    else {
      LOBYTE(v16) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v13, v14, v15, (char)v16);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventContinue>((uint64_t)v25, a3, 1);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFA9D01 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v20 = __p;
    }
    else {
      LOBYTE(v20) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v17, v18, v19, (char)v20);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_40:
  if (SHIBYTE(v24) < 0) {
    operator delete(__dst[0]);
  }
  uint64_t v21 = v26;
  if (v26)
  {
    if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_21DEA3424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  std::vector<std::string>::~vector[abi:ne180100](&a12);
  if ((a23 & 0x80000000) == 0)
  {
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v23 - 64);
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v23 - 64);
  _Unwind_Resume(a1);
}

void BBUpdaterController::checkManifest(BBUpdaterController *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(13, 0, "BBUpdaterController", "", "Perform manifest check\n", a6, a7, a8, v61);
  }
LABEL_5:
  uint64_t v9 = (BBUFeedback *)*((void *)this + 7);
  BBUFeedback::handleComment(v9, "entering %s", "StageContext::CheckManifest");
  uint64_t v10 = *((void *)v9 + 19);
  uint64_t v11 = *((void *)v9 + 18);
  if (v10 == v11) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = ((v10 - v11) << 7) - 1;
  }
  uint64_t v13 = *((void *)v9 + 22);
  unint64_t v14 = v13 + *((void *)v9 + 21);
  if (v12 == v14)
  {
    std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity((void *)v9 + 17);
    uint64_t v11 = *((void *)v9 + 18);
    uint64_t v13 = *((void *)v9 + 22);
    unint64_t v14 = *((void *)v9 + 21) + v13;
  }
  *(_DWORD *)(*(void *)(v11 + ((v14 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v14 & 0x3FF)) = 7;
  *((void *)v9 + 22) = v13 + 1;
  *((unsigned char *)this + 355) = 1;
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(this, 1);
  uint64_t v63 = FirmwareDataSource;
  if (!FirmwareDataSource)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_71;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_71:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v15, v16, v17, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&v65, "Fail to get update source for checkManifest\n");
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external((std::string *)v68, v65.__r_.__value_.__l.__data_, v65.__r_.__value_.__l.__size_);
    }
    else {
      *(std::string *)char v68 = v65;
    }
    *(void *)&v68[24] = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)v68);
    if ((v68[23] & 0x80000000) != 0) {
      operator delete(*(void **)v68);
    }
    if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v65.__r_.__value_.__l.__data_);
    }
    goto LABEL_59;
  }
  if (!(*(unsigned int (**)(void, void, uint64_t, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), *((void *)this + 6), 2, 1))
  {
    *((unsigned char *)this + 352) = 1;
    unsigned int v25 = BBUpdaterController::bootupInternal((BBULoader **)this, (uint64_t *)&v63);
    if (!v25)
    {
      unsigned int v25 = BBUpdaterController::performPingInternal((uint64_t)this, 0);
      if (!v25)
      {
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
            goto LABEL_19;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
            goto LABEL_19;
          }
        }
        if ((gBBULogVerbosity & 0x80000000) == 0) {
          _BBULog(13, 0, "BBUpdaterController", "", "Perform internal manifest check\n", v26, v27, v28, v62);
        }
LABEL_19:
        unint64_t v75 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v29 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v29 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v74[7] = v29;
        v74[8] = v29;
        v74[5] = v29;
        v74[6] = v29;
        v74[3] = v29;
        v74[4] = v29;
        v74[1] = v29;
        v74[2] = v29;
        long long v73 = v29;
        v74[0] = v29;
        *(_OWORD *)std::string __p = v29;
        long long v72 = v29;
        long long v69 = v29;
        long long v70 = v29;
        *(_OWORD *)char v68 = v29;
        *(_OWORD *)&v68[16] = v29;
        std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v68);
        char v67 = 0;
        uint64_t v30 = (capabilities::updater *)(*(uint64_t (**)(void, char *, void, char *, char *, void))(**((void **)this + 9) + 96))(*((void *)this + 9), (char *)this + 152, *((void *)this + 12), &v67, (char *)this + 240, 0);
        unsigned int v34 = v30;
        if (!v30)
        {
          uint64_t v35 = (void *)*((void *)this + 12);
          uint64_t v37 = v35[8];
          uint64_t v36 = v35[9];
          uint64_t v38 = v35[10];
          if (v36)
          {
            uint64_t v30 = (capabilities::updater *)(*(uint64_t (**)(uint64_t))(*(void *)v36 + 24))(v36);
            int v39 = (int)v30;
            if (v37) {
              goto LABEL_22;
            }
          }
          else
          {
            int v39 = -1;
            if (v37)
            {
LABEL_22:
              uint64_t v30 = (capabilities::updater *)(*(uint64_t (**)(uint64_t))(*(void *)v37 + 24))(v37);
              int v40 = (int)v30;
              if (v38) {
                goto LABEL_23;
              }
              goto LABEL_27;
            }
          }
          int v40 = -1;
          if (v38)
          {
LABEL_23:
            uint64_t v30 = (capabilities::updater *)(*(uint64_t (**)(uint64_t))(*(void *)v38 + 24))(v38);
            unsigned int v34 = v30;
            if (!v37) {
              goto LABEL_34;
            }
            goto LABEL_28;
          }
LABEL_27:
          unsigned int v34 = -1;
          if (!v37) {
            goto LABEL_34;
          }
LABEL_28:
          if (!v36 || v39 || v40)
          {
LABEL_34:
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)"Detected non-zero cal/prov/fac manifests status  [CMStatus=", 59);
            uint64_t v41 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)" ,PMStatus=", 11);
            uint64_t v42 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)", FCMStatus=", 12);
            uint64_t v43 = (void *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)" ]", 2);
            memset(&__dst, 170, sizeof(__dst));
            if ((BYTE8(v73) & 0x10) != 0)
            {
              uint64_t v46 = v73;
              if ((unint64_t)v73 < *((void *)&v70 + 1))
              {
                *(void *)&long long v73 = *((void *)&v70 + 1);
                uint64_t v46 = *((void *)&v70 + 1);
              }
              uint64_t v47 = (const void *)v70;
              std::string::size_type v44 = v46 - v70;
              if ((unint64_t)(v46 - v70) >= 0x7FFFFFFFFFFFFFF8) {
                goto LABEL_65;
              }
            }
            else
            {
              if ((BYTE8(v73) & 8) == 0)
              {
                std::string::size_type v44 = 0;
                *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
                p_dst = &__dst;
                goto LABEL_47;
              }
              uint64_t v47 = *(const void **)&v68[24];
              std::string::size_type v44 = *((void *)&v69 + 1) - *(void *)&v68[24];
              if (*((void *)&v69 + 1) - *(void *)&v68[24] >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_65:
              }
                std::string::__throw_length_error[abi:ne180100]();
            }
            if (v44 >= 0x17)
            {
              uint64_t v48 = (v44 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v44 | 7) != 0x17) {
                uint64_t v48 = v44 | 7;
              }
              uint64_t v49 = v48 + 1;
              p_dst = (std::string *)operator new(v48 + 1);
              __dst.__r_.__value_.__l.__size_ = v44;
              __dst.__r_.__value_.__r.__words[2] = v49 | 0x8000000000000000;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
            }
            else
            {
              *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v44;
              p_dst = &__dst;
              if (!v44)
              {
LABEL_47:
                p_dst->__r_.__value_.__s.__data_[v44] = 0;
                std::string v50 = &__dst;
                if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  std::string v50 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                }
                BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "%s", (const char *)v50);
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  std::string::__init_copy_ctor_external(&v65, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                }
                else {
                  std::string v65 = __dst;
                }
                uint64_t v66 = 38;
                BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v65);
                if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(v65.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_54;
                  }
                }
                else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
LABEL_54:
                  unsigned int v34 = 38;
                  goto LABEL_55;
                }
                operator delete(__dst.__r_.__value_.__l.__data_);
                goto LABEL_54;
              }
            }
            memmove(p_dst, v47, v44);
            goto LABEL_47;
          }
          if (!v38 || v34)
          {
            if (capabilities::updater::supportsFATPCalibrationManifestStatus(v30)) {
              goto LABEL_34;
            }
            unsigned int v34 = 0;
          }
LABEL_55:
          *(void *)char v68 = *MEMORY[0x263F8C2C8];
          *(void *)&v68[*(void *)(*(void *)v68 - 24)] = *(void *)(MEMORY[0x263F8C2C8] + 24);
          *(void *)&v68[8] = MEMORY[0x263F8C318] + 16;
          if (SHIBYTE(v72) < 0) {
            operator delete(__p[1]);
          }
          std::streambuf::~streambuf();
          std::ostream::~ostream();
          MEMORY[0x223C1DDF0](v74);
          if (!v34)
          {
            (*(void (**)(void, char *))(**((void **)this + 8) + 40))(*((void *)this + 8), (char *)this + 152);
            CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 4), @"done", (const void *)*MEMORY[0x263EFFB40]);
            BBUpdaterController::process_event<BBUpdaterControllerFSM::eventContinue>(*((int **)this + 2), *((std::__shared_weak_count **)this + 3), (uint64_t)v68);
            goto LABEL_59;
          }
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
              goto LABEL_102;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
            {
LABEL_102:
              if (gBBULogVerbosity >= 6) {
                _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v51, v52, v53, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
              }
            }
          }
          std::string::basic_string[abi:ne180100]<0>(&__dst, BBUReturnAsString::BBUReturnStrings[v34]);
          std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to check manifest in manifest check: ", &__dst, &v65);
          unsigned int v60 = capabilities::updater::manifestCheckRetryCount(v59);
          if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external((std::string *)v68, v65.__r_.__value_.__l.__data_, v65.__r_.__value_.__l.__size_);
          }
          else {
            *(std::string *)char v68 = v65;
          }
          *(void *)&v68[24] = __PAIR64__(v60, v34);
          BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>((uint64_t)this, (uint64_t)v68);
LABEL_121:
          if ((v68[23] & 0x80000000) != 0)
          {
            operator delete(*(void **)v68);
            if ((SHIBYTE(v65.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_123:
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_59;
              }
LABEL_127:
              operator delete(__dst.__r_.__value_.__l.__data_);
              goto LABEL_59;
            }
          }
          else if ((SHIBYTE(v65.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_123;
          }
          operator delete(v65.__r_.__value_.__l.__data_);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_59;
          }
          goto LABEL_127;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
            goto LABEL_96;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
          {
LABEL_96:
            if (gBBULogVerbosity >= 6) {
              _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v31, v32, v33, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
            }
          }
        }
        std::string::size_type v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v68, (uint64_t)"getProvisioningStatus returns: ", 31);
        size_t v58 = strlen(BBUReturnAsString::BBUReturnStrings[v34]);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)BBUReturnAsString::BBUReturnStrings[v34], v58);
        std::ostringstream::str[abi:ne180100](&__dst, (uint64_t)v68);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external(&v65, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          std::string v65 = __dst;
        }
        uint64_t v66 = v34;
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v65);
        if (SHIBYTE(v65.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v65.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        goto LABEL_55;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_90;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_90;
        }
      }
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v26, v27, v28, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
LABEL_90:
      std::string::basic_string[abi:ne180100]<0>(&__dst, BBUReturnAsString::BBUReturnStrings[v25]);
      std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to ping in manifest check: ", &__dst, &v65);
      unsigned int v55 = capabilities::updater::manifestCheckRetryCount(v56);
      if ((SHIBYTE(v65.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        *(std::string *)char v68 = v65;
        goto LABEL_112;
      }
      goto LABEL_111;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_83;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_83;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v22, v23, v24, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_83:
    std::string::basic_string[abi:ne180100]<0>(&__dst, BBUReturnAsString::BBUReturnStrings[v25]);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to bootup in manifest check: ", &__dst, &v65);
    unsigned int v55 = capabilities::updater::manifestCheckRetryCount(v54);
    if ((SHIBYTE(v65.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      *(std::string *)char v68 = v65;
LABEL_112:
      *(void *)&v68[24] = __PAIR64__(v55, v25);
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>((uint64_t)this, (uint64_t)v68);
      goto LABEL_121;
    }
LABEL_111:
    std::string::__init_copy_ctor_external((std::string *)v68, v65.__r_.__value_.__l.__data_, v65.__r_.__value_.__l.__size_);
    goto LABEL_112;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_59;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_59;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v19, v20, v21, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
  }
LABEL_59:
  BBUFeedback::exitStageContext(*((BBUFeedback **)this + 7));
  if (FirmwareDataSource) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  }
}

void sub_21DEA4178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a29);
  (*(void (**)(uint64_t))(*(void *)v34 + 16))(v34);
  _Unwind_Resume(a1);
}

void BBUpdaterController::finalize(BBUpdaterController *this)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(this, 1);
  if (FirmwareDataSource)
  {
    uint64_t v6 = FirmwareDataSource;
    BBUFeedback::handleBeginPhase(*((BBUFeedback **)this + 7), "Final stage");
    char v73 = 0;
    uint64_t v14 = (*(uint64_t (**)(void, char *, void, char *, char *, void))(**((void **)this + 9) + 96))(*((void *)this + 9), (char *)this + 152, *((void *)this + 12), &v73, (char *)this + 240, 0);
    CFDictionaryRef v15 = (const __CFDictionary *)*((void *)this + 5);
    if (v15) {
      uint64_t v16 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
    }
    else {
      uint64_t v16 = 0;
    }
    if (v16)
    {
      CFBooleanRef v17 = (const __CFBoolean *)CFDictionaryGetValue(v15, @"BypassManifestStatusCheck");
      if (v17)
      {
        CFTypeID TypeID = CFBooleanGetTypeID();
        if (TypeID == CFGetTypeID(v17))
        {
          if (CFBooleanGetValue(v17))
          {
            BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Bypass manifest status check has been specified. Returning success");
            goto LABEL_22;
          }
        }
      }
    }
    if (!v14)
    {
      if (v73)
      {
        uint64_t v19 = *((void *)this + 12);
        uint64_t v20 = *(capabilities::updater **)(v19 + 64);
        if (v20)
        {
          uint64_t v20 = (capabilities::updater *)(*(uint64_t (**)(capabilities::updater *))(*(void *)v20 + 24))(v20);
          unsigned int v21 = v20;
          if (*(_DWORD *)(*((void *)this + 12) + 88) != 3 || v20 == 0) {
            goto LABEL_22;
          }
        }
        else
        {
          unsigned int v21 = -1;
          if (*(_DWORD *)(v19 + 88) != 3) {
            goto LABEL_22;
          }
        }
        if (capabilities::updater::shouldBailOnNoManifestHashes(v20))
        {
          std::to_string(&__dst, v21);
          uint64_t v23 = std::string::insert(&__dst, 0, "Detected non-zero prov manifest status: ", 0x28uLL);
          unsigned int v25 = (std::string::value_type *)v23->__r_.__value_.__r.__words[0];
          std::string::size_type size = v23->__r_.__value_.__l.__size_;
          LODWORD(cf.__r_.__value_.__l.__data_) = v23->__r_.__value_.__r.__words[2];
          *(_DWORD *)((char *)cf.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&v23->__r_.__value_.__r.__words[2]
                                                                            + 3);
          int v26 = SHIBYTE(v23->__r_.__value_.__r.__words[2]);
          v23->__r_.__value_.__l.__size_ = 0;
          v23->__r_.__value_.__r.__words[2] = 0;
          v23->__r_.__value_.__r.__words[0] = 0;
          if (v26 < 0)
          {
            std::string::__init_copy_ctor_external(value, v25, size);
          }
          else
          {
            value[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
            value[0].__r_.__value_.__l.__size_ = size;
            LODWORD(value[0].__r_.__value_.__r.__words[2]) = cf.__r_.__value_.__l.__data_;
            *(_DWORD *)((char *)&value[0].__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)cf.__r_.__value_.__r.__words
                                                                                        + 3);
            *((unsigned char *)&value[0].__r_.__value_.__s + 23) = v26;
          }
          value[1].__r_.__value_.__r.__words[0] = 27;
          BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)value);
          if (SHIBYTE(value[0].__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(value[0].__r_.__value_.__l.__data_);
            if ((v26 & 0x80000000) == 0)
            {
LABEL_70:
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_71:
                uint64_t v14 = 27;
                goto LABEL_72;
              }
LABEL_78:
              operator delete(__dst.__r_.__value_.__l.__data_);
              goto LABEL_71;
            }
          }
          else if ((v26 & 0x80000000) == 0)
          {
            goto LABEL_70;
          }
          operator delete(v25);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_71;
          }
          goto LABEL_78;
        }
LABEL_22:
        uint64_t v27 = *((void *)this + 9);
        uint64_t NVRestoreSetting = BBUpdaterController::getNVRestoreSetting(*((BBUpdaterController **)this + 5), v7, v8, v9, v10, v11, v12, v13);
        std::string::value_type v29 = -1;
        __dst.__r_.__value_.__s.__data_[0] = -1;
        CFDictionaryRef v30 = (const __CFDictionary *)*((void *)this + 5);
        if (v30) {
          uint64_t v31 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
        }
        else {
          uint64_t v31 = 0;
        }
        if (v31)
        {
          value[0].__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
          if (CFDictionaryGetValueIfPresent(v30, @"IMEISwVersion", (const void **)&value[0].__r_.__value_.__l.__data_))
          {
            uint64_t v32 = (signed __int8 *)value[0].__r_.__value_.__r.__words[0];
            if (value[0].__r_.__value_.__r.__words[0])
            {
              CFTypeID v33 = CFGetTypeID(value[0].__r_.__value_.__l.__data_);
              if (v33 == CFNumberGetTypeID())
              {
                if (ctu::cf::assign((ctu::cf *)&__dst, v32, v34)) {
                  std::string::value_type v29 = __dst.__r_.__value_.__s.__data_[0];
                }
                else {
                  std::string::value_type v29 = -1;
                }
              }
            }
          }
        }
        CFDictionaryRef v35 = (const __CFDictionary *)*((void *)this + 5);
        if (v35) {
          uint64_t v36 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
        }
        else {
          uint64_t v36 = 0;
        }
        if (!v36
          || (cf.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL,
              !CFDictionaryGetValueIfPresent(v35, @"NVSerialNumber", (const void **)&cf.__r_.__value_.__l.__data_))
          || (CFTypeID v37 = CFGetTypeID(cf.__r_.__value_.__l.__data_), v37 != CFStringGetTypeID()))
        {
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
          __dst.__r_.__value_.__s.__data_[0] = 0;
          goto LABEL_43;
        }
        memset(value, 170, 0x400uLL);
        CFStringGetCString((CFStringRef)cf.__r_.__value_.__l.__data_, (char *)value, 1024, 0x8000100u);
        size_t v38 = strlen((const char *)value);
        if (v38 >= 0x7FFFFFFFFFFFFFF8) {
          std::string::__throw_length_error[abi:ne180100]();
        }
        std::string::size_type v39 = v38;
        if (v38 >= 0x17)
        {
          uint64_t v58 = (v38 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v38 | 7) != 0x17) {
            uint64_t v58 = v38 | 7;
          }
          uint64_t v59 = v58 + 1;
          p_dst = operator new(v58 + 1);
          __dst.__r_.__value_.__l.__size_ = v39;
          __dst.__r_.__value_.__r.__words[2] = v59 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v38;
          p_dst = &__dst;
          if (!v38) {
            goto LABEL_83;
          }
        }
        memcpy(p_dst, value, v39);
LABEL_83:
        *((unsigned char *)p_dst + v39) = 0;
LABEL_43:
        uint64_t v14 = (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t, void, std::string *))(*(void *)v27 + 48))(v27, (char *)this + 152, 8, NVRestoreSetting, v29, &__dst);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (!v14)
        {
          (*(void (**)(void, char *))(**((void **)this + 8) + 40))(*((void *)this + 8), (char *)this + 152);
          uint64_t v14 = 0;
          goto LABEL_47;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_138;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_138;
          }
        }
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v41, v42, v43, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
LABEL_138:
        std::string::basic_string[abi:ne180100]<0>(&cf, BBUReturnAsString::BBUReturnStrings[v14]);
        std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Failed to finalize: ", &cf, &__dst);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external(value, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          value[0] = __dst;
        }
        value[1].__r_.__value_.__r.__words[0] = v14;
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)value);
        if (SHIBYTE(value[0].__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(value[0].__r_.__value_.__l.__data_);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_169:
            if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_47;
            }
LABEL_173:
            operator delete(cf.__r_.__value_.__l.__data_);
            goto LABEL_47;
          }
        }
        else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_169;
        }
        operator delete(__dst.__r_.__value_.__l.__data_);
        if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_47;
        }
        goto LABEL_173;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
          goto LABEL_131;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
        {
LABEL_131:
          if (gBBULogVerbosity >= 6) {
            _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v11, v12, v13, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          }
        }
      }
      BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Key alignment is required");
      uint64_t v14 = 41;
      goto LABEL_72;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_127;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_127;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v11, v12, v13, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_127:
    std::to_string(&cf, v14);
    std::operator+[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>("Fail to getProvisioningStatus", &cf, &__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(value, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
    }
    else {
      value[0] = __dst;
    }
    value[1].__r_.__value_.__r.__words[0] = v14;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)value);
    if (SHIBYTE(value[0].__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(value[0].__r_.__value_.__l.__data_);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_161:
        if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_72;
        }
LABEL_165:
        operator delete(cf.__r_.__value_.__l.__data_);
LABEL_72:
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_47;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_47;
          }
        }
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v55, v56, v57, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
LABEL_47:
        (*(void (**)(void, uint64_t))(**((void **)this + 7) + 16))(*((void *)this + 7), v14);
        if (v14 == 41)
        {
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
              goto LABEL_52;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
              goto LABEL_52;
            }
          }
          if ((gBBULogVerbosity & 0x80000000) == 0) {
            _BBULog(13, 0, "BBUpdaterController", "", "re-personalize\n", v44, v45, v46, v71);
          }
LABEL_52:
          uint64_t v48 = (int *)*((void *)this + 2);
          std::string::size_type v47 = *((void *)this + 3);
          cf.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
          cf.__r_.__value_.__l.__size_ = v47;
          if (v47) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v47 + 8), 1uLL, memory_order_relaxed);
          }
          value[0].__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
          value[0].__r_.__value_.__r.__words[2] = 0x7AAAAAAAAAAAAAALL;
          strcpy((char *)value, "unknown");
          memset(&__dst, 170, sizeof(__dst));
          (*(void (**)(std::string *__return_ptr, int *))(*(void *)v48 + 24))(&__dst, v48);
          std::string::size_type v49 = __dst.__r_.__value_.__r.__words[0];
          std::string::size_type v50 = __dst.__r_.__value_.__r.__words[0] + 24 * v48[8];
          if (value != (std::string *)v50)
          {
            char v51 = *(unsigned char *)(v50 + 23);
            if (SHIBYTE(value[0].__r_.__value_.__r.__words[2]) < 0)
            {
              if (v51 >= 0) {
                uint64_t v53 = (void *)(__dst.__r_.__value_.__r.__words[0] + 24 * v48[8]);
              }
              else {
                uint64_t v53 = *(void **)v50;
              }
              if (v51 >= 0) {
                size_t v54 = *(unsigned __int8 *)(v50 + 23);
              }
              else {
                size_t v54 = *(void *)(v50 + 8);
              }
              std::string::__assign_no_alias<false>((void **)&value[0].__r_.__value_.__l.__data_, v53, v54);
            }
            else if ((*(unsigned char *)(v50 + 23) & 0x80) != 0)
            {
              std::string::__assign_no_alias<true>(value, *(void **)v50, *(void *)(v50 + 8));
            }
            else
            {
              long long v52 = *(_OWORD *)v50;
              value[0].__r_.__value_.__r.__words[2] = *(void *)(v50 + 16);
              *(_OWORD *)&value[0].__r_.__value_.__l.__data_ = v52;
            }
            std::string::size_type v49 = __dst.__r_.__value_.__r.__words[0];
          }
          if (v49)
          {
            std::string::size_type v60 = __dst.__r_.__value_.__l.__size_;
            char v61 = (void *)v49;
            if (__dst.__r_.__value_.__l.__size_ != v49)
            {
              do
              {
                if (*(char *)(v60 - 1) < 0) {
                  operator delete(*(void **)(v60 - 24));
                }
                v60 -= 24;
              }
              while (v60 != v49);
              char v61 = (void *)__dst.__r_.__value_.__r.__words[0];
            }
            __dst.__r_.__value_.__l.__size_ = v49;
            operator delete(v61);
          }
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
              goto LABEL_102;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
              goto LABEL_102;
            }
          }
          if ((gBBULogVerbosity & 0x80000000) == 0)
          {
            boost::core::demangle((boost::core *)&__dst, (const char *)(0x800000021DFA9E14 & 0x7FFFFFFFFFFFFFFFLL));
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string v65 = &__dst;
            }
            else {
              LOBYTE(v65) = __dst.__r_.__value_.__s.__data_[0];
            }
            _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v62, v63, v64, (char)v65);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
          }
LABEL_102:
          boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventRepersonalize>((uint64_t)cf.__r_.__value_.__l.__data_, (uint64_t)&v73, 1);
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
            {
LABEL_104:
              if ((gBBULogVerbosity & 0x80000000) == 0)
              {
                boost::core::demangle((boost::core *)&__dst, (const char *)(0x800000021DFA9E14 & 0x7FFFFFFFFFFFFFFFLL));
                if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  long long v69 = &__dst;
                }
                else {
                  LOBYTE(v69) = __dst.__r_.__value_.__s.__data_[0];
                }
                _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v66, v67, v68, (char)v69);
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__dst.__r_.__value_.__l.__data_);
                }
              }
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
              goto LABEL_104;
            }
          }
          if (SHIBYTE(value[0].__r_.__value_.__r.__words[2]) < 0) {
            operator delete(value[0].__r_.__value_.__l.__data_);
          }
          long long v70 = (std::__shared_weak_count *)cf.__r_.__value_.__l.__size_;
          if (cf.__r_.__value_.__l.__size_)
          {
            if (!atomic_fetch_add((atomic_ullong *volatile)(cf.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
              std::__shared_weak_count::__release_weak(v70);
            }
          }
          goto LABEL_115;
        }
        if (!v14)
        {
          BBUpdaterController::process_event<BBUpdaterControllerFSM::eventContinue>(*((int **)this + 2), *((std::__shared_weak_count **)this + 3), (uint64_t)value);
          CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 4), @"done", (const void *)*MEMORY[0x263EFFB40]);
LABEL_115:
          (*(void (**)(BBUEUR10UpdateSource *))(*(void *)v6 + 16))(v6);
          return;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
            goto LABEL_142;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
          {
LABEL_142:
            if (gBBULogVerbosity >= 6) {
              _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v44, v45, v46, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
            }
          }
        }
        std::string::basic_string[abi:ne180100]<0>(&__dst, "Fail to perform finalization.");
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          std::string::__init_copy_ctor_external(value, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else {
          value[0] = __dst;
        }
        value[1].__r_.__value_.__r.__words[0] = v14;
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)value);
        if (SHIBYTE(value[0].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(value[0].__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        goto LABEL_115;
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_161;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(cf.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_165;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_121;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_121;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v3, v4, v5, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
  }
LABEL_121:
  std::string::basic_string[abi:ne180100]<0>(&__dst, "Fail to get update source data for finalize\n");
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(value, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    value[0] = __dst;
  }
  value[1].__r_.__value_.__r.__words[0] = 35;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)value);
  if (SHIBYTE(value[0].__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(value[0].__r_.__value_.__l.__data_);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
LABEL_157:
    }
      operator delete(__dst.__r_.__value_.__l.__data_);
  }
  else if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    goto LABEL_157;
  }
}

void sub_21DEA51C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v30 + 16))(v30);
  _Unwind_Resume(a1);
}

uint64_t BBUpdaterController::collectCoredumpInternal(BBUpdaterController *this)
{
  memset(&v84, 0, sizeof(v84));
  char v2 = (BBUFeedback *)*((void *)this + 7);
  BBUFeedback::handleComment(v2, "entering %s", "StageContext::Coredump");
  uint64_t v3 = *((void *)v2 + 19);
  uint64_t v4 = *((void *)v2 + 18);
  if (v3 == v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = ((v3 - v4) << 7) - 1;
  }
  uint64_t v6 = *((void *)v2 + 22);
  unint64_t v7 = v6 + *((void *)v2 + 21);
  if (v5 == v7)
  {
    std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity((void *)v2 + 17);
    uint64_t v4 = *((void *)v2 + 18);
    uint64_t v6 = *((void *)v2 + 22);
    unint64_t v7 = *((void *)v2 + 21) + v6;
  }
  *(_DWORD *)(*(void *)(v4 + ((v7 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v7 & 0x3FF)) = 8;
  *((void *)v2 + 22) = v6 + 1;
  memset(&__p, 170, sizeof(__p));
  if (BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS == -1)
  {
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1) {
      goto LABEL_8;
    }
  }
  else
  {
    dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1)
    {
LABEL_8:
      if (BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS) {
        goto LABEL_9;
      }
LABEL_13:
      BBUpdaterController::getCoreDumpPath((BBUpdaterController *)&__p, (uint64_t)this);
      goto LABEL_14;
    }
  }
  dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
  if (!(BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS)) {
    goto LABEL_13;
  }
LABEL_9:
  BBUpdaterController::getCoreDumpPath((BBUpdaterController *)&v87, (uint64_t)this);
  bbufs::createDirectoryWithTimestamp((const void **)&v87.__r_.__value_.__l.__data_, &__p);
  if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v87.__r_.__value_.__l.__data_);
  }
LABEL_14:
  p_p = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "collecting coredump at %s", (const char *)p_p);
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_97;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_97:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v9, v10, v11, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&v86, "core dump path unavailable or not specified.");
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v87, v86.__r_.__value_.__l.__data_, v86.__r_.__value_.__l.__size_);
    }
    else {
      std::string v87 = v86;
    }
    uint64_t v88 = 2;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v87);
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v86.__r_.__value_.__l.__data_);
    }
    FirmwareDataSource = 0;
    CFNumberRef v34 = 0;
    uint64_t v35 = 2;
    goto LABEL_40;
  }
  eUICC::DumpRecords((char *)&__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v13 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v13 = __p.__r_.__value_.__l.__size_;
  }
  if (!v13)
  {
    BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Invalid path pointer to create coredump directory");
    goto LABEL_33;
  }
  if (!ctu::fs::create_directory())
  {
    BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Failed creating coredump directory");
    goto LABEL_33;
  }
  uint64_t v14 = getpwnam("_wireless");
  if (!v14)
  {
    _BBUFSDebugPrint("getWirelessID", "failed to get uid and gid information for _wireless\n", v15, v16, v17, v18, v19, v20, v80);
    BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Failed to get uid and gid information for _wireless:_wireless");
LABEL_33:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_35;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_35:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v28, v29, v30, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    uint64_t v31 = (char *)operator new(0x20uLL);
    strcpy(v31, "failed to create dump path");
    std::string::__init_copy_ctor_external(&v87, v31, 0x1AuLL);
    uint64_t v88 = 1;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v87);
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__r_.__value_.__l.__data_);
    }
    operator delete(v31);
    FirmwareDataSource = 0;
    CFNumberRef v34 = 0;
    uint64_t v35 = 1;
    goto LABEL_40;
  }
  uid_t pw_uid = v14->pw_uid;
  gid_t pw_gid = v14->pw_gid;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v23 = &__p;
  }
  else {
    uint64_t v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  uint64_t v24 = (capabilities::radio *)chown((const char *)v23, pw_uid, pw_gid);
  if (v24)
  {
    unsigned int v25 = (BBUFeedback *)*((void *)this + 7);
    int v26 = __error();
    uint64_t v27 = strerror(*v26);
    BBUFeedback::handleComment(v25, "Failed changing owner of coredump directory:  %s", v27);
    goto LABEL_33;
  }
  if (capabilities::radio::supportsBasebandStateController(v24)) {
    TelephonyBasebandSetBasebandState();
  }
  (*(void (**)(void, void, void))(**((void **)this + 9) + 56))(*((void *)this + 9), *((void *)this + 6), 0);
  (*(void (**)(void, uint64_t))(**((void **)this + 9) + 144))(*((void *)this + 9), 2);
  uint64_t InfoFirstStageInternal = (capabilities::radio *)BBUpdaterController::queryInfoFirstStageInternal((BBULoader **)this, v42);
  uint64_t v35 = (uint64_t)InfoFirstStageInternal;
  if (InfoFirstStageInternal)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      FirmwareDataSource = 0;
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_183;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      FirmwareDataSource = 0;
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_183;
      }
    }
    if (gBBULogVerbosity >= 6)
    {
      uint64_t InfoFirstStageInternal = (capabilities::radio *)_BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v43, v44, v45, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      FirmwareDataSource = 0;
      goto LABEL_166;
    }
LABEL_183:
    CFNumberRef v34 = 0;
    goto LABEL_40;
  }
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(this, 1);
  if (!FirmwareDataSource)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_115;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_115:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v46, v47, v48, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&v86, "Fail to get firmware data source\n");
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v87, v86.__r_.__value_.__l.__data_, v86.__r_.__value_.__l.__size_);
    }
    else {
      std::string v87 = v86;
    }
    uint64_t v88 = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v87);
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v86.__r_.__value_.__l.__data_);
    }
    uint64_t v82 = 0;
LABEL_151:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_153;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_153:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v59, v60, v61, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&v86, "Fail to get update source for collectCoredump\n");
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v87, v86.__r_.__value_.__l.__data_, v86.__r_.__value_.__l.__size_);
    }
    else {
      std::string v87 = v86;
    }
    uint64_t v88 = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v87);
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v86.__r_.__value_.__l.__data_);
    }
    FirmwareDataSource = 0;
    uint64_t v35 = 0;
    goto LABEL_166;
  }
  uint64_t v49 = *((void *)this + 12);
  if (v49)
  {
    uint64_t v50 = (*(uint64_t (**)(void))(**(void **)(v49 + 16) + 24))(*(void *)(v49 + 16));
    (*(void (**)(BBUEUR10UpdateSource *, uint64_t))(*(void *)FirmwareDataSource + 200))(FirmwareDataSource, v50);
    uint64_t v51 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 12) + 24) + 24))(*(void *)(*((void *)this + 12) + 24));
    (*(void (**)(BBUEUR10UpdateSource *, uint64_t))(*(void *)FirmwareDataSource + 208))(FirmwareDataSource, v51);
  }
  if (!(*(unsigned int (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 88))(FirmwareDataSource))
  {
    uint64_t v82 = FirmwareDataSource;
    goto LABEL_80;
  }
  (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Source doesn’t contain coredump programmer, falling back to folder");
  memset(&v86, 170, sizeof(v86));
  FirmwareFolder = (capabilities::radio *)BBUpdaterController::getFirmwareFolder(&v86, *((const __CFDictionary **)this + 5));
  std::string::size_type v53 = HIBYTE(v86.__r_.__value_.__r.__words[2]);
  if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v53 = v86.__r_.__value_.__l.__size_;
  }
  if (!v53)
  {
    capabilities::radio::personalizedFirmwarePath((uint64_t *)&v87, FirmwareFolder);
    if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v86.__r_.__value_.__l.__data_);
    }
    std::string v86 = v87;
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v86.__r_.__value_.__l.__size_)
      {
        size_t v54 = (std::string *)v86.__r_.__value_.__r.__words[0];
        goto LABEL_74;
      }
    }
    else if (*((unsigned char *)&v87.__r_.__value_.__s + 23))
    {
      size_t v54 = &v86;
LABEL_74:
      BBUFeedback::handleComment(*((BBUFeedback **)this + 7), "Baseband fw path that is used: %s\n", (const char *)v54);
      goto LABEL_75;
    }
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0xAD9u, (ctu::LogMessageBuffer *)"Assertion failure(folder.empty() != true && \"Failed finding the bbfw path.\")", v77, v78, v79, v80);
  }
LABEL_75:
  uint64_t v55 = (BBUEUR10UpdateSource *)BBUUpdateSource::createFromFolder((long long *)&v86, *((void *)this + 7), 0);
  FirmwareDataSource = v55;
  if (!v55)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_135;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_135:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v56, v57, v58, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&v85, "Fail to get update source from folder\n");
    if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v87, v85.__r_.__value_.__l.__data_, v85.__r_.__value_.__l.__size_);
    }
    else {
      std::string v87 = v85;
    }
    uint64_t v88 = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v87);
    goto LABEL_176;
  }
  unsigned int v62 = (*(uint64_t (**)(BBUEUR10UpdateSource *))(*(void *)v55 + 88))(v55);
  if (!v62) {
    goto LABEL_77;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_141;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_141:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v59, v60, v61, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&v85, "Miss image for collecting coredump");
  if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v87, v85.__r_.__value_.__l.__data_, v85.__r_.__value_.__l.__size_);
  }
  else {
    std::string v87 = v85;
  }
  uint64_t v88 = v62;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v87);
LABEL_176:
  if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v87.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v85.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v85.__r_.__value_.__l.__data_);
  }
LABEL_77:
  if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v86.__r_.__value_.__l.__data_);
  }
  uint64_t v82 = FirmwareDataSource;
  if (!FirmwareDataSource) {
    goto LABEL_151;
  }
LABEL_80:
  uint64_t v35 = BBUpdaterController::performFirstStageInternal((uint64_t)this, 0, &v82, &v84);
  if (v35)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_121;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_121:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v63, v64, v65, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v87, v84.__r_.__value_.__l.__data_, v84.__r_.__value_.__l.__size_);
    }
    else {
      std::string v87 = v84;
    }
    uint64_t v88 = v35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v87);
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__r_.__value_.__l.__data_);
    }
    goto LABEL_166;
  }
  uint64_t InfoFirstStageInternal = (capabilities::radio *)BBUpdaterController::queryInfoSecondStageInternal((uint64_t)this, 0, (uint64_t)&v82);
  uint64_t v35 = (uint64_t)InfoFirstStageInternal;
  if (InfoFirstStageInternal)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      CFNumberRef v34 = 0;
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_40;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      CFNumberRef v34 = 0;
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_40;
      }
    }
    if (gBBULogVerbosity < 6) {
      goto LABEL_40;
    }
    uint64_t InfoFirstStageInternal = (capabilities::radio *)_BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v66, v67, v68, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
LABEL_166:
    CFNumberRef v34 = 0;
    goto LABEL_40;
  }
  CFNumberRef v34 = (uint64_t *)(*(uint64_t (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 72))(FirmwareDataSource);
  uint64_t InfoFirstStageInternal = (capabilities::radio *)BBUProgrammer::addItemsFromList(*((void *)this + 11), (uint64_t)v34);
  uint64_t v35 = (uint64_t)InfoFirstStageInternal;
  if (InfoFirstStageInternal)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_40;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_40;
      }
    }
    if (gBBULogVerbosity >= 6) {
      uint64_t InfoFirstStageInternal = (capabilities::radio *)_BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v69, v70, v71, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
  }
  else
  {
    uint64_t v72 = *((void *)this + 11);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v81, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v81 = __p;
    }
    uint64_t InfoFirstStageInternal = (capabilities::radio *)(*(uint64_t (**)(uint64_t, void, std::string *))(*(void *)v72 + 88))(v72, 0, &v81);
    uint64_t v35 = (uint64_t)InfoFirstStageInternal;
    if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v81.__r_.__value_.__l.__data_);
    }
    if (v35)
    {
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
          goto LABEL_91;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
        {
LABEL_91:
          if (gBBULogVerbosity >= 6) {
            _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v73, v74, v75, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          }
        }
      }
      std::string::basic_string[abi:ne180100]<0>(&v86, "Fail to run collectCoreDump");
      if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v87, v86.__r_.__value_.__l.__data_, v86.__r_.__value_.__l.__size_);
      }
      else {
        std::string v87 = v86;
      }
      uint64_t v88 = v35;
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)this, (uint64_t)&v87);
      if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v87.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v86.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v86.__r_.__value_.__l.__data_);
      }
    }
  }
LABEL_40:
  if (capabilities::radio::supportsBasebandStateController(InfoFirstStageInternal)) {
    TelephonyBasebandSetBasebandState();
  }
  uint64_t v36 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v36) {
    (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
  }
  (*(void (**)(void, char *))(**((void **)this + 8) + 40))(*((void *)this + 8), (char *)this + 152);
  BBUFeedback::exitStageContext(*((BBUFeedback **)this + 7));
  if (v34)
  {
    if (v34[2])
    {
      uint64_t v38 = *v34;
      CFTypeID v37 = (uint64_t *)v34[1];
      uint64_t v39 = *v37;
      *(void *)(v39 + 8) = *(void *)(*v34 + 8);
      **(void **)(v38 + 8) = v39;
      v34[2] = 0;
      if (v37 != v34)
      {
        do
        {
          int v40 = (uint64_t *)v37[1];
          operator delete(v37);
          CFTypeID v37 = v40;
        }
        while (v40 != v34);
      }
    }
    operator delete(v34);
  }
  if (FirmwareDataSource) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v84.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v35;
    }
LABEL_55:
    operator delete(v84.__r_.__value_.__l.__data_);
    return v35;
  }
  if (SHIBYTE(v84.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_55;
  }
  return v35;
}

void sub_21DEA6554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v38 - 89) < 0) {
    operator delete(*(void **)(v38 - 112));
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

void BBUpdaterController::handleError(uint64_t a1, std::string *a2, int a3)
{
  BBUFeedback::handleBeginPhase(*(BBUFeedback **)(a1 + 56), "handleError");
  BBUpdaterController::dumpDebugLogBuffer((void *)a1, a3, v6, v7, v8, v9, v10, v11);
  if (*(unsigned char *)(a1 + 352))
  {
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS == -1)
    {
      if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1) {
        goto LABEL_4;
      }
    }
    else
    {
      dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
      if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1)
      {
LABEL_4:
        if (!(BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS)) {
          goto LABEL_9;
        }
LABEL_5:
        if (*(void *)(a1 + 120))
        {
          if (gBBULogMaskGet(void)::once != -1) {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          }
          _BBULog(19, 0xFFFFFFFFLL, "BBUpdaterController", "", "enabling kernel IPC log for coredump\n", v12, v13, v14, v50);
          (*(void (**)(void))(**(void **)(a1 + 120) + 32))(*(void *)(a1 + 120));
        }
LABEL_9:
        *(unsigned char *)(a1 + 352) = 0;
        uint64_t v15 = BBUpdaterController::collectCoredumpInternal((BBUpdaterController *)a1);
        BBUpdaterController::dumpDebugLogBuffer((void *)a1, v15, v16, v17, v18, v19, v20, v21);
        if (!v15)
        {
          std::string::append(a2, " [coredump collected]", 0x15uLL);
          BBUpdaterController::getCoreDumpPath((BBUpdaterController *)&__p, a1);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&v53, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else {
            std::string v53 = __p;
          }
          uint64_t v63 = 0;
          if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&block, v53.__r_.__value_.__l.__data_, v53.__r_.__value_.__l.__size_);
          }
          else {
            blocuint64_t k = v53;
          }
          if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&v54, block.__r_.__value_.__l.__data_, block.__r_.__value_.__l.__size_);
          }
          else {
            std::string v54 = block;
          }
          CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
          if (ctu::cf::convert_copy())
          {
            CFURLRef v27 = CFURLCreateWithString(v26, (CFStringRef)0xAAAAAAAAAAAAAAAALL, 0);
            CFRelease((CFTypeRef)0xAAAAAAAAAAAAAAAALL);
            if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_23;
            }
          }
          else
          {
            CFURLRef v27 = 0;
            if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_23:
              if ((SHIBYTE(block.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_24;
              }
              goto LABEL_32;
            }
          }
          operator delete(v54.__r_.__value_.__l.__data_);
          if ((SHIBYTE(block.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_24:
            CFURLRef v52 = v27;
            if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_25;
            }
            goto LABEL_33;
          }
LABEL_32:
          operator delete(block.__r_.__value_.__l.__data_);
          CFURLRef v52 = v27;
          if ((SHIBYTE(v53.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_25:
            if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_26;
            }
LABEL_34:
            operator delete(__p.__r_.__value_.__l.__data_);
LABEL_26:
            memset(&v54, 170, sizeof(v54));
            BBUpdaterController::getCoreDumpPath((BBUpdaterController *)&v54, a1);
            std::string::size_type size = HIBYTE(v54.__r_.__value_.__r.__words[2]);
            if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = v54.__r_.__value_.__l.__size_;
            }
            if (size) {
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), @"LogDirectory", v27);
            }
            else {
              BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "CoreDump path passed in to BBU is empty, skipping setting the coredump path for caller.");
            }
            if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v54.__r_.__value_.__l.__data_);
              if (!v27) {
                goto LABEL_41;
              }
            }
            else if (!v27)
            {
LABEL_41:
              uint64_t v15 = 0;
              pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
              uint64_t v25 = qword_26AA89AB0;
              if (qword_26AA89AB0) {
                goto LABEL_51;
              }
              goto LABEL_42;
            }
            CFRelease(v27);
            goto LABEL_41;
          }
LABEL_33:
          operator delete(v53.__r_.__value_.__l.__data_);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_26;
          }
          goto LABEL_34;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_102;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
            goto LABEL_102;
          }
        }
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v22, v23, v24, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
LABEL_102:
        BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Fail to collect coredump after hitting fatal error: %s", BBUReturnAsString::BBUReturnStrings[v15]);
        pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
        uint64_t v25 = qword_26AA89AB0;
        if (qword_26AA89AB0) {
          goto LABEL_51;
        }
        goto LABEL_42;
      }
    }
    dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
    if (!(BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS)) {
      goto LABEL_9;
    }
    goto LABEL_5;
  }
  uint64_t v15 = 1;
  pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  uint64_t v25 = qword_26AA89AB0;
  if (qword_26AA89AB0) {
    goto LABEL_51;
  }
LABEL_42:
  uint64_t v29 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
  block.__r_.__value_.__r.__words[0] = 0;
  ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v29, "BBUError", QOS_CLASS_UTILITY, (NSObject **)&block);
  if (block.__r_.__value_.__r.__words[0]) {
    dispatch_release((dispatch_object_t)block.__r_.__value_.__l.__data_);
  }
  v29->__on_zero_shared_weauint64_t k = 0;
  v29[1].~__shared_weak_count = 0;
  v29[1].~__shared_weak_count_0 = 0;
  std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&v54, v29);
  long long v30 = *(_OWORD *)&v54.__r_.__value_.__l.__data_;
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v31 = (std::__shared_weak_count *)off_26AA89AB8;
  *(_OWORD *)&qword_26AA89AB0 = v30;
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  uint64_t v32 = (std::__shared_weak_count *)v54.__r_.__value_.__l.__size_;
  if (v54.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(v54.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
    std::__shared_weak_count::__release_weak(v32);
  }
  uint64_t v25 = qword_26AA89AB0;
LABEL_51:
  CFTypeID v33 = (std::__shared_weak_count *)off_26AA89AB8;
  if (off_26AA89AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  v54.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
  v54.__r_.__value_.__l.__size_ = 0x40000000;
  v54.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN8BBUError8addErrorERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE9BBUReturn_block_invoke;
  uint64_t v55 = &__block_descriptor_tmp_8;
  uint64_t v56 = v25;
  uint64_t v57 = a2;
  int v58 = a3;
  v53.__r_.__value_.__r.__words[0] = (std::string::size_type)&v54;
  block.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
  block.__r_.__value_.__l.__size_ = 0x40000000;
  block.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  uint64_t v60 = &__block_descriptor_tmp_13_0;
  uint64_t v61 = v25;
  unsigned int v62 = &v53;
  CFNumberRef v34 = *(NSObject **)(v25 + 16);
  if (*(void *)(v25 + 24))
  {
    dispatch_async_and_wait(v34, &block);
    if (!v33) {
      goto LABEL_59;
    }
  }
  else
  {
    dispatch_sync(v34, &block);
    if (!v33) {
      goto LABEL_59;
    }
  }
  if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
LABEL_59:
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), v15);
  uint64_t v35 = *(BBUFeedback **)(a1 + 56);
  pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  uint64_t v36 = (BBUError *)qword_26AA89AB0;
  if (!qword_26AA89AB0)
  {
    CFTypeID v37 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
    block.__r_.__value_.__r.__words[0] = 0;
    ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v37, "BBUError", QOS_CLASS_UTILITY, (NSObject **)&block);
    if (block.__r_.__value_.__r.__words[0]) {
      dispatch_release((dispatch_object_t)block.__r_.__value_.__l.__data_);
    }
    v37->__on_zero_shared_weauint64_t k = 0;
    v37[1].~__shared_weak_count = 0;
    v37[1].~__shared_weak_count_0 = 0;
    std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&v54, v37);
    long long v38 = *(_OWORD *)&v54.__r_.__value_.__l.__data_;
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = 0uLL;
    uint64_t v39 = (std::__shared_weak_count *)off_26AA89AB8;
    *(_OWORD *)&qword_26AA89AB0 = v38;
    if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
    int v40 = (std::__shared_weak_count *)v54.__r_.__value_.__l.__size_;
    if (v54.__r_.__value_.__l.__size_
      && !atomic_fetch_add((atomic_ullong *volatile)(v54.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
    uint64_t v36 = (BBUError *)qword_26AA89AB0;
  }
  v53.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
  v53.__r_.__value_.__l.__size_ = (std::string::size_type)off_26AA89AB8;
  if (off_26AA89AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  uint64_t v41 = BBUReturnAsString::BBUReturnStrings[BBUError::getErrorCode(v36)];
  pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  uint64_t v42 = (BBUError *)qword_26AA89AB0;
  if (!qword_26AA89AB0)
  {
    uint64_t v43 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
    uint64_t v63 = 0;
    ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v43, "BBUError", QOS_CLASS_UTILITY, &v63);
    if (v63) {
      dispatch_release(v63);
    }
    v43->__on_zero_shared_weauint64_t k = 0;
    v43[1].~__shared_weak_count = 0;
    v43[1].~__shared_weak_count_0 = 0;
    std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&block, v43);
    long long v44 = *(_OWORD *)&block.__r_.__value_.__l.__data_;
    *(_OWORD *)&block.__r_.__value_.__l.__data_ = 0uLL;
    uint64_t v45 = (std::__shared_weak_count *)off_26AA89AB8;
    *(_OWORD *)&qword_26AA89AB0 = v44;
    if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
    uint64_t v46 = (std::__shared_weak_count *)block.__r_.__value_.__l.__size_;
    if (block.__r_.__value_.__l.__size_
      && !atomic_fetch_add((atomic_ullong *volatile)(block.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
    uint64_t v42 = (BBUError *)qword_26AA89AB0;
  }
  uint64_t v47 = (std::__shared_weak_count *)off_26AA89AB8;
  if (off_26AA89AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  BBUError::getErrorString(v42, &v54);
  if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v48 = &v54;
  }
  else {
    uint64_t v48 = (std::string *)v54.__r_.__value_.__r.__words[0];
  }
  BBUFeedback::handleComment(v35, "Hit fatal error: %s reason: %s", v41, (const char *)v48);
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v54.__r_.__value_.__l.__data_);
  }
  if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
  }
  uint64_t v49 = (std::__shared_weak_count *)v53.__r_.__value_.__l.__size_;
  if (v53.__r_.__value_.__l.__size_)
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(v53.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
}

void sub_21DEA70E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (*(char *)(v34 - 121) < 0)
  {
    operator delete(*(void **)(v34 - 144));
    ctu::cf::CFSharedRef<__CFURL const>::~CFSharedRef((const void **)(v34 - 88));
    if ((a27 & 0x80000000) == 0)
    {
LABEL_3:
      if (a20 < 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else
  {
    ctu::cf::CFSharedRef<__CFURL const>::~CFSharedRef((const void **)(v34 - 88));
    if ((a27 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  operator delete(a22);
  if (a20 < 0)
  {
LABEL_4:
    operator delete(__p);
    _Unwind_Resume(a1);
  }
LABEL_7:
  _Unwind_Resume(a1);
}

void BBUpdaterController::dumpDebugLogBuffer(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (a1[13])
    {
      uint64_t v9 = (std::__shared_weak_count *)a1[14];
      v12[0] = a1[13];
      v12[1] = v9;
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BBUpdaterController::dumpLogBufferInternal((uint64_t)a1, v12, "Debug Log Buffer");
      if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS == -1)
    {
      if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1) {
        goto LABEL_10;
      }
    }
    else
    {
      dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
      if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1)
      {
LABEL_10:
        if (!(BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS)) {
          return;
        }
LABEL_11:
        if (a1[15])
        {
          uint64_t v10 = (std::__shared_weak_count *)a1[16];
          v11[0] = a1[15];
          v11[1] = v10;
          if (v10) {
            atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          BBUpdaterController::dumpLogBufferInternal((uint64_t)a1, v11, "Kernel IPC Log");
          if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
        return;
      }
    }
    dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
    if (!(BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS)) {
      return;
    }
    goto LABEL_11;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      return;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      return;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", a6, a7, a8, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
  }
}

void sub_21DEA7534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DEA7548(_Unwind_Exception *a1)
{
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v1 - 32);
  _Unwind_Resume(a1);
}

void BBUpdaterController::getCoreDumpPath(BBUpdaterController *this, uint64_t a2)
{
  v29[2] = *MEMORY[0x263EF8340];
  std::string __p = operator new(0x48uLL);
  long long v28 = xmmword_21DFA8EE0;
  strcpy((char *)__p, "/wireless/Library/Logs/CrashReporter/Baseband/baseband_updater_logs/");
  memset(this, 170, 24);
  *((unsigned char *)this + 23) = 0;
  *(unsigned char *)this = 0;
  memset(&v26, 170, sizeof(v26));
  pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  uint64_t v4 = off_26AA89B50;
  if (!off_26AA89B50)
  {
    uint64_t v5 = (BBUPartitionManager *)operator new(0x18uLL);
    BBUPartitionManager::BBUPartitionManager(v5);
    uint64_t v6 = operator new(0x20uLL);
    void *v6 = &unk_26CECF498;
    v6[1] = 0;
    v6[2] = 0;
    v6[3] = v5;
    uint64_t v7 = (std::__shared_weak_count *)off_26AA89B58;
    off_26AA89B50 = v5;
    off_26AA89B58 = v6;
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    uint64_t v4 = off_26AA89B50;
  }
  uint64_t v8 = (std::__shared_weak_count *)off_26AA89B58;
  v25.__r_.__value_.__r.__words[0] = (std::string::size_type)v4;
  v25.__r_.__value_.__l.__size_ = (std::string::size_type)off_26AA89B58;
  if (off_26AA89B58) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  uint64_t v9 = (uint64_t *)v4[1];
  if (!v9) {
LABEL_14:
  }
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      int v10 = *((_DWORD *)v9 + 8);
      if (v10 < 2) {
        break;
      }
      uint64_t v9 = (uint64_t *)*v9;
      if (!v9) {
        goto LABEL_14;
      }
    }
    if (v10 == 1) {
      break;
    }
    uint64_t v9 = (uint64_t *)v9[1];
    if (!v9) {
      goto LABEL_14;
    }
  }
  if (*((char *)v9 + 63) < 0) {
    std::string::__init_copy_ctor_external(&v26, (const std::string::value_type *)v9[5], v9[6]);
  }
  else {
    std::string v26 = *(std::string *)(v9 + 5);
  }
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    std::string::size_type size = HIBYTE(v26.__r_.__value_.__r.__words[2]);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v26.__r_.__value_.__l.__size_;
    }
    if (!size) {
      goto LABEL_57;
    }
  }
  else
  {
    std::string::size_type v11 = HIBYTE(v26.__r_.__value_.__r.__words[2]);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v11 = v26.__r_.__value_.__l.__size_;
    }
    if (!v11) {
      goto LABEL_57;
    }
  }
  pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  uint64_t v12 = off_26AA89B50;
  if (!off_26AA89B50)
  {
    uint64_t v13 = (BBUPartitionManager *)operator new(0x18uLL);
    BBUPartitionManager::BBUPartitionManager(v13);
    uint64_t v14 = operator new(0x20uLL);
    *uint64_t v14 = &unk_26CECF498;
    v14[1] = 0;
    unint64_t v14[2] = 0;
    v14[3] = v13;
    uint64_t v15 = (std::__shared_weak_count *)off_26AA89B58;
    off_26AA89B50 = v13;
    off_26AA89B58 = v14;
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    uint64_t v12 = off_26AA89B50;
  }
  uint64_t v16 = (std::__shared_weak_count *)off_26AA89B58;
  if (off_26AA89B58) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  uint64_t v17 = (uint64_t *)v12[1];
  if (!v17) {
LABEL_36:
  }
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  while (1)
  {
    while (1)
    {
      int v18 = *((_DWORD *)v17 + 8);
      if (v18 < 2) {
        break;
      }
      uint64_t v17 = (uint64_t *)*v17;
      if (!v17) {
        goto LABEL_36;
      }
    }
    if (v18 == 1) {
      break;
    }
    uint64_t v17 = (uint64_t *)v17[1];
    if (!v17) {
      goto LABEL_36;
    }
  }
  if (*((char *)v17 + 63) < 0) {
    std::string::__init_copy_ctor_external(&v25, (const std::string::value_type *)v17[5], v17[6]);
  }
  else {
    std::string v25 = *(std::string *)(v17 + 5);
  }
  if (v28 >= 0) {
    p_p = (const std::string::value_type *)&__p;
  }
  else {
    p_p = (const std::string::value_type *)__p;
  }
  if (v28 >= 0) {
    std::string::size_type v21 = HIBYTE(v28);
  }
  else {
    std::string::size_type v21 = v28;
  }
  uint64_t v22 = std::string::append(&v25, p_p, v21);
  std::string::size_type v23 = v22->__r_.__value_.__r.__words[0];
  v29[0] = v22->__r_.__value_.__l.__size_;
  *(void *)((char *)v29 + 7) = *(std::string::size_type *)((char *)&v22->__r_.__value_.__r.__words[1] + 7);
  char v24 = HIBYTE(v22->__r_.__value_.__r.__words[2]);
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
  *(void *)this = v23;
  *((void *)this + 1) = v29[0];
  *(void *)((char *)this + 15) = *(void *)((char *)v29 + 7);
  *((unsigned char *)this + 23) = v24;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
LABEL_57:
  v25.__r_.__value_.__r.__words[0] = 0;
  if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a2 + 40), @"coreDumpPath", (const void **)&v25.__r_.__value_.__l.__data_)&& (ctu::cf::assign() & 1) == 0)
  {
    BBUFeedback::handleComment(*(BBUFeedback **)(a2 + 56), "failed converting core dump path to string");
    if (*((char *)this + 23) < 0)
    {
      *((void *)this + 1) = 0;
      this = *(BBUpdaterController **)this;
    }
    else
    {
      *((unsigned char *)this + 23) = 0;
    }
    *(unsigned char *)this = 0;
  }
  if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v28) & 0x80000000) == 0) {
      return;
    }
LABEL_67:
    operator delete(__p);
    return;
  }
  operator delete(v26.__r_.__value_.__l.__data_);
  if (SHIBYTE(v28) < 0) {
    goto LABEL_67;
  }
}

void sub_21DEA7A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy((uint64_t)v31, v31[1]);
  operator delete(v31);
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  if (a23 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v30 + 23) < 0) {
    operator delete(*(void **)v30);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(a1);
}

const void **ctu::cf::CFSharedRef<__CFURL const>::~CFSharedRef(const void **a1)
{
  char v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void BBUpdaterController::updateProvisioningInfo(uint64_t a1, uint64_t a2)
{
  char v2 = *(__CFDictionary **)(a1 + 32);
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 86, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x692u, (ctu::LogMessageBuffer *)"Assertion failure(dict && \"Failed to create dictionary for updating provisioning parameters.\")", v20, v21, v22, v54);
    goto LABEL_42;
  }
  if (!*(unsigned char *)(a1 + 242))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 86, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x694u, (ctu::LogMessageBuffer *)"Assertion failure(fProvisionState.requested && \"Failed to request provision state.\")", v23, v24, v25, v54);
LABEL_42:
  }
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  valuePtr[1] = Mutable;
  if (Mutable) {
    uint64_t v7 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7)
  {
    std::string v26 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v26, 86, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x69Au, (ctu::LogMessageBuffer *)"Assertion failure(tmp && \"Failed to create dictionary for updating provisioning parameters.\")", v27, v28, v29, v54);
  }
  uint64_t v8 = Mutable;
  LODWORD(valuePtr[0]) = *(unsigned char *)(a1 + 241) == 0;
  CFNumberRef v9 = CFNumberCreate(v5, kCFNumberSInt32Type, valuePtr);
  std::string value = v9;
  CFDictionarySetValue(v8, @"Status", v9);
  if (v9) {
    CFRelease(v9);
  }
  int v10 = *(void **)a2;
  uint64_t v11 = *(void *)(*(void *)a2 + 32);
  if (v11)
  {
    CFDataRef v12 = CFDataCreate(v5, *(const UInt8 **)v11, *(unsigned int *)(v11 + 8));
    CFDataRef v13 = v12;
    if (!v12)
    {
      uint64_t v30 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v30, 103, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Provisioning/BBUProvisioningParameters.h", 0x6Cu, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Failed to get session key.\")", v31, v32, v33, v54);
    }
    std::string value = v12;
    CFDictionarySetValue(v8, @"EncryptedSessionKey", v12);
    CFRelease(v13);
    int v10 = *(void **)a2;
  }
  if (*(unsigned char *)(a1 + 240))
  {
    if (*v10)
    {
      std::string value = (void *)0xAAAAAAAAAAAAAAAALL;
      if ((ctu::cf::convert_copy() & 1) == 0)
      {
        uint64_t v42 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v42, 30, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Provisioning/BBUProvisioningParameters.h", 0x1Cu, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Failed to get IMEI.\")", v43, v44, v45, v54);
      }
      uint64_t v14 = value;
      valuePtr[0] = value;
      CFDictionarySetValue(v8, @"IMEI", value);
      if (v14) {
        CFRelease(v14);
      }
      int v10 = *(void **)a2;
    }
    if (v10[1])
    {
      std::string value = (void *)0xAAAAAAAAAAAAAAAALL;
      if ((ctu::cf::convert_copy() & 1) == 0)
      {
        uint64_t v46 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v46, 30, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Provisioning/BBUProvisioningParameters.h", 0x1Cu, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Failed to get IMEI.\")", v47, v48, v49, v54);
      }
      uint64_t v15 = value;
      valuePtr[0] = value;
      CFDictionarySetValue(v8, @"IMEI2", value);
      if (v15) {
        CFRelease(v15);
      }
      int v10 = *(void **)a2;
    }
    if (v10[2])
    {
      std::string value = (void *)0xAAAAAAAAAAAAAAAALL;
      if ((ctu::cf::convert_copy() & 1) == 0)
      {
        char v50 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v50, 29, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Provisioning/BBUProvisioningParameters.h", 0x36u, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Failed to get MEID.\")", v51, v52, v53, v54);
      }
      uint64_t v16 = value;
      valuePtr[0] = value;
      CFDictionarySetValue(v8, @"MEID", value);
      if (v16) {
        CFRelease(v16);
      }
      int v10 = *(void **)a2;
    }
  }
  if (v10[3])
  {
    std::string value = (void *)0xAAAAAAAAAAAAAAAALL;
    if ((ctu::cf::convert_copy() & 1) == 0)
    {
      uint64_t v34 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v34, 107, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Provisioning/BBUProvisioningParameters.h", 0x50u, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Failed to get EID.\")", v35, v36, v37, v54);
    }
    uint64_t v17 = value;
    valuePtr[0] = value;
    CFDictionarySetValue(v8, @"EID", value);
    if (v17) {
      CFRelease(v17);
    }
    int v10 = *(void **)a2;
  }
  if (v10[6])
  {
    std::string value = (void *)0xAAAAAAAAAAAAAAAALL;
    if ((ctu::cf::convert_copy() & 1) == 0)
    {
      long long v38 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v38, 32, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Provisioning/BBUProvisioningParameters.h", 0xA1u, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Unrecognized radio type.\")", v39, v40, v41, v54);
    }
    int v18 = value;
    valuePtr[0] = value;
    CFDictionarySetValue(v8, @"CarrierID", value);
    if (v18) {
      CFRelease(v18);
    }
  }
  CFDictionarySetValue(v2, @"provisioning", v8);
  if (v8) {
    CFRelease(v8);
  }
}

void sub_21DEA8108(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, const void *a12)
{
  __cxa_free_exception(v12);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef(&a12);
  _Unwind_Resume(a1);
}

void sub_21DEA815C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEA8170(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEA8184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA8198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA81AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA81C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef((uint64_t *)va);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef(va1);
  _Unwind_Resume(a1);
}

void sub_21DEA81E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef((const void **)va1);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA8208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA821C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA8230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA8244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, const void *);
  ctu::cf::CFSharedRef<__CFNumber const>::~CFSharedRef((const void **)va1);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA8260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void sub_21DEA8274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ctu::cf::CFSharedRef<__CFDictionary>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

BBUProvisioningParameters **std::unique_ptr<BBUProvisioningParameters>::~unique_ptr[abi:ne180100](BBUProvisioningParameters **a1)
{
  char v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    BBUProvisioningParameters::~BBUProvisioningParameters(v2);
    operator delete(v3);
  }
  return a1;
}

void BBUpdaterController::provision(uint64_t a1, int a2)
{
  uint64_t v37 = 0;
  uint64_t v4 = operator new(0x38uLL);
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  unint64_t v4[2] = 0u;
  *((void *)v4 + 6) = 0;
  uint64_t v36 = v4;
  uint64_t v6 = BBUProvisioner::create(*(BBUProvisioner **)(a1 + 56), v5);
  uint64_t v7 = v6;
  if (!v6)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x3BCu, (ctu::LogMessageBuffer *)"Assertion failure(provisioner)", v25, v26, v27, v32);
  }
  (*(void (**)(void *, uint64_t))(*v6 + 24))(v6, 1);
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource((BBUpdaterController *)a1, 0);
  CFDataRef v12 = FirmwareDataSource;
  if (FirmwareDataSource)
  {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 104))(FirmwareDataSource);
    if (((*(uint64_t (**)(BBUEUR10UpdateSource *, uint64_t, uint64_t *))(*(void *)v12 + 120))(v12, 1, &v37) & 1) == 0)
    {
      BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "No provisioning data");
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventFinalize>(*(int **)(a1 + 16), *(std::__shared_weak_count **)(a1 + 24), (uint64_t)&v34);
      goto LABEL_12;
    }
    if (a2 != 2)
    {
      if (a2 != 1)
      {
        uint64_t v28 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v28, 70, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x3E5u, (ctu::LogMessageBuffer *)"Assertion failure(false && \"Unrecognized BBU provisioning stage.\")", v29, v30, v31, v32);
      }
      BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Will provision");
      BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Sending start provisioning command");
      unsigned int v16 = (*(uint64_t (**)(void *, uint64_t, _OWORD *, uint64_t))(*v7 + 32))(v7, v37, v4, a1 + 152);
      if (!v16)
      {
        BBUpdaterController::updateProvisioningInfo(a1, (uint64_t)&v36);
LABEL_12:
        (*(void (**)(BBUEUR10UpdateSource *))(*(void *)v12 + 16))(v12);
        goto LABEL_13;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_35;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_35;
        }
      }
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v13, v14, v15, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
LABEL_35:
      std::string::basic_string[abi:ne180100]<0>(&__p, "Failed starting mature provisioning.");
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        std::string v34 = __p;
        goto LABEL_44;
      }
      goto LABEL_43;
    }
    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Sending finish provisioning command");
    unsigned int v16 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*v7 + 40))(v7, v37, a1 + 152);
    if (!v16)
    {
      *(unsigned char *)(a1 + 241) = 1;
      BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Updating provisioning parameters from BB");
      unsigned int v16 = (*(uint64_t (**)(void, uint64_t, _OWORD *))(**(void **)(a1 + 72) + 88))(*(void *)(a1 + 72), a1 + 152, v4);
      if (!v16)
      {
        BBUpdaterController::updateProvisioningInfo(a1, (uint64_t)&v36);
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventFinalize>(*(int **)(a1 + 16), *(std::__shared_weak_count **)(a1 + 24), (uint64_t)&v34);
        goto LABEL_12;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_41;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_41;
        }
      }
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v20, v21, v22, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
LABEL_41:
      std::string::basic_string[abi:ne180100]<0>(&__p, "Failed to update provisioning parameters");
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        std::string v34 = __p;
        goto LABEL_44;
      }
      goto LABEL_43;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_29;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_29;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v17, v18, v19, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_29:
    std::string::basic_string[abi:ne180100]<0>(&__p, "Failed completing mature provisioning.");
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      std::string v34 = __p;
LABEL_44:
      uint64_t v35 = v16;
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&v34);
      if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v34.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      goto LABEL_12;
    }
LABEL_43:
    std::string::__init_copy_ctor_external(&v34, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    goto LABEL_44;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_16;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_16:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v9, v10, v11, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, "Fail to get update source for provision");
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v34, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v34 = __p;
  }
  uint64_t v35 = 35;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&v34);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v34.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_13:
  (*(void (**)(void *))(*v7 + 8))(v7);
  BBUProvisioningParameters::~BBUProvisioningParameters((BBUProvisioningParameters *)v4);
  operator delete(v23);
}

void sub_21DEA89F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v24 + 16))(v24);
  (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  std::unique_ptr<BBUProvisioningParameters>::~unique_ptr[abi:ne180100]((BBUProvisioningParameters **)(v25 - 64));
  _Unwind_Resume(a1);
}

void BBUpdaterController::process_event<BBUpdaterControllerFSM::eventFinalize>(int *a1, std::__shared_weak_count *a2, uint64_t a3)
{
  uint64_t v25 = a1;
  uint64_t v26 = a2;
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v24 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)a1 + 24))(__p, a1);
  CFAllocatorRef v5 = (void **)__p[0];
  uint64_t v6 = (void **)((char *)__p[0] + 24 * a1[8]);
  if (__dst != v6)
  {
    char v7 = *((unsigned char *)v6 + 23);
    if (SHIBYTE(v24) < 0)
    {
      if (v7 >= 0) {
        uint64_t v9 = (char *)__p[0] + 24 * a1[8];
      }
      else {
        uint64_t v9 = (char *)*v6;
      }
      if (v7 >= 0) {
        size_t v10 = *((unsigned __int8 *)v6 + 23);
      }
      else {
        size_t v10 = (size_t)v6[1];
      }
      std::string::__assign_no_alias<false>(__dst, v9, v10);
    }
    else if ((*((unsigned char *)v6 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v6, (size_t)v6[1]);
    }
    else
    {
      long long v8 = *(_OWORD *)v6;
      uint64_t v24 = (uint64_t)v6[2];
      *(_OWORD *)std::string __dst = v8;
    }
    CFAllocatorRef v5 = (void **)__p[0];
  }
  if (v5)
  {
    uint64_t v11 = (void **)__p[1];
    CFDataRef v12 = v5;
    if (__p[1] != v5)
    {
      do
      {
        if (*((char *)v11 - 1) < 0) {
          operator delete(*(v11 - 3));
        }
        v11 -= 3;
      }
      while (v11 != v5);
      CFDataRef v12 = (void **)__p[0];
    }
    __p[1] = v5;
    operator delete(v12);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFA9F31 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      unsigned int v16 = __p;
    }
    else {
      LOBYTE(v16) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v13, v14, v15, (char)v16);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventFinalize>((uint64_t)v25, a3, 1);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFA9F31 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v20 = __p;
    }
    else {
      LOBYTE(v20) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v17, v18, v19, (char)v20);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_40:
  if (SHIBYTE(v24) < 0) {
    operator delete(__dst[0]);
  }
  uint64_t v21 = v26;
  if (v26)
  {
    if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_21DEA8EC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  std::vector<std::string>::~vector[abi:ne180100](&a12);
  if ((a23 & 0x80000000) == 0)
  {
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v23 - 64);
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v23 - 64);
  _Unwind_Resume(a1);
}

uint64_t BBUpdaterController::createTransportNoEvents(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[7] = v6;
  v20[8] = v6;
  v20[5] = v6;
  v20[6] = v6;
  v20[3] = v6;
  v20[4] = v6;
  v20[1] = v6;
  v20[2] = v6;
  long long v19 = v6;
  v20[0] = v6;
  *(_OWORD *)std::string __p = v6;
  long long v18 = v6;
  v16[2] = v6;
  v16[3] = v6;
  v16[0] = v6;
  v16[1] = v6;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v16);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64), a1 + 152);
  uint64_t v10 = (*(uint64_t (**)(void, void, uint64_t, uint64_t))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72), *(void *)(a1 + 48), a3, a2);
  if (v10)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_8;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_8;
      }
    }
    if (gBBULogVerbosity < 6) {
      goto LABEL_8;
    }
    goto LABEL_14;
  }
  uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, double))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), a1 + 152, a3, 0, 0, 0.0);
  if (v10)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_8;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_8;
      }
    }
    if (gBBULogVerbosity < 6) {
      goto LABEL_8;
    }
LABEL_14:
    _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v7, v8, v9, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    goto LABEL_8;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    uint64_t v10 = 0;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 0x10) == 0) {
      goto LABEL_8;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t v10 = 0;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 0x10) == 0) {
      goto LABEL_8;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    char v11 = BBUStageAsString(a3);
    _BBULog(4, 0, "BBUpdaterController", "", "Finish preparing at %s\n", v12, v13, v14, v11);
    uint64_t v10 = 0;
  }
LABEL_8:
  *(void *)&v16[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v16 + *(void *)(*(void *)&v16[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v16[0] + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v20);
  return v10;
}

void sub_21DEA9314(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void BBUpdaterController::process_event<BBUpdaterControllerFSM::eventCmdQueryInfo>(int *a1, std::__shared_weak_count *a2, uint64_t a3)
{
  uint64_t v25 = a1;
  uint64_t v26 = a2;
  if (a2) {
    atomic_fetch_add_explicit(&a2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v24 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)a1 + 24))(__p, a1);
  CFAllocatorRef v5 = (void **)__p[0];
  long long v6 = (void **)((char *)__p[0] + 24 * a1[8]);
  if (__dst != v6)
  {
    char v7 = *((unsigned char *)v6 + 23);
    if (SHIBYTE(v24) < 0)
    {
      if (v7 >= 0) {
        uint64_t v9 = (char *)__p[0] + 24 * a1[8];
      }
      else {
        uint64_t v9 = (char *)*v6;
      }
      if (v7 >= 0) {
        size_t v10 = *((unsigned __int8 *)v6 + 23);
      }
      else {
        size_t v10 = (size_t)v6[1];
      }
      std::string::__assign_no_alias<false>(__dst, v9, v10);
    }
    else if ((*((unsigned char *)v6 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v6, (size_t)v6[1]);
    }
    else
    {
      long long v8 = *(_OWORD *)v6;
      uint64_t v24 = (uint64_t)v6[2];
      *(_OWORD *)std::string __dst = v8;
    }
    CFAllocatorRef v5 = (void **)__p[0];
  }
  if (v5)
  {
    char v11 = (void **)__p[1];
    uint64_t v12 = v5;
    if (__p[1] != v5)
    {
      do
      {
        if (*((char *)v11 - 1) < 0) {
          operator delete(*(v11 - 3));
        }
        v11 -= 3;
      }
      while (v11 != v5);
      uint64_t v12 = (void **)__p[0];
    }
    __p[1] = v5;
    operator delete(v12);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAA044 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      unsigned int v16 = __p;
    }
    else {
      LOBYTE(v16) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v13, v14, v15, (char)v16);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdQueryInfo>((uint64_t)v25, a3, 1);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAA044 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v20 = __p;
    }
    else {
      LOBYTE(v20) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v17, v18, v19, (char)v20);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_40:
  if (SHIBYTE(v24) < 0) {
    operator delete(__dst[0]);
  }
  unint64_t v21 = v26;
  if (v26)
  {
    if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void sub_21DEA969C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  std::vector<std::string>::~vector[abi:ne180100](&a12);
  if ((a23 & 0x80000000) == 0)
  {
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v23 - 64);
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v23 - 64);
  _Unwind_Resume(a1);
}

void BBUpdaterController::updateOutputPersonalizedParameters(BBUpdaterController *this)
{
  char v2 = (__CFDictionary *)*((void *)this + 4);
  uint64_t v3 = *(void *)(*((void *)this + 12) + 32);
  if (v3 && (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3))
  {
    uint64_t v4 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    CFDictionarySetValue(v2, @"ChipSerialNo", v4);
    uint64_t v5 = *(void *)(*((void *)this + 12) + 24);
    if (!v5)
    {
LABEL_9:
      CFDictionaryRemoveValue(v2, @"CertID");
      uint64_t v7 = *(void *)(*((void *)this + 12) + 40);
      if (!v7) {
        goto LABEL_14;
      }
      goto LABEL_10;
    }
  }
  else
  {
    CFDictionaryRemoveValue(v2, @"ChipSerialNo");
    uint64_t v5 = *(void *)(*((void *)this + 12) + 24);
    if (!v5) {
      goto LABEL_9;
    }
  }
  if (!(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5)) {
    goto LABEL_9;
  }
  long long v6 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  CFDictionarySetValue(v2, @"CertID", v6);
  uint64_t v7 = *(void *)(*((void *)this + 12) + 40);
  if (!v7) {
    goto LABEL_14;
  }
LABEL_10:
  if ((*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7))
  {
    long long v8 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
    CFDictionarySetValue(v2, @"CertHash", v8);
    return;
  }
LABEL_14:

  CFDictionaryRemoveValue(v2, @"CertHash");
}

void BBUpdaterController::cmdCopyRequirePartitionMount(BBUFeedback **this, const __CFDictionary **a2)
{
  if (a2)
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    ctu::cf::insert<__CFString const*,BOOL>(Mutable, @"requireSystemPartitionMount", 1);
    BBUFeedback::handleComment(this[7], "%s: supports flashless %d", "cmdCopyRequirePartitionMount", 1);
    BBUFeedback::handleComment(this[7], "%s: supports REFS %d", "cmdCopyRequirePartitionMount", 1);
    long long v6 = (capabilities::updater *)ctu::cf::insert<__CFString const*,BOOL>(Mutable, @"requireUserPartitionMount", 1);
    uint64_t v7 = capabilities::updater::BBUFSPartitionSizeMB(v6);
    block[0] = @"requestedBasebandFSPartitionMountSize";
    CFRetain(@"requestedBasebandFSPartitionMountSize");
    *(void *)&long long valuePtr = v7;
    CFNumberRef v8 = CFNumberCreate(v4, kCFNumberLongLongType, &valuePtr);
    __p[0] = v8;
    if (v8)
    {
      CFDictionaryAddValue(Mutable, @"requestedBasebandFSPartitionMountSize", v8);
      CFRelease(v8);
    }
    CFRelease(@"requestedBasebandFSPartitionMountSize");
    *a2 = Mutable;
    return;
  }
  pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  uint64_t v9 = qword_26AA89AB0;
  if (!qword_26AA89AB0)
  {
    size_t v10 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
    block[0] = 0;
    ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v10, "BBUError", QOS_CLASS_UTILITY, block);
    if (block[0]) {
      dispatch_release(block[0]);
    }
    v10->__on_zero_shared_weauint64_t k = 0;
    v10[1].~__shared_weak_count = 0;
    v10[1].~__shared_weak_count_0 = 0;
    std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&valuePtr, v10);
    long long v11 = valuePtr;
    long long valuePtr = 0uLL;
    uint64_t v12 = (std::__shared_weak_count *)off_26AA89AB8;
    *(_OWORD *)&qword_26AA89AB0 = v11;
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    uint64_t v13 = (std::__shared_weak_count *)*((void *)&valuePtr + 1);
    if (*((void *)&valuePtr + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&valuePtr + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    uint64_t v9 = qword_26AA89AB0;
  }
  uint64_t v14 = (std::__shared_weak_count *)off_26AA89AB8;
  if (off_26AA89AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  char v17 = 15;
  strcpy((char *)__p, "Null output ptr");
  *(void *)&long long valuePtr = MEMORY[0x263EF8330];
  *((void *)&valuePtr + 1) = 0x40000000;
  uint64_t v19 = ___ZN8BBUError8addErrorERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE9BBUReturn_block_invoke;
  uint64_t v20 = &__block_descriptor_tmp_8;
  unint64_t v21 = v9;
  uint64_t v22 = __p;
  int v23 = 2;
  p_long long valuePtr = &valuePtr;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_13_0;
  block[4] = v9;
  block[5] = &p_valuePtr;
  isa = v9[2].isa;
  if (!v9[3].isa)
  {
    dispatch_sync(isa, block);
    if ((v17 & 0x80000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  dispatch_async_and_wait(isa, block);
  if (v17 < 0) {
LABEL_20:
  }
    operator delete(__p[0]);
LABEL_21:
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
}

void sub_21DEA9CB8(_Unwind_Exception *a1)
{
  CFAllocatorRef v4 = *(NSObject **)(v2 - 96);
  if (v4) {
    dispatch_release(v4);
  }
  operator delete(v1);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

void sub_21DEA9CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  ctu::cf::ConvertToCFTypeRef::~ConvertToCFTypeRef((const void **)va);
  ctu::cf::ConvertToCFTypeRef::~ConvertToCFTypeRef((const void **)(v4 - 96));
  _Unwind_Resume(a1);
}

void sub_21DEA9D18(_Unwind_Exception *a1)
{
  ctu::cf::ConvertToCFTypeRef::~ConvertToCFTypeRef((const void **)(v1 - 96));
  _Unwind_Resume(a1);
}

uint64_t ctu::cf::insert<__CFString const*,BOOL>(CFMutableDictionaryRef theDict, CFTypeRef cf, int a3)
{
  if (cf) {
    CFRetain(cf);
  }
  long long v6 = (const void **)MEMORY[0x263EFFB40];
  if (!a3) {
    long long v6 = (const void **)MEMORY[0x263EFFB38];
  }
  uint64_t v7 = *v6;
  if (cf) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  uint64_t v9 = !v8;
  if (v8)
  {
    if (!v7) {
      goto LABEL_15;
    }
  }
  else
  {
    CFDictionaryAddValue(theDict, cf, v7);
  }
  CFRelease(v7);
LABEL_15:
  if (cf) {
    CFRelease(cf);
  }
  return v9;
}

void sub_21DEA9DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
}

void *BBUpdaterController::getFirmwareFolder(void *this, const __CFDictionary *a2)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  if (a2) {
    uint64_t v2 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    uint64_t v2 = 0;
  }
  if (v2)
  {
    uint64_t v3 = this;
    v6[0] = 0xAAAAAAAAAAAAAAAALL;
    v6[1] = 0xAAAAAAAAAAAAAAAALL;
    ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)v6, a2);
    ctu::cf::map_adapter::getString();
    *(_OWORD *)uint64_t v3 = v4;
    v3[2] = v5;
    return (void *)MEMORY[0x223C1D170](v6);
  }
  return this;
}

void sub_21DEA9EA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  MEMORY[0x223C1D170](v14 - 32);
  _Unwind_Resume(a1);
}

uint64_t BBUpdaterController::getNVRestoreSetting(BBUpdaterController *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  std::string value = (void *)0xAAAAAAAAAAAAAAAALL;
  if (this) {
    BOOL v8 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    BOOL v8 = 0;
  }
  if (!v8
    || !CFDictionaryGetValueIfPresent(this, @"NVRestoreSetting", (const void **)&value)
    || (v16 = -1431655766, (uint64_t v9 = (int *)value) == 0)
    || (CFTypeID v10 = CFGetTypeID(value), v10 != CFNumberGetTypeID())
    || (uint64_t v12 = (capabilities::updater *)ctu::cf::assign((ctu::cf *)&v16, v9, v11), (v12 & 1) == 0))
  {
LABEL_14:
    uint64_t v14 = 2;
    goto LABEL_15;
  }
  char v13 = v16;
  if (v16 - 6 > 0xFFFFFFFA)
  {
    uint64_t v14 = v16;
    if (v16 != 5) {
      goto LABEL_15;
    }
    if (capabilities::updater::supportsNVSettingOQCMagic(v12))
    {
      uint64_t v14 = 5;
      goto LABEL_15;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t v14 = 3;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
        goto LABEL_15;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      uint64_t v14 = 3;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
        goto LABEL_15;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      _BBULog(19, 0, "BBUpdaterController", "", "Invalid NVRestore setting provided: %d, changing to NoUpdate settings\n", a6, a7, a8, 5);
      uint64_t v14 = 3;
    }
  }
  else
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t v14 = 2;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
        goto LABEL_15;
      }
      goto LABEL_12;
    }
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t v14 = 2;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) != 0)
    {
LABEL_12:
      if (gBBULogVerbosity < 0) {
        goto LABEL_15;
      }
      _BBULog(19, 0, "BBUpdaterController", "", "Invalid NVRestore setting provided: %d, changing to Shipping (or NoUpdate for non-iOS) settings\n", a6, a7, a8, v13);
      goto LABEL_14;
    }
  }
LABEL_15:
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      return v14;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      return v14;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(19, 0, "BBUpdaterController", "", "NVRestore setting: %d\n", a6, a7, a8, v14);
  }
  return v14;
}

void BBUpdaterController::updateOutputFusingManifestInfo(BBUpdaterController *this)
{
  uint64_t v1 = (__CFDictionary *)*((void *)this + 4);
  if (!v1)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 24, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x625u, (ctu::LogMessageBuffer *)"Assertion failure(dict && \"Failed to create output dictionary for fusing manifest info.\")", v28, v29, v30, v39);
  }
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, (const void *)(*((void *)this + 12) + 88));
  if (v4) {
    uint64_t v5 = ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    uint64_t v31 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v31, 24, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x62Au, (ctu::LogMessageBuffer *)"Assertion failure(stateRef && \"Failed to create state reference for fusing manifest info.\")", v32, v33, v34, v39);
  }
  CFNumberRef v6 = v4;
  CFDictionarySetValue(v1, @"FusingStatus", v4);
  uint64_t v7 = *((void *)this + 12);
  if (*(_DWORD *)(v7 + 88) == 3)
  {
    BBUpdaterController::updateOutputPersonalizedParameters(this);
    uint64_t v7 = *((void *)this + 12);
  }
  uint64_t v8 = *(void *)(v7 + 8);
  if (v8 && (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8))
  {
    uint64_t v9 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
    CFDictionarySetValue(v1, @"Nonce", v9);
  }
  else
  {
    CFDictionaryRemoveValue(v1, @"Nonce");
  }
  uint64_t v10 = *(void *)(*((void *)this + 12) + 16);
  if (v10 && (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10))
  {
    CFNumberRef v11 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
    CFDictionarySetValue(v1, @"ChipID", v11);
  }
  else
  {
    CFDictionaryRemoveValue(v1, @"ChipID");
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v3, 6, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable) {
    char v13 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
  }
  else {
    char v13 = 0;
  }
  if (!v13)
  {
    uint64_t v35 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v35, 24, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x64Cu, (ctu::LogMessageBuffer *)"Assertion failure(manifestInfo && \"Failed to create fusing manifest info dictionary.\")", v36, v37, v38, (char)Mutable);
  }
  uint64_t v14 = *(void *)(*((void *)this + 12) + 48);
  if (v14 && (*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14))
  {
    uint64_t v15 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14);
    CFDictionarySetValue(Mutable, @"SKeyStatus", v15);
  }
  uint64_t v16 = *(void *)(*((void *)this + 12) + 56);
  if (v16 && (*(uint64_t (**)(uint64_t))(*(void *)v16 + 16))(v16))
  {
    char v17 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v16 + 16))(v16);
    CFDictionarySetValue(Mutable, @"SKeyHash", v17);
  }
  uint64_t v18 = *(void *)(*((void *)this + 12) + 64);
  if (v18 && (*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18))
  {
    uint64_t v19 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v18 + 16))(v18);
    CFDictionarySetValue(Mutable, @"PMStatusCode", v19);
  }
  uint64_t v20 = *(void *)(*((void *)this + 12) + 72);
  if (v20 && (*(uint64_t (**)(uint64_t))(*(void *)v20 + 16))(v20))
  {
    unint64_t v21 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v20 + 16))(v20);
    CFDictionarySetValue(Mutable, @"CMStatusCode", v21);
  }
  uint64_t v22 = *(void *)(*((void *)this + 12) + 80);
  if (v22 && (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22))
  {
    int v23 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
    CFDictionarySetValue(Mutable, @"FCMStatusCode", v23);
  }
  if (*((unsigned char *)this + 242))
  {
    int v24 = *((unsigned __int8 *)this + 240);
    uint64_t v25 = (const void *)*MEMORY[0x263EFFB40];
    if (v24) {
      uint64_t v26 = (const void *)*MEMORY[0x263EFFB40];
    }
    else {
      uint64_t v26 = (const void *)*MEMORY[0x263EFFB38];
    }
    CFDictionarySetValue(Mutable, @"ProvisioningManifestExists", v26);
    CFDictionarySetValue(Mutable, @"ProvisioningManifestSupported", v25);
  }
  if (CFDictionaryGetCount(Mutable) < 1) {
    CFDictionaryRemoveValue(v1, @"ManifestInfo");
  }
  else {
    CFDictionarySetValue(v1, @"ManifestInfo", Mutable);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v6) {
    CFRelease(v6);
  }
}

void sub_21DEAA6D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

const void **ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void **std::vector<std::string>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    CFAllocatorRef v3 = (void **)a1[1];
    CFNumberRef v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 3;
      }
      while (v3 != v2);
      CFNumberRef v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t BBUpdaterController::getShouldFuseProvision(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  value.__r_.__value_.__r.__words[0] = 0;
  __p.__r_.__value_.__s.__data_[0] = 0;
  uint64_t ValueIfPresent = *(void *)(a1 + 40);
  if (ValueIfPresent) {
    CFNumberRef v11 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    CFNumberRef v11 = 0;
  }
  if (v11 && *(_DWORD *)(*(void *)(a1 + 96) + 88) != 3)
  {
    uint64_t ValueIfPresent = CFDictionaryGetValueIfPresent((CFDictionaryRef)ValueIfPresent, @"DisallowFusing", (const void **)&value.__r_.__value_.__l.__data_);
    if (!ValueIfPresent) {
      goto LABEL_11;
    }
    uint64_t v12 = (BOOL *)value.__r_.__value_.__r.__words[0];
    if (value.__r_.__value_.__r.__words[0])
    {
      CFTypeID v13 = CFGetTypeID(value.__r_.__value_.__l.__data_);
      uint64_t ValueIfPresent = CFBooleanGetTypeID();
      if (v13 == ValueIfPresent) {
        uint64_t ValueIfPresent = ctu::cf::assign((ctu::cf *)&__p, v12, v14);
      }
    }
    if (!__p.__r_.__value_.__s.__data_[0])
    {
LABEL_11:
      uint64_t ValueIfPresent = CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 32), @"fuseAttemptSucceeded", (const void **)&value.__r_.__value_.__l.__data_);
      if (!ValueIfPresent) {
        goto LABEL_33;
      }
      uint64_t v15 = (BOOL *)value.__r_.__value_.__r.__words[0];
      if (value.__r_.__value_.__r.__words[0])
      {
        CFTypeID v16 = CFGetTypeID(value.__r_.__value_.__l.__data_);
        uint64_t ValueIfPresent = CFBooleanGetTypeID();
        if (v16 == ValueIfPresent) {
          uint64_t ValueIfPresent = ctu::cf::assign((ctu::cf *)&__p, v15, v17);
        }
      }
      if (!__p.__r_.__value_.__s.__data_[0])
      {
LABEL_33:
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
            goto LABEL_37;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
            goto LABEL_37;
          }
        }
        if ((gBBULogVerbosity & 0x80000000) == 0) {
          _BBULog(13, 0, "BBUpdaterController", "", "fusing is requested\n", a6, a7, a8, v74);
        }
LABEL_37:
        uint64_t v34 = *(int **)(a1 + 16);
        uint64_t v33 = *(std::__shared_weak_count **)(a1 + 24);
        uint64_t v79 = v34;
        char v80 = v33;
        if (v33) {
          atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        value.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
        value.__r_.__value_.__r.__words[2] = 0x7AAAAAAAAAAAAAALL;
        strcpy((char *)&value, "unknown");
        memset(&__p, 170, sizeof(__p));
        (*(void (**)(std::string *__return_ptr, int *))(*(void *)v34 + 24))(&__p, v34);
        std::string::size_type v35 = __p.__r_.__value_.__r.__words[0];
        std::string::size_type v36 = __p.__r_.__value_.__r.__words[0] + 24 * v34[8];
        if (&value != (std::string *)v36)
        {
          char v37 = *(unsigned char *)(v36 + 23);
          if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0)
          {
            if (v37 >= 0) {
              uint64_t v40 = (void *)(__p.__r_.__value_.__r.__words[0] + 24 * v34[8]);
            }
            else {
              uint64_t v40 = *(void **)v36;
            }
            if (v37 >= 0) {
              size_t v41 = *(unsigned __int8 *)(v36 + 23);
            }
            else {
              size_t v41 = *(void *)(v36 + 8);
            }
            std::string::__assign_no_alias<false>((void **)&value.__r_.__value_.__l.__data_, v40, v41);
          }
          else if ((*(unsigned char *)(v36 + 23) & 0x80) != 0)
          {
            std::string::__assign_no_alias<true>(&value, *(void **)v36, *(void *)(v36 + 8));
          }
          else
          {
            long long v38 = *(_OWORD *)v36;
            value.__r_.__value_.__r.__words[2] = *(void *)(v36 + 16);
            *(_OWORD *)&value.__r_.__value_.__l.__data_ = v38;
          }
          std::string::size_type v35 = __p.__r_.__value_.__r.__words[0];
        }
        if (v35)
        {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
          uint64_t v43 = (void *)v35;
          if (__p.__r_.__value_.__l.__size_ != v35)
          {
            do
            {
              if (*(char *)(size - 1) < 0) {
                operator delete(*(void **)(size - 24));
              }
              size -= 24;
            }
            while (size != v35);
            uint64_t v43 = (void *)__p.__r_.__value_.__r.__words[0];
          }
          __p.__r_.__value_.__l.__size_ = v35;
          operator delete(v43);
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
          {
LABEL_69:
            if ((gBBULogVerbosity & 0x80000000) == 0)
            {
              boost::core::demangle((boost::core *)&__p, (const char *)(0x800000021DFAA554 & 0x7FFFFFFFFFFFFFFFLL));
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                p_p = &__p;
              }
              else {
                LOBYTE(p_p) = __p.__r_.__value_.__s.__data_[0];
              }
              _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v44, v45, v46, (char)p_p);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
            }
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
            goto LABEL_69;
          }
        }
        boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventFuse>((uint64_t)v79, (uint64_t)&v75, 1);
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
            goto LABEL_133;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
            goto LABEL_133;
          }
        }
        if ((gBBULogVerbosity & 0x80000000) == 0)
        {
          boost::core::demangle((boost::core *)&__p, (const char *)(0x800000021DFAA554 & 0x7FFFFFFFFFFFFFFFLL));
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v51 = &__p;
          }
          else {
            LOBYTE(v51) = __p.__r_.__value_.__s.__data_[0];
          }
LABEL_131:
          _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v48, v49, v50, (char)v51);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
LABEL_133:
        if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(value.__r_.__value_.__l.__data_);
        }
        uint64_t v69 = v80;
        if (v80)
        {
          if (!atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
            std::__shared_weak_count::__release_weak(v69);
          }
        }
        return 0;
      }
    }
  }
  if (BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS == -1)
  {
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1) {
      goto LABEL_18;
    }
  }
  else
  {
    dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1)
    {
LABEL_18:
      if (BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS) {
        goto LABEL_19;
      }
LABEL_83:
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
          goto LABEL_88;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
          goto LABEL_88;
        }
      }
      if (gBBULogVerbosity < 1) {
        goto LABEL_88;
      }
      uint64_t v32 = "shouldPerformFusingVerification: it is not Resotre OS!\n";
      goto LABEL_87;
    }
  }
  dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
  if (!(BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS)) {
    goto LABEL_83;
  }
LABEL_19:
  if ((capabilities::updater::supportsBBFusing((capabilities::updater *)ValueIfPresent) & 1) == 0)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
        goto LABEL_88;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
        goto LABEL_88;
      }
    }
    if (gBBULogVerbosity < 1) {
      goto LABEL_88;
    }
    uint64_t v32 = "shouldPerformFusingVerification: Fusing verification will not perform on legacy device\n";
    goto LABEL_87;
  }
  value.__r_.__value_.__r.__words[0] = 0;
  if (!CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 32), @"fuseAttemptSucceeded", (const void **)&value.__r_.__value_.__l.__data_))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
        goto LABEL_88;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
        goto LABEL_88;
      }
    }
    if (gBBULogVerbosity < 1) {
      goto LABEL_88;
    }
    uint64_t v32 = "shouldPerformFusingVerification: it didn't go through fusing process before.\n";
LABEL_87:
    _BBULog(19, 1, "BBUpdaterController", "", v32, a6, a7, a8, v74);
    goto LABEL_88;
  }
  uint64_t v18 = BBUFusing::create(*(capabilities::updater **)(a1 + 56), a1 + 152);
  if (!v18)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 24, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x2EFu, (ctu::LogMessageBuffer *)"Assertion failure(fuser && \"Error in creating fusing process.\")", v71, v72, v73, v74);
  }
  uint64_t v19 = v18;
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource((BBUpdaterController *)a1, 0);
  int v24 = FirmwareDataSource;
  if (!FirmwareDataSource)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_157;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_157:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v21, v22, v23, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, "Fail to get update source for fuse");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&value, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string value = __p;
    }
    uint64_t v77 = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&value);
    if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(value.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    (*(void (**)(_DWORD *))(*(void *)v19 + 8))(v19);
    goto LABEL_49;
  }
  if (!(*(uint64_t (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 64))(FirmwareDataSource))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_163;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_163:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v25, v26, v27, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    std::string::basic_string[abi:ne180100]<0>(&__p, "Fusing Verification is requested, but could not found the fusing source (fusingprogram.plist)");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&value, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string value = __p;
    }
    uint64_t v77 = 24;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(a1, (uint64_t)&value);
    if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(value.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    char v31 = 0;
    goto LABEL_48;
  }
  if (!(*(unsigned int (**)(_DWORD *, BBUEUR10UpdateSource *, void))(*(void *)v19 + 24))(v19, v24, 0))
  {
    char v31 = 1;
    goto LABEL_48;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    char v31 = 0;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      goto LABEL_48;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    char v31 = 0;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
      goto LABEL_48;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    _BBULog(19, 0, "BBUpdaterController", "", "Failed to verify fusing\n", v28, v29, v30, v74);
    char v31 = 0;
  }
LABEL_48:
  (*(void (**)(BBUEUR10UpdateSource *))(*(void *)v24 + 16))(v24);
  (*(void (**)(_DWORD *))(*(void *)v19 + 8))(v19);
  if ((v31 & 1) == 0)
  {
LABEL_49:
    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Failed to validate fusing");
    return 125;
  }
LABEL_88:
  (*(void (**)(void))(**(void **)a2 + 104))();
  if ((*(unsigned int (**)(void))(**(void **)a2 + 112))())
  {
    *(unsigned char *)(a1 + 242) = 1;
    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "Will request provisioning");
    uint64_t v56 = *(int **)(a1 + 16);
    uint64_t v55 = *(std::__shared_weak_count **)(a1 + 24);
    uint64_t v79 = v56;
    char v80 = v55;
    if (v55) {
      atomic_fetch_add_explicit(&v55->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    value.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
    value.__r_.__value_.__r.__words[2] = 0x7AAAAAAAAAAAAAALL;
    strcpy((char *)&value, "unknown");
    memset(&__p, 170, sizeof(__p));
    (*(void (**)(std::string *__return_ptr, int *))(*(void *)v56 + 24))(&__p, v56);
    std::string::size_type v57 = __p.__r_.__value_.__r.__words[0];
    std::string::size_type v58 = __p.__r_.__value_.__r.__words[0] + 24 * v56[8];
    if (&value != (std::string *)v58)
    {
      char v59 = *(unsigned char *)(v58 + 23);
      if (SHIBYTE(value.__r_.__value_.__r.__words[2]) < 0)
      {
        if (v59 >= 0) {
          uint64_t v61 = (void *)(__p.__r_.__value_.__r.__words[0] + 24 * v56[8]);
        }
        else {
          uint64_t v61 = *(void **)v58;
        }
        if (v59 >= 0) {
          size_t v62 = *(unsigned __int8 *)(v58 + 23);
        }
        else {
          size_t v62 = *(void *)(v58 + 8);
        }
        std::string::__assign_no_alias<false>((void **)&value.__r_.__value_.__l.__data_, v61, v62);
      }
      else if ((*(unsigned char *)(v58 + 23) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(&value, *(void **)v58, *(void *)(v58 + 8));
      }
      else
      {
        long long v60 = *(_OWORD *)v58;
        value.__r_.__value_.__r.__words[2] = *(void *)(v58 + 16);
        *(_OWORD *)&value.__r_.__value_.__l.__data_ = v60;
      }
      std::string::size_type v57 = __p.__r_.__value_.__r.__words[0];
    }
    if (v57)
    {
      std::string::size_type v63 = __p.__r_.__value_.__l.__size_;
      uint64_t v64 = (void *)v57;
      if (__p.__r_.__value_.__l.__size_ != v57)
      {
        do
        {
          if (*(char *)(v63 - 1) < 0) {
            operator delete(*(void **)(v63 - 24));
          }
          v63 -= 24;
        }
        while (v63 != v57);
        uint64_t v64 = (void *)__p.__r_.__value_.__r.__words[0];
      }
      __p.__r_.__value_.__l.__size_ = v57;
      operator delete(v64);
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
      {
LABEL_119:
        if ((gBBULogVerbosity & 0x80000000) == 0)
        {
          boost::core::demangle((boost::core *)&__p, (const char *)(0x800000021DFAA65DLL & 0x7FFFFFFFFFFFFFFFLL));
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v68 = &__p;
          }
          else {
            LOBYTE(v68) = __p.__r_.__value_.__s.__data_[0];
          }
          _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v65, v66, v67, (char)v68);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
        }
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
        goto LABEL_119;
      }
    }
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventProvision>((uint64_t)v79, (uint64_t)&v75, 1);
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
        goto LABEL_133;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
        goto LABEL_133;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      boost::core::demangle((boost::core *)&__p, (const char *)(0x800000021DFAA65DLL & 0x7FFFFFFFFFFFFFFFLL));
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v51 = &__p;
      }
      else {
        LOBYTE(v51) = __p.__r_.__value_.__s.__data_[0];
      }
      goto LABEL_131;
    }
    goto LABEL_133;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x10) != 0) {
      goto LABEL_97;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x10) != 0)
    {
LABEL_97:
      if (gBBULogVerbosity >= 1) {
        _BBULog(20, 1, "BBUpdaterController", "", "baseband provisioning is not requested\n", v52, v53, v54, v74);
      }
    }
  }
  *(unsigned char *)(a1 + 242) = 0;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventFinalize>(*(int **)(a1 + 16), *(std::__shared_weak_count **)(a1 + 24), (uint64_t)&value);
  return 0;
}

void sub_21DEAB734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v27 + 16))(v27);
  (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  _Unwind_Resume(a1);
}

void sub_21DEAB860(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((a18 & 0x80000000) == 0)
    {
LABEL_3:
      std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v26 - 64);
      _Unwind_Resume(a1);
    }
  }
  else if ((a18 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  JUMPOUT(0x21DEAB8ACLL);
}

void sub_21DEAB8A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0)
  {
    operator delete(__p);
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v18 - 64);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v18 - 64);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C340] + 64;
  *(void *)(a1 + 112) = MEMORY[0x263F8C340] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x263F8C2C8] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x263F8C2C8] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  uint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x263F8C340] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_21DEABA34(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v1);
  _Unwind_Resume(a1);
}

unsigned char *std::ostringstream::str[abi:ne180100](unsigned char *__dst, uint64_t a2)
{
  uint64_t v2 = __dst;
  int v3 = *(_DWORD *)(a2 + 104);
  if ((v3 & 0x10) != 0)
  {
    unint64_t v4 = *(void *)(a2 + 96);
    unint64_t v5 = *(void *)(a2 + 56);
    if (v4 < v5)
    {
      *(void *)(a2 + 96) = v5;
      unint64_t v4 = v5;
    }
    uint64_t v6 = *(const void **)(a2 + 48);
    size_t v7 = v4 - (void)v6;
    if (v4 - (unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_16;
    }
  }
  else
  {
    if ((v3 & 8) == 0)
    {
      __dst[23] = 0;
LABEL_4:
      *std::string __dst = 0;
      return __dst;
    }
    uint64_t v6 = *(const void **)(a2 + 24);
    size_t v7 = *(void *)(a2 + 40) - (void)v6;
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_16:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v7 >= 0x17)
  {
    uint64_t v8 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v8 = v7 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t v10 = operator new(v8 + 1);
    v2[1] = v7;
    v2[2] = v9 | 0x8000000000000000;
    *uint64_t v2 = v10;
    uint64_t v2 = v10;
  }
  else
  {
    __dst[23] = v7;
    if (!v7) {
      goto LABEL_4;
    }
  }
  std::string __dst = memmove(v2, v6, v7);
  *((unsigned char *)v2 + v7) = 0;
  return __dst;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2C8];
  uint64_t v3 = *MEMORY[0x263F8C2C8];
  *(void *)a1 = *MEMORY[0x263F8C2C8];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](a1 + 112);
  return a1;
}

void BBUpdaterController::dumpLogBufferInternal(uint64_t a1, void *a2, const char *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!a3 || !*a2)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0xB61u, (ctu::LogMessageBuffer *)"Assertion failure(logBuffer && msg)", v13, v14, v15, v16);
  }
  (*(void (**)(void))(*(void *)*a2 + 40))(*a2);
  CFBooleanRef v17 = (void *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(void **__return_ptr))(*(void *)*a2 + 48))(&v17);
  bzero(v20, 0x400uLL);
  BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 56), "LOG BEGIN: ******* %s *******\n", a3);
  uint64_t v6 = (std::locale::id *)MEMORY[0x263F8C108];
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
    size_t v7 = std::locale::use_facet(&v19, v6);
    ((void (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10);
    std::locale::~locale(&v19);
    uint64_t v8 = (void *)std::istream::getline();
    uint64_t v9 = (char *)v8 + *(void *)(*v8 - 24);
    uint64_t v10 = *(BBUFeedback **)(a1 + 56);
    if ((v9[32] & 5) != 0) {
      break;
    }
    BBUFeedback::handleComment(v10, "%s", v20);
  }
  BBUFeedback::handleComment(v10, "LOG END: ******* %s *******\n", a3);
  CFNumberRef v11 = (std::__shared_weak_count *)v18;
  if (v18)
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(v18 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

void sub_21DEABED0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEABEE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DEABEFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, std::locale a13)
{
}

void sub_21DEABF18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke()
{
  char v31 = @"Query Info";
  uint64_t v0 = _Block_copy(&__block_literal_global_379);
  uint64_t v30 = @"queryInfo";
  uint64_t v32 = v0;
  uint64_t v33 = &v30;
  uint64_t v1 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  uint64_t v2 = (const void *)v1[6];
  v1[5] = @"Query Info";
  v1[6] = (uint64_t)v0;
  if (v2) {
    _Block_release(v2);
  }
  char v31 = @"Query Identifier Info";
  uint64_t v3 = _Block_copy(&__block_literal_global_385);
  uint64_t v30 = @"CopyIdentifier";
  uint64_t v32 = v3;
  uint64_t v33 = &v30;
  unint64_t v4 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  unint64_t v5 = (const void *)v4[6];
  v4[5] = @"Query Identifier Info";
  v4[6] = (uint64_t)v3;
  if (v5) {
    _Block_release(v5);
  }
  char v31 = @"Perform Next Stage";
  uint64_t v6 = _Block_copy(&__block_literal_global_391);
  uint64_t v30 = @"performNextStage";
  uint64_t v32 = v6;
  uint64_t v33 = &v30;
  size_t v7 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  uint64_t v8 = (const void *)v7[6];
  v7[5] = @"Perform Next Stage";
  v7[6] = (uint64_t)v6;
  if (v8) {
    _Block_release(v8);
  }
  char v31 = @"Perform Core Dump";
  uint64_t v9 = _Block_copy(&__block_literal_global_397);
  uint64_t v30 = @"performCoreDump";
  uint64_t v32 = v9;
  uint64_t v33 = &v30;
  uint64_t v10 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  CFNumberRef v11 = (const void *)v10[6];
  v10[5] = @"Perform Core Dump";
  v10[6] = (uint64_t)v9;
  if (v11) {
    _Block_release(v11);
  }
  char v31 = @"Boot up";
  uint64_t v12 = _Block_copy(&__block_literal_global_403);
  uint64_t v30 = @"performBootup";
  uint64_t v32 = v12;
  uint64_t v33 = &v30;
  uint64_t v13 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  uint64_t v14 = (const void *)v13[6];
  v13[5] = @"Boot up";
  v13[6] = (uint64_t)v12;
  if (v14) {
    _Block_release(v14);
  }
  char v31 = @"Manifest check";
  uint64_t v15 = _Block_copy(&__block_literal_global_409);
  uint64_t v30 = @"performManifestCheck";
  uint64_t v32 = v15;
  uint64_t v33 = &v30;
  char v16 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  CFBooleanRef v17 = (const void *)v16[6];
  v16[5] = @"Manifest check";
  v16[6] = (uint64_t)v15;
  if (v17) {
    _Block_release(v17);
  }
  char v31 = @"Query whether the system partition needs to be mounted";
  unint64_t v18 = _Block_copy(&__block_literal_global_415);
  uint64_t v30 = @"requireSystemPartitionMount";
  uint64_t v32 = v18;
  uint64_t v33 = &v30;
  std::locale v19 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  uint64_t v20 = (const void *)v19[6];
  v19[5] = @"Query whether the system partition needs to be mounted";
  v19[6] = (uint64_t)v18;
  if (v20) {
    _Block_release(v20);
  }
  char v31 = @"Query whether any partitions need to be mounted";
  uint64_t v21 = _Block_copy(&__block_literal_global_418);
  uint64_t v30 = @"requirePartitionMount";
  uint64_t v32 = v21;
  uint64_t v33 = &v30;
  uint64_t v22 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  uint64_t v23 = (const void *)v22[6];
  v22[5] = @"Query whether any partitions need to be mounted";
  v22[6] = (uint64_t)v21;
  if (v23) {
    _Block_release(v23);
  }
  char v31 = @"Copy baseband data to migrate during an erase install";
  int v24 = _Block_copy(&__block_literal_global_424);
  uint64_t v30 = @"copyBasebandMigrationData";
  uint64_t v32 = v24;
  uint64_t v33 = &v30;
  uint64_t v25 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  uint64_t v26 = (const void *)v25[6];
  v25[5] = @"Copy baseband data to migrate during an erase install";
  v25[6] = (uint64_t)v24;
  if (v26) {
    _Block_release(v26);
  }
  char v31 = @"restoreBasebandMigrationData";
  uint64_t v27 = _Block_copy(&__block_literal_global_433);
  uint64_t v30 = @"restoreBasebandMigrationData";
  uint64_t v32 = v27;
  uint64_t v33 = &v30;
  uint64_t v28 = std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>((CFStringRef *)&v30, (uint64_t **)&v33);
  uint64_t v32 = 0;
  uint64_t v29 = (const void *)v28[6];
  v28[5] = @"restoreBasebandMigrationData";
  v28[6] = (uint64_t)v27;
  if (v29) {
    _Block_release(v29);
  }
}

void sub_21DEAC2DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC2F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC30C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC324(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC33C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC354(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC36C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC384(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC39C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

void sub_21DEAC3B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  BBUpdaterController::CmdInfo::~CmdInfo((BBUpdaterController::CmdInfo *)va);
  _Unwind_Resume(a1);
}

CFTypeRef ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventCmdQueryInfo>(*(int **)(a2 + 16), *(std::__shared_weak_count **)(a2 + 24), (uint64_t)&v6);
  BBUpdaterController::updateOutputFusingManifestInfo((BBUpdaterController *)a2);
  CFTypeRef result = CFRetain(*(CFTypeRef *)(a2 + 32));
  *a3 = result;
  return result;
}

void BBUpdaterController::CmdInfo::~CmdInfo(BBUpdaterController::CmdInfo *this)
{
  uint64_t v1 = (const void *)*((void *)this + 1);
  if (v1) {
    _Block_release(v1);
  }
}

void ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_3(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v13 = 1;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 1) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 1) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(0, 0, "BBUpdaterController", "", "Entering cmdCopyIdentifier\n", a6, a7, a8, v11);
  }
LABEL_5:
  TelephonyBasebandGetReset();
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventCmdQueryInfo>(*(int **)(a2 + 16), *(std::__shared_weak_count **)(a2 + 24), (uint64_t)&v12);
  (*(void (**)(void, uint64_t))(**(void **)(a2 + 64) + 40))(*(void *)(a2 + 64), a2 + 152);
  BBUpdaterController::updateOutputPersonalizedParameters((BBUpdaterController *)a2);
  BBUpdaterController::updateOutputFusingManifestInfo((BBUpdaterController *)a2);
  CFTypeRef v10 = CFRetain(*(CFTypeRef *)(a2 + 32));
  *a3 = v10;
  CFShow(v10);
}

void sub_21DEAC7B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    operator delete(v17);
    _Unwind_Resume(a1);
  }
  operator delete(v17);
  _Unwind_Resume(a1);
}

CFTypeRef ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_4(uint64_t a1, uint64_t a2, void *a3)
{
  memset(&v25, 0, sizeof(v25));
  int v27 = 0;
  std::string::__assign_external(&v25, "Fail to perform cmdPerformNextStage", 0x23uLL);
  int v26 = 42;
  char v6 = *(int **)(a2 + 16);
  unint64_t v5 = *(std::__shared_weak_count **)(a2 + 24);
  char v31 = v6;
  uint64_t v32 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v30 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)v6 + 24))(__p, v6);
  size_t v7 = (void **)__p[0];
  uint64_t v8 = (void **)((char *)__p[0] + 24 * v6[8]);
  if (__dst != v8)
  {
    char v9 = *((unsigned char *)v8 + 23);
    if (SHIBYTE(v30) < 0)
    {
      if (v9 >= 0) {
        char v11 = (char *)__p[0] + 24 * v6[8];
      }
      else {
        char v11 = (char *)*v8;
      }
      if (v9 >= 0) {
        size_t v12 = *((unsigned __int8 *)v8 + 23);
      }
      else {
        size_t v12 = (size_t)v8[1];
      }
      std::string::__assign_no_alias<false>(__dst, v11, v12);
    }
    else if ((*((unsigned char *)v8 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v8, (size_t)v8[1]);
    }
    else
    {
      long long v10 = *(_OWORD *)v8;
      uint64_t v30 = (uint64_t)v8[2];
      *(_OWORD *)std::string __dst = v10;
    }
    size_t v7 = (void **)__p[0];
  }
  if (v7)
  {
    char v13 = (void **)__p[1];
    uint64_t v14 = v7;
    if (__p[1] != v7)
    {
      do
      {
        if (*((char *)v13 - 1) < 0) {
          operator delete(*(v13 - 3));
        }
        v13 -= 3;
      }
      while (v13 != v7);
      uint64_t v14 = (void **)__p[0];
    }
    __p[1] = v7;
    operator delete(v14);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAA772 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      unint64_t v18 = __p;
    }
    else {
      LOBYTE(v18) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v15, v16, v17, (char)v18);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformNextStage>((uint64_t)v31, (uint64_t)&v25, 1);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAA772 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v19, v20, v21, (char)v22);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_40:
  if (SHIBYTE(v30) < 0) {
    operator delete(__dst[0]);
  }
  uint64_t v23 = v32;
  if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
LABEL_45:
  }
    operator delete(v25.__r_.__value_.__l.__data_);
LABEL_46:
  BBUpdaterController::updateOutputFusingManifestInfo((BBUpdaterController *)a2);
  CFTypeRef result = CFRetain(*(CFTypeRef *)(a2 + 32));
  *a3 = result;
  return result;
}

void sub_21DEACBC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  std::vector<std::string>::~vector[abi:ne180100](&a19);
  if (a30 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v30 - 80);
  if (a17 < 0) {
    operator delete(a12);
  }
  _Unwind_Resume(a1);
}

void sub_21DEACC34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if ((a17 & 0x80000000) == 0) {
    JUMPOUT(0x21DEACC2CLL);
  }
  JUMPOUT(0x21DEACC24);
}

CFTypeRef ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_5(uint64_t a1, uint64_t a2, void *a3)
{
  char v6 = *(int **)(a2 + 16);
  unint64_t v5 = *(std::__shared_weak_count **)(a2 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v27 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)v6 + 24))(__p, v6);
  size_t v7 = (void **)__p[0];
  uint64_t v8 = (void **)((char *)__p[0] + 24 * v6[8]);
  if (__dst != v8)
  {
    char v9 = *((unsigned char *)v8 + 23);
    if (SHIBYTE(v27) < 0)
    {
      if (v9 >= 0) {
        char v11 = (char *)__p[0] + 24 * v6[8];
      }
      else {
        char v11 = (char *)*v8;
      }
      if (v9 >= 0) {
        size_t v12 = *((unsigned __int8 *)v8 + 23);
      }
      else {
        size_t v12 = (size_t)v8[1];
      }
      std::string::__assign_no_alias<false>(__dst, v11, v12);
    }
    else if ((*((unsigned char *)v8 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v8, (size_t)v8[1]);
    }
    else
    {
      long long v10 = *(_OWORD *)v8;
      uint64_t v27 = (uint64_t)v8[2];
      *(_OWORD *)std::string __dst = v10;
    }
    size_t v7 = (void **)__p[0];
  }
  if (v7)
  {
    char v13 = (void **)__p[1];
    uint64_t v14 = v7;
    if (__p[1] != v7)
    {
      do
      {
        if (*((char *)v13 - 1) < 0) {
          operator delete(*(v13 - 3));
        }
        v13 -= 3;
      }
      while (v13 != v7);
      uint64_t v14 = (void **)__p[0];
    }
    __p[1] = v7;
    operator delete(v14);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAAA9DLL & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      unint64_t v18 = __p;
    }
    else {
      LOBYTE(v18) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v15, v16, v17, (char)v18);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformCoreDump>((uint64_t)v6, (uint64_t)&v24, 1);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAAA9DLL & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v19, v20, v21, (char)v22);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_40:
  if (SHIBYTE(v27) < 0) {
    operator delete(__dst[0]);
  }
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  BBUpdaterController::updateOutputFusingManifestInfo((BBUpdaterController *)a2);
  CFTypeRef result = CFRetain(*(CFTypeRef *)(a2 + 32));
  *a3 = result;
  return result;
}

void sub_21DEACFB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **__p, void **a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (__p)
  {
    uint64_t v27 = a15;
    uint64_t v28 = __p;
    if (a15 != __p)
    {
      do
      {
        if (*((char *)v27 - 1) < 0) {
          operator delete(*(v27 - 3));
        }
        v27 -= 3;
      }
      while (v27 != __p);
      uint64_t v28 = __p;
    }
    operator delete(v28);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (v25)
  {
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_6(uint64_t a1, uint64_t a2, void *a3)
{
  char v6 = *(int **)(a2 + 16);
  unint64_t v5 = *(std::__shared_weak_count **)(a2 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v27 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)v6 + 24))(__p, v6);
  size_t v7 = (void **)__p[0];
  uint64_t v8 = (void **)((char *)__p[0] + 24 * v6[8]);
  if (__dst != v8)
  {
    char v9 = *((unsigned char *)v8 + 23);
    if (SHIBYTE(v27) < 0)
    {
      if (v9 >= 0) {
        char v11 = (char *)__p[0] + 24 * v6[8];
      }
      else {
        char v11 = (char *)*v8;
      }
      if (v9 >= 0) {
        size_t v12 = *((unsigned __int8 *)v8 + 23);
      }
      else {
        size_t v12 = (size_t)v8[1];
      }
      std::string::__assign_no_alias<false>(__dst, v11, v12);
    }
    else if ((*((unsigned char *)v8 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v8, (size_t)v8[1]);
    }
    else
    {
      long long v10 = *(_OWORD *)v8;
      uint64_t v27 = (uint64_t)v8[2];
      *(_OWORD *)std::string __dst = v10;
    }
    size_t v7 = (void **)__p[0];
  }
  if (v7)
  {
    char v13 = (void **)__p[1];
    uint64_t v14 = v7;
    if (__p[1] != v7)
    {
      do
      {
        if (*((char *)v13 - 1) < 0) {
          operator delete(*(v13 - 3));
        }
        v13 -= 3;
      }
      while (v13 != v7);
      uint64_t v14 = (void **)__p[0];
    }
    __p[1] = v7;
    operator delete(v14);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAABC4 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      unint64_t v18 = __p;
    }
    else {
      LOBYTE(v18) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v15, v16, v17, (char)v18);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformBootup>((uint64_t)v6, (uint64_t)&v24, 1);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAABC4 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v19, v20, v21, (char)v22);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_40:
  if (SHIBYTE(v27) < 0) {
    operator delete(__dst[0]);
  }
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  BBUpdaterController::updateOutputFusingManifestInfo((BBUpdaterController *)a2);
  CFTypeRef result = CFRetain(*(CFTypeRef *)(a2 + 32));
  *a3 = result;
  return result;
}

void sub_21DEAD404(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **__p, void **a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (__p)
  {
    uint64_t v27 = a15;
    uint64_t v28 = __p;
    if (a15 != __p)
    {
      do
      {
        if (*((char *)v27 - 1) < 0) {
          operator delete(*(v27 - 3));
        }
        v27 -= 3;
      }
      while (v27 != __p);
      uint64_t v28 = __p;
    }
    operator delete(v28);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (v25)
  {
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  _Unwind_Resume(exception_object);
}

CFTypeRef ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_7(uint64_t a1, uint64_t a2, void *a3)
{
  char v6 = *(int **)(a2 + 16);
  unint64_t v5 = *(std::__shared_weak_count **)(a2 + 24);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  __dst[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v27 = 0x7AAAAAAAAAAAAAALL;
  strcpy((char *)__dst, "unknown");
  memset(__p, 170, sizeof(__p));
  (*(void (**)(void **__return_ptr, int *))(*(void *)v6 + 24))(__p, v6);
  size_t v7 = (void **)__p[0];
  uint64_t v8 = (void **)((char *)__p[0] + 24 * v6[8]);
  if (__dst != v8)
  {
    char v9 = *((unsigned char *)v8 + 23);
    if (SHIBYTE(v27) < 0)
    {
      if (v9 >= 0) {
        char v11 = (char *)__p[0] + 24 * v6[8];
      }
      else {
        char v11 = (char *)*v8;
      }
      if (v9 >= 0) {
        size_t v12 = *((unsigned __int8 *)v8 + 23);
      }
      else {
        size_t v12 = (size_t)v8[1];
      }
      std::string::__assign_no_alias<false>(__dst, v11, v12);
    }
    else if ((*((unsigned char *)v8 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(__dst, *v8, (size_t)v8[1]);
    }
    else
    {
      long long v10 = *(_OWORD *)v8;
      uint64_t v27 = (uint64_t)v8[2];
      *(_OWORD *)std::string __dst = v10;
    }
    size_t v7 = (void **)__p[0];
  }
  if (v7)
  {
    char v13 = (void **)__p[1];
    uint64_t v14 = v7;
    if (__p[1] != v7)
    {
      do
      {
        if (*((char *)v13 - 1) < 0) {
          operator delete(*(v13 - 3));
        }
        v13 -= 3;
      }
      while (v13 != v7);
      uint64_t v14 = (void **)__p[0];
    }
    __p[1] = v7;
    operator delete(v14);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_32;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAACE7 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      unint64_t v18 = __p;
    }
    else {
      LOBYTE(v18) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "processing event: %s, current state %d [%s]\n", v15, v16, v17, (char)v18);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_32:
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>((uint64_t)v6, (uint64_t)&v24, 1);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) == 0) {
      goto LABEL_40;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    boost::core::demangle((boost::core *)__p, (const char *)(0x800000021DFAACE7 & 0x7FFFFFFFFFFFFFFFLL));
    if (SHIBYTE(__p[2]) >= 0) {
      uint64_t v22 = __p;
    }
    else {
      LOBYTE(v22) = __p[0];
    }
    _BBULog(21, 0, "BBUpdaterController", "", "finish processing event: %s\n", v19, v20, v21, (char)v22);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
  }
LABEL_40:
  if (SHIBYTE(v27) < 0) {
    operator delete(__dst[0]);
  }
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  BBUpdaterController::updateOutputFusingManifestInfo((BBUpdaterController *)a2);
  CFTypeRef result = CFRetain(*(CFTypeRef *)(a2 + 32));
  *a3 = result;
  return result;
}

void sub_21DEAD850(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **__p, void **a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (__p)
  {
    uint64_t v27 = a15;
    uint64_t v28 = __p;
    if (a15 != __p)
    {
      do
      {
        if (*((char *)v27 - 1) < 0) {
          operator delete(*(v27 - 3));
        }
        v27 -= 3;
      }
      while (v27 != __p);
      uint64_t v28 = __p;
    }
    operator delete(v28);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (v25)
  {
    if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  _Unwind_Resume(exception_object);
}

void ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_8(int a1, BBUFeedback **this, __CFDictionary **a3)
{
}

void ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_9(int a1, BBUFeedback **this, __CFDictionary **a3)
{
}

void ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_10(capabilities::updater *a1, uint64_t a2, CFMutableDictionaryRef *a3)
{
  if (a3)
  {
    unint64_t v4 = *(BBUICE16UpdateSource **)(a2 + 56);
    int BasebandMigrationDataType = capabilities::updater::getBasebandMigrationDataType(a1);
    if (BasebandMigrationDataType == 1)
    {
      *a3 = BBUICE16UpdateSource::copyBasebandMigrationData(v4, v6);
    }
    else if (BasebandMigrationDataType)
    {
      *a3 = 0;
    }
    else
    {
      *a3 = BBUEUR10UpdateSource::copyBasebandMigrationData(v4, v6);
    }
    return;
  }
  pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  size_t v7 = qword_26AA89AB0;
  if (!qword_26AA89AB0)
  {
    uint64_t v8 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
    block[0] = 0;
    ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v8, "BBUError", QOS_CLASS_UTILITY, block);
    if (block[0]) {
      dispatch_release(block[0]);
    }
    v8->__on_zero_shared_weauint64_t k = 0;
    v8[1].~__shared_weak_count = 0;
    v8[1].~__shared_weak_count_0 = 0;
    std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&v16, v8);
    long long v9 = v16;
    long long v16 = 0uLL;
    long long v10 = (std::__shared_weak_count *)off_26AA89AB8;
    *(_OWORD *)&qword_26AA89AB0 = v9;
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    char v11 = (std::__shared_weak_count *)*((void *)&v16 + 1);
    if (*((void *)&v16 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v16 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    size_t v7 = qword_26AA89AB0;
  }
  size_t v12 = (std::__shared_weak_count *)off_26AA89AB8;
  if (off_26AA89AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  char v15 = 15;
  strcpy((char *)__p, "Null output ptr");
  *(void *)&long long v16 = MEMORY[0x263EF8330];
  *((void *)&v16 + 1) = 0x40000000;
  uint64_t v17 = ___ZN8BBUError8addErrorERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE9BBUReturn_block_invoke;
  unint64_t v18 = &__block_descriptor_tmp_8;
  uint64_t v19 = v7;
  uint64_t v20 = __p;
  int v21 = 2;
  uint64_t v22 = &v16;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_13_0;
  block[4] = v7;
  block[5] = &v22;
  isa = v7[2].isa;
  if (!v7[3].isa)
  {
    dispatch_sync(isa, block);
    if ((v15 & 0x80000000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  dispatch_async_and_wait(isa, block);
  if (v15 < 0) {
LABEL_19:
  }
    operator delete(__p[0]);
LABEL_20:
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_21DEADC30(_Unwind_Exception *a1)
{
  unint64_t v4 = *(NSObject **)(v2 - 64);
  if (v4) {
    dispatch_release(v4);
  }
  operator delete(v1);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

void ___ZN19BBUpdaterController16sCmdInfoTableGetEv_block_invoke_11(uint64_t a1, uint64_t a2, const __CFDictionary **a3)
{
  if (a3)
  {
    *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
    ctu::cf::dict_adapter::dict_adapter((ctu::cf::dict_adapter *)&v25, *a3);
    unint64_t v4 = (BBUFeedback *)(*(uint64_t (**)(long long *, __CFString *))v25)(&v25, @"MigrationData");
    unint64_t v5 = v4;
    if (v4)
    {
      CFTypeID v6 = CFGetTypeID(v4);
      if (v6 == CFDictionaryGetTypeID()) {
        size_t v7 = v5;
      }
      else {
        size_t v7 = 0;
      }
      CFRelease(v5);
    }
    else
    {
      size_t v7 = 0;
    }
    BBUFeedback::handleComment(*(BBUFeedback **)(a2 + 56), "%s: restoring migration data", "cmdRestoreBasebandMigrationData");
    char v15 = *(BBUICE16UpdateSource **)(a2 + 56);
    int BasebandMigrationDataType = capabilities::updater::getBasebandMigrationDataType(v16);
    if (BasebandMigrationDataType)
    {
      if (BasebandMigrationDataType != 1)
      {
        if (BasebandMigrationDataType == 2)
        {
          uint64_t v19 = *(BBUFeedback **)(a2 + 56);
LABEL_31:
          uint64_t v22 = "succeeded";
LABEL_34:
          BBUFeedback::handleComment(v19, "restoring baseband migration data %s", v22);
          MEMORY[0x223C1D170](&v25);
          return;
        }
        uint64_t v19 = *(BBUFeedback **)(a2 + 56);
LABEL_33:
        uint64_t v22 = "failed";
        goto LABEL_34;
      }
      int v20 = BBUICE16UpdateSource::restoreBasebandMigrationData(v15, v7, v18);
    }
    else
    {
      int v20 = BBUEUR10UpdateSource::restoreBasebandMigrationData(v15, v7, v18);
    }
    int v21 = v20;
    uint64_t v19 = *(BBUFeedback **)(a2 + 56);
    if (v21) {
      goto LABEL_31;
    }
    goto LABEL_33;
  }
  pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  uint64_t v8 = qword_26AA89AB0;
  if (!qword_26AA89AB0)
  {
    long long v9 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
    block[0] = 0;
    ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v9, "BBUError", QOS_CLASS_UTILITY, block);
    if (block[0]) {
      dispatch_release(block[0]);
    }
    v9->__on_zero_shared_weauint64_t k = 0;
    v9[1].~__shared_weak_count = 0;
    v9[1].~__shared_weak_count_0 = 0;
    std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&v25, v9);
    long long v10 = v25;
    long long v25 = 0uLL;
    char v11 = (std::__shared_weak_count *)off_26AA89AB8;
    *(_OWORD *)&qword_26AA89AB0 = v10;
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    size_t v12 = (std::__shared_weak_count *)*((void *)&v25 + 1);
    if (*((void *)&v25 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v25 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    uint64_t v8 = qword_26AA89AB0;
  }
  char v13 = (std::__shared_weak_count *)off_26AA89AB8;
  if (off_26AA89AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  char v24 = 15;
  strcpy((char *)__p, "Null output ptr");
  *(void *)&long long v25 = MEMORY[0x263EF8330];
  *((void *)&v25 + 1) = 0x40000000;
  int v26 = ___ZN8BBUError8addErrorERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE9BBUReturn_block_invoke;
  uint64_t v27 = &__block_descriptor_tmp_8;
  uint64_t v28 = v8;
  uint64_t v29 = __p;
  int v30 = 2;
  char v31 = &v25;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  block[3] = &__block_descriptor_tmp_13_0;
  block[4] = v8;
  block[5] = &v31;
  isa = v8[2].isa;
  if (v8[3].isa)
  {
    dispatch_async_and_wait(isa, block);
    if ((v24 & 0x80000000) == 0) {
      goto LABEL_21;
    }
LABEL_36:
    operator delete(__p[0]);
    if (!v13) {
      return;
    }
    goto LABEL_37;
  }
  dispatch_sync(isa, block);
  if (v24 < 0) {
    goto LABEL_36;
  }
LABEL_21:
  if (!v13) {
    return;
  }
LABEL_37:
  if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

void sub_21DEAE044(_Unwind_Exception *a1)
{
  unint64_t v4 = *(NSObject **)(v2 - 80);
  if (v4) {
    dispatch_release(v4);
  }
  operator delete(v1);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t BBUpdaterExtremePrivate::getOwner(BBUpdaterExtremePrivate *this)
{
  return *((void *)this + 1);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x263F8C208], MEMORY[0x263F8C090]);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  unint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    unint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  std::string::size_type v4 = strlen(__s);

  return std::string::__assign_external(this, __s, v4);
}

void *boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::~state_machine(void *a1)
{
  *a1 = &unk_26CEC9610;
  boost::fusion::vector_detail::vector_data<std::integer_sequence<unsigned long,0ul,1ul,2ul,3ul,4ul,5ul,6ul,7ul,8ul,9ul>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit>::~vector_data(a1 + 13);
  uint64_t v2 = (void **)(a1 + 5);
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 5);
  uint64_t v3 = (void **)a1[6];
  std::string::size_type v4 = (void **)a1[7];
  if (v3 != v4)
  {
    do
    {
      unint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[6];
    uint64_t v6 = a1[7];
    if (v6 != v7) {
      a1[7] = v6 + ((v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*v2) {
    operator delete(*v2);
  }
  return a1;
}

void boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::~state_machine(void **a1)
{
  *a1 = &unk_26CEC9610;
  boost::fusion::vector_detail::vector_data<std::integer_sequence<unsigned long,0ul,1ul,2ul,3ul,4ul,5ul,6ul,7ul,8ul,9ul>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit>::~vector_data(a1 + 13);
  uint64_t v2 = a1 + 5;
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 5);
  uint64_t v3 = (void **)a1[6];
  std::string::size_type v4 = (void **)a1[7];
  if (v3 != v4)
  {
    do
    {
      unint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[6];
    uint64_t v6 = a1[7];
    if (v6 != v7) {
      a1[7] = &v6[(v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
  }
  if (*v2) {
    operator delete(*v2);
  }

  operator delete(a1);
}

const char *BBUpdaterControllerFSM::ControllerFSM_TOP::getDebugName(BBUpdaterControllerFSM::ControllerFSM_TOP *this)
{
  return "ControllerFSM_TOP";
}

void BBUpdaterControllerFSM::ControllerFSM_TOP::getStateNames(void *a1@<X8>)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  strcpy(v3, "\tstateBooting");
  strcpy((char *)v2, "stateInit");
  char v4 = 12;
  HIBYTE(v5[2]) = 18;
  strcpy((char *)v5, "stateManifestCheck");
  HIBYTE(v6[2]) = 16;
  strcpy((char *)v6, "statePersonalize");
  char v8 = 11;
  strcpy((char *)v7, "stateFusing");
  char v10 = 14;
  strcpy((char *)v9, "stateProvision");
  char v12 = 13;
  strcpy((char *)v11, "stateFinalize");
  HIBYTE(v13[2]) = 16;
  strcpy((char *)v13, "stateRegularMode");
  char v15 = 13;
  strcpy((char *)v14, "stateCoredump");
  char v17 = 14;
  strcpy((char *)__p, "stateDebugMode");
  std::vector<std::string>::vector[abi:ne180100](a1, (uint64_t)v2, 0xAuLL);
  if (v17 < 0)
  {
    operator delete(__p[0]);
    if ((v15 & 0x80000000) == 0)
    {
LABEL_3:
      if ((SHIBYTE(v13[2]) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }
  else if ((v15 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v14[0]);
  if ((SHIBYTE(v13[2]) & 0x80000000) == 0)
  {
LABEL_4:
    if ((v12 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }
LABEL_14:
  operator delete(v13[0]);
  if ((v12 & 0x80000000) == 0)
  {
LABEL_5:
    if ((v10 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_16;
  }
LABEL_15:
  operator delete(v11[0]);
  if ((v10 & 0x80000000) == 0)
  {
LABEL_6:
    if ((v8 & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_17;
  }
LABEL_16:
  operator delete(v9[0]);
  if ((v8 & 0x80000000) == 0)
  {
LABEL_7:
    if ((SHIBYTE(v6[2]) & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_18;
  }
LABEL_17:
  operator delete(v7[0]);
  if ((SHIBYTE(v6[2]) & 0x80000000) == 0)
  {
LABEL_8:
    if ((SHIBYTE(v5[2]) & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_19;
  }
LABEL_18:
  operator delete(v6[0]);
  if ((SHIBYTE(v5[2]) & 0x80000000) == 0)
  {
LABEL_9:
    if ((v4 & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_20;
  }
LABEL_19:
  operator delete(v5[0]);
  if ((v4 & 0x80000000) == 0)
  {
LABEL_10:
    if ((v3[0] & 0x80000000) == 0) {
      return;
    }
LABEL_21:
    operator delete(v2[0]);
    return;
  }
LABEL_20:
  operator delete(*(void **)&v3[1]);
  if (v3[0] < 0) {
    goto LABEL_21;
  }
}

void sub_21DEAE5D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a69 < 0)
  {
    operator delete(__p);
    if ((a63 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a57 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }
  else if ((a63 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a58);
  if ((a57 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a51 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }
LABEL_14:
  operator delete(a52);
  if ((a51 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a45 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_16;
  }
LABEL_15:
  operator delete(a46);
  if ((a45 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a39 & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_17;
  }
LABEL_16:
  operator delete(a40);
  if ((a39 & 0x80000000) == 0)
  {
LABEL_7:
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_18;
  }
LABEL_17:
  operator delete(a34);
  if ((a33 & 0x80000000) == 0)
  {
LABEL_8:
    if ((a27 & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_19;
  }
LABEL_18:
  operator delete(a28);
  if ((a27 & 0x80000000) == 0)
  {
LABEL_9:
    if ((a21 & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_20;
  }
LABEL_19:
  operator delete(a22);
  if ((a21 & 0x80000000) == 0)
  {
LABEL_10:
    if ((a15 & 0x80000000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_21;
  }
LABEL_20:
  operator delete(a16);
  if ((a15 & 0x80000000) == 0) {
LABEL_11:
  }
    _Unwind_Resume(a1);
LABEL_21:
  operator delete(a10);
  _Unwind_Resume(a1);
}

void *boost::fusion::vector_detail::store<6ul,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~store(void *a1)
{
  *a1 = &unk_26CEC9838;
  uint64_t v2 = (void **)(a1 + 4);
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 4);
  uint64_t v3 = (void **)a1[5];
  char v4 = (void **)a1[6];
  if (v3 != v4)
  {
    do
    {
      unint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[5];
    uint64_t v6 = a1[6];
    if (v6 != v7) {
      a1[6] = v6 + ((v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*v2) {
    operator delete(*v2);
  }
  return a1;
}

void *boost::fusion::vector_detail::store<4ul,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~store(void *a1)
{
  *a1 = &unk_26CEC9768;
  uint64_t v2 = (void **)(a1 + 4);
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 4);
  uint64_t v3 = (void **)a1[5];
  char v4 = (void **)a1[6];
  if (v3 != v4)
  {
    do
    {
      unint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[5];
    uint64_t v6 = a1[6];
    if (v6 != v7) {
      a1[6] = v6 + ((v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*v2) {
    operator delete(*v2);
  }
  return a1;
}

void *boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::~state_machine(void *a1)
{
  *a1 = &unk_26CEC9768;
  uint64_t v2 = (void **)(a1 + 4);
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 4);
  uint64_t v3 = (void **)a1[5];
  char v4 = (void **)a1[6];
  if (v3 != v4)
  {
    do
    {
      unint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[5];
    uint64_t v6 = a1[6];
    if (v6 != v7) {
      a1[6] = v6 + ((v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*v2) {
    operator delete(*v2);
  }
  return a1;
}

void boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::~state_machine(void **a1)
{
  *a1 = &unk_26CEC9768;
  uint64_t v2 = a1 + 4;
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 4);
  uint64_t v3 = (void **)a1[5];
  char v4 = (void **)a1[6];
  if (v3 != v4)
  {
    do
    {
      unint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[5];
    uint64_t v6 = a1[6];
    if (v6 != v7) {
      a1[6] = &v6[(v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
  }
  if (*v2) {
    operator delete(*v2);
  }

  operator delete(a1);
}

const char *BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::getDebugName(BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_ *this)
{
  return "Provision_";
}

void BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::getStateNames(void *a1@<X8>)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  HIBYTE(v2[2]) = 19;
  strcpy((char *)v2, "stateProvisionStart");
  char v4 = 20;
  strcpy(__p, "stateProvisionFinish");
  std::vector<std::string>::vector[abi:ne180100](a1, (uint64_t)v2, 2uLL);
  if ((v4 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v2[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(v2[0]);
    return;
  }
  operator delete(*(void **)__p);
  if (SHIBYTE(v2[2]) < 0) {
    goto LABEL_5;
  }
}

void sub_21DEAEA50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
  {
    operator delete(__p);
    if ((a14 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a14 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a9);
  _Unwind_Resume(exception_object);
}

void std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  if (v3 == v2)
  {
    a1[5] = 0;
    unint64_t v12 = 0;
  }
  else
  {
    unint64_t v4 = a1[4];
    uint64_t v5 = &v2[v4 >> 7];
    uint64_t v6 = (char *)*v5;
    uint64_t v7 = (char *)*v5 + 32 * (v4 & 0x7F);
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((a1[5] + v4) >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * ((a1[5] + v4) & 0x7F);
    if (v7 != (char *)v8)
    {
      do
      {
        uint64_t v9 = *(void *)v7;
        if (*(void *)v7)
        {
          if ((v9 & 1) == 0)
          {
            char v10 = *(void (**)(char *, char *, uint64_t))(v9 & 0xFFFFFFFFFFFFFFFELL);
            if (v10) {
              v10(v7 + 8, v7 + 8, 2);
            }
          }
          *(void *)uint64_t v7 = 0;
          uint64_t v6 = (char *)*v5;
        }
        v7 += 32;
        if (v7 - v6 == 4096)
        {
          char v11 = (char *)v5[1];
          ++v5;
          uint64_t v6 = v11;
          uint64_t v7 = v11;
        }
      }
      while (v7 != (char *)v8);
      uint64_t v2 = (void **)a1[1];
      uint64_t v3 = (void **)a1[2];
    }
    a1[5] = 0;
    unint64_t v12 = (char *)v3 - (char *)v2;
    if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
    {
      do
      {
        operator delete(*v2);
        uint64_t v13 = a1[2];
        uint64_t v2 = (void **)(a1[1] + 8);
        a1[1] = v2;
        unint64_t v12 = v13 - (void)v2;
      }
      while (v12 > 0x10);
    }
  }
  if (v12 >> 3 == 1)
  {
    uint64_t v14 = 64;
  }
  else
  {
    if (v12 >> 3 != 2) {
      return;
    }
    uint64_t v14 = 128;
  }
  a1[4] = v14;
}

uint64_t *boost::function<boost::msm::back::HandledEnum ()(void)>::~function(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

void *std::vector<std::string>::vector[abi:ne180100](void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    if (a3 >= 0xAAAAAAAAAAAAAABLL) {
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = 24 * a3;
    uint64_t v6 = (char *)operator new(24 * a3);
    uint64_t v7 = 0;
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[v5];
    do
    {
      uint64_t v9 = (std::string *)&v6[v7];
      char v10 = (long long *)(a2 + v7);
      if (*(char *)(a2 + v7 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v10, *((void *)v10 + 1));
      }
      else
      {
        long long v8 = *v10;
        v9->__r_.__value_.__r.__words[2] = *((void *)v10 + 2);
        *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v8;
      }
      v7 += 24;
    }
    while (v5 != v7);
    a1[1] = &v6[v7];
  }
  return a1;
}

void sub_21DEAED0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_21DEAED20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  for (; v11; v11 -= 24)
  {
    if (*(char *)(v10 + v11 - 1) < 0) {
      operator delete(*(void **)(v10 + v11 - 24));
    }
  }
  *(void *)(v9 + 8) = v10;
  std::__exception_guard_exceptions<std::vector<std::string>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void ***std::__exception_guard_exceptions<std::vector<std::string>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](void ***result)
{
  uint64_t v1 = result;
  if (!*((unsigned char *)result + 8))
  {
    uint64_t v2 = *result;
    uint64_t v3 = (void **)**result;
    if (v3)
    {
      unint64_t v4 = (void **)v2[1];
      uint64_t v5 = **result;
      if (v4 != v3)
      {
        do
        {
          if (*((char *)v4 - 1) < 0) {
            operator delete(*(v4 - 3));
          }
          v4 -= 3;
        }
        while (v4 != v3);
        uint64_t v5 = **v1;
      }
      v2[1] = v3;
      operator delete(v5);
      return v1;
    }
  }
  return result;
}

void std::vector<std::string>::__throw_length_error[abi:ne180100]()
{
}

void *boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::~state_machine(void *a1)
{
  *a1 = &unk_26CEC9838;
  uint64_t v2 = (void **)(a1 + 4);
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 4);
  uint64_t v3 = (void **)a1[5];
  unint64_t v4 = (void **)a1[6];
  if (v3 != v4)
  {
    do
    {
      uint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[5];
    uint64_t v6 = a1[6];
    if (v6 != v7) {
      a1[6] = v6 + ((v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*v2) {
    operator delete(*v2);
  }
  return a1;
}

void boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::~state_machine(void **a1)
{
  *a1 = &unk_26CEC9838;
  uint64_t v2 = a1 + 4;
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 4);
  uint64_t v3 = (void **)a1[5];
  unint64_t v4 = (void **)a1[6];
  if (v3 != v4)
  {
    do
    {
      uint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[5];
    uint64_t v6 = a1[6];
    if (v6 != v7) {
      a1[6] = &v6[(v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8];
    }
  }
  if (*v2) {
    operator delete(*v2);
  }

  operator delete(a1);
}

const char *BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::getDebugName(BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_ *this)
{
  return "Personalize_";
}

void BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::getStateNames(void *a1@<X8>)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  HIBYTE(v2[2]) = 21;
  strcpy((char *)v2, "statePersonalizeFirst");
  strcpy((char *)v3, "statePersonalizeSecond");
  HIBYTE(v3[2]) = 22;
  strcpy((char *)v4, "statePersonalizeBooted");
  HIBYTE(v4[2]) = 22;
  char v6 = 21;
  strcpy(__p, "statePersonalizeEUICC");
  std::vector<std::string>::vector[abi:ne180100](a1, (uint64_t)v2, 4uLL);
  if (v6 < 0)
  {
    operator delete(*(void **)__p);
    if ((SHIBYTE(v4[2]) & 0x80000000) == 0)
    {
LABEL_3:
      if ((SHIBYTE(v3[2]) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((SHIBYTE(v4[2]) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v4[0]);
  if ((SHIBYTE(v3[2]) & 0x80000000) == 0)
  {
LABEL_4:
    if ((SHIBYTE(v2[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_9:
    operator delete(v2[0]);
    return;
  }
LABEL_8:
  operator delete(v3[0]);
  if (SHIBYTE(v2[2]) < 0) {
    goto LABEL_9;
  }
}

void sub_21DEAF0B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
  {
    operator delete(__p);
    if ((a26 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a20 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((a26 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a21);
  if ((a20 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a14 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_9;
  }
LABEL_8:
  operator delete(a15);
  if ((a14 & 0x80000000) == 0) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_9:
  operator delete(a9);
  _Unwind_Resume(exception_object);
}

void *boost::fusion::vector_detail::vector_data<std::integer_sequence<unsigned long,0ul,1ul,2ul,3ul,4ul,5ul,6ul,7ul,8ul,9ul>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit>::~vector_data(void *a1)
{
  a1[22] = &unk_26CEC9838;
  uint64_t v2 = (void **)(a1 + 26);
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 26);
  uint64_t v3 = (void **)a1[27];
  unint64_t v4 = (void **)a1[28];
  if (v3 != v4)
  {
    do
    {
      uint64_t v5 = *v3++;
      operator delete(v5);
    }
    while (v3 != v4);
    uint64_t v7 = a1[27];
    uint64_t v6 = a1[28];
    if (v6 != v7) {
      a1[28] = v6 + ((v7 - v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*v2) {
    operator delete(*v2);
  }
  a1[5] = &unk_26CEC9768;
  long long v8 = (void **)(a1 + 9);
  std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::clear(a1 + 9);
  uint64_t v9 = (void **)a1[10];
  uint64_t v10 = (void **)a1[11];
  if (v9 != v10)
  {
    do
    {
      uint64_t v11 = *v9++;
      operator delete(v11);
    }
    while (v9 != v10);
    uint64_t v13 = a1[10];
    uint64_t v12 = a1[11];
    if (v12 != v13) {
      a1[11] = v12 + ((v13 - v12 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*v8) {
    operator delete(*v8);
  }
  return a1;
}

void std::__shared_ptr_pointer<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_> *,std::shared_ptr<void>::__shared_ptr_default_delete<void,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>,std::allocator<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_> *,std::shared_ptr<void>::__shared_ptr_default_delete<void,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>,std::allocator<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_> *,std::shared_ptr<void>::__shared_ptr_default_delete<void,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>,std::allocator<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFA96ABLL) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFA96ABLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFA96ABLL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFA96ABLL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 == result) {
    return result;
  }
  while (1)
  {
    uint64_t v2 = a2[2];
    if (*(unsigned char *)(v2 + 24)) {
      return result;
    }
    uint64_t v3 = *(uint64_t **)(v2 + 16);
    uint64_t v4 = *v3;
    if (*v3 != v2) {
      break;
    }
    uint64_t v7 = v3[1];
    if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (unsigned char *)(v7 + 24), v8))
    {
      if (*(uint64_t **)v2 == a2)
      {
        *(unsigned char *)(v2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v11 = *(void *)(v2 + 8);
        *uint64_t v3 = v11;
        if (v11) {
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t v9 = *(uint64_t **)(v2 + 8);
        uint64_t v10 = *v9;
        *(void *)(v2 + 8) = *v9;
        if (v10)
        {
          *(void *)(v10 + 16) = v2;
          uint64_t v3 = *(uint64_t **)(v2 + 16);
        }
        v9[2] = (uint64_t)v3;
        *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = v9;
        *uint64_t v9 = v2;
        *(void *)(v2 + 16) = v9;
        uint64_t v3 = (uint64_t *)v9[2];
        uint64_t v2 = *v3;
        *((unsigned char *)v9 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v11 = *(void *)(v2 + 8);
        *uint64_t v3 = v11;
        if (v11) {
LABEL_15:
        }
          *(void *)(v11 + 16) = v3;
      }
      *(void *)(v2 + 16) = v3[2];
      *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
      *(void *)(v2 + 8) = v3;
      v3[2] = v2;
      return result;
    }
LABEL_3:
    *(unsigned char *)(v2 + 24) = 1;
    a2 = v3;
    *((unsigned char *)v3 + 24) = v3 == result;
    unsigned char *v5 = 1;
    if (v3 == result) {
      return result;
    }
  }
  if (v4)
  {
    int v6 = *(unsigned __int8 *)(v4 + 24);
    uint64_t v5 = (unsigned char *)(v4 + 24);
    if (!v6) {
      goto LABEL_3;
    }
  }
  if (*(uint64_t **)v2 == a2)
  {
    uint64_t v12 = a2[1];
    *(void *)uint64_t v2 = v12;
    if (v12)
    {
      *(void *)(v12 + 16) = v2;
      uint64_t v3 = *(uint64_t **)(v2 + 16);
    }
    a2[2] = (uint64_t)v3;
    *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = a2;
    a2[1] = v2;
    *(void *)(v2 + 16) = a2;
    uint64_t v3 = (uint64_t *)a2[2];
  }
  else
  {
    a2 = (uint64_t *)a2[2];
  }
  *((unsigned char *)a2 + 24) = 1;
  *((unsigned char *)v3 + 24) = 0;
  uint64_t v13 = (uint64_t *)v3[1];
  uint64_t v14 = *v13;
  v3[1] = *v13;
  if (v14) {
    *(void *)(v14 + 16) = v3;
  }
  v13[2] = v3[2];
  *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v13;
  *uint64_t v13 = (uint64_t)v3;
  v3[2] = (uint64_t)v13;
  return result;
}

void std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::destroy(*a1);
    std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::destroy(a1[1]);
    uint64_t v2 = (const void *)a1[6];
    if (v2) {
      _Block_release(v2);
    }
    operator delete(a1);
  }
}

uint64_t ctu::PthreadMutexGuardPolicy<BBUPartitionManager>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

std::__shared_weak_count_vtbl **BBUError::create_default_global@<X0>(std::__shared_weak_count_vtbl **a1@<X8>)
{
  uint64_t v3 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
  dispatch_object_t object = 0;
  ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v3, "BBUError", QOS_CLASS_UTILITY, &object);
  if (object) {
    dispatch_release(object);
  }
  v3->__on_zero_shared_weauint64_t k = 0;
  v3[1].~__shared_weak_count = 0;
  v3[1].~__shared_weak_count_0 = 0;

  return std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>(a1, v3);
}

void sub_21DEAF67C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete(v10);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<BBUError>::operator=[abi:ne180100](uint64_t result, long long *a2)
{
  uint64_t v2 = result;
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(result + 8);
  *(_OWORD *)uint64_t result = v3;
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
      return v2;
    }
  }
  return result;
}

std::__shared_weak_count_vtbl **std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>(std::__shared_weak_count_vtbl **a1, std::__shared_weak_count_vtbl *a2)
{
  *a1 = a2;
  uint64_t v4 = (std::__shared_weak_count *)operator new(0x20uLL);
  v4->__shared_owners_ = 0;
  p_shared_owners = &v4->__shared_owners_;
  v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CEC9D68;
  v4->__shared_weak_owners_ = 0;
  v4[1].__vftable = a2;
  a1[1] = (std::__shared_weak_count_vtbl *)v4;
  if (!a2) {
    return a1;
  }
  int v6 = (std::__shared_weak_count *)a2->~__shared_weak_count_0;
  if (v6)
  {
    if (v6->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      a2->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))a2;
      a2->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v4;
      std::__shared_weak_count::__release_weak(v6);
      if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_8;
      }
    }
    return a1;
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v4->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  a2->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))a2;
  a2->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v4;
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
LABEL_8:
  ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
  std::__shared_weak_count::__release_weak(v4);
  return a1;
}

void sub_21DEAF83C(void *a1)
{
  __cxa_begin_catch(a1);
  dispatch_barrier_async_f(v1[2], v1, (dispatch_function_t)std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1}::operator() const(BBUError*)::{lambda(void *)#1}::__invoke);
  __cxa_rethrow();
}

void sub_21DEAF864(_Unwind_Exception *a1)
{
}

void std::__shared_ptr_pointer<BBUError *,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError *)#1},std::allocator<BBUError>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<BBUError *,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError *)#1},std::allocator<BBUError>>::__on_zero_shared(uint64_t a1)
{
}

uint64_t std::__shared_ptr_pointer<BBUError *,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError *)#1},std::allocator<BBUError>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN3ctu20SharedSynchronizableI8BBUErrorE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_") {
    return a1 + 24;
  }
  if (((v3 & (unint64_t)"ZN3ctu20SharedSynchronizableI8BBUErrorE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_" & 0x8000000000000000) != 0) == __OFSUB__(v3, "ZN3ctu20SharedSynchronizableI8BBUErrorE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_"))return 0; {
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN3ctu20SharedSynchronizableI8BBUErrorE15make_shared_ptrIS1_EENSt3__110shared_ptrIT_EEPS6_EUlPS1_E_" & 0x7FFFFFFFFFFFFFFFLL)))return a1 + 24;
  }
  return 0;
}

void std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1}::operator() const(BBUError*)::{lambda(void *)#1}::__invoke(BBUError *a1)
{
  if (a1)
  {
    BBUError::~BBUError(a1);
    operator delete(v1);
  }
}

void BBUError::~BBUError(BBUError *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 5);
    uint64_t v4 = (void *)*((void *)this + 4);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 9) < 0) {
          operator delete(*(void **)(v3 - 32));
        }
        v3 -= 32;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v2;
    operator delete(v4);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    dispatch_release(v5);
  }
  int v6 = *((void *)this + 2);
  if (v6) {
    dispatch_release(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t ctu::PthreadMutexGuardPolicy<BBUError>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

void boost::core::demangle(boost::core *this, const char *lpmangled)
{
  int status = 0;
  size_t v12 = 0;
  uint64_t v4 = __cxa_demangle(lpmangled, 0, &v12, &status);
  uint64_t v5 = v4;
  if (v4) {
    int v6 = v4;
  }
  else {
    int v6 = lpmangled;
  }
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = v7;
  if (v7 >= 0x17)
  {
    uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v9 = v7 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v11 = (boost::core *)operator new(v9 + 1);
    *((void *)this + 1) = v8;
    *((void *)this + 2) = v10 | 0x8000000000000000;
    *(void *)this = v11;
    this = v11;
  }
  else
  {
    *((unsigned char *)this + 23) = v7;
    if (!v7) {
      goto LABEL_12;
    }
  }
  memmove(this, v6, v8);
LABEL_12:
  *((unsigned char *)this + v8) = 0;
  free(v5);
}

void sub_21DEAFBC4(_Unwind_Exception *a1)
{
  free(v1);
  _Unwind_Resume(a1);
}

void *std::string::__assign_no_alias<true>(void *__dst, void *__src, size_t __len)
{
  if (__len > 0x16)
  {
    if (__len - 0x7FFFFFFFFFFFFFF7 <= 0x800000000000001ELL) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v7 = 44;
    if (__len > 0x2C) {
      size_t v7 = __len;
    }
    size_t v8 = (v7 | 7) + 1;
    int v6 = operator new(v8);
    memcpy(v6, __src, __len);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *std::string __dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    int v6 = __dst;
    if (__len)
    {
      memmove(__dst, __src, __len);
      int v6 = __dst;
    }
  }
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void **std::string::__assign_no_alias<false>(void **a1, void *__src, size_t __len)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v7 = v6 & 0x7FFFFFFFFFFFFFFFLL;
  if ((v6 & 0x7FFFFFFFFFFFFFFFLL) > __len)
  {
    size_t v8 = *a1;
    a1[1] = (void *)__len;
    if (__len) {
      memmove(v8, __src, __len);
    }
    goto LABEL_12;
  }
  size_t v9 = 0x7FFFFFFFFFFFFFF7;
  if (0x7FFFFFFFFFFFFFF7 - v7 < __len - v7 + 1) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  unint64_t v10 = v7 - 1;
  uint64_t v11 = a1;
  if ((v6 & 0x8000000000000000) == 0)
  {
    if (v10 > 0x3FFFFFFFFFFFFFF2) {
      goto LABEL_7;
    }
LABEL_14:
    unint64_t v13 = 2 * v10;
    if (__len > 2 * v10) {
      unint64_t v13 = __len;
    }
    uint64_t v14 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v14 = v13 | 7;
    }
    if (v13 >= 0x17) {
      size_t v9 = v14 + 1;
    }
    else {
      size_t v9 = 23;
    }
    size_t v8 = operator new(v9);
    if (!__len) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v11 = *a1;
  if (v10 <= 0x3FFFFFFFFFFFFFF2) {
    goto LABEL_14;
  }
LABEL_7:
  size_t v8 = operator new(0x7FFFFFFFFFFFFFF7uLL);
  if (__len) {
LABEL_8:
  }
    memcpy(v8, __src, __len);
LABEL_9:
  if (v10 != 22) {
    operator delete(v11);
  }
  a1[1] = (void *)__len;
  a1[2] = (void *)(v9 | 0x8000000000000000);
  *a1 = v8;
LABEL_12:
  *((unsigned char *)v8 + __len) = 0;
  return a1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventError>(uint64_t a1, uint64_t a2, char a3)
{
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::is_event_handling_blocked_helper<BBUpdaterControllerFSM::eventError>(a1)) {
    return 1;
  }
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventError,BBUpdaterControllerFSM::eventError>(a1, a2))return 1; {
  int v8 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EA70 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
  }
  uint64_t v6 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EA70 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v8;
  if (!*(unsigned char *)(a1 + 101) || (a3) && !v6)
  {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError>(a1, a1, *(_DWORD *)(a1 + 32));
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError>(a1, a1, *(_DWORD *)(a1 + 36));
  }
  *(unsigned char *)(a1 + 100) = 0;
  if ((a3 & 6) != 0) {
    return v6;
  }
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::is_event_handling_blocked_helper<BBUpdaterControllerFSM::eventError>(uint64_t a1)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v2 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v3 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  BOOL result = 1;
  if ((v2 & 1) == 0 && (v3 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v5 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v6 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v5 & 1) == 0 && !v6) {
      return 0;
    }
    qword_26AA8E658 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E650 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E648 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E640 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E638 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E630 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E628 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E620 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E618 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    qword_26AA8E610[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false;
    char v7 = ((uint64_t (*)(uint64_t))qword_26AA8E610[*(int *)(a1 + 32)])(a1);
    int v8 = ((uint64_t (*)(uint64_t))qword_26AA8E610[*(int *)(a1 + 36)])(a1);
    return (v7 & 1) == 0 && !v8;
  }
  return result;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventError,BBUpdaterControllerFSM::eventError>(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 100);
  if (*(unsigned char *)(a1 + 100))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      std::string::size_type v5 = *(void *)(a2 + 24);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_4:
        std::string v34 = v20;
        v35.__r_.__value_.__r.__words[0] = v5;
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_5;
        }
        goto LABEL_12;
      }
    }
    else
    {
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *(_OWORD *)a2;
      std::string::size_type v5 = *(void *)(a2 + 24);
      v20.__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }
    std::string::__init_copy_ctor_external(&v34, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v21;
    v35.__r_.__value_.__r.__words[0] = v21;
    if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_5:
      std::string v38 = v34;
      v39.__r_.__value_.__r.__words[0] = v5;
      if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_13;
    }
LABEL_12:
    std::string::__init_copy_ctor_external(&v38, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v35.__r_.__value_.__r.__words[0];
    v39.__r_.__value_.__r.__words[0] = v35.__r_.__value_.__r.__words[0];
    if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_6:
      std::string v42 = v38;
      v43.__r_.__value_.__r.__words[0] = v5;
      *(void *)uint64_t v46 = a1;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
LABEL_13:
    std::string::__init_copy_ctor_external(&v42, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v39.__r_.__value_.__r.__words[0];
    v43.__r_.__value_.__r.__words[0] = v39.__r_.__value_.__r.__words[0];
    *(void *)uint64_t v46 = a1;
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_7:
      *(_OWORD *)&v46[8] = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[0] = v42.__r_.__value_.__r.__words[2];
      v47.__r_.__value_.__l.__size_ = v5;
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
LABEL_14:
    std::string::__init_copy_ctor_external((std::string *)&v46[8], v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
    v47.__r_.__value_.__l.__size_ = v43.__r_.__value_.__r.__words[0];
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v42.__r_.__value_.__l.__data_);
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_17:
        *(void *)&long long v22 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventError>;
        *((void *)&v22 + 1) = 0;
        std::string::size_type v23 = *(void *)v46;
        if (v47.__r_.__value_.__s.__data_[7] < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&__p, *(const std::string::value_type **)&v46[8], *(std::string::size_type *)&v46[16]);
          *((void *)&v25 + 1) = v47.__r_.__value_.__l.__size_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if (v47.__r_.__value_.__s.__data_[7] < 0)
          {
            operator delete(*(void **)&v46[8]);
            if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_23:
              long long v29 = v22;
              std::string::size_type v6 = v23;
              std::string::size_type v30 = v23;
              if (SBYTE7(v25) < 0)
              {
                std::string::__init_copy_ctor_external(&v31, (const std::string::value_type *)__p, *((std::string::size_type *)&__p + 1));
                std::string::size_type v6 = v30;
              }
              else
              {
                *(_OWORD *)&v31.__r_.__value_.__l.__data_ = __p;
                v31.__r_.__value_.__r.__words[2] = v25;
              }
              std::string::size_type v7 = *((void *)&v25 + 1);
              std::string::size_type v32 = *((void *)&v25 + 1);
              std::string::value_type v8 = v26;
              std::string::value_type v33 = v26;
              unint64_t v27 = 0;
              *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v29;
              v34.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v35, v31.__r_.__value_.__l.__data_, v31.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v32;
                std::string::value_type v8 = v33;
                std::string::size_type v6 = v34.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v35 = v31;
              }
              std::string::size_type v36 = v7;
              std::string::value_type v37 = v8;
              *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)&v34.__r_.__value_.__l.__data_;
              v38.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v39, v35.__r_.__value_.__l.__data_, v35.__r_.__value_.__l.__size_);
                std::string::size_type v6 = v38.__r_.__value_.__r.__words[2];
                std::string::size_type v7 = v36;
                std::string::value_type v8 = v37;
              }
              else
              {
                std::string v39 = v35;
              }
              std::string::size_type v40 = v7;
              std::string::value_type v41 = v8;
              *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)&v38.__r_.__value_.__l.__data_;
              v42.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v43, v39.__r_.__value_.__l.__data_, v39.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v40;
                std::string::value_type v8 = v41;
                std::string::size_type v6 = v42.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v43 = v39;
              }
              std::string::size_type v44 = v7;
              std::string::value_type v45 = v8;
              *(_OWORD *)uint64_t v46 = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
              *(void *)&v46[16] = v6;
              if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v47, v43.__r_.__value_.__l.__data_, v43.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v44;
                std::string::value_type v8 = v45;
              }
              else
              {
                std::string v47 = v43;
              }
              std::string::size_type v48 = v7;
              std::string::value_type v49 = v8;
              size_t v9 = (std::string *)operator new(0x40uLL);
              *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)v46;
              v9->__r_.__value_.__r.__words[2] = *(void *)&v46[16];
              unint64_t v10 = v9 + 1;
              if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(v10, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
                std::string::value_type v11 = v49;
                int v12 = SHIBYTE(v47.__r_.__value_.__r.__words[2]);
                v9[2].__r_.__value_.__r.__words[0] = v48;
                v9[2].__r_.__value_.__s.__data_[8] = v11;
                v28[0] = (uint64_t)v9;
                if (v12 < 0)
                {
                  operator delete(v47.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_65;
                  }
                }
                else if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
                  goto LABEL_65;
                }
              }
              else
              {
                *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
                v9[1].__r_.__value_.__r.__words[2] = v47.__r_.__value_.__r.__words[2];
                v9[2].__r_.__value_.__r.__words[0] = v7;
                v9[2].__r_.__value_.__s.__data_[8] = v8;
                v28[0] = (uint64_t)v9;
                if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
LABEL_65:
                  operator delete(v43.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
                  {
LABEL_66:
                    operator delete(v39.__r_.__value_.__l.__data_);
                    unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventError>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventError>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
                    {
LABEL_67:
                      operator delete(v35.__r_.__value_.__l.__data_);
                      if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_46;
                      }
                      goto LABEL_68;
                    }
LABEL_45:
                    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_46;
                    }
LABEL_68:
                    operator delete(v31.__r_.__value_.__l.__data_);
LABEL_46:
                    uint64_t v13 = *(void *)(a1 + 56);
                    uint64_t v14 = *(void *)(a1 + 48);
                    uint64_t v15 = 16 * (v13 - v14) - 1;
                    if (v13 == v14) {
                      uint64_t v15 = 0;
                    }
                    unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
                    if (v15 == v16)
                    {
                      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
                      uint64_t v14 = *(void *)(a1 + 48);
                      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
                    }
                    char v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
                    *char v17 = 0;
                    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v27);
                    ++*(void *)(a1 + 80);
                    if (v27)
                    {
                      if ((v27 & 1) == 0)
                      {
                        uint64_t v18 = *(void (**)(uint64_t *, _WORD *, int))(v27 & 0xFFFFFFFFFFFFFFFELL);
                        if (v18) {
                          v18(v28, v28, 2);
                        }
                      }
                      unint64_t v27 = 0;
                    }
                    if (SBYTE7(v25) < 0)
                    {
                      operator delete((void *)__p);
                      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        return v3 == 0;
                      }
                    }
                    else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
                      return v3 == 0;
                    }
                    operator delete(v20.__r_.__value_.__l.__data_);
                    return v3 == 0;
                  }
LABEL_44:
                  unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventError>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventError>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_67;
                  }
                  goto LABEL_45;
                }
              }
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_66;
              }
              goto LABEL_44;
            }
          }
          else if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_23;
          }
        }
        else
        {
          long long __p = *(_OWORD *)&v46[8];
          long long v25 = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_23;
          }
        }
        operator delete(v34.__r_.__value_.__l.__data_);
        goto LABEL_23;
      }
    }
    else
    {
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
    }
LABEL_16:
    operator delete(v38.__r_.__value_.__l.__data_);
    goto LABEL_17;
  }
  *(unsigned char *)(a1 + 100) = 1;
  return v3 == 0;
}

void sub_21DEB0788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  operator delete(v61);
  if (*(char *)(v62 - 81) < 0)
  {
    operator delete(*(void **)(v62 - 104));
    if ((*(char *)(v62 - 145) & 0x80000000) == 0)
    {
LABEL_3:
      if ((a61 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((*(char *)(v62 - 145) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v62 - 168));
  if ((a61 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a50 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  operator delete(__p);
  if ((a50 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a39 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a45);
  if ((a39 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a24 & 0x80000000) == 0)
    {
LABEL_14:
      if (a14 < 0) {
        operator delete(a9);
      }
      _Unwind_Resume(a1);
    }
LABEL_13:
    operator delete(a19);
    goto LABEL_14;
  }
LABEL_12:
  operator delete(a34);
  if ((a24 & 0x80000000) == 0) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true()
{
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventError>>::flag_false()
{
  return 0;
}

void std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    a1[4] = v4;
    std::string::size_type v6 = (void *)a1[1];
    std::string::size_type v5 = (char *)a1[2];
    std::string::size_type v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    a1[1] = v6 + 1;
    if (v5 != (char *)a1[3])
    {
LABEL_94:
      *(void *)std::string::size_type v5 = v8;
      goto LABEL_95;
    }
    size_t v9 = (char *)*a1;
    if ((unint64_t)v7 > *a1)
    {
      uint64_t v10 = (uint64_t)&v7[-*a1] >> 3;
      if (v10 >= -1) {
        uint64_t v11 = v10 + 1;
      }
      else {
        uint64_t v11 = v10 + 2;
      }
      uint64_t v12 = v11 >> 1;
      uint64_t v13 = -v12;
      uint64_t v14 = &v7[-8 * v12];
      int64_t v15 = v5 - v7;
      if (v5 != v7)
      {
        memmove(&v7[-8 * v12], v7, v5 - v7);
        std::string::size_type v7 = (char *)a1[1];
      }
      std::string::size_type v5 = &v14[v15];
      unint64_t v16 = &v7[8 * v13];
      goto LABEL_11;
    }
    unint64_t v35 = (v5 - v9) >> 2;
    if (v5 == v9) {
      unint64_t v35 = 1;
    }
    if (v35 >> 61) {
      goto LABEL_111;
    }
    unint64_t v36 = v35 >> 2;
    uint64_t v37 = 8 * v35;
    std::string v38 = (char *)operator new(8 * v35);
    std::string v39 = &v38[8 * v36];
    int64_t v41 = v5 - v7;
    BOOL v40 = v5 == v7;
    std::string::size_type v5 = v39;
    if (!v40)
    {
      std::string::size_type v5 = &v39[v41 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v42 = v41 - 8;
      if ((unint64_t)(v41 - 8) >= 0x38)
      {
        unint64_t v92 = &v38[8 * v36];
        std::string v43 = v92;
        if ((unint64_t)(v92 - v7) >= 0x20)
        {
          uint64_t v93 = (v42 >> 3) + 1;
          uint64_t v94 = 8 * (v93 & 0x3FFFFFFFFFFFFFFCLL);
          std::string v43 = &v39[v94];
          v7 += v94;
          uint64_t v95 = (long long *)(v6 + 3);
          uint64_t v96 = v92 + 16;
          uint64_t v97 = v93 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v98 = *v95;
            *(v96 - 1) = *(v95 - 1);
            *uint64_t v96 = v98;
            v95 += 2;
            v96 += 2;
            v97 -= 4;
          }
          while (v97);
          if (v93 == (v93 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_91;
          }
        }
      }
      else
      {
        std::string v43 = &v38[8 * v36];
      }
      do
      {
        uint64_t v99 = *(void *)v7;
        v7 += 8;
        *(void *)std::string v43 = v99;
        v43 += 8;
      }
      while (v43 != v5);
    }
LABEL_91:
    *a1 = v38;
    a1[1] = v39;
    a1[2] = v5;
    a1[3] = &v38[v37];
    if (!v9) {
      goto LABEL_94;
    }
    int v100 = v9;
LABEL_93:
    operator delete(v100);
    std::string::size_type v5 = (char *)a1[2];
    goto LABEL_94;
  }
  uint64_t v18 = (char *)a1[2];
  char v17 = (char *)a1[3];
  std::string v20 = (char *)*a1;
  uint64_t v19 = (char *)a1[1];
  uint64_t v21 = v18 - v19;
  uint64_t v22 = (v18 - v19) >> 3;
  uint64_t v23 = (uint64_t)&v17[-*a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    char v24 = operator new(0x1000uLL);
    long long v25 = v24;
    if (v17 != v18)
    {
      *(void *)uint64_t v18 = v24;
LABEL_95:
      a1[2] += 8;
      return;
    }
    if (v19 == v20)
    {
      unint64_t v69 = (v17 - v19) >> 2;
      if (v18 == v19) {
        unint64_t v69 = 1;
      }
      if (v69 >> 61) {
        goto LABEL_111;
      }
      unint64_t v70 = (v69 + 3) >> 2;
      uint64_t v71 = 8 * v69;
      uint64_t v72 = (char *)operator new(8 * v69);
      std::string::size_type v44 = &v72[8 * v70];
      uint64_t v73 = v44;
      if (v18 != v19)
      {
        uint64_t v73 = &v44[8 * v22];
        char v74 = &v72[8 * v70];
        char v75 = v19;
        if ((unint64_t)(v21 - 8) < 0x38) {
          goto LABEL_115;
        }
        uint64_t v76 = &v72[8 * v70];
        char v74 = v76;
        char v75 = v19;
        if ((unint64_t)(v76 - v19) < 0x20) {
          goto LABEL_115;
        }
        unint64_t v77 = ((unint64_t)(v21 - 8) >> 3) + 1;
        uint64_t v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
        char v74 = &v44[v78];
        char v75 = &v19[v78];
        uint64_t v79 = (long long *)(v19 + 16);
        char v80 = v76 + 16;
        uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v82 = *v79;
          *(v80 - 1) = *(v79 - 1);
          *char v80 = v82;
          v79 += 2;
          v80 += 2;
          v81 -= 4;
        }
        while (v81);
        if (v77 != (v77 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_115:
          do
          {
            uint64_t v83 = *(void *)v75;
            v75 += 8;
            *(void *)char v74 = v83;
            v74 += 8;
          }
          while (v74 != v73);
        }
      }
      *a1 = v72;
      a1[1] = v44;
      a1[2] = v73;
      a1[3] = &v72[v71];
      if (v19)
      {
        operator delete(v19);
        std::string::size_type v44 = (char *)a1[1];
      }
    }
    else
    {
      std::string::size_type v44 = v19;
    }
    *((void *)v44 - 1) = v25;
    std::string v84 = (char *)a1[1];
    std::string::size_type v5 = (char *)a1[2];
    a1[1] = v84 - 8;
    uint64_t v8 = *((void *)v84 - 1);
    a1[1] = v84;
    if (v5 != (char *)a1[3]) {
      goto LABEL_94;
    }
    std::string v85 = (char *)*a1;
    if ((unint64_t)v84 > *a1)
    {
      uint64_t v86 = (uint64_t)&v84[-*a1] >> 3;
      if (v86 >= -1) {
        uint64_t v87 = v86 + 1;
      }
      else {
        uint64_t v87 = v86 + 2;
      }
      uint64_t v88 = v87 >> 1;
      uint64_t v89 = -v88;
      size_t v90 = &v84[-8 * v88];
      int64_t v91 = v5 - v84;
      if (v5 != v84)
      {
        memmove(&v84[-8 * v88], v84, v5 - v84);
        std::string v84 = (char *)a1[1];
      }
      std::string::size_type v5 = &v90[v91];
      unint64_t v16 = &v84[8 * v89];
LABEL_11:
      a1[1] = v16;
      a1[2] = v5;
      goto LABEL_94;
    }
    unint64_t v101 = (v5 - v85) >> 2;
    if (v5 == v85) {
      unint64_t v101 = 1;
    }
    if (!(v101 >> 61))
    {
      unint64_t v102 = v101 >> 2;
      uint64_t v103 = 8 * v101;
      uint64_t v104 = (char *)operator new(8 * v101);
      std::string::size_type v105 = &v104[8 * v102];
      int64_t v106 = v5 - v84;
      BOOL v40 = v5 == v84;
      std::string::size_type v5 = v105;
      if (!v40)
      {
        std::string::size_type v5 = &v105[v106 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v107 = v106 - 8;
        if ((unint64_t)(v106 - 8) >= 0x38)
        {
          unsigned int v109 = &v104[8 * v102];
          std::string v108 = v109;
          if ((unint64_t)(v109 - v84) >= 0x20)
          {
            uint64_t v110 = (v107 >> 3) + 1;
            uint64_t v111 = 8 * (v110 & 0x3FFFFFFFFFFFFFFCLL);
            std::string v108 = &v105[v111];
            v112 = &v84[v111];
            unsigned int v113 = (long long *)(v84 + 16);
            unsigned int v114 = v109 + 16;
            uint64_t v115 = v110 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v116 = *v113;
              *(v114 - 1) = *(v113 - 1);
              *unsigned int v114 = v116;
              v113 += 2;
              v114 += 2;
              v115 -= 4;
            }
            while (v115);
            std::string v84 = v112;
            if (v110 == (v110 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_108;
            }
          }
        }
        else
        {
          std::string v108 = &v104[8 * v102];
        }
        do
        {
          uint64_t v117 = *(void *)v84;
          v84 += 8;
          *(void *)std::string v108 = v117;
          v108 += 8;
        }
        while (v108 != v5);
      }
LABEL_108:
      *a1 = v104;
      a1[1] = v105;
      a1[2] = v5;
      a1[3] = &v104[v103];
      if (!v85) {
        goto LABEL_94;
      }
      int v100 = v85;
      goto LABEL_93;
    }
LABEL_111:
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v26 = v23 >> 2;
  if (v17 == v20) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = v26;
  }
  if (v27 >> 61) {
    goto LABEL_111;
  }
  uint64_t v28 = (char *)operator new(8 * v27);
  long long v29 = operator new(0x1000uLL);
  std::string::size_type v30 = &v28[8 * v22];
  std::string v31 = &v28[8 * v27];
  if (v22 == v27)
  {
    std::string::value_type v33 = v29;
    if (v21 < 1)
    {
      if (v18 == v19) {
        unint64_t v45 = 1;
      }
      else {
        unint64_t v45 = v21 >> 2;
      }
      if (v45 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      std::string::size_type v30 = (char *)operator new(8 * v45);
      std::string v31 = &v30[8 * v45];
      operator delete(v28);
      uint64_t v46 = (char *)a1[1];
      uint64_t v18 = (char *)a1[2];
      uint64_t v28 = v30;
      *(void *)std::string::size_type v30 = v33;
      std::string::size_type v32 = v30 + 8;
      if (v18 == v46) {
        goto LABEL_40;
      }
    }
    else
    {
      unint64_t v34 = v22 + 2;
      if (v22 >= -1) {
        unint64_t v34 = v22 + 1;
      }
      v30 -= 8 * (v34 >> 1);
      *(void *)std::string::size_type v30 = v29;
      std::string::size_type v32 = v30 + 8;
      if (v18 == v19) {
        goto LABEL_40;
      }
    }
    goto LABEL_46;
  }
  *(void *)std::string::size_type v30 = v29;
  std::string::size_type v32 = v30 + 8;
  if (v18 != v19)
  {
    do
    {
LABEL_46:
      if (v30 == v28)
      {
        if (v32 >= v31)
        {
          if (v31 == v28) {
            unint64_t v53 = 1;
          }
          else {
            unint64_t v53 = (v31 - v28) >> 2;
          }
          if (v53 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v54 = (char *)operator new(8 * v53);
          uint64_t v55 = v54;
          unint64_t v56 = (v53 + 3) >> 2;
          std::string::size_type v30 = &v54[8 * v56];
          int64_t v57 = v32 - v28;
          BOOL v40 = v32 == v28;
          std::string::size_type v32 = v30;
          if (!v40)
          {
            std::string::size_type v32 = &v30[v57 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v58 = v57 - 8;
            char v59 = &v54[8 * v56];
            long long v60 = v28;
            if (v58 < 0x38) {
              goto LABEL_116;
            }
            uint64_t v61 = 8 * v56;
            char v59 = &v54[8 * v56];
            long long v60 = v28;
            if ((unint64_t)(v59 - v28) < 0x20) {
              goto LABEL_116;
            }
            uint64_t v62 = (v58 >> 3) + 1;
            uint64_t v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
            char v59 = &v30[v63];
            long long v60 = &v28[v63];
            uint64_t v64 = (long long *)(v28 + 16);
            uint64_t v65 = &v54[v61 + 16];
            uint64_t v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v67 = *v64;
              *((_OWORD *)v65 - 1) = *(v64 - 1);
              *(_OWORD *)uint64_t v65 = v67;
              v64 += 2;
              v65 += 32;
              v66 -= 4;
            }
            while (v66);
            if (v62 != (v62 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_116:
              do
              {
                uint64_t v68 = *(void *)v60;
                v60 += 8;
                *(void *)char v59 = v68;
                v59 += 8;
              }
              while (v59 != v32);
            }
          }
          std::string v31 = &v54[8 * v53];
          operator delete(v28);
          uint64_t v28 = v55;
        }
        else
        {
          uint64_t v49 = (v31 - v32) >> 3;
          if (v49 >= -1) {
            uint64_t v50 = v49 + 1;
          }
          else {
            uint64_t v50 = v49 + 2;
          }
          uint64_t v51 = v50 >> 1;
          std::string::size_type v30 = &v28[8 * (v50 >> 1)];
          uint64_t v52 = v28;
          if (v32 != v28)
          {
            memmove(v30, v28, v32 - v28);
            uint64_t v52 = v32;
          }
          std::string::size_type v32 = (char *)v52 + 8 * v51;
        }
      }
      uint64_t v48 = *((void *)v18 - 1);
      v18 -= 8;
      *((void *)v30 - 1) = v48;
      v30 -= 8;
    }
    while (v18 != (char *)a1[1]);
  }
LABEL_40:
  std::string v47 = (char *)*a1;
  *a1 = v28;
  a1[1] = v30;
  a1[2] = v32;
  a1[3] = v31;
  if (v47)
  {
    operator delete(v47);
  }
}

void sub_21DEB107C(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::function0<boost::msm::back::HandledEnum>::move_assign(uint64_t result, uint64_t *a2)
{
  if (a2 != (uint64_t *)result)
  {
    unint64_t v2 = a2;
    BOOL v3 = (uint64_t *)result;
    uint64_t v4 = *a2;
    if (*a2)
    {
      *(void *)BOOL result = v4;
      if (v4)
      {
        long long v7 = *(_OWORD *)(a2 + 1);
        *(void *)(result + 24) = a2[3];
        *(_OWORD *)(result + 8) = v7;
      }
      else
      {
        BOOL result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, result + 8, 1);
      }
    }
    else
    {
      uint64_t v5 = *(void *)result;
      if (!*(void *)result) {
        return result;
      }
      if ((v5 & 1) == 0)
      {
        std::string::size_type v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL);
        if (v6) {
          BOOL result = v6(result + 8, result + 8, 2);
        }
      }
      unint64_t v2 = v3;
    }
    *unint64_t v2 = 0;
  }
  return result;
}

void sub_21DEB114C(void *a1)
{
  __cxa_begin_catch(a1);
  *uint64_t v1 = 0;
  __cxa_rethrow();
}

void sub_21DEB115C(_Unwind_Exception *a1)
{
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventError>,boost::_bi::value<unsigned char>>>>::manage(uint64_t *a1, _WORD *a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      std::string::size_type v6 = (std::string *)operator new(0x40uLL);
      *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)v5;
      v6->__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
      long long v7 = v6 + 1;
      if (*(char *)(v5 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(v5 + 24), *(void *)(v5 + 32));
      }
      else
      {
        long long v8 = *(_OWORD *)(v5 + 24);
        v6[1].__r_.__value_.__r.__words[2] = *(void *)(v5 + 40);
        *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
      }
      v6[2].__r_.__value_.__r.__words[0] = *(void *)(v5 + 48);
      v6[2].__r_.__value_.__s.__data_[8] = *(unsigned char *)(v5 + 56);
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      uint64_t v9 = *(void *)a2;
      if (*(void *)a2)
      {
        if (*(char *)(v9 + 47) < 0) {
          operator delete(*(void **)(v9 + 24));
        }
        operator delete((void *)v9);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      uint64_t v10 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v10 == (const char *)(0x800000021DFA9777 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v10, (const char *)(0x800000021DFA9777 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
}

void sub_21DEB12F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventError>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[56];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventError>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  long long v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  uint64_t v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFA9750 & 0x7FFFFFFFFFFFFFFFLL));
  uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFA9750 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unint64_t v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    uint64_t v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    uint64_t v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      int64_t v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unint64_t v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(unsigned int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEB19FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  v13[0] = 0xAAAAAAAAAAAAAAAALL;
  v13[1] = 0xAAAAAAAAAAAAAAAALL;
  MEMORY[0x223C1DB90](v13, a1);
  if (LOBYTE(v13[0]))
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&v14, MEMORY[0x263F8C108]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x223C1DBA0](v13);
  return a1;
}

void sub_21DEB1C58(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x223C1DBA0](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x21DEB1C38);
}

void sub_21DEB1CAC(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      size_t v12 = 0;
    }
    else {
      size_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if ((uint64_t)v12 >= 1)
    {
      memset(__b, 170, sizeof(__b));
      if (v12 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v12 >= 0x17)
      {
        uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v12 | 7) != 0x17) {
          uint64_t v14 = v12 | 7;
        }
        uint64_t v15 = v14 + 1;
        uint64_t v13 = (void **)operator new(v14 + 1);
        __b[1] = (void *)v12;
        __b[2] = (void *)(v15 | 0x8000000000000000);
        __b[0] = v13;
      }
      else
      {
        HIBYTE(__b[2]) = v12;
        uint64_t v13 = __b;
      }
      memset(v13, __c, v12);
      *((unsigned char *)v13 + v12) = 0;
      if (SHIBYTE(__b[2]) >= 0) {
        uint64_t v16 = __b;
      }
      else {
        uint64_t v16 = (void **)__b[0];
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t, void **, size_t))(*(void *)v6 + 96))(v6, v16, v12);
      uint64_t v18 = v17;
      if (SHIBYTE(__b[2]) < 0)
      {
        operator delete(__b[0]);
        if (v18 != v12) {
          return 0;
        }
      }
      else if (v17 != v12)
      {
        return 0;
      }
    }
    uint64_t v19 = a4 - a3;
    if (v19 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v19) == v19)
    {
      *(void *)(a5 + 24) = 0;
      return v6;
    }
    return 0;
  }
  return v6;
}

void sub_21DEB1EA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(uint64_t result)
{
  if (*(void *)(result + 80))
  {
    uint64_t v1 = result;
    while (1)
    {
      *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v18[0] + 1) = 0xAAAAAAAAAAAAAAAALL;
      v18[1] = v2;
      uint64_t v3 = *(void *)(v1 + 48);
      unint64_t v4 = *(void *)(v1 + 72);
      unint64_t v5 = v4 >> 7;
      uint64_t v6 = v4 & 0x7F;
      uint64_t v7 = *(void *)(v3 + 8 * (v4 >> 7)) + 32 * v6;
      *(void *)&v18[0] = 0;
      uint64_t v8 = *(void *)v7;
      if (!*(void *)v7) {
        goto LABEL_7;
      }
      *(void *)&v18[0] = *(void *)v7;
      if ((v8 & 1) == 0) {
        break;
      }
      long long v14 = *(_OWORD *)(v7 + 8);
      *((void *)&v18[1] + 1) = *(void *)(v7 + 24);
      *(_OWORD *)((char *)v18 + 8) = v14;
      int v9 = (uint64_t *)(*(void *)(v3 + 8 * v5) + 32 * v6);
      uint64_t v10 = *v9;
      if (*v9)
      {
LABEL_16:
        if ((v10 & 1) == 0)
        {
          uint64_t v15 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v10 & 0xFFFFFFFFFFFFFFFELL);
          if (v15)
          {
            v15(v9 + 1, v9 + 1, 2);
            unint64_t v4 = *(void *)(v1 + 72);
          }
        }
        *int v9 = 0;
        uint64_t v16 = *(void *)(v1 + 80) - 1;
        unint64_t v17 = v4 + 1;
        *(void *)(v1 + 72) = v17;
        *(void *)(v1 + 80) = v16;
        if (v17 < 0x100) {
          goto LABEL_10;
        }
LABEL_9:
        operator delete(**(void ***)(v1 + 48));
        *(void *)(v1 + 48) += 8;
        *(void *)(v1 + 72) -= 128;
        goto LABEL_10;
      }
LABEL_8:
      uint64_t v11 = *(void *)(v1 + 80) - 1;
      unint64_t v12 = v4 + 1;
      *(void *)(v1 + 72) = v12;
      *(void *)(v1 + 80) = v11;
      if (v12 >= 0x100) {
        goto LABEL_9;
      }
LABEL_10:
      if (!*(void *)&v18[0])
      {
        std::runtime_error::runtime_error(&v19, "call to empty boost::function");
        v19.__vftable = (std::runtime_error_vtbl *)&unk_26CEC9AA0;
        boost::throw_exception<boost::bad_function_call>(&v19);
      }
      BOOL result = (*(uint64_t (**)(char *))((*(void *)&v18[0] & 0xFFFFFFFFFFFFFFFELL) + 8))((char *)v18 + 8);
      if ((v18[0] & 1) == 0)
      {
        uint64_t v13 = *(uint64_t (**)(char *, char *, uint64_t))(*(void *)&v18[0] & 0xFFFFFFFFFFFFFFFELL);
        if (v13) {
          BOOL result = v13((char *)v18 + 8, (char *)v18 + 8, 2);
        }
      }
      if (!*(void *)(v1 + 80)) {
        return result;
      }
    }
    (*(void (**)(uint64_t, char *, void))(v8 & 0xFFFFFFFFFFFFFFFELL))(v7 + 8, (char *)v18 + 8, 0);
    uint64_t v3 = *(void *)(v1 + 48);
    unint64_t v4 = *(void *)(v1 + 72);
    unint64_t v5 = v4 >> 7;
    uint64_t v6 = v4 & 0x7F;
LABEL_7:
    int v9 = (uint64_t *)(*(void *)(v3 + 8 * v5) + 32 * v6);
    uint64_t v10 = *v9;
    if (*v9) {
      goto LABEL_16;
    }
    goto LABEL_8;
  }
  return result;
}

void sub_21DEB209C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::runtime_error a13)
{
}

void sub_21DEB20B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_21DEB20CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void boost::throw_exception<boost::bad_function_call>(const std::runtime_error *a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  uint64_t v3 = (void *)boost::wrapexcept<boost::bad_function_call>::wrapexcept((uint64_t)exception, a1);
}

uint64_t boost::wrapexcept<boost::bad_function_call>::wrapexcept(uint64_t a1, const std::runtime_error *a2)
{
  *(void *)a1 = &unk_26CEC9A70;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), a2);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = -1;
  *(void *)a1 = &unk_26CEC99F8;
  *(void *)(a1 + 8) = &unk_26CEC9A28;
  *(void *)(a1 + 24) = &unk_26CEC9A50;
  return a1;
}

uint64_t boost::wrapexcept<boost::bad_function_call>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_26CEC9AC8;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 32) = 0;
  }
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));
  return a1;
}

char *boost::wrapexcept<boost::bad_function_call>::clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_26CEC9A70;
  std::runtime_error::runtime_error((std::runtime_error *)(v2 + 8), (const std::runtime_error *)(a1 + 8));
  *((void *)v2 + 1) = &unk_26CEC9AA0;
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)v2 + 3) = &unk_26CEC9AC8;
  *((void *)v2 + 4) = v3;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  *((_DWORD *)v2 + 14) = *(_DWORD *)(a1 + 56);
  *(void *)uint64_t v2 = &unk_26CEC99F8;
  *((void *)v2 + 1) = &unk_26CEC9A28;
  *((void *)v2 + 3) = &unk_26CEC9A50;
  boost::exception_detail::copy_boost_exception((uint64_t)(v2 + 24), a1 + 24);
  return v2;
}

void sub_21DEB2390(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_21DEB23AC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::bad_function_call>::rethrow(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x40uLL);
  boost::wrapexcept<boost::bad_function_call>::wrapexcept((uint64_t)exception, a1);
}

void sub_21DEB2428(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::bad_function_call>::~wrapexcept(uint64_t a1)
{
  *(void *)(a1 + 24) = &unk_26CEC9AC8;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *(void *)(a1 + 32) = 0;
  }
  std::runtime_error::~runtime_error((std::runtime_error *)(a1 + 8));

  operator delete((void *)a1);
}

void non-virtual thunk to'boost::wrapexcept<boost::bad_function_call>::~wrapexcept(std::runtime_error *this)
{
  this[1].__vftable = (std::runtime_error_vtbl *)&unk_26CEC9AC8;
  imp = this[1].__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    this[1].__imp_.__imp_ = 0;
  }

  std::runtime_error::~runtime_error(this);
}

{
  const char *imp;
  uint64_t vars8;

  this[1].__vftable = (std::runtime_error_vtbl *)&unk_26CEC9AC8;
  imp = this[1].__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    this[1].__imp_.__imp_ = 0;
  }
  std::runtime_error::~runtime_error(this);

  operator delete(&this[-1].__imp_);
}

void non-virtual thunk to'boost::wrapexcept<boost::bad_function_call>::~wrapexcept(std::runtime_error *a1)
{
  a1->__vftable = (std::runtime_error_vtbl *)&unk_26CEC9AC8;
  imp = a1->__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    a1->__imp_.__imp_ = 0;
  }

  std::runtime_error::~runtime_error(a1 - 1);
}

{
  const char *imp;
  uint64_t vars8;

  a1->__vftable = (std::runtime_error_vtbl *)&unk_26CEC9AC8;
  imp = a1->__imp_.__imp_;
  if (imp && (*(unsigned int (**)(const char *))(*(void *)imp + 32))(imp)) {
    a1->__imp_.__imp_ = 0;
  }
  std::runtime_error::~runtime_error(a1 - 1);

  operator delete(&a1[-2].__imp_);
}

void boost::bad_function_call::~bad_function_call(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  operator delete(v1);
}

uint64_t *boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 32))(v2)) {
    *a1 = 0;
  }
  return a1;
}

uint64_t boost::wrapexcept<boost::bad_function_call>::wrapexcept(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26CEC9A70;
  std::runtime_error::runtime_error((std::runtime_error *)(a1 + 8), (const std::runtime_error *)(a2 + 8));
  *(void *)(a1 + 8) = &unk_26CEC9AA0;
  uint64_t v4 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = &unk_26CEC9AC8;
  *(void *)(a1 + 32) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v5;
  *(void *)a1 = &unk_26CEC99F8;
  *(void *)(a1 + 8) = &unk_26CEC9A28;
  *(void *)(a1 + 24) = &unk_26CEC9A50;
  return a1;
}

void sub_21DEB28C4(_Unwind_Exception *a1)
{
  std::runtime_error::~runtime_error(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::exception_detail::copy_boost_exception(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4)
  {
    uint64_t v5 = 0;
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
    uint64_t result = *(void *)(a1 + 8);
    if (!result) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 40))(&v7);
  uint64_t v5 = v7;
  uint64_t v8 = v7;
  if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 24))(v7);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
    }
  }
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
LABEL_8:
  }
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 32))(result);
LABEL_9:
  *(void *)(a1 + 8) = v5;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
    return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  return result;
}

void sub_21DEB2A58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void sub_21DEB2A78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_21DEB2A8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  boost::exception_detail::refcount_ptr<boost::exception_detail::error_info_container>::~refcount_ptr((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,BBUpdaterControllerFSM::eventError,BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,BBUpdaterControllerFSM::ControllerFSM_TOP::handleError,boost::msm::front::none>>::execute(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(v5 + 32) = 7;
  uint64_t v6 = (_DWORD *)(v5 + 32);
  uint64_t v7 = *(void *)(a1 + 16);
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    std::string __p = *(std::string *)a4;
  }
  BBUpdaterController::handleError(v7, &__p, *(_DWORD *)(a4 + 24));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  _DWORD *v6 = 9;
  return 1;
}

void sub_21DEB2B40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventSkipPersonalize>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E6A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E6A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E698 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E690 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E688 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E680 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E678 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E670 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E668 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      qword_26AA8E660[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E660[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E660[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      unint64_t v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *unint64_t v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventSkipPersonalize>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventSkipPersonalize>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventSkipPersonalize>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      unint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *unint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          uint64_t v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EAC8 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EAC8 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEB2F94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventSkipPersonalize>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventSkipPersonalize>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFA9912 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFA9912 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventSkipPersonalize>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)std::string __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  std::runtime_error v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFA98E1 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFA98E1 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unint64_t v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    uint64_t v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    uint64_t v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      int64_t v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unint64_t v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEB37F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::eventSkipPersonalize,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeBooted,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::skipPersonalize,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(v3 + 24) = 1;
  uint64_t v4 = (_DWORD *)(v3 + 24);
  char v5 = *(BBUFeedback ***)(a1 + 16);
  memset(&v61, 0, sizeof(v61));
  int v6 = v5[7];
  BBUFeedback::handleComment(v6, "entering %s", "StageContext::SkipPersonalize");
  uint64_t v7 = *((void *)v6 + 19);
  uint64_t v8 = *((void *)v6 + 18);
  if (v7 == v8) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = ((v7 - v8) << 7) - 1;
  }
  uint64_t v10 = *((void *)v6 + 22);
  unint64_t v11 = v10 + *((void *)v6 + 21);
  if (v9 == v11)
  {
    std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity((void *)v6 + 17);
    uint64_t v8 = *((void *)v6 + 18);
    uint64_t v10 = *((void *)v6 + 22);
    unint64_t v11 = *((void *)v6 + 21) + v10;
  }
  *(_DWORD *)(*(void *)(v8 + ((v11 >> 7) & 0x1FFFFFFFFFFFFF8)) + 4 * (v11 & 0x3FF)) = 6;
  *((void *)v6 + 22) = v10 + 1;
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource((BBUpdaterController *)v5, 1);
  long long v60 = FirmwareDataSource;
  if (FirmwareDataSource)
  {
    unsigned int v19 = BBUpdaterController::pushImagesInternal((uint64_t)v5, (uint64_t *)&v60, 1, &v61);
    if (!v19)
    {
      unsigned int v23 = BBUpdaterController::performPingInternal((uint64_t)v5, 0);
      if (!v23)
      {
        BBUpdaterController::performBootedStageInternal((uint64_t)v5, (uint64_t *)&v60);
        goto LABEL_10;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_34;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_34;
        }
      }
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v20, v21, v22, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
LABEL_34:
      uint64_t v30 = BBUReturnAsString::BBUReturnStrings[v23];
      size_t v31 = strlen(v30);
      if (v31 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      std::string::size_type v32 = v31;
      if (v31 >= 0x17)
      {
        uint64_t v47 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v31 | 7) != 0x17) {
          uint64_t v47 = v31 | 7;
        }
        uint64_t v48 = v47 + 1;
        long long v33 = operator new(v47 + 1);
        v56.__r_.__value_.__l.__size_ = v32;
        v56.__r_.__value_.__r.__words[2] = v48 | 0x8000000000000000;
        v56.__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
      }
      else
      {
        *((unsigned char *)&v56.__r_.__value_.__s + 23) = v31;
        long long v33 = &v56;
        if (!v31)
        {
LABEL_54:
          v33[v32] = 0;
          char v49 = std::string::insert(&v56, 0, "Failed to ping baseband: ", 0x19uLL);
          std::string v50 = (std::string::value_type *)v49->__r_.__value_.__r.__words[0];
          std::string::size_type size = v49->__r_.__value_.__l.__size_;
          LODWORD(v55.__r_.__value_.__l.__data_) = v49->__r_.__value_.__r.__words[2];
          *(_DWORD *)((char *)v55.__r_.__value_.__r.__words + 3) = *(_DWORD *)((char *)&v49->__r_.__value_.__r.__words[2]
                                                                             + 3);
          int v52 = SHIBYTE(v49->__r_.__value_.__r.__words[2]);
          v49->__r_.__value_.__l.__size_ = 0;
          v49->__r_.__value_.__r.__words[2] = 0;
          v49->__r_.__value_.__r.__words[0] = 0;
          unsigned int v53 = capabilities::updater::intermittentFailureRetryCount((capabilities::updater *)v49);
          if (v52 < 0)
          {
            std::string::__init_copy_ctor_external(&v58, v50, size);
          }
          else
          {
            v58.__r_.__value_.__r.__words[0] = (std::string::size_type)v50;
            v58.__r_.__value_.__l.__size_ = size;
            LODWORD(v58.__r_.__value_.__r.__words[2]) = v55.__r_.__value_.__l.__data_;
            *(_DWORD *)((char *)&v58.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v55.__r_.__value_.__r.__words
                                                                                   + 3);
            *((unsigned char *)&v58.__r_.__value_.__s + 23) = v52;
          }
          unint64_t v59 = __PAIR64__(v53, v23);
          BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>((uint64_t)v5, (uint64_t)&v58);
          if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v58.__r_.__value_.__l.__data_);
            if ((v52 & 0x80000000) == 0)
            {
LABEL_71:
              if ((SHIBYTE(v56.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_10;
              }
LABEL_75:
              operator delete(v56.__r_.__value_.__l.__data_);
              goto LABEL_10;
            }
          }
          else if ((v52 & 0x80000000) == 0)
          {
            goto LABEL_71;
          }
          operator delete(v50);
          if ((SHIBYTE(v56.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_10;
          }
          goto LABEL_75;
        }
      }
      memmove(v33, v30, v32);
      goto LABEL_54;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_26;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_26;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v16, v17, v18, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
LABEL_26:
    uint64_t v26 = BBUReturnAsString::BBUReturnStrings[v19];
    size_t v27 = strlen(v26);
    if (v27 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v28 = v27;
    if (v27 >= 0x17)
    {
      uint64_t v34 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v27 | 7) != 0x17) {
        uint64_t v34 = v27 | 7;
      }
      uint64_t v35 = v34 + 1;
      p_dst = (std::string *)operator new(v34 + 1);
      __dst.__r_.__value_.__l.__size_ = v28;
      __dst.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v27;
      p_dst = &__dst;
      if (!v27)
      {
LABEL_42:
        p_dst->__r_.__value_.__s.__data_[v28] = 0;
        size_t v36 = std::string::insert(&__dst, 0, "Failed to push images: ", 0x17uLL);
        long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
        v55.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v37;
        v36->__r_.__value_.__l.__size_ = 0;
        v36->__r_.__value_.__r.__words[2] = 0;
        v36->__r_.__value_.__r.__words[0] = 0;
        uint64_t v38 = std::string::append(&v55, ": ", 2uLL);
        long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
        v56.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v39;
        v38->__r_.__value_.__l.__size_ = 0;
        v38->__r_.__value_.__r.__words[2] = 0;
        v38->__r_.__value_.__r.__words[0] = 0;
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v40 = &v61;
        }
        else {
          uint64_t v40 = (std::string *)v61.__r_.__value_.__r.__words[0];
        }
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v41 = HIBYTE(v61.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v41 = v61.__r_.__value_.__l.__size_;
        }
        uint64_t v42 = std::string::append(&v56, (const std::string::value_type *)v40, v41);
        uint64_t v43 = (std::string::value_type *)v42->__r_.__value_.__r.__words[0];
        std::string::size_type v44 = v42->__r_.__value_.__l.__size_;
        v57[0] = v42->__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v57 + 3) = *(_DWORD *)((char *)&v42->__r_.__value_.__r.__words[2] + 3);
        int v45 = SHIBYTE(v42->__r_.__value_.__r.__words[2]);
        v42->__r_.__value_.__l.__size_ = 0;
        v42->__r_.__value_.__r.__words[2] = 0;
        v42->__r_.__value_.__r.__words[0] = 0;
        unsigned int v46 = capabilities::updater::intermittentFailureRetryCount((capabilities::updater *)v42);
        if (v45 < 0)
        {
          std::string::__init_copy_ctor_external(&v58, v43, v44);
        }
        else
        {
          v58.__r_.__value_.__r.__words[0] = (std::string::size_type)v43;
          v58.__r_.__value_.__l.__size_ = v44;
          LODWORD(v58.__r_.__value_.__r.__words[2]) = v57[0];
          *(_DWORD *)((char *)&v58.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v57 + 3);
          *((unsigned char *)&v58.__r_.__value_.__s + 23) = v45;
        }
        unint64_t v59 = __PAIR64__(v46, v19);
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>((uint64_t)v5, (uint64_t)&v58);
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v58.__r_.__value_.__l.__data_);
          if ((v45 & 0x80000000) == 0)
          {
LABEL_59:
            if ((SHIBYTE(v56.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_60;
            }
            goto LABEL_65;
          }
        }
        else if ((v45 & 0x80000000) == 0)
        {
          goto LABEL_59;
        }
        operator delete(v43);
        if ((SHIBYTE(v56.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_60:
          if ((SHIBYTE(v55.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_61;
          }
          goto LABEL_66;
        }
LABEL_65:
        operator delete(v56.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v55.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_61:
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_10;
          }
LABEL_67:
          operator delete(__dst.__r_.__value_.__l.__data_);
          goto LABEL_10;
        }
LABEL_66:
        operator delete(v55.__r_.__value_.__l.__data_);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_10;
        }
        goto LABEL_67;
      }
    }
    memmove(p_dst, v26, v28);
    goto LABEL_42;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_17;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_17:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v12, v13, v14, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  long long v25 = (char *)operator new(0x28uLL);
  strcpy(v25, "Fail to get update source for bootup\n");
  std::string::__init_copy_ctor_external(&v58, v25, 0x25uLL);
  unint64_t v59 = 35;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>((uint64_t)v5, (uint64_t)&v58);
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v58.__r_.__value_.__l.__data_);
  }
  operator delete(v25);
LABEL_10:
  BBUFeedback::exitStageContext(v5[7]);
  if (FirmwareDataSource) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  }
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v61.__r_.__value_.__l.__data_);
  }
  _DWORD *v4 = 1;
  ++*(_DWORD *)(a1 + 108);
  _DWORD *v4 = 2;
  return 1;
}

void sub_21DEB4030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (*(char *)(v37 - 81) < 0)
  {
    operator delete(*(void **)(v37 - 104));
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize>::execute(uint64_t a1, int a2)
{
  uint64_t v4 = a1 + 280;
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventSkipPersonalize,BBUpdaterControllerFSM::eventSkipPersonalize>(a1 + 280))
  {
    uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 304) + 33])(v4, 0);
    uint64_t v6 = v5;
    if (*(unsigned char *)(a1 + 369)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = v5 == 0;
    }
    if (v7) {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize>(v4, v4, *(_DWORD *)(a1 + 304));
    }
    *(unsigned char *)(a1 + 368) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v4);
  }
  else
  {
    uint64_t v6 = 1;
  }
  *(_DWORD *)(a1 + 4 * a2 + 32) = 3;
  return v6;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventSkipPersonalize>(uint64_t a1, uint64_t a2, char a3)
{
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventSkipPersonalize,BBUpdaterControllerFSM::eventSkipPersonalize>()) {
    return 1;
  }
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 24) + 33])(a1, 0);
  uint64_t v6 = v5;
  if (!*(unsigned char *)(a1 + 89) || (a3) && !v5) {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize>(a1, a1, *(_DWORD *)(a1 + 24));
  }
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  }
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventSkipPersonalize,BBUpdaterControllerFSM::eventSkipPersonalize>(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 88);
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = operator new(0x20uLL);
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = 16 * (v4 - v5) - 1;
    *uint64_t v3 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventSkipPersonalize>;
    v3[1] = 0;
    v3[2] = a1;
    *((unsigned char *)v3 + 25) = 5;
    unint64_t v11 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventSkipPersonalize>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventSkipPersonalize>,boost::_bi::value<unsigned char>>>)::stored_vtable;
    v12[0] = v3;
    if (v4 == v5) {
      uint64_t v6 = 0;
    }
    unint64_t v7 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
    if (v6 == v7)
    {
      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 32));
      uint64_t v5 = *(void *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
    }
    uint64_t v8 = (void *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
    *uint64_t v8 = 0;
    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v8, (uint64_t *)&v11);
    ++*(void *)(a1 + 72);
    if (v11 && (v11 & 1) == 0)
    {
      uint64_t v9 = *(void (**)(void *, void *, uint64_t))(v11 & 0xFFFFFFFFFFFFFFFELL);
      if (v9) {
        v9(v12, v12, 2);
      }
    }
    return v2 == 0;
  }
  else
  {
    *(unsigned char *)(a1 + 88) = 1;
    return v2 == 0;
  }
}

void sub_21DEB44B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventSkipPersonalize>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      uint64_t v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFA9A02 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFA9A02 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventSkipPersonalize>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)std::string __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  uint64_t v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  uint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFA98E1 & 0x7FFFFFFFFFFFFFFFLL));
  uint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFA98E1 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      unsigned int v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    unsigned int v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  unsigned int v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    std::string::size_type v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    uint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    uint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    uint64_t v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    uint64_t v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::size_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEB4CC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(uint64_t result)
{
  if (*(void *)(result + 72))
  {
    uint64_t v1 = result;
    while (1)
    {
      *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(void *)unsigned int v19 = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v19[8] = v2;
      uint64_t v3 = *(void *)(v1 + 40);
      unint64_t v4 = *(void *)(v1 + 64);
      unint64_t v5 = v4 >> 7;
      uint64_t v6 = v4 & 0x7F;
      uint64_t v7 = *(void *)(v3 + 8 * (v4 >> 7)) + 32 * v6;
      uint64_t v18 = 0;
      uint64_t v8 = *(void *)v7;
      if (!*(void *)v7) {
        goto LABEL_7;
      }
      uint64_t v18 = *(void *)v7;
      if ((v8 & 1) == 0) {
        break;
      }
      long long v14 = *(_OWORD *)(v7 + 8);
      *(void *)&v19[16] = *(void *)(v7 + 24);
      *(_OWORD *)unsigned int v19 = v14;
      uint64_t v9 = (uint64_t *)(*(void *)(v3 + 8 * v5) + 32 * v6);
      uint64_t v10 = *v9;
      if (*v9)
      {
LABEL_16:
        if ((v10 & 1) == 0)
        {
          int v15 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v10 & 0xFFFFFFFFFFFFFFFELL);
          if (v15)
          {
            v15(v9 + 1, v9 + 1, 2);
            unint64_t v4 = *(void *)(v1 + 64);
          }
        }
        *uint64_t v9 = 0;
        uint64_t v16 = *(void *)(v1 + 72) - 1;
        unint64_t v17 = v4 + 1;
        *(void *)(v1 + 64) = v17;
        *(void *)(v1 + 72) = v16;
        if (v17 < 0x100) {
          goto LABEL_10;
        }
LABEL_9:
        operator delete(**(void ***)(v1 + 40));
        *(void *)(v1 + 40) += 8;
        *(void *)(v1 + 64) -= 128;
        goto LABEL_10;
      }
LABEL_8:
      uint64_t v11 = *(void *)(v1 + 72) - 1;
      unint64_t v12 = v4 + 1;
      *(void *)(v1 + 64) = v12;
      *(void *)(v1 + 72) = v11;
      if (v12 >= 0x100) {
        goto LABEL_9;
      }
LABEL_10:
      if (!v18)
      {
        std::runtime_error::runtime_error(&v20, "call to empty boost::function");
        v20.__vftable = (std::runtime_error_vtbl *)&unk_26CEC9AA0;
        boost::throw_exception<boost::bad_function_call>(&v20);
      }
      uint64_t result = (*(uint64_t (**)(unsigned char *))((v18 & 0xFFFFFFFFFFFFFFFELL) + 8))(v19);
      if ((v18 & 1) == 0)
      {
        uint64_t v13 = *(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(v18 & 0xFFFFFFFFFFFFFFFELL);
        if (v13) {
          uint64_t result = v13(v19, v19, 2);
        }
      }
      if (!*(void *)(v1 + 72)) {
        return result;
      }
    }
    (*(void (**)(uint64_t, unsigned char *, void))(v8 & 0xFFFFFFFFFFFFFFFELL))(v7 + 8, v19, 0);
    uint64_t v3 = *(void *)(v1 + 40);
    unint64_t v4 = *(void *)(v1 + 64);
    unint64_t v5 = v4 >> 7;
    uint64_t v6 = v4 & 0x7F;
LABEL_7:
    uint64_t v9 = (uint64_t *)(*(void *)(v3 + 8 * v5) + 32 * v6);
    uint64_t v10 = *v9;
    if (*v9) {
      goto LABEL_16;
    }
    goto LABEL_8;
  }
  return result;
}

void sub_21DEB4FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::runtime_error a13)
{
}

void sub_21DEB4FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_21DEB4FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventRetry>(uint64_t a1, uint64_t a2, char a3)
{
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::is_event_handling_blocked_helper<BBUpdaterControllerFSM::eventRetry>(a1)) {
    return 1;
  }
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventRetry,BBUpdaterControllerFSM::eventRetry>(a1, a2))return 1; {
  int v8 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EB20 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
  }
  uint64_t v6 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EB20 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v8;
  if (!*(unsigned char *)(a1 + 101) || (a3) && !v6)
  {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>(a1, a1, *(_DWORD *)(a1 + 32));
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>(a1, a1, *(_DWORD *)(a1 + 36));
  }
  *(unsigned char *)(a1 + 100) = 0;
  if ((a3 & 6) != 0) {
    return v6;
  }
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::is_event_handling_blocked_helper<BBUpdaterControllerFSM::eventRetry>(uint64_t a1)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v2 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v3 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  BOOL result = 1;
  if ((v2 & 1) == 0 && (v3 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v5 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v6 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v5 & 1) == 0 && !v6) {
      return 0;
    }
    qword_26AA8E6F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6C0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    qword_26AA8E6B0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false;
    char v7 = ((uint64_t (*)(uint64_t))qword_26AA8E6B0[*(int *)(a1 + 32)])(a1);
    int v8 = ((uint64_t (*)(uint64_t))qword_26AA8E6B0[*(int *)(a1 + 36)])(a1);
    return (v7 & 1) == 0 && !v8;
  }
  return result;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventRetry,BBUpdaterControllerFSM::eventRetry>(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 100);
  if (*(unsigned char *)(a1 + 100))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      std::string::size_type v5 = *(void *)(a2 + 24);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_4:
        std::string v34 = v20;
        v35.__r_.__value_.__r.__words[0] = v5;
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_5;
        }
        goto LABEL_12;
      }
    }
    else
    {
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *(_OWORD *)a2;
      std::string::size_type v5 = *(void *)(a2 + 24);
      v20.__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }
    std::string::__init_copy_ctor_external(&v34, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v21;
    v35.__r_.__value_.__r.__words[0] = v21;
    if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_5:
      std::string v38 = v34;
      v39.__r_.__value_.__r.__words[0] = v5;
      if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_13;
    }
LABEL_12:
    std::string::__init_copy_ctor_external(&v38, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v35.__r_.__value_.__r.__words[0];
    v39.__r_.__value_.__r.__words[0] = v35.__r_.__value_.__r.__words[0];
    if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_6:
      std::string v42 = v38;
      v43.__r_.__value_.__r.__words[0] = v5;
      *(void *)uint64_t v46 = a1;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
LABEL_13:
    std::string::__init_copy_ctor_external(&v42, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v39.__r_.__value_.__r.__words[0];
    v43.__r_.__value_.__r.__words[0] = v39.__r_.__value_.__r.__words[0];
    *(void *)uint64_t v46 = a1;
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_7:
      *(_OWORD *)&v46[8] = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[0] = v42.__r_.__value_.__r.__words[2];
      v47.__r_.__value_.__l.__size_ = v5;
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
LABEL_14:
    std::string::__init_copy_ctor_external((std::string *)&v46[8], v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
    v47.__r_.__value_.__l.__size_ = v43.__r_.__value_.__r.__words[0];
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v42.__r_.__value_.__l.__data_);
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_17:
        *(void *)&long long v22 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventRetry>;
        *((void *)&v22 + 1) = 0;
        std::string::size_type v23 = *(void *)v46;
        if (v47.__r_.__value_.__s.__data_[7] < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&__p, *(const std::string::value_type **)&v46[8], *(std::string::size_type *)&v46[16]);
          *((void *)&v25 + 1) = v47.__r_.__value_.__l.__size_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if (v47.__r_.__value_.__s.__data_[7] < 0)
          {
            operator delete(*(void **)&v46[8]);
            if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_23:
              long long v29 = v22;
              std::string::size_type v6 = v23;
              std::string::size_type v30 = v23;
              if (SBYTE7(v25) < 0)
              {
                std::string::__init_copy_ctor_external(&v31, (const std::string::value_type *)__p, *((std::string::size_type *)&__p + 1));
                std::string::size_type v6 = v30;
              }
              else
              {
                *(_OWORD *)&v31.__r_.__value_.__l.__data_ = __p;
                v31.__r_.__value_.__r.__words[2] = v25;
              }
              std::string::size_type v7 = *((void *)&v25 + 1);
              std::string::size_type v32 = *((void *)&v25 + 1);
              std::string::value_type v8 = v26;
              std::string::value_type v33 = v26;
              unint64_t v27 = 0;
              *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v29;
              v34.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v35, v31.__r_.__value_.__l.__data_, v31.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v32;
                std::string::value_type v8 = v33;
                std::string::size_type v6 = v34.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v35 = v31;
              }
              std::string::size_type v36 = v7;
              std::string::value_type v37 = v8;
              *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)&v34.__r_.__value_.__l.__data_;
              v38.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v39, v35.__r_.__value_.__l.__data_, v35.__r_.__value_.__l.__size_);
                std::string::size_type v6 = v38.__r_.__value_.__r.__words[2];
                std::string::size_type v7 = v36;
                std::string::value_type v8 = v37;
              }
              else
              {
                std::string v39 = v35;
              }
              std::string::size_type v40 = v7;
              std::string::value_type v41 = v8;
              *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)&v38.__r_.__value_.__l.__data_;
              v42.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v43, v39.__r_.__value_.__l.__data_, v39.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v40;
                std::string::value_type v8 = v41;
                std::string::size_type v6 = v42.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v43 = v39;
              }
              std::string::size_type v44 = v7;
              std::string::value_type v45 = v8;
              *(_OWORD *)uint64_t v46 = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
              *(void *)&v46[16] = v6;
              if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v47, v43.__r_.__value_.__l.__data_, v43.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v44;
                std::string::value_type v8 = v45;
              }
              else
              {
                std::string v47 = v43;
              }
              std::string::size_type v48 = v7;
              std::string::value_type v49 = v8;
              uint64_t v9 = (std::string *)operator new(0x40uLL);
              *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)v46;
              v9->__r_.__value_.__r.__words[2] = *(void *)&v46[16];
              uint64_t v10 = v9 + 1;
              if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(v10, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
                std::string::value_type v11 = v49;
                int v12 = SHIBYTE(v47.__r_.__value_.__r.__words[2]);
                v9[2].__r_.__value_.__r.__words[0] = v48;
                v9[2].__r_.__value_.__s.__data_[8] = v11;
                v28[0] = (uint64_t)v9;
                if (v12 < 0)
                {
                  operator delete(v47.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_65;
                  }
                }
                else if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
                  goto LABEL_65;
                }
              }
              else
              {
                *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
                v9[1].__r_.__value_.__r.__words[2] = v47.__r_.__value_.__r.__words[2];
                v9[2].__r_.__value_.__r.__words[0] = v7;
                v9[2].__r_.__value_.__s.__data_[8] = v8;
                v28[0] = (uint64_t)v9;
                if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
LABEL_65:
                  operator delete(v43.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
                  {
LABEL_66:
                    operator delete(v39.__r_.__value_.__l.__data_);
                    unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
                    {
LABEL_67:
                      operator delete(v35.__r_.__value_.__l.__data_);
                      if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_46;
                      }
                      goto LABEL_68;
                    }
LABEL_45:
                    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_46;
                    }
LABEL_68:
                    operator delete(v31.__r_.__value_.__l.__data_);
LABEL_46:
                    uint64_t v13 = *(void *)(a1 + 56);
                    uint64_t v14 = *(void *)(a1 + 48);
                    uint64_t v15 = 16 * (v13 - v14) - 1;
                    if (v13 == v14) {
                      uint64_t v15 = 0;
                    }
                    unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
                    if (v15 == v16)
                    {
                      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
                      uint64_t v14 = *(void *)(a1 + 48);
                      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
                    }
                    unint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
                    *unint64_t v17 = 0;
                    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v27);
                    ++*(void *)(a1 + 80);
                    if (v27)
                    {
                      if ((v27 & 1) == 0)
                      {
                        uint64_t v18 = *(void (**)(uint64_t *, _WORD *, int))(v27 & 0xFFFFFFFFFFFFFFFELL);
                        if (v18) {
                          v18(v28, v28, 2);
                        }
                      }
                      unint64_t v27 = 0;
                    }
                    if (SBYTE7(v25) < 0)
                    {
                      operator delete((void *)__p);
                      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        return v3 == 0;
                      }
                    }
                    else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
                      return v3 == 0;
                    }
                    operator delete(v20.__r_.__value_.__l.__data_);
                    return v3 == 0;
                  }
LABEL_44:
                  unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_67;
                  }
                  goto LABEL_45;
                }
              }
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_66;
              }
              goto LABEL_44;
            }
          }
          else if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_23;
          }
        }
        else
        {
          long long __p = *(_OWORD *)&v46[8];
          long long v25 = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_23;
          }
        }
        operator delete(v34.__r_.__value_.__l.__data_);
        goto LABEL_23;
      }
    }
    else
    {
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
    }
LABEL_16:
    operator delete(v38.__r_.__value_.__l.__data_);
    goto LABEL_17;
  }
  *(unsigned char *)(a1 + 100) = 1;
  return v3 == 0;
}

void sub_21DEB59A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  operator delete(v61);
  if (*(char *)(v62 - 81) < 0)
  {
    operator delete(*(void **)(v62 - 104));
    if ((*(char *)(v62 - 145) & 0x80000000) == 0)
    {
LABEL_3:
      if ((a61 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((*(char *)(v62 - 145) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v62 - 168));
  if ((a61 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a50 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  operator delete(__p);
  if ((a50 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a39 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a45);
  if ((a39 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a24 & 0x80000000) == 0)
    {
LABEL_14:
      if (a14 < 0) {
        operator delete(a9);
      }
      _Unwind_Resume(a1);
    }
LABEL_13:
    operator delete(a19);
    goto LABEL_14;
  }
LABEL_12:
  operator delete(a34);
  if ((a24 & 0x80000000) == 0) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRetry>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>>::manage(uint64_t *a1, _WORD *a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      std::string::size_type v6 = (std::string *)operator new(0x40uLL);
      *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)v5;
      v6->__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
      std::string::size_type v7 = v6 + 1;
      if (*(char *)(v5 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(v5 + 24), *(void *)(v5 + 32));
      }
      else
      {
        long long v8 = *(_OWORD *)(v5 + 24);
        v6[1].__r_.__value_.__r.__words[2] = *(void *)(v5 + 40);
        *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
      }
      v6[2].__r_.__value_.__r.__words[0] = *(void *)(v5 + 48);
      v6[2].__r_.__value_.__s.__data_[8] = *(unsigned char *)(v5 + 56);
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      uint64_t v9 = *(void *)a2;
      if (*(void *)a2)
      {
        if (*(char *)(v9 + 47) < 0) {
          operator delete(*(void **)(v9 + 24));
        }
        operator delete((void *)v9);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      uint64_t v10 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v10 == (const char *)(0x800000021DFA9B27 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v10, (const char *)(0x800000021DFA9B27 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
}

void sub_21DEB5CF4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[56];
  unint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  long long v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  uint64_t v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFA9B00 & 0x7FFFFFFFFFFFFFFFLL));
  std::string::size_type v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFA9B00 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      std::string::size_type v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    std::string::size_type v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  std::string::size_type v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    std::string::size_type v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    std::string v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    std::string v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(unsigned int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEB63FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeBooted,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::performAction<(BBUStage)8>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 112);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  uint64_t v11 = -1;
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0 && (gBBULogVerbosity & 0x80000000) == 0)
  {
    _BBULog(21, 0, "allowRetry", "", "Retry limits are src.retryLimit:%u  evt.retryLimit:%u src.retryCounter:%u\n", a6, a7, a8, *(_DWORD *)(a1 + 112));
    uint64_t v11 = gBBULogMaskGet(void)::once;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 28);
  int v14 = *(_DWORD *)(a1 + 108);
  unsigned int v13 = *(_DWORD *)(a1 + 112);
  if (v13 >= v12) {
    unsigned int v13 = *(_DWORD *)(a4 + 28);
  }
  if (v12) {
    unsigned int v15 = v13;
  }
  else {
    unsigned int v15 = v10;
  }
  unsigned int v16 = v14 + 1;
  *(_DWORD *)(a1 + 108) = v14 + 1;
  if (v11 == -1)
  {
    uint64_t v17 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
    int v18 = gBBULogVerbosity;
    if (v16 > v15) {
      goto LABEL_13;
    }
LABEL_23:
    if ((v17 & 0x200000) != 0 && (v18 & 0x80000000) == 0) {
      _BBULog(21, 0, "allowRetry", "", "Clearing error states since we are retrying.\n", a6, a7, a8, v32);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    size_t v22 = qword_26AA89AB0;
    if (!qword_26AA89AB0)
    {
      std::string::size_type v23 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
      object[0] = 0;
      ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v23, "BBUError", QOS_CLASS_UTILITY, object);
      if (object[0]) {
        dispatch_release(object[0]);
      }
      v23->__on_zero_shared_weauint64_t k = 0;
      v23[1].~__shared_weak_count = 0;
      v23[1].~__shared_weak_count_0 = 0;
      std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&block, v23);
      long long v24 = *(_OWORD *)&block.__r_.__value_.__l.__data_;
      *(_OWORD *)&block.__r_.__value_.__l.__data_ = 0uLL;
      long long v25 = (std::__shared_weak_count *)off_26AA89AB8;
      *(_OWORD *)&qword_26AA89AB0 = v24;
      if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
      std::string::size_type size = (std::__shared_weak_count *)block.__r_.__value_.__l.__size_;
      if (block.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(block.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
      size_t v22 = qword_26AA89AB0;
    }
    uint64_t v27 = (std::__shared_weak_count *)off_26AA89AB8;
    if (off_26AA89AB8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    object[0] = (dispatch_object_t)MEMORY[0x263EF8330];
    object[1] = (dispatch_object_t)0x40000000;
    object[2] = (dispatch_object_t)___ZN8BBUError11clearErrorsEv_block_invoke;
    object[3] = (dispatch_object_t)&__block_descriptor_tmp_9;
    object[4] = v22;
    uint64_t v34 = object;
    block.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
    block.__r_.__value_.__l.__size_ = 0x40000000;
    block.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
    unint64_t v36 = (unint64_t)&__block_descriptor_tmp_13_0;
    std::string::value_type v37 = v22;
    uint64_t v38 = &v34;
    isa = v22[2].isa;
    if (v22[3].isa)
    {
      dispatch_async_and_wait(isa, &block);
      if (!v27) {
        goto LABEL_44;
      }
    }
    else
    {
      dispatch_sync(isa, &block);
      if (!v27) {
        goto LABEL_44;
      }
    }
    if (!atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
LABEL_44:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
        goto LABEL_46;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
      {
LABEL_46:
        if ((gBBULogVerbosity & 0x80000000) == 0) {
          _BBULog(21, 0, "allowRetry", "", "attempting %u out of %u\n", v29, v30, v31, *(_DWORD *)(a1 + 108));
        }
      }
    }
    BBUpdaterController::personalize(*(void *)(a1 + 16), 8);
    return 1;
  }
  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  uint64_t v17 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
  int v18 = gBBULogVerbosity;
  if (v16 <= v15) {
    goto LABEL_23;
  }
LABEL_13:
  if ((v17 & 2) != 0 && (v18 & 0x80000000) == 0) {
    _BBULog(1, 0, "allowRetry", "", "too many retries: %u\n", a6, a7, a8, v15);
  }
  uint64_t v19 = *(void *)(a1 + 16);
  unsigned int v20 = *(_DWORD *)(a4 + 24);
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&block, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    blocuint64_t k = *(std::string *)a4;
  }
  unint64_t v36 = v20;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v19, (uint64_t)&block);
  if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(block.__r_.__value_.__l.__data_);
  }
  return 2;
}

void sub_21DEB6988(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete(v24);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::performAction<(BBUStage)8>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 124);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  uint64_t v11 = -1;
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0 && (gBBULogVerbosity & 0x80000000) == 0)
  {
    _BBULog(21, 0, "allowRetry", "", "Retry limits are src.retryLimit:%u  evt.retryLimit:%u src.retryCounter:%u\n", a6, a7, a8, *(_DWORD *)(a1 + 124));
    uint64_t v11 = gBBULogMaskGet(void)::once;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 28);
  int v14 = *(_DWORD *)(a1 + 120);
  unsigned int v13 = *(_DWORD *)(a1 + 124);
  if (v13 >= v12) {
    unsigned int v13 = *(_DWORD *)(a4 + 28);
  }
  if (v12) {
    unsigned int v15 = v13;
  }
  else {
    unsigned int v15 = v10;
  }
  unsigned int v16 = v14 + 1;
  *(_DWORD *)(a1 + 120) = v14 + 1;
  if (v11 == -1)
  {
    uint64_t v17 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
    int v18 = gBBULogVerbosity;
    if (v16 > v15) {
      goto LABEL_13;
    }
LABEL_23:
    if ((v17 & 0x200000) != 0 && (v18 & 0x80000000) == 0) {
      _BBULog(21, 0, "allowRetry", "", "Clearing error states since we are retrying.\n", a6, a7, a8, v32);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    size_t v22 = qword_26AA89AB0;
    if (!qword_26AA89AB0)
    {
      std::string::size_type v23 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
      object[0] = 0;
      ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v23, "BBUError", QOS_CLASS_UTILITY, object);
      if (object[0]) {
        dispatch_release(object[0]);
      }
      v23->__on_zero_shared_weauint64_t k = 0;
      v23[1].~__shared_weak_count = 0;
      v23[1].~__shared_weak_count_0 = 0;
      std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&block, v23);
      long long v24 = *(_OWORD *)&block.__r_.__value_.__l.__data_;
      *(_OWORD *)&block.__r_.__value_.__l.__data_ = 0uLL;
      long long v25 = (std::__shared_weak_count *)off_26AA89AB8;
      *(_OWORD *)&qword_26AA89AB0 = v24;
      if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
      std::string::size_type size = (std::__shared_weak_count *)block.__r_.__value_.__l.__size_;
      if (block.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(block.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
      size_t v22 = qword_26AA89AB0;
    }
    uint64_t v27 = (std::__shared_weak_count *)off_26AA89AB8;
    if (off_26AA89AB8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    object[0] = (dispatch_object_t)MEMORY[0x263EF8330];
    object[1] = (dispatch_object_t)0x40000000;
    object[2] = (dispatch_object_t)___ZN8BBUError11clearErrorsEv_block_invoke;
    object[3] = (dispatch_object_t)&__block_descriptor_tmp_9;
    object[4] = v22;
    uint64_t v34 = object;
    block.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
    block.__r_.__value_.__l.__size_ = 0x40000000;
    block.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
    unint64_t v36 = (unint64_t)&__block_descriptor_tmp_13_0;
    std::string::value_type v37 = v22;
    uint64_t v38 = &v34;
    isa = v22[2].isa;
    if (v22[3].isa)
    {
      dispatch_async_and_wait(isa, &block);
      if (!v27) {
        goto LABEL_44;
      }
    }
    else
    {
      dispatch_sync(isa, &block);
      if (!v27) {
        goto LABEL_44;
      }
    }
    if (!atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
LABEL_44:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
        goto LABEL_46;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
      {
LABEL_46:
        if ((gBBULogVerbosity & 0x80000000) == 0) {
          _BBULog(21, 0, "allowRetry", "", "attempting %u out of %u\n", v29, v30, v31, *(_DWORD *)(a1 + 120));
        }
      }
    }
    BBUpdaterController::personalize(*(void *)(a1 + 16), 8);
    return 1;
  }
  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  uint64_t v17 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
  int v18 = gBBULogVerbosity;
  if (v16 <= v15) {
    goto LABEL_23;
  }
LABEL_13:
  if ((v17 & 2) != 0 && (v18 & 0x80000000) == 0) {
    _BBULog(1, 0, "allowRetry", "", "too many retries: %u\n", a6, a7, a8, v15);
  }
  uint64_t v19 = *(void *)(a1 + 16);
  unsigned int v20 = *(_DWORD *)(a4 + 24);
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&block, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    blocuint64_t k = *(std::string *)a4;
  }
  unint64_t v36 = v20;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v19, (uint64_t)&block);
  if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(block.__r_.__value_.__l.__data_);
  }
  return 2;
}

void sub_21DEB6E48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete(v24);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeFirst,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 136);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  uint64_t v11 = -1;
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0 && (gBBULogVerbosity & 0x80000000) == 0)
  {
    _BBULog(21, 0, "allowRetry", "", "Retry limits are src.retryLimit:%u  evt.retryLimit:%u src.retryCounter:%u\n", a6, a7, a8, *(_DWORD *)(a1 + 136));
    uint64_t v11 = gBBULogMaskGet(void)::once;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 28);
  int v14 = *(_DWORD *)(a1 + 132);
  unsigned int v13 = *(_DWORD *)(a1 + 136);
  if (v13 >= v12) {
    unsigned int v13 = *(_DWORD *)(a4 + 28);
  }
  if (v12) {
    unsigned int v15 = v13;
  }
  else {
    unsigned int v15 = v10;
  }
  unsigned int v16 = v14 + 1;
  *(_DWORD *)(a1 + 132) = v14 + 1;
  if (v11 == -1)
  {
    uint64_t v17 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
    int v18 = gBBULogVerbosity;
    if (v16 > v15) {
      goto LABEL_13;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t v17 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
    int v18 = gBBULogVerbosity;
    if (v16 > v15)
    {
LABEL_13:
      if ((v17 & 2) != 0 && (v18 & 0x80000000) == 0) {
        _BBULog(1, 0, "allowRetry", "", "too many retries: %u\n", a6, a7, a8, v15);
      }
      uint64_t v19 = *(void *)(a1 + 16);
      unsigned int v20 = *(_DWORD *)(a4 + 24);
      if (*(char *)(a4 + 23) < 0) {
        std::string::__init_copy_ctor_external(&block, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
      }
      else {
        blocuint64_t k = *(std::string *)a4;
      }
      unint64_t v39 = v20;
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v19, (uint64_t)&block);
      if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(block.__r_.__value_.__l.__data_);
      }
      return 2;
    }
  }
  if ((v17 & 0x200000) != 0 && (v18 & 0x80000000) == 0) {
    _BBULog(21, 0, "allowRetry", "", "Clearing error states since we are retrying.\n", a6, a7, a8, v35);
  }
  pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  size_t v22 = qword_26AA89AB0;
  if (!qword_26AA89AB0)
  {
    std::string::size_type v23 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
    object[0] = 0;
    ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v23, "BBUError", QOS_CLASS_UTILITY, object);
    if (object[0]) {
      dispatch_release(object[0]);
    }
    v23->__on_zero_shared_weauint64_t k = 0;
    v23[1].~__shared_weak_count = 0;
    v23[1].~__shared_weak_count_0 = 0;
    std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&block, v23);
    long long v24 = *(_OWORD *)&block.__r_.__value_.__l.__data_;
    *(_OWORD *)&block.__r_.__value_.__l.__data_ = 0uLL;
    long long v25 = (std::__shared_weak_count *)off_26AA89AB8;
    *(_OWORD *)&qword_26AA89AB0 = v24;
    if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
    std::string::size_type size = (std::__shared_weak_count *)block.__r_.__value_.__l.__size_;
    if (block.__r_.__value_.__l.__size_
      && !atomic_fetch_add((atomic_ullong *volatile)(block.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
    size_t v22 = qword_26AA89AB0;
  }
  uint64_t v27 = (std::__shared_weak_count *)off_26AA89AB8;
  if (off_26AA89AB8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  object[0] = (dispatch_object_t)MEMORY[0x263EF8330];
  object[1] = (dispatch_object_t)0x40000000;
  object[2] = (dispatch_object_t)___ZN8BBUError11clearErrorsEv_block_invoke;
  object[3] = (dispatch_object_t)&__block_descriptor_tmp_9;
  object[4] = v22;
  std::string::value_type v37 = object;
  block.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
  block.__r_.__value_.__l.__size_ = 0x40000000;
  block.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
  unint64_t v39 = (unint64_t)&__block_descriptor_tmp_13_0;
  uint64_t v40 = v22;
  std::string::value_type v41 = &v37;
  isa = v22[2].isa;
  if (v22[3].isa)
  {
    dispatch_async_and_wait(isa, &block);
    if (!v27) {
      goto LABEL_44;
    }
  }
  else
  {
    dispatch_sync(isa, &block);
    if (!v27) {
      goto LABEL_44;
    }
  }
  if (!atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
  }
LABEL_44:
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
      goto LABEL_46;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
    {
LABEL_46:
      if ((gBBULogVerbosity & 0x80000000) == 0) {
        _BBULog(21, 0, "allowRetry", "", "attempting %u out of %u\n", v29, v30, v31, *(_DWORD *)(a1 + 132));
      }
    }
  }
  char v32 = *(BBUpdaterController **)(a1 + 16);
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(v32, 0);
  BBUpdaterController::parsePreflightArgs(v32);
  BBUpdaterController::queryInfoFirstStageInternal((BBULoader **)v32, v34);
  if (FirmwareDataSource) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  }
  return 1;
}

void sub_21DEB734C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete(v24);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>::execute(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1 + 280;
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventRetry,BBUpdaterControllerFSM::eventRetry>(a1 + 280, a4))
  {
    uint64_t v7 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 304) + 38])(v6, 0);
    uint64_t v8 = v7;
    if (*(unsigned char *)(a1 + 369)) {
      BOOL v9 = 0;
    }
    else {
      BOOL v9 = v7 == 0;
    }
    if (v9) {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>(v6, v6, *(_DWORD *)(a1 + 304));
    }
    *(unsigned char *)(a1 + 368) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v6);
  }
  else
  {
    uint64_t v8 = 1;
  }
  *(_DWORD *)(a1 + 4 * a2 + 32) = 3;
  return v8;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventRetry>(uint64_t a1, uint64_t a2, char a3)
{
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventRetry,BBUpdaterControllerFSM::eventRetry>()) {
    return 1;
  }
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 24) + 38])(a1, 0);
  uint64_t v6 = v5;
  if (!*(unsigned char *)(a1 + 89) || (a3) && !v5) {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>(a1, a1, *(_DWORD *)(a1 + 24));
  }
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  }
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventRetry,BBUpdaterControllerFSM::eventRetry>(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 88);
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      std::string::size_type v5 = *(void *)(a2 + 24);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_4:
        std::string v34 = v20;
        v35.__r_.__value_.__r.__words[0] = v5;
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_5;
        }
        goto LABEL_12;
      }
    }
    else
    {
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *(_OWORD *)a2;
      std::string::size_type v5 = *(void *)(a2 + 24);
      v20.__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }
    std::string::__init_copy_ctor_external(&v34, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v21;
    v35.__r_.__value_.__r.__words[0] = v21;
    if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_5:
      std::string v38 = v34;
      v39.__r_.__value_.__r.__words[0] = v5;
      if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_13;
    }
LABEL_12:
    std::string::__init_copy_ctor_external(&v38, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v35.__r_.__value_.__r.__words[0];
    v39.__r_.__value_.__r.__words[0] = v35.__r_.__value_.__r.__words[0];
    if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_6:
      std::string v42 = v38;
      v43.__r_.__value_.__r.__words[0] = v5;
      *(void *)uint64_t v46 = a1;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
LABEL_13:
    std::string::__init_copy_ctor_external(&v42, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v39.__r_.__value_.__r.__words[0];
    v43.__r_.__value_.__r.__words[0] = v39.__r_.__value_.__r.__words[0];
    *(void *)uint64_t v46 = a1;
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_7:
      *(_OWORD *)&v46[8] = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[0] = v42.__r_.__value_.__r.__words[2];
      v47.__r_.__value_.__l.__size_ = v5;
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
LABEL_14:
    std::string::__init_copy_ctor_external((std::string *)&v46[8], v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
    v47.__r_.__value_.__l.__size_ = v43.__r_.__value_.__r.__words[0];
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v42.__r_.__value_.__l.__data_);
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_17:
        *(void *)&long long v22 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventRetry>;
        *((void *)&v22 + 1) = 0;
        std::string::size_type v23 = *(void *)v46;
        if (v47.__r_.__value_.__s.__data_[7] < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&__p, *(const std::string::value_type **)&v46[8], *(std::string::size_type *)&v46[16]);
          *((void *)&v25 + 1) = v47.__r_.__value_.__l.__size_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if (v47.__r_.__value_.__s.__data_[7] < 0)
          {
            operator delete(*(void **)&v46[8]);
            if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_23:
              long long v29 = v22;
              std::string::size_type v6 = v23;
              std::string::size_type v30 = v23;
              if (SBYTE7(v25) < 0)
              {
                std::string::__init_copy_ctor_external(&v31, (const std::string::value_type *)__p, *((std::string::size_type *)&__p + 1));
                std::string::size_type v6 = v30;
              }
              else
              {
                *(_OWORD *)&v31.__r_.__value_.__l.__data_ = __p;
                v31.__r_.__value_.__r.__words[2] = v25;
              }
              std::string::size_type v7 = *((void *)&v25 + 1);
              std::string::size_type v32 = *((void *)&v25 + 1);
              std::string::value_type v8 = v26;
              std::string::value_type v33 = v26;
              unint64_t v27 = 0;
              *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v29;
              v34.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v35, v31.__r_.__value_.__l.__data_, v31.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v32;
                std::string::value_type v8 = v33;
                std::string::size_type v6 = v34.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v35 = v31;
              }
              std::string::size_type v36 = v7;
              std::string::value_type v37 = v8;
              *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)&v34.__r_.__value_.__l.__data_;
              v38.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v39, v35.__r_.__value_.__l.__data_, v35.__r_.__value_.__l.__size_);
                std::string::size_type v6 = v38.__r_.__value_.__r.__words[2];
                std::string::size_type v7 = v36;
                std::string::value_type v8 = v37;
              }
              else
              {
                std::string v39 = v35;
              }
              std::string::size_type v40 = v7;
              std::string::value_type v41 = v8;
              *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)&v38.__r_.__value_.__l.__data_;
              v42.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v43, v39.__r_.__value_.__l.__data_, v39.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v40;
                std::string::value_type v8 = v41;
                std::string::size_type v6 = v42.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v43 = v39;
              }
              std::string::size_type v44 = v7;
              std::string::value_type v45 = v8;
              *(_OWORD *)uint64_t v46 = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
              *(void *)&v46[16] = v6;
              if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v47, v43.__r_.__value_.__l.__data_, v43.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v44;
                std::string::value_type v8 = v45;
              }
              else
              {
                std::string v47 = v43;
              }
              std::string::size_type v48 = v7;
              std::string::value_type v49 = v8;
              BOOL v9 = (std::string *)operator new(0x40uLL);
              *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)v46;
              v9->__r_.__value_.__r.__words[2] = *(void *)&v46[16];
              unsigned int v10 = v9 + 1;
              if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(v10, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
                std::string::value_type v11 = v49;
                int v12 = SHIBYTE(v47.__r_.__value_.__r.__words[2]);
                v9[2].__r_.__value_.__r.__words[0] = v48;
                v9[2].__r_.__value_.__s.__data_[8] = v11;
                v28[0] = (uint64_t)v9;
                if (v12 < 0)
                {
                  operator delete(v47.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_65;
                  }
                }
                else if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
                  goto LABEL_65;
                }
              }
              else
              {
                *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
                v9[1].__r_.__value_.__r.__words[2] = v47.__r_.__value_.__r.__words[2];
                v9[2].__r_.__value_.__r.__words[0] = v7;
                v9[2].__r_.__value_.__s.__data_[8] = v8;
                v28[0] = (uint64_t)v9;
                if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
LABEL_65:
                  operator delete(v43.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
                  {
LABEL_66:
                    operator delete(v39.__r_.__value_.__l.__data_);
                    unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
                    {
LABEL_67:
                      operator delete(v35.__r_.__value_.__l.__data_);
                      if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_46;
                      }
                      goto LABEL_68;
                    }
LABEL_45:
                    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_46;
                    }
LABEL_68:
                    operator delete(v31.__r_.__value_.__l.__data_);
LABEL_46:
                    uint64_t v13 = *(void *)(a1 + 48);
                    uint64_t v14 = *(void *)(a1 + 40);
                    uint64_t v15 = 16 * (v13 - v14) - 1;
                    if (v13 == v14) {
                      uint64_t v15 = 0;
                    }
                    unint64_t v16 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
                    if (v15 == v16)
                    {
                      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 32));
                      uint64_t v14 = *(void *)(a1 + 40);
                      unint64_t v16 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
                    }
                    uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
                    *uint64_t v17 = 0;
                    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v27);
                    ++*(void *)(a1 + 72);
                    if (v27)
                    {
                      if ((v27 & 1) == 0)
                      {
                        int v18 = *(void (**)(uint64_t *, _WORD *, int))(v27 & 0xFFFFFFFFFFFFFFFELL);
                        if (v18) {
                          v18(v28, v28, 2);
                        }
                      }
                      unint64_t v27 = 0;
                    }
                    if (SBYTE7(v25) < 0)
                    {
                      operator delete((void *)__p);
                      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        return v3 == 0;
                      }
                    }
                    else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
                      return v3 == 0;
                    }
                    operator delete(v20.__r_.__value_.__l.__data_);
                    return v3 == 0;
                  }
LABEL_44:
                  unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_67;
                  }
                  goto LABEL_45;
                }
              }
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_66;
              }
              goto LABEL_44;
            }
          }
          else if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_23;
          }
        }
        else
        {
          long long __p = *(_OWORD *)&v46[8];
          long long v25 = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_23;
          }
        }
        operator delete(v34.__r_.__value_.__l.__data_);
        goto LABEL_23;
      }
    }
    else
    {
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
    }
LABEL_16:
    operator delete(v38.__r_.__value_.__l.__data_);
    goto LABEL_17;
  }
  *(unsigned char *)(a1 + 88) = 1;
  return v3 == 0;
}

void sub_21DEB7B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  operator delete(v61);
  if (*(char *)(v62 - 81) < 0)
  {
    operator delete(*(void **)(v62 - 104));
    if ((*(char *)(v62 - 145) & 0x80000000) == 0)
    {
LABEL_3:
      if ((a61 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((*(char *)(v62 - 145) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v62 - 168));
  if ((a61 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a50 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  operator delete(__p);
  if ((a50 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a39 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a45);
  if ((a39 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a24 & 0x80000000) == 0)
    {
LABEL_14:
      if (a14 < 0) {
        operator delete(a9);
      }
      _Unwind_Resume(a1);
    }
LABEL_13:
    operator delete(a19);
    goto LABEL_14;
  }
LABEL_12:
  operator delete(a34);
  if ((a24 & 0x80000000) == 0) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>>::manage(uint64_t *a1, _WORD *a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      std::string::size_type v6 = (std::string *)operator new(0x40uLL);
      *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)v5;
      v6->__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
      std::string::size_type v7 = v6 + 1;
      if (*(char *)(v5 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(v5 + 24), *(void *)(v5 + 32));
      }
      else
      {
        long long v8 = *(_OWORD *)(v5 + 24);
        v6[1].__r_.__value_.__r.__words[2] = *(void *)(v5 + 40);
        *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
      }
      v6[2].__r_.__value_.__r.__words[0] = *(void *)(v5 + 48);
      v6[2].__r_.__value_.__s.__data_[8] = *(unsigned char *)(v5 + 56);
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      uint64_t v9 = *(void *)a2;
      if (*(void *)a2)
      {
        if (*(char *)(v9 + 47) < 0) {
          operator delete(*(void **)(v9 + 24));
        }
        operator delete((void *)v9);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      unsigned int v10 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v10 == (const char *)(0x800000021DFA9C0DLL & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v10, (const char *)(0x800000021DFA9C0DLL & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
}

void sub_21DEB7E30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRetry>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[56];
  unint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  long long v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  unsigned int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFA9B00 & 0x7FFFFFFFFFFFFFFFLL));
  std::string::size_type v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFA9B00 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      std::string::size_type v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    std::string::size_type v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  std::string::size_type v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    std::string::size_type v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    std::string v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    std::string v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEB8538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,BBUpdaterControllerFSM::eventRetry,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(v3 + 32) = 4;
  unint64_t v4 = (_DWORD *)(v3 + 32);
  uint64_t v5 = *(BBUpdaterController **)(a1 + 16);
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(v5, 0);
  BBUpdaterController::parsePreflightArgs(v5);
  BBUpdaterController::queryInfoFirstStageInternal((BBULoader **)v5, v7);
  if (FirmwareDataSource) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  }
  _DWORD *v4 = 4;
  int v8 = *(_DWORD *)(a1 + 364);
  *(_DWORD *)(a1 + 304) = v8;
  *(void *)(a1 + 296) = *(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  switch(v8)
  {
    case 0:
      uint64_t v9 = (_DWORD *)(a1 + 412);
      goto LABEL_8;
    case 1:
      uint64_t v9 = (_DWORD *)(a1 + 400);
      goto LABEL_8;
    case 2:
      uint64_t v9 = (_DWORD *)(a1 + 388);
      goto LABEL_8;
    case 3:
      uint64_t v9 = (_DWORD *)(a1 + 376);
LABEL_8:
      ++*v9;
      break;
    default:
      break;
  }
  *(unsigned char *)(a1 + 368) = 0;
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1 + 280);
  _DWORD *v4 = 3;
  return 1;
}

void sub_21DEB8764(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::ControllerFSM_TOP::checkManifest,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 432);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  uint64_t v11 = -1;
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0 && (gBBULogVerbosity & 0x80000000) == 0)
  {
    _BBULog(21, 0, "allowRetry", "", "Retry limits are src.retryLimit:%u  evt.retryLimit:%u src.retryCounter:%u\n", a6, a7, a8, *(_DWORD *)(a1 + 432));
    uint64_t v11 = gBBULogMaskGet(void)::once;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 28);
  unsigned int v13 = *(_DWORD *)(a1 + 432);
  if (v13 >= v12) {
    unsigned int v13 = *(_DWORD *)(a4 + 28);
  }
  if (v12) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = v10;
  }
  unsigned int v15 = *(_DWORD *)(a1 + 428) + 1;
  *(_DWORD *)(a1 + 428) = v15;
  if (v11 == -1)
  {
    uint64_t v16 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
    int v17 = gBBULogVerbosity;
    if (v15 > v14) {
      goto LABEL_13;
    }
LABEL_23:
    if ((v16 & 0x200000) != 0 && (v17 & 0x80000000) == 0) {
      _BBULog(21, 0, "allowRetry", "", "Clearing error states since we are retrying.\n", a6, a7, a8, v35);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    std::string::size_type v21 = qword_26AA89AB0;
    if (!qword_26AA89AB0)
    {
      size_t v22 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
      object[0] = 0;
      ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v22, "BBUError", QOS_CLASS_UTILITY, object);
      if (object[0]) {
        dispatch_release(object[0]);
      }
      v22->__on_zero_shared_weauint64_t k = 0;
      v22[1].~__shared_weak_count = 0;
      v22[1].~__shared_weak_count_0 = 0;
      std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&block, v22);
      long long v23 = *(_OWORD *)&block.__r_.__value_.__l.__data_;
      *(_OWORD *)&block.__r_.__value_.__l.__data_ = 0uLL;
      uint64_t v24 = (std::__shared_weak_count *)off_26AA89AB8;
      *(_OWORD *)&qword_26AA89AB0 = v23;
      if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
      std::string::size_type size = (std::__shared_weak_count *)block.__r_.__value_.__l.__size_;
      if (block.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(block.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
      std::string::size_type v21 = qword_26AA89AB0;
    }
    uint64_t v26 = (std::__shared_weak_count *)off_26AA89AB8;
    if (off_26AA89AB8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    object[0] = (dispatch_object_t)MEMORY[0x263EF8330];
    object[1] = (dispatch_object_t)0x40000000;
    object[2] = (dispatch_object_t)___ZN8BBUError11clearErrorsEv_block_invoke;
    object[3] = (dispatch_object_t)&__block_descriptor_tmp_9;
    object[4] = v21;
    std::string::value_type v37 = object;
    block.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
    block.__r_.__value_.__l.__size_ = 0x40000000;
    block.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
    unint64_t v39 = (unint64_t)&__block_descriptor_tmp_13_0;
    uint64_t v40 = v21;
    std::string::value_type v41 = &v37;
    isa = v21[2].isa;
    if (v21[3].isa)
    {
      dispatch_async_and_wait(isa, &block);
      if (!v26) {
        goto LABEL_44;
      }
    }
    else
    {
      dispatch_sync(isa, &block);
      if (!v26) {
        goto LABEL_44;
      }
    }
    if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
LABEL_44:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
        goto LABEL_46;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
      {
LABEL_46:
        if ((gBBULogVerbosity & 0x80000000) == 0) {
          _BBULog(21, 0, "allowRetry", "", "attempting %u out of %u\n", v32, v33, v34, *(_DWORD *)(a1 + 428));
        }
      }
    }
    BBUpdaterController::checkManifest(*(BBUpdaterController **)(a1 + 16), v28, v29, v30, v31, v32, v33, v34);
    return 1;
  }
  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  uint64_t v16 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
  int v17 = gBBULogVerbosity;
  if (v15 <= v14) {
    goto LABEL_23;
  }
LABEL_13:
  if ((v16 & 2) != 0 && (v17 & 0x80000000) == 0) {
    _BBULog(1, 0, "allowRetry", "", "too many retries: %u\n", a6, a7, a8, v14);
  }
  uint64_t v18 = *(void *)(a1 + 16);
  unsigned int v19 = *(_DWORD *)(a4 + 24);
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&block, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    blocuint64_t k = *(std::string *)a4;
  }
  unint64_t v39 = v19;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v18, (uint64_t)&block);
  if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(block.__r_.__value_.__l.__data_);
  }
  return 2;
}

void sub_21DEB8C1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete(v24);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::ControllerFSM_TOP::bootup<true>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 444);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  uint64_t v11 = -1;
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0 && (gBBULogVerbosity & 0x80000000) == 0)
  {
    _BBULog(21, 0, "allowRetry", "", "Retry limits are src.retryLimit:%u  evt.retryLimit:%u src.retryCounter:%u\n", a6, a7, a8, *(_DWORD *)(a1 + 444));
    uint64_t v11 = gBBULogMaskGet(void)::once;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 28);
  unsigned int v13 = *(_DWORD *)(a1 + 444);
  if (v13 >= v12) {
    unsigned int v13 = *(_DWORD *)(a4 + 28);
  }
  if (v12) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = v10;
  }
  unsigned int v15 = *(_DWORD *)(a1 + 440) + 1;
  *(_DWORD *)(a1 + 440) = v15;
  if (v11 == -1)
  {
    uint64_t v16 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
    int v17 = gBBULogVerbosity;
    if (v15 > v14) {
      goto LABEL_13;
    }
LABEL_23:
    if ((v16 & 0x200000) != 0 && (v17 & 0x80000000) == 0) {
      _BBULog(21, 0, "allowRetry", "", "Clearing error states since we are retrying.\n", a6, a7, a8, v31);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    std::string::size_type v21 = qword_26AA89AB0;
    if (!qword_26AA89AB0)
    {
      size_t v22 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
      object[0] = 0;
      ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v22, "BBUError", QOS_CLASS_UTILITY, object);
      if (object[0]) {
        dispatch_release(object[0]);
      }
      v22->__on_zero_shared_weauint64_t k = 0;
      v22[1].~__shared_weak_count = 0;
      v22[1].~__shared_weak_count_0 = 0;
      std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&block, v22);
      long long v23 = *(_OWORD *)&block.__r_.__value_.__l.__data_;
      *(_OWORD *)&block.__r_.__value_.__l.__data_ = 0uLL;
      uint64_t v24 = (std::__shared_weak_count *)off_26AA89AB8;
      *(_OWORD *)&qword_26AA89AB0 = v23;
      if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
      std::string::size_type size = (std::__shared_weak_count *)block.__r_.__value_.__l.__size_;
      if (block.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(block.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
      std::string::size_type v21 = qword_26AA89AB0;
    }
    uint64_t v26 = (std::__shared_weak_count *)off_26AA89AB8;
    if (off_26AA89AB8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    object[0] = (dispatch_object_t)MEMORY[0x263EF8330];
    object[1] = (dispatch_object_t)0x40000000;
    object[2] = (dispatch_object_t)___ZN8BBUError11clearErrorsEv_block_invoke;
    object[3] = (dispatch_object_t)&__block_descriptor_tmp_9;
    object[4] = v21;
    uint64_t v33 = object;
    block.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
    block.__r_.__value_.__l.__size_ = 0x40000000;
    block.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
    unint64_t v35 = (unint64_t)&__block_descriptor_tmp_13_0;
    size_t v36 = v21;
    std::string::value_type v37 = &v33;
    isa = v21[2].isa;
    if (v21[3].isa)
    {
      dispatch_async_and_wait(isa, &block);
      if (!v26) {
        goto LABEL_44;
      }
    }
    else
    {
      dispatch_sync(isa, &block);
      if (!v26) {
        goto LABEL_44;
      }
    }
    if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
LABEL_44:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
        goto LABEL_46;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
      {
LABEL_46:
        if ((gBBULogVerbosity & 0x80000000) == 0) {
          _BBULog(21, 0, "allowRetry", "", "attempting %u out of %u\n", v28, v29, v30, *(_DWORD *)(a1 + 440));
        }
      }
    }
    BBUpdaterController::bootup(*(BBUpdaterController **)(a1 + 16));
    return 1;
  }
  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  uint64_t v16 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
  int v17 = gBBULogVerbosity;
  if (v15 <= v14) {
    goto LABEL_23;
  }
LABEL_13:
  if ((v16 & 2) != 0 && (v17 & 0x80000000) == 0) {
    _BBULog(1, 0, "allowRetry", "", "too many retries: %u\n", a6, a7, a8, v14);
  }
  uint64_t v18 = *(void *)(a1 + 16);
  unsigned int v19 = *(_DWORD *)(a4 + 24);
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&block, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    blocuint64_t k = *(std::string *)a4;
  }
  unint64_t v35 = v19;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v18, (uint64_t)&block);
  if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(block.__r_.__value_.__l.__data_);
  }
  return 2;
}

void sub_21DEB90E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete(v24);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventContinue>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E748 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E740 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E738 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E730 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E728 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E720 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E718 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E710 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E708 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      qword_26AA8E700[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E700[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E700[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      unsigned int v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *unsigned int v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventContinue>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventContinue const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventContinue>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventContinue const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventContinue>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      int v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *int v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          uint64_t v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EB78 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EB78 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventContinue>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventContinue>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEB956C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventContinue>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventContinue const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventContinue>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFA9D2BLL & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFA9D2BLL & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventContinue const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventContinue>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  unint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventContinue>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unsigned int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFA9D01 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFA9D01 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      long long v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    long long v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  long long v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEB9DD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventContinue>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,BBUpdaterControllerFSM::eventContinue,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::front::none,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(v2 + 32) = 6;
  ++*(_DWORD *)(a1 + 452);
  *(_DWORD *)(v2 + 32) = 0;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,BBUpdaterControllerFSM::eventContinue,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::front::none,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(v2 + 32) = 4;
  uint64_t v3 = (_DWORD *)(v2 + 32);
  int v4 = *(_DWORD *)(a1 + 364);
  *(_DWORD *)(a1 + 304) = v4;
  *(void *)(a1 + 296) = *(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  switch(v4)
  {
    case 0:
      char v5 = (_DWORD *)(a1 + 412);
      goto LABEL_6;
    case 1:
      char v5 = (_DWORD *)(a1 + 400);
      goto LABEL_6;
    case 2:
      char v5 = (_DWORD *)(a1 + 388);
      goto LABEL_6;
    case 3:
      char v5 = (_DWORD *)(a1 + 376);
LABEL_6:
      ++*v5;
      break;
    default:
      break;
  }
  *(unsigned char *)(a1 + 368) = 0;
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1 + 280);
  *uint64_t v3 = 3;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::eventContinue,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::front::none,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 428) = 0;
  *(_DWORD *)(v2 + 32) = 2;
  ++*(_DWORD *)(a1 + 452);
  *(_DWORD *)(v2 + 32) = 0;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::eventContinue,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::front::none,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 440) = 0;
  *(_DWORD *)(v2 + 32) = 1;
  ++*(_DWORD *)(a1 + 452);
  *(_DWORD *)(v2 + 32) = 0;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventRepersonalize>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E798 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E790 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E788 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E780 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E778 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E770 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E768 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E760 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E758 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      qword_26AA8E750[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E750[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E750[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      unsigned int v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *unsigned int v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventRepersonalize>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRepersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRepersonalize>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRepersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRepersonalize>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *uint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          uint64_t v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EBD0 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EBD0 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRepersonalize>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRepersonalize>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEBA464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventRepersonalize>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRepersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRepersonalize>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFA9E43 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFA9E43 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRepersonalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventRepersonalize>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  int v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRepersonalize>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unsigned int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFA9E14 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFA9E14 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      long long v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    long long v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  long long v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEBACC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,BBUpdaterControllerFSM::eventRepersonalize,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRePerso>>::execute(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *(_DWORD *)(a1 + 28);
  unsigned int v10 = *(_DWORD *)(a1 + 24) + 1;
  *(_DWORD *)(a1 + 24) = v10;
  if (v10 > v9)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    unsigned int v12 = (char *)operator new(0x20uLL);
    strcpy(v12, "too many repersonalizations");
    std::string::__init_copy_ctor_external(&v22, v12, 0x1BuLL);
    uint64_t v23 = 43;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v11, (uint64_t)&v22);
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
    operator delete(v12);
    return 2;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
      goto LABEL_7;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
    {
LABEL_7:
      if ((gBBULogVerbosity & 0x80000000) == 0) {
        _BBULog(21, 0, "allowRePerso", "", "attempting %u out of %u\n", a6, a7, a8, *(_DWORD *)(a1 + 24));
      }
    }
  }
  uint64_t v15 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 136) = 0;
  *(_DWORD *)(v15 + 32) = 6;
  uint64_t v16 = (_DWORD *)(v15 + 32);
  uint64_t v17 = *(BBUpdaterController **)(a1 + 16);
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(v17, 0);
  BBUpdaterController::parsePreflightArgs(v17);
  BBUpdaterController::queryInfoFirstStageInternal((BBULoader **)v17, v19);
  if (FirmwareDataSource) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  }
  *uint64_t v16 = 6;
  int v20 = *(_DWORD *)(a1 + 364);
  *(_DWORD *)(a1 + 304) = v20;
  *(void *)(a1 + 296) = *(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  switch(v20)
  {
    case 0:
      unint64_t v21 = (_DWORD *)(a1 + 412);
      goto LABEL_16;
    case 1:
      unint64_t v21 = (_DWORD *)(a1 + 400);
      goto LABEL_16;
    case 2:
      unint64_t v21 = (_DWORD *)(a1 + 388);
      goto LABEL_16;
    case 3:
      unint64_t v21 = (_DWORD *)(a1 + 376);
LABEL_16:
      ++*v21;
      break;
    default:
      break;
  }
  *(unsigned char *)(a1 + 368) = 0;
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1 + 280);
  *uint64_t v16 = 3;
  return 1;
}

void sub_21DEBB028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
    operator delete(v16);
    _Unwind_Resume(a1);
  }
  operator delete(v16);
  _Unwind_Resume(a1);
}

void sub_21DEBB060(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

void BBUProvisioningParameters::~BBUProvisioningParameters(BBUProvisioningParameters *this)
{
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete((void *)v2);
  }
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    if (*(char *)(v3 + 23) < 0) {
      operator delete(*(void **)v3);
    }
    operator delete((void *)v3);
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4)
  {
    if (*(char *)(v4 + 23) < 0) {
      operator delete(*(void **)v4);
    }
    operator delete((void *)v4);
  }
  uint64_t v5 = *((void *)this + 3);
  if (v5)
  {
    if (*(char *)(v5 + 23) < 0) {
      operator delete(*(void **)v5);
    }
    operator delete((void *)v5);
  }
  int v6 = (void **)*((void *)this + 4);
  if (v6)
  {
    if (*v6) {
      operator delete(*v6);
    }
    operator delete(v6);
  }
  uint64_t v7 = *((void *)this + 5);
  if (v7)
  {
    if (*(char *)(v7 + 23) < 0) {
      operator delete(*(void **)v7);
    }
    operator delete((void *)v7);
  }
  uint64_t v8 = *((void *)this + 6);
  if (v8)
  {
    if (*(char *)(v8 + 23) < 0) {
      operator delete(*(void **)v8);
    }
    operator delete((void *)v8);
  }
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventFinalize>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E7E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7C0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      qword_26AA8E7A0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E7A0[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E7A0[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      unsigned int v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *unsigned int v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventFinalize>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventFinalize>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventFinalize>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *uint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          uint64_t v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EC28 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EC28 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEBB5E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFinalize>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventFinalize>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFA9F5BLL & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFA9F5BLL & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventFinalize>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unsigned int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFA9F31 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFA9F31 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEBBE44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,BBUpdaterControllerFSM::ControllerFSM_TOP::finalize,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 32) = 5;
  uint64_t v4 = (_DWORD *)(v3 + 32);
  int v5 = *(_DWORD *)(a1 + 168);
  if (!v5)
  {
    int v6 = (_DWORD *)(a1 + 252);
    goto LABEL_5;
  }
  if (v5 == 1)
  {
    int v6 = (_DWORD *)(a1 + 240);
LABEL_5:
    _DWORD *v6 = 0;
  }
  _DWORD *v4 = 5;
  BBUpdaterController::finalize(*(BBUpdaterController **)(a1 + 16));
  _DWORD *v4 = 5;
  ++*(_DWORD *)(a1 + 136);
  _DWORD *v4 = 6;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,BBUpdaterControllerFSM::ControllerFSM_TOP::finalize,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 32) = 3;
  uint64_t v4 = (_DWORD *)(v3 + 32);
  switch(*(_DWORD *)(a1 + 304))
  {
    case 0:
      int v5 = (_DWORD *)(a1 + 412);
      goto LABEL_6;
    case 1:
      int v5 = (_DWORD *)(a1 + 400);
      goto LABEL_6;
    case 2:
      int v5 = (_DWORD *)(a1 + 388);
      goto LABEL_6;
    case 3:
      int v5 = (_DWORD *)(a1 + 376);
LABEL_6:
      _DWORD *v5 = 0;
      break;
    default:
      break;
  }
  _DWORD *v4 = 3;
  BBUpdaterController::finalize(*(BBUpdaterController **)(a1 + 16));
  _DWORD *v4 = 3;
  ++*(_DWORD *)(a1 + 136);
  _DWORD *v4 = 6;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdQueryInfo>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E838 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E830 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E828 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E820 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E818 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E810 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E808 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E800 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E7F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      qword_26AA8E7F0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E7F0[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E7F0[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      unsigned int v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *unsigned int v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdQueryInfo>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *uint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          uint64_t v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EC80 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EC80 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEBC4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdQueryInfo>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAA072 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAA072 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unsigned int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA044 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA044 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEBCD38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeEUICC,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,BBUpdaterControllerFSM::queryAction<(BBUStage)32>,boost::msm::front::none>>::execute(uint64_t a1)
{
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,BBUpdaterControllerFSM::queryAction<(BBUStage)4>,boost::msm::front::none>>::execute(uint64_t a1)
{
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeFirst,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,boost::msm::front::none>>::execute(uint64_t a1)
{
  uint64_t v1 = *(BBUpdaterController **)(a1 + 16);
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(v1, 0);
  BBUpdaterController::parsePreflightArgs(v1);
  BBUpdaterController::queryInfoFirstStageInternal((BBULoader **)v1, v3);
  if (FirmwareDataSource) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  }
  return 1;
}

void sub_21DEBCF10(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionFinish,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,boost::msm::front::none,boost::msm::front::none>>::execute()
{
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionStart,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::gatherParam,boost::msm::front::none>>::execute(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  char v18 = -86;
  uint64_t v2 = operator new(0x38uLL);
  *uint64_t v2 = 0u;
  v2[1] = 0u;
  v2[2] = 0u;
  *((void *)v2 + 6) = 0;
  uint64_t v17 = v2;
  BBUFeedback::handleComment(*(BBUFeedback **)(v1 + 56), "Getting manifest status for provisioning");
  int v6 = (*(uint64_t (**)(void, uint64_t, void, char *, uint64_t, uint64_t))(**(void **)(v1 + 72) + 96))(*(void *)(v1 + 72), v1 + 152, *(void *)(v1 + 96), &v18, v1 + 240, 1);
  if (!v6)
  {
    BBUFeedback::handleComment(*(BBUFeedback **)(v1 + 56), "Gathering provisioning parameters from BB");
    int v10 = (*(uint64_t (**)(void, uint64_t, _OWORD *))(**(void **)(v1 + 72) + 88))(*(void *)(v1 + 72), v1 + 152, v2);
    if (!v10)
    {
      BBUpdaterController::updateProvisioningInfo(v1, (uint64_t)&v17);
      goto LABEL_4;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_12;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_12:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v7, v8, v9, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    uint64_t v13 = (char *)operator new(0x30uLL);
    strcpy(v13, "Failed to gather provisioning parameters");
    std::string::__init_copy_ctor_external(&v14, v13, 0x28uLL);
    int v15 = v10;
    int v16 = 0;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v1, (uint64_t)&v14);
    goto LABEL_15;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_7;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_7:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v3, v4, v5, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  uint64_t v13 = (char *)operator new(0x20uLL);
  strcpy(v13, "Failed to get manifest status");
  std::string::__init_copy_ctor_external(&v14, v13, 0x1DuLL);
  int v15 = v6;
  int v16 = 0;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v1, (uint64_t)&v14);
LABEL_15:
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  operator delete(v13);
LABEL_4:
  BBUProvisioningParameters::~BBUProvisioningParameters((BBUProvisioningParameters *)v2);
  operator delete(v11);
  return 1;
}

void sub_21DEBD24C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  operator delete(v19);
  BBUProvisioningParameters::~BBUProvisioningParameters(v18);
  operator delete(v21);
  _Unwind_Resume(a1);
}

void sub_21DEBD2A4(_Unwind_Exception *a1)
{
  BBUProvisioningParameters::~BBUProvisioningParameters(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_21DEBD2BC(_Unwind_Exception *a1)
{
  BBUProvisioningParameters::~BBUProvisioningParameters(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>::execute(uint64_t a1, int a2)
{
  uint64_t v4 = a1 + 280;
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdQueryInfo,BBUpdaterControllerFSM::eventCmdQueryInfo>(a1 + 280))
  {
    uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 304) + 43])(v4, 0);
    uint64_t v6 = v5;
    if (*(unsigned char *)(a1 + 369)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = v5 == 0;
    }
    if (v7) {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(v4, v4, *(_DWORD *)(a1 + 304));
    }
    *(unsigned char *)(a1 + 368) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v4);
  }
  else
  {
    uint64_t v6 = 1;
  }
  *(_DWORD *)(a1 + 4 * a2 + 32) = 3;
  return v6;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdQueryInfo>(uint64_t a1, uint64_t a2, char a3)
{
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdQueryInfo,BBUpdaterControllerFSM::eventCmdQueryInfo>()) {
    return 1;
  }
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 24) + 43])(a1, 0);
  uint64_t v6 = v5;
  if (!*(unsigned char *)(a1 + 89) || (a3) && !v5) {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(a1, a1, *(_DWORD *)(a1 + 24));
  }
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  }
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdQueryInfo,BBUpdaterControllerFSM::eventCmdQueryInfo>(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 88);
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = operator new(0x20uLL);
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = 16 * (v4 - v5) - 1;
    *uint64_t v3 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    v3[1] = 0;
    v3[2] = a1;
    *((unsigned char *)v3 + 25) = 5;
    unint64_t v11 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>)::stored_vtable;
    v12[0] = v3;
    if (v4 == v5) {
      uint64_t v6 = 0;
    }
    unint64_t v7 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
    if (v6 == v7)
    {
      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 32));
      uint64_t v5 = *(void *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
    }
    uint64_t v8 = (void *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
    *uint64_t v8 = 0;
    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v8, (uint64_t *)&v11);
    ++*(void *)(a1 + 72);
    if (v11 && (v11 & 1) == 0)
    {
      uint64_t v9 = *(void (**)(void *, void *, uint64_t))(v11 & 0xFFFFFFFFFFFFFFFELL);
      if (v9) {
        v9(v12, v12, 2);
      }
    }
    return v2 == 0;
  }
  else
  {
    *(unsigned char *)(a1 + 88) = 1;
    return v2 == 0;
  }
}

void sub_21DEBD580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      uint64_t v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAA15FLL & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAA15FLL & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unsigned int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  char v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA044 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA044 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEBDD94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>::execute(uint64_t a1, int a2)
{
  uint64_t v4 = a1 + 144;
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdQueryInfo,BBUpdaterControllerFSM::eventCmdQueryInfo>(a1 + 144))
  {
    uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 168) + 27])(v4, 0);
    uint64_t v6 = v5;
    if (*(unsigned char *)(a1 + 233)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = v5 == 0;
    }
    if (v7) {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(v4, v4, *(_DWORD *)(a1 + 168));
    }
    *(unsigned char *)(a1 + 232) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v4);
  }
  else
  {
    uint64_t v6 = 1;
  }
  *(_DWORD *)(a1 + 4 * a2 + 32) = 5;
  return v6;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdQueryInfo>(uint64_t a1, uint64_t a2, char a3)
{
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdQueryInfo,BBUpdaterControllerFSM::eventCmdQueryInfo>()) {
    return 1;
  }
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 24) + 27])(a1, 0);
  uint64_t v6 = v5;
  if (!*(unsigned char *)(a1 + 89) || (a3) && !v5) {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(a1, a1, *(_DWORD *)(a1 + 24));
  }
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  }
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdQueryInfo,BBUpdaterControllerFSM::eventCmdQueryInfo>(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 88);
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = operator new(0x20uLL);
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = 16 * (v4 - v5) - 1;
    *uint64_t v3 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    v3[1] = 0;
    v3[2] = a1;
    *((unsigned char *)v3 + 25) = 5;
    unint64_t v11 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>)::stored_vtable;
    v12[0] = v3;
    if (v4 == v5) {
      uint64_t v6 = 0;
    }
    unint64_t v7 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
    if (v6 == v7)
    {
      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 32));
      uint64_t v5 = *(void *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
    }
    uint64_t v8 = (void *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
    *uint64_t v8 = 0;
    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v8, (uint64_t *)&v11);
    ++*(void *)(a1 + 72);
    if (v11 && (v11 & 1) == 0)
    {
      uint64_t v9 = *(void (**)(void *, void *, uint64_t))(v11 & 0xFFFFFFFFFFFFFFFELL);
      if (v9) {
        v9(v12, v12, 2);
      }
    }
    return v2 == 0;
  }
  else
  {
    *(unsigned char *)(a1 + 88) = 1;
    return v2 == 0;
  }
}

void sub_21DEBE150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      uint64_t v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      uint64_t v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAA25ALL & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAA25ALL & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdQueryInfo>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unsigned int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  char v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA044 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA044 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEBE964(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(uint64_t result)
{
  if (*(void *)(result + 72))
  {
    uint64_t v1 = result;
    while (1)
    {
      *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(void *)unsigned int v19 = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)&v19[8] = v2;
      uint64_t v3 = *(void *)(v1 + 40);
      unint64_t v4 = *(void *)(v1 + 64);
      unint64_t v5 = v4 >> 7;
      uint64_t v6 = v4 & 0x7F;
      uint64_t v7 = *(void *)(v3 + 8 * (v4 >> 7)) + 32 * v6;
      uint64_t v18 = 0;
      uint64_t v8 = *(void *)v7;
      if (!*(void *)v7) {
        goto LABEL_7;
      }
      uint64_t v18 = *(void *)v7;
      if ((v8 & 1) == 0) {
        break;
      }
      long long v14 = *(_OWORD *)(v7 + 8);
      *(void *)&v19[16] = *(void *)(v7 + 24);
      *(_OWORD *)unsigned int v19 = v14;
      uint64_t v9 = (uint64_t *)(*(void *)(v3 + 8 * v5) + 32 * v6);
      uint64_t v10 = *v9;
      if (*v9)
      {
LABEL_16:
        if ((v10 & 1) == 0)
        {
          int v15 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v10 & 0xFFFFFFFFFFFFFFFELL);
          if (v15)
          {
            v15(v9 + 1, v9 + 1, 2);
            unint64_t v4 = *(void *)(v1 + 64);
          }
        }
        *uint64_t v9 = 0;
        uint64_t v16 = *(void *)(v1 + 72) - 1;
        unint64_t v17 = v4 + 1;
        *(void *)(v1 + 64) = v17;
        *(void *)(v1 + 72) = v16;
        if (v17 < 0x100) {
          goto LABEL_10;
        }
LABEL_9:
        operator delete(**(void ***)(v1 + 40));
        *(void *)(v1 + 40) += 8;
        *(void *)(v1 + 64) -= 128;
        goto LABEL_10;
      }
LABEL_8:
      uint64_t v11 = *(void *)(v1 + 72) - 1;
      unint64_t v12 = v4 + 1;
      *(void *)(v1 + 64) = v12;
      *(void *)(v1 + 72) = v11;
      if (v12 >= 0x100) {
        goto LABEL_9;
      }
LABEL_10:
      if (!v18)
      {
        std::runtime_error::runtime_error(&v20, "call to empty boost::function");
        v20.__vftable = (std::runtime_error_vtbl *)&unk_26CEC9AA0;
        boost::throw_exception<boost::bad_function_call>(&v20);
      }
      BOOL result = (*(uint64_t (**)(unsigned char *))((v18 & 0xFFFFFFFFFFFFFFFELL) + 8))(v19);
      if ((v18 & 1) == 0)
      {
        uint64_t v13 = *(uint64_t (**)(unsigned char *, unsigned char *, uint64_t))(v18 & 0xFFFFFFFFFFFFFFFELL);
        if (v13) {
          BOOL result = v13(v19, v19, 2);
        }
      }
      if (!*(void *)(v1 + 72)) {
        return result;
      }
    }
    (*(void (**)(uint64_t, unsigned char *, void))(v8 & 0xFFFFFFFFFFFFFFFELL))(v7 + 8, v19, 0);
    uint64_t v3 = *(void *)(v1 + 40);
    unint64_t v4 = *(void *)(v1 + 64);
    unint64_t v5 = v4 >> 7;
    uint64_t v6 = v4 & 0x7F;
LABEL_7:
    uint64_t v9 = (uint64_t *)(*(void *)(v3 + 8 * v5) + 32 * v6);
    uint64_t v10 = *v9;
    if (*v9) {
      goto LABEL_16;
    }
    goto LABEL_8;
  }
  return result;
}

void sub_21DEBEC5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::runtime_error a13)
{
}

void sub_21DEBEC78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_21DEBEC8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 452) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  unint64_t v4 = (_DWORD *)(v3 + 32);
  unint64_t v5 = *(BBUpdaterController **)(a1 + 16);
  FirmwareDataSource = BBUpdaterController::getFirmwareDataSource(v5, 0);
  BBUpdaterController::parsePreflightArgs(v5);
  BBUpdaterController::queryInfoFirstStageInternal((BBULoader **)v5, v7);
  if (FirmwareDataSource) {
    (*(void (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 16))(FirmwareDataSource);
  }
  _DWORD *v4 = 0;
  int v8 = *(_DWORD *)(a1 + 364);
  *(_DWORD *)(a1 + 304) = v8;
  *(void *)(a1 + 296) = *(void *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  switch(v8)
  {
    case 0:
      uint64_t v9 = (_DWORD *)(a1 + 412);
      goto LABEL_8;
    case 1:
      uint64_t v9 = (_DWORD *)(a1 + 400);
      goto LABEL_8;
    case 2:
      uint64_t v9 = (_DWORD *)(a1 + 388);
      goto LABEL_8;
    case 3:
      uint64_t v9 = (_DWORD *)(a1 + 376);
LABEL_8:
      ++*v9;
      break;
    default:
      break;
  }
  *(unsigned char *)(a1 + 368) = 0;
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1 + 280);
  _DWORD *v4 = 3;
  return 1;
}

void sub_21DEBEDAC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  _Unwind_Resume(exception_object);
}

void ctu::cf::ConvertToCFTypeRef::~ConvertToCFTypeRef(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventEUICC>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E888 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E880 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E878 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E870 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E868 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E860 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E858 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E850 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E848 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      qword_26AA8E840[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E840[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E840[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      unint64_t v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *unint64_t v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventEUICC>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventEUICC>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventEUICC>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      unint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *unint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          uint64_t v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8ECD8 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8ECD8 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEBF260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventEUICC>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventEUICC>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAA37ALL & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAA37ALL & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventEUICC>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  unint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA353 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA353 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEBFAC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeBooted,BBUpdaterControllerFSM::eventEUICC,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeEUICC,BBUpdaterControllerFSM::performAction<(BBUStage)32>,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(v3 + 24) = 2;
  BBUpdaterController::personalize(*(void *)(a1 + 16), 32);
  *(_DWORD *)(v3 + 24) = 2;
  ++*(_DWORD *)(a1 + 96);
  *(_DWORD *)(v3 + 24) = 3;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC>::execute(uint64_t a1, int a2)
{
  uint64_t v4 = a1 + 280;
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventEUICC,BBUpdaterControllerFSM::eventEUICC>(a1 + 280))
  {
    uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 304) + 48])(v4, 0);
    uint64_t v6 = v5;
    if (*(unsigned char *)(a1 + 369)) {
      BOOL v7 = 0;
    }
    else {
      BOOL v7 = v5 == 0;
    }
    if (v7) {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC>(v4, v4, *(_DWORD *)(a1 + 304));
    }
    *(unsigned char *)(a1 + 368) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v4);
  }
  else
  {
    uint64_t v6 = 1;
  }
  *(_DWORD *)(a1 + 4 * a2 + 32) = 3;
  return v6;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventEUICC>(uint64_t a1, uint64_t a2, char a3)
{
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventEUICC,BBUpdaterControllerFSM::eventEUICC>()) {
    return 1;
  }
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 24) + 48])(a1, 0);
  uint64_t v6 = v5;
  if (!*(unsigned char *)(a1 + 89) || (a3) && !v5) {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC>(a1, a1, *(_DWORD *)(a1 + 24));
  }
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  }
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventEUICC,BBUpdaterControllerFSM::eventEUICC>(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 88);
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v3 = operator new(0x20uLL);
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = 16 * (v4 - v5) - 1;
    *uint64_t v3 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventEUICC>;
    v3[1] = 0;
    v3[2] = a1;
    *((unsigned char *)v3 + 25) = 5;
    unint64_t v11 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventEUICC>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventEUICC>,boost::_bi::value<unsigned char>>>)::stored_vtable;
    v12[0] = v3;
    if (v4 == v5) {
      uint64_t v6 = 0;
    }
    unint64_t v7 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
    if (v6 == v7)
    {
      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 32));
      uint64_t v5 = *(void *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
    }
    char v8 = (void *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v7 & 0x7F));
    *char v8 = 0;
    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v8, (uint64_t *)&v11);
    ++*(void *)(a1 + 72);
    if (v11 && (v11 & 1) == 0)
    {
      int v9 = *(void (**)(void *, void *, uint64_t))(v11 & 0xFFFFFFFFFFFFFFFELL);
      if (v9) {
        v9(v12, v12, 2);
      }
    }
    return v2 == 0;
  }
  else
  {
    *(unsigned char *)(a1 + 88) = 1;
    return v2 == 0;
  }
}

void sub_21DEBFEF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventEUICC>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      uint64_t v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAA460 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAA460 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventEUICC>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA353 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA353 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEC0704(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventFuse>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E8D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E8D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E8C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E8C0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E8B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E8B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E8A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E8A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E898 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      qword_26AA8E890[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E890[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E890[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      unint64_t v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *unint64_t v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventFuse>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventFuse>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventFuse>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *uint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          uint64_t v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8ED30 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8ED30 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEC0C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventFuse>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventFuse>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAA579 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAA579 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventFuse>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  unsigned int v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA554 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA554 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unsigned int v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)unsigned int v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEC14B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,BBUpdaterControllerFSM::ControllerFSM_TOP::fuse,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(v3 + 32) = 3;
  uint64_t v4 = (_DWORD *)(v3 + 32);
  switch(*(_DWORD *)(a1 + 304))
  {
    case 0:
      char v5 = (_DWORD *)(a1 + 412);
      goto LABEL_6;
    case 1:
      char v5 = (_DWORD *)(a1 + 400);
      goto LABEL_6;
    case 2:
      char v5 = (_DWORD *)(a1 + 388);
      goto LABEL_6;
    case 3:
      char v5 = (_DWORD *)(a1 + 376);
LABEL_6:
      _DWORD *v5 = 0;
      break;
    default:
      break;
  }
  _DWORD *v4 = 3;
  uint64_t v6 = *(void *)(a1 + 16);
  long long v7 = (capabilities::updater *)capabilities::updater::supportsBBFusing((capabilities::updater *)a1);
  if (v7)
  {
    unsigned int valuePtr = capabilities::updater::intermittentFailureRetryCount(v7);
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 32), @"fuseRetrial");
    if (Value)
    {
      CFNumberRef v9 = Value;
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      uint64_t v10 = v6 + 152;
      size_t v11 = BBUFusing::create(*(capabilities::updater **)(v6 + 56), v6 + 152);
      if (v11) {
        goto LABEL_10;
      }
    }
    else
    {
      CFNumberRef v9 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, &valuePtr);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 32), @"fuseRetrial", v9);
      uint64_t v10 = v6 + 152;
      size_t v11 = BBUFusing::create(*(capabilities::updater **)(v6 + 56), v6 + 152);
      if (v11)
      {
LABEL_10:
        unint64_t v12 = v11;
        FirmwareDataSource = BBUpdaterController::getFirmwareDataSource((BBUpdaterController *)v6, 0);
        uint64_t v17 = FirmwareDataSource;
        if (FirmwareDataSource)
        {
          if ((*(uint64_t (**)(BBUEUR10UpdateSource *))(*(void *)FirmwareDataSource + 64))(FirmwareDataSource))
          {
            unsigned int v24 = (*(uint64_t (**)(_DWORD *, BBUEUR10UpdateSource *, void))(*(void *)v12 + 16))(v12, v17, 0);
            if (v24)
            {
              if (gBBULogMaskGet(void)::once == -1)
              {
                if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
                  goto LABEL_18;
                }
              }
              else
              {
                dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
                  goto LABEL_18;
                }
              }
              if ((gBBULogVerbosity & 0x80000000) == 0) {
                _BBULog(19, 0, "BBUpdaterController", "", "Failed performing fusing with %d trials\n", v21, v22, v23, valuePtr);
              }
LABEL_18:
              if (valuePtr--)
              {
                (*(void (**)(void, void))(**(void **)(v6 + 72) + 32))(*(void *)(v6 + 72), *(void *)(v6 + 48));
                if (gBBULogMaskGet(void)::once == -1)
                {
                  if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
                    goto LABEL_23;
                  }
                }
                else
                {
                  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                  if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
                    goto LABEL_23;
                  }
                }
                if (gBBULogVerbosity >= 6) {
                  _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v26, v27, v28, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
                }
LABEL_23:
                std::to_string(&v79, valuePtr);
                uint64_t v29 = std::string::insert(&v79, 0, "Failed performing fusing. Retry: ", 0x21uLL);
                uint64_t v31 = (std::string::value_type *)v29->__r_.__value_.__r.__words[0];
                std::string::size_type size = v29->__r_.__value_.__l.__size_;
                v80[0] = v29->__r_.__value_.__r.__words[2];
                *(_DWORD *)((char *)v80 + 3) = *(_DWORD *)((char *)&v29->__r_.__value_.__r.__words[2] + 3);
                int v32 = SHIBYTE(v29->__r_.__value_.__r.__words[2]);
                v29->__r_.__value_.__l.__size_ = 0;
                v29->__r_.__value_.__r.__words[2] = 0;
                v29->__r_.__value_.__r.__words[0] = 0;
                unsigned int v33 = valuePtr;
                if (v32 < 0)
                {
                  std::string::__init_copy_ctor_external(&v82, v31, size);
                }
                else
                {
                  v82.__r_.__value_.__r.__words[0] = (std::string::size_type)v31;
                  v82.__r_.__value_.__l.__size_ = size;
                  LODWORD(v82.__r_.__value_.__r.__words[2]) = v80[0];
                  *(_DWORD *)((char *)&v82.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v80 + 3);
                  *((unsigned char *)&v82.__r_.__value_.__s + 23) = v32;
                }
                unint64_t v83 = __PAIR64__(v33, v24);
                BBUpdaterController::process_event<BBUpdaterControllerFSM::eventRetry>(v6, (uint64_t)&v82);
                if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(v82.__r_.__value_.__l.__data_);
                  if ((v32 & 0x80000000) == 0)
                  {
LABEL_55:
                    if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
LABEL_56:
                      uint64_t v62 = (const void **)MEMORY[0x263EFFB38];
                      goto LABEL_57;
                    }
LABEL_67:
                    operator delete(v79.__r_.__value_.__l.__data_);
                    goto LABEL_56;
                  }
                }
                else if ((v32 & 0x80000000) == 0)
                {
                  goto LABEL_55;
                }
                operator delete(v31);
                if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_56;
                }
                goto LABEL_67;
              }
              if (gBBULogMaskGet(void)::once == -1)
              {
                if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
                  goto LABEL_47;
                }
              }
              else
              {
                dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
                {
LABEL_47:
                  if (gBBULogVerbosity >= 6) {
                    _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v21, v22, v23, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
                  }
                }
              }
              unint64_t v63 = (char *)operator new(0x20uLL);
              strcpy(v63, "Failed performing fusing.");
              std::string::__init_copy_ctor_external(&v82, v63, 0x19uLL);
              unint64_t v83 = v24;
              BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
              if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v82.__r_.__value_.__l.__data_);
              }
              operator delete(v63);
              goto LABEL_56;
            }
            if (gBBULogMaskGet(void)::once == -1)
            {
              if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
                goto LABEL_42;
              }
            }
            else
            {
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
              if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 8) == 0) {
                goto LABEL_42;
              }
            }
            if (gBBULogVerbosity >= 1) {
              _BBULog(19, 1, "BBUpdaterController", "", "Succeeded to perform fusing with %d trials\n", v21, v22, v23, valuePtr);
            }
LABEL_42:
            (*(void (**)(void, uint64_t))(**(void **)(v6 + 64) + 40))(*(void *)(v6 + 64), v10);
            BBUFeedback::handleComment(*(BBUFeedback **)(v6 + 56), "Powercycle after fusing");
            if ((*(uint64_t (**)(void, void))(**(void **)(v6 + 72) + 32))(*(void *)(v6 + 72), *(void *)(v6 + 48)))
            {
              BBUpdaterController::process_event<BBUpdaterControllerFSM::eventContinue>(*(int **)(v6 + 16), *(std::__shared_weak_count **)(v6 + 24), (uint64_t)&v82);
LABEL_44:
              uint64_t v62 = (const void **)MEMORY[0x263EFFB40];
LABEL_57:
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 32), @"fuseAttemptSucceeded", *v62);
LABEL_58:
              if (v9) {
                CFRelease(v9);
              }
              CFNumberRef v64 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, &valuePtr);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 32), @"fuseRetrial", v64);
              if (v64) {
                CFRelease(v64);
              }
              if (v17) {
                (*(void (**)(BBUEUR10UpdateSource *))(*(void *)v17 + 16))(v17);
              }
              goto LABEL_64;
            }
            if (gBBULogMaskGet(void)::once == -1)
            {
              if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
                goto LABEL_127;
              }
            }
            else
            {
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
              if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
              {
LABEL_127:
                if (gBBULogVerbosity >= 6) {
                  _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v59, v60, v61, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
                }
              }
            }
            char v74 = (char *)operator new(0x28uLL);
            strcpy(v74, "Fail to powercycle modem after fusing");
            std::string::__init_copy_ctor_external(&v82, v74, 0x25uLL);
            unint64_t v83 = 39;
            BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
            if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v82.__r_.__value_.__l.__data_);
            }
            operator delete(v74);
            goto LABEL_44;
          }
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
              goto LABEL_80;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
            {
LABEL_80:
              if (gBBULogVerbosity >= 6) {
                _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v18, v19, v20, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
              }
            }
          }
          uint64_t v66 = (char *)operator new(0x40uLL);
          strcpy(v66, "Fusing is requested but no fusing program was given yet. ");
          std::string::__init_copy_ctor_external(&v82, v66, 0x39uLL);
          unint64_t v83 = 24;
          BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
          goto LABEL_83;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
            goto LABEL_70;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
          {
LABEL_70:
            if (gBBULogVerbosity >= 6) {
              _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v14, v15, v16, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
            }
          }
        }
        uint64_t v66 = (char *)operator new(0x28uLL);
        strcpy(v66, "Fail to get update source for fuse");
        std::string::__init_copy_ctor_external(&v82, v66, 0x22uLL);
        unint64_t v83 = 35;
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
LABEL_83:
        if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v82.__r_.__value_.__l.__data_);
        }
        operator delete(v66);
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v6 + 32), @"fuseAttemptSucceeded");
        goto LABEL_58;
      }
    }
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 24, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x31Au, (ctu::LogMessageBuffer *)"Assertion failure(fuser && \"Error in creating fusing process.\")", v56, v57, v58, v78);
LABEL_135:
  }
  uint64_t v34 = BBUFusing::create(*(capabilities::updater **)(v6 + 56), v6 + 152);
  if (!v34)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 24, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp", 0x367u, (ctu::LogMessageBuffer *)"Assertion failure(fuser && \"Error in creating fusing process.\")", v75, v76, v77, v78);
    goto LABEL_135;
  }
  unint64_t v12 = v34;
  unint64_t v35 = BBUpdaterController::getFirmwareDataSource((BBUpdaterController *)v6, 0);
  uint64_t v39 = v35;
  if (!v35)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_75;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_75:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v36, v37, v38, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    long long v67 = (char *)operator new(0x28uLL);
    strcpy(v67, "Fail to get update source for fuse");
    std::string::__init_copy_ctor_external(&v82, v67, 0x22uLL);
    unint64_t v83 = 35;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
    goto LABEL_91;
  }
  if ((*(uint64_t (**)(BBUEUR10UpdateSource *))(*(void *)v35 + 64))(v35))
  {
    unsigned int v46 = (*(uint64_t (**)(_DWORD *, BBUEUR10UpdateSource *, void))(*(void *)v12 + 16))(v12, v39, 0);
    if (!v46)
    {
      unsigned int v50 = (*(uint64_t (**)(void, uint64_t, void))(**(void **)(v6 + 72) + 72))(*(void *)(v6 + 72), v6 + 152, *(void *)(v6 + 96));
      if (!v50)
      {
        (*(void (**)(void, uint64_t))(**(void **)(v6 + 64) + 40))(*(void *)(v6 + 64), v6 + 152);
        BBUFeedback::handleComment(*(BBUFeedback **)(v6 + 56), "Powercycle after fusing");
        if ((*(uint64_t (**)(void, void))(**(void **)(v6 + 72) + 32))(*(void *)(v6 + 72), *(void *)(v6 + 48)))
        {
          BBUpdaterController::process_event<BBUpdaterControllerFSM::eventContinue>(*(int **)(v6 + 16), *(std::__shared_weak_count **)(v6 + 24), (uint64_t)&v82);
          goto LABEL_32;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
            goto LABEL_114;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
          {
LABEL_114:
            if (gBBULogVerbosity >= 6) {
              _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v51, v52, v53, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
            }
          }
        }
        uint64_t v73 = (char *)operator new(0x28uLL);
        strcpy(v73, "Fail to powercycle modem after fusing");
        std::string::__init_copy_ctor_external(&v82, v73, 0x25uLL);
        unint64_t v83 = 39;
        BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
        if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v82.__r_.__value_.__l.__data_);
        }
        operator delete(v73);
        goto LABEL_32;
      }
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
          goto LABEL_104;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
        {
LABEL_104:
          if (gBBULogVerbosity >= 6) {
            _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v47, v48, v49, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
          }
        }
      }
      unint64_t v69 = (char *)operator new(0x30uLL);
      strcpy(v69, "Failed gathering personalization parameters");
      std::string::__init_copy_ctor_external(&v82, v69, 0x2BuLL);
      unint64_t v83 = v50;
      BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
      if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v82.__r_.__value_.__l.__data_);
      }
      operator delete(v69);
      if (gBBULogMaskGet(void)::once == -1)
      {
        uint64_t v54 = (const void **)MEMORY[0x263EFFB40];
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_33;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        uint64_t v54 = (const void **)MEMORY[0x263EFFB40];
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_33;
        }
      }
      if (gBBULogVerbosity < 6) {
        goto LABEL_33;
      }
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v70, v71, v72, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
LABEL_32:
      uint64_t v54 = (const void **)MEMORY[0x263EFFB40];
LABEL_33:
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 32), @"fuseAttemptSucceeded", *v54);
LABEL_34:
      (*(void (**)(BBUEUR10UpdateSource *))(*(void *)v39 + 16))(v39);
      goto LABEL_64;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
        goto LABEL_97;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
      {
LABEL_97:
        if (gBBULogVerbosity >= 6) {
          _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v43, v44, v45, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
        }
      }
    }
    uint64_t v68 = (char *)operator new(0x20uLL);
    strcpy(v68, "Failed performing fusing.");
    std::string::__init_copy_ctor_external(&v82, v68, 0x19uLL);
    unint64_t v83 = v46;
    BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
    if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v82.__r_.__value_.__l.__data_);
    }
    operator delete(v68);
    uint64_t v54 = (const void **)MEMORY[0x263EFFB38];
    goto LABEL_33;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0) {
      goto LABEL_88;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) != 0)
    {
LABEL_88:
      if (gBBULogVerbosity >= 6) {
        _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v40, v41, v42, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
      }
    }
  }
  long long v67 = (char *)operator new(0x40uLL);
  strcpy(v67, "Fusing is requested but no fusing program was given yet. ");
  std::string::__init_copy_ctor_external(&v82, v67, 0x39uLL);
  unint64_t v83 = 24;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v6, (uint64_t)&v82);
LABEL_91:
  if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v82.__r_.__value_.__l.__data_);
  }
  operator delete(v67);
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v6 + 32), @"fuseAttemptSucceeded");
  if (v39) {
    goto LABEL_34;
  }
LABEL_64:
  (*(void (**)(_DWORD *))(*(void *)v12 + 8))(v12);
  _DWORD *v4 = 3;
  ++*(_DWORD *)(a1 + 268);
  _DWORD *v4 = 4;
  return 1;
}

void sub_21DEC2720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  operator delete(v29);
  (*(void (**)(uint64_t))(*(void *)v28 + 16))(v28);
  (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventProvision>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E928 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E920 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E918 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E910 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E908 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E900 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E8F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E8F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E8E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      qword_26AA8E8E0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E8E0[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E8E0[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      unint64_t v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *unint64_t v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventProvision>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventProvision>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventProvision>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *uint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          uint64_t v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8ED88 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8ED88 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEC2DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventProvision>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventProvision>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAA688 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAA688 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventProvision>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  unint64_t v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA65DLL & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA65DLL & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    unint64_t v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    unint64_t v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    uint64_t v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    uint64_t v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      uint64_t v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)uint64_t v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    uint64_t v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      uint64_t v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEC3644(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::front::none,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 4 * a2;
  *(_DWORD *)(v2 + 32) = 3;
  uint64_t v3 = (_DWORD *)(v2 + 32);
  switch(*(_DWORD *)(a1 + 304))
  {
    case 0:
      uint64_t v4 = (_DWORD *)(a1 + 412);
      goto LABEL_6;
    case 1:
      uint64_t v4 = (_DWORD *)(a1 + 400);
      goto LABEL_6;
    case 2:
      uint64_t v4 = (_DWORD *)(a1 + 388);
      goto LABEL_6;
    case 3:
      uint64_t v4 = (_DWORD *)(a1 + 376);
LABEL_6:
      _DWORD *v4 = 0;
      break;
    default:
      break;
  }
  *uint64_t v3 = 3;
  int v5 = *(_DWORD *)(a1 + 228);
  *(_DWORD *)(a1 + 168) = v5;
  *(void *)(a1 + 160) = *(void *)(a1 + 16);
  if (!v5)
  {
    int v6 = (_DWORD *)(a1 + 252);
    goto LABEL_11;
  }
  if (v5 == 1)
  {
    int v6 = (_DWORD *)(a1 + 240);
LABEL_11:
    ++*v6;
  }
  *(unsigned char *)(a1 + 232) = 0;
  boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1 + 144);
  *uint64_t v3 = 5;
  return 1;
}

uint64_t *std::__tree<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>,BBUpdaterController::CFStringCompareFunctor,true>,std::allocator<std::__value_type<__CFString const*,BBUpdaterController::CmdInfo>>>::__emplace_unique_key_args<__CFString const*,std::piecewise_construct_t const&,std::tuple<__CFString const*&&>,std::tuple<>>(CFStringRef *a1, uint64_t **a2)
{
  uint64_t v3 = qword_26AA8E468;
  if (!qword_26AA8E468)
  {
    int v5 = &qword_26AA8E468;
    int v6 = &qword_26AA8E468;
LABEL_9:
    long long v7 = (uint64_t *)operator new(0x38uLL);
    v7[4] = **a2;
    v7[5] = 0;
    v7[6] = 0;
    *long long v7 = 0;
    v7[1] = 0;
    unint64_t v7[2] = (uint64_t)v6;
    uint64_t *v5 = (uint64_t)v7;
    char v8 = v7;
    if (*(void *)qword_26AA8E460)
    {
      qword_26AA8E460 = *(void *)qword_26AA8E460;
      char v8 = (uint64_t *)*v5;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_26AA8E468, v8);
    ++qword_26AA8E470;
    return v7;
  }
  int v5 = &qword_26AA8E468;
  while (1)
  {
    while (1)
    {
      int v6 = (uint64_t *)v3;
      if ((CFStringCompare(*a1, *(CFStringRef *)(v3 + 32), 0) & 0x8000000000000000) == 0) {
        break;
      }
      uint64_t v3 = *v6;
      int v5 = v6;
      if (!*v6) {
        goto LABEL_9;
      }
    }
    if ((CFStringCompare((CFStringRef)v6[4], *a1, 0) & 0x8000000000000000) == 0) {
      break;
    }
    int v5 = v6 + 1;
    uint64_t v3 = v6[1];
    if (!v3) {
      goto LABEL_9;
    }
  }
  long long v7 = (uint64_t *)*v5;
  if (!*v5) {
    goto LABEL_9;
  }
  return v7;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformNextStage>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v6 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v7 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v8 = 1;
  if ((v6 & 1) == 0 && (v7 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v10 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v9 & 1) != 0 || v10)
    {
      qword_26AA8E978 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E970 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E968 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E960 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E958 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E950 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E948 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E940 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E938 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      qword_26AA8E930[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false;
      char v12 = ((uint64_t (*)(uint64_t))qword_26AA8E930[*(int *)(a1 + 32)])(a1);
      int v13 = ((uint64_t (*)(uint64_t))qword_26AA8E930[*(int *)(a1 + 36)])(a1);
      if ((v12 & 1) == 0 && !v13) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      if (*(char *)(a2 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&v29, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
        std::string::size_type v11 = *(void *)(a2 + 24);
        std::string::size_type v30 = v11;
        if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_8:
          std::string v43 = v29;
          v44.__r_.__value_.__r.__words[0] = v11;
          if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_9;
          }
          goto LABEL_23;
        }
      }
      else
      {
        *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)a2;
        std::string::size_type v11 = *(void *)(a2 + 24);
        v29.__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
        std::string::size_type v30 = v11;
        if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_8;
        }
      }
      std::string::__init_copy_ctor_external(&v43, v29.__r_.__value_.__l.__data_, v29.__r_.__value_.__l.__size_);
      std::string::size_type v11 = v30;
      v44.__r_.__value_.__r.__words[0] = v30;
      if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_9:
        std::string v47 = v43;
        __p.__r_.__value_.__r.__words[0] = v11;
        if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_10;
        }
        goto LABEL_24;
      }
LABEL_23:
      std::string::__init_copy_ctor_external(&v47, v43.__r_.__value_.__l.__data_, v43.__r_.__value_.__l.__size_);
      std::string::size_type v11 = v44.__r_.__value_.__r.__words[0];
      __p.__r_.__value_.__r.__words[0] = v44.__r_.__value_.__r.__words[0];
      if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_10:
        std::string v51 = v47;
        v52.__r_.__value_.__r.__words[0] = v11;
        *(void *)long long v55 = a1;
        if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_11:
          *(_OWORD *)&v55[8] = *(_OWORD *)&v51.__r_.__value_.__l.__data_;
          v56.__r_.__value_.__r.__words[0] = v51.__r_.__value_.__r.__words[2];
          v56.__r_.__value_.__l.__size_ = v11;
          goto LABEL_27;
        }
LABEL_25:
        std::string::__init_copy_ctor_external((std::string *)&v55[8], v51.__r_.__value_.__l.__data_, v51.__r_.__value_.__l.__size_);
        v56.__r_.__value_.__l.__size_ = v52.__r_.__value_.__r.__words[0];
        if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v51.__r_.__value_.__l.__data_);
        }
LABEL_27:
        v56.__r_.__value_.__s.__data_[16] = 5;
        if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v47.__r_.__value_.__l.__data_);
        }
        *(void *)&long long v31 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
        *((void *)&v31 + 1) = 0;
        std::string::size_type v32 = *(void *)v55;
        if (v56.__r_.__value_.__s.__data_[7] < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&v33, *(const std::string::value_type **)&v55[8], *(std::string::size_type *)&v55[16]);
          *((void *)&v34 + 1) = v56.__r_.__value_.__l.__size_;
          std::string::value_type v35 = v56.__r_.__value_.__s.__data_[16];
          if (v56.__r_.__value_.__s.__data_[7] < 0) {
            operator delete(*(void **)&v55[8]);
          }
        }
        else
        {
          long long v33 = *(_OWORD *)&v55[8];
          long long v34 = *(_OWORD *)&v56.__r_.__value_.__l.__data_;
          std::string::value_type v35 = v56.__r_.__value_.__s.__data_[16];
        }
        if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v43.__r_.__value_.__l.__data_);
        }
        long long v38 = v31;
        std::string::size_type v15 = v32;
        std::string::size_type v39 = v32;
        if (SBYTE7(v34) < 0)
        {
          std::string::__init_copy_ctor_external(&v40, (const std::string::value_type *)v33, *((std::string::size_type *)&v33 + 1));
          std::string::size_type v15 = v39;
        }
        else
        {
          *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v33;
          v40.__r_.__value_.__r.__words[2] = v34;
        }
        std::string::size_type v16 = *((void *)&v34 + 1);
        std::string::size_type v41 = *((void *)&v34 + 1);
        std::string::value_type v17 = v35;
        std::string::value_type v42 = v35;
        unint64_t v36 = 0;
        *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v38;
        v43.__r_.__value_.__r.__words[2] = v15;
        if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(&v44, v40.__r_.__value_.__l.__data_, v40.__r_.__value_.__l.__size_);
          std::string::size_type v16 = v41;
          std::string::value_type v17 = v42;
          std::string::size_type v15 = v43.__r_.__value_.__r.__words[2];
        }
        else
        {
          std::string v44 = v40;
        }
        std::string::size_type v45 = v16;
        std::string::value_type v46 = v17;
        *(_OWORD *)&v47.__r_.__value_.__l.__data_ = *(_OWORD *)&v43.__r_.__value_.__l.__data_;
        v47.__r_.__value_.__r.__words[2] = v15;
        if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(&__p, v44.__r_.__value_.__l.__data_, v44.__r_.__value_.__l.__size_);
          std::string::size_type v15 = v47.__r_.__value_.__r.__words[2];
          std::string::size_type v16 = v45;
          std::string::value_type v17 = v46;
        }
        else
        {
          std::string __p = v44;
        }
        std::string::size_type v49 = v16;
        std::string::value_type v50 = v17;
        *(_OWORD *)&v51.__r_.__value_.__l.__data_ = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
        v51.__r_.__value_.__r.__words[2] = v15;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(&v52, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          std::string::size_type v16 = v49;
          std::string::value_type v17 = v50;
          std::string::size_type v15 = v51.__r_.__value_.__r.__words[2];
        }
        else
        {
          std::string v52 = __p;
        }
        std::string::size_type v53 = v16;
        std::string::value_type v54 = v17;
        *(_OWORD *)long long v55 = *(_OWORD *)&v51.__r_.__value_.__l.__data_;
        *(void *)&v55[16] = v15;
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(&v56, v52.__r_.__value_.__l.__data_, v52.__r_.__value_.__l.__size_);
          std::string::size_type v16 = v53;
          std::string::value_type v17 = v54;
        }
        else
        {
          std::string v56 = v52;
        }
        std::string::size_type v57 = v16;
        std::string::value_type v58 = v17;
        uint64_t v18 = (std::string *)operator new(0x40uLL);
        *(_OWORD *)&v18->__r_.__value_.__l.__data_ = *(_OWORD *)v55;
        v18->__r_.__value_.__r.__words[2] = *(void *)&v55[16];
        uint64_t v19 = v18 + 1;
        if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
        {
          std::string::__init_copy_ctor_external(v19, v56.__r_.__value_.__l.__data_, v56.__r_.__value_.__l.__size_);
          std::string::value_type v20 = v58;
          int v21 = SHIBYTE(v56.__r_.__value_.__r.__words[2]);
          v18[2].__r_.__value_.__r.__words[0] = v57;
          v18[2].__r_.__value_.__s.__data_[8] = v20;
          v37[0] = (uint64_t)v18;
          if (v21 < 0) {
            operator delete(v56.__r_.__value_.__l.__data_);
          }
        }
        else
        {
          *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)&v56.__r_.__value_.__l.__data_;
          v18[1].__r_.__value_.__r.__words[2] = v56.__r_.__value_.__r.__words[2];
          v18[2].__r_.__value_.__r.__words[0] = v16;
          v18[2].__r_.__value_.__s.__data_[8] = v17;
          v37[0] = (uint64_t)v18;
        }
        if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v52.__r_.__value_.__l.__data_);
          if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_56:
            unint64_t v36 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>)::stored_vtable;
            if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_57;
            }
            goto LABEL_73;
          }
        }
        else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_56;
        }
        operator delete(__p.__r_.__value_.__l.__data_);
        unint64_t v36 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>)::stored_vtable;
        if ((SHIBYTE(v44.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_57:
          if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_58;
          }
LABEL_74:
          operator delete(v40.__r_.__value_.__l.__data_);
LABEL_58:
          uint64_t v22 = *(void *)(a1 + 56);
          uint64_t v23 = *(void *)(a1 + 48);
          uint64_t v24 = 16 * (v22 - v23) - 1;
          if (v22 == v23) {
            uint64_t v24 = 0;
          }
          unint64_t v25 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
          if (v24 == v25)
          {
            std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
            uint64_t v23 = *(void *)(a1 + 48);
            unint64_t v25 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
          }
          uint64_t v26 = (void *)(*(void *)(v23 + ((v25 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v25 & 0x7F));
          *uint64_t v26 = 0;
          boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v26, (uint64_t *)&v36);
          ++*(void *)(a1 + 80);
          if (v36)
          {
            if ((v36 & 1) == 0)
            {
              uint64_t v27 = *(void (**)(uint64_t *, _WORD *, int))(v36 & 0xFFFFFFFFFFFFFFFELL);
              if (v27) {
                v27(v37, v37, 2);
              }
            }
            unint64_t v36 = 0;
          }
          if (SBYTE7(v34) < 0)
          {
            operator delete((void *)v33);
            if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              return 1;
            }
          }
          else if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            return 1;
          }
          operator delete(v29.__r_.__value_.__l.__data_);
          return 1;
        }
LABEL_73:
        operator delete(v44.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v40.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_58;
        }
        goto LABEL_74;
      }
LABEL_24:
      std::string::__init_copy_ctor_external(&v51, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
      std::string::size_type v11 = __p.__r_.__value_.__r.__words[0];
      v52.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__r.__words[0];
      *(void *)long long v55 = a1;
      if ((SHIBYTE(v51.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_11;
      }
      goto LABEL_25;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v14 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EDE0 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v8 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EDE0 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v14;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v8)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v8;
}

void sub_21DEC41D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  operator delete(v61);
  if (*(char *)(v62 - 81) < 0)
  {
    operator delete(*(void **)(v62 - 104));
    if ((*(char *)(v62 - 145) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((*(char *)(v62 - 145) & 0x80000000) == 0)
  {
LABEL_3:
    if (a61 < 0) {
      goto LABEL_4;
    }
    goto LABEL_10;
  }
  operator delete(*(void **)(v62 - 168));
  if (a61 < 0)
  {
LABEL_4:
    operator delete(__p);
    if ((a50 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  if ((a50 & 0x80000000) == 0)
  {
LABEL_5:
    if (a39 < 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a45);
  if (a39 < 0)
  {
LABEL_6:
    operator delete(a34);
    if ((a24 & 0x80000000) == 0)
    {
LABEL_14:
      if (a14 < 0) {
        operator delete(a9);
      }
      _Unwind_Resume(a1);
    }
LABEL_13:
    operator delete(a19);
    goto LABEL_14;
  }
LABEL_12:
  if ((a24 & 0x80000000) == 0) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformNextStage>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>::manage(uint64_t *a1, _WORD *a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      char v6 = (std::string *)operator new(0x40uLL);
      *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)v5;
      v6->__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
      char v7 = v6 + 1;
      if (*(char *)(v5 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(v5 + 24), *(void *)(v5 + 32));
      }
      else
      {
        long long v8 = *(_OWORD *)(v5 + 24);
        v6[1].__r_.__value_.__r.__words[2] = *(void *)(v5 + 40);
        *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
      }
      v6[2].__r_.__value_.__r.__words[0] = *(void *)(v5 + 48);
      v6[2].__r_.__value_.__s.__data_[8] = *(unsigned char *)(v5 + 56);
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      uint64_t v9 = *(void *)a2;
      if (*(void *)a2)
      {
        if (*(char *)(v9 + 47) < 0) {
          operator delete(*(void **)(v9 + 24));
        }
        operator delete((void *)v9);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      int v10 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v10 == (const char *)(0x800000021DFAA7A7 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v10, (const char *)(0x800000021DFAA7A7 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
}

void sub_21DEC4528(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[56];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)std::string __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  long long v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  char v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  int v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA772 & 0x7FFFFFFFFFFFFFFFLL));
  int v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA772 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    unint64_t v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      uint64_t v23 = __dst;
      goto LABEL_21;
    }
    unint64_t v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    uint64_t v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  uint64_t v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string::size_type v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    std::string::value_type v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    std::string::value_type v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    uint64_t v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    uint64_t v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::size_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)std::string::size_type v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEC4C30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeEUICC,BBUpdaterControllerFSM::eventCmdPerformNextStage,boost::msm::front::none,BBUpdaterControllerFSM::performAction<(BBUStage)32>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 100);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  uint64_t v11 = -1;
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0 && (gBBULogVerbosity & 0x80000000) == 0)
  {
    _BBULog(21, 0, "allowRetry", "", "Retry limits are src.retryLimit:%u  evt.retryLimit:%u src.retryCounter:%u\n", a6, a7, a8, *(_DWORD *)(a1 + 100));
    uint64_t v11 = gBBULogMaskGet(void)::once;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 28);
  int v14 = *(_DWORD *)(a1 + 96);
  unsigned int v13 = *(_DWORD *)(a1 + 100);
  if (v13 >= v12) {
    unsigned int v13 = *(_DWORD *)(a4 + 28);
  }
  if (v12) {
    unsigned int v15 = v13;
  }
  else {
    unsigned int v15 = v10;
  }
  unsigned int v16 = v14 + 1;
  *(_DWORD *)(a1 + 96) = v14 + 1;
  if (v11 == -1)
  {
    uint64_t v17 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
    int v18 = gBBULogVerbosity;
    if (v16 > v15) {
      goto LABEL_13;
    }
LABEL_23:
    if ((v17 & 0x200000) != 0 && (v18 & 0x80000000) == 0) {
      _BBULog(21, 0, "allowRetry", "", "Clearing error states since we are retrying.\n", a6, a7, a8, v32);
    }
    pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    size_t v22 = qword_26AA89AB0;
    if (!qword_26AA89AB0)
    {
      uint64_t v23 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
      object[0] = 0;
      ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v23, "BBUError", QOS_CLASS_UTILITY, object);
      if (object[0]) {
        dispatch_release(object[0]);
      }
      v23->__on_zero_shared_weauint64_t k = 0;
      v23[1].~__shared_weak_count = 0;
      v23[1].~__shared_weak_count_0 = 0;
      std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&block, v23);
      long long v24 = *(_OWORD *)&block.__r_.__value_.__l.__data_;
      *(_OWORD *)&block.__r_.__value_.__l.__data_ = 0uLL;
      unint64_t v25 = (std::__shared_weak_count *)off_26AA89AB8;
      *(_OWORD *)&qword_26AA89AB0 = v24;
      if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
      std::string::size_type size = (std::__shared_weak_count *)block.__r_.__value_.__l.__size_;
      if (block.__r_.__value_.__l.__size_
        && !atomic_fetch_add((atomic_ullong *volatile)(block.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
      size_t v22 = qword_26AA89AB0;
    }
    uint64_t v27 = (std::__shared_weak_count *)off_26AA89AB8;
    if (off_26AA89AB8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
    object[0] = (dispatch_object_t)MEMORY[0x263EF8330];
    object[1] = (dispatch_object_t)0x40000000;
    object[2] = (dispatch_object_t)___ZN8BBUError11clearErrorsEv_block_invoke;
    object[3] = (dispatch_object_t)&__block_descriptor_tmp_9;
    object[4] = v22;
    uint64_t v34 = object;
    block.__r_.__value_.__r.__words[0] = MEMORY[0x263EF8330];
    block.__r_.__value_.__l.__size_ = 0x40000000;
    block.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
    unint64_t v36 = (unint64_t)&__block_descriptor_tmp_13_0;
    uint64_t v37 = v22;
    uint64_t v38 = &v34;
    isa = v22[2].isa;
    if (v22[3].isa)
    {
      dispatch_async_and_wait(isa, &block);
      if (!v27) {
        goto LABEL_44;
      }
    }
    else
    {
      dispatch_sync(isa, &block);
      if (!v27) {
        goto LABEL_44;
      }
    }
    if (!atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
LABEL_44:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0) {
        goto LABEL_46;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 2) & 0x20) != 0)
      {
LABEL_46:
        if ((gBBULogVerbosity & 0x80000000) == 0) {
          _BBULog(21, 0, "allowRetry", "", "attempting %u out of %u\n", v29, v30, v31, *(_DWORD *)(a1 + 96));
        }
      }
    }
    BBUpdaterController::personalize(*(void *)(a1 + 16), 32);
    return 1;
  }
  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  uint64_t v17 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
  int v18 = gBBULogVerbosity;
  if (v16 <= v15) {
    goto LABEL_23;
  }
LABEL_13:
  if ((v17 & 2) != 0 && (v18 & 0x80000000) == 0) {
    _BBULog(1, 0, "allowRetry", "", "too many retries: %u\n", a6, a7, a8, v15);
  }
  uint64_t v19 = *(void *)(a1 + 16);
  unsigned int v20 = *(_DWORD *)(a4 + 24);
  if (*(char *)(a4 + 23) < 0) {
    std::string::__init_copy_ctor_external(&block, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else {
    blocuint64_t k = *(std::string *)a4;
  }
  unint64_t v36 = v20;
  BBUpdaterController::process_event<BBUpdaterControllerFSM::eventError>(v19, (uint64_t)&block);
  if (SHIBYTE(block.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(block.__r_.__value_.__l.__data_);
  }
  return 2;
}

void sub_21DEC51BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, dispatch_object_t object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (object) {
    dispatch_release(object);
  }
  operator delete(v24);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeBooted,BBUpdaterControllerFSM::performAction<(BBUStage)4>,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(v3 + 24) = 1;
  BBUpdaterController::personalize(*(void *)(a1 + 16), 4);
  *(_DWORD *)(v3 + 24) = 1;
  ++*(_DWORD *)(a1 + 108);
  *(_DWORD *)(v3 + 24) = 2;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeFirst,BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::performAction<(BBUStage)2>,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  BBUpdaterController::personalize(*(void *)(a1 + 16), 2);
  *(_DWORD *)(v3 + 24) = 0;
  ++*(_DWORD *)(a1 + 120);
  *(_DWORD *)(v3 + 24) = 1;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionFinish,BBUpdaterControllerFSM::eventCmdPerformNextStage,boost::msm::front::none,BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::finishProvision,boost::msm::front::none>>::execute(uint64_t a1)
{
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionStart,BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionFinish,BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::startProvision,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  BBUpdaterController::provision(*(void *)(a1 + 16), 1);
  *(_DWORD *)(v3 + 24) = 0;
  ++*(_DWORD *)(a1 + 96);
  *(_DWORD *)(v3 + 24) = 1;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>::execute(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1 + 280;
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::eventCmdPerformNextStage>(a1 + 280, a4))
  {
    uint64_t v7 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 304) + 53])(v6, 0);
    uint64_t v8 = v7;
    if (*(unsigned char *)(a1 + 369)) {
      BOOL v9 = 0;
    }
    else {
      BOOL v9 = v7 == 0;
    }
    if (v9) {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(v6, v6, *(_DWORD *)(a1 + 304));
    }
    *(unsigned char *)(a1 + 368) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v6);
  }
  else
  {
    uint64_t v8 = 1;
  }
  *(_DWORD *)(a1 + 4 * a2 + 32) = 3;
  return v8;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformNextStage>(uint64_t a1, uint64_t a2, char a3)
{
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::eventCmdPerformNextStage>()) {
    return 1;
  }
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 24) + 53])(a1, 0);
  uint64_t v6 = v5;
  if (!*(unsigned char *)(a1 + 89) || (a3) && !v5) {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(a1, a1, *(_DWORD *)(a1 + 24));
  }
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  }
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::eventCmdPerformNextStage>(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 88);
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      std::string::size_type v5 = *(void *)(a2 + 24);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_4:
        std::string v34 = v20;
        v35.__r_.__value_.__r.__words[0] = v5;
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_5;
        }
        goto LABEL_12;
      }
    }
    else
    {
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *(_OWORD *)a2;
      std::string::size_type v5 = *(void *)(a2 + 24);
      v20.__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }
    std::string::__init_copy_ctor_external(&v34, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v21;
    v35.__r_.__value_.__r.__words[0] = v21;
    if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_5:
      std::string v38 = v34;
      v39.__r_.__value_.__r.__words[0] = v5;
      if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_13;
    }
LABEL_12:
    std::string::__init_copy_ctor_external(&v38, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v35.__r_.__value_.__r.__words[0];
    v39.__r_.__value_.__r.__words[0] = v35.__r_.__value_.__r.__words[0];
    if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_6:
      std::string v42 = v38;
      v43.__r_.__value_.__r.__words[0] = v5;
      *(void *)uint64_t v46 = a1;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
LABEL_13:
    std::string::__init_copy_ctor_external(&v42, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v39.__r_.__value_.__r.__words[0];
    v43.__r_.__value_.__r.__words[0] = v39.__r_.__value_.__r.__words[0];
    *(void *)uint64_t v46 = a1;
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_7:
      *(_OWORD *)&v46[8] = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[0] = v42.__r_.__value_.__r.__words[2];
      v47.__r_.__value_.__l.__size_ = v5;
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
LABEL_14:
    std::string::__init_copy_ctor_external((std::string *)&v46[8], v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
    v47.__r_.__value_.__l.__size_ = v43.__r_.__value_.__r.__words[0];
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v42.__r_.__value_.__l.__data_);
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_17:
        *(void *)&long long v22 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
        *((void *)&v22 + 1) = 0;
        std::string::size_type v23 = *(void *)v46;
        if (v47.__r_.__value_.__s.__data_[7] < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&__p, *(const std::string::value_type **)&v46[8], *(std::string::size_type *)&v46[16]);
          *((void *)&v25 + 1) = v47.__r_.__value_.__l.__size_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if (v47.__r_.__value_.__s.__data_[7] < 0)
          {
            operator delete(*(void **)&v46[8]);
            if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_23:
              long long v29 = v22;
              std::string::size_type v6 = v23;
              std::string::size_type v30 = v23;
              if (SBYTE7(v25) < 0)
              {
                std::string::__init_copy_ctor_external(&v31, (const std::string::value_type *)__p, *((std::string::size_type *)&__p + 1));
                std::string::size_type v6 = v30;
              }
              else
              {
                *(_OWORD *)&v31.__r_.__value_.__l.__data_ = __p;
                v31.__r_.__value_.__r.__words[2] = v25;
              }
              std::string::size_type v7 = *((void *)&v25 + 1);
              std::string::size_type v32 = *((void *)&v25 + 1);
              std::string::value_type v8 = v26;
              std::string::value_type v33 = v26;
              unint64_t v27 = 0;
              *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v29;
              v34.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v35, v31.__r_.__value_.__l.__data_, v31.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v32;
                std::string::value_type v8 = v33;
                std::string::size_type v6 = v34.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v35 = v31;
              }
              std::string::size_type v36 = v7;
              std::string::value_type v37 = v8;
              *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)&v34.__r_.__value_.__l.__data_;
              v38.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v39, v35.__r_.__value_.__l.__data_, v35.__r_.__value_.__l.__size_);
                std::string::size_type v6 = v38.__r_.__value_.__r.__words[2];
                std::string::size_type v7 = v36;
                std::string::value_type v8 = v37;
              }
              else
              {
                std::string v39 = v35;
              }
              std::string::size_type v40 = v7;
              std::string::value_type v41 = v8;
              *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)&v38.__r_.__value_.__l.__data_;
              v42.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v43, v39.__r_.__value_.__l.__data_, v39.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v40;
                std::string::value_type v8 = v41;
                std::string::size_type v6 = v42.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v43 = v39;
              }
              std::string::size_type v44 = v7;
              std::string::value_type v45 = v8;
              *(_OWORD *)uint64_t v46 = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
              *(void *)&v46[16] = v6;
              if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v47, v43.__r_.__value_.__l.__data_, v43.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v44;
                std::string::value_type v8 = v45;
              }
              else
              {
                std::string v47 = v43;
              }
              std::string::size_type v48 = v7;
              std::string::value_type v49 = v8;
              BOOL v9 = (std::string *)operator new(0x40uLL);
              *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)v46;
              v9->__r_.__value_.__r.__words[2] = *(void *)&v46[16];
              unsigned int v10 = v9 + 1;
              if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(v10, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
                std::string::value_type v11 = v49;
                int v12 = SHIBYTE(v47.__r_.__value_.__r.__words[2]);
                v9[2].__r_.__value_.__r.__words[0] = v48;
                v9[2].__r_.__value_.__s.__data_[8] = v11;
                v28[0] = (uint64_t)v9;
                if (v12 < 0)
                {
                  operator delete(v47.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_65;
                  }
                }
                else if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
                  goto LABEL_65;
                }
              }
              else
              {
                *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
                v9[1].__r_.__value_.__r.__words[2] = v47.__r_.__value_.__r.__words[2];
                v9[2].__r_.__value_.__r.__words[0] = v7;
                v9[2].__r_.__value_.__s.__data_[8] = v8;
                v28[0] = (uint64_t)v9;
                if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
LABEL_65:
                  operator delete(v43.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
                  {
LABEL_66:
                    operator delete(v39.__r_.__value_.__l.__data_);
                    unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
                    {
LABEL_67:
                      operator delete(v35.__r_.__value_.__l.__data_);
                      if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_46;
                      }
                      goto LABEL_68;
                    }
LABEL_45:
                    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_46;
                    }
LABEL_68:
                    operator delete(v31.__r_.__value_.__l.__data_);
LABEL_46:
                    uint64_t v13 = *(void *)(a1 + 48);
                    uint64_t v14 = *(void *)(a1 + 40);
                    uint64_t v15 = 16 * (v13 - v14) - 1;
                    if (v13 == v14) {
                      uint64_t v15 = 0;
                    }
                    unint64_t v16 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
                    if (v15 == v16)
                    {
                      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 32));
                      uint64_t v14 = *(void *)(a1 + 40);
                      unint64_t v16 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
                    }
                    uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
                    *uint64_t v17 = 0;
                    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v27);
                    ++*(void *)(a1 + 72);
                    if (v27)
                    {
                      if ((v27 & 1) == 0)
                      {
                        int v18 = *(void (**)(uint64_t *, _WORD *, int))(v27 & 0xFFFFFFFFFFFFFFFELL);
                        if (v18) {
                          v18(v28, v28, 2);
                        }
                      }
                      unint64_t v27 = 0;
                    }
                    if (SBYTE7(v25) < 0)
                    {
                      operator delete((void *)__p);
                      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        return v3 == 0;
                      }
                    }
                    else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
                      return v3 == 0;
                    }
                    operator delete(v20.__r_.__value_.__l.__data_);
                    return v3 == 0;
                  }
LABEL_44:
                  unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_67;
                  }
                  goto LABEL_45;
                }
              }
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_66;
              }
              goto LABEL_44;
            }
          }
          else if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_23;
          }
        }
        else
        {
          long long __p = *(_OWORD *)&v46[8];
          long long v25 = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_23;
          }
        }
        operator delete(v34.__r_.__value_.__l.__data_);
        goto LABEL_23;
      }
    }
    else
    {
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
    }
LABEL_16:
    operator delete(v38.__r_.__value_.__l.__data_);
    goto LABEL_17;
  }
  *(unsigned char *)(a1 + 88) = 1;
  return v3 == 0;
}

void sub_21DEC5A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  operator delete(v61);
  if (*(char *)(v62 - 81) < 0)
  {
    operator delete(*(void **)(v62 - 104));
    if ((*(char *)(v62 - 145) & 0x80000000) == 0)
    {
LABEL_3:
      if ((a61 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((*(char *)(v62 - 145) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v62 - 168));
  if ((a61 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a50 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  operator delete(__p);
  if ((a50 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a39 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a45);
  if ((a39 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a24 & 0x80000000) == 0)
    {
LABEL_14:
      if (a14 < 0) {
        operator delete(a9);
      }
      _Unwind_Resume(a1);
    }
LABEL_13:
    operator delete(a19);
    goto LABEL_14;
  }
LABEL_12:
  operator delete(a34);
  if ((a24 & 0x80000000) == 0) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>::manage(uint64_t *a1, _WORD *a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      std::string::size_type v6 = (std::string *)operator new(0x40uLL);
      *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)v5;
      v6->__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
      std::string::size_type v7 = v6 + 1;
      if (*(char *)(v5 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(v5 + 24), *(void *)(v5 + 32));
      }
      else
      {
        long long v8 = *(_OWORD *)(v5 + 24);
        v6[1].__r_.__value_.__r.__words[2] = *(void *)(v5 + 40);
        *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
      }
      v6[2].__r_.__value_.__r.__words[0] = *(void *)(v5 + 48);
      v6[2].__r_.__value_.__s.__data_[8] = *(unsigned char *)(v5 + 56);
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      uint64_t v9 = *(void *)a2;
      if (*(void *)a2)
      {
        if (*(char *)(v9 + 47) < 0) {
          operator delete(*(void **)(v9 + 24));
        }
        operator delete((void *)v9);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      unsigned int v10 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v10 == (const char *)(0x800000021DFAA89BLL & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v10, (const char *)(0x800000021DFAA89BLL & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
}

void sub_21DEC5D94(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[56];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  long long v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  unsigned int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA772 & 0x7FFFFFFFFFFFFFFFLL));
  std::string::size_type v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA772 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      std::string::size_type v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    std::string::size_type v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  std::string::size_type v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string::size_type v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    std::string v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    std::string v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)std::string::size_type v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEC649C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>::execute(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1 + 144;
  if (boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::eventCmdPerformNextStage>(a1 + 144, a4))
  {
    uint64_t v7 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 168) + 30])(v6, 0);
    uint64_t v8 = v7;
    if (*(unsigned char *)(a1 + 233)) {
      BOOL v9 = 0;
    }
    else {
      BOOL v9 = v7 == 0;
    }
    if (v9) {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(v6, v6, *(_DWORD *)(a1 + 168));
    }
    *(unsigned char *)(a1 + 232) = 0;
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(v6);
  }
  else
  {
    uint64_t v8 = 1;
  }
  *(_DWORD *)(a1 + 4 * a2 + 32) = 5;
  return v8;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformNextStage>(uint64_t a1, uint64_t a2, char a3)
{
  if (!boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::eventCmdPerformNextStage>()) {
    return 1;
  }
  uint64_t v5 = ((uint64_t (*)(uint64_t, void))_MergedGlobals_1[*(_DWORD *)(a1 + 24) + 30])(a1, 0);
  uint64_t v6 = v5;
  if (!*(unsigned char *)(a1 + 89) || (a3) && !v5) {
    BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(a1, a1, *(_DWORD *)(a1 + 24));
  }
  *(unsigned char *)(a1 + 88) = 0;
  if ((a3 & 6) == 0) {
    boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
  }
  return v6;
}

BOOL boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::do_pre_msg_queue_helper<BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::eventCmdPerformNextStage>(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 88);
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
      std::string::size_type v5 = *(void *)(a2 + 24);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_4:
        std::string v34 = v20;
        v35.__r_.__value_.__r.__words[0] = v5;
        if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_5;
        }
        goto LABEL_12;
      }
    }
    else
    {
      *(_OWORD *)&v20.__r_.__value_.__l.__data_ = *(_OWORD *)a2;
      std::string::size_type v5 = *(void *)(a2 + 24);
      v20.__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
      std::string::size_type v21 = v5;
      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_4;
      }
    }
    std::string::__init_copy_ctor_external(&v34, v20.__r_.__value_.__l.__data_, v20.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v21;
    v35.__r_.__value_.__r.__words[0] = v21;
    if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_5:
      std::string v38 = v34;
      v39.__r_.__value_.__r.__words[0] = v5;
      if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_13;
    }
LABEL_12:
    std::string::__init_copy_ctor_external(&v38, v34.__r_.__value_.__l.__data_, v34.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v35.__r_.__value_.__r.__words[0];
    v39.__r_.__value_.__r.__words[0] = v35.__r_.__value_.__r.__words[0];
    if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_6:
      std::string v42 = v38;
      v43.__r_.__value_.__r.__words[0] = v5;
      *(void *)uint64_t v46 = a1;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_7;
      }
      goto LABEL_14;
    }
LABEL_13:
    std::string::__init_copy_ctor_external(&v42, v38.__r_.__value_.__l.__data_, v38.__r_.__value_.__l.__size_);
    std::string::size_type v5 = v39.__r_.__value_.__r.__words[0];
    v43.__r_.__value_.__r.__words[0] = v39.__r_.__value_.__r.__words[0];
    *(void *)uint64_t v46 = a1;
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_7:
      *(_OWORD *)&v46[8] = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[0] = v42.__r_.__value_.__r.__words[2];
      v47.__r_.__value_.__l.__size_ = v5;
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
LABEL_14:
    std::string::__init_copy_ctor_external((std::string *)&v46[8], v42.__r_.__value_.__l.__data_, v42.__r_.__value_.__l.__size_);
    v47.__r_.__value_.__l.__size_ = v43.__r_.__value_.__r.__words[0];
    if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v42.__r_.__value_.__l.__data_);
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_17:
        *(void *)&long long v22 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
        *((void *)&v22 + 1) = 0;
        std::string::size_type v23 = *(void *)v46;
        if (v47.__r_.__value_.__s.__data_[7] < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)&__p, *(const std::string::value_type **)&v46[8], *(std::string::size_type *)&v46[16]);
          *((void *)&v25 + 1) = v47.__r_.__value_.__l.__size_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if (v47.__r_.__value_.__s.__data_[7] < 0)
          {
            operator delete(*(void **)&v46[8]);
            if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_23:
              long long v29 = v22;
              std::string::size_type v6 = v23;
              std::string::size_type v30 = v23;
              if (SBYTE7(v25) < 0)
              {
                std::string::__init_copy_ctor_external(&v31, (const std::string::value_type *)__p, *((std::string::size_type *)&__p + 1));
                std::string::size_type v6 = v30;
              }
              else
              {
                *(_OWORD *)&v31.__r_.__value_.__l.__data_ = __p;
                v31.__r_.__value_.__r.__words[2] = v25;
              }
              std::string::size_type v7 = *((void *)&v25 + 1);
              std::string::size_type v32 = *((void *)&v25 + 1);
              std::string::value_type v8 = v26;
              std::string::value_type v33 = v26;
              unint64_t v27 = 0;
              *(_OWORD *)&v34.__r_.__value_.__l.__data_ = v29;
              v34.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v35, v31.__r_.__value_.__l.__data_, v31.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v32;
                std::string::value_type v8 = v33;
                std::string::size_type v6 = v34.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v35 = v31;
              }
              std::string::size_type v36 = v7;
              std::string::value_type v37 = v8;
              *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)&v34.__r_.__value_.__l.__data_;
              v38.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v39, v35.__r_.__value_.__l.__data_, v35.__r_.__value_.__l.__size_);
                std::string::size_type v6 = v38.__r_.__value_.__r.__words[2];
                std::string::size_type v7 = v36;
                std::string::value_type v8 = v37;
              }
              else
              {
                std::string v39 = v35;
              }
              std::string::size_type v40 = v7;
              std::string::value_type v41 = v8;
              *(_OWORD *)&v42.__r_.__value_.__l.__data_ = *(_OWORD *)&v38.__r_.__value_.__l.__data_;
              v42.__r_.__value_.__r.__words[2] = v6;
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v43, v39.__r_.__value_.__l.__data_, v39.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v40;
                std::string::value_type v8 = v41;
                std::string::size_type v6 = v42.__r_.__value_.__r.__words[2];
              }
              else
              {
                std::string v43 = v39;
              }
              std::string::size_type v44 = v7;
              std::string::value_type v45 = v8;
              *(_OWORD *)uint64_t v46 = *(_OWORD *)&v42.__r_.__value_.__l.__data_;
              *(void *)&v46[16] = v6;
              if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(&v47, v43.__r_.__value_.__l.__data_, v43.__r_.__value_.__l.__size_);
                std::string::size_type v7 = v44;
                std::string::value_type v8 = v45;
              }
              else
              {
                std::string v47 = v43;
              }
              std::string::size_type v48 = v7;
              std::string::value_type v49 = v8;
              BOOL v9 = (std::string *)operator new(0x40uLL);
              *(_OWORD *)&v9->__r_.__value_.__l.__data_ = *(_OWORD *)v46;
              v9->__r_.__value_.__r.__words[2] = *(void *)&v46[16];
              unsigned int v10 = v9 + 1;
              if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(v10, v47.__r_.__value_.__l.__data_, v47.__r_.__value_.__l.__size_);
                std::string::value_type v11 = v49;
                int v12 = SHIBYTE(v47.__r_.__value_.__r.__words[2]);
                v9[2].__r_.__value_.__r.__words[0] = v48;
                v9[2].__r_.__value_.__s.__data_[8] = v11;
                v28[0] = (uint64_t)v9;
                if (v12 < 0)
                {
                  operator delete(v47.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_65;
                  }
                }
                else if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
                  goto LABEL_65;
                }
              }
              else
              {
                *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
                v9[1].__r_.__value_.__r.__words[2] = v47.__r_.__value_.__r.__words[2];
                v9[2].__r_.__value_.__r.__words[0] = v7;
                v9[2].__r_.__value_.__s.__data_[8] = v8;
                v28[0] = (uint64_t)v9;
                if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                {
LABEL_65:
                  operator delete(v43.__r_.__value_.__l.__data_);
                  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
                  {
LABEL_66:
                    operator delete(v39.__r_.__value_.__l.__data_);
                    unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
                    {
LABEL_67:
                      operator delete(v35.__r_.__value_.__l.__data_);
                      if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        goto LABEL_46;
                      }
                      goto LABEL_68;
                    }
LABEL_45:
                    if ((SHIBYTE(v31.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_46;
                    }
LABEL_68:
                    operator delete(v31.__r_.__value_.__l.__data_);
LABEL_46:
                    uint64_t v13 = *(void *)(a1 + 48);
                    uint64_t v14 = *(void *)(a1 + 40);
                    uint64_t v15 = 16 * (v13 - v14) - 1;
                    if (v13 == v14) {
                      uint64_t v15 = 0;
                    }
                    unint64_t v16 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
                    if (v15 == v16)
                    {
                      std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 32));
                      uint64_t v14 = *(void *)(a1 + 40);
                      unint64_t v16 = *(void *)(a1 + 72) + *(void *)(a1 + 64);
                    }
                    uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
                    *uint64_t v17 = 0;
                    boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v27);
                    ++*(void *)(a1 + 72);
                    if (v27)
                    {
                      if ((v27 & 1) == 0)
                      {
                        int v18 = *(void (**)(uint64_t *, _WORD *, int))(v27 & 0xFFFFFFFFFFFFFFFELL);
                        if (v18) {
                          v18(v28, v28, 2);
                        }
                      }
                      unint64_t v27 = 0;
                    }
                    if (SBYTE7(v25) < 0)
                    {
                      operator delete((void *)__p);
                      if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        return v3 == 0;
                      }
                    }
                    else if ((SHIBYTE(v20.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                    {
                      return v3 == 0;
                    }
                    operator delete(v20.__r_.__value_.__l.__data_);
                    return v3 == 0;
                  }
LABEL_44:
                  unint64_t v27 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>)::stored_vtable;
                  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
                    goto LABEL_67;
                  }
                  goto LABEL_45;
                }
              }
              if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
                goto LABEL_66;
              }
              goto LABEL_44;
            }
          }
          else if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_23;
          }
        }
        else
        {
          long long __p = *(_OWORD *)&v46[8];
          long long v25 = *(_OWORD *)&v47.__r_.__value_.__l.__data_;
          std::string::value_type v26 = v47.__r_.__value_.__s.__data_[16];
          if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_23;
          }
        }
        operator delete(v34.__r_.__value_.__l.__data_);
        goto LABEL_23;
      }
    }
    else
    {
      v47.__r_.__value_.__s.__data_[16] = 5;
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_17;
      }
    }
LABEL_16:
    operator delete(v38.__r_.__value_.__l.__data_);
    goto LABEL_17;
  }
  *(unsigned char *)(a1 + 88) = 1;
  return v3 == 0;
}

void sub_21DEC6CF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  operator delete(v61);
  if (*(char *)(v62 - 81) < 0)
  {
    operator delete(*(void **)(v62 - 104));
    if ((*(char *)(v62 - 145) & 0x80000000) == 0)
    {
LABEL_3:
      if ((a61 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((*(char *)(v62 - 145) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v62 - 168));
  if ((a61 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a50 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  operator delete(__p);
  if ((a50 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a39 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(a45);
  if ((a39 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a24 & 0x80000000) == 0)
    {
LABEL_14:
      if (a14 < 0) {
        operator delete(a9);
      }
      _Unwind_Resume(a1);
    }
LABEL_13:
    operator delete(a19);
    goto LABEL_14;
  }
LABEL_12:
  operator delete(a34);
  if ((a24 & 0x80000000) == 0) {
    goto LABEL_14;
  }
  goto LABEL_13;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>>::manage(uint64_t *a1, _WORD *a2, int a3)
{
  switch(a3)
  {
    case 0:
      uint64_t v5 = *a1;
      std::string::size_type v6 = (std::string *)operator new(0x40uLL);
      *(_OWORD *)&v6->__r_.__value_.__l.__data_ = *(_OWORD *)v5;
      v6->__r_.__value_.__r.__words[2] = *(void *)(v5 + 16);
      std::string::size_type v7 = v6 + 1;
      if (*(char *)(v5 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(v5 + 24), *(void *)(v5 + 32));
      }
      else
      {
        long long v8 = *(_OWORD *)(v5 + 24);
        v6[1].__r_.__value_.__r.__words[2] = *(void *)(v5 + 40);
        *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
      }
      v6[2].__r_.__value_.__r.__words[0] = *(void *)(v5 + 48);
      v6[2].__r_.__value_.__s.__data_[8] = *(unsigned char *)(v5 + 56);
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      uint64_t v9 = *(void *)a2;
      if (*(void *)a2)
      {
        if (*(char *)(v9 + 47) < 0) {
          operator delete(*(void **)(v9 + 24));
        }
        operator delete((void *)v9);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      unsigned int v10 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v10 == (const char *)(0x800000021DFAA99DLL & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v10, (const char *)(0x800000021DFAA99DLL & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      a2[4] = 0;
      break;
  }
}

void sub_21DEC6FFC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformNextStage>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[56];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  uint64_t v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  long long v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  unsigned int v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAA772 & 0x7FFFFFFFFFFFFFFFLL));
  std::string::size_type v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAA772 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      std::string::size_type v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    std::string::size_type v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  std::string::size_type v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string::size_type v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    std::string v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    std::string v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)std::string::size_type v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEC7704(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformCoreDump>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8E9C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E9C0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E9B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E9B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E9A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E9A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E998 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E990 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E988 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      qword_26AA8E980[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E980[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E980[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      int v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *int v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformCoreDump const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformCoreDump>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformCoreDump const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformCoreDump>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *uint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          int v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EE38 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EE38 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformCoreDump>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformCoreDump>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEC7C54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformCoreDump>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformCoreDump const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformCoreDump>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAAAD1 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAAAD1 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformCoreDump const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformCoreDump>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformCoreDump>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAAA9DLL & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAAA9DLL & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      std::string::size_type v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    std::string::size_type v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  std::string::size_type v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string::size_type v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    std::string v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    std::string v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)std::string::size_type v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEC84B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,BBUpdaterControllerFSM::eventCmdPerformCoreDump,BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,BBUpdaterControllerFSM::ControllerFSM_TOP::collectDump,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 452) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  uint64_t v4 = (_DWORD *)(v3 + 32);
  char v5 = *(CFMutableDictionaryRef **)(a1 + 16);
  if (BBUpdaterController::collectCoredumpInternal((BBUpdaterController *)v5))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_3;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_3;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(1, 6, "BBUpdaterController", "", "check failed: %s, %d, assertion: %s\n", v6, v7, v8, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterController.cpp");
    }
  }
  else
  {
    CFDictionarySetValue(v5[4], @"done", (const void *)*MEMORY[0x263EFFB40]);
  }
LABEL_3:
  _DWORD *v4 = 0;
  ++*(_DWORD *)(a1 + 112);
  _DWORD *v4 = 8;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformBootup>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8EA18 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8EA10 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8EA08 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8EA00 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8E9F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8E9F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8E9E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8E9E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8E9D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      qword_26AA8E9D0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8E9D0[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8E9D0[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      int v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *int v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformBootup>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformBootup const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformBootup>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformBootup const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformBootup>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *uint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          int v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EE90 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EE90 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformBootup>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformBootup>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEC8B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformBootup>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformBootup const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformBootup>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAABF6 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAABF6 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformBootup const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformBootup>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformBootup>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAABC4 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAABC4 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      std::string::size_type v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    std::string::size_type v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  std::string::size_type v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string::size_type v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    std::string v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    std::string v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)std::string::size_type v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DEC9398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,BBUpdaterControllerFSM::eventCmdPerformBootup,BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::ControllerFSM_TOP::bootup<false>,boost::msm::front::none>>::execute(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 4 * a2;
  *(_DWORD *)(a1 + 452) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  BBUpdaterController::bootup(*(BBUpdaterController **)(a1 + 16));
  *(_DWORD *)(v3 + 32) = 0;
  ++*(_DWORD *)(a1 + 440);
  *(_DWORD *)(v3 + 32) = 1;
  return 1;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>(uint64_t a1, uint64_t a2, char a3)
{
  qword_26AA8E5B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::TerminateFlag>::flag_true;
  qword_26AA8E5B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E5A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E598 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E590 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E588 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E580 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E578 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::TerminateFlag>::flag_false;
  qword_26AA8E570[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::TerminateFlag>::flag_false;
  char v5 = ((uint64_t (*)(void))qword_26AA8E570[*(int *)(a1 + 32)])();
  char v6 = ((uint64_t (*)(uint64_t))qword_26AA8E570[*(int *)(a1 + 36)])(a1);
  uint64_t v7 = 1;
  if ((v5 & 1) == 0 && (v6 & 1) == 0)
  {
    qword_26AA8E608 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E600 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5D0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::InterruptedFlag>::flag_false;
    qword_26AA8E5C0[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::InterruptedFlag>::flag_false;
    char v8 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 32)])(a1);
    int v9 = ((uint64_t (*)(uint64_t))qword_26AA8E5C0[*(int *)(a1 + 36)])(a1);
    if ((v8 & 1) != 0 || v9)
    {
      qword_26AA8EA68 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA60 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA58 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA50 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA48 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA40 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA38 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA30 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA28 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      qword_26AA8EA20[0] = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false;
      char v10 = ((uint64_t (*)(uint64_t))qword_26AA8EA20[*(int *)(a1 + 32)])(a1);
      int v11 = ((uint64_t (*)(uint64_t))qword_26AA8EA20[*(int *)(a1 + 36)])(a1);
      if ((v10 & 1) == 0 && !v11) {
        return 1;
      }
    }
    if (*(unsigned char *)(a1 + 100))
    {
      int v12 = operator new(0x20uLL);
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = 16 * (v13 - v14) - 1;
      *int v12 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_event_internal<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
      v12[1] = 0;
      void v12[2] = a1;
      *((unsigned char *)v12 + 25) = 5;
      unint64_t v21 = (unint64_t)boost::function0<boost::msm::back::HandledEnum>::assign_to<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformManifestCheck const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>,boost::_bi::value<unsigned char>>>>(boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformManifestCheck const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>,boost::_bi::value<unsigned char>>>)::stored_vtable;
      v22[0] = v12;
      if (v13 == v14) {
        uint64_t v15 = 0;
      }
      unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      if (v15 == v16)
      {
        std::deque<boost::function<boost::msm::back::HandledEnum ()(void)>>::__add_back_capacity((void *)(a1 + 40));
        uint64_t v14 = *(void *)(a1 + 48);
        unint64_t v16 = *(void *)(a1 + 80) + *(void *)(a1 + 72);
      }
      uint64_t v17 = (void *)(*(void *)(v14 + ((v16 >> 4) & 0xFFFFFFFFFFFFFF8)) + 32 * (v16 & 0x7F));
      *uint64_t v17 = 0;
      boost::function0<boost::msm::back::HandledEnum>::move_assign((uint64_t)v17, (uint64_t *)&v21);
      ++*(void *)(a1 + 80);
      if (v21)
      {
        if ((v21 & 1) == 0)
        {
          int v18 = *(void (**)(void *, void *, uint64_t))(v21 & 0xFFFFFFFFFFFFFFFELL);
          if (v18) {
            v18(v22, v22, 2);
          }
        }
      }
      return 1;
    }
    *(unsigned char *)(a1 + 100) = 1;
    int v20 = (*((uint64_t (**)(uint64_t, void))&unk_26AA8EEE8 + *(_DWORD *)(a1 + 32) + 1))(a1, 0);
    uint64_t v7 = (*((unsigned int (**)(uint64_t, uint64_t))&unk_26AA8EEE8 + *(_DWORD *)(a1 + 36) + 1))(a1, 1) | v20;
    if (!*(unsigned char *)(a1 + 101) || (a3) && !v7)
    {
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformManifestCheck>(a1, a1, *(_DWORD *)(a1 + 32));
      BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformManifestCheck>(a1, a1, *(_DWORD *)(a1 + 36));
    }
    *(unsigned char *)(a1 + 100) = 0;
    if ((a3 & 6) == 0) {
      boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::process_message_queue<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>(a1);
    }
  }
  return v7;
}

void sub_21DEC9940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::FlagHandler<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::EndInterruptFlag<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>>::flag_false()
{
  return 0;
}

void boost::detail::function::functor_manager<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformManifestCheck const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>,boost::_bi::value<unsigned char>>>>::manage(_OWORD **a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case 0:
      char v5 = *a1;
      char v6 = operator new(0x20uLL);
      long long v7 = v5[1];
      _OWORD *v6 = *v5;
      v6[1] = v7;
      *(void *)a2 = v6;
      break;
    case 1:
      *(void *)a2 = *a1;
      *a1 = 0;
      break;
    case 2:
      if (*(void *)a2) {
        operator delete(*(void **)a2);
      }
      *(void *)a2 = 0;
      break;
    case 3:
      char v8 = (const char *)(*(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL);
      if (v8 == (const char *)(0x800000021DFAAD20 & 0x7FFFFFFFFFFFFFFFLL)
        || !strcmp(v8, (const char *)(0x800000021DFAAD20 & 0x7FFFFFFFFFFFFFFFLL)))
      {
        *(void *)a2 = *a1;
      }
      else
      {
        *(void *)a2 = 0;
      }
      break;
    default:
      *(_WORD *)(a2 + 8) = 0;
      break;
  }
}

uint64_t boost::detail::function::function_obj_invoker0<boost::_bi::bind_t<boost::msm::back::HandledEnum,boost::_mfi::mf2<boost::msm::back::HandledEnum,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformManifestCheck const&,unsigned char>,boost::_bi::list3<boost::_bi::value<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>*>,boost::_bi::value<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>,boost::_bi::value<unsigned char>>>,boost::msm::back::HandledEnum>::invoke(unsigned __int8 **a1)
{
  uint64_t v1 = (uint64_t (**)(void, void, void))*a1;
  uint64_t v2 = *((void *)*a1 + 1);
  uint64_t v3 = (*a1)[25];
  uint64_t v4 = *(uint64_t (**)(void *, void, uint64_t))*a1;
  char v5 = (void *)(*((void *)*a1 + 2) + (v2 >> 1));
  if (v2) {
    return (*(uint64_t (**)(void))(*v5 + v4))();
  }
  else {
    return v4(v5, v1 + 3, v3);
  }
}

void BBUpdaterControllerFSM::FSMBase<BBUpdaterControllerFSM::ControllerFSM_TOP>::no_transition<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformManifestCheck>(uint64_t a1, uint64_t a2, int a3)
{
  memset(v64, 170, sizeof(v64));
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 24))(v64);
  int v6 = a3;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v64[1] - v64[0]) >> 3) <= a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/API/BBUpdaterControllerFSM.hpp", 0x87u, (ctu::LogMessageBuffer *)"Assertion failure(( state < stateNames.size()) && \"Unrecognized BBU Stage.\")", v46, v47, v48, v49);
  }
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v62[7] = v7;
  v62[8] = v7;
  v62[5] = v7;
  v62[6] = v7;
  v62[3] = v7;
  v62[4] = v7;
  v62[1] = v7;
  v62[2] = v7;
  long long v61 = v7;
  v62[0] = v7;
  *(_OWORD *)long long __p = v7;
  long long v60 = v7;
  long long v57 = v7;
  long long v58 = v7;
  long long v55 = v7;
  long long v56 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v55);
  char v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v55, (uint64_t)"no transition defined: ", 23);
  int v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)" in ", 4);
  char v10 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  size_t v11 = strlen(v10);
  int v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)v10, v11);
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" from ", 6);
  uint64_t v14 = v64[0] + 24 * v6;
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = v64[0] + 24 * v6;
  }
  else {
    uint64_t v16 = *(void *)v14;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    uint64_t v17 = *(void *)(v14 + 8);
  }
  int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, v16, v17);
  uint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" on ", 4);
  size_t v20 = strlen((const char *)(0x800000021DFAACE7 & 0x7FFFFFFFFFFFFFFFLL));
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, 0x800000021DFAACE7 & 0x7FFFFFFFFFFFFFFFLL, v20);
  v53[0] = 10;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)v53, 1);
  memset(__dst, 170, sizeof(__dst));
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v24 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v24 = *((void *)&v58 + 1);
    }
    long long v25 = (const void *)v58;
    size_t v22 = v24 - v58;
    if ((unint64_t)(v24 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_62;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      size_t v22 = 0;
      HIBYTE(__dst[2]) = 0;
      std::string::size_type v23 = __dst;
      goto LABEL_21;
    }
    long long v25 = (const void *)*((void *)&v56 + 1);
    size_t v22 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_62:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v22 >= 0x17)
  {
    uint64_t v26 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v22 | 7) != 0x17) {
      uint64_t v26 = v22 | 7;
    }
    uint64_t v27 = v26 + 1;
    std::string::size_type v23 = (void **)operator new(v26 + 1);
    __dst[1] = (void *)v22;
    __dst[2] = (void *)(v27 | 0x8000000000000000);
    __dst[0] = v23;
    goto LABEL_20;
  }
  HIBYTE(__dst[2]) = v22;
  std::string::size_type v23 = __dst;
  if (v22) {
LABEL_20:
  }
    memmove(v23, v25, v22);
LABEL_21:
  *((unsigned char *)v23 + v22) = 0;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_27;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v28 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::string::size_type v32 = __dst;
    if (SHIBYTE(__dst[2]) < 0) {
      LOBYTE(v32) = __dst[0];
    }
    _BBULog(1, 0, v28, "", "%s", v29, v30, v31, (char)v32);
  }
LABEL_27:
  *(void *)&long long v33 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v33 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string::size_type v53 = v33;
  *(_OWORD *)&v53[16] = v33;
  if ((BYTE8(v61) & 0x10) != 0)
  {
    uint64_t v34 = v61;
    if ((unint64_t)v61 < *((void *)&v58 + 1))
    {
      *(void *)&long long v61 = *((void *)&v58 + 1);
      uint64_t v34 = *((void *)&v58 + 1);
    }
    std::string v35 = (const void *)v58;
    size_t v36 = v34 - v58;
    if ((unint64_t)(v34 - v58) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v61) & 8) == 0)
    {
      HIBYTE(v52) = 0;
      LOBYTE(v51) = 0;
      goto LABEL_36;
    }
    std::string v35 = (const void *)*((void *)&v56 + 1);
    size_t v36 = *((void *)&v57 + 1) - *((void *)&v56 + 1);
    if (*((void *)&v57 + 1) - *((void *)&v56 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v36 >= 0x17)
  {
    uint64_t v39 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v39 = v36 | 7;
    }
    uint64_t v40 = v39 + 1;
    std::string::value_type v37 = (long long *)operator new(v39 + 1);
    *((void *)&v51 + 1) = v36;
    unint64_t v52 = v40 | 0x8000000000000000;
    *(void *)&long long v51 = v37;
  }
  else
  {
    HIBYTE(v52) = v36;
    std::string::value_type v37 = &v51;
    if (!v36)
    {
      LOBYTE(v51) = 0;
      if ((SHIBYTE(v52) & 0x80000000) == 0) {
        goto LABEL_36;
      }
LABEL_42:
      std::string::value_type v41 = (void *)v51;
      std::string::__init_copy_ctor_external((std::string *)v53, (const std::string::value_type *)v51, *((std::string::size_type *)&v51 + 1));
      *(void *)&v53[24] = 44;
      operator delete(v41);
      uint64_t v38 = *(void *)(a2 + 16);
      if ((v53[23] & 0x80000000) == 0) {
        goto LABEL_37;
      }
      goto LABEL_43;
    }
  }
  memmove(v37, v35, v36);
  *((unsigned char *)v37 + v36) = 0;
  if (SHIBYTE(v52) < 0) {
    goto LABEL_42;
  }
LABEL_36:
  *(_OWORD *)std::string::size_type v53 = v51;
  *(void *)&v53[16] = v52;
  *(void *)&v53[24] = 44;
  uint64_t v38 = *(void *)(a2 + 16);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
LABEL_37:
    std::string v50 = *(std::string *)v53;
    goto LABEL_44;
  }
LABEL_43:
  std::string::__init_copy_ctor_external(&v50, *(const std::string::value_type **)v53, *(std::string::size_type *)&v53[8]);
LABEL_44:
  BBUpdaterController::handleError(v38, &v50, *(int *)&v53[24]);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((v53[23] & 0x80000000) == 0) {
      goto LABEL_46;
    }
LABEL_59:
    operator delete(*(void **)v53);
    if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
      goto LABEL_47;
    }
    goto LABEL_60;
  }
  operator delete(v50.__r_.__value_.__l.__data_);
  if ((v53[23] & 0x80000000) != 0) {
    goto LABEL_59;
  }
LABEL_46:
  if ((SHIBYTE(__dst[2]) & 0x80000000) == 0) {
    goto LABEL_47;
  }
LABEL_60:
  operator delete(__dst[0]);
LABEL_47:
  *(void *)&long long v55 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v55 + *(void *)(v55 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v55 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v60) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v62);
  uint64_t v42 = v64[0];
  if (v64[0])
  {
    uint64_t v43 = v64[1];
    std::string::size_type v44 = (void *)v64[0];
    if (v64[1] != v64[0])
    {
      do
      {
        if (*(char *)(v43 - 1) < 0) {
          operator delete(*(void **)(v43 - 24));
        }
        v43 -= 24;
      }
      while (v43 != v42);
      std::string::size_type v44 = (void *)v64[0];
    }
    v64[1] = v42;
    operator delete(v44);
  }
}

void sub_21DECA1A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,char a34)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a33 & 0x80000000) == 0)
  {
LABEL_6:
    std::ostringstream::~ostringstream((uint64_t)&a34);
    std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
    _Unwind_Resume(a1);
  }
  operator delete(a28);
  std::ostringstream::~ostringstream((uint64_t)&a34);
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v34 - 88));
  _Unwind_Resume(a1);
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>()
{
  return 0;
}

uint64_t boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,BBUpdaterControllerFSM::eventCmdPerformManifestCheck,BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::ControllerFSM_TOP::checkManifest,boost::msm::front::none>>::execute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1 + 4 * (int)a2;
  *(_DWORD *)(a1 + 452) = 0;
  *(_DWORD *)(v9 + 32) = 0;
  BBUpdaterController::checkManifest(*(BBUpdaterController **)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  *(_DWORD *)(v9 + 32) = 0;
  ++*(_DWORD *)(a1 + 428);
  *(_DWORD *)(v9 + 32) = 2;
  return 1;
}

uint64_t __cxx_global_var_init_0()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<BBUPartitionManager>::~PthreadMutexGuardPolicy, &ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

uint64_t __cxx_global_var_init_434()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<BBUError>::~PthreadMutexGuardPolicy, &ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

void __cxx_global_var_init_435()
{
  if ((byte_26AA8E3B8 & 1) == 0)
  {
    byte_26AA8E3B8 = 1;
    qword_26AA8EAC0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EAB8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EAA8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EAA0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EA98 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EA90 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EA88 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EA80 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EA78 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventError>;
    qword_26AA8EAB0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateRegularMode,BBUpdaterControllerFSM::eventError,BBUpdaterControllerFSM::ControllerFSM_TOP::stateDebugMode,BBUpdaterControllerFSM::ControllerFSM_TOP::handleError,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_436()
{
  if ((byte_26AA8E3C0 & 1) == 0)
  {
    byte_26AA8E3C0 = 1;
    qword_26AA8E4C0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    unk_26AA8E4C8 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8E4B0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8E4B8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::eventSkipPersonalize,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeBooted,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::skipPersonalize,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_437()
{
  if ((byte_26AA8E3C8 & 1) == 0)
  {
    byte_26AA8E3C8 = 1;
    qword_26AA8EB18 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EB10 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EB08 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EB00 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EAF8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EAF0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EAE0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EAD8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EAD0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventSkipPersonalize>;
    qword_26AA8EAE8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventSkipPersonalize>::execute;
  }
}

void __cxx_global_var_init_438()
{
  if ((byte_26AA8E3D0 & 1) == 0)
  {
    byte_26AA8E3D0 = 1;
    qword_26AA8E4F0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>;
    qword_26AA8E4E8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeBooted,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::performAction<(BBUStage)8>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute;
    qword_26AA8E4E0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::performAction<(BBUStage)8>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute;
    qword_26AA8E4D8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeFirst,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute;
  }
}

void __cxx_global_var_init_439()
{
  if ((byte_26AA8E3D8 & 1) == 0)
  {
    byte_26AA8E3D8 = 1;
    qword_26AA8EB70 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>;
    qword_26AA8EB68 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>;
    qword_26AA8EB60 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>;
    qword_26AA8EB58 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>;
    qword_26AA8EB50 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>;
    qword_26AA8EB28 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRetry>;
    qword_26AA8EB40 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventRetry>::execute;
    qword_26AA8EB48 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,BBUpdaterControllerFSM::eventRetry,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,boost::msm::front::none>>::execute;
    qword_26AA8EB38 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::ControllerFSM_TOP::checkManifest,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute;
    qword_26AA8EB30 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::eventRetry,boost::msm::front::none,BBUpdaterControllerFSM::ControllerFSM_TOP::bootup<true>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute;
  }
}

void __cxx_global_var_init_440()
{
  if ((byte_26AA8E3E0 & 1) == 0)
  {
    byte_26AA8E3E0 = 1;
    qword_26AA8EBC8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventContinue>;
    qword_26AA8EBC0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventContinue>;
    qword_26AA8EBB8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventContinue>;
    qword_26AA8EBA8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventContinue>;
    qword_26AA8EB98 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventContinue>;
    qword_26AA8EB80 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventContinue>;
    qword_26AA8EBB0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,BBUpdaterControllerFSM::eventContinue,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::front::none,boost::msm::front::none>>::execute;
    qword_26AA8EBA0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,BBUpdaterControllerFSM::eventContinue,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::front::none,boost::msm::front::none>>::execute;
    qword_26AA8EB90 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::eventContinue,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::front::none,boost::msm::front::none>>::execute;
    qword_26AA8EB88 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::eventContinue,BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,boost::msm::front::none,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_441()
{
  if ((byte_26AA8E3E8 & 1) == 0)
  {
    byte_26AA8E3E8 = 1;
    qword_26AA8EC20 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EC18 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EC10 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EC00 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EBF8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EBF0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EBE8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EBE0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EBD8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventRepersonalize>;
    qword_26AA8EC08 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,BBUpdaterControllerFSM::eventRepersonalize,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRePerso>>::execute;
  }
}

void __cxx_global_var_init_442()
{
  if ((byte_26AA8E3F0 & 1) == 0)
  {
    byte_26AA8E3F0 = 1;
    qword_26AA8EC78 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>;
    qword_26AA8EC70 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>;
    qword_26AA8EC68 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>;
    qword_26AA8EC60 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>;
    qword_26AA8EC50 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>;
    qword_26AA8EC40 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>;
    qword_26AA8EC38 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>;
    qword_26AA8EC30 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFinalize>;
    qword_26AA8EC58 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,BBUpdaterControllerFSM::ControllerFSM_TOP::finalize,boost::msm::front::none>>::execute;
    qword_26AA8EC48 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFinalize,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFinalize,BBUpdaterControllerFSM::ControllerFSM_TOP::finalize,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_443()
{
  if ((byte_26AA8E3F8 & 1) == 0)
  {
    byte_26AA8E3F8 = 1;
    qword_26AA8E510 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    qword_26AA8E518 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeEUICC,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,BBUpdaterControllerFSM::queryAction<(BBUStage)32>,boost::msm::front::none>>::execute;
    qword_26AA8E508 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,BBUpdaterControllerFSM::queryAction<(BBUStage)4>,boost::msm::front::none>>::execute;
    qword_26AA8E500 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeFirst,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_444()
{
  if ((byte_26AA8E400 & 1) == 0)
  {
    byte_26AA8E400 = 1;
    qword_26AA8E488 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionFinish,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,boost::msm::front::none,boost::msm::front::none>>::execute;
    qword_26AA8E480 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionStart,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::front::none,BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::gatherParam,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_445()
{
  if ((byte_26AA8E408 & 1) == 0)
  {
    byte_26AA8E408 = 1;
    qword_26AA8ECD0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    qword_26AA8ECC8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    qword_26AA8ECC0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    qword_26AA8ECB8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    qword_26AA8ECA8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    qword_26AA8EC98 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    qword_26AA8EC90 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdQueryInfo>;
    qword_26AA8ECA0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>::execute;
    qword_26AA8ECB0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdQueryInfo>::execute;
    qword_26AA8EC88 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,BBUpdaterControllerFSM::eventCmdQueryInfo,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::queryAction<(BBUStage)2>,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_446()
{
  if ((byte_26AA8E410 & 1) == 0)
  {
    byte_26AA8E410 = 1;
    qword_26AA8E540 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8E528 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    unk_26AA8E530 = boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8E538 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeBooted,BBUpdaterControllerFSM::eventEUICC,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeEUICC,BBUpdaterControllerFSM::performAction<(BBUStage)32>,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_447()
{
  if ((byte_26AA8E418 & 1) == 0)
  {
    byte_26AA8E418 = 1;
    qword_26AA8ED28 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ED20 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ED18 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ED10 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ED08 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ED00 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ECF0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ECE8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ECE0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventEUICC>;
    qword_26AA8ECF8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventEUICC>::execute;
  }
}

void __cxx_global_var_init_448()
{
  if ((byte_26AA8E420 & 1) == 0)
  {
    byte_26AA8E420 = 1;
    qword_26AA8ED80 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED78 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED70 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED68 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED60 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED58 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED48 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED40 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED38 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventFuse>;
    qword_26AA8ED50 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventFuse,BBUpdaterControllerFSM::ControllerFSM_TOP::stateFusing,BBUpdaterControllerFSM::ControllerFSM_TOP::fuse,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_449()
{
  if ((byte_26AA8E428 & 1) == 0)
  {
    byte_26AA8E428 = 1;
    qword_26AA8EDD8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8EDD0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8EDC8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8EDC0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8EDB8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8EDB0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8EDA0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8ED98 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8ED90 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventProvision>;
    qword_26AA8EDA8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::_row_<boost::msm::front::Row<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventProvision,boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,boost::msm::front::none,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_450()
{
  if ((byte_26AA8E430 & 1) == 0)
  {
    byte_26AA8E430 = 1;
    qword_26AA8E560 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8E568 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeEUICC,BBUpdaterControllerFSM::eventCmdPerformNextStage,boost::msm::front::none,BBUpdaterControllerFSM::performAction<(BBUStage)32>,BBUpdaterControllerFSM::ControllerFSM_TOP::allowRetry>>::execute;
    qword_26AA8E558 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeBooted,BBUpdaterControllerFSM::performAction<(BBUStage)4>,boost::msm::front::none>>::execute;
    qword_26AA8E550 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeFirst,BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_::statePersonalizeSecond,BBUpdaterControllerFSM::performAction<(BBUStage)2>,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_451()
{
  if ((byte_26AA8E438 & 1) == 0)
  {
    byte_26AA8E438 = 1;
    qword_26AA8E4A0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_irow_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionFinish,BBUpdaterControllerFSM::eventCmdPerformNextStage,boost::msm::front::none,BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::finishProvision,boost::msm::front::none>>::execute;
    qword_26AA8E498 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionStart,BBUpdaterControllerFSM::eventCmdPerformNextStage,BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::stateProvisionFinish,BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_::startProvision,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_452()
{
  if ((byte_26AA8E440 & 1) == 0)
  {
    byte_26AA8E440 = 1;
    qword_26AA8EE30 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8EE28 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8EE20 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8EE18 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8EE08 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8EDF8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8EDF0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8EDE8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformNextStage>;
    qword_26AA8EE00 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Personalize_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>::execute;
    qword_26AA8EE10 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::frow<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP::Provision_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>,BBUpdaterControllerFSM::eventCmdPerformNextStage>::execute;
  }
}

void __cxx_global_var_init_453()
{
  if ((byte_26AA8E448 & 1) == 0)
  {
    byte_26AA8E448 = 1;
    qword_26AA8EE88 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE80 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE78 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE70 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE68 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE60 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE58 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE50 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE48 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformCoreDump>;
    qword_26AA8EE40 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,BBUpdaterControllerFSM::eventCmdPerformCoreDump,BBUpdaterControllerFSM::ControllerFSM_TOP::stateCoredump,BBUpdaterControllerFSM::ControllerFSM_TOP::collectDump,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_454()
{
  if ((byte_26AA8E450 & 1) == 0)
  {
    byte_26AA8E450 = 1;
    qword_26AA8EEE0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EED8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EED0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EEC8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EEC0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EEB8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EEB0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EEA8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EEA0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformBootup>;
    qword_26AA8EE98 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,BBUpdaterControllerFSM::eventCmdPerformBootup,BBUpdaterControllerFSM::ControllerFSM_TOP::stateBooting,BBUpdaterControllerFSM::ControllerFSM_TOP::bootup<false>,boost::msm::front::none>>::execute;
  }
}

void __cxx_global_var_init_455()
{
  if ((byte_26AA8E458 & 1) == 0)
  {
    byte_26AA8E458 = 1;
    qword_26AA8EF38 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EF30 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EF28 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EF20 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EF18 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EF10 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EF08 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EF00 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EEF8 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::call_no_transition<BBUpdaterControllerFSM::eventCmdPerformManifestCheck>;
    qword_26AA8EEF0 = (uint64_t)boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>::a_row_<boost::msm::front::Row<BBUpdaterControllerFSM::ControllerFSM_TOP::stateInit,BBUpdaterControllerFSM::eventCmdPerformManifestCheck,BBUpdaterControllerFSM::ControllerFSM_TOP::stateManifestCheck,BBUpdaterControllerFSM::ControllerFSM_TOP::checkManifest,boost::msm::front::none>>::execute;
  }
}

uint64_t eUICC::detail::StateMachine::Run(int *a1, void *a2, uint64_t a3, const __CFDictionary **a4)
{
  uint64_t v120 = *MEMORY[0x263EF8340];
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)std::string v84 = v7;
  long long v85 = v7;
  long long v83 = v7;
  CFDictionaryRef v8 = *a4;
  CFDictionaryRef v82 = v8;
  if (v8) {
    CFRetain(v8);
  }
  eUICC::Options::Options((uint64_t)&v83, &v82);
  if (v8) {
    CFRelease(v8);
  }
  if (BYTE10(v85) | BYTE10(v83)) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = BYTE11(v83) == 0;
  }
  char v80 = (std::__shared_weak_count_vtbl *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v81 = 0xAAAAAAAAAAAAAAAALL;
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a3 + 184))(&v78, a3);
  eUICC::Source::CreateFromZip(&v78, &v80);
  char v10 = v79;
  if (v79 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  eUICC::Options::ToString((eUICC::Options *)&v83, &__p);
  if (SHIBYTE(v91) >= 0) {
    p_p = &__p;
  }
  else {
    LOBYTE(p_p) = (_BYTE)__p;
  }
  int v15 = (capabilities::radio *)_BBULog(0, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Options:\n%s\n", v11, v12, v13, (char)p_p);
  if (SHIBYTE(v91) < 0) {
    operator delete(__p);
  }
  unint64_t v77 = 0xAAAAAAAAAAAAAAAALL;
  int v16 = v83;
  int v17 = BYTE9(v85);
  int v18 = (capabilities::radio *)capabilities::radio::maverick(v15);
  if (v18)
  {
    size_t v22 = operator new(0x138uLL);
    v22[289] = 0;
    *(void *)size_t v22 = &unk_26CED0128;
    *((void *)v22 + 37) = a2;
    *((_DWORD *)v22 + 73) = v16;
    v22[290] = v17;
    v22[304] = 15;
    goto LABEL_22;
  }
  if (!capabilities::radio::ice(v18))
  {
    unint64_t v77 = 0;
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t v28 = *a1;
      if (v28 <= 9)
      {
LABEL_27:
        uint64_t v29 = (&off_264489838)[v28];
LABEL_121:
        _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Fatal Error: Error creating vinyl valve! Current State: %s\n", v23, v24, v25, (char)v29);
        *a1 = 8;
        uint64_t v59 = 9;
LABEL_122:
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(0, 0xFFFFFFFFLL, "eUICCStateMachine", "", "ret = %d\n", v30, v31, v32, v59);
        unint64_t v68 = v77;
        unint64_t v77 = 0;
        if (!v68) {
          goto LABEL_126;
        }
LABEL_125:
        (*(void (**)(unint64_t))(*(void *)v68 + 96))(v68);
        goto LABEL_126;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      uint64_t v28 = *a1;
      if (v28 <= 9) {
        goto LABEL_27;
      }
    }
    uint64_t v29 = "??????";
    goto LABEL_121;
  }
  size_t v22 = operator new(0x140uLL);
  eUICC::eUICCVinylICEValve::eUICCVinylICEValve((eUICC::eUICCVinylICEValve *)v22, a2, v16, v17 != 0);
LABEL_22:
  unint64_t v77 = (unint64_t)v22;
  uint64_t v26 = *a1;
  *a1 = 0;
  if (gBBULogMaskGet(void)::once != -1)
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if (v26 <= 9) {
      goto LABEL_24;
    }
LABEL_29:
    uint64_t v27 = "??????";
    goto LABEL_30;
  }
  if (v26 > 9) {
    goto LABEL_29;
  }
LABEL_24:
  uint64_t v27 = (&off_264489838)[v26];
LABEL_30:
  _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Resetting state machine: %s --> %s\n", v19, v20, v21, (char)v27);
  while (1)
  {
    if (*a1 > 7)
    {
      uint64_t v59 = 0;
      goto LABEL_122;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t v33 = *a1;
      uint64_t v34 = "??????";
      if (v33 > 9) {
        goto LABEL_36;
      }
LABEL_35:
      uint64_t v34 = (&off_264489838)[v33];
      goto LABEL_36;
    }
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t v33 = *a1;
    uint64_t v34 = "??????";
    if (v33 <= 9) {
      goto LABEL_35;
    }
LABEL_36:
    _BBULog(0, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Running at state %s\n", v30, v31, v32, (char)v34);
    BOOL v76 = v9;
    std::string v35 = v80;
    size_t v36 = (std::__shared_weak_count *)v81;
    if (v81) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v81 + 8), 1uLL, memory_order_relaxed);
    }
    int v88 = 8;
    LODWORD(__p) = 0;
    size_t v90 = (std::__shared_weak_count *)&unk_26CEC9DB8;
    int64_t v91 = eUICC::detail::StateMachine::Start;
    unint64_t v92 = (void **)&v90;
    int v93 = 3;
    v94[0] = &unk_26CEC9DB8;
    v94[1] = eUICC::detail::StateMachine::Perso;
    uint64_t v95 = v94;
    int v96 = 1;
    v97[0] = &unk_26CEC9DB8;
    v97[1] = eUICC::detail::StateMachine::Recovery;
    long long v98 = v97;
    int v99 = 2;
    v100[0] = &unk_26CEC9DB8;
    v100[1] = eUICC::detail::StateMachine::VersionCheck;
    unint64_t v101 = v100;
    int v102 = 4;
    v103[0] = &unk_26CEC9DB8;
    v103[1] = eUICC::detail::StateMachine::UpdateGold;
    uint64_t v104 = v103;
    int v105 = 5;
    v106[0] = &unk_26CEC9DB8;
    v106[1] = eUICC::detail::StateMachine::UpdateMain;
    unint64_t v107 = v106;
    int v108 = 6;
    v109[0] = &unk_26CEC9DB8;
    v109[1] = eUICC::detail::StateMachine::PostProcess;
    uint64_t v110 = v109;
    int v111 = 7;
    v112[0] = &unk_26CEC9DB8;
    v112[1] = eUICC::detail::StateMachine::Retry;
    unsigned int v113 = v112;
    int v114 = 8;
    long long v116 = 0;
    int v117 = 9;
    uint64_t v119 = 0;
    v87[0] = 0;
    v87[1] = 0;
    uint64_t v86 = v87;
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, 0, (uint64_t)&__p);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v93, (uint64_t)&v93);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v96, (uint64_t)&v96);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v99, (uint64_t)&v99);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v102, (uint64_t)&v102);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v105, (uint64_t)&v105);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v108, (uint64_t)&v108);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v111, (uint64_t)&v111);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v114, (uint64_t)&v114);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>((uint64_t *)&v86, (uint64_t *)v87, v117, (uint64_t)&v117);
    if (v119 == v118)
    {
      (*(void (**)(void *))(v118[0] + 32))(v118);
      std::string::value_type v37 = v116;
      if (v116 == v115) {
        goto LABEL_71;
      }
    }
    else
    {
      if (v119) {
        (*(void (**)(void))(*v119 + 40))();
      }
      std::string::value_type v37 = v116;
      if (v116 == v115)
      {
LABEL_71:
        (*(void (**)(void *))(v115[0] + 32))(v115);
        uint64_t v38 = v113;
        if (v113 == v112) {
          goto LABEL_72;
        }
        goto LABEL_45;
      }
    }
    if (v37) {
      (*(void (**)(void *))(*v37 + 40))(v37);
    }
    uint64_t v38 = v113;
    if (v113 == v112)
    {
LABEL_72:
      (*(void (**)(void *))(v112[0] + 32))(v112);
      uint64_t v39 = v110;
      if (v110 == v109) {
        goto LABEL_73;
      }
      goto LABEL_48;
    }
LABEL_45:
    if (v38) {
      (*(void (**)(void *))(*v38 + 40))(v38);
    }
    uint64_t v39 = v110;
    if (v110 == v109)
    {
LABEL_73:
      (*(void (**)(void *))(v109[0] + 32))(v109);
      uint64_t v40 = v107;
      if (v107 == v106) {
        goto LABEL_74;
      }
      goto LABEL_51;
    }
LABEL_48:
    if (v39) {
      (*(void (**)(void *))(*v39 + 40))(v39);
    }
    uint64_t v40 = v107;
    if (v107 == v106)
    {
LABEL_74:
      (*(void (**)(void *))(v106[0] + 32))(v106);
      std::string::value_type v41 = v104;
      if (v104 == v103) {
        goto LABEL_75;
      }
      goto LABEL_54;
    }
LABEL_51:
    if (v40) {
      (*(void (**)(void *))(*v40 + 40))(v40);
    }
    std::string::value_type v41 = v104;
    if (v104 == v103)
    {
LABEL_75:
      (*(void (**)(void *))(v103[0] + 32))(v103);
      uint64_t v42 = v101;
      if (v101 == v100) {
        goto LABEL_76;
      }
      goto LABEL_57;
    }
LABEL_54:
    if (v41) {
      (*(void (**)(void *))(*v41 + 40))(v41);
    }
    uint64_t v42 = v101;
    if (v101 == v100)
    {
LABEL_76:
      (*(void (**)(void *))(v100[0] + 32))(v100);
      uint64_t v43 = v98;
      if (v98 == v97) {
        goto LABEL_77;
      }
      goto LABEL_60;
    }
LABEL_57:
    if (v42) {
      (*(void (**)(void *))(*v42 + 40))(v42);
    }
    uint64_t v43 = v98;
    if (v98 == v97)
    {
LABEL_77:
      (*(void (**)(void *))(v97[0] + 32))(v97);
      std::string::size_type v44 = v95;
      if (v95 == v94) {
        goto LABEL_78;
      }
      goto LABEL_63;
    }
LABEL_60:
    if (v43) {
      (*(void (**)(void *))(*v43 + 40))(v43);
    }
    std::string::size_type v44 = v95;
    if (v95 == v94)
    {
LABEL_78:
      (*(void (**)(void *))(v94[0] + 32))(v94);
      std::string::value_type v45 = v92;
      if (v92 == (void **)&v90) {
        goto LABEL_79;
      }
      goto LABEL_66;
    }
LABEL_63:
    if (v44) {
      (*(void (**)(void *))(*v44 + 40))(v44);
    }
    std::string::value_type v45 = v92;
    if (v92 == (void **)&v90)
    {
LABEL_79:
      ((void (*)(std::__shared_weak_count **))v90[1].__shared_owners_)(&v90);
      uint64_t v46 = v87[0];
      if (!v87[0]) {
        goto LABEL_137;
      }
      goto LABEL_80;
    }
LABEL_66:
    if (v45) {
      (*((void (**)(void **))*v45 + 5))(v45);
    }
    uint64_t v46 = v87[0];
    if (!v87[0])
    {
LABEL_137:
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/eUICC/StateMachine/eUICCStateMachine.cpp", 0x8Eu, (ctu::LogMessageBuffer *)"Assertion failure(((stateMap.end() != def) && def->second) && \"StateMachine is corrupted.\")", v72, v73, v74, v75);
    }
LABEL_80:
    signed int v47 = *a1;
    uint64_t v48 = v87;
    do
    {
      char v49 = v46;
      std::string v50 = v48;
      signed int v51 = *((_DWORD *)v46 + 8);
      unint64_t v52 = v46 + 1;
      if (v51 >= v47)
      {
        unint64_t v52 = v49;
        uint64_t v48 = (void **)v49;
      }
      uint64_t v46 = (void *)*v52;
    }
    while (v46);
    if (v48 == v87) {
      goto LABEL_137;
    }
    std::string::size_type v53 = v51 >= v47 ? v49 : v50;
    if (v47 < *((_DWORD *)v53 + 8)) {
      goto LABEL_137;
    }
    std::string::value_type v54 = v51 >= v47 ? v49 : v50;
    uint64_t v55 = v54[8];
    if (!v55) {
      goto LABEL_137;
    }
    long long __p = v35;
    size_t v90 = v36;
    if (v36)
    {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v55 = v54[8];
      if (!v55) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
    }
    uint64_t v59 = (*(uint64_t (**)(uint64_t, void **, long long *, int *, unint64_t *))(*(void *)v55 + 48))(v55, &__p, &v83, &v88, &v77);
    long long v60 = v90;
    if (v90 && !atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Ret %d from state %s next %s\n", v56, v57, v58, v59);
    BOOL v61 = v59 == 45 || v59 == 0;
    int v62 = v88;
    if (!v61) {
      int v62 = 8;
    }
    *a1 = v62;
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::destroy(v87[0]);
    if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
    if (v59 == 45) {
      break;
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    BOOL v9 = v76;
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Result %d next state %s allowRetry %d\n", v63, v64, v65, v59);
    if (v59 != 0 && v76)
    {
      uint64_t v59 = 0;
      BOOL v9 = 0;
      *a1 = 7;
    }
    if (v59) {
      goto LABEL_122;
    }
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    uint64_t v66 = *a1;
    if (v66 <= 9) {
      goto LABEL_118;
    }
LABEL_134:
    long long v67 = "??????";
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t v66 = *a1;
    if (v66 > 9) {
      goto LABEL_134;
    }
LABEL_118:
    long long v67 = (&off_264489838)[v66];
  }
  _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "eUICC -- back to host to personalize in state %s\n", v63, v64, v65, (char)v67);
  uint64_t v59 = 0;
  unint64_t v68 = v77;
  unint64_t v77 = 0;
  if (v68) {
    goto LABEL_125;
  }
LABEL_126:
  unint64_t v69 = (std::__shared_weak_count *)v81;
  if (v81 && !atomic_fetch_add((atomic_ullong *volatile)(v81 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
    std::__shared_weak_count::__release_weak(v69);
    if (SBYTE7(v85) < 0) {
LABEL_129:
    }
      operator delete(v84[0]);
  }
  else if (SBYTE7(v85) < 0)
  {
    goto LABEL_129;
  }
  return v59;
}

void sub_21DECBB84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  operator delete(v53);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a32);
  if (a42 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t eUICC::detail::StateMachine::Start(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)v17 + 10) = v6;
  v16[15] = v6;
  v17[0] = v6;
  v16[13] = v6;
  v16[14] = v6;
  v16[11] = v6;
  v16[12] = v6;
  v16[9] = v6;
  v16[10] = v6;
  v16[7] = v6;
  v16[8] = v6;
  v16[5] = v6;
  v16[6] = v6;
  v16[3] = v6;
  _OWORD v16[4] = v6;
  v16[1] = v6;
  v16[2] = v6;
  v16[0] = v6;
  (*(void (**)(_OWORD *__return_ptr))(**(void **)a4 + 8))(v16);
  int v13 = eUICC::HowToProceed((unsigned __int8 *)v16, a2, v7, v8, v9, v10, v11, v12);
  switch(v13)
  {
    case 0:
      return 18;
    case 3:
      int v14 = 9;
      break;
    case 2:
      int v14 = 6;
      break;
    default:
      int v14 = 3;
      break;
  }
  uint64_t result = 0;
  *a3 = v14;
  return result;
}

uint64_t eUICC::detail::StateMachine::Perso(uint64_t a1, uint64_t a2, int *a3, void *a4)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)v15 + 10) = v7;
  long long v14 = v7;
  v15[0] = v7;
  v13[13] = v7;
  v13[14] = v7;
  v13[11] = v7;
  v13[12] = v7;
  v13[9] = v7;
  v13[10] = v7;
  v13[7] = v7;
  v13[8] = v7;
  v13[5] = v7;
  v13[6] = v7;
  _OWORD v13[3] = v7;
  v13[4] = v7;
  v13[1] = v7;
  void v13[2] = v7;
  v13[0] = v7;
  (*(void (**)(_OWORD *__return_ptr))(*(void *)*a4 + 8))(v13);
  if (BYTE4(v13[0]) == 1 || *(unsigned char *)(a2 + 40))
  {
    memset(&__p, 170, sizeof(__p));
    eUICC::Firmware::BootloaderVersion((eUICC::Firmware *)v14, BYTE1(v14), &__p);
    uint64_t v8 = eUICC::Perso::Perform(a2, (uint64_t)&__p, a4);
    uint64_t v9 = (_OWORD *)*a4;
    *(_OWORD *)((char *)v9 + 8) = 0u;
    uint64_t v9 = (_OWORD *)((char *)v9 + 8);
    v9[15] = 0u;
    v9[16] = 0u;
    v9[13] = 0u;
    v9[14] = 0u;
    v9[11] = 0u;
    v9[12] = 0u;
    v9[9] = 0u;
    v9[10] = 0u;
    v9[7] = 0u;
    v9[8] = 0u;
    v9[5] = 0u;
    v9[6] = 0u;
    v9[3] = 0u;
    void v9[4] = 0u;
    v9[1] = 0u;
    v9[2] = 0u;
    *(_OWORD *)((char *)v9 + 266) = 0u;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (*(unsigned char *)(a2 + 9)) {
    int v10 = 6;
  }
  else {
    int v10 = 1;
  }
  *a3 = v10;
  return v8;
}

void sub_21DECBF74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t eUICC::detail::StateMachine::Recovery(uint64_t *a1, uint64_t a2, _DWORD *a3, void *a4)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v60[10] = v7;
  long long v59 = v7;
  *(_OWORD *)long long v60 = v7;
  v58[4] = v7;
  v58[5] = v7;
  v58[2] = v7;
  v58[3] = v7;
  v58[0] = v7;
  v58[1] = v7;
  long long v56 = v7;
  long long v57 = v7;
  long long v54 = v7;
  long long v55 = v7;
  long long v53 = v7;
  long long v51 = v7;
  long long v52 = v7;
  long long v49 = v7;
  long long v50 = v7;
  uint64_t v8 = (capabilities::updater *)(*(void *(**)(long long *__return_ptr))(*(void *)*a4 + 8))(&v49);
  int v9 = capabilities::updater::EUICCVinylSuccessStatus(v8);
  if (v49 != v9)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v11, v12, v13, (char)"euiccData.Valid()");
    return 18;
  }
  if (!BYTE7(v50))
  {
    uint64_t v15 = 0;
    goto LABEL_52;
  }
  unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = *a1;
  if (v60[19] < 5u) {
    memset(__p, 0, sizeof(__p));
  }
  else {
    eUICC::eUICCHashedFWDir((eUICC *)__p, (char *)&v59, (uint64_t)&v59 + 3, v10);
  }
  eUICC::Source::GetMainFirmware(v14, (uint64_t)__p, &v47);
  if (SHIBYTE(__p[2]) < 0)
  {
    operator delete(__p[0]);
    unint64_t v19 = v47;
    if (v47)
    {
LABEL_12:
      uint64_t v20 = (void *)(*(uint64_t (**)(unint64_t))(*(void *)v19 + 8))(v19);
      BOOL v24 = *((void *)&v53 + 1) != *v20;
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "SM::Recovery -- normal? %d\n", v21, v22, v23, !v24);
      unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
      if (v24)
      {
        uint64_t v26 = *a1;
        if (v60[19] < 5u) {
          memset(__p, 0, sizeof(__p));
        }
        else {
          eUICC::eUICCHashedFWDir((eUICC *)__p, (char *)&v59, (uint64_t)&v59 + 3, v25);
        }
        eUICC::Source::GetRecoveryForMac((ctu *)((char *)v58 + 3), v26, (const char *)__p, &v44);
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        unint64_t v28 = v44;
        if (!v44) {
          goto LABEL_36;
        }
      }
      else
      {
        unint64_t v28 = v47;
        unint64_t v44 = v47;
        unint64_t v45 = v48;
        if (v48) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v48 + 8), 1uLL, memory_order_relaxed);
        }
        if (!v28)
        {
LABEL_36:
          memset(__p, 170, sizeof(__p));
          ctu::hex((ctu *)((char *)v58 + 3), (const void *)8);
          if (gBBULogMaskGet(void)::once != -1) {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          }
          uint64_t v38 = __p;
          if (SHIBYTE(__p[2]) < 0) {
            LOBYTE(v38) = __p[0];
          }
          _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "SM::Recovery Missing gold with hash %s\n", v35, v36, v37, (char)v38);
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
          int v27 = 2;
          uint64_t v15 = 15;
          uint64_t v39 = (std::__shared_weak_count *)v45;
          if (!v45) {
            goto LABEL_49;
          }
LABEL_47:
          if (!atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
          goto LABEL_49;
        }
      }
      uint64_t v29 = *a4;
      unint64_t v42 = v28;
      uint64_t v43 = (std::__shared_weak_count *)v45;
      if (v45) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(void *)v29 + 32))(v29, &v42);
      uint64_t v33 = v43;
      if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }
      uint64_t v34 = (_OWORD *)*a4;
      *(_OWORD *)((char *)v34 + 8) = 0u;
      uint64_t v34 = (_OWORD *)((char *)v34 + 8);
      v34[15] = 0u;
      v34[16] = 0u;
      v34[13] = 0u;
      v34[14] = 0u;
      v34[11] = 0u;
      v34[12] = 0u;
      v34[9] = 0u;
      v34[10] = 0u;
      v34[7] = 0u;
      v34[8] = 0u;
      v34[5] = 0u;
      v34[6] = 0u;
      v34[3] = 0u;
      v34[4] = 0u;
      v34[1] = 0u;
      v34[2] = 0u;
      *(_OWORD *)((char *)v34 + 266) = 0u;
      if (v15)
      {
        if (gBBULogMaskGet(void)::once == -1) {
          goto LABEL_46;
        }
      }
      else
      {
        uint64_t v15 = (*(uint64_t (**)(void, void, void))(*(void *)*a4 + 16))(*a4, 0, 0);
        if (!v15)
        {
          int v27 = 0;
          uint64_t v39 = (std::__shared_weak_count *)v45;
          if (!v45) {
            goto LABEL_49;
          }
          goto LABEL_47;
        }
        if (gBBULogMaskGet(void)::once == -1)
        {
LABEL_46:
          _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v30, v31, v32, (char)"kBBUReturnSuccess == ret");
          int v27 = 2;
          uint64_t v39 = (std::__shared_weak_count *)v45;
          if (!v45) {
            goto LABEL_49;
          }
          goto LABEL_47;
        }
      }
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      goto LABEL_46;
    }
  }
  else
  {
    unint64_t v19 = v47;
    if (v47) {
      goto LABEL_12;
    }
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v16, v17, v18, (char)"mainFW != nullptr");
  int v27 = 2;
  uint64_t v15 = 15;
LABEL_49:
  uint64_t v40 = (std::__shared_weak_count *)v48;
  if (v48 && !atomic_fetch_add((atomic_ullong *volatile)(v48 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
    if (v27) {
      return v15;
    }
    goto LABEL_52;
  }
  if (!v27) {
LABEL_52:
  }
    *a3 = 2;
  return v15;
}

void sub_21DECC5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DECC608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a23 < 0)
  {
    operator delete(__p);
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a24);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a16);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void sub_21DECC69C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DECC6C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t eUICC::detail::StateMachine::VersionCheck(uint64_t *a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v86 = *MEMORY[0x263EF8340];
  memset(&v82, 0, sizeof(v82));
  std::string v79 = 0;
  char v80 = 0;
  uint64_t v81 = 0;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v85[10] = v6;
  *(_OWORD *)std::string v84 = v6;
  *(_OWORD *)long long v85 = v6;
  v83[13] = v6;
  v83[14] = v6;
  v83[11] = v6;
  v83[12] = v6;
  v83[9] = v6;
  v83[10] = v6;
  v83[7] = v6;
  v83[8] = v6;
  v83[5] = v6;
  v83[6] = v6;
  v83[3] = v6;
  v83[4] = v6;
  v83[1] = v6;
  v83[2] = v6;
  v83[0] = v6;
  (*(void (**)(_OWORD *__return_ptr))(**(void **)a4 + 8))(v83);
  unint64_t v77 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v78 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = *a1;
  if (v85[19] < 5u) {
    memset(&__p, 0, sizeof(__p));
  }
  else {
    eUICC::eUICCHashedFWDir((eUICC *)&__p, (char *)v84, (uint64_t)v84 + 3, v7);
  }
  eUICC::Source::GetMainFirmware(v8, (uint64_t)&__p, &v77);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    unint64_t v74 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v75 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v10 = *a1;
    if (v85[19] >= 5u) {
      goto LABEL_6;
    }
  }
  else
  {
    unint64_t v74 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v75 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v10 = *a1;
    if (v85[19] >= 5u)
    {
LABEL_6:
      eUICC::eUICCHashedFWDir((eUICC *)&__p, (char *)v84, (uint64_t)v84 + 3, v9);
      goto LABEL_9;
    }
  }
  memset(&__p, 0, sizeof(__p));
LABEL_9:
  eUICC::Source::GetGoldFirmware(v10, (uint64_t)&__p, &v74);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v77) {
      goto LABEL_11;
    }
LABEL_22:
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "eUICC Source has no FW, ENG?\n", v12, v13, v14, v68);
    goto LABEL_99;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v77) {
    goto LABEL_22;
  }
LABEL_11:
  if (v74)
  {
    int v15 = capabilities::updater::EUICCVinylSuccessStatus(v11);
    if (LODWORD(v83[0]) == v15)
    {
      eUICC::Firmware::BootloaderVersion((eUICC::Firmware *)LOBYTE(v84[0]), BYTE1(v84[0]), &__p);
      if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v82.__r_.__value_.__l.__data_);
      }
      std::string v82 = __p;
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      uint64_t v22 = &v82;
      if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        LOBYTE(v22) = v82.__r_.__value_.__s.__data_[0];
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Main FW supports %s?\n", v19, v20, v21, (char)v22);
      uint64_t v24 = *a1;
      if (v85[19] < 5u) {
        memset(&__p, 0, sizeof(__p));
      }
      else {
        eUICC::eUICCHashedFWDir((eUICC *)&__p, (char *)v84, (uint64_t)v84 + 3, v23);
      }
      eUICC::Source::GetMainFirmware(v24, (uint64_t)&__p, &v72);
      char v33 = eUICC::Firmware::BundleVersionsSupported(v72, (std::string **)&v79);
      uint64_t v34 = v73;
      if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if ((v33 & 1) == 0)
      {
        exception = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/eUICC/StateMachine/eUICCStateMachine.cpp", 0x105u, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Failed to get the main loader version from Main FW.\")", v62, v63, v64, v69);
        goto LABEL_119;
      }
      uint64_t v36 = (void **)v79;
      uint64_t v35 = v80;
      if (v79 != v80)
      {
        if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v82.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v82.__r_.__value_.__l.__size_;
        }
        if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v38 = &v82;
        }
        else {
          uint64_t v38 = (std::string *)v82.__r_.__value_.__r.__words[0];
        }
        do
        {
          uint64_t v39 = *((unsigned __int8 *)v36 + 23);
          if ((v39 & 0x80u) == 0) {
            uint64_t v40 = (void *)*((unsigned __int8 *)v36 + 23);
          }
          else {
            uint64_t v40 = v36[1];
          }
          if (v40 == (void *)size)
          {
            if ((v39 & 0x80) != 0)
            {
              if (!memcmp(*v36, v38, (size_t)v36[1])) {
                goto LABEL_58;
              }
            }
            else
            {
              if (!*((unsigned char *)v36 + 23))
              {
LABEL_58:
                uint64_t v42 = gBBULogMaskGet(void)::once;
                if (v35 != v36)
                {
                  if (gBBULogMaskGet(void)::once != -1) {
                    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                  }
                  uint64_t v43 = &v82;
                  if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    LOBYTE(v43) = v82.__r_.__value_.__s.__data_[0];
                  }
                  _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Gold FW supports %s?\n", v30, v31, v32, (char)v43);
                  uint64_t v45 = *a1;
                  if (v85[19] < 5u) {
                    memset(&__p, 0, sizeof(__p));
                  }
                  else {
                    eUICC::eUICCHashedFWDir((eUICC *)&__p, (char *)v84, (uint64_t)v84 + 3, v44);
                  }
                  eUICC::Source::GetGoldFirmware(v45, (uint64_t)&__p, &v72);
                  char v46 = eUICC::Firmware::BundleVersionsSupported(v72, (std::string **)&v79);
                  unint64_t v47 = v73;
                  if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                    std::__shared_weak_count::__release_weak(v47);
                  }
                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__p.__r_.__value_.__l.__data_);
                  }
                  if (v46)
                  {
                    long long v49 = (void **)v79;
                    unint64_t v48 = v80;
                    if (v79 == v80) {
                      goto LABEL_96;
                    }
                    if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      std::string::size_type v50 = HIBYTE(v82.__r_.__value_.__r.__words[2]);
                    }
                    else {
                      std::string::size_type v50 = v82.__r_.__value_.__l.__size_;
                    }
                    if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      long long v51 = &v82;
                    }
                    else {
                      long long v51 = (std::string *)v82.__r_.__value_.__r.__words[0];
                    }
                    while (1)
                    {
                      uint64_t v52 = *((unsigned __int8 *)v49 + 23);
                      if ((v52 & 0x80u) == 0) {
                        long long v53 = (void *)*((unsigned __int8 *)v49 + 23);
                      }
                      else {
                        long long v53 = v49[1];
                      }
                      if (v53 == (void *)v50)
                      {
                        if ((v52 & 0x80) != 0)
                        {
                          if (!memcmp(*v49, v51, (size_t)v49[1])) {
                            goto LABEL_94;
                          }
                        }
                        else
                        {
                          if (!*((unsigned char *)v49 + 23))
                          {
LABEL_94:
                            if (v48 != v49)
                            {
                              uint64_t v28 = 0;
                              int v29 = 4;
                              goto LABEL_100;
                            }
LABEL_96:
                            if (gBBULogMaskGet(void)::once != -1) {
                              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                            }
LABEL_98:
                            _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v30, v31, v32, (char)"std::end(bundleVersions) != std::find(bundleVersions.begin(), bundleVersions.end(), cardVersion)");
LABEL_99:
                            uint64_t v28 = 0;
                            int v29 = 6;
                            goto LABEL_100;
                          }
                          uint64_t v54 = 0;
                          while (*((unsigned __int8 *)v49 + v54) == v51->__r_.__value_.__s.__data_[v54])
                          {
                            if (v52 == ++v54) {
                              goto LABEL_94;
                            }
                          }
                        }
                      }
                      v49 += 3;
                      if (v49 == v48) {
                        goto LABEL_96;
                      }
                    }
                  }
                  exception = __cxa_allocate_exception(0x210uLL);
                  _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/eUICC/StateMachine/eUICCStateMachine.cpp", 0x10Au, (ctu::LogMessageBuffer *)"Assertion failure(success && \"Failed to get the gold loader version from Gold FW.\")", v65, v66, v67, v71);
LABEL_119:
                }
LABEL_66:
                if (v42 != -1) {
                  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                }
                goto LABEL_98;
              }
              uint64_t v41 = 0;
              while (*((unsigned __int8 *)v36 + v41) == v38->__r_.__value_.__s.__data_[v41])
              {
                if (v39 == ++v41) {
                  goto LABEL_58;
                }
              }
            }
          }
          v36 += 3;
        }
        while (v36 != v35);
      }
      uint64_t v42 = gBBULogMaskGet(void)::once;
      goto LABEL_66;
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v16, v17, v18, (char)"euiccData.Valid()");
    uint64_t v28 = 18;
    int v29 = 4;
  }
  else
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v12, v13, v14, (char)"goldFirmware");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Main & !Gold?\n", v25, v26, v27, v70);
    uint64_t v28 = 15;
    int v29 = 4;
  }
LABEL_100:
  *a3 = v29;
  long long v55 = (std::__shared_weak_count *)v75;
  if (v75 && !atomic_fetch_add((atomic_ullong *volatile)(v75 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
  long long v56 = (std::__shared_weak_count *)v78;
  if (v78 && !atomic_fetch_add((atomic_ullong *volatile)(v78 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
    std::__shared_weak_count::__release_weak(v56);
  }
  long long v57 = (void **)v79;
  if (v79)
  {
    uint64_t v58 = v80;
    long long v59 = v79;
    if (v80 != v79)
    {
      do
      {
        if (*((char *)v58 - 1) < 0) {
          operator delete(*(v58 - 3));
        }
        v58 -= 3;
      }
      while (v58 != v57);
      long long v59 = v79;
    }
    char v80 = v57;
    operator delete(v59);
  }
  if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v82.__r_.__value_.__l.__data_);
  }
  return v28;
}

void sub_21DECCFD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  __cxa_free_exception(v33);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a23);
  std::vector<std::string>::~vector[abi:ne180100](&a25);
  if ((a33 & 0x80000000) == 0) {
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t eUICC::detail::StateMachine::UpdateGold(uint64_t *a1, uint64_t a2, _DWORD *a3, void *a4)
{
  void (***v20)(void **__return_ptr);
  atomic_ullong *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t (*v32)(uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _OWORD *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  _OWORD *v40;
  _OWORD *v41;
  std::__shared_weak_count *v42;
  capabilities::updater *v44;
  int v45;
  _OWORD *v46;
  char v47;
  long long v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  BOOL v52;
  char v53;
  char v54;
  char v55;
  void *__p[3];
  void (***v57)(void **__return_ptr);
  std::__shared_weak_count *v58;
  CFTypeRef v59;
  void (***v60)(void **__return_ptr);
  std::__shared_weak_count *v61;
  CFTypeRef cf[36];
  _OWORD __dst[18];
  uint64_t v64;

  uint64_t v64 = *MEMORY[0x263EF8340];
  long long v60 = 0;
  uint64_t v61 = 0;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)&__dst[16] + 10) = v8;
  __dst[15] = v8;
  __dst[16] = v8;
  __dst[13] = v8;
  __dst[14] = v8;
  __dst[11] = v8;
  __dst[12] = v8;
  __dst[9] = v8;
  __dst[10] = v8;
  __dst[7] = v8;
  __dst[8] = v8;
  __dst[5] = v8;
  __dst[6] = v8;
  __dst[3] = v8;
  __dst[4] = v8;
  __dst[1] = v8;
  __dst[2] = v8;
  __dst[0] = v8;
  int v9 = (capabilities::updater *)(*(void *(**)(_OWORD *__return_ptr))(*(void *)*a4 + 8))(__dst);
  int v10 = capabilities::updater::EUICCVinylSuccessStatus(v9);
  if (LODWORD(__dst[0]) != v10)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    goto LABEL_6;
  }
  uint64_t v15 = *a1;
  if (BYTE3(__dst[17]) < 5u) {
    memset(cf, 0, 24);
  }
  else {
    eUICC::eUICCHashedFWDir((eUICC *)cf, (char *)&__dst[15], (uint64_t)&__dst[15] + 3, v11);
  }
  eUICC::Source::GetGoldFirmware(v15, (uint64_t)cf, __p);
  uint64_t v20 = (void (***)(void **__return_ptr))__p[0];
  uint64_t v21 = (atomic_ullong *)__p[1];
  __p[0] = 0;
  __p[1] = 0;
  long long v60 = v20;
  uint64_t v61 = (std::__shared_weak_count *)v21;
  if ((SHIBYTE(cf[2]) & 0x80000000) == 0)
  {
    if (v20) {
      goto LABEL_10;
    }
LABEL_29:
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v17, v18, v19, (char)"goldFW");
    uint64_t v16 = 15;
    goto LABEL_56;
  }
  operator delete((void *)cf[0]);
  if (!v20) {
    goto LABEL_29;
  }
LABEL_10:
  uint64_t v25 = (void *)((uint64_t (*)(void *))(*v20)[1])(v20);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "In UpdateGold, fwMac.data = %p\n", v22, v23, v24, (char)v25);
  if (!*(unsigned char *)(a2 + 11) && *v25 == *(void *)((char *)&__dst[9] + 3))
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Gold FW Macs already matching (no forceGold)\n", v26, v27, v28, v53);
    uint64_t v16 = 0;
    *a3 = 5;
  }
  else
  {
    ((void (*)(CFTypeRef *__return_ptr, void (***)(void **__return_ptr)))(*v20)[2])(cf, v20);
    if (cf[0]) {
      uint64_t v32 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
    }
    else {
      uint64_t v32 = 0;
    }
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    if (v32)
    {
      if (*(unsigned char *)(a2 + 11) || *v25 != *(void *)((char *)&__dst[9] + 3))
      {
        char v33 = *a4;
        ((void (*)(CFTypeRef *__return_ptr, void (***)(void **__return_ptr)))(*v20)[2])(&v59, v20);
        uint64_t v16 = (*(uint64_t (**)(uint64_t, CFTypeRef *))(*(void *)v33 + 24))(v33, &v59);
        if (v59) {
          CFRelease(v59);
        }
        uint64_t v37 = (_OWORD *)*a4;
        *(_OWORD *)((char *)v37 + 8) = 0u;
        uint64_t v37 = (_OWORD *)((char *)v37 + 8);
        v37[15] = 0u;
        v37[16] = 0u;
        v37[13] = 0u;
        v37[14] = 0u;
        v37[11] = 0u;
        v37[12] = 0u;
        v37[9] = 0u;
        v37[10] = 0u;
        v37[7] = 0u;
        v37[8] = 0u;
        v37[5] = 0u;
        v37[6] = 0u;
        uint64_t v37[3] = 0u;
        v37[4] = 0u;
        v37[1] = 0u;
        v37[2] = 0u;
        *(_OWORD *)((char *)v37 + 266) = 0u;
        if (v16)
        {
          if (gBBULogMaskGet(void)::once != -1) {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          }
LABEL_55:
          _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v34, v35, v36, (char)"kBBUReturnSuccess == ret");
          goto LABEL_56;
        }
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "successfully pushed Install Ticket\n", v34, v35, v36, v53);
      }
      uint64_t v38 = *a4;
      long long v57 = v20;
      uint64_t v58 = (std::__shared_weak_count *)v21;
      if (v21) {
        atomic_fetch_add_explicit(v21 + 1, 1uLL, memory_order_relaxed);
      }
      uint64_t v16 = (*(uint64_t (**)(uint64_t, void (****)(void **__return_ptr)))(*(void *)v38 + 32))(v38, &v57);
      uint64_t v39 = v58;
      if (v58 && !atomic_fetch_add(&v58->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
        std::__shared_weak_count::__release_weak(v39);
      }
      uint64_t v40 = (_OWORD *)*a4;
      *(_OWORD *)((char *)v40 + 8) = 0u;
      uint64_t v40 = (_OWORD *)((char *)v40 + 8);
      v40[15] = 0u;
      v40[16] = 0u;
      v40[13] = 0u;
      v40[14] = 0u;
      v40[11] = 0u;
      v40[12] = 0u;
      v40[9] = 0u;
      v40[10] = 0u;
      v40[7] = 0u;
      v40[8] = 0u;
      v40[5] = 0u;
      v40[6] = 0u;
      v40[3] = 0u;
      v40[4] = 0u;
      v40[1] = 0u;
      v40[2] = 0u;
      *(_OWORD *)((char *)v40 + 266) = 0u;
      if (v16)
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        goto LABEL_55;
      }
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "successfully streamed Firmware\n", v34, v35, v36, v53);
      uint64_t v16 = (*(uint64_t (**)(void, void, void))(*(void *)*a4 + 16))(*a4, 0, 0);
      uint64_t v41 = (_OWORD *)*a4;
      *(_OWORD *)((char *)v41 + 8) = 0u;
      uint64_t v41 = (_OWORD *)((char *)v41 + 8);
      v41[15] = 0u;
      v41[16] = 0u;
      v41[13] = 0u;
      v41[14] = 0u;
      v41[11] = 0u;
      v41[12] = 0u;
      v41[9] = 0u;
      v41[10] = 0u;
      v41[7] = 0u;
      v41[8] = 0u;
      v41[5] = 0u;
      v41[6] = 0u;
      v41[3] = 0u;
      v41[4] = 0u;
      v41[1] = 0u;
      v41[2] = 0u;
      *(_OWORD *)((char *)v41 + 266) = 0u;
      if (v16)
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        goto LABEL_55;
      }
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "successfully switched back to Normal\n", v34, v35, v36, v54);
      (*(void (**)(CFTypeRef *__return_ptr))(*(void *)*a4 + 8))(cf);
      unint64_t v44 = (capabilities::updater *)memcpy(__dst, cf, 0x11AuLL);
      uint64_t v45 = capabilities::updater::EUICCVinylSuccessStatus(v44);
      if (LODWORD(__dst[0]) == v45)
      {
        char v46 = operator new(0x28uLL);
        unint64_t v47 = (char)v46;
        cf[0] = v46;
        *(_OWORD *)&cf[1] = xmmword_21DFAAF20;
        unint64_t v48 = *(_OWORD *)((char *)&__dst[2] + 8);
        *char v46 = *(_OWORD *)((char *)&__dst[1] + 8);
        v46[1] = v48;
        *((unsigned char *)v46 + 32) = 0;
        memset(__p, 170, sizeof(__p));
        (**v60)(__p);
        uint64_t v52 = std::operator==[abi:ne180100]<std::allocator<char>>((unsigned __int8 *)cf, (unsigned __int8 *)__p);
        if (v52)
        {
          uint64_t v16 = 0;
        }
        else
        {
          if (gBBULogMaskGet(void)::once != -1) {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          }
          uint64_t v16 = 22;
          _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Gold version strings mismatched: Card %s Bundle %s\n", v49, v50, v51, v47);
        }
        if (SHIBYTE(__p[2]) < 0)
        {
          operator delete(__p[0]);
          if ((SHIBYTE(cf[2]) & 0x80000000) == 0)
          {
LABEL_72:
            if (!v52) {
              goto LABEL_56;
            }
            goto LABEL_76;
          }
        }
        else if ((SHIBYTE(cf[2]) & 0x80000000) == 0)
        {
          goto LABEL_72;
        }
        operator delete((void *)cf[0]);
        if (!v52) {
          goto LABEL_56;
        }
LABEL_76:
        *a3 = 5;
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Success!\n", v49, v50, v51, v55);
        goto LABEL_56;
      }
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
LABEL_6:
      _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v12, v13, v14, (char)"euiccData.Valid()");
      uint64_t v16 = 18;
      goto LABEL_56;
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Install gold but no ticket -- back to restored please\n", v29, v30, v31, v53);
    uint64_t v16 = 45;
    *a3 = 4;
  }
LABEL_56:
  uint64_t v42 = v61;
  if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
  return v16;
}

void sub_21DECDAA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20,char a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a23);
  _Unwind_Resume(a1);
}

uint64_t eUICC::detail::StateMachine::UpdateMain(uint64_t *a1, uint64_t a2, _DWORD *a3, void *a4)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  uint64_t v77 = 0;
  unint64_t v78 = 0;
  __p[0] = 0;
  __p[1] = 0;
  CFTypeRef v76 = 0;
  __s1 = 0;
  __n[0] = 0;
  __n[1] = 0;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)&__dst[16] + 10) = v8;
  __dst[15] = v8;
  __dst[16] = v8;
  __dst[13] = v8;
  __dst[14] = v8;
  __dst[11] = v8;
  __dst[12] = v8;
  __dst[9] = v8;
  __dst[10] = v8;
  __dst[7] = v8;
  __dst[8] = v8;
  __dst[5] = v8;
  __dst[6] = v8;
  __dst[3] = v8;
  __dst[4] = v8;
  __dst[1] = v8;
  __dst[2] = v8;
  __dst[0] = v8;
  int v9 = (capabilities::updater *)(*(void *(**)(_OWORD *__return_ptr))(*(void *)*a4 + 8))(__dst);
  int v10 = capabilities::updater::EUICCVinylSuccessStatus(v9);
  if (LODWORD(__dst[0]) != v10)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v12, v13, v14, (char)"euiccData.Valid()");
    uint64_t v16 = 18;
    goto LABEL_93;
  }
  uint64_t v15 = *a1;
  if (BYTE3(__dst[17]) < 5u) {
    memset(cf, 0, 24);
  }
  else {
    eUICC::eUICCHashedFWDir((eUICC *)cf, (char *)&__dst[15], (uint64_t)&__dst[15] + 3, v11);
  }
  eUICC::Source::GetMainFirmware(v15, (uint64_t)cf, &v71);
  uint64_t v20 = v71;
  uint64_t v21 = v72;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  uint64_t v77 = v20;
  unint64_t v78 = v21;
  if ((SHIBYTE(cf[2]) & 0x80000000) == 0)
  {
    if (v20) {
      goto LABEL_10;
    }
LABEL_35:
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v17, v18, v19, (char)"mainFW");
    uint64_t v16 = 15;
    goto LABEL_93;
  }
  operator delete((void *)cf[0]);
  if (!v20) {
    goto LABEL_35;
  }
LABEL_10:
  (**(void (***)(CFTypeRef *__return_ptr, uint64_t))v20)(cf, v20);
  if (SHIBYTE(v76) < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)std::string __p = *(_OWORD *)cf;
  CFTypeRef v76 = cf[2];
  uint64_t v22 = operator new(0x28uLL);
  long long v23 = *(_OWORD *)((char *)&__dst[2] + 8);
  *uint64_t v22 = *(_OWORD *)((char *)&__dst[1] + 8);
  v22[1] = v23;
  *((unsigned char *)v22 + 32) = 0;
  if (SHIBYTE(__n[1]) < 0) {
    operator delete(__s1);
  }
  __s1 = v22;
  *(_OWORD *)__n = xmmword_21DFAAF20;
  uint64_t v27 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v20 + 8))(v20);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  p_s1 = &__s1;
  if ((__n[1] & 0x8000000000000000) != 0) {
    LOBYTE(p_s1) = (_BYTE)__s1;
  }
  _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Update Main:Card %s Bundle %s\n", v24, v25, v26, (char)p_s1);
  if (*(unsigned char *)(a2 + 10)) {
    goto LABEL_39;
  }
  uint64_t v32 = HIBYTE(__n[1]);
  if ((__n[1] & 0x8000000000000000) == 0) {
    size_t v33 = HIBYTE(__n[1]);
  }
  else {
    size_t v33 = __n[0];
  }
  uint64_t v34 = (void *)HIBYTE(v76);
  if (SHIBYTE(v76) < 0) {
    uint64_t v34 = __p[1];
  }
  if ((void *)v33 != v34) {
    goto LABEL_39;
  }
  if (SHIBYTE(v76) >= 0) {
    uint64_t v35 = __p;
  }
  else {
    uint64_t v35 = (void **)__p[0];
  }
  if ((__n[1] & 0x8000000000000000) != 0)
  {
    if (memcmp(__s1, v35, __n[0])) {
      goto LABEL_39;
    }
LABEL_68:
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    uint64_t v52 = "Main FW versions already matching (no forceMain)\n";
LABEL_71:
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", v52, v29, v30, v31, v66);
    uint64_t v16 = 0;
    *a3 = 6;
    goto LABEL_93;
  }
  if (!HIBYTE(__n[1])) {
    goto LABEL_68;
  }
  uint64_t v36 = &__s1;
  while (*(unsigned __int8 *)v36 == *(unsigned __int8 *)v35)
  {
    uint64_t v36 = (void **)((char *)v36 + 1);
    uint64_t v35 = (void **)((char *)v35 + 1);
    if (!--v32) {
      goto LABEL_68;
    }
  }
LABEL_39:
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v20 + 16))(cf, v20);
  if (cf[0]) {
    uint64_t v40 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    uint64_t v40 = 0;
  }
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  if (v40)
  {
    if (*(unsigned char *)(a2 + 10) || *((void *)&__dst[4] + 1) != *v27)
    {
      uint64_t v41 = *a4;
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v20 + 16))(&v70, v20);
      uint64_t v16 = (*(uint64_t (**)(uint64_t, CFTypeRef *))(*(void *)v41 + 24))(v41, &v70);
      if (v70) {
        CFRelease(v70);
      }
      uint64_t v45 = (_OWORD *)*a4;
      *(_OWORD *)((char *)v45 + 8) = 0u;
      uint64_t v45 = (_OWORD *)((char *)v45 + 8);
      v45[15] = 0u;
      v45[16] = 0u;
      v45[13] = 0u;
      v45[14] = 0u;
      v45[11] = 0u;
      v45[12] = 0u;
      v45[9] = 0u;
      v45[10] = 0u;
      v45[7] = 0u;
      v45[8] = 0u;
      v45[5] = 0u;
      v45[6] = 0u;
      v45[3] = 0u;
      v45[4] = 0u;
      v45[1] = 0u;
      unint64_t v45[2] = 0u;
      *(_OWORD *)((char *)v45 + 266) = 0u;
      if (v16)
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v42, v43, v44, (char)"kBBUReturnSuccess == ret");
        goto LABEL_93;
      }
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "successfully pushed Install Ticket\n", v42, v43, v44, v66);
    }
    uint64_t v46 = *a4;
    uint64_t v68 = v20;
    char v69 = v21;
    if (v21) {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v46 + 32))(v46, &v68);
    std::string::size_type v50 = v69;
    if (v69 && !atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
    long long v51 = (_OWORD *)*a4;
    *(_OWORD *)((char *)v51 + 8) = 0u;
    long long v51 = (_OWORD *)((char *)v51 + 8);
    v51[15] = 0u;
    v51[16] = 0u;
    v51[13] = 0u;
    v51[14] = 0u;
    v51[11] = 0u;
    v51[12] = 0u;
    v51[9] = 0u;
    v51[10] = 0u;
    v51[7] = 0u;
    v51[8] = 0u;
    v51[5] = 0u;
    v51[6] = 0u;
    v51[3] = 0u;
    v51[4] = 0u;
    v51[1] = 0u;
    v51[2] = 0u;
    *(_OWORD *)((char *)v51 + 266) = 0u;
    if (v16)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
LABEL_67:
      _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v47, v48, v49, (char)"kBBUReturnSuccess == ret");
      goto LABEL_93;
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "successfully streamed Firmware\n", v47, v48, v49, v66);
    uint64_t v16 = (*(uint64_t (**)(void, void, void))(*(void *)*a4 + 16))(*a4, 0, 0);
    long long v53 = (_OWORD *)*a4;
    *(_OWORD *)((char *)v53 + 8) = 0u;
    long long v53 = (_OWORD *)((char *)v53 + 8);
    v53[15] = 0u;
    v53[16] = 0u;
    v53[13] = 0u;
    v53[14] = 0u;
    v53[11] = 0u;
    v53[12] = 0u;
    v53[9] = 0u;
    v53[10] = 0u;
    v53[7] = 0u;
    v53[8] = 0u;
    v53[5] = 0u;
    v53[6] = 0u;
    v53[3] = 0u;
    v53[4] = 0u;
    v53[1] = 0u;
    v53[2] = 0u;
    *(_OWORD *)((char *)v53 + 266) = 0u;
    if (v16)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      goto LABEL_67;
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "successfully switched back to Normal\n", v47, v48, v49, v67);
    (*(void (**)(CFTypeRef *__return_ptr))(*(void *)*a4 + 8))(cf);
    memcpy(__dst, cf, 0x11AuLL);
    uint64_t v54 = operator new(0x28uLL);
    char v55 = (char)v54;
    cf[0] = v54;
    *(_OWORD *)&cf[1] = xmmword_21DFAAF20;
    long long v56 = *(_OWORD *)((char *)&__dst[2] + 8);
    *uint64_t v54 = *(_OWORD *)((char *)&__dst[1] + 8);
    v54[1] = v56;
    *((unsigned char *)v54 + 32) = 0;
    int v57 = capabilities::updater::EUICCVinylSuccessStatus((capabilities::updater *)v54);
    if (LODWORD(__dst[0]) == v57)
    {
      if (std::operator==[abi:ne180100]<std::allocator<char>>((unsigned __int8 *)cf, (unsigned __int8 *)__p))
      {
        operator delete((void *)cf[0]);
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        uint64_t v52 = "Success!\n";
        goto LABEL_71;
      }
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Main version strings mismatched: Card %s Bundle %s", v61, v62, v63, v55);
      if (SHIBYTE(cf[2]) < 0) {
        operator delete((void *)cf[0]);
      }
      uint64_t v16 = 22;
    }
    else
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Condition <<%s>> failed %s %s/%d\n", v58, v59, v60, (char)"euiccData.Valid()");
      operator delete((void *)cf[0]);
      uint64_t v16 = 18;
    }
  }
  else
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Install main but no ticket -- back to restored please\n", v37, v38, v39, v66);
    uint64_t v16 = 45;
    *a3 = 5;
  }
LABEL_93:
  if ((SHIBYTE(__n[1]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v76) & 0x80000000) == 0) {
      goto LABEL_95;
    }
LABEL_98:
    operator delete(__p[0]);
    uint64_t v64 = v78;
    if (!v78) {
      return v16;
    }
    goto LABEL_99;
  }
  operator delete(__s1);
  if (SHIBYTE(v76) < 0) {
    goto LABEL_98;
  }
LABEL_95:
  uint64_t v64 = v78;
  if (!v78) {
    return v16;
  }
LABEL_99:
  if (!atomic_fetch_add(&v64->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
    std::__shared_weak_count::__release_weak(v64);
  }
  return v16;
}

void sub_21DECE600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a25 < 0)
  {
    operator delete(__p);
    if ((a31 & 0x80000000) == 0)
    {
LABEL_7:
      std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a33);
      _Unwind_Resume(a1);
    }
  }
  else if ((a31 & 0x80000000) == 0)
  {
    goto LABEL_7;
  }
  operator delete(a26);
  goto LABEL_7;
}

uint64_t eUICC::detail::StateMachine::PostProcess(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(*(_DWORD *)(a2 + 4))
  {
    case 1:
      uint64_t v12 = (*(uint64_t (**)(void, void))(*(void *)*a4 + 40))(*a4, 0);
      if (!v12) {
        goto LABEL_7;
      }
      goto LABEL_3;
    case 2:
      uint64_t v12 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a4 + 40))(*a4, 1);
      if (v12)
      {
LABEL_3:
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "Failed to handle post processing request\n", v9, v10, v11, v15);
        *a3 = 9;
        return v12;
      }
      else
      {
LABEL_7:
        *a3 = 9;
        return v12;
      }
    case 3:
      int v14 = 1;
      goto LABEL_10;
    case 4:
      int v14 = 0;
LABEL_10:
      eUICC::ClearMetadata::Perform(v14, a4, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
      break;
    default:
      break;
  }
  *a3 = 9;
  return 0;
}

uint64_t eUICC::detail::StateMachine::Retry(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4)
{
  (*(void (**)(void, void, uint64_t))(*(void *)*a4 + 16))(*a4, 0, 1);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "eUICCStateMachine", "", "...waiting patiently for reset\n", v5, v6, v7, v9);
  __ns.__rep_ = 10000000000;
  std::this_thread::sleep_for (&__ns);
  *a3 = 0;
  return 0;
}

uint64_t std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>::~pair(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
    return a1;
  }
  else
  {
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
    }
    return a1;
  }
}

uint64_t eUICC::HowToProceed(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 8))
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    long long v8 = "eUICC Skip All\n";
LABEL_5:
    _BBULog(22, 0xFFFFFFFFLL, "eUICC", "", v8, a6, a7, a8, v29);
    return 3;
  }
  uint64_t v12 = (capabilities::updater *)capabilities::updater::EUICCVinylSuccessStatus((capabilities::updater *)a1);
  if (*(_DWORD *)a1 == v12)
  {
    memset(v30, 170, sizeof(v30));
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 3;
    LODWORD(__p.__r_.__value_.__l.__data_) = 3223088;
    std::vector<std::string>::vector[abi:ne180100](v30, (uint64_t)&__p, 1uLL);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    memset(&__p, 170, sizeof(__p));
    eUICC::Firmware::BootloaderVersion((eUICC::Firmware *)a1[240], a1[241], &__p);
    uint64_t v16 = v30[0];
    uint64_t v17 = v30[1];
    if (v30[0] != v30[1])
    {
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      while (1)
      {
        uint64_t v20 = *((unsigned __int8 *)v16 + 23);
        if ((v20 & 0x80u) == 0) {
          uint64_t v21 = *((unsigned __int8 *)v16 + 23);
        }
        else {
          uint64_t v21 = v16[1];
        }
        if (v21 == size)
        {
          if ((v20 & 0x80) != 0)
          {
            if (!memcmp((const void *)*v16, p_p, v16[1])) {
              break;
            }
          }
          else
          {
            if (!*((unsigned char *)v16 + 23)) {
              break;
            }
            uint64_t v22 = 0;
            while (*((unsigned __int8 *)v16 + v22) == p_p->__r_.__value_.__s.__data_[v22])
            {
              if (v20 == ++v22) {
                goto LABEL_32;
              }
            }
          }
        }
        v16 += 3;
        if (v16 == v17) {
          goto LABEL_50;
        }
      }
    }
LABEL_32:
    if (v16 == v17)
    {
LABEL_50:
      uint64_t v9 = 1;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_37:
        long long v23 = (void **)v30[0];
        if (v30[0])
        {
          uint64_t v24 = (void **)v30[1];
          uint64_t v25 = v30[0];
          if (v30[1] != v30[0])
          {
            do
            {
              if (*((char *)v24 - 1) < 0) {
                operator delete(*(v24 - 3));
              }
              v24 -= 3;
            }
            while (v24 != v23);
            uint64_t v25 = v30[0];
          }
          v30[1] = v23;
          operator delete(v25);
        }
        return v9;
      }
    }
    else
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICC", "", "eUICC HW present is too old so we will skip updating it\n", v13, v14, v15, v29);
      uint64_t v9 = 3;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_37;
      }
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    goto LABEL_37;
  }
  if (a1[278])
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    long long v8 = "eUICC not stuffed but that's ok!\n";
    goto LABEL_5;
  }
  if (!capabilities::updater::shouldBailOnEUICCError(v12)) {
    return 2;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "eUICC", "", "Bailing on eUICC error due to status %u\n", v26, v27, v28, *(_DWORD *)a1);
  return 0;
}

void sub_21DECECC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::vector<std::string>::~vector[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void sub_21DECECF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void eUICC::eUICCHashedFWDir(eUICC *this, char *a2, uint64_t a3, unsigned __int8 *a4)
{
  unint64_t v74 = 0;
  unint64_t v75 = 0;
  unint64_t v76 = 0;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  long long v73 = v7;
  long long v72 = v7;
  long long v71 = v7;
  long long v70 = v7;
  long long v69 = v7;
  long long v68 = v7;
  long long v67 = v7;
  long long v66 = v7;
  long long v65 = v7;
  long long v62 = v7;
  *(_OWORD *)std::string __p = v7;
  long long v60 = v7;
  long long v59 = v7;
  long long v58 = v7;
  long long v57 = v7;
  uint64_t v8 = MEMORY[0x263F8C340] + 64;
  uint64_t v64 = MEMORY[0x263F8C340] + 64;
  uint64_t v9 = *(void *)(MEMORY[0x263F8C2C8] + 16);
  uint64_t v56 = *(void *)(MEMORY[0x263F8C2C8] + 8);
  *(uint64_t *)((char *)&v56 + *(void *)(v56 - 24)) = v9;
  uint64_t v10 = (std::ios_base *)((char *)&v56 + *(void *)(v56 - 24));
  std::ios_base::init(v10, &v57);
  uint64_t v11 = MEMORY[0x263F8C340] + 24;
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  uint64_t v56 = v11;
  uint64_t v64 = v8;
  std::streambuf::basic_streambuf();
  uint64_t v12 = MEMORY[0x263F8C318] + 16;
  *(void *)&long long v57 = MEMORY[0x263F8C318] + 16;
  __p[0] = 0;
  BYTE7(v62) = 0;
  *((void *)&v62 + 1) = 0;
  LODWORD(v63) = 16;
  std::stringbuf::__init_buf_ptrs[abi:ne180100]((uint64_t)&v57);
  char v13 = *a2;
  char v55 = this;
  uint64_t v54 = v12;
  if ((a2[1] | ((*a2 & 0x7F) << 8)) < 0x301u)
  {
    uint64_t v19 = operator new(0x14uLL);
    *(_OWORD *)uint64_t v19 = *(_OWORD *)a3;
    v19[4] = *(_DWORD *)(a3 + 16);
    uint64_t v20 = (char *)(v19 + 5);
    goto LABEL_34;
  }
  uint64_t v14 = (char *)operator new(0x14uLL);
  unint64_t v75 = v14 + 20;
  unint64_t v76 = (unint64_t)(v14 + 20);
  *(_OWORD *)uint64_t v14 = *(_OWORD *)a3;
  *((_DWORD *)v14 + 4) = *(_DWORD *)(a3 + 16);
  unint64_t v74 = v14;
  uint64_t v15 = operator new(0x28uLL);
  v15[20] = v13;
  *(_OWORD *)(v15 + 4) = *(_OWORD *)(v14 + 4);
  *(_DWORD *)uint64_t v15 = *(_DWORD *)v14;
  uint64_t v16 = v74;
  unint64_t v74 = v15;
  unint64_t v76 = (unint64_t)(v15 + 40);
  if (v16)
  {
    uint64_t v17 = v15 + 21;
    operator delete(v16);
    unint64_t v75 = v15 + 21;
    if ((unint64_t)(v15 + 21) >= v76)
    {
      uint64_t v21 = v74;
      unint64_t v22 = v17 - v74;
      uint64_t v23 = v17 - v74 + 1;
      if (v23 < 0) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v24 = v76 - (void)v74;
      if (2 * (v76 - (unint64_t)v74) > v23) {
        uint64_t v23 = 2 * v24;
      }
      if (v24 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v25 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v25 = v23;
      }
      if (v25) {
        uint64_t v26 = (char *)operator new(v25);
      }
      else {
        uint64_t v26 = 0;
      }
      uint64_t v27 = &v26[v22];
      uint64_t v28 = &v26[v25];
      v26[v22] = a2[1];
      uint64_t v18 = (uint64_t)&v26[v22 + 1];
      if (v17 == v21)
      {
        unint64_t v74 = &v26[v22];
        unint64_t v76 = (unint64_t)v28;
        goto LABEL_32;
      }
      if (v22 < 8) {
        goto LABEL_29;
      }
      if (v22 >= 0x20)
      {
        unint64_t v29 = v22 & 0xFFFFFFFFFFFFFFE0;
        uint64_t v30 = (long long *)(v15 + 5);
        uint64_t v31 = &v26[v15 + 5 - v21];
        unint64_t v32 = v22 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v33 = *v30;
          *((_OWORD *)v31 - 1) = *(v30 - 1);
          *(_OWORD *)uint64_t v31 = v33;
          v31 -= 32;
          v30 -= 2;
          v32 -= 32;
        }
        while (v32);
        if (v22 == v29)
        {
LABEL_31:
          uint64_t v17 = v74;
          unint64_t v74 = v26;
          unint64_t v76 = (unint64_t)v28;
          if (!v17) {
            goto LABEL_33;
          }
LABEL_32:
          operator delete(v17);
          goto LABEL_33;
        }
        if ((v22 & 0x18) == 0)
        {
          v27 -= v29;
          v17 -= v29;
          goto LABEL_29;
        }
      }
      else
      {
        unint64_t v29 = 0;
      }
      v17 -= v22 & 0xFFFFFFFFFFFFFFF8;
      v27 -= v22 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v34 = &v15[-v29 + 13];
      uint64_t v35 = &v26[v34 - v21];
      unint64_t v36 = v29 - (v22 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        uint64_t v37 = *(void *)v34;
        v34 -= 8;
        *(void *)uint64_t v35 = v37;
        v35 -= 8;
        v36 += 8;
      }
      while (v36);
      if (v22 == (v22 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_31;
      }
LABEL_29:
      uint64_t v38 = v27 - 1;
      do
      {
        char v39 = *--v17;
        *v38-- = v39;
      }
      while (v17 != v21);
      goto LABEL_31;
    }
  }
  v15[21] = a2[1];
  uint64_t v18 = (uint64_t)(v15 + 22);
LABEL_33:
  unint64_t v75 = (unsigned char *)v18;
  uint64_t v19 = operator new(0x20uLL);
  *(_OWORD *)uint64_t v19 = 0u;
  *((_OWORD *)v19 + 1) = 0u;
  CC_SHA256(v74, v18 - v74, (unsigned __int8 *)v19);
  uint64_t v20 = (char *)(v19 + 8);
LABEL_34:
  uint64_t v40 = 0;
  unint64_t v41 = v20 - (char *)v19;
  if (v41 <= 1) {
    uint64_t v42 = 1;
  }
  else {
    uint64_t v42 = v41;
  }
  do
  {
    uint64_t v43 = v56;
    *(_DWORD *)((char *)&v57 + *(void *)(v56 - 24)) = *(_DWORD *)((unsigned char *)&v57 + *(void *)(v56 - 24)) & 0xFFFFFFB5 | 8;
    *(void *)((char *)&v58 + *(void *)(v43 - 24)) = 2;
    uint64_t v44 = (char *)&v56 + *(void *)(v43 - 24);
    if (*((_DWORD *)v44 + 36) == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)&v56 + *(void *)(v43 - 24)));
      uint64_t v45 = std::locale::use_facet(&v77, MEMORY[0x263F8C108]);
      ((void (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 32);
      std::locale::~locale(&v77);
    }
    *((_DWORD *)v44 + 36) = 48;
    std::ostream::operator<<();
    ++v40;
  }
  while (v42 != v40);
  if ((v63 & 0x10) != 0)
  {
    uint64_t v49 = *((void *)&v62 + 1);
    uint64_t v46 = v55;
    uint64_t v47 = (uint64_t *)MEMORY[0x263F8C2C8];
    if (*((void *)&v62 + 1) < (unint64_t)v60)
    {
      *((void *)&v62 + 1) = v60;
      uint64_t v49 = v60;
    }
    std::string::size_type v50 = (const void *)*((void *)&v59 + 1);
    size_t v48 = v49 - *((void *)&v59 + 1);
    if ((unint64_t)(v49 - *((void *)&v59 + 1)) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_59;
    }
  }
  else
  {
    uint64_t v46 = v55;
    uint64_t v47 = (uint64_t *)MEMORY[0x263F8C2C8];
    if ((v63 & 8) == 0)
    {
      size_t v48 = 0;
      *((unsigned char *)v55 + 23) = 0;
      goto LABEL_53;
    }
    std::string::size_type v50 = (const void *)v58;
    size_t v48 = v59 - v58;
    if ((void)v59 - (void)v58 >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_59:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v48 >= 0x17)
  {
    uint64_t v51 = (v48 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v48 | 7) != 0x17) {
      uint64_t v51 = v48 | 7;
    }
    uint64_t v52 = v51 + 1;
    long long v53 = (eUICC *)operator new(v51 + 1);
    *((void *)v46 + 1) = v48;
    *((void *)v46 + 2) = v52 | 0x8000000000000000;
    *(void *)uint64_t v46 = v53;
    uint64_t v46 = v53;
    goto LABEL_52;
  }
  *((unsigned char *)v46 + 23) = v48;
  if (v48) {
LABEL_52:
  }
    memmove(v46, v50, v48);
LABEL_53:
  *((unsigned char *)v46 + v48) = 0;
  uint64_t v56 = *v47;
  *(uint64_t *)((char *)&v56 + *(void *)(v56 - 24)) = v47[3];
  *(void *)&long long v57 = v54;
  if (SBYTE7(v62) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](&v64);
  operator delete(v19);
  if (v74) {
    operator delete(v74);
  }
}

void sub_21DECF3C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  std::ostringstream::~ostringstream((uint64_t)&a13);
  operator delete(v27);
  uint64_t v30 = *(void **)(v28 - 120);
  if (v30)
  {
    *(void *)(v28 - 112) = v30;
    operator delete(v30);
  }
  _Unwind_Resume(a1);
}

BOOL std::operator==[abi:ne180100]<std::allocator<char>>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

void *std::__function::__func<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &),std::allocator<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>,BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_26CEC9DB8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &),std::allocator<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>,BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26CEC9DB8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &),std::allocator<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>,BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>::operator()(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5 = *(uint64_t (**)(long long *, uint64_t, uint64_t, uint64_t))(a1 + 8);
  long long v9 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t result = v5(&v9, a3, a4, a5);
  uint64_t v7 = result;
  int v8 = (std::__shared_weak_count *)*((void *)&v9 + 1);
  if (*((void *)&v9 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v9 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
      return v7;
    }
  }
  return result;
}

void sub_21DECF654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    if (!atomic_fetch_add(&a10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &),std::allocator<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>,BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFAB0C1) {
    return a1 + 8;
  }
  if (((v3 & 0x800000021DFAB0C1 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFAB0C1)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFAB0C1 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &),std::allocator<BBUReturn (*)(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>,BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State &,std::unique_ptr<eUICC::eUICCVinylValve> &)>::target_type()
{
}

void *std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  long long v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      unint64_t v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      goto LABEL_22;
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    size_t v11 = v8 >= 0x3FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v10;
    if ((v11 & 0x8000000000000000) != 0) {
LABEL_22:
    }
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    uint64_t result = operator new(v11);
    long long v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    unint64_t v7[2] = (char *)result + v11;
    size_t v12 = a3 - __src;
    if (v12) {
      uint64_t result = memcpy(result, __src, v12);
    }
LABEL_21:
    v7[1] = &v9[v12];
    return result;
  }
  BOOL v13 = (unsigned char *)result[1];
  size_t v14 = v13 - v9;
  if (v13 - v9 >= a4)
  {
    size_t v12 = a3 - __src;
    if (v12) {
      uint64_t result = memmove((void *)*result, __src, v12);
    }
    goto LABEL_21;
  }
  uint64_t v15 = &__src[v14];
  if (v13 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v14);
    long long v9 = (char *)v7[1];
  }
  if (a3 != v15) {
    uint64_t result = memmove(v9, v15, a3 - v15);
  }
  v7[1] = &v9[a3 - v15];
  return result;
}

void std::vector<unsigned char>::__throw_length_error[abi:ne180100]()
{
}

uint64_t ctu::PthreadMutexGuardPolicy<ICEARIContext>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t *std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::__emplace_hint_unique_key_args<eUICC::detail::StateMachine::State,std::pair<eUICC::detail::StateMachine::State const,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>> const&>(uint64_t *result, uint64_t *a2, int a3, uint64_t a4)
{
  int v5 = a2;
  uint64_t v6 = result;
  uint64_t v7 = (uint64_t **)(result + 1);
  if (result + 1 == a2 || (int v8 = *((_DWORD *)a2 + 8), v8 > a3))
  {
    uint64_t v9 = *a2;
    if ((uint64_t *)*result == a2)
    {
      size_t v11 = a2;
LABEL_16:
      if (v9) {
        uint64_t v17 = v11;
      }
      else {
        uint64_t v17 = a2;
      }
      if (v9) {
        BOOL v13 = v11 + 1;
      }
      else {
        BOOL v13 = a2;
      }
      if (*v13) {
        return result;
      }
      int v5 = v17;
LABEL_37:
      unint64_t v22 = operator new(0x48uLL);
      v22[8] = *(_DWORD *)a4;
      uint64_t v23 = *(void *)(a4 + 32);
      if (v23)
      {
        if (v23 == a4 + 8)
        {
          *((void *)v22 + 8) = v22 + 10;
          (*(void (**)(uint64_t))(*(void *)v23 + 24))(v23);
          goto LABEL_47;
        }
        uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 16))(v23);
      }
      *((void *)v22 + 8) = v23;
LABEL_47:
      *(void *)unint64_t v22 = 0;
      *((void *)v22 + 1) = 0;
      *((void *)v22 + 2) = v5;
      *BOOL v13 = (uint64_t)v22;
      uint64_t v25 = *(void *)*v6;
      if (v25)
      {
        uint64_t *v6 = v25;
        unint64_t v22 = (_DWORD *)*v13;
      }
      uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v6[1], (uint64_t *)v22);
      ++v6[2];
      return result;
    }
    if (v9)
    {
      uint64_t v10 = (uint64_t *)*a2;
      do
      {
        size_t v11 = v10;
        uint64_t v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      uint64_t v15 = a2;
      do
      {
        size_t v11 = (uint64_t *)v15[2];
        BOOL v16 = *v11 == (void)v15;
        uint64_t v15 = v11;
      }
      while (v16);
    }
    if (*((_DWORD *)v11 + 8) < a3) {
      goto LABEL_16;
    }
    uint64_t v18 = *v7;
    BOOL v13 = result + 1;
    int v5 = result + 1;
    if (!*v7) {
      goto LABEL_37;
    }
    while (1)
    {
      while (1)
      {
        int v5 = v18;
        int v19 = *((_DWORD *)v18 + 8);
        if (v19 <= a3) {
          break;
        }
        uint64_t v18 = (uint64_t *)*v18;
        BOOL v13 = v5;
        if (!*v5) {
          goto LABEL_37;
        }
      }
      if (v19 >= a3) {
        break;
      }
      uint64_t v18 = (uint64_t *)v18[1];
      if (!v18) {
        goto LABEL_30;
      }
    }
  }
  else
  {
    if (v8 >= a3) {
      return result;
    }
    BOOL v13 = a2 + 1;
    size_t v12 = (uint64_t *)a2[1];
    if (v12)
    {
      do
      {
        BOOL v13 = v12;
        size_t v12 = (uint64_t *)*v12;
        int v5 = v13;
        size_t v14 = v13;
      }
      while (v12);
    }
    else
    {
      size_t v14 = a2;
      do
      {
        uint64_t v20 = v14;
        size_t v14 = (uint64_t *)v14[2];
      }
      while ((uint64_t *)*v14 != v20);
    }
    if (v14 == (uint64_t *)v7) {
      goto LABEL_37;
    }
    if (*((_DWORD *)v14 + 8) > a3) {
      goto LABEL_37;
    }
    uint64_t v21 = *v7;
    BOOL v13 = result + 1;
    int v5 = result + 1;
    if (!*v7) {
      goto LABEL_37;
    }
    while (1)
    {
      while (1)
      {
        int v5 = v21;
        int v24 = *((_DWORD *)v21 + 8);
        if (v24 <= a3) {
          break;
        }
        uint64_t v21 = (uint64_t *)*v21;
        BOOL v13 = v5;
        if (!*v5) {
          goto LABEL_37;
        }
      }
      if (v24 >= a3) {
        break;
      }
      uint64_t v21 = (uint64_t *)v21[1];
      if (!v21)
      {
LABEL_30:
        BOOL v13 = v5 + 1;
        goto LABEL_37;
      }
    }
  }
  return result;
}

void sub_21DECFBD8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::destroy(*a1);
    std::__tree<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::__map_value_compare<eUICC::detail::StateMachine::State,std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>,std::less<eUICC::detail::StateMachine::State>,true>,std::allocator<std::__value_type<eUICC::detail::StateMachine::State,std::function<BBUReturn ()(std::shared_ptr<eUICC::Source>,eUICC::Options const&,eUICC::detail::StateMachine::State&,std::unique_ptr<eUICC::eUICCVinylValve> &)>>>>::destroy(a1[1]);
    uint64_t v2 = (void *)a1[8];
    if (v2 == a1 + 5)
    {
      (*(void (**)(void *))(a1[5] + 32))(a1 + 5);
      uint64_t v3 = a1;
    }
    else
    {
      if (v2) {
        (*(void (**)(void *))(*v2 + 40))(v2);
      }
      uint64_t v3 = a1;
    }
    operator delete(v3);
  }
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);

  operator delete(v1);
}

uint64_t ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get(uint64_t a1)
{
  return *(void *)a1;
}

std::string *std::stringbuf::__init_buf_ptrs[abi:ne180100](uint64_t a1)
{
  *(void *)(a1 + 88) = 0;
  uint64_t result = (std::string *)(a1 + 64);
  unint64_t v3 = *(unsigned __int8 *)(a1 + 87);
  if ((*(char *)(a1 + 87) & 0x80000000) == 0)
  {
    uint64_t v4 = result;
    unint64_t v5 = *(unsigned __int8 *)(a1 + 87);
    int v6 = *(_DWORD *)(a1 + 96);
    if ((v6 & 8) == 0) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  uint64_t v4 = *(std::string **)(a1 + 64);
  unint64_t v5 = *(void *)(a1 + 72);
  int v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
LABEL_3:
    *(void *)(a1 + 88) = (char *)v4 + v5;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = (char *)v4 + v5;
  }
LABEL_4:
  if ((v6 & 0x10) == 0) {
    return result;
  }
  *(void *)(a1 + 88) = (char *)v4 + v5;
  if ((v3 & 0x80) == 0)
  {
    unint64_t v7 = 22;
    if (v3 > 0x15)
    {
      *(unsigned char *)(a1 + 87) = 22;
      goto LABEL_15;
    }
LABEL_11:
    uint64_t result = std::string::append(result, v7 - v3, 0);
    int v8 = *(char *)(a1 + 87);
    if (v8 < 0) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
  unint64_t v3 = *(void *)(a1 + 72);
  unint64_t v7 = (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v3 < v7) {
    goto LABEL_11;
  }
  uint64_t result = *(std::string **)(a1 + 64);
  *(void *)(a1 + 72) = v7;
LABEL_15:
  result->__r_.__value_.__s.__data_[v7] = 0;
  int v8 = *(char *)(a1 + 87);
  if (v8 < 0)
  {
LABEL_16:
    uint64_t v9 = (char *)v4 + *(void *)(a1 + 72);
    *(void *)(a1 + 40) = v4;
    *(void *)(a1 + 48) = v4;
    *(void *)(a1 + 56) = v9;
    if ((*(unsigned char *)(a1 + 96) & 3) == 0) {
      return result;
    }
    goto LABEL_17;
  }
LABEL_12:
  *(void *)(a1 + 40) = v4;
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 56) = (char *)v4 + v8;
  if ((*(unsigned char *)(a1 + 96) & 3) == 0) {
    return result;
  }
LABEL_17:
  if (v5 >> 31)
  {
    uint64_t v10 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
    unint64_t v11 = 0x7FFFFFFF * ((v10 + ((v5 - 0x80000000 - v10) >> 1)) >> 30);
    uint64_t v4 = (std::string *)((char *)v4 + v11 + 0x7FFFFFFF);
    unint64_t v5 = v5 - v11 - 0x7FFFFFFF;
    *(void *)(a1 + 48) = v4;
  }
  if (v5) {
    *(void *)(a1 + 48) = (char *)v4 + v5;
  }
  return result;
}

uint64_t __cxx_global_var_init_1()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ICEARIContext>::~PthreadMutexGuardPolicy, &ctu::Singleton<ICEARIContext,ICEARIContext,ctu::PthreadMutexGuardPolicy<ICEARIContext>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

uint64_t BasebandProvisioning::sendServerReq(BasebandProvisioning *this, const __CFString *a2, const __CFDictionary *a3, CFTypeRef *a4)
{
  v138 = this;
  uint64_t v160 = *MEMORY[0x263EF8340];
  uint64_t v147 = 0;
  CFTypeRef v148 = 0;
  v145 = 0;
  v146 = 0;
  CFTypeRef v144 = 0;
  char v142 = 0;
  std::string __p = 0;
  if (!a2
    || !a4
    || ((CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x263EFFB08],
         this = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]), v6 = this, (v148 = this) != 0)? (unint64_t v7 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get): (unint64_t v7 = 0), !v7))
  {
    ACFULogging::getLogInstance(this);
LABEL_200:
    ACFULogging::handleMessage();
    v136 = 0;
    goto LABEL_207;
  }
  buffer.isa = 0;
  v156.__r_.__value_.__r.__words[0] = 0;
  if (!this)
  {
    ACFULogging::getLogInstance(0);
LABEL_198:
    ACFULogging::handleMessage();
    BOOL v52 = 0;
    goto LABEL_66;
  }
  int v8 = (ACFULogging *)setHttpUriEscapedValue(alloc, this, @"COMMAND_CODE", a2);
  if (v8
    || (int v8 = (ACFULogging *)setHttpUriEscapedValue(alloc, v6, @"TICKET_VERSION", @"2"), v8)
    || (int v8 = (ACFULogging *)setHttpUriEscapedValue(alloc, v6, @"VERSION", @"2"), v8))
  {
    ACFULogging::getLogInstance(v8);
    goto LABEL_198;
  }
  CFIndex Count = CFDictionaryGetCount(*((CFDictionaryRef *)v138 + 10));
  uint64_t v10 = (const void **)malloc(8 * Count);
  unint64_t v11 = (ACFULogging *)malloc(8 * Count);
  size_t v12 = (CFTypeRef *)v11;
  if (!v10)
  {
    ACFULogging::getLogInstance(v11);
    ACFULogging::handleMessage();
    BOOL v52 = 0;
    if (v12) {
      goto LABEL_65;
    }
    goto LABEL_66;
  }
  if (!v11)
  {
LABEL_186:
    ACFULogging::getLogInstance(0);
    goto LABEL_188;
  }
  CFDictionaryGetKeysAndValues(*((CFDictionaryRef *)v138 + 10), v10, (const void **)v11);
  if (Count >= 1)
  {
    size_t v14 = (const __CFString **)v10;
    uint64_t v15 = v12;
    while (*v14)
    {
      if (!*v15) {
        goto LABEL_186;
      }
      CFTypeID v16 = CFGetTypeID(*v15);
      CFTypeID TypeID = CFDataGetTypeID();
      CFStringRef v18 = *v14;
      CFDataRef v19 = (const __CFData *)*v15;
      BOOL v13 = (ACFULogging *)(v16 == TypeID
                          ? setHttpBase64EncodedValue(alloc, v6, v18, v19)
                          : setHttpUriEscapedValue(alloc, v6, v18, (CFStringRef)v19));
      if (v13) {
        break;
      }
      ++v15;
      ++v14;
      if (!--Count) {
        goto LABEL_22;
      }
    }
    goto LABEL_187;
  }
LABEL_22:
  if (CFEqual(a2, @"100"))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a3, @"MarketingPartNumber");
    CFStringRef v21 = Value;
    if (Value)
    {
      CFTypeID v22 = CFGetTypeID(Value);
      BOOL v13 = (ACFULogging *)CFStringGetTypeID();
      if ((ACFULogging *)v22 != v13) {
        goto LABEL_187;
      }
      BOOL v13 = (ACFULogging *)setHttpUriEscapedValue(alloc, v6, @"MPN", v21);
      if (v13) {
        goto LABEL_187;
      }
    }
    CFStringRef v23 = (const __CFString *)CFDictionaryGetValue(a3, @"RegionCode");
    CFStringRef v24 = v23;
    if (v23)
    {
      CFTypeID v25 = CFGetTypeID(v23);
      BOOL v13 = (ACFULogging *)CFStringGetTypeID();
      if ((ACFULogging *)v25 != v13) {
        goto LABEL_187;
      }
      BOOL v13 = (ACFULogging *)setHttpUriEscapedValue(alloc, v6, @"RGN", v24);
      if (v13) {
        goto LABEL_187;
      }
    }
  }
  CFDictionaryRef v26 = (const __CFDictionary *)*((void *)v138 + 11);
  if (!v26) {
    goto LABEL_61;
  }
  CFDataRef v27 = (const __CFData *)CFDictionaryGetValue(v26, @"ChipSerialNo");
  CFDataRef v28 = v27;
  if (v27)
  {
    CFTypeID v29 = CFGetTypeID(v27);
    BOOL v13 = (ACFULogging *)CFDataGetTypeID();
    if ((ACFULogging *)v29 != v13) {
      goto LABEL_187;
    }
    BOOL v13 = (ACFULogging *)setHttpBase64EncodedValue(alloc, v6, @"B64_BB_SNUM", v28);
    if (v13) {
      goto LABEL_187;
    }
  }
  CFComparisonResult v30 = CFStringCompare(a2, @"100", 0);
  CFDictionaryRef v31 = (const __CFDictionary *)*((void *)v138 + 11);
  if (v30 == kCFCompareEqualTo)
  {
    CFDataRef v37 = (const __CFData *)CFDictionaryGetValue(v31, @"EncryptedSessionKey");
    CFDataRef v38 = v37;
    if (!v37
      || (v39 = CFGetTypeID(v37), BOOL v13 = (ACFULogging *)CFDataGetTypeID(), (ACFULogging *)v39 == v13)
      && (BOOL v13 = (ACFULogging *)setHttpBase64EncodedValue(alloc, v6, @"B64_SESS_KEY", v38), !v13))
    {
      CFDataRef v40 = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)v138 + 11), @"SKeyHash");
      CFDataRef v41 = v40;
      if (!v40
        || (v42 = CFGetTypeID(v40), BOOL v13 = (ACFULogging *)CFDataGetTypeID(), (ACFULogging *)v42 == v13)
        && (BOOL v13 = (ACFULogging *)setHttpBase64EncodedValue(alloc, v6, @"B64_SKEY_HASH", v41), !v13))
      {
        int v36 = 0;
        goto LABEL_52;
      }
    }
LABEL_187:
    ACFULogging::getLogInstance(v13);
    goto LABEL_188;
  }
  unint64_t v32 = (__CFString *)CFDictionaryGetValue(v31, @"IMEI");
  if (v32)
  {
    uint64_t ReversedIMEIFromString = createReversedIMEIFromString(v32, (CFTypeRef *)&v156.__r_.__value_.__l.__data_);
    if ((ReversedIMEIFromString & 1) == 0) {
      goto LABEL_234;
    }
    uint64_t v34 = (const void *)v156.__r_.__value_.__r.__words[0];
    if (!v156.__r_.__value_.__r.__words[0]) {
      goto LABEL_234;
    }
    uint64_t v35 = (ACFULogging *)setHttpBase64EncodedValue(alloc, v6, @"B64_IMEI", (CFDataRef)v156.__r_.__value_.__l.__data_);
    if (v35) {
      goto LABEL_238;
    }
    CFRelease(v34);
    v156.__r_.__value_.__r.__words[0] = 0;
    int v36 = 1;
  }
  else
  {
    int v36 = 0;
  }
  uint64_t v43 = (__CFString *)CFDictionaryGetValue(*((CFDictionaryRef *)v138 + 11), @"IMEI2");
  if (!v43) {
    goto LABEL_52;
  }
  uint64_t ReversedIMEIFromString = createReversedIMEIFromString(v43, (CFTypeRef *)&v156.__r_.__value_.__l.__data_);
  if ((ReversedIMEIFromString & 1) == 0 || (uint64_t v44 = (const void *)v156.__r_.__value_.__r.__words[0]) == 0)
  {
LABEL_234:
    ACFULogging::getLogInstance((ACFULogging *)ReversedIMEIFromString);
LABEL_188:
    ACFULogging::handleMessage();
    BOOL v52 = 0;
    free(v10);
    if (!v12) {
      goto LABEL_66;
    }
LABEL_65:
    free(v12);
    goto LABEL_66;
  }
  uint64_t v35 = (ACFULogging *)setHttpBase64EncodedValue(alloc, v6, @"B64_IMEI2", (CFDataRef)v156.__r_.__value_.__l.__data_);
  if (v35)
  {
LABEL_238:
    ACFULogging::getLogInstance(v35);
    ACFULogging::handleMessage();
LABEL_61:
    BOOL v52 = 1;
    free(v10);
    if (!v12) {
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  CFRelease(v44);
  int v36 = 1;
LABEL_52:
  CFDataRef v45 = (const __CFData *)CFDictionaryGetValue(*((CFDictionaryRef *)v138 + 11), @"ChipID");
  CFDataRef v46 = v45;
  if (!v45
    || (v47 = CFGetTypeID(v45), size_t v48 = (ACFULogging *)CFDataGetTypeID(), (ACFULogging *)v47 == v48)
    && (size_t v48 = (ACFULogging *)setHttpBase64EncodedValue(alloc, v6, @"B64_BB_CHIPID", v46), !v48))
  {
    uint64_t v49 = (support::cf *)CFDictionaryGetValue(*((CFDictionaryRef *)v138 + 11), @"EID");
    if (v49)
    {
      uint64_t v51 = (ACFULogging *)support::cf::copyDataFromHexString(v49, &buffer, v50);
      BOOL v52 = (char)v51;
      if (buffer.isa) {
        char v53 = (char)v51;
      }
      else {
        char v53 = 0;
      }
      if (v53)
      {
        setHttpBase64EncodedValue(alloc, v6, @"B64_EID", (CFDataRef)buffer.isa);
        goto LABEL_61;
      }
      ACFULogging::getLogInstance(v51);
      ACFULogging::handleMessage();
    }
    else
    {
      BOOL v52 = 1;
    }
    free(v10);
    if (!v12) {
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  ACFULogging::getLogInstance(v48);
  ACFULogging::handleMessage();
  BOOL v52 = v36 != 0;
  free(v10);
  if (v12) {
    goto LABEL_65;
  }
LABEL_66:
  isa = (ACFULogging *)buffer.isa;
  if (buffer.isa) {
    CFRelease(buffer.isa);
  }
  if (!v52)
  {
    ACFULogging::getLogInstance(isa);
    goto LABEL_200;
  }
  ACFULogging::getLogInstance(isa);
  *((unsigned char *)&v155.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v155, "BasebandProvisioning");
  char v55 = std::string::append(&v155, "::", 2uLL);
  long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
  v156.__r_.__value_.__r.__words[2] = v55->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v156.__r_.__value_.__l.__data_ = v56;
  v55->__r_.__value_.__l.__size_ = 0;
  v55->__r_.__value_.__r.__words[2] = 0;
  v55->__r_.__value_.__r.__words[0] = 0;
  long long v57 = std::string::append(&v156, "sendServerReq", 0xDuLL);
  long long v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
  buffer.data = (char *)v57->__r_.__value_.__r.__words[2];
  *(_OWORD *)&buffer.isa = v58;
  v57->__r_.__value_.__l.__size_ = 0;
  v57->__r_.__value_.__r.__words[2] = 0;
  v57->__r_.__value_.__r.__words[0] = 0;
  ACFULogging::handleMessageCFType();
  if ((SHIBYTE(buffer.data) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v156.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_71;
    }
LABEL_76:
    operator delete(v156.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v155.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_77;
  }
  operator delete(buffer.isa);
  if (SHIBYTE(v156.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_76;
  }
LABEL_71:
  if ((SHIBYTE(v155.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_72;
  }
LABEL_77:
  operator delete(v155.__r_.__value_.__l.__data_);
LABEL_72:
  buffer.isa = 0;
  buffer.info = (uint64_t)&v144;
  char PostBodyFromDictionary = createPostBodyFromDictionary(alloc, v6, (const __CFData **)&buffer);
  uint64_t v60 = *(void *)buffer.info;
  if (buffer.isa)
  {
    *(void *)buffer.info = buffer.isa;
    if (v60) {
      goto LABEL_79;
    }
  }
  else
  {
    *(void *)buffer.info = 0;
    if (v60) {
LABEL_79:
    }
      CFRelease((CFTypeRef)v60);
  }
  if ((PostBodyFromDictionary & 1) == 0
    || !v144
    || (ACFULogging::getLogInstance((ACFULogging *)v60),
        ACFULogging::handleMessage(),
        uint64_t v60 = ctu::cf::assign(),
        (v60 & 1) == 0))
  {
    ACFULogging::getLogInstance((ACFULogging *)v60);
    goto LABEL_200;
  }
  ACFULogging::getLogInstance((ACFULogging *)v60);
  ACFULogging::handleMessage();
  uint64_t v61 = (char *)operator new(0xA0uLL);
  *((void *)v61 + 3) = 850045863;
  *((void *)v61 + 1) = 0;
  *((void *)v61 + 2) = 0;
  *((_OWORD *)v61 + 2) = 0u;
  *((_OWORD *)v61 + 3) = 0u;
  *((_OWORD *)v61 + 4) = 0u;
  *((void *)v61 + 10) = 0;
  *((void *)v61 + 11) = 1018212795;
  *((_OWORD *)v61 + 6) = 0u;
  *((_OWORD *)v61 + 7) = 0u;
  *(_OWORD *)(v61 + 124) = 0u;
  *(void *)uint64_t v61 = &unk_26CEC9F40;
  v152 = (atomic_ullong *)v61;
  CFDataRef theData = (CFDataRef)v61;
  std::mutex::lock((std::mutex *)(v61 + 24));
  int v62 = *((_DWORD *)v61 + 34);
  if ((v62 & 2) != 0) {
    std::__throw_future_error[abi:ne180100](1u);
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)v61 + 1, 1uLL, memory_order_relaxed);
  *((_DWORD *)v61 + 34) = v62 | 2;
  std::mutex::unlock((std::mutex *)(v61 + 24));
  v155.__r_.__value_.__r.__words[0] = 0xAAAAAAAAAAAAAAAALL;
  v155.__r_.__value_.__l.__size_ = 0xAAAAAAAAAAAAAAAALL;
  buffer.info = 0;
  buffer.data = 0;
  buffer.isa = &buffer.info;
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = 0uLL;
  ctu::Http::HttpRequest::create();
  std::string::size_type size = (std::__shared_weak_count *)v154.__r_.__value_.__l.__size_;
  if (v154.__r_.__value_.__l.__size_
    && !atomic_fetch_add((atomic_ullong *volatile)(v154.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
    std::__shared_weak_count::__release_weak(size);
  }
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,ctu::Http::case_insensitive_key_comparer,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)&buffer, buffer.info);
  (*(void (**)(std::string::size_type, void))(*(void *)v155.__r_.__value_.__l.__data_ + 8))(v155.__r_.__value_.__r.__words[0], *((void *)v138 + 4));
  std::string::size_type v64 = v155.__r_.__value_.__r.__words[0];
  dispatch::future_callback_impl<std::shared_ptr<ctu::Http::HttpResponse>,std::shared_ptr<ctu::Http::HttpResponse>>(&v152, &buffer.isa);
  (*(void (**)(std::string::size_type, void *))(*(void *)v64 + 16))(v64, buffer.isa);
  if (buffer.isa) {
    _Block_release(buffer.isa);
  }
  LODWORD(v65) = *((_DWORD *)v138 + 6);
  (*(void (**)(std::string::size_type, double))(*(void *)v155.__r_.__value_.__l.__data_ + 96))(v155.__r_.__value_.__r.__words[0], (double)v65);
  std::string::size_type v66 = v155.__r_.__value_.__r.__words[0];
  long long v67 = (const void *)*((void *)v138 + 5);
  CFTypeRef cf = v67;
  if (v67) {
    CFRetain(v67);
  }
  (*(void (**)(std::string::size_type, CFTypeRef *))(*(void *)v66 + 88))(v66, &cf);
  if (cf) {
    CFRelease(cf);
  }
  (*(void (**)(std::string::size_type, void **))(*(void *)v155.__r_.__value_.__l.__data_ + 56))(v155.__r_.__value_.__r.__words[0], &v145);
  memset(&buffer, 0, 24);
  (*(void (**)(std::string::size_type, __CFString *))(*(void *)v155.__r_.__value_.__l.__data_ + 40))(v155.__r_.__value_.__r.__words[0], &buffer);
  if (SHIBYTE(buffer.data) < 0) {
    operator delete(buffer.isa);
  }
  *(void *)&long long v150 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v150 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v68 = v152;
  v152 = 0;
  std::__assoc_state<std::shared_ptr<ctu::Http::HttpResponse>>::move((uint64_t)v68, &v150);
  if (v68 && !atomic_fetch_add(v68 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v68 + 16))(v68);
  }
  long long v69 = (ACFULogging *)(*(uint64_t (**)(void))(*(void *)v150 + 16))(v150);
  if (v69 == 1)
  {
    long long v69 = (ACFULogging *)(*(uint64_t (**)(void))(*(void *)v150 + 24))(v150);
    if (v69 == 200)
    {
      v136 = (std::__shared_weak_count *)*((void *)&v150 + 1);
      uint64_t v70 = v150;
      long long v71 = (std::__shared_weak_count *)v155.__r_.__value_.__l.__size_;
      if (!v155.__r_.__value_.__l.__size_) {
        goto LABEL_113;
      }
      goto LABEL_111;
    }
  }
  ACFULogging::getLogInstance(v69);
  (*(void (**)(void))(*(void *)v150 + 16))(v150);
  (*(void (**)(void))(*(void *)v150 + 24))(v150);
  (*(void (**)(void))(*(void *)v150 + 32))(v150);
  (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v150 + 72))(&v149);
  ctu::cf::show((uint64_t *)&v156, (ctu::cf *)v149, v72);
  ACFULogging::handleMessage();
  if ((SHIBYTE(v156.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    CFTypeRef v73 = v149;
    if (!v149) {
      goto LABEL_107;
    }
    goto LABEL_106;
  }
  operator delete(v156.__r_.__value_.__l.__data_);
  CFTypeRef v73 = v149;
  if (v149) {
LABEL_106:
  }
    CFRelease(v73);
LABEL_107:
  unint64_t v74 = (std::__shared_weak_count *)*((void *)&v150 + 1);
  if (*((void *)&v150 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v150 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
    std::__shared_weak_count::__release_weak(v74);
  }
  uint64_t v70 = 0;
  v136 = 0;
  long long v71 = (std::__shared_weak_count *)v155.__r_.__value_.__l.__size_;
  if (v155.__r_.__value_.__l.__size_)
  {
LABEL_111:
    if (!atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
LABEL_113:
  unint64_t v75 = v152;
  if (v152 && !atomic_fetch_add(v152 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v75 + 16))(v75);
  }
  unint64_t v76 = (ACFULogging *)std::promise<std::shared_ptr<ctu::Http::HttpResponse>>::~promise((uint64_t *)&theData);
  if (v70)
  {
    ACFULogging::getLogInstance(v76);
    (*(void (**)(uint64_t))(*(void *)v70 + 24))(v70);
    ACFULogging::handleMessage();
    (*(void (**)(uint64_t))(*(void *)v70 + 16))(v70);
    std::locale v77 = (ACFULogging *)ctu::Http::asString();
    __pa = buffer.isa;
    char data_high = HIBYTE(buffer.data);
    ACFULogging::getLogInstance(v77);
    ACFULogging::handleMessage();
    unint64_t v78 = (ACFULogging *)(*(void *(**)(__CFString *__return_ptr, uint64_t))(*(void *)v70 + 48))(&buffer, v70);
    if (data_high < 0) {
      operator delete(__pa);
    }
    std::string __p = buffer.isa;
    char v142 = HIBYTE(buffer.data);
    ACFULogging::getLogInstance(v78);
    std::string v79 = (ACFULogging *)ACFULogging::handleMessage();
    ACFULogging::getLogInstance(v79);
    ACFULogging::handleMessage();
    char v80 = (ACFULogging *)(*(void *(**)(CFDataRef *__return_ptr, uint64_t))(*(void *)v70 + 40))(&theData, v70);
    CFDataRef v81 = theData;
    *(void *)&long long v150 = 0;
    if (theData)
    {
      BytePtr = CFDataGetBytePtr(theData);
      CFIndex Length = CFDataGetLength(v81);
      CFStringRef theString = CFStringCreateWithBytes(alloc, BytePtr, Length, 0x8000100u, 0);
      if (theString)
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
        if (Mutable)
        {
          *(void *)&long long v85 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v85 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)&v159[12] = v85;
          long long v158 = v85;
          *(_OWORD *)v159 = v85;
          *(_OWORD *)&buffer.isa = v85;
          *(_OWORD *)&buffer.data = v85;
          CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(alloc, theString, @"&");
          CFArrayRef v87 = ArrayBySeparatingStrings;
          if (!ArrayBySeparatingStrings || (v88 = CFArrayGetCount(ArrayBySeparatingStrings), (CFIndex v89 = v88) == 0))
          {
            ACFULogging::getLogInstance(0);
            ACFULogging::handleMessage();
            CFRelease(theString);
            char v130 = 0;
LABEL_175:
            CFRelease(Mutable);
            if ((void)v150)
            {
              CFRelease((CFTypeRef)v150);
              *(void *)&long long v150 = 0;
            }
            if (v87) {
              CFRelease(v87);
            }
            unint64_t v76 = theData;
            if (theData) {
              goto LABEL_180;
            }
            goto LABEL_181;
          }
          if (v88 >= 1)
          {
            CFIndex v90 = 0;
            while (1)
            {
              CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v87, v90);
              CFIndex location = CFStringFind(ValueAtIndex, @"=", 0).location;
              if (location != -1) {
                break;
              }
              ACFULogging::getLogInstance((ACFULogging *)0xFFFFFFFFFFFFFFFFLL);
              CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
              ACFULogging::handleMessage();
LABEL_126:
              if (v89 == ++v90) {
                goto LABEL_136;
              }
            }
            CFIndex v93 = CFStringGetLength(ValueAtIndex);
            v162.CFIndex location = 0;
            v162.length = location;
            CFStringRef v94 = CFStringCreateWithSubstring(alloc, ValueAtIndex, v162);
            v163.CFIndex location = location + 1;
            v163.length = v93 + ~location;
            uint64_t v95 = (__CFString *)CFStringCreateWithSubstring(alloc, ValueAtIndex, v163);
            CFStringRef v96 = v95;
            if (v94 && v95)
            {
              CFDictionarySetValue(Mutable, v94, v95);
            }
            else
            {
              ACFULogging::getLogInstance((ACFULogging *)v95);
              CFStringGetCStringPtr(v94, 0x8000100u);
              CFStringGetCStringPtr(v96, 0x8000100u);
              ACFULogging::handleMessage();
              if (!v94) {
                goto LABEL_134;
              }
            }
            CFRelease(v94);
LABEL_134:
            if (v96) {
              CFRelease(v96);
            }
            goto LABEL_126;
          }
LABEL_136:
          uint64_t v97 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"IMEI");
          CFStringRef v98 = (const __CFString *)v97;
          if (v97)
          {
            ACFULogging::getLogInstance(v97);
            CFStringGetCStringPtr(v98, 0x8000100u);
            ACFULogging::handleMessage();
          }
          int v99 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"IMEI2");
          CFStringRef v100 = (const __CFString *)v99;
          if (v99)
          {
            ACFULogging::getLogInstance(v99);
            CFStringGetCStringPtr(v100, 0x8000100u);
            ACFULogging::handleMessage();
          }
          unint64_t v101 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"EID");
          CFStringRef v102 = (const __CFString *)v101;
          if (v101)
          {
            ACFULogging::getLogInstance(v101);
            CFStringGetCStringPtr(v102, 0x8000100u);
            ACFULogging::handleMessage();
          }
          uint64_t v103 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"WIFI_MAC");
          CFStringRef v104 = (const __CFString *)v103;
          if (v103)
          {
            ACFULogging::getLogInstance(v103);
            CFStringGetCStringPtr(v104, 0x8000100u);
            ACFULogging::handleMessage();
          }
          int v105 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"BT_MAC");
          CFStringRef v106 = (const __CFString *)v105;
          if (v105)
          {
            ACFULogging::getLogInstance(v105);
            CFStringGetCStringPtr(v106, 0x8000100u);
            ACFULogging::handleMessage();
          }
          unint64_t v107 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"USB_ETHER_MAC");
          CFStringRef v108 = (const __CFString *)v107;
          if (v107)
          {
            ACFULogging::getLogInstance(v107);
            CFStringGetCStringPtr(v108, 0x8000100u);
            ACFULogging::handleMessage();
          }
          unsigned int v109 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"WIFI_MAC2");
          CFStringRef v110 = (const __CFString *)v109;
          if (v109)
          {
            ACFULogging::getLogInstance(v109);
            CFStringGetCStringPtr(v110, 0x8000100u);
            ACFULogging::handleMessage();
          }
          int v111 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"BT_MAC2");
          CFStringRef v112 = (const __CFString *)v111;
          if (v111)
          {
            ACFULogging::getLogInstance(v111);
            CFStringGetCStringPtr(v112, 0x8000100u);
            ACFULogging::handleMessage();
          }
          unsigned int v113 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"ETH_MAC");
          CFStringRef v114 = (const __CFString *)v113;
          if (v113)
          {
            ACFULogging::getLogInstance(v113);
            CFStringGetCStringPtr(v114, 0x8000100u);
            ACFULogging::handleMessage();
          }
          uint64_t v115 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"ETHER_MAC2");
          CFStringRef v116 = (const __CFString *)v115;
          if (v115)
          {
            ACFULogging::getLogInstance(v115);
            CFStringGetCStringPtr(v116, 0x8000100u);
            ACFULogging::handleMessage();
          }
          int v117 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"T_MAC");
          CFStringRef v118 = (const __CFString *)v117;
          if (v117)
          {
            ACFULogging::getLogInstance(v117);
            CFStringGetCStringPtr(v118, 0x8000100u);
            ACFULogging::handleMessage();
          }
          uint64_t v119 = (ACFULogging *)CFDictionaryGetValue(Mutable, @"B64_SECDATA");
          CFStringRef v120 = (const __CFString *)v119;
          if (!v119) {
            goto LABEL_173;
          }
          ACFULogging::getLogInstance(v119);
          ACFULogging::handleMessage();
          uint64_t v121 = (ACFULogging *)decodeBase64(alloc, v120, (CFTypeRef *)&v150);
          if (!v121)
          {
            if (!(void)v150)
            {
LABEL_228:
              ACFULogging::getLogInstance(0);
              goto LABEL_229;
            }
            uint64_t v121 = (ACFULogging *)CFDataGetLength((CFDataRef)v150);
            if ((unint64_t)v121 > 0x4B)
            {
              v161.CFIndex location = 0;
              v161.length = 76;
              CFDataGetBytes((CFDataRef)v150, v161, (UInt8 *)&buffer);
              if (!*(_DWORD *)&v159[24]) {
                goto LABEL_173;
              }
              uint64_t v122 = CFDataGetBytePtr((CFDataRef)v150);
              CFDataRef v123 = CFDataCreate(alloc, v122 + 76, *(unsigned int *)&v159[24]);
              if (v123)
              {
                CFDictionarySetValue(Mutable, @"MANIFESTDATA", v123);
                ACFULogging::getLogInstance(v124);
                *((unsigned char *)&v154.__r_.__value_.__s + 23) = 20;
                strcpy((char *)&v154, "BasebandProvisioning");
                char v125 = std::string::append(&v154, "::", 2uLL);
                long long v126 = *(_OWORD *)&v125->__r_.__value_.__l.__data_;
                v155.__r_.__value_.__r.__words[2] = v125->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v155.__r_.__value_.__l.__data_ = v126;
                v125->__r_.__value_.__l.__size_ = 0;
                v125->__r_.__value_.__r.__words[2] = 0;
                v125->__r_.__value_.__r.__words[0] = 0;
                std::string v127 = std::string::append(&v155, "copyResponse", 0xCuLL);
                long long v128 = *(_OWORD *)&v127->__r_.__value_.__l.__data_;
                v156.__r_.__value_.__r.__words[2] = v127->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v156.__r_.__value_.__l.__data_ = v128;
                v127->__r_.__value_.__l.__size_ = 0;
                v127->__r_.__value_.__r.__words[2] = 0;
                v127->__r_.__value_.__r.__words[0] = 0;
                ACFULogging::handleMessageCFType();
                if (SHIBYTE(v156.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(v156.__r_.__value_.__l.__data_);
                  if ((SHIBYTE(v155.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                  {
LABEL_166:
                    if ((SHIBYTE(v154.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                      goto LABEL_167;
                    }
LABEL_171:
                    operator delete(v154.__r_.__value_.__l.__data_);
                    v129 = (const void *)*((void *)v138 + 9);
                    *((void *)v138 + 9) = v123;
                    if (v129) {
LABEL_172:
                    }
                      CFRelease(v129);
LABEL_173:
                    *a4 = CFRetain(Mutable);
                    char v130 = 1;
LABEL_174:
                    CFRelease(theString);
                    goto LABEL_175;
                  }
                }
                else if ((SHIBYTE(v155.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
                  goto LABEL_166;
                }
                operator delete(v155.__r_.__value_.__l.__data_);
                if ((SHIBYTE(v154.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                {
LABEL_167:
                  v129 = (const void *)*((void *)v138 + 9);
                  *((void *)v138 + 9) = v123;
                  if (!v129) {
                    goto LABEL_173;
                  }
                  goto LABEL_172;
                }
                goto LABEL_171;
              }
              goto LABEL_228;
            }
          }
          ACFULogging::getLogInstance(v121);
LABEL_229:
          ACFULogging::handleMessage();
          char v130 = 0;
          goto LABEL_174;
        }
        ACFULogging::getLogInstance(0);
        ACFULogging::handleMessage();
        CFRelease(theString);
LABEL_222:
        char v130 = 0;
        unint64_t v76 = theData;
        if (theData) {
LABEL_180:
        }
          CFRelease(v76);
LABEL_181:
        if (v130)
        {
          uint64_t v131 = 1;
          if ((v142 & 0x80000000) == 0) {
            goto LABEL_183;
          }
LABEL_208:
          operator delete(__p);
          std::string v132 = v136;
          if (!v136) {
            goto LABEL_210;
          }
          goto LABEL_209;
        }
        goto LABEL_206;
      }
      ACFULogging::getLogInstance(0);
    }
    else
    {
      ACFULogging::getLogInstance(v80);
    }
    ACFULogging::handleMessage();
    goto LABEL_222;
  }
LABEL_206:
  ACFULogging::getLogInstance(v76);
  ACFULogging::handleMessage();
LABEL_207:
  uint64_t v131 = 0;
  if (v142 < 0) {
    goto LABEL_208;
  }
LABEL_183:
  std::string v132 = v136;
  if (!v136)
  {
LABEL_210:
    CFTypeRef v133 = v144;
    if (!v144) {
      goto LABEL_212;
    }
    goto LABEL_211;
  }
LABEL_209:
  if (atomic_fetch_add(&v132->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_210;
  }
  ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
  std::__shared_weak_count::__release_weak(v132);
  CFTypeRef v133 = v144;
  if (v144) {
LABEL_211:
  }
    CFRelease(v133);
LABEL_212:
  if (v145)
  {
    v146 = v145;
    operator delete(v145);
  }
  if (v148) {
    CFRelease(v148);
  }
  return v131;
}

void sub_21DED1A64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,char a29,uint64_t a30,char a31,void *a32,uint64_t a33,uint64_t a34,char a35,int a36,__int16 a37,char a38,char a39,int a40,__int16 a41,char a42,char a43,uint64_t a44,char a45,uint64_t a46,char a47,void *__p,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t createReversedIMEIFromString(__CFString *a1, CFTypeRef *a2)
{
  unint64_t v3 = a1;
  cf.isa = 0;
  CFIndex Length = CFStringGetLength(a1);
  int v6 = (CFAllocatorRef *)MEMORY[0x263EFFB08];
  if (Length == 15)
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    v26.length = CFStringGetLength(v3) - 1;
    v26.CFIndex location = 0;
    CFStringRef v8 = CFStringCreateWithSubstring(v7, v3, v26);
    unint64_t v3 = (__CFString *)v8;
  }
  else
  {
    CFStringRef v8 = 0;
  }
  uint64_t v9 = (ACFULogging *)support::cf::copyDataFromHexString((support::cf *)v3, &cf, v5);
  if (v9)
  {
    if (cf.isa)
    {
      CFDataRef v10 = (const __CFData *)CFRetain(cf.isa);
      int v11 = 1;
      if (!v8) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }
    ACFULogging::getLogInstance(0);
  }
  else
  {
    ACFULogging::getLogInstance(v9);
  }
  ACFULogging::handleMessage();
  CFDataRef v10 = 0;
  int v11 = 0;
  if (v8) {
LABEL_7:
  }
    CFRelease(v8);
LABEL_8:
  isa = (ACFULogging *)cf.isa;
  if (cf.isa) {
    CFRelease(cf.isa);
  }
  if (!v11)
  {
    ACFULogging::getLogInstance(isa);
    ACFULogging::handleMessage();
    if (!v10) {
      return 0;
    }
    goto LABEL_31;
  }
  if (v10)
  {
    BOOL v13 = (void *)CFDataGetLength(v10);
    if (v13 != (void *)7) {
      goto LABEL_29;
    }
    BYTE6(cf.isa) = *CFDataGetBytePtr(v10);
    BYTE5(cf.isa) = CFDataGetBytePtr(v10)[1];
    BYTE4(cf.isa) = CFDataGetBytePtr(v10)[2];
    BYTE3(cf.isa) = CFDataGetBytePtr(v10)[3];
    BYTE2(cf.isa) = CFDataGetBytePtr(v10)[4];
    BYTE1(cf.isa) = CFDataGetBytePtr(v10)[5];
    LOBYTE(cf.isa) = CFDataGetBytePtr(v10)[6];
    BOOL v13 = CFDataCreate(*v6, (const UInt8 *)&cf, 7);
    if (v13)
    {
      size_t v14 = v13;
      CFTypeRef v15 = CFRetain(v13);
      CFRelease(v14);
      ACFULogging::getLogInstance(v16);
      if (v15)
      {
        *((unsigned char *)&v23.__r_.__value_.__s + 23) = 20;
        strcpy((char *)&v23, "BasebandProvisioning");
        uint64_t v17 = std::string::append(&v23, "::", 2uLL);
        long long v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
        v24.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v18;
        v17->__r_.__value_.__l.__size_ = 0;
        v17->__r_.__value_.__r.__words[2] = 0;
        v17->__r_.__value_.__r.__words[0] = 0;
        CFDataRef v19 = std::string::append(&v24, "createReversedIMEIFromString", 0x1CuLL);
        long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
        cf.data = (char *)v19->__r_.__value_.__r.__words[2];
        *(_OWORD *)&cf.isa = v20;
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        v19->__r_.__value_.__r.__words[0] = 0;
        ACFULogging::handleMessageCFType();
        if (SHIBYTE(cf.data) < 0)
        {
          operator delete(cf.isa);
          if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_17:
            if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_18:
              *a2 = CFRetain(v15);
              CFRelease(v10);
              CFRelease(v15);
              return 1;
            }
LABEL_21:
            operator delete(v23.__r_.__value_.__l.__data_);
            goto LABEL_18;
          }
        }
        else if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_17;
        }
        operator delete(v24.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_18;
        }
        goto LABEL_21;
      }
    }
    else
    {
LABEL_29:
      ACFULogging::getLogInstance((ACFULogging *)v13);
      CFTypeID v22 = (ACFULogging *)ACFULogging::handleMessage();
      ACFULogging::getLogInstance(v22);
    }
    ACFULogging::handleMessage();
LABEL_31:
    CFRelease(v10);
    return 0;
  }
  ACFULogging::getLogInstance(isa);
  ACFULogging::handleMessage();
  return 0;
}

void sub_21DED2154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
  {
    operator delete(__p);
    if ((a23 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a16 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a23 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a18);
  if ((a16 & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(a11);
  _Unwind_Resume(exception_object);
}

const void **ctu::cf::CFSharedRef<__CFError>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void **std::vector<std::pair<std::string,std::vector<unsigned char>>>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    unint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = (void *)*((void *)v3 - 3);
        if (v5)
        {
          *((void *)v3 - 2) = v5;
          operator delete(v5);
        }
        if (*(v3 - 25) < 0) {
          operator delete(*((void **)v3 - 6));
        }
        v3 -= 48;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

const void **ctu::cf::detail::TakeOwnershipProxy<__CFData const>::~TakeOwnershipProxy(const void **a1)
{
  unint64_t v3 = *a1;
  uint64_t v2 = (const void **)a1[1];
  uint64_t v4 = *v2;
  if (v3)
  {
    *uint64_t v2 = v3;
    if (v4) {
      goto LABEL_5;
    }
  }
  else
  {
    *uint64_t v2 = 0;
    if (v4) {
LABEL_5:
    }
      CFRelease(v4);
  }
  return a1;
}

uint64_t createBasebandProvInfo(int a1, void *a2, ACFUFirmware **a3, __CFDictionary **a4)
{
  uint64_t v131 = *MEMORY[0x263EF8340];
  strcpy((char *)bytes, "DeadBeef");
  CFTypeRef v92 = 0;
  CFStringRef v8 = (UInt8 *)operator new(0xFA0uLL);
  bzero(v8, 0xFA0uLL);
  uint64_t v9 = (UInt8 *)operator new(0x4C4uLL);
  bzero(v9, 0x4C4uLL);
  std::string value = 0;
  CFTypeRef v91 = 0;
  int __dst = 0;
  CFTypeRef v87 = 0;
  CFTypeRef cf = 0;
  long long v85 = 0;
  CFStringRef v83 = 0;
  unint64_t v100 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v99[2] = v11;
  v99[3] = v11;
  v99[0] = v11;
  v99[1] = v11;
  *(_OWORD *)cStr = v11;
  CFStringRef v81 = 0;
  CFStringRef v82 = 0;
  if (!*a2 || !*a3 || !a4)
  {
    ACFULogging::getLogInstance(v10);
LABEL_149:
    ACFULogging::handleMessage();
    goto LABEL_150;
  }
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (!Mutable)
  {
    ACFULogging::getLogInstance(0);
    goto LABEL_149;
  }
  if (a1)
  {
    CFDataRef v14 = CFDataCreate(v12, bytes, 9);
    CFDataRef v15 = v14;
    CFTypeRef v92 = v14;
    if (v14) {
      CFTypeID v16 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
    }
    else {
      CFTypeID v16 = 0;
    }
    if (!v16) {
      goto LABEL_139;
    }
    *(_WORD *)CFStringRef v8 = CFDataGetLength(v14);
    v132.CFIndex length = CFDataGetLength(v15);
    v132.CFIndex location = 0;
    CFDataGetBytes(v15, v132, v8 + 2);
    __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
    support::transport::ARI::create((support::transport::ARI *)"BasebandProvisioning", (dispatch_queue_s *)0x2710, 0, 0, (char **)__p);
    long long v18 = __p[0];
    if (!__p[0] || (uint64_t v17 = KTLStartProvision(), (v17 & 1) == 0))
    {
      ACFULogging::getLogInstance((ACFULogging *)v17);
      ACFULogging::handleMessage();
      if (v18) {
        (*(void (**)(void *))(*(void *)v18 + 8))(v18);
      }
      goto LABEL_150;
    }
    (*(void (**)(void *))(*(void *)v18 + 8))(v18);
    CFDataRef v14 = CFDataCreate(v12, v9 + 48, *((unsigned __int16 *)v9 + 23));
    CFTypeRef v91 = v14;
    if (!(v14
         ? ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get
         : 0))
    {
LABEL_139:
      ACFULogging::getLogInstance(v14);
      goto LABEL_149;
    }
    CFDictionaryAddValue(Mutable, @"EncryptedSessionKey", v14);
  }
  long long v20 = (ACFULogging *)(**(void *(***)(void **__return_ptr))*a2)(__p);
  CFStringRef v21 = (const __CFData **)__p[0];
  CFTypeID v22 = (std::__shared_weak_count *)__p[1];
  if (__p[1])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 1, 1uLL, memory_order_relaxed);
    std::string v23 = (std::__shared_weak_count *)__p[1];
    std::string v84 = v21;
    long long v85 = v22;
    int v24 = v103;
    int v86 = v103;
    if (__p[1])
    {
      if (!atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
      int v24 = v86;
    }
  }
  else
  {
    std::string v84 = (const __CFData **)__p[0];
    long long v85 = 0;
    int v24 = v103;
  }
  if (v24)
  {
    ACFULogging::getLogInstance(v20);
    ACFULogging::handleMessage();
    goto LABEL_150;
  }
  __p[0] = v84;
  __p[1] = v85;
  if (v85) {
    atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (*((unsigned char *)v84 + 16))
  {
    CFDataRef v25 = v84[1];
    if (v25)
    {
      BytePtr = CFDataGetBytePtr(v25);
      unint64_t v27 = CFDataGetLength(v84[1]);
      if (v27 <= 4)
      {
        int __dst = 0;
        memcpy(&__dst, BytePtr, v27);
      }
    }
  }
  if (v85 && !atomic_fetch_add(&v85->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
    std::__shared_weak_count::__release_weak(v85);
  }
  CFDataRef v28 = CFDataCreate(v12, (const UInt8 *)&__dst, 4);
  ByteSwappedData = (void *)cf;
  CFTypeRef cf = v28;
  if (ByteSwappedData) {
    CFRelease(ByteSwappedData);
  }
  if (v28) {
    CFComparisonResult v30 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    CFComparisonResult v30 = 0;
  }
  if (!v30) {
    goto LABEL_55;
  }
  CFDictionaryAddValue(Mutable, @"ChipID", v28);
  __p[0] = v84;
  __p[1] = v85;
  if (v85) {
    atomic_fetch_add_explicit(&v85->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  ByteSwappedData = (void *)support::cf::createByteSwappedData(v84[5], (CFDataRef *)&value);
  char v31 = (char)ByteSwappedData;
  if (v85 && !atomic_fetch_add(&v85->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
    std::__shared_weak_count::__release_weak(v85);
  }
  if ((v31 & 1) == 0)
  {
LABEL_55:
    ACFULogging::getLogInstance((ACFULogging *)ByteSwappedData);
    goto LABEL_149;
  }
  CFDictionaryAddValue(Mutable, @"ChipSerialNo", value);
  uint64_t v35 = *a3;
  uint64_t v34 = (std::__shared_weak_count *)a3[1];
  char v80 = v34;
  if (v34) {
    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v95.__r_.__value_.__r.__words[0] = 0;
  v95.__r_.__value_.__l.__size_ = (std::string::size_type)&v87;
  unint64_t v130 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v36 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v36 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v128 = v36;
  long long v129 = v36;
  long long v126 = v36;
  long long v127 = v36;
  long long v124 = v36;
  long long v125 = v36;
  long long v122 = v36;
  long long v123 = v36;
  long long v120 = v36;
  long long v121 = v36;
  long long v118 = v36;
  long long v119 = v36;
  long long v116 = v36;
  long long v117 = v36;
  long long v114 = v36;
  long long v115 = v36;
  long long v112 = v36;
  long long v113 = v36;
  long long v110 = v36;
  long long v111 = v36;
  long long v108 = v36;
  long long v109 = v36;
  long long v106 = v36;
  long long v107 = v36;
  long long v104 = v36;
  long long v105 = v36;
  *(_OWORD *)std::string __p = v36;
  long long v103 = v36;
  CFDictionaryRef theDict = 0;
  CFIndex length = 0xAAAAAAAAAAAAAAAALL;
  if (!v35)
  {
    ACFULogging::getLogInstance(v32);
LABEL_143:
    ACFULogging::handleMessage();
    PersonalizedFirmwarePath = 0;
LABEL_145:
    CFDataRef v44 = 0;
    char v45 = 0;
    goto LABEL_69;
  }
  if (BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS == -1)
  {
    if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS == -1) {
      goto LABEL_50;
    }
LABEL_59:
    dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS, &__block_literal_global_13);
    if (BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS) {
      goto LABEL_51;
    }
    goto LABEL_60;
  }
  dispatch_once(&BBUpdaterCommon::inRestoreOS(void)::sOnceRestoreOS, &__block_literal_global_7);
  if (BBUpdaterCommon::inRestoreOS(void)::sOnceRecoveryOS != -1) {
    goto LABEL_59;
  }
LABEL_50:
  if (BBUpdaterCommon::inRestoreOS(void)::restoreOS | BBUpdaterCommon::inRestoreOS(void)::recoveryOS)
  {
LABEL_51:
    Manifest = (ACFULogging *)ACFUFirmware::getManifest(v35);
    CFDataRef v38 = Manifest;
    PersonalizedFirmwarePath = 0;
    CFDataRef v40 = 0;
    goto LABEL_63;
  }
LABEL_60:
  PersonalizedFirmwarePath = (const void *)ACFUDataAccess::createPersonalizedFirmwarePath((ACFUDataAccess *)@"Baseband", v33);
  if (!PersonalizedFirmwarePath)
  {
    ACFULogging::getLogInstance(0);
    goto LABEL_143;
  }
  GetBasebandTatsuTagToFileNameMap((uint64_t *)&v96);
  RTKitFirmware::create();
  CFDataRef v40 = v93;
  CFIndex v93 = 0;
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy((uint64_t)&v96, (char *)v96.__r_.__value_.__l.__size_);
  if (!v40)
  {
    ACFULogging::getLogInstance(v41);
    ACFULogging::handleMessage();
    goto LABEL_145;
  }
  Manifest = (ACFULogging *)ACFUFirmware::getManifest(v40);
  CFDataRef v38 = Manifest;
LABEL_63:
  if (!v38
    || (CFTypeID v42 = CFDataGetBytePtr(v38),
        CFIndex v43 = CFDataGetLength(v38),
        Manifest = (ACFULogging *)Img4DecodeInitManifest((uint64_t)v42, v43, (uint64_t)__p),
        Manifest)
    || (Img4DecodeGetObjectPropertyData((uint64_t)__p, 1296125520, 1886546793, &theDict, &length), Manifest))
  {
    ACFULogging::getLogInstance(Manifest);
  }
  else
  {
    CFDataRef v44 = CFDataCreate(v12, (const UInt8 *)theDict, length);
    v95.__r_.__value_.__r.__words[0] = (std::string::size_type)v44;
    if (v44)
    {
      char v45 = 1;
      if (!v40) {
        goto LABEL_69;
      }
      goto LABEL_68;
    }
    ACFULogging::getLogInstance(0);
  }
  ACFULogging::handleMessage();
  CFDataRef v44 = 0;
  char v45 = 0;
  if (v40) {
LABEL_68:
  }
    (*(void (**)(ACFUFirmware *))(*(void *)v40 + 56))(v40);
LABEL_69:
  if (PersonalizedFirmwarePath)
  {
    CFRelease(PersonalizedFirmwarePath);
    std::string::size_type size = (void *)v95.__r_.__value_.__l.__size_;
    CFDataRef v44 = (CFDataRef)v95.__r_.__value_.__r.__words[0];
    CFTypeID v47 = *(void **)v95.__r_.__value_.__l.__size_;
    if (v95.__r_.__value_.__r.__words[0]) {
      goto LABEL_71;
    }
  }
  else
  {
    std::string::size_type size = &v87;
    CFTypeID v47 = (void *)v87;
    if (v44)
    {
LABEL_71:
      *std::string::size_type size = v44;
      if (v47) {
        goto LABEL_75;
      }
      goto LABEL_76;
    }
  }
  *std::string::size_type size = 0;
  if (v47) {
LABEL_75:
  }
    CFRelease(v47);
LABEL_76:
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v80->__on_zero_shared)(v80);
    std::__shared_weak_count::__release_weak(v80);
  }
  if ((v45 & 1) == 0
    || (v87
      ? (size_t v48 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get)
      : (size_t v48 = 0),
        !v48))
  {
LABEL_148:
    ACFULogging::getLogInstance((ACFULogging *)v47);
    goto LABEL_149;
  }
  CFDictionaryAddValue(Mutable, @"SKeyHash", v87);
  CFDictionaryRef theDict = 0;
  uint64_t v49 = dlopen("/usr/local/lib/libVinylNonUpdater.dylib", 1);
  std::string::size_type v50 = v49;
  if (!v49) {
    goto LABEL_106;
  }
  uint64_t v51 = dlsym(v49, "VinyleUICCPerformOperation");
  if (!v51)
  {
    CFStringRef Copy = 0;
    goto LABEL_104;
  }
  BOOL v52 = (ACFULogging *)((uint64_t (*)(void, CFDictionaryRef *, void, uint64_t))v51)(0, &theDict, 0, 1);
  ACFULogging::getLogInstance(v52);
  char v53 = (ACFULogging *)ACFULogging::handleMessage();
  CFStringRef Copy = 0;
  if (!v52 && theDict)
  {
    ACFULogging::getLogInstance(v53);
    *((unsigned char *)&v95.__r_.__value_.__s + 23) = 20;
    strcpy((char *)&v95, "BasebandProvisioning");
    char v55 = std::string::append(&v95, "::", 2uLL);
    long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
    v96.__r_.__value_.__r.__words[2] = v55->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v56;
    v55->__r_.__value_.__l.__size_ = 0;
    v55->__r_.__value_.__r.__words[2] = 0;
    v55->__r_.__value_.__r.__words[0] = 0;
    long long v57 = std::string::append(&v96, "copyVinylEID", 0xCuLL);
    long long v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
    *(void *)&long long v103 = *((void *)&v57->__r_.__value_.__l + 2);
    *(_OWORD *)std::string __p = v58;
    v57->__r_.__value_.__l.__size_ = 0;
    v57->__r_.__value_.__r.__words[2] = 0;
    v57->__r_.__value_.__r.__words[0] = 0;
    ACFULogging::handleMessageCFType();
    if (SBYTE7(v103) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_90:
        if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_91;
        }
LABEL_101:
        operator delete(v95.__r_.__value_.__l.__data_);
LABEL_91:
        CFStringRef Copy = (const __CFString *)CFDictionaryGetValue(theDict, @"EID");
        if (!Copy)
        {
LABEL_103:
          CFRelease(theDict);
          goto LABEL_104;
        }
        CFTypeID TypeID = CFStringGetTypeID();
        uint64_t v60 = (ACFULogging *)CFGetTypeID(Copy);
        if ((ACFULogging *)TypeID != v60)
        {
          CFStringRef Copy = 0;
          goto LABEL_103;
        }
        ACFULogging::getLogInstance(v60);
        *((unsigned char *)&v95.__r_.__value_.__s + 23) = 20;
        strcpy((char *)&v95, "BasebandProvisioning");
        uint64_t v61 = std::string::append(&v95, "::", 2uLL);
        long long v62 = *(_OWORD *)&v61->__r_.__value_.__l.__data_;
        v96.__r_.__value_.__r.__words[2] = v61->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v62;
        v61->__r_.__value_.__l.__size_ = 0;
        v61->__r_.__value_.__r.__words[2] = 0;
        v61->__r_.__value_.__r.__words[0] = 0;
        unint64_t v63 = std::string::append(&v96, "copyVinylEID", 0xCuLL);
        long long v64 = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
        *(void *)&long long v103 = *((void *)&v63->__r_.__value_.__l + 2);
        *(_OWORD *)std::string __p = v64;
        v63->__r_.__value_.__l.__size_ = 0;
        v63->__r_.__value_.__r.__words[2] = 0;
        v63->__r_.__value_.__r.__words[0] = 0;
        ACFULogging::handleMessageCFType();
        if (SBYTE7(v103) < 0)
        {
          operator delete(__p[0]);
          if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_95:
            if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_96:
              CFStringRef Copy = CFStringCreateCopy(v12, Copy);
              goto LABEL_103;
            }
LABEL_131:
            operator delete(v95.__r_.__value_.__l.__data_);
            goto LABEL_96;
          }
        }
        else if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_95;
        }
        operator delete(v96.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_96;
        }
        goto LABEL_131;
      }
    }
    else if ((SHIBYTE(v96.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_90;
    }
    operator delete(v96.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v95.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_91;
    }
    goto LABEL_101;
  }
LABEL_104:
  dlclose(v50);
  if (Copy)
  {
    CFStringRef v83 = Copy;
    goto LABEL_107;
  }
LABEL_106:
  CFStringRef v83 = 0;
LABEL_107:
  if (v83) {
    unint64_t v65 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
  }
  else {
    unint64_t v65 = 0;
  }
  if (v65) {
    CFDictionaryAddValue(Mutable, @"EID", v83);
  }
  if (a1) {
    goto LABEL_126;
  }
  __p[0] = (void *)0xAAAAAAAAAAAAAAAALL;
  support::transport::ARI::create((support::transport::ARI *)"BasebandProvisioning", (dispatch_queue_s *)0x2710, 0, 0, (char **)__p);
  long long v67 = __p[0];
  if (__p[0])
  {
    uint64_t v68 = KTLGetIMEI_V2();
    int v69 = v68;
    if ((v68 & 1) == 0)
    {
      ACFULogging::getLogInstance((ACFULogging *)v68);
      ACFULogging::handleMessage();
    }
    uint64_t v70 = (ACFULogging *)(*(uint64_t (**)(void *))(*(void *)v67 + 8))(v67);
    if (v69)
    {
      ACFULogging::getLogInstance(v70);
      long long v71 = (ACFULogging *)ACFULogging::handleMessage();
      ACFULogging::getLogInstance(v71);
      ACFULogging::handleMessage();
      CFStringRef v72 = CFStringCreateWithCString(v12, cStr, 0x8000100u);
      CFTypeID v47 = 0;
      CFStringRef v82 = v72;
      if (v72) {
        CFTypeRef v73 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
      }
      else {
        CFTypeRef v73 = 0;
      }
      if (v73)
      {
        CFStringRef v74 = CFStringCreateWithCString(v12, (const char *)v99 + 4, 0x8000100u);
        CFTypeID v47 = 0;
        CFStringRef v81 = v74;
        if (v74
           ? ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get
           : 0)
        {
          CFDictionaryAddValue(Mutable, @"IMEI", v72);
          CFDictionaryAddValue(Mutable, @"IMEI2", v74);
LABEL_126:
          *a4 = Mutable;
          goto LABEL_127;
        }
      }
      goto LABEL_148;
    }
LABEL_150:
    uint64_t v76 = 0;
    CFStringRef v77 = v81;
    if (!v81) {
      goto LABEL_152;
    }
    goto LABEL_151;
  }
  ACFULogging::getLogInstance(v66);
  ACFULogging::handleMessage();
LABEL_127:
  uint64_t v76 = 1;
  CFStringRef v77 = v81;
  if (v81) {
LABEL_151:
  }
    CFRelease(v77);
LABEL_152:
  if (v82) {
    CFRelease(v82);
  }
  if (v83) {
    CFRelease(v83);
  }
  if (!v85 || atomic_fetch_add(&v85->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    CFTypeRef v78 = v87;
    if (!v87) {
      goto LABEL_160;
    }
    goto LABEL_159;
  }
  ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
  std::__shared_weak_count::__release_weak(v85);
  CFTypeRef v78 = v87;
  if (v87) {
LABEL_159:
  }
    CFRelease(v78);
LABEL_160:
  if (cf) {
    CFRelease(cf);
  }
  if (value) {
    CFRelease(value);
  }
  if (v91) {
    CFRelease(v91);
  }
  operator delete(v9);
  operator delete(v8);
  if (v92) {
    CFRelease(v92);
  }
  return v76;
}

void sub_21DED3230(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, const void *a20,const void *a21,__int16 a22,uint64_t a23,uint64_t a24,const void *a25,const void *a26,uint64_t a27,const void *a28,const void *a29,const void *a30)
{
  ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(&a19);
  ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(&a20);
  ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(&a21);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a22);
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(&a25);
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(&a26);
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(&a28);
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(&a29);
  operator delete(v31);
  operator delete(v30);
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(&a30);
  _Unwind_Resume(a1);
}

const void **ctu::cf::detail::TakeOwnershipProxy<__CFString const>::~TakeOwnershipProxy(const void **a1)
{
  unint64_t v3 = *a1;
  uint64_t v2 = (const void **)a1[1];
  uint64_t v4 = *v2;
  if (v3)
  {
    *uint64_t v2 = v3;
    if (v4) {
      goto LABEL_5;
    }
  }
  else
  {
    *uint64_t v2 = 0;
    if (v4) {
LABEL_5:
    }
      CFRelease(v4);
  }
  return a1;
}

uint64_t ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t configureProvisioner(std::string *a1, CFDictionaryRef theDict)
{
  unint64_t v25 = 0xAAAAAAAA0000003CLL;
  memset(&v24, 0, sizeof(v24));
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"AuthInstallProvisioningServerURL");
  CFStringRef v4 = Value;
  if (!Value)
  {
    ACFULogging::getLogInstance(0);
    goto LABEL_40;
  }
  CFTypeID v5 = CFGetTypeID(Value);
  CFTypeID TypeID = (ACFULogging *)CFStringGetTypeID();
  if ((ACFULogging *)v5 != TypeID)
  {
    ACFULogging::getLogInstance(TypeID);
    goto LABEL_40;
  }
  CStringPtr = CFStringGetCStringPtr(v4, 0x8000100u);
  std::string::__assign_external(&v24, CStringPtr);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v22, v24.__r_.__value_.__l.__data_, v24.__r_.__value_.__l.__size_);
  }
  else {
    std::string v22 = v24;
  }
  int v23 = v25;
  if (&v22 != a1)
  {
    if (SHIBYTE(a1->__r_.__value_.__r.__words[2]) < 0)
    {
      if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFStringRef v8 = &v22;
      }
      else {
        CFStringRef v8 = (std::string *)v22.__r_.__value_.__r.__words[0];
      }
      if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v22.__r_.__value_.__l.__size_;
      }
      std::string::__assign_no_alias<false>((void **)&a1->__r_.__value_.__l.__data_, v8, size);
    }
    else if ((*((unsigned char *)&v22.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(a1, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
    }
    else
    {
      *a1 = v22;
    }
  }
  LODWORD(a1[1].__r_.__value_.__l.__data_) = v23;
  dispatch_queue_t v10 = dispatch_queue_create("BasebandProvisioning", 0);
  long long v11 = a1[1].__r_.__value_.__l.__size_;
  a1[1].__r_.__value_.__l.__size_ = (std::string::size_type)v10;
  if (v11)
  {
    dispatch_release(v11);
    dispatch_queue_t v10 = (dispatch_queue_t)a1[1].__r_.__value_.__l.__size_;
  }
  if (!v10)
  {
    ACFULogging::getLogInstance(0);
    goto LABEL_43;
  }
  getReverseProxySettings((uint64_t)a1, (uint64_t *)&v26);
  CFAllocatorRef v12 = (CFTypeRef *)&a1[1].__r_.__value_.__r.__words[2];
  if (v12 != &v26)
  {
    CFTypeRef v13 = *v12;
    *CFAllocatorRef v12 = v26;
    CFTypeRef v26 = 0;
    if (!v13) {
      goto LABEL_26;
    }
    CFRelease(v13);
  }
  if (v26) {
    CFRelease(v26);
  }
LABEL_26:
  CFDataRef v14 = (void *)*v12;
  if (*v12) {
    CFDataRef v15 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    CFDataRef v15 = 0;
  }
  if (v15)
  {
    CFTypeID v16 = CFGetTypeID(v14);
    uint64_t v17 = (ACFULogging *)CFDictionaryGetTypeID();
    ACFULogging::getLogInstance(v17);
    if ((ACFULogging *)v16 == v17)
    {
      long long v18 = (ACFULogging *)ACFULogging::handleMessage();
      char v19 = 1;
      if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_33;
      }
      goto LABEL_32;
    }
  }
  else
  {
    ACFULogging::getLogInstance((ACFULogging *)v14);
  }
LABEL_43:
  long long v18 = (ACFULogging *)ACFULogging::handleMessage();
  char v19 = 0;
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
LABEL_32:
  }
    operator delete(v22.__r_.__value_.__l.__data_);
LABEL_33:
  if ((v19 & 1) == 0)
  {
    ACFULogging::getLogInstance(v18);
LABEL_40:
    ACFULogging::handleMessage();
    uint64_t v20 = 0;
    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return v20;
    }
    goto LABEL_41;
  }
  uint64_t v20 = 1;
  if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    return v20;
  }
LABEL_41:
  operator delete(v24.__r_.__value_.__l.__data_);
  return v20;
}

void sub_21DED37F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((a24 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a24 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a19);
  _Unwind_Resume(exception_object);
}

uint64_t provisionBaseband(ACFULogging *a1, uint64_t *a2, ACFUFirmware **a3, __CFDictionary **a4)
{
  unint64_t v74 = 0xAAAAAAAAAAAAAAAALL;
  memset(&v73, 0, sizeof(v73));
  long long v75 = 0u;
  long long v76 = 0u;
  *(_OWORD *)CFDataRef theData = 0u;
  long long v78 = 0u;
  CFTypeRef v71 = 0;
  CFTypeRef cf = 0;
  CFDictionaryRef theDict = 0;
  ACFULogging::getLogInstance(a1);
  CFStringRef v8 = (ACFULogging *)ACFULogging::handleMessage();
  if (!a1 || !*a2 || !*a3 || !a4)
  {
    ACFULogging::getLogInstance(v8);
    goto LABEL_91;
  }
  uint64_t v9 = configureProvisioner(&v73, a1);
  if ((v9 & 1) == 0)
  {
    ACFULogging::getLogInstance((ACFULogging *)v9);
    goto LABEL_91;
  }
  ACFULogging::getLogInstance((ACFULogging *)v9);
  ACFULogging::handleMessage();
  APProvisioningInfo = (ACFULogging *)createAPProvisioningInfo((__CFDictionary **)&cf);
  if ((APProvisioningInfo & 1) == 0 || (CFTypeRef v11 = cf) == 0)
  {
    ACFULogging::getLogInstance(APProvisioningInfo);
    goto LABEL_91;
  }
  CFRetain(cf);
  CFAllocatorRef v12 = (const void *)v78;
  *(void *)&long long v78 = v11;
  if (v12) {
    CFRelease(v12);
  }
  CFRelease(v11);
  ACFULogging::getLogInstance(v13);
  *((unsigned char *)&v79.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v79, "BasebandProvisioning");
  CFDataRef v14 = std::string::append(&v79, "::", 2uLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  CFTypeID v16 = std::string::append(&v80, "provisionBaseband", 0x11uLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  *(void *)&v81[1] = *((void *)&v16->__r_.__value_.__l + 2);
  v81[0] = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  ACFULogging::handleMessageCFType();
  if (SBYTE7(v81[1]) < 0)
  {
    operator delete(*(void **)&v81[0]);
    if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_12:
      if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_13;
      }
      goto LABEL_64;
    }
  }
  else if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_12;
  }
  operator delete(v80.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_13:
    long long v18 = (std::__shared_weak_count *)a2[1];
    uint64_t v68 = *a2;
    int v69 = v18;
    if (!v18) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
LABEL_64:
  operator delete(v79.__r_.__value_.__l.__data_);
  long long v18 = (std::__shared_weak_count *)a2[1];
  uint64_t v68 = *a2;
  int v69 = v18;
  if (v18) {
LABEL_14:
  }
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_15:
  char v19 = (atomic_ullong *)a3[1];
  v67[0] = *a3;
  v67[1] = (ACFUFirmware *)v19;
  if (v19) {
    atomic_fetch_add_explicit(v19 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = (ACFULogging *)createBasebandProvInfo(1, &v68, v67, (__CFDictionary **)&v71);
  char v21 = (char)v20;
  if (v19 && !atomic_fetch_add(v19 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(atomic_ullong *))(*v19 + 16))(v19);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v19);
  }
  std::string v22 = v69;
  if (v69 && !atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  if ((v21 & 1) == 0) {
    goto LABEL_81;
  }
  CFTypeRef v23 = v71;
  if (!v71) {
    goto LABEL_81;
  }
  CFRetain(v71);
  std::string v24 = (const void *)*((void *)&v78 + 1);
  *((void *)&v78 + 1) = v23;
  if (v24) {
    CFRelease(v24);
  }
  CFRelease(v23);
  ACFULogging::getLogInstance(v25);
  *((unsigned char *)&v79.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v79, "BasebandProvisioning");
  CFTypeRef v26 = std::string::append(&v79, "::", 2uLL);
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  CFDataRef v28 = std::string::append(&v80, "provisionBaseband", 0x11uLL);
  long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  *(void *)&v81[1] = *((void *)&v28->__r_.__value_.__l + 2);
  v81[0] = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  CFComparisonResult v30 = (ACFULogging *)ACFULogging::handleMessageCFType();
  if ((SBYTE7(v81[1]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
LABEL_67:
    operator delete(v80.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_68;
  }
  operator delete(*(void **)&v81[0]);
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_67;
  }
LABEL_29:
  if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_30;
  }
LABEL_68:
  operator delete(v79.__r_.__value_.__l.__data_);
LABEL_30:
  ACFULogging::getLogInstance(v30);
  ACFULogging::handleMessage();
  char v31 = (ACFULogging *)BasebandProvisioning::sendServerReq((BasebandProvisioning *)&v73, @"100", a1, (CFTypeRef *)&theDict);
  int v32 = (int)v31;
  ACFULogging::getLogInstance(v31);
  if (!v32) {
    goto LABEL_85;
  }
  *((unsigned char *)&v79.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v79, "BasebandProvisioning");
  CFStringRef v33 = std::string::append(&v79, "::", 2uLL);
  long long v34 = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v33->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v34;
  v33->__r_.__value_.__l.__size_ = 0;
  v33->__r_.__value_.__r.__words[2] = 0;
  v33->__r_.__value_.__r.__words[0] = 0;
  uint64_t v35 = std::string::append(&v80, "createProvisionedInfo", 0x15uLL);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  *(void *)&v81[1] = *((void *)&v35->__r_.__value_.__l + 2);
  v81[0] = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  ACFULogging::handleMessageCFType();
  if ((SBYTE7(v81[1]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_33;
    }
LABEL_70:
    operator delete(v80.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_71;
  }
  operator delete(*(void **)&v81[0]);
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_70;
  }
LABEL_33:
  if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_34;
  }
LABEL_71:
  operator delete(v79.__r_.__value_.__l.__data_);
LABEL_34:
  CFStringRef Value = (ACFULogging *)CFDictionaryGetValue(theDict, @"STATUS");
  ACFULogging::getLogInstance(Value);
  if (!Value) {
    goto LABEL_85;
  }
  *((unsigned char *)&v79.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v79, "BasebandProvisioning");
  CFDataRef v38 = std::string::append(&v79, "::", 2uLL);
  long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
  v80.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v39;
  v38->__r_.__value_.__l.__size_ = 0;
  v38->__r_.__value_.__r.__words[2] = 0;
  v38->__r_.__value_.__r.__words[0] = 0;
  CFDataRef v40 = std::string::append(&v80, "createProvisionedInfo", 0x15uLL);
  long long v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  *(void *)&v81[1] = *((void *)&v40->__r_.__value_.__l + 2);
  v81[0] = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  ACFULogging::handleMessageCFType();
  if ((SBYTE7(v81[1]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v80.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_37;
    }
LABEL_73:
    operator delete(v80.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_38;
    }
    goto LABEL_74;
  }
  operator delete(*(void **)&v81[0]);
  if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_73;
  }
LABEL_37:
  if ((SHIBYTE(v79.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_38;
  }
LABEL_74:
  operator delete(v79.__r_.__value_.__l.__data_);
LABEL_38:
  CFTypeID v42 = (ACFULogging *)CFStringCompare((CFStringRef)Value, @"0", 0);
  if (v42)
  {
    ACFULogging::getLogInstance(v42);
LABEL_85:
    std::string::size_type v66 = (ACFULogging *)ACFULogging::handleMessage();
    ACFULogging::getLogInstance(v66);
    goto LABEL_91;
  }
  ACFULogging::getLogInstance(0);
  ACFULogging::handleMessage();
  CFIndex v43 = (UInt8 *)operator new(0xC02uLL);
  CFDataRef v44 = operator new(0xACuLL);
  bzero(v43, 0xC02uLL);
  *(_OWORD *)((char *)v44 + 156) = 0u;
  v44[8] = 0u;
  v44[9] = 0u;
  v44[6] = 0u;
  v44[7] = 0u;
  v44[4] = 0u;
  v44[5] = 0u;
  v44[2] = 0u;
  v44[3] = 0u;
  *CFDataRef v44 = 0u;
  v44[1] = 0u;
  if (theData[1]) {
    char v45 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    char v45 = 0;
  }
  if (!v45)
  {
    ACFULogging::getLogInstance(theData[1]);
LABEL_89:
    uint64_t v55 = 0;
    ACFULogging::handleMessage();
    goto LABEL_94;
  }
  *(_WORD *)CFIndex v43 = CFDataGetLength(theData[1]);
  CFDataRef v46 = theData[1];
  v82.CFIndex length = CFDataGetLength(theData[1]);
  v82.CFIndex location = 0;
  CFDataGetBytes(v46, v82, v43 + 2);
  ACFULogging::getLogInstance(v47);
  ACFULogging::handleMessage();
  LODWORD(v48) = *(unsigned __int16 *)v43;
  if (*(_WORD *)v43)
  {
    int v49 = 0;
    unint64_t v50 = 0;
    do
    {
      unsigned int v51 = v49 + v48;
      if (v51 >= 0x10) {
        uint64_t v52 = 16;
      }
      else {
        uint64_t v52 = v51;
      }
      memset(v81, 170, 24);
      char v53 = (ACFULogging *)ctu::hex((ctu *)&v43[v50 + 2], (const void *)v52);
      ACFULogging::getLogInstance(v53);
      ACFULogging::handleMessage();
      if (SBYTE7(v81[1]) < 0) {
        operator delete(*(void **)&v81[0]);
      }
      v50 += 16;
      unint64_t v48 = *(unsigned __int16 *)v43;
      v49 -= 16;
    }
    while (v50 < v48);
  }
  support::transport::ARI::create((support::transport::ARI *)"BasebandProvisioning", (dispatch_queue_s *)0x2710, 0, 0, (char **)v81);
  uint64_t v55 = *(void *)&v81[0];
  if (!*(void *)&v81[0])
  {
    ACFULogging::getLogInstance(v54);
    goto LABEL_89;
  }
  uint64_t v56 = KTLFinishProvision();
  if (v56)
  {
    memset(v81, 170, 24);
    ctu::hex((ctu *)((char *)v44 + 44), (const void *)7);
    memset(&v80, 170, sizeof(v80));
    long long v57 = (ACFULogging *)ctu::hex((ctu *)((char *)v44 + 60), (const void *)7);
    ACFULogging::getLogInstance(v57);
    long long v58 = (ACFULogging *)ACFULogging::handleMessage();
    ACFULogging::getLogInstance(v58);
    ACFULogging::handleMessage();
    if (SHIBYTE(v80.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v80.__r_.__value_.__l.__data_);
      if ((SBYTE7(v81[1]) & 0x80000000) == 0) {
        goto LABEL_55;
      }
    }
    else if ((SBYTE7(v81[1]) & 0x80000000) == 0)
    {
      goto LABEL_55;
    }
    operator delete(*(void **)&v81[0]);
LABEL_55:
    char v59 = 1;
    operator delete(v44);
    operator delete(v43);
    if (!v55) {
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  ACFULogging::getLogInstance((ACFULogging *)v56);
  ACFULogging::handleMessage();
LABEL_94:
  char v59 = 0;
  operator delete(v44);
  operator delete(v43);
  if (v55) {
LABEL_56:
  }
    uint64_t v20 = (ACFULogging *)(*(uint64_t (**)(uint64_t))(*(void *)v55 + 8))(v55);
LABEL_57:
  if ((v59 & 1) == 0)
  {
LABEL_81:
    ACFULogging::getLogInstance(v20);
    goto LABEL_91;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  uint64_t v61 = Mutable;
  if (!Mutable)
  {
    ACFULogging::getLogInstance(0);
LABEL_91:
    ACFULogging::handleMessage();
    uint64_t v63 = 0;
    CFDictionaryRef v64 = theDict;
    if (!theDict) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
  CFDictionaryAddValue(Mutable, @"ProvisionedInfo", theDict);
  CFDictionaryAddValue(v61, @"BasebandProvInfo", v71);
  *a4 = v61;
  ACFULogging::getLogInstance(v62);
  ACFULogging::handleMessage();
  uint64_t v63 = 1;
  CFDictionaryRef v64 = theDict;
  if (theDict) {
LABEL_60:
  }
    CFRelease(v64);
LABEL_61:
  BasebandProvisioning::~BasebandProvisioning((BasebandProvisioning *)&v73);
  return v63;
}

void sub_21DED4390(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (*(char *)(v26 - 105) < 0)
  {
    operator delete(*(void **)(v26 - 128));
    operator delete(v24);
    operator delete(v23);
    if (!v25)
    {
LABEL_4:
      BasebandProvisioning::~BasebandProvisioning((BasebandProvisioning *)&a23);
      _Unwind_Resume(a1);
    }
  }
  else
  {
    operator delete(v24);
    operator delete(v23);
    if (!v25) {
      goto LABEL_4;
    }
  }
  (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  goto LABEL_4;
}

void sub_21DED4584()
{
  operator delete(v1);
  operator delete(v0);
  if (!v2) {
    JUMPOUT(0x21DED454CLL);
  }
  JUMPOUT(0x21DED4524);
}

void sub_21DED45C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  BasebandProvisioning::~BasebandProvisioning((BasebandProvisioning *)va);
  _Unwind_Resume(a1);
}

void sub_21DED45D4()
{
  if (*(char *)(v2 - 105) < 0) {
    operator delete(*(void **)(v2 - 128));
  }
  operator delete(v1);
  operator delete(v0);
  JUMPOUT(0x21DED454CLL);
}

uint64_t createAPProvisioningInfo(__CFDictionary **a1)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  ACFULogging::getLogInstance((ACFULogging *)a1);
  if (!a1) {
    goto LABEL_68;
  }
  ACFULogging::handleMessage();
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (!Mutable)
  {
    ACFULogging::getLogInstance(0);
    goto LABEL_68;
  }
  CFStringRef v4 = Mutable;
  if (BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken == -1)
  {
    CFTypeID v5 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_8;
    }
  }
  else
  {
    dispatch_once(&BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken, &__block_literal_global_4);
    CFTypeID v5 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_8;
    }
  }
  int v6 = (const void *)v5(@"MLBSerialNumber", 0);
  if (v6)
  {
    CFAllocatorRef v7 = v6;
    CFDictionarySetValue(v4, @"MLB", v6);
    CFRelease(v7);
  }
  if (BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken != -1)
  {
    dispatch_once(&BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken, &__block_literal_global_4);
    CFStringRef v8 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
LABEL_8:
  CFStringRef v8 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
  if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v9 = (const void *)v8(@"ModelNumber", 0);
  if (v9)
  {
    dispatch_queue_t v10 = v9;
    CFDictionarySetValue(v4, @"MPN", v9);
    CFRelease(v10);
  }
  if (BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken != -1)
  {
    dispatch_once(&BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken, &__block_literal_global_4);
    CFTypeRef v11 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_16;
    }
    goto LABEL_13;
  }
LABEL_12:
  CFTypeRef v11 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
  if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
    goto LABEL_16;
  }
LABEL_13:
  CFAllocatorRef v12 = (const void *)v11(@"RegionInfo", 0);
  if (v12)
  {
    CFTypeRef v13 = v12;
    CFDictionarySetValue(v4, @"RGN", v12);
    CFRelease(v13);
  }
  if (BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken != -1)
  {
    dispatch_once(&BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken, &__block_literal_global_4);
    CFDataRef v14 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_22;
    }
    goto LABEL_17;
  }
LABEL_16:
  CFDataRef v14 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
  if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
    goto LABEL_22;
  }
LABEL_17:
  CFNumberRef v15 = (const __CFNumber *)v14(@"UniqueChipID", 0);
  if (v15)
  {
    CFNumberRef v16 = v15;
    *(void *)&valuePtr[0] = 0;
    if (CFNumberGetValue(v15, kCFNumberSInt64Type, valuePtr))
    {
      CFStringRef v17 = CFStringCreateWithFormat(v2, 0, @"%qu", *(void *)&valuePtr[0], "createAPProvisioningInfo");
      if (!v17)
      {
        ACFULogging::getLogInstance(0);
        goto LABEL_68;
      }
      CFStringRef v18 = v17;
      CFDictionarySetValue(v4, @"ECID", v17);
      CFRelease(v18);
    }
    CFRelease(v16);
  }
LABEL_22:
  *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
  valuePtr[6] = v19;
  valuePtr[7] = v19;
  valuePtr[4] = v19;
  valuePtr[5] = v19;
  void valuePtr[2] = v19;
  valuePtr[3] = v19;
  valuePtr[0] = v19;
  valuePtr[1] = v19;
  size_t v57 = 128;
  uint64_t v20 = (ACFULogging *)sysctlbyname("hw.target", valuePtr, &v57, 0, 0);
  if (v20)
  {
    ACFULogging::getLogInstance(v20);
    char v21 = __error();
    strerror(*v21);
    ACFULogging::handleMessage();
    CFStringRef v22 = @"unknown";
  }
  else
  {
    CFStringRef v22 = CFStringCreateWithCString(v2, (const char *)valuePtr, 0x8000100u);
    if (!v22) {
      goto LABEL_32;
    }
  }
  MutableCFStringRef Copy = CFStringCreateMutableCopy(v2, 0, v22);
  CFStringLowercase(MutableCopy, 0);
  CFIndex Length = CFStringGetLength(MutableCopy);
  if (CFStringHasSuffix(MutableCopy, @"ap") == 1)
  {
    uint64_t v25 = -2;
    v26.CFIndex length = 2;
  }
  else
  {
    if (CFStringHasSuffix(MutableCopy, @"dev") != 1) {
      goto LABEL_30;
    }
    uint64_t v25 = -3;
    v26.CFIndex length = 3;
  }
  v26.CFIndex location = v25 + Length;
  CFStringDelete(MutableCopy, v26);
LABEL_30:
  CFRelease(v22);
  if (MutableCopy)
  {
    CFStringUppercase(MutableCopy, 0);
    CFDictionarySetValue(v4, @"PRODUCT", MutableCopy);
    CFRelease(MutableCopy);
  }
LABEL_32:
  if (BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken == -1)
  {
    long long v27 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_36;
    }
  }
  else
  {
    dispatch_once(&BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken, &__block_literal_global_4);
    long long v27 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_36;
    }
  }
  CFDataRef v28 = (const void *)v27(@"SerialNumber", 0);
  if (v28)
  {
    long long v29 = v28;
    CFDictionarySetValue(v4, @"SN", v28);
    CFRelease(v29);
  }
LABEL_36:
  CFStringRef v30 = copy_mac_address_existence(@"WifiAddress");
  if (v30)
  {
    CFStringRef v31 = v30;
    CFDictionarySetValue(v4, @"WIFI_MAC", v30);
    CFRelease(v31);
  }
  CFStringRef v32 = copy_mac_address_existence(@"BluetoothAddress");
  if (v32)
  {
    CFStringRef v33 = v32;
    CFDictionarySetValue(v4, @"BT_MAC", v32);
    CFRelease(v33);
  }
  CFStringRef v34 = copy_mac_address_existence(@"EthernetMacAddress");
  if (v34)
  {
    CFStringRef v35 = v34;
    CFDictionarySetValue(v4, @"USB_ETHER_MAC", v34);
    CFRelease(v35);
  }
  CFStringRef v36 = copy_mac_address_existence(@"SecondaryWifiMacAddress");
  if (v36)
  {
    CFStringRef v37 = v36;
    CFDictionarySetValue(v4, @"WIFI_MAC2", v36);
    CFRelease(v37);
  }
  CFStringRef v38 = copy_mac_address_existence(@"SecondaryBluetoothMacAddress");
  if (v38)
  {
    CFStringRef v39 = v38;
    CFDictionarySetValue(v4, @"BT_MAC2", v38);
    CFRelease(v39);
  }
  CFStringRef v40 = copy_mac_address_existence(@"SecondaryEthernetMacAddress");
  if (v40)
  {
    CFStringRef v41 = v40;
    CFDictionarySetValue(v4, @"ETH_MAC", v40);
    CFRelease(v41);
  }
  CFStringRef v42 = copy_mac_address_existence(@"ExtendedLOMMacAddress");
  if (v42)
  {
    CFStringRef v43 = v42;
    CFDictionarySetValue(v4, @"ETHER_MAC2", v42);
    CFRelease(v43);
  }
  CFStringRef v44 = copy_mac_address_existence(@"PintoMacAddress");
  if (v44)
  {
    CFStringRef v45 = v44;
    CFDictionarySetValue(v4, @"PINTO_MAC", v44);
    CFRelease(v45);
  }
  CFStringRef v46 = copy_mac_address_existence(@"ThreadRadioMacAddressForProvisioning");
  if (v46)
  {
    CFStringRef v47 = v46;
    CFDictionarySetValue(v4, @"T_MAC", v46);
    CFRelease(v47);
  }
  if (BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken == -1)
  {
    unint64_t v48 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_59;
    }
  }
  else
  {
    dispatch_once(&BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken, &__block_literal_global_4);
    unint64_t v48 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_59;
    }
  }
  int v49 = (const void *)v48(@"UniqueDeviceID", 0);
  if (v49)
  {
    unint64_t v50 = v49;
    CFDictionarySetValue(v4, @"UDID", v49);
    CFRelease(v50);
  }
  if (BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken != -1)
  {
    dispatch_once(&BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken, &__block_literal_global_4);
    unsigned int v51 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      goto LABEL_65;
    }
    goto LABEL_60;
  }
LABEL_59:
  unsigned int v51 = (uint64_t (*)(__CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
  if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer)
  {
LABEL_65:
    *a1 = v4;
    return 1;
  }
LABEL_60:
  CFNumberRef v52 = (const __CFNumber *)v51(@"BoardId", 0);
  if (!v52) {
    goto LABEL_65;
  }
  CFNumberRef v53 = v52;
  *(void *)&valuePtr[0] = 0;
  if (!CFNumberGetValue(v52, kCFNumberSInt64Type, valuePtr))
  {
LABEL_64:
    CFRelease(v53);
    goto LABEL_65;
  }
  CFStringRef v54 = CFStringCreateWithFormat(v2, 0, @"%qx", *(void *)&valuePtr[0]);
  if (v54)
  {
    CFStringRef v55 = v54;
    CFDictionarySetValue(v4, @"BoardId", v54);
    CFRelease(v55);
    goto LABEL_64;
  }
  ACFULogging::getLogInstance(0);
LABEL_68:
  ACFULogging::handleMessage();
  return 0;
}

uint64_t sendProvisionPing(ACFULogging *a1, uint64_t *a2, ACFUFirmware **a3, BOOL *a4)
{
  unint64_t v50 = 0xAAAAAAAAAAAAAAAALL;
  memset(&v49, 0, sizeof(v49));
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  CFTypeRef v47 = 0;
  CFTypeRef cf = 0;
  CFDictionaryRef theDict = 0;
  ACFULogging::getLogInstance(a1);
  CFStringRef v8 = (ACFULogging *)ACFULogging::handleMessage();
  if (!a1 || !*a2 || !*a3)
  {
    ACFULogging::getLogInstance(v8);
    goto LABEL_55;
  }
  uint64_t v9 = configureProvisioner(&v49, a1);
  if ((v9 & 1) == 0)
  {
    ACFULogging::getLogInstance((ACFULogging *)v9);
    goto LABEL_55;
  }
  ACFULogging::getLogInstance((ACFULogging *)v9);
  ACFULogging::handleMessage();
  APProvisioningInfo = (ACFULogging *)createAPProvisioningInfo((__CFDictionary **)&cf);
  if ((APProvisioningInfo & 1) == 0 || (CFTypeRef v11 = cf) == 0)
  {
    ACFULogging::getLogInstance(APProvisioningInfo);
    goto LABEL_55;
  }
  CFRetain(cf);
  CFAllocatorRef v12 = (const void *)v54;
  *(void *)&long long v54 = v11;
  if (v12) {
    CFRelease(v12);
  }
  CFRelease(v11);
  ACFULogging::getLogInstance(v13);
  *((unsigned char *)&v42.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v42, "BasebandProvisioning");
  CFDataRef v14 = std::string::append(&v42, "::", 2uLL);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  CFNumberRef v16 = std::string::append(&v43, "sendProvisionPing", 0x11uLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  std::string::size_type v45 = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  ACFULogging::handleMessageCFType();
  if (SHIBYTE(v45) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_11:
      if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_12;
      }
      goto LABEL_40;
    }
  }
  else if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_11;
  }
  operator delete(v43.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_12:
    CFStringRef v18 = (std::__shared_weak_count *)a2[1];
    uint64_t v40 = *a2;
    CFStringRef v41 = v18;
    if (!v18) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_40:
  operator delete(v42.__r_.__value_.__l.__data_);
  CFStringRef v18 = (std::__shared_weak_count *)a2[1];
  uint64_t v40 = *a2;
  CFStringRef v41 = v18;
  if (v18) {
LABEL_13:
  }
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_14:
  long long v19 = (atomic_ullong *)a3[1];
  v39[0] = *a3;
  v39[1] = (ACFUFirmware *)v19;
  if (v19) {
    atomic_fetch_add_explicit(v19 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v20 = createBasebandProvInfo(0, &v40, v39, (__CFDictionary **)&v47);
  char v21 = v20;
  if (v19 && !atomic_fetch_add(v19 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(atomic_ullong *))(*v19 + 16))(v19);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v19);
  }
  CFStringRef v22 = v41;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  if ((v21 & 1) == 0) {
    goto LABEL_52;
  }
  CFTypeRef v23 = v47;
  if (!v47) {
    goto LABEL_52;
  }
  CFRetain(v47);
  std::string v24 = (const void *)*((void *)&v54 + 1);
  *((void *)&v54 + 1) = v23;
  if (v24) {
    CFRelease(v24);
  }
  CFRelease(v23);
  ACFULogging::getLogInstance(v25);
  *((unsigned char *)&v42.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v42, "BasebandProvisioning");
  CFRange v26 = std::string::append(&v42, "::", 2uLL);
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  CFDataRef v28 = std::string::append(&v43, "sendProvisionPing", 0x11uLL);
  long long v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
  std::string::size_type v45 = v28->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v29;
  v28->__r_.__value_.__l.__size_ = 0;
  v28->__r_.__value_.__r.__words[2] = 0;
  v28->__r_.__value_.__r.__words[0] = 0;
  ACFULogging::handleMessageCFType();
  if ((SHIBYTE(v45) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_28;
    }
LABEL_43:
    operator delete(v43.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_29;
    }
    goto LABEL_44;
  }
  operator delete(__p[0]);
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_43;
  }
LABEL_28:
  if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_29;
  }
LABEL_44:
  operator delete(v42.__r_.__value_.__l.__data_);
LABEL_29:
  uint64_t v20 = BasebandProvisioning::sendServerReq((BasebandProvisioning *)&v49, @"1", a1, (CFTypeRef *)&theDict);
  if ((v20 & 1) == 0)
  {
LABEL_52:
    ACFULogging::getLogInstance((ACFULogging *)v20);
    goto LABEL_55;
  }
  if (!theDict
    || (Value = (ACFULogging *)CFDictionaryGetValue(theDict, @"STATUS"), (CFStringRef v31 = (const __CFString *)Value) == 0))
  {
    ACFULogging::getLogInstance(0);
LABEL_55:
    ACFULogging::handleMessage();
    uint64_t v36 = 0;
    CFDictionaryRef v37 = theDict;
    if (!theDict) {
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  ACFULogging::getLogInstance(Value);
  *((unsigned char *)&v42.__r_.__value_.__s + 23) = 20;
  strcpy((char *)&v42, "BasebandProvisioning");
  CFStringRef v32 = std::string::append(&v42, "::", 2uLL);
  long long v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  CFStringRef v34 = std::string::append(&v43, "sendProvisionPing", 0x11uLL);
  long long v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  std::string::size_type v45 = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  ACFULogging::handleMessageCFType();
  if ((SHIBYTE(v45) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v43.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_34;
    }
LABEL_46:
    operator delete(v43.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_47;
  }
  operator delete(__p[0]);
  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_46;
  }
LABEL_34:
  if ((SHIBYTE(v42.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_35;
  }
LABEL_47:
  operator delete(v42.__r_.__value_.__l.__data_);
LABEL_35:
  *a4 = CFEqual(v31, @"0");
  uint64_t v36 = 1;
  CFDictionaryRef v37 = theDict;
  if (theDict) {
LABEL_36:
  }
    CFRelease(v37);
LABEL_37:
  BasebandProvisioning::~BasebandProvisioning((BasebandProvisioning *)&v49);
  return v36;
}

void sub_21DED53AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0)
  {
    operator delete(__p);
    if ((a29 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a22 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a29 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a24);
  if ((a22 & 0x80000000) == 0)
  {
LABEL_4:
    BasebandProvisioning::~BasebandProvisioning((BasebandProvisioning *)(v36 - 160));
    _Unwind_Resume(a1);
  }
LABEL_7:
  operator delete(a17);
  BasebandProvisioning::~BasebandProvisioning((BasebandProvisioning *)(v36 - 160));
  _Unwind_Resume(a1);
}

void sub_21DED54AC(_Unwind_Exception *a1)
{
  BasebandProvisioning::~BasebandProvisioning((BasebandProvisioning *)(v1 - 160));
  _Unwind_Resume(a1);
}

std::string *std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>(std::string **a1, long long *a2, uint64_t a3)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((char *)a1[1] - (char *)*a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555) {
    std::vector<std::string>::__throw_length_error[abi:ne180100]();
  }
  if (0x5555555555555556 * (((char *)a1[2] - (char *)*a1) >> 4) > v5) {
    unint64_t v5 = 0x5555555555555556 * (((char *)a1[2] - (char *)*a1) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((char *)a1[2] - (char *)*a1) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v8 = 0x555555555555555;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0x555555555555555) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    uint64_t v9 = (char *)operator new(48 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  CFStringRef v18 = (std::string *)&v9[48 * v4];
  long long v19 = (std::string *)&v9[48 * v8];
  std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(v18, a2, a3);
  dispatch_queue_t v10 = v18;
  CFTypeRef v11 = v18 + 2;
  CFAllocatorRef v12 = *a1;
  CFTypeRef v13 = a1[1];
  if (v13 == *a1)
  {
    *a1 = v18;
    a1[1] = v11;
    a1[2] = v19;
  }
  else
  {
    do
    {
      long long v14 = *(_OWORD *)&v13[-2].__r_.__value_.__l.__data_;
      v10[-2].__r_.__value_.__r.__words[2] = v13[-2].__r_.__value_.__r.__words[2];
      *(_OWORD *)&v10[-2].__r_.__value_.__l.__data_ = v14;
      v13[-2].__r_.__value_.__l.__size_ = 0;
      v13[-2].__r_.__value_.__r.__words[2] = 0;
      v13[-2].__r_.__value_.__r.__words[0] = 0;
      v10[-1].__r_.__value_.__r.__words[0] = 0;
      v10[-1].__r_.__value_.__l.__size_ = 0;
      v10[-1].__r_.__value_.__r.__words[2] = 0;
      *(_OWORD *)&v10[-1].__r_.__value_.__l.__data_ = *(_OWORD *)&v13[-1].__r_.__value_.__l.__data_;
      v10[-1].__r_.__value_.__r.__words[2] = v13[-1].__r_.__value_.__r.__words[2];
      v10 -= 2;
      v13[-1].__r_.__value_.__r.__words[0] = 0;
      v13[-1].__r_.__value_.__l.__size_ = 0;
      v13[-1].__r_.__value_.__r.__words[2] = 0;
      v13 -= 2;
    }
    while (v13 != v12);
    CFTypeRef v13 = *a1;
    long long v15 = a1[1];
    *a1 = v10;
    a1[1] = v11;
    a1[2] = v19;
    while (v15 != v13)
    {
      std::string::pointer data = v15[-1].__r_.__value_.__l.__data_;
      if (data)
      {
        v15[-1].__r_.__value_.__l.__size_ = (std::string::size_type)data;
        operator delete(data);
      }
      if (SHIBYTE(v15[-2].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v15[-2].__r_.__value_.__l.__data_);
      }
      v15 -= 2;
    }
  }
  if (v13) {
    operator delete(v13);
  }
  return v18 + 2;
}

void sub_21DED5670(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<std::string,std::vector<unsigned char>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

std::string *std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(std::string *this, long long *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    this[1].__r_.__value_.__r.__words[0] = 0;
    this[1].__r_.__value_.__l.__size_ = 0;
    this[1].__r_.__value_.__r.__words[2] = 0;
    int v6 = *(const void **)a3;
    size_t v7 = *(void *)(a3 + 8) - *(void *)a3;
    if (!v7) {
      return this;
    }
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
    this[1].__r_.__value_.__r.__words[0] = 0;
    this[1].__r_.__value_.__l.__size_ = 0;
    this[1].__r_.__value_.__r.__words[2] = 0;
    int v6 = *(const void **)a3;
    size_t v7 = *(void *)(a3 + 8) - *(void *)a3;
    if (!v7) {
      return this;
    }
  }
  if ((v7 & 0x8000000000000000) != 0) {
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v9 = operator new(v7);
  this[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v9;
  this[1].__r_.__value_.__l.__size_ = (std::string::size_type)v9;
  std::string::size_type v10 = (std::string::size_type)v9 + v7;
  this[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v9 + v7;
  memcpy(v9, v6, v7);
  this[1].__r_.__value_.__l.__size_ = v10;
  return this;
}

void sub_21DED5754(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
    if ((*(char *)(v1 + 23) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v1 + 23) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<std::pair<std::string,std::vector<unsigned char>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    unint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
    if (*(char *)(i - 25) < 0) {
      operator delete(*(void **)(i - 48));
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::vector<std::pair<std::string,std::vector<unsigned char>>>::__init_with_size[abi:ne180100]<std::pair<std::string,std::vector<unsigned char>>*,std::pair<std::string,std::vector<unsigned char>>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v5 = result;
    if (a4 >= 0x555555555555556) {
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    }
    uint64_t result = operator new(48 * a4);
    unint64_t v8 = result;
    void *v5 = result;
    v5[1] = result;
    uint64_t v5[2] = &result[6 * a4];
    if (a2 != a3)
    {
      unint64_t v9 = 0;
      do
      {
        uint64_t result = std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]((std::string *)&v8[v9 / 8], (long long *)(a2 + v9));
        v9 += 48;
      }
      while (a2 + v9 != a3);
      unint64_t v8 = (void *)((char *)v8 + v9);
    }
    v5[1] = v8;
  }
  return result;
}

void sub_21DED58CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_21DED58E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  for (; v11; v11 -= 48)
  {
    uint64_t v13 = v10 + v11;
    long long v14 = *(void **)(v10 + v11 - 24);
    if (v14)
    {
      *(void *)(v13 - 16) = v14;
      operator delete(v14);
    }
    if (*(char *)(v13 - 25) < 0) {
      operator delete(*(void **)(v13 - 48));
    }
  }
  *(void *)(v9 + 8) = v10;
  std::__exception_guard_exceptions<std::vector<std::pair<std::string,std::vector<unsigned char>>>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void ***std::__exception_guard_exceptions<std::vector<std::pair<std::string,std::vector<unsigned char>>>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](void ***result)
{
  uint64_t v1 = result;
  if (!*((unsigned char *)result + 8))
  {
    uint64_t v2 = *result;
    unint64_t v3 = (char *)**result;
    if (v3)
    {
      unint64_t v4 = (char *)v2[1];
      long long v5 = **result;
      if (v4 != v3)
      {
        do
        {
          int v6 = (void *)*((void *)v4 - 3);
          if (v6)
          {
            *((void *)v4 - 2) = v6;
            operator delete(v6);
          }
          if (*(v4 - 25) < 0) {
            operator delete(*((void **)v4 - 6));
          }
          v4 -= 48;
        }
        while (v4 != v3);
        long long v5 = **v1;
      }
      v2[1] = v3;
      operator delete(v5);
      return v1;
    }
  }
  return result;
}

std::string *std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100](std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    this[1].__r_.__value_.__r.__words[0] = 0;
    this[1].__r_.__value_.__l.__size_ = 0;
    this[1].__r_.__value_.__r.__words[2] = 0;
    int v6 = (unsigned char *)*((void *)a2 + 3);
    uint64_t v9 = (unsigned char *)*((void *)a2 + 4);
    size_t v7 = v9 - v6;
    if (v9 == v6) {
      return this;
    }
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
    this[1].__r_.__value_.__r.__words[0] = 0;
    this[1].__r_.__value_.__l.__size_ = 0;
    this[1].__r_.__value_.__r.__words[2] = 0;
    int v6 = (unsigned char *)*((void *)a2 + 3);
    long long v5 = (unsigned char *)*((void *)a2 + 4);
    size_t v7 = v5 - v6;
    if (v5 == v6) {
      return this;
    }
  }
  if ((v7 & 0x8000000000000000) != 0) {
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v10 = operator new(v7);
  this[1].__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
  this[1].__r_.__value_.__l.__size_ = (std::string::size_type)v10;
  std::string::size_type v11 = (std::string::size_type)v10 + v7;
  this[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v10 + v7;
  memcpy(v10, v6, v7);
  this[1].__r_.__value_.__l.__size_ = v11;
  return this;
}

void sub_21DED5AA0(_Unwind_Exception *exception_object)
{
  long long v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
    if ((*(char *)(v1 + 23) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v1 + 23) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t boost::basic_format<char,std::char_traits<char>,std::allocator<char>>::~basic_format(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 184))
  {
    std::locale::~locale((std::locale *)(a1 + 192));
    *(unsigned char *)(a1 + 184) = 0;
  }
  *(void *)(a1 + 96) = &unk_26CEC9EA8;
  if (*(unsigned char *)(a1 + 168)) {
    operator delete(*(void **)(a1 + 112));
  }
  *(_OWORD *)(a1 + 153) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  std::streambuf::~streambuf();
  if ((*(char *)(a1 + 87) & 0x80000000) == 0)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    if (!v2) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  operator delete(*(void **)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2) {
LABEL_7:
  }
    operator delete(v2);
LABEL_8:
  unint64_t v3 = *(std::locale **)a1;
  if (*(void *)a1)
  {
    long long v4 = *(std::locale **)(a1 + 8);
    long long v5 = *(std::locale **)a1;
    if (v4 == v3)
    {
LABEL_22:
      *(void *)(a1 + 8) = v3;
      operator delete(v5);
      return a1;
    }
    while (1)
    {
      if (LOBYTE(v4[-4].__locale_))
      {
        std::locale::~locale(v4 - 3);
        LOBYTE(v4[-4].__locale_) = 0;
      }
      if (SHIBYTE(v4[-9].__locale_) < 0)
      {
        operator delete(v4[-11].__locale_);
        if (SHIBYTE(v4[-12].__locale_) < 0) {
LABEL_18:
        }
          operator delete(v4[-14].__locale_);
      }
      else if (SHIBYTE(v4[-12].__locale_) < 0)
      {
        goto LABEL_18;
      }
      v4 -= 15;
      if (v4 == v3)
      {
        long long v5 = *(std::locale **)a1;
        goto LABEL_22;
      }
    }
  }
  return a1;
}

uint64_t boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_altstringbuf(uint64_t a1)
{
  *(void *)a1 = &unk_26CEC9EA8;
  if (*(unsigned char *)(a1 + 72)) {
    operator delete(*(void **)(a1 + 16));
  }
  *(_OWORD *)(a1 + 57) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;

  return std::streambuf::~streambuf();
}

void **std::vector<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::~vector[abi:ne180100](void **a1)
{
  uint64_t v2 = (std::locale *)*a1;
  if (*a1)
  {
    unint64_t v3 = (std::locale *)a1[1];
    long long v4 = *a1;
    if (v3 == v2)
    {
LABEL_13:
      a1[1] = v2;
      operator delete(v4);
      return a1;
    }
    while (1)
    {
      if (LOBYTE(v3[-4].__locale_))
      {
        std::locale::~locale(v3 - 3);
        LOBYTE(v3[-4].__locale_) = 0;
      }
      if (SHIBYTE(v3[-9].__locale_) < 0)
      {
        operator delete(v3[-11].__locale_);
        if (SHIBYTE(v3[-12].__locale_) < 0) {
LABEL_11:
        }
          operator delete(v3[-14].__locale_);
      }
      else if (SHIBYTE(v3[-12].__locale_) < 0)
      {
        goto LABEL_11;
      }
      v3 -= 15;
      if (v3 == v2)
      {
        long long v4 = *a1;
        goto LABEL_13;
      }
    }
  }
  return a1;
}

void boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_altstringbuf(uint64_t a1)
{
  *(void *)a1 = &unk_26CEC9EA8;
  if (*(unsigned char *)(a1 + 72)) {
    operator delete(*(void **)(a1 + 16));
  }
  *(_OWORD *)(a1 + 57) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v2 = (void *)std::streambuf::~streambuf();

  operator delete(v2);
}

double boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>::seekoff@<D0>(void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  unint64_t v5 = a1[6];
  if (v5 && a1[8] < v5) {
    a1[8] = v5;
  }
  if ((a4 & 8) != 0)
  {
    uint64_t v6 = a1[3];
    if (v6)
    {
      if (a3)
      {
        if (a3 == 1)
        {
          if ((a4 & 0x10) != 0) {
            goto LABEL_29;
          }
          goto LABEL_21;
        }
        if (a3 != 2) {
          goto LABEL_29;
        }
        size_t v7 = a1 + 8;
      }
      else
      {
        size_t v7 = a1 + 2;
      }
      a2 = a2 - v6 + *v7;
LABEL_21:
      if (a1[2] <= (unint64_t)(v6 + a2) && (unint64_t)(v6 + a2) <= a1[8])
      {
        uint64_t v9 = v6 + (int)a2;
        a1[3] = v9;
        if ((a4 & 0x10) == 0 || !v5) {
          goto LABEL_27;
        }
        LODWORD(v9) = v9 - v5;
LABEL_26:
        a1[6] = v5 + (int)v9;
LABEL_27:
        uint64_t v8 = a2;
        goto LABEL_30;
      }
LABEL_29:
      uint64_t v8 = -1;
      goto LABEL_30;
    }
  }
  uint64_t v8 = -1;
  if ((a4 & 0x10) != 0 && v5)
  {
    if (!a3)
    {
      unint64_t v11 = a1[5];
      uint64_t v9 = v11 - v5 + a2;
      unint64_t v10 = v11 + a2;
      if (v11 > v11 + a2) {
        goto LABEL_29;
      }
      goto LABEL_17;
    }
    if (a3 == 2)
    {
      uint64_t v9 = a1[8] - v5 + a2;
      unint64_t v10 = a1[8] + a2;
      if (a1[5] > v10) {
        goto LABEL_29;
      }
LABEL_17:
      a2 = v9;
      if (v10 <= a1[8]) {
        goto LABEL_26;
      }
      goto LABEL_29;
    }
  }
LABEL_30:
  double result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(void *)(a5 + 128) = v8;
  return result;
}

double boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>::seekpos@<D0>(void *a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *(void *)(a2 + 128);
  unint64_t v5 = a1[6];
  if (v5 && a1[8] < v5) {
    a1[8] = v5;
  }
  if (v4 == -1)
  {
LABEL_16:
    uint64_t v10 = -1;
    goto LABEL_17;
  }
  if ((a3 & 8) != 0)
  {
    uint64_t v6 = a1[3];
    if (v6)
    {
      if ((v4 & 0x8000000000000000) == 0)
      {
        uint64_t v7 = a1[2];
        if (v4 <= a1[8] - v7)
        {
          uint64_t v8 = v6 + (int)v4 - (int)v6 + (int)v7;
          a1[3] = v8;
          if ((a3 & 0x10) == 0 || !v5) {
            goto LABEL_20;
          }
          int v9 = v8 - v5;
LABEL_19:
          a1[6] = v5 + v9;
LABEL_20:
          uint64_t v10 = v4;
          goto LABEL_17;
        }
      }
      goto LABEL_16;
    }
  }
  uint64_t v10 = -1;
  if ((a3 & 0x10) != 0 && v5 && (v4 & 0x8000000000000000) == 0)
  {
    uint64_t v11 = a1[2];
    if (v4 <= a1[8] - v11)
    {
      int v9 = v4 - v5 + v11;
      goto LABEL_19;
    }
    goto LABEL_16;
  }
LABEL_17:
  double result = 0.0;
  *(_OWORD *)(a4 + 96) = 0u;
  *(_OWORD *)(a4 + 112) = 0u;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)(a4 + 48) = 0u;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(a4 + 128) = v10;
  return result;
}

uint64_t boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>::underflow(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 24);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  if ((unint64_t)v1 < *(void *)(a1 + 32)) {
    return *v1;
  }
  if ((*(unsigned char *)(a1 + 76) & 8) == 0) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v3 = *(void *)(a1 + 48);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v4 = *(void *)(a1 + 64);
  if ((unint64_t)v1 >= v3 && (unint64_t)v1 >= v4) {
    return 0xFFFFFFFFLL;
  }
  if (v4 < v3)
  {
    *(void *)(a1 + 64) = v3;
    unint64_t v4 = v3;
  }
  *(void *)(a1 + 32) = v4;
  return *v1;
}

uint64_t boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>::pbackfail(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 24);
  if (!v2 || *(void *)(a1 + 16) >= v2) {
    return 0xFFFFFFFFLL;
  }
  if (a2 != -1 && (*(_DWORD *)(a1 + 76) & 0x10) == 0)
  {
    int v4 = *(unsigned __int8 *)(v2 - 1);
    unint64_t v3 = (unsigned char *)(v2 - 1);
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = v3;
      *unint64_t v3 = a2;
      return a2;
    }
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = (unsigned char *)(v2 - 1);
  *(void *)(a1 + 24) = v6;
  if (a2 == -1) {
    return 0;
  }
  unsigned char *v6 = a2;
  return a2;
}

uint64_t boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>::overflow(uint64_t a1, uint64_t a2)
{
  if (a2 == -1) {
    return 0;
  }
  int v4 = *(unsigned char **)(a1 + 48);
  if (v4)
  {
    unint64_t v5 = *(void *)(a1 + 56);
    if ((unint64_t)v4 < v5)
    {
      *(void *)(a1 + 48) = v4 + 1;
      unsigned char *v4 = a2;
      return a2;
    }
    if ((*(unsigned char *)(a1 + 76) & 0x10) == 0) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v8 = *(void **)(a1 + 16);
    size_t v7 = v5 - (void)v8;
  }
  else
  {
    if ((*(unsigned char *)(a1 + 76) & 0x10) == 0) {
      return 0xFFFFFFFFLL;
    }
    size_t v7 = 0;
    uint64_t v8 = *(void **)(a1 + 16);
  }
  unint64_t v9 = v7 >> 1;
  if (v7 >> 1 <= 0x100) {
    unint64_t v9 = 256;
  }
  while (__CFADD__(v9, v7))
  {
    BOOL v10 = v9 >= 2;
    v9 >>= 1;
    if (!v10)
    {
      uint64_t v11 = 0;
      size_t v12 = v7;
LABEL_18:
      memmove(v11, v8, v7);
      int v13 = 0;
      if (!*(unsigned char *)(a1 + 72)) {
        goto LABEL_20;
      }
LABEL_19:
      operator delete(v8);
      goto LABEL_20;
    }
  }
  size_t v12 = v9 + v7;
  uint64_t v11 = operator new(v9 + v7);
  if (v7) {
    goto LABEL_18;
  }
  int v13 = 1;
  if (*(unsigned char *)(a1 + 72)) {
    goto LABEL_19;
  }
LABEL_20:
  *(unsigned char *)(a1 + 72) = 1;
  if (v13)
  {
    long long v14 = &v11[v12];
    *(void *)(a1 + 40) = v11;
    *(void *)(a1 + 48) = v11;
    *(void *)(a1 + 56) = &v11[v12];
    *(void *)(a1 + 64) = v11;
    if ((*(unsigned char *)(a1 + 76) & 8) != 0)
    {
      *(void *)(a1 + 16) = v11;
      *(void *)(a1 + 24) = v11;
      *(void *)(a1 + 32) = v11 + 1;
      if (v11 == v14) {
        goto LABEL_23;
      }
    }
    else
    {
      *(void *)(a1 + 16) = v11;
      *(void *)(a1 + 24) = 0;
      *(void *)(a1 + 32) = v11;
      if (v11 == v14)
      {
LABEL_23:
        (*(void (**)(uint64_t, void))(*(void *)a1 + 104))(a1, a2);
        return a2;
      }
    }
  }
  else
  {
    long long v15 = &v11[*(void *)(a1 + 64) - (void)v8];
    uint64_t v16 = *(void *)(a1 + 40);
    int v17 = *(_DWORD *)(a1 + 48) - v16;
    uint64_t v18 = v16 - (void)v8;
    uint64_t v20 = *(void *)(a1 + 16);
    uint64_t v19 = *(void *)(a1 + 24);
    char v21 = &v11[v18];
    CFStringRef v22 = &v11[v12];
    *(void *)(a1 + 56) = &v11[v12];
    *(void *)(a1 + 64) = v15;
    CFTypeRef v23 = &v21[v17];
    *(void *)(a1 + 40) = v21;
    *(void *)(a1 + 48) = v23;
    if ((*(unsigned char *)(a1 + 76) & 8) != 0)
    {
      *(void *)(a1 + 16) = v11;
      *(void *)(a1 + 24) = &v11[(int)v19 - (int)v20];
      uint64_t v11 = &v21[v17];
      *(void *)(a1 + 32) = v23 + 1;
      if (v23 == v22) {
        goto LABEL_23;
      }
    }
    else
    {
      *(void *)(a1 + 16) = v11;
      *(void *)(a1 + 24) = 0;
      std::string v24 = v11;
      uint64_t v11 = &v21[v17];
      *(void *)(a1 + 32) = v24;
      if (v23 == v22) {
        goto LABEL_23;
      }
    }
  }
  *(void *)(a1 + 48) = v11 + 1;
  *uint64_t v11 = a2;
  return a2;
}

uint64_t boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>::~format_item(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88))
  {
    std::locale::~locale((std::locale *)(a1 + 96));
    *(unsigned char *)(a1 + 88) = 0;
  }
  if (*(char *)(a1 + 55) < 0)
  {
    operator delete(*(void **)(a1 + 32));
    if ((*(char *)(a1 + 31) & 0x80000000) == 0) {
      return a1;
    }
  }
  else if ((*(char *)(a1 + 31) & 0x80000000) == 0)
  {
    return a1;
  }
  operator delete(*(void **)(a1 + 8));
  return a1;
}

void std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[63] < 0)
    {
      operator delete(*((void **)a2 + 5));
      int v4 = a2;
    }
    else
    {
      int v4 = a2;
    }
    operator delete(v4);
  }
}

CFStringRef copy_mac_address_existence(const __CFString *a1)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    ACFULogging::getLogInstance(0);
    ACFULogging::handleMessage();
    return 0;
  }
  if (BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken == -1)
  {
    unint64_t v2 = (uint64_t (*)(const __CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      return 0;
    }
  }
  else
  {
    dispatch_once(&BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::onceToken, &__block_literal_global_4);
    unint64_t v2 = (uint64_t (*)(const __CFString *, void))BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer;
    if (!BBUpdaterCommon::BBUMGCopyAnswer(__CFString const*)::sCopyAnswer) {
      return 0;
    }
  }
  CFStringRef v3 = (const __CFString *)v2(a1, 0);
  if (v3)
  {
    int v21 = -1431655766;
    *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v19 = v4;
    long long v20 = v4;
    long long v17 = v4;
    long long v18 = v4;
    long long v16 = v4;
    *(_OWORD *)__CFString buffer = v4;
    int v14 = -1431655766;
    long long v12 = v4;
    long long v13 = v4;
    long long v10 = v4;
    long long v11 = v4;
    *(_OWORD *)__s = v4;
    long long v9 = v4;
    CFStringGetCString(a1, buffer, 100, 0x600u);
    CString = (ACFULogging *)CFStringGetCString(v3, __s, 100, 0x600u);
    ACFULogging::getLogInstance(CString);
    ACFULogging::handleMessage();
    uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"00:00:00:00:00:00", 1uLL);
    if (!v6) {
      goto LABEL_17;
    }
    uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"BA:BA:BA:BA:BA:BA", 1uLL);
    if (!v6) {
      goto LABEL_17;
    }
    uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"DE:AD:BE:FF:00:00", 1uLL);
    if (!v6
      || (uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"DE:AD:BE:FF:00:01", 1uLL)) == 0
      || (uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"DF:AD:BE:FF:00:00", 1uLL)) == 0
      || (uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"88:88:88:88:88:88", 1uLL)) == 0
      || (uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"99:99:99:99:99:99", 1uLL)) == 0
      || (uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"02:88:88:88:88:88", 1uLL)) == 0
      || (uint64_t v6 = (ACFULogging *)CFStringCompare(v3, @"02:99:99:99:99:99", 1uLL)) == 0
      || strlen(__s) > 2 && (uint64_t v6 = (ACFULogging *)AMSupportHexAsciiToNumeric(), !v6))
    {
LABEL_17:
      ACFULogging::getLogInstance(v6);
      ACFULogging::handleMessage();
      CFRelease(v3);
      return 0;
    }
  }
  return v3;
}

void BasebandProvisioning::~BasebandProvisioning(BasebandProvisioning *this)
{
  unint64_t v2 = (const void *)*((void *)this + 11);
  if (v2) {
    CFRelease(v2);
  }
  CFStringRef v3 = (const void *)*((void *)this + 10);
  if (v3) {
    CFRelease(v3);
  }
  long long v4 = (const void *)*((void *)this + 9);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = *((void *)this + 6);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 7);
    size_t v7 = (void *)*((void *)this + 6);
    if (v6 != v5)
    {
      do
      {
        uint64_t v8 = *(void **)(v6 - 24);
        if (v8)
        {
          *(void *)(v6 - 16) = v8;
          operator delete(v8);
        }
        if (*(char *)(v6 - 25) < 0) {
          operator delete(*(void **)(v6 - 48));
        }
        v6 -= 48;
      }
      while (v6 != v5);
      size_t v7 = (void *)*((void *)this + 6);
    }
    *((void *)this + 7) = v5;
    operator delete(v7);
  }
  long long v9 = (const void *)*((void *)this + 5);
  if (v9) {
    CFRelease(v9);
  }
  long long v10 = *((void *)this + 4);
  if (v10) {
    dispatch_release(v10);
  }
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

void std::__assoc_state<std::shared_ptr<ctu::Http::HttpResponse>>::~__assoc_state(uint64_t a1)
{
  *(void *)a1 = MEMORY[0x263F8C320] + 16;
  unint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);

  std::__shared_count::~__shared_count((std::__shared_count *)a1);
}

{
  std::exception_ptr *v2;
  void *v3;
  uint64_t vars8;

  *(void *)a1 = MEMORY[0x263F8C320] + 16;
  unint64_t v2 = (std::exception_ptr *)(a1 + 16);
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 88));
  std::mutex::~mutex((std::mutex *)(a1 + 24));
  std::exception_ptr::~exception_ptr(v2);
  std::__shared_count::~__shared_count((std::__shared_count *)a1);

  operator delete(v3);
}

uint64_t std::__assoc_state<std::shared_ptr<ctu::Http::HttpResponse>>::__on_zero_shared(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 136))
  {
    unint64_t v2 = *(std::__shared_weak_count **)(a1 + 152);
    if (v2)
    {
      if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
  }
  CFStringRef v3 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 8);

  return v3(a1);
}

uint64_t *std::promise<std::shared_ptr<ctu::Http::HttpResponse>>::~promise(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (!v2) {
    return a1;
  }
  if ((*(unsigned char *)(v2 + 136) & 1) == 0)
  {
    v10.__ptr_ = 0;
    uint64_t v3 = *(void *)(v2 + 16);
    std::exception_ptr::~exception_ptr(&v10);
    uint64_t v2 = *a1;
    if (!v3 && *(uint64_t *)(v2 + 8) >= 1)
    {
      uint64_t v5 = std::future_category();
      MEMORY[0x223C1DA90](&v8, 4, v5);
      exception = (std::logic_error *)__cxa_allocate_exception(0x20uLL);
      size_t v7 = std::logic_error::logic_error(exception, &v8);
      v7->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C2E0] + 16);
      v7[1] = v9;
      __cxa_throw(v7, MEMORY[0x263F8C1A0], MEMORY[0x263F8C0C0]);
    }
  }
  if (atomic_fetch_add((atomic_ullong *volatile)(v2 + 8), 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
  return a1;
}

void std::__throw_future_error[abi:ne180100](unsigned int a1)
{
  exception = __cxa_allocate_exception(0x20uLL);
  uint64_t v3 = std::future_category();
  MEMORY[0x223C1DA90](exception, a1, v3);
  __cxa_throw(exception, MEMORY[0x263F8C1A0], MEMORY[0x263F8C0C0]);
}

void sub_21DED6A7C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t *dispatch::future_callback_impl<std::shared_ptr<ctu::Http::HttpResponse>,std::shared_ptr<ctu::Http::HttpResponse>>@<X0>(atomic_ullong **a1@<X0>, void **a2@<X8>)
{
  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x3812000000;
  v9[3] = __Block_byref_object_copy_;
  void v9[4] = __Block_byref_object_dispose_;
  v9[5] = "";
  long long v4 = (char *)operator new(0xA0uLL);
  *((void *)v4 + 3) = 850045863;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  *((_OWORD *)v4 + 4) = 0u;
  *((void *)v4 + 10) = 0;
  *((void *)v4 + 11) = 1018212795;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *(_OWORD *)(v4 + 124) = 0u;
  *(void *)long long v4 = &unk_26CEC9F40;
  std::exception_ptr v10 = v4;
  std::mutex::lock((std::mutex *)(v4 + 24));
  int v5 = *((_DWORD *)v4 + 34);
  if ((v5 & 2) != 0) {
    std::__throw_future_error[abi:ne180100](1u);
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)v4 + 1, 1uLL, memory_order_relaxed);
  *((_DWORD *)v4 + 34) = v5 | 2;
  std::mutex::unlock((std::mutex *)(v4 + 24));
  uint64_t v6 = *a1;
  *a1 = (atomic_ullong *)v4;
  if (v6 && !atomic_fetch_add(v6 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v6 + 16))(v6);
  }
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 3254779904;
  v8[2] = ___ZN8dispatch20future_callback_implINSt3__110shared_ptrIN3ctu4Http12HttpResponseEEES6_EENS_5blockIU13block_pointerFvT0_EEERNS1_6futureIT_EE_block_invoke;
  v8[3] = &__block_descriptor_40_e8_32r_e82_v24__0_shared_ptr_ctu::Http::HttpResponse____HttpResponse_____shared_weak_count__8l;
  unint64_t v8[4] = v9;
  *a2 = _Block_copy(v8);
  _Block_object_dispose(v9, 8);
  return std::promise<std::shared_ptr<ctu::Http::HttpResponse>>::~promise((uint64_t *)&v10);
}

void sub_21DED6C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  std::mutex::unlock(v15);
  _Block_object_dispose(&a14, 8);
  std::promise<std::shared_ptr<ctu::Http::HttpResponse>>::~promise(v14);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  return result;
}

uint64_t *__Block_byref_object_dispose_(uint64_t a1)
{
  return std::promise<std::shared_ptr<ctu::Http::HttpResponse>>::~promise((uint64_t *)(a1 + 48));
}

void ___ZN8dispatch20future_callback_implINSt3__110shared_ptrIN3ctu4Http12HttpResponseEEES6_EENS_5blockIU13block_pointerFvT0_EEERNS1_6futureIT_EE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 48);
  if (!v2) {
    std::__throw_future_error[abi:ne180100](3u);
  }

  std::__assoc_state<std::shared_ptr<ctu::Http::HttpResponse>>::set_value<std::shared_ptr<ctu::Http::HttpResponse>>(v2, a2);
}

void __copy_helper_block_e8_32r(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_e8_32r(uint64_t a1)
{
}

void std::__assoc_state<std::shared_ptr<ctu::Http::HttpResponse>>::set_value<std::shared_ptr<ctu::Http::HttpResponse>>(uint64_t a1, uint64_t a2)
{
  long long v4 = (std::mutex *)(a1 + 24);
  std::mutex::lock((std::mutex *)(a1 + 24));
  if ((*(unsigned char *)(a1 + 136) & 1) != 0
    || (v6.__ptr_ = 0, uint64_t v5 = *(void *)(a1 + 16), std::exception_ptr::~exception_ptr(&v6), v5))
  {
    std::__throw_future_error[abi:ne180100](2u);
  }
  *(_OWORD *)(a1 + 144) = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a1 + 136) |= 5u;
  std::condition_variable::notify_all((std::condition_variable *)(a1 + 88));
  std::mutex::unlock(v4);
}

void sub_21DED6D90(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__assoc_state<std::shared_ptr<ctu::Http::HttpResponse>>::move(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 24);
  *(void *)&__lk.__owns_ = 0xAAAAAAAAAAAAAA01;
  std::mutex::lock((std::mutex *)(a1 + 24));
  std::__assoc_sub_state::__sub_wait((std::__assoc_sub_state *)a1, &__lk);
  uint64_t v4 = *(void *)(a1 + 16);
  v7.__ptr_ = 0;
  std::exception_ptr::~exception_ptr(&v7);
  if (v4)
  {
    std::exception_ptr::exception_ptr(&v6, (const std::exception_ptr *)(a1 + 16));
    v5.__ptr_ = &v6;
    std::rethrow_exception(v5);
    __break(1u);
  }
  else
  {
    *a2 = *(_OWORD *)(a1 + 144);
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 152) = 0;
    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
  }
}

void sub_21DED6E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12)
{
  if (a12) {
    std::mutex::unlock(a11);
  }
  _Unwind_Resume(a1);
}

uint64_t boost::basic_format<char,std::char_traits<char>,std::allocator<char>>::basic_format(uint64_t a1, const char *a2)
{
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 45) = 0u;
  *(unsigned char *)(a1 + 88) = -1;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 96) = &unk_26CEC9EA8;
  *(void *)(a1 + 160) = 0;
  *(unsigned char *)(a1 + 168) = 0;
  *(_DWORD *)(a1 + 172) = 24;
  *(unsigned char *)(a1 + 184) = 0;
  if (!a2) {
    return a1;
  }
  size_t v4 = strlen(a2);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  std::exception_ptr v5 = (void *)v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    std::exception_ptr v6 = (void **)operator new(v7 + 1);
    __dst[1] = v5;
    unint64_t v11 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_9;
  }
  HIBYTE(v11) = v4;
  std::exception_ptr v6 = __dst;
  if (v4) {
LABEL_9:
  }
    memcpy(v6, a2, (size_t)v5);
  *((unsigned char *)v5 + (void)v6) = 0;
  boost::basic_format<char,std::char_traits<char>,std::allocator<char>>::parse(a1, (uint64_t)__dst);
  if (SHIBYTE(v11) < 0) {
    operator delete(__dst[0]);
  }
  return a1;
}

void sub_21DED6FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(unsigned char *)(v15 + 184))
  {
    std::locale::~locale((std::locale *)(v15 + 192));
    *(unsigned char *)(v15 + 184) = 0;
  }
  boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>::~basic_altstringbuf(v16);
  if (*(char *)(v15 + 87) < 0)
  {
    operator delete(*v17);
    long long v19 = *(void **)(v15 + 24);
    if (!v19)
    {
LABEL_7:
      std::vector<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::~vector[abi:ne180100]((void **)v15);
      _Unwind_Resume(a1);
    }
  }
  else
  {
    long long v19 = *(void **)(v15 + 24);
    if (!v19) {
      goto LABEL_7;
    }
  }
  operator delete(v19);
  std::vector<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::~vector[abi:ne180100]((void **)v15);
  _Unwind_Resume(a1);
}

uint64_t boost::basic_format<char,std::char_traits<char>,std::allocator<char>>::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 184)) {
    std::locale::locale(&v58, (const std::locale *)(a1 + 192));
  }
  else {
    MEMORY[0x223C1DD80](&v58);
  }
  size_t v4 = std::locale::use_facet(&v58, MEMORY[0x263F8C108]);
  std::locale::~locale(&v58);
  CFStringRef v55 = &v4->__vftable;
  int __c = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 37);
  int v5 = boost::io::detail::upper_bound_from_fstring<std::string,std::ctype<char>>(a2, __c, (uint64_t)v4, *(unsigned char *)(a1 + 88));
  boost::basic_format<char,std::char_traits<char>,std::allocator<char>>::make_or_reuse_data((char **)a1, v5);
  size_t v57 = 0;
  int v6 = *(char *)(a2 + 23);
  uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  unsigned int v8 = v6 >> 31;
  uint64_t v9 = *(void *)(a2 + 8);
  if (v6 >= 0) {
    size_t v10 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v10 = *(void *)(a2 + 8);
  }
  if (!v10)
  {
    uint64_t v16 = 0;
    int v54 = 0;
    char v51 = 0;
    char v52 = 1;
    int v53 = -1;
    goto LABEL_63;
  }
  uint64_t v11 = *(void *)a2;
  if (v6 >= 0) {
    uint64_t v12 = a2;
  }
  else {
    uint64_t v12 = *(void *)a2;
  }
  long long v13 = memchr((void *)v12, __c, v10);
  int64_t v14 = (int64_t)&v13[-v12];
  if (v13) {
    BOOL v15 = v14 == -1;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15)
  {
    uint64_t v16 = 0;
    int v54 = 0;
    char v51 = 0;
    char v52 = 1;
    int v53 = -1;
    goto LABEL_63;
  }
  uint64_t v16 = 0;
  int v17 = 0;
  int v54 = 0;
  int v53 = -1;
  char v51 = 0;
  char v52 = 1;
  do
  {
    long long v18 = (std::string *)(a1 + 64);
    if (v17) {
      long long v18 = (std::string *)(*(void *)a1 + 120 * v17 - 88);
    }
    int64_t v19 = v14 + 1;
    if (v8) {
      uint64_t v20 = v11;
    }
    else {
      uint64_t v20 = a2;
    }
    if (*(unsigned __int8 *)(v20 + v19) == *(unsigned __int8 *)(v20 + v14))
    {
      std::string::append[abi:ne180100]<std::__wrap_iter<char const*>,0>(v18, (unint64_t)&v16[v12], (char *)(v12 + v19));
      uint64_t v16 = (unsigned __int8 *)(v14 + 2);
      int v21 = (unsigned __int8 *)(v14 + 2);
      goto LABEL_52;
    }
    if ((unsigned __int8 *)v14 != v16)
    {
      std::string::append[abi:ne180100]<std::__wrap_iter<char const*>,0>(v18, (unint64_t)&v16[v12], (char *)(v12 + v14));
      uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
    }
    if ((v7 & 0x80) != 0)
    {
      uint64_t v22 = *(void *)a2;
      uint64_t v7 = *(void *)(a2 + 8);
    }
    else
    {
      uint64_t v22 = a2;
    }
    size_t v57 = (unsigned __int8 *)(v22 + v19);
    v58.__locale_ = (std::locale::__imp *)(v22 + v7);
    int v23 = boost::io::detail::parse_printf_directive<char,std::char_traits<char>,std::allocator<char>,std::__wrap_iter<char const*>,std::ctype<char>>(&v57, (char **)&v58, *(void *)a1 + 120 * v17, v55, (unsigned __int8 *)(v14 + 1), *(unsigned __int8 *)(a1 + 88));
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v24 = a2;
    }
    else {
      uint64_t v24 = *(void *)a2;
    }
    int v21 = &v57[-v24];
    if (!v23)
    {
      uint64_t v16 = (unsigned __int8 *)v14;
      goto LABEL_52;
    }
    uint64_t v25 = *(char **)a1;
    CFRange v26 = (_DWORD *)(*(void *)a1 + 120 * v17);
    long long v27 = v26 + 28;
    unsigned int v28 = v26[28];
    if ((v28 & 1) == 0) {
      goto LABEL_37;
    }
    long long v29 = &v25[120 * v17];
    int v32 = *((_DWORD *)v29 + 19);
    CFStringRef v30 = (unsigned int *)(v29 + 76);
    int v31 = v32;
    if ((v32 & 0x20) == 0)
    {
      v28 &= ~2u;
      *long long v27 = v28;
      v25[120 * v17 + 72] = 48;
      *CFStringRef v30 = v31 & 0xFFFFFF4F | 0x10;
LABEL_37:
      if ((v28 & 2) != 0) {
        goto LABEL_38;
      }
      goto LABEL_42;
    }
    v28 &= ~1u;
    *long long v27 = v28;
    if ((v28 & 2) != 0)
    {
LABEL_38:
      if ((v25[120 * v17 + 77] & 8) != 0) {
        *long long v27 = v28 & 0xFFFFFFFD;
      }
    }
LABEL_42:
    int v33 = *v26;
    if (v33 != -3)
    {
      if (v33 == -1)
      {
        char v52 = 0;
      }
      else if (v33 == -2)
      {
        char v51 = 1;
      }
      else
      {
        int v34 = v53;
        if (v33 > v53) {
          int v34 = v33;
        }
        int v53 = v34;
      }
      ++v54;
      ++v17;
    }
    uint64_t v16 = v21;
LABEL_52:
    int v35 = *(char *)(a2 + 23);
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
    unsigned int v8 = v35 >> 31;
    uint64_t v9 = *(void *)(a2 + 8);
    if (v35 >= 0) {
      unint64_t v36 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      unint64_t v36 = *(void *)(a2 + 8);
    }
    if (v36 <= (unint64_t)v21) {
      break;
    }
    uint64_t v11 = *(void *)a2;
    uint64_t v12 = v35 >= 0 ? a2 : *(void *)a2;
    CFDictionaryRef v37 = memchr(&v21[v12], __c, v36 - (void)v21);
    if (!v37) {
      break;
    }
    int64_t v14 = (int64_t)&v37[-v12];
  }
  while (&v37[-v12] != (unsigned char *)-1);
  if (v17)
  {
    CFStringRef v38 = (std::string *)(*(void *)a1 + 120 * v17 - 88);
    goto LABEL_64;
  }
LABEL_63:
  CFStringRef v38 = (std::string *)(a1 + 64);
LABEL_64:
  if (v8) {
    uint64_t v39 = v9;
  }
  else {
    uint64_t v39 = v7;
  }
  uint64_t v40 = *(void *)a2;
  if (!v8) {
    uint64_t v40 = a2;
  }
  std::string::append[abi:ne180100]<std::__wrap_iter<char const*>,0>(v38, (unint64_t)&v16[v40], (char *)(v40 + v39));
  if (v52)
  {
    CFStringRef v41 = v55;
  }
  else
  {
    if (v53 & 0x80000000) == 0 && (*(unsigned char *)(a1 + 88))
    {
      v58.__locale_ = (std::locale::__imp *)&unk_26CECA0A8;
      v59[0] = (void *)v53;
      v59[1] = 0;
      boost::throw_exception<boost::io::bad_format_string>((uint64_t)&v58);
    }
    if (v54 < 1)
    {
      int v42 = 0;
      CFStringRef v41 = v55;
    }
    else
    {
      int v42 = 0;
      std::string v43 = *(char **)a1;
      uint64_t v44 = v54;
      CFStringRef v41 = v55;
      do
      {
        if (*(_DWORD *)v43 == -1) {
          *(_DWORD *)std::string v43 = v42++;
        }
        v43 += 120;
        --v44;
      }
      while (v44);
    }
    int v53 = v42 - 1;
  }
  char v45 = (*(uint64_t (**)(void *, uint64_t))(*v41 + 56))(v41, 32);
  LODWORD(v58.__locale_) = -1;
  char v67 = 0;
  *(_OWORD *)uint64_t v59 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v61 = 0u;
  uint64_t v62 = 0;
  uint64_t v63 = 6;
  char v64 = v45;
  int v66 = 0;
  uint64_t v65 = 4098;
  v68[1].__locale_ = (std::locale::__imp *)0x7FFFFFFFFFFFFFFFLL;
  int v69 = 0;
  uint64_t v46 = *(void *)(a1 + 8);
  unint64_t v47 = 0xEEEEEEEEEEEEEEEFLL * ((v46 - *(void *)a1) >> 3);
  if (v54 > v47)
  {
    std::vector<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::__append((void **)a1, v54 - v47, (uint64_t)&v58);
    goto LABEL_93;
  }
  if (v54 < v47)
  {
    uint64_t v48 = *(void *)a1 + 120 * v54;
    while (1)
    {
      if (v46 == v48)
      {
        *(void *)(a1 + 8) = v48;
        break;
      }
      if (*(unsigned char *)(v46 - 32))
      {
        std::locale::~locale((std::locale *)(v46 - 24));
        *(unsigned char *)(v46 - 32) = 0;
      }
      if (*(char *)(v46 - 65) < 0)
      {
        operator delete(*(void **)(v46 - 88));
        if ((*(char *)(v46 - 89) & 0x80000000) == 0) {
          goto LABEL_85;
        }
      }
      else if ((*(char *)(v46 - 89) & 0x80000000) == 0)
      {
        goto LABEL_85;
      }
      operator delete(*(void **)(v46 - 112));
LABEL_85:
      v46 -= 120;
    }
  }
LABEL_93:
  if (v67)
  {
    std::locale::~locale(v68);
    char v67 = 0;
  }
  if ((SHIBYTE(v61) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
      goto LABEL_97;
    }
LABEL_101:
    operator delete(v59[0]);
    int v49 = *(_DWORD *)(a1 + 48);
    if ((v51 & 1) == 0) {
      goto LABEL_99;
    }
LABEL_98:
    v49 |= 4u;
    *(_DWORD *)(a1 + 48) = v49;
    goto LABEL_99;
  }
  operator delete(__p[1]);
  if (SHIBYTE(__p[0]) < 0) {
    goto LABEL_101;
  }
LABEL_97:
  int v49 = *(_DWORD *)(a1 + 48);
  if (v51) {
    goto LABEL_98;
  }
LABEL_99:
  *(_DWORD *)(a1 + 56) = v53 + 1;
  *(_DWORD *)(a1 + 48) = v49 & 0xFFFFFFFE | v52 & 1;
  return a1;
}

void sub_21DED763C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::exception a18)
{
}

void sub_21DED7650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>::~format_item((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DED7664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::locale a18)
{
}

uint64_t boost::io::detail::upper_bound_from_fstring<std::string,std::ctype<char>>(uint64_t a1, int __c, uint64_t a3, char a4)
{
  size_t v4 = (char *)*(unsigned __int8 *)(a1 + 23);
  int v5 = *(char **)(a1 + 8);
  if ((char)v4 >= 0) {
    unint64_t v6 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    unint64_t v6 = *(void *)(a1 + 8);
  }
  if (v6)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = *(void *)a1;
    if ((char)v4 >= 0) {
      uint64_t v12 = a1;
    }
    else {
      uint64_t v12 = *(void *)a1;
    }
    uint64_t v13 = *(void *)(a3 + 16);
    while (1)
    {
      int64_t v14 = (char *)memchr(&v9[v12], __c, v6 - (void)v9);
      if (!v14) {
        return v10;
      }
      BOOL v15 = &v14[-v12];
      if (&v14[-v12] == (char *)-1) {
        return v10;
      }
      uint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >= v6)
      {
        if (a4)
        {
          v25[0] = &unk_26CECA0A8;
          v25[1] = &v14[-v12];
          v25[2] = v6;
          boost::throw_exception<boost::io::bad_format_string>((uint64_t)v25);
        }
        return (v10 + 1);
      }
      int v17 = v16[v12];
      if ((v4 & 0x80) != 0)
      {
        uint64_t v18 = v11;
        int64_t v19 = v5;
        if (v17 == v15[v11]) {
          goto LABEL_9;
        }
LABEL_17:
        uint64_t v20 = (unsigned __int8 *)&v16[v18];
        if (v16 != v19)
        {
          int v21 = (unsigned __int8 *)&v19[v18];
          uint64_t v22 = &v19[v12 - 1] - v14;
          while (((char)*v20 & 0x80000000) == 0 && (*(_DWORD *)(v13 + 4 * *v20) & 0x400) != 0)
          {
            ++v20;
            if (!--v22)
            {
              uint64_t v20 = v21;
              break;
            }
          }
        }
        uint64_t v9 = (char *)&v20[-v12];
        if ((unint64_t)v9 < v6 && v9[v12] == __c) {
          ++v9;
        }
        uint64_t v10 = (v10 + 1);
        if (v6 <= (unint64_t)v9) {
          return v10;
        }
      }
      else
      {
        uint64_t v18 = a1;
        int64_t v19 = v4;
        if (v17 != v15[a1]) {
          goto LABEL_17;
        }
LABEL_9:
        uint64_t v9 = v15 + 2;
        if (v6 <= (unint64_t)v9) {
          return v10;
        }
      }
    }
  }
  return 0;
}

void sub_21DED7820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
}

void boost::basic_format<char,std::char_traits<char>,std::allocator<char>>::make_or_reuse_data(char **a1, unint64_t a2)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)a1 + 184)) {
    std::locale::locale(&v17, (const std::locale *)a1 + 24);
  }
  else {
    MEMORY[0x223C1DD80](&v17);
  }
  size_t v4 = std::locale::use_facet(&v17, MEMORY[0x263F8C108]);
  char v5 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 32);
  std::locale::~locale(&v17);
  uint64_t v6 = a1[1] - *a1;
  if (v6)
  {
    unint64_t v7 = 0xEEEEEEEEEEEEEEEFLL * (v6 >> 3);
    if (a2 > v7)
    {
      LODWORD(v17.__locale_) = -1;
      char v26 = 0;
      *(_OWORD *)uint64_t v18 = 0u;
      *(_OWORD *)std::string __p = 0u;
      long long v20 = 0u;
      uint64_t v21 = 0;
      uint64_t v22 = 6;
      char v23 = v5;
      int v25 = 0;
      uint64_t v24 = 4098;
      uint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
      int v29 = 0;
      std::vector<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::__append((void **)a1, a2 - v7, (uint64_t)&v17);
      if (v26)
      {
        std::locale::~locale(&v27);
        char v26 = 0;
      }
      if (SHIBYTE(v20) < 0)
      {
        operator delete(__p[1]);
        if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
          goto LABEL_10;
        }
      }
      else if ((SHIBYTE(__p[0]) & 0x80000000) == 0)
      {
LABEL_10:
        std::vector<BOOL>::resize((uint64_t)(a1 + 3), 0, 0);
LABEL_17:
        uint64_t v8 = 56;
        while (1)
        {
          uint64_t v10 = *a1;
          uint64_t v11 = (uint64_t)&(*a1)[v8];
          *(_DWORD *)(v11 - 56) = -1;
          *(void *)(v11 + 48) = 0x7FFFFFFFFFFFFFFFLL;
          *(_DWORD *)(v11 + 56) = 0;
          uint64_t v12 = (unsigned char **)(v11 - 48);
          if (*(char *)(v11 - 25) < 0)
          {
            BOOL v15 = *v12;
            *(void *)(v11 - 40) = 0;
            *BOOL v15 = 0;
            uint64_t v13 = &v10[v8];
            int64_t v14 = &v10[v8 - 24];
            if (v10[v8 - 1] < 0)
            {
LABEL_24:
              int64_t v14 = *(char **)v14;
              *((void *)v13 - 2) = 0;
              goto LABEL_19;
            }
          }
          else
          {
            *(unsigned char *)(v11 - 25) = 0;
            *(unsigned char *)uint64_t v12 = 0;
            uint64_t v13 = &v10[v8];
            int64_t v14 = &v10[v8 - 24];
            if (v10[v8 - 1] < 0) {
              goto LABEL_24;
            }
          }
          *(v13 - 1) = 0;
LABEL_19:
          *int64_t v14 = 0;
          uint64_t v9 = &v10[v8];
          *(_OWORD *)uint64_t v9 = xmmword_21DFAB250;
          v9[16] = v5;
          *((_DWORD *)v9 + 7) = 0;
          v8 += 120;
          *(void *)(v9 + 20) = 4098;
          if (!--a2) {
            goto LABEL_27;
          }
        }
      }
      operator delete(v18[0]);
      goto LABEL_10;
    }
    std::vector<BOOL>::resize((uint64_t)(a1 + 3), 0, 0);
    if (a2) {
      goto LABEL_17;
    }
  }
  else
  {
    LODWORD(v17.__locale_) = -1;
    char v26 = 0;
    *(_OWORD *)uint64_t v18 = 0u;
    *(_OWORD *)std::string __p = 0u;
    long long v20 = 0u;
    uint64_t v21 = 0;
    uint64_t v22 = 6;
    char v23 = v5;
    int v25 = 0;
    uint64_t v24 = 4098;
    uint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
    int v29 = 0;
    std::vector<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::assign((uint64_t *)a1, a2, (uint64_t)&v17);
    if (v26)
    {
      std::locale::~locale(&v27);
      char v26 = 0;
    }
    if (SHIBYTE(v20) < 0)
    {
      operator delete(__p[1]);
      if ((SHIBYTE(__p[0]) & 0x80000000) == 0) {
        goto LABEL_27;
      }
    }
    else if ((SHIBYTE(__p[0]) & 0x80000000) == 0)
    {
      goto LABEL_27;
    }
    operator delete(v18[0]);
  }
LABEL_27:
  if (*((char *)a1 + 87) < 0)
  {
    uint64_t v16 = a1[8];
    a1[9] = 0;
  }
  else
  {
    uint64_t v16 = (char *)(a1 + 8);
    *((unsigned char *)a1 + 87) = 0;
  }
  *uint64_t v16 = 0;
}

void sub_21DED7B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_21DED7B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_21DED7B64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

uint64_t boost::io::detail::parse_printf_directive<char,std::char_traits<char>,std::allocator<char>,std::__wrap_iter<char const*>,std::ctype<char>>(unsigned __int8 **a1, char **a2, uint64_t a3, void *a4, unsigned __int8 *a5, uint64_t a6)
{
  *(_DWORD *)a3 = -1;
  uint64_t v8 = *a1;
  uint64_t v9 = (uint64_t)&a5[*a2 - (char *)*a1];
  if (*a2 <= (char *)*a1)
  {
    if (a6)
    {
      std::locale v58 = &unk_26CECA0A8;
      uint64_t v59 = a5;
      uint64_t v60 = v9;
      boost::throw_exception<boost::io::bad_format_string>((uint64_t)&v58);
    }
    return 0;
  }
  int v14 = *v8;
  unsigned __int8 v15 = (*(uint64_t (**)(void *, uint64_t))(*a4 + 56))(a4, 124);
  uint64_t v16 = *a1;
  if (v14 == v15)
  {
    *a1 = ++v16;
    if (v16 >= (unsigned __int8 *)*a2)
    {
      if (a6)
      {
        std::locale v58 = &unk_26CECA0A8;
        uint64_t v59 = &v16[a5 - v8];
        uint64_t v60 = v9;
        boost::throw_exception<boost::io::bad_format_string>((uint64_t)&v58);
      }
      return 0;
    }
  }
  unsigned __int8 v56 = v15;
  int v57 = v14;
  int v17 = *v16;
  unsigned __int8 v18 = (*(uint64_t (**)(void *, uint64_t))(*a4 + 56))(a4, 48);
  int64_t v19 = *a1;
  if (v17 == v18 || (char)*v19 < 0 || (*(_DWORD *)(a4[2] + 4 * *v19) & 0x400) == 0) {
    goto LABEL_29;
  }
  uint64_t v55 = v9;
  if (*a2 == (char *)v19)
  {
    int v20 = 0;
  }
  else
  {
    int v20 = 0;
    do
    {
      if ((char)*v19 < 0) {
        break;
      }
      uint64_t v21 = *v19;
      if ((*(_DWORD *)(a4[2] + 4 * v21) & 0x400) == 0) {
        break;
      }
      int v20 = (*(uint64_t (**)(void *, void, void))(*a4 + 72))(a4, (char)v21, 0)
          + 10 * v20
          - 48;
      ++v19;
    }
    while (v19 != (unsigned __int8 *)*a2);
  }
  *a1 = v19;
  if (v19 >= (unsigned __int8 *)*a2)
  {
    if (a6)
    {
      std::locale v58 = &unk_26CECA0A8;
      uint64_t v59 = &v19[a5 - v8];
      uint64_t v60 = v55;
      boost::throw_exception<boost::io::bad_format_string>((uint64_t)&v58);
    }
    return 0;
  }
  int v23 = *v19;
  if (v23 == (*(unsigned __int8 (**)(void *, uint64_t))(*a4 + 56))(a4, 37))
  {
    *(_DWORD *)a3 = v20 - 1;
    uint64_t v24 = (uint64_t)(*a1 + 1);
    *a1 = (unsigned __int8 *)v24;
    if (v57 == v56)
    {
      uint64_t v25 = a5 - v8 + v24;
      uint64_t v26 = a6;
      uint64_t v27 = v55;
      goto LABEL_79;
    }
    return 1;
  }
  int v28 = **a1;
  if (v28 == (*(unsigned __int8 (**)(void *, uint64_t))(*a4 + 56))(a4, 36))
  {
    *(_DWORD *)a3 = v20 - 1;
    int64_t v19 = *a1 + 1;
    *a1 = v19;
    uint64_t v9 = v55;
LABEL_29:
    while (2)
    {
      if (v19 == (unsigned __int8 *)*a2)
      {
        if (a6)
        {
          std::locale v58 = &unk_26CECA0A8;
          uint64_t v59 = &v19[a5 - v8];
          uint64_t v60 = v9;
          boost::throw_exception<boost::io::bad_format_string>((uint64_t)&v58);
        }
        return 1;
      }
      switch((*(unsigned int (**)(void *, void, void))(*a4 + 72))(a4, (char)*v19, 0))
      {
        case ' ':
          *(_DWORD *)(a3 + 112) |= 2u;
          goto LABEL_28;
        case '#':
          int v29 = *(_DWORD *)(a3 + 76) | 0x600;
          goto LABEL_27;
        case '\'':
          goto LABEL_28;
        case '+':
          int v29 = *(_DWORD *)(a3 + 76) | 0x800;
          goto LABEL_27;
        case '-':
          int v29 = *(_DWORD *)(a3 + 76) | 0x20;
          goto LABEL_27;
        case '0':
          *(_DWORD *)(a3 + 112) |= 1u;
          goto LABEL_28;
        case '=':
          *(_DWORD *)(a3 + 112) |= 4u;
          goto LABEL_28;
        case '_':
          int v29 = *(_DWORD *)(a3 + 76) | 0x10;
LABEL_27:
          *(_DWORD *)(a3 + 76) = v29;
LABEL_28:
          int64_t v19 = *a1 + 1;
          *a1 = v19;
          continue;
        default:
          int v30 = **a1;
          unsigned __int8 v31 = (*(uint64_t (**)(void *, uint64_t))(*a4 + 56))(a4, 42);
          int v32 = *a1;
          if (v30 == v31)
          {
            ++v32;
LABEL_41:
            *a1 = v32;
            goto LABEL_51;
          }
          if (v32 != (unsigned __int8 *)*a2
            && ((char)*v32 & 0x80000000) == 0
            && (*(_DWORD *)(a4[2] + 4 * *v32) & 0x400) != 0)
          {
            *(void *)(a3 + 56) = 0;
            do
            {
              if ((char)*v32 < 0) {
                break;
              }
              uint64_t v33 = *v32;
              if ((*(_DWORD *)(a4[2] + 4 * v33) & 0x400) == 0) {
                break;
              }
              *(void *)(a3 + 56) = 10 * *(void *)(a3 + 56)
                                   + (*(int (**)(void *, void, void))(*a4 + 72))(a4, (char)v33, 0)- 48;
              ++v32;
            }
            while (v32 != (unsigned __int8 *)*a2);
            goto LABEL_41;
          }
          break;
      }
      goto LABEL_51;
    }
  }
  *(void *)(a3 + 56) = v20;
  *(_DWORD *)a3 = -1;
  int v32 = *a1;
  uint64_t v9 = v55;
LABEL_51:
  if (v32 >= (unsigned __int8 *)*a2)
  {
    if (a6)
    {
      std::locale v58 = &unk_26CECA0A8;
      uint64_t v59 = &v32[a5 - v8];
      uint64_t v60 = v9;
      boost::throw_exception<boost::io::bad_format_string>((uint64_t)&v58);
    }
    return 1;
  }
  int v34 = *v32;
  unsigned __int8 v35 = (*(uint64_t (**)(void *, uint64_t))(*a4 + 56))(a4, 46);
  unint64_t v36 = *a1;
  if (v34 != v35)
  {
    int v39 = 0;
    if (v36 == (unsigned __int8 *)*a2)
    {
LABEL_96:
      if (a6)
      {
        std::locale v58 = &unk_26CECA0A8;
        uint64_t v59 = &v36[a5 - v8];
        uint64_t v60 = v9;
        boost::throw_exception<boost::io::bad_format_string>((uint64_t)&v58);
      }
      return 1;
    }
    goto LABEL_65;
  }
  *a1 = ++v36;
  if (v36 == (unsigned __int8 *)*a2) {
    goto LABEL_64;
  }
  int v37 = *v36;
  unsigned __int8 v38 = (*(uint64_t (**)(void *, uint64_t))(*a4 + 56))(a4, 42);
  unint64_t v36 = *a1;
  if (v37 == v38)
  {
    int v39 = 0;
    *a1 = ++v36;
    if (v36 == (unsigned __int8 *)*a2) {
      goto LABEL_96;
    }
    goto LABEL_65;
  }
  if (v36 == (unsigned __int8 *)*a2 || (char)*v36 < 0 || (*(_DWORD *)(a4[2] + 4 * *v36) & 0x400) == 0)
  {
LABEL_64:
    int v39 = 0;
    *(void *)(a3 + 64) = 0;
    if (v36 == (unsigned __int8 *)*a2) {
      goto LABEL_96;
    }
  }
  else
  {
    unint64_t v36 = boost::io::detail::str2int<long,std::__wrap_iter<char const*>,std::ctype<char>>(a1, a2, (void *)(a3 + 64), a4);
    *a1 = v36;
    int v39 = 1;
    if (v36 == (unsigned __int8 *)*a2) {
      goto LABEL_96;
    }
  }
LABEL_65:
  int v40 = 0;
  while (2)
  {
    switch((*(unsigned int (**)(void *, void, void))(*a4 + 72))(a4, (char)*v36, 0))
    {
      case '2':
        if (v40 == 51) {
          goto LABEL_72;
        }
        goto LABEL_77;
      case '3':
        if (v40 != 73) {
          goto LABEL_77;
        }
        int v40 = 51;
        goto LABEL_67;
      case '4':
        if (v40 != 54) {
          goto LABEL_77;
        }
LABEL_72:
        int v40 = 0;
        goto LABEL_67;
      case '6':
        if (v40 == 73)
        {
          int v40 = 54;
LABEL_67:
          unint64_t v36 = *a1 + 1;
          *a1 = v36;
          if (v36 == (unsigned __int8 *)*a2) {
            goto LABEL_96;
          }
          continue;
        }
LABEL_77:
        CFStringRef v41 = *a1;
LABEL_78:
        uint64_t v25 = (uint64_t)&v41[a5 - v8];
        uint64_t v26 = a6;
        uint64_t v27 = v9;
LABEL_79:
        boost::io::detail::maybe_throw_exception(v26, v25, v27);
        return 1;
      case 'I':
        int v40 = 73;
        goto LABEL_67;
      case 'L':
      case 'h':
      case 'j':
      case 'l':
      case 'w':
      case 'z':
        goto LABEL_67;
      default:
        unint64_t v36 = *a1;
        BOOL v42 = v40 == 73 || v40 == 0;
        int v43 = !v42;
        if (v36 >= (unsigned __int8 *)*a2 || v43 != 0) {
          goto LABEL_96;
        }
        int v45 = v57;
        if (v57 == v56)
        {
          int v46 = *v36;
          unsigned __int8 v47 = (*(uint64_t (**)(void *, uint64_t))(*a4 + 56))(a4, 124);
          unint64_t v36 = *a1;
          BOOL v42 = v46 == v47;
          int v45 = v57;
          if (v42)
          {
            *a1 = v36 + 1;
            return 1;
          }
        }
        switch((*(unsigned int (**)(void *, void, void))(*a4 + 72))(a4, (char)*v36, 0))
        {
          case 'A':
            int v50 = *(_DWORD *)(a3 + 76) | 0x4000;
            *(_DWORD *)(a3 + 76) = v50;
            goto LABEL_117;
          case 'C':
          case 'c':
            *(void *)(a3 + 104) = 1;
            goto LABEL_123;
          case 'E':
            int v51 = *(_DWORD *)(a3 + 76) | 0x4000;
            *(_DWORD *)(a3 + 76) = v51;
            goto LABEL_120;
          case 'F':
            int v52 = *(_DWORD *)(a3 + 76) | 0x4000;
            *(_DWORD *)(a3 + 76) = v52;
            unsigned int v49 = v52 | 4;
            goto LABEL_121;
          case 'G':
            *(_DWORD *)(a3 + 76) |= 0x4000u;
            goto LABEL_123;
          case 'S':
          case 's':
            if (v39) {
              *(void *)(a3 + 104) = *(void *)(a3 + 64);
            }
            *(void *)(a3 + 64) = 6;
            goto LABEL_122;
          case 'T':
            uint64_t v48 = *a1 + 1;
            *a1 = v48;
            if (v48 >= (unsigned __int8 *)*a2)
            {
              boost::io::detail::maybe_throw_exception(a6, (uint64_t)&v48[a5 - v8], v9);
              return 0;
            }
            *(unsigned char *)(a3 + 72) = *v48;
            *(_DWORD *)(a3 + 112) |= 8u;
            *(_DWORD *)a3 = -2;
LABEL_122:
            int v45 = v57;
LABEL_123:
            CFStringRef v41 = *a1 + 1;
            *a1 = v41;
            if (v45 != v56) {
              return 1;
            }
            if (v41 != (unsigned __int8 *)*a2)
            {
              int v53 = *v41;
              unsigned __int8 v54 = (*(uint64_t (**)(void *, uint64_t))(*a4 + 56))(a4, 124);
              CFStringRef v41 = *a1;
              if (v53 == v54)
              {
                *a1 = v41 + 1;
                return 1;
              }
            }
            break;
          case 'X':
            *(_DWORD *)(a3 + 76) |= 0x4000u;
            goto LABEL_109;
          case 'a':
            int v50 = *(_DWORD *)(a3 + 76);
LABEL_117:
            unsigned int v49 = v50 & 0xFFFFFEB1 | 0x104;
            goto LABEL_121;
          case 'b':
            *(_DWORD *)(a3 + 76) |= 1u;
            goto LABEL_123;
          case 'd':
          case 'g':
          case 'i':
          case 'u':
            goto LABEL_123;
          case 'e':
            int v51 = *(_DWORD *)(a3 + 76);
LABEL_120:
            unsigned int v49 = v51 | 0x100;
            goto LABEL_121;
          case 'f':
            unsigned int v49 = *(_DWORD *)(a3 + 76) | 4;
LABEL_121:
            *(_DWORD *)(a3 + 76) = v49;
            goto LABEL_122;
          case 'n':
            *(_DWORD *)a3 = -3;
            goto LABEL_123;
          case 'o':
            *(_DWORD *)(a3 + 76) = *(_DWORD *)(a3 + 76) & 0xFFFFFFB5 | 0x40;
            goto LABEL_123;
          case 'p':
          case 'x':
LABEL_109:
            *(_DWORD *)(a3 + 76) = *(_DWORD *)(a3 + 76) & 0xFFFFFFB5 | 8;
            goto LABEL_123;
          case 't':
            *(unsigned char *)(a3 + 72) = (*(uint64_t (**)(void *, uint64_t))(*a4 + 56))(a4, 32);
            *(_DWORD *)(a3 + 112) |= 8u;
            *(_DWORD *)a3 = -2;
            goto LABEL_123;
          default:
            boost::io::detail::maybe_throw_exception(a6, (uint64_t)&(*a1)[a5 - v8], v9);
            goto LABEL_123;
        }
        goto LABEL_78;
    }
  }
}

void sub_21DED8628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

void sub_21DED863C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

void sub_21DED8650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

void sub_21DED8664(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

void sub_21DED8678(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

void sub_21DED868C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12)
{
}

void boost::throw_exception<boost::io::bad_format_string>(uint64_t a1)
{
  exception = (__n128 *)__cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::io::bad_format_string>::wrapexcept(exception, a1);
}

void sub_21DED89EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::vector<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::assign(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[2];
  uint64_t v7 = *a1;
  if (0xEEEEEEEEEEEEEEEFLL * ((v6 - *a1) >> 3) >= a2)
  {
    unint64_t v10 = (a1[1] - v7) / 120;
    if (v10 >= a2) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = (a1[1] - v7) / 120;
    }
    for (; v11; --v11)
    {
      boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>::operator=(v7, a3);
      v7 += 120;
    }
    if (a2 > v10)
    {
      uint64_t v12 = a1[1];
      unint64_t v13 = v12 + 120 * (a2 - v10);
      uint64_t v14 = -120 * v10 + 120 * a2;
      do
      {
        std::construct_at[abi:ne180100]<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>> const&,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>*>(v12, a3);
        v12 += 120;
        v14 -= 120;
      }
      while (v14);
      a1[1] = v13;
      return;
    }
    uint64_t v15 = a1[1];
    uint64_t v16 = *a1 + 120 * a2;
    while (1)
    {
      if (v15 == v16)
      {
        a1[1] = v16;
        return;
      }
      if (*(unsigned char *)(v15 - 32))
      {
        std::locale::~locale((std::locale *)(v15 - 24));
        *(unsigned char *)(v15 - 32) = 0;
      }
      if (*(char *)(v15 - 65) < 0)
      {
        operator delete(*(void **)(v15 - 88));
        if ((*(char *)(v15 - 89) & 0x80000000) == 0) {
          goto LABEL_23;
        }
      }
      else if ((*(char *)(v15 - 89) & 0x80000000) == 0)
      {
        goto LABEL_23;
      }
      operator delete(*(void **)(v15 - 112));
LABEL_23:
      v15 -= 120;
    }
  }
  if (!v7) {
    goto LABEL_35;
  }
  uint64_t v8 = a1[1];
  uint64_t v9 = (void *)*a1;
  if (v8 != v7)
  {
    while (1)
    {
      if (*(unsigned char *)(v8 - 32))
      {
        std::locale::~locale((std::locale *)(v8 - 24));
        *(unsigned char *)(v8 - 32) = 0;
      }
      if (*(char *)(v8 - 65) < 0)
      {
        operator delete(*(void **)(v8 - 88));
        if (*(char *)(v8 - 89) < 0) {
LABEL_12:
        }
          operator delete(*(void **)(v8 - 112));
      }
      else if (*(char *)(v8 - 89) < 0)
      {
        goto LABEL_12;
      }
      v8 -= 120;
      if (v8 == v7)
      {
        uint64_t v9 = (void *)*a1;
        break;
      }
    }
  }
  a1[1] = v7;
  operator delete(v9);
  uint64_t v6 = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
LABEL_35:
  if (a2 > 0x222222222222222) {
    goto LABEL_45;
  }
  unint64_t v17 = 0xEEEEEEEEEEEEEEEFLL * (v6 >> 3);
  uint64_t v18 = 2 * v17;
  if (2 * v17 <= a2) {
    uint64_t v18 = a2;
  }
  unint64_t v19 = v17 >= 0x111111111111111 ? 0x222222222222222 : v18;
  if (v19 > 0x222222222222222) {
LABEL_45:
  }
    std::vector<std::string>::__throw_length_error[abi:ne180100]();
  uint64_t v20 = 120 * v19;
  uint64_t v21 = (char *)operator new(120 * v19);
  *a1 = (uint64_t)v21;
  a1[1] = (uint64_t)v21;
  a1[2] = (uint64_t)&v21[v20];
  uint64_t v22 = 120 * a2;
  int v23 = &v21[120 * a2];
  do
  {
    std::construct_at[abi:ne180100]<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>> const&,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>*>((uint64_t)v21, a3);
    v21 += 120;
    v22 -= 120;
  }
  while (v22);
  a1[1] = (uint64_t)v23;
}

void sub_21DED8C80(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_21DED8C88(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<BOOL>::resize(uint64_t a1, unint64_t a2, size_t __len)
{
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = a2 - v4;
  if (a2 <= v4)
  {
    *(void *)(a1 + 8) = a2;
    return;
  }
  int v6 = __len;
  uint64_t v7 = *(void *)(a1 + 16);
  unint64_t v8 = v7 << 6;
  if (v7 << 6 < v5 || v4 > (v7 << 6) - v5)
  {
    int __dst = 0;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    if ((a2 & 0x8000000000000000) != 0) {
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = v7 << 7;
    if (v10 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0)) {
      unint64_t v10 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
    }
    if (v8 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    std::vector<BOOL>::reserve((uint64_t)&__dst, v11);
    uint64_t v12 = *(void **)a1;
    uint64_t v13 = *(void *)(a1 + 8);
    unint64_t v14 = v13 + v5;
    uint64_t v24 = v13 + v5;
    uint64_t v15 = (char *)__dst;
    if (v13 < 1)
    {
      LODWORD(v17) = 0;
      uint64_t v16 = (char *)__dst;
    }
    else
    {
      unint64_t v17 = (unint64_t)v13 >> 6;
      if ((unint64_t)v13 >= 0x40) {
        memmove(__dst, v12, 8 * v17);
      }
      uint64_t v16 = &v15[8 * v17];
      if ((v13 & 0x3F) != 0)
      {
        *(void *)uint64_t v16 = *(void *)v16 & ~(0xFFFFFFFFFFFFFFFFLL >> -(v13 & 0x3F)) | *((void *)v12 + v17) & (0xFFFFFFFFFFFFFFFFLL >> -(v13 & 0x3F));
        LODWORD(v17) = v13 & 0x3F;
      }
      else
      {
        LODWORD(v17) = 0;
      }
      uint64_t v12 = *(void **)a1;
      uint64_t v13 = *(void *)(a1 + 8);
      uint64_t v15 = (char *)__dst;
      unint64_t v14 = v24;
    }
    *(void *)a1 = v15;
    *(void *)(a1 + 8) = v14;
    int __dst = v12;
    uint64_t v24 = v13;
    uint64_t v18 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25;
    uint64_t v25 = v18;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    uint64_t v16 = (char *)(*(void *)a1 + 8 * (v4 >> 6));
    unint64_t v17 = *(void *)(a1 + 8) & 0x3FLL;
    *(void *)(a1 + 8) = a2;
  }
  if (v5)
  {
    if (v6)
    {
      if (v17)
      {
        if ((64 - v17) >= v5) {
          unint64_t v19 = v5;
        }
        else {
          unint64_t v19 = (64 - v17);
        }
        *(void *)v16 |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v17 - v19)) & (-1 << v17);
        v16 += 8;
        v5 -= v19;
      }
      uint64_t v20 = 8 * (v5 >> 6);
      if (v5 >= 0x40) {
        memset(v16, 255, 8 * (v5 >> 6));
      }
      if ((v5 & 0x3F) != 0)
      {
        unint64_t v21 = *(void *)&v16[v20] | (0xFFFFFFFFFFFFFFFFLL >> -(v5 & 0x3F));
LABEL_44:
        *(void *)&v16[v20] = v21;
      }
    }
    else
    {
      if (v17)
      {
        if ((64 - v17) >= v5) {
          unint64_t v22 = v5;
        }
        else {
          unint64_t v22 = (64 - v17);
        }
        *(void *)v16 &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v17 - v22)) & (-1 << v17));
        v16 += 8;
        v5 -= v22;
      }
      uint64_t v20 = 8 * (v5 >> 6);
      if (v5 >= 0x40) {
        bzero(v16, 8 * (v5 >> 6));
      }
      if ((v5 & 0x3F) != 0)
      {
        unint64_t v21 = *(void *)&v16[v20] & ~(0xFFFFFFFFFFFFFFFFLL >> -(v5 & 0x3F));
        goto LABEL_44;
      }
    }
  }
}

void sub_21DED8EF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>::operator=(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v4 = a1 + 8;
  if (a1 != a2)
  {
    char v5 = *(unsigned char *)(a2 + 31);
    if (*(char *)(a1 + 31) < 0)
    {
      if (v5 >= 0) {
        unint64_t v10 = (void *)(a2 + 8);
      }
      else {
        unint64_t v10 = *(void **)(a2 + 8);
      }
      if (v5 >= 0) {
        size_t v11 = *(unsigned __int8 *)(a2 + 31);
      }
      else {
        size_t v11 = *(void *)(a2 + 16);
      }
      std::string::__assign_no_alias<false>((void **)v4, v10, v11);
      uint64_t v7 = a1 + 32;
      unint64_t v8 = (void *)(a2 + 32);
      size_t v9 = *(unsigned __int8 *)(a2 + 55);
      if (*(char *)(a1 + 55) < 0) {
        goto LABEL_16;
      }
    }
    else if ((*(unsigned char *)(a2 + 31) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>((void *)v4, *(void **)(a2 + 8), *(void *)(a2 + 16));
      uint64_t v7 = a1 + 32;
      unint64_t v8 = (void *)(a2 + 32);
      size_t v9 = *(unsigned __int8 *)(a2 + 55);
      if (*(char *)(a1 + 55) < 0)
      {
LABEL_16:
        if ((v9 & 0x80u) == 0) {
          uint64_t v13 = v8;
        }
        else {
          uint64_t v13 = *(void **)(a2 + 32);
        }
        if ((v9 & 0x80u) == 0) {
          size_t v14 = v9;
        }
        else {
          size_t v14 = *(void *)(a2 + 40);
        }
        std::string::__assign_no_alias<false>((void **)v7, v13, v14);
        goto LABEL_24;
      }
    }
    else
    {
      long long v6 = *(_OWORD *)(a2 + 8);
      *(void *)(v4 + 16) = *(void *)(a2 + 24);
      *(_OWORD *)uint64_t v4 = v6;
      uint64_t v7 = a1 + 32;
      unint64_t v8 = (void *)(a2 + 32);
      size_t v9 = *(unsigned __int8 *)(a2 + 55);
      if (*(char *)(a1 + 55) < 0) {
        goto LABEL_16;
      }
    }
    if ((v9 & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>((void *)v7, *(void **)(a2 + 32), *(void *)(a2 + 40));
    }
    else
    {
      long long v12 = *(_OWORD *)v8;
      *(void *)(v7 + 16) = v8[2];
      *(_OWORD *)uint64_t v7 = v12;
    }
  }
LABEL_24:
  long long v15 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v15;
  if (*(unsigned char *)(a1 + 88))
  {
    if (*(unsigned char *)(a2 + 88))
    {
      std::locale::operator=((std::locale *)(a1 + 96), (const std::locale *)(a2 + 96));
    }
    else
    {
      std::locale::~locale((std::locale *)(a1 + 96));
      *(unsigned char *)(a1 + 88) = 0;
    }
  }
  else if (*(unsigned char *)(a2 + 88))
  {
    std::locale::locale((std::locale *)(a1 + 96), (const std::locale *)(a2 + 96));
    *(unsigned char *)(a1 + 88) = 1;
  }
  uint64_t v16 = *(void *)(a2 + 104);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  *(void *)(a1 + 104) = v16;
  return a1;
}

uint64_t std::construct_at[abi:ne180100]<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>> const&,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>*>(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a1 + 8), *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
    char v5 = (std::string *)(a1 + 32);
    if ((*(char *)(a2 + 55) & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
    char v5 = (std::string *)(a1 + 32);
    if ((*(char *)(a2 + 55) & 0x80000000) == 0)
    {
LABEL_3:
      long long v6 = *(_OWORD *)(a2 + 32);
      v5->__r_.__value_.__r.__words[2] = *(void *)(a2 + 48);
      *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
      goto LABEL_6;
    }
  }
  std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 32), *(void *)(a2 + 40));
LABEL_6:
  long long v7 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 56) = v7;
  *(unsigned char *)(a1 + 88) = 0;
  if (*(unsigned char *)(a2 + 88))
  {
    std::locale::locale((std::locale *)(a1 + 96), (const std::locale *)(a2 + 96));
    *(unsigned char *)(a1 + 88) = 1;
  }
  uint64_t v8 = *(void *)(a2 + 104);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  *(void *)(a1 + 104) = v8;
  return a1;
}

void sub_21DED9148(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

std::string *std::string::append[abi:ne180100]<std::__wrap_iter<char const*>,0>(std::string *this, unint64_t a2, char *a3)
{
  int v6 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  unint64_t v7 = (unint64_t)&a3[-a2];
  if (v6 < 0)
  {
    if (a3 == (char *)a2) {
      return this;
    }
    std::string::size_type size = this->__r_.__value_.__l.__size_;
    unint64_t v12 = this->__r_.__value_.__r.__words[2];
    unint64_t v9 = (v12 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    size_t v11 = (std::string *)this->__r_.__value_.__r.__words[0];
    unint64_t v10 = HIBYTE(v12);
    if (this->__r_.__value_.__r.__words[0] > a2) {
      goto LABEL_17;
    }
  }
  else
  {
    if (a3 == (char *)a2) {
      return this;
    }
    std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    unint64_t v9 = 22;
    LOBYTE(v10) = *((unsigned char *)&this->__r_.__value_.__s + 23);
    size_t v11 = this;
    if ((unint64_t)this > a2)
    {
LABEL_17:
      if (v9 - size >= v7)
      {
        unint64_t v22 = (char *)this;
        if ((v10 & 0x80) != 0) {
          unint64_t v22 = (char *)this->__r_.__value_.__r.__words[0];
        }
LABEL_28:
        int v23 = &v22[size];
        if ((char *)a2 != a3)
        {
          if (v7 >= 0x20)
          {
            uint64_t v24 = (char *)a2;
            if ((unint64_t)&v22[size - a2] >= 0x20)
            {
              v23 += v7 & 0xFFFFFFFFFFFFFFE0;
              uint64_t v24 = (char *)(a2 + (v7 & 0xFFFFFFFFFFFFFFE0));
              uint64_t v27 = (long long *)(a2 + 16);
              int v28 = &v22[size + 16];
              unint64_t v29 = v7 & 0xFFFFFFFFFFFFFFE0;
              do
              {
                long long v30 = *v27;
                *((_OWORD *)v28 - 1) = *(v27 - 1);
                *(_OWORD *)int v28 = v30;
                v27 += 2;
                v28 += 32;
                v29 -= 32;
              }
              while (v29);
              if (v7 == (v7 & 0xFFFFFFFFFFFFFFE0)) {
                goto LABEL_40;
              }
            }
          }
          else
          {
            uint64_t v24 = (char *)a2;
          }
          do
          {
            char v31 = *v24++;
            *v23++ = v31;
          }
          while (v24 != a3);
        }
LABEL_40:
        *int v23 = 0;
        std::string::size_type v32 = size + v7;
        if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
          this->__r_.__value_.__l.__size_ = v32;
        }
        else {
          *((unsigned char *)&this->__r_.__value_.__s + 23) = v32 & 0x7F;
        }
        return this;
      }
      size_t v20 = 0x7FFFFFFFFFFFFFF7;
      if (0x7FFFFFFFFFFFFFF7 - v9 < size + v7 - v9) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      unint64_t v21 = this;
      if (v6 < 0)
      {
        unint64_t v21 = (std::string *)this->__r_.__value_.__r.__words[0];
        if (v9 > 0x3FFFFFFFFFFFFFF2)
        {
LABEL_21:
          unint64_t v22 = (char *)operator new(0x7FFFFFFFFFFFFFF7uLL);
          if (!size)
          {
LABEL_23:
            if (v9 != 22) {
              operator delete(v21);
            }
            this->__r_.__value_.__l.__size_ = size;
            this->__r_.__value_.__r.__words[2] = v20 | 0x8000000000000000;
            this->__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
            goto LABEL_28;
          }
LABEL_22:
          memmove(v22, v21, size);
          goto LABEL_23;
        }
      }
      else if (v9 > 0x3FFFFFFFFFFFFFF2)
      {
        goto LABEL_21;
      }
      unint64_t v37 = 2 * v9;
      if (size + v7 > 2 * v9) {
        unint64_t v37 = size + v7;
      }
      uint64_t v38 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v37 | 7) != 0x17) {
        uint64_t v38 = v37 | 7;
      }
      if (v37 >= 0x17) {
        size_t v20 = v38 + 1;
      }
      else {
        size_t v20 = 23;
      }
      unint64_t v22 = (char *)operator new(v20);
      if (!size) {
        goto LABEL_23;
      }
      goto LABEL_22;
    }
  }
  if ((unint64_t)v11->__r_.__value_.__r.__words + size + 1 <= a2) {
    goto LABEL_17;
  }
  memset(__p, 170, sizeof(__p));
  if (v7 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v7 > 0x16)
  {
    uint64_t v25 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v25 = v7 | 7;
    }
    uint64_t v26 = v25 + 1;
    uint64_t v13 = operator new(v25 + 1);
    __p[1] = (void *)v7;
    __p[2] = (void *)(v26 | 0x8000000000000000);
    __p[0] = v13;
    if ((char *)a2 != a3) {
      goto LABEL_11;
    }
LABEL_34:
    size_t v14 = v13;
    goto LABEL_45;
  }
  HIBYTE(__p[2]) = (_BYTE)a3 - a2;
  uint64_t v13 = __p;
  if ((char *)a2 == a3) {
    goto LABEL_34;
  }
LABEL_11:
  if (v7 < 0x20 || (unint64_t)v13 - a2 < 0x20)
  {
    size_t v14 = v13;
    long long v15 = (char *)a2;
  }
  else
  {
    size_t v14 = (char *)v13 + (v7 & 0xFFFFFFFFFFFFFFE0);
    long long v15 = (char *)(a2 + (v7 & 0xFFFFFFFFFFFFFFE0));
    uint64_t v16 = (long long *)(a2 + 16);
    unint64_t v17 = v13 + 1;
    unint64_t v18 = v7 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v19 = *v16;
      *(v17 - 1) = *(v16 - 1);
      *unint64_t v17 = v19;
      v16 += 2;
      v17 += 2;
      v18 -= 32;
    }
    while (v18);
    if (v7 == (v7 & 0x7FFFFFFFFFFFFFE0)) {
      goto LABEL_45;
    }
  }
  do
  {
    char v33 = *v15++;
    *v14++ = v33;
  }
  while (v15 != a3);
LABEL_45:
  *size_t v14 = 0;
  if (SHIBYTE(__p[2]) >= 0) {
    int v34 = __p;
  }
  else {
    int v34 = (void **)__p[0];
  }
  if (SHIBYTE(__p[2]) >= 0) {
    std::string::size_type v35 = HIBYTE(__p[2]);
  }
  else {
    std::string::size_type v35 = (std::string::size_type)__p[1];
  }
  std::string::append(this, (const std::string::value_type *)v34, v35);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  return this;
}

void sub_21DED94B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t boost::io::detail::maybe_throw_exception(uint64_t this, uint64_t a2, uint64_t a3)
{
  if (this)
  {
    v3[0] = &unk_26CECA0A8;
    v3[1] = a2;
    v3[2] = a3;
    boost::throw_exception<boost::io::bad_format_string>((uint64_t)v3);
  }
  return this;
}

void sub_21DED9524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
}

unsigned __int8 *boost::io::detail::str2int<long,std::__wrap_iter<char const*>,std::ctype<char>>(unsigned __int8 **a1, char **a2, void *a3, void *a4)
{
  *a3 = 0;
  for (uint64_t i = *a1; i != (unsigned __int8 *)*a2; ++i)
  {
    if ((char)*i < 0) {
      break;
    }
    uint64_t v8 = *i;
    if ((*(_DWORD *)(a4[2] + 4 * v8) & 0x400) == 0) {
      break;
    }
    *a3 = 10 * *a3
        + (*(int (**)(void *, void, void))(*a4 + 72))(a4, (char)v8, 0)
        - 48;
  }
  return i;
}

__n128 boost::wrapexcept<boost::io::bad_format_string>::wrapexcept(__n128 *a1, uint64_t a2)
{
  a1->n128_u64[0] = (unint64_t)&unk_26CEC9A70;
  a1->n128_u64[1] = (unint64_t)&unk_26CECA0A8;
  __n128 result = *(__n128 *)(a2 + 8);
  a1[1] = result;
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u32[0] = -1;
  a1->n128_u64[0] = (unint64_t)&unk_26CECA030;
  a1->n128_u64[1] = (unint64_t)&unk_26CECA060;
  a1[2].n128_u64[0] = (unint64_t)&unk_26CECA088;
  a1[2].n128_u64[1] = 0;
  return result;
}

std::exception *boost::wrapexcept<boost::io::bad_format_string>::~wrapexcept(std::exception *a1)
{
  a1[4].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[5].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[5].__vftable = 0;
  }
  std::exception::~exception(a1 + 1);
  return a1;
}

void *boost::wrapexcept<boost::io::bad_format_string>::clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = &unk_26CEC9A70;
  v2[1] = &unk_26CECA0A8;
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 40);
  v2[4] = &unk_26CEC9AC8;
  v2[5] = v3;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  *((_OWORD *)v2 + 3) = *(_OWORD *)(a1 + 48);
  *((_DWORD *)v2 + 16) = *(_DWORD *)(a1 + 64);
  *uint64_t v2 = &unk_26CECA030;
  v2[1] = &unk_26CECA060;
  v2[4] = &unk_26CECA088;
  boost::exception_detail::copy_boost_exception((uint64_t)(v2 + 4), a1 + 32);
  return v2;
}

void sub_21DED9860(_Unwind_Exception *a1)
{
  std::exception::~exception(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_21DED987C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::io::bad_format_string>::rethrow(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::io::bad_format_string>::wrapexcept((uint64_t)exception, a1);
}

void sub_21DED98F8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::io::bad_format_string>::~wrapexcept(std::exception *a1)
{
  a1[4].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[5].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[5].__vftable = 0;
  }
  std::exception::~exception(a1 + 1);

  operator delete(a1);
}

void non-virtual thunk to'boost::wrapexcept<boost::io::bad_format_string>::~wrapexcept(std::exception *this)
{
  this[3].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = this[4].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    this[4].__vftable = 0;
  }

  std::exception::~exception(this);
}

{
  std::exception_vtbl *v2;
  uint64_t vars8;

  this[3].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = this[4].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    this[4].__vftable = 0;
  }
  std::exception::~exception(this);

  operator delete(&this[-1]);
}

const char *boost::io::bad_format_string::what(boost::io::bad_format_string *this)
{
  return "boost::bad_format_string: format-string is ill-formed";
}

void non-virtual thunk to'boost::wrapexcept<boost::io::bad_format_string>::~wrapexcept(std::exception *a1)
{
  a1->__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[1].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[1].__vftable = 0;
  }

  std::exception::~exception(a1 - 3);
}

{
  std::exception_vtbl *v2;
  uint64_t vars8;

  a1->__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[1].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[1].__vftable = 0;
  }
  std::exception::~exception(a1 - 3);

  operator delete(&a1[-4]);
}

void boost::io::bad_format_string::~bad_format_string(std::exception *this)
{
  std::exception::~exception(this);

  operator delete(v1);
}

uint64_t boost::wrapexcept<boost::io::bad_format_string>::wrapexcept(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26CEC9A70;
  *(void *)(a1 + 8) = &unk_26CECA0A8;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = &unk_26CEC9AC8;
  *(void *)(a1 + 40) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v5;
  *(void *)a1 = &unk_26CECA030;
  *(void *)(a1 + 8) = &unk_26CECA060;
  *(void *)(a1 + 32) = &unk_26CECA088;
  return a1;
}

void sub_21DED9D38(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void std::vector<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::__append(void **a1, unint64_t a2, uint64_t a3)
{
  int v6 = a1[2];
  uint64_t v7 = (uint64_t)a1[1];
  if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)&v6[-v7] >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 120 * a2;
      uint64_t v14 = 120 * a2;
      do
      {
        std::construct_at[abi:ne180100]<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>> const&,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>*>(v7, a3);
        v7 += 120;
        v14 -= 120;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    a1[1] = (void *)v7;
  }
  else
  {
    unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((v7 - (uint64_t)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x222222222222222) {
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xEEEEEEEEEEEEEEEFLL * ((v6 - (unsigned char *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x111111111111111) {
      unint64_t v11 = 0x222222222222222;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 > 0x222222222222222) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unint64_t v12 = (char *)operator new(120 * v11);
    }
    else
    {
      unint64_t v12 = 0;
    }
    uint64_t v15 = (uint64_t)&v12[120 * v8];
    uint64_t v28 = v15;
    unint64_t v29 = &v12[120 * v11];
    uint64_t v16 = 120 * a2;
    unint64_t v17 = v15 + 120 * a2;
    do
    {
      std::construct_at[abi:ne180100]<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>> const&,boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>*>(v15, a3);
      v15 += 120;
      v16 -= 120;
    }
    while (v16);
    long long v19 = (char *)*a1;
    unint64_t v18 = (std::locale *)a1[1];
    if (v18 != *a1)
    {
      uint64_t v20 = 0;
      do
      {
        uint64_t v22 = v28 + v20 * 8;
        int v23 = &v18[v20];
        *(_DWORD *)(v22 - 120) = v18[v20 - 15].__locale_;
        long long v24 = *(_OWORD *)&v18[v20 - 14].__locale_;
        *(std::locale *)(v22 - 96) = v18[v20 - 12];
        *(_OWORD *)(v22 - 112) = v24;
        v23[-13].__locale_ = 0;
        v23[-12].__locale_ = 0;
        v23[-14].__locale_ = 0;
        long long v25 = *(_OWORD *)&v18[v20 - 11].__locale_;
        *(std::locale *)(v22 - 72) = v18[v20 - 9];
        *(_OWORD *)(v22 - 88) = v25;
        v23[-10].__locale_ = 0;
        v23[-9].__locale_ = 0;
        v23[-11].__locale_ = 0;
        long long v26 = *(_OWORD *)&v18[v20 - 6].__locale_;
        *(_OWORD *)(v22 - 64) = *(_OWORD *)&v18[v20 - 8].__locale_;
        *(_OWORD *)(v22 - 48) = v26;
        *(unsigned char *)(v22 - 32) = 0;
        if (LOBYTE(v18[v20 - 4].__locale_))
        {
          std::locale::locale((std::locale *)(v22 - 24), v23 - 3);
          *(unsigned char *)(v22 - 32) = 1;
        }
        locale = v23[-2].__locale_;
        *(_DWORD *)(v22 - 8) = v23[-1].__locale_;
        *(void *)(v22 - 16) = locale;
        v20 -= 15;
      }
      while (&v18[v20] != (std::locale *)v19);
      unint64_t v18 = (std::locale *)*a1;
      uint64_t v27 = (std::locale *)a1[1];
      *a1 = (void *)(v28 + v20 * 8);
      a1[1] = (void *)v17;
      a1[2] = v29;
      while (1)
      {
        if (v27 == v18) {
          goto LABEL_35;
        }
        if (LOBYTE(v27[-4].__locale_))
        {
          std::locale::~locale(v27 - 3);
          LOBYTE(v27[-4].__locale_) = 0;
        }
        if (SHIBYTE(v27[-9].__locale_) < 0)
        {
          operator delete(v27[-11].__locale_);
          if ((SHIBYTE(v27[-12].__locale_) & 0x80000000) == 0) {
            goto LABEL_25;
          }
        }
        else if ((SHIBYTE(v27[-12].__locale_) & 0x80000000) == 0)
        {
          goto LABEL_25;
        }
        operator delete(v27[-14].__locale_);
LABEL_25:
        v27 -= 15;
      }
    }
    *a1 = (void *)v28;
    a1[1] = (void *)v17;
    a1[2] = v29;
LABEL_35:
    if (v18) {
      operator delete(v18);
    }
  }
}

void sub_21DED9FDC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_21DED9FE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<boost::io::detail::format_item<char,std::char_traits<char>,std::allocator<char>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 120;
    if (*(unsigned char *)(i - 32))
    {
      std::locale::~locale((std::locale *)(i - 24));
      *(unsigned char *)(i - 32) = 0;
    }
    if (*(char *)(i - 65) < 0)
    {
      operator delete(*(void **)(i - 88));
      if ((*(char *)(i - 89) & 0x80000000) == 0) {
        continue;
      }
    }
    else if ((*(char *)(i - 89) & 0x80000000) == 0)
    {
      continue;
    }
    operator delete(*(void **)(i - 112));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t boost::io::detail::feed_impl<char,std::char_traits<char>,std::allocator<char>,boost::io::detail::put_holder<char,std::char_traits<char>> const&>(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 60))
  {
    uint64_t v4 = *(void *)a1;
    uint64_t v3 = *(void *)(a1 + 8);
    if (v3 != *(void *)a1)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      do
      {
        if (!*(void *)(a1 + 32)
          || (unint64_t v8 = *(unsigned int *)(v4 + v5), (v8 & 0x80000000) != 0)
          || ((*(void *)(*(void *)(a1 + 24) + ((v8 >> 3) & 0x1FFFFFF8)) >> v8) & 1) == 0)
        {
          uint64_t v9 = v4 + v5;
          uint64_t v7 = (void *)(v9 + 8);
          if (*(char *)(v9 + 31) < 0)
          {
            uint64_t v7 = (void *)*v7;
            *(void *)(v9 + 16) = 0;
          }
          else
          {
            *(unsigned char *)(v9 + 31) = 0;
          }
          *(unsigned char *)uint64_t v7 = 0;
          uint64_t v4 = *(void *)a1;
          uint64_t v3 = *(void *)(a1 + 8);
        }
        ++v6;
        v5 += 120;
      }
      while (v6 < 0xEEEEEEEEEEEEEEEFLL * ((v3 - v4) >> 3));
    }
    *(_DWORD *)(a1 + 52) = 0;
    *(unsigned char *)(a1 + 60) = 0;
    if (*(void *)(a1 + 32))
    {
      uint64_t v10 = *(unsigned int *)(a1 + 56);
      if ((int)v10 >= 1)
      {
        unint64_t v11 = 0;
        uint64_t v12 = *(void *)(a1 + 24);
        do
        {
          if (((*(void *)(v12 + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v11) & 1) == 0) {
            break;
          }
          *(_DWORD *)(a1 + 52) = ++v11;
        }
        while (v10 != v11);
      }
    }
  }
  boost::io::detail::distribute<char,std::char_traits<char>,std::allocator<char>,boost::io::detail::put_holder<char,std::char_traits<char>> const&>(a1, a2);
  uint64_t v13 = *(int *)(a1 + 52);
  unint64_t v14 = v13 + 1;
  *(_DWORD *)(a1 + 52) = v13 + 1;
  if (*(void *)(a1 + 32))
  {
    uint64_t v15 = *(int *)(a1 + 56);
    if ((int)v14 < (int)v15)
    {
      uint64_t v16 = *(void *)(a1 + 24);
      int v17 = v13 + 2;
      do
      {
        if (((*(void *)(v16 + ((v14 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v14) & 1) == 0) {
          break;
        }
        ++v14;
        *(_DWORD *)(a1 + 52) = v17++;
      }
      while (v15 != v14);
    }
  }
  return a1;
}

uint64_t boost::io::detail::distribute<char,std::char_traits<char>,std::allocator<char>,boost::io::detail::put_holder<char,std::char_traits<char>> const&>(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(int *)(result + 52);
  uint64_t v4 = *(int *)(result + 56);
  if ((int)v3 >= (int)v4)
  {
    if ((*(unsigned char *)(result + 88) & 4) != 0)
    {
      v11[0] = &unk_26CECA1A8;
      v11[1] = v3;
      void v11[2] = v4;
      boost::throw_exception<boost::io::too_many_args>((uint64_t)v11);
    }
  }
  else
  {
    uint64_t v6 = *(void *)result;
    uint64_t v5 = *(void *)(result + 8);
    if (v5 != *(void *)result)
    {
      uint64_t v8 = 0;
      unint64_t v9 = 0;
      do
      {
        if (*(_DWORD *)(v6 + v8) == *(_DWORD *)(v2 + 52))
        {
          if (*(unsigned char *)(v2 + 184)) {
            uint64_t v10 = (const std::locale *)(v2 + 192);
          }
          else {
            uint64_t v10 = 0;
          }
          __n128 result = boost::io::detail::put<char,std::char_traits<char>,std::allocator<char>,boost::io::detail::put_holder<char,std::char_traits<char>> const&>(a2, v6 + v8, (std::string *)(v6 + v8 + 8), (void *)(v2 + 96), v10);
          uint64_t v6 = *(void *)v2;
          uint64_t v5 = *(void *)(v2 + 8);
        }
        ++v9;
        v8 += 120;
      }
      while (v9 < 0xEEEEEEEEEEEEEEEFLL * ((v5 - v6) >> 3));
    }
  }
  return result;
}

void sub_21DEDA2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
}

void boost::throw_exception<boost::io::too_many_args>(uint64_t a1)
{
  exception = (__n128 *)__cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::io::too_many_args>::wrapexcept(exception, a1);
}

void sub_21DEDA34C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::io::detail::put<char,std::char_traits<char>,std::allocator<char>,boost::io::detail::put_holder<char,std::char_traits<char>> const&>(void *a1, uint64_t a2, std::string *a3, void *a4, const std::locale *a5)
{
  uint64_t v98 = *MEMORY[0x263EF8340];
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v76[8] = v10;
  v76[9] = v10;
  v76[7] = v10;
  v76[5] = v10;
  v76[6] = v10;
  v76[3] = v10;
  v76[4] = v10;
  v76[1] = v10;
  v76[2] = v10;
  long long v75 = v10;
  v76[0] = v10;
  boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::basic_oaltstringstream((uint64_t)&v75, a4);
  uint64_t v73 = a2;
  if (a5)
  {
    unint64_t v11 = (std::ios_base *)((char *)&v76[-1] + *(void *)(v75 - 24));
    v74.__locale_ = (std::locale::__imp *)0xAAAAAAAAAAAAAAAALL;
    std::ios_base::getloc(v11);
    std::ios_base::imbue(v11, a5);
    std::locale::~locale(v77);
    rdbuf = (std::locale *)v11->__rdbuf_;
    if (rdbuf)
    {
      (*((void (**)(std::locale *, const std::locale *))rdbuf->__locale_ + 2))(rdbuf, a5);
      *(void *)&long long v89 = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v13 = rdbuf + 1;
      std::locale::locale((std::locale *)&v89, v13);
      std::locale::operator=(v13, a5);
      std::locale::~locale((std::locale *)&v89);
    }
    std::locale::~locale(&v74);
  }
  uint64_t v14 = a2 + 56;
  boost::io::detail::stream_format_state<char,std::char_traits<char>>::apply_on(v14, (std::ios_base *)((char *)&v76[-1] + *(void *)(v75 - 24)), a5);
  ((void (*)(long long *, void))a1[1])(&v75, *a1);
  uint64_t v15 = v75;
  uint64_t v16 = (char *)&v76[-1] + *(void *)(v75 - 24);
  int v17 = *((_DWORD *)v16 + 2);
  uint64_t __requested_capacity = *((void *)v16 + 3);
  if (SHIBYTE(a3->__r_.__value_.__r.__words[2]) < 0)
  {
    unint64_t v18 = (unsigned char *)a3->__r_.__value_.__r.__words[0];
    a3->__r_.__value_.__l.__size_ = 0;
    *unint64_t v18 = 0;
    if ((v17 & 0x10) == 0)
    {
LABEL_19:
      if (__requested_capacity >= 1) {
        *(void *)((char *)v76 + *(void *)(v15 - 24) + 8) = 0;
      }
      ((void (*)(long long *, void))a1[2])(&v75, *a1);
      char v31 = (const std::string::value_type *)a4[5];
      uint64_t v32 = v73;
      if ((*(unsigned char *)(v73 + 112) & 2) != 0)
      {
        if ((const std::string::value_type *)a4[6] == v31) {
          goto LABEL_66;
        }
        int v34 = *(unsigned __int8 *)v31;
        std::ios_base::getloc((const std::ios_base *)((char *)&v76[-1] + *(void *)(v75 - 24)));
        std::string::size_type v35 = std::locale::use_facet(v77, MEMORY[0x263F8C108]);
        unsigned __int8 v36 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 43);
        std::locale::~locale(v77);
        if (v34 == v36)
        {
          int v33 = 0;
          uint64_t v32 = v73;
          goto LABEL_67;
        }
        int v57 = *(unsigned __int8 *)v31;
        std::ios_base::getloc((const std::ios_base *)((char *)&v76[-1] + *(void *)(v75 - 24)));
        std::locale v58 = std::locale::use_facet(v77, MEMORY[0x263F8C108]);
        unsigned __int8 v59 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v58->__vftable[2].~facet_0)(v58, 45);
        std::locale::~locale(v77);
        BOOL v60 = v57 == v59;
        uint64_t v32 = v73;
        if (!v60)
        {
LABEL_66:
          std::ios_base::getloc((const std::ios_base *)((char *)&v76[-1] + *(void *)(v75 - 24)));
          long long v61 = std::locale::use_facet(v77, MEMORY[0x263F8C108]);
          uint64_t v32 = v73;
          int v33 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v61->__vftable[2].~facet_0)(v61, 32);
          std::locale::~locale(v77);
          goto LABEL_67;
        }
      }
      int v33 = 0;
LABEL_67:
      uint64_t v62 = v32;
      if (a4[6] - a4[5] >= *(void *)(v32 + 104) - (unint64_t)(v33 != 0)) {
        std::string::size_type v63 = *(void *)(v32 + 104) - (v33 != 0);
      }
      else {
        std::string::size_type v63 = a4[6] - a4[5];
      }
      char v64 = (char *)&v76[-1] + *(void *)(v75 - 24);
      int v65 = *((_DWORD *)v64 + 36);
      if (v65 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)&v76[-1] + *(void *)(v75 - 24)));
        int v66 = std::locale::use_facet(v77, MEMORY[0x263F8C108]);
        int v65 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v66->__vftable[2].~facet_0)(v66, 32);
        std::locale::~locale(v77);
        *((_DWORD *)v64 + 36) = v65;
        uint64_t v62 = v73;
      }
      boost::io::detail::mk_str<char,std::char_traits<char>,std::allocator<char>>(a3, v31, v63, __requested_capacity, v65, v17, v33, (*(_DWORD *)(v62 + 112) >> 2) & 1);
      goto LABEL_73;
    }
  }
  else
  {
    *((unsigned char *)&a3->__r_.__value_.__s + 23) = 0;
    a3->__r_.__value_.__s.__data_[0] = 0;
    if ((v17 & 0x10) == 0) {
      goto LABEL_19;
    }
  }
  if (!__requested_capacity) {
    goto LABEL_19;
  }
  ((void (*)(long long *, void))a1[2])(&v75, *a1);
  uint64_t v20 = (const std::string::value_type *)a4[5];
  long long v19 = (const std::string::value_type *)a4[6];
  std::string::size_type v21 = v19 - v20;
  if ((*(unsigned char *)(v73 + 112) & 2) == 0) {
    goto LABEL_14;
  }
  if (v19 == v20) {
    goto LABEL_27;
  }
  std::string::size_type v71 = v19 - v20;
  int v22 = *(unsigned __int8 *)v20;
  std::ios_base::getloc((const std::ios_base *)((char *)&v76[-1] + *(void *)(v75 - 24)));
  int v23 = std::locale::use_facet(v77, MEMORY[0x263F8C108]);
  unsigned __int8 v24 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 43);
  std::locale::~locale(v77);
  std::string::size_type v21 = v71;
  if (v22 == v24) {
    goto LABEL_14;
  }
  int v25 = *(unsigned __int8 *)v20;
  std::ios_base::getloc((const std::ios_base *)((char *)&v76[-1] + *(void *)(v75 - 24)));
  long long v26 = std::locale::use_facet(v77, MEMORY[0x263F8C108]);
  unsigned __int8 v27 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 45);
  std::locale::~locale(v77);
  std::string::size_type v21 = v71;
  if (v25 != v27)
  {
LABEL_27:
    uint64_t v28 = (std::string::size_type *)(v73 + 104);
    unsigned int v30 = 1;
  }
  else
  {
LABEL_14:
    uint64_t v28 = (std::string::size_type *)(v73 + 104);
    if (v21 == __requested_capacity && __requested_capacity <= *(void *)(v73 + 104))
    {
      std::string::__assign_external(a3, v20, __requested_capacity);
      goto LABEL_73;
    }
    unsigned int v30 = 0;
  }
  unint64_t v37 = v20;
  std::string::size_type v38 = v21;
  std::string::__assign_external(a3, v37, v21);
  uint64_t v39 = a4[6];
  if (v39 && v39 != a4[5])
  {
    *(void *)&long long v85 = 0;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    *(_OWORD *)&v77[0].__locale_ = 0u;
    long long v78 = 0u;
    (*(void (**)(long long *__return_ptr, void *, std::locale *, uint64_t))(*a4 + 40))(&v89, a4, v77, 16);
  }
  uint64_t v40 = a4[3];
  if (v40 && v40 != a4[2])
  {
    uint64_t v97 = 0;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v93 = 0u;
    long long v94 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    (*(void (**)(void *__return_ptr, void *, long long *, uint64_t))(*a4 + 40))(v88, a4, &v89, 8);
  }
  *(void *)&long long v41 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v41 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v86 = v41;
  long long v87 = v41;
  long long v84 = v41;
  long long v85 = v41;
  long long v82 = v41;
  long long v83 = v41;
  long long v80 = v41;
  long long v81 = v41;
  long long v78 = v41;
  long long v79 = v41;
  *(_OWORD *)&v77[0].__locale_ = v41;
  boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::basic_oaltstringstream((uint64_t)v77, a4);
  boost::io::detail::stream_format_state<char,std::char_traits<char>>::apply_on(v14, (std::ios_base *)((char *)v77 + *((void *)v77[0].__locale_ - 3)), a5);
  ((void (*)(std::locale *, void))a1[1])(v77, *a1);
  *(void *)((char *)&v78 + *((void *)v77[0].__locale_ - 3) + 8) = 0;
  if (v30)
  {
    LOBYTE(v89) = 32;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v77, (uint64_t)&v89, 1);
  }
  ((void (*)(std::locale *, void))a1[2])(v77, *a1);
  int v43 = (const std::string::value_type *)a4[5];
  BOOL v42 = (const std::string::value_type *)a4[6];
  if (v42 != v43) {
    goto LABEL_39;
  }
  int v43 = (const std::string::value_type *)a4[6];
  unint64_t v44 = __requested_capacity;
  if ((*(unsigned char *)(v73 + 112) & 2) != 0)
  {
    LOBYTE(v89) = 32;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v77, (uint64_t)&v89, 1);
    int v43 = (const std::string::value_type *)a4[5];
    BOOL v42 = (const std::string::value_type *)a4[6];
    unsigned int v30 = 1;
LABEL_39:
    unint64_t v44 = __requested_capacity;
  }
  std::string::size_type v45 = v42 - v43;
  if (v45 >= *v28) {
    std::string::size_type v46 = *v28;
  }
  else {
    std::string::size_type v46 = v45;
  }
  std::string::size_type v47 = v44 - v46;
  if (v44 <= v46)
  {
    std::string::__assign_external(a3, v43, v46);
  }
  else
  {
    unint64_t v48 = v38 + v30;
    if (v46 < v48) {
      unint64_t v48 = v46;
    }
    std::string::size_type v49 = v30;
    if (v48 > v30)
    {
      int v50 = (std::string *)a3->__r_.__value_.__r.__words[0];
      if ((a3->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v50 = a3;
      }
      std::string::size_type v49 = v30;
      while (1)
      {
        int v51 = v50->__r_.__value_.__s.__data_[0];
        int v50 = (std::string *)((char *)v50 + 1);
        if (v43[v49] != v51) {
          break;
        }
        if (v48 == ++v49)
        {
          std::string::size_type v49 = v48;
          break;
        }
      }
    }
    if (v49 >= v46) {
      std::string::size_type v52 = v30;
    }
    else {
      std::string::size_type v52 = v49;
    }
    std::string::__assign_external(a3, v43, v52);
    int v53 = (char *)v77 + *((void *)v77[0].__locale_ - 3);
    int v54 = *((_DWORD *)v53 + 36);
    if (v54 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)v77 + *((void *)v77[0].__locale_ - 3)));
      uint64_t v55 = std::locale::use_facet((const std::locale *)&v89, MEMORY[0x263F8C108]);
      int v54 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 32);
      std::locale::~locale((std::locale *)&v89);
      *((_DWORD *)v53 + 36) = v54;
    }
    std::string::append(a3, v47, v54);
    std::string::append(a3, &v43[v52], v46 - v52);
  }
  std::ostream::~ostream();
  unsigned __int8 v56 = (atomic_uint *)v78;
  if ((void)v78)
  {
    if (atomic_fetch_add((atomic_uint *volatile)(v78 + 8), 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v56 + 16))(v56);
      if (atomic_fetch_add(v56 + 3, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v56 + 24))(v56);
      }
    }
  }
  MEMORY[0x223C1DDF0]((char *)&v78 + 8);
LABEL_73:
  uint64_t v67 = a4[6];
  if (v67 && v67 != a4[5])
  {
    *(void *)&long long v85 = 0;
    long long v83 = 0u;
    long long v84 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    *(_OWORD *)&v77[0].__locale_ = 0u;
    long long v78 = 0u;
    (*(void (**)(long long *__return_ptr, void *, std::locale *, uint64_t))(*a4 + 40))(&v89, a4, v77, 16);
  }
  uint64_t v68 = a4[3];
  if (v68 && v68 != a4[2])
  {
    uint64_t v97 = 0;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v93 = 0u;
    long long v94 = 0u;
    long long v91 = 0u;
    long long v92 = 0u;
    long long v89 = 0u;
    long long v90 = 0u;
    (*(void (**)(void *__return_ptr, void *, long long *, uint64_t))(*a4 + 40))(v88, a4, &v89, 8);
  }
  std::ostream::~ostream();
  int v69 = *(atomic_uint **)&v76[0];
  if (*(void *)&v76[0])
  {
    if (atomic_fetch_add((atomic_uint *volatile)(*(void *)&v76[0] + 8), 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v69 + 16))(v69);
      if (atomic_fetch_add(v69 + 3, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v69 + 24))(v69);
      }
    }
  }
  return MEMORY[0x223C1DDF0]((char *)v76 + 8);
}

void sub_21DEDAE20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  std::locale::~locale((std::locale *)(v35 - 240));
  boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_oaltstringstream((uint64_t)&a35);
  boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_oaltstringstream((uint64_t)&a13);
  _Unwind_Resume(a1);
}

void sub_21DEDAE44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,std::locale a35)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_21DEDAEDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::locale a12, char a13)
{
}

void sub_21DEDAEF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_oaltstringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DEDAF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_oaltstringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DEDAF3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_oaltstringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 boost::wrapexcept<boost::io::too_many_args>::wrapexcept(__n128 *a1, uint64_t a2)
{
  a1->n128_u64[0] = (unint64_t)&unk_26CEC9A70;
  a1->n128_u64[1] = (unint64_t)&unk_26CECA1A8;
  __n128 result = *(__n128 *)(a2 + 8);
  a1[1] = result;
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u32[0] = -1;
  a1->n128_u64[0] = (unint64_t)&unk_26CECA130;
  a1->n128_u64[1] = (unint64_t)&unk_26CECA160;
  a1[2].n128_u64[0] = (unint64_t)&unk_26CECA188;
  a1[2].n128_u64[1] = 0;
  return result;
}

std::exception *boost::wrapexcept<boost::io::too_many_args>::~wrapexcept(std::exception *a1)
{
  a1[4].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[5].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[5].__vftable = 0;
  }
  std::exception::~exception(a1 + 1);
  return a1;
}

void *boost::wrapexcept<boost::io::too_many_args>::clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = &unk_26CEC9A70;
  v2[1] = &unk_26CECA1A8;
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 40);
  v2[4] = &unk_26CEC9AC8;
  v2[5] = v3;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  *((_OWORD *)v2 + 3) = *(_OWORD *)(a1 + 48);
  *((_DWORD *)v2 + 16) = *(_DWORD *)(a1 + 64);
  *uint64_t v2 = &unk_26CECA130;
  v2[1] = &unk_26CECA160;
  v2[4] = &unk_26CECA188;
  boost::exception_detail::copy_boost_exception((uint64_t)(v2 + 4), a1 + 32);
  return v2;
}

void sub_21DEDB1B8(_Unwind_Exception *a1)
{
  std::exception::~exception(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_21DEDB1D4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::io::too_many_args>::rethrow(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::io::too_many_args>::wrapexcept((uint64_t)exception, a1);
}

void sub_21DEDB250(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::io::too_many_args>::~wrapexcept(std::exception *a1)
{
  a1[4].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[5].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[5].__vftable = 0;
  }
  std::exception::~exception(a1 + 1);

  operator delete(a1);
}

void non-virtual thunk to'boost::wrapexcept<boost::io::too_many_args>::~wrapexcept(std::exception *this)
{
  this[3].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = this[4].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    this[4].__vftable = 0;
  }

  std::exception::~exception(this);
}

{
  std::exception_vtbl *v2;
  uint64_t vars8;

  this[3].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = this[4].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    this[4].__vftable = 0;
  }
  std::exception::~exception(this);

  operator delete(&this[-1]);
}

const char *boost::io::too_many_args::what(boost::io::too_many_args *this)
{
  return "boost::too_many_args: format-string referred to fewer arguments than were passed";
}

void non-virtual thunk to'boost::wrapexcept<boost::io::too_many_args>::~wrapexcept(std::exception *a1)
{
  a1->__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[1].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[1].__vftable = 0;
  }

  std::exception::~exception(a1 - 3);
}

{
  std::exception_vtbl *v2;
  uint64_t vars8;

  a1->__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[1].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[1].__vftable = 0;
  }
  std::exception::~exception(a1 - 3);

  operator delete(&a1[-4]);
}

void boost::io::too_many_args::~too_many_args(std::exception *this)
{
  std::exception::~exception(this);

  operator delete(v1);
}

uint64_t boost::wrapexcept<boost::io::too_many_args>::wrapexcept(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26CEC9A70;
  *(void *)(a1 + 8) = &unk_26CECA1A8;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = &unk_26CEC9AC8;
  *(void *)(a1 + 40) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v5;
  *(void *)a1 = &unk_26CECA130;
  *(void *)(a1 + 8) = &unk_26CECA160;
  *(void *)(a1 + 32) = &unk_26CECA188;
  return a1;
}

void sub_21DEDB690(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

uint64_t boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::basic_oaltstringstream(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = a2;
  uint64_t v4 = (std::ios_base *)(a1 + 24);
  uint64_t v5 = MEMORY[0x263F8C368] + 16;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v5;
  uint64_t v6 = operator new(0x20uLL);
  v6[1] = 0x100000001;
  void *v6 = &unk_26CECA2D8;
  void v6[2] = a2;
  *(void *)a1 = &unk_26CECA248;
  *(void *)(a1 + 16) = v6;
  *(void *)(a1 + 24) = &unk_26CECA270;
  std::ios_base::init(v4, a2);
  *(void *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 168) = -1;
  *(void *)a1 = &unk_26CECA1D8;
  *(void *)(a1 + 24) = &unk_26CECA200;
  return a1;
}

void sub_21DEDB7B8(_Unwind_Exception *a1)
{
  boost::base_from_member<boost::shared_ptr<boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>>,0>::~base_from_member(v2);
  MEMORY[0x223C1DDF0](v1);
  _Unwind_Resume(a1);
}

void sub_21DEDB7D4(void *a1)
{
}

void sub_21DEDB7E0(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  MEMORY[0x223C1DDF0](v1);
  _Unwind_Resume(a1);
}

void boost::io::detail::stream_format_state<char,std::char_traits<char>>::apply_on(uint64_t a1, std::ios_base *this, const std::locale *a3)
{
  if (*(unsigned char *)(a1 + 32))
  {
    unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
    std::ios_base::getloc(this);
    std::ios_base::imbue(this, (const std::locale *)(a1 + 40));
    std::locale::~locale(&v18);
    rdbuf = (std::locale *)this->__rdbuf_;
    if (rdbuf)
    {
      (*((void (**)(void *, uint64_t))rdbuf->__locale_ + 2))(this->__rdbuf_, a1 + 40);
      v17.__locale_ = (std::locale::__imp *)0xAAAAAAAAAAAAAAAALL;
      uint64_t v6 = rdbuf + 1;
      std::locale::locale(&v17, v6);
      std::locale::operator=(v6, (const std::locale *)(a1 + 40));
      std::locale::~locale(&v17);
    }
    uint64_t v7 = &v16;
  }
  else
  {
    if (!a3) {
      goto LABEL_10;
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
    std::ios_base::getloc(this);
    std::ios_base::imbue(this, a3);
    std::locale::~locale(&v18);
    unint64_t v9 = (std::locale *)this->__rdbuf_;
    if (v9)
    {
      (*((void (**)(void *, const std::locale *))v9->__locale_ + 2))(this->__rdbuf_, a3);
      v17.__locale_ = (std::locale::__imp *)0xAAAAAAAAAAAAAAAALL;
      long long v10 = v9 + 1;
      std::locale::locale(&v17, v10);
      std::locale::operator=(v10, a3);
      std::locale::~locale(&v17);
    }
    uint64_t v7 = &v15;
  }
  std::locale::~locale((std::locale *)v7);
LABEL_10:
  if (*(void *)a1 != -1) {
    this->__width_ = *(void *)a1;
  }
  std::streamsize v11 = *(void *)(a1 + 8);
  if (v11 != -1) {
    this->__precision_ = v11;
  }
  std::ios_base::fmtflags v12 = *(char *)(a1 + 16);
  if (*(unsigned char *)(a1 + 16))
  {
    if (this[1].__fmtflags_ == -1)
    {
      std::ios_base::getloc(this);
      uint64_t v13 = std::locale::use_facet(&v18, MEMORY[0x263F8C108]);
      std::ios_base::fmtflags v14 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 32);
      std::locale::~locale(&v18);
      this[1].__fmtflags_ = v14;
    }
    this[1].__fmtflags_ = v12;
  }
  this->__fmtflags_ = *(_DWORD *)(a1 + 20);
  std::ios_base::clear(this, *(_DWORD *)(a1 + 24));
  this->__exceptions_ = *(_DWORD *)(a1 + 28);
  std::ios_base::clear(this, this->__rdstate_);
}

void sub_21DEDBA20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

void sub_21DEDBA34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::locale a12)
{
}

void sub_21DEDBA48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void boost::io::detail::mk_str<char,std::char_traits<char>,std::allocator<char>>(std::string *this, const std::string::value_type *a2, std::string::size_type a3, int64_t __requested_capacity, std::string::value_type a5, char a6, int a7, int a8)
{
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    unint64_t v15 = (unsigned char *)this->__r_.__value_.__r.__words[0];
    this->__r_.__value_.__l.__size_ = 0;
    *unint64_t v15 = 0;
    if (__requested_capacity < 1)
    {
LABEL_12:
      if (a7) {
        std::string::size_type v19 = a3 + 1;
      }
      else {
        std::string::size_type v19 = a3;
      }
      std::string::reserve(this, v19);
      if (a7) {
        std::string::append(this, 1uLL, a7);
      }
      if (a3)
      {
        std::string::append(this, a2, a3);
      }
      return;
    }
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = 0;
    this->__r_.__value_.__s.__data_[0] = 0;
    if (__requested_capacity < 1) {
      goto LABEL_12;
    }
  }
  if (__requested_capacity <= a3) {
    goto LABEL_12;
  }
  int64_t v16 = __requested_capacity - a3 - (a7 != 0);
  std::string::reserve(this, __requested_capacity);
  if (a8)
  {
    if (v16 >= 0) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = v16 + 1;
    }
    std::string::size_type v18 = v17 >> 1;
    v16 -= v17 >> 1;
    if (!v16) {
      goto LABEL_24;
    }
LABEL_23:
    std::string::append(this, v16, a5);
    goto LABEL_24;
  }
  if ((a6 & 0x20) != 0)
  {
    std::string::size_type v18 = v16;
    if (!a7) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  std::string::size_type v18 = 0;
  if (v16) {
    goto LABEL_23;
  }
LABEL_24:
  if (a7) {
LABEL_25:
  }
    std::string::append(this, 1uLL, a7);
LABEL_26:
  if (a3) {
    std::string::append(this, a2, a3);
  }
  if (v18)
  {
    std::string::append(this, v18, a5);
  }
}

uint64_t boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_oaltstringstream(uint64_t a1)
{
  uint64_t v2 = *(atomic_uint **)(std::ostream::~ostream() + 16);
  if (v2)
  {
    if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
      if (atomic_fetch_add(v2 + 3, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v2 + 24))(v2);
      }
    }
  }
  MEMORY[0x223C1DDF0](a1 + 24);
  return a1;
}

uint64_t boost::base_from_member<boost::shared_ptr<boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>>>,0>::~base_from_member(uint64_t a1)
{
  uint64_t v2 = *(atomic_uint **)(a1 + 8);
  if (v2)
  {
    if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
      if (atomic_fetch_add(v2 + 3, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v2 + 24))(v2);
      }
    }
  }
  return a1;
}

void boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_oaltstringstream(char *a1)
{
  uint64_t v2 = *(atomic_uint **)(std::ostream::~ostream() + 16);
  if (v2)
  {
    if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
      if (atomic_fetch_add(v2 + 3, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v2 + 24))(v2);
      }
    }
  }
  MEMORY[0x223C1DDF0](a1 + 24);

  operator delete(a1);
}

void virtual thunk to'boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_oaltstringstream(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24);
  std::ostream::~ostream();
  uint64_t v2 = (atomic_uint *)*((void *)v1 + 2);
  if (v2)
  {
    if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
      if (atomic_fetch_add(v2 + 3, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v2 + 24))(v2);
      }
    }
  }

  JUMPOUT(0x223C1DDF0);
}

{
  void *v1;
  atomic_uint *v2;
  uint64_t vars8;

  uint64_t v1 = (void *)((char *)a1 + *(void *)(*a1 - 24));
  std::ostream::~ostream();
  uint64_t v2 = (atomic_uint *)v1[2];
  if (v2)
  {
    if (atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1)
    {
      (*(void (**)(atomic_uint *))(*(void *)v2 + 16))(v2);
      if (atomic_fetch_add(v2 + 3, 0xFFFFFFFF) == 1) {
        (*(void (**)(atomic_uint *))(*(void *)v2 + 24))(v2);
      }
    }
  }
  MEMORY[0x223C1DDF0](v1 + 3);

  operator delete(v1);
}

uint64_t boost::detail::sp_counted_base::destroy(uint64_t this)
{
  if (this) {
    return (*(uint64_t (**)(void))(*(void *)this + 8))();
  }
  return this;
}

uint64_t boost::detail::sp_counted_impl_pd<boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>> *,boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::No_Op>::get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFAB52CLL) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFAB52CLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFAB52CLL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFAB52CLL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

uint64_t boost::detail::sp_counted_impl_pd<boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>> *,boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::No_Op>::get_local_deleter()
{
  return 0;
}

uint64_t boost::detail::sp_counted_impl_pd<boost::io::basic_altstringbuf<char,std::char_traits<char>,std::allocator<char>> *,boost::io::basic_oaltstringstream<char,std::char_traits<char>,std::allocator<char>>::No_Op>::get_untyped_deleter(uint64_t a1)
{
  return a1 + 24;
}

uint64_t boost::io::detail::call_put_last<char,std::char_traits<char>,int const>()
{
  return std::ostream::operator<<();
}

void *boost::io::detail::call_put_last<char,std::char_traits<char>,std::string const>(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    uint64_t v3 = v2;
  }
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, a2, v3);
}

void boost::basic_format<char,std::char_traits<char>,std::allocator<char>>::str(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = v4 - *a1;
  if (v4 == *a1)
  {
    if (*((char *)a1 + 87) < 0)
    {
      unsigned __int8 v27 = (const std::string::value_type *)a1[8];
      std::string::size_type v28 = a1[9];
      std::string::__init_copy_ctor_external((std::string *)a2, v27, v28);
    }
    else
    {
      *(_OWORD *)a2 = *((_OWORD *)a1 + 4);
      *(void *)(a2 + 16) = a1[10];
    }
    return;
  }
  uint64_t v7 = *((int *)a1 + 13);
  uint64_t v8 = *((int *)a1 + 14);
  if ((int)v7 < (int)v8 && (a1[11] & 2) != 0)
  {
    v29[0] = &unk_26CECA420;
    v29[1] = v7;
    v29[2] = v8;
    boost::throw_exception<boost::io::too_few_args>((uint64_t)v29);
  }
  unint64_t v9 = 0xEEEEEEEEEEEEEEEFLL * (v6 >> 3);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  if (*((char *)a1 + 87) < 0) {
    std::string::size_type v10 = a1[9];
  }
  else {
    std::string::size_type v10 = *((unsigned __int8 *)a1 + 87);
  }
  if (v9 <= 1) {
    unint64_t v9 = 1;
  }
  std::streamsize v11 = (std::string::size_type *)(v5 + 56);
  do
  {
    while (1)
    {
      if (*((char *)v11 - 25) < 0)
      {
        std::string::size_type v12 = *(v11 - 5) + v10;
        if (*((_DWORD *)v11 - 14) != -2) {
          goto LABEL_12;
        }
      }
      else
      {
        std::string::size_type v12 = *((unsigned __int8 *)v11 - 25) + v10;
        if (*((_DWORD *)v11 - 14) != -2) {
          goto LABEL_12;
        }
      }
      if (v12 <= *v11) {
        std::string::size_type v12 = *v11;
      }
LABEL_12:
      if (*((char *)v11 - 1) < 0) {
        break;
      }
      std::string::size_type v10 = *((unsigned __int8 *)v11 - 1) + v12;
      v11 += 15;
      if (!--v9) {
        goto LABEL_23;
      }
    }
    std::string::size_type v10 = *(v11 - 2) + v12;
    v11 += 15;
    --v9;
  }
  while (v9);
LABEL_23:
  std::string::reserve((std::string *)a2, v10);
  int v13 = *((char *)a1 + 87);
  if (v13 >= 0) {
    std::ios_base::fmtflags v14 = (const std::string::value_type *)(a1 + 8);
  }
  else {
    std::ios_base::fmtflags v14 = (const std::string::value_type *)a1[8];
  }
  if (v13 >= 0) {
    std::string::size_type v15 = *((unsigned __int8 *)a1 + 87);
  }
  else {
    std::string::size_type v15 = a1[9];
  }
  std::string::append((std::string *)a2, v14, v15);
  uint64_t v16 = *a1;
  if (a1[1] != *a1)
  {
    unint64_t v17 = 0;
    uint64_t v18 = 40;
    while (1)
    {
      int v19 = *(char *)(v16 + v18 - 9);
      if (v19 >= 0) {
        uint64_t v20 = (const std::string::value_type *)(v16 + v18 - 32);
      }
      else {
        uint64_t v20 = *(const std::string::value_type **)(v16 + v18 - 32);
      }
      if (v19 >= 0) {
        std::string::size_type v21 = *(unsigned __int8 *)(v16 + v18 - 9);
      }
      else {
        std::string::size_type v21 = *(void *)(v16 + v18 - 24);
      }
      std::string::append((std::string *)a2, v20, v21);
      if (*(_DWORD *)(v16 + v18 - 40) != -2) {
        goto LABEL_43;
      }
      unint64_t v22 = *(void *)(v16 + v18 + 16);
      if ((*(char *)(a2 + 23) & 0x80000000) == 0) {
        break;
      }
      unint64_t v23 = *(void *)(a2 + 8);
      if (v22 > v23) {
        goto LABEL_42;
      }
LABEL_43:
      int v24 = *(char *)(v16 + v18 + 15);
      if (v24 >= 0) {
        int v25 = (const std::string::value_type *)(v16 + v18 - 8);
      }
      else {
        int v25 = *(const std::string::value_type **)(v16 + v18 - 8);
      }
      if (v24 >= 0) {
        std::string::size_type v26 = *(unsigned __int8 *)(v16 + v18 + 15);
      }
      else {
        std::string::size_type v26 = *(void *)(v16 + v18);
      }
      std::string::append((std::string *)a2, v25, v26);
      ++v17;
      uint64_t v16 = *a1;
      v18 += 120;
      if (v17 >= 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3)) {
        goto LABEL_50;
      }
    }
    unint64_t v23 = *(unsigned __int8 *)(a2 + 23);
    if (v22 <= v23) {
      goto LABEL_43;
    }
LABEL_42:
    std::string::append((std::string *)a2, v22 - v23, *(unsigned char *)(v16 + v18 + 32));
    goto LABEL_43;
  }
LABEL_50:
  *((unsigned char *)a1 + 60) = 1;
}

void sub_21DEDC3A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception a10)
{
}

void sub_21DEDC3B8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void boost::throw_exception<boost::io::too_few_args>(uint64_t a1)
{
  exception = (__n128 *)__cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::io::too_few_args>::wrapexcept(exception, a1);
}

void sub_21DEDC420(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 boost::wrapexcept<boost::io::too_few_args>::wrapexcept(__n128 *a1, uint64_t a2)
{
  a1->n128_u64[0] = (unint64_t)&unk_26CEC9A70;
  a1->n128_u64[1] = (unint64_t)&unk_26CECA420;
  __n128 result = *(__n128 *)(a2 + 8);
  a1[1] = result;
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u32[0] = -1;
  a1->n128_u64[0] = (unint64_t)&unk_26CECA3A8;
  a1->n128_u64[1] = (unint64_t)&unk_26CECA3D8;
  a1[2].n128_u64[0] = (unint64_t)&unk_26CECA400;
  a1[2].n128_u64[1] = 0;
  return result;
}

std::exception *boost::wrapexcept<boost::io::too_few_args>::~wrapexcept(std::exception *a1)
{
  a1[4].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[5].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[5].__vftable = 0;
  }
  std::exception::~exception(a1 + 1);
  return a1;
}

void *boost::wrapexcept<boost::io::too_few_args>::clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x48uLL);
  *uint64_t v2 = &unk_26CEC9A70;
  v2[1] = &unk_26CECA420;
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 40);
  v2[4] = &unk_26CEC9AC8;
  v2[5] = v3;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
  }
  *((_OWORD *)v2 + 3) = *(_OWORD *)(a1 + 48);
  *((_DWORD *)v2 + 16) = *(_DWORD *)(a1 + 64);
  *uint64_t v2 = &unk_26CECA3A8;
  v2[1] = &unk_26CECA3D8;
  v2[4] = &unk_26CECA400;
  boost::exception_detail::copy_boost_exception((uint64_t)(v2 + 4), a1 + 32);
  return v2;
}

void sub_21DEDC6A0(_Unwind_Exception *a1)
{
  std::exception::~exception(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_21DEDC6BC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::io::too_few_args>::rethrow(uint64_t a1)
{
  exception = __cxa_allocate_exception(0x48uLL);
  boost::wrapexcept<boost::io::too_few_args>::wrapexcept((uint64_t)exception, a1);
}

void sub_21DEDC738(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void boost::wrapexcept<boost::io::too_few_args>::~wrapexcept(std::exception *a1)
{
  a1[4].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[5].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[5].__vftable = 0;
  }
  std::exception::~exception(a1 + 1);

  operator delete(a1);
}

void non-virtual thunk to'boost::wrapexcept<boost::io::too_few_args>::~wrapexcept(std::exception *this)
{
  this[3].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = this[4].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    this[4].__vftable = 0;
  }

  std::exception::~exception(this);
}

{
  std::exception_vtbl *v2;
  uint64_t vars8;

  this[3].__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = this[4].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    this[4].__vftable = 0;
  }
  std::exception::~exception(this);

  operator delete(&this[-1]);
}

const char *boost::io::too_few_args::what(boost::io::too_few_args *this)
{
  return "boost::too_few_args: format-string referred to more arguments than were passed";
}

void non-virtual thunk to'boost::wrapexcept<boost::io::too_few_args>::~wrapexcept(std::exception *a1)
{
  a1->__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[1].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[1].__vftable = 0;
  }

  std::exception::~exception(a1 - 3);
}

{
  std::exception_vtbl *v2;
  uint64_t vars8;

  a1->__vftable = (std::exception_vtbl *)&unk_26CEC9AC8;
  uint64_t v2 = a1[1].__vftable;
  if (v2 && (*((unsigned int (**)(std::exception_vtbl *))v2->~exception + 4))(v2)) {
    a1[1].__vftable = 0;
  }
  std::exception::~exception(a1 - 3);

  operator delete(&a1[-4]);
}

void boost::io::too_few_args::~too_few_args(std::exception *this)
{
  std::exception::~exception(this);

  operator delete(v1);
}

uint64_t boost::wrapexcept<boost::io::too_few_args>::wrapexcept(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26CEC9A70;
  *(void *)(a1 + 8) = &unk_26CECA420;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = &unk_26CEC9AC8;
  *(void *)(a1 + 40) = v4;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
  }
  long long v5 = *(_OWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v5;
  *(void *)a1 = &unk_26CECA3A8;
  *(void *)(a1 + 8) = &unk_26CECA3D8;
  *(void *)(a1 + 32) = &unk_26CECA400;
  return a1;
}

void sub_21DEDCB78(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_var_init_292()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

uint64_t __cxx_global_var_init_293()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ICEARIContext>::~PthreadMutexGuardPolicy, &ctu::Singleton<ICEARIContext,ICEARIContext,ctu::PthreadMutexGuardPolicy<ICEARIContext>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

void BBUFileDataSource::~BBUFileDataSource(BBUFileDataSource *this)
{
  *(void *)this = &unk_26CECA448;
  uint64_t v2 = (FILE *)*((void *)this + 4);
  if (v2) {
    fclose(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

{
  FILE *v2;
  BBUFileDataSource *v3;
  uint64_t vars8;

  *(void *)this = &unk_26CECA448;
  uint64_t v2 = (FILE *)*((void *)this + 4);
  if (v2) {
    fclose(v2);
  }
  if (*((char *)this + 31) < 0)
  {
    operator delete(*((void **)this + 1));
    uint64_t v3 = this;
  }
  else
  {
    uint64_t v3 = this;
  }
  operator delete(v3);
}

uint64_t BBUFileDataSource::init(uint64_t a1, const char *a2, int a3)
{
  *(_DWORD *)(a1 + 44) = a3;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
      goto LABEL_8;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
      goto LABEL_8;
    }
  }
  if (gBBULogVerbosity >= 7)
  {
    long long v5 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
    if (a2[23] >= 0) {
      LOBYTE(v9) = (_BYTE)a2;
    }
    else {
      unint64_t v9 = *(const char **)a2;
    }
    _BBULog(15, 7, v5, "", "Opening %s\n", v6, v7, v8, (char)v9);
  }
LABEL_8:
  if (a2[23] >= 0) {
    std::string::size_type v10 = a2;
  }
  else {
    std::string::size_type v10 = *(const char **)a2;
  }
  std::streamsize v11 = fopen(v10, "r");
  *(void *)(a1 + 32) = v11;
  if (!v11)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
    }
    if (gBBULogVerbosity < 0) {
      return result;
    }
    uint64_t v20 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
    if (a2[23] >= 0) {
      LOBYTE(v24) = (_BYTE)a2;
    }
    else {
      int v24 = *(const char **)a2;
    }
    _BBULog(15, 0, v20, "", "Failed to open file %s\n", v21, v22, v23, (char)v24);
    return 35;
  }
  if (fseek(v11, 0, 2))
  {
    int v12 = *__error();
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
      goto LABEL_15;
    }
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t result = 35;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) != 0)
    {
LABEL_15:
      if (gBBULogVerbosity < 0) {
        return result;
      }
      std::ios_base::fmtflags v14 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
      char v15 = strerror(v12);
      int v19 = "Failed to seek, err = %s (%u)\n";
      goto LABEL_17;
    }
    return result;
  }
  uint64_t v25 = MEMORY[0x223C1E280](*(void *)(a1 + 32));
  if ((v25 & 0x8000000000000000) == 0)
  {
    *(_DWORD *)(a1 + 40) = v25;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) != 0) {
        goto LABEL_30;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) != 0)
      {
LABEL_30:
        if (gBBULogVerbosity >= 7)
        {
          std::string::size_type v26 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
          _BBULog(15, 7, v26, "", "File size is %u\n", v27, v28, v29, *(_DWORD *)(a1 + 40));
        }
      }
    }
    if (!fseek(*(FILE **)(a1 + 32), 0, 0))
    {
      if ((const char *)(a1 + 8) != a2)
      {
        char v32 = a2[23];
        if (*(char *)(a1 + 31) < 0)
        {
          if (v32 >= 0) {
            int v34 = (char *)a2;
          }
          else {
            int v34 = *(char **)a2;
          }
          if (v32 >= 0) {
            size_t v35 = *((unsigned __int8 *)a2 + 23);
          }
          else {
            size_t v35 = *((void *)a2 + 1);
          }
          std::string::__assign_no_alias<false>((void **)(a1 + 8), v34, v35);
        }
        else
        {
          if ((a2[23] & 0x80) == 0)
          {
            uint64_t result = 0;
            long long v33 = *(_OWORD *)a2;
            *(void *)(a1 + 24) = *((void *)a2 + 2);
            *(_OWORD *)(a1 + 8) = v33;
            return result;
          }
          std::string::__assign_no_alias<true>((void *)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
        }
      }
      return 0;
    }
    int v30 = *__error();
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
    }
    if (gBBULogVerbosity < 0) {
      return result;
    }
    std::ios_base::fmtflags v14 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
    char v15 = strerror(v30);
    int v19 = "Failed to re-seek, err = %s (%u)\n";
LABEL_17:
    _BBULog(15, 0, v14, "", v19, v16, v17, v18, v15);
    return 35;
  }
  int v31 = *__error();
  if (gBBULogMaskGet(void)::once == -1)
  {
    uint64_t result = 35;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
      return result;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t result = 35;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
      return result;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    std::ios_base::fmtflags v14 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
    char v15 = strerror(v31);
    int v19 = "Failed to tell, err = %s (%u)\n";
    goto LABEL_17;
  }
  return result;
}

uint64_t BBUFileDataSource::copyData(FILE **this, unsigned __int8 *a2, int a3, unsigned int *a4, unsigned int a5)
{
  LODWORD(v7) = a3;
  if (((unsigned int (*)(FILE **))(*this)->_bf._base)(this) < a5)
  {
    uint64_t result = 0;
    *a4 = 0;
    return result;
  }
  unsigned int v11 = ((uint64_t (*)(FILE **))(*this)->_bf._base)(this) - a5;
  if (v11 >= v7) {
    size_t v7 = v7;
  }
  else {
    size_t v7 = v11;
  }
  if (fseek(this[4], a5, 0))
  {
    int v12 = *__error();
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      int v13 = (const char *)((uint64_t (*)(FILE **))(*this)->_close)(this);
      strerror(v12);
      _BBULog(15, 0, v13, "", "Failed to seek to %u, err = %s (%u)\n", v14, v15, v16, a5);
      return 35;
    }
  }
  else
  {
    unsigned int v17 = fread(a2, 1uLL, v7, this[4]);
    *a4 = v17;
    if (v7 <= v17) {
      return 0;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      uint64_t result = 35;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        return result;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      uint64_t v18 = (const char *)((uint64_t (*)(FILE **))(*this)->_close)(this);
      _BBULog(15, 0, v18, "", "Read only %u of %u bytes\n", v19, v20, v21, *a4);
      return 35;
    }
  }
  return result;
}

uint64_t BBUFileDataSource::getSize(BBUFileDataSource *this)
{
  return *((unsigned int *)this + 10);
}

uint64_t BBUFileDataSource::getBaseAddress(BBUFileDataSource *this)
{
  return *((unsigned int *)this + 11);
}

void *BBUFileDataSource::getNameAsString@<X0>(void *this@<X0>, void *a2@<X8>)
{
  int v3 = *((char *)this + 31);
  if (v3 >= 0) {
    size_t v4 = *((unsigned __int8 *)this + 31);
  }
  else {
    size_t v4 = this[2];
  }
  unint64_t v5 = v4 + 5;
  memset(a2, 170, 24);
  if (v4 + 5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v6 = (uint64_t)this;
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    std::string::size_type v10 = (char *)operator new(v8 + 1);
    a2[1] = v5;
    a2[2] = v9 | 0x8000000000000000;
    *a2 = v10;
    *(_DWORD *)std::string::size_type v10 = 1701603654;
    size_t v7 = v10 + 5;
    v10[4] = 32;
  }
  else
  {
    a2[1] = 0;
    a2[2] = 0;
    *a2 = 0;
    *((unsigned char *)a2 + 23) = v5;
    *((unsigned char *)a2 + 4) = 32;
    size_t v7 = (char *)a2 + 5;
    *(_DWORD *)a2 = 1701603654;
    if (!v4)
    {
      *size_t v7 = 0;
      return this;
    }
  }
  if (v3 >= 0) {
    unsigned int v11 = (const void *)(v6 + 8);
  }
  else {
    unsigned int v11 = *(const void **)(v6 + 8);
  }
  this = memmove(v7, v11, v4);
  v7[v4] = 0;
  return this;
}

const char *BBUFileDataSource::getDebugName(BBUFileDataSource *this)
{
  return "BBUFileDataSource";
}

BOOL BBUEUR20HashData::compare(BBUEUR20HashData *this, BBUFeedback *a2, const BBUHashData *lpsrc)
{
  if (lpsrc)
  {
    uint64_t v6 = v5;
    if (v5
      && (unint64_t v5 = (unsigned __int8 *)BBUHashData::compareHash(this, a2, (const unsigned __int8 *)this + 8, v5 + 8, "SBL1"),
          v5))
    {
      BOOL v9 = BBUHashData::compareHash(this, a2, (const unsigned __int8 *)this + 56, v6 + 56, "ACDB");
      BOOL v7 = v9;
      if (capabilities::updater::supportsBbcfgImage((capabilities::updater *)v9)) {
        goto LABEL_5;
      }
    }
    else
    {
      BOOL v7 = 0;
      if (capabilities::updater::supportsBbcfgImage((capabilities::updater *)v5))
      {
LABEL_5:
        if (!v7 || !BBUHashData::compareHash(this, a2, (const unsigned __int8 *)this + 104, v6 + 104, "BBCFG")) {
          return 0;
        }
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    BOOL v7 = 0;
    if (capabilities::updater::supportsBbcfgImage(this)) {
      goto LABEL_5;
    }
  }
  if (!v7) {
    return 0;
  }
LABEL_10:

  return BBUHashData::compareHash(this, a2, (const unsigned __int8 *)this + 152, v6 + 152, "OEMMisc");
}

void BBUEUR20HashData::showHashes(BBUEUR20HashData *this, BBUFeedback *a2)
{
  std::string __p = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  (*(void (**)(BBUEUR20HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  BBUFeedback::handleComment(a2, "\t %s:  %s", "SBL1_HASH", (const char *)&__p);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  (*(void (**)(BBUEUR20HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v9 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "ACDB_HASH", p_p);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  (*(void (**)(BBUEUR20HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v9 >= 0) {
    unint64_t v5 = (const char *)&__p;
  }
  else {
    unint64_t v5 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "BBCFG_HASH", v5);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  (*(void (**)(BBUEUR20HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v9 >= 0) {
    uint64_t v6 = (const char *)&__p;
  }
  else {
    uint64_t v6 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "OEMMisc_HASH", v6);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p);
  }
}

void sub_21DEDD990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void BasebandUpdater::BasebandUpdater(BasebandUpdater *this, const void *a2, const __CFDictionary *a3)
{
  *(void *)this = &unk_26CECA500;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  capabilities::radio::vendor(this);
  BasebandRestore::create(a3, (ACFULogging **)&v8);
  long long v5 = v8;
  long long v8 = 0uLL;
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 3);
  *((_OWORD *)this + 1) = v5;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  BOOL v7 = (std::__shared_weak_count *)*((void *)&v8 + 1);
  if (*((void *)&v8 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v8 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void sub_21DEDDADC(_Unwind_Exception *a1)
{
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_21DEDDAF0(_Unwind_Exception *a1)
{
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void BasebandUpdater::~BasebandUpdater(BasebandUpdater *this)
{
  *(void *)this = &unk_26CECA500;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 3);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    int v3 = (std::__shared_weak_count *)*((void *)this + 3);
    if (v3)
    {
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  BasebandUpdater *v4;
  uint64_t vars8;

  *(void *)this = &unk_26CECA500;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 3);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  if (!v2) {
    goto LABEL_6;
  }
  if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  int v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    size_t v4 = this;
  }
  else
  {
LABEL_6:
    size_t v4 = this;
  }
  operator delete(v4);
}

uint64_t BBUpdaterExtremePrivate::setOptions()
{
  return 0;
}

uint64_t BBUpdaterExtremePrivate::execCommand()
{
  return 0;
}

void BBUEUR20UpdateSource::~BBUEUR20UpdateSource(BBUEUR20UpdateSource *this)
{
  *(void *)this = &unk_26CECA558;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  BBUEUR10UpdateSource::~BBUEUR10UpdateSource(this);
}

{
  uint64_t v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26CECA558;
  uint64_t v2 = *((void *)this + 52);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  BBUEUR10UpdateSource::~BBUEUR10UpdateSource(this);

  operator delete(v3);
}

void BBUEUR20UpdateSource::init(BBUEUR20UpdateSource *this)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  uint64_t v2 = (*(uint64_t (**)(BBUEUR20UpdateSource *))(*(void *)this + 64))(this);
  if (v2)
  {
    if (!*((unsigned char *)this + 424))
    {
      uint64_t v3 = v2;
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
          goto LABEL_7;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
          goto LABEL_7;
        }
      }
      if ((gBBULogVerbosity & 0x80000000) == 0)
      {
        size_t v4 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
        _BBULog(3, 0, v4, "", "Detected it is unfused and there is fusing source. So, fetching sec.elf from fusing source.\n", v5, v6, v7, v86);
      }
LABEL_7:
      long long v95 = 0u;
      long long v96 = 0u;
      *(_OWORD *)long long v94 = 0u;
      BBUDataSource::generateHash(v3, (unsigned __int8 *)v94, 1);
      long long v8 = operator new(0x30uLL);
      long long v91 = v8;
      long long v93 = v8 + 3;
      long long v9 = v95;
      *long long v8 = *(_OWORD *)v94;
      v8[1] = v9;
      v8[2] = v96;
      long long v92 = v8 + 3;
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
          goto LABEL_15;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
          goto LABEL_15;
        }
      }
      if ((gBBULogVerbosity & 0x80000000) == 0)
      {
        std::string::size_type v10 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
        ctu::hex();
        if (v90 >= 0) {
          uint64_t v14 = __p;
        }
        else {
          LOBYTE(v14) = __p[0];
        }
        _BBULog(3, 0, v10, "", "Fusing Source SHA-384: %s\n", v11, v12, v13, (char)v14);
        if (v90 < 0) {
          operator delete(__p[0]);
        }
      }
LABEL_15:
      uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3);
      CFIndex v16 = v15;
      unsigned int v17 = (UInt8 *)operator new[](v15);
      int v88 = -1431655766;
      if ((*(unsigned int (**)(uint64_t, UInt8 *, uint64_t, int *, void))(*(void *)v3 + 16))(v3, v17, v15, &v88, 0))
      {
        exception = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)exception, 122, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x5Bu, (ctu::LogMessageBuffer *)"Failed to copy data from fusing source", v58, v59, v60, v86);
      }
      else
      {
        if (v88 == v15)
        {
          CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
          CFDataRef v19 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v17, v16);
          if (!v19)
          {
            char v64 = __cxa_allocate_exception(0x210uLL);
            _BBUException::_BBUException((uint64_t)v64, 121, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x5Fu, (ctu::LogMessageBuffer *)"Failed to create CFDataRef from the buffer", v65, v66, v67, v86);
          }
          CFPropertyListFormat format = kCFPropertyListXMLFormat_v1_0;
          CFDictionaryRef v20 = (const __CFDictionary *)CFPropertyListCreateWithData(v18, v19, 2uLL, &format, 0);
          CFDictionaryRef v21 = v20;
          if (!v20)
          {
            uint64_t v68 = __cxa_allocate_exception(0x210uLL);
            _BBUException::_BBUException((uint64_t)v68, 121, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x64u, (ctu::LogMessageBuffer *)"Failed to create fusing dictionary from plist", v69, v70, v71, v86);
          }
          CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v20, @"Instructions");
          CFArrayRef v23 = Value;
          if (Value)
          {
            CFTypeID v24 = CFGetTypeID(Value);
            if (v24 == CFArrayGetTypeID())
            {
              CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(v23, 0);
              std::string::size_type v26 = ValueAtIndex;
              if (ValueAtIndex)
              {
                CFTypeID v27 = CFGetTypeID(ValueAtIndex);
                if (v27 == CFDataGetTypeID())
                {
                  uint64_t v28 = operator new(0x18uLL);
                  v28[4] = 0;
                  *(void *)uint64_t v28 = &unk_26CECE780;
                  *((void *)v28 + 1) = v26;
                  CFRetain(v26);
                  long long v95 = 0u;
                  long long v96 = 0u;
                  *(_OWORD *)long long v94 = 0u;
                  BBUDataSource::generateHash((uint64_t)v28, (unsigned __int8 *)v94, 1);
                  uint64_t v29 = operator new(0x30uLL);
                  long long v30 = v95;
                  _OWORD *v29 = *(_OWORD *)v94;
                  v29[1] = v30;
                  v29[2] = v96;
                  if (v91)
                  {
                    long long v92 = v91;
                    operator delete(v91);
                  }
                  long long v91 = v29;
                  long long v92 = v29 + 3;
                  long long v93 = v29 + 3;
                  if (gBBULogMaskGet(void)::once == -1)
                  {
                    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0)
                    {
LABEL_27:
                      if ((gBBULogVerbosity & 0x80000000) == 0)
                      {
                        int v31 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
                        ctu::hex();
                        if (v90 >= 0) {
                          size_t v35 = __p;
                        }
                        else {
                          LOBYTE(v35) = __p[0];
                        }
                        _BBULog(3, 0, v31, "", "sec.elf SHA-384: %s\n", v32, v33, v34, (char)v35);
                        if (v90 < 0) {
                          operator delete(__p[0]);
                        }
                      }
                    }
                  }
                  else
                  {
                    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0) {
                      goto LABEL_27;
                    }
                  }
                  CFRelease(v21);
                  CFRelease(v19);
                  operator delete[](v17);
                  if (v91)
                  {
                    long long v92 = v91;
                    operator delete(v91);
                  }
                  goto LABEL_49;
                }
                long long v79 = __cxa_allocate_exception(0x210uLL);
                _BBUException::_BBUException((uint64_t)v79, 124, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x6Fu, (ctu::LogMessageBuffer *)"Failed to get sec.elf in CFDataRef type", v83, v84, v85, v86);
              }
              else
              {
                long long v79 = __cxa_allocate_exception(0x210uLL);
                _BBUException::_BBUException((uint64_t)v79, 124, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x6Eu, (ctu::LogMessageBuffer *)"Failed to get sec.elf in Instructions array", v80, v81, v82, v86);
              }
            }
            CFStringRef v72 = __cxa_allocate_exception(0x210uLL);
            _BBUException::_BBUException((uint64_t)v72, 123, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x68u, (ctu::LogMessageBuffer *)"Failed to get Instructions as CFArrayRef type", v76, v77, v78, v86);
          }
          else
          {
            CFStringRef v72 = __cxa_allocate_exception(0x210uLL);
            _BBUException::_BBUException((uint64_t)v72, 123, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x67u, (ctu::LogMessageBuffer *)"Failed to get Instructions in fusingprogram.plist", v73, v74, v75, v86);
          }
        }
        exception = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)exception, 122, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x5Cu, (ctu::LogMessageBuffer *)"Failed due to copied size (%d) and original length (%d) is different.", v61, v62, v63, v88);
      }
    }
  }
  else
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        goto LABEL_39;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        goto LABEL_39;
      }
    }
    if (gBBULogVerbosity >= 1)
    {
      unsigned __int8 v36 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
      _BBULog(3, 1, v36, "", "Fusing source is not found.\n", v37, v38, v39, v86);
    }
  }
LABEL_39:
  BYTE7(v95) = 7;
  strcpy((char *)v94, "sec.elf");
  int v40 = BBUEURUpdateSource::containsFile((uint64_t)this, (uint64_t)v94);
  int v41 = v40;
  if (SBYTE7(v95) < 0)
  {
    operator delete(v94[0]);
    if (!v41) {
      goto LABEL_54;
    }
  }
  else if (!v40)
  {
    goto LABEL_54;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_47;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_47;
    }
  }
  if (gBBULogVerbosity >= 1)
  {
    BOOL v42 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
    _BBULog(3, 1, v42, "", "Detected it is fused or fusing source is not found. Use the dummy sec.elf\n", v43, v44, v45, v86);
  }
LABEL_47:
  BYTE7(v95) = 7;
  strcpy((char *)v94, "sec.elf");
  DataSource = BBUEURUpdateSource::createDataSource((uint64_t)this, (uint64_t)v94, 0);
  uint64_t v28 = DataSource;
  if (SBYTE7(v95) < 0)
  {
    operator delete(v94[0]);
    if (v28) {
      goto LABEL_49;
    }
LABEL_54:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        return;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        return;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      int v53 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
      _BBULog(3, 0, v53, "", "File not present: %s\n", v54, v55, v56, (char)"sec.elf");
    }
    return;
  }
  if (!DataSource) {
    goto LABEL_54;
  }
LABEL_49:
  std::string::size_type v47 = operator new(0x20uLL);
  void *v47 = &unk_26CECA7E0;
  v47[1] = v28;
  v47[2] = 0;
  *((_DWORD *)v47 + 6) = 0;
  unint64_t v48 = (BBUELF32Header *)operator new(0x48uLL);
  BBUELF32Header::BBUELF32Header(v48, (BBUDataSource *)v28, 0);
  v47[2] = v48;
  void *v47 = &unk_26CECA688;
  *((void *)this + 52) = v47;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    std::string::size_type v49 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
    _BBULog(3, 0, v49, "", "Loaded SEC\n", v50, v51, v52, v86);
  }
}

void sub_21DEDE8B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a19)
  {
    operator delete(a19);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

char *BBUEUR20UpdateSource::copyHashData(BBUEUR20UpdateSource *this, int a2)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  if (a2)
  {
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __src[1] = v3;
    __src[2] = v3;
    __src[0] = v3;
    v37[1] = v3;
    v37[2] = v3;
    v36[2] = v3;
    v37[0] = v3;
    v36[0] = v3;
    v36[1] = v3;
    v35[1] = v3;
    v35[2] = v3;
    v35[0] = v3;
    uint64_t v4 = *((void *)this + 28);
    if (!v4)
    {
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 89, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x9Au, (ctu::LogMessageBuffer *)"Assertion failure(fSBLImage && \"Failed loading SBL image for creating hash.\")", v20, v21, v22, v35[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)v4 + 56))(v4, __src, 1);
    uint64_t v5 = *((void *)this + 40);
    if (!v5)
    {
      CFArrayRef v23 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v23, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x9Du, (ctu::LogMessageBuffer *)"Assertion failure(fAcdbImage && \"Failed loading ACDB image for creating hash.\")", v24, v25, v26, v35[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)v5 + 56))(v5, v37, 1);
    uint64_t v6 = *((void *)this + 47);
    if (!v6)
    {
      CFTypeID v27 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v27, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0xA0u, (ctu::LogMessageBuffer *)"Assertion failure(fOEMMiscImage && \"Failed loading OEMMisc image for creating hash.\")", v28, v29, v30, v35[0]);
    }
    uint64_t v7 = (capabilities::updater *)(*(uint64_t (**)(uint64_t, _OWORD *, uint64_t))(*(void *)v6 + 56))(v6, v35, 1);
    if (capabilities::updater::supportsBbcfgImage(v7))
    {
      uint64_t v8 = *((void *)this + 41);
      if (!v8)
      {
        int v31 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v31, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0xA5u, (ctu::LogMessageBuffer *)"Assertion failure(fBbcfgImage && \"Failed loading BBCFG image for creating hash.\")", v32, v33, v34, v35[0]);
      }
      (*(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)v8 + 56))(v8, v36, 1);
    }
    long long v9 = (char *)operator new(0xC8uLL);
    *(void *)long long v9 = &unk_26CECA4B0;
    size_t v10 = off_26CECA4D0((BBUEURHashData *)v9);
    memcpy(v9 + 8, __src, v10);
    size_t v11 = (*(uint64_t (**)(char *))(*(void *)v9 + 32))(v9);
    memcpy(v9 + 56, v37, v11);
    size_t v12 = (*(uint64_t (**)(char *))(*(void *)v9 + 32))(v9);
    memcpy(v9 + 104, v36, v12);
    size_t v13 = (*(uint64_t (**)(char *))(*(void *)v9 + 32))(v9);
    memcpy(v9 + 152, v35, v13);
  }
  else
  {
    long long v9 = (char *)operator new(0xC8uLL);
    *(void *)long long v9 = &unk_26CECA4B0;
    size_t v14 = off_26CECA4D0((BBUEURHashData *)v9);
    bzero(v9 + 8, v14);
    size_t v15 = (*(uint64_t (**)(char *))(*(void *)v9 + 32))(v9);
    bzero(v9 + 56, v15);
    size_t v16 = (*(uint64_t (**)(char *))(*(void *)v9 + 32))(v9);
    bzero(v9 + 104, v16);
    size_t v17 = (*(uint64_t (**)(char *))(*(void *)v9 + 32))(v9);
    bzero(v9 + 152, v17);
  }
  return v9;
}

void sub_21DEDEE04(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEDEE18(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEDEE2C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEDEE40(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEDEE54(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_21DEDEE68(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *BBUEUR20UpdateSource::getItems(BBUEUR20UpdateSource *this)
{
  uint64_t v2 = (uint64_t *)operator new(0x18uLL);
  *uint64_t v2 = (uint64_t)v2;
  v2[1] = (uint64_t)v2;
  v2[2] = 0;
  long long v3 = (uint64_t *)*((void *)this + 28);
  int SBLType = BBUEURUpdateSource::getSBLType(this);
  if (v3)
  {
    uint64_t v5 = BBUProgrammer::Item::createFromImage(SBLType, v3);
    uint64_t v6 = operator new(0x18uLL);
    v6[1] = v2;
    void v6[2] = v5;
    uint64_t v7 = *v2;
    void *v6 = *v2;
    *(void *)(v7 + 8) = v6;
    *uint64_t v2 = (uint64_t)v6;
    ++v2[2];
  }
  uint64_t v8 = (uint64_t *)*((void *)this + 42);
  int APDPType = BBUEURUpdateSource::getAPDPType(this);
  if (v8)
  {
    size_t v10 = BBUProgrammer::Item::createFromImage(APDPType, v8);
    size_t v11 = operator new(0x18uLL);
    v11[1] = v2;
    void v11[2] = v10;
    uint64_t v12 = *v2;
    *size_t v11 = *v2;
    *(void *)(v12 + 8) = v11;
    *uint64_t v2 = (uint64_t)v11;
    ++v2[2];
  }
  size_t v13 = (uint64_t *)*((void *)this + 43);
  int DEVCFGType = BBUEURUpdateSource::getDEVCFGType(this);
  if (v13)
  {
    size_t v15 = BBUProgrammer::Item::createFromImage(DEVCFGType, v13);
    size_t v16 = operator new(0x18uLL);
    v16[1] = v2;
    v16[2] = v15;
    uint64_t v17 = *v2;
    *size_t v16 = *v2;
    *(void *)(v17 + 8) = v16;
    *uint64_t v2 = (uint64_t)v16;
    ++v2[2];
  }
  CFAllocatorRef v18 = (uint64_t *)*((void *)this + 52);
  int SECType = BBUEURUpdateSource::getSECType(this);
  if (v18)
  {
    uint64_t v20 = BBUProgrammer::Item::createFromImage(SECType, v18);
    uint64_t v21 = operator new(0x18uLL);
    v21[1] = v2;
    v21[2] = v20;
    uint64_t v22 = *v2;
    void *v21 = *v2;
    *(void *)(v22 + 8) = v21;
    *uint64_t v2 = (uint64_t)v21;
    ++v2[2];
  }
  CFArrayRef v23 = (uint64_t *)*((void *)this + 44);
  int HYPType = BBUEURUpdateSource::getHYPType(this);
  if (v23)
  {
    uint64_t v25 = BBUProgrammer::Item::createFromImage(HYPType, v23);
    uint64_t v26 = operator new(0x18uLL);
    v26[1] = v2;
    v26[2] = v25;
    uint64_t v27 = *v2;
    *uint64_t v26 = *v2;
    *(void *)(v27 + 8) = v26;
    *uint64_t v2 = (uint64_t)v26;
    ++v2[2];
  }
  uint64_t v28 = (uint64_t *)*((void *)this + 45);
  int AOPType = BBUEURUpdateSource::getAOPType(this);
  if (v28)
  {
    uint64_t v30 = BBUProgrammer::Item::createFromImage(AOPType, v28);
    int v31 = operator new(0x18uLL);
    v31[1] = v2;
    v31[2] = v30;
    uint64_t v32 = *v2;
    *int v31 = *v2;
    *(void *)(v32 + 8) = v31;
    *uint64_t v2 = (uint64_t)v31;
    ++v2[2];
  }
  uint64_t v33 = (uint64_t *)*((void *)this + 30);
  int APPSType = BBUEURUpdateSource::getAPPSType(this);
  if (v33)
  {
    size_t v35 = BBUProgrammer::Item::createFromImage(APPSType, v33);
    unsigned __int8 v36 = operator new(0x18uLL);
    v36[1] = v2;
    v36[2] = v35;
    uint64_t v37 = *v2;
    *unsigned __int8 v36 = *v2;
    *(void *)(v37 + 8) = v36;
    *uint64_t v2 = (uint64_t)v36;
    ++v2[2];
  }
  uint64_t v38 = (uint64_t *)*((void *)this + 33);
  int QDSP6SWType = BBUEURUpdateSource::getQDSP6SWType(this);
  if (v38)
  {
    int v40 = BBUProgrammer::Item::createFromImage(QDSP6SWType, v38);
    int v41 = operator new(0x18uLL);
    v41[1] = v2;
    v41[2] = v40;
    uint64_t v42 = *v2;
    void *v41 = *v2;
    *(void *)(v42 + 8) = v41;
    *uint64_t v2 = (uint64_t)v41;
    ++v2[2];
  }
  uint64_t v43 = (uint64_t *)*((void *)this + 34);
  int TZType = BBUEURUpdateSource::getTZType(this);
  if (v43)
  {
    uint64_t v45 = BBUProgrammer::Item::createFromImage(TZType, v43);
    std::string::size_type v46 = operator new(0x18uLL);
    v46[1] = v2;
    v46[2] = v45;
    uint64_t v47 = *v2;
    *std::string::size_type v46 = *v2;
    *(void *)(v47 + 8) = v46;
    *uint64_t v2 = (uint64_t)v46;
    ++v2[2];
  }
  unint64_t v48 = (uint64_t *)**((void **)this + 36);
  int EFS1Type = BBUEURUpdateSource::getEFS1Type(this);
  if (v48)
  {
    uint64_t v50 = BBUProgrammer::Item::createFromImage(EFS1Type, v48);
    uint64_t v51 = operator new(0x18uLL);
    v51[1] = v2;
    v51[2] = v50;
    uint64_t v52 = *v2;
    *uint64_t v51 = *v2;
    *(void *)(v52 + 8) = v51;
    *uint64_t v2 = (uint64_t)v51;
    ++v2[2];
  }
  int v53 = *(uint64_t **)(*((void *)this + 36) + 8);
  int EFS2Type = BBUEURUpdateSource::getEFS2Type(this);
  if (v53)
  {
    uint64_t v55 = BBUProgrammer::Item::createFromImage(EFS2Type, v53);
    uint64_t v56 = operator new(0x18uLL);
    v56[1] = v2;
    v56[2] = v55;
    uint64_t v57 = *v2;
    *uint64_t v56 = *v2;
    *(void *)(v57 + 8) = v56;
    *uint64_t v2 = (uint64_t)v56;
    ++v2[2];
  }
  uint64_t v58 = *(uint64_t **)(*((void *)this + 36) + 16);
  int EFS3Type = BBUEURUpdateSource::getEFS3Type(this);
  if (v58)
  {
    uint64_t v60 = BBUProgrammer::Item::createFromImage(EFS3Type, v58);
    uint64_t v61 = operator new(0x18uLL);
    v61[1] = v2;
    v61[2] = v60;
    uint64_t v62 = *v2;
    *uint64_t v61 = *v2;
    *(void *)(v62 + 8) = v61;
    *uint64_t v2 = (uint64_t)v61;
    ++v2[2];
  }
  uint64_t v63 = (uint64_t *)*((void *)this + 40);
  int ACDBType = BBUEURUpdateSource::getACDBType(this);
  if (v63)
  {
    uint64_t v65 = BBUProgrammer::Item::createFromImage(ACDBType, v63);
    uint64_t v66 = operator new(0x18uLL);
    v66[1] = v2;
    v66[2] = v65;
    uint64_t v67 = *v2;
    *uint64_t v66 = *v2;
    *(void *)(v67 + 8) = v66;
    *uint64_t v2 = (uint64_t)v66;
    ++v2[2];
  }
  uint64_t v68 = (uint64_t *)*((void *)this + 5);
  int CalType = BBUEURUpdateSource::getCalType(this);
  if (v68)
  {
    uint64_t v70 = BBUProgrammer::Item::createFromImage(CalType, v68);
    uint64_t v71 = operator new(0x18uLL);
    v71[1] = v2;
    v71[2] = v70;
    uint64_t v72 = *v2;
    *uint64_t v71 = *v2;
    *(void *)(v72 + 8) = v71;
    *uint64_t v2 = (uint64_t)v71;
    ++v2[2];
  }
  uint64_t v73 = (uint64_t *)*((void *)this + 6);
  int ProvType = BBUEURUpdateSource::getProvType(this);
  if (v73)
  {
    uint64_t v75 = BBUProgrammer::Item::createFromImage(ProvType, v73);
    uint64_t v76 = operator new(0x18uLL);
    v76[1] = v2;
    v76[2] = v75;
    uint64_t v77 = *v2;
    void *v76 = *v2;
    *(void *)(v77 + 8) = v76;
    *uint64_t v2 = (uint64_t)v76;
    ++v2[2];
  }
  uint64_t v78 = (uint64_t *)*((void *)this + 7);
  int PacType = BBUEURUpdateSource::getPacType(this);
  if (v78)
  {
    uint64_t v80 = BBUProgrammer::Item::createFromImage(PacType, v78);
    uint64_t v81 = operator new(0x18uLL);
    v81[1] = v2;
    v81[2] = v80;
    uint64_t v82 = *v2;
    void *v81 = *v2;
    *(void *)(v82 + 8) = v81;
    *uint64_t v2 = (uint64_t)v81;
    ++v2[2];
  }
  uint64_t v83 = (uint64_t *)*((void *)this + 41);
  int BBCFGType = BBUEURUpdateSource::getBBCFGType(this);
  if (v83)
  {
    uint64_t v85 = BBUProgrammer::Item::createFromImage(BBCFGType, v83);
    char v86 = operator new(0x18uLL);
    v86[1] = v2;
    v86[2] = v85;
    uint64_t v87 = *v2;
    void *v86 = *v2;
    *(void *)(v87 + 8) = v86;
    *uint64_t v2 = (uint64_t)v86;
    ++v2[2];
  }
  int v88 = (uint64_t *)*((void *)this + 46);
  int MDMDDRType = BBUEURUpdateSource::getMDMDDRType(this);
  if (v88)
  {
    char v90 = BBUProgrammer::Item::createFromImage(MDMDDRType, v88);
    long long v91 = operator new(0x18uLL);
    v91[1] = v2;
    v91[2] = v90;
    uint64_t v92 = *v2;
    *long long v91 = *v2;
    *(void *)(v92 + 8) = v91;
    *uint64_t v2 = (uint64_t)v91;
    ++v2[2];
  }
  long long v93 = (uint64_t *)*((void *)this + 47);
  int OEMMiscType = BBUEURUpdateSource::getOEMMiscType(this);
  if (v93)
  {
    long long v95 = BBUProgrammer::Item::createFromImage(OEMMiscType, v93);
    long long v96 = operator new(0x18uLL);
    v96[1] = v2;
    v96[2] = v95;
    uint64_t v97 = *v2;
    *long long v96 = *v2;
    *(void *)(v97 + 8) = v96;
    *uint64_t v2 = (uint64_t)v96;
    ++v2[2];
  }
  uint64_t v98 = (uint64_t *)*((void *)this + 48);
  QTIMiscType = (capabilities::updater *)BBUEURUpdateSource::getQTIMiscType(this);
  if (v98)
  {
    unint64_t v100 = BBUProgrammer::Item::createFromImage((int)QTIMiscType, v98);
    QTIMiscType = (capabilities::updater *)operator new(0x18uLL);
    *((void *)QTIMiscType + 1) = v2;
    *((void *)QTIMiscType + 2) = v100;
    uint64_t v101 = *v2;
    *(void *)QTIMiscType = *v2;
    *(void *)(v101 + 8) = QTIMiscType;
    *uint64_t v2 = (uint64_t)QTIMiscType;
    ++v2[2];
  }
  XblCfgType = (capabilities::updater *)capabilities::updater::supportsXblCfgImage(QTIMiscType);
  if (XblCfgType)
  {
    long long v103 = (uint64_t *)*((void *)this + 49);
    XblCfgType = (capabilities::updater *)BBUEURUpdateSource::getXblCfgType(this);
    if (v103)
    {
      long long v104 = BBUProgrammer::Item::createFromImage((int)XblCfgType, v103);
      XblCfgType = (capabilities::updater *)operator new(0x18uLL);
      *((void *)XblCfgType + 1) = v2;
      *((void *)XblCfgType + 2) = v104;
      uint64_t v105 = *v2;
      *(void *)XblCfgType = *v2;
      *(void *)(v105 + 8) = XblCfgType;
      *uint64_t v2 = (uint64_t)XblCfgType;
      ++v2[2];
    }
  }
  UEFIType = (capabilities::updater *)capabilities::updater::supportsUEFIImage(XblCfgType);
  if (UEFIType)
  {
    long long v107 = (uint64_t *)*((void *)this + 50);
    UEFIType = (capabilities::updater *)BBUEURUpdateSource::getUEFIType(this);
    if (v107)
    {
      long long v108 = BBUProgrammer::Item::createFromImage((int)UEFIType, v107);
      UEFIType = (capabilities::updater *)operator new(0x18uLL);
      *((void *)UEFIType + 1) = v2;
      *((void *)UEFIType + 2) = v108;
      uint64_t v109 = *v2;
      *(void *)UEFIType = *v2;
      *(void *)(v109 + 8) = UEFIType;
      *uint64_t v2 = (uint64_t)UEFIType;
      ++v2[2];
    }
  }
  if (capabilities::updater::supportsXblSupportImage(UEFIType))
  {
    long long v110 = (uint64_t *)*((void *)this + 51);
    int XblSupportType = BBUEURUpdateSource::getXblSupportType(this);
    if (v110)
    {
      long long v112 = BBUProgrammer::Item::createFromImage(XblSupportType, v110);
      long long v113 = operator new(0x18uLL);
      v113[1] = v2;
      v113[2] = v112;
      uint64_t v114 = *v2;
      *long long v113 = *v2;
      *(void *)(v114 + 8) = v113;
      *uint64_t v2 = (uint64_t)v113;
      ++v2[2];
    }
  }
  return v2;
}

uint64_t BBUEUR20UpdateSource::validateBootupItems(BBUEUR20UpdateSource *this)
{
  uint64_t v2 = *((void *)this + 28);
  if (!v2) {
    return 35;
  }
  long long v3 = (capabilities::updater *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 64))(v2);
  if (!v3) {
    return 35;
  }
  if (*((void *)this + 42))
  {
    if (*((void *)this + 43))
    {
      if (*((void *)this + 52))
      {
        if (*((void *)this + 44))
        {
          if (*((void *)this + 45))
          {
            if (*((void *)this + 30))
            {
              if (*((void *)this + 33))
              {
                if (*((void *)this + 34))
                {
                  if (**((void **)this + 36))
                  {
                    if (*((void *)this + 40))
                    {
                      if (*((void *)this + 47))
                      {
                        if (*((void *)this + 48))
                        {
                          uint64_t v4 = (capabilities::updater *)capabilities::updater::supportsBbcfgImage(v3);
                          if (!v4 || *((void *)this + 41))
                          {
                            uint64_t v5 = (capabilities::updater *)capabilities::updater::supportsXblCfgImage(v4);
                            if (!v5 || *((void *)this + 49))
                            {
                              uint64_t v6 = (capabilities::updater *)capabilities::updater::supportsUEFIImage(v5);
                              if (!v6 || *((void *)this + 50))
                              {
                                uint64_t result = capabilities::updater::supportsXblSupportImage(v6);
                                if (!result) {
                                  return result;
                                }
                                if (*((void *)this + 51)) {
                                  return 0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    uint64_t result = 35;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return result;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t result = 35;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return result;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v8 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
    _BBULog(3, 0, v8, "", "Baseband FW isn't complete. You are missing some images!\n", v9, v10, v11, v12);
    return 35;
  }
  return result;
}

uint64_t BBUEUR20UpdateSource::validateCoredumpItems(BBUEUR20UpdateSource *this)
{
  uint64_t v2 = *((void *)this + 28);
  if (!v2) {
    return 35;
  }
  long long v3 = (capabilities::updater *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 64))(v2);
  if (!v3 || !*((void *)this + 42) || !*((void *)this + 47)) {
    return 35;
  }
  uint64_t result = capabilities::updater::supportsXblCfgImage(v3);
  if (!result) {
    return result;
  }
  if (!*((void *)this + 49)) {
    return 35;
  }
  return 0;
}

uint64_t BBUEUR20UpdateSource::saveImages(BBUEUR20UpdateSource *this)
{
  if (!*((void *)this + 8))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x118u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"Firmware data source error!\")", v22, v23, v24, __p[0]);
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  uint64_t v2 = (const char *)(**(uint64_t (***)(BBUEUR20UpdateSource *))this)(this);
  uint64_t v6 = (capabilities::radio *)_BBULog(19, 0xFFFFFFFFLL, v2, "", "BBUEUR20UpdateSource::saveImages\n", v3, v4, v5, __p[0]);
  memset(v31, 170, sizeof(v31));
  capabilities::radio::personalizedFirmwarePath((uint64_t *)v31, v6);
  uint64_t v7 = (void *)HIBYTE(v31[2]);
  if (SHIBYTE(v31[2]) < 0) {
    uint64_t v7 = v31[1];
  }
  if (!v7)
  {
    uint64_t v25 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v25, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR20UpdateSource.cpp", 0x11Du, (ctu::LogMessageBuffer *)"Assertion failure(folder.empty() != true && \"Failed finding the bbfw path.\")", v26, v27, v28, __p[0]);
  }
  uint64_t v8 = BBUEURUpdateSource::saveImages(this);
  if (!v8)
  {
    char v30 = 15;
    strcpy(__p, "restoresbl1.mbn");
    uint64_t v9 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
    uint64_t v8 = v9;
    if (v30 < 0)
    {
      operator delete(*(void **)__p);
      if (v8) {
        goto LABEL_74;
      }
    }
    else if (v9)
    {
      goto LABEL_74;
    }
    char v30 = 8;
    strcpy(__p, "sbl1.mbn");
    uint64_t v10 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
    uint64_t v8 = v10;
    if (v30 < 0)
    {
      operator delete(*(void **)__p);
      if (v8) {
        goto LABEL_74;
      }
    }
    else if (v10)
    {
      goto LABEL_74;
    }
    char v30 = 8;
    strcpy(__p, "acdb.mbn");
    uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
    if (v30 < 0) {
      operator delete(*(void **)__p);
    }
    if (!v8)
    {
      char v30 = 7;
      strcpy(__p, "aop.mbn");
      uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
      if (v30 < 0) {
        operator delete(*(void **)__p);
      }
      if (!v8)
      {
        char v30 = 8;
        strcpy(__p, "apdp.mbn");
        uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
        if (v30 < 0) {
          operator delete(*(void **)__p);
        }
        if (!v8)
        {
          char v30 = 8;
          strcpy(__p, "apps.mbn");
          uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
          if (v30 < 0) {
            operator delete(*(void **)__p);
          }
          if (!v8)
          {
            char v30 = 10;
            strcpy(__p, "devcfg.mbn");
            uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
            if (v30 < 0) {
              operator delete(*(void **)__p);
            }
            if (!v8)
            {
              char v30 = 7;
              strcpy(__p, "hyp.mbn");
              uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
              if (v30 < 0) {
                operator delete(*(void **)__p);
              }
              if (!v8)
              {
                char v30 = 11;
                strcpy(__p, "qdsp6sw.mbn");
                uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                if (v30 < 0) {
                  operator delete(*(void **)__p);
                }
                if (!v8)
                {
                  char v30 = 7;
                  strcpy(__p, "sec.elf");
                  uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                  if (v30 < 0) {
                    operator delete(*(void **)__p);
                  }
                  if (!v8)
                  {
                    char v30 = 6;
                    strcpy(__p, "tz.mbn");
                    uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                    if (v30 < 0) {
                      operator delete(*(void **)__p);
                    }
                    if (!v8)
                    {
                      char v30 = 15;
                      strcpy(__p, "multi_image.mbn");
                      uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                      if (v30 < 0) {
                        operator delete(*(void **)__p);
                      }
                      if (!v8)
                      {
                        char v30 = 19;
                        strcpy(__p, "multi_image_qti.mbn");
                        uint64_t v11 = (capabilities::updater *)BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                        uint64_t v8 = (uint64_t)v11;
                        if (v30 < 0) {
                          operator delete(*(void **)__p);
                        }
                        if (!v8)
                        {
                          if ((capabilities::updater::supportsBbcfgImage(v11) & 1) == 0)
                          {
                            uint64_t v12 = *((void *)this + 8);
                            char v30 = 9;
                            strcpy(__p, "bbcfg.mbn");
                            size_t v13 = (capabilities::updater *)BBUZipFile::containsFile(v12, __p);
                            if (!v13) {
                              goto LABEL_58;
                            }
                          }
                          char v30 = 9;
                          strcpy(__p, "bbcfg.mbn");
                          size_t v13 = (capabilities::updater *)BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                          uint64_t v8 = (uint64_t)v13;
                          if (v30 < 0) {
                            operator delete(*(void **)__p);
                          }
                          if (!v8)
                          {
LABEL_58:
                            if ((capabilities::updater::supportsXblCfgImage(v13) & 1) == 0)
                            {
                              uint64_t v14 = *((void *)this + 8);
                              char v30 = 11;
                              strcpy(__p, "xbl_cfg.elf");
                              size_t v15 = (capabilities::updater *)BBUZipFile::containsFile(v14, __p);
                              if (!v15) {
                                goto LABEL_63;
                              }
                            }
                            char v30 = 11;
                            strcpy(__p, "xbl_cfg.elf");
                            size_t v15 = (capabilities::updater *)BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                            uint64_t v8 = (uint64_t)v15;
                            if (v30 < 0) {
                              operator delete(*(void **)__p);
                            }
                            if (!v8)
                            {
LABEL_63:
                              if ((capabilities::updater::supportsUEFIImage(v15) & 1) == 0)
                              {
                                uint64_t v16 = *((void *)this + 8);
                                char v30 = 8;
                                strcpy(__p, "uefi.elf");
                                uint64_t v17 = (capabilities::updater *)BBUZipFile::containsFile(v16, __p);
                                if (!v17) {
                                  goto LABEL_68;
                                }
                              }
                              char v30 = 8;
                              strcpy(__p, "uefi.elf");
                              uint64_t v17 = (capabilities::updater *)BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                              uint64_t v8 = (uint64_t)v17;
                              if (v30 < 0) {
                                operator delete(*(void **)__p);
                              }
                              if (!v8)
                              {
LABEL_68:
                                if ((capabilities::updater::supportsXblSupportImage(v17) & 1) == 0)
                                {
                                  uint64_t v18 = *((void *)this + 8);
                                  char v30 = 15;
                                  strcpy(__p, "xbl_support.elf");
                                  if (!BBUZipFile::containsFile(v18, __p)) {
                                    goto LABEL_69;
                                  }
                                }
                                char v30 = 15;
                                strcpy(__p, "xbl_support.elf");
                                uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                                if (v30 < 0) {
                                  operator delete(*(void **)__p);
                                }
                                if (!v8)
                                {
LABEL_69:
                                  uint64_t v19 = *((void *)this + 8);
                                  (*(void (**)(char *__return_ptr, BBUEUR20UpdateSource *))(*(void *)this + 56))(__p, this);
                                  uint64_t v8 = BBUZipFile::containsFile(v19, __p);
                                  if (v30 < 0) {
                                    operator delete(*(void **)__p);
                                  }
                                  if (v8)
                                  {
                                    (*(void (**)(char *__return_ptr, BBUEUR20UpdateSource *))(*(void *)this + 56))(__p, this);
                                    uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v31);
                                    if (v30 < 0) {
                                      operator delete(*(void **)__p);
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_74:
  if (SHIBYTE(v31[2]) < 0) {
    operator delete(v31[0]);
  }
  return v8;
}

void sub_21DEDFF40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a20 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a20 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a15);
  _Unwind_Resume(exception_object);
}

const char *BBUEUR20UpdateSource::getDebugName(BBUEUR20UpdateSource *this)
{
  return "BBUEUR20UpdateSource";
}

uint64_t BBUUpdateSource::getFirmwareVersion(BBUUpdateSource *this)
{
  return *((void *)this + 3);
}

uint64_t BBUEURUpdateSource::getShouldProgram(BBUEURUpdateSource *this)
{
  return 1;
}

uint64_t BBUEURUpdateSource::getCanProvision(BBUEURUpdateSource *this)
{
  return *((unsigned __int8 *)this + 120);
}

uint64_t BBUEURUpdateSource::getZipFile@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 72);
  *a2 = *(void *)(this + 64);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

void BBUEURSecImage::~BBUEURSecImage(BBUEURSecImage *this)
{
  *(void *)this = &unk_26CECA7E0;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = (void *)v2[8];
    if (v3) {
      operator delete[](v3);
    }
    operator delete(v2);
  }
  uint64_t v4 = *((void *)this + 1);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
}

{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t vars8;

  *(void *)this = &unk_26CECA7E0;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = (void *)v2[8];
    if (v3) {
      operator delete[](v3);
    }
    operator delete(v2);
  }
  uint64_t v4 = *((void *)this + 1);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }

  operator delete(this);
}

const char *BBUEURSecImage::getName(BBUEURSecImage *this)
{
  return "SEC";
}

uint64_t BBUEURELFImage::getWritePayloadLength(BBUEURELFImage *this)
{
  uint64_t result = *((void *)this + 1);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  return result;
}

uint64_t BBUEURELFImage::getOpenPayloadData(BBUEURELFImage *this)
{
  return 0;
}

uint64_t BBUEURELFImage::getOpenPayloadLength(BBUEURELFImage *this)
{
  return 0;
}

void BBUEURELFImage::generateHash(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    if (v3) {
      BBUDataSource::generateHash(v3, a2, a3);
    }
  }
}

void BBUConsoleFeedback::~BBUConsoleFeedback(BBUConsoleFeedback *this)
{
  *(void *)this = &unk_26CECA6F0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::deque<std::string>::~deque[abi:ne180100]((uint64_t)this + 192);

  BBUFeedback::~BBUFeedback((CFTypeRef *)this);
}

{
  std::__shared_weak_count *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26CECA6F0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::deque<std::string>::~deque[abi:ne180100]((uint64_t)this + 192);
  BBUFeedback::~BBUFeedback((CFTypeRef *)this);

  operator delete(v3);
}

void BBUConsoleFeedback::addBracketedReturn(std::string *a1, int a2)
{
  *((unsigned char *)&v10.__r_.__value_.__s + 23) = 1;
  LOWORD(v10.__r_.__value_.__l.__data_) = 40;
  uint64_t v3 = BBUReturnAsString::BBUReturnStrings[a2];
  std::string::size_type v4 = strlen(v3);
  uint64_t v5 = std::string::append(&v10, v3, v4);
  long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  char v9 = 1;
  LOWORD(__p) = 41;
  uint64_t v7 = std::string::append(&v11, (const std::string::value_type *)&__p, 1uLL);
  *a1 = *v7;
  v7->__r_.__value_.__l.__size_ = 0;
  v7->__r_.__value_.__r.__words[2] = 0;
  v7->__r_.__value_.__r.__words[0] = 0;
  if (v9 < 0)
  {
    operator delete(__p);
    if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_3:
      if ((SHIBYTE(v10.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      operator delete(v10.__r_.__value_.__l.__data_);
      return;
    }
  }
  else if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v11.__r_.__value_.__l.__data_);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_7;
  }
}

void sub_21DEE0484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a26 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a20 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a26 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a21);
  if ((a20 & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(a15);
  _Unwind_Resume(exception_object);
}

uint64_t BBUConsoleFeedback::writeToStream(BBUConsoleFeedback *this, const char *a2, ...)
{
  va_start(va, a2);
  return (*(uint64_t (**)(BBUConsoleFeedback *, const char *, uint64_t *))(*(void *)this + 104))(this, a2, (uint64_t *)va);
}

uint64_t BBUConsoleFeedback::writeToStreamInternal(BBUConsoleFeedback *this, const char *a2, va_list a3)
{
  long long v6 = (FILE **)MEMORY[0x263EF8358];
  vfprintf((FILE *)*MEMORY[0x263EF8358], a2, a3);
  (*(void (**)(BBUConsoleFeedback *, const char *, va_list))(*(void *)this + 112))(this, a2, a3);
  uint64_t v7 = *v6;

  return fflush(v7);
}

void BBUConsoleFeedback::registerLogBuffer(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  std::string::size_type v4 = *(std::__shared_weak_count **)(a1 + 288);
  *(void *)(a1 + 280) = v3;
  *(void *)(a1 + 288) = v2;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t BBUConsoleFeedback::writeToBuffInternal(uint64_t this, const char *a2, va_list a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (*(void *)(this + 280))
  {
    uint64_t v5 = this;
    bzero(__str, 0x401uLL);
    this = vsnprintf(__str, 0x400uLL, a2, a3);
    if ((int)this >= 1)
    {
      if (this >= 0x400)
      {
        __str[1023] = 10;
        LODWORD(this) = 1024;
      }
      return (*(uint64_t (**)(void, char *, void))(**(void **)(v5 + 280) + 24))(*(void *)(v5 + 280), __str, this);
    }
  }
  return this;
}

void BBUConsoleFeedback::handleBeginPhaseInternal(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 240))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x4Eu, (ctu::LogMessageBuffer *)"Assertion failure(!fQuickStepInProgress)", v123, v124, v125, v129);
    goto LABEL_138;
  }
  if (*(unsigned char *)(a1 + 241))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x4Fu, (ctu::LogMessageBuffer *)"Assertion failure(!fLongStepInProgress)", v126, v127, v128, v129);
LABEL_138:
  }
  memset(__b, 170, sizeof(__b));
  size_t v3 = *(void *)(a1 + 232);
  if (v3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v3 >= 0x17)
  {
    uint64_t v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v6 = v3 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v5 = (void **)operator new(v6 + 1);
    __b[1] = (void *)v3;
    __b[2] = (void *)(v7 | 0x8000000000000000);
    __b[0] = v5;
    goto LABEL_10;
  }
  HIBYTE(__b[2]) = *(void *)(a1 + 232);
  uint64_t v5 = __b;
  if (v3) {
LABEL_10:
  }
    memset(v5, 9, v3);
  *((unsigned char *)v5 + v3) = 0;
  uint64_t v8 = *(char **)(a1 + 200);
  char v9 = *(char **)(a1 + 208);
  uint64_t v10 = (v9 - v8) >> 3;
  uint64_t v11 = v9 - v8;
  if (v9 == v8) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = 170 * v10 - 1;
  }
  unint64_t v13 = *(void *)(a1 + 224);
  if (v12 == *(void *)(a1 + 232) + v13)
  {
    BOOL v14 = v13 >= 0xAA;
    unint64_t v15 = v13 - 170;
    if (!v14)
    {
      uint64_t v26 = *(char **)(a1 + 216);
      uint64_t v27 = *(char **)(a1 + 192);
      if (v10 >= (unint64_t)((v26 - v27) >> 3))
      {
        if (v26 == v27) {
          unint64_t v30 = 1;
        }
        else {
          unint64_t v30 = (v26 - v27) >> 2;
        }
        if (!(v30 >> 61))
        {
          int v31 = (char *)operator new(8 * v30);
          uint64_t v32 = operator new(0xFF0uLL);
          uint64_t v33 = &v31[8 * v10];
          uint64_t v34 = &v31[8 * v30];
          if (v10 == v30)
          {
            size_t v35 = v32;
            if (v11 < 1)
            {
              if (v9 == v8) {
                unint64_t v45 = 1;
              }
              else {
                unint64_t v45 = v11 >> 2;
              }
              if (v45 >> 61) {
                std::__throw_bad_array_new_length[abi:ne180100]();
              }
              uint64_t v33 = (char *)operator new(8 * v45);
              uint64_t v34 = &v33[8 * v45];
              operator delete(v31);
              uint64_t v8 = *(char **)(a1 + 200);
              char v9 = *(char **)(a1 + 208);
              int v31 = v33;
            }
            else
            {
              unint64_t v36 = v10 + 2;
              if (v10 >= -1) {
                unint64_t v36 = v10 + 1;
              }
              v33 -= 8 * (v36 >> 1);
            }
            uint64_t v32 = v35;
          }
          *(void *)uint64_t v33 = v32;
          std::string::size_type v46 = v33 + 8;
          if (v9 != v8)
          {
            do
            {
              if (v33 == v31)
              {
                if (v46 >= v34)
                {
                  if (v34 == v31) {
                    unint64_t v53 = 1;
                  }
                  else {
                    unint64_t v53 = (v34 - v31) >> 2;
                  }
                  if (v53 >> 61) {
                    std::__throw_bad_array_new_length[abi:ne180100]();
                  }
                  uint64_t v54 = (char *)operator new(8 * v53);
                  uint64_t v55 = v54;
                  unint64_t v56 = (v53 + 3) >> 2;
                  uint64_t v33 = &v54[8 * v56];
                  int64_t v57 = v46 - v31;
                  BOOL v40 = v46 == v31;
                  std::string::size_type v46 = v33;
                  if (!v40)
                  {
                    std::string::size_type v46 = &v33[v57 & 0xFFFFFFFFFFFFFFF8];
                    unint64_t v58 = v57 - 8;
                    uint64_t v59 = &v54[8 * v56];
                    uint64_t v60 = v31;
                    if (v58 < 0x38) {
                      goto LABEL_145;
                    }
                    uint64_t v61 = 8 * v56;
                    uint64_t v59 = &v54[8 * v56];
                    uint64_t v60 = v31;
                    if ((unint64_t)(v59 - v31) < 0x20) {
                      goto LABEL_145;
                    }
                    uint64_t v62 = (v58 >> 3) + 1;
                    uint64_t v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
                    uint64_t v59 = &v33[v63];
                    uint64_t v60 = &v31[v63];
                    char v64 = (long long *)(v31 + 16);
                    uint64_t v65 = &v54[v61 + 16];
                    uint64_t v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v67 = *v64;
                      *((_OWORD *)v65 - 1) = *(v64 - 1);
                      *(_OWORD *)uint64_t v65 = v67;
                      v64 += 2;
                      v65 += 32;
                      v66 -= 4;
                    }
                    while (v66);
                    if (v62 != (v62 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_145:
                      do
                      {
                        uint64_t v68 = *(void *)v60;
                        v60 += 8;
                        *(void *)uint64_t v59 = v68;
                        v59 += 8;
                      }
                      while (v59 != v46);
                    }
                  }
                  uint64_t v34 = &v54[8 * v53];
                  operator delete(v31);
                  int v31 = v55;
                }
                else
                {
                  uint64_t v49 = (v34 - v46) >> 3;
                  if (v49 >= -1) {
                    uint64_t v50 = v49 + 1;
                  }
                  else {
                    uint64_t v50 = v49 + 2;
                  }
                  uint64_t v51 = v50 >> 1;
                  uint64_t v33 = &v31[8 * (v50 >> 1)];
                  uint64_t v52 = v31;
                  if (v46 != v31)
                  {
                    memmove(v33, v31, v46 - v31);
                    uint64_t v52 = v46;
                  }
                  std::string::size_type v46 = (char *)v52 + 8 * v51;
                }
              }
              uint64_t v48 = *((void *)v9 - 1);
              v9 -= 8;
              *((void *)v33 - 1) = v48;
              v33 -= 8;
            }
            while (v9 != *(char **)(a1 + 200));
          }
          uint64_t v47 = *(void **)(a1 + 192);
          *(void *)(a1 + 192) = v31;
          *(void *)(a1 + 200) = v33;
          char v9 = v46;
          *(void *)(a1 + 208) = v46;
          *(void *)(a1 + 216) = v34;
          if (v47)
          {
            operator delete(v47);
            char v9 = *(char **)(a1 + 208);
          }
          goto LABEL_108;
        }
      }
      else
      {
        uint64_t v28 = operator new(0xFF0uLL);
        uint64_t v29 = v28;
        if (v26 != v9)
        {
          *(void *)char v9 = v28;
LABEL_107:
          char v9 = (char *)(*(void *)(a1 + 208) + 8);
          *(void *)(a1 + 208) = v9;
LABEL_108:
          uint64_t v8 = *(char **)(a1 + 200);
          goto LABEL_109;
        }
        if (v8 == v27)
        {
          if (v9 == v8) {
            unint64_t v69 = 1;
          }
          else {
            unint64_t v69 = (v26 - v8) >> 2;
          }
          if (v69 >> 61) {
            goto LABEL_141;
          }
          uint64_t v70 = (char *)operator new(8 * v69);
          unint64_t v71 = (v69 + 3) >> 2;
          uint64_t v44 = &v70[8 * v71];
          uint64_t v72 = v44;
          if (v9 != v8)
          {
            uint64_t v72 = &v44[8 * v10];
            uint64_t v73 = &v70[8 * v71];
            uint64_t v74 = v8;
            if ((unint64_t)(v11 - 8) < 0x38) {
              goto LABEL_146;
            }
            uint64_t v75 = &v70[8 * v71];
            uint64_t v73 = v75;
            uint64_t v74 = v8;
            if ((unint64_t)(v75 - v8) < 0x20) {
              goto LABEL_146;
            }
            unint64_t v76 = ((unint64_t)(v11 - 8) >> 3) + 1;
            uint64_t v77 = 8 * (v76 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v73 = &v44[v77];
            uint64_t v74 = &v8[v77];
            uint64_t v78 = (long long *)(v8 + 16);
            long long v79 = v75 + 16;
            uint64_t v80 = v76 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v81 = *v78;
              *(v79 - 1) = *(v78 - 1);
              *long long v79 = v81;
              v78 += 2;
              v79 += 2;
              v80 -= 4;
            }
            while (v80);
            if (v76 != (v76 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_146:
              do
              {
                uint64_t v82 = *(void *)v74;
                v74 += 8;
                *(void *)uint64_t v73 = v82;
                v73 += 8;
              }
              while (v73 != v72);
            }
          }
          *(void *)(a1 + 192) = v70;
          *(void *)(a1 + 200) = v44;
          *(void *)(a1 + 208) = v72;
          *(void *)(a1 + 216) = &v70[8 * v69];
          if (v8)
          {
            operator delete(v8);
            uint64_t v44 = *(char **)(a1 + 200);
          }
        }
        else
        {
          uint64_t v44 = v8;
        }
        *((void *)v44 - 1) = v29;
        uint64_t v83 = *(char **)(a1 + 200);
        uint64_t v84 = *(char **)(a1 + 208);
        *(void *)(a1 + 200) = v83 - 8;
        uint64_t v85 = *((void *)v83 - 1);
        *(void *)(a1 + 200) = v83;
        if (v84 != *(char **)(a1 + 216))
        {
LABEL_91:
          *(void *)uint64_t v84 = v85;
          goto LABEL_107;
        }
        char v86 = *(char **)(a1 + 192);
        if (v83 > v86)
        {
          uint64_t v87 = (v83 - v86) >> 3;
          if (v87 >= -1) {
            uint64_t v88 = v87 + 1;
          }
          else {
            uint64_t v88 = v87 + 2;
          }
          uint64_t v89 = v88 >> 1;
          uint64_t v90 = -v89;
          long long v91 = &v83[-8 * v89];
          size_t v92 = v84 - v83;
          if (v92)
          {
            memmove(&v83[-8 * v89], v83, v92);
            uint64_t v83 = *(char **)(a1 + 200);
          }
          long long v93 = &v91[v92];
          *(void *)(a1 + 200) = &v83[8 * v90];
          *(void *)(a1 + 208) = v93;
          *(void *)long long v93 = v85;
          goto LABEL_107;
        }
        if (v84 == v86) {
          unint64_t v107 = 1;
        }
        else {
          unint64_t v107 = (v84 - v86) >> 2;
        }
        if (!(v107 >> 61))
        {
          long long v108 = (char *)operator new(8 * v107);
          uint64_t v109 = &v108[8 * (v107 >> 2)];
          int64_t v110 = v84 - v83;
          BOOL v40 = v84 == v83;
          uint64_t v84 = v109;
          if (v40) {
            goto LABEL_134;
          }
          uint64_t v84 = &v109[v110 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v111 = v110 - 8;
          if (v111 >= 0x38)
          {
            long long v113 = &v108[8 * (v107 >> 2)];
            long long v112 = v113;
            if ((unint64_t)(v113 - v83) >= 0x20)
            {
              uint64_t v114 = (v111 >> 3) + 1;
              uint64_t v115 = 8 * (v114 & 0x3FFFFFFFFFFFFFFCLL);
              long long v112 = &v109[v115];
              long long v116 = &v83[v115];
              long long v117 = (long long *)(v83 + 16);
              long long v118 = v113 + 16;
              uint64_t v119 = v114 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v120 = *v117;
                *(v118 - 1) = *(v117 - 1);
                *long long v118 = v120;
                v117 += 2;
                v118 += 2;
                v119 -= 4;
              }
              while (v119);
              uint64_t v83 = v116;
              if (v114 == (v114 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_134:
                *(void *)(a1 + 192) = v108;
                *(void *)(a1 + 200) = v109;
                *(void *)(a1 + 208) = v84;
                *(void *)(a1 + 216) = &v108[8 * v107];
                if (v86)
                {
                  operator delete(v86);
                  uint64_t v84 = *(char **)(a1 + 208);
                }
                goto LABEL_91;
              }
            }
          }
          else
          {
            long long v112 = &v108[8 * (v107 >> 2)];
          }
          do
          {
            uint64_t v121 = *(void *)v83;
            v83 += 8;
            *(void *)long long v112 = v121;
            v112 += 8;
          }
          while (v112 != v84);
          goto LABEL_134;
        }
      }
LABEL_141:
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    *(void *)(a1 + 224) = v15;
    uint64_t v16 = v8 + 8;
    uint64_t v17 = *(void *)v8;
    *(void *)(a1 + 200) = v8 + 8;
    if (v9 != *(char **)(a1 + 216))
    {
LABEL_106:
      *(void *)char v9 = v17;
      goto LABEL_107;
    }
    uint64_t v18 = *(char **)(a1 + 192);
    if (v16 > v18)
    {
      uint64_t v19 = (v16 - v18) >> 3;
      if (v19 >= -1) {
        uint64_t v20 = v19 + 1;
      }
      else {
        uint64_t v20 = v19 + 2;
      }
      uint64_t v21 = v20 >> 1;
      uint64_t v22 = -v21;
      uint64_t v23 = &v16[-8 * v21];
      int64_t v24 = v9 - v16;
      if (v9 != v16)
      {
        memmove(&v16[-8 * v21], v16, v9 - v16);
        char v9 = *(char **)(a1 + 200);
      }
      uint64_t v25 = &v9[8 * v22];
      char v9 = &v23[v24];
      *(void *)(a1 + 200) = v25;
      *(void *)(a1 + 208) = &v23[v24];
      goto LABEL_106;
    }
    if (v9 == v18) {
      unint64_t v37 = 1;
    }
    else {
      unint64_t v37 = (v9 - v18) >> 2;
    }
    if (v37 >> 61) {
      goto LABEL_141;
    }
    uint64_t v38 = (char *)operator new(8 * v37);
    uint64_t v39 = &v38[8 * (v37 >> 2)];
    int64_t v41 = v9 - v16;
    BOOL v40 = v9 == v16;
    char v9 = v39;
    if (!v40)
    {
      char v9 = &v39[v41 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v42 = v41 - 8;
      if (v42 < 0x38)
      {
        uint64_t v43 = &v38[8 * (v37 >> 2)];
        do
        {
LABEL_103:
          uint64_t v101 = *(void *)v16;
          v16 += 8;
          *(void *)uint64_t v43 = v101;
          v43 += 8;
        }
        while (v43 != v9);
        goto LABEL_104;
      }
      long long v94 = &v38[8 * (v37 >> 2)];
      uint64_t v43 = v94;
      if ((unint64_t)(v94 - v16) < 0x20) {
        goto LABEL_103;
      }
      uint64_t v95 = (v42 >> 3) + 1;
      uint64_t v96 = 8 * (v95 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v43 = &v39[v96];
      v16 += v96;
      uint64_t v97 = (long long *)(v8 + 24);
      uint64_t v98 = v94 + 16;
      uint64_t v99 = v95 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v100 = *v97;
        *(v98 - 1) = *(v97 - 1);
        _OWORD *v98 = v100;
        v97 += 2;
        v98 += 2;
        v99 -= 4;
      }
      while (v99);
      if (v95 != (v95 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_103;
      }
    }
LABEL_104:
    *(void *)(a1 + 192) = v38;
    *(void *)(a1 + 200) = v39;
    *(void *)(a1 + 208) = v9;
    *(void *)(a1 + 216) = &v38[8 * v37];
    if (v18)
    {
      operator delete(v18);
      char v9 = *(char **)(a1 + 208);
    }
    goto LABEL_106;
  }
LABEL_109:
  if (v9 == v8)
  {
    long long v103 = 0;
    if ((*(char *)(a2 + 23) & 0x80000000) == 0) {
      goto LABEL_111;
    }
  }
  else
  {
    unint64_t v102 = *(void *)(a1 + 232) + *(void *)(a1 + 224);
    long long v103 = (std::string *)(*(void *)&v8[8 * (v102 / 0xAA)] + 24 * (v102 % 0xAA));
    if ((*(char *)(a2 + 23) & 0x80000000) == 0)
    {
LABEL_111:
      long long v104 = *(_OWORD *)a2;
      v103->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
      *(_OWORD *)&v103->__r_.__value_.__l.__data_ = v104;
      goto LABEL_114;
    }
  }
  std::string::__init_copy_ctor_external(v103, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
LABEL_114:
  ++*(void *)(a1 + 232);
  BBUProfiler::startStage((void *)(a1 + 80), a2);
  uint64_t v105 = (const char *)__b;
  if (SHIBYTE(__b[2]) < 0) {
    uint64_t v105 = (const char *)__b[0];
  }
  if (*(char *)(a2 + 23) >= 0) {
    long long v106 = (const char *)a2;
  }
  else {
    long long v106 = *(const char **)a2;
  }
  BBUConsoleFeedback::writeToStream((BBUConsoleFeedback *)a1, "%sBEGIN: %s\n", v105, v106);
  if (SHIBYTE(__b[2]) < 0) {
    operator delete(__b[0]);
  }
}

void sub_21DEE0F6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  operator delete(v18);
  operator delete(v17);
  if (a17 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void BBUConsoleFeedback::handleEndPhase(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 240))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x5Au, (ctu::LogMessageBuffer *)"Assertion failure(!fQuickStepInProgress)", v25, v26, v27, v34);
    goto LABEL_40;
  }
  if (*(unsigned char *)(a1 + 241))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x5Bu, (ctu::LogMessageBuffer *)"Assertion failure(!fLongStepInProgress)", v28, v29, v30, v34);
    goto LABEL_40;
  }
  uint64_t v3 = *(void *)(a1 + 232);
  if (!v3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x5Du, (ctu::LogMessageBuffer *)"Assertion failure(fPhases.size())", v31, v32, v33, v34);
LABEL_40:
  }
  memset(&v38, 170, sizeof(v38));
  uint64_t v5 = *(void *)(a1 + 224);
  uint64_t v6 = v3 - 1;
  unint64_t v7 = v5 + v3 - 1;
  uint64_t v8 = *(void *)(a1 + 200);
  unint64_t v9 = v7 / 0xAA;
  uint64_t v10 = *(void *)(v8 + 8 * (v7 / 0xAA));
  unint64_t v11 = v7 % 0xAA;
  uint64_t v12 = (long long *)(v10 + 24 * v11);
  if ((*((char *)v12 + 23) & 0x80000000) == 0)
  {
    long long v13 = *v12;
    v38.__r_.__value_.__r.__words[2] = *((void *)v12 + 2);
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v13;
    uint64_t v14 = *(void *)(v8 + 8 * v9) + 24 * v11;
    if ((*(char *)(v14 + 23) & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  std::string::__init_copy_ctor_external(&v38, *(const std::string::value_type **)v12, *((void *)v12 + 1));
  uint64_t v5 = *(void *)(a1 + 224);
  uint64_t v3 = *(void *)(a1 + 232);
  uint64_t v8 = *(void *)(a1 + 200);
  uint64_t v6 = v3 - 1;
  uint64_t v14 = *(void *)(v8 + 8 * ((v3 - 1 + v5) / 0xAAuLL)) + 24 * ((v3 - 1 + v5) % 0xAAuLL);
  if (*(char *)(v14 + 23) < 0)
  {
LABEL_6:
    operator delete(*(void **)v14);
    uint64_t v8 = *(void *)(a1 + 200);
    uint64_t v5 = *(void *)(a1 + 224);
    uint64_t v3 = *(void *)(a1 + 232);
    uint64_t v6 = v3 - 1;
  }
LABEL_7:
  uint64_t v15 = *(void *)(a1 + 208);
  *(void *)(a1 + 232) = v6;
  if (v15 == v8) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = 170 * ((v15 - v8) >> 3) - 1;
  }
  if ((unint64_t)(v16 - (v5 + v3) + 1) >= 0x154)
  {
    operator delete(*(void **)(v15 - 8));
    *(void *)(a1 + 208) -= 8;
  }
  BBUProfiler::endStage((BBUProfiler *)(a1 + 80));
  memset(__b, 170, sizeof(__b));
  size_t v17 = *(void *)(a1 + 232);
  if (v17 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v17 >= 0x17)
  {
    uint64_t v20 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v17 | 7) != 0x17) {
      uint64_t v20 = v17 | 7;
    }
    uint64_t v21 = v20 + 1;
    uint64_t v18 = (void **)operator new(v20 + 1);
    __b[1] = (void *)v17;
    __b[2] = (void *)(v21 | 0x8000000000000000);
    __b[0] = v18;
  }
  else
  {
    HIBYTE(__b[2]) = *(void *)(a1 + 232);
    uint64_t v18 = __b;
    if (!v17)
    {
      LOBYTE(__b[0]) = 0;
      memset(&__p, 0, sizeof(__p));
      if (a2) {
        goto LABEL_16;
      }
LABEL_23:
      p_p = &__p;
      goto LABEL_24;
    }
  }
  memset(v18, 9, v17);
  *((unsigned char *)v18 + v17) = 0;
  memset(&__p, 0, sizeof(__p));
  if (!a2) {
    goto LABEL_23;
  }
LABEL_16:
  BBUConsoleFeedback::addBracketedReturn(&v35, a2);
  std::string __p = v35;
  p_p = &__p;
  if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    p_p = (std::string *)v35.__r_.__value_.__r.__words[0];
  }
LABEL_24:
  uint64_t v22 = (const char *)__b;
  if (SHIBYTE(__b[2]) < 0) {
    uint64_t v22 = (const char *)__b[0];
  }
  uint64_t v23 = &v38;
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v23 = (std::string *)v38.__r_.__value_.__r.__words[0];
  }
  BBUConsoleFeedback::writeToStream((BBUConsoleFeedback *)a1, "%sEND%s: %s\n", v22, (const char *)p_p, (const char *)v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__b[2]) & 0x80000000) == 0)
    {
LABEL_30:
      if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_36:
      operator delete(v38.__r_.__value_.__l.__data_);
      return;
    }
  }
  else if ((SHIBYTE(__b[2]) & 0x80000000) == 0)
  {
    goto LABEL_30;
  }
  operator delete(__b[0]);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_36;
  }
}

void sub_21DEE136C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE1380(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE1394(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE13A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0)
  {
    operator delete(__p);
    if ((*(char *)(v26 - 57) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v26 - 57) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v26 - 80));
  _Unwind_Resume(exception_object);
}

void BBUConsoleFeedback::handleBeginQuickStepInternal(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 240))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x70u, (ctu::LogMessageBuffer *)"Assertion failure(!fQuickStepInProgress)", v11, v12, v13, v17);
    goto LABEL_21;
  }
  if (*(unsigned char *)(a1 + 241))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x71u, (ctu::LogMessageBuffer *)"Assertion failure(!fLongStepInProgress)", v14, v15, v16, v17);
LABEL_21:
  }
  BBUProfiler::startStage((void *)(a1 + 80), a2);
  size_t v4 = *(void *)(a1 + 232);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v4 >= 0x17)
  {
    uint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v6 = v4 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v5 = (void **)operator new(v6 + 1);
    __b[1] = (void *)v4;
    int64_t v19 = v7 | 0x8000000000000000;
    __b[0] = v5;
    goto LABEL_10;
  }
  HIBYTE(v19) = *(void *)(a1 + 232);
  uint64_t v5 = __b;
  if (v4) {
LABEL_10:
  }
    memset(v5, 9, v4);
  *((unsigned char *)v5 + v4) = 0;
  uint64_t v8 = (const char *)__b;
  if (v19 < 0) {
    uint64_t v8 = (const char *)__b[0];
  }
  if (*(char *)(a2 + 23) >= 0) {
    unint64_t v9 = (const char *)a2;
  }
  else {
    unint64_t v9 = *(const char **)a2;
  }
  BBUConsoleFeedback::writeToStream((BBUConsoleFeedback *)a1, "%s%s...\n", v8, v9);
  if (SHIBYTE(v19) < 0) {
    operator delete(__b[0]);
  }
  *(unsigned char *)(a1 + 240) = 1;
}

void sub_21DEE15B8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE15CC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE15E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void BBUConsoleFeedback::handleEndQuickStep(BBUConsoleFeedback *this, int a2)
{
  if (!*((unsigned char *)this + 240))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x7Bu, (ctu::LogMessageBuffer *)"Assertion failure(fQuickStepInProgress)", v12, v13, v14, v18);
    goto LABEL_32;
  }
  if (*((unsigned char *)this + 241))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x7Cu, (ctu::LogMessageBuffer *)"Assertion failure(!fLongStepInProgress)", v15, v16, v17, v18);
LABEL_32:
  }
  memset(&v20, 0, sizeof(v20));
  if (a2 != 14 && a2)
  {
    *((unsigned char *)&v20.__r_.__value_.__s + 23) = 6;
    qmemcpy(&v20, "FAILED", 6);
    BBUConsoleFeedback::addBracketedReturn(&__p, a2);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::append(&v20, (const std::string::value_type *)p_p, size);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    *((unsigned char *)&v20.__r_.__value_.__s + 23) = 2;
    LOWORD(v20.__r_.__value_.__l.__data_) = 19279;
  }
  std::string::size_type v5 = *((void *)this + 29);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v5 >= 0x17)
  {
    uint64_t v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v7 = v5 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = (std::string *)operator new(v7 + 1);
    __p.__r_.__value_.__l.__size_ = v5;
    __p.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v6;
    goto LABEL_21;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = *((void *)this + 29);
  uint64_t v6 = &__p;
  if (v5) {
LABEL_21:
  }
    memset(v6, 9, v5);
  v6->__r_.__value_.__s.__data_[v5] = 0;
  unint64_t v9 = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    unint64_t v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  uint64_t v10 = &v20;
  if ((v20.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v10 = (std::string *)v20.__r_.__value_.__r.__words[0];
  }
  BBUConsoleFeedback::writeToStream(this, "%s%s\n", (const char *)v9, (const char *)v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  BBUProfiler::endStage((BBUConsoleFeedback *)((char *)this + 80));
  *((unsigned char *)this + 240) = 0;
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
}

void sub_21DEE1824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((a22 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a22 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a17);
  _Unwind_Resume(exception_object);
}

uint64_t BBUConsoleFeedback::handleBeginLongStep(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (*(unsigned char *)(a1 + 240))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x93u, (ctu::LogMessageBuffer *)"Assertion failure(!fQuickStepInProgress)", v17, v18, v19, v23);
    goto LABEL_24;
  }
  if (*(unsigned char *)(a1 + 241))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0x94u, (ctu::LogMessageBuffer *)"Assertion failure(!fLongStepInProgress)", v20, v21, v22, v23);
LABEL_24:
  }
  if (*(_DWORD *)(a1 + 184)) {
    uint64_t v8 = 10;
  }
  else {
    uint64_t v8 = 32;
  }
  BBUProfiler::startStage((void *)(a1 + 80), a2);
  size_t v9 = *(void *)(a1 + 232);
  if (v9 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v9 >= 0x17)
  {
    uint64_t v11 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v11 = v9 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __b[1] = (void *)v9;
    int64_t v25 = v12 | 0x8000000000000000;
    __b[0] = v10;
    goto LABEL_13;
  }
  HIBYTE(v25) = *(void *)(a1 + 232);
  uint64_t v10 = __b;
  if (v9) {
LABEL_13:
  }
    memset(v10, 9, v9);
  *((unsigned char *)v10 + v9) = 0;
  uint64_t v13 = (const char *)__b;
  if (v25 < 0) {
    uint64_t v13 = (const char *)__b[0];
  }
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v14 = (const char *)a2;
  }
  else {
    uint64_t v14 = *(const char **)a2;
  }
  BBUConsoleFeedback::writeToStream((BBUConsoleFeedback *)a1, "%s%s...%c", v13, v14, v8);
  if (SHIBYTE(v25) < 0) {
    operator delete(__b[0]);
  }
  *(unsigned char *)(a1 + 241) = 1;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 248) = a3;
  *(void *)(a1 + 256) = a4;
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
}

void sub_21DEE1AA8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE1ABC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE1AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void BBUConsoleFeedback::handleLongStepProgress(BBUConsoleFeedback *this, unint64_t a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  if (*((unsigned char *)this + 240))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0xB2u, (ctu::LogMessageBuffer *)"Assertion failure(!fQuickStepInProgress)", v17, v18, v19, v29);
    goto LABEL_31;
  }
  if (!*((unsigned char *)this + 241))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0xB3u, (ctu::LogMessageBuffer *)"Assertion failure(fLongStepInProgress)", v20, v21, v22, v29);
    goto LABEL_31;
  }
  int v3 = a2;
  unint64_t v4 = *((void *)this + 31);
  unint64_t v5 = a2 - v4;
  if (a2 < v4)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0xB5u, (ctu::LogMessageBuffer *)"Assertion failure(current >= fLongStepStart)", v23, v24, v25, v29);
    goto LABEL_31;
  }
  unint64_t v6 = *((void *)this + 32);
  if (v6 < a2)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0xB6u, (ctu::LogMessageBuffer *)"Assertion failure(current <= fLongStepEnd)", v26, v27, v28, v29);
LABEL_31:
  }
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v33 = 0;
  v30[0] = 0;
  v30[1] = 0;
  uint64_t v31 = 0;
  if (*((_DWORD *)this + 46))
  {
    HIBYTE(v33) = 1;
    LOWORD(__p[0]) = 9;
    HIBYTE(v31) = 1;
    LOBYTE(v30[0]) = 10;
  }
  else
  {
    size_t v7 = *((void *)this + 34);
    if (v7)
    {
      if (v7 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v7 >= 0x17)
      {
        uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v7 | 7) != 0x17) {
          uint64_t v9 = v7 | 7;
        }
        uint64_t v10 = v9 + 1;
        p_b = (long long *)operator new(v9 + 1);
        *((void *)&__b + 1) = v7;
        *(void *)&long long v35 = v10 | 0x8000000000000000;
        *(void *)&long long __b = p_b;
      }
      else
      {
        BYTE7(v35) = *((void *)this + 34);
        p_b = &__b;
      }
      memset(p_b, 8, v7);
      *((unsigned char *)p_b + v7) = 0;
      *(_OWORD *)std::string __p = __b;
      uint64_t v33 = v35;
    }
  }
  *(void *)&long long v11 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v11 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v40 = v11;
  long long v41 = v11;
  long long v39 = v11;
  long long v37 = v11;
  long long v38 = v11;
  long long v35 = v11;
  long long v36 = v11;
  long long __b = v11;
  unint64_t v12 = 100 * v5 / (v6 - v4);
  if (v12 == *((void *)this + 33)) {
    goto LABEL_22;
  }
  *((void *)this + 33) = v12;
  unsigned int v13 = snprintf((char *)&__b, 0x80uLL, "0x%x of 0x%x (%u percent)", v3, v6, 100 * v5 / (v6 - v4));
  uint64_t v14 = v13 >= 0x80 ? 128 : v13;
  *((void *)this + 34) = v14;
  uint64_t v15 = __p;
  if (v33 < 0) {
    uint64_t v15 = (void **)__p[0];
  }
  BBUConsoleFeedback::writeToStream(this, "%s%s%s", (const char *)v15, (const char *)&__b, (const char *)v30);
  if ((SHIBYTE(v31) & 0x80000000) == 0)
  {
LABEL_22:
    if ((SHIBYTE(v33) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_23;
  }
  operator delete(v30[0]);
  if (SHIBYTE(v33) < 0) {
LABEL_23:
  }
    operator delete(__p[0]);
}

void sub_21DEE1DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if ((a23 & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_21DEE1E2C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE1E40(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE1E54(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE1E68(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUConsoleFeedback::handleEndLongStep(BBUConsoleFeedback *a1, int a2)
{
  if (*((unsigned char *)a1 + 240))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0xE1u, (ctu::LogMessageBuffer *)"Assertion failure(!fQuickStepInProgress)", v5, v6, v7, v11);
    goto LABEL_10;
  }
  if (!*((unsigned char *)a1 + 241))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUConsoleFeedback.cpp", 0xE2u, (ctu::LogMessageBuffer *)"Assertion failure(fLongStepInProgress)", v8, v9, v10, v11);
LABEL_10:
  }
  if (!a2) {
    (*(void (**)(BBUConsoleFeedback *, void))(*(void *)a1 + 40))(a1, *((void *)a1 + 32));
  }
  BBUProfiler::endStage((BBUConsoleFeedback *)((char *)a1 + 80));
  *((unsigned char *)a1 + 241) = 0;

  return BBUConsoleFeedback::writeToStream(a1, "\n");
}

void sub_21DEE1F78(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE1F8C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void BBUConsoleFeedback::handleCommentInternal(BBUConsoleFeedback *this, uint64_t a2)
{
  size_t v2 = *((void *)this + 29);
  if (v2 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v2 >= 0x17)
  {
    uint64_t v6 = (v2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v2 | 7) != 0x17) {
      uint64_t v6 = v2 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v5 = (void **)operator new(v6 + 1);
    __b[1] = (void *)v2;
    int64_t v11 = v7 | 0x8000000000000000;
    __b[0] = v5;
    goto LABEL_8;
  }
  HIBYTE(v11) = *((void *)this + 29);
  uint64_t v5 = __b;
  if (v2) {
LABEL_8:
  }
    memset(v5, 9, v2);
  *((unsigned char *)v5 + v2) = 0;
  uint64_t v8 = (const char *)__b;
  if (v11 < 0) {
    uint64_t v8 = (const char *)__b[0];
  }
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v9 = (const char *)a2;
  }
  else {
    uint64_t v9 = *(const char **)a2;
  }
  BBUConsoleFeedback::writeToStream(this, "%s%s\n", v8, v9);
  if (SHIBYTE(v11) < 0) {
    operator delete(__b[0]);
  }
}

void sub_21DEE20B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBUConsoleFeedback::handleLongStepCommentInternal(BBUConsoleFeedback *a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) >= 0) {
    size_t v2 = (const char *)a2;
  }
  else {
    size_t v2 = *(const char **)a2;
  }
  return BBUConsoleFeedback::writeToStream(a1, "\n%s\n", v2);
}

const char *BBUFeedback::getDebugName(BBUFeedback *this)
{
  return "BBUFeedback";
}

uint64_t std::deque<std::string>::~deque[abi:ne180100](uint64_t a1)
{
  size_t v2 = *(void ***)(a1 + 8);
  int v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    int v3 = *(void ***)(a1 + 8);
    *(void *)(a1 + 40) = 0;
    unint64_t v11 = 0;
    goto LABEL_13;
  }
  unint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = &v2[v4 / 0xAA];
  unint64_t v6 = (unint64_t)*v5;
  unint64_t v7 = (unint64_t)*v5 + 24 * (v4 % 0xAA);
  unint64_t v8 = (unint64_t)v2[(*(void *)(a1 + 40) + v4) / 0xAA] + 24 * ((*(void *)(a1 + 40) + v4) % 0xAA);
  if (v7 == v8) {
    goto LABEL_11;
  }
  do
  {
    if (*(char *)(v7 + 23) < 0)
    {
      uint64_t v9 = *(void **)v7;
      v7 += 24;
      operator delete(v9);
      unint64_t v6 = (unint64_t)*v5;
      if (v7 - (void)*v5 != 4080) {
        continue;
      }
    }
    else
    {
      v7 += 24;
      if (v7 - v6 != 4080) {
        continue;
      }
    }
    unint64_t v10 = (unint64_t)v5[1];
    ++v5;
    unint64_t v6 = v10;
    unint64_t v7 = v10;
  }
  while (v7 != v8);
  size_t v2 = *(void ***)(a1 + 8);
  int v3 = *(void ***)(a1 + 16);
LABEL_11:
  *(void *)(a1 + 40) = 0;
  unint64_t v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      int v3 = *(void ***)(a1 + 16);
      size_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
LABEL_13:
  unint64_t v12 = v11 >> 3;
  if (v12 == 1)
  {
    uint64_t v13 = 85;
LABEL_18:
    *(void *)(a1 + 32) = v13;
  }
  else if (v12 == 2)
  {
    uint64_t v13 = 170;
    goto LABEL_18;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    uint64_t v16 = *(void *)(a1 + 8);
    uint64_t v15 = *(void *)(a1 + 16);
    if (v15 != v16) {
      *(void *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GetBasebandTatsuTagToFileNameMap(uint64_t *a1@<X8>)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  unint64_t v4 = @"Cellular1,LLB";
  char v6 = 4;
  strcpy((char *)v5, "illb");
  unint64_t v7 = @"Cellular1,iBootData";
  char v9 = 4;
  strcpy((char *)v8, "ibdt");
  unint64_t v10 = @"Cellular1,iBSS";
  char v12 = 4;
  strcpy((char *)v11, "ibss");
  uint64_t v13 = @"Cellular1,PMUFW";
  char v15 = 4;
  strcpy((char *)v14, "apmu");
  uint64_t v16 = @"Cellular1,PMUFW2";
  char v18 = 4;
  strcpy((char *)v17, "pmfw");
  uint64_t v19 = @"Cellular1,RTKitOS";
  char v21 = 4;
  strcpy((char *)v20, "rkos");
  uint64_t v22 = @"Cellular1,CdpAscDl";
  char v24 = 4;
  strcpy((char *)v23, "cdpd");
  uint64_t v25 = @"Cellular1,CdpAscUl";
  char v27 = 4;
  strcpy((char *)v26, "cdpu");
  uint64_t v28 = @"Cellular1,CdpHost";
  char v30 = 4;
  strcpy((char *)v29, "cdph");
  uint64_t v31 = @"Cellular1,L1CL1S";
  char v33 = 4;
  strcpy((char *)v32, "l1cs");
  char v34 = @"Cellular1,ProvisioningFirmware";
  char v36 = 4;
  a1[1] = 0;
  size_t v2 = a1 + 1;
  strcpy((char *)v35, "prfw");
  long long v37 = @"Cellular1,Recipe";
  char v39 = 4;
  strcpy((char *)__p, "rcpi");
  a1[2] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, a1 + 1, (unint64_t)@"Cellular1,LLB", (uint64_t)&v4);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v7, (uint64_t)&v7);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v10, (uint64_t)&v10);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v13, (uint64_t)&v13);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v16, (uint64_t)&v16);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v19, (uint64_t)&v19);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v22, (uint64_t)&v22);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v25, (uint64_t)&v25);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v28, (uint64_t)&v28);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v31, (uint64_t)&v31);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v34, (uint64_t)&v34);
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(a1, v2, (unint64_t)v37, (uint64_t)&v37);
  if (v39 < 0)
  {
    operator delete(__p[0]);
    if ((v36 & 0x80000000) == 0)
    {
LABEL_3:
      if ((v33 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }
  else if ((v36 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v35[0]);
  if ((v33 & 0x80000000) == 0)
  {
LABEL_4:
    if ((v30 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
LABEL_16:
  operator delete(v32[0]);
  if ((v30 & 0x80000000) == 0)
  {
LABEL_5:
    if ((v27 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_18;
  }
LABEL_17:
  operator delete(v29[0]);
  if ((v27 & 0x80000000) == 0)
  {
LABEL_6:
    if ((v24 & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_19;
  }
LABEL_18:
  operator delete(v26[0]);
  if ((v24 & 0x80000000) == 0)
  {
LABEL_7:
    if ((v21 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_20;
  }
LABEL_19:
  operator delete(v23[0]);
  if ((v21 & 0x80000000) == 0)
  {
LABEL_8:
    if ((v18 & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_21;
  }
LABEL_20:
  operator delete(v20[0]);
  if ((v18 & 0x80000000) == 0)
  {
LABEL_9:
    if ((v15 & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_22;
  }
LABEL_21:
  operator delete(v17[0]);
  if ((v15 & 0x80000000) == 0)
  {
LABEL_10:
    if ((v12 & 0x80000000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_23;
  }
LABEL_22:
  operator delete(v14[0]);
  if ((v12 & 0x80000000) == 0)
  {
LABEL_11:
    if ((v9 & 0x80000000) == 0) {
      goto LABEL_12;
    }
LABEL_24:
    operator delete(v8[0]);
    if ((v6 & 0x80000000) == 0) {
      return;
    }
    goto LABEL_25;
  }
LABEL_23:
  operator delete(v11[0]);
  if (v9 < 0) {
    goto LABEL_24;
  }
LABEL_12:
  if ((v6 & 0x80000000) == 0) {
    return;
  }
LABEL_25:
  int v3 = v5[0];

  operator delete(v3);
}

void sub_21DEE26DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,void *a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,void *a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,void *a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,uint64_t a52,void *a53,uint64_t a54,int a55,__int16 a56,char a57,char a58,uint64_t a59,void *a60,uint64_t a61,int a62,__int16 a63)
{
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy(v78, *(char **)(v78 + 8));
  if (a78 < 0)
  {
    operator delete(__p);
    if ((a76 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a74 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }
  else if ((a76 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a75);
  if ((a74 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a72 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }
LABEL_16:
  operator delete(a73);
  if ((a72 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a65 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_18;
  }
LABEL_17:
  operator delete(a67);
  if ((a65 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a58 & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_19;
  }
LABEL_18:
  operator delete(a60);
  if ((a58 & 0x80000000) == 0)
  {
LABEL_7:
    if ((a51 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_20;
  }
LABEL_19:
  operator delete(a53);
  if ((a51 & 0x80000000) == 0)
  {
LABEL_8:
    if ((a44 & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_21;
  }
LABEL_20:
  operator delete(a46);
  if ((a44 & 0x80000000) == 0)
  {
LABEL_9:
    if ((a37 & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_22;
  }
LABEL_21:
  operator delete(a39);
  if ((a37 & 0x80000000) == 0)
  {
LABEL_10:
    if ((a30 & 0x80000000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_23;
  }
LABEL_22:
  operator delete(a32);
  if ((a30 & 0x80000000) == 0)
  {
LABEL_11:
    if ((a23 & 0x80000000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_24;
  }
LABEL_23:
  operator delete(a25);
  if ((a23 & 0x80000000) == 0)
  {
LABEL_12:
    if ((a16 & 0x80000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_25;
  }
LABEL_24:
  operator delete(a18);
  if ((a16 & 0x80000000) == 0) {
LABEL_13:
  }
    _Unwind_Resume(a1);
LABEL_25:
  operator delete(a11);
  _Unwind_Resume(a1);
}

void GetBasebandNVM4ccToFileNameMap(void *a1@<X8>)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  memset(a1, 170, 24);
  std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[11],0>((uint64_t)v2, (const char **)kBasebandNVMStaticFile, "static.nvm");
  std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[12],0>((uint64_t)&v6, (const char **)kBasebandNVMDynamicFile, "dynamic.nvm");
  std::map<std::string,std::string>::map[abi:ne180100]((void **)a1, (const void **)v2, 2);
  if (v9 < 0)
  {
    operator delete(__p);
    if ((v7 & 0x80000000) == 0)
    {
LABEL_3:
      if ((v5 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((v7 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v6);
  if ((v5 & 0x80000000) == 0)
  {
LABEL_4:
    if ((v3 & 0x80000000) == 0) {
      return;
    }
LABEL_9:
    operator delete(v2[0]);
    return;
  }
LABEL_8:
  operator delete(v4);
  if (v3 < 0) {
    goto LABEL_9;
  }
}

void sub_21DEE2930(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::pair<std::string const,std::string>::~pair(v2);
  std::pair<std::string const,std::string>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DEE294C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::pair<std::string const,std::string>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,std::string>::~pair(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
  {
    operator delete(*(void **)(a1 + 24));
    if ((*(char *)(a1 + 23) & 0x80000000) == 0) {
      return a1;
    }
  }
  else if ((*(char *)(a1 + 23) & 0x80000000) == 0)
  {
    return a1;
  }
  operator delete(*(void **)a1);
  return a1;
}

void GetBasebandFDR4ccToFileNameMap(void *a1@<X8>)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  memset(a1, 170, 24);
  std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[10],0>((uint64_t)v2, (const char **)kBasebandCalibrationFile, "calib.nvm");
  std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[10],0>((uint64_t)&v6, (const char **)kBasebandFATPCalibrationFile, "bbpac.der");
  std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[9],0>((uint64_t)&v10, (const char **)kBasebandProvisioningFile, "prov.nvm");
  std::map<std::string,std::string>::map[abi:ne180100]((void **)a1, (const void **)v2, 3);
  if (v13 < 0)
  {
    operator delete(__p);
    if ((v11 & 0x80000000) == 0)
    {
LABEL_3:
      if ((v9 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v10);
  if ((v9 & 0x80000000) == 0)
  {
LABEL_4:
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  operator delete(v8);
  if ((v7 & 0x80000000) == 0)
  {
LABEL_5:
    if ((v5 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(v6);
  if ((v5 & 0x80000000) == 0)
  {
LABEL_6:
    if ((v3 & 0x80000000) == 0) {
      return;
    }
LABEL_13:
    operator delete(v2[0]);
    return;
  }
LABEL_12:
  operator delete(v4);
  if (v3 < 0) {
    goto LABEL_13;
  }
}

void sub_21DEE2B38(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::pair<std::string const,std::string>::~pair(v2);
  std::pair<std::string const,std::string>::~pair(v3);
  std::pair<std::string const,std::string>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DEE2B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  do
  {
    v10 -= 48;
    std::pair<std::string const,std::string>::~pair((uint64_t)v10);
  }
  while (v10 != &a10);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[11],0>(uint64_t a1, const char **a2, const char *a3)
{
  char v5 = *a2;
  size_t v6 = strlen(*a2);
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    unint64_t v8 = operator new(v9 + 1);
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v10 | 0x8000000000000000;
    *(void *)a1 = v8;
    goto LABEL_8;
  }
  *(unsigned char *)(a1 + 23) = v6;
  unint64_t v8 = (void *)a1;
  if (v6) {
LABEL_8:
  }
    memmove(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  char v11 = (void *)(a1 + 24);
  size_t v12 = strlen(a3);
  if (v12 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v13 = v12;
  if (v12 >= 0x17)
  {
    uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v14 = v12 | 7;
    }
    uint64_t v15 = v14 + 1;
    char v11 = operator new(v14 + 1);
    *(void *)(a1 + 32) = v13;
    *(void *)(a1 + 40) = v15 | 0x8000000000000000;
    *(void *)(a1 + 24) = v11;
  }
  else
  {
    *(unsigned char *)(a1 + 47) = v12;
    if (!v12) {
      goto LABEL_17;
    }
  }
  memmove(v11, a3, v13);
LABEL_17:
  *((unsigned char *)v11 + v13) = 0;
  return a1;
}

void sub_21DEE2CC4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[12],0>(uint64_t a1, const char **a2, const char *a3)
{
  char v5 = *a2;
  size_t v6 = strlen(*a2);
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    unint64_t v8 = operator new(v9 + 1);
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v10 | 0x8000000000000000;
    *(void *)a1 = v8;
    goto LABEL_8;
  }
  *(unsigned char *)(a1 + 23) = v6;
  unint64_t v8 = (void *)a1;
  if (v6) {
LABEL_8:
  }
    memmove(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  char v11 = (void *)(a1 + 24);
  size_t v12 = strlen(a3);
  if (v12 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v13 = v12;
  if (v12 >= 0x17)
  {
    uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v14 = v12 | 7;
    }
    uint64_t v15 = v14 + 1;
    char v11 = operator new(v14 + 1);
    *(void *)(a1 + 32) = v13;
    *(void *)(a1 + 40) = v15 | 0x8000000000000000;
    *(void *)(a1 + 24) = v11;
  }
  else
  {
    *(unsigned char *)(a1 + 47) = v12;
    if (!v12) {
      goto LABEL_17;
    }
  }
  memmove(v11, a3, v13);
LABEL_17:
  *((unsigned char *)v11 + v13) = 0;
  return a1;
}

void sub_21DEE2E20(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[10],0>(uint64_t a1, const char **a2, const char *a3)
{
  char v5 = *a2;
  size_t v6 = strlen(*a2);
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    unint64_t v8 = operator new(v9 + 1);
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v10 | 0x8000000000000000;
    *(void *)a1 = v8;
    goto LABEL_8;
  }
  *(unsigned char *)(a1 + 23) = v6;
  unint64_t v8 = (void *)a1;
  if (v6) {
LABEL_8:
  }
    memmove(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  char v11 = (void *)(a1 + 24);
  size_t v12 = strlen(a3);
  if (v12 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v13 = v12;
  if (v12 >= 0x17)
  {
    uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v14 = v12 | 7;
    }
    uint64_t v15 = v14 + 1;
    char v11 = operator new(v14 + 1);
    *(void *)(a1 + 32) = v13;
    *(void *)(a1 + 40) = v15 | 0x8000000000000000;
    *(void *)(a1 + 24) = v11;
  }
  else
  {
    *(unsigned char *)(a1 + 47) = v12;
    if (!v12) {
      goto LABEL_17;
    }
  }
  memmove(v11, a3, v13);
LABEL_17:
  *((unsigned char *)v11 + v13) = 0;
  return a1;
}

void sub_21DEE2F7C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::pair<std::string const,std::string>::pair[abi:ne180100]<char const*&,char const(&)[9],0>(uint64_t a1, const char **a2, const char *a3)
{
  char v5 = *a2;
  size_t v6 = strlen(*a2);
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    unint64_t v8 = operator new(v9 + 1);
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v10 | 0x8000000000000000;
    *(void *)a1 = v8;
    goto LABEL_8;
  }
  *(unsigned char *)(a1 + 23) = v6;
  unint64_t v8 = (void *)a1;
  if (v6) {
LABEL_8:
  }
    memmove(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  char v11 = (void *)(a1 + 24);
  size_t v12 = strlen(a3);
  if (v12 > 0x7FFFFFFFFFFFFFF7) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v13 = v12;
  if (v12 >= 0x17)
  {
    uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v14 = v12 | 7;
    }
    uint64_t v15 = v14 + 1;
    char v11 = operator new(v14 + 1);
    *(void *)(a1 + 32) = v13;
    *(void *)(a1 + 40) = v15 | 0x8000000000000000;
    *(void *)(a1 + 24) = v11;
  }
  else
  {
    *(unsigned char *)(a1 + 47) = v12;
    if (!v12) {
      goto LABEL_17;
    }
  }
  memmove(v11, a3, v13);
LABEL_17:
  *((unsigned char *)v11 + v13) = 0;
  return a1;
}

void sub_21DEE30D8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::__emplace_hint_unique_key_args<__CFString const*,std::pair<__CFString const* const,std::string> const&>(uint64_t *result, uint64_t *a2, unint64_t a3, uint64_t a4)
{
  char v5 = (uint64_t **)a2;
  size_t v6 = result;
  size_t v7 = (uint64_t **)(result + 1);
  if (result + 1 == a2 || (unint64_t v8 = a2[4], v8 > a3))
  {
    uint64_t v9 = *a2;
    if ((uint64_t *)*result == a2)
    {
      char v11 = a2;
LABEL_16:
      if (v9) {
        uint64_t v17 = v11;
      }
      else {
        uint64_t v17 = a2;
      }
      if (v9) {
        size_t v13 = (uint64_t **)(v11 + 1);
      }
      else {
        size_t v13 = (uint64_t **)a2;
      }
      if (*v13) {
        return result;
      }
      char v5 = (uint64_t **)v17;
LABEL_37:
      uint64_t v22 = (uint64_t *)operator new(0x40uLL);
      v22[4] = *(void *)a4;
      uint64_t v23 = (std::string *)(v22 + 5);
      if (*(char *)(a4 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(v23, *(const std::string::value_type **)(a4 + 8), *(void *)(a4 + 16));
      }
      else
      {
        *(_OWORD *)&v23->__r_.__value_.__l.__data_ = *(_OWORD *)(a4 + 8);
        v22[7] = *(void *)(a4 + 24);
      }
      *uint64_t v22 = 0;
      v22[1] = 0;
      uint64_t v22[2] = (uint64_t)v5;
      *size_t v13 = v22;
      uint64_t v25 = *(void *)*v6;
      if (v25)
      {
        uint64_t *v6 = v25;
        uint64_t v22 = *v13;
      }
      uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v6[1], v22);
      ++v6[2];
      return result;
    }
    if (v9)
    {
      uint64_t v10 = (uint64_t *)*a2;
      do
      {
        char v11 = v10;
        uint64_t v10 = (uint64_t *)v10[1];
      }
      while (v10);
    }
    else
    {
      uint64_t v15 = a2;
      do
      {
        char v11 = (uint64_t *)v15[2];
        BOOL v16 = *v11 == (void)v15;
        uint64_t v15 = v11;
      }
      while (v16);
    }
    if (v11[4] < a3) {
      goto LABEL_16;
    }
    char v18 = *v7;
    size_t v13 = (uint64_t **)(result + 1);
    char v5 = (uint64_t **)(result + 1);
    if (!*v7) {
      goto LABEL_37;
    }
    while (1)
    {
      while (1)
      {
        char v5 = (uint64_t **)v18;
        unint64_t v19 = v18[4];
        if (v19 <= a3) {
          break;
        }
        char v18 = (uint64_t *)*v18;
        size_t v13 = v5;
        if (!*v5) {
          goto LABEL_37;
        }
      }
      if (v19 >= a3) {
        break;
      }
      char v18 = (uint64_t *)v18[1];
      if (!v18) {
        goto LABEL_30;
      }
    }
  }
  else
  {
    if (v8 >= a3) {
      return result;
    }
    size_t v13 = (uint64_t **)(a2 + 1);
    size_t v12 = (uint64_t *)a2[1];
    if (v12)
    {
      do
      {
        size_t v13 = (uint64_t **)v12;
        size_t v12 = (uint64_t *)*v12;
        char v5 = v13;
        uint64_t v14 = v13;
      }
      while (v12);
    }
    else
    {
      uint64_t v14 = (uint64_t **)a2;
      do
      {
        uint64_t v20 = (uint64_t *)v14;
        uint64_t v14 = (uint64_t **)v14[2];
      }
      while (*v14 != v20);
    }
    if (v14 == v7) {
      goto LABEL_37;
    }
    if ((unint64_t)v14[4] > a3) {
      goto LABEL_37;
    }
    char v21 = *v7;
    size_t v13 = (uint64_t **)(result + 1);
    char v5 = (uint64_t **)(result + 1);
    if (!*v7) {
      goto LABEL_37;
    }
    while (1)
    {
      while (1)
      {
        char v5 = (uint64_t **)v21;
        unint64_t v24 = v21[4];
        if (v24 <= a3) {
          break;
        }
        char v21 = (uint64_t *)*v21;
        size_t v13 = v5;
        if (!*v5) {
          goto LABEL_37;
        }
      }
      if (v24 >= a3) {
        break;
      }
      char v21 = (uint64_t *)v21[1];
      if (!v21)
      {
LABEL_30:
        size_t v13 = v5 + 1;
        goto LABEL_37;
      }
    }
  }
  return result;
}

void sub_21DEE3318(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void **std::map<std::string,std::string>::map[abi:ne180100](void **a1, const void **a2, uint64_t a3)
{
  a1[1] = 0;
  unint64_t v4 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = a1 + 1;
  if (a3)
  {
    uint64_t v6 = 48 * a3;
    do
    {
      size_t v13 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      uint64_t v14 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
      size_t v7 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1, v4, &v14, &v13, a2);
      if (!*v7)
      {
        memset(v12, 170, sizeof(v12));
        std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::pair<std::string const,std::string> const&>((uint64_t)a1, (uint64_t)a2, v12);
        unint64_t v8 = v14;
        uint64_t v9 = (uint64_t *)v12[0];
        *(void *)v12[0] = 0;
        v9[1] = 0;
        v9[2] = (uint64_t)v8;
        *size_t v7 = (uint64_t)v9;
        uint64_t v10 = (void *)**a1;
        if (v10)
        {
          *a1 = v10;
          uint64_t v9 = (uint64_t *)*v7;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v9);
        a1[2] = (void *)((char *)a1[2] + 1);
      }
      a2 += 6;
      v6 -= 48;
    }
    while (v6);
  }
  return a1;
}

void sub_21DEE341C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,ctu::Http::case_insensitive_key_comparer,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v1, *(void *)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, const void **a5)
{
  unint64_t v8 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2) {
    goto LABEL_23;
  }
  int v10 = *((char *)a5 + 23);
  if (v10 >= 0) {
    char v11 = a5;
  }
  else {
    char v11 = *a5;
  }
  if (v10 >= 0) {
    size_t v12 = *((unsigned __int8 *)a5 + 23);
  }
  else {
    size_t v12 = (size_t)a5[1];
  }
  int v13 = *((char *)a2 + 55);
  if (v13 >= 0) {
    uint64_t v14 = a2 + 4;
  }
  else {
    uint64_t v14 = (const void *)a2[4];
  }
  if (v13 >= 0) {
    size_t v15 = *((unsigned __int8 *)a2 + 55);
  }
  else {
    size_t v15 = a2[5];
  }
  if (v15 >= v12) {
    size_t v16 = v12;
  }
  else {
    size_t v16 = v15;
  }
  int v17 = memcmp(v11, v14, v16);
  if (!v17)
  {
    if (v12 >= v15) {
      goto LABEL_19;
    }
LABEL_23:
    unint64_t v19 = (uint64_t *)*a2;
    if (*a1 == a2)
    {
      char v21 = a2;
    }
    else
    {
      if (v19)
      {
        uint64_t v20 = (uint64_t *)*a2;
        do
        {
          char v21 = v20;
          uint64_t v20 = (uint64_t *)v20[1];
        }
        while (v20);
      }
      else
      {
        uint64_t v22 = a2;
        do
        {
          char v21 = (uint64_t *)v22[2];
          BOOL v23 = *v21 == (void)v22;
          uint64_t v22 = v21;
        }
        while (v23);
      }
      int v24 = *((char *)v21 + 55);
      if (v24 >= 0) {
        uint64_t v25 = v21 + 4;
      }
      else {
        uint64_t v25 = (const void *)v21[4];
      }
      if (v24 >= 0) {
        size_t v26 = *((unsigned __int8 *)v21 + 55);
      }
      else {
        size_t v26 = v21[5];
      }
      int v27 = *((char *)a5 + 23);
      if (v27 >= 0) {
        uint64_t v28 = a5;
      }
      else {
        uint64_t v28 = *a5;
      }
      if (v27 >= 0) {
        size_t v29 = *((unsigned __int8 *)a5 + 23);
      }
      else {
        size_t v29 = (size_t)a5[1];
      }
      if (v29 >= v26) {
        size_t v30 = v26;
      }
      else {
        size_t v30 = v29;
      }
      int v31 = memcmp(v25, v28, v30);
      if (v31)
      {
        if ((v31 & 0x80000000) == 0) {
          goto LABEL_48;
        }
      }
      else if (v26 >= v29)
      {
LABEL_48:
        uint64_t v32 = *v8;
        if (!*v8)
        {
          char v33 = v8;
LABEL_69:
          *a3 = (uint64_t *)v33;
          return (uint64_t *)v8;
        }
        while (1)
        {
          char v33 = (uint64_t **)v32;
          char v36 = (const void *)v32[4];
          char v34 = v32 + 4;
          long long v35 = v36;
          int v37 = *((char *)v34 + 23);
          if (v37 >= 0) {
            long long v38 = v34;
          }
          else {
            long long v38 = v35;
          }
          if (v37 >= 0) {
            size_t v39 = *((unsigned __int8 *)v34 + 23);
          }
          else {
            size_t v39 = v34[1];
          }
          if (v39 >= v29) {
            size_t v40 = v29;
          }
          else {
            size_t v40 = v39;
          }
          int v41 = memcmp(v28, v38, v40);
          if (v41)
          {
            if (v41 < 0) {
              goto LABEL_50;
            }
LABEL_64:
            int v42 = memcmp(v38, v28, v40);
            if (v42)
            {
              if ((v42 & 0x80000000) == 0) {
                goto LABEL_69;
              }
            }
            else if (v39 >= v29)
            {
              goto LABEL_69;
            }
            unint64_t v8 = v33 + 1;
            uint64_t v32 = v33[1];
            if (!v32) {
              goto LABEL_69;
            }
          }
          else
          {
            if (v29 >= v39) {
              goto LABEL_64;
            }
LABEL_50:
            uint64_t v32 = *v33;
            unint64_t v8 = v33;
            if (!*v33) {
              goto LABEL_69;
            }
          }
        }
      }
    }
    if (v19)
    {
      *a3 = v21;
      return v21 + 1;
    }
    else
    {
      *a3 = a2;
      return a2;
    }
  }
  if (v17 < 0) {
    goto LABEL_23;
  }
LABEL_19:
  int v18 = memcmp(v14, v11, v16);
  if (v18)
  {
    if ((v18 & 0x80000000) == 0)
    {
LABEL_21:
      *a3 = a2;
      *a4 = a2;
      return (uint64_t *)a4;
    }
  }
  else if (v15 >= v12)
  {
    goto LABEL_21;
  }
  uint64_t v43 = a2[1];
  if (v43)
  {
    uint64_t v44 = (uint64_t *)a2[1];
    do
    {
      a4 = (uint64_t **)v44;
      uint64_t v44 = (uint64_t *)*v44;
    }
    while (v44);
  }
  else
  {
    unint64_t v45 = a2;
    do
    {
      a4 = (uint64_t **)v45[2];
      BOOL v23 = *a4 == v45;
      unint64_t v45 = (uint64_t *)a4;
    }
    while (!v23);
  }
  if (a4 != v8)
  {
    int v46 = *((char *)a4 + 55);
    if (v46 >= 0) {
      uint64_t v47 = (uint64_t *)(a4 + 4);
    }
    else {
      uint64_t v47 = a4[4];
    }
    if (v46 >= 0) {
      size_t v48 = *((unsigned __int8 *)a4 + 55);
    }
    else {
      size_t v48 = (size_t)a4[5];
    }
    if (v48 >= v12) {
      size_t v49 = v12;
    }
    else {
      size_t v49 = v48;
    }
    int v50 = memcmp(v11, v47, v49);
    if (v50)
    {
      if ((v50 & 0x80000000) == 0)
      {
LABEL_95:
        uint64_t v51 = *v8;
        if (*v8)
        {
          uint64_t v52 = a3;
          while (1)
          {
            unint64_t v53 = (uint64_t **)v51;
            unint64_t v56 = (const void *)v51[4];
            uint64_t v54 = v51 + 4;
            uint64_t v55 = v56;
            int v57 = *((char *)v54 + 23);
            if (v57 >= 0) {
              unint64_t v58 = v54;
            }
            else {
              unint64_t v58 = v55;
            }
            if (v57 >= 0) {
              size_t v59 = *((unsigned __int8 *)v54 + 23);
            }
            else {
              size_t v59 = v54[1];
            }
            if (v59 >= v12) {
              size_t v60 = v12;
            }
            else {
              size_t v60 = v59;
            }
            int v61 = memcmp(v11, v58, v60);
            if (v61)
            {
              if (v61 < 0) {
                goto LABEL_97;
              }
LABEL_111:
              int v62 = memcmp(v58, v11, v60);
              if (v62)
              {
                if ((v62 & 0x80000000) == 0) {
                  goto LABEL_123;
                }
              }
              else if (v59 >= v12)
              {
                goto LABEL_123;
              }
              unint64_t v8 = v53 + 1;
              uint64_t v51 = v53[1];
              if (!v51) {
                goto LABEL_123;
              }
            }
            else
            {
              if (v12 >= v59) {
                goto LABEL_111;
              }
LABEL_97:
              uint64_t v51 = *v53;
              unint64_t v8 = v53;
              if (!*v53) {
                goto LABEL_123;
              }
            }
          }
        }
        unint64_t v53 = v8;
        uint64_t v52 = a3;
LABEL_123:
        *uint64_t v52 = (uint64_t *)v53;
        return (uint64_t *)v8;
      }
    }
    else if (v12 >= v48)
    {
      goto LABEL_95;
    }
  }
  if (v43)
  {
    *a3 = (uint64_t *)a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return (uint64_t *)a4;
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__construct_node<std::pair<std::string const,std::string> const&>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  memset(a3, 170, 24);
  uint64_t v6 = (char *)operator new(0x50uLL);
  size_t v7 = v6;
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(v6 + 32), *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *((_OWORD *)v6 + 2) = *(_OWORD *)a2;
    *((void *)v6 + 6) = *(void *)(a2 + 16);
  }
  unint64_t v8 = (std::string *)(v7 + 56);
  if (*(char *)(a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 24);
    *((void *)v7 + 9) = *(void *)(a2 + 40);
  }
  *((unsigned char *)a3 + 16) = 1;
}

void sub_21DEE38A4(_Unwind_Exception *a1)
{
  if (*(char *)(v2 + 55) < 0)
  {
    operator delete(*v3);
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::~unique_ptr[abi:ne180100](v1);
    _Unwind_Resume(a1);
  }
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::~unique_ptr[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      if (*(char *)(v2 + 79) < 0)
      {
        operator delete(*(void **)(v2 + 56));
        if ((*(char *)(v2 + 55) & 0x80000000) == 0) {
          goto LABEL_5;
        }
      }
      else if ((*(char *)(v2 + 55) & 0x80000000) == 0)
      {
        goto LABEL_5;
      }
      operator delete(*(void **)(v2 + 32));
    }
LABEL_5:
    operator delete((void *)v2);
  }
  return a1;
}

uint64_t ctu::PthreadMutexGuardPolicy<ctu::Gestalt>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

uint64_t __cxx_global_var_init_2()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ctu::Gestalt>::~PthreadMutexGuardPolicy, &ctu::Singleton<ctu::Gestalt,ctu::Gestalt,ctu::PthreadMutexGuardPolicy<ctu::Gestalt>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

uint64_t eUICC::Perso::Perform(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v171 = *MEMORY[0x263EF8340];
  pthread_mutex_lock(&ctu::Singleton<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation,ctu::PthreadMutexGuardPolicy<eUICC::Perso::PersoImplementation>>::sInstance);
  if (!qword_26AA89B00)
  {
    size_t v7 = (char *)operator new(0x38uLL);
    *((void *)v7 + 4) = 0;
    *((void *)v7 + 5) = 0;
    *((void *)v7 + 6) = 0;
    *((void *)v7 + 1) = 0;
    *((void *)v7 + 2) = 0;
    *(void *)size_t v7 = 0;
    uint64_t v6 = (std::__shared_weak_count *)operator new(0x20uLL);
    v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CECA790;
    v6->__shared_owners_ = 0;
    v6->__shared_weak_owners_ = 0;
    v6[1].__vftable = (std::__shared_weak_count_vtbl *)v7;
    unint64_t v8 = (std::__shared_weak_count *)off_26AA89B08;
    qword_26AA89B00 = (uint64_t)v7;
    off_26AA89B08 = v6;
    if (!v8)
    {
      v145 = v6;
      goto LABEL_8;
    }
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  size_t v7 = (char *)qword_26AA89B00;
  uint64_t v6 = (std::__shared_weak_count *)off_26AA89B08;
  v145 = (std::__shared_weak_count *)off_26AA89B08;
  if (off_26AA89B08) {
LABEL_8:
  }
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  pthread_mutex_unlock(&ctu::Singleton<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation,ctu::PthreadMutexGuardPolicy<eUICC::Perso::PersoImplementation>>::sInstance);
  v146[0] = 0;
  v146[1] = 0;
  std::string::size_type v147 = 0;
  if (!*a3)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    size_t v26 = "vinylValve";
    goto LABEL_40;
  }
  *((void *)v7 + 3) = a1;
  dispatch_queue_t v12 = dispatch_queue_create("PersoImpl", 0);
  int v13 = *(NSObject **)v7;
  *(void *)size_t v7 = v12;
  if (v13) {
    dispatch_release(v13);
  }
  uint64_t v14 = *(unsigned __int8 *)(a1 + 39);
  if ((v14 & 0x80u) != 0) {
    uint64_t v14 = *(void *)(a1 + 24);
  }
  if (!v14)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    size_t v26 = "!performOptions.alderHostname.empty()";
    goto LABEL_40;
  }
  ReverseProxyGetSettings(a1 + 16, (uint64_t *)cf);
  size_t v15 = (const void **)(v7 + 8);
  if (v7 + 8 != (char *)cf)
  {
    size_t v16 = *v15;
    *size_t v15 = (const void *)cf[0].__r_.__value_.__r.__words[0];
    cf[0].__r_.__value_.__r.__words[0] = 0;
    if (!v16) {
      goto LABEL_20;
    }
    CFRelease(v16);
  }
  if (cf[0].__r_.__value_.__r.__words[0]) {
    CFRelease(cf[0].__r_.__value_.__l.__data_);
  }
LABEL_20:
  if (*v15) {
    int v17 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    int v17 = 0;
  }
  if (!v17)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    size_t v26 = "this->reverseProxySettings";
LABEL_40:
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v9, v10, v11, (char)v26);
    uint64_t v30 = 10;
    goto LABEL_81;
  }
  if (!*(unsigned char *)(*((void *)v7 + 3) + 40)) {
    goto LABEL_58;
  }
  if (BBUpdaterCommon::getECID(void)::sOnce != -1) {
    dispatch_once(&BBUpdaterCommon::getECID(void)::sOnce, &__block_literal_global_18);
  }
  v157 = (void *)BBUpdaterCommon::getECID(void)::ecid;
  long long v168 = 0uLL;
  values = 0;
  std::string __p = 0;
  CFRange v161 = 0;
  CFRange v162 = 0;
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&cf[11].__r_.__value_.__s.__data_[2] = v18;
  *(_OWORD *)&cf[10].__r_.__value_.__l.__data_ = v18;
  *(_OWORD *)&cf[10].__r_.__value_.__r.__words[2] = v18;
  *(_OWORD *)&cf[8].__r_.__value_.__r.__words[2] = v18;
  *(_OWORD *)&cf[9].__r_.__value_.__r.__words[1] = v18;
  *(_OWORD *)&cf[7].__r_.__value_.__r.__words[1] = v18;
  *(_OWORD *)&cf[8].__r_.__value_.__l.__data_ = v18;
  *(_OWORD *)&cf[6].__r_.__value_.__l.__data_ = v18;
  *(_OWORD *)&cf[6].__r_.__value_.__r.__words[2] = v18;
  *(_OWORD *)&cf[4].__r_.__value_.__r.__words[2] = v18;
  *(_OWORD *)&cf[5].__r_.__value_.__r.__words[1] = v18;
  *(_OWORD *)&cf[3].__r_.__value_.__r.__words[1] = v18;
  *(_OWORD *)&cf[4].__r_.__value_.__l.__data_ = v18;
  *(_OWORD *)&cf[2].__r_.__value_.__l.__data_ = v18;
  *(_OWORD *)&cf[2].__r_.__value_.__r.__words[2] = v18;
  *(_OWORD *)&cf[0].__r_.__value_.__r.__words[2] = v18;
  *(_OWORD *)&cf[1].__r_.__value_.__r.__words[1] = v18;
  *(_OWORD *)&cf[0].__r_.__value_.__l.__data_ = v18;
  unint64_t v19 = (capabilities::updater *)(*(void *(**)(std::string *__return_ptr))(*(void *)*a3 + 8))(cf);
  int v20 = capabilities::updater::EUICCVinylSuccessStatus(v19);
  if (LODWORD(cf[0].__r_.__value_.__l.__data_) != v20)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    goto LABEL_43;
  }
  if (cf[0].__r_.__value_.__s.__data_[4]) {
    goto LABEL_29;
  }
  if (DEREncodeItemIntoVector(4uLL, 8uLL, &v157, (uint64_t)&values))
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_49;
    }
    goto LABEL_282;
  }
  if (DEREncodeItemIntoVector(0x2000000000000010uLL, v168 - (void)values, values, (uint64_t)&__p))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
LABEL_49:
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v31, v32, v33, (char)"DR_Success == derRet");
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      int v37 = "Failed to encode ECID\n";
LABEL_52:
      _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", v37, v34, v35, v36, v141);
LABEL_53:
      char v24 = 0;
      uint64_t v25 = __p;
      if (!__p) {
        goto LABEL_55;
      }
      goto LABEL_54;
    }
LABEL_282:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    goto LABEL_49;
  }
  if ((*(unsigned int (**)(void, void **, void **))(*(void *)*a3 + 56))(*a3, &__p, v146))
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v96, v97, v98, (char)"kBBUReturnSuccess == ret");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    int v37 = "Failed to complete InitPerso command\n";
    goto LABEL_52;
  }
  (*(void (**)(void, void, uint64_t))(*(void *)*a3 + 16))(*a3, 0, 1);
  __src[0].__r_.__value_.__r.__words[0] = 10000000000;
  std::this_thread::sleep_for ((const std::chrono::nanoseconds *)__src);
  (*(void (**)(std::string *__return_ptr))(*(void *)*a3 + 8))(__src);
  long long v116 = (capabilities::updater *)memcpy(cf, __src, 0x11AuLL);
  int v117 = capabilities::updater::EUICCVinylSuccessStatus(v116);
  if (LODWORD(cf[0].__r_.__value_.__l.__data_) != v117)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
LABEL_43:
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v21, v22, v23, (char)"cardData.Valid()");
    goto LABEL_53;
  }
  if (!cf[0].__r_.__value_.__s.__data_[4])
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v21, v22, v23, (char)"cardData.contents.perso");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    int v37 = "Still persod after force?\n";
    goto LABEL_52;
  }
LABEL_29:
  char v24 = 1;
  uint64_t v25 = __p;
  if (__p)
  {
LABEL_54:
    CFRange v161 = v25;
    operator delete(v25);
  }
LABEL_55:
  if (values)
  {
    *(void *)&long long v168 = values;
    operator delete(values);
  }
  if ((v24 & 1) == 0)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    int v41 = "kBBUReturnSuccess == ret";
    goto LABEL_80;
  }
LABEL_58:
  if (BBUpdaterCommon::getECID(void)::sOnce != -1) {
    dispatch_once(&BBUpdaterCommon::getECID(void)::sOnce, &__block_literal_global_18);
  }
  v152 = (void *)BBUpdaterCommon::getECID(void)::ecid;
  long long v150 = 0;
  memset(cf, 0, 24);
  memset(__src, 0, 24);
  if (DEREncodeItemIntoVector(4uLL, 8uLL, &v152, (uint64_t)cf))
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_68;
    }
    goto LABEL_275;
  }
  if (DEREncodeItemIntoVector(0x2000000000000010uLL, cf[0].__r_.__value_.__l.__size_ - cf[0].__r_.__value_.__r.__words[0], cf[0].__r_.__value_.__l.__data_, (uint64_t)__src))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
LABEL_68:
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v38, v39, v40, (char)"DR_Success == derRet");
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to encode ECID\n", v42, v43, v44, v142);
      int v48 = 10;
      goto LABEL_71;
    }
LABEL_275:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    goto LABEL_68;
  }
  values = operator new(0x19uLL);
  long long v168 = xmmword_21DFA8EC0;
  strcpy((char *)values, "InitPersoDeviceBlob.bin");
  CFRange v161 = 0;
  CFRange v162 = 0;
  std::string __p = 0;
  unint64_t v58 = (const void *)__src[0].__r_.__value_.__r.__words[0];
  size_t v59 = __src[0].__r_.__value_.__l.__size_ - __src[0].__r_.__value_.__r.__words[0];
  if (__src[0].__r_.__value_.__l.__size_ != __src[0].__r_.__value_.__r.__words[0])
  {
    if ((v59 & 0x8000000000000000) != 0) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    std::string __p = operator new(__src[0].__r_.__value_.__l.__size_ - __src[0].__r_.__value_.__r.__words[0]);
    CFRange v161 = __p;
    size_t v60 = (char *)__p + v59;
    CFRange v162 = (char *)__p + v59;
    memcpy(__p, v58, v59);
    CFRange v161 = v60;
  }
  int v61 = (std::string *)*((void *)v7 + 5);
  if ((unint64_t)v61 >= *((void *)v7 + 6))
  {
    int v62 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)v7 + 4, (long long *)&values, (uint64_t)&__p);
  }
  else
  {
    std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*((std::string **)v7 + 5), (long long *)&values, (uint64_t)&__p);
    int v62 = v61 + 2;
    *((void *)v7 + 5) = v61 + 2;
  }
  *((void *)v7 + 5) = v62;
  if (__p)
  {
    CFRange v161 = __p;
    operator delete(__p);
  }
  if (SHIBYTE(v168) < 0) {
    operator delete(values);
  }
  int v48 = (*(uint64_t (**)(void, std::string *, void **))(*(void *)*a3 + 56))(*a3, __src, v146);
  if (v48)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v80, v81, v82, (char)"kBBUReturnSuccess == ret");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to complete InitPerso command\n", v83, v84, v85, v143);
  }
  else
  {
    v157 = operator new(0x20uLL);
    long long v158 = xmmword_21DFAB640;
    strcpy((char *)v157, "InitPersoDeviceResponse.bin");
    memset(&v155, 0, sizeof(v155));
    char v86 = v146[0];
    size_t v87 = (char *)v146[1] - (char *)v146[0];
    if (v146[1] != v146[0])
    {
      if ((v87 & 0x8000000000000000) != 0) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      v155.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new((char *)v146[1] - (char *)v146[0]);
      v155.__r_.__value_.__l.__size_ = v155.__r_.__value_.__r.__words[0];
      std::string::size_type v88 = v155.__r_.__value_.__r.__words[0] + v87;
      v155.__r_.__value_.__r.__words[2] = v155.__r_.__value_.__r.__words[0] + v87;
      memcpy(v155.__r_.__value_.__l.__data_, v86, v87);
      v155.__r_.__value_.__l.__size_ = v88;
    }
    uint64_t v89 = (std::string *)*((void *)v7 + 5);
    if ((unint64_t)v89 >= *((void *)v7 + 6))
    {
      uint64_t v90 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)v7 + 4, (long long *)&v157, (uint64_t)&v155);
    }
    else
    {
      std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*((std::string **)v7 + 5), (long long *)&v157, (uint64_t)&v155);
      uint64_t v90 = v89 + 2;
      *((void *)v7 + 5) = v89 + 2;
    }
    *((void *)v7 + 5) = v90;
    if (v155.__r_.__value_.__r.__words[0])
    {
      v155.__r_.__value_.__l.__size_ = v155.__r_.__value_.__r.__words[0];
      operator delete(v155.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v158) < 0) {
      operator delete(v157);
    }
    int v48 = 0;
  }
LABEL_71:
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "InitPersoDevice %d\n", v45, v46, v47, v48);
  if (__src[0].__r_.__value_.__r.__words[0])
  {
    __src[0].__r_.__value_.__l.__size_ = __src[0].__r_.__value_.__r.__words[0];
    operator delete(__src[0].__r_.__value_.__l.__data_);
  }
  if (cf[0].__r_.__value_.__r.__words[0])
  {
    cf[0].__r_.__value_.__l.__size_ = cf[0].__r_.__value_.__r.__words[0];
    operator delete(cf[0].__r_.__value_.__l.__data_);
  }
  if (v48 || (uint64_t v52 = v146[0], v146[0] == v146[1]))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
LABEL_79:
      int v41 = "kBBUReturnSuccess == ret && !dataBuffer.empty()";
LABEL_80:
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v21, v22, v23, (char)v41);
      uint64_t v30 = 18;
      goto LABEL_81;
    }
LABEL_274:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    goto LABEL_79;
  }
  CFTypeRef v165 = 0;
  long long v164 = 0uLL;
  CFRange v162 = 0;
  CFTypeRef v163 = 0;
  std::string __p = 0;
  CFRange v161 = 0;
  v157 = 0;
  long long v158 = 0uLL;
  size_t v53 = (char *)v146[1] - (char *)v146[0];
  if ((char *)v146[1] - (char *)v146[0] < 0) {
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v54 = (char *)operator new((char *)v146[1] - (char *)v146[0]);
  v157 = v54;
  *((void *)&v158 + 1) = &v54[v53];
  memcpy(v54, v52, v53);
  values = 0;
  memset(cf, 0, 24);
  uint64_t v55 = operator new(v53);
  std::string::size_type v56 = (std::string::size_type)v55 + v53;
  cf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v55;
  cf[0].__r_.__value_.__r.__words[2] = (std::string::size_type)v55 + v53;
  memcpy(v55, v54, v53);
  cf[0].__r_.__value_.__l.__size_ = v56;
  __src[0].__r_.__value_.__r.__words[0] = 0;
  if (ctu::cf::convert_copy())
  {
    int v57 = (const void *)__src[0].__r_.__value_.__r.__words[0];
    values = (void *)__src[0].__r_.__value_.__r.__words[0];
  }
  else
  {
    int v57 = 0;
  }
  if (cf[0].__r_.__value_.__r.__words[0])
  {
    cf[0].__r_.__value_.__l.__size_ = cf[0].__r_.__value_.__r.__words[0];
    operator delete(cf[0].__r_.__value_.__l.__data_);
  }
  CFTypeRef v159 = v57;
  *(void *)&long long v158 = v54;
  operator delete(v54);
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v155, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v155 = *(std::string *)a2;
  }
  if (SHIBYTE(v155.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(__src, v155.__r_.__value_.__l.__data_, v155.__r_.__value_.__l.__size_);
  }
  else {
    __src[0] = v155;
  }
  v152 = 0;
  if (SHIBYTE(__src[0].__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(cf, __src[0].__r_.__value_.__l.__data_, __src[0].__r_.__value_.__l.__size_);
  }
  else {
    cf[0] = __src[0];
  }
  values = 0;
  if (ctu::cf::convert_copy()) {
    uint64_t v63 = values;
  }
  else {
    uint64_t v63 = 0;
  }
  if ((SHIBYTE(cf[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    CFTypeRef v156 = v63;
    if ((SHIBYTE(__src[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_119;
    }
LABEL_149:
    operator delete(__src[0].__r_.__value_.__l.__data_);
    if ((SHIBYTE(v155.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_120;
    }
    goto LABEL_150;
  }
  operator delete(cf[0].__r_.__value_.__l.__data_);
  CFTypeRef v156 = v63;
  if (SHIBYTE(__src[0].__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_149;
  }
LABEL_119:
  if ((SHIBYTE(v155.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_120;
  }
LABEL_150:
  operator delete(v155.__r_.__value_.__l.__data_);
LABEL_120:
  *(void *)&long long v64 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v64 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&cf[11].__r_.__value_.__s.__data_[2] = v64;
  *(_OWORD *)&cf[10].__r_.__value_.__l.__data_ = v64;
  *(_OWORD *)&cf[10].__r_.__value_.__r.__words[2] = v64;
  *(_OWORD *)&cf[8].__r_.__value_.__r.__words[2] = v64;
  *(_OWORD *)&cf[9].__r_.__value_.__r.__words[1] = v64;
  *(_OWORD *)&cf[7].__r_.__value_.__r.__words[1] = v64;
  *(_OWORD *)&cf[8].__r_.__value_.__l.__data_ = v64;
  *(_OWORD *)&cf[6].__r_.__value_.__l.__data_ = v64;
  *(_OWORD *)&cf[6].__r_.__value_.__r.__words[2] = v64;
  *(_OWORD *)&cf[4].__r_.__value_.__r.__words[2] = v64;
  *(_OWORD *)&cf[5].__r_.__value_.__r.__words[1] = v64;
  *(_OWORD *)&cf[3].__r_.__value_.__r.__words[1] = v64;
  *(_OWORD *)&cf[4].__r_.__value_.__l.__data_ = v64;
  *(_OWORD *)&cf[2].__r_.__value_.__l.__data_ = v64;
  *(_OWORD *)&cf[2].__r_.__value_.__r.__words[2] = v64;
  *(_OWORD *)&cf[0].__r_.__value_.__r.__words[2] = v64;
  *(_OWORD *)&cf[1].__r_.__value_.__r.__words[1] = v64;
  *(_OWORD *)&cf[0].__r_.__value_.__l.__data_ = v64;
  uint64_t v65 = (capabilities::updater *)(**(void *(***)(std::string *__return_ptr))*a3)(cf);
  int v66 = capabilities::updater::EUICCVinylSuccessStatus(v65);
  if (LODWORD(cf[0].__r_.__value_.__l.__data_) != v66)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    uint64_t v75 = "hwType.Valid()";
    goto LABEL_129;
  }
  *(_OWORD *)&__src[0].__r_.__value_.__l.__data_ = xmmword_264489888;
  *(_OWORD *)&__src[0].__r_.__value_.__r.__words[2] = *(_OWORD *)&off_264489898;
  values = @"StartSession";
  *(void *)&long long v168 = v57;
  uint64_t v70 = @"0";
  if (cf[11].__r_.__value_.__s.__data_[15]) {
    uint64_t v70 = @"2";
  }
  *((void *)&v168 + 1) = v63;
  v169 = v70;
  int v71 = eUICC::Perso::PersoImplementation::SerializeKeyValuePairsIntoPlistData((const void **)&__src[0].__r_.__value_.__l.__data_, (const void **)&values, 4);
  if (v71)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
LABEL_125:
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v67, v68, v69, (char)"kBBUReturnSuccess == ret");
      goto LABEL_130;
    }
LABEL_283:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    goto LABEL_125;
  }
  values = operator new(0x20uLL);
  long long v168 = xmmword_21DFAB650;
  strcpy((char *)values, "InitPersoServerRequest.plist");
  v153 = 0;
  std::string v154 = 0;
  v152 = 0;
  long long v91 = __p;
  size_t v92 = v161 - (unsigned char *)__p;
  if (v161 != __p)
  {
    if ((v92 & 0x8000000000000000) != 0) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    v152 = operator new(v161 - (unsigned char *)__p);
    v153 = v152;
    long long v93 = (char *)v152 + v92;
    std::string v154 = (char *)v152 + v92;
    memcpy(v152, v91, v92);
    v153 = v93;
  }
  long long v94 = (std::string *)*((void *)v7 + 5);
  if ((unint64_t)v94 >= *((void *)v7 + 6))
  {
    uint64_t v95 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)v7 + 4, (long long *)&values, (uint64_t)&v152);
  }
  else
  {
    std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*((std::string **)v7 + 5), (long long *)&values, (uint64_t)&v152);
    uint64_t v95 = v94 + 2;
    *((void *)v7 + 5) = v94 + 2;
  }
  *((void *)v7 + 5) = v95;
  if (v152)
  {
    v153 = v152;
    operator delete(v152);
  }
  if (SHIBYTE(v168) < 0) {
    operator delete(values);
  }
  eUICC::Perso::PersoImplementation::PostDataSync((uint64_t)__src, v7, (uint64_t)&__p);
  long long v164 = *(_OWORD *)&__src[0].__r_.__value_.__l.__data_;
  std::string::size_type v102 = __src[0].__r_.__value_.__r.__words[0];
  if (!__src[0].__r_.__value_.__r.__words[0])
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v99, v100, v101, (char)"response");
    goto LABEL_210;
  }
  long long v150 = operator new(0x20uLL);
  long long v151 = xmmword_21DFA8ED0;
  strcpy((char *)v150, "InitPersoServerResponse.plist");
  (*(void (**)(CFTypeRef *__return_ptr, std::string::size_type))(*(void *)v102 + 40))(&v149, v102);
  eUICC::Perso::PersoImplementation::logTransactionCFData((uint64_t)v7, (long long *)&v150, (CFDataRef *)&v149);
  if (v149) {
    CFRelease(v149);
  }
  if (SHIBYTE(v151) < 0) {
    operator delete(v150);
  }
  (*(void (**)(CFTypeRef *__return_ptr, std::string::size_type))(*(void *)v102 + 40))(&v148, v102);
  int v71 = eUICC::Perso::PersoImplementation::CreateDictionaryFromPlistData((uint64_t *)&v148, &v165, v103, v104, v105, v106, v107, v108);
  if (v148) {
    CFRelease(v148);
  }
  if (v71)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_125;
    }
    goto LABEL_283;
  }
  if (v165) {
    uint64_t v109 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    uint64_t v109 = 0;
  }
  if (!v109)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    uint64_t v75 = "respDict";
LABEL_129:
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v67, v68, v69, (char)v75);
    int v71 = 18;
    goto LABEL_130;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v165, @"SessionId");
  CFStringRef v114 = Value;
  if (Value)
  {
    CFTypeID v115 = CFGetTypeID(Value);
    if (v115 == CFStringGetTypeID()) {
      CFRetain(v114);
    }
    else {
      CFStringRef v114 = 0;
    }
  }
  long long v118 = (const void *)*((void *)v7 + 2);
  *((void *)v7 + 2) = v114;
  if (v118)
  {
    CFRelease(v118);
    CFStringRef v114 = (const __CFString *)*((void *)v7 + 2);
  }
  if (v114) {
    uint64_t v119 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
  }
  else {
    uint64_t v119 = 0;
  }
  if (!v119 || !CFStringGetLength(v114))
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v111, v112, v113, (char)"this->serverSessionID && CFStringGetLength( this->serverSessionID.get()) != 0");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    ctu::cf::show((uint64_t *)__src, (ctu::cf *)v165, v128);
    if ((__src[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      CFRange v132 = __src;
    }
    else {
      LOBYTE(v132) = __src[0].__r_.__value_.__s.__data_[0];
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Missing or empty server sssion?! %s\n", v129, v130, v131, (char)v132);
    goto LABEL_257;
  }
  long long v120 = (ctu::cf *)v165;
  uint64_t v121 = CFDictionaryGetValue((CFDictionaryRef)v165, @"DATA");
  ctu::cf::CFSharedRef<__CFData const>::operator=<void const,void>(&v163, v121);
  if (v163) {
    uint64_t v125 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    uint64_t v125 = 0;
  }
  if (!v125)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v122, v123, v124, (char)"respDataPayload");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    ctu::cf::show((uint64_t *)__src, v120, v133);
    if ((__src[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      v137 = __src;
    }
    else {
      LOBYTE(v137) = __src[0].__r_.__value_.__s.__data_[0];
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Couldn't get response payload %s\n", v134, v135, v136, (char)v137);
LABEL_257:
    if (SHIBYTE(__src[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__src[0].__r_.__value_.__l.__data_);
    }
LABEL_210:
    int v71 = 53;
    goto LABEL_130;
  }
  memset(__src, 0, 24);
  ctu::cf::assign();
  long long v126 = *(_OWORD *)&__src[0].__r_.__value_.__l.__data_;
  std::string::size_type v127 = __src[0].__r_.__value_.__r.__words[2];
  if (v146[0])
  {
    v146[1] = v146[0];
    long long v144 = *(_OWORD *)&__src[0].__r_.__value_.__l.__data_;
    operator delete(v146[0]);
    long long v126 = v144;
  }
  int v71 = 0;
  *(_OWORD *)v146 = v126;
  std::string::size_type v147 = v127;
LABEL_130:
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "InitPersoServer %d\n", v72, v73, v74, v71);
  if (v156) {
    CFRelease(v156);
  }
  if (v159) {
    CFRelease(v159);
  }
  if (__p)
  {
    CFRange v161 = __p;
    operator delete(__p);
  }
  if (v163) {
    CFRelease(v163);
  }
  long long v79 = (std::__shared_weak_count *)*((void *)&v164 + 1);
  if (*((void *)&v164 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v164 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
    std::__shared_weak_count::__release_weak(v79);
  }
  if (v165) {
    CFRelease(v165);
  }
  if (v71 || v146[0] == v146[1])
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
LABEL_147:
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v76, v77, v78, (char)"kBBUReturnSuccess == ret && !dataBuffer.empty()");
      uint64_t v30 = 53;
      goto LABEL_81;
    }
LABEL_308:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    goto LABEL_147;
  }
  if (eUICC::Perso::PersoImplementation::AuthenticatePersoDevice((uint64_t)v7, (uint64_t)v146, a3)
    || v146[0] == v146[1])
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_79;
    }
    goto LABEL_274;
  }
  if (eUICC::Perso::PersoImplementation::GetWrapKeyServer((uint64_t)v7, (uint64_t)v146)
    || v146[0] == v146[1])
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_147;
    }
    goto LABEL_308;
  }
  uint64_t v30 = eUICC::Perso::PersoImplementation::FinalizePersoDevice((uint64_t)v7, (uint64_t)v146, a3);
  if (v30)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
LABEL_228:
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v27, v28, v29, (char)"kBBUReturnSuccess == ret");
      goto LABEL_81;
    }
LABEL_301:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    goto LABEL_228;
  }
  ctu::cf::CFSharedRef<__CFString const>::reset((const void **)v7 + 2);
  if (eUICC::Perso::PersoImplementation::GetNonceServer((uint64_t)v7, (uint64_t)v146, (void *(***)(_OWORD *__return_ptr, void))*a3)|| v146[0] == v146[1])
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_147;
    }
    goto LABEL_308;
  }
  if (eUICC::Perso::PersoImplementation::CreateValidationBlob(v146) || v146[0] == v146[1])
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_147;
    }
    goto LABEL_308;
  }
  if (eUICC::Perso::PersoImplementation::ValidatePersoDevice((uint64_t)v7, (uint64_t)v146, a3)
    || v146[0] == v146[1])
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_147;
    }
    goto LABEL_308;
  }
  uint64_t v30 = eUICC::Perso::PersoImplementation::SendReceiptServer((uint64_t)v7, (uint64_t)v146);
  if (v30)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_228;
    }
    goto LABEL_301;
  }
  uint64_t v138 = *((void *)v7 + 4);
  for (uint64_t i = *((void *)v7 + 5); i != v138; i -= 48)
  {
    v140 = *(void **)(i - 24);
    if (v140)
    {
      *(void *)(i - 16) = v140;
      operator delete(v140);
    }
    if (*(char *)(i - 25) < 0) {
      operator delete(*(void **)(i - 48));
    }
  }
  uint64_t v30 = 0;
  *((void *)v7 + 5) = v138;
LABEL_81:
  size_t v49 = (const void *)*((void *)v7 + 2);
  *((void *)v7 + 2) = 0;
  if (v49) {
    CFRelease(v49);
  }
  *((void *)v7 + 3) = 0;
  int v50 = *(NSObject **)v7;
  *(void *)size_t v7 = 0;
  if (v50) {
    dispatch_release(v50);
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "ret %d records %zu\n", v27, v28, v29, v30);
  if (v146[0])
  {
    v146[1] = v146[0];
    operator delete(v146[0]);
  }
  if (v145 && !atomic_fetch_add(&v145->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
    std::__shared_weak_count::__release_weak(v145);
  }
  return v30;
}

void sub_21DEE5464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,const void *a32,void *a33,uint64_t a34,uint64_t a35,const void *a36,void *a37,uint64_t a38,uint64_t a39,const void *a40,__int16 a41,uint64_t a42,uint64_t a43,const void *a44,void *__p,uint64_t a46,int a47,__int16 a48,char a49,char a50)
{
  if (a50 < 0) {
    operator delete(__p);
  }
  ctu::cf::CFSharedRef<__CFString const>::~CFSharedRef(&a32);
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(&a36);
  if (a37)
  {
    a38 = (uint64_t)a37;
    operator delete(a37);
  }
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(&a40);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a41);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(&a44);
  if (!a17)
  {
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
    _Unwind_Resume(a1);
  }
  a18 = (uint64_t)a17;
  operator delete(a17);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void eUICC::Perso::DumpTransactions(void *a1@<X8>)
{
  pthread_mutex_lock(&ctu::Singleton<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation,ctu::PthreadMutexGuardPolicy<eUICC::Perso::PersoImplementation>>::sInstance);
  if (qword_26AA89B00) {
    goto LABEL_2;
  }
  unint64_t v4 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
  v4->__on_zero_shared_weauint64_t k = 0;
  v4[1].~__shared_weak_count = 0;
  v4[1].~__shared_weak_count_0 = 0;
  v4->~__shared_weak_count_0 = 0;
  v4->__on_zero_shared = 0;
  v4->~__shared_weak_count = 0;
  uint64_t v3 = (std::__shared_weak_count *)operator new(0x20uLL);
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CECA790;
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3[1].__vftable = v4;
  uint64_t v5 = (std::__shared_weak_count *)off_26AA89B08;
  qword_26AA89B00 = (uint64_t)v4;
  off_26AA89B08 = v3;
  if (v5)
  {
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
LABEL_2:
    unint64_t v4 = (std::__shared_weak_count_vtbl *)qword_26AA89B00;
    uint64_t v3 = (std::__shared_weak_count *)off_26AA89B08;
    uint64_t v6 = (std::__shared_weak_count *)off_26AA89B08;
    if (!off_26AA89B08) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v6 = v3;
LABEL_8:
  atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_9:
  pthread_mutex_unlock(&ctu::Singleton<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation,ctu::PthreadMutexGuardPolicy<eUICC::Perso::PersoImplementation>>::sInstance);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<std::pair<std::string,std::vector<unsigned char>>>::__init_with_size[abi:ne180100]<std::pair<std::string,std::vector<unsigned char>>*,std::pair<std::string,std::vector<unsigned char>>*>(a1, (uint64_t)v4->__on_zero_shared_weak, (uint64_t)v4[1].~__shared_weak_count, 0xAAAAAAAAAAAAAAABLL * (((char *)v4[1].~__shared_weak_count - (char *)v4->__on_zero_shared_weak) >> 4));
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_21DEE5978(_Unwind_Exception *a1)
{
  eUICC::Perso::PersoImplementation::~PersoImplementation(v1);
  operator delete(v3);
  pthread_mutex_unlock(&ctu::Singleton<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation,ctu::PthreadMutexGuardPolicy<eUICC::Perso::PersoImplementation>>::sInstance);
  _Unwind_Resume(a1);
}

void sub_21DEE59A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t eUICC::Perso::PersoImplementation::AuthenticatePersoDevice(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v39 = (char *)operator new(0x28uLL);
  long long v40 = xmmword_21DFAB660;
  strcpy(v39, "AuthenticatePersoDeviceRequest.bin");
  int v37 = 0;
  uint64_t v38 = 0;
  std::string __p = 0;
  size_t v7 = *(const void **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  size_t v8 = v6 - *(void *)a2;
  if (v6 != *(void *)a2)
  {
    if ((v8 & 0x8000000000000000) != 0) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = (char *)operator new(v6 - *(void *)a2);
    uint64_t v10 = &v9[v8];
    std::string __p = v9;
    uint64_t v38 = &v9[v8];
    memcpy(v9, v7, v8);
    int v37 = v10;
  }
  uint64_t v11 = *(std::string **)(a1 + 40);
  if ((unint64_t)v11 >= *(void *)(a1 + 48))
  {
    dispatch_queue_t v12 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)(a1 + 32), (long long *)&v39, (uint64_t)&__p);
  }
  else
  {
    std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*(std::string **)(a1 + 40), (long long *)&v39, (uint64_t)&__p);
    dispatch_queue_t v12 = v11 + 2;
    *(void *)(a1 + 40) = v11 + 2;
  }
  *(void *)(a1 + 40) = v12;
  if (__p)
  {
    int v37 = __p;
    operator delete(__p);
  }
  if (SHIBYTE(v40) < 0) {
    operator delete(v39);
  }
  uint64_t v16 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*a3 + 64))(*a3, a2, a2);
  if (v16)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v13, v14, v15, (char)"kBBUReturnSuccess == ret");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to complete AuthPerso command\n", v17, v18, v19, v30);
  }
  else
  {
    uint64_t v33 = 0;
    uint64_t v34 = operator new(0x28uLL);
    long long v35 = xmmword_21DFA8EB0;
    strcpy((char *)v34, "AuthenticatePersoDeviceResponse.bin");
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    uint64_t v23 = *(const void **)a2;
    size_t v24 = *(void *)(a2 + 8) - *(void *)a2;
    if (v24)
    {
      if ((v24 & 0x8000000000000000) != 0) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v25 = (char *)operator new(v24);
      size_t v26 = &v25[v24];
      uint64_t v31 = v25;
      uint64_t v33 = &v25[v24];
      memcpy(v25, v23, v24);
      uint64_t v32 = v26;
    }
    uint64_t v27 = *(std::string **)(a1 + 40);
    if ((unint64_t)v27 >= *(void *)(a1 + 48))
    {
      uint64_t v28 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)(a1 + 32), (long long *)&v34, (uint64_t)&v31);
    }
    else
    {
      std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*(std::string **)(a1 + 40), (long long *)&v34, (uint64_t)&v31);
      uint64_t v28 = v27 + 2;
      *(void *)(a1 + 40) = v27 + 2;
    }
    *(void *)(a1 + 40) = v28;
    if (v31)
    {
      uint64_t v32 = v31;
      operator delete(v31);
    }
    if (SHIBYTE(v35) < 0) {
      operator delete(v34);
    }
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "AuthenticatePersoDevice %d\n", v20, v21, v22, v16);
  return v16;
}

void sub_21DEE5CE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t eUICC::Perso::PersoImplementation::GetWrapKeyServer(uint64_t a1, uint64_t a2)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  CFDictionaryRef v73 = 0;
  int v71 = 0;
  long long v72 = 0uLL;
  std::string __p = 0;
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  int v66 = 0;
  unint64_t v67 = 0xAAAAAAAAAAAAAAAALL;
  long long v64 = 0;
  uint64_t v65 = 0;
  uint64_t v5 = *(const void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  size_t v6 = v4 - *(void *)a2;
  if (v4 == *(void *)a2)
  {
    size_t v8 = 0;
    size_t v7 = 0;
    uint64_t v75 = 0;
    values[0] = 0;
    long long v74 = 0uLL;
  }
  else
  {
    if ((v6 & 0x8000000000000000) != 0) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    size_t v7 = (char *)operator new(v4 - *(void *)a2);
    long long v64 = v7;
    int v66 = &v7[v6];
    memcpy(v7, v5, v6);
    uint64_t v65 = &v7[v6];
    size_t v8 = operator new(v6);
    memcpy(v8, v7, v6);
    values[0] = 0;
    uint64_t v9 = (char *)operator new(v6);
    uint64_t v10 = &v9[v6];
    *(void *)&long long v74 = v9;
    uint64_t v75 = &v9[v6];
    memcpy(v9, v7, v6);
    *((void *)&v74 + 1) = v10;
  }
  keys[0] = 0;
  if (!ctu::cf::convert_copy())
  {
    uint64_t v11 = 0;
    dispatch_queue_t v12 = (void *)v74;
    if (!(void)v74) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v11 = keys[0];
  values[0] = keys[0];
  dispatch_queue_t v12 = (void *)v74;
  if ((void)v74)
  {
LABEL_9:
    *((void *)&v74 + 1) = v12;
    operator delete(v12);
  }
LABEL_10:
  unint64_t v67 = (unint64_t)v11;
  values[0] = 0;
  if (v8) {
    operator delete(v8);
  }
  if (v7)
  {
    uint64_t v65 = v7;
    operator delete(v7);
  }
  *(_OWORD *)keys = xmmword_2644898B8;
  uint64_t v78 = @"SessionId";
  values[0] = @"GetWrapKey";
  values[1] = v11;
  values[2] = *(void **)(a1 + 16);
  uint64_t DictionaryFromPlistData = eUICC::Perso::PersoImplementation::SerializeKeyValuePairsIntoPlistData((const void **)keys, (const void **)values, 3);
  if (DictionaryFromPlistData)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v13, v14, v15, (char)"kBBUReturnSuccess == ret");
    uint64_t v20 = 0;
LABEL_18:
    uint64_t v21 = 0;
    goto LABEL_19;
  }
  uint64_t v61 = 0;
  int v62 = operator new(0x20uLL);
  long long v63 = xmmword_21DFA8ED0;
  strcpy((char *)v62, "GetWrapKeyServerRequest.plist");
  size_t v59 = 0;
  size_t v60 = 0;
  size_t v24 = *(std::string **)(a1 + 40);
  if ((unint64_t)v24 >= *(void *)(a1 + 48))
  {
    uint64_t v25 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)(a1 + 32), (long long *)&v62, (uint64_t)&v59);
  }
  else
  {
    std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*(std::string **)(a1 + 40), (long long *)&v62, (uint64_t)&v59);
    uint64_t v25 = v24 + 2;
    *(void *)(a1 + 40) = v24 + 2;
  }
  *(void *)(a1 + 40) = v25;
  if (v59)
  {
    size_t v60 = v59;
    operator delete(v59);
  }
  if (SHIBYTE(v63) < 0) {
    operator delete(v62);
  }
  eUICC::Perso::PersoImplementation::PostDataSync((uint64_t)&v74, (void *)a1, (uint64_t)&__p);
  uint64_t v20 = (std::__shared_weak_count *)*((void *)&v74 + 1);
  uint64_t v29 = v74;
  long long v72 = v74;
  if ((void)v74)
  {
    int v57 = operator new(0x20uLL);
    long long v58 = xmmword_21DFAB670;
    strcpy((char *)v57, "GetWrapKeyServerResponse.plist");
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v29 + 40))(&cf, v29);
    eUICC::Perso::PersoImplementation::logTransactionCFData(a1, (long long *)&v57, (CFDataRef *)&cf);
    if (cf) {
      CFRelease(cf);
    }
    if (SHIBYTE(v58) < 0) {
      operator delete(v57);
    }
    (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v29 + 40))(&v55, v29);
    uint64_t DictionaryFromPlistData = eUICC::Perso::PersoImplementation::CreateDictionaryFromPlistData((uint64_t *)&v55, (const void **)&v73, v30, v31, v32, v33, v34, v35);
    if (v55) {
      CFRelease(v55);
    }
    if (DictionaryFromPlistData)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v36, v37, v38, (char)"kBBUReturnSuccess == ret");
      goto LABEL_18;
    }
    uint64_t v39 = v73;
    CFStringRef Value = CFDictionaryGetValue(v73, @"DATA");
    uint64_t v21 = Value;
    if (Value)
    {
      CFTypeID v44 = CFGetTypeID(Value);
      if (v44 != CFDataGetTypeID())
      {
        uint64_t v21 = 0;
        int v71 = 0;
LABEL_64:
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v41, v42, v43, (char)"respDataPayload");
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        ctu::cf::show((uint64_t *)&v74, v39, v49);
        if (SHIBYTE(v75) >= 0) {
          size_t v53 = &v74;
        }
        else {
          LOBYTE(v53) = v74;
        }
        _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Couldn't get response payload %s\n", v50, v51, v52, (char)v53);
        if (SHIBYTE(v75) < 0) {
          operator delete((void *)v74);
        }
        uint64_t DictionaryFromPlistData = 53;
        goto LABEL_19;
      }
      CFRetain(v21);
    }
    int v71 = v21;
    if (v21) {
      uint64_t v45 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
    }
    else {
      uint64_t v45 = 0;
    }
    if (v45)
    {
      long long v74 = 0uLL;
      uint64_t v75 = 0;
      ctu::cf::assign();
      long long v46 = v74;
      uint64_t v47 = v75;
      int v48 = *(void **)a2;
      if (*(void *)a2)
      {
        *(void *)(a2 + 8) = v48;
        long long v54 = v46;
        operator delete(v48);
        long long v46 = v54;
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
      }
      uint64_t DictionaryFromPlistData = 0;
      *(_OWORD *)a2 = v46;
      *(void *)(a2 + 16) = v47;
      goto LABEL_19;
    }
    goto LABEL_64;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v26, v27, v28, (char)"response");
  uint64_t v21 = 0;
  uint64_t DictionaryFromPlistData = 53;
LABEL_19:
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "GetWrapKeyServer %d\n", v17, v18, v19, DictionaryFromPlistData);
  if (__p)
  {
    uint64_t v69 = __p;
    operator delete(__p);
  }
  if (v21)
  {
    CFRelease(v21);
    uint64_t v20 = (std::__shared_weak_count *)*((void *)&v72 + 1);
  }
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
    CFDictionaryRef v22 = v73;
    if (!v73) {
      return DictionaryFromPlistData;
    }
    goto LABEL_28;
  }
  CFDictionaryRef v22 = v73;
  if (v73) {
LABEL_28:
  }
    CFRelease(v22);
  return DictionaryFromPlistData;
}

void sub_21DEE64A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,uint64_t a37,char a38,void *__p,uint64_t a40)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t eUICC::Perso::PersoImplementation::FinalizePersoDevice(uint64_t a1, uint64_t a2, void *a3)
{
  size_t v24 = 0;
  uint64_t v25 = operator new(0x20uLL);
  long long v26 = xmmword_21DFAB670;
  strcpy((char *)v25, "FinalizePersoDeviceRequest.bin");
  std::string __p = 0;
  uint64_t v23 = 0;
  size_t v7 = *(const void **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  size_t v8 = v6 - *(void *)a2;
  if (v6 != *(void *)a2)
  {
    if ((v8 & 0x8000000000000000) != 0) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = (char *)operator new(v6 - *(void *)a2);
    uint64_t v10 = &v9[v8];
    std::string __p = v9;
    size_t v24 = &v9[v8];
    memcpy(v9, v7, v8);
    uint64_t v23 = v10;
  }
  uint64_t v11 = *(std::string **)(a1 + 40);
  if ((unint64_t)v11 >= *(void *)(a1 + 48))
  {
    dispatch_queue_t v12 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)(a1 + 32), (long long *)&v25, (uint64_t)&__p);
  }
  else
  {
    std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*(std::string **)(a1 + 40), (long long *)&v25, (uint64_t)&__p);
    dispatch_queue_t v12 = v11 + 2;
    *(void *)(a1 + 40) = v11 + 2;
  }
  *(void *)(a1 + 40) = v12;
  if (__p)
  {
    uint64_t v23 = __p;
    operator delete(__p);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25);
  }
  uint64_t v16 = (*(uint64_t (**)(void, uint64_t))(*(void *)*a3 + 72))(*a3, a2);
  if (v16)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v13, v14, v15, (char)"kBBUReturnSuccess == ret");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to complete FinalizePerso command\n", v17, v18, v19, v21);
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "FinalizePersoDevice %d\n", v13, v14, v15, v16);
  return v16;
}

void sub_21DEE6864(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (__p)
  {
    operator delete(__p);
    if ((a21 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a21 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a16);
  _Unwind_Resume(exception_object);
}

void ctu::cf::CFSharedRef<__CFString const>::reset(const void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2) {
    CFRelease(v2);
  }
}

uint64_t eUICC::Perso::PersoImplementation::GetNonceServer(uint64_t a1, uint64_t a2, void *(***a3)(_OWORD *__return_ptr, void))
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  CFTypeRef v79 = 0;
  long long v78 = 0uLL;
  uint64_t v76 = 0;
  CFTypeRef cf = 0;
  std::string __p = 0;
  uint64_t v75 = 0;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v82[10] = v5;
  v81[15] = v5;
  *(_OWORD *)uint64_t v82 = v5;
  v81[13] = v5;
  v81[14] = v5;
  v81[11] = v5;
  v81[12] = v5;
  v81[9] = v5;
  v81[10] = v5;
  v81[7] = v5;
  v81[8] = v5;
  v81[5] = v5;
  v81[6] = v5;
  _OWORD v81[3] = v5;
  v81[4] = v5;
  v81[1] = v5;
  v81[2] = v5;
  v81[0] = v5;
  uint64_t v6 = (capabilities::updater *)(**a3)(v81, a3);
  int v7 = capabilities::updater::EUICCVinylSuccessStatus(v6);
  if (LODWORD(v81[0]) == v7)
  {
    long long keys = xmmword_2644898A8;
    if (v82[23]) {
      uint64_t v11 = @"2";
    }
    else {
      uint64_t v11 = @"0";
    }
    values[0] = @"GetNonce";
    values[1] = v11;
    uint64_t v15 = eUICC::Perso::PersoImplementation::SerializeKeyValuePairsIntoPlistData((const void **)&keys, (const void **)values, 2);
    if (v15)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v12, v13, v14, (char)"kBBUReturnSuccess == ret");
      goto LABEL_12;
    }
    uint64_t v71 = 0;
    long long v72 = operator new(0x20uLL);
    long long v73 = xmmword_21DFAB640;
    strcpy((char *)v72, "GetNonceServerRequest.plist");
    uint64_t v69 = 0;
    uint64_t v70 = 0;
    CFDictionaryRef v22 = *(std::string **)(a1 + 40);
    if ((unint64_t)v22 >= *(void *)(a1 + 48))
    {
      uint64_t v23 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)(a1 + 32), (long long *)&v72, (uint64_t)&v69);
    }
    else
    {
      std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*(std::string **)(a1 + 40), (long long *)&v72, (uint64_t)&v69);
      uint64_t v23 = v22 + 2;
      *(void *)(a1 + 40) = v22 + 2;
    }
    *(void *)(a1 + 40) = v23;
    if (v69)
    {
      uint64_t v70 = v69;
      operator delete(v69);
    }
    if (SHIBYTE(v73) < 0) {
      operator delete(v72);
    }
    eUICC::Perso::PersoImplementation::PostDataSync((uint64_t)&keys, (void *)a1, (uint64_t)&__p);
    long long v78 = keys;
    uint64_t v27 = keys;
    if ((void)keys)
    {
      unint64_t v67 = operator new(0x20uLL);
      long long v68 = xmmword_21DFAB650;
      strcpy((char *)v67, "GetNonceServerResponse.plist");
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v27 + 40))(&v66, v27);
      eUICC::Perso::PersoImplementation::logTransactionCFData(a1, (long long *)&v67, (CFDataRef *)&v66);
      if (v66) {
        CFRelease(v66);
      }
      if (SHIBYTE(v68) < 0) {
        operator delete(v67);
      }
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t))(*(void *)v27 + 40))(&v65, v27);
      uint64_t v15 = eUICC::Perso::PersoImplementation::CreateDictionaryFromPlistData((uint64_t *)&v65, &v79, v28, v29, v30, v31, v32, v33);
      if (v65) {
        CFRelease(v65);
      }
      if (v15)
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v34, v35, v36, (char)"kBBUReturnSuccess == ret");
        goto LABEL_12;
      }
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v79, @"SessionId");
      CFStringRef v41 = Value;
      if (Value)
      {
        CFTypeID v42 = CFGetTypeID(Value);
        if (v42 == CFStringGetTypeID()) {
          CFRetain(v41);
        }
        else {
          CFStringRef v41 = 0;
        }
      }
      uint64_t v43 = *(const void **)(a1 + 16);
      *(void *)(a1 + 16) = v41;
      if (v43)
      {
        CFRelease(v43);
        CFStringRef v41 = *(const __CFString **)(a1 + 16);
      }
      if (v41) {
        CFTypeID v44 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
      }
      else {
        CFTypeID v44 = 0;
      }
      if (v44 && CFStringGetLength(v41))
      {
        uint64_t v45 = (ctu::cf *)v79;
        long long v46 = CFDictionaryGetValue((CFDictionaryRef)v79, @"DATA");
        ctu::cf::CFSharedRef<__CFData const>::operator=<void const,void>(&cf, v46);
        if (cf) {
          uint64_t v50 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
        }
        else {
          uint64_t v50 = 0;
        }
        if (v50)
        {
          long long keys = 0uLL;
          uint64_t v84 = 0;
          ctu::cf::assign();
          long long v51 = keys;
          uint64_t v52 = v84;
          size_t v53 = *(void **)a2;
          if (*(void *)a2)
          {
            *(void *)(a2 + 8) = v53;
            long long v64 = v51;
            operator delete(v53);
            long long v51 = v64;
            *(void *)a2 = 0;
            *(void *)(a2 + 8) = 0;
            *(void *)(a2 + 16) = 0;
          }
          uint64_t v15 = 0;
          *(_OWORD *)a2 = v51;
          *(void *)(a2 + 16) = v52;
          goto LABEL_12;
        }
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v47, v48, v49, (char)"respDataPayload");
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        ctu::cf::show((uint64_t *)&keys, v45, v59);
        if (v84 >= 0) {
          p_long long keys = &keys;
        }
        else {
          LOBYTE(p_keys) = keys;
        }
        _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Couldn't get response payload %s\n", v60, v61, v62, (char)p_keys);
      }
      else
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v38, v39, v40, (char)"this->serverSessionID && CFStringGetLength( this->serverSessionID.get()) != 0");
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        ctu::cf::show((uint64_t *)&keys, (ctu::cf *)v79, v54);
        if (v84 >= 0) {
          long long v58 = &keys;
        }
        else {
          LOBYTE(v58) = keys;
        }
        _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Missing or empty server sssion?! %s\n", v55, v56, v57, (char)v58);
      }
      if (SHIBYTE(v84) < 0) {
        operator delete((void *)keys);
      }
    }
    else
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v24, v25, v26, (char)"response");
    }
    uint64_t v15 = 53;
    goto LABEL_12;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v8, v9, v10, (char)"hwType.Valid()");
  uint64_t v15 = 18;
LABEL_12:
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "GetNonceServer %d\n", v16, v17, v18, v15);
  if (__p)
  {
    uint64_t v75 = __p;
    operator delete(__p);
  }
  if (cf) {
    CFRelease(cf);
  }
  uint64_t v19 = (std::__shared_weak_count *)*((void *)&v78 + 1);
  if (*((void *)&v78 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v78 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
    CFTypeRef v20 = v79;
    if (!v79) {
      return v15;
    }
    goto LABEL_21;
  }
  CFTypeRef v20 = v79;
  if (v79) {
LABEL_21:
  }
    CFRelease(v20);
  return v15;
}

void sub_21DEE7100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *__p,uint64_t a37,uint64_t a38,const void *a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,const void *a45)
{
  if (*(char *)(v45 - 73) < 0) {
    operator delete(*(void **)(v45 - 96));
  }
  if (__p) {
    operator delete(__p);
  }
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef(&a39);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a40);
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef(&a45);
  _Unwind_Resume(a1);
}

uint64_t eUICC::Perso::PersoImplementation::CreateValidationBlob(void *a1)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (BBUpdaterCommon::getECID(void)::sOnce != -1) {
    dispatch_once(&BBUpdaterCommon::getECID(void)::sOnce, &__block_literal_global_18);
  }
  uint64_t v43 = BBUpdaterCommon::getECID(void)::ecid;
  char v42 = 4;
  int v41 = 17433507;
  v44[0] = 0;
  v44[2] = 512;
  *(_OWORD *)&v45[8] = 0u;
  v44[1] = 12;
  *(_OWORD *)uint64_t v45 = xmmword_21DFAB680;
  *(_WORD *)&v45[16] = 512;
  v40[0] = v44;
  v40[1] = 0xAAAAAAAAAAAA0002;
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v38 = v2;
  long long v39 = v2;
  long long v36 = v2;
  long long v37 = v2;
  long long v34 = v2;
  long long v35 = v2;
  long long v32 = v2;
  long long v33 = v2;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  CFTypeRef v20 = 0;
  char v21 = 0;
  uint64_t v22 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  std::string __p = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v3 = a1[1] - *a1;
  v9[0] = *a1;
  v9[1] = v3;
  memset(v10, 170, sizeof(v10));
  int v7 = DERDecodeItem((uint64_t)v9, v10);
  if (v7)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }
  int v7 = DEREncodeItemIntoVector(0xCuLL, 6uLL, "kNonce", (uint64_t)&v20);
  if (v7)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }
  *(void *)&long long v36 = v20;
  *((void *)&v36 + 1) = v21 - (unsigned char *)v20;
  long long v37 = *(_OWORD *)&v10[1];
  int v7 = DEREncodeSequenceIntoVector(0x2000000000000010, (unint64_t)&v36, (uint64_t)v40, (uint64_t)&v26);
  if (v7)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }
  int v7 = DEREncodeItemIntoVector(0xCuLL, 0x11uLL, "kDeviceIdentifier", (uint64_t)&v29);
  if (v7)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }
  int v7 = DEREncodeItemIntoVector(4uLL, 8uLL, &v43, (uint64_t)&v23);
  if (v7)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }
  *(void *)&long long v38 = v29;
  *((void *)&v38 + 1) = v30 - (unsigned char *)v29;
  *(void *)&long long v39 = v23;
  *((void *)&v39 + 1) = v24 - (unsigned char *)v23;
  int v7 = DEREncodeSequenceIntoVector(0x2000000000000010, (unint64_t)&v38, (uint64_t)v40, (uint64_t)&v17);
  if (v7)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }
  *(void *)&long long v34 = v17;
  *((void *)&v34 + 1) = v18 - (unsigned char *)v17;
  *(void *)&long long v35 = v26;
  *((void *)&v35 + 1) = v27 - (unsigned char *)v26;
  int v7 = DEREncodeSequenceIntoVector(0x2000000000000010, (unint64_t)&v34, (uint64_t)v40, (uint64_t)&v14);
  if (v7)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }
  int v7 = DEREncodeItemIntoVector(0xA000000000000005, v15 - (unsigned char *)v14, v14, (uint64_t)&__p);
  if (v7)
  {
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_29;
    }
    goto LABEL_49;
  }
  *(void *)&long long v32 = &v41;
  *((void *)&v32 + 1) = 5;
  *(void *)&long long v33 = __p;
  *((void *)&v33 + 1) = v12 - (unsigned char *)__p;
  int v7 = DEREncodeSequenceIntoVector(0x2000000000000010, (unint64_t)&v32, (uint64_t)v40, (uint64_t)a1);
  if (!v7) {
    goto LABEL_30;
  }
  if (gBBULogMaskGet(void)::once != -1) {
LABEL_49:
  }
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
LABEL_29:
  _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v4, v5, v6, (char)"DR_Success == ret");
LABEL_30:
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "CreateValidationBlob DR %d\n", v4, v5, v6, v7);
  if (__p)
  {
    uint64_t v12 = __p;
    operator delete(__p);
  }
  if (v14)
  {
    uint64_t v15 = v14;
    operator delete(v14);
  }
  if (v17)
  {
    uint64_t v18 = v17;
    operator delete(v17);
  }
  if (v20)
  {
    char v21 = v20;
    operator delete(v20);
  }
  if (v23)
  {
    uint64_t v24 = v23;
    operator delete(v23);
  }
  if (v26)
  {
    uint64_t v27 = v26;
    operator delete(v26);
  }
  if (v29)
  {
    uint64_t v30 = v29;
    operator delete(v29);
  }
  if (v7) {
    return 11;
  }
  else {
    return 0;
  }
}

void sub_21DEE78EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37)
{
  if (__p)
  {
    operator delete(__p);
    long long v38 = a21;
    if (!a21)
    {
LABEL_3:
      long long v39 = a24;
      if (!a24) {
        goto LABEL_4;
      }
      goto LABEL_11;
    }
  }
  else
  {
    long long v38 = a21;
    if (!a21) {
      goto LABEL_3;
    }
  }
  operator delete(v38);
  long long v39 = a24;
  if (!a24)
  {
LABEL_4:
    uint64_t v40 = a27;
    if (!a27) {
      goto LABEL_5;
    }
    goto LABEL_12;
  }
LABEL_11:
  operator delete(v39);
  uint64_t v40 = a27;
  if (!a27)
  {
LABEL_5:
    int v41 = a30;
    if (!a30) {
      goto LABEL_6;
    }
    goto LABEL_13;
  }
LABEL_12:
  operator delete(v40);
  int v41 = a30;
  if (!a30)
  {
LABEL_6:
    char v42 = a33;
    if (!a33) {
      goto LABEL_7;
    }
    goto LABEL_14;
  }
LABEL_13:
  operator delete(v41);
  char v42 = a33;
  if (!a33)
  {
LABEL_7:
    uint64_t v43 = a36;
    if (!a36) {
      goto LABEL_8;
    }
    goto LABEL_15;
  }
LABEL_14:
  operator delete(v42);
  uint64_t v43 = a36;
  if (!a36) {
LABEL_8:
  }
    _Unwind_Resume(exception_object);
LABEL_15:
  operator delete(v43);
  _Unwind_Resume(exception_object);
}

uint64_t eUICC::Perso::PersoImplementation::ValidatePersoDevice(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v24 = 0;
  uint64_t v25 = operator new(0x20uLL);
  long long v26 = xmmword_21DFAB670;
  strcpy((char *)v25, "ValidatePersoDeviceRequest.bin");
  std::string __p = 0;
  uint64_t v23 = 0;
  int v7 = *(const void **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  size_t v8 = v6 - *(void *)a2;
  if (v6 != *(void *)a2)
  {
    if ((v8 & 0x8000000000000000) != 0) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v9 = (char *)operator new(v6 - *(void *)a2);
    uint64_t v10 = &v9[v8];
    std::string __p = v9;
    uint64_t v24 = &v9[v8];
    memcpy(v9, v7, v8);
    uint64_t v23 = v10;
  }
  uint64_t v11 = *(std::string **)(a1 + 40);
  if ((unint64_t)v11 >= *(void *)(a1 + 48))
  {
    uint64_t v12 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)(a1 + 32), (long long *)&v25, (uint64_t)&__p);
  }
  else
  {
    std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*(std::string **)(a1 + 40), (long long *)&v25, (uint64_t)&__p);
    uint64_t v12 = v11 + 2;
    *(void *)(a1 + 40) = v11 + 2;
  }
  *(void *)(a1 + 40) = v12;
  if (__p)
  {
    uint64_t v23 = __p;
    operator delete(__p);
  }
  if (SHIBYTE(v26) < 0) {
    operator delete(v25);
  }
  uint64_t v16 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*a3 + 80))(*a3, a2, a2);
  if (v16)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v13, v14, v15, (char)"kBBUReturnSuccess == ret");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to complete ValidatePerso command\n", v17, v18, v19, v21);
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "ValidatePersoDevice %d\n", v13, v14, v15, v16);
  return v16;
}

void sub_21DEE7BE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (__p)
  {
    operator delete(__p);
    if ((a21 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a21 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a16);
  _Unwind_Resume(exception_object);
}

uint64_t eUICC::Perso::PersoImplementation::SendReceiptServer(uint64_t a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  char v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v40 = 0;
  unint64_t v41 = 0xAAAAAAAAAAAAAAAALL;
  long long v38 = 0;
  long long v39 = 0;
  uint64_t v5 = *(const void **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  size_t v6 = v4 - *(void *)a2;
  if (v4 == *(void *)a2)
  {
    size_t v8 = 0;
    int v7 = 0;
    uint64_t v31 = 0;
    keys[0] = 0;
    keys[1] = 0;
    uint64_t v49 = 0;
  }
  else
  {
    if ((v6 & 0x8000000000000000) != 0) {
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    }
    int v7 = (char *)operator new(v4 - *(void *)a2);
    long long v38 = v7;
    uint64_t v40 = &v7[v6];
    memcpy(v7, v5, v6);
    long long v39 = &v7[v6];
    size_t v8 = operator new(v6);
    memcpy(v8, v7, v6);
    uint64_t v31 = 0;
    uint64_t v9 = (char *)operator new(v6);
    uint64_t v10 = &v9[v6];
    keys[0] = v9;
    uint64_t v49 = (__CFString *)&v9[v6];
    memcpy(v9, v7, v6);
    keys[1] = v10;
  }
  values[0] = 0;
  if (!ctu::cf::convert_copy())
  {
    uint64_t v11 = 0;
    uint64_t v12 = keys[0];
    if (!keys[0]) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v11 = values[0];
  uint64_t v31 = values[0];
  uint64_t v12 = keys[0];
  if (keys[0])
  {
LABEL_9:
    keys[1] = v12;
    operator delete(v12);
  }
LABEL_10:
  unint64_t v41 = (unint64_t)v11;
  uint64_t v31 = 0;
  if (v8) {
    operator delete(v8);
  }
  if (v7)
  {
    long long v39 = v7;
    operator delete(v7);
  }
  *(_OWORD *)long long keys = xmmword_2644898B8;
  uint64_t v49 = @"SessionId";
  values[0] = @"SendReceipt";
  values[1] = v11;
  values[2] = *(void **)(a1 + 16);
  uint64_t v16 = eUICC::Perso::PersoImplementation::SerializeKeyValuePairsIntoPlistData((const void **)keys, (const void **)values, 3);
  if (v16)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v13, v14, v15, (char)"kBBUReturnSuccess == ret");
    CFTypeRef v20 = 0;
    if (gBBULogMaskGet(void)::once != -1) {
LABEL_41:
    }
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  else
  {
    uint64_t v35 = 0;
    long long v36 = operator new(0x20uLL);
    long long v37 = xmmword_21DFAB670;
    strcpy((char *)v36, "SendReceiptServerRequest.plist");
    std::string __p = 0;
    long long v34 = 0;
    char v21 = *(std::string **)(a1 + 40);
    if ((unint64_t)v21 >= *(void *)(a1 + 48))
    {
      uint64_t v22 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)(a1 + 32), (long long *)&v36, (uint64_t)&__p);
    }
    else
    {
      std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*(std::string **)(a1 + 40), (long long *)&v36, (uint64_t)&__p);
      uint64_t v22 = v21 + 2;
      *(void *)(a1 + 40) = v21 + 2;
    }
    *(void *)(a1 + 40) = v22;
    if (__p)
    {
      long long v34 = __p;
      operator delete(__p);
    }
    if (SHIBYTE(v37) < 0) {
      operator delete(v36);
    }
    eUICC::Perso::PersoImplementation::PostDataSync((uint64_t)&v31, (void *)a1, (uint64_t)&v42);
    long long v26 = v31;
    CFTypeRef v20 = v32;
    uint64_t v45 = v31;
    uint64_t v46 = v32;
    if (v31)
    {
      uint64_t v29 = operator new(0x20uLL);
      long long v30 = xmmword_21DFAB690;
      strcpy((char *)v29, "SendReceiptServerResponse.plist");
      (*(void (**)(CFTypeRef *__return_ptr, void *))(*(void *)v26 + 40))(&cf, v26);
      eUICC::Perso::PersoImplementation::logTransactionCFData(a1, (long long *)&v29, (CFDataRef *)&cf);
      if (cf) {
        CFRelease(cf);
      }
      if (SHIBYTE(v30) < 0) {
        operator delete(v29);
      }
      uint64_t v16 = 0;
      *(void *)(a2 + 8) = *(void *)a2;
      if (gBBULogMaskGet(void)::once != -1) {
        goto LABEL_41;
      }
    }
    else
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v23, v24, v25, (char)"response");
      uint64_t v16 = 53;
      if (gBBULogMaskGet(void)::once != -1) {
        goto LABEL_41;
      }
    }
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "SendReceiptServer %d\n", v17, v18, v19, v16);
  if (v42)
  {
    uint64_t v43 = v42;
    operator delete(v42);
  }
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  return v16;
}

void sub_21DEE8120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,uint64_t a33,char a34,void *a35,uint64_t a36)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

const void **ctu::cf::CFSharedRef<__CFData>::~CFSharedRef(const void **a1)
{
  long long v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t eUICC::Perso::PersoImplementation::SerializeKeyValuePairsIntoPlistData(const void **keys, const void **values, CFIndex numValues)
{
  CFDataRef v42 = 0;
  CFTypeRef v43 = 0;
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFDictionaryRef v7 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], keys, values, numValues, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFDictionaryRef v41 = v7;
  if (v7) {
    size_t v8 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  }
  else {
    size_t v8 = 0;
  }
  if (!v8)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v4, v5, v6, (char)"inDict");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to create dictionary\n", v14, v15, v16, v34);
    CFDataRef v12 = 0;
    goto LABEL_38;
  }
  CFErrorRef error = 0;
  long long v39 = &v43;
  CFDataRef v12 = CFPropertyListCreateData(v3, v7, kCFPropertyListXMLFormat_v1_0, 0, &error);
  CFDataRef v42 = v12;
  uint64_t v13 = *v39;
  if (error)
  {
    *long long v39 = error;
    if (!v13) {
      goto LABEL_15;
    }
  }
  else
  {
    *long long v39 = 0;
    if (!v13) {
      goto LABEL_15;
    }
  }
  CFRelease(v13);
LABEL_15:
  if (v12) {
    uint64_t v17 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    uint64_t v17 = 0;
  }
  if (!v17)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v9, v10, v11, (char)"outData");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    ctu::cf::show((ctu::cf *)1, (uint64_t)v7, v22);
    int v23 = v40;
    char v24 = (char)error;
    ctu::cf::show((ctu::cf *)1, (uint64_t)v43, v25);
    p_CFErrorRef error = &error;
    if (v23 < 0) {
      LOBYTE(p_error) = v24;
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to serialize dictionary %s error %s\n", v26, v27, v28, (char)p_error);
    if (v37 < 0)
    {
      operator delete(__p);
      if ((v40 & 0x80000000) == 0) {
        goto LABEL_38;
      }
    }
    else if ((v40 & 0x80000000) == 0)
    {
      goto LABEL_38;
    }
    operator delete(error);
LABEL_38:
    uint64_t v21 = 11;
    if (!v7) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  if ((ctu::cf::assign() & 1) == 0)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v18, v19, v20, (char)"success");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to assign output data\n", v30, v31, v32, v35);
    goto LABEL_38;
  }
  uint64_t v21 = 0;
  if (v7) {
LABEL_39:
  }
    CFRelease(v7);
LABEL_40:
  if (v12) {
    CFRelease(v12);
  }
  if (v43) {
    CFRelease(v43);
  }
  return v21;
}

void sub_21DEE8634(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  ctu::cf::CFSharedRef<__CFDictionary const>::~CFSharedRef((const void **)(v25 - 72));
  ctu::cf::CFSharedRef<__CFData const>::~CFSharedRef((const void **)(v25 - 64));
  ctu::cf::CFSharedRef<__CFError>::~CFSharedRef((const void **)(v25 - 56));
  _Unwind_Resume(a1);
}

uint64_t *eUICC::Perso::PersoImplementation::PostDataSync(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = (char *)operator new(0xA0uLL);
  *((void *)v6 + 3) = 850045863;
  *((void *)v6 + 1) = 0;
  *((void *)v6 + 2) = 0;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((void *)v6 + 10) = 0;
  *((void *)v6 + 11) = 1018212795;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *(_OWORD *)(v6 + 124) = 0u;
  *(void *)uint64_t v6 = &unk_26CEC9F40;
  uint64_t v32 = (atomic_ullong *)v6;
  long long v33 = v6;
  std::mutex::lock((std::mutex *)(v6 + 24));
  int v7 = *((_DWORD *)v6 + 34);
  if ((v7 & 2) != 0) {
    std::__throw_future_error[abi:ne180100](1u);
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)v6 + 1, 1uLL, memory_order_relaxed);
  *((_DWORD *)v6 + 34) = v7 | 2;
  std::mutex::unlock((std::mutex *)(v6 + 24));
  unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v27 = &v28;
  cf[1] = 0;
  cf[2] = 0;
  ctu::Http::HttpRequest::create();
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,ctu::Http::case_insensitive_key_comparer,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((uint64_t)&v27, v28);
  (*(void (**)(unint64_t, void))(*(void *)v30 + 8))(v30, *a2);
  unint64_t v8 = v30;
  dispatch::future_callback_impl<std::shared_ptr<ctu::Http::HttpResponse>,std::shared_ptr<ctu::Http::HttpResponse>>(&v32, (void **)&v27);
  (*(void (**)(unint64_t, uint64_t *))(*(void *)v8 + 16))(v8, v27);
  if (v27) {
    _Block_release(v27);
  }
  (*(void (**)(unint64_t, double))(*(void *)v30 + 96))(v30, 60.0);
  unint64_t v9 = v30;
  uint64_t v10 = (const void *)a2[1];
  cf[0] = v10;
  if (v10) {
    CFRetain(v10);
  }
  (*(void (**)(unint64_t, CFTypeRef *))(*(void *)v9 + 88))(v9, cf);
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  (*(void (**)(unint64_t, uint64_t))(*(void *)v30 + 56))(v30, a3);
  __p[1] = 0;
  uint64_t v25 = 0;
  __p[0] = 0;
  (*(void (**)(unint64_t, void **))(*(void *)v30 + 40))(v30, __p);
  if (SHIBYTE(v25) < 0) {
    operator delete(__p[0]);
  }
  *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v11 = v32;
  uint64_t v32 = 0;
  std::__assoc_state<std::shared_ptr<ctu::Http::HttpResponse>>::move((uint64_t)v11, &v23);
  if (v11 && !atomic_fetch_add(v11 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v11 + 16))(v11);
  }
  if ((*(unsigned int (**)(void))(*(void *)v23 + 16))(v23) == 1
    && (*(unsigned int (**)(void))(*(void *)v23 + 24))(v23) == 200)
  {
    *(_OWORD *)a1 = v23;
    goto LABEL_26;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  char v12 = (*(uint64_t (**)(void))(*(void *)v23 + 16))(v23);
  (*(void (**)(void))(*(void *)v23 + 24))(v23);
  (*(void (**)(void))(*(void *)v23 + 32))(v23);
  (*(void (**)(CFTypeRef *__return_ptr))(*(void *)v23 + 72))(&v22);
  ctu::cf::show((uint64_t *)&v27, (ctu::cf *)v22, v13);
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "result %d code %d raw_error %ld error %s\n", v14, v15, v16, v12);
  if ((SHIBYTE(v29) & 0x80000000) == 0)
  {
    CFTypeRef v17 = v22;
    if (!v22) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  operator delete(v27);
  CFTypeRef v17 = v22;
  if (v22) {
LABEL_22:
  }
    CFRelease(v17);
LABEL_23:
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t v18 = (std::__shared_weak_count *)*((void *)&v23 + 1);
  if (*((void *)&v23 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v23 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
LABEL_26:
  uint64_t v19 = (std::__shared_weak_count *)v31;
  if (v31 && !atomic_fetch_add((atomic_ullong *volatile)(v31 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = v32;
  if (v32 && !atomic_fetch_add(v32 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
    (*(void (**)(atomic_ullong *))(*v20 + 16))(v20);
  }
  return std::promise<std::shared_ptr<ctu::Http::HttpResponse>>::~promise((uint64_t *)&v33);
}

void sub_21DEE8C84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,int a27,__int16 a28,char a29,char a30)
{
  if (*(char *)(v30 - 81) < 0) {
    operator delete(*(void **)(v30 - 104));
  }
  ctu::cf::CFSharedRef<__CFError>::~CFSharedRef(&a14);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a15);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v30 - 80);
  uint64_t v32 = *(atomic_ullong **)(v30 - 64);
  if (v32)
  {
    if (!atomic_fetch_add(v32 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      (*(void (**)(atomic_ullong *))(*v32 + 16))(v32);
    }
  }
  std::promise<std::shared_ptr<ctu::Http::HttpResponse>>::~promise((uint64_t *)(v30 - 56));
  _Unwind_Resume(a1);
}

void eUICC::Perso::PersoImplementation::logTransactionCFData(uint64_t a1, long long *a2, CFDataRef *a3)
{
  if (*a3) {
    uint64_t v4 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4)
  {
    BytePtr = CFDataGetBytePtr(*a3);
    CFIndex Length = CFDataGetLength(*a3);
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    std::string __p = 0;
    if (Length)
    {
      size_t v9 = Length;
      if (Length < 0) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v10 = (char *)operator new(Length);
      uint64_t v11 = &v10[v9];
      std::string __p = v10;
      uint64_t v16 = &v10[v9];
      memcpy(v10, BytePtr, v9);
      uint64_t v15 = v11;
    }
    char v12 = *(std::string **)(a1 + 40);
    if ((unint64_t)v12 >= *(void *)(a1 + 48))
    {
      uint64_t v13 = std::vector<std::pair<std::string,std::vector<unsigned char>>>::__emplace_back_slow_path<std::string&,std::vector<unsigned char>&>((std::string **)(a1 + 32), a2, (uint64_t)&__p);
    }
    else
    {
      std::pair<std::string,std::vector<unsigned char>>::pair[abi:ne180100]<std::string&,std::vector<unsigned char>&,0>(*(std::string **)(a1 + 40), a2, (uint64_t)&__p);
      uint64_t v13 = v12 + 2;
      *(void *)(a1 + 40) = v12 + 2;
    }
    *(void *)(a1 + 40) = v13;
    if (__p)
    {
      uint64_t v15 = __p;
      operator delete(__p);
    }
  }
}

void sub_21DEE8EF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t eUICC::Perso::PersoImplementation::CreateDictionaryFromPlistData(uint64_t *a1, const void **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  CFDataRef v9 = (const __CFData *)*a1;
  if (*a1) {
    uint64_t v10 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    uint64_t v10 = 0;
  }
  if (!v10)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", a6, a7, a8, (char)"inData");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to create data\n", v18, v19, v20, v43);
    uint64_t v21 = 11;
    goto LABEL_52;
  }
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFErrorRef error = 0;
  uint64_t v47 = (const void **)&v50;
  uint64_t v16 = (void *)CFPropertyListCreateWithData(v12, v9, 0, 0, &error);
  uint64_t v49 = v16;
  CFTypeRef v17 = *v47;
  if (error)
  {
    char *v47 = error;
    if (!v17) {
      goto LABEL_15;
    }
  }
  else
  {
    char *v47 = 0;
    if (!v17) {
      goto LABEL_15;
    }
  }
  CFRelease(v17);
LABEL_15:
  if (v16) {
    CFTypeRef v22 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get;
  }
  else {
    CFTypeRef v22 = 0;
  }
  if (v22)
  {
    CFTypeID v23 = CFGetTypeID(v16);
    if (v23 == CFDictionaryGetTypeID())
    {
      if (v16)
      {
        CFTypeID v27 = CFGetTypeID(v16);
        if (v27 == CFDictionaryGetTypeID())
        {
          CFRetain(v16);
          uint64_t v28 = *a2;
          *a2 = v16;
          if (!v28) {
            goto LABEL_50;
          }
        }
        else
        {
          uint64_t v28 = *a2;
          *a2 = 0;
          if (!v28) {
            goto LABEL_50;
          }
        }
      }
      else
      {
        uint64_t v28 = *a2;
        *a2 = 0;
        if (!v28)
        {
LABEL_50:
          uint64_t v21 = 0;
          if (!v16) {
            goto LABEL_52;
          }
          goto LABEL_51;
        }
      }
      CFRelease(v28);
      goto LABEL_50;
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v24, v25, v26, (char)"CFGetTypeID(outPlist.get()) == CFDictionaryGetTypeID()");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    ctu::cf::show((uint64_t *)&error, (ctu::cf *)v16, v37);
    if (v48 >= 0) {
      p_CFErrorRef error = &error;
    }
    else {
      LOBYTE(p_error) = (_BYTE)error;
    }
    _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Deserialized plist data is not a dictionary: %s\n", v38, v39, v40, (char)p_error);
    if ((v48 & 0x80000000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(25, 0xFFFFFFFFLL, "PersoImpl", "", "Condition <<%s>> failed %s %s/%d\n", v13, v14, v15, (char)"outPlist");
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  ctu::cf::show((ctu::cf *)1, *a1, v29);
  int v30 = v48;
  char v31 = (char)error;
  ctu::cf::show((uint64_t *)&__p, v50, v32);
  long long v36 = &error;
  if (v30 < 0) {
    LOBYTE(v36) = v31;
  }
  _BBULog(22, 0xFFFFFFFFLL, "PersoImpl", "", "Failed to deserialize dictionary %s error %s\n", v33, v34, v35, (char)v36);
  if ((v45 & 0x80000000) == 0)
  {
    if ((v48 & 0x80000000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  operator delete(__p);
  if (v48 < 0) {
LABEL_32:
  }
    operator delete(error);
LABEL_33:
  uint64_t v21 = 11;
  if (v16) {
LABEL_51:
  }
    CFRelease(v16);
LABEL_52:
  if (v50) {
    CFRelease(v50);
  }
  return v21;
}

void sub_21DEE9338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0)
  {
    operator delete(__p);
    ctu::cf::CFSharedRef<void const>::~CFSharedRef((const void **)(v24 - 48));
    ctu::cf::CFSharedRef<__CFError>::~CFSharedRef((const void **)(v24 - 40));
    _Unwind_Resume(a1);
  }
  ctu::cf::CFSharedRef<void const>::~CFSharedRef((const void **)(v24 - 48));
  ctu::cf::CFSharedRef<__CFError>::~CFSharedRef((const void **)(v24 - 40));
  _Unwind_Resume(a1);
}

void sub_21DEE93CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  ctu::cf::detail::TakeOwnershipProxy<__CFError>::~TakeOwnershipProxy((const void **)va);
  ctu::cf::CFSharedRef<void const>::~CFSharedRef((const void **)(v8 - 48));
  ctu::cf::CFSharedRef<__CFError>::~CFSharedRef((const void **)(v8 - 40));
  _Unwind_Resume(a1);
}

void sub_21DEE93F0(_Unwind_Exception *a1)
{
  ctu::cf::CFSharedRef<void const>::~CFSharedRef((const void **)(v1 - 48));
  ctu::cf::CFSharedRef<__CFError>::~CFSharedRef((const void **)(v1 - 40));
  _Unwind_Resume(a1);
}

const void **ctu::cf::CFSharedRef<__CFData const>::operator=<void const,void>(const void **a1, CFTypeRef cf)
{
  if (!cf)
  {
LABEL_4:
    uint64_t v5 = *a1;
    *a1 = cf;
    if (!v5) {
      return a1;
    }
    goto LABEL_7;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFDataGetTypeID())
  {
    CFRetain(cf);
    goto LABEL_4;
  }
  uint64_t v5 = *a1;
  *a1 = 0;
  if (v5) {
LABEL_7:
  }
    CFRelease(v5);
  return a1;
}

const void **ctu::cf::detail::TakeOwnershipProxy<__CFError>::~TakeOwnershipProxy(const void **a1)
{
  CFAllocatorRef v3 = *a1;
  long long v2 = (const void **)a1[1];
  CFTypeID v4 = *v2;
  if (v3)
  {
    *long long v2 = v3;
    if (v4) {
      goto LABEL_5;
    }
  }
  else
  {
    *long long v2 = 0;
    if (v4) {
LABEL_5:
    }
      CFRelease(v4);
  }
  return a1;
}

uint64_t ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t ctu::PthreadMutexGuardPolicy<eUICC::Perso::PersoImplementation>::~PthreadMutexGuardPolicy(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  long long v2 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  CFAllocatorRef v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return a1;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  return a1;
}

void std::__shared_ptr_pointer<eUICC::Perso::PersoImplementation *,std::shared_ptr<eUICC::Perso::PersoImplementation>::__shared_ptr_default_delete<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation>,std::allocator<eUICC::Perso::PersoImplementation>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<eUICC::Perso::PersoImplementation *,std::shared_ptr<eUICC::Perso::PersoImplementation>::__shared_ptr_default_delete<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation>,std::allocator<eUICC::Perso::PersoImplementation>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(eUICC::Perso::PersoImplementation **)(a1 + 24);
  if (v1)
  {
    eUICC::Perso::PersoImplementation::~PersoImplementation(v1);
    operator delete(v2);
  }
}

uint64_t std::__shared_ptr_pointer<eUICC::Perso::PersoImplementation *,std::shared_ptr<eUICC::Perso::PersoImplementation>::__shared_ptr_default_delete<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation>,std::allocator<eUICC::Perso::PersoImplementation>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFAB732) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFAB732 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFAB732)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFAB732 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void eUICC::Perso::PersoImplementation::~PersoImplementation(eUICC::Perso::PersoImplementation *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 5);
    CFTypeID v4 = (void *)*((void *)this + 4);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 24);
        if (v5)
        {
          *(void *)(v3 - 16) = v5;
          operator delete(v5);
        }
        if (*(char *)(v3 - 25) < 0) {
          operator delete(*(void **)(v3 - 48));
        }
        v3 -= 48;
      }
      while (v3 != v2);
      CFTypeID v4 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v2;
    operator delete(v4);
  }
  uint64_t v6 = (const void *)*((void *)this + 2);
  if (v6) {
    CFRelease(v6);
  }
  int v7 = (const void *)*((void *)this + 1);
  if (v7) {
    CFRelease(v7);
  }
  if (*(void *)this) {
    dispatch_release(*(dispatch_object_t *)this);
  }
}

uint64_t __cxx_global_var_init_3()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ICEARIContext>::~PthreadMutexGuardPolicy, &ctu::Singleton<ICEARIContext,ICEARIContext,ctu::PthreadMutexGuardPolicy<ICEARIContext>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

uint64_t __cxx_global_var_init_94()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<eUICC::Perso::PersoImplementation>::~PthreadMutexGuardPolicy, &ctu::Singleton<eUICC::Perso::PersoImplementation,eUICC::Perso::PersoImplementation,ctu::PthreadMutexGuardPolicy<eUICC::Perso::PersoImplementation>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

void BBUEURELFImage::~BBUEURELFImage(BBUEURELFImage *this)
{
  *(void *)this = &unk_26CECA7E0;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = (void *)v2[8];
    if (v3) {
      operator delete[](v3);
    }
    operator delete(v2);
  }
  uint64_t v4 = *((void *)this + 1);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
}

{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t vars8;

  *(void *)this = &unk_26CECA7E0;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = (void *)v2[8];
    if (v3) {
      operator delete[](v3);
    }
    operator delete(v2);
  }
  uint64_t v4 = *((void *)this + 1);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }

  operator delete(this);
}

uint64_t BBUEURELFImage::getWritePayloadData(BBUEURELFImage *this, unsigned __int8 *a2, uint64_t a3, unsigned int a4)
{
  if ((*(unsigned int (**)(BBUEURELFImage *))(*(void *)this + 32))(this) <= a4)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 77, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Images/Eureka/ELF/BBUEURELFImage.cpp", 0x16u, (ctu::LogMessageBuffer *)"Assertion failure(( offset < getWritePayloadLength()) && \"Error: Chunk size is not sufficient to write payload data of the ELF image.\")", v10, v11, v12, v19);
    goto LABEL_8;
  }
  int v20 = -1431655766;
  uint64_t result = (*(uint64_t (**)(void, unsigned __int8 *, uint64_t, int *, void))(**((void **)this + 1) + 16))(*((void *)this + 1), a2, a3, &v20, *((_DWORD *)this + 6) + a4);
  if (result)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 78, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Images/Eureka/ELF/BBUEURELFImage.cpp", 0x19u, (ctu::LogMessageBuffer *)"Assertion failure(( ret == kBBUReturnSuccess) && \"Failed to copy from ELF image!\")", v13, v14, v15, v19);
    goto LABEL_8;
  }
  if (v20 != a3)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 78, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Images/Eureka/ELF/BBUEURELFImage.cpp", 0x1Au, (ctu::LogMessageBuffer *)"Assertion failure(( amountCopied == amount) && \"Copied data size mismatch: Failed to copy from ELF image!\")", v16, v17, v18, v19);
LABEL_8:
  }
  return result;
}

void sub_21DEE9A54(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE9A68(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEE9A7C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const char *BBUEURELFImage::getName(BBUEURELFImage *this)
{
  return "ELF";
}

uint64_t BBUFSServerParametersInit(uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && __s1)
  {
    *(_OWORD *)(a1 + 336) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
    *(_OWORD *)(a1 + 304) = 0u;
    *(_OWORD *)(a1 + 320) = 0u;
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 288) = 0u;
    *(_OWORD *)(a1 + 240) = 0u;
    *(_OWORD *)(a1 + 256) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
    size_t v10 = strnlen(__s1, 0x100uLL);
    uint64_t v11 = TelephonyUtilStrlcpy();
    BOOL v18 = v11 != v10 || (unint64_t)(v11 + 1) >= 0x101;
    uint64_t v19 = !v18;
    if (v18) {
      _BBUFSDebugPrint("BBUFSServerParametersInit", "required path CFIndex length = %zu, copied = %zu, max CFIndex length = %zu\n", v12, v13, v14, v15, v16, v17, v10 + 1);
    }
    *(void *)(a1 + 360) = a3;
  }
  else
  {
    _BBUFSDebugPrint("BBUFSServerParametersInit", "invalid parameters specified: parameters = %p, destination = %s\n", a3, a4, a5, a6, a7, a8, a1);
    return 0;
  }
  return v19;
}

uint64_t BBUFSServerPrepare(bbufs *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (bbufs::prepareDestination(a1, a2))
    {
      return 1;
    }
    else
    {
      _BBUFSDebugPrint("BBUFSServerPrepare", "failed preparing baseband filesystem directory\n", v8, v9, v10, v11, v12, v13, v15);
      return 0;
    }
  }
  else
  {
    _BBUFSDebugPrint("BBUFSServerPrepare", "invalid path specified %s\n", a3, a4, a5, a6, a7, a8, 0);
    return 0;
  }
}

uint64_t BBUFSServerCreate(void *a1, uint64_t (**a2)(const char *, const char *, char *), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    uint64_t v18 = 0;
    uint64_t v19 = "bad parameters for file server creation\n";
    goto LABEL_15;
  }
  a1[50] = 0;
  *((_OWORD *)a1 + 23) = 0u;
  *((_OWORD *)a1 + 24) = 0u;
  *((_OWORD *)a1 + 21) = 0u;
  *((_OWORD *)a1 + 22) = 0u;
  *((_OWORD *)a1 + 19) = 0u;
  *((_OWORD *)a1 + 20) = 0u;
  *((_OWORD *)a1 + 17) = 0u;
  *((_OWORD *)a1 + 18) = 0u;
  *((_OWORD *)a1 + 15) = 0u;
  *((_OWORD *)a1 + 16) = 0u;
  *((_OWORD *)a1 + 13) = 0u;
  *((_OWORD *)a1 + 14) = 0u;
  *((_OWORD *)a1 + 11) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v10 = (capabilities::radio *)memcpy(a1, a2, 0x170uLL);
  uint64_t v11 = ICEStateMachineSetConfigDefaults;
  uint64_t v12 = ICEStateMachineSetConfig;
  uint64_t v13 = ICEStateMachineSnapshotInProgress;
  uint64_t v14 = ICEStateMachinePerformSnapshot;
  char v15 = ICEStateMachineStop;
  uint64_t v16 = ICEStateMachineStart;
  int v17 = capabilities::radio::vendor(v10);
  if (v17 == 3)
  {
    uint64_t v11 = INTStateMachineSetConfigDefaults;
    uint64_t v12 = INTStateMachineSetConfig;
    uint64_t v13 = INTStateMachineSnapshotInProgress;
    uint64_t v14 = INTStateMachinePerformSnapshot;
    char v15 = INTStateMachineStop;
    uint64_t v16 = INTStateMachineStart;
    goto LABEL_8;
  }
  if (v17 == 2)
  {
LABEL_8:
    sBBUFSServerStart = v16;
    sBBUFSServerStop = v15;
    sBBUFSServerFlush = v14;
    sBBUFSServerFlushInProgress = v13;
    sBBUFSServerSetConfig = v12;
    sBBUFSServerSetConfigDefaults = v11;
LABEL_10:
    if (((unsigned int (*)(void *))v11)(a1)) {
      goto LABEL_11;
    }
LABEL_14:
    uint64_t v18 = 0;
    uint64_t v19 = "BBUFSServer create failed\n";
    goto LABEL_15;
  }
  if (v17 != 1)
  {
    _BBUFSDebugPrint("BBUFSServerCreate", "invalid state machine type %u\n", a3, a4, a5, a6, a7, a8, v17);
    uint64_t v11 = sBBUFSServerSetConfigDefaults;
    if (!sBBUFSServerSetConfigDefaults) {
      goto LABEL_14;
    }
    goto LABEL_10;
  }
  sBBUFSServerStart = EURStateMachineStart;
  sBBUFSServerStop = EURStateMachineStop;
  sBBUFSServerFlush = EURStateMachinePerformFlush;
  sBBUFSServerFlushInProgress = EURStateMachineFlushInProgress;
  sBBUFSServerSetConfig = EURStateMachineSetConfig;
  sBBUFSServerSetConfigDefaults = 0;
LABEL_11:
  if (*a2) {
    sDelegate = *a2;
  }
  uint64_t v18 = 1;
  uint64_t v19 = "BBUFSServer created successfully\n";
LABEL_15:
  _BBUFSDebugPrint("BBUFSServerCreate", v19, a3, a4, a5, a6, a7, a8, v21);
  return v18;
}

BOOL BBUFSServerRelease(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(void *)(a1 + 360))
    {
      _BBUFSDebugPrint("BBUFSServerRelease", "BBUFSServer releasing registry\n", a3, a4, a5, a6, a7, a8, v13);
      uint64_t v9 = *(void **)(a1 + 360);
      if (v9)
      {
        uint64_t v10 = (std::__shared_weak_count *)v9[1];
        if (v10) {
          std::__shared_weak_count::__release_weak(v10);
        }
        operator delete(v9);
      }
      *(void *)(a1 + 360) = 0;
    }
    sBBUFSServerStart = 0;
    sBBUFSServerStop = 0;
    sBBUFSServerFlush = 0;
    sBBUFSServerFlushInProgress = 0;
    sBBUFSServerSetConfig = 0;
    uint64_t v11 = "BBUFSServer destroyed\n";
    sBBUFSServerSetConfigDefaults = 0;
  }
  else
  {
    uint64_t v11 = "trying to release invalid file server\n";
  }
  _BBUFSDebugPrint("BBUFSServerRelease", v11, a3, a4, a5, a6, a7, a8, v13);
  return a1 != 0;
}

uint64_t BBUFSServerStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = (uint64_t (*)(void))sBBUFSServerStart;
  if (!sBBUFSServerStart)
  {
    _BBUFSDebugPrint("BBUFSServerStart", "sBBUFSServerStart function not initialized\n", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }

  return v8();
}

uint64_t BBUFSServerFlush(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = (uint64_t (*)(void))sBBUFSServerFlush;
  if (!sBBUFSServerFlush)
  {
    _BBUFSDebugPrint("BBUFSServerFlush", "sBBUFSServerFlush function not initialized\n", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }

  return v8();
}

uint64_t BBUFSServerFlushInProgress(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = (uint64_t (*)(void))sBBUFSServerFlushInProgress;
  if (!sBBUFSServerFlushInProgress)
  {
    _BBUFSDebugPrint("BBUFSServerFlushInProgress", "sBBUFSServerFlushInProgress function not initialized\n", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }

  return v8();
}

uint64_t BBUFSServerSetConfig(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = (uint64_t (*)(void))sBBUFSServerSetConfig;
  if (!sBBUFSServerSetConfig)
  {
    _BBUFSDebugPrint("BBUFSServerSetConfig", "sBBUFSServerSetConfig function not initialized\n", a3, 0, a5, a6, a7, a8, vars0);
    return 0;
  }

  return v8();
}

uint64_t BBUFSServerSetConfigDefaults(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = (uint64_t (*)(void))sBBUFSServerSetConfigDefaults;
  if (!sBBUFSServerSetConfigDefaults)
  {
    _BBUFSDebugPrint("BBUFSServerSetConfigDefaults", "sBBUFSServerSetConfigDefaults function not initialized\n", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }

  return v8();
}

uint64_t BBUFSServerStop(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = (uint64_t (*)(void))sBBUFSServerStop;
  if (!sBBUFSServerStop)
  {
    _BBUFSDebugPrint("BBUFSServerStop", "sBBUFSServerStop function not initialized\n", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }

  return v8();
}

uint64_t BBUEUR10HashData::compare(BBUEUR10HashData *this, BBUFeedback *a2, const BBUHashData *lpsrc)
{
  uint64_t v4 = (unsigned __int8 *)this;
  if (!lpsrc)
  {
    uint64_t v5 = 0;
LABEL_13:
    unsigned int v6 = 0;
    goto LABEL_14;
  }
  uint64_t v5 = (const unsigned __int8 *)this;
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 8, (const unsigned __int8 *)this + 8, "SBL1");
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 40, v5 + 40, "RPM");
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 264, v5 + 264, "ACDB");
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 72, v5 + 72, "APPS");
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 104, v5 + 104, "DSP3");
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 136, v5 + 136, "MBA");
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 168, v5 + 168, "QDSP6SW");
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 200, v5 + 200, "TZ");
  if (!this) {
    goto LABEL_13;
  }
  this = (BBUEUR10HashData *)BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 232, v5 + 232, "WDT");
  unsigned int v6 = this;
LABEL_14:
  int v7 = capabilities::updater::supportsBbcfgImage(this) ^ 1;
  if ((v7 & 1) != 0 || !v6) {
    return v7 & v6;
  }

  return BBUHashData::compareHash((BBUHashData *)v4, a2, v4 + 296, v5 + 296, "BBCFG");
}

void BBUEUR10HashData::showHashes(BBUEUR10HashData *this, BBUFeedback *a2)
{
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  BBUFeedback::handleComment(a2, "\t %s:  %s", "SBL1_HASH", (const char *)&__p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "RPM_HASH", p_p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    uint64_t v5 = (const char *)&__p;
  }
  else {
    uint64_t v5 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "APPS_HASH", v5);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    unsigned int v6 = (const char *)&__p;
  }
  else {
    unsigned int v6 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "DSP3_HASH", v6);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    int v7 = (const char *)&__p;
  }
  else {
    int v7 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "MBA_HASH", v7);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    uint64_t v8 = (const char *)&__p;
  }
  else {
    uint64_t v8 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "QDSP6SW_HASH", v8);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    uint64_t v9 = (const char *)&__p;
  }
  else {
    uint64_t v9 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "TZ_HASH", v9);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    uint64_t v10 = (const char *)&__p;
  }
  else {
    uint64_t v10 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "WDT_HASH", v10);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    uint64_t v11 = (const char *)&__p;
  }
  else {
    uint64_t v11 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "ACDB_HASH", v11);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  (*(void (**)(BBUEUR10HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v15 >= 0) {
    uint64_t v12 = (const char *)&__p;
  }
  else {
    uint64_t v12 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "BBCFG_HASH", v12);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
}

void sub_21DEEA8E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void _BBUException::constructCommon(uint64_t a1, int a2, char *a3, unsigned int a4, ctu::LogMessageBuffer *this, char *a6)
{
  memset(&v42, 170, sizeof(v42));
  ctu::LogMessageBuffer::vCreateWithFormat((uint64_t *)&v40, this, a6, a3);
  uint64_t v10 = MEMORY[0x223C1D0C0](&v40);
  long long v11 = *(_OWORD *)v10;
  v42.__r_.__value_.__r.__words[2] = *(void *)(v10 + 16);
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v11;
  *(void *)(v10 + 8) = 0;
  *(void *)(v10 + 16) = 0;
  *(void *)uint64_t v10 = 0;
  MEMORY[0x223C1D0F0](&v40);
  *((unsigned char *)&v35.__r_.__value_.__s + 23) = 1;
  LOWORD(v35.__r_.__value_.__l.__data_) = 32;
  uint64_t v12 = BBUReturnAsString::BBUReturnStrings[a2];
  std::string::size_type v13 = strlen(v12);
  uint64_t v14 = std::string::append(&v35, v12, v13);
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v36.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  uint64_t v16 = std::string::append(&v36, "@", 1uLL);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v37.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  strlen(a3);
  ctu::basename();
  if ((v34 & 0x80u) == 0) {
    uint64_t v18 = __p;
  }
  else {
    uint64_t v18 = (void **)__p[0];
  }
  if ((v34 & 0x80u) == 0) {
    std::string::size_type v19 = v34;
  }
  else {
    std::string::size_type v19 = (std::string::size_type)__p[1];
  }
  int v20 = std::string::append(&v37, (const std::string::value_type *)v18, v19);
  long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  CFTypeRef v22 = std::string::append(&v38, ":", 1uLL);
  long long v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v39.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v32, a4);
  if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v24 = &v32;
  }
  else {
    uint64_t v24 = (std::string *)v32.__r_.__value_.__r.__words[0];
  }
  if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v32.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v32.__r_.__value_.__l.__size_;
  }
  uint64_t v26 = std::string::append(&v39, (const std::string::value_type *)v24, size);
  long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  int64_t v41 = v26->__r_.__value_.__r.__words[2];
  long long v40 = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  if (v41 >= 0) {
    uint64_t v28 = (const std::string::value_type *)&v40;
  }
  else {
    uint64_t v28 = (const std::string::value_type *)v40;
  }
  if (v41 >= 0) {
    std::string::size_type v29 = HIBYTE(v41);
  }
  else {
    std::string::size_type v29 = *((void *)&v40 + 1);
  }
  std::string::append(&v42, v28, v29);
  if (SHIBYTE(v41) < 0)
  {
    operator delete((void *)v40);
    if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_21:
      if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_22;
      }
      goto LABEL_33;
    }
  }
  else if ((SHIBYTE(v32.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_21;
  }
  operator delete(v32.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_22:
    if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_34;
  }
LABEL_33:
  operator delete(v39.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_23:
    if (((char)v34 & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_35;
  }
LABEL_34:
  operator delete(v38.__r_.__value_.__l.__data_);
  if (((char)v34 & 0x80000000) == 0)
  {
LABEL_24:
    if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_36;
  }
LABEL_35:
  operator delete(__p[0]);
  if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_25:
    if ((SHIBYTE(v36.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_26;
    }
LABEL_37:
    operator delete(v36.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v35.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_38;
  }
LABEL_36:
  operator delete(v37.__r_.__value_.__l.__data_);
  if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_37;
  }
LABEL_26:
  if ((SHIBYTE(v35.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_27;
  }
LABEL_38:
  operator delete(v35.__r_.__value_.__l.__data_);
LABEL_27:
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v30 = a1 + 8;
  *(_OWORD *)(v30 + 480) = 0u;
  *(_OWORD *)(v30 + 496) = 0u;
  *(_OWORD *)(v30 + 448) = 0u;
  *(_OWORD *)(v30 + 464) = 0u;
  *(_OWORD *)(v30 + 416) = 0u;
  *(_OWORD *)(v30 + 432) = 0u;
  *(_OWORD *)(v30 + 384) = 0u;
  *(_OWORD *)(v30 + 400) = 0u;
  *(_OWORD *)(v30 + 352) = 0u;
  *(_OWORD *)(v30 + 368) = 0u;
  *(_OWORD *)(v30 + 320) = 0u;
  *(_OWORD *)(v30 + 336) = 0u;
  *(_OWORD *)(v30 + 288) = 0u;
  *(_OWORD *)(v30 + 304) = 0u;
  *(_OWORD *)(v30 + 256) = 0u;
  *(_OWORD *)(v30 + 272) = 0u;
  *(_OWORD *)(v30 + 224) = 0u;
  *(_OWORD *)(v30 + 240) = 0u;
  *(_OWORD *)(v30 + 192) = 0u;
  *(_OWORD *)(v30 + 208) = 0u;
  *(_OWORD *)(v30 + 160) = 0u;
  *(_OWORD *)(v30 + 176) = 0u;
  *(_OWORD *)(v30 + 128) = 0u;
  *(_OWORD *)(v30 + 144) = 0u;
  *(_OWORD *)(v30 + 96) = 0u;
  *(_OWORD *)(v30 + 112) = 0u;
  *(_OWORD *)(v30 + 64) = 0u;
  *(_OWORD *)(v30 + 80) = 0u;
  *(_OWORD *)(v30 + 32) = 0u;
  *(_OWORD *)(v30 + 48) = 0u;
  char v31 = &v42;
  if ((v42.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    char v31 = (std::string *)v42.__r_.__value_.__r.__words[0];
  }
  *(_OWORD *)(v30 + 16) = 0uLL;
  snprintf((char *)v30, 0x200uLL, "%s\n", (const char *)v31);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v42.__r_.__value_.__l.__data_);
  }
}

void sub_21DEEAC70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47,uint64_t a48,void *a49,uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (*(char *)(v54 - 121) < 0)
  {
    operator delete(*(void **)(v54 - 144));
    if ((a15 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a54 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_13;
    }
  }
  else if ((a15 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(__p);
  if ((a54 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a47 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_14;
  }
LABEL_13:
  operator delete(a49);
  if ((a47 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a21 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }
LABEL_14:
  operator delete(a42);
  if ((a21 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a40 & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_16;
  }
LABEL_15:
  operator delete(a16);
  if ((a40 & 0x80000000) == 0)
  {
LABEL_7:
    if ((a33 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_17;
  }
LABEL_16:
  operator delete(a35);
  if ((a33 & 0x80000000) == 0)
  {
LABEL_8:
    if ((a27 & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_18;
  }
LABEL_17:
  operator delete(a28);
  if ((a27 & 0x80000000) == 0)
  {
LABEL_9:
    if ((*(char *)(v54 - 57) & 0x80000000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_19;
  }
LABEL_18:
  operator delete(a22);
  if ((*(char *)(v54 - 57) & 0x80000000) == 0) {
LABEL_10:
  }
    _Unwind_Resume(exception_object);
LABEL_19:
  operator delete(*(void **)(v54 - 80));
  _Unwind_Resume(exception_object);
}

uint64_t _BBUException::_BBUException(uint64_t a1, int a2, char *a3, unsigned int a4, ctu::LogMessageBuffer *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(void *)a1 = &unk_26CECA898;
  *(_DWORD *)(a1 + 520) = a2;
  _BBUException::constructCommon(a1, a2, a3, a4, a5, &a9);
  return a1;
}

void sub_21DEEAE34(_Unwind_Exception *a1)
{
  std::exception::~exception(v1);
  _Unwind_Resume(a1);
}

void _BBUException::~_BBUException(std::exception *this)
{
  std::exception::~exception(this);

  operator delete(v1);
}

uint64_t _BBUException::what(_BBUException *this)
{
  return (uint64_t)this + 8;
}

void (__cdecl ***std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this)))(std::fstream *__hidden this)
{
  uint64_t v2 = a1 + 54;
  MEMORY[0x223C1DAE0](a1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x223C1DDF0](v2);
  return a1;
}

void non-virtual thunk to'std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this))
{
  MEMORY[0x223C1DAE0](a1 + 1);
  std::iostream::~basic_iostream();

  JUMPOUT(0x223C1DDF0);
}

{
  void (__cdecl ***v1)(std::fstream *__hidden);
  void *v2;
  uint64_t vars8;

  uint64_t v1 = a1 - 2;
  uint64_t v2 = a1 + 52;
  MEMORY[0x223C1DAE0](a1 + 1);
  std::iostream::~basic_iostream();
  MEMORY[0x223C1DDF0](v2);

  operator delete(v1);
}

void virtual thunk to'std::fstream::~fstream(void *a1)
{
  uint64_t v1 = (void (__cdecl ***)(std::fstream *__hidden))((char *)a1 + *(void *)(*a1 - 24));
  MEMORY[0x223C1DAE0](v1 + 3);
  std::iostream::~basic_iostream();

  JUMPOUT(0x223C1DDF0);
}

{
  void (__cdecl ***v1)(std::fstream *__hidden);
  uint64_t vars8;

  uint64_t v1 = (void (__cdecl ***)(std::fstream *__hidden))((char *)a1 + *(void *)(*a1 - 24));
  MEMORY[0x223C1DAE0](v1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x223C1DDF0](v1 + 54);

  operator delete(v1);
}

void std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this))
{
  uint64_t v2 = a1 + 54;
  MEMORY[0x223C1DAE0](a1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x223C1DDF0](v2);

  operator delete(a1);
}

void std::__throw_bad_weak_ptr[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x263F8C2D8] + 16;
  __cxa_throw(exception, MEMORY[0x263F8C198], MEMORY[0x263F8C0A0]);
}

uint64_t __cxx_global_var_init_4()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::shared_stdio,support::log::shared_stdio,ctu::PthreadMutexGuardPolicy<support::log::shared_stdio>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

eUICC::eUICCVinylICEValve *eUICC::eUICCVinylICEValve::eUICCVinylICEValve(eUICC::eUICCVinylICEValve *this, void *a2, int a3, char a4)
{
  *((unsigned char *)this + 289) = 0;
  *((unsigned char *)this + 304) = 0;
  *(void *)this = &unk_26CECAAD0;
  uint64_t v5 = (eUICC::VinylCommandDriver **)((char *)this + 312);
  *((void *)this + 39) = 0;
  *((void *)this + 37) = a2;
  int v6 = a3 != 1;
  if (a3 == 255) {
    int v6 = 255;
  }
  *((_DWORD *)this + 73) = v6;
  *((unsigned char *)this + 290) = a4;
  IceAriGetContext();
  int v7 = (eUICC::VinylCommandDriver *)operator new(8uLL);
  eUICC::VinylCommandDriver::VinylCommandDriver();
  uint64_t v8 = *v5;
  const char *v5 = v7;
  if (v8)
  {
    eUICC::VinylCommandDriver::~VinylCommandDriver(v8);
    operator delete(v9);
  }
  *((unsigned char *)this + 304) = 15;
  return this;
}

void sub_21DEEB3E4(_Unwind_Exception *a1)
{
  operator delete(v2);
  std::unique_ptr<eUICC::VinylCommandDriver>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_21DEEB400(_Unwind_Exception *a1)
{
  std::unique_ptr<eUICC::VinylCommandDriver>::~unique_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

std::__shared_weak_count_vtbl *IceAriGetContext(void)
{
  pthread_mutex_lock(&ctu::Singleton<ICEARIContext,ICEARIContext,ctu::PthreadMutexGuardPolicy<ICEARIContext>>::sInstance);
  if (!qword_26AA89BA0)
  {
    uint64_t v0 = (std::__shared_weak_count_vtbl *)operator new(0x28uLL);
    LOBYTE(v0->__on_zero_shared_weak) = 0;
    uint64_t v1 = (std::__shared_weak_count *)operator new(0x20uLL);
    v1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CECAB70;
    v1->__shared_owners_ = 0;
    v1->__shared_weak_owners_ = 0;
    v1[1].__vftable = v0;
    uint64_t v3 = (std::__shared_weak_count *)off_26AA89BA8;
    qword_26AA89BA0 = (uint64_t)v0;
    off_26AA89BA8 = v1;
    if (!v3) {
      goto LABEL_7;
    }
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  uint64_t v0 = (std::__shared_weak_count_vtbl *)qword_26AA89BA0;
  uint64_t v1 = (std::__shared_weak_count *)off_26AA89BA8;
  if (off_26AA89BA8)
  {
LABEL_7:
    char v2 = 0;
    atomic_fetch_add_explicit(&v1->__shared_owners_, 1uLL, memory_order_relaxed);
    goto LABEL_8;
  }
  char v2 = 1;
LABEL_8:
  pthread_mutex_unlock(&ctu::Singleton<ICEARIContext,ICEARIContext,ctu::PthreadMutexGuardPolicy<ICEARIContext>>::sInstance);
  if ((v2 & 1) != 0 || atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    return v0;
  }
  ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
  std::__shared_weak_count::__release_weak(v1);
  return v0;
}

void sub_21DEEB564(_Unwind_Exception *a1)
{
  operator delete(v1);
  pthread_mutex_unlock(&ctu::Singleton<ICEARIContext,ICEARIContext,ctu::PthreadMutexGuardPolicy<ICEARIContext>>::sInstance);
  _Unwind_Resume(a1);
}

eUICC::VinylCommandDriver **std::unique_ptr<eUICC::VinylCommandDriver>::~unique_ptr[abi:ne180100](eUICC::VinylCommandDriver **a1)
{
  char v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    eUICC::VinylCommandDriver::~VinylCommandDriver(v2);
    operator delete(v3);
  }
  return a1;
}

void *eUICC::eUICCVinylICEValve::GetVinylType@<X0>(eUICC::eUICCVinylICEValve *this@<X0>, void *a2@<X8>)
{
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 287) = 1;
  return memcpy(a2, (char *)this + 8, 0x11AuLL);
}

uint64_t eUICC::eUICCVinylICEValve::GetData@<X0>(eUICC::eUICCVinylICEValve *this@<X0>, void *a2@<X8>)
{
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53[3] = v4;
  *(_OWORD *)std::string __p = v4;
  v53[1] = v4;
  v53[2] = v4;
  v53[0] = v4;
  AriSdk::ARI_IBIVinylGetDataReq_SDK::ARI_IBIVinylGetDataReq_SDK((AriSdk::ARI_IBIVinylGetDataReq_SDK *)v53);
  uint64_t v8 = (_OWORD *)((char *)this + 8);
  if (*((unsigned char *)this + 289))
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "eUICCVinylData cache is valid. Using cached data!\n", v5, v6, v7, v51);
    eUICC::logEUICCData((int *)this + 2);
    goto LABEL_5;
  }
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *uint64_t v8 = 0u;
  *(_OWORD *)((char *)this + 274) = 0u;
  uint64_t v10 = operator new(4uLL);
  *uint64_t v10 = *((_DWORD *)this + 73);
  long long v11 = __p[0];
  __p[0] = v10;
  if (v11) {
    operator delete(v11);
  }
  uint64_t v12 = operator new(1uLL);
  *uint64_t v12 = 0;
  std::string::size_type v13 = __p[1];
  __p[1] = v12;
  if (v13) {
    operator delete(v13);
  }
  uint64_t v57 = (void *)0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v56[2] = v14;
  v56[3] = v14;
  v56[0] = v14;
  v56[1] = v14;
  AriSdk::ARI_IBISimAccessGetSimDataReq_SDK::ARI_IBISimAccessGetSimDataReq_SDK((AriSdk::ARI_IBISimAccessGetSimDataReq_SDK *)v56);
  uint64_t v55 = 0;
  long long v15 = operator new(4uLL);
  *long long v15 = *((_DWORD *)this + 73);
  uint64_t v16 = v57;
  uint64_t v57 = v15;
  if (v16) {
    operator delete(v16);
  }
  int v17 = 0;
  while (1)
  {
    if ((eUICC::VinylCommandDriver::GetVinylType() & 1) == 0)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Error: failed to get slot info from BB\n", v18, v19, v20, v51);
LABEL_30:
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v25, v26, v27, (char)"ret");
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Failed to get data from UIM\n", v28, v29, v30, v52);
LABEL_40:
      BOOL v34 = 0;
      goto LABEL_41;
    }
    uint64_t v21 = v55;
    int v22 = **(_DWORD **)(v55 + 128);
    if (v22)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v18, v19, v20, (char)"!(GET_RSP_FIELD(rsp, sim_error_cause_t28) & sim_error_cause_mask)");
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "sim_state 0x%x, sim_error_cause 0x%x\n", v31, v32, v33, **(_DWORD **)(v55 + 72));
      goto LABEL_40;
    }
    int v23 = **(_DWORD **)(v55 + 72);
    if (v23 != 1 && v23 != 254 && v23 != 4) {
      break;
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "SIM still initializing, trying again... sim_state 0x%x (retryCount: %d, retryLimit: %d)\n", v18, v19, v20, **(_DWORD **)(v55 + 72));
    if (v55) {
      (*(void (**)(uint64_t))(*(void *)v55 + 16))(v55);
    }
    uint64_t v55 = 0;
    __ns.__rep_ = 2000000000;
    std::this_thread::sleep_for (&__ns);
    if (++v17 == 7) {
      goto LABEL_30;
    }
  }
  if (v22 == 2)
  {
    BOOL v34 = 1;
    goto LABEL_42;
  }
  uint64_t v50 = *(unsigned char **)(v55 + 136);
  if (v50) {
    BOOL v34 = (*v50 & 3) == 0;
  }
  else {
    BOOL v34 = 1;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "sim_state 0x%x sim_error_cause: 0x%x sim_ext_capabilities 0x%x isAbsentOk: %s\n", v18, v19, v20, **(_DWORD **)(v55 + 72));
LABEL_41:
  uint64_t v21 = v55;
  if (!v55) {
    goto LABEL_43;
  }
LABEL_42:
  (*(void (**)(uint64_t))(*(void *)v21 + 16))(v21);
LABEL_43:
  MEMORY[0x223C1D740](v56);
  *((unsigned char *)this + 286) = v34;
  *((unsigned char *)this + 288) = 0;
  if (v34) {
    goto LABEL_63;
  }
  if ((eUICC::VinylCommandDriver::GetData() & 1) == 0)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Invalid GetData response from the BB\n", v35, v36, v37, v51);
LABEL_63:
    *(_DWORD *)uint64_t v8 = 255;
    goto LABEL_5;
  }
  *((_DWORD *)this + 2) = *MEMORY[0x48];
  *(_WORD *)((char *)this + 13) = *MEMORY[0x58];
  std::string v38 = (_OWORD *)MEMORY[0x60];
  if (MEMORY[0x60] == MEMORY[0x68]) {
    std::string v38 = 0;
  }
  *(_OWORD *)((char *)this + 15) = *v38;
  *((unsigned char *)this + 31) = *MEMORY[0x78];
  std::string v39 = (_OWORD *)MEMORY[0x80];
  if (MEMORY[0x80] == MEMORY[0x88]) {
    std::string v39 = 0;
  }
  long long v40 = v39[1];
  *((_OWORD *)this + 2) = *v39;
  *((_OWORD *)this + 3) = v40;
  *((void *)this + 8) = *MEMORY[0x98];
  *((void *)this + 9) = *MEMORY[0xB0];
  int64_t v41 = (_OWORD *)MEMORY[0xC8];
  if (MEMORY[0xC8] == MEMORY[0xD0]) {
    int64_t v41 = 0;
  }
  *((_OWORD *)this + 5) = *v41;
  std::string v42 = (_OWORD *)MEMORY[0x128];
  if (MEMORY[0x128] == MEMORY[0x130]) {
    std::string v42 = 0;
  }
  *(_OWORD *)((char *)this + 155) = *v42;
  char v43 = (_OWORD *)MEMORY[0x1C0];
  if (MEMORY[0x1C0] == MEMORY[0x1C8]) {
    char v43 = 0;
  }
  long long v44 = v43[1];
  *(_OWORD *)((char *)this + 251) = *v43;
  *(_OWORD *)((char *)this + 267) = v44;
  *((_WORD *)this + 115) = *MEMORY[0x188];
  uint64_t v45 = MEMORY[0x1A8];
  if (MEMORY[0x1A8] == MEMORY[0x1B0]) {
    uint64_t v45 = 0;
  }
  char v46 = *(unsigned char *)(v45 + 2);
  *((_WORD *)this + 124) = *(_WORD *)v45;
  *((unsigned char *)this + 250) = v46;
  *((unsigned char *)this + 12) = *MEMORY[0x50];
  *((unsigned char *)this + 283) = *MEMORY[0x1E8];
  *((unsigned char *)this + 289) = 1;
  eUICC::logEUICCData((int *)this + 2);
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "result  0x%x \n", v47, v48, v49, *MEMORY[0x48]);
LABEL_5:
  memcpy(a2, (char *)this + 8, 0x11AuLL);
  return MEMORY[0x223C1D5E0](v53);
}

uint64_t eUICC::eUICCVinylICEValve::SetCardMode(uint64_t a1)
{
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v13[3] = v2;
  *(_OWORD *)std::string __p = v2;
  v13[1] = v2;
  void v13[2] = v2;
  v13[0] = v2;
  AriSdk::ARI_IBIVinylSwitchModeReq_SDK::ARI_IBIVinylSwitchModeReq_SDK((AriSdk::ARI_IBIVinylSwitchModeReq_SDK *)v13);
  uint64_t v3 = operator new(4uLL);
  *uint64_t v3 = *(_DWORD *)(a1 + 292);
  long long v4 = __p[0];
  __p[0] = v3;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = operator new(1uLL);
  unsigned char *v5 = 0;
  uint64_t v6 = __p[1];
  __p[1] = v5;
  if (v6) {
    operator delete(v6);
  }
  if (eUICC::VinylCommandDriver::SwitchCardMode())
  {
    uint64_t v10 = 0;
  }
  else
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Error: failed to SwitchCardMode\n", v7, v8, v9, v12);
    uint64_t v10 = 18;
  }
  MEMORY[0x223C1D6A0](v13);
  return v10;
}

uint64_t eUICC::eUICCVinylICEValve::InstallTicket(_DWORD *a1, CFDataRef *a2)
{
  __src[36] = *MEMORY[0x263EF8340];
  unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)long long v44 = v4;
  long long v45 = v4;
  v42[3] = v4;
  *(_OWORD *)std::string __p = v4;
  v42[1] = v4;
  v42[2] = v4;
  v42[0] = v4;
  AriSdk::ARI_IBIVinylInstallVadReq_SDK::ARI_IBIVinylInstallVadReq_SDK((AriSdk::ARI_IBIVinylInstallVadReq_SDK *)v42);
  if (*a2) {
    uint64_t v8 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v8)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v5, v6, v7, (char)"installTicket");
    goto LABEL_27;
  }
  (*(void (**)(uint64_t *__return_ptr, _DWORD *))(*(void *)a1 + 8))(__src, a1);
  uint64_t v9 = (capabilities::updater *)memcpy(a1 + 2, __src, 0x11AuLL);
  if (a1[2] == capabilities::updater::EUICCVinylSuccessStatus(v9))
  {
    if (*((unsigned char *)a1 + 31))
    {
      uint64_t v16 = (*(uint64_t (**)(_DWORD *, void, void))(*(void *)a1 + 16))(a1, 0, 0);
      if (v16)
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v13, v14, v15, (char)"kBBUReturnSuccess == ret");
        goto LABEL_28;
      }
    }
    int v17 = operator new(4uLL);
    *int v17 = a1[73];
    uint64_t v18 = __p[0];
    __p[0] = v17;
    if (v18) {
      operator delete(v18);
    }
    uint64_t v19 = operator new(2uLL);
    *uint64_t v19 = 1;
    uint64_t v20 = __p[1];
    __p[1] = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = operator new(2uLL);
    _WORD *v21 = 0;
    int v22 = v44[0];
    v44[0] = v21;
    if (v22) {
      operator delete(v22);
    }
    BytePtr = CFDataGetBytePtr(*a2);
    unint64_t Length = CFDataGetLength(*a2);
    if (Length >= 0xE01)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Ticket provided is larger than spec. [ %lu (lenth) > %lu (spec max) ] \n", v24, v25, v26, Length);
LABEL_27:
      uint64_t v16 = 2;
      goto LABEL_28;
    }
    uint64_t v29 = operator new(2uLL);
    _WORD *v29 = Length;
    uint64_t v31 = v44[1];
    v44[1] = v29;
    if (v31) {
      operator delete(v31);
    }
    if (Length)
    {
      uint64_t v32 = operator new(Length);
      memcpy(v32, BytePtr, Length);
      uint64_t v33 = operator new(Length);
      uint64_t v34 = (uint64_t)v33 + Length;
      __src[0] = (uint64_t)v33;
      __src[2] = (uint64_t)v33 + Length;
      memcpy(v33, v32, Length);
      __src[1] = v34;
    }
    else
    {
      uint64_t v32 = 0;
      memset(__src, 0, 24);
    }
    AriSdk::TlvArray<unsigned char,3584ul>::operator=((uint64_t)&v45, __src, v30);
    if (__src[0])
    {
      __src[1] = __src[0];
      operator delete((void *)__src[0]);
    }
    if (eUICC::VinylCommandDriver::InstallVad())
    {
      if (*MEMORY[0x48])
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "InstallTicket result 0x%x sw1_sw2 0x%hx\n", v35, v36, v37, *MEMORY[0x48]);
        uint64_t v16 = 16;
        if (!v32) {
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v16 = 0;
        if (!v32) {
          goto LABEL_28;
        }
      }
LABEL_47:
      operator delete(v32);
      goto LABEL_28;
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v35, v36, v37, (char)"status");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "InstallTicket failed to get desired response\n", v38, v39, v40, v41);
    uint64_t v16 = 11;
    if (v32) {
      goto LABEL_47;
    }
  }
  else
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v10, v11, v12, (char)"outData.Valid()");
    uint64_t v16 = 18;
  }
LABEL_28:
  MEMORY[0x223C1D680](v42);
  return v16;
}

void sub_21DEEC464(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31)
{
  if (v31)
  {
    operator delete(v31);
    MEMORY[0x223C1D680](&a15);
    _Unwind_Resume(a1);
  }
  MEMORY[0x223C1D680](&a15);
  _Unwind_Resume(a1);
}

uint64_t AriSdk::TlvArray<unsigned char,3584ul>::operator=(uint64_t a1, uint64_t *a2, const char *a3)
{
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if ((unint64_t)(v5 - *a2) < 0xE01)
  {
    uint64_t v10 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v10;
      operator delete(v10);
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      uint64_t v6 = *a2;
      uint64_t v5 = a2[1];
    }
    *(void *)a1 = v6;
    *(void *)(a1 + 8) = v5;
    *(void *)(a1 + 16) = a2[2];
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return a1;
  }
  else
  {
    AriOsa::LogSrcInfo((uint64_t *)__p, (AriOsa *)"/AppleInternal/Library/BuildRoots/7a5643da-a7fb-11ef-987a-36218cb420d5/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal.sdk/usr/local/include/ARI/ari_sdk_msg.h", "operator=", a3);
    if (v12 >= 0) {
      uint64_t v8 = __p;
    }
    else {
      uint64_t v8 = (void **)__p[0];
    }
    Ari::Log((Ari *)8, (uint64_t)"(%s:%d) Array assignment too large(%p), got(%zu) max(%zu)", v7, v8, 360, a1, a2[1] - *a2, 3584);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    return a1;
  }
}

void sub_21DEEC658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t eUICC::eUICCVinylICEValve::StreamFirmware(_DWORD *a1, uint64_t a2)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  uint64_t v70 = 0;
  memset(v69, 170, sizeof(v69));
  (*(void (**)(void **__return_ptr))(**(void **)a2 + 24))(v69);
  uint64_t v3 = v69[1];
  long long v4 = v69[0];
  (*(void (**)(_OWORD *__return_ptr, _DWORD *))(*(void *)a1 + 8))(v73, a1);
  uint64_t v5 = (capabilities::updater *)memcpy(a1 + 2, v73, 0x11AuLL);
  if (a1[2] != capabilities::updater::EUICCVinylSuccessStatus(v5))
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v6, v7, v8, (char)"outData.Valid()");
    uint64_t v10 = 18;
    uint64_t v11 = v70;
    if (!v70) {
      goto LABEL_58;
    }
LABEL_57:
    (*((void (**)(_DWORD **))*v11 + 2))(v11);
    goto LABEL_58;
  }
  if (*((unsigned char *)a1 + 31) == 1)
  {
    int v9 = 18;
  }
  else
  {
    uint64_t v10 = (*(uint64_t (**)(_DWORD *, void, void))(*(void *)a1 + 16))(a1, 0, 0);
    if (v10)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v6, v7, v8, (char)"kBBUReturnSuccess == ret");
      goto LABEL_56;
    }
    int v9 = 0;
  }
  unint64_t v12 = (v3 - v4) >> 5;
  unint64_t v13 = *((unsigned __int8 *)a1 + 304);
  unint64_t v67 = v12;
  if (v12 % v13) {
    uint64_t v14 = v12 / v13 + 1;
  }
  else {
    uint64_t v14 = v12 / v13;
  }
  if (v14)
  {
    unsigned int v63 = v9;
    uint64_t v68 = 0;
    uint64_t v15 = 0;
    long long v64 = (void *)&v73[6] + 1;
    uint64_t v65 = v14;
    *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    while (1)
    {
      v73[6] = v16;
      v73[7] = v16;
      v73[5] = v16;
      v73[3] = v16;
      v73[4] = v16;
      v73[1] = v16;
      v73[2] = v16;
      v73[0] = v16;
      uint64_t v17 = AriSdk::ARI_IBIVinylInstallFwReq_SDK::ARI_IBIVinylInstallFwReq_SDK((AriSdk::ARI_IBIVinylInstallFwReq_SDK *)v73);
      CFTypeRef v66 = v62;
      unint64_t v18 = *((unsigned __int8 *)a1 + 304);
      if (v67 - (v15 * v18) >= v18) {
        unint64_t v19 = *((unsigned __int8 *)a1 + 304);
      }
      else {
        unint64_t v19 = v67 - (v15 * v18);
      }
      MEMORY[0x270FA5388](v17);
      uint64_t v21 = &v62[-v20];
      bzero(&v62[-v20], v22);
      int v23 = operator new(4uLL);
      *int v23 = a1[73];
      uint64_t v27 = *(void **)&v73[4];
      *(void *)&v73[4] = v23;
      if (v27) {
        operator delete(v27);
      }
      uint64_t v28 = v21;
      if (v19) {
        break;
      }
LABEL_30:
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      uint64_t v37 = v65;
      _BBULog(0, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "StreamFirmware set %d/%zu adpusThisSet %zu\n", v24, v25, v26, v15);
      uint64_t v38 = operator new(2uLL);
      *uint64_t v38 = v37;
      uint64_t v39 = (void *)*((void *)&v73[4] + 1);
      *((void *)&v73[4] + 1) = v38;
      if (v39) {
        operator delete(v39);
      }
      uint64_t v40 = operator new(2uLL);
      *uint64_t v40 = v15;
      char v41 = *(void **)&v73[5];
      *(void *)&v73[5] = v40;
      if (v41) {
        operator delete(v41);
      }
      std::string v42 = operator new(2uLL);
      *std::string v42 = (_WORD)v28 - (_WORD)v21;
      long long v44 = *(void **)&v73[6];
      *(void *)&v73[6] = v42;
      if (v44) {
        operator delete(v44);
      }
      if ((unint64_t)(v28 - v21) >= 0xF5B)
      {
        AriOsa::LogSrcInfo((uint64_t *)v71, (AriOsa *)"/AppleInternal/Library/BuildRoots/7a5643da-a7fb-11ef-987a-36218cb420d5/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal.sdk/usr/local/include/ARI/ari_sdk_msg.h", "assign", v43);
        unint64_t v46 = v71;
        if (v72 < 0) {
          unint64_t v46 = (void **)v71[0];
        }
        Ari::Log((Ari *)8, (uint64_t)"(%s:%d) Range assignment too large(%p), got(%ld) max(%ld)", v45, v46, 385, v64, v28 - v21, 3930);
        if (v72 < 0) {
          operator delete(v71[0]);
        }
      }
      else
      {
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(v64, v21, v28, v28 - v21);
      }
      uint64_t v47 = operator new(1uLL);
      unsigned char *v47 = v19;
      uint64_t v48 = (void *)*((void *)&v73[5] + 1);
      *((void *)&v73[5] + 1) = v47;
      if (v48) {
        operator delete(v48);
      }
      if ((eUICC::VinylCommandDriver::StreamFW() & 1) == 0)
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v49, v50, v51, (char)"status");
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "StreamFirmware failed\n", v56, v57, v58, v62[0]);
        uint64_t v10 = 11;
        goto LABEL_55;
      }
      if (*v70[9])
      {
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v49, v50, v51, (char)"!GET_RSP_FIELD(rsp, result_t3)");
        if (gBBULogMaskGet(void)::once != -1) {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        }
        _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Failed StreamAPDU set %d/%zu, status %d sw1_sw2 0x%x \n", v59, v60, v61, v15);
        uint64_t v10 = 16;
        goto LABEL_55;
      }
      (*((void (**)(_DWORD **))*v70 + 2))(v70);
      uint64_t v70 = 0;
      MEMORY[0x223C1D640](v73);
      uint64_t v10 = 0;
      ++v15;
      v68 += 32;
      *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
      if (v15 == v37) {
        goto LABEL_56;
      }
    }
    unint64_t v29 = v67 - (v15 * v18);
    if (v29 >= v18) {
      unint64_t v29 = v18;
    }
    uint64_t v30 = 32 * v29;
    uint64_t v31 = (size_t *)((char *)v69[0] + v68 * *((unsigned __int8 *)a1 + 304) + 24);
    uint64_t v28 = v21;
    while (1)
    {
      unint64_t v32 = *(v31 - 2);
      if (v32 > 5 || *v31 >= 0x100) {
        break;
      }
      uint64_t v33 = &v28[v32 + *v31];
      *uint64_t v28 = v32;
      memcpy(v28 + 1, (const void *)*(v31 - 3), *(v31 - 2));
      v28[*(v31 - 2) + 1] = *(unsigned char *)v31;
      uint64_t v34 = (const void *)*(v31 - 1);
      uint64_t v35 = &v28[*(v31 - 2) + 2];
      size_t v36 = *v31;
      v31 += 4;
      memcpy(v35, v34, v36);
      uint64_t v28 = v33 + 2;
      v30 -= 32;
      if (!v30) {
        goto LABEL_30;
      }
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    uint64_t v10 = v63;
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v24, v25, v26, (char)"f.header.length <= 5 && f.data.length <= 255");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Firmware APDU not within expected bounds : received (header - 5 : %zu data- 255 : %zu\n", v52, v53, v54, *(v31 - 2));
LABEL_55:
    MEMORY[0x223C1D640](v73);
LABEL_56:
    uint64_t v11 = v70;
    if (!v70) {
      goto LABEL_58;
    }
    goto LABEL_57;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v6, v7, v8, (char)"apduSetCount");
  uint64_t v10 = 15;
  uint64_t v11 = v70;
  if (v70) {
    goto LABEL_57;
  }
LABEL_58:
  uint64_t v70 = 0;
  if (v69[0])
  {
    v69[1] = v69[0];
    operator delete(v69[0]);
  }
  return v10;
}

void sub_21DEECF58(_Unwind_Exception *a1)
{
  MEMORY[0x223C1D640](v1 + 112);
  uint64_t v3 = *(void **)(v1 + 56);
  if (!v3) {
    _Unwind_Resume(a1);
  }
  *(void *)(v1 + 64) = v3;
  operator delete(v3);
  _Unwind_Resume(a1);
}

uint64_t eUICC::eUICCVinylICEValve::DeleteProfile(eUICC::eUICCVinylICEValve *this, unsigned int a2)
{
  unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)unint64_t v32 = v4;
  long long v33 = v4;
  *(_OWORD *)std::string __p = v4;
  *(_OWORD *)uint64_t v31 = v4;
  v29[2] = v4;
  void v29[3] = v4;
  v29[0] = v4;
  v29[1] = v4;
  AriSdk::ARI_IBIVinylTapeReq_SDK::ARI_IBIVinylTapeReq_SDK((AriSdk::ARI_IBIVinylTapeReq_SDK *)v29);
  uint64_t v28 = 0;
  v27[0] = 0xBFD00602820434BFLL;
  *(void *)((char *)v27 + 6) = 0xD80602820434BFD0;
  uint64_t v5 = operator new(4uLL);
  _DWORD *v5 = *((_DWORD *)this + 73);
  uint64_t v6 = __p[0];
  __p[0] = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = operator new(4uLL);
  *uint64_t v7 = 16;
  uint64_t v8 = __p[1];
  __p[1] = v7;
  if (v8) {
    operator delete(v8);
  }
  int v9 = operator new(4uLL);
  *int v9 = 1;
  uint64_t v10 = v31[0];
  v31[0] = v9;
  if (v10) {
    operator delete(v10);
  }
  uint64_t v11 = operator new(2uLL);
  *uint64_t v11 = 1;
  unint64_t v12 = v31[1];
  v31[1] = v11;
  if (v12) {
    operator delete(v12);
  }
  unint64_t v13 = operator new(2uLL);
  *unint64_t v13 = 0;
  uint64_t v14 = v32[0];
  v32[0] = v13;
  if (v14) {
    operator delete(v14);
  }
  uint64_t v15 = operator new(2uLL);
  *uint64_t v15 = 7;
  long long v16 = v32[1];
  v32[1] = v15;
  if (v16) {
    operator delete(v16);
  }
  uint64_t v17 = (char *)&v27[a2] - a2;
  std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(&v33, v17, v17 + 7, 7uLL);
  if (eUICC::VinylCommandDriver::DeleteProfile())
  {
    uint64_t v21 = v28;
    if (**(_DWORD **)(v28 + 80))
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v18, v19, v20, (char)"!GET_RSP_FIELD(rsp, result_t4)");
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Failed to DeleteProfile status %d SW1_SW2 0x%x\n", v22, v23, v24, **(_DWORD **)(v28 + 80));
      uint64_t v25 = 18;
      uint64_t v21 = v28;
      if (!v28) {
        goto LABEL_27;
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
LABEL_26:
    (*(void (**)(uint64_t))(*(void *)v21 + 16))(v21);
    goto LABEL_27;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v18, v19, v20, (char)"status");
  uint64_t v25 = 11;
  uint64_t v21 = v28;
  if (v28) {
    goto LABEL_26;
  }
LABEL_27:
  MEMORY[0x223C1D560](v29);
  return v25;
}

uint64_t eUICC::eUICCVinylICEValve::StoreData(uint64_t a1, char **a2, void *a3, _WORD *a4)
{
  unint64_t v50 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v48 = v8;
  *(_OWORD *)int __dst = v8;
  *(_OWORD *)std::string __p = v8;
  *(_OWORD *)uint64_t v47 = v8;
  unint64_t v45[2] = v8;
  v45[3] = v8;
  v45[0] = v8;
  v45[1] = v8;
  AriSdk::ARI_IBIVinylTapeReq_SDK::ARI_IBIVinylTapeReq_SDK((AriSdk::ARI_IBIVinylTapeReq_SDK *)v45);
  int v9 = operator new(4uLL);
  *int v9 = *(_DWORD *)(a1 + 292);
  uint64_t v10 = __p[0];
  __p[0] = v9;
  if (v10) {
    operator delete(v10);
  }
  uint64_t v11 = operator new(4uLL);
  *uint64_t v11 = 5;
  unint64_t v12 = __p[1];
  __p[1] = v11;
  if (v12) {
    operator delete(v12);
  }
  unint64_t v13 = operator new(4uLL);
  *unint64_t v13 = 1;
  uint64_t v14 = v47[0];
  v47[0] = v13;
  if (v14) {
    operator delete(v14);
  }
  uint64_t v15 = operator new(2uLL);
  *uint64_t v15 = 1;
  long long v16 = v47[1];
  v47[1] = v15;
  if (v16) {
    operator delete(v16);
  }
  uint64_t v17 = operator new(2uLL);
  *uint64_t v17 = 0;
  uint64_t v18 = v48[0];
  v48[0] = v17;
  if (v18) {
    operator delete(v18);
  }
  uint64_t v19 = *a2;
  uint64_t v20 = a2[1];
  uint64_t v21 = operator new(2uLL);
  size_t v23 = v20 - v19;
  _WORD *v21 = (_WORD)v20 - (_WORD)v19;
  uint64_t v24 = v48[1];
  v48[1] = v21;
  if (v24)
  {
    operator delete(v24);
    uint64_t v19 = *a2;
    uint64_t v20 = a2[1];
    size_t v23 = v20 - *a2;
  }
  if (v23 < 0xE01)
  {
    unint64_t v25 = v50;
    uint64_t v26 = (char *)__dst[0];
    if (v50 - (unint64_t)__dst[0] < v23)
    {
      if (__dst[0])
      {
        __dst[1] = __dst[0];
        operator delete(__dst[0]);
        unint64_t v25 = 0;
        __dst[0] = 0;
        __dst[1] = 0;
        unint64_t v50 = 0;
      }
      uint64_t v27 = 2 * v25;
      if (2 * v25 <= v23) {
        uint64_t v27 = v23;
      }
      if (v25 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v28 = v27;
      }
      if ((v28 & 0x8000000000000000) != 0) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v29 = (char *)operator new(v28);
      uint64_t v30 = v29;
      __dst[0] = v29;
      __dst[1] = v29;
      unint64_t v50 = (unint64_t)&v29[v28];
      if (v20 != v19) {
        memmove(v29, v19, v23);
      }
      uint64_t v31 = &v30[v23];
      goto LABEL_40;
    }
    if ((char *)__dst[1] - (char *)__dst[0] >= v23)
    {
      if (v20 == v19)
      {
LABEL_39:
        uint64_t v31 = &v26[v23];
LABEL_40:
        __dst[1] = v31;
        goto LABEL_41;
      }
      uint64_t v35 = __dst[0];
      size_t v36 = v19;
    }
    else
    {
      unint64_t v34 = &v19[(char *)__dst[1] - (char *)__dst[0]];
      if (__dst[1] != __dst[0])
      {
        memmove(__dst[0], v19, (char *)__dst[1] - (char *)__dst[0]);
        uint64_t v26 = (char *)__dst[1];
      }
      size_t v23 = v20 - v34;
      if (v20 == v34) {
        goto LABEL_39;
      }
      uint64_t v35 = v26;
      size_t v36 = v34;
    }
    memmove(v35, v36, v23);
    goto LABEL_39;
  }
  AriOsa::LogSrcInfo((uint64_t *)v51, (AriOsa *)"/AppleInternal/Library/BuildRoots/7a5643da-a7fb-11ef-987a-36218cb420d5/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal.sdk/usr/local/include/ARI/ari_sdk_msg.h", "assign", v22);
  if (v52 >= 0) {
    long long v33 = v51;
  }
  else {
    long long v33 = (void **)v51[0];
  }
  Ari::Log((Ari *)8, (uint64_t)"(%s:%d) Range assignment too large(%p), got(%ld) max(%ld)", v32, v33, 385, __dst, v23, 3584);
  if (v52 < 0) {
    operator delete(v51[0]);
  }
LABEL_41:
  if (eUICC::VinylCommandDriver::DeleteProfile())
  {
    if (*MEMORY[0x50])
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v37, v38, v39, (char)"!GET_RSP_FIELD(rsp, result_t4)");
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Failed to store data status %d SW1_SW2 0x%x\n", v40, v41, v42, *MEMORY[0x50]);
      uint64_t v43 = 18;
    }
    else
    {
      std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(a3, MEMORY[0x78], (char *)(MEMORY[0x78] + (unsigned __int16)*MEMORY[0x70]), (unsigned __int16)*MEMORY[0x70]);
      uint64_t v43 = 0;
      *a4 = *MEMORY[0x58];
      (*(void (**)(void))(MEMORY[0] + 16))(0);
    }
  }
  else
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v37, v38, v39, (char)"status");
    uint64_t v43 = 11;
  }
  MEMORY[0x223C1D560](v45);
  return v43;
}

void sub_21DEED7B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  MEMORY[0x223C1D560](va);
  _Unwind_Resume(a1);
}

uint64_t eUICC::eUICCVinylICEValve::InitPerso(uint64_t a1, void *a2, void *a3)
{
  unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v41 = v6;
  long long v42 = v6;
  v39[3] = v6;
  *(_OWORD *)std::string __p = v6;
  v39[1] = v6;
  v39[2] = v6;
  v39[0] = v6;
  AriSdk::ARI_IBIVinylInitPsoReq_SDK::ARI_IBIVinylInitPsoReq_SDK((AriSdk::ARI_IBIVinylInitPsoReq_SDK *)v39);
  uint64_t v38 = 0;
  uint64_t v10 = a2[1];
  uint64_t v11 = v10 - *a2;
  size_t v12 = (unsigned __int16)(v10 - *(_WORD *)a2);
  if (v12 < 0xE01)
  {
    unint64_t v13 = operator new(4uLL);
    *unint64_t v13 = *(_DWORD *)(a1 + 292);
    uint64_t v14 = __p[0];
    __p[0] = v13;
    if (v14) {
      operator delete(v14);
    }
    uint64_t v15 = operator new(1uLL);
    *uint64_t v15 = 0;
    long long v16 = __p[1];
    __p[1] = v15;
    if (v16) {
      operator delete(v16);
    }
    uint64_t v17 = operator new(1uLL);
    *uint64_t v17 = 0;
    uint64_t v18 = v41[0];
    v41[0] = v17;
    if (v18) {
      operator delete(v18);
    }
    uint64_t v19 = operator new(2uLL);
    *uint64_t v19 = v11;
    uint64_t v21 = v41[1];
    v41[1] = v19;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = (const void *)*a2;
    size_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v35 = 0;
    if (v12)
    {
      size_t v23 = (char *)operator new(v12);
      uint64_t v24 = &v23[v12];
      uint64_t v35 = v23;
      uint64_t v37 = &v23[v12];
      memcpy(v23, v22, v12);
      size_t v36 = v24;
    }
    AriSdk::TlvArray<unsigned char,3584ul>::operator=((uint64_t)&v42, (uint64_t *)&v35, v20);
    if (v35) {
      operator delete(v35);
    }
    if ((eUICC::VinylCommandDriver::InitPerso() & 1) == 0)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v25, v26, v27, (char)"status");
      uint64_t v31 = 11;
      uint64_t v32 = v38;
      if (v38) {
        goto LABEL_25;
      }
      goto LABEL_26;
    }
    if (!**(_DWORD **)(v38 + 72))
    {
      unint64_t v34 = *(_WORD **)(v38 + 88);
      if (*v34)
      {
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(a3, *(char **)(v38 + 96), (char *)(*(void *)(v38 + 96) + (unsigned __int16)*v34), (unsigned __int16)*v34);
        uint64_t v31 = 0;
        uint64_t v32 = v38;
        if (!v38) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v25, v26, v27, (char)"!GET_RSP_FIELD(rsp, result_t3) && GET_RSP_FIELD(rsp, sim_rsp_len_t5)");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Failed to InitPerso status %d SW1_SW2 0x%x rsp_len %u\n", v28, v29, v30, **(_DWORD **)(v38 + 72));
  }
  else
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Payload too large -- payload_size: %d  max allowed: %lu)\n", v7, v8, v9, v11);
  }
  uint64_t v31 = 18;
  uint64_t v32 = v38;
  if (v38) {
LABEL_25:
  }
    (*(void (**)(uint64_t))(*(void *)v32 + 16))(v32);
LABEL_26:
  MEMORY[0x223C1D600](v39);
  return v31;
}

void sub_21DEEDB78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t eUICC::eUICCVinylICEValve::AuthPerso(uint64_t a1, void *a2, void *a3)
{
  unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v41 = v6;
  long long v42 = v6;
  v39[3] = v6;
  *(_OWORD *)std::string __p = v6;
  v39[1] = v6;
  v39[2] = v6;
  v39[0] = v6;
  AriSdk::ARI_IBIVinylAuthPsoReq_SDK::ARI_IBIVinylAuthPsoReq_SDK((AriSdk::ARI_IBIVinylAuthPsoReq_SDK *)v39);
  uint64_t v38 = 0;
  uint64_t v10 = a2[1];
  uint64_t v11 = v10 - *a2;
  size_t v12 = (unsigned __int16)(v10 - *(_WORD *)a2);
  if (v12 < 0xE01)
  {
    unint64_t v13 = operator new(4uLL);
    *unint64_t v13 = *(_DWORD *)(a1 + 292);
    uint64_t v14 = __p[0];
    __p[0] = v13;
    if (v14) {
      operator delete(v14);
    }
    uint64_t v15 = operator new(1uLL);
    *uint64_t v15 = 0;
    long long v16 = __p[1];
    __p[1] = v15;
    if (v16) {
      operator delete(v16);
    }
    uint64_t v17 = operator new(1uLL);
    *uint64_t v17 = 0;
    uint64_t v18 = v41[0];
    v41[0] = v17;
    if (v18) {
      operator delete(v18);
    }
    uint64_t v19 = operator new(2uLL);
    *uint64_t v19 = v11;
    uint64_t v21 = v41[1];
    v41[1] = v19;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = (const void *)*a2;
    size_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v35 = 0;
    if (v12)
    {
      size_t v23 = (char *)operator new(v12);
      uint64_t v24 = &v23[v12];
      uint64_t v35 = v23;
      uint64_t v37 = &v23[v12];
      memcpy(v23, v22, v12);
      size_t v36 = v24;
    }
    AriSdk::TlvArray<unsigned char,3584ul>::operator=((uint64_t)&v42, (uint64_t *)&v35, v20);
    if (v35) {
      operator delete(v35);
    }
    if ((eUICC::VinylCommandDriver::AuthPerso() & 1) == 0)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v25, v26, v27, (char)"status");
      uint64_t v31 = 11;
      uint64_t v32 = v38;
      if (v38) {
        goto LABEL_25;
      }
      goto LABEL_26;
    }
    if (!**(_DWORD **)(v38 + 72))
    {
      unint64_t v34 = *(_WORD **)(v38 + 88);
      if (*v34)
      {
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(a3, *(char **)(v38 + 96), (char *)(*(void *)(v38 + 96) + (unsigned __int16)*v34), (unsigned __int16)*v34);
        uint64_t v31 = 0;
        uint64_t v32 = v38;
        if (!v38) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v25, v26, v27, (char)"!GET_RSP_FIELD(rsp, result_t3) && GET_RSP_FIELD(rsp, sim_rsp_len_t5)");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Failed to AuthPerso status %d SW1_SW2 0x%x rsp_len %u\n", v28, v29, v30, **(_DWORD **)(v38 + 72));
  }
  else
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Payload too large -- payload_size: %d  max allowed: %lu)\n", v7, v8, v9, v11);
  }
  uint64_t v31 = 18;
  uint64_t v32 = v38;
  if (v38) {
LABEL_25:
  }
    (*(void (**)(uint64_t))(*(void *)v32 + 16))(v32);
LABEL_26:
  MEMORY[0x223C1D5C0](v39);
  return v31;
}

void sub_21DEEDF34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t eUICC::eUICCVinylICEValve::FinalizePerso(uint64_t a1, void *a2)
{
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v38 = v4;
  long long v39 = v4;
  _OWORD v36[3] = v4;
  *(_OWORD *)std::string __p = v4;
  v36[1] = v4;
  v36[2] = v4;
  v36[0] = v4;
  AriSdk::ARI_IBIVinylFinalizePsoReq_SDK::ARI_IBIVinylFinalizePsoReq_SDK((AriSdk::ARI_IBIVinylFinalizePsoReq_SDK *)v36);
  uint64_t v35 = 0;
  uint64_t v8 = a2[1];
  uint64_t v9 = v8 - *a2;
  size_t v10 = (unsigned __int16)(v8 - *(_WORD *)a2);
  if (v10 >= 0xE01)
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Payload too large -- payload_size: %d  max allowed: %lu)\n", v5, v6, v7, v9);
    goto LABEL_24;
  }
  uint64_t v11 = operator new(4uLL);
  *uint64_t v11 = *(_DWORD *)(a1 + 292);
  size_t v12 = __p[0];
  __p[0] = v11;
  if (v12) {
    operator delete(v12);
  }
  unint64_t v13 = operator new(1uLL);
  *unint64_t v13 = 0;
  uint64_t v14 = __p[1];
  __p[1] = v13;
  if (v14) {
    operator delete(v14);
  }
  uint64_t v15 = operator new(1uLL);
  *uint64_t v15 = 0;
  long long v16 = v38[0];
  v38[0] = v15;
  if (v16) {
    operator delete(v16);
  }
  uint64_t v17 = operator new(2uLL);
  *uint64_t v17 = v9;
  uint64_t v19 = v38[1];
  v38[1] = v17;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = (const void *)*a2;
  long long v33 = 0;
  unint64_t v34 = 0;
  uint64_t v32 = 0;
  if (v10)
  {
    uint64_t v21 = (char *)operator new(v10);
    uint64_t v22 = &v21[v10];
    uint64_t v32 = v21;
    unint64_t v34 = &v21[v10];
    memcpy(v21, v20, v10);
    long long v33 = v22;
  }
  AriSdk::TlvArray<unsigned char,3584ul>::operator=((uint64_t)&v39, (uint64_t *)&v32, v18);
  if (v32) {
    operator delete(v32);
  }
  if (eUICC::VinylCommandDriver::FinalizePerso())
  {
    uint64_t v26 = v35;
    if (**(_DWORD **)(v35 + 72))
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v23, v24, v25, (char)"!GET_RSP_FIELD(rsp, result_t3)");
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Failed to FinalizePerso status %d SW1_SW2 0x%x\n", v27, v28, v29, **(_DWORD **)(v35 + 72));
LABEL_24:
      uint64_t v30 = 18;
      uint64_t v26 = v35;
      if (!v35) {
        goto LABEL_32;
      }
      goto LABEL_31;
    }
    uint64_t v30 = 0;
LABEL_31:
    (*(void (**)(uint64_t))(*(void *)v26 + 16))(v26);
    goto LABEL_32;
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v23, v24, v25, (char)"status");
  uint64_t v30 = 11;
  uint64_t v26 = v35;
  if (v35) {
    goto LABEL_31;
  }
LABEL_32:
  MEMORY[0x223C1D6C0](v36);
  return v30;
}

void sub_21DEEE2B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t eUICC::eUICCVinylICEValve::ValidatePerso(uint64_t a1, void *a2, void *a3)
{
  unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v41 = v6;
  long long v42 = v6;
  v39[3] = v6;
  *(_OWORD *)std::string __p = v6;
  v39[1] = v6;
  v39[2] = v6;
  v39[0] = v6;
  AriSdk::ARI_IBIVinylValidatePsoReq_SDK::ARI_IBIVinylValidatePsoReq_SDK((AriSdk::ARI_IBIVinylValidatePsoReq_SDK *)v39);
  uint64_t v38 = 0;
  uint64_t v10 = a2[1];
  uint64_t v11 = v10 - *a2;
  size_t v12 = (unsigned __int16)(v10 - *(_WORD *)a2);
  if (v12 < 0xE01)
  {
    unint64_t v13 = operator new(4uLL);
    *unint64_t v13 = *(_DWORD *)(a1 + 292);
    uint64_t v14 = __p[0];
    __p[0] = v13;
    if (v14) {
      operator delete(v14);
    }
    uint64_t v15 = operator new(2uLL);
    *uint64_t v15 = 1;
    long long v16 = __p[1];
    __p[1] = v15;
    if (v16) {
      operator delete(v16);
    }
    uint64_t v17 = operator new(2uLL);
    *uint64_t v17 = 0;
    uint64_t v18 = v41[0];
    v41[0] = v17;
    if (v18) {
      operator delete(v18);
    }
    uint64_t v19 = operator new(2uLL);
    *uint64_t v19 = v11;
    uint64_t v21 = v41[1];
    v41[1] = v19;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = (const void *)*a2;
    size_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v35 = 0;
    if (v12)
    {
      uint64_t v23 = (char *)operator new(v12);
      uint64_t v24 = &v23[v12];
      uint64_t v35 = v23;
      uint64_t v37 = &v23[v12];
      memcpy(v23, v22, v12);
      size_t v36 = v24;
    }
    AriSdk::TlvArray<unsigned char,3584ul>::operator=((uint64_t)&v42, (uint64_t *)&v35, v20);
    if (v35) {
      operator delete(v35);
    }
    if ((eUICC::VinylCommandDriver::ValidatePerso() & 1) == 0)
    {
      if (gBBULogMaskGet(void)::once != -1) {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      }
      _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v25, v26, v27, (char)"status");
      uint64_t v31 = 11;
      uint64_t v32 = v38;
      if (v38) {
        goto LABEL_25;
      }
      goto LABEL_26;
    }
    if (!**(_DWORD **)(v38 + 72))
    {
      unint64_t v34 = *(_WORD **)(v38 + 88);
      if (*v34)
      {
        std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(a3, *(char **)(v38 + 96), (char *)(*(void *)(v38 + 96) + (unsigned __int16)*v34), (unsigned __int16)*v34);
        uint64_t v31 = 0;
        uint64_t v32 = v38;
        if (!v38) {
          goto LABEL_26;
        }
        goto LABEL_25;
      }
    }
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(25, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Condition <<%s>> failed %s %s/%d\n", v25, v26, v27, (char)"!GET_RSP_FIELD(rsp, result_t3) && GET_RSP_FIELD(rsp, sim_rsp_len_t5)");
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Failed to AuthPerso status %d SW1_SW2 0x%x rsp_len %u\n", v28, v29, v30, **(_DWORD **)(v38 + 72));
  }
  else
  {
    if (gBBULogMaskGet(void)::once != -1) {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    }
    _BBULog(22, 0xFFFFFFFFLL, "eUICCVinylICEValve", "", "Payload too large -- payload_size: %d  max allowed: %lu)\n", v7, v8, v9, v11);
  }
  uint64_t v31 = 18;
  uint64_t v32 = v38;
  if (v38) {
LABEL_25:
  }
    (*(void (**)(uint64_t))(*(void *)v32 + 16))(v32);
LABEL_26:
  MEMORY[0x223C1D6E0](v39);
  return v31;
}

void sub_21DEEE670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void eUICC::eUICCVinylICEValve::~eUICCVinylICEValve(eUICC::eUICCVinylICEValve *this)
{
  *(void *)this = &unk_26CECAAD0;
  long long v2 = (eUICC::VinylCommandDriver *)*((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v2)
  {
    eUICC::VinylCommandDriver::~VinylCommandDriver(v2);
    operator delete(v3);
  }
}

{
  eUICC::VinylCommandDriver *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26CECAAD0;
  long long v2 = (eUICC::VinylCommandDriver *)*((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v2)
  {
    eUICC::VinylCommandDriver::~VinylCommandDriver(v2);
    operator delete(v3);
  }

  operator delete(this);
}

void std::__shared_ptr_pointer<ICEARIContext *,std::shared_ptr<ICEARIContext>::__shared_ptr_default_delete<ICEARIContext,ICEARIContext>,std::allocator<ICEARIContext>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<ICEARIContext *,std::shared_ptr<ICEARIContext>::__shared_ptr_default_delete<ICEARIContext,ICEARIContext>,std::allocator<ICEARIContext>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t std::__shared_ptr_pointer<ICEARIContext *,std::shared_ptr<ICEARIContext>::__shared_ptr_default_delete<ICEARIContext,ICEARIContext>,std::allocator<ICEARIContext>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFAB8B7) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFAB8B7 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFAB8B7)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFAB8B7 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void *std::vector<unsigned char>::__assign_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  uint64_t v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      unint64_t v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      goto LABEL_21;
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    size_t v11 = v8 >= 0x3FFFFFFFFFFFFFFFLL ? 0x7FFFFFFFFFFFFFFFLL : v10;
    if ((v11 & 0x8000000000000000) != 0) {
LABEL_21:
    }
      std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
    uint64_t result = operator new(v11);
    uint64_t v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    unint64_t v7[2] = (char *)result + v11;
    goto LABEL_18;
  }
  size_t v12 = (unsigned char *)result[1];
  if (v12 - v9 >= a4)
  {
LABEL_18:
    size_t v14 = a3 - __src;
    if (v14) {
      uint64_t result = memmove(v9, __src, v14);
    }
    v7[1] = &v9[v14];
    return result;
  }
  unint64_t v13 = &__src[v12 - v9];
  if (v12 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v12 - v9);
    uint64_t v9 = (char *)v7[1];
  }
  if (a3 != v13) {
    uint64_t result = memmove(v9, v13, a3 - v13);
  }
  v7[1] = &v9[a3 - v13];
  return result;
}

uint64_t __cxx_global_var_init_5()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ICEARIContext>::~PthreadMutexGuardPolicy, &ctu::Singleton<ICEARIContext,ICEARIContext,ctu::PthreadMutexGuardPolicy<ICEARIContext>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::buffer>::~PthreadMutexGuardPolicy, &ctu::Singleton<support::log::buffer,support::log::buffer,ctu::PthreadMutexGuardPolicy<support::log::buffer>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

uint64_t support::cf::createNum64Num32FromData(ACFULogging *Length, const void **a2)
{
  if (Length)
  {
    if (a2
      && (CFDataRef v3 = Length,
          BytePtr = CFDataGetBytePtr(Length),
          unint64_t Length = (ACFULogging *)CFDataGetLength(v3),
          (unint64_t)Length - 9 > 0xFFFFFFFFFFFFFFF7))
    {
      if ((unint64_t)Length < 5)
      {
        int valuePtr = 0;
        memcpy(&valuePtr, BytePtr, (size_t)Length);
        uint64_t v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
        uint64_t v9 = *a2;
        *a2 = v5;
        if (v9)
        {
          CFRelease(v9);
          uint64_t v5 = (ACFULogging *)*a2;
        }
        if (v5) {
          uint64_t v10 = ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get;
        }
        else {
          uint64_t v10 = 0;
        }
        if (v10) {
          return 1;
        }
      }
      else
      {
        uint64_t __dst = 0;
        memcpy(&__dst, BytePtr, (size_t)Length);
        uint64_t v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt64Type, &__dst);
        long long v6 = *a2;
        *a2 = v5;
        if (v6)
        {
          CFRelease(v6);
          uint64_t v5 = (ACFULogging *)*a2;
        }
        if (v5) {
          uint64_t v7 = ctu::SharedRef<__CFNumber const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFNumber const>::get;
        }
        else {
          uint64_t v7 = 0;
        }
        if (v7) {
          return 1;
        }
      }
      ACFULogging::getLogInstance(v5);
    }
    else
    {
      ACFULogging::getLogInstance(Length);
    }
  }
  else
  {
    ACFULogging::getLogInstance(0);
  }
  ACFULogging::handleMessage();
  return 0;
}

uint64_t support::cf::createByteSwappedData(CFDataRef theData, CFDataRef *a2)
{
  if (a2)
  {
    CFDataRef v2 = theData;
    if (theData)
    {
      CFDataRef theData = (CFDataRef)CFDataGetLength(theData);
      if (theData)
      {
        CFDataRef v4 = theData;
        uint64_t v5 = (UInt8 *)malloc((size_t)theData);
        v13.CFIndex location = 0;
        v13.CFIndex length = (CFIndex)v4;
        CFDataGetBytes(v2, v13, v5);
        long long v6 = (UInt8 *)v4 + (void)v5 - 1;
        if (v6 > v5)
        {
          uint64_t v7 = v5 + 1;
          do
          {
            UInt8 v8 = *(v7 - 1);
            *(v7 - 1) = *v6;
            *v6-- = v8;
          }
          while (v7++ < v6);
        }
        CFDataRef theData = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v5, (CFIndex)v4, (CFAllocatorRef)*MEMORY[0x263EFFB18]);
        CFDataRef v10 = *a2;
        *a2 = theData;
        if (v10)
        {
          CFRelease(v10);
          CFDataRef theData = *a2;
        }
        if (theData
           ? ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get
           : 0)
        {
          return 1;
        }
      }
    }
  }
  ACFULogging::getLogInstance(theData);
  ACFULogging::handleMessage();
  return 0;
}

uint64_t support::cf::createNum32FromString(support::cf *this, const __CFString *a2, const __CFNumber **a3)
{
  uint64_t v3 = 0;
  int valuePtr = 0;
  memset(&__p, 0, sizeof(__p));
  if (this && a2)
  {
    if ((ctu::cf::assign() & 1) == 0)
    {
      uint64_t v3 = 0;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v3;
      }
      goto LABEL_8;
    }
    int valuePtr = std::stoi(&__p, 0, 10);
    a2->isa = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
    uint64_t v3 = 1;
  }
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    return v3;
  }
LABEL_8:
  operator delete(__p.__r_.__value_.__l.__data_);
  return v3;
}

uint64_t support::cf::copyDataFromHexString(support::cf *this, const __CFString *a2, const __CFData **a3)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (!this)
  {
    ACFULogging::getLogInstance(0);
LABEL_11:
    ACFULogging::handleMessage();
    return 0;
  }
  if (!a2)
  {
    ACFULogging::getLogInstance(this);
    goto LABEL_11;
  }
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v38 = v4;
  long long v39 = v4;
  long long v36 = v4;
  long long v37 = v4;
  long long v34 = v4;
  long long v35 = v4;
  long long v32 = v4;
  long long v33 = v4;
  long long v30 = v4;
  long long v31 = v4;
  long long v28 = v4;
  long long v29 = v4;
  long long v26 = v4;
  long long v27 = v4;
  long long v24 = v4;
  long long v25 = v4;
  long long v22 = v4;
  long long v23 = v4;
  long long v20 = v4;
  long long v21 = v4;
  long long v18 = v4;
  long long v19 = v4;
  long long v16 = v4;
  long long v17 = v4;
  long long v14 = v4;
  long long v15 = v4;
  long long v12 = v4;
  long long v13 = v4;
  long long v10 = v4;
  long long v11 = v4;
  *(_OWORD *)__CFString buffer = v4;
  long long v9 = v4;
  CString = (ACFULogging *)CFStringGetCString((CFStringRef)this, buffer, 512, 0x8000100u);
  if (!CString)
  {
    ACFULogging::getLogInstance(CString);
    goto LABEL_11;
  }
  long long v6 = (void *)AMSupportCopyDataFromAsciiEncodedHex();
  a2->isa = v6;
  if (!v6)
  {
    ACFULogging::getLogInstance(0);
    goto LABEL_11;
  }
  return 1;
}

uint64_t BBUPersonalizedConsoleFeedback::writeToStreamInternal(BBUPersonalizedConsoleFeedback *this, const char *__format, va_list a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v8[14] = v6;
  v8[15] = v6;
  v8[12] = v6;
  v8[13] = v6;
  v8[10] = v6;
  v8[11] = v6;
  v8[8] = v6;
  v8[9] = v6;
  v8[6] = v6;
  v8[7] = v6;
  unint64_t v8[4] = v6;
  void v8[5] = v6;
  v8[2] = v6;
  v8[3] = v6;
  v8[0] = v6;
  v8[1] = v6;
  if (gBBULogSinkFunc)
  {
    vsnprintf((char *)v8, 0x100uLL, __format, a3);
    gBBULogSinkFunc(gBBULogSinkContext, 3, v8);
  }
  else
  {
    vprintf(__format, a3);
  }
  return (*(uint64_t (**)(BBUPersonalizedConsoleFeedback *, const char *, va_list))(*(void *)this + 112))(this, __format, a3);
}

void BBUPersonalizedConsoleFeedback::~BBUPersonalizedConsoleFeedback(BBUPersonalizedConsoleFeedback *this)
{
  *(void *)this = &unk_26CECA6F0;
  CFDataRef v2 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::deque<std::string>::~deque[abi:ne180100]((uint64_t)this + 192);

  BBUFeedback::~BBUFeedback((CFTypeRef *)this);
}

{
  std::__shared_weak_count *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26CECA6F0;
  CFDataRef v2 = (std::__shared_weak_count *)*((void *)this + 36);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::deque<std::string>::~deque[abi:ne180100]((uint64_t)this + 192);
  BBUFeedback::~BBUFeedback((CFTypeRef *)this);

  operator delete(v3);
}

uint64_t DEREncodeItemIntoVector(unint64_t a1, unint64_t a2, const void *a3, uint64_t a4)
{
  unint64_t v8 = DERLengthOfItem(a1, a2);
  unint64_t v9 = v8;
  unint64_t v61 = v8;
  unint64_t v11 = *(void *)a4;
  long long v10 = *(char **)(a4 + 8);
  unint64_t v12 = (unint64_t)&v10[-*(void *)a4];
  size_t v13 = v8 - v12;
  if (v8 <= v12)
  {
    if (v8 < v12) {
      *(void *)(a4 + 8) = v11 + v8;
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a4 + 16);
    if (v14 - (uint64_t)v10 >= v13)
    {
      bzero(*(void **)(a4 + 8), v13);
      *(void *)(a4 + 8) = &v10[v13];
      goto LABEL_32;
    }
    uint64_t v60 = a3;
    if ((v8 & 0x8000000000000000) != 0) {
      goto LABEL_66;
    }
    unint64_t v15 = v14 - v11;
    uint64_t v16 = 2 * v15;
    if (2 * v15 <= v8) {
      uint64_t v16 = v8;
    }
    if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v17 = v16;
    }
    long long v18 = operator new(v17);
    uint64_t v59 = (char *)v18 + v17;
    long long v19 = (char *)v18 + v9;
    long long v20 = (char *)v18 + v12;
    bzero((char *)v18 + v12, v13);
    if (v10 != (char *)v11)
    {
      if (v12 < 8 || v11 - (unint64_t)v18 < 0x20) {
        goto LABEL_28;
      }
      if (v12 >= 0x20)
      {
        unint64_t v21 = v12 & 0xFFFFFFFFFFFFFFE0;
        long long v22 = v10 - 16;
        long long v23 = &v10[(void)v18 - 16 - v11];
        unint64_t v24 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v25 = *(_OWORD *)v22;
          *((_OWORD *)v23 - 1) = *((_OWORD *)v22 - 1);
          *(_OWORD *)long long v23 = v25;
          v23 -= 32;
          v22 -= 32;
          v24 -= 32;
        }
        while (v24);
        if (v12 == v21)
        {
LABEL_30:
          long long v10 = (char *)v11;
          *(void *)a4 = v18;
          *(void *)(a4 + 8) = v19;
          *(void *)(a4 + 16) = v59;
          a3 = v60;
          if (!v11) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }
        if ((v12 & 0x18) == 0)
        {
          v20 -= v21;
          v10 -= v21;
          goto LABEL_28;
        }
      }
      else
      {
        unint64_t v21 = 0;
      }
      v20 -= v12 & 0xFFFFFFFFFFFFFFF8;
      long long v26 = &v10[-v21 - 8];
      long long v27 = &v26[-v11];
      unint64_t v28 = v21 - (v12 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        uint64_t v29 = *(void *)v26;
        v26 -= 8;
        *(void *)&v27[(void)v18] = v29;
        v27 -= 8;
        v28 += 8;
      }
      while (v28);
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_30;
      }
LABEL_28:
      long long v30 = v20 - 1;
      do
      {
        char v31 = *--v10;
        *v30-- = v31;
      }
      while (v10 != (char *)v11);
      goto LABEL_30;
    }
    *(void *)a4 = v20;
    *(void *)(a4 + 8) = v19;
    *(void *)(a4 + 16) = v59;
    a3 = v60;
    if (v10) {
LABEL_31:
    }
      operator delete(v10);
  }
LABEL_32:
  uint64_t v32 = DEREncodeItem(a1, a2, a3, *(void *)a4, &v61);
  if (v32)
  {
    unint64_t v33 = *(void *)a4;
LABEL_34:
    *(void *)(a4 + 8) = v33;
    return v32;
  }
  unint64_t v35 = v61;
  unint64_t v37 = *(void *)a4;
  long long v36 = *(char **)(a4 + 8);
  unint64_t v38 = (unint64_t)&v36[-*(void *)a4];
  size_t v39 = v61 - v38;
  if (v61 <= v38)
  {
    if (v61 >= v38) {
      return v32;
    }
    unint64_t v33 = v37 + v61;
    goto LABEL_34;
  }
  uint64_t v40 = *(void *)(a4 + 16);
  if (v40 - (uint64_t)v36 >= v39)
  {
    bzero(*(void **)(a4 + 8), v61 - v38);
    *(void *)(a4 + 8) = &v36[v39];
    return v32;
  }
  if ((v61 & 0x8000000000000000) != 0) {
LABEL_66:
  }
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  unint64_t v41 = v40 - v37;
  uint64_t v42 = 2 * v41;
  if (2 * v41 <= v61) {
    uint64_t v42 = v61;
  }
  if (v41 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v43 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v43 = v42;
  }
  long long v44 = (char *)operator new(v43);
  long long v45 = &v44[v38];
  unint64_t v46 = &v44[v43];
  uint64_t v47 = &v44[v35];
  bzero(&v44[v38], v39);
  if (v36 == (char *)v37) {
    goto LABEL_64;
  }
  if (v38 >= 8 && v37 - (unint64_t)v44 >= 0x20)
  {
    if (v38 < 0x20)
    {
      unint64_t v48 = 0;
      goto LABEL_56;
    }
    unint64_t v48 = v38 & 0xFFFFFFFFFFFFFFE0;
    uint64_t v49 = v36 - 16;
    unint64_t v50 = &v36[(void)v44 - 16 - v37];
    unint64_t v51 = v38 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v52 = *(_OWORD *)v49;
      *((_OWORD *)v50 - 1) = *((_OWORD *)v49 - 1);
      *(_OWORD *)unint64_t v50 = v52;
      v50 -= 32;
      v49 -= 32;
      v51 -= 32;
    }
    while (v51);
    if (v38 == v48) {
      goto LABEL_63;
    }
    if ((v38 & 0x18) != 0)
    {
LABEL_56:
      v45 -= v38 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v53 = &v36[-v48 - 8];
      uint64_t v54 = &v53[-v37];
      unint64_t v55 = v48 - (v38 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        uint64_t v56 = *(void *)v53;
        v53 -= 8;
        *(void *)&v54[(void)v44] = v56;
        v54 -= 8;
        v55 += 8;
      }
      while (v55);
      v36 -= v38 & 0xFFFFFFFFFFFFFFF8;
      if (v38 == (v38 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_63;
      }
      goto LABEL_61;
    }
    v45 -= v48;
    v36 -= v48;
  }
LABEL_61:
  uint64_t v57 = v45 - 1;
  do
  {
    char v58 = *--v36;
    *v57-- = v58;
  }
  while (v36 != (char *)v37);
LABEL_63:
  long long v36 = (char *)v37;
  long long v45 = v44;
LABEL_64:
  *(void *)a4 = v45;
  *(void *)(a4 + 8) = v47;
  *(void *)(a4 + 16) = v46;
  if (v36) {
    operator delete(v36);
  }
  return v32;
}

uint64_t DEREncodeSequenceIntoVector(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = a2;
  unint64_t v8 = DERLengthOfEncodedSequence(a1, a2, *(unsigned __int16 *)(a3 + 8), *(void *)a3);
  unint64_t v9 = v8;
  unint64_t v61 = v8;
  unint64_t v11 = *(void *)a4;
  long long v10 = *(char **)(a4 + 8);
  unint64_t v12 = (unint64_t)&v10[-*(void *)a4];
  size_t v13 = v8 - v12;
  if (v8 <= v12)
  {
    if (v8 < v12) {
      *(void *)(a4 + 8) = v11 + v8;
    }
  }
  else
  {
    uint64_t v14 = *(void *)(a4 + 16);
    if (v14 - (uint64_t)v10 >= v13)
    {
      bzero(*(void **)(a4 + 8), v13);
      *(void *)(a4 + 8) = &v10[v13];
      goto LABEL_32;
    }
    unint64_t v60 = v6;
    if ((v8 & 0x8000000000000000) != 0) {
      goto LABEL_66;
    }
    unint64_t v15 = v14 - v11;
    uint64_t v16 = 2 * v15;
    if (2 * v15 <= v8) {
      uint64_t v16 = v8;
    }
    if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v17 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v17 = v16;
    }
    long long v18 = operator new(v17);
    uint64_t v59 = (char *)v18 + v17;
    long long v19 = (char *)v18 + v9;
    long long v20 = (char *)v18 + v12;
    bzero((char *)v18 + v12, v13);
    if (v10 != (char *)v11)
    {
      if (v12 < 8 || v11 - (unint64_t)v18 < 0x20) {
        goto LABEL_28;
      }
      if (v12 >= 0x20)
      {
        unint64_t v21 = v12 & 0xFFFFFFFFFFFFFFE0;
        long long v22 = v10 - 16;
        long long v23 = &v10[(void)v18 - 16 - v11];
        unint64_t v24 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v25 = *(_OWORD *)v22;
          *((_OWORD *)v23 - 1) = *((_OWORD *)v22 - 1);
          *(_OWORD *)long long v23 = v25;
          v23 -= 32;
          v22 -= 32;
          v24 -= 32;
        }
        while (v24);
        if (v12 == v21)
        {
LABEL_30:
          long long v10 = (char *)v11;
          *(void *)a4 = v18;
          *(void *)(a4 + 8) = v19;
          *(void *)(a4 + 16) = v59;
          unint64_t v6 = v60;
          if (!v11) {
            goto LABEL_32;
          }
          goto LABEL_31;
        }
        if ((v12 & 0x18) == 0)
        {
          v20 -= v21;
          v10 -= v21;
          goto LABEL_28;
        }
      }
      else
      {
        unint64_t v21 = 0;
      }
      v20 -= v12 & 0xFFFFFFFFFFFFFFF8;
      long long v26 = &v10[-v21 - 8];
      long long v27 = &v26[-v11];
      unint64_t v28 = v21 - (v12 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        uint64_t v29 = *(void *)v26;
        v26 -= 8;
        *(void *)&v27[(void)v18] = v29;
        v27 -= 8;
        v28 += 8;
      }
      while (v28);
      v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
      if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_30;
      }
LABEL_28:
      long long v30 = v20 - 1;
      do
      {
        char v31 = *--v10;
        *v30-- = v31;
      }
      while (v10 != (char *)v11);
      goto LABEL_30;
    }
    *(void *)a4 = v20;
    *(void *)(a4 + 8) = v19;
    *(void *)(a4 + 16) = v59;
    unint64_t v6 = v60;
    if (v10) {
LABEL_31:
    }
      operator delete(v10);
  }
LABEL_32:
  uint64_t v32 = DEREncodeSequence(a1, v6, *(unsigned __int16 *)(a3 + 8), *(void *)a3, *(void *)a4, &v61);
  if (v32)
  {
    unint64_t v33 = *(void *)a4;
LABEL_34:
    *(void *)(a4 + 8) = v33;
    return v32;
  }
  unint64_t v35 = v61;
  unint64_t v37 = *(void *)a4;
  long long v36 = *(char **)(a4 + 8);
  unint64_t v38 = (unint64_t)&v36[-*(void *)a4];
  size_t v39 = v61 - v38;
  if (v61 <= v38)
  {
    if (v61 >= v38) {
      return v32;
    }
    unint64_t v33 = v37 + v61;
    goto LABEL_34;
  }
  uint64_t v40 = *(void *)(a4 + 16);
  if (v40 - (uint64_t)v36 >= v39)
  {
    bzero(*(void **)(a4 + 8), v61 - v38);
    *(void *)(a4 + 8) = &v36[v39];
    return v32;
  }
  if ((v61 & 0x8000000000000000) != 0) {
LABEL_66:
  }
    std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
  unint64_t v41 = v40 - v37;
  uint64_t v42 = 2 * v41;
  if (2 * v41 <= v61) {
    uint64_t v42 = v61;
  }
  if (v41 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v43 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v43 = v42;
  }
  long long v44 = (char *)operator new(v43);
  long long v45 = &v44[v38];
  unint64_t v46 = &v44[v43];
  uint64_t v47 = &v44[v35];
  bzero(&v44[v38], v39);
  if (v36 == (char *)v37) {
    goto LABEL_64;
  }
  if (v38 >= 8 && v37 - (unint64_t)v44 >= 0x20)
  {
    if (v38 < 0x20)
    {
      unint64_t v48 = 0;
      goto LABEL_56;
    }
    unint64_t v48 = v38 & 0xFFFFFFFFFFFFFFE0;
    uint64_t v49 = v36 - 16;
    unint64_t v50 = &v36[(void)v44 - 16 - v37];
    unint64_t v51 = v38 & 0xFFFFFFFFFFFFFFE0;
    do
    {
      long long v52 = *(_OWORD *)v49;
      *((_OWORD *)v50 - 1) = *((_OWORD *)v49 - 1);
      *(_OWORD *)unint64_t v50 = v52;
      v50 -= 32;
      v49 -= 32;
      v51 -= 32;
    }
    while (v51);
    if (v38 == v48) {
      goto LABEL_63;
    }
    if ((v38 & 0x18) != 0)
    {
LABEL_56:
      v45 -= v38 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v53 = &v36[-v48 - 8];
      uint64_t v54 = &v53[-v37];
      unint64_t v55 = v48 - (v38 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        uint64_t v56 = *(void *)v53;
        v53 -= 8;
        *(void *)&v54[(void)v44] = v56;
        v54 -= 8;
        v55 += 8;
      }
      while (v55);
      v36 -= v38 & 0xFFFFFFFFFFFFFFF8;
      if (v38 == (v38 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_63;
      }
      goto LABEL_61;
    }
    v45 -= v48;
    v36 -= v48;
  }
LABEL_61:
  uint64_t v57 = v45 - 1;
  do
  {
    char v58 = *--v36;
    *v57-- = v58;
  }
  while (v36 != (char *)v37);
LABEL_63:
  long long v36 = (char *)v37;
  long long v45 = v44;
LABEL_64:
  *(void *)a4 = v45;
  *(void *)(a4 + 8) = v47;
  *(void *)(a4 + 16) = v46;
  if (v36) {
    operator delete(v36);
  }
  return v32;
}

uint64_t DERDecodeBBTicket(uint64_t a1, unsigned int a2, unint64_t a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  memset(v10, 170, sizeof(v10));
  v13[6] = xmmword_21DFAB9A0;
  v13[7] = unk_21DFAB9B0;
  v13[8] = xmmword_21DFAB9C0;
  void v13[2] = xmmword_21DFAB960;
  _OWORD v13[3] = unk_21DFAB970;
  _OWORD v13[4] = xmmword_21DFAB980;
  v13[5] = unk_21DFAB990;
  v13[0] = __const__Z17DERDecodeBBTicketPhjP11DERBbTicket_DERBbTicketItemSpecs;
  v13[1] = unk_21DFAB950;
  v11[6] = xmmword_21DFABA30;
  v11[7] = unk_21DFABA40;
  v11[8] = xmmword_21DFABA50;
  v11[9] = unk_21DFABA60;
  void v11[2] = xmmword_21DFAB9F0;
  void v11[3] = unk_21DFABA00;
  v11[4] = xmmword_21DFABA10;
  v11[5] = unk_21DFABA20;
  v11[0] = __const__Z17DERDecodeBBTicketPhjP11DERBbTicket_DERBbTicketItemSpecs_MAV;
  v11[1] = unk_21DFAB9E0;
  uint64_t v12 = 1;
  v9[0] = a1;
  v9[1] = a2;
  uint64_t result = DERDecodeItem((uint64_t)v9, v10);
  if (!result)
  {
    if (v10[0] != 0x2000000000000010) {
      return 2;
    }
    if (capabilities::radio::maverick((capabilities::radio *)result))
    {
      uint64_t result = (uint64_t)DERParseSequenceContent(&v10[1], 7u, (uint64_t)v11, a3, 0);
      if (result) {
        return result;
      }
    }
    else
    {
      uint64_t result = (uint64_t)DERParseSequenceContent(&v10[1], 6u, (uint64_t)v13, a3, 0);
      if (result) {
        return result;
      }
    }
    uint64_t v5 = *(uint64_t **)(a3 + 16);
    uint64_t v6 = *v5;
    int v7 = *((unsigned __int16 *)v5 + 4);
    BOOL v8 = v6 == 0x43DCE48862A0806 && v7 == 771;
    uint64_t result = 3;
    if (v8)
    {
      if (*(void *)(a3 + 24) == 10) {
        return 0;
      }
      else {
        return 3;
      }
    }
  }
  return result;
}

const char *BBUBootModeAsString(unsigned int a1)
{
  if (a1 > 2) {
    return "Unknown";
  }
  else {
    return off_2644898D0[a1];
  }
}

const char *BBUNVRestoreSettingAsString(unsigned int a1)
{
  if (a1 > 6) {
    return "Invalid";
  }
  else {
    return off_2644898E8[a1];
  }
}

uint64_t EURStateMachineStart(uint64_t a1)
{
  *(_DWORD *)(a1 + 376) = 0;
  *(unsigned char *)(a1 + 368) = 1;
  return 1;
}

uint64_t EURStateMachineStop(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 368) = 0;
  _BBUFSDebugPrint("EURStateMachineStop", "aborting pending reads\n", a3, a4, a5, a6, a7, a8, v11);
  unint64_t v9 = *(void (**)(uint64_t))(a1 + 24);
  if (v9) {
    v9(a1 + 8);
  }
  return 1;
}

uint64_t EURStateMachinePerformFlush(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = *(int *)(a1 + 376);
        long long v10 = "Unknown";
        if (v9 <= 2) {
          long long v10 = off_264489940[v9];
        }
        _BBUFSDebugPrint("EURStateMachinePerformFlush", "---------------------%s---------------------\n", a3, a4, a5, a6, a7, a8, (char)v10);
        int v17 = *(_DWORD *)(a1 + 376);
        if (v17) {
          break;
        }
        uint64_t v84 = 0;
        v86[0] = 0;
        v87[0] = 0;
        int v18 = createETLStructures(v87, &v84, v86, v12, v13, v14, v15, v16);
        long long v25 = "failed creating ETL header and ring buffer structures\n";
        if (!v18)
        {
LABEL_17:
          _BBUFSDebugPrint("sListen", v25, v19, v20, v21, v22, v23, v24, v80);
          int v36 = 0;
          *(void *)&long long v37 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v37 + 1) = 0xAAAAAAAAAAAAAAAALL;
          v85[0] = v37;
          v85[1] = v37;
          goto LABEL_35;
        }
        while (1)
        {
          _BBUFSDebugPrint("sListen", "waiting for hello with timeout of %u sec\n", v19, v20, v21, v22, v23, v24, gHelloWaitTimeoutMilliSec / 0x3E8u);
          if (!ETLSAHCommandReceive())
          {
            long long v25 = "failed receiving hello packet\n";
            goto LABEL_17;
          }
          if (*(_DWORD *)v84 != 8) {
            break;
          }
          _BBUFSDebugPrint("sListen", "received reset response (dropping)\n", v19, v20, v21, v22, v23, v24, v80);
        }
        *(void *)&long long v38 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v38 + 1) = 0xAAAAAAAAAAAAAAAALL;
        v85[0] = v38;
        v85[1] = v38;
        if (ETLSAHCommandParseHello())
        {
          _BBUFSDebugPrint("sPrintHelloParameters", "version number:  %u\n", a3, a4, a5, a6, a7, a8, v85[0]);
          _BBUFSDebugPrint("sPrintHelloParameters", "version compatible:  %u\n", v39, v40, v41, v42, v43, v44, SBYTE4(v85[0]));
          _BBUFSDebugPrint("sPrintHelloParameters", "command packet Length:  %u\n", v45, v46, v47, v48, v49, v50, SBYTE8(v85[0]));
          char v51 = ETLSAHModeAsString();
          _BBUFSDebugPrint("sPrintHelloParameters", "mode:  %s\n", v52, v53, v54, v55, v56, v57, v51);
          if (ETLSAHCommandCreateHelloResponse())
          {
            if (ETLSAHCommandSend())
            {
              int v36 = 1;
              goto LABEL_35;
            }
            char v58 = "failed to respond to hello packet\n";
          }
          else
          {
            char v58 = "Failed to create hello response\n";
          }
        }
        else
        {
          char v58 = "failed parsing hello packet\n";
        }
        _BBUFSDebugPrint("sListen", v58, a3, a4, a5, a6, a7, a8, v80);
        int v36 = 0;
LABEL_35:
        unint64_t v60 = (void **)v87[0];
        if ((unint64_t)v84 | v87[0])
        {
          if (v84)
          {
            free(v84);
            uint64_t v84 = 0;
            unint64_t v60 = (void **)v87[0];
          }
          if (v60)
          {
            if (*v60)
            {
              free(*v60);
              unint64_t v60 = (void **)v87[0];
            }
            free(v60);
          }
        }
        if (!v36) {
          goto LABEL_68;
        }
        *(_DWORD *)(a1 + 376) = 1;
      }
      if (v17 != 1) {
        break;
      }
      uint64_t v83 = 0;
      int v82 = 0;
      uint64_t v81 = 0;
      int v26 = createETLStructures((uint64_t *)&v81, &v83, &v82, v12, v13, v14, v15, v16);
      unint64_t v33 = "failed creating ETL header and ring buffer structures\n";
      if (v26 && (v34 = ETLSAHGetDebugRecordCount(), unint64_t v33 = "failed receiving debug table location\n", (v34 & 1) != 0))
      {
        int v35 = 1;
      }
      else
      {
        _BBUFSDebugPrint("sGetRecords", v33, v27, v28, v29, v30, v31, v32, v80);
        int v35 = 0;
      }
      _BBUFSDebugPrint("sGetRecords", "%i records requested\n", v27, v28, v29, v30, v31, v32, 0);
      uint64_t v59 = (void **)v81;
      if ((unint64_t)v83 | (unint64_t)v81)
      {
        if (v83)
        {
          free(v83);
          uint64_t v83 = 0;
          uint64_t v59 = (void **)v81;
        }
        if (v59)
        {
          if (*v59)
          {
            free(*v59);
            uint64_t v59 = (void **)v81;
          }
          free(v59);
        }
      }
      if (!v35) {
        goto LABEL_68;
      }
      *(_DWORD *)(a1 + 376) = 2;
    }
    if (v17 == 2) {
      break;
    }
    _BBUFSDebugPrint("EURStateMachinePerformFlush", "unknown state\n", v11, v12, v13, v14, v15, v16, v80);
  }
  *(void *)&v85[0] = 0;
  LODWORD(v87[0]) = 0;
  uint64_t v84 = 0;
  if (!createETLStructures((uint64_t *)&v84, (void **)v85, v87, v12, v13, v14, v15, v16))
  {
    uint64_t v75 = "failed creating ETL header and ring buffer structures\n";
    goto LABEL_53;
  }
  if (!ETLSAHCommandCreateReset())
  {
    uint64_t v75 = "failed to create reset command\n";
    goto LABEL_53;
  }
  if ((ETLSAHCommandSend() & 1) == 0)
  {
    uint64_t v75 = "failed sending reset command\n";
LABEL_53:
    _BBUFSDebugPrint("sCompleteTransfer", v75, v61, v62, v63, v64, v65, v66, v80);
    *(_DWORD *)(a1 + 376) = 0;
    long long v73 = *(void **)&v85[0];
    uint64_t v76 = (void **)v84;
    if (!(*(void *)&v85[0] | (unint64_t)v84)) {
      goto LABEL_68;
    }
LABEL_54:
    if (v73)
    {
      int v74 = 0;
LABEL_56:
      free(v73);
      *(void *)&v85[0] = 0;
      uint64_t v76 = (void **)v84;
      if (!v84)
      {
        if (!v74) {
          goto LABEL_68;
        }
LABEL_64:
        *(_DWORD *)(a1 + 376) = 0;
        unsigned int v77 = 1;
        goto LABEL_69;
      }
    }
    else
    {
      if (!v76) {
        goto LABEL_68;
      }
      LOBYTE(v74) = 0;
    }
    if (*v76)
    {
      free(*v76);
      uint64_t v76 = (void **)v84;
    }
    free(v76);
    if ((v74 & 1) == 0) {
      goto LABEL_68;
    }
    goto LABEL_64;
  }
  *(_DWORD *)(a1 + 376) = 0;
  if (ETLSAHCommandReceive())
  {
    long long v73 = *(void **)&v85[0];
    if (**(_DWORD **)&v85[0] == 8)
    {
      int v74 = 1;
      goto LABEL_56;
    }
    int v80 = **(_DWORD **)&v85[0];
    long long v78 = "expect reset response but receive type %d\n";
  }
  else
  {
    long long v78 = "failed to receive reset response\n";
  }
  _BBUFSDebugPrint("sCompleteTransfer", v78, v67, v68, v69, v70, v71, v72, v80);
  long long v73 = *(void **)&v85[0];
  uint64_t v76 = (void **)v84;
  if (*(void *)&v85[0] | (unint64_t)v84) {
    goto LABEL_54;
  }
LABEL_68:
  unsigned int v77 = 0;
LABEL_69:
  if (*(unsigned char *)(a1 + 368)) {
    return v77;
  }
  else {
    return 1;
  }
}

void sub_21DEF0924(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (*(char *)(v37 - 169) < 0) {
    operator delete(v36[18]);
  }
  if (*(char *)(v37 - 137) < 0) {
    operator delete(v36[22]);
  }
  if (*(char *)(v37 - 105) < 0) {
    operator delete(v36[26]);
  }
  _Unwind_Resume(exception_object);
}

uint64_t EURStateMachineSetConfig(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && (char v8 = (char)a2, a2))
  {
    int v9 = a3;
    if (!strcasecmp("HelloWaitTimeoutSec", a2))
    {
      if (v9 < 1)
      {
        if (v9)
        {
          _BBUFSDebugPrint("EURStateMachineSetConfig", "failed to set config '%s', invalid config value '%d'\n", v10, v11, v12, v13, v14, v15, v8);
          return 0;
        }
        else
        {
          gHelloWaitTimeoutMilliSec = -1;
          _BBUFSDebugPrint("EURStateMachineSetConfig", "Set config '%s' to 'infinite'\n", v10, v11, v12, v13, v14, v15, v8);
          return 1;
        }
      }
      else
      {
        gHelloWaitTimeoutMilliSec = 1000 * v9;
        _BBUFSDebugPrint("EURStateMachineSetConfig", "Set config '%s' to '%d' millisec\n", v10, v11, v12, v13, v14, v15, v8);
        return 1;
      }
    }
    else
    {
      _BBUFSDebugPrint("EURStateMachineSetConfig", "failed to set config, unrecognized config name '%s'\n", v10, v11, v12, v13, v14, v15, v8);
      return 0;
    }
  }
  else
  {
    _BBUFSDebugPrint("EURStateMachineSetConfig", "failed to set config as one of the args is NULL\n", a3, a4, a5, a6, a7, a8, v17);
    return 0;
  }
}

BOOL EURStateMachineFlushInProgress(uint64_t a1)
{
  return *(_DWORD *)(a1 + 376) > 0;
}

const char *___ZL11sSaveRecordP16_BBUFSServer_tagPKcPK28ETLSAHDebugDataFieldRecord_t_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _BBUFSDebugPrint("sHandleCapureProgress", "%s:  %0.1f%c\n", a3, a4, a5, a6, a7, a8, a3 + 32);
}

void BBUEUREFSImage::BBUEUREFSImage(BBUEUREFSImage *this, BBUDataSource *a2, unsigned int a3, uint64_t a4)
{
  BBUEURMIImage::BBUEURMIImage(this, a2, a4);
  void *v5 = &unk_26CECAC80;
  v5[8] = 0;
  uint64_t v6 = (void **)(v5 + 8);
  v5[9] = 0;
  v5[10] = 0;
  unint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v23[7] = v7;
  v23[8] = v7;
  v23[5] = v7;
  v23[6] = v7;
  v23[3] = v7;
  v23[4] = v7;
  v23[1] = v7;
  v23[2] = v7;
  v23[0] = v7;
  long long v21 = v7;
  long long v22 = v7;
  long long v19 = v7;
  *(_OWORD *)std::string __p = v7;
  long long v17 = v7;
  long long v18 = v7;
  long long v16 = v7;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v16);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v16, (uint64_t)"EFS", 3);
  std::ostream::operator<<();
  if ((BYTE8(v22) & 0x10) != 0)
  {
    uint64_t v10 = v22;
    if ((unint64_t)v22 < *((void *)&v19 + 1))
    {
      *(void *)&long long v22 = *((void *)&v19 + 1);
      uint64_t v10 = *((void *)&v19 + 1);
    }
    uint64_t v11 = (const void *)v19;
    size_t v8 = v10 - v19;
    if ((unint64_t)(v10 - v19) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_20;
    }
  }
  else
  {
    if ((BYTE8(v22) & 8) == 0)
    {
      size_t v8 = 0;
      HIBYTE(v15) = 0;
      p_dst = &__dst;
      goto LABEL_14;
    }
    uint64_t v11 = (const void *)*((void *)&v17 + 1);
    size_t v8 = *((void *)&v18 + 1) - *((void *)&v17 + 1);
    if (*((void *)&v18 + 1) - *((void *)&v17 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_20:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v8 >= 0x17)
  {
    uint64_t v12 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v12 = v8 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (long long *)operator new(v12 + 1);
    *((void *)&__dst + 1) = v8;
    unint64_t v15 = v13 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_13;
  }
  HIBYTE(v15) = v8;
  p_dst = &__dst;
  if (v8) {
LABEL_13:
  }
    memmove(p_dst, v11, v8);
LABEL_14:
  *((unsigned char *)p_dst + v8) = 0;
  if (*((char *)this + 87) < 0) {
    operator delete(*v6);
  }
  *(_OWORD *)uint64_t v6 = __dst;
  void v6[2] = (void *)v15;
  *(void *)&long long v16 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v16 + *(void *)(v16 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v16 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v21) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v23);
}

void sub_21DEF0E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (*(char *)(v13 + 87) < 0)
  {
    operator delete(*v14);
    *(void *)uint64_t v13 = &unk_26CECEAE8;
    uint64_t v16 = *(void *)(v13 + 8);
    if (!v16) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    *(void *)uint64_t v13 = &unk_26CECEAE8;
    uint64_t v16 = *(void *)(v13 + 8);
    if (!v16) {
      goto LABEL_3;
    }
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  _Unwind_Resume(exception_object);
}

void BBUEUREFSImage::~BBUEUREFSImage(void **this)
{
  *this = &unk_26CECAC80;
  if (*((char *)this + 87) < 0)
  {
    operator delete(this[8]);
    *this = &unk_26CECEAE8;
    CFDataRef v2 = this[1];
    if (!v2) {
      return;
    }
  }
  else
  {
    *this = &unk_26CECEAE8;
    CFDataRef v2 = this[1];
    if (!v2) {
      return;
    }
  }
  (*(void (**)(void *))(*(void *)v2 + 8))(v2);
}

void BBUEUREFSImage::~BBUEUREFSImage(BBUEUREFSImage *this)
{
  *(void *)this = &unk_26CECAC80;
  if ((*((char *)this + 87) & 0x80000000) == 0)
  {
    *(void *)this = &unk_26CECEAE8;
    uint64_t v2 = *((void *)this + 1);
    if (!v2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  operator delete(*((void **)this + 8));
  *(void *)this = &unk_26CECEAE8;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
LABEL_3:
  }
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
LABEL_4:

  operator delete(this);
}

uint64_t BBUEUREFSImage::getName(BBUEUREFSImage *this)
{
  uint64_t result = (uint64_t)this + 64;
  if (*((char *)this + 87) < 0) {
    return *(void *)result;
  }
  return result;
}

uint64_t BBUEURMIImage::getWritePayloadLength(BBUEURMIImage *this)
{
  return (*((_DWORD *)this + 8) + 40);
}

uint64_t BBUEURMIImage::getOpenPayloadData(BBUEURMIImage *this)
{
  return 0;
}

uint64_t BBUEURMIImage::getOpenPayloadLength(BBUEURMIImage *this)
{
  return 0;
}

void BBUEURMIImage::generateHash(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    if (v3) {
      BBUDataSource::generateHash(v3, a2, a3);
    }
  }
}

uint64_t BBUEURMIImage::getDataSource(BBUEURMIImage *this)
{
  return *((void *)this + 1);
}

BOOL BBUEURMIImage::verifyMIHeaderSize(BBUEURMIImage *this, int a2)
{
  return *((unsigned int *)this + 6) + (unint64_t)*((unsigned int *)this + 9) + 40 == a2;
}

void BBUFeedback::BBUFeedback(BBUFeedback *this, const void *a2)
{
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26CECACF8;
  *((void *)this + 1) = (char *)this + 16;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((unsigned char *)this + 44) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = a2;
  *((void *)this + 8) = 0;
  BBUProfiler::BBUProfiler((BBUFeedback *)((char *)this + 80));
  uint64_t v3 = operator new(8uLL);
  long long v4 = operator new(0x1000uLL);
  *uint64_t v3 = v4;
  _DWORD *v4 = 0;
  *((void *)this + 17) = v3;
  *((void *)this + 18) = v3;
  *((void *)this + 19) = v3 + 1;
  *((void *)this + 20) = v3 + 1;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 1;
  CFNotificationCenterRef LocalCenter = CFNotificationCenterGetLocalCenter();
  *((void *)this + 9) = LocalCenter;
  CFRetain(LocalCenter);
  CFAllocatorRef v6 = CFGetAllocator(*((CFTypeRef *)this + 7));
  *((void *)this + 8) = CFDictionaryCreateMutable(v6, 2, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  int valuePtr = 0;
  CFAllocatorRef v7 = CFGetAllocator(*((CFTypeRef *)this + 7));
  CFNumberRef v8 = CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
  CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 8), @"percentage", v8);
  CFRelease(v8);
}

void sub_21DEF11F4(void *a1)
{
}

void sub_21DEF1204(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  operator delete(v3);
  BBUProfiler::~BBUProfiler(v2);
  std::__tree<std::__value_type<BBUFeedback::ProgressBarStages,double>,std::__map_value_compare<BBUFeedback::ProgressBarStages,std::__value_type<BBUFeedback::ProgressBarStages,double>,std::less<BBUFeedback::ProgressBarStages>,true>,std::allocator<std::__value_type<BBUFeedback::ProgressBarStages,double>>>::destroy(v1, *v4);
  _Unwind_Resume(a1);
}

void BBUProfiler::~BBUProfiler(CFTypeRef *this)
{
  if (*this) {
    CFRelease(*this);
  }
}

void BBUFeedback::~BBUFeedback(CFTypeRef *this)
{
  *this = &unk_26CECACF8;
  CFRelease(this[9]);
  CFRelease(this[8]);
  std::deque<BBUpdaterCommon::StageContext>::~deque[abi:ne180100]((uint64_t)(this + 17));
  std::deque<ctu::cf::CFSharedRef<__CFDictionary>>::~deque[abi:ne180100]((uint64_t)(this + 11));
  CFTypeRef v2 = this[10];
  if (v2) {
    CFRelease(v2);
  }
  std::__tree<std::__value_type<BBUFeedback::ProgressBarStages,double>,std::__map_value_compare<BBUFeedback::ProgressBarStages,std::__value_type<BBUFeedback::ProgressBarStages,double>,std::less<BBUFeedback::ProgressBarStages>,true>,std::allocator<std::__value_type<BBUFeedback::ProgressBarStages,double>>>::destroy((uint64_t)(this + 1), this[2]);
}

void BBUFeedback::updateProgressBarItem(BBUFeedback *this, double a2)
{
  if (*((unsigned char *)this + 44))
  {
    uint64_t v5 = (uint64_t **)((char *)this + 16);
    long long v4 = (char *)*((void *)this + 2);
    int v6 = *((_DWORD *)this + 10);
    if (v4)
    {
      while (1)
      {
        while (1)
        {
          CFAllocatorRef v7 = (uint64_t **)v4;
          int v8 = *((_DWORD *)v4 + 8);
          if (v6 >= v8) {
            break;
          }
          long long v4 = (char *)*v7;
          uint64_t v5 = v7;
          if (!*v7) {
            goto LABEL_9;
          }
        }
        if (v8 >= v6) {
          break;
        }
        long long v4 = (char *)v7[1];
        if (!v4)
        {
          uint64_t v5 = v7 + 1;
          goto LABEL_9;
        }
      }
    }
    else
    {
      CFAllocatorRef v7 = (uint64_t **)((char *)this + 16);
LABEL_9:
      int v9 = (char *)v7;
      CFAllocatorRef v7 = (uint64_t **)operator new(0x30uLL);
      *((_DWORD *)v7 + 8) = v6;
      v7[5] = 0;
      *CFAllocatorRef v7 = 0;
      v7[1] = 0;
      unint64_t v7[2] = (uint64_t *)v9;
      void *v5 = (uint64_t *)v7;
      uint64_t v10 = **((void **)this + 1);
      uint64_t v11 = (uint64_t *)v7;
      if (v10)
      {
        *((void *)this + 1) = v10;
        uint64_t v11 = *v5;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 2), v11);
      ++*((void *)this + 3);
    }
    unsigned int valuePtr = ((*((double *)this + 6) + *((double *)v7 + 5) * a2 / *((double *)this + 4)) * 100.0);
    CFAllocatorRef v12 = CFGetAllocator(*((CFTypeRef *)this + 7));
    CFNumberRef v13 = CFNumberCreate(v12, kCFNumberSInt32Type, &valuePtr);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 8), @"percentage", v13);
    CFRelease(v13);
    CFNotificationCenterPostNotification(*((CFNotificationCenterRef *)this + 9), @"BBUpdateProgress", *((const void **)this + 7), *((CFDictionaryRef *)this + 8), 0);
  }
}

void BBUFeedback::endProgressBarItem(BBUFeedback *this)
{
  if (*((unsigned char *)this + 44))
  {
    uint64_t v3 = (uint64_t **)((char *)this + 16);
    CFTypeRef v2 = (char *)*((void *)this + 2);
    int v4 = *((_DWORD *)this + 10);
    if (v2)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v5 = (uint64_t **)v2;
          int v6 = *((_DWORD *)v2 + 8);
          if (v4 >= v6) {
            break;
          }
          CFTypeRef v2 = (char *)*v5;
          uint64_t v3 = v5;
          if (!*v5) {
            goto LABEL_9;
          }
        }
        if (v6 >= v4) {
          break;
        }
        CFTypeRef v2 = (char *)v5[1];
        if (!v2)
        {
          uint64_t v3 = v5 + 1;
          goto LABEL_9;
        }
      }
    }
    else
    {
      uint64_t v5 = (uint64_t **)((char *)this + 16);
LABEL_9:
      CFAllocatorRef v7 = (char *)v5;
      uint64_t v5 = (uint64_t **)operator new(0x30uLL);
      *((_DWORD *)v5 + 8) = v4;
      v5[5] = 0;
      void *v5 = 0;
      v5[1] = 0;
      uint64_t v5[2] = (uint64_t *)v7;
      *uint64_t v3 = (uint64_t *)v5;
      uint64_t v8 = **((void **)this + 1);
      int v9 = (uint64_t *)v5;
      if (v8)
      {
        *((void *)this + 1) = v8;
        int v9 = *v3;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 2), v9);
      ++*((void *)this + 3);
    }
    double v10 = *((double *)this + 6) + *((double *)v5 + 5) / *((double *)this + 4);
    *((double *)this + 6) = v10;
    unsigned int valuePtr = (v10 * 100.0);
    CFAllocatorRef v11 = CFGetAllocator(*((CFTypeRef *)this + 7));
    CFNumberRef v12 = CFNumberCreate(v11, kCFNumberSInt32Type, &valuePtr);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 8), @"percentage", v12);
    CFRelease(v12);
    CFNotificationCenterPostNotification(*((CFNotificationCenterRef *)this + 9), @"BBUpdateProgress", *((const void **)this + 7), *((CFDictionaryRef *)this + 8), 0);
  }
}

void BBUFeedback::handleBeginQuickStep(BBUFeedback *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v13 = *MEMORY[0x263EF8340];
  memset(__b, 170, sizeof(__b));
  va_copy(v11, va);
  vsnprintf(__b, 0x400uLL, a2, va);
  size_t v4 = strlen(__b);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v5 = (void *)v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v6 = (void **)operator new(v7 + 1);
    __dst[1] = v5;
    unint64_t v10 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_8;
  }
  HIBYTE(v10) = v4;
  int v6 = __dst;
  if (v4) {
LABEL_8:
  }
    memcpy(v6, __b, (size_t)v5);
  *((unsigned char *)v5 + (void)v6) = 0;
  (*(void (**)(BBUFeedback *, void **))(*(void *)this + 56))(this, __dst);
  if (SHIBYTE(v10) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_21DEF1728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void BBUFeedback::handleBeginPhase(BBUFeedback *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v13 = *MEMORY[0x263EF8340];
  memset(__b, 170, sizeof(__b));
  va_copy(v11, va);
  vsnprintf(__b, 0x400uLL, a2, va);
  size_t v4 = strlen(__b);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v5 = (void *)v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v6 = (void **)operator new(v7 + 1);
    __dst[1] = v5;
    unint64_t v10 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_8;
  }
  HIBYTE(v10) = v4;
  int v6 = __dst;
  if (v4) {
LABEL_8:
  }
    memcpy(v6, __b, (size_t)v5);
  *((unsigned char *)v5 + (void)v6) = 0;
  (*(void (**)(BBUFeedback *, void **))(*(void *)this + 64))(this, __dst);
  if (SHIBYTE(v10) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_21DEF18A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void BBUFeedback::handleComment(BBUFeedback *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v13 = *MEMORY[0x263EF8340];
  memset(__b, 170, sizeof(__b));
  va_copy(v11, va);
  vsnprintf(__b, 0x400uLL, a2, va);
  size_t v4 = strlen(__b);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  uint64_t v5 = (void *)v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v6 = (void **)operator new(v7 + 1);
    __dst[1] = v5;
    unint64_t v10 = v8 | 0x8000000000000000;
    __dst[0] = v6;
    goto LABEL_8;
  }
  HIBYTE(v10) = v4;
  int v6 = __dst;
  if (v4) {
LABEL_8:
  }
    memcpy(v6, __b, (size_t)v5);
  *((unsigned char *)v5 + (void)v6) = 0;
  (*(void (**)(BBUFeedback *, void **))(*(void *)this + 72))(this, __dst);
  if (SHIBYTE(v10) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_21DEF1A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void BBUFeedback::exitStageContext(BBUFeedback *this)
{
  uint64_t v1 = *((void *)this + 22);
  if (!v1)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUFeedback.cpp", 0xC9u, (ctu::LogMessageBuffer *)"Assertion failure(!fStageContext.empty())", v14, v15, v16, v20);
    goto LABEL_16;
  }
  unsigned int v3 = *(_DWORD *)(*(void *)(*((void *)this + 18)
                             + (((unint64_t)(v1 + *((void *)this + 21) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                 + 4 * ((v1 + *((void *)this + 21) - 1) & 0x3FF))
     - 1;
  if (v3 > 7) {
    size_t v4 = "StageContext::None";
  }
  else {
    size_t v4 = off_264489958[v3];
  }
  BBUFeedback::handleComment(this, "exiting %s", v4);
  uint64_t v6 = *((void *)this + 18);
  uint64_t v5 = *((void *)this + 19);
  uint64_t v7 = ((v5 - v6) << 7) - 1;
  uint64_t v9 = *((void *)this + 21);
  uint64_t v8 = *((void *)this + 22);
  if (v5 == v6) {
    uint64_t v7 = 0;
  }
  uint64_t v10 = v8 - 1;
  *((void *)this + 22) = v8 - 1;
  if ((unint64_t)(v7 - (v8 + v9) + 1) >= 0x800)
  {
    operator delete(*(void **)(v5 - 8));
    *((void *)this + 19) -= 8;
    uint64_t v10 = *((void *)this + 22);
  }
  if (!v10)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUFeedback.cpp", 0xCEu, (ctu::LogMessageBuffer *)"Assertion failure(!fStageContext.empty())", v17, v18, v19, v21);
LABEL_16:
  }
  unsigned int v11 = *(_DWORD *)(*(void *)(*((void *)this + 18)
                              + (((unint64_t)(v10 + *((void *)this + 21) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                  + 4 * ((v10 + *((void *)this + 21) - 1) & 0x3FF))
      - 1;
  if (v11 > 7) {
    CFNumberRef v12 = "StageContext::None";
  }
  else {
    CFNumberRef v12 = off_264489958[v11];
  }
  BBUFeedback::handleComment(this, "now in %s", v12);
}

void sub_21DEF1BF0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF1C04(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUFeedback::getStageContext(BBUFeedback *this)
{
  uint64_t v1 = *((void *)this + 22);
  if (!v1)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Feedback/BBUFeedback.cpp", 0xD4u, (ctu::LogMessageBuffer *)"Assertion failure(!fStageContext.empty())", v4, v5, v6, v7);
  }
  return *(unsigned int *)(*(void *)(*((void *)this + 18)
                                     + (((unint64_t)(v1 + *((void *)this + 21) - 1) >> 7) & 0x1FFFFFFFFFFFFF8))
                         + 4 * ((v1 + *((void *)this + 21) - 1) & 0x3FF));
}

void sub_21DEF1CA8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t std::deque<ctu::cf::CFSharedRef<__CFDictionary>>::~deque[abi:ne180100](uint64_t a1)
{
  CFTypeRef v2 = *(void ***)(a1 + 8);
  unsigned int v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    unsigned int v3 = *(void ***)(a1 + 8);
    *(void *)(a1 + 40) = 0;
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = &v2[v4 >> 9];
    uint64_t v6 = *v5;
    char v7 = (CFTypeRef *)((char *)*v5 + 8 * (v4 & 0x1FF));
    uint64_t v8 = *(uint64_t *)((char *)v2 + (((*(void *)(a1 + 40) + v4) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*(void *)(a1 + 40) + v4) & 0x1FF);
    if (v7 != (CFTypeRef *)v8)
    {
      do
      {
        if (*v7)
        {
          CFRelease(*v7);
          uint64_t v6 = *v5;
        }
        if ((char *)++v7 - v6 == 4096)
        {
          uint64_t v9 = (CFTypeRef *)v5[1];
          ++v5;
          uint64_t v6 = v9;
          char v7 = v9;
        }
      }
      while (v7 != (CFTypeRef *)v8);
      CFTypeRef v2 = *(void ***)(a1 + 8);
      unsigned int v3 = *(void ***)(a1 + 16);
    }
    *(void *)(a1 + 40) = 0;
    unint64_t v10 = (char *)v3 - (char *)v2;
    if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
    {
      do
      {
        operator delete(*v2);
        unsigned int v3 = *(void ***)(a1 + 16);
        CFTypeRef v2 = (void **)(*(void *)(a1 + 8) + 8);
        *(void *)(a1 + 8) = v2;
        unint64_t v10 = (char *)v3 - (char *)v2;
      }
      while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
    }
  }
  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 256;
    goto LABEL_17;
  }
  if (v11 == 2)
  {
    uint64_t v12 = 512;
LABEL_17:
    *(void *)(a1 + 32) = v12;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v13 = *v2++;
      operator delete(v13);
    }
    while (v2 != v3);
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 16);
    if (v14 != v15) {
      *(void *)(a1 + 16) = v14 + ((v15 - v14 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::deque<BBUpdaterCommon::StageContext>::~deque[abi:ne180100](uint64_t a1)
{
  CFTypeRef v2 = *(void ***)(a1 + 8);
  unsigned int v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unsigned int v3 = *(void ***)(a1 + 16);
      CFTypeRef v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 512;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 1024;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      char v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__tree<std::__value_type<BBUFeedback::ProgressBarStages,double>,std::__map_value_compare<BBUFeedback::ProgressBarStages,std::__value_type<BBUFeedback::ProgressBarStages,double>,std::less<BBUFeedback::ProgressBarStages>,true>,std::allocator<std::__value_type<BBUFeedback::ProgressBarStages,double>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<BBUFeedback::ProgressBarStages,double>,std::__map_value_compare<BBUFeedback::ProgressBarStages,std::__value_type<BBUFeedback::ProgressBarStages,double>,std::less<BBUFeedback::ProgressBarStages>,true>,std::allocator<std::__value_type<BBUFeedback::ProgressBarStages,double>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<BBUFeedback::ProgressBarStages,double>,std::__map_value_compare<BBUFeedback::ProgressBarStages,std::__value_type<BBUFeedback::ProgressBarStages,double>,std::less<BBUFeedback::ProgressBarStages>,true>,std::allocator<std::__value_type<BBUFeedback::ProgressBarStages,double>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void std::deque<BBUpdaterCommon::StageContext>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x400;
  unint64_t v4 = v2 - 1024;
  if (v3)
  {
    a1[4] = v4;
    uint64_t v6 = (void *)a1[1];
    unint64_t v5 = (char *)a1[2];
    char v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    a1[1] = v6 + 1;
    if (v5 != (char *)a1[3])
    {
LABEL_94:
      *(void *)unint64_t v5 = v8;
      goto LABEL_95;
    }
    uint64_t v9 = (char *)*a1;
    if ((unint64_t)v7 > *a1)
    {
      uint64_t v10 = (uint64_t)&v7[-*a1] >> 3;
      if (v10 >= -1) {
        uint64_t v11 = v10 + 1;
      }
      else {
        uint64_t v11 = v10 + 2;
      }
      uint64_t v12 = v11 >> 1;
      uint64_t v13 = -v12;
      uint64_t v14 = &v7[-8 * v12];
      int64_t v15 = v5 - v7;
      if (v5 != v7)
      {
        memmove(&v7[-8 * v12], v7, v5 - v7);
        char v7 = (char *)a1[1];
      }
      unint64_t v5 = &v14[v15];
      uint64_t v16 = &v7[8 * v13];
      goto LABEL_11;
    }
    unint64_t v35 = (v5 - v9) >> 2;
    if (v5 == v9) {
      unint64_t v35 = 1;
    }
    if (v35 >> 61) {
      goto LABEL_111;
    }
    unint64_t v36 = v35 >> 2;
    uint64_t v37 = 8 * v35;
    long long v38 = (char *)operator new(8 * v35);
    uint64_t v39 = &v38[8 * v36];
    int64_t v41 = v5 - v7;
    BOOL v40 = v5 == v7;
    unint64_t v5 = v39;
    if (!v40)
    {
      unint64_t v5 = &v39[v41 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v42 = v41 - 8;
      if ((unint64_t)(v41 - 8) >= 0x38)
      {
        size_t v92 = &v38[8 * v36];
        uint64_t v43 = v92;
        if ((unint64_t)(v92 - v7) >= 0x20)
        {
          uint64_t v93 = (v42 >> 3) + 1;
          uint64_t v94 = 8 * (v93 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v43 = &v39[v94];
          v7 += v94;
          uint64_t v95 = (long long *)(v6 + 3);
          uint64_t v96 = v92 + 16;
          uint64_t v97 = v93 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v98 = *v95;
            *(v96 - 1) = *(v95 - 1);
            *uint64_t v96 = v98;
            v95 += 2;
            v96 += 2;
            v97 -= 4;
          }
          while (v97);
          if (v93 == (v93 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_91;
          }
        }
      }
      else
      {
        uint64_t v43 = &v38[8 * v36];
      }
      do
      {
        uint64_t v99 = *(void *)v7;
        v7 += 8;
        *(void *)uint64_t v43 = v99;
        v43 += 8;
      }
      while (v43 != v5);
    }
LABEL_91:
    *a1 = v38;
    a1[1] = v39;
    a1[2] = v5;
    a1[3] = &v38[v37];
    if (!v9) {
      goto LABEL_94;
    }
    uint64_t v100 = v9;
LABEL_93:
    operator delete(v100);
    unint64_t v5 = (char *)a1[2];
    goto LABEL_94;
  }
  uint64_t v18 = (char *)a1[2];
  uint64_t v17 = (char *)a1[3];
  char v20 = (char *)*a1;
  uint64_t v19 = (char *)a1[1];
  uint64_t v21 = v18 - v19;
  uint64_t v22 = (v18 - v19) >> 3;
  uint64_t v23 = (uint64_t)&v17[-*a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    unint64_t v24 = operator new(0x1000uLL);
    long long v25 = v24;
    if (v17 != v18)
    {
      *(void *)uint64_t v18 = v24;
LABEL_95:
      a1[2] += 8;
      return;
    }
    if (v19 == v20)
    {
      unint64_t v69 = (v17 - v19) >> 2;
      if (v18 == v19) {
        unint64_t v69 = 1;
      }
      if (v69 >> 61) {
        goto LABEL_111;
      }
      unint64_t v70 = (v69 + 3) >> 2;
      uint64_t v71 = 8 * v69;
      uint64_t v72 = (char *)operator new(8 * v69);
      uint64_t v44 = &v72[8 * v70];
      long long v73 = v44;
      if (v18 != v19)
      {
        long long v73 = &v44[8 * v22];
        int v74 = &v72[8 * v70];
        uint64_t v75 = v19;
        if ((unint64_t)(v21 - 8) < 0x38) {
          goto LABEL_115;
        }
        uint64_t v76 = &v72[8 * v70];
        int v74 = v76;
        uint64_t v75 = v19;
        if ((unint64_t)(v76 - v19) < 0x20) {
          goto LABEL_115;
        }
        unint64_t v77 = ((unint64_t)(v21 - 8) >> 3) + 1;
        uint64_t v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
        int v74 = &v44[v78];
        uint64_t v75 = &v19[v78];
        CFTypeRef v79 = (long long *)(v19 + 16);
        int v80 = v76 + 16;
        uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v82 = *v79;
          *(v80 - 1) = *(v79 - 1);
          *int v80 = v82;
          v79 += 2;
          v80 += 2;
          v81 -= 4;
        }
        while (v81);
        if (v77 != (v77 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_115:
          do
          {
            uint64_t v83 = *(void *)v75;
            v75 += 8;
            *(void *)int v74 = v83;
            v74 += 8;
          }
          while (v74 != v73);
        }
      }
      *a1 = v72;
      a1[1] = v44;
      a1[2] = v73;
      a1[3] = &v72[v71];
      if (v19)
      {
        operator delete(v19);
        uint64_t v44 = (char *)a1[1];
      }
    }
    else
    {
      uint64_t v44 = v19;
    }
    *((void *)v44 - 1) = v25;
    uint64_t v84 = (char *)a1[1];
    unint64_t v5 = (char *)a1[2];
    a1[1] = v84 - 8;
    uint64_t v8 = *((void *)v84 - 1);
    a1[1] = v84;
    if (v5 != (char *)a1[3]) {
      goto LABEL_94;
    }
    uint64_t v85 = (char *)*a1;
    if ((unint64_t)v84 > *a1)
    {
      uint64_t v86 = (uint64_t)&v84[-*a1] >> 3;
      if (v86 >= -1) {
        uint64_t v87 = v86 + 1;
      }
      else {
        uint64_t v87 = v86 + 2;
      }
      uint64_t v88 = v87 >> 1;
      uint64_t v89 = -v88;
      uint64_t v90 = &v84[-8 * v88];
      int64_t v91 = v5 - v84;
      if (v5 != v84)
      {
        memmove(&v84[-8 * v88], v84, v5 - v84);
        uint64_t v84 = (char *)a1[1];
      }
      unint64_t v5 = &v90[v91];
      uint64_t v16 = &v84[8 * v89];
LABEL_11:
      a1[1] = v16;
      a1[2] = v5;
      goto LABEL_94;
    }
    unint64_t v101 = (v5 - v85) >> 2;
    if (v5 == v85) {
      unint64_t v101 = 1;
    }
    if (!(v101 >> 61))
    {
      unint64_t v102 = v101 >> 2;
      uint64_t v103 = 8 * v101;
      uint64_t v104 = (char *)operator new(8 * v101);
      uint64_t v105 = &v104[8 * v102];
      int64_t v106 = v5 - v84;
      BOOL v40 = v5 == v84;
      unint64_t v5 = v105;
      if (!v40)
      {
        unint64_t v5 = &v105[v106 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v107 = v106 - 8;
        if ((unint64_t)(v106 - 8) >= 0x38)
        {
          uint64_t v109 = &v104[8 * v102];
          uint64_t v108 = v109;
          if ((unint64_t)(v109 - v84) >= 0x20)
          {
            uint64_t v110 = (v107 >> 3) + 1;
            uint64_t v111 = 8 * (v110 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v108 = &v105[v111];
            uint64_t v112 = &v84[v111];
            uint64_t v113 = (long long *)(v84 + 16);
            CFStringRef v114 = v109 + 16;
            uint64_t v115 = v110 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v116 = *v113;
              *(v114 - 1) = *(v113 - 1);
              *CFStringRef v114 = v116;
              v113 += 2;
              v114 += 2;
              v115 -= 4;
            }
            while (v115);
            uint64_t v84 = v112;
            if (v110 == (v110 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_108;
            }
          }
        }
        else
        {
          uint64_t v108 = &v104[8 * v102];
        }
        do
        {
          uint64_t v117 = *(void *)v84;
          v84 += 8;
          *(void *)uint64_t v108 = v117;
          v108 += 8;
        }
        while (v108 != v5);
      }
LABEL_108:
      *a1 = v104;
      a1[1] = v105;
      a1[2] = v5;
      a1[3] = &v104[v103];
      if (!v85) {
        goto LABEL_94;
      }
      uint64_t v100 = v85;
      goto LABEL_93;
    }
LABEL_111:
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v26 = v23 >> 2;
  if (v17 == v20) {
    unint64_t v27 = 1;
  }
  else {
    unint64_t v27 = v26;
  }
  if (v27 >> 61) {
    goto LABEL_111;
  }
  uint64_t v28 = (char *)operator new(8 * v27);
  uint64_t v29 = operator new(0x1000uLL);
  uint64_t v30 = &v28[8 * v22];
  uint64_t v31 = &v28[8 * v27];
  if (v22 == v27)
  {
    unint64_t v33 = v29;
    if (v21 < 1)
    {
      if (v18 == v19) {
        unint64_t v45 = 1;
      }
      else {
        unint64_t v45 = v21 >> 2;
      }
      if (v45 >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v30 = (char *)operator new(8 * v45);
      uint64_t v31 = &v30[8 * v45];
      operator delete(v28);
      uint64_t v46 = (char *)a1[1];
      uint64_t v18 = (char *)a1[2];
      uint64_t v28 = v30;
      *(void *)uint64_t v30 = v33;
      uint64_t v32 = v30 + 8;
      if (v18 == v46) {
        goto LABEL_40;
      }
    }
    else
    {
      unint64_t v34 = v22 + 2;
      if (v22 >= -1) {
        unint64_t v34 = v22 + 1;
      }
      v30 -= 8 * (v34 >> 1);
      *(void *)uint64_t v30 = v29;
      uint64_t v32 = v30 + 8;
      if (v18 == v19) {
        goto LABEL_40;
      }
    }
    goto LABEL_46;
  }
  *(void *)uint64_t v30 = v29;
  uint64_t v32 = v30 + 8;
  if (v18 != v19)
  {
    do
    {
LABEL_46:
      if (v30 == v28)
      {
        if (v32 >= v31)
        {
          if (v31 == v28) {
            unint64_t v53 = 1;
          }
          else {
            unint64_t v53 = (v31 - v28) >> 2;
          }
          if (v53 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v54 = (char *)operator new(8 * v53);
          uint64_t v55 = v54;
          unint64_t v56 = (v53 + 3) >> 2;
          uint64_t v30 = &v54[8 * v56];
          int64_t v57 = v32 - v28;
          BOOL v40 = v32 == v28;
          uint64_t v32 = v30;
          if (!v40)
          {
            uint64_t v32 = &v30[v57 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v58 = v57 - 8;
            uint64_t v59 = &v54[8 * v56];
            unint64_t v60 = v28;
            if (v58 < 0x38) {
              goto LABEL_116;
            }
            uint64_t v61 = 8 * v56;
            uint64_t v59 = &v54[8 * v56];
            unint64_t v60 = v28;
            if ((unint64_t)(v59 - v28) < 0x20) {
              goto LABEL_116;
            }
            uint64_t v62 = (v58 >> 3) + 1;
            uint64_t v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v59 = &v30[v63];
            unint64_t v60 = &v28[v63];
            uint64_t v64 = (long long *)(v28 + 16);
            uint64_t v65 = &v54[v61 + 16];
            uint64_t v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v67 = *v64;
              *((_OWORD *)v65 - 1) = *(v64 - 1);
              *(_OWORD *)uint64_t v65 = v67;
              v64 += 2;
              v65 += 32;
              v66 -= 4;
            }
            while (v66);
            if (v62 != (v62 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_116:
              do
              {
                uint64_t v68 = *(void *)v60;
                v60 += 8;
                *(void *)uint64_t v59 = v68;
                v59 += 8;
              }
              while (v59 != v32);
            }
          }
          uint64_t v31 = &v54[8 * v53];
          operator delete(v28);
          uint64_t v28 = v55;
        }
        else
        {
          uint64_t v49 = (v31 - v32) >> 3;
          if (v49 >= -1) {
            uint64_t v50 = v49 + 1;
          }
          else {
            uint64_t v50 = v49 + 2;
          }
          uint64_t v51 = v50 >> 1;
          uint64_t v30 = &v28[8 * (v50 >> 1)];
          uint64_t v52 = v28;
          if (v32 != v28)
          {
            memmove(v30, v28, v32 - v28);
            uint64_t v52 = v32;
          }
          uint64_t v32 = (char *)v52 + 8 * v51;
        }
      }
      uint64_t v48 = *((void *)v18 - 1);
      v18 -= 8;
      *((void *)v30 - 1) = v48;
      v30 -= 8;
    }
    while (v18 != (char *)a1[1]);
  }
LABEL_40:
  uint64_t v47 = (char *)*a1;
  *a1 = v28;
  a1[1] = v30;
  a1[2] = v32;
  a1[3] = v31;
  if (v47)
  {
    operator delete(v47);
  }
}

void sub_21DEF25D8(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *BBUCommunication::create(capabilities::updater *a1)
{
  switch(capabilities::updater::getCommunicationType(a1))
  {
    case 0u:
    case 3u:
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 87, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Communication/Common/BBUCommunication.cpp", 0x1Bu, (ctu::LogMessageBuffer *)"Assertion failure(false && \"Unrecognized radio type.\")", v12, v13, v14, v15);
    case 1u:
      BOOL v3 = operator new(0x60uLL);
      *(void *)BOOL v3 = &unk_26CECBBA0;
      *((void *)v3 + 1) = a1;
      __asm { FMOV            V0.2D, #5.0 }
      *((_OWORD *)v3 + 1) = _Q0;
      strcpy((char *)v3 + 32, "/dev/cu.debug");
      *((unsigned char *)v3 + 55) = 13;
      *((_DWORD *)v3 + 14) = -1;
      *((double *)v3 + 3) = *((double *)v3 + 3)
                          + (double)(capabilities::updater::bootupTimeMaxValue((capabilities::updater *)v3) / 1000);
      *(void *)BOOL v3 = &unk_26CECBAD0;
      goto LABEL_4;
    case 2u:
      BOOL v3 = operator new(0x60uLL);
      *(void *)BOOL v3 = &unk_26CECE578;
      *((void *)v3 + 1) = a1;
      __asm { FMOV            V0.2D, #5.0 }
      *((_OWORD *)v3 + 1) = _Q0;
      strcpy((char *)v3 + 32, "/dev/cu.debug");
      *((unsigned char *)v3 + 55) = 13;
      *((_DWORD *)v3 + 14) = -1;
      *((double *)v3 + 3) = *((double *)v3 + 3)
                          + (double)(capabilities::updater::bootupTimeMaxValue((capabilities::updater *)v3) / 1000);
      *(void *)BOOL v3 = &unk_26CECECB0;
      *((unsigned char *)v3 + 60) = 0;
LABEL_4:
      *((void *)v3 + 8) = dispatch_queue_create("com.apple.BBUCommunication", 0);
      *((void *)v3 + 9) = dispatch_queue_create("com.apple.BBUStatuscallback", 0);
      *((void *)v3 + 10) = 0;
      *((_DWORD *)v3 + 22) = 34;
      uint64_t result = v3;
      break;
    default:
      uint64_t result = v1;
      break;
  }
  return result;
}

void sub_21DEF2854(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF2868(_Unwind_Exception *a1)
{
  if (v1[55] < 0) {
    operator delete(*v2);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void BBUCommunication::getIPCLogBuffer(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t ICEStateMachineStart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 368) = 1;
  _BBUFSDebugPrint("sRegister", "Registering for NVM updates: opt=%p, ari=%u\n", a3, a4, a5, a6, a7, a8, *(void *)(a1 + 96));
  uint64_t v8 = KTLNVMSendRegister();
  _BBUFSDebugPrint("sRegister", "Register call returns %d\n", v9, v10, v11, v12, v13, v14, v8);
  return v8;
}

uint64_t ICEStateMachineStop(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 368) = 0;
  if (*(unsigned char *)(a1 + 393)) {
    return 1;
  }
  _BBUFSDebugPrint("sDeRegister", "De-registering for NVM updates\n", a3, a4, a5, a6, a7, a8, v11);
  uint64_t v10 = *(void *)(a1 + 96);

  return MEMORY[0x270F92918](v10);
}

uint64_t ICEStateMachinePerformSnapshot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __s = (char *)(a1 + 104);
  uint64_t v222 = *MEMORY[0x263EF8340];
  *(unsigned char *)(a1 + 400) = 0;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = *(int *)(a1 + 376);
        uint64_t v10 = "Unknown";
        if (v9 <= 2) {
          uint64_t v10 = off_2644899B8[v9];
        }
        char v11 = (capabilities::updater *)_BBUFSDebugPrint("ICEStateMachinePerformSnapshot", "---------------------%s---------------------\n", a3, a4, a5, a6, a7, a8, (char)v10);
        int v18 = *(_DWORD *)(a1 + 376);
        if (v18 == 2) {
          break;
        }
        if (v18 == 1)
        {
          *(void *)&long long v27 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v27 + 1) = 0xAAAAAAAAAAAAAAAALL;
          long long v220 = v27;
          long long v221 = v27;
          *(_OWORD *)&v218[16] = v27;
          long long v219 = v27;
          *(_OWORD *)v218 = v27;
          if (!KTLNVMReadUpdateHeader())
          {
            v197 = "failed reading update header\n";
LABEL_189:
            _BBUFSDebugPrint("sProcessUpdate", v197, a3, a4, a5, a6, a7, a8, v205);
            goto LABEL_190;
          }
          uint64_t v28 = DWORD1(v221);
          _BBUFSDebugPrint("sProcessUpdate", "Expecting %d bytes from device\n", a3, a4, a5, a6, a7, a8, SBYTE4(v221));
          int v29 = DWORD1(v219);
          uint64_t v30 = v221;
          *(_DWORD *)(a1 + 396) = DWORD1(v219);
          uint64_t v210 = v30;
          v209 = (std::string *)__s;
          _BBUFSDebugPrint("sSaveRecord", "saving file %u to %s, offset %u, size %u\n", v31, v32, v33, v34, v35, v36, v29);
          memset(&v217, 170, sizeof(v217));
          uint64_t v37 = (const void *)kBBUFSServerBackupName;
          size_t v38 = strlen((const char *)kBBUFSServerBackupName);
          if (v38 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          std::string::size_type v39 = v38;
          if (v38 >= 0x17)
          {
            uint64_t v61 = (v38 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v38 | 7) != 0x17) {
              uint64_t v61 = v38 | 7;
            }
            uint64_t v62 = v61 + 1;
            BOOL v40 = operator new(v61 + 1);
            v217.__r_.__value_.__l.__size_ = v39;
            v217.__r_.__value_.__r.__words[2] = v62 | 0x8000000000000000;
            v217.__r_.__value_.__r.__words[0] = (std::string::size_type)v40;
LABEL_44:
            memmove(v40, v37, v39);
            goto LABEL_45;
          }
          *((unsigned char *)&v217.__r_.__value_.__s + 23) = v38;
          BOOL v40 = &v217;
          if (v38) {
            goto LABEL_44;
          }
LABEL_45:
          *((unsigned char *)v40 + v39) = 0;
          memset(&v216, 170, sizeof(v216));
          size_t v63 = strlen(__s);
          if (v63 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          std::string::size_type v64 = v63;
          if (v63 >= 0x17)
          {
            uint64_t v66 = (v63 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v63 | 7) != 0x17) {
              uint64_t v66 = v63 | 7;
            }
            uint64_t v67 = v66 + 1;
            uint64_t v65 = operator new(v66 + 1);
            v216.__r_.__value_.__l.__size_ = v64;
            v216.__r_.__value_.__r.__words[2] = v67 | 0x8000000000000000;
            v216.__r_.__value_.__r.__words[0] = (std::string::size_type)v65;
LABEL_52:
            memcpy(v65, __s, v64);
            goto LABEL_53;
          }
          *((unsigned char *)&v216.__r_.__value_.__s + 23) = v63;
          uint64_t v65 = &v216;
          if (v63) {
            goto LABEL_52;
          }
LABEL_53:
          *((unsigned char *)v65 + v64) = 0;
          ctu::path_join_impl();
          int v74 = 1;
          uint64_t v75 = "calib.nvm";
          switch(v29)
          {
            case 0:
              break;
            case 1:
              uint64_t v75 = "static.nvm";
              break;
            case 2:
              uint64_t v75 = "dynamic.nvm";
              break;
            case 3:
              uint64_t v75 = "bbpac.der";
              break;
            default:
              _BBUFSDebugPrint("sSaveRecord", "failed obtaining true file name\n", v68, v69, v70, v71, v72, v73, v206);
              int v74 = 0;
              uint64_t v75 = 0;
              break;
          }
          memset(v215, 170, sizeof(v215));
          size_t v76 = strlen(v75);
          if (v76 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          unint64_t v77 = (void *)v76;
          if (v76 >= 0x17)
          {
            uint64_t v79 = (v76 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v76 | 7) != 0x17) {
              uint64_t v79 = v76 | 7;
            }
            uint64_t v80 = v79 + 1;
            uint64_t v78 = (void **)operator new(v79 + 1);
            v215[1] = v77;
            v215[2] = (void *)(v80 | 0x8000000000000000);
            v215[0] = v78;
LABEL_65:
            memcpy(v78, v75, (size_t)v77);
            goto LABEL_66;
          }
          HIBYTE(v215[2]) = v76;
          uint64_t v78 = v215;
          if (v76) {
            goto LABEL_65;
          }
LABEL_66:
          *((unsigned char *)v77 + (void)v78) = 0;
          memset(v214, 170, sizeof(v214));
          size_t v81 = strlen(__s);
          if (v81 > 0x7FFFFFFFFFFFFFF7) {
            std::string::__throw_length_error[abi:ne180100]();
          }
          long long v82 = (void *)v81;
          if (v81 >= 0x17)
          {
            uint64_t v84 = (v81 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v81 | 7) != 0x17) {
              uint64_t v84 = v81 | 7;
            }
            uint64_t v85 = v84 + 1;
            uint64_t v83 = (void **)operator new(v84 + 1);
            v214[1] = v82;
            v214[2] = (void *)(v85 | 0x8000000000000000);
            v214[0] = v83;
LABEL_73:
            memcpy(v83, __s, (size_t)v82);
            goto LABEL_74;
          }
          HIBYTE(v214[2]) = v81;
          uint64_t v83 = v214;
          if (v81) {
            goto LABEL_73;
          }
LABEL_74:
          *((unsigned char *)v82 + (void)v83) = 0;
          ctu::path_join_impl();
          memset(&v213, 170, sizeof(v213));
          if (SHIBYTE(v216.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&v213, v216.__r_.__value_.__l.__data_, v216.__r_.__value_.__l.__size_);
          }
          else {
            std::string v213 = v216;
          }
          ctu::path_join_impl();
          if (!v74) {
            goto LABEL_82;
          }
          v92.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          v92.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          *(timespec *)&__dst.st_blkstd::string::size_type size = v92;
          *(timespec *)__dst.st_qspare = v92;
          *(timespec *)&__dst.st_std::string::size_type size = v92;
          __dst.st_ctimespec = v92;
          __dst.st_birthtimespec = v92;
          __dst.st_atimespec = v92;
          __dst.st_mtimespec = v92;
          *(timespec *)&__dst.st_dev = v92;
          *(timespec *)&__dst.st_uid = v92;
          uint64_t v93 = SHIBYTE(v214[2]) >= 0 ? (const char *)v214 : (const char *)v214[0];
          if (!stat(v93, &__dst))
          {
            v113.tv_sec = 0xAAAAAAAAAAAAAAAALL;
            v113.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
            *(timespec *)&__dst.st_blkstd::string::size_type size = v113;
            *(timespec *)__dst.st_qspare = v113;
            *(timespec *)&__dst.st_std::string::size_type size = v113;
            __dst.st_ctimespec = v113;
            __dst.st_birthtimespec = v113;
            __dst.st_atimespec = v113;
            __dst.st_mtimespec = v113;
            *(timespec *)&__dst.st_dev = v113;
            *(timespec *)&__dst.st_uid = v113;
            if ((v216.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              CFStringRef v114 = &v216;
            }
            else {
              CFStringRef v114 = (std::string *)v216.__r_.__value_.__r.__words[0];
            }
            if (stat((const char *)v114, &__dst))
            {
              uint64_t v121 = &v216;
              if ((v216.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                LOBYTE(v121) = v216.__r_.__value_.__s.__data_[0];
              }
              _BBUFSDebugPrint("sSaveRecord", "creating backup directory at %s\n", v115, v116, v117, v118, v119, v120, (char)v121);
              if ((v216.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v122 = &v216;
              }
              else {
                uint64_t v122 = (std::string *)v216.__r_.__value_.__r.__words[0];
              }
              int v123 = mkdir((const char *)v122, 0x1C0u);
              if (v123)
              {
                char v124 = v123;
                __error();
                uint64_t v125 = __error();
                strerror(*v125);
                _BBUFSDebugPrint("sSaveRecord", "failed creating backup directory: %d, %d (%s)\n", v126, v127, v128, v129, v130, v131, v124);
                goto LABEL_145;
              }
            }
            else if ((__dst.st_mode & 0xF000) != 0x4000)
            {
              _BBUFSDebugPrint("sSaveRecord", "backup dir path exists but is not a directory\n", v115, v116, v117, v118, v119, v120, v206);
              goto LABEL_145;
            }
            if (SHIBYTE(v214[2]) >= 0) {
              std::string::size_type v147 = v214;
            }
            else {
              LOBYTE(v147) = v214[0];
            }
            CFTypeRef v148 = &v213;
            if ((v213.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              CFTypeRef v148 = (std::string *)v213.__r_.__value_.__r.__words[0];
            }
            v209 = v148;
            _BBUFSDebugPrint("sSaveRecord", "backing up file from %s to %s\n", v115, v116, v117, v118, v119, v120, (char)v147);
            if (SHIBYTE(v214[2]) >= 0) {
              long long v150 = (const std::__fs::filesystem::path *)v214;
            }
            else {
              long long v150 = (const std::__fs::filesystem::path *)v214[0];
            }
            if ((v213.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v151 = (const std::__fs::filesystem::path *)&v213;
            }
            else {
              long long v151 = (const std::__fs::filesystem::path *)v213.__r_.__value_.__r.__words[0];
            }
            rename(v150, v151, v149);
            if (v152 < 0)
            {
              if (SHIBYTE(v214[2]) >= 0) {
                uint64_t v160 = v214;
              }
              else {
                LOBYTE(v160) = v214[0];
              }
              CFRange v161 = __error();
              strerror(*v161);
              _BBUFSDebugPrint("sSaveRecord", "failed backing up file %s to %s:  %s\n", v162, v163, v164, v165, v166, v167, (char)v160);
LABEL_145:
              int v94 = 0;
              int v96 = -1;
LABEL_146:
              int v159 = 0;
              memset(&__dst, 0, 88);
              goto LABEL_147;
            }
            int v94 = 0;
          }
          else
          {
LABEL_82:
            _BBUFSDebugPrint("sSaveRecord", "nothing to back up\n", v86, v87, v88, v89, v90, v91, v206);
            int v94 = 1;
            if (!v74)
            {
              int v96 = -1;
              goto LABEL_146;
            }
          }
          if (SHIBYTE(v214[2]) >= 0) {
            uint64_t v95 = (const char *)v214;
          }
          else {
            uint64_t v95 = (const char *)v214[0];
          }
          int v96 = open(v95, 1537, 384, v209, v210, v28);
          if (v96 < 0)
          {
            if (SHIBYTE(v214[2]) >= 0) {
              CFRange v132 = v214;
            }
            else {
              LOBYTE(v132) = v214[0];
            }
            CFTypeRef v133 = __error();
            strerror(*v133);
            _BBUFSDebugPrint("sSaveRecord", "failed opening %s:  %s\n", v134, v135, v136, v137, v138, v139, (char)v132);
            goto LABEL_146;
          }
          uint64_t v97 = getpwnam("_wireless");
          if (!v97)
          {
            _BBUFSDebugPrint("getWirelessID", "failed to get uid and gid information for _wireless\n", v98, v99, v100, v101, v102, v103, v205);
            _BBUFSDebugPrint("sSaveRecord", "failed to get uid and gid information for _wireless\n", v141, v142, v143, v144, v145, v146, v207);
            goto LABEL_146;
          }
          if (fchown(v96, v97->pw_uid, v97->pw_gid))
          {
            uint64_t v104 = __error();
            char v105 = strerror(*v104);
            _BBUFSDebugPrint("sSaveRecord", "failed changing file owner:  %s", v106, v107, v108, v109, v110, v111, v105);
            goto LABEL_146;
          }
          memset(&__dst, 0, 88);
          if (TelephonyUtilTransportCreateWithFD())
          {
            int v159 = 1;
          }
          else
          {
            _BBUFSDebugPrint("sSaveRecord", "failed creating telephony util transport\n", v153, v154, v155, v156, v157, v158, v205);
            int v159 = 0;
          }
LABEL_147:
          if (!v159)
          {
            int v175 = 0;
            if (v96 < 0) {
              goto LABEL_163;
            }
LABEL_157:
            if (close(v96)) {
              char v176 = 0;
            }
            else {
              char v176 = v175;
            }
            if (v176)
            {
              int v175 = 1;
            }
            else
            {
              v177 = __error();
              char v178 = strerror(*v177);
              _BBUFSDebugPrint("sSaveRecord", "failed closing saved record:  %s\n", v179, v180, v181, v182, v183, v184, v178);
              int v175 = 0;
            }
            goto LABEL_163;
          }
          int v168 = ICE_FILER_read();
          if (v168 == v28)
          {
            int v175 = 1;
            if (v96 < 0) {
              goto LABEL_163;
            }
            goto LABEL_157;
          }
          if (v168 < 0) {
            _BBUFSDebugPrint("sSaveRecord", "failed reading file: return code = %d\n", v169, v170, v171, v172, v173, v174, v168);
          }
          else {
            _BBUFSDebugPrint("sSaveRecord", "Unexpected data size received.  Got %u, expected %u\n", v169, v170, v171, v172, v173, v174, v168);
          }
          int v175 = 0;
          if ((v96 & 0x80000000) == 0) {
            goto LABEL_157;
          }
LABEL_163:
          TelephonyUtilTransportFree();
          if (((v94 | v175) & 1) == 0)
          {
            _BBUFSDebugPrint("sSaveRecord", "restoring backup file\n", a3, a4, a5, a6, a7, a8, v205);
            v186 = (v213.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                 ? (const std::__fs::filesystem::path *)&v213
                 : (const std::__fs::filesystem::path *)v213.__r_.__value_.__r.__words[0];
            v187 = SHIBYTE(v214[2]) >= 0
                 ? (const std::__fs::filesystem::path *)v214
                 : (const std::__fs::filesystem::path *)v214[0];
            rename(v186, v187, v185);
            if (v188 < 0)
            {
              v189 = __error();
              char v190 = strerror(*v189);
              _BBUFSDebugPrint("sSaveRecord", "failed restoring backup file %s\n", v191, v192, v193, v194, v195, v196, v190);
            }
          }
          if (SHIBYTE(v213.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v213.__r_.__value_.__l.__data_);
            if ((SHIBYTE(v214[2]) & 0x80000000) == 0)
            {
LABEL_174:
              if ((SHIBYTE(v215[2]) & 0x80000000) == 0) {
                goto LABEL_175;
              }
              goto LABEL_181;
            }
          }
          else if ((SHIBYTE(v214[2]) & 0x80000000) == 0)
          {
            goto LABEL_174;
          }
          operator delete(v214[0]);
          if ((SHIBYTE(v215[2]) & 0x80000000) == 0)
          {
LABEL_175:
            if ((SHIBYTE(v216.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_176;
            }
            goto LABEL_182;
          }
LABEL_181:
          operator delete(v215[0]);
          if ((SHIBYTE(v216.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_176:
            if ((SHIBYTE(v217.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_177;
            }
            goto LABEL_183;
          }
LABEL_182:
          operator delete(v216.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v217.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_177:
            if ((v175 & 1) == 0) {
              goto LABEL_188;
            }
            goto LABEL_184;
          }
LABEL_183:
          operator delete(v217.__r_.__value_.__l.__data_);
          if ((v175 & 1) == 0)
          {
LABEL_188:
            v197 = "failed saving update\n";
            goto LABEL_189;
          }
LABEL_184:
          *(_DWORD *)(a1 + 376) = 2;
        }
        else if (v18)
        {
          _BBUFSDebugPrint("ICEStateMachinePerformSnapshot", "unknown state\n", v12, v13, v14, v15, v16, v17, v205);
        }
        else
        {
          LOBYTE(__dst.st_dev) = 0;
          int v19 = *(_DWORD *)(a1 + 388);
          BOOL v20 = *(unsigned char *)(a1 + 393) != 0;
          if ((v20 & capabilities::updater::shouldOnlySyncDynamicOnShutdown(v11)) == 1 && v19 == 40) {
            _BBUFSDebugPrint("sSnapshot", "Only sync dynamic.nvm when shutdown sync is triggered\n", v21, v22, v23, v24, v25, v26, v205);
          }
          if ((KTLNVMSendSnapshot() & 1) == 0)
          {
            _BBUFSDebugPrint("sSnapshot", "failed sending snapshot command\n", a3, a4, a5, a6, a7, a8, v205);
LABEL_190:
            unsigned int updated = 0;
            goto LABEL_191;
          }
          if (!LOBYTE(__dst.st_dev))
          {
            _BBUFSDebugPrint("sSnapshot", "No update pending, finished with sync\n", a3, a4, a5, a6, a7, a8, v205);
            *(_DWORD *)(a1 + 376) = 0;
            _BBUFSDebugPrint("ICEStateMachinePerformSnapshot", "device has no further updates\n", v198, v199, v200, v201, v202, v203, v208);
            unsigned int updated = 1;
            goto LABEL_191;
          }
          *(_DWORD *)(a1 + 376) = 1;
          *(unsigned char *)(a1 + 400) = 1;
        }
      }
      LOBYTE(v215[0]) = 0;
      unsigned int updated = KTLNVMSendUpdateAck();
      if ((updated & 1) == 0) {
        _BBUFSDebugPrint("sUpdateAck", "failed acknowledging update\n", v41, v42, v43, v44, v45, v46, v205);
      }
      int v48 = LOBYTE(v215[0]);
      memset(&__dst, 170, 24);
      uint64_t v49 = (const void *)kBBUFSServerBackupName;
      size_t v50 = strlen((const char *)kBBUFSServerBackupName);
      if (v50 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      __darwin_ino64_t v51 = v50;
      if (v50 >= 0x17)
      {
        uint64_t v53 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v50 | 7) != 0x17) {
          uint64_t v53 = v50 | 7;
        }
        uint64_t v54 = v53 + 1;
        p_dst = (stat *)operator new(v53 + 1);
        __dst.st_ino = v51;
        *(void *)&__dst.st_uid = v54 | 0x8000000000000000;
        *(void *)&__dst.st_dev = p_dst;
LABEL_28:
        memmove(p_dst, v49, v51);
        goto LABEL_29;
      }
      HIBYTE(__dst.st_gid) = v50;
      p_dst = &__dst;
      if (v50) {
        goto LABEL_28;
      }
LABEL_29:
      *((unsigned char *)&p_dst->st_dev + v51) = 0;
      memset(v218, 170, 24);
      size_t v55 = strlen(__s);
      if (v55 > 0x7FFFFFFFFFFFFFF7) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v56 = v55;
      if (v55 >= 0x17)
      {
        uint64_t v58 = (v55 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v55 | 7) != 0x17) {
          uint64_t v58 = v55 | 7;
        }
        uint64_t v59 = v58 + 1;
        int64_t v57 = operator new(v58 + 1);
        *(void *)&v218[8] = v56;
        *(void *)&v218[16] = v59 | 0x8000000000000000;
        *(void *)v218 = v57;
LABEL_36:
        memcpy(v57, __s, v56);
        goto LABEL_37;
      }
      v218[23] = v55;
      int64_t v57 = v218;
      if (v55) {
        goto LABEL_36;
      }
LABEL_37:
      v57[v56] = 0;
      ctu::path_join_impl();
      int v60 = v48 ^ 1;
      if (!updated) {
        goto LABEL_92;
      }
      if (!v60) {
        break;
      }
      if (!ctu::fs::read_folder()) {
        _BBUFSDebugPrint("sUpdateAck", "did not find any backup\n", a3, a4, a5, a6, a7, a8, v205);
      }
      unsigned int updated = 1;
      if ((v218[23] & 0x80000000) == 0) {
        goto LABEL_93;
      }
LABEL_115:
      operator delete(*(void **)v218);
      if ((SHIBYTE(__dst.st_gid) & 0x80000000) == 0) {
        goto LABEL_94;
      }
LABEL_116:
      operator delete(*(void **)&__dst.st_dev);
      char v140 = updated ^ 1;
      if (v60) {
        char v140 = 1;
      }
      if (v140) {
        goto LABEL_119;
      }
LABEL_97:
      *(_DWORD *)(a1 + 376) = 1;
    }
    unsigned int updated = 1;
LABEL_92:
    if ((v218[23] & 0x80000000) != 0) {
      goto LABEL_115;
    }
LABEL_93:
    if (SHIBYTE(__dst.st_gid) < 0) {
      goto LABEL_116;
    }
LABEL_94:
    char v112 = updated ^ 1;
    if (v60) {
      char v112 = 1;
    }
    if ((v112 & 1) == 0) {
      goto LABEL_97;
    }
LABEL_119:
    if (v60) {
      break;
    }
    if ((updated & 1) == 0) {
      goto LABEL_190;
    }
  }
  *(_DWORD *)(a1 + 376) = 0;
  _BBUFSDebugPrint("ICEStateMachinePerformSnapshot", "device has no further updates\n", a3, a4, a5, a6, a7, a8, v205);
LABEL_191:
  if (*(unsigned char *)(a1 + 368)) {
    return updated;
  }
  else {
    return 1;
  }
}

void sub_21DEF38B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,int a45,__int16 a46,char a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,uint64_t a56,uint64_t a57,int a58,__int16 a59,char a60,char a61,uint64_t a62,uint64_t a63)
{
  if (a48 < 0)
  {
    operator delete(v67[18]);
    if ((a55 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a61 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((a55 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(v67[22]);
  if ((a61 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a67 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  operator delete(v67[25]);
  if ((a67 & 0x80000000) == 0)
  {
LABEL_5:
    if ((*(char *)(v68 - 217) & 0x80000000) == 0) {
LABEL_12:
    }
      _Unwind_Resume(a1);
LABEL_11:
    operator delete(v67[32]);
    _Unwind_Resume(a1);
  }
LABEL_10:
  operator delete(v67[28]);
  if ((*(char *)(v68 - 217) & 0x80000000) == 0) {
    goto LABEL_12;
  }
  goto LABEL_11;
}

uint64_t ICEStateMachineSetConfig(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || !a2)
  {
    _BBUFSDebugPrint("ICEStateMachineSetConfig", "failed to set config as one of the args is NULL\n", a3, a4, a5, a6, a7, a8, v45);
    return 0;
  }
  int v9 = a3;
  if (!strcasecmp("ForceSync", a2))
  {
    *(unsigned char *)(a1 + 392) = v9 != 0;
    uint64_t v42 = "false";
    if (v9) {
      uint64_t v42 = "true";
    }
    _BBUFSDebugPrint("ICEStateMachineSetConfig", "Set forceSync config to %s\n", v11, v12, v13, v14, v15, v16, (char)v42);
  }
  else if (!strcasecmp("ShutdownSync", a2))
  {
    *(unsigned char *)(a1 + 393) = v9 != 0;
    uint64_t v43 = "false";
    if (v9) {
      uint64_t v43 = "true";
    }
    _BBUFSDebugPrint("ICEStateMachineSetConfig", "Set shutdownSync config to %s\n", v17, v18, v19, v20, v21, v22, (char)v43);
  }
  else if (!strcasecmp("ARICtxId", a2))
  {
    *(_DWORD *)(a1 + 380) = v9;
    _BBUFSDebugPrint("ICEStateMachineSetConfig", "Set ARI context ID to %d\n", v23, v24, v25, v26, v27, v28, v9);
  }
  else
  {
    if (!strcasecmp("SyncStatic", a2))
    {
      *(_DWORD *)(a1 + 388) = 1;
      _BBUFSDebugPrint("ICEStateMachineSetConfig", "Requested to sync static\n", v29, v30, v31, v32, v33, v34, v45);
      return 1;
    }
    if (!strcasecmp("SyncDynamic", a2))
    {
      *(_DWORD *)(a1 + 388) = 2;
      uint64_t v44 = "Requested to sync dynamic\n";
    }
    else if (!strcasecmp("SyncCalibration", a2))
    {
      *(_DWORD *)(a1 + 388) = 0;
      uint64_t v44 = "Requested to sync calibration\n";
    }
    else if (!strcasecmp("SyncFATPCalibration", a2))
    {
      *(_DWORD *)(a1 + 388) = 3;
      uint64_t v44 = "Requested to sync FATP-calibration\n";
    }
    else if (!strcasecmp("SyncStaticDynamicCalibration", a2))
    {
      *(_DWORD *)(a1 + 388) = 30;
      uint64_t v44 = "Requested to sync static + dynamic + calibration\n";
    }
    else
    {
      if (strcasecmp("SyncStaticDynamic", a2))
      {
        _BBUFSDebugPrint("ICEStateMachineSetConfig", "failed to set config, unrecognized config name '%s'\n", v35, v36, v37, v38, v39, v40, (char)a2);
        return 0;
      }
      *(_DWORD *)(a1 + 388) = 40;
      uint64_t v44 = "Requested to sync static + dynamic\n";
    }
    _BBUFSDebugPrint("ICEStateMachineSetConfig", v44, v35, v36, v37, v38, v39, v40, v45);
  }
  return 1;
}

uint64_t ICEStateMachineSetConfigDefaults(uint64_t a1)
{
  *(_DWORD *)(a1 + 388) = 40;
  *(_WORD *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 396) = 40;
  *(unsigned char *)(a1 + 400) = 0;
  return 1;
}

BOOL ICEStateMachineSnapshotInProgress(uint64_t a1)
{
  return *(_DWORD *)(a1 + 376) > 0;
}

const char *___ZL11sSaveRecordP16_BBUFSServer_tagPKcjjj_block_invoke(const char *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (100 * a2 / a3 > _ZZZL11sSaveRecordP16_BBUFSServer_tagPKcjjjEUb_E19prev_update_percent + 10)
  {
    _ZZZL11sSaveRecordP16_BBUFSServer_tagPKcjjjEUb_E19prev_update_percent = 100 * a2 / a3;
    return _BBUFSDebugPrint("sHandleCapureProgress", "%s:  %0.1f%c\n", a3, a4, a5, a6, a7, a8, *((void *)result + 4));
  }
  return result;
}

uint64_t eUICC::getEID(capabilities::euicc *a1, uint64_t a2, BBUFeedback *a3)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  v50[0] = 0;
  v50[1] = 0;
  unint64_t v51 = 0;
  uint64_t v6 = (capabilities::radio *)capabilities::euicc::supportsLegacyUpdater(a1);
  if (v6)
  {
    char v7 = (capabilities::radio *)capabilities::radio::maverick(v6);
    if (v7)
    {
      uint64_t v8 = (char *)operator new(0x138uLL);
      *(_WORD *)(v8 + 289) = 0;
      *(void *)uint64_t v8 = &unk_26CED0128;
      *((void *)v8 + 37) = a1;
      *((_DWORD *)v8 + 73) = 255;
      v8[304] = 15;
    }
    else if (capabilities::radio::ice(v7))
    {
      uint64_t v8 = (char *)operator new(0x140uLL);
      eUICC::eUICCVinylICEValve::eUICCVinylICEValve((eUICC::eUICCVinylICEValve *)v8, a1, 255, 0);
    }
    else
    {
      uint64_t v8 = 0;
    }
    *(void *)&long long v19 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v19 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v79[10] = v19;
    long long v78 = v19;
    *(_OWORD *)uint64_t v79 = v19;
    long long v76 = v19;
    long long v77 = v19;
    long long v74 = v19;
    long long v75 = v19;
    long long v72 = v19;
    long long v73 = v19;
    long long v70 = v19;
    long long v71 = v19;
    long long v68 = v19;
    long long v69 = v19;
    long long v66 = v19;
    long long v67 = v19;
    long long v64 = v19;
    long long v65 = v19;
    long long v63 = v19;
    uint64_t v20 = (capabilities::updater *)(*(void *(**)(long long *__return_ptr, char *))(*(void *)v8 + 8))(&v63, v8);
    int v21 = capabilities::updater::EUICCVinylSuccessStatus(v20);
    int v22 = v21;
    int v23 = v63;
    if (v63 != v21)
    {
      if (v79[24])
      {
        BBUFeedback::handleComment(a3, "Failed to get EID - Adc config mismatch");
        uint64_t v26 = 126;
      }
      else
      {
        BBUFeedback::handleComment(a3, "Failed to get EID.");
        uint64_t v26 = 107;
      }
      goto LABEL_45;
    }
    int v46 = v63;
    int v47 = v21;
    unint64_t v61 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v60[7] = v24;
    v60[8] = v24;
    v60[5] = v24;
    v60[6] = v24;
    v60[3] = v24;
    v60[4] = v24;
    v60[1] = v24;
    v60[2] = v24;
    long long v59 = v24;
    v60[0] = v24;
    long long v57 = v24;
    long long v58 = v24;
    long long v55 = v24;
    long long v56 = v24;
    long long v53 = v24;
    long long v54 = v24;
    *(_OWORD *)CFDictionaryRef theDict = v24;
    std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)theDict);
    uint64_t v25 = 0;
    uint64_t v26 = (uint64_t)&v53 + 8;
    uint64_t v27 = (std::locale::id *)MEMORY[0x263F8C108];
    do
    {
      uint64_t v28 = v53;
      uint64_t v29 = v53;
      *(_DWORD *)((char *)&v53 + *(void *)(v53 - 24) + 8) = *(_DWORD *)((unsigned char *)&v53 + *(void *)(v53 - 24) + 8) & 0xFFFFFFB5 | 8;
      uint64_t v30 = (const std::ios_base *)((char *)&v53 + *(void *)(v29 - 24));
      if (v30[1].__fmtflags_ == -1)
      {
        std::ios_base::getloc(v30);
        uint64_t v31 = std::locale::use_facet(&v62, v27);
        ((void (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 32);
        std::locale::~locale(&v62);
        uint64_t v28 = v53;
      }
      v30[1].__fmtflags_ = 48;
      *(void *)((char *)&v54 + *(void *)(v28 - 24) + 8) = 2;
      std::ostream::operator<<();
      ++v25;
    }
    while (v25 != 16);
    if ((BYTE8(v59) & 0x10) != 0)
    {
      uint64_t v34 = v59;
      if ((unint64_t)v59 < *((void *)&v56 + 1))
      {
        *(void *)&long long v59 = *((void *)&v56 + 1);
        uint64_t v34 = *((void *)&v56 + 1);
      }
      uint64_t v35 = (const void *)v56;
      size_t v32 = v34 - v56;
      if ((unint64_t)(v34 - v56) > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_48;
      }
    }
    else
    {
      if ((BYTE8(v59) & 8) == 0)
      {
        size_t v32 = 0;
        HIBYTE(v49) = 0;
        p_dst = &__dst;
        goto LABEL_40;
      }
      uint64_t v35 = (const void *)*((void *)&v54 + 1);
      size_t v32 = *((void *)&v55 + 1) - *((void *)&v54 + 1);
      if (*((void *)&v55 + 1) - *((void *)&v54 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_48:
      }
        std::string::__throw_length_error[abi:ne180100]();
    }
    if (v32 >= 0x17)
    {
      uint64_t v36 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v32 | 7) != 0x17) {
        uint64_t v36 = v32 | 7;
      }
      uint64_t v37 = v36 + 1;
      p_dst = (long long *)operator new(v36 + 1);
      *((void *)&__dst + 1) = v32;
      unint64_t v49 = v37 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v49) = v32;
      p_dst = &__dst;
      if (!v32) {
        goto LABEL_40;
      }
    }
    memmove(p_dst, v35, v32);
LABEL_40:
    *((unsigned char *)p_dst + v32) = 0;
    theDict[0] = *(CFDictionaryRef *)MEMORY[0x263F8C2B8];
    uint64_t v38 = *(void *)(MEMORY[0x263F8C2B8] + 72);
    *(CFDictionaryRef *)((char *)theDict + *((void *)theDict[0] - 3)) = *(CFDictionaryRef *)(MEMORY[0x263F8C2B8] + 64);
    *(void *)&long long v53 = v38;
    *((void *)&v53 + 1) = MEMORY[0x263F8C318] + 16;
    if (SHIBYTE(v58) < 0) {
      operator delete(*((void **)&v57 + 1));
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x223C1DDF0](v60);
    int v23 = v46;
    int v22 = v47;
    if (SHIBYTE(v51) < 0) {
      operator delete(v50[0]);
    }
    *(_OWORD *)size_t v50 = __dst;
    unint64_t v51 = v49;
LABEL_45:
    (*(void (**)(char *))(*(void *)v8 + 96))(v8);
    if (v23 != v22)
    {
LABEL_66:
      if ((SHIBYTE(v51) & 0x80000000) == 0) {
        return v26;
      }
LABEL_74:
      operator delete(v50[0]);
      return v26;
    }
    goto LABEL_58;
  }
  BBUFeedback::handleComment(a3, "Querying vinyl library for EID");
  int v9 = dlopen("/usr/local/lib/libVinylNonUpdater.dylib", 1);
  uint64_t v10 = v9;
  if (!v9) {
    goto LABEL_58;
  }
  uint64_t v11 = dlsym(v9, "VinyleUICCPerformOperationWithTransport");
  if (!v11)
  {
LABEL_57:
    dlclose(v10);
    goto LABEL_58;
  }
  theDict[0] = 0;
  int v12 = ((uint64_t (*)(void, CFDictionaryRef *, void, uint64_t, capabilities::euicc *))v11)(0, theDict, 0, 1, a1);
  BBUFeedback::handleComment(a3, "VinyleUICCPerformOperationWithTransport returned %d", v12);
  if (!v12 && theDict[0])
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict[0], @"EID");
    if (!Value || (CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(Value)))
    {
LABEL_56:
      CFRelease(theDict[0]);
      goto LABEL_57;
    }
    CStringPtr = CFStringGetCStringPtr(Value, 0x8000100u);
    size_t v16 = strlen(CStringPtr);
    if (v16 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v17 = v16;
    if (v16 >= 0x17)
    {
      uint64_t v39 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v39 = v16 | 7;
      }
      uint64_t v40 = v39 + 1;
      uint64_t v18 = (long long *)operator new(v39 + 1);
      *((void *)&v63 + 1) = v17;
      *(void *)&long long v64 = v40 | 0x8000000000000000;
      *(void *)&long long v63 = v18;
    }
    else
    {
      BYTE7(v64) = v16;
      uint64_t v18 = &v63;
      if (!v16) {
        goto LABEL_53;
      }
    }
    memmove(v18, CStringPtr, v17);
LABEL_53:
    *((unsigned char *)v18 + v17) = 0;
    if (SHIBYTE(v51) < 0) {
      operator delete(v50[0]);
    }
    *(_OWORD *)size_t v50 = v63;
    unint64_t v51 = v64;
    goto LABEL_56;
  }
  dlclose(v10);
  if (v12)
  {
    BBUFeedback::handleComment(a3, "Failed to get EID.");
    goto LABEL_65;
  }
LABEL_58:
  if ((SHIBYTE(v51) & 0x80000000) == 0)
  {
    if (HIBYTE(v51))
    {
      uint64_t v41 = v50;
      goto LABEL_63;
    }
LABEL_65:
    uint64_t v26 = 107;
    goto LABEL_66;
  }
  if (!v50[1]) {
    goto LABEL_65;
  }
  uint64_t v41 = (void **)v50[0];
LABEL_63:
  BBUFeedback::handleComment(a3, "EID: %s", (const char *)v41);
  uint64_t v42 = (std::string *)operator new(0x18uLL);
  uint64_t v43 = v42;
  if (SHIBYTE(v51) < 0)
  {
    std::string::__init_copy_ctor_external(v42, (const std::string::value_type *)v50[0], (std::string::size_type)v50[1]);
  }
  else
  {
    *(_OWORD *)&v42->__r_.__value_.__l.__data_ = *(_OWORD *)v50;
    v42->__r_.__value_.__r.__words[2] = v51;
  }
  uint64_t v45 = *(void *)(a2 + 24);
  if (v45)
  {
    if (*(char *)(v45 + 23) < 0) {
      operator delete(*(void **)v45);
    }
    operator delete((void *)v45);
  }
  uint64_t v26 = 0;
  *(void *)(a2 + 24) = v43;
  if (SHIBYTE(v51) < 0) {
    goto LABEL_74;
  }
  return v26;
}

void sub_21DEF45F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,std::locale a59)
{
  operator delete(v59);
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_var_init_6()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<ICEARIContext>::~PthreadMutexGuardPolicy, &ctu::Singleton<ICEARIContext,ICEARIContext,ctu::PthreadMutexGuardPolicy<ICEARIContext>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

{
  uint64_t result;

  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<support::log::manager_global>::~PthreadMutexGuardPolicy, &stru_26AA8A330, &dword_21DE8A000);
  }
  return result;
}

uint64_t BBUICE16UpdateSource::getMRCFilePath@<X0>(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v30 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v29[7] = v3;
  v29[8] = v3;
  v29[5] = v3;
  v29[6] = v3;
  void v29[3] = v3;
  _OWORD v29[4] = v3;
  v29[1] = v3;
  v29[2] = v3;
  long long v28 = v3;
  v29[0] = v3;
  *(_OWORD *)uint64_t v26 = v3;
  long long v27 = v3;
  long long v24 = v3;
  long long v25 = v3;
  long long v22 = v3;
  long long v23 = v3;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v22);
  pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  unint64_t v4 = (BBUPartitionManager *)off_26AA89B50;
  if (!off_26AA89B50)
  {
    unint64_t v5 = (BBUPartitionManager *)operator new(0x18uLL);
    BBUPartitionManager::BBUPartitionManager(v5);
    uint64_t v6 = operator new(0x20uLL);
    void *v6 = &unk_26CECF498;
    v6[1] = 0;
    void v6[2] = 0;
    v6[3] = v5;
    char v7 = (std::__shared_weak_count *)off_26AA89B58;
    off_26AA89B50 = v5;
    off_26AA89B58 = v6;
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    unint64_t v4 = (BBUPartitionManager *)off_26AA89B50;
  }
  uint64_t v8 = (std::__shared_weak_count *)off_26AA89B58;
  if (off_26AA89B58) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  BBUPartitionManager::getBBUFSPath(v4, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v22, (uint64_t)p_p, size);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)"mrc.dat", 7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    char v12 = BYTE8(v28);
    if ((BYTE8(v28) & 0x10) == 0) {
      goto LABEL_19;
    }
LABEL_23:
    uint64_t v16 = v28;
    if ((unint64_t)v28 < *((void *)&v25 + 1))
    {
      *(void *)&long long v28 = *((void *)&v25 + 1);
      uint64_t v16 = *((void *)&v25 + 1);
    }
    uint64_t v15 = (const void **)&v25;
    goto LABEL_26;
  }
  char v12 = BYTE8(v28);
  if ((BYTE8(v28) & 0x10) != 0) {
    goto LABEL_23;
  }
LABEL_19:
  if ((v12 & 8) == 0)
  {
    std::string::size_type v13 = 0;
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    uint64_t v14 = &__p;
    goto LABEL_34;
  }
  uint64_t v15 = (const void **)&v23 + 1;
  uint64_t v16 = *((void *)&v24 + 1);
LABEL_26:
  size_t v17 = *v15;
  std::string::size_type v13 = v16 - (void)*v15;
  if (v13 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v13 >= 0x17)
  {
    uint64_t v18 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v13 | 7) != 0x17) {
      uint64_t v18 = v13 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v14 = (std::string *)operator new(v18 + 1);
    __p.__r_.__value_.__l.__size_ = v13;
    __p.__r_.__value_.__r.__words[2] = v19 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v14;
    goto LABEL_33;
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = v16 - *(unsigned char *)v15;
  uint64_t v14 = &__p;
  if (v13) {
LABEL_33:
  }
    memmove(v14, v17, v13);
LABEL_34:
  v14->__r_.__value_.__s.__data_[v13] = 0;
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(std::string *)a1 = __p;
  *(void *)&long long v22 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v22 + *(void *)(v22 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v22 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v27) < 0) {
    operator delete(v26[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x223C1DDF0](v29);
}

void sub_21DEF4A70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy((uint64_t)v19, v19[1]);
  operator delete(v19);
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  std::ostringstream::~ostringstream((uint64_t)&a18);
  if (*(char *)(v18 + 23) < 0) {
    operator delete(*(void **)v18);
  }
  _Unwind_Resume(a1);
}

uint64_t BBUICE16UpdateSource::getMRCFileName@<X0>(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v20[7] = v3;
  v20[8] = v3;
  v20[5] = v3;
  v20[6] = v3;
  v20[3] = v3;
  v20[4] = v3;
  v20[1] = v3;
  v20[2] = v3;
  v20[0] = v3;
  long long v18 = v3;
  long long v19 = v3;
  long long v16 = v3;
  *(_OWORD *)std::string __p = v3;
  long long v14 = v3;
  long long v15 = v3;
  long long v13 = v3;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v13);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v13, (uint64_t)"mrc.dat", 7);
  if ((BYTE8(v19) & 0x10) != 0)
  {
    uint64_t v6 = v19;
    if ((unint64_t)v19 < *((void *)&v16 + 1))
    {
      *(void *)&long long v19 = *((void *)&v16 + 1);
      uint64_t v6 = *((void *)&v16 + 1);
    }
    char v7 = (const void *)v16;
    size_t v4 = v6 - v16;
    if ((unint64_t)(v6 - v16) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_20;
    }
  }
  else
  {
    if ((BYTE8(v19) & 8) == 0)
    {
      size_t v4 = 0;
      HIBYTE(v12) = 0;
      p_dst = &__dst;
      goto LABEL_14;
    }
    char v7 = (const void *)*((void *)&v14 + 1);
    size_t v4 = *((void *)&v15 + 1) - *((void *)&v14 + 1);
    if (*((void *)&v15 + 1) - *((void *)&v14 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_20:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v4 >= 0x17)
  {
    uint64_t v8 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v8 = v4 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (long long *)operator new(v8 + 1);
    *((void *)&__dst + 1) = v4;
    unint64_t v12 = v9 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_13;
  }
  HIBYTE(v12) = v4;
  p_dst = &__dst;
  if (v4) {
LABEL_13:
  }
    memmove(p_dst, v7, v4);
LABEL_14:
  *((unsigned char *)p_dst + v4) = 0;
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = __dst;
  *(void *)(a1 + 16) = v12;
  *(void *)&long long v13 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v13 + *(void *)(v13 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v13 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x223C1DDF0](v20);
}

void sub_21DEF4D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DEF4D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void BBUICE16UpdateSource::BBUICE16UpdateSource(BBUICE16UpdateSource *this, BBUZipFile *a2, unsigned int a3, BBUFeedback *a4)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_26CECB8D8;
  *((void *)this + 1) = a4;
  *((void *)this + 8) = a2;
  uint64_t v6 = operator new(0x20uLL);
  void *v6 = &unk_26CECAF18;
  v6[1] = 0;
  void v6[2] = 0;
  v6[3] = a2;
  *((void *)this + 9) = v6;
  *((unsigned char *)this + 103) = 0;
  *((unsigned char *)this + 80) = 0;
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 14) = 0;
  *((unsigned char *)this + 120) = 0;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *(void *)this = &unk_26CECAD98;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((void *)this + 25) = 0;
  *((unsigned char *)this + 208) = 1;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((void *)this + 41) = 0;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  BBUICE16UpdateSource::init(this);
}

void sub_21DEF4E8C(_Unwind_Exception *a1)
{
  std::vector<std::string>::~vector[abi:ne180100](v1 + 39);
  std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](v1 + 36);
  std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](v1 + 33);
  std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](v1 + 30);
  std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](v2);
  BBUICEUpdateSource::~BBUICEUpdateSource((BBUICEUpdateSource *)v1);
  _Unwind_Resume(a1);
}

void sub_21DEF4ED4(_Unwind_Exception *a1)
{
  long long v3 = v2;
  if (v3)
  {
    BBUZipFile::~BBUZipFile(v3);
    operator delete(v5);
  }
  BBUUpdateSource::~BBUUpdateSource(v1);
  _Unwind_Resume(a1);
}

void **std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](void **a1)
{
  unint64_t v2 = (char *)*a1;
  if (*a1)
  {
    long long v3 = (char *)a1[1];
    size_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = (std::__shared_weak_count *)*((void *)v3 - 1);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      size_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void BBUICEUpdateSource::~BBUICEUpdateSource(BBUICEUpdateSource *this)
{
  *(void *)this = &unk_26CECB8D8;
  uint64_t v2 = *((void *)this + 14);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 16);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 17);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 18);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 19);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  if (*((char *)this + 103) < 0)
  {
    operator delete(*((void **)this + 10));
    char v7 = (std::__shared_weak_count *)*((void *)this + 9);
    if (!v7) {
      goto LABEL_13;
    }
  }
  else
  {
    char v7 = (std::__shared_weak_count *)*((void *)this + 9);
    if (!v7) {
      goto LABEL_13;
    }
  }
  if (atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
LABEL_13:
    uint64_t v8 = this;
    goto LABEL_15;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  uint64_t v8 = this;

LABEL_15:
  BBUUpdateSource::~BBUUpdateSource(v8);
}

void BBUICE16UpdateSource::BBUICE16UpdateSource(BBUICE16UpdateSource *this, long long *a2, uint64_t a3, uint64_t a4)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_26CECB8D8;
  *((void *)this + 1) = a4;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  uint64_t v5 = (std::string *)((char *)this + 80);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    v5->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 14) = 0;
  *((unsigned char *)this + 120) = 0;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *(void *)this = &unk_26CECAD98;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((void *)this + 25) = 0;
  *((unsigned char *)this + 208) = 1;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((void *)this + 41) = 0;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  BBUICE16UpdateSource::init(this);
}

void sub_21DEF525C(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v3);
  BBUUpdateSource::~BBUUpdateSource(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF527C(_Unwind_Exception *a1)
{
  std::vector<std::string>::~vector[abi:ne180100](v1 + 39);
  std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](v1 + 36);
  std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](v1 + 33);
  std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](v1 + 30);
  std::vector<std::shared_ptr<BBUICEMRCImage>>::~vector[abi:ne180100](v2);
  BBUICEUpdateSource::~BBUICEUpdateSource((BBUICEUpdateSource *)v1);
  _Unwind_Resume(a1);
}

void BBUICE16UpdateSource::~BBUICE16UpdateSource(BBUICE16UpdateSource *this)
{
  *(void *)this = &unk_26CECAD98;
  uint64_t v2 = *((void *)this + 25);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 21);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 22);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 23);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 24);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *((void *)this + 39);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 40);
    uint64_t v9 = (void *)*((void *)this + 39);
    if (v8 != v7)
    {
      do
      {
        if (*(char *)(v8 - 1) < 0) {
          operator delete(*(void **)(v8 - 24));
        }
        v8 -= 24;
      }
      while (v8 != v7);
      uint64_t v9 = (void *)*((void *)this + 39);
    }
    *((void *)this + 40) = v7;
    operator delete(v9);
  }
  uint64_t v10 = *((void *)this + 36);
  if (v10)
  {
    uint64_t v11 = *((void *)this + 37);
    unint64_t v12 = (void *)*((void *)this + 36);
    if (v11 != v10)
    {
      do
      {
        long long v13 = *(std::__shared_weak_count **)(v11 - 8);
        if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
        v11 -= 16;
      }
      while (v11 != v10);
      unint64_t v12 = (void *)*((void *)this + 36);
    }
    *((void *)this + 37) = v10;
    operator delete(v12);
  }
  uint64_t v14 = *((void *)this + 33);
  if (v14)
  {
    uint64_t v15 = *((void *)this + 34);
    long long v16 = (void *)*((void *)this + 33);
    if (v15 != v14)
    {
      do
      {
        size_t v17 = *(std::__shared_weak_count **)(v15 - 8);
        if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
        v15 -= 16;
      }
      while (v15 != v14);
      long long v16 = (void *)*((void *)this + 33);
    }
    *((void *)this + 34) = v14;
    operator delete(v16);
  }
  uint64_t v18 = *((void *)this + 30);
  if (v18)
  {
    uint64_t v19 = *((void *)this + 31);
    uint64_t v20 = (void *)*((void *)this + 30);
    if (v19 != v18)
    {
      do
      {
        unint64_t v21 = *(std::__shared_weak_count **)(v19 - 8);
        if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
        v19 -= 16;
      }
      while (v19 != v18);
      uint64_t v20 = (void *)*((void *)this + 30);
    }
    *((void *)this + 31) = v18;
    operator delete(v20);
  }
  uint64_t v22 = *((void *)this + 27);
  if (v22)
  {
    uint64_t v23 = *((void *)this + 28);
    long long v24 = (void *)*((void *)this + 27);
    if (v23 != v22)
    {
      do
      {
        long long v25 = *(std::__shared_weak_count **)(v23 - 8);
        if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
        v23 -= 16;
      }
      while (v23 != v22);
      long long v24 = (void *)*((void *)this + 27);
    }
    *((void *)this + 28) = v22;
    operator delete(v24);
  }

  BBUICEUpdateSource::~BBUICEUpdateSource(this);
}

{
  void *v1;
  uint64_t vars8;

  BBUICE16UpdateSource::~BBUICE16UpdateSource(this);

  operator delete(v1);
}

void BBUICE16UpdateSource::init(BBUICE16UpdateSource *this)
{
  pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  uint64_t v2 = (BBUPartitionManager *)off_26AA89B50;
  if (!off_26AA89B50)
  {
    uint64_t v3 = (BBUPartitionManager *)operator new(0x18uLL);
    BBUPartitionManager::BBUPartitionManager(v3);
    uint64_t v4 = operator new(0x20uLL);
    void *v4 = &unk_26CECF498;
    v4[1] = 0;
    unint64_t v4[2] = 0;
    v4[3] = v3;
    uint64_t v5 = (std::__shared_weak_count *)off_26AA89B58;
    off_26AA89B50 = v3;
    off_26AA89B58 = v4;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    uint64_t v2 = (BBUPartitionManager *)off_26AA89B50;
  }
  uint64_t v6 = (std::__shared_weak_count *)off_26AA89B58;
  if (off_26AA89B58) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  BBUPartitionManager::getBBUFSPath(v2, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = (bbufs *)&__p;
  }
  else {
    p_p = (bbufs *)__p.__r_.__value_.__r.__words[0];
  }
  if (p_p)
  {
    if ((bbufs::prepareDestination(p_p, v7) & 1) == 0) {
      _BBUFSDebugPrint("BBUFSServerPrepare", "failed preparing baseband filesystem directory\n", v15, v16, v17, v18, v19, v20, v47);
    }
  }
  else
  {
    _BBUFSDebugPrint("BBUFSServerPrepare", "invalid path specified %s\n", v8, v9, v10, v11, v12, v13, 0);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v21 = *((void *)this + 39);
  for (uint64_t i = *((void *)this + 40); i != v21; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  *((void *)this + 40) = v21;
  memset(&ff_buffer, 255, 0x4000uLL);
  if (((*(uint64_t (**)(BBUICE16UpdateSource *))(*(void *)this + 296))(this) & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 82, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x9Eu, (ctu::LogMessageBuffer *)"Assertion failure(loadPSIImages() && \"Error: Failed to load the PSI images!\")", v32, v33, v34, v47);
    goto LABEL_50;
  }
  if (((*(uint64_t (**)(BBUICE16UpdateSource *))(*(void *)this + 288))(this) & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 82, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xA1u, (ctu::LogMessageBuffer *)"Assertion failure(loadEBLImage() && \"Error: Failed to load the EBL image!\")", v35, v36, v37, v47);
    goto LABEL_50;
  }
  if (((*(uint64_t (**)(BBUICE16UpdateSource *))(*(void *)this + 320))(this) & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 83, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xA4u, (ctu::LogMessageBuffer *)"Assertion failure(loadNVMFiles() && \"Error: Failed to load the NVM image!\")", v38, v39, v40, v47);
    goto LABEL_50;
  }
  if (((*(uint64_t (**)(BBUICE16UpdateSource *))(*(void *)this + 312))(this) & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 80, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xA7u, (ctu::LogMessageBuffer *)"Assertion failure(loadBINFiles() && \"Error: Failed to load the BIN image!\")", v41, v42, v43, v47);
    goto LABEL_50;
  }
  if (((*(uint64_t (**)(BBUICE16UpdateSource *))(*(void *)this + 304))(this) & 1) == 0)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 78, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xAAu, (ctu::LogMessageBuffer *)"Assertion failure(loadELFFiles() && \"Error: Failed to load the ELF image!\")", v44, v45, v46, v47);
LABEL_50:
  }
  if (!MEMORY[0x223C1CBE0]()) {
    return;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_35;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_35;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v23 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(3, 0, v23, "", "trying to find MRC file\n", v24, v25, v26, v47);
  }
LABEL_35:
  if ((*(uint64_t (**)(BBUICE16UpdateSource *))(*(void *)this + 264))(this)) {
    return;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    long long v27 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(3, 0, v27, "", "Error: Failed to load or create new MRC data!\n", v28, v29, v30, v47);
  }
}

void sub_21DEF5BD0(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy((uint64_t)v1, v1[1]);
  operator delete(v1);
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  _Unwind_Resume(a1);
}

void sub_21DEF5C0C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF5C20(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF5C34(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF5C48(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF5C5C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF5C74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DEF5C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a10);
  _Unwind_Resume(a1);
}

void BBUICE16UpdateSource::setSaveImageFilter(void *a1, void ***a2)
{
  uint64_t v4 = a1 + 39;
  unint64_t v5 = a1[39];
  uint64_t v6 = (long long *)a1[40];
  if (v6 == (long long *)v5)
  {
    a1[40] = v5;
    uint64_t v7 = *a2;
    uint64_t v8 = a2[1];
    uint64_t v9 = (char *)v8 - (char *)*a2;
    if (v9 < 1) {
      return;
    }
  }
  else
  {
    do
    {
      if (*((char *)v6 - 1) < 0) {
        operator delete(*((void **)v6 - 3));
      }
      uint64_t v6 = (long long *)((char *)v6 - 24);
    }
    while (v6 != (long long *)v5);
    uint64_t v6 = (long long *)*v4;
    a1[40] = v5;
    uint64_t v7 = *a2;
    uint64_t v8 = a2[1];
    uint64_t v9 = (char *)v8 - (char *)*a2;
    if (v9 < 1) {
      return;
    }
  }
  uint64_t v10 = v9 / 24;
  uint64_t v11 = (uint64_t)(v5 - (void)v6) / 24;
  uint64_t v12 = (long long *)((char *)v6 + 24 * v11);
  uint64_t v13 = a1[41];
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v5) >> 3)) < v9 / 24)
  {
    unint64_t v14 = v11 + v10;
    if ((unint64_t)(v11 + v10) > 0xAAAAAAAAAAAAAAALL) {
      std::vector<std::string>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v13 - (uint64_t)v6) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x555555555555555) {
      unint64_t v16 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      if (v16 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v17 = (char *)operator new(24 * v16);
    }
    else
    {
      uint64_t v17 = 0;
    }
    unint64_t v25 = 0;
    uint64_t v26 = &v17[24 * v11];
    long long v27 = &v17[24 * v16];
    uint64_t v28 = 24 * v10;
    uint64_t v29 = &v26[24 * v10];
    do
    {
      uint64_t v31 = (std::string *)&v26[v25];
      uint64_t v32 = &v7[v25 / 8];
      if (SHIBYTE(v7[v25 / 8 + 2]) < 0)
      {
        std::string::__init_copy_ctor_external(v31, (const std::string::value_type *)*v32, (std::string::size_type)v32[1]);
      }
      else
      {
        long long v30 = *(_OWORD *)v32;
        v31->__r_.__value_.__r.__words[2] = (std::string::size_type)v32[2];
        *(_OWORD *)&v31->__r_.__value_.__l.__data_ = v30;
      }
      v25 += 24;
    }
    while (v28 != v25);
    uint64_t v33 = (long long *)*v4;
    if ((long long *)*v4 == v12)
    {
      uint64_t v35 = v26;
      uint64_t v37 = (long long *)a1[40];
      if (v37 == v12) {
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v34 = v12;
      do
      {
        uint64_t v35 = v26 - 24;
        long long v36 = *(long long *)((char *)v34 - 24);
        *((void *)v26 - 1) = *((void *)v34 - 1);
        *(_OWORD *)(v26 - 24) = v36;
        *((void *)v34 - 2) = 0;
        *((void *)v34 - 1) = 0;
        *((void *)v34 - 3) = 0;
        v26 -= 24;
        uint64_t v34 = (long long *)((char *)v34 - 24);
      }
      while (v34 != v33);
      uint64_t v37 = (long long *)a1[40];
      if (v37 == v12) {
        goto LABEL_40;
      }
    }
    do
    {
      long long v38 = *v12;
      *((void *)v29 + 2) = *((void *)v12 + 2);
      *(_OWORD *)uint64_t v29 = v38;
      v29 += 24;
      *((void *)v12 + 1) = 0;
      *((void *)v12 + 2) = 0;
      *(void *)uint64_t v12 = 0;
      uint64_t v12 = (long long *)((char *)v12 + 24);
    }
    while (v12 != v37);
    uint64_t v12 = (long long *)a1[40];
LABEL_40:
    uint64_t v39 = (long long *)a1[39];
    a1[39] = v35;
    a1[40] = v29;
    a1[41] = v27;
    while (v12 != v39)
    {
      if (*((char *)v12 - 1) < 0) {
        operator delete(*((void **)v12 - 3));
      }
      uint64_t v12 = (long long *)((char *)v12 - 24);
    }
    if (v39)
    {
      operator delete(v39);
    }
    return;
  }
  uint64_t v18 = v5 - (void)v12;
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - (void)v12) >> 3)) >= v10)
  {
    uint64_t v19 = &v7[3 * v10];
    unint64_t v24 = v5;
  }
  else
  {
    uint64_t v19 = &v7[(uint64_t)(v5 - (void)v12) >> 3];
    if (v19 == v8)
    {
      unint64_t v24 = v5;
      a1[40] = v5;
      if (v18 < 1) {
        return;
      }
    }
    else
    {
      uint64_t v20 = 0;
      do
      {
        uint64_t v22 = (std::string *)(v5 + v20 * 8);
        uint64_t v23 = &v19[v20];
        if (SHIBYTE(v19[v20 + 2]) < 0)
        {
          std::string::__init_copy_ctor_external(v22, (const std::string::value_type *)*v23, (std::string::size_type)v23[1]);
        }
        else
        {
          long long v21 = *(_OWORD *)v23;
          v22->__r_.__value_.__r.__words[2] = (std::string::size_type)v23[2];
          *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v21;
        }
        v20 += 3;
      }
      while (&v19[v20] != v8);
      unint64_t v24 = v5 + v20 * 8;
      a1[40] = v5 + v20 * 8;
      if (v18 < 1) {
        return;
      }
    }
  }
  uint64_t v40 = (uint64_t)v12 + 24 * v10;
  uint64_t v41 = (long long *)(v24 - 24 * v10);
  unint64_t v42 = v24;
  if ((unint64_t)v41 < v5)
  {
    unint64_t v42 = v24;
    do
    {
      long long v43 = *v41;
      *(void *)(v42 + 16) = *((void *)v41 + 2);
      *(_OWORD *)unint64_t v42 = v43;
      v42 += 24;
      *((void *)v41 + 1) = 0;
      *((void *)v41 + 2) = 0;
      *(void *)uint64_t v41 = 0;
      uint64_t v41 = (long long *)((char *)v41 + 24);
    }
    while ((unint64_t)v41 < v5);
  }
  a1[40] = v42;
  if (v24 != v40)
  {
    unint64_t v44 = v24 - 24;
    uint64_t v45 = 8 * ((uint64_t)(v24 - v40) >> 3);
    do
    {
      if (*(char *)(v44 + 23) < 0) {
        operator delete(*(void **)v44);
      }
      uint64_t v46 = (long long *)((char *)v12 + v45 - 24);
      long long v47 = *v46;
      *(void *)(v44 + 16) = *(void *)((char *)v12 + v45 - 8);
      *(_OWORD *)unint64_t v44 = v47;
      v44 -= 24;
      *((unsigned char *)v12 + v45 - 1) = 0;
      *(unsigned char *)uint64_t v46 = 0;
      v45 -= 24;
    }
    while (v45);
  }
  for (; v7 != v19; uint64_t v12 = (long long *)((char *)v12 + 24))
  {
    if (v7 != (void **)v12)
    {
      char v50 = *((unsigned char *)v7 + 23);
      if (*((char *)v12 + 23) < 0)
      {
        if (v50 >= 0) {
          int v48 = v7;
        }
        else {
          int v48 = *v7;
        }
        if (v50 >= 0) {
          size_t v49 = *((unsigned __int8 *)v7 + 23);
        }
        else {
          size_t v49 = (size_t)v7[1];
        }
        std::string::__assign_no_alias<false>((void **)v12, v48, v49);
      }
      else if ((*((unsigned char *)v7 + 23) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(v12, *v7, (size_t)v7[1]);
      }
      else
      {
        long long v51 = *(_OWORD *)v7;
        *((void *)v12 + 2) = v7[2];
        *uint64_t v12 = v51;
      }
    }
    v7 += 3;
  }
}

void sub_21DEF6144(_Unwind_Exception *exception_object)
{
  for (; v3; v3 -= 24)
  {
    if (*(char *)(v2 + v3 - 1) < 0) {
      operator delete(*(void **)(v2 + v3 - 24));
    }
  }
  if (!v1) {
    _Unwind_Resume(exception_object);
  }
  operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t BBUICE16UpdateSource::setChipID(uint64_t this, int a2)
{
  *(_DWORD *)(this + 160) = a2;
  return this;
}

uint64_t BBUICE16UpdateSource::setCertID(uint64_t this, int a2)
{
  *(_DWORD *)(this + 164) = a2;
  return this;
}

BOOL BBUICE16UpdateSource::isDeviceECDSAFused(BBUICE16UpdateSource *this)
{
  int v1 = *((_DWORD *)this + 41);
  return v1 == -2087094182 || v1 == 653523660 || v1 == 1559424078;
}

uint64_t BBUICE16UpdateSource::getProgrammerSource(BBUICE16UpdateSource *this, int a2)
{
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v4 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(3, 0, v4, "", "chipID:0x%X certID:0x%X\n", v5, v6, v7, *((_DWORD *)this + 40));
  }
LABEL_5:
  if (*((_DWORD *)this + 40) == 104)
  {
    int v8 = (*(uint64_t (**)(BBUICE16UpdateSource *))(*(void *)this + 336))(this);
    if (a2)
    {
      if (v8) {
        return *((void *)this + 21);
      }
      else {
        return *((void *)this + 23);
      }
    }
    else if (v8)
    {
      return *((void *)this + 22);
    }
    else
    {
      return *((void *)this + 24);
    }
  }
  else
  {
    uint64_t v10 = (char *)this + 176;
    if (a2) {
      uint64_t v10 = (char *)this + 168;
    }
    return *(void *)v10;
  }
}

uint64_t BBUICE16UpdateSource::loadPSIImages(BBUICE16UpdateSource *this)
{
  if (*((void *)this + 21))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xF1u, (ctu::LogMessageBuffer *)"Assertion failure(fPSIRamSource == __null)", v32, v33, v34, v68);
    goto LABEL_73;
  }
  if (*((void *)this + 22))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xF2u, (ctu::LogMessageBuffer *)"Assertion failure(fRestorePSIRamSource == __null)", v35, v36, v37, v68);
    goto LABEL_73;
  }
  if (*((void *)this + 23))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xF3u, (ctu::LogMessageBuffer *)"Assertion failure(fPSIRam2Source == __null)", v38, v39, v40, v68);
    goto LABEL_73;
  }
  if (*((void *)this + 24))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xF4u, (ctu::LogMessageBuffer *)"Assertion failure(fRestorePSIRam2Source == __null)", v41, v42, v43, v68);
    goto LABEL_73;
  }
  char v70 = 11;
  strcpy((char *)__p, "psi_ram.bin");
  int v2 = BBUICEUpdateSource::containsFile((uint64_t)this, (uint64_t)__p);
  int v3 = v2;
  if (v70 < 0)
  {
    operator delete(__p[0]);
    if (!v3) {
      goto LABEL_17;
    }
  }
  else if (!v2)
  {
    goto LABEL_17;
  }
  if (*((void *)this + 21))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xF8u, (ctu::LogMessageBuffer *)"Assertion failure(fPSIRamSource == __null)", v44, v45, v46, v68);
    goto LABEL_73;
  }
  char v70 = 11;
  strcpy((char *)__p, "psi_ram.bin");
  DataSource = BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)__p, 0);
  *((void *)this + 21) = DataSource;
  if (v70 < 0)
  {
    operator delete(__p[0]);
    DataSource = (void *)*((void *)this + 21);
  }
  if (!DataSource)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 82, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0xFAu, (ctu::LogMessageBuffer *)"Assertion failure(fPSIRamSource && \"Failed to load PSI.\")", v47, v48, v49, v68);
    goto LABEL_73;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_17;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_17;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v5 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(3, 0, v5, "", "Loaded PSI\n", v6, v7, v8, v68);
  }
LABEL_17:
  char v70 = 12;
  strcpy((char *)__p, "psi_ram2.bin");
  int v9 = BBUICEUpdateSource::containsFile((uint64_t)this, (uint64_t)__p);
  int v10 = v9;
  if (v70 < 0)
  {
    operator delete(__p[0]);
    if (!v10) {
      goto LABEL_29;
    }
  }
  else if (!v9)
  {
    goto LABEL_29;
  }
  if (*((void *)this + 23))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x100u, (ctu::LogMessageBuffer *)"Assertion failure(fPSIRam2Source == __null)", v50, v51, v52, v68);
    goto LABEL_73;
  }
  char v70 = 12;
  strcpy((char *)__p, "psi_ram2.bin");
  uint64_t v11 = BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)__p, 0);
  *((void *)this + 23) = v11;
  if (v70 < 0)
  {
    operator delete(__p[0]);
    uint64_t v11 = (void *)*((void *)this + 23);
  }
  if (!v11)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 82, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x102u, (ctu::LogMessageBuffer *)"Assertion failure(fPSIRam2Source && \"Failed to load PSI2.\")", v53, v54, v55, v68);
    goto LABEL_73;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_29;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_29;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v12 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(3, 0, v12, "", "Loaded PSI2\n", v13, v14, v15, v68);
  }
LABEL_29:
  char v70 = 14;
  strcpy((char *)__p, "restorepsi.bin");
  int v16 = BBUICEUpdateSource::containsFile((uint64_t)this, (uint64_t)__p);
  int v17 = v16;
  if (v70 < 0)
  {
    operator delete(__p[0]);
    if (!v17) {
      goto LABEL_41;
    }
  }
  else if (!v16)
  {
    goto LABEL_41;
  }
  if (*((void *)this + 22))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x108u, (ctu::LogMessageBuffer *)"Assertion failure(fRestorePSIRamSource == __null)", v56, v57, v58, v68);
    goto LABEL_73;
  }
  char v70 = 14;
  strcpy((char *)__p, "restorepsi.bin");
  uint64_t v18 = BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)__p, 0);
  *((void *)this + 22) = v18;
  if (v70 < 0)
  {
    operator delete(__p[0]);
    uint64_t v18 = (void *)*((void *)this + 22);
  }
  if (!v18)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 82, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x10Au, (ctu::LogMessageBuffer *)"Assertion failure(fRestorePSIRamSource && \"Failed to load RestorePSI.\")", v59, v60, v61, v68);
    goto LABEL_73;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_41;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_41;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v19 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(3, 0, v19, "", "Loaded RestorePSI\n", v20, v21, v22, v68);
  }
LABEL_41:
  char v70 = 15;
  strcpy((char *)__p, "restorepsi2.bin");
  int v23 = BBUICEUpdateSource::containsFile((uint64_t)this, (uint64_t)__p);
  int v24 = v23;
  if (v70 < 0)
  {
    operator delete(__p[0]);
    if (!v24) {
      return 1;
    }
  }
  else if (!v23)
  {
    return 1;
  }
  if (*((void *)this + 24))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x110u, (ctu::LogMessageBuffer *)"Assertion failure(fRestorePSIRam2Source == __null)", v62, v63, v64, v68);
    goto LABEL_73;
  }
  char v70 = 15;
  strcpy((char *)__p, "restorepsi2.bin");
  unint64_t v25 = BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)__p, 0);
  *((void *)this + 24) = v25;
  if (v70 < 0)
  {
    operator delete(__p[0]);
    unint64_t v25 = (void *)*((void *)this + 24);
  }
  if (!v25)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 82, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x112u, (ctu::LogMessageBuffer *)"Assertion failure(fRestorePSIRam2Source && \"Failed to load RestorePSI2.\")", v65, v66, v67, v68);
LABEL_73:
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return 1;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return 1;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v26 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(3, 0, v26, "", "Loaded RestorePSI2\n", v27, v28, v29, v68);
    return 1;
  }
  return 1;
}

void sub_21DEF6AE8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF6B28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL BBUICE16UpdateSource::loadEBLImage(BBUICE16UpdateSource *this)
{
  if (*((void *)this + 25))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x11Bu, (ctu::LogMessageBuffer *)"Assertion failure(fEBLImage == __null)", v16, v17, v18, v19);
  }
  char v21 = 7;
  strcpy((char *)__p, "ebl.bin");
  char v2 = BBUICEUpdateSource::containsFile((uint64_t)this, (uint64_t)__p);
  char v3 = v2;
  if (v21 < 0)
  {
    operator delete(__p[0]);
    if (v3)
    {
LABEL_4:
      char v21 = 7;
      strcpy((char *)__p, "ebl.bin");
      DataSource = BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)__p, 0);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
      uint64_t v5 = operator new(0x18uLL);
      *(void *)uint64_t v5 = &unk_26CECF280;
      uint64_t v5[2] = 0;
      *((void *)v5 + 2) = DataSource;
      *((void *)this + 25) = v5;
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0) {
          goto LABEL_8;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0)
        {
LABEL_8:
          if ((gBBULogVerbosity & 0x80000000) == 0)
          {
            uint64_t v6 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
            _BBULog(3, 0, v6, "", "Loaded EBL file\n", v7, v8, v9, v19);
          }
        }
      }
      return *((void *)this + 25) != 0;
    }
  }
  else if (v2)
  {
    goto LABEL_4;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    BOOL result = 1;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return result;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    BOOL result = 1;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return result;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v11 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(3, 0, v11, "", "EBL file '%s' not found.\n", v12, v13, v14, (char)"ebl.bin");
    return 1;
  }
  return result;
}

void sub_21DEF6E18(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEF6E2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBUICE16UpdateSource::loadNVMFiles(BBUFeedback **this)
{
  memset(&__p, 170, sizeof(__p));
  getNVMFilePath((uint64_t)&__p, 0);
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v46.st_blkstd::string::size_type size = v2;
  *(timespec *)v46.st_qspare = v2;
  v46.st_birthtimespec = v2;
  *(timespec *)&v46.st_std::string::size_type size = v2;
  v46.st_mtimespec = v2;
  v46.st_ctimespec = v2;
  *(timespec *)&v46.st_uid = v2;
  v46.st_atimespec = v2;
  *(timespec *)&v46.st_dev = v2;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (stat((const char *)p_p, &v46))
  {
    uint64_t v4 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v4 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(this[1], "%s not found, generating default (ffs) file.", (const char *)v4);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v44, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v44 = __p;
    }
    unsigned int v5 = capabilities::updater::ICENVMFSizeBytes();
    if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v6 = &v44;
    }
    else {
      uint64_t v6 = (std::string *)v44.__r_.__value_.__r.__words[0];
    }
    int v7 = open((const char *)v6, 1537, 384);
    if ((v7 & 0x80000000) == 0)
    {
      if (v5 >= 0x4000)
      {
        unsigned int v8 = v5 >> 14;
        do
        {
          write(v7, &ff_buffer, 0x4000uLL);
          --v8;
        }
        while (v8);
      }
      close(v7);
    }
    if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v44.__r_.__value_.__l.__data_);
      if (v7 < 0) {
        goto LABEL_73;
      }
    }
    else if (v7 < 0)
    {
      goto LABEL_73;
    }
  }
  uint64_t v9 = (BBUDataSource *)operator new(0x30uLL);
  *(void *)uint64_t v9 = &unk_26CECA448;
  *(_OWORD *)((char *)v9 + 8) = 0u;
  *(_OWORD *)((char *)v9 + 24) = 0u;
  if (BBUFileDataSource::init((uint64_t)v9, (const char *)&__p, 0))
  {
    (*(void (**)(BBUDataSource *))(*(void *)v9 + 8))(v9);
    uint64_t v9 = 0;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_30;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_30;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    int v10 = (const char *)(*(uint64_t (**)(BBUFeedback **))*this)(this);
    uint64_t v14 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      LOBYTE(v14) = __p.__r_.__value_.__s.__data_[0];
    }
    _BBULog(3, 0, v10, "", "Loaded NVM file %s\n", v11, v12, v13, (char)v14);
  }
LABEL_30:
  uint64_t v15 = (BBUICENVMImage *)operator new(0x38uLL);
  BBUICENVMImage::BBUICENVMImage(v15, v9, "static.nvm", 0);
  *(void *)&v46.st_dev = v15;
  uint64_t v16 = (std::__shared_weak_count *)operator new(0x20uLL);
  uint64_t v17 = v16;
  v16->__shared_owners_ = 0;
  p_shared_owners = &v16->__shared_owners_;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CECAF68;
  v16->__shared_weak_owners_ = 0;
  v16[1].__vftable = (std::__shared_weak_count_vtbl *)v15;
  v46.st_ino = (__darwin_ino64_t)v16;
  char v19 = this[34];
  if (v19 >= this[35])
  {
    uint64_t v20 = (BBUFeedback *)std::vector<std::shared_ptr<BBUICENVMImage>>::__push_back_slow_path<std::shared_ptr<BBUICENVMImage> const&>((uint64_t)(this + 33), (uint64_t)v15, (uint64_t)v16);
  }
  else
  {
    *(void *)char v19 = v15;
    *((void *)v19 + 1) = v16;
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v20 = (BBUFeedback *)((char *)v19 + 16);
  }
  this[34] = v20;
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_35;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_35;
    }
  }
  operator delete(__p.__r_.__value_.__l.__data_);
LABEL_35:
  memset(&__p, 170, sizeof(__p));
  getNVMFilePath((uint64_t)&__p, 1);
  v21.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v21.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v46.st_blkstd::string::size_type size = v21;
  *(timespec *)v46.st_qspare = v21;
  v46.st_birthtimespec = v21;
  *(timespec *)&v46.st_std::string::size_type size = v21;
  v46.st_mtimespec = v21;
  v46.st_ctimespec = v21;
  *(timespec *)&v46.st_uid = v21;
  v46.st_atimespec = v21;
  *(timespec *)&v46.st_dev = v21;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v22 = &__p;
  }
  else {
    uint64_t v22 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (!stat((const char *)v22, &v46)) {
    goto LABEL_56;
  }
  int v23 = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    int v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  BBUFeedback::handleComment(this[1], "%s not found, generating default (ffs) file.", (const char *)v23);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v44, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v44 = __p;
  }
  unsigned int v24 = capabilities::updater::ICENVMFSizeBytes();
  if ((v44.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v25 = &v44;
  }
  else {
    unint64_t v25 = (std::string *)v44.__r_.__value_.__r.__words[0];
  }
  int v26 = open((const char *)v25, 1537, 384);
  if ((v26 & 0x80000000) == 0)
  {
    if (v24 >= 0x4000)
    {
      unsigned int v27 = v24 >> 14;
      do
      {
        write(v26, &ff_buffer, 0x4000uLL);
        --v27;
      }
      while (v27);
    }
    close(v26);
  }
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v44.__r_.__value_.__l.__data_);
    if (v26 < 0) {
      goto LABEL_73;
    }
LABEL_56:
    uint64_t v28 = (BBUDataSource *)operator new(0x30uLL);
    *(void *)uint64_t v28 = &unk_26CECA448;
    *(_OWORD *)((char *)v28 + 8) = 0u;
    *(_OWORD *)((char *)v28 + 24) = 0u;
    if (BBUFileDataSource::init((uint64_t)v28, (const char *)&__p, 0))
    {
      (*(void (**)(BBUDataSource *))(*(void *)v28 + 8))(v28);
      uint64_t v28 = 0;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        goto LABEL_64;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        goto LABEL_64;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      uint64_t v29 = (const char *)(*(uint64_t (**)(BBUFeedback **))*this)(this);
      uint64_t v33 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        LOBYTE(v33) = __p.__r_.__value_.__s.__data_[0];
      }
      _BBULog(3, 0, v29, "", "Loaded NVM file %s\n", v30, v31, v32, (char)v33);
    }
LABEL_64:
    uint64_t v34 = (BBUICENVMImage *)operator new(0x38uLL);
    BBUICENVMImage::BBUICENVMImage(v34, v28, "dynamic.nvm", 0);
    *(void *)&v46.st_dev = v34;
    uint64_t v35 = (std::__shared_weak_count *)operator new(0x20uLL);
    uint64_t v36 = v35;
    v35->__shared_owners_ = 0;
    uint64_t v37 = &v35->__shared_owners_;
    v35->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CECAF68;
    v35->__shared_weak_owners_ = 0;
    v35[1].__vftable = (std::__shared_weak_count_vtbl *)v34;
    v46.st_ino = (__darwin_ino64_t)v35;
    uint64_t v38 = this[34];
    if (v38 >= this[35])
    {
      uint64_t v39 = (BBUFeedback *)std::vector<std::shared_ptr<BBUICENVMImage>>::__push_back_slow_path<std::shared_ptr<BBUICENVMImage> const&>((uint64_t)(this + 33), (uint64_t)v34, (uint64_t)v35);
    }
    else
    {
      *(void *)uint64_t v38 = v34;
      *((void *)v38 + 1) = v35;
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v39 = (BBUFeedback *)((char *)v38 + 16);
    }
    this[34] = v39;
    if (atomic_fetch_add(v37, 0xFFFFFFFFFFFFFFFFLL))
    {
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return 1;
      }
    }
    else
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return 1;
      }
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    return 1;
  }
  if ((v26 & 0x80000000) == 0) {
    goto LABEL_56;
  }
LABEL_73:
  uint64_t v41 = this[1];
  uint64_t v42 = __error();
  uint64_t v43 = strerror(*v42);
  BBUFeedback::handleComment(v41, "Failed to create file %s\n", v43);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_21DEF7540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  if ((a22 & 0x80000000) == 0) {
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t getNVMFilePath(uint64_t a1, int a2)
{
  unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v33[7] = v4;
  v33[8] = v4;
  v33[5] = v4;
  v33[6] = v4;
  v33[3] = v4;
  v33[4] = v4;
  v33[1] = v4;
  v33[2] = v4;
  long long v32 = v4;
  v33[0] = v4;
  *(_OWORD *)uint64_t v30 = v4;
  long long v31 = v4;
  long long v28 = v4;
  long long v29 = v4;
  long long v26 = v4;
  long long v27 = v4;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v26);
  if (a2) {
    unsigned int v5 = "dynamic.nvm";
  }
  else {
    unsigned int v5 = "static.nvm";
  }
  if (!strcasecmp(v5, ""))
  {
    *(unsigned char *)(a1 + 23) = 0;
    *(unsigned char *)a1 = 0;
    goto LABEL_43;
  }
  pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  uint64_t v6 = (BBUPartitionManager *)off_26AA89B50;
  if (!off_26AA89B50)
  {
    int v7 = (BBUPartitionManager *)operator new(0x18uLL);
    BBUPartitionManager::BBUPartitionManager(v7);
    unsigned int v8 = operator new(0x20uLL);
    *unsigned int v8 = &unk_26CECF498;
    v8[1] = 0;
    v8[2] = 0;
    v8[3] = v7;
    uint64_t v9 = (std::__shared_weak_count *)off_26AA89B58;
    off_26AA89B50 = v7;
    off_26AA89B58 = v8;
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    uint64_t v6 = (BBUPartitionManager *)off_26AA89B50;
  }
  int v10 = (std::__shared_weak_count *)off_26AA89B58;
  if (off_26AA89B58) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  BBUPartitionManager::getBBUFSPath(v6, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v26, (uint64_t)p_p, size);
  if (a2) {
    uint64_t v14 = 11;
  }
  else {
    uint64_t v14 = 10;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)v5, v14);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    char v15 = BYTE8(v32);
    if ((BYTE8(v32) & 0x10) == 0) {
      goto LABEL_26;
    }
LABEL_31:
    uint64_t v19 = v32;
    if ((unint64_t)v32 < *((void *)&v29 + 1))
    {
      *(void *)&long long v32 = *((void *)&v29 + 1);
      uint64_t v19 = *((void *)&v29 + 1);
    }
    uint64_t v18 = (const void **)&v29;
    goto LABEL_34;
  }
  char v15 = BYTE8(v32);
  if ((BYTE8(v32) & 0x10) != 0) {
    goto LABEL_31;
  }
LABEL_26:
  if ((v15 & 8) == 0)
  {
    std::string::size_type v16 = 0;
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    uint64_t v17 = &__p;
    goto LABEL_42;
  }
  uint64_t v18 = (const void **)&v27 + 1;
  uint64_t v19 = *((void *)&v28 + 1);
LABEL_34:
  uint64_t v20 = *v18;
  std::string::size_type v16 = v19 - (void)*v18;
  if (v16 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v16 >= 0x17)
  {
    uint64_t v21 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v21 = v16 | 7;
    }
    uint64_t v22 = v21 + 1;
    uint64_t v17 = (std::string *)operator new(v21 + 1);
    __p.__r_.__value_.__l.__size_ = v16;
    __p.__r_.__value_.__r.__words[2] = v22 | 0x8000000000000000;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
  }
  else
  {
    *((unsigned char *)&__p.__r_.__value_.__s + 23) = v19 - *(unsigned char *)v18;
    uint64_t v17 = &__p;
    if (!v16) {
      goto LABEL_42;
    }
  }
  memmove(v17, v20, v16);
LABEL_42:
  v17->__r_.__value_.__s.__data_[v16] = 0;
  long long v23 = *(_OWORD *)&__p.__r_.__value_.__r.__words[1];
  *(void *)a1 = __p.__r_.__value_.__r.__words[0];
  *(_OWORD *)(a1 + 8) = v23;
LABEL_43:
  *(void *)&long long v26 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v26 + *(void *)(v26 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v26 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v31) < 0) {
    operator delete(v30[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x223C1DDF0](v33);
}

void sub_21DEF79F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy((uint64_t)v18, v18[1]);
  operator delete(v18);
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  std::ostringstream::~ostringstream((uint64_t)&a18);
  _Unwind_Resume(a1);
}

uint64_t BBUICE16UpdateSource::loadMRCData(BBUFeedback **this)
{
  memset(&__p, 170, sizeof(__p));
  BBUICE16UpdateSource::getMRCFilePath((uint64_t)&__p);
  v2.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v48.st_blkstd::string::size_type size = v2;
  *(timespec *)v48.st_qspare = v2;
  v48.st_birthtimespec = v2;
  *(timespec *)&v48.st_std::string::size_type size = v2;
  v48.st_mtimespec = v2;
  v48.st_ctimespec = v2;
  *(timespec *)&v48.st_uid = v2;
  v48.st_atimespec = v2;
  *(timespec *)&v48.st_dev = v2;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (stat((const char *)p_p, &v48))
  {
    long long v4 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      long long v4 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(this[1], "%s not found, generating default (ffs) file.", (const char *)v4);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v46, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    }
    else {
      std::string v46 = __p;
    }
    if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unsigned int v5 = &v46;
    }
    else {
      unsigned int v5 = (std::string *)v46.__r_.__value_.__r.__words[0];
    }
    int v6 = open((const char *)v5, 1537, 384);
    int v7 = v6;
    if ((v6 & 0x80000000) == 0) {
      close(v6);
    }
    if ((SHIBYTE(v46.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      if ((v7 & 0x80000000) == 0) {
        goto LABEL_17;
      }
LABEL_30:
      uint64_t v19 = this[1];
      uint64_t v20 = __error();
      uint64_t v21 = strerror(*v20);
      BBUFeedback::handleComment(v19, "Failed to create file %s\n", v21);
      uint64_t v22 = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_62;
      }
      return v22;
    }
    operator delete(v46.__r_.__value_.__l.__data_);
    if (v7 < 0) {
      goto LABEL_30;
    }
  }
LABEL_17:
  unsigned int v8 = (char *)operator new(0x30uLL);
  *(void *)unsigned int v8 = &unk_26CECA448;
  *(_OWORD *)(v8 + 8) = 0u;
  *(_OWORD *)(v8 + 24) = 0u;
  int v9 = BBUFileDataSource::init((uint64_t)v8, (const char *)&__p, 0);
  uint64_t v10 = *(void *)v8;
  if (v9)
  {
    (*(void (**)(char *))(v10 + 8))(v8);
    uint64_t v11 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(this[1], "Failed to read file %s", (const char *)v11);
    goto LABEL_61;
  }
  if ((*(unsigned int (**)(char *))(v10 + 24))(v8) >= 0x801)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0) {
        goto LABEL_24;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0)
      {
LABEL_24:
        if ((gBBULogVerbosity & 0x80000000) == 0)
        {
          uint64_t v12 = (const char *)(*(uint64_t (**)(BBUFeedback **))*this)(this);
          int v13 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
          std::string::value_type v14 = __p.__r_.__value_.__s.__data_[0];
          (*(void (**)(char *))(*(void *)v8 + 24))(v8);
          uint64_t v18 = &__p;
          if (v13 < 0) {
            LOBYTE(v18) = v14;
          }
          _BBULog(3, 0, v12, "", "MRC file %s is too large (%lu), ignoring\n", v15, v16, v17, (char)v18);
        }
      }
    }
    (*(void (**)(char *))(*(void *)v8 + 8))(v8);
    goto LABEL_61;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_38;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_38;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    long long v23 = (const char *)(*(uint64_t (**)(BBUFeedback **))*this)(this);
    long long v27 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      LOBYTE(v27) = __p.__r_.__value_.__s.__data_[0];
    }
    _BBULog(3, 0, v23, "", "Loaded MRC file %s\n", v24, v25, v26, (char)v27);
  }
LABEL_38:
  long long v28 = operator new(0x30uLL);
  *(void *)long long v28 = &unk_26CECD7D0;
  v28[31] = 7;
  strcpy(v28 + 8, "mrc.dat");
  *((_DWORD *)v28 + 8) = 0;
  *((void *)v28 + 5) = v8;
  *(void *)&v48.st_dev = v28;
  long long v29 = (std::__shared_weak_count *)operator new(0x20uLL);
  st_ino = v29;
  v29->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CECAFB8;
  v29->__shared_owners_ = 0;
  v29->__shared_weak_owners_ = 0;
  v29[1].__vftable = (std::__shared_weak_count_vtbl *)v28;
  v48.st_ino = (__darwin_ino64_t)v29;
  long long v32 = this[37];
  long long v31 = this[38];
  if (v32 < v31)
  {
    *(void *)long long v32 = v28;
    *((void *)v32 + 1) = v29;
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    this[37] = (BBUFeedback *)((char *)v32 + 16);
LABEL_59:
    if (!atomic_fetch_add(&st_ino->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))st_ino->__on_zero_shared)(st_ino);
      std::__shared_weak_count::__release_weak(st_ino);
    }
    goto LABEL_61;
  }
  uint64_t v33 = this[36];
  uint64_t v34 = (v32 - v33) >> 4;
  unint64_t v35 = v34 + 1;
  if ((unint64_t)(v34 + 1) >> 60) {
    std::vector<std::string>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v36 = v31 - v33;
  if (v36 >> 3 > v35) {
    unint64_t v35 = v36 >> 3;
  }
  if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v37 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v37 = v35;
  }
  if (v37 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v38 = (char *)operator new(16 * v37);
  uint64_t v39 = (BBUFeedback *)&v38[16 * v34];
  uint64_t v40 = (BBUFeedback *)&v38[16 * v37];
  *(void *)uint64_t v39 = v28;
  *((void *)v39 + 1) = st_ino;
  atomic_fetch_add_explicit(&st_ino->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v41 = (BBUFeedback *)((char *)v39 + 16);
  if (v32 == v33)
  {
    this[36] = v39;
    this[37] = v41;
    this[38] = v40;
  }
  else
  {
    do
    {
      long long v42 = *((_OWORD *)v32 - 1);
      long long v32 = (BBUFeedback *)((char *)v32 - 16);
      *((_OWORD *)v39 - 1) = v42;
      uint64_t v39 = (BBUFeedback *)((char *)v39 - 16);
      *(void *)long long v32 = 0;
      *((void *)v32 + 1) = 0;
    }
    while (v32 != v33);
    long long v32 = this[36];
    uint64_t v43 = this[37];
    this[36] = v39;
    this[37] = v41;
    for (this[38] = v40; v43 != v32; uint64_t v43 = (BBUFeedback *)((char *)v43 - 16))
    {
      std::string v44 = (std::__shared_weak_count *)*((void *)v43 - 1);
      if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
    }
  }
  if (v32) {
    operator delete(v32);
  }
  st_ino = (std::__shared_weak_count *)v48.st_ino;
  this[37] = v41;
  if (st_ino) {
    goto LABEL_59;
  }
LABEL_61:
  uint64_t v22 = 1;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_62:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
  return v22;
}

void sub_21DEF8094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  off_26CECD7D8(v23);
  if ((a22 & 0x80000000) == 0) {
    _Unwind_Resume(a1);
  }
  operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t BBUICE16UpdateSource::loadBINFiles(BBUFeedback **this)
{
  uint64_t v42 = (uint64_t)&v42;
  uint64_t v43 = &v42;
  uint64_t v44 = 0;
  char v41 = 4;
  strcpy((char *)__p, ".bin");
  (*((void (**)(BBUFeedback **, uint64_t *, void **))*this + 32))(this, &v42, __p);
  if (v41 < 0) {
    operator delete(__p[0]);
  }
  *((unsigned char *)&v39.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v39, "psi_ram.bin");
  std::list<std::string>::remove(&v42, (unsigned __int8 **)&v39);
  *((unsigned char *)&v39.__r_.__value_.__s + 23) = 14;
  strcpy((char *)&v39, "restorepsi.bin");
  std::list<std::string>::remove(&v42, (unsigned __int8 **)&v39);
  *((unsigned char *)&v39.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&v39, "psi_ram2.bin");
  std::list<std::string>::remove(&v42, (unsigned __int8 **)&v39);
  *((unsigned char *)&v39.__r_.__value_.__s + 23) = 15;
  strcpy((char *)&v39, "restorepsi2.bin");
  std::list<std::string>::remove(&v42, (unsigned __int8 **)&v39);
  *((unsigned char *)&v39.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v39, "ebl.bin");
  std::list<std::string>::remove(&v42, (unsigned __int8 **)&v39);
  timespec v2 = v43;
  if (v43 != &v42)
  {
    char v3 = &unk_26AA8F000;
    while (1)
    {
      memset(&v39, 170, sizeof(v39));
      if (*((char *)v2 + 39) < 0) {
        std::string::__init_copy_ctor_external(&v39, (const std::string::value_type *)v2[2], v2[3]);
      }
      else {
        std::string v39 = *(std::string *)(v2 + 2);
      }
      uint64_t v4 = BBUICEUpdateSource::containsFile((uint64_t)this, (uint64_t)&v39);
      if ((v4 & 1) == 0)
      {
        if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v19 = &v39;
        }
        else {
          uint64_t v19 = (std::string *)v39.__r_.__value_.__r.__words[0];
        }
        BBUFeedback::handleComment(this[1], "Unable to locate file from directory listing '%s'.", (const char *)v19);
LABEL_46:
        if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_48;
        }
LABEL_47:
        operator delete(v39.__r_.__value_.__l.__data_);
        goto LABEL_48;
      }
      DataSource = (BBUDataSource *)BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)&v39, 0);
      if (v3[406] == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
          goto LABEL_16;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
          goto LABEL_16;
        }
      }
      if ((gBBULogVerbosity & 0x80000000) == 0)
      {
        int v6 = (const char *)(*(uint64_t (**)(BBUFeedback **))*this)(this);
        if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v10 = &v39;
        }
        else {
          LOBYTE(v10) = v39.__r_.__value_.__s.__data_[0];
        }
        _BBULog(3, 0, v6, "", "Loaded binary file '%s'\n", v7, v8, v9, (char)v10);
      }
LABEL_16:
      uint64_t v11 = (BBUICEBinaryImage *)operator new(0x38uLL);
      uint64_t v12 = v11;
      if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v13 = &v39;
      }
      else {
        int v13 = (std::string *)v39.__r_.__value_.__r.__words[0];
      }
      BBUICEBinaryImage::BBUICEBinaryImage(v11, DataSource, (const char *)v13, 0);
      std::string::value_type v14 = (std::__shared_weak_count *)operator new(0x20uLL);
      uint64_t v15 = v14;
      v14->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CECB008;
      v14->__shared_owners_ = 0;
      v14->__shared_weak_owners_ = 0;
      v14[1].__vftable = (std::__shared_weak_count_vtbl *)v12;
      uint64_t v38 = v14;
      uint64_t v17 = this[31];
      uint64_t v16 = this[32];
      if (v17 >= v16)
      {
        uint64_t v20 = v3;
        uint64_t v21 = this[30];
        uint64_t v22 = (v17 - v21) >> 4;
        unint64_t v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 60) {
          std::vector<std::string>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v24 = v16 - v21;
        if (v24 >> 3 > v23) {
          unint64_t v23 = v24 >> 3;
        }
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v25 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v23;
        }
        if (v25 >> 60) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v26 = (char *)operator new(16 * v25);
        long long v27 = (BBUFeedback *)&v26[16 * v22];
        long long v28 = (BBUFeedback *)&v26[16 * v25];
        *(void *)long long v27 = v12;
        *((void *)v27 + 1) = v15;
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
        long long v29 = (BBUFeedback *)((char *)v27 + 16);
        if (v17 == v21)
        {
          this[30] = v27;
          this[31] = v29;
          this[32] = v28;
        }
        else
        {
          do
          {
            long long v30 = *((_OWORD *)v17 - 1);
            uint64_t v17 = (BBUFeedback *)((char *)v17 - 16);
            *((_OWORD *)v27 - 1) = v30;
            long long v27 = (BBUFeedback *)((char *)v27 - 16);
            *(void *)uint64_t v17 = 0;
            *((void *)v17 + 1) = 0;
          }
          while (v17 != v21);
          uint64_t v17 = this[30];
          long long v31 = this[31];
          this[30] = v27;
          this[31] = v29;
          this[32] = v28;
          while (v31 != v17)
          {
            long long v32 = (std::__shared_weak_count *)*((void *)v31 - 1);
            if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
              std::__shared_weak_count::__release_weak(v32);
            }
            long long v31 = (BBUFeedback *)((char *)v31 - 16);
          }
        }
        char v3 = v20;
        if (v17) {
          operator delete(v17);
        }
        this[31] = v29;
        uint64_t v18 = v38;
        if (!v38) {
          goto LABEL_46;
        }
      }
      else
      {
        *(void *)uint64_t v17 = v12;
        *((void *)v17 + 1) = v14;
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        this[31] = (BBUFeedback *)((char *)v17 + 16);
        uint64_t v18 = v14;
        if (!v14) {
          goto LABEL_46;
        }
      }
      if (atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_46;
      }
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_47;
      }
LABEL_48:
      if (v4)
      {
        timespec v2 = (uint64_t *)v2[1];
        if (v2 != &v42) {
          continue;
        }
      }
      goto LABEL_56;
    }
  }
  uint64_t v4 = 1;
LABEL_56:
  if (v44)
  {
    uint64_t v33 = v42;
    uint64_t v34 = v43;
    uint64_t v35 = *v43;
    *(void *)(v35 + 8) = *(void *)(v42 + 8);
    **(void **)(v33 + 8) = v35;
    uint64_t v44 = 0;
    if (v34 != &v42)
    {
      do
      {
        unint64_t v37 = (uint64_t *)v34[1];
        if (*((char *)v34 + 39) < 0) {
          operator delete((void *)v34[2]);
        }
        operator delete(v34);
        uint64_t v34 = v37;
      }
      while (v37 != &v42);
    }
  }
  return v4;
}

void sub_21DEF86A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  std::list<std::string>::~list(&a26);
  _Unwind_Resume(a1);
}

void std::list<std::string>::remove(void *a1, unsigned __int8 **a2)
{
  unint64_t v25 = &v25;
  std::string __p = &v25;
  uint64_t v27 = 0;
  timespec v2 = (void *)a1[1];
  if (v2 == a1) {
    return;
  }
  uint64_t v5 = 0;
  int v6 = &v25;
  while (2)
  {
    uint64_t v8 = *((unsigned __int8 *)v2 + 39);
    if ((v8 & 0x80u) == 0) {
      uint64_t v9 = (unsigned __int8 *)*((unsigned __int8 *)v2 + 39);
    }
    else {
      uint64_t v9 = (unsigned __int8 *)v2[3];
    }
    uint64_t v10 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    int v11 = (char)v10;
    if ((char)v10 < 0) {
      uint64_t v10 = a2[1];
    }
    if (v9 != v10) {
      goto LABEL_4;
    }
    if (v11 >= 0) {
      uint64_t v12 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v12 = *a2;
    }
    if ((v8 & 0x80) != 0)
    {
      if (memcmp((const void *)v2[2], v12, v2[3])) {
        goto LABEL_4;
      }
    }
    else if (*((unsigned char *)v2 + 39))
    {
      uint64_t v13 = 0;
      while (*((unsigned __int8 *)v2 + v13 + 16) == v12[v13])
      {
        if (v8 == ++v13) {
          goto LABEL_21;
        }
      }
LABEL_4:
      uint64_t i = v2;
LABEL_5:
      uint64_t i = (void *)i[1];
      goto LABEL_6;
    }
LABEL_21:
    for (uint64_t i = (void *)v2[1]; ; uint64_t i = (void *)i[1])
    {
      if (i == a1)
      {
        char v17 = 1;
        uint64_t i = a1;
        if (v2 == a1) {
          goto LABEL_36;
        }
        goto LABEL_39;
      }
      uint64_t v14 = *((unsigned __int8 *)i + 39);
      if ((v14 & 0x80u) == 0) {
        uint64_t v15 = (unsigned __int8 *)*((unsigned __int8 *)i + 39);
      }
      else {
        uint64_t v15 = (unsigned __int8 *)i[3];
      }
      if (v15 != v9) {
        goto LABEL_35;
      }
      if ((v14 & 0x80) == 0) {
        break;
      }
      if (memcmp((const void *)i[2], v12, i[3])) {
        goto LABEL_35;
      }
LABEL_23:
      ;
    }
    if (!*((unsigned char *)i + 39)) {
      goto LABEL_23;
    }
    uint64_t v16 = 0;
    while (*((unsigned __int8 *)i + v16 + 16) == v12[v16])
    {
      if (v14 == ++v16) {
        goto LABEL_23;
      }
    }
LABEL_35:
    char v17 = 0;
    if (v2 == i)
    {
LABEL_36:
      if ((v17 & 1) == 0) {
        goto LABEL_5;
      }
      goto LABEL_6;
    }
LABEL_39:
    int v6 = (void *)*i;
    if (&v25 != a1)
    {
      uint64_t v18 = 1;
      if (v6 != v2)
      {
        uint64_t v19 = v2;
        do
        {
          uint64_t v19 = (void *)v19[1];
          ++v18;
        }
        while (v19 != v6);
      }
      a1[2] -= v18;
      v5 += v18;
      uint64_t v27 = v5;
    }
    uint64_t v20 = *v2;
    *(void *)(v20 + 8) = v6[1];
    *(void *)v6[1] = v20;
    uint64_t v21 = v25;
    v25[1] = v2;
    *timespec v2 = v21;
    unint64_t v25 = v6;
    v6[1] = &v25;
    if ((v17 & 1) == 0) {
      goto LABEL_5;
    }
LABEL_6:
    timespec v2 = i;
    if (i != a1) {
      continue;
    }
    break;
  }
  if (v5)
  {
    uint64_t v22 = (char *)__p;
    uint64_t v23 = *(void *)__p;
    *(void *)(v23 + 8) = v6[1];
    *(void *)v6[1] = v23;
    uint64_t v27 = 0;
    if (v22 != (char *)&v25)
    {
      do
      {
        uint64_t v24 = (char *)*((void *)v22 + 1);
        if (v22[39] < 0) {
          operator delete(*((void **)v22 + 2));
        }
        operator delete(v22);
        uint64_t v22 = v24;
      }
      while (v24 != (char *)&v25);
    }
  }
}

char *std::list<std::string>::~list(char *a1)
{
  if (*((void *)a1 + 2))
  {
    uint64_t v2 = *(void *)a1;
    char v3 = (char *)*((void *)a1 + 1);
    uint64_t v4 = *(void *)v3;
    *(void *)(v4 + 8) = *(void *)(*(void *)a1 + 8);
    **(void **)(v2 + 8) = v4;
    *((void *)a1 + 2) = 0;
    if (v3 != a1)
    {
      do
      {
        int v6 = (char *)*((void *)v3 + 1);
        if (v3[39] < 0) {
          operator delete(*((void **)v3 + 2));
        }
        operator delete(v3);
        char v3 = v6;
      }
      while (v6 != a1);
    }
  }
  return a1;
}

uint64_t BBUICE16UpdateSource::loadELFFiles(BBUFeedback **this)
{
  uint64_t v44 = (uint64_t)&v44;
  uint64_t v45 = &v44;
  uint64_t v46 = 0;
  char v43 = 4;
  strcpy((char *)__p, ".elf");
  (*((void (**)(BBUFeedback **, uint64_t *, void **))*this + 32))(this, &v44, __p);
  if ((v43 & 0x80000000) == 0)
  {
    uint64_t v2 = v45;
    if (v45 != &v44) {
      goto LABEL_3;
    }
    goto LABEL_61;
  }
  operator delete(__p[0]);
  uint64_t v2 = v45;
  if (v45 != &v44)
  {
    while (1)
    {
LABEL_3:
      memset(&v41, 170, sizeof(v41));
      if (*((char *)v2 + 39) < 0) {
        std::string::__init_copy_ctor_external(&v41, (const std::string::value_type *)v2[2], v2[3]);
      }
      else {
        std::string v41 = *(std::string *)(v2 + 2);
      }
      uint64_t v3 = BBUICEUpdateSource::containsFile((uint64_t)this, (uint64_t)&v41);
      if ((v3 & 1) == 0)
      {
        if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v16 = &v41;
        }
        else {
          uint64_t v16 = (std::string *)v41.__r_.__value_.__r.__words[0];
        }
        BBUFeedback::handleComment(this[1], "Unable to locate file from directory listing '%s'.", (const char *)v16);
LABEL_51:
        if ((SHIBYTE(v41.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_53;
        }
LABEL_52:
        operator delete(v41.__r_.__value_.__l.__data_);
        goto LABEL_53;
      }
      DataSource = BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)&v41, 0);
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
          goto LABEL_14;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
          goto LABEL_14;
        }
      }
      if ((gBBULogVerbosity & 0x80000000) == 0)
      {
        uint64_t v5 = (const char *)(*(uint64_t (**)(BBUFeedback **))*this)(this);
        if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v9 = &v41;
        }
        else {
          LOBYTE(v9) = v41.__r_.__value_.__s.__data_[0];
        }
        _BBULog(3, 0, v5, "", "Loaded download file '%s'\n", v6, v7, v8, (char)v9);
      }
LABEL_14:
      uint64_t v10 = operator new(0x30uLL);
      int v11 = v10;
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v12 = &v41;
      }
      else {
        uint64_t v12 = (std::string *)v41.__r_.__value_.__r.__words[0];
      }
      *uint64_t v10 = &unk_26CECE3E0;
      uint64_t v13 = v10 + 1;
      size_t v14 = strlen((const char *)v12);
      if (v14 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      size_t v15 = v14;
      if (v14 >= 0x17)
      {
        uint64_t v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v14 | 7) != 0x17) {
          uint64_t v17 = v14 | 7;
        }
        uint64_t v18 = v17 + 1;
        uint64_t v13 = operator new(v17 + 1);
        void v11[2] = v15;
        void v11[3] = v18 | 0x8000000000000000;
        v11[1] = v13;
LABEL_28:
        memmove(v13, v12, v15);
        goto LABEL_29;
      }
      *((unsigned char *)v11 + 31) = v14;
      if (v14) {
        goto LABEL_28;
      }
LABEL_29:
      *((unsigned char *)v13 + v15) = 0;
      *((_DWORD *)v11 + 8) = 0;
      v11[5] = DataSource;
      uint64_t v19 = (std::__shared_weak_count *)operator new(0x20uLL);
      uint64_t v20 = v19;
      v19->__vftable = (std::__shared_weak_count_vtbl *)&unk_26CECB058;
      v19->__shared_owners_ = 0;
      v19->__shared_weak_owners_ = 0;
      v19[1].__vftable = (std::__shared_weak_count_vtbl *)v11;
      uint64_t v40 = v19;
      uint64_t v22 = this[28];
      uint64_t v21 = this[29];
      if (v22 >= v21)
      {
        uint64_t v24 = this[27];
        uint64_t v25 = (v22 - v24) >> 4;
        unint64_t v26 = v25 + 1;
        if ((unint64_t)(v25 + 1) >> 60) {
          std::vector<std::string>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v27 = v21 - v24;
        if (v27 >> 3 > v26) {
          unint64_t v26 = v27 >> 3;
        }
        if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28 >> 60) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        long long v29 = (char *)operator new(16 * v28);
        long long v30 = (BBUFeedback *)&v29[16 * v25];
        long long v31 = (BBUFeedback *)&v29[16 * v28];
        *(void *)long long v30 = v11;
        *((void *)v30 + 1) = v20;
        atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v23 = (BBUFeedback *)((char *)v30 + 16);
        if (v22 == v24)
        {
          this[27] = v30;
          this[28] = v23;
          this[29] = v31;
        }
        else
        {
          do
          {
            long long v32 = *((_OWORD *)v22 - 1);
            uint64_t v22 = (BBUFeedback *)((char *)v22 - 16);
            *((_OWORD *)v30 - 1) = v32;
            long long v30 = (BBUFeedback *)((char *)v30 - 16);
            *(void *)uint64_t v22 = 0;
            *((void *)v22 + 1) = 0;
          }
          while (v22 != v24);
          uint64_t v22 = this[27];
          uint64_t v33 = this[28];
          this[27] = v30;
          this[28] = v23;
          this[29] = v31;
          while (v33 != v22)
          {
            uint64_t v34 = (std::__shared_weak_count *)*((void *)v33 - 1);
            if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
              std::__shared_weak_count::__release_weak(v34);
            }
            uint64_t v33 = (BBUFeedback *)((char *)v33 - 16);
          }
        }
        if (v22) {
          operator delete(v22);
        }
      }
      else
      {
        *(void *)uint64_t v22 = v11;
        *((void *)v22 + 1) = v19;
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        uint64_t v23 = (BBUFeedback *)((char *)v22 + 16);
      }
      this[28] = v23;
      if (!v40 || atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_51;
      }
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
      if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_52;
      }
LABEL_53:
      if (v3)
      {
        uint64_t v2 = (uint64_t *)v2[1];
        if (v2 != &v44) {
          continue;
        }
      }
      goto LABEL_62;
    }
  }
LABEL_61:
  uint64_t v3 = 1;
LABEL_62:
  if (v46)
  {
    uint64_t v35 = v44;
    uint64_t v36 = v45;
    uint64_t v37 = *v45;
    *(void *)(v37 + 8) = *(void *)(v44 + 8);
    **(void **)(v35 + 8) = v37;
    uint64_t v46 = 0;
    if (v36 != &v44)
    {
      do
      {
        std::string v39 = (uint64_t *)v36[1];
        if (*((char *)v36 + 39) < 0) {
          operator delete((void *)v36[2]);
        }
        operator delete(v36);
        uint64_t v36 = v39;
      }
      while (v39 != &v44);
    }
  }
  return v3;
}

void sub_21DEF8F5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  std::list<std::string>::~list(&a26);
  _Unwind_Resume(a1);
}

uint64_t BBUICE16UpdateSource::getEBLImage(BBUICE16UpdateSource *this)
{
  return *((void *)this + 25);
}

uint64_t *BBUICE16UpdateSource::getItems(uint64_t **this)
{
  uint64_t v2 = (uint64_t *)operator new(0x18uLL);
  *uint64_t v2 = (uint64_t)v2;
  v2[1] = (uint64_t)v2;
  v2[2] = 0;
  uint64_t v3 = (uint64_t *)((uint64_t (*)(uint64_t **))(*this)[35])(this);
  if (v3)
  {
    uint64_t v4 = BBUProgrammer::Item::createFromImage(20480, v3);
    uint64_t v5 = operator new(0x18uLL);
    v5[1] = v2;
    uint64_t v5[2] = v4;
    uint64_t v6 = *v2;
    void *v5 = *v2;
    *(void *)(v6 + 8) = v5;
    *uint64_t v2 = (uint64_t)v5;
    ++v2[2];
  }
  uint64_t v7 = this[6];
  if (v7)
  {
    uint64_t v8 = BBUProgrammer::Item::createFromImage(20484, v7);
    uint64_t v9 = operator new(0x18uLL);
    v9[1] = v2;
    void v9[2] = v8;
    uint64_t v10 = *v2;
    *uint64_t v9 = *v2;
    *(void *)(v10 + 8) = v9;
    *uint64_t v2 = (uint64_t)v9;
    ++v2[2];
  }
  int v11 = this[7];
  if (v11)
  {
    uint64_t v12 = BBUProgrammer::Item::createFromImage(20485, v11);
    uint64_t v13 = operator new(0x18uLL);
    v13[1] = v2;
    void v13[2] = v12;
    uint64_t v14 = *v2;
    *uint64_t v13 = *v2;
    *(void *)(v14 + 8) = v13;
    *uint64_t v2 = (uint64_t)v13;
    ++v2[2];
  }
  size_t v15 = this[5];
  if (v15)
  {
    uint64_t v16 = BBUProgrammer::Item::createFromImage(20486, v15);
    uint64_t v17 = operator new(0x18uLL);
    v17[1] = v2;
    _OWORD v17[2] = v16;
    uint64_t v18 = *v2;
    *uint64_t v17 = *v2;
    *(void *)(v18 + 8) = v17;
    *uint64_t v2 = (uint64_t)v17;
    ++v2[2];
  }
  uint64_t v19 = this[33];
  for (uint64_t i = this[34]; v19 != i; v19 += 2)
  {
    uint64_t v21 = (uint64_t *)*v19;
    uint64_t v22 = (std::__shared_weak_count *)v19[1];
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v21)
    {
      uint64_t v23 = BBUProgrammer::Item::createFromImage(20481, v21);
      uint64_t v24 = operator new(0x18uLL);
      v24[1] = v2;
      v24[2] = v23;
      uint64_t v25 = *v2;
      *uint64_t v24 = *v2;
      *(void *)(v25 + 8) = v24;
      *uint64_t v2 = (uint64_t)v24;
      ++v2[2];
    }
    if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }
  unint64_t v26 = this[30];
  for (uint64_t j = this[31]; v26 != j; v26 += 2)
  {
    unint64_t v28 = (uint64_t *)*v26;
    long long v29 = (std::__shared_weak_count *)v26[1];
    if (v29) {
      atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v28)
    {
      long long v30 = BBUProgrammer::Item::createFromImage(20482, v28);
      long long v31 = operator new(0x18uLL);
      v31[1] = v2;
      v31[2] = v30;
      uint64_t v32 = *v2;
      *long long v31 = *v2;
      *(void *)(v32 + 8) = v31;
      *uint64_t v2 = (uint64_t)v31;
      ++v2[2];
    }
    if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }
  uint64_t v33 = this[27];
  for (uint64_t k = this[28]; v33 != k; v33 += 2)
  {
    uint64_t v35 = (uint64_t *)*v33;
    uint64_t v36 = (std::__shared_weak_count *)v33[1];
    if (v36) {
      atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v35)
    {
      uint64_t v37 = BBUProgrammer::Item::createFromImage(20483, v35);
      uint64_t v38 = operator new(0x18uLL);
      v38[1] = v2;
      v38[2] = v37;
      uint64_t v39 = *v2;
      *uint64_t v38 = *v2;
      *(void *)(v39 + 8) = v38;
      *uint64_t v2 = (uint64_t)v38;
      ++v2[2];
    }
    if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
  uint64_t v40 = this[36];
  for (m = this[37]; v40 != m; v40 += 2)
  {
    uint64_t v42 = (uint64_t *)*v40;
    char v43 = (std::__shared_weak_count *)v40[1];
    if (v43) {
      atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v42)
    {
      uint64_t v44 = BBUProgrammer::Item::createFromImage(20487, v42);
      uint64_t v45 = operator new(0x18uLL);
      v45[1] = v2;
      unint64_t v45[2] = v44;
      uint64_t v46 = *v2;
      void *v45 = *v2;
      *(void *)(v46 + 8) = v45;
      *uint64_t v2 = (uint64_t)v45;
      ++v2[2];
    }
    if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  return v2;
}

void sub_21DEF9484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_21DEF9498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_21DEF94AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_21DEF94C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t BBUICE16UpdateSource::eraseBasebandFilesystem(BBUFeedback **this)
{
  memset(&__p, 170, sizeof(__p));
  getNVMFilePath((uint64_t)&__p, 0);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  BBUFeedback::handleComment(this[1], "generating 0xFF-filled file for %s", (const char *)p_p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v3 = &__p;
  }
  else {
    uint64_t v3 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  int v4 = open((const char *)v3, 1537, 384);
  if (v4 < 0)
  {
    uint64_t v6 = this[1];
    uint64_t v7 = __error();
    uint64_t v8 = strerror(*v7);
    BBUFeedback::handleComment(v6, "Failed to create file %s\n", v8);
    uint64_t v5 = 15;
  }
  else
  {
    uint64_t v5 = 0;
  }
  unsigned int v9 = 0;
  char v10 = 1;
  while (v9 < (unint64_t)capabilities::updater::ICENVMFSizeBytes() >> 14)
  {
    if (write(v4, &ff_buffer, 0x4000uLL) != 0x4000)
    {
      int v11 = this[1];
      uint64_t v12 = __error();
      uint64_t v13 = strerror(*v12);
      BBUFeedback::handleComment(v11, "Failed zero-filling file at segment %u, err=%s\n", v9, v13);
      char v10 = 0;
    }
    ++v9;
  }
  close(v4);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  memset(&__p, 170, sizeof(__p));
  getNVMFilePath((uint64_t)&__p, 1);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v14 = &__p;
  }
  else {
    uint64_t v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  BBUFeedback::handleComment(this[1], "generating 0xFF-filled file for %s", (const char *)v14);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v15 = &__p;
  }
  else {
    size_t v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  int v16 = open((const char *)v15, 1537, 384);
  if (v16 < 0)
  {
    uint64_t v17 = this[1];
    uint64_t v18 = __error();
    uint64_t v19 = strerror(*v18);
    BBUFeedback::handleComment(v17, "Failed to create file %s\n", v19);
    uint64_t v5 = 15;
  }
  for (unsigned int i = 0; i < (unint64_t)capabilities::updater::ICENVMFSizeBytes() >> 14; ++i)
  {
    if (write(v16, &ff_buffer, 0x4000uLL) != 0x4000)
    {
      uint64_t v21 = this[1];
      uint64_t v22 = __error();
      uint64_t v23 = strerror(*v22);
      BBUFeedback::handleComment(v21, "Failed zero-filling file at segment %u, err=%s\n", i, v23);
      char v10 = 0;
    }
  }
  uint64_t v24 = close(v16);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((v10 & 1) == 0) {
      return v5;
    }
  }
  else if ((v10 & 1) == 0)
  {
    return v5;
  }
  if (MEMORY[0x223C1CBE0](v24))
  {
    memset(&__p, 170, sizeof(__p));
    BBUICE16UpdateSource::getMRCFilePath((uint64_t)&__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v25 = &__p;
    }
    else {
      uint64_t v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(this[1], "unlinking MRC data %s", (const char *)v25);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v26 = &__p;
    }
    else {
      unint64_t v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    int v27 = unlink((const char *)v26);
    if (v27 < 0)
    {
      unint64_t v28 = this[1];
      long long v29 = __error();
      long long v30 = strerror(*v29);
      BBUFeedback::handleComment(v28, "Unlinking MRC had an error %s", v30);
      uint64_t v5 = 15;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_43:
        if (v27 < 0) {
          return v5;
        }
        goto LABEL_47;
      }
    }
    else if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_43;
    }
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v27 < 0) {
      return v5;
    }
  }
LABEL_47:
  pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  long long v31 = (BBUPartitionManager *)off_26AA89B50;
  if (!off_26AA89B50)
  {
    uint64_t v32 = (BBUPartitionManager *)operator new(0x18uLL);
    BBUPartitionManager::BBUPartitionManager(v32);
    uint64_t v33 = operator new(0x20uLL);
    *uint64_t v33 = &unk_26CECF498;
    v33[1] = 0;
    v33[2] = 0;
    v33[3] = v32;
    uint64_t v34 = (std::__shared_weak_count *)off_26AA89B58;
    off_26AA89B50 = v32;
    off_26AA89B58 = v33;
    if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
    long long v31 = (BBUPartitionManager *)off_26AA89B50;
  }
  uint64_t v35 = (std::__shared_weak_count *)off_26AA89B58;
  if (off_26AA89B58) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  BBUPartitionManager::getBBUFSPath(v31, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    char v43 = (bbufs *)&__p;
  }
  else {
    char v43 = (bbufs *)__p.__r_.__value_.__r.__words[0];
  }
  if (v43)
  {
    if (bbufs::prepareDestination(v43, v36))
    {
      char v50 = 1;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_64;
      }
      goto LABEL_65;
    }
    _BBUFSDebugPrint("BBUFSServerPrepare", "failed preparing baseband filesystem directory\n", v44, v45, v46, v47, v48, v49, v56);
  }
  else
  {
    _BBUFSDebugPrint("BBUFSServerPrepare", "invalid path specified %s\n", v37, v38, v39, v40, v41, v42, 0);
  }
  char v50 = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_64:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_65:
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  if ((v50 & 1) == 0)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t v5 = 11;
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        return v5;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      uint64_t v5 = 11;
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        return v5;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      uint64_t v51 = (const char *)(*(uint64_t (**)(BBUFeedback **))*this)(this);
      _BBULog(3, 0, v51, "", "failed preparing filesystem after erase\n", v52, v53, v54, v56);
    }
  }
  return v5;
}

void sub_21DEF9A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy((uint64_t)v19, v19[1]);
  operator delete(v19);
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef BBUICE16UpdateSource::copyBasebandMigrationData(BBUICE16UpdateSource *this, BBUFeedback *a2)
{
  memset(&v39, 170, sizeof(v39));
  pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  uint64_t v3 = (BBUPartitionManager *)off_26AA89B50;
  if (!off_26AA89B50)
  {
    int v4 = (BBUPartitionManager *)operator new(0x18uLL);
    BBUPartitionManager::BBUPartitionManager(v4);
    uint64_t v5 = operator new(0x20uLL);
    void *v5 = &unk_26CECF498;
    v5[1] = 0;
    uint64_t v5[2] = 0;
    v5[3] = v4;
    uint64_t v6 = (std::__shared_weak_count *)off_26AA89B58;
    off_26AA89B50 = v4;
    off_26AA89B58 = v5;
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    uint64_t v3 = (BBUPartitionManager *)off_26AA89B50;
  }
  uint64_t v7 = (std::__shared_weak_count *)off_26AA89B58;
  *(void *)&v40.st_dev = v3;
  v40.st_ino = (__darwin_ino64_t)off_26AA89B58;
  if (off_26AA89B58) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  BBUPartitionManager::getBBUFSPath(v3, &v39);
  if (!v7 || atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v15 = (bbufs *)&v39;
    }
    else {
      size_t v15 = (bbufs *)v39.__r_.__value_.__r.__words[0];
    }
    if (v15) {
      goto LABEL_14;
    }
LABEL_27:
    _BBUFSDebugPrint("BBUFSServerPrepare", "invalid path specified %s\n", v9, v10, v11, v12, v13, v14, 0);
LABEL_28:
    BBUFeedback::handleComment(this, "Failed preparing baseband filesystem directory for copying baseband migration data\n");
    CFMutableDictionaryRef Mutable = 0;
    if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_49;
    }
    return Mutable;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  if ((v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v15 = (bbufs *)&v39;
  }
  else {
    size_t v15 = (bbufs *)v39.__r_.__value_.__r.__words[0];
  }
  if (!v15) {
    goto LABEL_27;
  }
LABEL_14:
  if ((bbufs::prepareDestination(v15, v8) & 1) == 0)
  {
    _BBUFSDebugPrint("BBUFSServerPrepare", "failed preparing baseband filesystem directory\n", v16, v17, v18, v19, v20, v21, v36);
    goto LABEL_28;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  memset(&__p, 170, sizeof(__p));
  getNVMFilePath((uint64_t)&__p, 0);
  v23.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v23.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v40.st_blkstd::string::size_type size = v23;
  *(timespec *)v40.st_qspare = v23;
  v40.st_birthtimespec = v23;
  *(timespec *)&v40.st_std::string::size_type size = v23;
  v40.st_mtimespec = v23;
  v40.st_ctimespec = v23;
  *(timespec *)&v40.st_uid = v23;
  v40.st_atimespec = v23;
  *(timespec *)&v40.st_dev = v23;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (stat((const char *)p_p, &v40))
  {
    uint64_t v25 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(this, "Failed to locate %s while copying baseband migration data\n", (const char *)v25);
    goto LABEL_34;
  }
  unint64_t v26 = (BBUDataSource *)operator new(0x30uLL);
  *(void *)unint64_t v26 = &unk_26CECA448;
  *(_OWORD *)((char *)v26 + 8) = 0u;
  *(_OWORD *)((char *)v26 + 24) = 0u;
  if (BBUFileDataSource::init((uint64_t)v26, (const char *)&__p, 0))
  {
    (*(void (**)(BBUDataSource *))(*(void *)v26 + 8))(v26);
    int v27 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      int v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(this, "Failed generating data source for %s while copying baseband migration data\n", (const char *)v27);
LABEL_34:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  uint64_t v34 = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v34 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  BBUFeedback::handleComment(this, "copying %s for migration", (const char *)v34);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v37, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v37 = __p;
  }
  BBUDataSource::createData(v26, (CFDataRef *)&v40);
  ctu::cf::insert<std::string,__CFData const*>((uint64_t)Mutable, (uint64_t)&v37, *(const void **)&v40.st_dev);
  if (*(void *)&v40.st_dev) {
    CFRelease(*(CFTypeRef *)&v40.st_dev);
  }
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v37.__r_.__value_.__l.__data_);
  }
  (*(void (**)(BBUDataSource *))(*(void *)v26 + 8))(v26);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_35:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_36:
  memset(&__p, 170, sizeof(__p));
  getNVMFilePath((uint64_t)&__p, 1);
  v28.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v28.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v40.st_blkstd::string::size_type size = v28;
  *(timespec *)v40.st_qspare = v28;
  v40.st_birthtimespec = v28;
  *(timespec *)&v40.st_std::string::size_type size = v28;
  v40.st_mtimespec = v28;
  v40.st_ctimespec = v28;
  *(timespec *)&v40.st_uid = v28;
  v40.st_atimespec = v28;
  *(timespec *)&v40.st_dev = v28;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v29 = &__p;
  }
  else {
    long long v29 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if (stat((const char *)v29, &v40))
  {
    long long v30 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      long long v30 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(this, "Failed to locate %s while copying baseband migration data\n", (const char *)v30);
    goto LABEL_47;
  }
  long long v31 = (BBUDataSource *)operator new(0x30uLL);
  *(void *)long long v31 = &unk_26CECA448;
  *(_OWORD *)((char *)v31 + 8) = 0u;
  *(_OWORD *)((char *)v31 + 24) = 0u;
  if (BBUFileDataSource::init((uint64_t)v31, (const char *)&__p, 0))
  {
    (*(void (**)(BBUDataSource *))(*(void *)v31 + 8))(v31);
    uint64_t v32 = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    BBUFeedback::handleComment(this, "Failed generating data source for %s while copying baseband migration data\n", (const char *)v32);
LABEL_47:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_48;
    }
LABEL_72:
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v39.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return Mutable;
    }
    goto LABEL_49;
  }
  uint64_t v35 = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v35 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  BBUFeedback::handleComment(this, "copying %s for migration", (const char *)v35);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v37, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v37 = __p;
  }
  BBUDataSource::createData(v31, (CFDataRef *)&v40);
  ctu::cf::insert<std::string,__CFData const*>((uint64_t)Mutable, (uint64_t)&v37, *(const void **)&v40.st_dev);
  if (*(void *)&v40.st_dev) {
    CFRelease(*(CFTypeRef *)&v40.st_dev);
  }
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v37.__r_.__value_.__l.__data_);
  }
  (*(void (**)(BBUDataSource *))(*(void *)v31 + 8))(v31);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_72;
  }
LABEL_48:
  if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0) {
LABEL_49:
  }
    operator delete(v39.__r_.__value_.__l.__data_);
  return Mutable;
}

void sub_21DEFA0D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,const void *a30)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((a23 & 0x80000000) == 0)
    {
LABEL_3:
      if (a29 < 0)
      {
LABEL_8:
        operator delete(a24);
        _Unwind_Resume(a1);
      }
LABEL_7:
      _Unwind_Resume(a1);
    }
  }
  else if ((a23 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a18);
  if (a29 < 0) {
    goto LABEL_8;
  }
  goto LABEL_7;
}

uint64_t ctu::cf::insert<std::string,__CFData const*>(uint64_t a1, uint64_t a2, const void *a3)
{
  if (a3)
  {
    CFRetain(a3);
    CFRelease(a3);
  }
  return 0;
}

void sub_21DEFA250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

void sub_21DEFA274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t BBUICE16UpdateSource::restoreBasebandMigrationData(BBUICE16UpdateSource *this, BBUFeedback *a2, const __CFDictionary *a3)
{
  memset(&__p, 170, sizeof(__p));
  pthread_mutex_lock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  uint64_t v5 = (BBUPartitionManager *)off_26AA89B50;
  if (!off_26AA89B50)
  {
    uint64_t v6 = (BBUPartitionManager *)operator new(0x18uLL);
    BBUPartitionManager::BBUPartitionManager(v6);
    uint64_t v7 = operator new(0x20uLL);
    *uint64_t v7 = &unk_26CECF498;
    v7[1] = 0;
    unint64_t v7[2] = 0;
    v7[3] = v6;
    uint64_t v8 = (std::__shared_weak_count *)off_26AA89B58;
    off_26AA89B50 = v6;
    off_26AA89B58 = v7;
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
    uint64_t v5 = (BBUPartitionManager *)off_26AA89B50;
  }
  uint64_t v9 = (std::__shared_weak_count *)off_26AA89B58;
  *(void *)uint64_t v48 = v5;
  *(void *)&v48[8] = off_26AA89B58;
  if (off_26AA89B58) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89B58 + 1, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  BBUPartitionManager::getBBUFSPath(v5, &__p);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = (bbufs *)&__p;
    }
    else {
      p_p = (bbufs *)__p.__r_.__value_.__r.__words[0];
    }
    if (p_p) {
      goto LABEL_14;
    }
LABEL_21:
    _BBUFSDebugPrint("BBUFSServerPrepare", "invalid path specified %s\n", v11, v12, v13, v14, v15, v16, 0);
    goto LABEL_22;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = (bbufs *)&__p;
  }
  else {
    p_p = (bbufs *)__p.__r_.__value_.__r.__words[0];
  }
  if (!p_p) {
    goto LABEL_21;
  }
LABEL_14:
  if (bbufs::prepareDestination(p_p, v10))
  {
    uint64_t v24 = 1;
    goto LABEL_23;
  }
  _BBUFSDebugPrint("BBUFSServerPrepare", "failed preparing baseband filesystem directory\n", v18, v19, v20, v21, v22, v23, v45);
LABEL_22:
  BBUFeedback::handleComment(this, "Failed preparing baseband filesystem directory for copying baseband migration data");
  uint64_t v24 = 0;
LABEL_23:
  *((void *)&v49 + 1) = 0;
  uint64_t v50 = 0;
  *(void *)&long long v49 = (char *)&v49 + 8;
  *(_OWORD *)&v48[8] = 0uLL;
  *(void *)uint64_t v48 = &v48[8];
  context.__r_.__value_.__r.__words[0] = (std::string::size_type)v48;
  context.__r_.__value_.__l.__size_ = (std::string::size_type)&v48[8];
  if (!a2)
  {
    std::__tree<std::__value_type<std::string,__CFData const*>,std::__map_value_compare<std::string,std::__value_type<std::string,__CFData const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,__CFData const*>>>::destroy((uint64_t)v48, 0);
    long long v30 = (_OWORD *)v49;
    if ((long long *)v49 == (long long *)((char *)&v49 + 8)) {
      goto LABEL_85;
    }
    goto LABEL_31;
  }
  CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)ctu::cf::_Applier_InsertMapDefault<std::string,__CFData const*,std::insert_iterator<std::map<std::string,__CFData const*>>>, &context);
  long long v25 = v49;
  long long v49 = *(_OWORD *)v48;
  *(_OWORD *)uint64_t v48 = v25;
  uint64_t v26 = v50;
  uint64_t v50 = *(void *)&v48[16];
  *(void *)&v48[16] = v26;
  int v27 = &v49;
  if (v50) {
    int v27 = (long long *)(*((void *)&v49 + 1) + 16);
  }
  *(void *)int v27 = (char *)&v49 + 8;
  BOOL v28 = v26 == 0;
  long long v29 = v48;
  if (!v28) {
    long long v29 = (void *)(*((void *)&v25 + 1) + 16);
  }
  void *v29 = &v48[8];
  std::__tree<std::__value_type<std::string,__CFData const*>,std::__map_value_compare<std::string,std::__value_type<std::string,__CFData const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,__CFData const*>>>::destroy((uint64_t)v48, *((char **)&v25 + 1));
  long long v30 = (_OWORD *)v49;
  if ((long long *)v49 != (long long *)((char *)&v49 + 8))
  {
LABEL_31:
    CFAllocatorRef v31 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    do
    {
      *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)uint64_t v48 = v32;
      *(_OWORD *)&v48[16] = v32;
      if (*((char *)v30 + 55) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)v48, *((const std::string::value_type **)v30 + 4), *((void *)v30 + 5));
      }
      else
      {
        *(_OWORD *)uint64_t v48 = v30[2];
        *(void *)&v48[16] = *((void *)v30 + 6);
      }
      *(void *)&v48[24] = *((void *)v30 + 7);
      if ((v48[23] & 0x80000000) != 0) {
        std::string::__init_copy_ctor_external(&v46, *(const std::string::value_type **)v48, *(std::string::size_type *)&v48[8]);
      }
      else {
        std::string v46 = *(std::string *)v48;
      }
      if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v53, v46.__r_.__value_.__l.__data_, v46.__r_.__value_.__l.__size_);
      }
      else {
        std::string v53 = v46;
      }
      uint64_t v52 = 0;
      if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&context, v53.__r_.__value_.__l.__data_, v53.__r_.__value_.__l.__size_);
      }
      else {
        std::string context = v53;
      }
      CFStringRef v55 = 0;
      if (ctu::cf::convert_copy()) {
        CFStringRef v33 = v55;
      }
      else {
        CFStringRef v33 = 0;
      }
      if (SHIBYTE(context.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(context.__r_.__value_.__l.__data_);
        CFStringRef v47 = v33;
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
        {
LABEL_64:
          operator delete(v53.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v46.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_51;
          }
          goto LABEL_65;
        }
      }
      else
      {
        CFStringRef v47 = v33;
        if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_64;
        }
      }
      if ((SHIBYTE(v46.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_51;
      }
LABEL_65:
      operator delete(v46.__r_.__value_.__l.__data_);
LABEL_51:
      CFURLRef v34 = CFURLCreateWithFileSystemPath(v31, v33, kCFURLPOSIXPathStyle, 0);
      if (!v34)
      {
        uint64_t v35 = v48;
        if (v48[23] < 0) {
          uint64_t v35 = *(const char **)v48;
        }
        BBUFeedback::handleComment(this, "Failed creating CFURLRef for %s while restoring baseband migration data", v35);
      }
      if (v33) {
        CFRelease(v33);
      }
      if (!v34)
      {
        uint64_t v24 = 0;
        goto LABEL_76;
      }
      context.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
      v53.__r_.__value_.__r.__words[0] = 0;
      char v36 = CFWriteStreamCreateWithFile(0, v34);
      std::string v37 = v36;
      v53.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
      if (v36) {
        uint64_t v38 = ctu::SharedRef<__CFWriteStream,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFWriteStream>::get;
      }
      else {
        uint64_t v38 = 0;
      }
      if (v38)
      {
        if (CFWriteStreamOpen(v36))
        {
          BytePtr = CFDataGetBytePtr(*(CFDataRef *)&v48[24]);
          CFIndex Length = CFDataGetLength(*(CFDataRef *)&v48[24]);
          CFIndex v41 = CFWriteStreamWrite(v37, BytePtr, Length);
          if (v41 <= 0) {
            BBUFeedback::handleComment(this, "Failed writing to stream for restoring baseband migration data");
          }
          CFWriteStreamClose(v37);
          uint64_t v24 = v24 & (v41 > 0);
          if (!v37) {
            goto LABEL_75;
          }
LABEL_74:
          CFRelease(v37);
          goto LABEL_75;
        }
        BBUFeedback::handleComment(this, "Failed opening stream for restoring baseband migration data");
      }
      else
      {
        BBUFeedback::handleComment(this, "Failed creating CFWriteStremRef for restoring baseband migration data");
      }
      uint64_t v24 = 0;
      if (v37) {
        goto LABEL_74;
      }
LABEL_75:
      CFRelease(v34);
LABEL_76:
      if ((v48[23] & 0x80000000) != 0)
      {
        operator delete(*(void **)v48);
        uint64_t v42 = (void *)*((void *)v30 + 1);
        if (v42)
        {
          do
          {
LABEL_80:
            char v43 = v42;
            uint64_t v42 = (void *)*v42;
          }
          while (v42);
          goto LABEL_32;
        }
      }
      else
      {
        uint64_t v42 = (void *)*((void *)v30 + 1);
        if (v42) {
          goto LABEL_80;
        }
      }
      do
      {
        char v43 = (_OWORD *)*((void *)v30 + 2);
        BOOL v28 = *(void *)v43 == (void)v30;
        long long v30 = v43;
      }
      while (!v28);
LABEL_32:
      long long v30 = v43;
    }
    while (v43 != (long long *)((char *)&v49 + 8));
  }
LABEL_85:
  std::__tree<std::__value_type<std::string,__CFData const*>,std::__map_value_compare<std::string,std::__value_type<std::string,__CFData const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,__CFData const*>>>::destroy((uint64_t)&v49, *((char **)&v49 + 1));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v24;
}

void sub_21DEFA82C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  std::__tree<std::__value_type<__CFString const*,std::string>,std::__map_value_compare<__CFString const*,std::__value_type<__CFString const*,std::string>,std::less<__CFString const*>,true>,std::allocator<std::__value_type<__CFString const*,std::string>>>::destroy((uint64_t)v41, v41[1]);
  operator delete(v41);
  pthread_mutex_unlock(&ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance);
  _Unwind_Resume(a1);
}

void sub_21DEFA9A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if ((a20 & 0x80000000) == 0) {
    JUMPOUT(0x21DEFA984);
  }
  JUMPOUT(0x21DEFA97CLL);
}

uint64_t ctu::SharedRef<__CFWriteStream,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFWriteStream>::get(uint64_t a1)
{
  return *(void *)a1;
}

const void **ctu::cf::CFSharedRef<__CFWriteStream>::~CFSharedRef(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *BBUICE16UpdateSource::copyHashData(BBUICE16UpdateSource *this, char a2)
{
  if (!capabilities::updater::supportsHashSha384(this))
  {
    if ((a2 & 1) == 0)
    {
      uint64_t v59 = operator new(0x20uLL);
      BBUICE16HashData::BBUICE16HashData(v59, 0, 0);
      return v59;
    }
    CFStringRef v33 = (BBUZipFile *)*((void *)this + 8);
    if (!v33)
    {
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x2E9u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"BBU firmware data error.\")", v73, v74, v75, v76);
      goto LABEL_99;
    }
    long long v80 = 0uLL;
    uint64_t v79 = &v80;
    memset(v78, 170, sizeof(v78));
    BBUZipFile::getFileList(v33, v78);
    CFURLRef v34 = operator new(0x20uLL);
    *CFURLRef v34 = 0u;
    v34[1] = 0u;
    uint64_t v35 = v78[1];
    if ((void *)v78[1] == v78)
    {
LABEL_84:
      uint64_t v59 = operator new(0x20uLL);
      v59[2] = 0;
      *uint64_t v59 = &unk_26CECBEB0;
      v59[1] = v59 + 2;
      v59[3] = 0;
      std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<std::string,std::vector<unsigned char>>,std::__tree_node<std::__value_type<std::string,std::vector<unsigned char>>,void *> *,long>>((uint64_t)(v59 + 1), v79, &v80);
      operator delete(v34);
      if (v78[2])
      {
        uint64_t v60 = v78[0];
        uint64_t v61 = (void *)v78[1];
        uint64_t v62 = *(void *)v78[1];
        *(void *)(v62 + 8) = *(void *)(v78[0] + 8);
        **(void **)(v60 + 8) = v62;
        v78[2] = 0;
        if (v61 != v78)
        {
          do
          {
            uint64_t v63 = (void *)v61[1];
            if (*((char *)v61 + 39) < 0) {
              operator delete((void *)v61[2]);
            }
            operator delete(v61);
            uint64_t v61 = v63;
          }
          while (v63 != v78);
        }
      }
LABEL_92:
      std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy((uint64_t)&v79, (char *)v80);
      return v59;
    }
    char v36 = (void (*)(uint64_t, unsigned __int8 *, int))off_26CECF2B8;
    while (1)
    {
      memset(&v77, 170, sizeof(v77));
      if (*(char *)(v35 + 39) < 0) {
        std::string::__init_copy_ctor_external(&v77, *(const std::string::value_type **)(v35 + 16), *(void *)(v35 + 24));
      }
      else {
        std::string v77 = *(std::string *)(v35 + 16);
      }
      DataSource = BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)&v77, 0);
      uint64_t v38 = operator new(0x18uLL);
      *(void *)uint64_t v38 = &unk_26CECF280;
      v38[2] = 0;
      *((void *)v38 + 2) = DataSource;
      v36((uint64_t)v38, (unsigned __int8 *)v34, 0);
      ctu::assign();
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0) {
          goto LABEL_58;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0)
        {
LABEL_58:
          if ((gBBULogVerbosity & 0x80000000) == 0)
          {
            std::string v39 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
            if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              char v43 = &v77;
            }
            else {
              LOBYTE(v43) = v77.__r_.__value_.__s.__data_[0];
            }
            _BBULog(3, 0, v39, "", "Zipfile hash of %s: %s\n", v40, v41, v42, (char)v43);
          }
        }
      }
      size_t v81 = &v77;
      uint64_t v44 = std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)&v79, (const void **)&v77.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, (long long **)&v81);
      char v45 = v44;
      CFStringRef v47 = v44 + 7;
      std::string v46 = v44[7];
      unint64_t v48 = (unint64_t)v44[9];
      if (v48 - (unint64_t)v46 >= 0x20)
      {
        uint64_t v54 = v44[8];
        int64_t v55 = (char *)v54 - (char *)v46;
        if ((unint64_t)((char *)v54 - (char *)v46) > 0x1F)
        {
          long long v58 = v34[1];
          *(_OWORD *)std::string v46 = *v34;
          *((_OWORD *)v46 + 1) = v58;
          std::string v53 = v46 + 4;
        }
        else
        {
          if (v54 != v46)
          {
            memmove(v44[7], v34, (char *)v54 - (char *)v46);
            std::string v46 = v45[8];
          }
          char v56 = (char *)v34 + v55;
          size_t v57 = 32 - v55;
          memmove(v46, v56, v57);
          std::string v53 = (uint64_t *)((char *)v46 + v57);
        }
      }
      else
      {
        if (v46)
        {
          v44[8] = v46;
          operator delete(v46);
          unint64_t v48 = 0;
          void *v47 = 0;
          v47[1] = 0;
          v47[2] = 0;
        }
        uint64_t v49 = 2 * v48;
        if (2 * v48 <= 0x20) {
          uint64_t v49 = 32;
        }
        if (v48 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v50 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v50 = v49;
        }
        uint64_t v51 = (uint64_t *)operator new(v50);
        v45[7] = v51;
        v45[8] = v51;
        v45[9] = (uint64_t *)((char *)v51 + v50);
        long long v52 = v34[1];
        *(_OWORD *)uint64_t v51 = *v34;
        *((_OWORD *)v51 + 1) = v52;
        std::string v53 = v51 + 4;
      }
      v45[8] = v53;
      (*(void (**)(_DWORD *))(*(void *)v38 + 8))(v38);
      if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v77.__r_.__value_.__l.__data_);
        uint64_t v35 = *(void *)(v35 + 8);
        if ((void *)v35 == v78) {
          goto LABEL_84;
        }
      }
      else
      {
        uint64_t v35 = *(void *)(v35 + 8);
        if ((void *)v35 == v78) {
          goto LABEL_84;
        }
      }
    }
  }
  if (a2)
  {
    int v4 = (BBUZipFile *)*((void *)this + 8);
    if (v4)
    {
      long long v80 = 0uLL;
      uint64_t v79 = &v80;
      memset(v78, 170, sizeof(v78));
      BBUZipFile::getFileList(v4, v78);
      uint64_t v5 = (long long *)operator new(0x30uLL);
      v5[1] = 0u;
      uint64_t v5[2] = 0u;
      long long *v5 = 0u;
      uint64_t v6 = v78[1];
      if ((void *)v78[1] != v78)
      {
        while (1)
        {
          memset(&v77, 170, sizeof(v77));
          if (*(char *)(v6 + 39) < 0) {
            std::string::__init_copy_ctor_external(&v77, *(const std::string::value_type **)(v6 + 16), *(void *)(v6 + 24));
          }
          else {
            std::string v77 = *(std::string *)(v6 + 16);
          }
          v5[1] = 0u;
          uint64_t v5[2] = 0u;
          long long *v5 = 0u;
          uint64_t v7 = BBUICEUpdateSource::createDataSource((uint64_t)this, (uint64_t)&v77, 0);
          uint64_t v8 = operator new(0x18uLL);
          *(void *)uint64_t v8 = &unk_26CECF280;
          v8[2] = 0;
          *((void *)v8 + 2) = v7;
          if (*((_DWORD *)this + 40) != 104
            || ((*(uint64_t (**)(BBUICE16UpdateSource *))(*(void *)this + 336))(this) & 1) != 0)
          {
LABEL_20:
            uint64_t v11 = 1;
            goto LABEL_21;
          }
          if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
          {
            uint64_t v10 = (std::string *)v77.__r_.__value_.__r.__words[0];
            if (!strcmp(v77.__r_.__value_.__l.__data_, "psi_ram2.bin")) {
              goto LABEL_45;
            }
          }
          else
          {
            if (v77.__r_.__value_.__r.__words[0] == 0x326D61725F697370
              && *(std::string::size_type *)((char *)v77.__r_.__value_.__r.__words + 5) == 0x6E69622E326D61)
            {
              goto LABEL_45;
            }
            uint64_t v10 = &v77;
          }
          if (strcmp((const char *)v10, "restorepsi2.bin")) {
            goto LABEL_20;
          }
LABEL_45:
          uint64_t v11 = 0;
LABEL_21:
          (*(void (**)(_DWORD *, long long *, uint64_t))(*(void *)v8 + 56))(v8, v5, v11);
          ctu::assign();
          if (gBBULogMaskGet(void)::once == -1)
          {
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0) {
              goto LABEL_23;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0)
            {
LABEL_23:
              if ((gBBULogVerbosity & 0x80000000) == 0)
              {
                uint64_t v12 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
                if ((v77.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  uint64_t v16 = &v77;
                }
                else {
                  LOBYTE(v16) = v77.__r_.__value_.__s.__data_[0];
                }
                _BBULog(3, 0, v12, "", "Zipfile hash of %s: %s\n", v13, v14, v15, (char)v16);
              }
            }
          }
          size_t v81 = &v77;
          uint64_t v17 = std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)&v79, (const void **)&v77.__r_.__value_.__l.__data_, (uint64_t)&std::piecewise_construct, (long long **)&v81);
          uint64_t v18 = v17;
          uint64_t v20 = v17 + 7;
          uint64_t v19 = v17[7];
          unint64_t v21 = (unint64_t)v17[9];
          if (v21 - (unint64_t)v19 >= 0x30)
          {
            int v27 = v17[8];
            int64_t v28 = (char *)v27 - (char *)v19;
            if ((unint64_t)((char *)v27 - (char *)v19) > 0x2F)
            {
              long long v31 = *v5;
              long long v32 = v5[2];
              *((_OWORD *)v19 + 1) = v5[1];
              *((_OWORD *)v19 + 2) = v32;
              *(_OWORD *)uint64_t v19 = v31;
              uint64_t v26 = v19 + 6;
            }
            else
            {
              if (v27 != v19)
              {
                memmove(v17[7], v5, (char *)v27 - (char *)v19);
                uint64_t v19 = v18[8];
              }
              long long v29 = (char *)v5 + v28;
              size_t v30 = 48 - v28;
              memmove(v19, v29, v30);
              uint64_t v26 = (uint64_t *)((char *)v19 + v30);
            }
          }
          else
          {
            if (v19)
            {
              v17[8] = v19;
              operator delete(v19);
              unint64_t v21 = 0;
              *uint64_t v20 = 0;
              v20[1] = 0;
              v20[2] = 0;
            }
            uint64_t v22 = 2 * v21;
            if (2 * v21 <= 0x30) {
              uint64_t v22 = 48;
            }
            if (v21 >= 0x3FFFFFFFFFFFFFFFLL) {
              size_t v23 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              size_t v23 = v22;
            }
            uint64_t v24 = (uint64_t *)operator new(v23);
            v18[7] = v24;
            v18[8] = v24;
            v18[9] = (uint64_t *)((char *)v24 + v23);
            long long v25 = v5[1];
            *(_OWORD *)uint64_t v24 = *v5;
            *((_OWORD *)v24 + 1) = v25;
            *((_OWORD *)v24 + 2) = v5[2];
            uint64_t v26 = v24 + 6;
          }
          v18[8] = v26;
          (*(void (**)(_DWORD *))(*(void *)v8 + 8))(v8);
          if (SHIBYTE(v77.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v77.__r_.__value_.__l.__data_);
            uint64_t v6 = *(void *)(v6 + 8);
            if ((void *)v6 == v78) {
              break;
            }
          }
          else
          {
            uint64_t v6 = *(void *)(v6 + 8);
            if ((void *)v6 == v78) {
              break;
            }
          }
        }
      }
      uint64_t v59 = operator new(0x20uLL);
      v59[2] = 0;
      *uint64_t v59 = &unk_26CECED00;
      v59[1] = v59 + 2;
      v59[3] = 0;
      std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<std::string,std::vector<unsigned char>>,std::__tree_node<std::__value_type<std::string,std::vector<unsigned char>>,void *> *,long>>((uint64_t)(v59 + 1), v79, &v80);
      operator delete(v5);
      if (v78[2])
      {
        uint64_t v64 = v78[0];
        uint64_t v65 = (void *)v78[1];
        uint64_t v66 = *(void *)v78[1];
        *(void *)(v66 + 8) = *(void *)(v78[0] + 8);
        **(void **)(v64 + 8) = v66;
        v78[2] = 0;
        if (v65 != v78)
        {
          do
          {
            char v68 = (void *)v65[1];
            if (*((char *)v65 + 39) < 0) {
              operator delete((void *)v65[2]);
            }
            operator delete(v65);
            uint64_t v65 = v68;
          }
          while (v68 != v78);
        }
      }
      goto LABEL_92;
    }
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x2BEu, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"BBU firmware data error.\")", v70, v71, v72, v76);
LABEL_99:
  }
  uint64_t v59 = operator new(0x20uLL);
  BBUICE18HashData::BBUICE18HashData(v59, 0, 0);
  return v59;
}

void sub_21DEFB3F4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFB408(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFB41C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28,char *a29)
{
  std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(v31, v29[2]);
  operator delete(v29);
  operator delete(v30);
  std::list<std::string>::~list(&a25);
  std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy((uint64_t)&a28, a29);
  _Unwind_Resume(a1);
}

uint64_t BBUICE16UpdateSource::saveImages(BBUICE16UpdateSource *this)
{
  if (!*((void *)this + 8))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x310u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"BBU firmware data error.\")", v40, v41, v42, v47);
  }
  memset(__p, 170, sizeof(__p));
  capabilities::radio::personalizedFirmwarePath((uint64_t *)__p, this);
  uint64_t v2 = (void *)HIBYTE(__p[2]);
  if (SHIBYTE(__p[2]) < 0) {
    uint64_t v2 = __p[1];
  }
  if (!v2)
  {
    char v43 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v43, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICE16UpdateSource.cpp", 0x313u, (ctu::LogMessageBuffer *)"Assertion failure(folder.empty() != true && \"Failed finding the bbfw path.\")", v44, v45, v46, v47);
  }
  uint64_t v3 = BBUICEUpdateSource::saveImages(this);
  if (*((void *)this + 39) != *((void *)this + 40))
  {
    uint64_t v4 = v3;
    memset(v52, 170, sizeof(v52));
    BBUZipFile::getFileList(*((BBUZipFile **)this + 8), v52);
    uint64_t v5 = v52[1];
    if ((void *)v52[1] == v52) {
      goto LABEL_70;
    }
    uint64_t v6 = &unk_26AA8F000;
    uint64_t v7 = (unsigned char **)&unk_26AA8F000;
    while (1)
    {
      memset(&v51, 170, sizeof(v51));
      if (*(char *)(v5 + 39) < 0) {
        std::string::__init_copy_ctor_external(&v51, *(const std::string::value_type **)(v5 + 16), *(void *)(v5 + 24));
      }
      else {
        std::string v51 = *(std::string *)(v5 + 16);
      }
      if (!*((unsigned char *)this + 208)) {
        goto LABEL_41;
      }
      if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&v50, v51.__r_.__value_.__l.__data_, v51.__r_.__value_.__l.__size_);
      }
      else {
        std::string v50 = v51;
      }
      uint64_t v8 = *((void *)this + 39);
      uint64_t v9 = *((void *)this + 40);
      char v10 = HIBYTE(v50.__r_.__value_.__r.__words[2]);
      if (v8 != v9) {
        break;
      }
      if ((*((unsigned char *)&v50.__r_.__value_.__s + 23) & 0x80) != 0) {
        operator delete(v50.__r_.__value_.__l.__data_);
      }
LABEL_49:
      if (v6[406] == -1)
      {
        int v19 = 3;
        if ((*v7[405] & 2) == 0) {
          goto LABEL_56;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        int v19 = 3;
        if ((*v7[405] & 2) == 0) {
          goto LABEL_56;
        }
      }
      if ((gBBULogVerbosity & 0x80000000) == 0)
      {
        long long v25 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
        long long v29 = &v51;
        if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          LOBYTE(v29) = v51.__r_.__value_.__s.__data_[0];
        }
        _BBULog(1, 0, v25, "", "Skipping saving image %s: not in allowed list\n", v26, v27, v28, (char)v29);
      }
LABEL_56:
      if (SHIBYTE(v51.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v51.__r_.__value_.__l.__data_);
        if (v19 == 3) {
          goto LABEL_8;
        }
      }
      else if (v19 == 3)
      {
        goto LABEL_8;
      }
      if (v19)
      {
        uint64_t v4 = v48;
LABEL_70:
        if (v52[2])
        {
          uint64_t v34 = v52[0];
          uint64_t v35 = (void *)v52[1];
          uint64_t v36 = *(void *)v52[1];
          *(void *)(v36 + 8) = *(void *)(v52[0] + 8);
          **(void **)(v34 + 8) = v36;
          v52[2] = 0;
          if (v35 != v52)
          {
            do
            {
              uint64_t v38 = (void *)v35[1];
              if (*((char *)v35 + 39) < 0) {
                operator delete((void *)v35[2]);
              }
              operator delete(v35);
              uint64_t v35 = v38;
            }
            while (v38 != v52);
          }
        }
        goto LABEL_72;
      }
LABEL_8:
      uint64_t v5 = *(void *)(v5 + 8);
      if ((void *)v5 == v52) {
        goto LABEL_70;
      }
    }
    unsigned int v49 = v4;
    uint64_t v11 = v7;
    uint64_t v12 = v6;
    uint64_t v13 = (void *)v50.__r_.__value_.__r.__words[0];
    if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v50.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v50.__r_.__value_.__l.__size_;
    }
    if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = &v50;
    }
    else {
      uint64_t v15 = (std::string *)v50.__r_.__value_.__r.__words[0];
    }
    do
    {
      uint64_t v16 = *(unsigned __int8 *)(v8 + 23);
      if ((v16 & 0x80u) == 0) {
        uint64_t v17 = *(unsigned __int8 *)(v8 + 23);
      }
      else {
        uint64_t v17 = *(void *)(v8 + 8);
      }
      if (v17 == size)
      {
        if ((v16 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v8, v15, *(void *)(v8 + 8))) {
            goto LABEL_34;
          }
        }
        else
        {
          if (!*(unsigned char *)(v8 + 23))
          {
LABEL_34:
            if ((v10 & 0x80) == 0) {
              goto LABEL_35;
            }
            goto LABEL_40;
          }
          uint64_t v18 = 0;
          while (*(unsigned __int8 *)(v8 + v18) == v15->__r_.__value_.__s.__data_[v18])
          {
            if (v16 == ++v18) {
              goto LABEL_34;
            }
          }
        }
      }
      v8 += 24;
    }
    while (v8 != v9);
    uint64_t v8 = v9;
    if ((v10 & 0x80) == 0)
    {
LABEL_35:
      uint64_t v6 = v12;
      uint64_t v7 = v11;
      uint64_t v4 = v49;
      if (v8 != v9) {
        goto LABEL_41;
      }
      goto LABEL_49;
    }
LABEL_40:
    operator delete(v13);
    uint64_t v6 = v12;
    uint64_t v7 = v11;
    uint64_t v4 = v49;
    if (v8 == v9) {
      goto LABEL_49;
    }
LABEL_41:
    uint64_t v4 = BBUICEUpdateSource::saveFile((uint64_t)this, (uint64_t)&v51, (uint64_t)__p);
    if (v4)
    {
      if (v6[406] == -1)
      {
        int v19 = 1;
        if ((*v7[405] & 8) != 0)
        {
LABEL_44:
          if ((gBBULogVerbosity & 0x80000000) == 0)
          {
            uint64_t v20 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
            uint64_t v24 = &v51;
            if ((v51.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              LOBYTE(v24) = v51.__r_.__value_.__s.__data_[0];
            }
            _BBULog(3, 0, v20, "", "Failed saving %s", v21, v22, v23, (char)v24);
          }
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        int v19 = 1;
        if ((*v7[405] & 8) != 0) {
          goto LABEL_44;
        }
      }
      unsigned int v48 = v4;
      goto LABEL_56;
    }
    int v19 = 0;
    goto LABEL_56;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    uint64_t v4 = 22;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_72;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t v4 = 22;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_72;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    size_t v30 = (const char *)(**(uint64_t (***)(BBUICE16UpdateSource *))this)(this);
    _BBULog(1, 0, v30, "", "Error: image filter list is empty, cannot save any images!\n", v31, v32, v33, v47);
  }
LABEL_72:
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_21DEFBABC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBUICE16UpdateSource::validateCoredumpItems(BBUICE16UpdateSource *this)
{
  if (*((_DWORD *)this + 40) == 104)
  {
    if ((*(unsigned int (**)(BBUICE16UpdateSource *))(*(void *)this + 336))(this))
    {
      uint64_t v2 = *((void *)this + 21);
      if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 24))(v2)) {
        return 0;
      }
    }
    else
    {
      uint64_t v5 = *((void *)this + 23);
      if (v5 && (*(unsigned int (**)(uint64_t))(*(void *)v5 + 24))(v5)) {
        return 0;
      }
    }
  }
  else
  {
    uint64_t v4 = *((void *)this + 21);
    if (v4 && (*(unsigned int (**)(uint64_t))(*(void *)v4 + 24))(v4)) {
      return 0;
    }
  }
  return 35;
}

const char *BBUICE16UpdateSource::getDebugName(BBUICE16UpdateSource *this)
{
  return "BBUICE16UpdateSource";
}

uint64_t BBUICEUpdateSource::getShouldProgram(BBUICEUpdateSource *this)
{
  return 1;
}

uint64_t BBUICEUpdateSource::getCanProvision(BBUICEUpdateSource *this)
{
  return *((unsigned __int8 *)this + 120);
}

uint64_t BBUICEUpdateSource::getZipFile@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 72);
  *a2 = *(void *)(this + 64);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t BBUICE16UpdateSource::isBbcfgImageMandatory(BBUICE16UpdateSource *this)
{
  return 0;
}

void std::__shared_ptr_pointer<BBUZipFile *,std::shared_ptr<BBUZipFile>::__shared_ptr_default_delete<BBUZipFile,BBUZipFile>,std::allocator<BBUZipFile>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void std::__shared_ptr_pointer<BBUZipFile *,std::shared_ptr<BBUZipFile>::__shared_ptr_default_delete<BBUZipFile,BBUZipFile>,std::allocator<BBUZipFile>>::__on_zero_shared(uint64_t a1)
{
  int v1 = *(BBUZipFile **)(a1 + 24);
  if (v1)
  {
    BBUZipFile::~BBUZipFile(v1);
    operator delete(v2);
  }
}

uint64_t std::__shared_ptr_pointer<BBUZipFile *,std::shared_ptr<BBUZipFile>::__shared_ptr_default_delete<BBUZipFile,BBUZipFile>,std::allocator<BBUZipFile>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFABB52) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFABB52 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFABB52)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFABB52 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::pointer begin = this->__begin_;
  std::__split_buffer<std::string>::pointer end = this->__end_;
  if (end != begin)
  {
    do
    {
      std::__split_buffer<std::string>::pointer v4 = end - 1;
      this->__end_ = end - 1;
      if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v4->__r_.__value_.__l.__data_);
        std::__split_buffer<std::string>::pointer v4 = this->__end_;
      }
      std::__split_buffer<std::string>::pointer end = v4;
    }
    while (v4 != begin);
  }
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void *std::vector<std::shared_ptr<BBUICENVMImage>>::__push_back_slow_path<std::shared_ptr<BBUICENVMImage> const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)a1;
  std::__split_buffer<std::string>::pointer v4 = *(void **)(a1 + 8);
  uint64_t v5 = ((uint64_t)v4 - *(void *)a1) >> 4;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 60) {
    std::vector<std::string>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = *(void *)(a1 + 16) - (void)v3;
  if (v8 >> 3 > v6) {
    unint64_t v6 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v6 = 0xFFFFFFFFFFFFFFFLL;
  }
  if (v6 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v11 = 16 * v6;
  uint64_t v12 = (char *)operator new(16 * v6);
  uint64_t v13 = &v12[16 * v5];
  *(void *)uint64_t v13 = a2;
  *((void *)v13 + 1) = a3;
  if (a3)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void **)a1;
    std::__split_buffer<std::string>::pointer v4 = *(void **)(a1 + 8);
  }
  uint64_t v14 = &v12[v11];
  uint64_t v15 = v13 + 16;
  if (v4 == v3)
  {
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v14;
  }
  else
  {
    do
    {
      long long v16 = *((_OWORD *)v4 - 1);
      v4 -= 2;
      *((_OWORD *)v13 - 1) = v16;
      v13 -= 16;
      void *v4 = 0;
      v4[1] = 0;
    }
    while (v4 != v3);
    uint64_t v3 = *(void **)a1;
    uint64_t v17 = *(void **)(a1 + 8);
    *(void *)a1 = v13;
    *(void *)(a1 + 8) = v15;
    for (*(void *)(a1 + 16) = v14; v17 != v3; v17 -= 2)
    {
      uint64_t v18 = (std::__shared_weak_count *)*(v17 - 1);
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
  }
  if (v3) {
    operator delete(v3);
  }
  return v15;
}

void std::__shared_ptr_pointer<BBUICENVMImage *,std::shared_ptr<BBUICENVMImage>::__shared_ptr_default_delete<BBUICENVMImage,BBUICENVMImage>,std::allocator<BBUICENVMImage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<BBUICENVMImage *,std::shared_ptr<BBUICENVMImage>::__shared_ptr_default_delete<BBUICENVMImage,BBUICENVMImage>,std::allocator<BBUICENVMImage>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<BBUICENVMImage *,std::shared_ptr<BBUICENVMImage>::__shared_ptr_default_delete<BBUICENVMImage,BBUICENVMImage>,std::allocator<BBUICENVMImage>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFABC19) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFABC19 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFABC19)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFABC19 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__shared_ptr_pointer<BBUICEMRCImage *,std::shared_ptr<BBUICEMRCImage>::__shared_ptr_default_delete<BBUICEMRCImage,BBUICEMRCImage>,std::allocator<BBUICEMRCImage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<BBUICEMRCImage *,std::shared_ptr<BBUICEMRCImage>::__shared_ptr_default_delete<BBUICEMRCImage,BBUICEMRCImage>,std::allocator<BBUICEMRCImage>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<BBUICEMRCImage *,std::shared_ptr<BBUICEMRCImage>::__shared_ptr_default_delete<BBUICEMRCImage,BBUICEMRCImage>,std::allocator<BBUICEMRCImage>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFABCE4) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFABCE4 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFABCE4)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFABCE4 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__shared_ptr_pointer<BBUICEBinaryImage *,std::shared_ptr<BBUICEBinaryImage>::__shared_ptr_default_delete<BBUICEBinaryImage,BBUICEBinaryImage>,std::allocator<BBUICEBinaryImage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<BBUICEBinaryImage *,std::shared_ptr<BBUICEBinaryImage>::__shared_ptr_default_delete<BBUICEBinaryImage,BBUICEBinaryImage>,std::allocator<BBUICEBinaryImage>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<BBUICEBinaryImage *,std::shared_ptr<BBUICEBinaryImage>::__shared_ptr_default_delete<BBUICEBinaryImage,BBUICEBinaryImage>,std::allocator<BBUICEBinaryImage>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFABDB2) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFABDB2 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFABDB2)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFABDB2 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__shared_ptr_pointer<BBUICEDownloadImage *,std::shared_ptr<BBUICEDownloadImage>::__shared_ptr_default_delete<BBUICEDownloadImage,BBUICEDownloadImage>,std::allocator<BBUICEDownloadImage>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<BBUICEDownloadImage *,std::shared_ptr<BBUICEDownloadImage>::__shared_ptr_default_delete<BBUICEDownloadImage,BBUICEDownloadImage>,std::allocator<BBUICEDownloadImage>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<BBUICEDownloadImage *,std::shared_ptr<BBUICEDownloadImage>::__shared_ptr_default_delete<BBUICEDownloadImage,BBUICEDownloadImage>,std::allocator<BBUICEDownloadImage>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFABE85) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFABE85 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFABE85)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFABE85 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

void std::__tree<std::__value_type<std::string,__CFData const*>,std::__map_value_compare<std::string,std::__value_type<std::string,__CFData const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,__CFData const*>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,__CFData const*>,std::__map_value_compare<std::string,std::__value_type<std::string,__CFData const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,__CFData const*>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<std::string,__CFData const*>,std::__map_value_compare<std::string,std::__value_type<std::string,__CFData const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,__CFData const*>>>::destroy(a1, *((void *)a2 + 1));
    if (a2[55] < 0)
    {
      operator delete(*((void **)a2 + 4));
      std::__split_buffer<std::string>::pointer v4 = a2;
    }
    else
    {
      std::__split_buffer<std::string>::pointer v4 = a2;
    }
    operator delete(v4);
  }
}

void ctu::cf::_Applier_InsertMapDefault<std::string,__CFData const*,std::insert_iterator<std::map<std::string,__CFData const*>>>(uint64_t a1, const void *a2, uint64_t a3)
{
  *(_OWORD *)uint64_t v12 = 0u;
  long long v13 = 0u;
  if (!ctu::cf::assign()) {
    goto LABEL_14;
  }
  if (a2)
  {
    CFTypeID v5 = CFGetTypeID(a2);
    if (v5 == CFDataGetTypeID()) {
      *((void *)&v13 + 1) = a2;
    }
  }
  if (SBYTE7(v13) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v12[0], (std::string::size_type)v12[1]);
  }
  else
  {
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)v12;
    __p.__r_.__value_.__r.__words[2] = v13;
  }
  uint64_t v11 = *((void *)&v13 + 1);
  unint64_t v6 = std::__tree<std::__value_type<std::string,__CFData const*>,std::__map_value_compare<std::string,std::__value_type<std::string,__CFData const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,__CFData const*>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,__CFData const*>>(*(uint64_t ***)a3, *(uint64_t **)(a3 + 8), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&__p);
  *(void *)(a3 + 8) = v6;
  uint64_t v7 = (void *)v6[1];
  if (v7)
  {
    do
    {
      uint64_t v8 = v7;
      uint64_t v7 = (void *)*v7;
    }
    while (v7);
  }
  else
  {
    do
    {
      uint64_t v8 = (void *)v6[2];
      BOOL v9 = *v8 == (void)v6;
      unint64_t v6 = v8;
    }
    while (!v9);
  }
  *(void *)(a3 + 8) = v8;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_14:
    if ((SBYTE7(v13) & 0x80000000) == 0) {
      return;
    }
LABEL_17:
    operator delete(v12[0]);
    return;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SBYTE7(v13) < 0) {
    goto LABEL_17;
  }
}

void sub_21DEFC468(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *std::__tree<std::__value_type<std::string,__CFData const*>,std::__map_value_compare<std::string,std::__value_type<std::string,__CFData const*>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,__CFData const*>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,__CFData const*>>(uint64_t **a1, uint64_t *a2, const void **a3, uint64_t a4)
{
  uint64_t v14 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unint64_t v6 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1, a2, &v15, &v14, a3);
  if (*v6) {
    return (void *)*v6;
  }
  uint64_t v8 = v6;
  BOOL v9 = operator new(0x40uLL);
  char v10 = (std::string *)(v9 + 4);
  if (*(char *)(a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a4;
    void v9[6] = *(void *)(a4 + 16);
  }
  v9[7] = *(void *)(a4 + 24);
  uint64_t v11 = v15;
  *BOOL v9 = 0;
  v9[1] = 0;
  void v9[2] = v11;
  *uint64_t v8 = (uint64_t)v9;
  uint64_t v12 = (uint64_t *)**a1;
  long long v13 = v9;
  if (v12)
  {
    *a1 = v12;
    long long v13 = (uint64_t *)*v8;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v13);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v9;
}

void sub_21DEFC5AC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(a1, *(void *)a2);
    std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::destroy(a1, *((void *)a2 + 1));
    std::__split_buffer<std::string>::pointer v4 = (void *)*((void *)a2 + 7);
    if (v4)
    {
      *((void *)a2 + 8) = v4;
      operator delete(v4);
    }
    if (a2[55] < 0)
    {
      operator delete(*((void **)a2 + 4));
      CFTypeID v5 = a2;
    }
    else
    {
      CFTypeID v5 = a2;
    }
    operator delete(v5);
  }
}

uint64_t **std::__tree<std::__value_type<std::string,std::vector<unsigned char>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<unsigned char>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<unsigned char>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *((char *)a2 + 23);
    if (v8 >= 0) {
      BOOL v9 = a2;
    }
    else {
      BOOL v9 = *a2;
    }
    if (v8 >= 0) {
      size_t v10 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v10 = (size_t)a2[1];
    }
    while (1)
    {
      uint64_t v11 = (uint64_t **)v6;
      uint64_t v14 = (const void *)v6[4];
      uint64_t v12 = v6 + 4;
      long long v13 = v14;
      int v15 = *((char *)v12 + 23);
      if (v15 >= 0) {
        long long v16 = v12;
      }
      else {
        long long v16 = v13;
      }
      if (v15 >= 0) {
        size_t v17 = *((unsigned __int8 *)v12 + 23);
      }
      else {
        size_t v17 = v12[1];
      }
      if (v17 >= v10) {
        size_t v18 = v10;
      }
      else {
        size_t v18 = v17;
      }
      int v19 = memcmp(v9, v16, v18);
      if (v19)
      {
        if (v19 < 0) {
          goto LABEL_8;
        }
LABEL_22:
        int v20 = memcmp(v16, v9, v18);
        if (v20)
        {
          if ((v20 & 0x80000000) == 0) {
            return v11;
          }
        }
        else if (v17 >= v10)
        {
          return v11;
        }
        unint64_t v6 = v11[1];
        if (!v6)
        {
          uint64_t v7 = v11 + 1;
          goto LABEL_29;
        }
      }
      else
      {
        if (v10 >= v17) {
          goto LABEL_22;
        }
LABEL_8:
        unint64_t v6 = *v11;
        uint64_t v7 = v11;
        if (!*v11) {
          goto LABEL_29;
        }
      }
    }
  }
  uint64_t v11 = a1 + 1;
LABEL_29:
  uint64_t v21 = operator new(0x50uLL);
  uint64_t v22 = (std::string *)(v21 + 4);
  uint64_t v23 = *a4;
  if (*((char *)*a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v22, *(const std::string::value_type **)v23, *((void *)v23 + 1));
  }
  else
  {
    long long v24 = *v23;
    v21[6] = *((void *)v23 + 2);
    *(_OWORD *)&v22->__r_.__value_.__l.__data_ = v24;
  }
  v21[7] = 0;
  v21[8] = 0;
  v21[9] = 0;
  void *v21 = 0;
  v21[1] = 0;
  v21[2] = v11;
  *uint64_t v7 = v21;
  long long v25 = (uint64_t *)**a1;
  uint64_t v26 = v21;
  if (v25)
  {
    *a1 = v25;
    uint64_t v26 = *v7;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v26);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v21;
}

void sub_21DEFC7D4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t __cxx_global_var_init_7()
{
  {
    return __cxa_atexit((void (*)(void *))ctu::PthreadMutexGuardPolicy<BBUPartitionManager>::~PthreadMutexGuardPolicy, &ctu::Singleton<BBUPartitionManager,BBUPartitionManager,ctu::PthreadMutexGuardPolicy<BBUPartitionManager>>::sInstance, &dword_21DE8A000);
  }
  return result;
}

char *BBUEUR16UpdateSource::copyHashData(BBUEUR16UpdateSource *this, int a2)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  if (a2)
  {
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __src[0] = v3;
    __src[1] = v3;
    v79[0] = v3;
    v79[1] = v3;
    v78[0] = v3;
    v78[1] = v3;
    v77[0] = v3;
    v77[1] = v3;
    v76[0] = v3;
    v76[1] = v3;
    v75[0] = v3;
    v75[1] = v3;
    v74[0] = v3;
    v74[1] = v3;
    v73[0] = v3;
    v73[1] = v3;
    v72[0] = v3;
    v72[1] = v3;
    uint64_t v4 = *((void *)this + 28);
    if (!v4)
    {
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 89, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x32u, (ctu::LogMessageBuffer *)"Assertion failure(fSBLImage && \"Failed loading SBL image for creating hash.\")", v37, v38, v39, v72[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v4 + 56))(v4, __src, 0);
    uint64_t v5 = *((void *)this + 29);
    if (!v5)
    {
      uint64_t v40 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v40, 90, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x35u, (ctu::LogMessageBuffer *)"Assertion failure(fRPMImage && \"Failed loading RPM image for creating hash.\")", v41, v42, v43, v72[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v5 + 56))(v5, v79, 0);
    uint64_t v6 = *((void *)this + 30);
    if (!v6)
    {
      uint64_t v44 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v44, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x38u, (ctu::LogMessageBuffer *)"Assertion failure(fAppsImage && \"Failed loading Apps image for creating hash.\")", v45, v46, v47, v72[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v6 + 56))(v6, v78, 0);
    uint64_t v7 = *((void *)this + 32);
    if (!v7)
    {
      unsigned int v48 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v48, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x3Bu, (ctu::LogMessageBuffer *)"Assertion failure(fMBAImage && \"Failed loading MBA image for creating hash.\")", v49, v50, v51, v72[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v7 + 56))(v7, v77, 0);
    uint64_t v8 = *((void *)this + 33);
    if (!v8)
    {
      long long v52 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v52, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x3Eu, (ctu::LogMessageBuffer *)"Assertion failure(fQDSP6SWImage && \"Failed loading QDSP6SW image for creating hash.\")", v53, v54, v55, v72[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v8 + 56))(v8, v76, 0);
    uint64_t v9 = *((void *)this + 34);
    if (!v9)
    {
      char v56 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v56, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x41u, (ctu::LogMessageBuffer *)"Assertion failure(fTZImage && \"Failed loading TZI image for creating hash.\")", v57, v58, v59, v72[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v9 + 56))(v9, v75, 0);
    uint64_t v10 = *((void *)this + 29);
    if (!v10)
    {
      uint64_t v60 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v60, 90, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x44u, (ctu::LogMessageBuffer *)"Assertion failure(fRPMImage && \"Failed loading RPM image for creating hash.\")", v61, v62, v63, v72[0]);
    }
    (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v10 + 56))(v10, v74, 0);
    uint64_t v11 = *((void *)this + 40);
    if (!v11)
    {
      uint64_t v64 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v64, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x47u, (ctu::LogMessageBuffer *)"Assertion failure(fAcdbImage && \"Failed loading ACDB image for creating hash.\")", v65, v66, v67, v72[0]);
    }
    uint64_t v12 = (capabilities::updater *)(*(uint64_t (**)(uint64_t, _OWORD *, void))(*(void *)v11 + 56))(v11, v73, 0);
    if (capabilities::updater::supportsBbcfgImage(v12))
    {
      uint64_t v13 = *((void *)this + 41);
      if (!v13)
      {
        char v68 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v68, 92, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x4Cu, (ctu::LogMessageBuffer *)"Assertion failure(fBbcfgImage && \"Failed loading BBCFG image for creating hash.\")", v69, v70, v71, v72[0]);
      }
      (*(void (**)(uint64_t, _OWORD *, void))(*(void *)v13 + 56))(v13, v72, 0);
    }
    uint64_t v14 = (char *)operator new(0x148uLL);
    *(void *)uint64_t v14 = &unk_26CECA848;
    size_t v15 = off_26CECA868((BBUEURHashData *)v14);
    memcpy(v14 + 8, __src, v15);
    size_t v16 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    memcpy(v14 + 40, v79, v16);
    size_t v17 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    memcpy(v14 + 72, v78, v17);
    size_t v18 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 104, v18);
    size_t v19 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    memcpy(v14 + 136, v77, v19);
    size_t v20 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    memcpy(v14 + 168, v76, v20);
    size_t v21 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    memcpy(v14 + 200, v75, v21);
    size_t v22 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 232, v22);
    size_t v23 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    memcpy(v14 + 264, v73, v23);
    size_t v24 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    memcpy(v14 + 296, v72, v24);
  }
  else
  {
    uint64_t v14 = (char *)operator new(0x148uLL);
    *(void *)uint64_t v14 = &unk_26CECA848;
    size_t v25 = off_26CECA868((BBUEURHashData *)v14);
    bzero(v14 + 8, v25);
    size_t v26 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 40, v26);
    size_t v27 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 72, v27);
    size_t v28 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 104, v28);
    size_t v29 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 136, v29);
    size_t v30 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 168, v30);
    size_t v31 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 200, v31);
    size_t v32 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 232, v32);
    size_t v33 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 264, v33);
    size_t v34 = (*(uint64_t (**)(char *))(*(void *)v14 + 32))(v14);
    bzero(v14 + 296, v34);
  }
  return v14;
}

void sub_21DEFD19C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD1B0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD1C4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD1D8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD1EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD200(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD214(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD228(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD23C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD250(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_21DEFD264(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUEUR16UpdateSource::validateBootupItems(BBUEUR16UpdateSource *this)
{
  uint64_t v2 = *((void *)this + 28);
  if (!v2) {
    return 35;
  }
  long long v3 = (capabilities::updater *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 64))(v2);
  if (!v3) {
    return 35;
  }
  if (*((void *)this + 29)
    && *((void *)this + 30)
    && *((void *)this + 32)
    && *((void *)this + 33)
    && *((void *)this + 34)
    && *((void *)this + 40))
  {
    uint64_t result = capabilities::updater::supportsBbcfgImage(v3);
    if (!result) {
      return result;
    }
    if (*((void *)this + 41)) {
      return 0;
    }
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    uint64_t result = 35;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return result;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t result = 35;
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return result;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v5 = (const char *)(**(uint64_t (***)(BBUEUR16UpdateSource *))this)(this);
    _BBULog(3, 0, v5, "", "Baseband FW isn't complete. You are missing some images!\n", v6, v7, v8, v9);
    return 35;
  }
  return result;
}

uint64_t BBUEUR16UpdateSource::saveImages(BBUEUR16UpdateSource *this)
{
  if (!*((void *)this + 8))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x80u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"Firmware data source error!\")", v16, v17, v18, (char)__p[0]);
  }
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  uint64_t v2 = (const char *)(**(uint64_t (***)(BBUEUR16UpdateSource *))this)(this);
  uint64_t v6 = (capabilities::radio *)_BBULog(19, 0xFFFFFFFFLL, v2, "", "BBUEUR16UpdateSource::saveImages\n", v3, v4, v5, (char)__p[0]);
  memset(v25, 170, sizeof(v25));
  capabilities::radio::personalizedFirmwarePath((uint64_t *)v25, v6);
  uint64_t v7 = (void *)HIBYTE(v25[2]);
  if (SHIBYTE(v25[2]) < 0) {
    uint64_t v7 = v25[1];
  }
  if (!v7)
  {
    size_t v19 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v19, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/Eureka/BBUEUR16UpdateSource.cpp", 0x85u, (ctu::LogMessageBuffer *)"Assertion failure(folder.empty() != true && \"Failed finding the bbfw path.\")", v20, v21, v22, (char)__p[0]);
  }
  uint64_t v8 = BBUEURUpdateSource::saveImages(this);
  if (!v8)
  {
    char v24 = 8;
    strcpy((char *)__p, "sbl1.mbn");
    uint64_t v9 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
    uint64_t v8 = v9;
    if (v24 < 0)
    {
      operator delete(__p[0]);
      if (v8) {
        goto LABEL_41;
      }
    }
    else if (v9)
    {
      goto LABEL_41;
    }
    char v24 = 7;
    strcpy((char *)__p, "rpm.mbn");
    uint64_t v10 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
    uint64_t v8 = v10;
    if (v24 < 0)
    {
      operator delete(__p[0]);
      if (v8) {
        goto LABEL_41;
      }
    }
    else if (v10)
    {
      goto LABEL_41;
    }
    char v24 = 8;
    strcpy((char *)__p, "apps.mbn");
    uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
    if (v24 < 0) {
      operator delete(__p[0]);
    }
    if (!v8)
    {
      char v24 = 11;
      strcpy((char *)__p, "qdsp6sw.mbn");
      uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (!v8)
      {
        char v24 = 7;
        strcpy((char *)__p, "mba.mbn");
        uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
        if (v24 < 0) {
          operator delete(__p[0]);
        }
        if (!v8)
        {
          char v24 = 6;
          strcpy((char *)__p, "tz.mbn");
          uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
          if (v24 < 0) {
            operator delete(__p[0]);
          }
          if (!v8)
          {
            char v24 = 8;
            strcpy((char *)__p, "acdb.mbn");
            uint64_t v11 = (capabilities::updater *)BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
            uint64_t v8 = (uint64_t)v11;
            if (v24 < 0) {
              operator delete(__p[0]);
            }
            if (!v8)
            {
              if ((capabilities::updater::supportsBbcfgImage(v11) & 1) == 0)
              {
                uint64_t v12 = *((void *)this + 8);
                char v24 = 9;
                strcpy((char *)__p, "bbcfg.mbn");
                if (!BBUZipFile::containsFile(v12, __p)) {
                  goto LABEL_36;
                }
              }
              char v24 = 9;
              strcpy((char *)__p, "bbcfg.mbn");
              uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
              if (v24 < 0) {
                operator delete(__p[0]);
              }
              if (!v8)
              {
LABEL_36:
                uint64_t v13 = *((void *)this + 8);
                (*(void (**)(void **__return_ptr, BBUEUR16UpdateSource *))(*(void *)this + 56))(__p, this);
                uint64_t v8 = BBUZipFile::containsFile(v13, __p);
                if (v24 < 0) {
                  operator delete(__p[0]);
                }
                if (v8)
                {
                  (*(void (**)(void **__return_ptr, BBUEUR16UpdateSource *))(*(void *)this + 56))(__p, this);
                  uint64_t v8 = BBUEURUpdateSource::saveFile((uint64_t)this, (uint64_t)__p, (uint64_t)v25);
                  if (v24 < 0) {
                    operator delete(__p[0]);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_41:
  if (SHIBYTE(v25[2]) < 0) {
    operator delete(v25[0]);
  }
  return v8;
}

void sub_21DEFD894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a20 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a20 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a15);
  _Unwind_Resume(exception_object);
}

const char *BBUEUR16UpdateSource::getDebugName(BBUEUR16UpdateSource *this)
{
  return "BBUEUR16UpdateSource";
}

void BBUEUR16UpdateSource::~BBUEUR16UpdateSource(BBUEUR16UpdateSource *this)
{
  BBUEUR10UpdateSource::~BBUEUR10UpdateSource(this);

  operator delete(v1);
}

uint64_t BBUEUR3Fusing::writeFuse(unsigned char *a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v13[14] = v2;
  _OWORD v13[15] = v2;
  v13[12] = v2;
  v13[13] = v2;
  v13[10] = v2;
  v13[11] = v2;
  v13[8] = v2;
  _OWORD v13[9] = v2;
  v13[6] = v2;
  v13[7] = v2;
  _OWORD v13[4] = v2;
  v13[5] = v2;
  void v13[2] = v2;
  _OWORD v13[3] = v2;
  v13[0] = v2;
  v13[1] = v2;
  TelephonyUtilLogBinaryToBuffer();
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v3 = (const char *)(*(uint64_t (**)(unsigned char *))(*(void *)a1 + 32))(a1);
    _BBULog(13, 0, v3, "", "%s\n", v4, v5, v6, (char)v13);
  }
LABEL_5:
  if (a1[24]) {
    return 1;
  }
  (*(void (**)(unsigned char *))(*(void *)a1 + 48))(a1);
  if (ETLFusingProgramQfpromFuse()) {
    return 1;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    uint64_t result = 0;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      return result;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t result = 0;
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      return result;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v8 = (const char *)(*(uint64_t (**)(unsigned char *))(*(void *)a1 + 32))(a1);
    _BBULog(13, 0, v8, "", "ETLFusingProgramQfpromFuse failed\n", v9, v10, v11, v12);
    return 0;
  }
  return result;
}

uint64_t BBUEUR3Fusing::readFuse(uint64_t a1, char a2, void *a3, unsigned int a4)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (gBBULogMaskGet(void)::once != -1) {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  }
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) != 0 && (gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v8 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    _BBULog(13, 0, v8, "", "FuseID %d\n", v9, v10, v11, a2);
  }
  memset(__src, 0, 256);
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  uint64_t QfpromFuse = ETLFusingReadQfpromFuse();
  if (QfpromFuse)
  {
    TelephonyUtilLogBinaryToBuffer();
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) != 0) {
        goto LABEL_9;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) != 0)
      {
LABEL_9:
        if ((gBBULogVerbosity & 0x80000000) == 0)
        {
          uint64_t v13 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
          _BBULog(13, 0, v13, "", "Received (%u) %d: %s\n", v14, v15, v16, 170);
        }
      }
    }
    if (a4 <= 0xAAAAAAAA) {
      size_t v17 = a4;
    }
    else {
      size_t v17 = 2863311530;
    }
    memcpy(a3, __src, v17);
    return QfpromFuse;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      return QfpromFuse;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      return QfpromFuse;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v18 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
    _BBULog(13, 0, v18, "", "ETLFusingReadQfpromFuse failed\n", v19, v20, v21, v23);
  }
  return QfpromFuse;
}

uint64_t BBUEUR3Fusing::processFusedItem(uint64_t a1, CFArrayRef *this, CFIndex a3, uint64_t a4)
{
  int v5 = a3;
  uint64_t v72 = *MEMORY[0x263EF8340];
  unsigned int v38 = -1431655766;
  *(void *)uint64_t v36 = 0;
  uint64_t v37 = (__CFString *)0xAAAAAAAAAAAAAAAALL;
  memset(v71, 0, sizeof(v71));
  if ((BBUpdaterFusingProgram::copyFuseItem(this, a3, (ctu::cf *)&v36[1], v36, (const __CFString **)&v37, (unsigned __int8 *)v71, 0x80u, (ctu::cf *)&v38) & 1) == 0)
  {
    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 8), "Failed to copy fuse item %u", v5);
    goto LABEL_57;
  }
  if ((v36[1] & 0x80000000) != 0)
  {
    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 8), "Fuse ID invalid %d", v36[1]);
    goto LABEL_57;
  }
  if (!v37)
  {
    BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 8), "No fuse name - malformed fusing program?");
    goto LABEL_57;
  }
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v40 = 0;
  int v8 = ctu::cf::assign();
  if (v8)
  {
    uint64_t v9 = __p;
    if (SBYTE7(v40) < 0) {
      uint64_t v9 = (void **)__p[0];
    }
    BBUFeedback::handleBeginPhase(*(BBUFeedback **)(a1 + 8), "Writing Fuse %d(%s) length %u", v36[1], (const char *)v9, v38);
  }
  if (SBYTE7(v40) < 0)
  {
    operator delete(__p[0]);
    if (v38) {
      int v11 = v8;
    }
    else {
      int v11 = 0;
    }
    if (v11 == 1)
    {
LABEL_13:
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      *(_OWORD *)std::string __p = 0u;
      if (v36[1] == 107) {
        strcpy((char *)__p, "monkey");
      }
      else {
        TelephonyUtilBinToHex();
      }
      BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 8), "Value: '%s'", (const char *)__p);
      if (*(char *)(a1 + 55) < 0)
      {
        uint64_t v14 = &unk_26AA8F000;
        uint64_t v15 = &unk_26AA8F000;
        if (*(void *)(a1 + 40)) {
          goto LABEL_35;
        }
      }
      else
      {
        uint64_t v14 = (void *)&unk_26AA8F000;
        uint64_t v15 = (void *)&unk_26AA8F000;
        if (*(unsigned char *)(a1 + 55))
        {
LABEL_35:
          if (*(char *)(a1 + 79) < 0)
          {
            if (*(void *)(a1 + 64)) {
              goto LABEL_45;
            }
          }
          else if (*(unsigned char *)(a1 + 79))
          {
LABEL_45:
            if (v14[406] == -1)
            {
              if ((*(unsigned char *)(v15[405] + 1) & 0x20) == 0) {
                goto LABEL_49;
              }
            }
            else
            {
              dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
              if ((*(unsigned char *)(v15[405] + 1) & 0x20) == 0) {
                goto LABEL_49;
              }
            }
            if ((gBBULogVerbosity & 0x80000000) == 0)
            {
              char v24 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
              _BBULog(13, 0, v24, "", "Writing Fuse ID %u, Value Length %u\n", v25, v26, v27, v36[1]);
            }
LABEL_49:
            unsigned int v28 = v36[0];
            if ((*(uint64_t (**)(uint64_t, void, BOOL, _OWORD *, void, uint64_t))(*(void *)a1 + 64))(a1, v36[1], v36[0] != 0, v71, v38, a4))
            {
              if (*((_DWORD *)this + 7) > v5)
              {
                if (v14[406] == -1)
                {
                  if ((*(unsigned char *)(v15[405] + 1) & 0x20) == 0) {
                    goto LABEL_55;
                  }
                }
                else
                {
                  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
                  if ((*(unsigned char *)(v15[405] + 1) & 0x20) == 0) {
                    goto LABEL_55;
                  }
                }
                if ((gBBULogVerbosity & 0x80000000) == 0)
                {
                  size_t v29 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
                  _BBULog(13, 0, v29, "", "Verifying Fuse ID %u, Value Length %u\n", v30, v31, v32, v36[1]);
                }
LABEL_55:
                char v33 = (*(uint64_t (**)(uint64_t, void, BOOL, _OWORD *, void, uint64_t))(*(void *)a1 + 80))(a1, v36[1], v28 != 0, v71, v38, a4);
                uint64_t v12 = *(void *)(a1 + 8);
                if (v33) {
                  goto LABEL_61;
                }
                goto LABEL_23;
              }
              uint64_t v12 = *(void *)(a1 + 8);
LABEL_61:
              uint64_t v34 = 0;
              uint64_t v13 = 1;
              goto LABEL_59;
            }
LABEL_57:
            uint64_t v13 = 0;
            uint64_t v12 = *(void *)(a1 + 8);
            goto LABEL_58;
          }
          if (v36[1] != 105) {
            goto LABEL_45;
          }
          if (v14[406] == -1)
          {
            if ((*(unsigned char *)(v15[405] + 1) & 0x20) != 0) {
              goto LABEL_42;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            if ((*(unsigned char *)(v15[405] + 1) & 0x20) != 0)
            {
LABEL_42:
              if ((gBBULogVerbosity & 0x80000000) == 0)
              {
                uint64_t v20 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
                _BBULog(13, 0, v20, "", "Overriding PublicKeyHash as %s\n", v21, v22, v23, (char)__p);
              }
            }
          }
          std::string::__assign_external((std::string *)(a1 + 56), (const std::string::value_type *)__p);
          goto LABEL_45;
        }
      }
      if (v36[1] != 100) {
        goto LABEL_35;
      }
      if (v14[406] == -1)
      {
        if ((*(unsigned char *)(v15[405] + 1) & 0x20) != 0) {
          goto LABEL_32;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)(v15[405] + 1) & 0x20) != 0)
        {
LABEL_32:
          if ((gBBULogVerbosity & 0x80000000) == 0)
          {
            uint64_t v16 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
            _BBULog(13, 0, v16, "", "Overriding PublicKeyHash as %s\n", v17, v18, v19, (char)__p);
          }
        }
      }
      std::string::__assign_external((std::string *)(a1 + 32), (const std::string::value_type *)__p);
      goto LABEL_35;
    }
  }
  else
  {
    if (v38) {
      int v10 = v8;
    }
    else {
      int v10 = 0;
    }
    if (v10 == 1) {
      goto LABEL_13;
    }
  }
  uint64_t v12 = *(void *)(a1 + 8);
  if (v8) {
    goto LABEL_61;
  }
LABEL_23:
  uint64_t v13 = 0;
LABEL_58:
  uint64_t v34 = 12;
LABEL_59:
  (*(void (**)(uint64_t, uint64_t))(*(void *)v12 + 16))(v12, v34);
  return v13;
}

void sub_21DEFE51C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBUEUR3Fusing::processFusedArray(BBUFeedback **a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v6 = *(const __CFArray **)(a2 + 16);
  if (v6)
  {
    int Count = CFArrayGetCount(v6);
    if (gBBULogMaskGet(void)::once == -1) {
      goto LABEL_3;
    }
LABEL_12:
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
      goto LABEL_6;
    }
    goto LABEL_4;
  }
  int Count = 0;
  if (gBBULogMaskGet(void)::once != -1) {
    goto LABEL_12;
  }
LABEL_3:
  if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
    goto LABEL_6;
  }
LABEL_4:
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    int v8 = (const char *)(*((uint64_t (**)(BBUFeedback **))*a1 + 4))(a1);
    _BBULog(13, 0, v8, "", "Number of fuses %d\n", v9, v10, v11, Count);
  }
LABEL_6:
  if (Count < 1) {
    return 1;
  }
  uint64_t v12 = 0;
  while (((*((uint64_t (**)(BBUFeedback **, uint64_t, uint64_t, uint64_t))*a1 + 11))(a1, a2, v12, a3) & 1) != 0)
  {
    uint64_t v12 = (v12 + 1);
    if (Count == v12) {
      return 1;
    }
  }
  BBUFeedback::handleComment(a1[1], "Fuse item %u failed", v12);
  return 0;
}

uint64_t BBUEUR3Fusing::performFusing(BBUFeedback **a1, uint64_t a2)
{
  BBUFeedback::handleBeginPhase(a1[1], "Fuse and verify");
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
  if (!v4)
  {
    BBUFeedback::handleComment(a1[1], "Error: No fusing program given");
    uint64_t v7 = 24;
    goto LABEL_15;
  }
  uint64_t v5 = (*((uint64_t (**)(BBUFeedback **, uint64_t))*a1 + 7))(a1, v4);
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 24, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/Eureka/BBUEUR3Fusing.cpp", 0x103u, (ctu::LogMessageBuffer *)"Assertion failure(parseObj && \"Error: unable to create fusing program.\")", v15, v16, v17, v18);
  }
  uint64_t v6 = v5;
  if (((*((uint64_t (**)(BBUFeedback **, uint64_t, BBUFeedback *))*a1 + 12))(a1, v5, a1[2]) & 1) == 0)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      uint64_t v7 = 24;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
        goto LABEL_10;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      uint64_t v7 = 24;
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x20) == 0) {
        goto LABEL_10;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      int v8 = (const char *)(*((uint64_t (**)(BBUFeedback **))*a1 + 4))(a1);
      _BBULog(13, 0, v8, "", "Failed to fuse baseband\n", v9, v10, v11, v18);
    }
    goto LABEL_10;
  }
  uint64_t v7 = 0;
LABEL_10:
  if (*(void *)v6) {
    CFRelease(*(CFTypeRef *)v6);
  }
  uint64_t v12 = *(const void **)(v6 + 16);
  if (v12) {
    CFRelease(v12);
  }
  operator delete((void *)v6);
LABEL_15:
  (*(void (**)(BBUFeedback *, uint64_t))(*(void *)a1[1] + 16))(a1[1], v7);
  return v7;
}

void sub_21DEFE900(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUEUR3Fusing::verifyFusing()
{
  return 0;
}

BBUpdaterFusingProgram *BBUEUR3Fusing::createFusingProgram(BBUEUR3Fusing *this, BBUDataSource *a2)
{
  uint64_t v3 = (BBUpdaterFusingProgram *)operator new(0x20uLL);
  BBUpdaterFusingProgram::BBUpdaterFusingProgram(v3, a2, v4, v5, v6, v7, v8, v9);
  return v3;
}

void sub_21DEFE958(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void BasebandBooter::BasebandBooter(BasebandBooter *this)
{
  *(void *)this = &unk_26CECB200;
}

void BasebandBooter::create(BasebandBooter *this@<X0>, void *a2@<X8>)
{
  long long v6 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v4 = 0u;
  long long v5 = 0u;
  long long v3 = 0u;
  long long v2 = &unk_26CECB230;
  BYTE8(v6) = 0;
  *a2 = 0;
  ACFULogging::getLogInstance(this);
  ACFULogging::handleMessage();
  BasebandBooterParams::~BasebandBooterParams((BasebandBooterParams *)&v2);
}

void sub_21DEFEA34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  void *v4 = 0;
  BasebandBooterParams::~BasebandBooterParams((BasebandBooterParams *)va);
  _Unwind_Resume(a1);
}

uint64_t BasebandBooter::create@<X0>(ACFULogging *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  ACFULogging::getLogInstance(a1);
  return ACFULogging::handleMessage();
}

void sub_21DEFEAA0(_Unwind_Exception *a1)
{
  *int v1 = 0;
  _Unwind_Resume(a1);
}

void BasebandBooterParams::~BasebandBooterParams(BasebandBooterParams *this)
{
  *(void *)this = &unk_26CECB230;
  if (!*((unsigned char *)this + 112)) {
    goto LABEL_5;
  }
  long long v2 = (void **)*((void *)this + 11);
  if (v2)
  {
    do
    {
      long long v4 = (void **)*v2;
      if (*((char *)v2 + 63) < 0)
      {
        operator delete(v2[5]);
        if (*((char *)v2 + 39) < 0) {
LABEL_15:
        }
          operator delete(v2[2]);
      }
      else if (*((char *)v2 + 39) < 0)
      {
        goto LABEL_15;
      }
      operator delete(v2);
      long long v2 = v4;
    }
    while (v4);
  }
  long long v3 = (void *)*((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v3) {
    operator delete(v3);
  }
LABEL_5:
  if (*((unsigned char *)this + 64) && *((char *)this + 63) < 0)
  {
    operator delete(*((void **)this + 5));
    if (!*((unsigned char *)this + 32)) {
      return;
    }
  }
  else if (!*((unsigned char *)this + 32))
  {
    return;
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t BBUEUR2HashData::compare(BBUEUR2HashData *this, BBUFeedback *a2, const BBUHashData *lpsrc)
{
  if (lpsrc) {
  else
  }
    long long v5 = 0;
  BOOL v6 = BBUHashData::compareHash(this, a2, (const unsigned __int8 *)this + 8, v5 + 8, "EDBL");
  BOOL v7 = BBUHashData::compareHash(this, a2, (const unsigned __int8 *)this + 40, v5 + 40, "OSBL");
  return (BBUHashData::compareHash(this, a2, (const unsigned __int8 *)this + 72, v5 + 72, "AMSS") && v7) & v6;
}

void BBUEUR2HashData::showHashes(BBUEUR2HashData *this, BBUFeedback *a2)
{
  std::string __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  (*(void (**)(BBUEUR2HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  BBUFeedback::handleComment(a2, "\t %s:  %s", "DBL_HASH", (const char *)&__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  (*(void (**)(BBUEUR2HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v8 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "OSBL_HASH", p_p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p);
  }
  std::string __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  (*(void (**)(BBUEUR2HashData *))(*(void *)this + 32))(this);
  ctu::assign();
  if (v8 >= 0) {
    long long v5 = (const char *)&__p;
  }
  else {
    long long v5 = (const char *)__p;
  }
  BBUFeedback::handleComment(a2, "\t %s:  %s", "AMSS_HASH", v5);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p);
  }
}

void sub_21DEFEE78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void BBUEURFirmwareVersion::~BBUEURFirmwareVersion(void **this)
{
  *this = &unk_26CECB2B8;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 47) & 0x80000000) == 0) {
        return;
      }
LABEL_7:
      operator delete(this[3]);
      return;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if (*((char *)this + 47) < 0) {
    goto LABEL_7;
  }
}

{
  BBUEURFirmwareVersion *v2;
  uint64_t vars8;

  *this = &unk_26CECB2B8;
  if (*((char *)this + 95) < 0)
  {
    operator delete(this[9]);
    if ((*((char *)this + 71) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 47) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((*((char *)this + 71) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[6]);
  if ((*((char *)this + 47) & 0x80000000) == 0)
  {
LABEL_4:
    long long v2 = (BBUEURFirmwareVersion *)this;
    goto LABEL_6;
  }
LABEL_9:
  operator delete(this[3]);
  long long v2 = (BBUEURFirmwareVersion *)this;

LABEL_6:
  operator delete(v2);
}

BOOL BBUEURFirmwareVersion::initCommon(uint64_t a1, uint64_t a2)
{
  memset(&__dst, 0, sizeof(__dst));
  memset(v60, 170, sizeof(v60));
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v59, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v59 = *(std::string *)a2;
  }
  ctu::tokenize();
  if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v59.__r_.__value_.__l.__data_);
  }
  long long v3 = (unsigned __int8 *)v60[0];
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v60[1] - v60[0]) >> 3) < 2) {
    goto LABEL_32;
  }
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 24))(__p, a1);
  uint64_t v4 = v3[23];
  if ((v4 & 0x80u) == 0) {
    long long v5 = (void *)v3[23];
  }
  else {
    long long v5 = (void *)*((void *)v3 + 1);
  }
  unint64_t v6 = v58;
  int v7 = (char)v58;
  if ((v58 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  if (v5 == (void *)v6)
  {
    if ((v58 & 0x80u) == 0) {
      uint64_t v8 = __p;
    }
    else {
      uint64_t v8 = (void **)__p[0];
    }
    if ((v4 & 0x80) != 0)
    {
      BOOL v16 = memcmp(*(const void **)v3, v8, *((void *)v3 + 1)) == 0;
      if ((v7 & 0x80000000) == 0) {
        goto LABEL_25;
      }
    }
    else if (v3[23])
    {
      uint64_t v9 = v4 - 1;
      do
      {
        int v11 = *v3++;
        int v10 = v11;
        int v13 = *(unsigned __int8 *)v8;
        uint64_t v8 = (void **)((char *)v8 + 1);
        int v12 = v13;
        BOOL v15 = v9-- != 0;
        BOOL v16 = v10 == v12;
      }
      while (v10 == v12 && v15);
      if (((char)v58 & 0x80000000) == 0)
      {
LABEL_25:
        long long v3 = (unsigned __int8 *)v60[0];
        if (v16) {
          goto LABEL_26;
        }
LABEL_32:
        if (v3)
        {
          char v18 = (unsigned __int8 *)v60[1];
          uint64_t v19 = v3;
          if ((unsigned __int8 *)v60[1] != v3)
          {
            do
            {
              if ((char)*(v18 - 1) < 0) {
                operator delete(*((void **)v18 - 3));
              }
              v18 -= 24;
            }
            while (v18 != v3);
            uint64_t v19 = (unsigned __int8 *)v60[0];
          }
          v60[1] = v3;
          goto LABEL_40;
        }
        goto LABEL_41;
      }
    }
    else
    {
      BOOL v16 = 1;
      if (((char)v58 & 0x80000000) == 0) {
        goto LABEL_25;
      }
    }
  }
  else
  {
    BOOL v16 = 0;
    if (((char)v58 & 0x80000000) == 0) {
      goto LABEL_25;
    }
  }
  operator delete(__p[0]);
  long long v3 = (unsigned __int8 *)v60[0];
  if (!v16) {
    goto LABEL_32;
  }
LABEL_26:
  if (&__dst != (std::string *)(v3 + 24))
  {
    signed __int8 v17 = v3[47];
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      if (v17 >= 0) {
        uint64_t v22 = v3 + 24;
      }
      else {
        uint64_t v22 = (void *)*((void *)v3 + 3);
      }
      if (v17 >= 0) {
        size_t v23 = v3[47];
      }
      else {
        size_t v23 = *((void *)v3 + 4);
      }
      std::string::__assign_no_alias<false>((void **)&__dst.__r_.__value_.__l.__data_, v22, v23);
    }
    else if ((v3[47] & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(&__dst, *((void **)v3 + 3), *((void *)v3 + 4));
    }
    else
    {
      std::string __dst = *(std::string *)(v3 + 1);
    }
    long long v3 = (unsigned __int8 *)v60[0];
  }
  if (v3)
  {
    char v24 = (unsigned __int8 *)v60[1];
    uint64_t v25 = v3;
    if ((unsigned __int8 *)v60[1] != v3)
    {
      do
      {
        if ((char)*(v24 - 1) < 0) {
          operator delete(*((void **)v24 - 3));
        }
        v24 -= 24;
      }
      while (v24 != v3);
      uint64_t v25 = (unsigned __int8 *)v60[0];
    }
    v60[1] = v3;
    operator delete(v25);
  }
  memset(v60, 170, sizeof(v60));
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v56, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v56 = __dst;
  }
  ctu::tokenize();
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v56.__r_.__value_.__l.__data_);
  }
  uint64_t v27 = (void **)v60[0];
  uint64_t v26 = (void **)v60[1];
  unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v60[1] - v60[0]) >> 3);
  if (v28 != 1)
  {
    if (v28 != 2)
    {
      if (!v60[0]) {
        goto LABEL_41;
      }
      if (v60[1] == v60[0]) {
        goto LABEL_130;
      }
      do
      {
        if (*((char *)v26 - 1) < 0) {
          operator delete(*(v26 - 3));
        }
        v26 -= 3;
      }
      while (v26 != v27);
      goto LABEL_129;
    }
    if (&__dst != (std::string *)v60[0])
    {
      char v29 = *(unsigned char *)(v60[0] + 23);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        if (v29 >= 0) {
          uint64_t v31 = (void *)v60[0];
        }
        else {
          uint64_t v31 = *(void **)v60[0];
        }
        if (v29 >= 0) {
          size_t v32 = *(unsigned __int8 *)(v60[0] + 23);
        }
        else {
          size_t v32 = *(void *)(v60[0] + 8);
        }
        std::string::__assign_no_alias<false>((void **)&__dst.__r_.__value_.__l.__data_, v31, v32);
      }
      else if ((*(unsigned char *)(v60[0] + 23) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(&__dst, *(void **)v60[0], *(void *)(v60[0] + 8));
      }
      else
      {
        long long v30 = *(_OWORD *)v60[0];
        __dst.__r_.__value_.__r.__words[2] = *(void *)(v60[0] + 16);
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v30;
      }
    }
    uint64_t v27 = (void **)v60[0];
    if (a1 != v60[0])
    {
      char v33 = (void **)(a1 + 24);
      char v34 = *(unsigned char *)(v60[0] + 47);
      if (*(char *)(a1 + 47) < 0)
      {
        if (v34 >= 0) {
          uint64_t v36 = (void *)(v60[0] + 24);
        }
        else {
          uint64_t v36 = *(void **)(v60[0] + 24);
        }
        if (v34 >= 0) {
          size_t v37 = *(unsigned __int8 *)(v60[0] + 47);
        }
        else {
          size_t v37 = *(void *)(v60[0] + 32);
        }
        std::string::__assign_no_alias<false>(v33, v36, v37);
      }
      else if ((*(unsigned char *)(v60[0] + 47) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(v33, *(void **)(v60[0] + 24), *(void *)(v60[0] + 32));
      }
      else
      {
        long long v35 = *(_OWORD *)(v60[0] + 24);
        *(void *)(a1 + 40) = *(void *)(v60[0] + 40);
        *(_OWORD *)char v33 = v35;
      }
      uint64_t v27 = (void **)v60[0];
    }
  }
  if (v27)
  {
    unsigned int v38 = (void **)v60[1];
    uint64_t v39 = v27;
    if ((void **)v60[1] != v27)
    {
      do
      {
        if (*((char *)v38 - 1) < 0) {
          operator delete(*(v38 - 3));
        }
        v38 -= 3;
      }
      while (v38 != v27);
      uint64_t v39 = (void **)v60[0];
    }
    v60[1] = v27;
    operator delete(v39);
  }
  memset(v60, 170, sizeof(v60));
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v55, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v55 = __dst;
  }
  ctu::tokenize();
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v55.__r_.__value_.__l.__data_);
  }
  uint64_t v27 = (void **)v60[0];
  uint64_t v26 = (void **)v60[1];
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v60[1] - v60[0]) >> 3);
  if (v40 != 1)
  {
    if (v40 == 2)
    {
      if (&__dst != (std::string *)v60[0])
      {
        char v41 = *(unsigned char *)(v60[0] + 23);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          if (v41 >= 0) {
            long long v43 = (void *)v60[0];
          }
          else {
            long long v43 = *(void **)v60[0];
          }
          if (v41 >= 0) {
            size_t v44 = *(unsigned __int8 *)(v60[0] + 23);
          }
          else {
            size_t v44 = *(void *)(v60[0] + 8);
          }
          std::string::__assign_no_alias<false>((void **)&__dst.__r_.__value_.__l.__data_, v43, v44);
        }
        else if ((*(unsigned char *)(v60[0] + 23) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(&__dst, *(void **)v60[0], *(void *)(v60[0] + 8));
        }
        else
        {
          long long v42 = *(_OWORD *)v60[0];
          __dst.__r_.__value_.__r.__words[2] = *(void *)(v60[0] + 16);
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v42;
        }
      }
      if (*(char *)(v60[0] + 47) >= 0) {
        long long v45 = (const char *)(v60[0] + 24);
      }
      else {
        long long v45 = *(const char **)(v60[0] + 24);
      }
      *(_DWORD *)(a1 + 20) = strtoul(v45, 0, 10);
      uint64_t v27 = (void **)v60[0];
      goto LABEL_143;
    }
    if (v60[0])
    {
      if (v60[1] == v60[0]) {
        goto LABEL_130;
      }
      do
      {
        if (*((char *)v26 - 1) < 0) {
          operator delete(*(v26 - 3));
        }
        v26 -= 3;
      }
      while (v26 != v27);
LABEL_129:
      uint64_t v26 = (void **)v60[0];
LABEL_130:
      v60[1] = v27;
      uint64_t v19 = (unsigned __int8 *)v26;
LABEL_40:
      operator delete(v19);
    }
LABEL_41:
    BOOL v20 = 0;
    goto LABEL_42;
  }
LABEL_143:
  if (v27)
  {
    long long v46 = (void **)v60[1];
    long long v47 = v27;
    if ((void **)v60[1] != v27)
    {
      do
      {
        if (*((char *)v46 - 1) < 0) {
          operator delete(*(v46 - 3));
        }
        v46 -= 3;
      }
      while (v46 != v27);
      long long v47 = (void **)v60[0];
    }
    v60[1] = v27;
    operator delete(v47);
  }
  memset(v60, 170, sizeof(v60));
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v54, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  }
  else {
    std::string v54 = __dst;
  }
  ctu::tokenize();
  if ((SHIBYTE(v54.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    uint64_t v48 = v60[0];
    BOOL v20 = v60[1] - v60[0] == 72;
    if (v60[1] - v60[0] == 72) {
      goto LABEL_156;
    }
LABEL_168:
    if (!v48) {
      goto LABEL_42;
    }
    goto LABEL_169;
  }
  operator delete(v54.__r_.__value_.__l.__data_);
  uint64_t v48 = v60[0];
  BOOL v20 = v60[1] - v60[0] == 72;
  if (v60[1] - v60[0] != 72) {
    goto LABEL_168;
  }
LABEL_156:
  if (*(char *)(v48 + 23) >= 0) {
    long long v49 = (const char *)v48;
  }
  else {
    long long v49 = *(const char **)v48;
  }
  *(_DWORD *)(a1 + 8) = strtoul(v49, 0, 10);
  if (*(char *)(v60[0] + 47) >= 0) {
    long long v50 = (const char *)(v60[0] + 24);
  }
  else {
    long long v50 = *(const char **)(v60[0] + 24);
  }
  *(_DWORD *)(a1 + 12) = strtoul(v50, 0, 10);
  if (*(char *)(v60[0] + 71) >= 0) {
    long long v51 = (const char *)(v60[0] + 48);
  }
  else {
    long long v51 = *(const char **)(v60[0] + 48);
  }
  *(_DWORD *)(a1 + 16) = strtoul(v51, 0, 10);
  uint64_t v48 = v60[0];
  if (!v60[0]) {
    goto LABEL_42;
  }
LABEL_169:
  uint64_t v52 = v60[1];
  long long v53 = (void *)v48;
  if (v60[1] != v48)
  {
    do
    {
      if (*(char *)(v52 - 1) < 0) {
        operator delete(*(void **)(v52 - 24));
      }
      v52 -= 24;
    }
    while (v52 != v48);
    long long v53 = (void *)v60[0];
  }
  v60[1] = v48;
  operator delete(v53);
LABEL_42:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v20;
}

void sub_21DEFF704(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  std::vector<std::string>::~vector[abi:ne180100]((void **)(v37 - 88));
  if (*(char *)(v37 - 41) < 0) {
    operator delete(*(void **)(v37 - 64));
  }
  _Unwind_Resume(a1);
}

BOOL BBUEURFirmwareVersion::initWithVersionString(char *a1, void **a2)
{
  v39[2] = *MEMORY[0x263EF8340];
  memset(__p, 0, sizeof(__p));
  uint64_t v4 = &v37;
  (*(void (**)(std::string *__return_ptr))(*(void *)a1 + 24))(&v37);
  int v5 = SHIBYTE(v37.__r_.__value_.__r.__words[2]);
  unint64_t v6 = (void *)v37.__r_.__value_.__r.__words[0];
  if ((v37.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
  {
    int64_t size = HIBYTE(v37.__r_.__value_.__r.__words[2]);
  }
  else
  {
    int64_t size = v37.__r_.__value_.__l.__size_;
    uint64_t v4 = (std::string *)v37.__r_.__value_.__r.__words[0];
  }
  if (!size)
  {
    uint64_t v8 = 0;
    if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_7;
    }
LABEL_20:
    operator delete(v6);
    if (v8) {
      goto LABEL_8;
    }
LABEL_21:
    if (__p != a2)
    {
      char v17 = *((unsigned char *)a2 + 23);
      if (SHIBYTE(__p[2]) < 0)
      {
        if (v17 >= 0) {
          size_t v23 = a2;
        }
        else {
          size_t v23 = *a2;
        }
        if (v17 >= 0) {
          size_t v24 = *((unsigned __int8 *)a2 + 23);
        }
        else {
          size_t v24 = (size_t)a2[1];
        }
        std::string::__assign_no_alias<false>(__p, v23, v24);
      }
      else if ((*((unsigned char *)a2 + 23) & 0x80) != 0)
      {
        std::string::__assign_no_alias<true>(__p, *a2, (size_t)a2[1]);
      }
      else
      {
        *(_OWORD *)std::string __p = *(_OWORD *)a2;
        __p[2] = a2[2];
      }
    }
    goto LABEL_46;
  }
  if (size <= 0)
  {
    char v18 = 0;
    int v19 = v4->__r_.__value_.__s.__data_[0];
    BOOL v20 = __p;
    do
    {
      if (&v18[-size] == (char *)-1) {
        break;
      }
      uint64_t v21 = (void **)memchr(v20, v19, (size_t)&v18[-size + 1]);
      if (!v21) {
        break;
      }
      uint64_t v22 = v21;
      if (!memcmp(v21, v4, size))
      {
        if (v22 == __p) {
          uint64_t v8 = -1;
        }
        else {
          uint64_t v8 = (char *)v22 - (char *)__p;
        }
        if ((v5 & 0x80000000) == 0) {
          goto LABEL_7;
        }
        goto LABEL_20;
      }
      BOOL v20 = (void **)((char *)v22 + 1);
      char v18 = (char *)((char *)__p - ((char *)v22 + 1));
    }
    while ((uint64_t)v18 >= size);
  }
  uint64_t v8 = -1;
  if (v5 < 0) {
    goto LABEL_20;
  }
LABEL_7:
  if (!v8) {
    goto LABEL_21;
  }
LABEL_8:
  (*(void (**)(std::string *__return_ptr, char *))(*(void *)a1 + 24))(&v36, a1);
  uint64_t v9 = std::string::append(&v36, " ", 1uLL);
  long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v37.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0;
  v9->__r_.__value_.__r.__words[2] = 0;
  v9->__r_.__value_.__r.__words[0] = 0;
  int v11 = *((char *)a2 + 23);
  if (v11 >= 0) {
    int v12 = (const std::string::value_type *)a2;
  }
  else {
    int v12 = (const std::string::value_type *)*a2;
  }
  if (v11 >= 0) {
    std::string::size_type v13 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    std::string::size_type v13 = (std::string::size_type)a2[1];
  }
  uint64_t v14 = std::string::append(&v37, v12, v13);
  BOOL v15 = (void *)v14->__r_.__value_.__r.__words[0];
  v39[0] = v14->__r_.__value_.__l.__size_;
  *(void *)((char *)v39 + 7) = *(std::string::size_type *)((char *)&v14->__r_.__value_.__r.__words[1] + 7);
  char v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = v15;
  __p[1] = (void *)v39[0];
  *(void **)((char *)&__p[1] + 7) = *(void **)((char *)v39 + 7);
  HIBYTE(__p[2]) = v16;
  if (SHIBYTE(v37.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v37.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v36.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_46;
    }
  }
  else if ((SHIBYTE(v36.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_46;
  }
  operator delete(v36.__r_.__value_.__l.__data_);
LABEL_46:
  int v25 = *((char *)a2 + 23);
  if (v25 >= 0) {
    size_t v26 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v26 = (size_t)a2[1];
  }
  unint64_t v27 = v26 + 16;
  memset(&v37, 170, sizeof(v37));
  if (v26 + 16 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v27 >= 0x17)
  {
    uint64_t v32 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v27 | 7) != 0x17) {
      uint64_t v32 = v27 | 7;
    }
    uint64_t v33 = v32 + 1;
    char v34 = operator new(v32 + 1);
    v37.__r_.__value_.__l.__size_ = v26 + 16;
    v37.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
    v37.__r_.__value_.__r.__words[0] = (std::string::size_type)v34;
    *char v34 = *(_OWORD *)"Version String: ";
    unint64_t v28 = (std::string::value_type *)(v34 + 1);
  }
  else
  {
    unint64_t v28 = &v37.__r_.__value_.__s.__data_[16];
    v37.__r_.__value_.__r.__words[2] = 0;
    *((unsigned char *)&v37.__r_.__value_.__s + 23) = v26 + 16;
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = *(_OWORD *)"Version String: ";
    if (!v26)
    {
      v37.__r_.__value_.__s.__data_[16] = 0;
      char v29 = (void **)(a1 + 48);
      if ((a1[71] & 0x80000000) == 0) {
        goto LABEL_53;
      }
      goto LABEL_63;
    }
  }
  if (v25 >= 0) {
    long long v35 = a2;
  }
  else {
    long long v35 = *a2;
  }
  memmove(v28, v35, v26);
  v28[v26] = 0;
  char v29 = (void **)(a1 + 48);
  if ((a1[71] & 0x80000000) == 0) {
    goto LABEL_53;
  }
LABEL_63:
  operator delete(*v29);
LABEL_53:
  *(std::string *)char v29 = v37;
  BOOL inited = BBUEURFirmwareVersion::initCommon((uint64_t)a1, (uint64_t)__p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  return inited;
}

void sub_21DEFFB7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if ((a15 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a28 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a15 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a10);
  if ((a28 & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(a23);
  _Unwind_Resume(exception_object);
}

BOOL BBUEURFirmwareVersion::initWithFolderName(uint64_t a1, uint64_t a2)
{
  int v2 = *(char *)(a2 + 23);
  if (v2 >= 0) {
    size_t v3 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v3 = *(void *)(a2 + 8);
  }
  unint64_t v4 = v3 + 8;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  if (v3 + 8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v4 >= 0x17)
  {
    uint64_t v10 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v10 = v4 | 7;
    }
    uint64_t v11 = v10 + 1;
    int v12 = operator new(v10 + 1);
    *int v12 = 0x203A7265646C6F46;
    int v7 = (char *)(v12 + 1);
    *((void *)&v14 + 1) = v3 + 8;
    unint64_t v15 = v11 | 0x8000000000000000;
    *(void *)&long long v14 = v12;
  }
  else
  {
    int v7 = (char *)&v14 + 8;
    unint64_t v15 = 0;
    HIBYTE(v15) = v3 + 8;
    long long v14 = 0x203A7265646C6F46uLL;
    if (!v3)
    {
      BYTE8(v14) = 0;
      uint64_t v8 = a1 + 48;
      if ((*(char *)(a1 + 71) & 0x80000000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_18;
    }
  }
  if (v2 >= 0) {
    std::string::size_type v13 = (const void *)a2;
  }
  else {
    std::string::size_type v13 = *(const void **)a2;
  }
  memmove(v7, v13, v3);
  v7[v3] = 0;
  uint64_t v8 = a1 + 48;
  if ((*(char *)(a1 + 71) & 0x80000000) == 0) {
    goto LABEL_8;
  }
LABEL_18:
  operator delete(*(void **)v8);
LABEL_8:
  *(_OWORD *)uint64_t v8 = v14;
  *(void *)(v8 + 16) = v15;

  return BBUEURFirmwareVersion::initCommon(a1, a2);
}

unsigned int *BBUEURFirmwareVersion::isNewerThan(_DWORD *a1, void *lpsrc)
{
  if (result)
  {
    unsigned int v4 = a1[2];
    unsigned int v5 = result[2];
    if (v4 >= v5)
    {
      if (v4 > v5) {
        return (unsigned int *)1;
      }
      unsigned int v6 = a1[3];
      unsigned int v7 = result[3];
      if (v6 < v7) {
        return 0;
      }
      if (v6 > v7) {
        return (unsigned int *)1;
      }
      unsigned int v8 = a1[4];
      unsigned int v9 = result[4];
      if (v8 < v9) {
        return 0;
      }
      if (v8 > v9) {
        return (unsigned int *)1;
      }
      else {
        return (unsigned int *)(a1[5] > (int)result[5]);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BBUEURFirmwareVersion::equals(uint64_t a1, void *lpsrc)
{
  if (result)
  {
    if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(result + 8))
    {
      if (*(_DWORD *)(a1 + 12) != *(_DWORD *)(result + 12)
        || *(_DWORD *)(a1 + 16) != *(_DWORD *)(result + 16)
        || *(_DWORD *)(a1 + 20) != *(_DWORD *)(result + 20))
      {
        return 0;
      }
      uint64_t v4 = *(unsigned __int8 *)(a1 + 47);
      if ((v4 & 0x80u) == 0) {
        uint64_t v5 = *(unsigned __int8 *)(a1 + 47);
      }
      else {
        uint64_t v5 = *(void *)(a1 + 32);
      }
      uint64_t v6 = *(unsigned __int8 *)(result + 47);
      int v7 = (char)v6;
      if ((v6 & 0x80u) != 0) {
        uint64_t v6 = *(void *)(result + 32);
      }
      if (v5 == v6)
      {
        unsigned int v8 = (const void **)(a1 + 24);
        uint64_t v11 = *(unsigned __int8 **)(result + 24);
        unsigned int v9 = (unsigned __int8 *)(result + 24);
        uint64_t v10 = v11;
        if (v7 >= 0) {
          int v12 = v9;
        }
        else {
          int v12 = v10;
        }
        if ((v4 & 0x80) != 0)
        {
          return memcmp(*v8, v12, *(void *)(a1 + 32)) == 0;
        }
        else if (*(unsigned char *)(a1 + 47))
        {
          uint64_t v13 = v4 - 1;
          do
          {
            int v15 = *(unsigned __int8 *)v8;
            unsigned int v8 = (const void **)((char *)v8 + 1);
            int v14 = v15;
            int v17 = *v12++;
            int v16 = v17;
            BOOL v19 = v13-- != 0;
            uint64_t result = v14 == v16;
          }
          while (v14 == v16 && v19);
        }
        else
        {
          return 1;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BBUEURFirmwareVersion::getAsFileName@<X0>(BBUEURFirmwareVersion *this@<X0>, std::string *a2@<X8>)
{
  unint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v32[7] = v4;
  v32[8] = v4;
  v32[5] = v4;
  v32[6] = v4;
  v32[3] = v4;
  v32[4] = v4;
  v32[1] = v4;
  v32[2] = v4;
  long long v31 = v4;
  v32[0] = v4;
  *(_OWORD *)std::string __p = v4;
  long long v30 = v4;
  long long v27 = v4;
  long long v28 = v4;
  long long v25 = v4;
  long long v26 = v4;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v25);
  uint64_t v5 = v25;
  uint64_t v6 = (char *)&v25 + *(void *)(v25 - 24);
  if (*((_DWORD *)v6 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)&v25 + *(void *)(v25 - 24)));
    int v7 = std::locale::use_facet((const std::locale *)&v24, MEMORY[0x263F8C108]);
    ((void (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 32);
    std::locale::~locale((std::locale *)&v24);
    uint64_t v5 = v25;
  }
  *((_DWORD *)v6 + 36) = 48;
  *(void *)((char *)&v26 + *(void *)(v5 - 24) + 8) = 2;
  std::ostream::operator<<();
  *(void *)((char *)&v26 + *(void *)(v25 - 24) + 8) = 1;
  v24.__r_.__value_.__s.__data_[0] = 46;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v25, (uint64_t)&v24, 1);
  *(void *)((char *)&v26 + *(void *)(v25 - 24) + 8) = 2;
  std::ostream::operator<<();
  *(void *)((char *)&v26 + *(void *)(v25 - 24) + 8) = 1;
  v24.__r_.__value_.__s.__data_[0] = 46;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v25, (uint64_t)&v24, 1);
  *(void *)((char *)&v26 + *(void *)(v25 - 24) + 8) = 2;
  std::ostream::operator<<();
  *(void *)((char *)&v26 + *(void *)(v25 - 24) + 8) = 1;
  if (*((_DWORD *)this + 5) != -1)
  {
    v24.__r_.__value_.__s.__data_[0] = 45;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v25, (uint64_t)&v24, 1);
    std::ostream::operator<<();
  }
  memset(a2, 170, sizeof(std::string));
  (*(void (**)(std::string *__return_ptr, BBUEURFirmwareVersion *))(*(void *)this + 24))(&v23, this);
  unsigned int v8 = std::string::append(&v23, "-", 1uLL);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  if ((BYTE8(v31) & 0x10) != 0)
  {
    uint64_t v12 = v31;
    if ((unint64_t)v31 < *((void *)&v28 + 1))
    {
      *(void *)&long long v31 = *((void *)&v28 + 1);
      uint64_t v12 = *((void *)&v28 + 1);
    }
    uint64_t v13 = (const void *)v28;
    size_t v10 = v12 - v28;
    if ((unint64_t)(v12 - v28) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_34;
    }
  }
  else
  {
    if ((BYTE8(v31) & 8) == 0)
    {
      size_t v10 = 0;
      HIBYTE(v22) = 0;
      uint64_t v11 = &v20;
      goto LABEL_18;
    }
    uint64_t v13 = (const void *)*((void *)&v26 + 1);
    size_t v10 = *((void *)&v27 + 1) - *((void *)&v26 + 1);
    if (*((void *)&v27 + 1) - *((void *)&v26 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_34:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v10 >= 0x17)
  {
    uint64_t v14 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17) {
      uint64_t v14 = v10 | 7;
    }
    uint64_t v15 = v14 + 1;
    uint64_t v11 = operator new(v14 + 1);
    std::string::size_type v21 = v10;
    int64_t v22 = v15 | 0x8000000000000000;
    BOOL v20 = v11;
    goto LABEL_17;
  }
  HIBYTE(v22) = v10;
  uint64_t v11 = &v20;
  if (v10) {
LABEL_17:
  }
    memmove(v11, v13, v10);
LABEL_18:
  *((unsigned char *)v11 + v10) = 0;
  if (v22 >= 0) {
    int v16 = (const std::string::value_type *)&v20;
  }
  else {
    int v16 = (const std::string::value_type *)v20;
  }
  if (v22 >= 0) {
    std::string::size_type v17 = HIBYTE(v22);
  }
  else {
    std::string::size_type v17 = v21;
  }
  char v18 = std::string::append(&v24, v16, v17);
  *a2 = *v18;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v24.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_26;
    }
LABEL_31:
    operator delete(v24.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_27;
    }
    goto LABEL_32;
  }
  operator delete(v20);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_31;
  }
LABEL_26:
  if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
    goto LABEL_27;
  }
LABEL_32:
  operator delete(v23.__r_.__value_.__l.__data_);
LABEL_27:
  *(void *)&long long v25 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v25 + *(void *)(v25 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v25 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v30) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x223C1DDF0](v32);
}

void sub_21DF00470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::locale a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void sub_21DF0048C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,char a28)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a26 & 0x80000000) == 0)
    {
LABEL_3:
      if ((a20 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a26 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a21);
  if ((a20 & 0x80000000) == 0)
  {
LABEL_4:
    std::ostringstream::~ostringstream((uint64_t)&a28);
    _Unwind_Resume(a1);
  }
LABEL_7:
  operator delete(a15);
  std::ostringstream::~ostringstream((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void sub_21DF00524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21DF00538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void BBUEURFirmwareVersion::getAsString(BBUEURFirmwareVersion *this@<X0>, std::string *a2@<X8>)
{
  memset(a2, 170, sizeof(std::string));
  (*(void (**)(std::string *__return_ptr))(*(void *)this + 32))(a2);
  char v4 = *((unsigned char *)this + 47);
  if (v4 < 0)
  {
    if (!*((void *)this + 4)) {
      return;
    }
  }
  else if (!*((unsigned char *)this + 47))
  {
    return;
  }
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)this + 47);
  }
  else {
    size_t v5 = *((void *)this + 4);
  }
  unint64_t v6 = v5 + 1;
  memset(__p, 170, sizeof(__p));
  if (v5 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v6 >= 0x17)
  {
    uint64_t v8 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v8 = v6 | 7;
    }
    uint64_t v9 = v8 + 1;
    size_t v10 = (char *)operator new(v8 + 1);
    __p[1] = (void *)(v5 + 1);
    __p[2] = (void *)(v9 | 0x8000000000000000);
    __p[0] = v10;
    *size_t v10 = 95;
    int v7 = v10 + 1;
    goto LABEL_15;
  }
  __p[1] = 0;
  __p[2] = 0;
  HIBYTE(__p[2]) = v5 + 1;
  int v7 = (char *)__p + 1;
  __p[0] = (void *)95;
  if (v5)
  {
LABEL_15:
    if (v4 >= 0) {
      uint64_t v11 = (char *)this + 24;
    }
    else {
      uint64_t v11 = (char *)*((void *)this + 3);
    }
    memmove(v7, v11, v5);
  }
  v7[v5] = 0;
  if (SHIBYTE(__p[2]) >= 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = (void **)__p[0];
  }
  if (SHIBYTE(__p[2]) >= 0) {
    std::string::size_type v13 = HIBYTE(__p[2]);
  }
  else {
    std::string::size_type v13 = (std::string::size_type)__p[1];
  }
  std::string::append(a2, (const std::string::value_type *)v12, v13);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
}

void sub_21DF006D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((*(char *)(v15 + 23) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v15 + 23) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)v15);
  _Unwind_Resume(exception_object);
}

void BBUEURFirmwareVersion::getFirmwarePrefix(BBUEURFirmwareVersion *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 95) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *((const std::string::value_type **)this + 9), *((void *)this + 10));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)((char *)this + 72);
    a2->__r_.__value_.__r.__words[2] = *((void *)this + 11);
  }
}

uint64_t BBULogIOABP::startRunLoopThread(pthread_t *this)
{
  int v2 = dispatch_group_create();
  dispatch_group_enter(v2);
  v6[0] = MEMORY[0x263EF8330];
  v6[1] = 1174405120;
  void v6[2] = ___ZN11BBULogIOABP18startRunLoopThreadEv_block_invoke;
  v6[3] = &__block_descriptor_tmp_10;
  v6[4] = this;
  dispatch_object_t object = v2;
  if (v2) {
    dispatch_retain(v2);
  }
  pthread_create(this + 9, 0, (void *(__cdecl *)(void *))enterRunLoopThread, v6);
  dispatch_group_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t Controller = TelephonyBasebandCreateController();
  pthread_t v4 = this[11];
  this[11] = (pthread_t)Controller;
  if (v4) {
    CFRelease(v4);
  }
  if (object) {
    dispatch_release(object);
  }
  if (v2) {
    dispatch_release(v2);
  }
  return 1;
}

void sub_21DF00848(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object)
{
  if (object)
  {
    dispatch_release(object);
    if (!v14) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if (!v14)
  {
    goto LABEL_3;
  }
  dispatch_release(v14);
  _Unwind_Resume(exception_object);
}

const void **ctu::cf::CFSharedRef<__CFRunLoopSource>::~CFSharedRef(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

const void **ctu::cf::CFSharedRef<__CFRunLoop>::~CFSharedRef(const void **a1)
{
  int v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void *std::vector<std::unique_ptr<BBULogIOABP::ABPBuffer>>::~vector[abi:ne180100](void *a1)
{
  int v2 = (void *)*a1;
  if (*a1)
  {
    size_t v3 = (void *)a1[1];
    pthread_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        unint64_t v6 = (void *)*--v3;
        size_t v5 = v6;
        *size_t v3 = 0;
        if (v6)
        {
          int v7 = (void *)v5[1];
          if (v7)
          {
            uint64_t v5[2] = v7;
            operator delete(v7);
          }
          operator delete(v5);
        }
      }
      while (v3 != v2);
      pthread_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void BBULogIOABP::BBULogIOABP(BBULogIOABP *this)
{
  *((void *)this + 12) = &off_26CECB608;
  *(void *)this = &off_26CECB690;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 16) = 0;
  int v2 = (char *)operator new(0x1000uLL);
  bzero(v2, 0x1000uLL);
  *((void *)this + 17) = v2 + 4096;
  *((void *)this + 18) = v2 + 4096;
  *((void *)this + 15) = 4096;
  *((void *)this + 16) = v2;
  *(_OWORD *)((char *)this + 104) = xmmword_21DFABF70;
  *((unsigned char *)this + 152) = 1;
  *((void *)this + 12) = &unk_26CECB400;
  *(void *)this = &unk_26CECB370;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  dispatch_queue_t v3 = dispatch_queue_create("com.apple.BBULogIOABP", 0);
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 3) = v3;
  *((unsigned char *)this + 80) = 0;
  *((void *)this + 11) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + *(void *)(*(void *)this - 80) + 56) = 0;
  BBULogIOABP::startRunLoopThread((pthread_t *)this);
}

void sub_21DF00AC0(_Unwind_Exception *a1)
{
  ctu::cf::CFSharedRef<__TelephonyBasebandControllerHandle_tag>::~CFSharedRef(v3);
  ctu::cf::CFSharedRef<__CFRunLoopSource>::~CFSharedRef((const void **)(v2 + 64));
  ctu::cf::CFSharedRef<__CFRunLoop>::~CFSharedRef((const void **)(v2 + 56));
  std::vector<std::unique_ptr<BBULogIOABP::ABPBuffer>>::~vector[abi:ne180100](v4);
  int v7 = *(NSObject **)(v2 + 24);
  if (v7)
  {
    dispatch_release(v7);
    uint64_t v8 = *(void *)(v2 + 16);
    *(void *)(v2 + 16) = 0;
    if (!v8)
    {
LABEL_3:
      uint64_t v9 = *v5;
      uint64_t *v5 = 0;
      if (!v9) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v8 = *(void *)(v2 + 16);
    *(void *)(v2 + 16) = 0;
    if (!v8) {
      goto LABEL_3;
    }
  }
  (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  uint64_t v9 = *v5;
  uint64_t *v5 = 0;
  if (!v9)
  {
LABEL_4:
    BBULogCircularBuffer::~BBULogCircularBuffer(v1, (uint64_t *)off_26CECB458);
    _Unwind_Resume(a1);
  }
LABEL_7:
  (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
  BBULogCircularBuffer::~BBULogCircularBuffer(v1, (uint64_t *)off_26CECB458);
  _Unwind_Resume(a1);
}

void BBULogCircularBuffer::~BBULogCircularBuffer(BBULogCircularBuffer *this, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)this = *a2;
  *(void *)((char *)this + *(void *)(v3 - 80)) = a2[1];
  pthread_t v4 = (void *)*((void *)this + 4);
  if (v4)
  {
    *((void *)this + 5) = v4;
    operator delete(v4);
  }
}

void BBULogIOABP::~BBULogIOABP(BBULogIOABP *this)
{
  *((void *)this + 12) = &unk_26CECB400;
  *(void *)this = &unk_26CECB370;
  BBULogIOABP::disable(this);
  uint64_t v18 = 0;
  BOOL v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 0;
  uint64_t v2 = (const void *)*((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((void *)this + 3);
  v17[0] = MEMORY[0x263EF8330];
  v17[1] = 1107296256;
  _OWORD v17[2] = ___ZN11BBULogIOABP17stopRunLoopThreadEv_block_invoke;
  v17[3] = &__block_descriptor_tmp_4;
  v17[4] = &v18;
  v17[5] = this;
  dispatch_sync(v3, v17);
  if (*((unsigned char *)v19 + 24))
  {
    pthread_join(*((pthread_t *)this + 9), 0);
    pthread_t v4 = (const void *)*((void *)this + 7);
    *((void *)this + 7) = 0;
    if (v4) {
      CFRelease(v4);
    }
  }
  _Block_object_dispose(&v18, 8);
  size_t v5 = (const void *)*((void *)this + 11);
  if (v5) {
    CFRelease(v5);
  }
  unint64_t v6 = (const void *)*((void *)this + 8);
  if (v6) {
    CFRelease(v6);
  }
  int v7 = (const void *)*((void *)this + 7);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 4);
  if (v8)
  {
    uint64_t v9 = (void *)*((void *)this + 5);
    size_t v10 = (void *)*((void *)this + 4);
    if (v9 != v8)
    {
      do
      {
        uint64_t v12 = (void *)*--v9;
        uint64_t v11 = v12;
        *uint64_t v9 = 0;
        if (v12)
        {
          std::string::size_type v13 = (void *)v11[1];
          if (v13)
          {
            void v11[2] = v13;
            operator delete(v13);
          }
          operator delete(v11);
        }
      }
      while (v9 != v8);
      size_t v10 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v8;
    operator delete(v10);
  }
  uint64_t v14 = *((void *)this + 3);
  if (v14) {
    dispatch_release(v14);
  }
  uint64_t v15 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 16))(v16);
  }
}

{
  void *v2;
  void *v3;

  BBULogIOABP::~BBULogIOABP(this);
  v2[12] = &off_26CECB608;
  *uint64_t v2 = &off_26CECB690;
  uint64_t v3 = (void *)v2[16];
  if (v3)
  {
    *((void *)this + 17) = v3;
    operator delete(v3);
  }
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  BBULogIOABP::~BBULogIOABP(this);
  v2[12] = &off_26CECB608;
  *uint64_t v2 = &off_26CECB690;
  uint64_t v3 = (void *)v2[16];
  if (v3)
  {
    *((void *)this + 17) = v3;
    operator delete(v3);
  }

  operator delete(this);
}

void sub_21DF00E78(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  __clang_call_terminate(a1);
}

void virtual thunk to'BBULogIOABP::~BBULogIOABP(BBULogIOABP *this)
{
  BBULogIOABP::~BBULogIOABP((BBULogIOABP *)((char *)this + *(void *)(*(void *)this - 32)));
  v1[12] = &off_26CECB608;
  *int v1 = &off_26CECB690;
  uint64_t v2 = (void *)v1[16];
  if (v2)
  {
    v1[17] = v2;
    operator delete(v2);
  }
}

{
  BBULogIOABP *v1;
  void *v2;
  uint64_t vars8;

  int v1 = (BBULogIOABP *)((char *)this + *(void *)(*(void *)this - 32));
  BBULogIOABP::~BBULogIOABP(v1);
  *((void *)v1 + 12) = &off_26CECB608;
  *(void *)int v1 = &off_26CECB690;
  uint64_t v2 = (void *)*((void *)v1 + 16);
  if (v2)
  {
    *((void *)v1 + 17) = v2;
    operator delete(v2);
  }

  operator delete(v1);
}

void ___ZN11BBULogIOABP18startRunLoopThreadEv_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  CFRunLoopRef v6 = Current;
  if (Current) {
    CFRetain(Current);
  }
  int v7 = *(const void **)(v4 + 56);
  *(void *)(v4 + 56) = v6;
  if (v7) {
    CFRelease(v7);
  }
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v8 = *(const void **)(v4 + 64);
  *(void *)(v4 + 64) = a2;
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *(NSObject **)(a1 + 40);

  dispatch_group_leave(v9);
}

void __copy_helper_block_e8_40c21_ZTSN8dispatch5groupE(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(NSObject **)(a2 + 40);
  *(void *)(a1 + 40) = v3;
  if (v3) {
    dispatch_retain(v3);
  }
}

void __destroy_helper_block_e8_40c21_ZTSN8dispatch5groupE(uint64_t a1)
{
  int v1 = *(NSObject **)(a1 + 40);
  if (v1) {
    dispatch_release(v1);
  }
}

uint64_t enterRunLoopThread(void (**a1)(void, void))
{
  memset(&context, 0, 72);
  context.perform = (void (__cdecl *)(void *))peformNOP;
  uint64_t v2 = CFRunLoopSourceCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, &context);
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  CFRunLoopAddSource(Current, v2, (CFRunLoopMode)*MEMORY[0x263EFFE88]);
  ((void (**)(void, __CFRunLoopSource *))a1)[2](a1, v2);
  CFRunLoopRun();
  if (v2) {
    CFRelease(v2);
  }
  return 0;
}

void sub_21DF01210(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ctu::cf::CFSharedRef<__CFRunLoopSource>::~CFSharedRef((const void **)va);
  _Unwind_Resume(a1);
}

void ___ZN11BBULogIOABP17stopRunLoopThreadEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(__CFRunLoop **)(v2 + 56);
  if (v3)
  {
    CFRunLoopWakeUp(v3);
    CFRunLoopSourceInvalidate(*(CFRunLoopSourceRef *)(v2 + 64));
    uint64_t v4 = *(const void **)(v2 + 64);
    *(void *)(v2 + 64) = 0;
    if (v4) {
      CFRelease(v4);
    }
    CFRunLoopPerformBlock(*(CFRunLoopRef *)(v2 + 56), (CFTypeRef)*MEMORY[0x263EFFE88], &__block_literal_global_1);
    CFRunLoopWakeUp(*(CFRunLoopRef *)(v2 + 56));
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

void ___ZN11BBULogIOABP17stopRunLoopThreadEv_block_invoke_2()
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();

  CFRunLoopStop(Current);
}

void ___ZN11BBULogIOABP25registerIOABPControl_syncEv_block_invoke()
{
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      return;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      return;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    char v0 = pci::transport::kernel::errorAsString();
    _BBULog(1, 0, "BBULogIOABP", "", "received '%s' error. arg0 = %#llx arg1 = %#llx\n", v1, v2, v3, v0);
  }
}

uint64_t ___ZN11BBULogIOABP25registerIOABPControl_syncEv_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(NSObject **)(v3 + 24);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZN11BBULogIOABP25registerIOABPControl_syncEv_block_invoke_3;
  block[3] = &__block_descriptor_tmp_26;
  block[4] = v3;
  block[5] = a2;
  block[6] = a3;
  dispatch_async(v4, block);
  return 0;
}

void ___ZN11BBULogIOABP25registerIOABPControl_syncEv_block_invoke_3(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[4];
  if (!*(unsigned char *)(v8 + *(void *)(*(void *)v8 - 80) + 56))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBULogIOABP.cpp", 0x93u, (ctu::LogMessageBuffer *)"Assertion failure(fEnabled)", v17, v18, v19, v23);
    goto LABEL_22;
  }
  size_t v10 = (unsigned int *)a1[5];
  if (!*v10)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBULogIOABP.cpp", 0x95u, (ctu::LogMessageBuffer *)"Assertion failure(buf->size)", v20, v21, v22, v23);
LABEL_22:
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_7;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_7;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(2, 6, "BBULogIOABP", "", "add log: data %p size %zu\n", a6, a7, a8, *((void *)v10 + 1));
  }
LABEL_7:
  (*(void (**)(uint64_t, void, void))(*(void *)(v8 + *(void *)(*(void *)v8 - 80)) + 24))(v8 + *(void *)(*(void *)v8 - 80), *((void *)v10 + 1), a1[6]);
  if (*(unsigned char *)(v8 + 80))
  {
    uint64_t v11 = (const void *)*((void *)v10 + 4);
    _Block_release(v11);
  }
  else
  {
    char v15 = (*(uint64_t (**)(void, void, void, void, void (*)(BBULogIOABP *, void *, int, void *, uint64_t, uint64_t, uint64_t, uint64_t), unsigned int *))(**(void **)(v8 + 16) + 64))(*(void *)(v8 + 16), *((void *)v10 + 1), *v10, 0, BBULogIOABP::cbReadLogs, v10);
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
        return;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
        return;
      }
    }
    if (gBBULogVerbosity >= 6) {
      _BBULog(2, 6, "BBULogIOABP", "", "readLogsAsync: ret %#x\n", v12, v13, v14, v15);
    }
  }
}

void sub_21DF016B0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DF016C4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void BBULogIOABP::cbReadLogs(BBULogIOABP *this, void *a2, int a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = (char)a2;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_5;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(2, 6, "BBULogIOABP", "", "readCompletion: ret %#x, arg0 %p, refCon %p\n", a6, a7, a8, v8);
  }
LABEL_5:
  if (this && (*(unsigned int (**)(void))(*((void *)this + 4) + 16))())
  {
    size_t v10 = (const void *)*((void *)this + 4);
    _Block_release(v10);
  }
}

void **std::unique_ptr<BBULogIOABP::ABPBuffer>::~unique_ptr[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = (void *)v2[1];
    if (v3)
    {
      v2[2] = v3;
      operator delete(v3);
    }
    operator delete(v2);
  }
  return a1;
}

void BBULogIOABP::enable(BBULogIOABP *this)
{
  uint64_t v1 = *((void *)this + 3);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZN11BBULogIOABP6enableEv_block_invoke;
  block[3] = &__block_descriptor_tmp_40;
  block[4] = this;
  dispatch_async(v1, block);
}

void ___ZN11BBULogIOABP6enableEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = *(void **)(a1 + 32);
  if (*((unsigned char *)v9 + *(void *)(*v9 - 80) + 56) || !v9[7] || !v9[11]) {
    return;
  }
  _Block_copy(&__block_literal_global_33);
  uint64_t v10 = TelephonyBasebandRegisterForReset();
  if ((v10 & 1) == 0)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_9;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_9;
      }
    }
    if (gBBULogVerbosity >= 1) {
      uint64_t v10 = _BBULog(1, 1, "BBULogIOABP", "", "Failed to register for reset detect", v11, v12, v13, v80);
    }
  }
LABEL_9:
  unsigned int v83 = 0x10000;
  pci::transport::kernelControl::create((uint64_t *)&__p, (pci::transport::kernelControl *)v10);
  uint64_t v17 = __p;
  std::string __p = 0;
  uint64_t v18 = v9[2];
  void v9[2] = v17;
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    uint64_t v19 = __p;
    std::string __p = 0;
    if (v19) {
      (*(void (**)(void *))(*(void *)v19 + 8))(v19);
    }
    uint64_t v17 = (void *)v9[2];
  }
  if (!v17)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_81;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_81;
      }
    }
    if (gBBULogVerbosity >= 6)
    {
      _BBULog(1, 6, "BBULogIOABP", "", "check failed: %s, %d, assertion: %s\n", v14, v15, v16, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBULogIOABP.cpp");
      if (gBBULogMaskGet(void)::once != -1)
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_114;
        }
LABEL_82:
        if (gBBULogVerbosity < 1) {
          goto LABEL_114;
        }
        std::string v77 = "Fail to create kernelControl\n";
LABEL_113:
        _BBULog(1, 1, "BBULogIOABP", "", v77, v14, v15, v16, v80);
        goto LABEL_114;
      }
    }
LABEL_81:
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_114;
    }
    goto LABEL_82;
  }
  if (((*(uint64_t (**)(void *))(*(void *)v17 + 24))(v17) & 1) == 0)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_88;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_88;
      }
    }
    if (gBBULogVerbosity >= 6)
    {
      _BBULog(1, 6, "BBULogIOABP", "", "check failed: %s, %d, assertion: %s\n", v14, v15, v16, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBULogIOABP.cpp");
      if (gBBULogMaskGet(void)::once != -1)
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_114;
        }
LABEL_89:
        if (gBBULogVerbosity < 1) {
          goto LABEL_114;
        }
        std::string v77 = "Fail to start kernelControl\n";
        goto LABEL_113;
      }
    }
LABEL_88:
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_114;
    }
    goto LABEL_89;
  }
  int v20 = (*(uint64_t (**)(void, void, void *))(*(void *)v9[2] + 72))(v9[2], v9[7], &__block_literal_global_15);
  if (v20)
  {
    char v78 = v20;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_95;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_95;
      }
    }
    if (gBBULogVerbosity >= 6)
    {
      _BBULog(1, 6, "BBULogIOABP", "", "check failed: %s, %d, assertion: %s\n", v14, v15, v16, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBULogIOABP.cpp");
      if (gBBULogMaskGet(void)::once != -1)
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_114;
        }
LABEL_96:
        if (gBBULogVerbosity < 1) {
          goto LABEL_114;
        }
        uint64_t v79 = "Fail to registerEventNotification: %#x \n";
LABEL_105:
        _BBULog(1, 1, "BBULogIOABP", "", v79, v14, v15, v16, v78);
        goto LABEL_114;
      }
    }
LABEL_95:
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_114;
    }
    goto LABEL_96;
  }
  int v21 = (*(uint64_t (**)(void, void))(*(void *)v9[2] + 40))(v9[2], v9[7]);
  if (v21)
  {
    char v78 = v21;
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_102;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_102;
      }
    }
    if (gBBULogVerbosity >= 6)
    {
      _BBULog(1, 6, "BBULogIOABP", "", "check failed: %s, %d, assertion: %s\n", v14, v15, v16, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBULogIOABP.cpp");
      if (gBBULogMaskGet(void)::once != -1)
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
          goto LABEL_114;
        }
LABEL_103:
        if (gBBULogVerbosity < 1) {
          goto LABEL_114;
        }
        uint64_t v79 = "Fail to open kernelControl: %#x \n";
        goto LABEL_105;
      }
    }
LABEL_102:
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
      goto LABEL_114;
    }
    goto LABEL_103;
  }
  char v22 = (*(uint64_t (**)(void, unsigned int *))(*(void *)v9[2] + 96))(v9[2], &v83);
  char v23 = v22;
  if (gBBULogMaskGet(void)::once != -1)
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    uint64_t v24 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
    int v25 = gBBULogVerbosity;
    if (v23) {
      goto LABEL_19;
    }
    goto LABEL_107;
  }
  uint64_t v24 = *(void *)gBBULogMaskGet(void)::sBBULogMask;
  int v25 = gBBULogVerbosity;
  if ((v22 & 1) == 0)
  {
LABEL_107:
    if ((v24 & 2) != 0
      && v25 >= 6
      && (_BBULog(1, 6, "BBULogIOABP", "", "check failed: %s, %d, assertion: %s\n", v14, v15, v16, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBULogIOABP.cpp"), gBBULogMaskGet(void)::once != -1))
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        goto LABEL_114;
      }
    }
    else if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0)
    {
      goto LABEL_114;
    }
    if (gBBULogVerbosity >= 1)
    {
      std::string v77 = "failed to getLogInternalBufferSize... will use %lu bytes.\n";
      char v80 = v83;
      goto LABEL_113;
    }
LABEL_114:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        return;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        return;
      }
    }
    if (gBBULogVerbosity < 1) {
      return;
    }
    uint64_t v74 = "Failed to enable\n";
    int v75 = 1;
    uint64_t v76 = 1;
    goto LABEL_74;
  }
LABEL_19:
  if ((v24 & 4) != 0 && v25 >= 6) {
    _BBULog(2, 6, "BBULogIOABP", "", "internal buffer is %lu bytes\n", v14, v15, v16, v83);
  }
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___ZN11BBULogIOABP25registerIOABPControl_syncEv_block_invoke_2;
  aBlock[3] = &__block_descriptor_tmp_28;
  aBlock[4] = v9;
  long long v26 = operator new(0x28uLL);
  size_t v27 = v83;
  *(_DWORD *)long long v26 = v83;
  v26[2] = 0;
  v26[3] = 0;
  v26[1] = 0;
  if (v27)
  {
    long long v28 = (char *)operator new(v27);
    v26[1] = v28;
    char v29 = &v28[v27];
    v26[3] = &v28[v27];
    bzero(v28, v27);
    v26[2] = v29;
  }
  v26[4] = _Block_copy(aBlock);
  std::string __p = v26;
  long long v30 = (void *)v9[5];
  if ((unint64_t)v30 >= v9[6])
  {
    long long v31 = std::vector<std::unique_ptr<BBULogIOABP::ABPBuffer>>::__push_back_slow_path<std::unique_ptr<BBULogIOABP::ABPBuffer>>(v9 + 4, (uint64_t *)&__p);
    uint64_t v32 = __p;
    v9[5] = v31;
    if (v32)
    {
      unint64_t v33 = (void *)v32[1];
      if (v33)
      {
        v32[2] = v33;
        operator delete(v33);
      }
      operator delete(v32);
    }
  }
  else
  {
    *long long v30 = v26;
    v9[5] = v30 + 1;
  }
  char v37 = (*(uint64_t (**)(void, void, void, void, void (*)(BBULogIOABP *, void *, int, void *, uint64_t, uint64_t, uint64_t, uint64_t), void *))(*(void *)v9[2] + 64))(v9[2], v26[1], *(unsigned int *)v26, 0, BBULogIOABP::cbReadLogs, v26);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_34;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_34;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(2, 6, "BBULogIOABP", "", "readLogsAsync returned %#x\n", v34, v35, v36, v37);
  }
LABEL_34:
  unsigned int v38 = operator new(0x28uLL);
  size_t v39 = v83;
  *(_DWORD *)unsigned int v38 = v83;
  v38[2] = 0;
  v38[3] = 0;
  v38[1] = 0;
  if (v39)
  {
    unint64_t v40 = (char *)operator new(v39);
    v38[1] = v40;
    char v41 = &v40[v39];
    v38[3] = &v40[v39];
    bzero(v40, v39);
    v38[2] = v41;
  }
  v38[4] = _Block_copy(aBlock);
  std::string __p = v38;
  long long v42 = (void *)v9[5];
  if ((unint64_t)v42 >= v9[6])
  {
    long long v43 = std::vector<std::unique_ptr<BBULogIOABP::ABPBuffer>>::__push_back_slow_path<std::unique_ptr<BBULogIOABP::ABPBuffer>>(v9 + 4, (uint64_t *)&__p);
    size_t v44 = __p;
    v9[5] = v43;
    if (v44)
    {
      long long v45 = (void *)v44[1];
      if (v45)
      {
        v44[2] = v45;
        operator delete(v45);
      }
      operator delete(v44);
    }
  }
  else
  {
    *long long v42 = v38;
    v9[5] = v42 + 1;
  }
  char v49 = (*(uint64_t (**)(void, void, void, void, void (*)(BBULogIOABP *, void *, int, void *, uint64_t, uint64_t, uint64_t, uint64_t), void *))(*(void *)v9[2] + 64))(v9[2], v38[1], *(unsigned int *)v38, 0, BBULogIOABP::cbReadLogs, v38);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_46;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_46;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(2, 6, "BBULogIOABP", "", "readLogsAsync returned %#x\n", v46, v47, v48, v49);
  }
LABEL_46:
  long long v50 = operator new(0x28uLL);
  size_t v51 = v83;
  *(_DWORD *)long long v50 = v83;
  v50[2] = 0;
  v50[3] = 0;
  v50[1] = 0;
  if (v51)
  {
    uint64_t v52 = (char *)operator new(v51);
    v50[1] = v52;
    long long v53 = &v52[v51];
    v50[3] = &v52[v51];
    bzero(v52, v51);
    v50[2] = v53;
  }
  v50[4] = _Block_copy(aBlock);
  std::string __p = v50;
  std::string v54 = (void *)v9[5];
  if ((unint64_t)v54 >= v9[6])
  {
    std::string v55 = std::vector<std::unique_ptr<BBULogIOABP::ABPBuffer>>::__push_back_slow_path<std::unique_ptr<BBULogIOABP::ABPBuffer>>(v9 + 4, (uint64_t *)&__p);
    std::string v56 = __p;
    v9[5] = v55;
    if (v56)
    {
      long long v57 = (void *)v56[1];
      if (v57)
      {
        v56[2] = v57;
        operator delete(v57);
      }
      operator delete(v56);
    }
  }
  else
  {
    *std::string v54 = v50;
    v9[5] = v54 + 1;
  }
  char v61 = (*(uint64_t (**)(void, void, void, void, void (*)(BBULogIOABP *, void *, int, void *, uint64_t, uint64_t, uint64_t, uint64_t), void *))(*(void *)v9[2] + 64))(v9[2], v50[1], *(unsigned int *)v50, 0, BBULogIOABP::cbReadLogs, v50);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_58;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_58;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(2, 6, "BBULogIOABP", "", "readLogsAsync returned %#x\n", v58, v59, v60, v61);
  }
LABEL_58:
  long long v62 = operator new(0x28uLL);
  size_t v63 = v83;
  *(_DWORD *)long long v62 = v83;
  v62[2] = 0;
  v62[3] = 0;
  v62[1] = 0;
  if (v63)
  {
    long long v64 = (char *)operator new(v63);
    v62[1] = v64;
    long long v65 = &v64[v63];
    v62[3] = &v64[v63];
    bzero(v64, v63);
    v62[2] = v65;
  }
  v62[4] = _Block_copy(aBlock);
  std::string __p = v62;
  long long v66 = (void *)v9[5];
  if ((unint64_t)v66 >= v9[6])
  {
    long long v67 = std::vector<std::unique_ptr<BBULogIOABP::ABPBuffer>>::__push_back_slow_path<std::unique_ptr<BBULogIOABP::ABPBuffer>>(v9 + 4, (uint64_t *)&__p);
    long long v68 = __p;
    v9[5] = v67;
    if (v68)
    {
      long long v69 = (void *)v68[1];
      if (v69)
      {
        std::locale v68[2] = v69;
        operator delete(v69);
      }
      operator delete(v68);
    }
  }
  else
  {
    *long long v66 = v62;
    v9[5] = v66 + 1;
  }
  char v73 = (*(uint64_t (**)(void, void, void, void, void (*)(BBULogIOABP *, void *, int, void *, uint64_t, uint64_t, uint64_t, uint64_t), void *))(*(void *)v9[2] + 64))(v9[2], v62[1], *(unsigned int *)v62, 0, BBULogIOABP::cbReadLogs, v62);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0) {
      goto LABEL_68;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0)
    {
LABEL_68:
      if (gBBULogVerbosity >= 6) {
        _BBULog(2, 6, "BBULogIOABP", "", "readLogsAsync returned %#x\n", v70, v71, v72, v73);
      }
    }
  }
  (*(void (**)(char *, void))(*(void *)((char *)v9 + *(void *)(*v9 - 80)) + 56))((char *)v9 + *(void *)(*v9 - 80), 2 * v83);
  *((unsigned char *)v9 + *(void *)(*v9 - 80) + 56) = 1;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      return;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      return;
    }
  }
  if (gBBULogVerbosity < 6) {
    return;
  }
  uint64_t v74 = "Succeed to enable\n";
  int v75 = 2;
  uint64_t v76 = 6;
LABEL_74:

  _BBULog(v75, v76, "BBULogIOABP", "", v74, v14, v15, v16, a9);
}

void sub_21DF026EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p)
{
  if (__p)
  {
    uint64_t v18 = (void *)__p[1];
    if (v18)
    {
      __p[2] = v18;
      operator delete(v18);
    }
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN11BBULogIOABP6enableEv_block_invoke_2(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a2 == -469794816)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
        return;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
        return;
      }
    }
    if (gBBULogVerbosity < 0) {
      return;
    }
    uint64_t v10 = "baseband reset detected\n";
    goto LABEL_11;
  }
  char v9 = a2;
  if (a2 == -469794815)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
        return;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
        return;
      }
    }
    if (gBBULogVerbosity < 0) {
      return;
    }
    uint64_t v10 = "baseband alive detected\n";
LABEL_11:
    _BBULog(2, 0, "BBULogIOABP", "", v10, a6, a7, a8, a9);
    return;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      return;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      return;
    }
  }
  if (gBBULogVerbosity >= 6) {
    _BBULog(2, 6, "BBULogIOABP", "", "reset message type: %x\n", a6, a7, a8, v9);
  }
}

void sResetDetectCallback(void (**a1)(void, void), unsigned int a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    a1[2](a1, a3);
    _Block_release(a1);
  }
}

void virtual thunk to'BBULogIOABP::enable(BBULogIOABP *this)
{
  uint64_t v1 = (char *)this + *(void *)(*(void *)this - 48);
  uint64_t v2 = *((void *)v1 + 3);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZN11BBULogIOABP6enableEv_block_invoke;
  block[3] = &__block_descriptor_tmp_40;
  block[4] = v1;
  dispatch_async(v2, block);
}

void BBULogIOABP::disable(BBULogIOABP *this)
{
  uint64_t v2 = dispatch_group_create();
  dispatch_group_enter(v2);
  uint64_t v3 = *((void *)this + 3);
  v8[0] = MEMORY[0x263EF8330];
  v8[1] = 1174405120;
  v8[2] = ___ZN11BBULogIOABP7disableEv_block_invoke;
  v8[3] = &__block_descriptor_tmp_50;
  unint64_t v8[4] = this;
  dispatch_object_t object = v2;
  if (v2) {
    dispatch_retain(v2);
  }
  dispatch_async(v3, v8);
  dispatch_group_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  if (*((void *)this + 2))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0) {
        goto LABEL_6;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0)
      {
LABEL_6:
        if (gBBULogVerbosity >= 6) {
          _BBULog(2, 6, "BBULogIOABP", "", "closing ABPControlObj\n", v4, v5, v6, v8[0]);
        }
      }
    }
    (*(void (**)(void))(**((void **)this + 2) + 56))(*((void *)this + 2));
    (*(void (**)(void))(**((void **)this + 2) + 32))(*((void *)this + 2));
    uint64_t v7 = *((void *)this + 2);
    *((void *)this + 2) = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  if (object) {
    dispatch_release(object);
  }
  if (v2) {
    dispatch_release(v2);
  }
}

void sub_21DF02B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, dispatch_object_t object)
{
  if (object)
  {
    dispatch_release(object);
    if (!v14) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if (!v14)
  {
    goto LABEL_3;
  }
  dispatch_release(v14);
  _Unwind_Resume(exception_object);
}

void ___ZN11BBULogIOABP7disableEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + *(void *)(*(void *)v2 - 80) + 56) && *(void *)(v2 + 16))
  {
    aBlock[0] = MEMORY[0x263EF8330];
    aBlock[1] = 1174405120;
    aBlock[2] = ___ZN11BBULogIOABP7disableEv_block_invoke_2;
    aBlock[3] = &__block_descriptor_tmp_47;
    uint64_t v3 = *(NSObject **)(a1 + 40);
    aBlock[4] = v2;
    dispatch_object_t object = v3;
    if (v3) {
      dispatch_retain(v3);
    }
    *(unsigned char *)(v2 + 80) = 1;
    uint64_t v4 = operator new(0x28uLL);
    *(_DWORD *)uint64_t v4 = 0;
    unint64_t v4[2] = 0;
    v4[3] = 0;
    v4[1] = 0;
    v4[4] = _Block_copy(aBlock);
    std::string __p = v4;
    uint64_t v5 = *(void **)(v2 + 40);
    if ((unint64_t)v5 >= *(void *)(v2 + 48))
    {
      uint64_t v7 = std::vector<std::unique_ptr<BBULogIOABP::ABPBuffer>>::__push_back_slow_path<std::unique_ptr<BBULogIOABP::ABPBuffer>>((void *)(v2 + 32), (uint64_t *)&__p);
      char v8 = __p;
      *(void *)(v2 + 40) = v7;
      if (v8)
      {
        char v9 = (void *)v8[1];
        if (v9)
        {
          v8[2] = v9;
          operator delete(v9);
        }
        operator delete(v8);
      }
    }
    else
    {
      void *v5 = v4;
      *(void *)(v2 + 40) = v5 + 1;
    }
    if ((*(unsigned int (**)(void, void, void, uint64_t, void (*)(BBULogIOABP *, void *, int, void *, uint64_t, uint64_t, uint64_t, uint64_t), void *))(**(void **)(v2 + 16) + 64))(*(void *)(v2 + 16), v4[1], *(unsigned int *)v4, 1, BBULogIOABP::cbReadLogs, v4))
    {
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    }
    if (object) {
      dispatch_release(object);
    }
  }
  else
  {
    uint64_t v6 = *(NSObject **)(a1 + 40);
    dispatch_group_leave(v6);
  }
}

void sub_21DF02D78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, dispatch_object_t object)
{
  if (object) {
    dispatch_release(object);
  }
  _Unwind_Resume(a1);
}

uint64_t ___ZN11BBULogIOABP7disableEv_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v1 = *(NSObject **)(a1 + 40);
  uint64_t v3 = *(NSObject **)(v2 + 24);
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 1174405120;
  uint64_t v5[2] = ___ZN11BBULogIOABP7disableEv_block_invoke_3;
  v5[3] = &__block_descriptor_tmp_44;
  v5[4] = v2;
  dispatch_object_t object = v1;
  if (v1) {
    dispatch_retain(v1);
  }
  dispatch_async(v3, v5);
  if (object) {
    dispatch_release(object);
  }
  return 1;
}

void ___ZN11BBULogIOABP7disableEv_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = *(void **)(a1 + 32);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(2, 0, "BBULogIOABP", "", "last readLogBlock callback\n", a6, a7, a8, v11);
  }
LABEL_5:
  *((unsigned char *)v9 + *(void *)(*v9 - 80) + 56) = 0;
  uint64_t v10 = *(NSObject **)(a1 + 40);

  dispatch_group_leave(v10);
}

void virtual thunk to'BBULogIOABP::disable(BBULogIOABP *this)
{
}

void BBULogCircularBuffer::~BBULogCircularBuffer(BBULogCircularBuffer *this)
{
  *(void *)this = &unk_26CECB810;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26CECB810;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }

  operator delete(this);
}

void virtual thunk to'BBULogCircularBuffer::~BBULogCircularBuffer(BBULogCircularBuffer *this)
{
  uint64_t v1 = (void *)((char *)this + *(void *)(*(void *)this - 32));
  *uint64_t v1 = &unk_26CECB810;
  uint64_t v2 = (void *)v1[4];
  if (v2)
  {
    v1[5] = v2;
    operator delete(v2);
  }
}

{
  void *v1;
  void *v2;
  uint64_t vars8;

  uint64_t v1 = (void *)((char *)this + *(void *)(*(void *)this - 32));
  *uint64_t v1 = &unk_26CECB810;
  uint64_t v2 = (void *)v1[4];
  if (v2)
  {
    v1[5] = v2;
    operator delete(v2);
  }

  operator delete(v1);
}

void *std::vector<std::unique_ptr<BBULogIOABP::ABPBuffer>>::__push_back_slow_path<std::unique_ptr<BBULogIOABP::ABPBuffer>>(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    std::vector<std::string>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    char v9 = (char *)operator new(8 * v8);
  }
  else
  {
    char v9 = 0;
  }
  uint64_t v10 = &v9[8 * v3];
  char v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)uint64_t v10 = v12;
  uint64_t v13 = v10 + 8;
  uint64_t v14 = (char *)*a1;
  uint64_t v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
  }
  else
  {
    unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
    if (v16 < 0x78 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15) {
      goto LABEL_33;
    }
    uint64_t v17 = (v16 >> 3) + 1;
    uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    v10 -= v18;
    uint64_t v19 = &v15[-v18];
    int v20 = v15 - 16;
    int v21 = &v9[8 * v3 - 16];
    uint64_t v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *((_OWORD *)v20 - 1);
      long long v23 = *(_OWORD *)v20;
      *((_OWORD *)v20 - 1) = 0uLL;
      *(_OWORD *)int v20 = 0uLL;
      *((_OWORD *)v21 - 1) = v24;
      *(_OWORD *)int v21 = v23;
      v20 -= 32;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    uint64_t v15 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_33:
      do
      {
        uint64_t v25 = *((void *)v15 - 1);
        v15 -= 8;
        *(void *)uint64_t v15 = 0;
        *((void *)v10 - 1) = v25;
        v10 -= 8;
      }
      while (v15 != v14);
    }
    uint64_t v15 = (char *)*a1;
    long long v26 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    while (v26 != v15)
    {
      long long v28 = (void *)*((void *)v26 - 1);
      v26 -= 8;
      size_t v27 = v28;
      *(void *)long long v26 = 0;
      if (v28)
      {
        char v29 = (void *)v27[1];
        if (v29)
        {
          void v27[2] = v29;
          operator delete(v29);
        }
        operator delete(v27);
      }
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

uint64_t BBUICEProgrammer::BBUICEProgrammer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (capabilities::programmer *)BBUProgrammer::BBUProgrammer(a1, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_26CECB718;
  unint64_t v6 = capabilities::programmer::connectAttemptCount(v5);
  if (HIDWORD(v6))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/ICE/BBUICEProgrammer.cpp", 0xCu, (ctu::LogMessageBuffer *)"Assertion failure(capabilities::programmer::connectAttemptCount() <= std::numeric_limits<UInt32>::max() && \"capabilities::programmer::connectAttemptCount() exceeds maximum allowable value\")", v13, v14, v15, v22);
    goto LABEL_8;
  }
  uint64_t v7 = capabilities::programmer::connectTimeout((capabilities::programmer *)v6);
  if (v7 >= 0x100000000)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/ICE/BBUICEProgrammer.cpp", 0xDu, (ctu::LogMessageBuffer *)"Assertion failure(capabilities::programmer::connectTimeout().count() <= std::numeric_limits<UInt32>::max() && \"capabilities::programmer::connectTimeout().count() exceeds maximum allowable value\")", v16, v17, v18, v22);
    goto LABEL_8;
  }
  uint64_t v8 = capabilities::programmer::commandTimeout((capabilities::programmer *)v7);
  if (v8 >= 0x100000000)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/ICE/BBUICEProgrammer.cpp", 0xEu, (ctu::LogMessageBuffer *)"Assertion failure(capabilities::programmer::commandTimeout().count() <= std::numeric_limits<UInt32>::max() && \"capabilities::programmer::commandTimeout().count() exceeds maximum allowable value\")", v19, v20, v21, v22);
LABEL_8:
  }
  char v9 = (capabilities::programmer *)capabilities::programmer::connectAttemptCount((capabilities::programmer *)v8);
  *(_DWORD *)(a1 + 68) = v9;
  uint64_t v10 = (capabilities::programmer *)capabilities::programmer::connectTimeout(v9);
  *(_DWORD *)(a1 + 72) = v10;
  *(_DWORD *)(a1 + 76) = capabilities::programmer::commandTimeout(v10);
  *(unsigned char *)(a1 + 80) = 0;
  return a1;
}

void sub_21DF0338C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  BBUProgrammer::~BBUProgrammer(v1);
  _Unwind_Resume(a1);
}

void sub_21DF033B0(_Unwind_Exception *a1)
{
  BBUProgrammer::~BBUProgrammer(v1);
  _Unwind_Resume(a1);
}

void sub_21DF033C4(_Unwind_Exception *a1)
{
  BBUProgrammer::~BBUProgrammer(v1);
  _Unwind_Resume(a1);
}

void sub_21DF033D8(_Unwind_Exception *a1)
{
  BBUProgrammer::~BBUProgrammer(v1);
  _Unwind_Resume(a1);
}

void sub_21DF033EC(_Unwind_Exception *a1)
{
  BBUProgrammer::~BBUProgrammer(v1);
  _Unwind_Resume(a1);
}

void sub_21DF03400(_Unwind_Exception *a1)
{
  BBUProgrammer::~BBUProgrammer(v1);
  _Unwind_Resume(a1);
}

void BBUICEProgrammer::~BBUICEProgrammer(BBUICEProgrammer *this)
{
  *(void *)this = &unk_26CECEA50;
  uint64_t v2 = (char *)this + 40;
  for (uint64_t i = *((void *)this + 6); (char *)i != v2; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v4 = *(void *)(i + 16);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*((void *)this + 7))
  {
    uint64_t v6 = *((void *)this + 5);
    uint64_t v5 = (char *)*((void *)this + 6);
    uint64_t v7 = *(void *)v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    *((void *)this + 7) = 0;
    if (v5 != v2)
    {
      do
      {
        uint64_t v8 = (char *)*((void *)v5 + 1);
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
}

{
  char *v2;
  uint64_t i;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;

  *(void *)this = &unk_26CECEA50;
  uint64_t v2 = (char *)this + 40;
  for (uint64_t i = *((void *)this + 6); (char *)i != v2; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v4 = *(void *)(i + 16);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*((void *)this + 7))
  {
    uint64_t v6 = *((void *)this + 5);
    uint64_t v5 = (char *)*((void *)this + 6);
    uint64_t v7 = *(void *)v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    *((void *)this + 7) = 0;
    if (v5 != v2)
    {
      do
      {
        uint64_t v8 = (char *)*((void *)v5 + 1);
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }
}

{
  char *v2;
  uint64_t i;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t vars8;

  *(void *)this = &unk_26CECEA50;
  uint64_t v2 = (char *)this + 40;
  for (uint64_t i = *((void *)this + 6); (char *)i != v2; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v4 = *(void *)(i + 16);
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*((void *)this + 7))
  {
    uint64_t v6 = *((void *)this + 5);
    uint64_t v5 = (char *)*((void *)this + 6);
    uint64_t v7 = *(void *)v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    *((void *)this + 7) = 0;
    if (v5 != v2)
    {
      do
      {
        uint64_t v8 = (char *)*((void *)v5 + 1);
        operator delete(v5);
        uint64_t v5 = v8;
      }
      while (v8 != v2);
    }
  }

  operator delete(this);
}

uint64_t BBUICEProgrammer::enableStepThroughImages(uint64_t this)
{
  *(unsigned char *)(this + 80) = 1;
  return this;
}

uint64_t BBUICEProgrammer::getConnectTries(BBUICEProgrammer *this)
{
  return *((unsigned int *)this + 17);
}

uint64_t BBUICEProgrammer::getConnectTimeout(BBUICEProgrammer *this)
{
  return *((unsigned int *)this + 18);
}

uint64_t BBUICEProgrammer::getCommandTimeout(BBUICEProgrammer *this)
{
  return *((unsigned int *)this + 19);
}

void BBUICEProgrammer::gatherPersonalizationParameters(BBUICEProgrammer *this, BOOL a2, BOOL a3, unsigned int *a4, BBUPersonalizationParameters *a5)
{
  exception = __cxa_allocate_exception(0x210uLL);
  _BBUException::_BBUException((uint64_t)exception, 68, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/ICE/BBUICEProgrammer.cpp", 0x36u, (ctu::LogMessageBuffer *)"Assertion failure(false && \"Error in gathering personalization parameters.\")", v6, v7, v8, v9);
}

void sub_21DF03710(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void BBUICEProgrammer::program()
{
  exception = __cxa_allocate_exception(0x210uLL);
  _BBUException::_BBUException((uint64_t)exception, 68, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Protocol/ICE/BBUICEProgrammer.cpp", 0x3Du, (ctu::LogMessageBuffer *)"Assertion failure(false && \"Programmer failure.\")", v1, v2, v3, v4);
}

void sub_21DF0377C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUProgrammer::load()
{
  return 9;
}

uint64_t BBUProgrammer::eraseEFS(BBUProgrammer *this)
{
  return 0;
}

uint64_t BBUProgrammer::collectCoreDump()
{
  return 0;
}

{
  return 0;
}

uint64_t BBUICEProgrammer::getEFSEraseIndicated(BBUICEProgrammer *this)
{
  return 0;
}

void BBUProgrammer::getHashVerifiedFiles(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void *BBULogCircularBuffer::clearLog(void *this)
{
  this[1] = 0;
  this[3] = this[2];
  return this;
}

void *virtual thunk to'BBULogCircularBuffer::clearLog(void *this)
{
  uint64_t v1 = (void *)((char *)this + *(void *)(*this - 24));
  v1[1] = 0;
  v1[3] = v1[2];
  return this;
}

uint64_t BBULogCircularBuffer::log(BBULogCircularBuffer *this, const char *a2, size_t a3)
{
  if (a2) {
    BOOL v3 = a3 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  uint64_t v4 = !v3;
  if (!v3 && *((unsigned char *)this + 56))
  {
    uint64_t v7 = *((void *)this + 1);
    size_t v6 = *((void *)this + 2);
    size_t v8 = a3 - v6;
    if (a3 < v6) {
      size_t v8 = 0;
    }
    char v9 = &a2[v8];
    if (v6 >= a3) {
      size_t v10 = a3;
    }
    else {
      size_t v10 = *((void *)this + 2);
    }
    size_t v11 = v6 - v7;
    uint64_t v12 = (void *)(*((void *)this + 4) + v7);
    if (v10 <= v6 - v7)
    {
      memcpy(v12, &a2[v8], v10);
    }
    else
    {
      memcpy(v12, &a2[v8], v11);
      size_t v13 = *((void *)this + 3);
      uint64_t v14 = *((void *)this + 4);
      BOOL v15 = v13 >= v11;
      size_t v16 = v13 - v11;
      if (!v15) {
        size_t v16 = 0;
      }
      *((void *)this + 3) = v16;
      size_t v17 = (*((void *)this + 1) + v11) % *((void *)this + 2);
      *((void *)this + 1) = v17;
      memcpy((void *)(v14 + v17), &v9[v11], v10 - v11);
      v10 -= v11;
    }
    unint64_t v19 = *((void *)this + 2);
    size_t v18 = *((void *)this + 3);
    BOOL v15 = v18 >= v10;
    size_t v20 = v18 - v10;
    if (!v15) {
      size_t v20 = 0;
    }
    *((void *)this + 3) = v20;
    *((void *)this + 1) = (*((void *)this + 1) + v10) % v19;
  }
  return v4;
}

uint64_t virtual thunk to'BBULogCircularBuffer::log(BBULogCircularBuffer *this, const char *a2, size_t a3)
{
  uint64_t v3 = *(void *)(*(void *)this - 40);
  if (a2) {
    BOOL v4 = a3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  uint64_t v5 = !v4;
  if (!v4)
  {
    size_t v6 = (void *)((char *)this + v3);
    if (*((unsigned char *)this + v3 + 56))
    {
      uint64_t v8 = v6[1];
      size_t v7 = v6[2];
      size_t v9 = a3 - v7;
      if (a3 < v7) {
        size_t v9 = 0;
      }
      size_t v10 = &a2[v9];
      if (v7 >= a3) {
        size_t v11 = a3;
      }
      else {
        size_t v11 = v6[2];
      }
      size_t v12 = v7 - v8;
      size_t v13 = (void *)(v6[4] + v8);
      if (v11 <= v7 - v8)
      {
        memcpy(v13, &a2[v9], v11);
      }
      else
      {
        memcpy(v13, &a2[v9], v12);
        size_t v14 = v6[3];
        uint64_t v15 = v6[4];
        BOOL v16 = v14 >= v12;
        size_t v17 = v14 - v12;
        if (!v16) {
          size_t v17 = 0;
        }
        v6[3] = v17;
        size_t v18 = (v6[1] + v12) % v6[2];
        v6[1] = v18;
        memcpy((void *)(v15 + v18), &v10[v12], v11 - v12);
        v11 -= v12;
      }
      unint64_t v20 = v6[2];
      size_t v19 = v6[3];
      BOOL v16 = v19 >= v11;
      size_t v21 = v19 - v11;
      if (!v16) {
        size_t v21 = 0;
      }
      v6[3] = v21;
      v6[1] = (v6[1] + v11) % v20;
    }
  }
  return v5;
}

uint64_t BBULogCircularBuffer::enable(uint64_t this)
{
  *(unsigned char *)(this + 56) = 1;
  return this;
}

void *virtual thunk to'BBULogCircularBuffer::enable(void *this)
{
  *((unsigned char *)this + *(void *)(*this - 48) + 56) = 1;
  return this;
}

uint64_t BBULogCircularBuffer::disable(uint64_t this)
{
  *(unsigned char *)(this + 56) = 0;
  return this;
}

void *virtual thunk to'BBULogCircularBuffer::disable(void *this)
{
  *((unsigned char *)this + *(void *)(*this - 56) + 56) = 0;
  return this;
}

uint64_t BBULogCircularBuffer::getLogAsStringStreamSharedRef@<X0>(BBULogCircularBuffer *this@<X0>, void *a2@<X8>)
{
  *a2 = 0xAAAAAAAAAAAAAAAALL;
  a2[1] = 0xAAAAAAAAAAAAAAAALL;
  BOOL v4 = operator new(0x118uLL);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v4);
  *a2 = v4;
  uint64_t v5 = operator new(0x20uLL);
  void *v5 = &unk_26CECB888;
  v5[1] = 0;
  uint64_t v5[2] = 0;
  v5[3] = v4;
  a2[1] = v5;
  if (!*((void *)this + 3)) {
    std::ostream::write();
  }
  if (*((void *)this + 1)) {
    std::ostream::write();
  }
  return (**(uint64_t (***)(BBULogCircularBuffer *))this)(this);
}

void sub_21DF03B1C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_21DF03B50(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_21DF03B64(_Unwind_Exception *a1)
{
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t virtual thunk to'BBULogCircularBuffer::getLogAsStringStreamSharedRef@<X0>(BBULogCircularBuffer *this@<X0>, void *a2@<X8>)
{
  return BBULogCircularBuffer::getLogAsStringStreamSharedRef((BBULogCircularBuffer *)((char *)this + *(void *)(*(void *)this - 64)), a2);
}

void BBULogCircularBuffer::resize(BBULogCircularBuffer *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((unsigned char *)this + 56))
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        return;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        return;
      }
    }
    if (gBBULogVerbosity >= 6) {
      goto LABEL_42;
    }
  }
  else
  {
    if (*((void *)this + 2) < a2)
    {
      size_t v11 = (char *)*((void *)this + 4);
      size_t v10 = (char *)*((void *)this + 5);
      unint64_t v12 = v10 - v11;
      if (a2 <= v10 - v11)
      {
        if (a2 < v10 - v11) {
          *((void *)this + 5) = &v11[a2];
        }
        goto LABEL_33;
      }
      uint64_t v13 = *((void *)this + 6);
      if (v13 - (uint64_t)v10 >= a2 - (v10 - v11))
      {
        bzero(*((void **)this + 5), a2 - (v10 - v11));
        *((void *)this + 5) = &v11[a2];
LABEL_33:
        *((void *)this + 2) = a2;
        *((void *)this + 3) = a2;
        *((void *)this + 1) = 0;
        return;
      }
      if ((a2 & 0x8000000000000000) != 0) {
        std::vector<unsigned char>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v14 = v13 - (void)v11;
      uint64_t v15 = 2 * v14;
      if (2 * v14 <= a2) {
        uint64_t v15 = a2;
      }
      if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v16 = v15;
      }
      size_t v17 = (char *)operator new(v16);
      size_t v18 = &v17[v12];
      size_t v19 = &v17[v16];
      bzero(&v17[v12], a2 - (v10 - v11));
      if (v10 == v11)
      {
LABEL_31:
        *((void *)this + 4) = v18;
        *((void *)this + 5) = &v17[a2];
        *((void *)this + 6) = v19;
        if (v10) {
          operator delete(v10);
        }
        goto LABEL_33;
      }
      if (v12 >= 8 && (unint64_t)(v11 - v17) >= 0x20)
      {
        if (v12 < 0x20)
        {
          unint64_t v20 = 0;
          goto LABEL_23;
        }
        unint64_t v20 = v12 & 0xFFFFFFFFFFFFFFE0;
        size_t v21 = v10 - 16;
        char v22 = &v17[v10 - 16 - v11];
        unint64_t v23 = v12 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v24 = *(_OWORD *)v21;
          *((_OWORD *)v22 - 1) = *((_OWORD *)v21 - 1);
          *(_OWORD *)char v22 = v24;
          v22 -= 32;
          v21 -= 32;
          v23 -= 32;
        }
        while (v23);
        if (v12 == v20) {
          goto LABEL_30;
        }
        if ((v12 & 0x18) != 0)
        {
LABEL_23:
          v18 -= v12 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v25 = &v10[-v20 - 8];
          long long v26 = (char *)(v25 - v11);
          unint64_t v27 = v20 - (v12 & 0xFFFFFFFFFFFFFFF8);
          do
          {
            uint64_t v28 = *(void *)v25;
            v25 -= 8;
            *(void *)&v26[(void)v17] = v28;
            v26 -= 8;
            v27 += 8;
          }
          while (v27);
          v10 -= v12 & 0xFFFFFFFFFFFFFFF8;
          if (v12 == (v12 & 0xFFFFFFFFFFFFFFF8)) {
            goto LABEL_30;
          }
          goto LABEL_28;
        }
        v18 -= v20;
        v10 -= v20;
      }
LABEL_28:
      char v29 = v18 - 1;
      do
      {
        char v30 = *--v10;
        *v29-- = v30;
      }
      while (v10 != v11);
LABEL_30:
      size_t v10 = v11;
      size_t v18 = v17;
      goto LABEL_31;
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        return;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 2) == 0) {
        return;
      }
    }
    if (gBBULogVerbosity >= 6) {
LABEL_42:
    }
      _BBULog(1, 6, "BBULogCircularBuffer", (const char *)&str_3, "check failed: %s, %d, assertion: %s\n", a6, a7, a8, (char)"/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBULogCircularBuffer.cpp");
  }
}

void virtual thunk to'BBULogCircularBuffer::resize(BBULogCircularBuffer *this, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void std::__shared_ptr_pointer<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> *,std::shared_ptr<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>::__shared_ptr_default_delete<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>,std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>,std::allocator<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> *,std::shared_ptr<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>::__shared_ptr_default_delete<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>,std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>,std::allocator<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>> *,std::shared_ptr<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>::__shared_ptr_default_delete<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>,std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>,std::allocator<std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFAC06DLL) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFAC06DLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFAC06DLL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFAC06DLL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

uint64_t BBUICEUpdateSource::containsFile(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (!v4)
  {
    int v6 = *(char *)(a1 + 103);
    if (v6 >= 0) {
      size_t v7 = *(unsigned __int8 *)(a1 + 103);
    }
    else {
      size_t v7 = *(void *)(a1 + 88);
    }
    unint64_t v8 = v7 + 1;
    memset(&__dst, 170, sizeof(__dst));
    if (v7 + 1 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v8 >= 0x17)
    {
      uint64_t v10 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v8 | 7) != 0x17) {
        uint64_t v10 = v8 | 7;
      }
      uint64_t v11 = v10 + 1;
      p_dst = (std::string *)operator new(v10 + 1);
      __dst.__r_.__value_.__l.__size_ = v7 + 1;
      __dst.__r_.__value_.__r.__words[2] = v11 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v7 + 1;
      if (!v7) {
        goto LABEL_19;
      }
    }
    if (v6 >= 0) {
      unint64_t v12 = (const void *)(a1 + 80);
    }
    else {
      unint64_t v12 = *(const void **)(a1 + 80);
    }
    memmove(p_dst, v12, v7);
LABEL_19:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v7) = 47;
    int v13 = *(char *)(a2 + 23);
    if (v13 >= 0) {
      unint64_t v14 = (const std::string::value_type *)a2;
    }
    else {
      unint64_t v14 = *(const std::string::value_type **)a2;
    }
    if (v13 >= 0) {
      std::string::size_type v15 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      std::string::size_type v15 = *(void *)(a2 + 8);
    }
    size_t v16 = std::string::append(&__dst, v14, v15);
    long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    std::string::size_type v21 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    uint64_t v18 = ctu::fs::file_exists();
    if (SHIBYTE(v21) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v18;
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      return v18;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    return v18;
  }

  return BBUZipFile::containsFile(v4, (void *)a2);
}

void sub_21DF0414C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if ((a15 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a15 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a10);
  _Unwind_Resume(exception_object);
}

void BBUICEUpdateSource::listFiles(uint64_t a1, uint64_t *a2, unsigned __int8 *a3)
{
  uint64_t v71 = (uint64_t)&v71;
  uint64_t v72 = &v71;
  uint64_t v73 = 0;
  if (*(void *)(a1 + 64))
  {
    BBUZipFile::getFileList(*(BBUZipFile **)(a1 + 64), &__p);
    if (v73)
    {
      uint64_t v5 = v71;
      int v6 = v72;
      uint64_t v7 = *v72;
      *(void *)(v7 + 8) = *(void *)(v71 + 8);
      **(void **)(v5 + 8) = v7;
      uint64_t v73 = 0;
      if (v6 != &v71)
      {
        do
        {
          unint64_t v12 = (uint64_t *)v6[1];
          if (*((char *)v6 + 39) < 0) {
            operator delete((void *)v6[2]);
          }
          operator delete(v6);
          int v6 = v12;
        }
        while (v12 != &v71);
      }
    }
    std::string::size_type v8 = __p.__r_.__value_.__r.__words[2];
    if (__p.__r_.__value_.__r.__words[2])
    {
      long long v9 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      uint64_t v10 = *(void *)__p.__r_.__value_.__l.__size_;
      *(void *)(v10 + 8) = *(void *)(__p.__r_.__value_.__r.__words[0] + 8);
      **(void **)(v9 + 8) = v10;
      uint64_t v11 = v71;
      *(void *)(v71 + 8) = *((void *)&v9 + 1);
      **((void **)&v9 + 1) = v11;
      *(void *)(v9 + 8) = &v71;
      uint64_t v71 = v9;
      v73 += v8;
    }
  }
  else
  {
    BBUpdaterCommon::BBUReadDirectory((const char *)(a1 + 80), &v71);
  }
  uint64_t v13 = a3[23];
  if ((v13 & 0x80u) != 0) {
    uint64_t v13 = *((void *)a3 + 1);
  }
  if (v13)
  {
    for (uint64_t i = v72; i != &v71; uint64_t i = (uint64_t *)i[1])
    {
      memset(&__p, 170, sizeof(__p));
      if (*((char *)i + 39) < 0) {
        std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)i[2], i[3]);
      }
      else {
        std::string __p = *(std::string *)(i + 2);
      }
      uint64_t v15 = a3[23];
      if ((char)a3[23] < 0)
      {
        std::string::size_type v16 = *((void *)a3 + 1);
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_22:
          if (v16 > size) {
            continue;
          }
          std::string::size_type v18 = size;
LABEL_26:
          if ((v15 & 0x80) != 0)
          {
            std::string::size_type v19 = v18 - *((void *)a3 + 1);
            if ((size & 0x80) == 0) {
              goto LABEL_28;
            }
          }
          else
          {
            std::string::size_type v19 = v18 - v15;
            if ((size & 0x80) == 0)
            {
LABEL_28:
              if (v19 > size) {
                goto LABEL_114;
              }
              p_p = &__p;
              size_t v21 = size - v19;
              if (size - v19 >= 0x7FFFFFFFFFFFFFF8) {
                goto LABEL_115;
              }
              goto LABEL_34;
            }
          }
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
          if (__p.__r_.__value_.__l.__size_ < v19) {
LABEL_114:
          }
            std::string::__throw_out_of_range[abi:ne180100]();
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          size_t v21 = __p.__r_.__value_.__l.__size_ - v19;
          if (__p.__r_.__value_.__l.__size_ - v19 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_115:
          }
            std::string::__throw_length_error[abi:ne180100]();
LABEL_34:
          if (v21 >= 0x17)
          {
            uint64_t v23 = (v21 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v21 | 7) != 0x17) {
              uint64_t v23 = v21 | 7;
            }
            uint64_t v24 = v23 + 1;
            p_dst = (void **)operator new(v23 + 1);
            size_t v68 = v21;
            int64_t v69 = v24 | 0x8000000000000000;
            std::string __dst = p_dst;
          }
          else
          {
            HIBYTE(v69) = v21;
            p_dst = (void **)&__dst;
            if (size == v19)
            {
LABEL_41:
              BOOL v25 = 0;
              *((unsigned char *)p_dst + v21) = 0;
              uint64_t v26 = a3[23];
              if ((v26 & 0x80u) == 0) {
                uint64_t v27 = a3[23];
              }
              else {
                uint64_t v27 = *((void *)a3 + 1);
              }
              size_t v28 = HIBYTE(v69);
              int v29 = SHIBYTE(v69);
              if (v69 < 0) {
                size_t v28 = v68;
              }
              if (v27 == v28)
              {
                if (v69 >= 0) {
                  char v30 = (void **)&__dst;
                }
                else {
                  char v30 = __dst;
                }
                if ((v26 & 0x80) != 0)
                {
                  BOOL v25 = memcmp(*(const void **)a3, v30, *((void *)a3 + 1)) == 0;
                  if (v29 < 0) {
                    goto LABEL_63;
                  }
                }
                else
                {
                  if (a3[23])
                  {
                    uint64_t v31 = v26 - 1;
                    uint64_t v32 = a3;
                    do
                    {
                      int v34 = *v32++;
                      int v33 = v34;
                      int v36 = *(unsigned __int8 *)v30;
                      char v30 = (void **)((char *)v30 + 1);
                      int v35 = v36;
                      BOOL v38 = v31-- != 0;
                      BOOL v25 = v33 == v35;
                    }
                    while (v33 == v35 && v38);
                    goto LABEL_58;
                  }
                  BOOL v25 = 1;
                  if (SHIBYTE(v69) < 0)
                  {
LABEL_63:
                    operator delete(__dst);
                    if (!v25)
                    {
LABEL_64:
                      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                        continue;
                      }
                      goto LABEL_15;
                    }
                    goto LABEL_60;
                  }
                }
              }
              else
              {
LABEL_58:
                if (SHIBYTE(v69) < 0) {
                  goto LABEL_63;
                }
              }
              if (!v25) {
                goto LABEL_64;
              }
LABEL_60:
              size_t v39 = operator new(0x28uLL);
              unint64_t v40 = (std::string *)(v39 + 2);
              *size_t v39 = 0;
              v39[1] = 0;
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
              {
                std::string::__init_copy_ctor_external(v40, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
              }
              else
              {
                *(_OWORD *)&v40->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                _OWORD v39[4] = *((void *)&__p.__r_.__value_.__l + 2);
              }
              uint64_t v41 = *a2;
              *size_t v39 = *a2;
              v39[1] = a2;
              *(void *)(v41 + 8) = v39;
              *a2 = (uint64_t)v39;
              ++a2[2];
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                continue;
              }
              goto LABEL_15;
            }
          }
          memmove(p_dst, (char *)p_p + v19, v21);
          goto LABEL_41;
        }
      }
      else
      {
        std::string::size_type v16 = a3[23];
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_22;
        }
      }
      std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
      if (v16 <= __p.__r_.__value_.__l.__size_) {
        goto LABEL_26;
      }
LABEL_15:
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else if (&v71 != a2)
  {
    long long v42 = v72;
    long long v43 = (uint64_t *)a2[1];
    if (v72 != &v71 && v43 != a2)
    {
      do
      {
        if (v43 != v42)
        {
          uint64_t v47 = (void **)(v43 + 2);
          char v48 = *((unsigned char *)v42 + 39);
          if (*((char *)v43 + 39) < 0)
          {
            if (v48 >= 0) {
              size_t v44 = v42 + 2;
            }
            else {
              size_t v44 = (void *)v42[2];
            }
            if (v48 >= 0) {
              size_t v45 = *((unsigned __int8 *)v42 + 39);
            }
            else {
              size_t v45 = v42[3];
            }
            std::string::__assign_no_alias<false>(v47, v44, v45);
          }
          else if ((*((unsigned char *)v42 + 39) & 0x80) != 0)
          {
            std::string::__assign_no_alias<true>(v47, (void *)v42[2], v42[3]);
          }
          else
          {
            long long v49 = *((_OWORD *)v42 + 1);
            v43[4] = v42[4];
            *(_OWORD *)uint64_t v47 = v49;
          }
        }
        long long v42 = (uint64_t *)v42[1];
        long long v43 = (uint64_t *)v43[1];
      }
      while (v42 != &v71 && v43 != a2);
    }
    if (v43 == a2)
    {
      if (v42 != &v71)
      {
        long long v53 = operator new(0x28uLL);
        std::string v54 = (std::string *)(v53 + 2);
        *long long v53 = 0;
        v53[1] = 0;
        if (*((char *)v42 + 39) < 0)
        {
          std::string::__init_copy_ctor_external(v54, (const std::string::value_type *)v42[2], v42[3]);
        }
        else
        {
          long long v55 = *((_OWORD *)v42 + 1);
          _OWORD v53[4] = v42[4];
          *(_OWORD *)&v54->__r_.__value_.__l.__data_ = v55;
        }
        uint64_t v56 = v42[1];
        uint64_t v57 = 1;
        if ((uint64_t *)v56 == &v71)
        {
          uint64_t v60 = v53;
        }
        else
        {
          uint64_t v58 = v53;
          do
          {
            uint64_t v60 = operator new(0x28uLL);
            void *v60 = v58;
            v60[1] = 0;
            char v61 = (std::string *)(v60 + 2);
            if (*(char *)(v56 + 39) < 0)
            {
              std::string::__init_copy_ctor_external(v61, *(const std::string::value_type **)(v56 + 16), *(void *)(v56 + 24));
            }
            else
            {
              long long v59 = *(_OWORD *)(v56 + 16);
              v60[4] = *(void *)(v56 + 32);
              *(_OWORD *)&v61->__r_.__value_.__l.__data_ = v59;
            }
            v58[1] = v60;
            ++v57;
            uint64_t v56 = *(void *)(v56 + 8);
            uint64_t v58 = v60;
          }
          while ((uint64_t *)v56 != &v71);
        }
        uint64_t v62 = *a2;
        *(void *)(v62 + 8) = v53;
        *long long v53 = v62;
        *a2 = (uint64_t)v60;
        v60[1] = a2;
        a2[2] += v57;
      }
    }
    else
    {
      uint64_t v50 = *a2;
      uint64_t v51 = *v43;
      *(void *)(v51 + 8) = *(void *)(*a2 + 8);
      **(void **)(v50 + 8) = v51;
      do
      {
        uint64_t v52 = (uint64_t *)v43[1];
        --a2[2];
        if (*((char *)v43 + 39) < 0) {
          operator delete((void *)v43[2]);
        }
        operator delete(v43);
        long long v43 = v52;
      }
      while (v52 != a2);
    }
  }
  if (v73)
  {
    uint64_t v63 = v71;
    long long v64 = v72;
    uint64_t v65 = *v72;
    *(void *)(v65 + 8) = *(void *)(v71 + 8);
    **(void **)(v63 + 8) = v65;
    uint64_t v73 = 0;
    if (v64 != &v71)
    {
      do
      {
        long long v66 = (uint64_t *)v64[1];
        if (*((char *)v64 + 39) < 0) {
          operator delete((void *)v64[2]);
        }
        operator delete(v64);
        long long v64 = v66;
      }
      while (v66 != &v71);
    }
  }
}

void sub_21DF04780(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  operator delete(v16);
  std::list<std::string>::~list(&a16);
  _Unwind_Resume(a1);
}

void sub_21DF0479C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  operator delete(v17);
  __cxa_begin_catch(a1);
  while (1)
  {
    std::string::size_type v19 = (void **)*v16;
    if (*((char *)v16 + 39) < 0) {
      operator delete(v16[2]);
    }
    operator delete(v16);
    std::string::size_type v16 = v19;
    if (!v19) {
      __cxa_rethrow();
    }
  }
}

void sub_21DF04814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  operator delete(v19);
  if (a18 < 0) {
    operator delete(__p);
  }
  std::list<std::string>::~list(&a19);
  _Unwind_Resume(a1);
}

void *BBUICEUpdateSource::createDataSource(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 64);
  if (!v6)
  {
    int v9 = *(char *)(a1 + 103);
    if (v9 >= 0) {
      size_t v10 = *(unsigned __int8 *)(a1 + 103);
    }
    else {
      size_t v10 = *(void *)(a1 + 88);
    }
    unint64_t v11 = v10 + 1;
    memset(&__dst, 170, sizeof(__dst));
    if (v10 + 1 >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    if (v11 >= 0x17)
    {
      uint64_t v13 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v13 = v11 | 7;
      }
      uint64_t v14 = v13 + 1;
      p_dst = (std::string *)operator new(v13 + 1);
      __dst.__r_.__value_.__l.__size_ = v10 + 1;
      __dst.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v10 + 1;
      if (!v10) {
        goto LABEL_23;
      }
    }
    if (v9 >= 0) {
      uint64_t v15 = (const void *)(a1 + 80);
    }
    else {
      uint64_t v15 = *(const void **)(a1 + 80);
    }
    memmove(p_dst, v15, v10);
LABEL_23:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v10) = 47;
    int v16 = *(char *)(a2 + 23);
    if (v16 >= 0) {
      long long v17 = (const std::string::value_type *)a2;
    }
    else {
      long long v17 = *(const std::string::value_type **)a2;
    }
    if (v16 >= 0) {
      std::string::size_type v18 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      std::string::size_type v18 = *(void *)(a2 + 8);
    }
    std::string::size_type v19 = std::string::append(&__dst, v17, v18);
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    std::string::size_type v24 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v8 = operator new(0x30uLL);
    *std::string::size_type v8 = &unk_26CECA448;
    *(_OWORD *)(v8 + 1) = 0u;
    *(_OWORD *)(v8 + 3) = 0u;
    if (BBUFileDataSource::init((uint64_t)v8, (const char *)__p, a3))
    {
      (*(void (**)(void *))(*v8 + 8))(v8);
      std::string::size_type v8 = 0;
    }
    if (SHIBYTE(v24) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return v8;
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      return v8;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    return v8;
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 72);
  uint64_t v25 = *(void *)(a1 + 64);
  uint64_t v26 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  std::string::size_type v8 = operator new(0x38uLL);
  *std::string::size_type v8 = &unk_26CECBB38;
  v8[1] = v6;
  unint64_t v8[4] = 0;
  void v8[5] = 0;
  v8[3] = 0;
  if (BBUZipDataSource::init((uint64_t)v8, (void *)a2, a3))
  {
    (*(void (**)(void *))(*v8 + 8))(v8);
    std::string::size_type v8 = 0;
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return v8;
}

void sub_21DF04B28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBUICEUpdateSource::saveFile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (!v4)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x58u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"Error: BBU firmware data error!\")", v39, v40, v41, v42);
  }
  if (!BBUZipFile::containsFile(v4, (void *)a2)) {
    return 35;
  }
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 72);
  uint64_t v55 = v8;
  uint64_t v56 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v9 = operator new(0x38uLL);
  *int v9 = &unk_26CECBB38;
  v9[1] = v8;
  void v9[4] = 0;
  v9[5] = 0;
  v9[3] = 0;
  if (BBUZipDataSource::init((uint64_t)v9, (void *)a2, 0))
  {
    (*(void (**)(void *))(*v9 + 8))(v9);
    int v9 = 0;
  }
  if (!v7 || atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (v9) {
      goto LABEL_10;
    }
    return 35;
  }
  ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
  std::__shared_weak_count::__release_weak(v7);
  if (!v9) {
    return 35;
  }
LABEL_10:
  unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53[7] = v10;
  v53[8] = v10;
  v53[5] = v10;
  v53[6] = v10;
  v53[3] = v10;
  _OWORD v53[4] = v10;
  v53[1] = v10;
  v53[2] = v10;
  v53[0] = v10;
  long long v51 = v10;
  long long v52 = v10;
  long long v49 = v10;
  *(_OWORD *)std::string __p = v10;
  long long v47 = v10;
  long long v48 = v10;
  long long v46 = v10;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v46);
  int v11 = *(char *)(a3 + 23);
  if (v11 >= 0) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = *(void *)a3;
  }
  if (v11 >= 0) {
    uint64_t v13 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v13 = *(void *)(a3 + 8);
  }
  uint64_t v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v46, v12, v13);
  uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"/", 1);
  int v16 = *(char *)(a2 + 23);
  if (v16 >= 0) {
    uint64_t v17 = a2;
  }
  else {
    uint64_t v17 = *(void *)a2;
  }
  if (v16 >= 0) {
    uint64_t v18 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v18 = *(void *)(a2 + 8);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, v17, v18);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_44;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_44;
    }
  }
  if (gBBULogVerbosity < 0) {
    goto LABEL_44;
  }
  char v22 = (const char *)(**(uint64_t (***)(uint64_t))a1)(a1);
  if ((BYTE8(v52) & 0x10) != 0)
  {
    uint64_t v26 = v52;
    if ((unint64_t)v52 < *((void *)&v49 + 1))
    {
      *(void *)&long long v52 = *((void *)&v49 + 1);
      uint64_t v26 = *((void *)&v49 + 1);
    }
    uint64_t v27 = (const void *)v49;
    size_t v23 = v26 - v49;
    if ((unint64_t)(v26 - v49) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_66;
    }
  }
  else
  {
    if ((BYTE8(v52) & 8) == 0)
    {
      size_t v23 = 0;
      HIBYTE(v45) = 0;
      p_dst = (void **)&__dst;
      goto LABEL_40;
    }
    uint64_t v27 = (const void *)*((void *)&v47 + 1);
    size_t v23 = *((void *)&v48 + 1) - *((void *)&v47 + 1);
    if (*((void *)&v48 + 1) - *((void *)&v47 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_66:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v23 >= 0x17)
  {
    uint64_t v28 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v23 | 7) != 0x17) {
      uint64_t v28 = v23 | 7;
    }
    uint64_t v29 = v28 + 1;
    p_dst = (void **)operator new(v28 + 1);
    size_t v44 = v23;
    int64_t v45 = v29 | 0x8000000000000000;
    std::string __dst = p_dst;
  }
  else
  {
    HIBYTE(v45) = v23;
    p_dst = (void **)&__dst;
    if (!v23) {
      goto LABEL_40;
    }
  }
  memmove(p_dst, v27, v23);
LABEL_40:
  *((unsigned char *)p_dst + v23) = 0;
  char v30 = (void **)&__dst;
  if (v45 < 0) {
    LOBYTE(v30) = (_BYTE)__dst;
  }
  _BBULog(3, 0, v22, "", "Saving %s\n", v19, v20, v21, (char)v30);
  if (SHIBYTE(v45) < 0) {
    operator delete(__dst);
  }
LABEL_44:
  if ((BYTE8(v52) & 0x10) != 0)
  {
    uint64_t v33 = v52;
    if ((unint64_t)v52 < *((void *)&v49 + 1))
    {
      *(void *)&long long v52 = *((void *)&v49 + 1);
      uint64_t v33 = *((void *)&v49 + 1);
    }
    int v34 = (const void *)v49;
    size_t v31 = v33 - v49;
    if ((unint64_t)(v33 - v49) > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_64;
    }
  }
  else
  {
    if ((BYTE8(v52) & 8) == 0)
    {
      size_t v31 = 0;
      HIBYTE(v45) = 0;
      uint64_t v32 = (void **)&__dst;
      goto LABEL_57;
    }
    int v34 = (const void *)*((void *)&v47 + 1);
    size_t v31 = *((void *)&v48 + 1) - *((void *)&v47 + 1);
    if (*((void *)&v48 + 1) - *((void *)&v47 + 1) > 0x7FFFFFFFFFFFFFF7uLL) {
LABEL_64:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v31 >= 0x17)
  {
    uint64_t v35 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v31 | 7) != 0x17) {
      uint64_t v35 = v31 | 7;
    }
    uint64_t v36 = v35 + 1;
    uint64_t v32 = (void **)operator new(v35 + 1);
    size_t v44 = v31;
    int64_t v45 = v36 | 0x8000000000000000;
    std::string __dst = v32;
  }
  else
  {
    HIBYTE(v45) = v31;
    uint64_t v32 = (void **)&__dst;
    if (!v31) {
      goto LABEL_57;
    }
  }
  memmove(v32, v34, v31);
LABEL_57:
  *((unsigned char *)v32 + v31) = 0;
  uint64_t v25 = (*(uint64_t (**)(void *, void ***, void))(*v9 + 48))(v9, &__dst, 0);
  if (SHIBYTE(v45) < 0) {
    operator delete(__dst);
  }
  (*(void (**)(void *))(*v9 + 8))(v9);
  *(void *)&long long v46 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v46 + *(void *)(v46 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v46 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v51) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v53);
  return v25;
}

void sub_21DF05130(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    std::ostringstream::~ostringstream((uint64_t)&a16);
    _Unwind_Resume(a1);
  }
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t BBUICEUpdateSource::saveImages(BBUICEUpdateSource *this)
{
  if (!*((void *)this + 8))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x72u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"Error: BBU firmware data error!\")", v28, v29, v30, v35);
  }
  memset(__src, 170, 24);
  capabilities::radio::personalizedFirmwarePath(__src, this);
  if (SHIBYTE(__src[2]) < 0)
  {
    if (__src[1])
    {
      uint64_t v2 = (const char *)__src[0];
      goto LABEL_7;
    }
LABEL_75:
    size_t v31 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v31, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x75u, (ctu::LogMessageBuffer *)"Assertion failure(folder.empty() != true && \"Failed finding the bbfw path.\")", v32, v33, v34, v35);
  }
  if (!HIBYTE(__src[2])) {
    goto LABEL_75;
  }
  uint64_t v2 = (const char *)__src;
LABEL_7:
  BBUFeedback::handleComment(*((BBUFeedback **)this + 1), "Saving image to %s", v2);
  unint64_t v3 = 0;
  v4.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v4.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v37.st_blkstd::string::size_type size = v4;
  *(timespec *)v37.st_qspare = v4;
  v37.st_birthtimespec = v4;
  *(timespec *)&v37.st_std::string::size_type size = v4;
  v37.st_mtimespec = v4;
  v37.st_ctimespec = v4;
  *(timespec *)&v37.st_uid = v4;
  v37.st_atimespec = v4;
  *(timespec *)&v37.st_dev = v4;
  while (1)
  {
    uint64_t v6 = __src[2] >= 0 ? (const char *)__src : (const char *)__src[0];
    int v7 = stat(v6, &v37);
    uint64_t v8 = 0;
    if (v3 == -1 || !v7) {
      break;
    }
    size_t v9 = HIBYTE(__src[2]);
    unint64_t v10 = __src[1];
    if (__src[2] >= 0) {
      unint64_t v11 = HIBYTE(__src[2]);
    }
    else {
      unint64_t v11 = __src[1];
    }
    if (v11 <= v3
      || ((uint64_t v12 = (uint64_t *)__src[0], __src[2] >= 0) ? (v13 = __src) : (v13 = (uint64_t *)__src[0]),
          (uint64_t v14 = memchr((char *)v13 + v3, 47, v11 - v3), v5 = v14 - (unsigned char *)v13, v14) ? (v15 = v5 == -1) : (v15 = 1),
          v15))
    {
      if ((v9 & 0x80) != 0)
      {
        if (!v10)
        {
LABEL_8:
          size_t v5 = 0;
          goto LABEL_9;
        }
        memset(__dst, 170, sizeof(__dst));
        size_t v5 = v10;
        uint64_t v12 = (uint64_t *)__src[0];
        size_t v9 = v10;
        if (v10 >= 0x7FFFFFFFFFFFFFF8) {
          goto LABEL_59;
        }
      }
      else
      {
        if (!v9) {
          goto LABEL_8;
        }
        size_t v5 = v9;
        memset(__dst, 170, sizeof(__dst));
        uint64_t v12 = __src;
      }
    }
    else
    {
      if (!v5) {
        goto LABEL_9;
      }
      memset(__dst, 170, sizeof(__dst));
      if ((v9 & 0x80) != 0)
      {
        if (v10 >= v5) {
          size_t v9 = v5;
        }
        else {
          size_t v9 = v10;
        }
        if (v9 >= 0x7FFFFFFFFFFFFFF8) {
          goto LABEL_59;
        }
      }
      else
      {
        uint64_t v12 = __src;
        if (v9 >= v5) {
          size_t v9 = v5;
        }
        if (v9 >= 0x7FFFFFFFFFFFFFF8) {
LABEL_59:
        }
          std::string::__throw_length_error[abi:ne180100]();
      }
    }
    if (v9 >= 0x17)
    {
      uint64_t v17 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17) {
        uint64_t v17 = v9 | 7;
      }
      uint64_t v18 = v17 + 1;
      int v16 = (void **)operator new(v17 + 1);
      __dst[1] = (void *)v9;
      __dst[2] = (void *)(v18 | 0x8000000000000000);
      __dst[0] = v16;
    }
    else
    {
      HIBYTE(__dst[2]) = v9;
      int v16 = __dst;
      if (!v9) {
        goto LABEL_45;
      }
    }
    memmove(v16, v12, v9);
LABEL_45:
    *((unsigned char *)v16 + v9) = 0;
    if (SHIBYTE(__dst[2]) >= 0) {
      uint64_t v19 = (const char *)__dst;
    }
    else {
      uint64_t v19 = (const char *)__dst[0];
    }
    if (stat(v19, &v37))
    {
      uint64_t v20 = SHIBYTE(__dst[2]) >= 0 ? (const char *)__dst : (const char *)__dst[0];
      if (mkdir(v20, 0x1EDu))
      {
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0)
          {
LABEL_62:
            if ((gBBULogVerbosity & 0x80000000) == 0)
            {
              uint64_t v21 = (const char *)(**(uint64_t (***)(BBUICEUpdateSource *))this)(this);
              uint64_t v25 = __dst;
              if (SHIBYTE(__dst[2]) < 0) {
                LOBYTE(v25) = __dst[0];
              }
              _BBULog(3, 0, v21, "", "Failed to create path %s", v22, v23, v24, (char)v25);
            }
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) != 0) {
            goto LABEL_62;
          }
        }
        if (SHIBYTE(__dst[2]) < 0) {
          operator delete(__dst[0]);
        }
        uint64_t v8 = 35;
        break;
      }
    }
    if (SHIBYTE(__dst[2]) < 0)
    {
      operator delete(__dst[0]);
      unint64_t v3 = v5 + 1;
    }
    else
    {
LABEL_9:
      unint64_t v3 = v5 + 1;
    }
  }
  if (SHIBYTE(__src[2]) < 0) {
    operator delete((void *)__src[0]);
  }
  return v8;
}

void sub_21DF055BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((*(char *)(v15 - 97) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v15 - 97) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)(v15 - 120));
  _Unwind_Resume(exception_object);
}

uint64_t BBUICEUpdateSource::cleanupFirmwareImage(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 64))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x9Bu, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"Error: BBU firmware data error!\")", v27, v28, v29, v34);
  }
  memset(v38, 170, sizeof(v38));
  capabilities::radio::personalizedFirmwarePath((uint64_t *)v38, (capabilities::radio *)a1);
  char v4 = HIBYTE(v38[2]);
  if ((SHIBYTE(v38[2]) & 0x80000000) == 0)
  {
    if (HIBYTE(v38[2]))
    {
      size_t v5 = v38[1];
      goto LABEL_6;
    }
LABEL_44:
    uint64_t v30 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v30, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0xA0u, (ctu::LogMessageBuffer *)"Assertion failure(dirPath.empty() != true && \"Failed finding the bbfw path.\")", v31, v32, v33, v34);
  }
  size_t v5 = v38[1];
  if (!v38[1]) {
    goto LABEL_44;
  }
LABEL_6:
  if (SHIBYTE(v38[2]) >= 0) {
    size_t v6 = HIBYTE(v38[2]);
  }
  else {
    size_t v6 = (size_t)v5;
  }
  unint64_t v7 = v6 + 1;
  memset(&__dst, 170, sizeof(__dst));
  if (v6 + 1 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (v7 >= 0x17)
  {
    uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v9 = v7 | 7;
    }
    uint64_t v10 = v9 + 1;
    p_dst = (std::string *)operator new(v9 + 1);
    __dst.__r_.__value_.__l.__size_ = v6 + 1;
    __dst.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6 + 1;
    if (!v6) {
      goto LABEL_20;
    }
  }
  if (v4 >= 0) {
    unint64_t v11 = v38;
  }
  else {
    unint64_t v11 = (void **)v38[0];
  }
  memmove(p_dst, v11, v6);
LABEL_20:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v6) = 47;
  int v12 = *(char *)(a2 + 23);
  if (v12 >= 0) {
    uint64_t v13 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v13 = *(const std::string::value_type **)a2;
  }
  if (v12 >= 0) {
    std::string::size_type v14 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v14 = *(void *)(a2 + 8);
  }
  uint64_t v15 = std::string::append(&__dst, v13, v14);
  long long v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  int64_t v37 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v17 = (const char *)a2;
  }
  else {
    uint64_t v17 = *(const char **)a2;
  }
  uint64_t v18 = v38;
  if (SHIBYTE(v38[2]) < 0) {
    uint64_t v18 = (void **)v38[0];
  }
  BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 8), "Removing Firmware image [%s] in path [%s]\n", v17, (const char *)v18);
  char v19 = HIBYTE(v37);
  if (v37 >= 0) {
    uint64_t v20 = __p;
  }
  else {
    uint64_t v20 = (void **)__p[0];
  }
  if (unlink((const char *)v20))
  {
    uint64_t v21 = *(BBUFeedback **)(a1 + 8);
    int v22 = *__error();
    uint64_t v23 = __error();
    uint64_t v24 = strerror(*v23);
    BBUFeedback::handleComment(v21, "Unable to remove Firmware image [%s]. Error[%d][%s]\n", (const char *)v20, v22, v24);
    char v19 = HIBYTE(v37);
  }
  if (v19 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v38[2]) & 0x80000000) == 0) {
      return 0;
    }
LABEL_42:
    operator delete(v38[0]);
    return 0;
  }
  if (SHIBYTE(v38[2]) < 0) {
    goto LABEL_42;
  }
  return 0;
}

void sub_21DF05904(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BBUICEUpdateSource::saveFirmwareImage(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 64))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0xB1u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"Error: BBU firmware data error!\")", v28, v29, v30, v31);
  }
  memset(v43, 170, sizeof(v43));
  capabilities::radio::personalizedFirmwarePath(v43, (capabilities::radio *)a1);
  if ((SHIBYTE(v43[2]) & 0x80000000) == 0)
  {
    if (HIBYTE(v43[2])) {
      goto LABEL_4;
    }
LABEL_21:
    long long v16 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v16, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0xB8u, (ctu::LogMessageBuffer *)"Assertion failure(dirPath.empty() != true && \"Failed finding the bbfw path.\")", v17, v18, v19, v31);
  }
  if (!v43[1]) {
    goto LABEL_21;
  }
LABEL_4:
  uint64_t v4 = BBUICEUpdateSource::saveImages((BBUICEUpdateSource *)a1);
  unint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v41[7] = v5;
  v41[8] = v5;
  v41[5] = v5;
  v41[6] = v5;
  v41[3] = v5;
  v41[4] = v5;
  v41[1] = v5;
  v41[2] = v5;
  v41[0] = v5;
  long long v39 = v5;
  long long v40 = v5;
  long long v37 = v5;
  *(_OWORD *)std::string __p = v5;
  long long v35 = v5;
  long long v36 = v5;
  long long v34 = v5;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v34);
  if (v43[2] >= 0) {
    size_t v6 = v43;
  }
  else {
    size_t v6 = (uint64_t *)v43[0];
  }
  if (v43[2] >= 0) {
    uint64_t v7 = HIBYTE(v43[2]);
  }
  else {
    uint64_t v7 = v43[1];
  }
  uint64_t v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v34, (uint64_t)v6, v7);
  uint64_t v9 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"/", 1);
  int v10 = *(char *)(a2 + 23);
  if (v10 >= 0) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = *(void *)a2;
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v12 = *(void *)(a2 + 8);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, v11, v12);
  if (v4) {
    goto LABEL_40;
  }
  uint64_t v13 = *(void *)(a1 + 64);
  if ((BYTE8(v40) & 0x10) != 0)
  {
    uint64_t v20 = v40;
    if ((unint64_t)v40 < *((void *)&v37 + 1))
    {
      *(void *)&long long v40 = *((void *)&v37 + 1);
      uint64_t v20 = *((void *)&v37 + 1);
    }
    uint64_t v21 = (const void *)v37;
    size_t v14 = v20 - v37;
    if ((unint64_t)(v20 - v37) >= 0x7FFFFFFFFFFFFFF8) {
      goto LABEL_46;
    }
  }
  else
  {
    if ((BYTE8(v40) & 8) == 0)
    {
      size_t v14 = 0;
      HIBYTE(v33) = 0;
      uint64_t v15 = __dst;
      goto LABEL_32;
    }
    uint64_t v21 = (const void *)*((void *)&v35 + 1);
    size_t v14 = *((void *)&v36 + 1) - *((void *)&v35 + 1);
    if (*((void *)&v36 + 1) - *((void *)&v35 + 1) >= 0x7FFFFFFFFFFFFFF8uLL) {
LABEL_46:
    }
      std::string::__throw_length_error[abi:ne180100]();
  }
  if (v14 >= 0x17)
  {
    uint64_t v22 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v22 = v14 | 7;
    }
    uint64_t v23 = v22 + 1;
    uint64_t v15 = (void **)operator new(v22 + 1);
    __dst[1] = (void *)v14;
    unint64_t v33 = v23 | 0x8000000000000000;
    __dst[0] = v15;
  }
  else
  {
    HIBYTE(v33) = v14;
    uint64_t v15 = __dst;
    if (!v14) {
      goto LABEL_32;
    }
  }
  memmove(v15, v21, v14);
LABEL_32:
  *((unsigned char *)v15 + v14) = 0;
  uint64_t v4 = BBUZipFile::saveDataToFile(v13, (uint64_t)__dst);
  if (SHIBYTE(v33) < 0) {
    operator delete(__dst[0]);
  }
  if (*(char *)(a2 + 23) >= 0) {
    uint64_t v24 = (const char *)a2;
  }
  else {
    uint64_t v24 = *(const char **)a2;
  }
  uint64_t v25 = (const char *)v43;
  if (v43[2] < 0) {
    uint64_t v25 = (const char *)v43[0];
  }
  BBUFeedback::handleComment(*(BBUFeedback **)(a1 + 8), "Saving Firmware image [%s] in path [%s]\n", v24, v25);
LABEL_40:
  *(void *)&long long v34 = *MEMORY[0x263F8C2C8];
  *(void *)((char *)&v34 + *(void *)(v34 - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  *((void *)&v34 + 1) = MEMORY[0x263F8C318] + 16;
  if (SHIBYTE(v39) < 0) {
    operator delete(__p[1]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x223C1DDF0](v41);
  if (SHIBYTE(v43[2]) < 0) {
    operator delete((void *)v43[0]);
  }
  return v4;
}

void sub_21DF05D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a18);
  if (*(char *)(v18 - 65) < 0) {
    operator delete(*(void **)(v18 - 88));
  }
  _Unwind_Resume(a1);
}

void BBUICEUpdateSource::loadProvisioningData(BBUICEUpdateSource *this)
{
  memset(v47, 170, 24);
  *((unsigned char *)&v46.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&v46, "provisioning/");
  uint64_t v2 = std::string::append(&v46, "info.plist", 0xAuLL);
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  *(void *)&v47[1] = *((void *)&v2->__r_.__value_.__l + 2);
  v47[0] = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  memset(&v46, 170, sizeof(v46));
  *((unsigned char *)&v45.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&v45, "provisioning/");
  uint64_t v4 = std::string::append(&v45, "puk.pem", 7uLL);
  long long v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v46.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v45.__r_.__value_.__l.__data_);
  }
  *((unsigned char *)&v44.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&v44, "provisioning/");
  size_t v6 = std::string::append(&v44, "manifest.bin", 0xCuLL);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v45.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v44.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v44.__r_.__value_.__l.__data_);
  }
  uint64_t v8 = *((void *)this + 8);
  if (!v8)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0xD2u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"BBU firmware data error.\")", v31, v32, v33, v43);
    goto LABEL_66;
  }
  *((unsigned char *)&v44.__r_.__value_.__s + 23) = 13;
  strcpy((char *)&v44, "provisioning/");
  if (BBUZipFile::containsFile(v8, &v44)) {
    *((unsigned char *)this + 120) = 1;
  }
  if (BBUZipFile::containsFile(*((void *)this + 8), v47))
  {
    if (*((void *)this + 16))
    {
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0xDDu, (ctu::LogMessageBuffer *)"Assertion failure(fProvisioningDictSource == __null)", v34, v35, v36, v43);
      goto LABEL_66;
    }
    uint64_t v10 = *((void *)this + 8);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 9);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = operator new(0x38uLL);
    *uint64_t v11 = &unk_26CECBB38;
    v11[1] = v10;
    v11[4] = 0;
    v11[5] = 0;
    void v11[3] = 0;
    if (BBUZipDataSource::init((uint64_t)v11, v47, 0))
    {
      (*(void (**)(void *))(*v11 + 8))(v11);
      uint64_t v11 = 0;
    }
    *((void *)this + 16) = v11;
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        goto LABEL_23;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        goto LABEL_23;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      uint64_t v12 = (const char *)(**(uint64_t (***)(BBUICEUpdateSource *))this)(this);
      _BBULog(3, 0, v12, "", "Loaded provisioning dictionary\n", v13, v14, v15, v43);
    }
  }
LABEL_23:
  if (!BBUZipFile::containsFile(*((void *)this + 8), &v46)) {
    goto LABEL_36;
  }
  if (*((void *)this + 17))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0xE7u, (ctu::LogMessageBuffer *)"Assertion failure(fProvisioningPublicKeySource == __null)", v37, v38, v39, v43);
    goto LABEL_66;
  }
  uint64_t v17 = *((void *)this + 8);
  long long v16 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = operator new(0x38uLL);
  *uint64_t v18 = &unk_26CECBB38;
  v18[1] = v17;
  v18[4] = 0;
  v18[5] = 0;
  v18[3] = 0;
  if (BBUZipDataSource::init((uint64_t)v18, &v46, 0))
  {
    (*(void (**)(void *))(*v18 + 8))(v18);
    uint64_t v18 = 0;
  }
  *((void *)this + 17) = v18;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_36;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_36;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v19 = (const char *)(**(uint64_t (***)(BBUICEUpdateSource *))this)(this);
    _BBULog(3, 0, v19, "", "Loaded public key source\n", v20, v21, v22, v43);
  }
LABEL_36:
  if (!BBUZipFile::containsFile(*((void *)this + 8), &v45)) {
    goto LABEL_49;
  }
  if (*((void *)this + 18))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0xF0u, (ctu::LogMessageBuffer *)"Assertion failure(fProvisioningManifestSource == __null)", v40, v41, v42, v43);
LABEL_66:
  }
  uint64_t v24 = *((void *)this + 8);
  uint64_t v23 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v25 = operator new(0x38uLL);
  void *v25 = &unk_26CECBB38;
  v25[1] = v24;
  v25[4] = 0;
  v25[5] = 0;
  void v25[3] = 0;
  if (BBUZipDataSource::init((uint64_t)v25, &v45, 0))
  {
    (*(void (**)(void *))(*v25 + 8))(v25);
    uint64_t v25 = 0;
  }
  *((void *)this + 18) = v25;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_49;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      goto LABEL_49;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v26 = (const char *)(**(uint64_t (***)(BBUICEUpdateSource *))this)(this);
    _BBULog(3, 0, v26, "", "Loaded provisioning manifest\n", v27, v28, v29, v43);
  }
LABEL_49:
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v45.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v46.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_51:
      if ((SBYTE7(v47[1]) & 0x80000000) == 0) {
        return;
      }
LABEL_55:
      operator delete(*(void **)&v47[0]);
      return;
    }
  }
  else if ((SHIBYTE(v46.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_51;
  }
  operator delete(v46.__r_.__value_.__l.__data_);
  if (SBYTE7(v47[1]) < 0) {
    goto LABEL_55;
  }
}

void sub_21DF064D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  __cxa_free_exception(v27);
  if (a27 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v28 - 73) < 0) {
    operator delete(*(void **)(v28 - 96));
  }
  if (*(char *)(v28 - 41) < 0) {
    operator delete(*(void **)(v28 - 64));
  }
  _Unwind_Resume(a1);
}

uint64_t BBUICEUpdateSource::copyProvisioningData(uint64_t a1, int a2, BBUMatureProvisioningData **a3)
{
  if (a2 != 1)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 70, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x105u, (ctu::LogMessageBuffer *)"Assertion failure(false && \"Unrecognized provisioning support type.\")", v9, v10, v11, v12);
  }
  long long v5 = *(BBUDataSource **)(a1 + 136);
  if (!v5 && !*(void *)(a1 + 144)) {
    return 0;
  }
  size_t v6 = (BBUMatureProvisioningData *)operator new(0x18uLL);
  BBUMatureProvisioningData::BBUMatureProvisioningData(v6, v5, *(BBUDataSource **)(a1 + 144));
  *a3 = v6;
  return 1;
}

void sub_21DF06660(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DF06674(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUICEUpdateSource::getFusingSource(BBUICEUpdateSource *this)
{
  uint64_t v2 = *((void *)this + 8);
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x10Eu, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"BBU firmware data error.\")", v13, v14, v15, v19);
    goto LABEL_23;
  }
  int v3 = *((_DWORD *)this + 26);
  if ((v3 & 4) != 0) {
    return *((void *)this + 14);
  }
  *((_DWORD *)this + 26) = v3 | 4;
  char v21 = 19;
  strcpy(__p, "fusingprogram.plist");
  if (!BBUZipFile::containsFile(v2, __p)) {
    return *((void *)this + 14);
  }
  if (*((void *)this + 14))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x116u, (ctu::LogMessageBuffer *)"Assertion failure(fFusingSource == __null)", v16, v17, v18, aFusingprogramP[0]);
LABEL_23:
  }
  uint64_t v5 = *((void *)this + 8);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v21 = 19;
  strcpy(__p, "fusingprogram.plist");
  size_t v6 = operator new(0x38uLL);
  void *v6 = &unk_26CECBB38;
  v6[1] = v5;
  v6[4] = 0;
  void v6[5] = 0;
  v6[3] = 0;
  if (BBUZipDataSource::init((uint64_t)v6, __p, 0))
  {
    (*(void (**)(void *))(*v6 + 8))(v6);
    size_t v6 = 0;
  }
  *((void *)this + 14) = v6;
  if (v21 < 0) {
    operator delete(*(void **)__p);
  }
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return *((void *)this + 14);
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return *((void *)this + 14);
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    long long v7 = (const char *)(**(uint64_t (***)(BBUICEUpdateSource *))this)(this);
    _BBULog(3, 0, v7, "", "Loaded Fusing program\n", v8, v9, v10, aFusingprogramP[0]);
  }
  return *((void *)this + 14);
}

void sub_21DF06924(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DF06938(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a11);
  _Unwind_Resume(a1);
}

void sub_21DF0695C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUICEUpdateSource::getManifestSource(BBUICEUpdateSource *this)
{
  int v2 = *((_DWORD *)this + 26);
  if (v2) {
    return *((void *)this + 19);
  }
  *((_DWORD *)this + 26) = v2 | 1;
  uint64_t v3 = *((void *)this + 8);
  if (!v3)
  {
    char v6 = *((unsigned char *)this + 103);
    if (v6 < 0)
    {
      if (!*((void *)this + 11)) {
        return *((void *)this + 19);
      }
    }
    else if (!*((unsigned char *)this + 103))
    {
      return *((void *)this + 19);
    }
    if (v6 >= 0) {
      size_t v10 = *((unsigned __int8 *)this + 103);
    }
    else {
      size_t v10 = *((void *)this + 11);
    }
    unint64_t v11 = v10 + 1;
    memset(&__dst, 170, sizeof(__dst));
    if (v10 + 1 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_88;
    }
    char v12 = (char **)((char *)this + 80);
    if (v11 >= 0x17)
    {
      uint64_t v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v11 | 7) != 0x17) {
        uint64_t v14 = v11 | 7;
      }
      uint64_t v15 = v14 + 1;
      p_dst = (std::string *)operator new(v14 + 1);
      __dst.__r_.__value_.__l.__size_ = v10 + 1;
      __dst.__r_.__value_.__r.__words[2] = v15 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v10 + 1;
      if (!v10) {
        goto LABEL_38;
      }
    }
    if (v6 >= 0) {
      uint64_t v16 = (char *)this + 80;
    }
    else {
      uint64_t v16 = *v12;
    }
    memmove(p_dst, v16, v10);
LABEL_38:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v10) = 47;
    (*(void (**)(void **__return_ptr, BBUICEUpdateSource *))(*(void *)this + 56))(&v46, this);
    if ((v48 & 0x80u) == 0) {
      uint64_t v17 = (const std::string::value_type *)&v46;
    }
    else {
      uint64_t v17 = (const std::string::value_type *)v46;
    }
    if ((v48 & 0x80u) == 0) {
      std::string::size_type v18 = v48;
    }
    else {
      std::string::size_type v18 = v47;
    }
    char v19 = std::string::append(&__dst, v17, v18);
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    std::string::size_type v53 = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    int v21 = ctu::fs::file_exists();
    if (SHIBYTE(v53) < 0)
    {
      operator delete(__p[0]);
      if (((char)v48 & 0x80000000) == 0)
      {
LABEL_46:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_47;
        }
        goto LABEL_51;
      }
    }
    else if (((char)v48 & 0x80000000) == 0)
    {
      goto LABEL_46;
    }
    operator delete(v46);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_47:
      if (!v21) {
        return *((void *)this + 19);
      }
      goto LABEL_52;
    }
LABEL_51:
    operator delete(__dst.__r_.__value_.__l.__data_);
    if (!v21) {
      return *((void *)this + 19);
    }
LABEL_52:
    if (*((void *)this + 19))
    {
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x132u, (ctu::LogMessageBuffer *)"Assertion failure(fRootManifestSource == __null)", v43, v44, v45, (char)v46);
LABEL_91:
    }
    int v22 = *((char *)this + 103);
    if (v22 >= 0) {
      size_t v23 = *((unsigned __int8 *)this + 103);
    }
    else {
      size_t v23 = *((void *)this + 11);
    }
    unint64_t v24 = v23 + 1;
    memset(&__dst, 170, sizeof(__dst));
    if (v23 + 1 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v24 >= 0x17)
      {
        uint64_t v26 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v24 | 7) != 0x17) {
          uint64_t v26 = v24 | 7;
        }
        uint64_t v27 = v26 + 1;
        uint64_t v25 = (std::string *)operator new(v26 + 1);
        __dst.__r_.__value_.__l.__size_ = v23 + 1;
        __dst.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
      }
      else
      {
        memset(&__dst, 0, sizeof(__dst));
        uint64_t v25 = &__dst;
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v23 + 1;
        if (!v23) {
          goto LABEL_67;
        }
      }
      if (v22 >= 0) {
        uint64_t v28 = (char *)this + 80;
      }
      else {
        uint64_t v28 = *v12;
      }
      memmove(v25, v28, v23);
LABEL_67:
      *(_WORD *)((char *)&v25->__r_.__value_.__l.__data_ + v23) = 47;
      (*(void (**)(void **__return_ptr, BBUICEUpdateSource *))(*(void *)this + 56))(&v46, this);
      if ((v48 & 0x80u) == 0) {
        uint64_t v29 = (const std::string::value_type *)&v46;
      }
      else {
        uint64_t v29 = (const std::string::value_type *)v46;
      }
      if ((v48 & 0x80u) == 0) {
        std::string::size_type v30 = v48;
      }
      else {
        std::string::size_type v30 = v47;
      }
      uint64_t v31 = std::string::append(&__dst, v29, v30);
      long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
      std::string::size_type v53 = v31->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v32;
      v31->__r_.__value_.__l.__size_ = 0;
      v31->__r_.__value_.__r.__words[2] = 0;
      v31->__r_.__value_.__r.__words[0] = 0;
      uint64_t v33 = (char *)operator new(0x30uLL);
      *(void *)uint64_t v33 = &unk_26CECA448;
      *(_OWORD *)(v33 + 8) = 0u;
      *(_OWORD *)(v33 + 24) = 0u;
      if (BBUFileDataSource::init((uint64_t)v33, (const char *)__p, 0))
      {
        (*(void (**)(char *))(*(void *)v33 + 8))(v33);
        uint64_t v33 = 0;
      }
      *((void *)this + 19) = v33;
      if (SHIBYTE(v53) < 0)
      {
        operator delete(__p[0]);
        if (((char)v48 & 0x80000000) == 0)
        {
LABEL_77:
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_78;
          }
          goto LABEL_85;
        }
      }
      else if (((char)v48 & 0x80000000) == 0)
      {
        goto LABEL_77;
      }
      operator delete(v46);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_78:
        if (gBBULogMaskGet(void)::once != -1) {
          goto LABEL_86;
        }
        goto LABEL_79;
      }
LABEL_85:
      operator delete(__dst.__r_.__value_.__l.__data_);
      if (gBBULogMaskGet(void)::once != -1) {
        goto LABEL_86;
      }
LABEL_79:
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
        return *((void *)this + 19);
      }
      goto LABEL_80;
    }
LABEL_88:
    std::string::__throw_length_error[abi:ne180100]();
  }
  (*(void (**)(void **__return_ptr, BBUICEUpdateSource *))(*(void *)this + 56))(__p, this);
  int v4 = BBUZipFile::containsFile(v3, __p);
  int v5 = v4;
  if (SHIBYTE(v53) < 0)
  {
    operator delete(__p[0]);
    if (!v5) {
      return *((void *)this + 19);
    }
  }
  else if (!v4)
  {
    return *((void *)this + 19);
  }
  if (*((void *)this + 19))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x129u, (ctu::LogMessageBuffer *)"Assertion failure(fRootManifestSource == __null)", v40, v41, v42, (char)v46);
    goto LABEL_91;
  }
  uint64_t v8 = *((void *)this + 8);
  long long v7 = (std::__shared_weak_count *)*((void *)this + 9);
  uint64_t v50 = v8;
  long long v51 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(void **__return_ptr, BBUICEUpdateSource *))(*(void *)this + 56))(__p, this);
  uint64_t v9 = operator new(0x38uLL);
  *uint64_t v9 = &unk_26CECBB38;
  v9[1] = v8;
  void v9[4] = 0;
  v9[5] = 0;
  v9[3] = 0;
  if (BBUZipDataSource::init((uint64_t)v9, __p, 0))
  {
    (*(void (**)(void *))(*v9 + 8))(v9);
    uint64_t v9 = 0;
  }
  *((void *)this + 19) = v9;
  if (SHIBYTE(v53) < 0) {
    operator delete(__p[0]);
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
      return *((void *)this + 19);
    }
    goto LABEL_80;
  }
LABEL_86:
  dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
  if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 8) == 0) {
    return *((void *)this + 19);
  }
LABEL_80:
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    uint64_t v34 = (const char *)(**(uint64_t (***)(BBUICEUpdateSource *))this)(this);
    _BBULog(3, 0, v34, "", "Loaded Manifest\n", v35, v36, v37, (char)v46);
  }
  return *((void *)this + 19);
}

void sub_21DF06FE4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_21DF06FF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((a20 & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((a20 & 0x80000000) == 0)
  {
LABEL_6:
    _Unwind_Resume(exception_object);
  }
  operator delete(a15);
  goto LABEL_6;
}

uint64_t BBUICEUpdateSource::hasManifestSource(BBUICEUpdateSource *this)
{
  if (*((unsigned char *)this + 104)) {
    return *((void *)this + 19) != 0;
  }
  (*(void (**)(void **__return_ptr, BBUICEUpdateSource *))(*(void *)this + 56))(__p, this);
  uint64_t result = BBUICEUpdateSource::containsFile((uint64_t)this, (uint64_t)__p);
  uint64_t v3 = result;
  if (v5 < 0)
  {
    operator delete(__p[0]);
    return v3;
  }
  return result;
}

void sub_21DF071A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void BBUICEUpdateSource::getManifestFilename(char *a1@<X8>)
{
  a1[23] = 12;
  strcpy(a1, "bbticket.der");
}

uint64_t BBUICEUpdateSource::generateHash(BBUICEUpdateSource *this, unsigned __int8 *a2)
{
  uint64_t v2 = *((void *)this + 8);
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 35, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Updater/ICE/BBUICEUpdateSource.cpp", 0x154u, (ctu::LogMessageBuffer *)"Assertion failure(fZipFile && \"BBU firmware data error.\")", v8, v9, v10, v11);
  }
  int v4 = *(const void **)(v2 + 144);
  char v5 = operator new(0x18uLL);
  v5[4] = 0;
  *(void *)char v5 = &unk_26CECE780;
  *((void *)v5 + 1) = v4;
  if (v4) {
    CFRetain(v4);
  }
  BBUDataSource::generateHash((uint64_t)v5, a2, 0);
  (*(void (**)(_DWORD *))(*(void *)v5 + 8))(v5);
  return 1;
}

void sub_21DF072D8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUICEUpdateSource::getProgrammerSource(BBUICEUpdateSource *this)
{
  return 0;
}

uint64_t BBUICEUpdateSource::getItems(BBUICEUpdateSource *this)
{
  return 0;
}

uint64_t BBUICEUpdateSource::validateBootupItems(BBUICEUpdateSource *this)
{
  return 0;
}

uint64_t BBUICEUpdateSource::copyHashData(BBUICEUpdateSource *this)
{
  return 0;
}

uint64_t BBUICEUpdateSource::validateCoredumpItems(BBUICEUpdateSource *this)
{
  return 0;
}

uint64_t BBUUpdateSource::eraseBasebandFilesystem(BBUUpdateSource *this)
{
  return 0;
}

uint64_t BBUEUR13Communication::freeTransportSync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 80);
  if (!v8) {
    return 1;
  }
  if (v8 != a2)
  {
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0) {
        goto LABEL_5;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0)
      {
LABEL_5:
        if ((gBBULogVerbosity & 0x80000000) == 0) {
          _BBULog(2, 0, "BBUEUR13Communication", "", "call with %p different from fTransportCreated(%p)\n", a6, a7, a8, a2);
        }
      }
    }
    return 0;
  }
  uint64_t v12 = TelephonyUtilTransportFree();
  uint64_t v13 = *(NSObject **)(a1 + 72);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZN21BBUEUR13Communication17freeTransportSyncEP26TelephonyUtilTransport_tag_block_invoke;
  block[3] = &__block_descriptor_tmp_3;
  char v15 = v12;
  block[4] = a1;
  void block[5] = a2;
  dispatch_sync(v13, block);
  return v12;
}

void ___ZN21BBUEUR13Communication17freeTransportSyncEP26TelephonyUtilTransport_tag_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 48))
  {
    *(void *)(*(void *)(a1 + 32) + 80) = 0;
    return;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      return;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      return;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(2, 0, "BBUEUR13Communication", "", "fail to free transport: %p\n", a6, a7, a8, *(void *)(a1 + 40));
  }
}

uint64_t BBUEUR13Communication::createTransport(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v46 = 0;
  std::string::size_type v47 = &v46;
  uint64_t v48 = 0x2000000000;
  int v49 = 3;
  v44[0] = 0;
  v44[1] = v44;
  v44[2] = 0x2000000000;
  char v45 = 0;
  unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v41 = v9;
  long long v42 = v9;
  long long v39 = v9;
  long long v40 = v9;
  long long v38 = v9;
  TelephonyBasebandPCITransportInitParameters();
  if (*(void *)(a1 + 80))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 67, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Communication/Eureka/BBUEUR13Communication.cpp", 0x4Du, (ctu::LogMessageBuffer *)"Assertion failure(nullptr == fTransportCreated && \"Telephony transport error.\")", v20, v21, v22, v29);
    goto LABEL_26;
  }
  uint64_t v13 = *(void *)(a1 + 72);
  v37[0] = MEMORY[0x263EF8330];
  v37[1] = 0x40000000;
  v37[2] = ___ZN21BBUEUR13Communication15createTransportEP26TelephonyUtilTransport_tag8BBUStagedbN16BBUCommunication17BasebandInterfaceE_block_invoke;
  _OWORD v37[3] = &__block_descriptor_tmp_11;
  v37[4] = a2;
  *((void *)&v38 + 1) = v13;
  *(void *)&long long v39 = v37;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0) {
      goto LABEL_4;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0)
    {
LABEL_4:
      if ((gBBULogVerbosity & 0x80000000) == 0) {
        _BBULog(2, 0, "BBUEUR13Communication", "", "Creating transport:%p stage:%d interface:%d %f ms\n", v10, v11, v12, a2);
      }
    }
  }
  switch(a3)
  {
    case 1:
    case 16:
      int v14 = 2;
      LODWORD(v38) = 2;
      int v15 = 2000;
      goto LABEL_16;
    case 2:
      int v14 = 0;
      LODWORD(v38) = 0;
      goto LABEL_15;
    case 4:
      int v14 = 1;
      goto LABEL_14;
    case 8:
      if (a5 == 1)
      {
        int v14 = 3;
        goto LABEL_14;
      }
      if (a5)
      {
        if (gBBULogMaskGet(void)::once == -1)
        {
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0) {
            goto LABEL_34;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0)
          {
LABEL_34:
            if ((gBBULogVerbosity & 0x80000000) == 0) {
              _BBULog(2, 0, "BBUEUR13Communication", "", "Unsupported intf: %d\n", v10, v11, v12, a5);
            }
          }
        }
        exception = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)exception, 67, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Communication/Eureka/BBUEUR13Communication.cpp", 0x70u, (ctu::LogMessageBuffer *)"Assertion failure(false)", v26, v27, v28, v29);
LABEL_26:
      }
      int v14 = 2;
LABEL_14:
      LODWORD(v38) = v14;
LABEL_15:
      int v15 = 5000;
LABEL_16:
      DWORD2(v39) = v15;
      *(_DWORD *)(a1 + 88) = v14;
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
          goto LABEL_20;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
          goto LABEL_20;
        }
      }
      if ((gBBULogVerbosity & 0x80000000) == 0) {
        _BBULog(2, 0, "BBUEUR13Communication", "", "Creating with timeout set to %u ms\n", v10, v11, v12, SBYTE8(v39));
      }
LABEL_20:
      uint64_t v16 = *(NSObject **)(a1 + 64);
      block[0] = MEMORY[0x263EF8330];
      block[1] = 1107296256;
      block[2] = ___ZN21BBUEUR13Communication15createTransportEP26TelephonyUtilTransport_tag8BBUStagedbN16BBUCommunication17BasebandInterfaceE_block_invoke_2;
      block[3] = &__block_descriptor_tmp_20_0;
      void block[6] = a1;
      void block[7] = a2;
      long long v33 = v40;
      long long v34 = v41;
      long long v35 = v42;
      unint64_t v36 = v43;
      long long v31 = v38;
      long long v32 = v39;
      block[4] = v44;
      void block[5] = &v46;
      dispatch_sync(v16, block);
      uint64_t v17 = *((unsigned int *)v47 + 6);
      _Block_object_dispose(v44, 8);
      _Block_object_dispose(&v46, 8);
      return v17;
    default:
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0) {
          goto LABEL_29;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0)
        {
LABEL_29:
          if ((gBBULogVerbosity & 0x80000000) == 0) {
            _BBULog(2, 0, "BBUEUR13Communication", "", "Unsupported BBU stage: %d\n", v10, v11, v12, a3);
          }
        }
      }
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 69, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Communication/Eureka/BBUEUR13Communication.cpp", 0x76u, (ctu::LogMessageBuffer *)"Assertion failure(false && \"Unsupported BBU stage.\")", v23, v24, v25, v29);
      goto LABEL_26;
  }
}

void sub_21DF079F4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Block_object_dispose((const void *)(v2 - 144), 8);
  _Block_object_dispose((const void *)(v2 - 112), 8);
  _Unwind_Resume(a1);
}

void ___ZN21BBUEUR13Communication15createTransportEP26TelephonyUtilTransport_tag8BBUStagedbN16BBUCommunication17BasebandInterfaceE_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 32);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(2, 0, "BBUEUR13Communication", "", "transport %p, status: %#x\n", a6, a7, a8, v9);
  }
LABEL_5:
  if (a2 != 1) {
    return;
  }
  uint64_t Controller = (const void *)TelephonyBasebandCreateController();
  int v14 = TelephonyBasebandResetModem();
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0) {
      goto LABEL_8;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) != 0)
    {
LABEL_8:
      if ((gBBULogVerbosity & 0x80000000) == 0)
      {
        int v15 = "failure";
        if (v14) {
          int v15 = "success";
        }
        _BBULog(2, 0, "BBUEUR13Communication", "", "Resetting modem: %s\n", v11, v12, v13, (char)v15);
      }
    }
  }
  if (Controller) {
    CFRelease(Controller);
  }
}

void sub_21DF07BEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void ___ZN21BBUEUR13Communication15createTransportEP26TelephonyUtilTransport_tag8BBUStagedbN16BBUCommunication17BasebandInterfaceE_block_invoke_2(void *a1)
{
  uint64_t v2 = a1[6];
  *(void *)(v2 + 80) = a1[7];
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = TelephonyBasebandPCITransportCreate();
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_8;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_8;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0)
  {
    if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24)) {
      uint64_t v9 = "success";
    }
    else {
      uint64_t v9 = "failure";
    }
    _BBULog(2, 0, "BBUEUR13Communication", "", " TelephonyBasebandPCITransportCreate returns: %s\n", v6, v7, v8, (char)v9);
  }
LABEL_8:
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    if (!*(void *)(v2 + 80))
    {
      exception = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)exception, 67, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Communication/Eureka/BBUEUR13Communication.cpp", 0x88u, (ctu::LogMessageBuffer *)"Assertion failure(nullptr != fTransportCreated && \"Telephony Util transport error!\")", v12, v13, v14, v15);
    }
    int v10 = 0;
  }
  else
  {
    BBUEUR13Communication::freeTransportSync(v2, a1[7], v3, v4, v5, v6, v7, v8);
    int v10 = 3;
  }
  *(_DWORD *)(*(void *)(a1[5] + 8) + 24) = v10;
}

void sub_21DF07D78(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void __copy_helper_block_e8_32r40r(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 8);
  uint64_t v4 = *(const void **)(a2 + 40);

  _Block_object_assign((void *)(a1 + 40), v4, 8);
}

void __destroy_helper_block_e8_32r40r(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 8);
  uint64_t v2 = *(const void **)(a1 + 32);

  _Block_object_dispose(v2, 8);
}

uint64_t BBUEUR13Communication::getBasebandState(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(int *)(a1 + 88);
  if (v9 > 3) {
    int v10 = 3;
  }
  else {
    int v10 = dword_21DFAC200[v9];
  }
  *a3 = v10;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      return 0;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      return 0;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(2, 0, "BBUEUR13Communication", "", "returning state: %d\n", a6, a7, a8, *a3);
  }
  return 0;
}

uint64_t BBUEUR13Communication::freeTransport(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = 0;
  char v15 = &v14;
  uint64_t v16 = 0x2000000000;
  char v17 = 1;
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_5;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)gBBULogMaskGet(void)::sBBULogMask & 4) == 0) {
      goto LABEL_5;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(2, 0, "BBUEUR13Communication", "", "request to free transport: %p\n", a6, a7, a8, a2);
  }
LABEL_5:
  int v10 = *(NSObject **)(a1 + 64);
  block[0] = MEMORY[0x263EF8330];
  block[1] = 1107296256;
  block[2] = ___ZN21BBUEUR13Communication13freeTransportEP26TelephonyUtilTransport_tag_block_invoke;
  block[3] = &__block_descriptor_tmp_23_0;
  block[4] = &v14;
  void block[5] = a1;
  void block[6] = a2;
  dispatch_sync(v10, block);
  uint64_t v11 = *((unsigned __int8 *)v15 + 24);
  _Block_object_dispose(&v14, 8);
  return v11;
}

void sub_21DF08030(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN21BBUEUR13Communication13freeTransportEP26TelephonyUtilTransport_tag_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = BBUEUR13Communication::freeTransportSync(a1[5], a1[6], a3, a4, a5, a6, a7, a8);
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

void BBUEUR13Communication::~BBUEUR13Communication(BBUEUR13Communication *this)
{
  *(void *)this = &unk_26CECBAD0;
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *((void *)this + 8);
  if (v3) {
    dispatch_release(v3);
  }
  *(void *)this = &unk_26CECBBA0;
  if (*((char *)this + 55) < 0) {
    operator delete(*((void **)this + 4));
  }
}

{
  NSObject *v2;
  NSObject *v3;
  BBUEUR13Communication *v4;
  uint64_t vars8;

  *(void *)this = &unk_26CECBAD0;
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *((void *)this + 8);
  if (v3) {
    dispatch_release(v3);
  }
  *(void *)this = &unk_26CECBBA0;
  if (*((char *)this + 55) < 0)
  {
    operator delete(*((void **)this + 4));
    uint64_t v4 = this;
  }
  else
  {
    uint64_t v4 = this;
  }
  operator delete(v4);
}

std::string *BBUEURCommunication::setUartDevicePath(BBUEURCommunication *this, char *a2)
{
  return std::string::__assign_external((std::string *)((char *)this + 32), a2);
}

void *BBUEUR13Communication::getIPCLogBuffer@<X0>(void *a1@<X8>)
{
  uint64_t v3 = (BBULogIOABP *)operator new(0xA0uLL);
  BBULogIOABP::BBULogIOABP(v3);
  *a1 = (char *)v3 + *(void *)(*(void *)v3 - 88);
  uint64_t result = operator new(0x20uLL);
  *uint64_t result = &unk_26CECBA80;
  result[1] = 0;
  result[2] = 0;
  result[3] = v3;
  a1[1] = result;
  return result;
}

void sub_21DF0827C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(v2 + 16))(v1);
  _Unwind_Resume(a1);
}

void sub_21DF0829C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<BBULogIOABP *,std::shared_ptr<BBULogBuffer>::__shared_ptr_default_delete<BBULogBuffer,BBULogIOABP>,std::allocator<BBULogIOABP>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t std::__shared_ptr_pointer<BBULogIOABP *,std::shared_ptr<BBULogBuffer>::__shared_ptr_default_delete<BBULogBuffer,BBULogIOABP>,std::allocator<BBULogIOABP>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 16))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<BBULogIOABP *,std::shared_ptr<BBULogBuffer>::__shared_ptr_default_delete<BBULogBuffer,BBULogIOABP>,std::allocator<BBULogIOABP>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x800000021DFAC19DLL) {
    return a1 + 24;
  }
  if (((v3 & 0x800000021DFAC19DLL & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x800000021DFAC19DLL)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x800000021DFAC19DLL & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 24;
  }
  return 0;
}

uint64_t BBUEURHashData::getHashSize(BBUEURHashData *this)
{
  return MEMORY[0x270F91B80](this);
}

void BBUZipFile::BBUZipFile(BBUZipFile *this, const __CFData *a2)
{
  uint64_t v105 = *MEMORY[0x263EF8340];
  pthread_mutex_init((pthread_mutex_t *)this, 0);
  *((void *)this + 12) = 0;
  uint64_t v4 = (char **)((char *)this + 96);
  *((void *)this + 11) = (char *)this + 96;
  uint64_t v5 = (char *)this + 88;
  *((void *)this + 8) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 15) = 0;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v76[2] = v6;
  v76[3] = v6;
  v76[0] = v6;
  v76[1] = v6;
  fill_memory_filefunc((unint64_t *(**)(uint64_t, const char *, char))v76);
  unint64_t v90 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__str = v7;
  long long v89 = v7;
  *((void *)this + 18) = a2;
  CFRetain(a2);
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 18));
  CFIndex Length = CFDataGetLength(*((CFDataRef *)this + 18));
  snprintf(__str, 0x28uLL, "%lx+%lx", BytePtr, Length);
  int v10 = unzOpen2((uint64_t)__str, v76);
  *((void *)this + 8) = v10;
  if (!v10)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0x31u, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v72, v73, v74, v75);
LABEL_97:
  }
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)(v10 + 9);
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
      goto LABEL_6;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
      goto LABEL_6;
    }
  }
  if ((gBBULogVerbosity & 0x80000000) == 0) {
    _BBULog(15, 0, "BBUZipFile", (const char *)&str_4_3, "%s - Num entries %lu\n", v11, v12, v13, (char)__str);
  }
LABEL_6:
  uint64_t v14 = (void *)*((void *)this + 8);
  if (!v14
    || (uint64_t v15 = v14[17],
        v14[12] = 0,
        v14[13] = v15,
        int CurrentFileInfoInternal = unzlocal_GetCurrentFileInfoInternal((uint64_t)v14, (uint64_t)(v14 + 18), v14 + 35, 0, 0, 0, 0, 0, 0), v14[14] = CurrentFileInfoInternal == 0, CurrentFileInfoInternal))
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0x4Bu, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v69, v70, v71, v75);
    goto LABEL_97;
  }
  do
  {
    while (1)
    {
      unint64_t v87 = 0xAAAAAAAAAAAAAAAALL;
      v18.i64[0] = 0xAAAAAAAAAAAAAAAALL;
      v18.i64[1] = 0xAAAAAAAAAAAAAAAALL;
      int8x16_t v85 = v18;
      int8x16_t v86 = v18;
      int8x16_t v83 = v18;
      int8x16_t v84 = v18;
      int8x16_t v81 = v18;
      int8x16_t v82 = v18;
      int8x16_t v79 = v18;
      int8x16_t v80 = v18;
      int8x16_t v78 = v18;
      memset(v77, 0, sizeof(v77));
      *(_OWORD *)__s = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      int v104 = 0;
      *(_OWORD *)uint64_t v91 = 0u;
      long long v92 = 0u;
      long long v93 = 0u;
      long long v94 = 0u;
      long long v95 = 0u;
      long long v96 = 0u;
      int v97 = 0;
      char v19 = (int8x16_t *)*((void *)this + 8);
      if (!v19 || !v19[7].i64[0])
      {
        uint64_t v58 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v58, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0x57u, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v59, v60, v61, v75);
        goto LABEL_94;
      }
      int8x16_t v78 = vextq_s8(v19[6], v19[6], 8uLL);
      if (unzlocal_GetCurrentFileInfoInternal((uint64_t)v19, (uint64_t)&v79, 0, (uint64_t)__s, 0x63uLL, 0, 0, (uint64_t)v91, 0x63uLL))
      {
        uint64_t v58 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v58, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0x5Eu, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v65, v66, v67, v75);
LABEL_94:
      }
      std::string::__assign_external(v77, __s);
      std::string::__assign_external(&v77[1], v91);
      if (gBBULogMaskGet(void)::once == -1)
      {
        if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
          goto LABEL_19;
        }
      }
      else
      {
        dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
        if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
          goto LABEL_19;
        }
      }
      if ((gBBULogVerbosity & 0x80000000) == 0) {
        _BBULog(15, 0, "BBUZipFile", (const char *)&str_4_3, "Loaded file %s, Comment %s\n", v20, v21, v22, (char)__s);
      }
LABEL_19:
      uint64_t v23 = v5;
      uint64_t v24 = *v4;
      uint64_t v25 = (uint64_t **)((char *)this + 96);
      uint64_t v26 = (char *)this + 96;
      if (*v4)
      {
        if ((v77[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v27 = v77;
        }
        else {
          uint64_t v27 = (std::string *)v77[0].__r_.__value_.__r.__words[0];
        }
        if ((v77[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(v77[0].__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = v77[0].__r_.__value_.__l.__size_;
        }
        while (1)
        {
          uint64_t v26 = v24;
          long long v31 = (char *)*((void *)v24 + 4);
          char v29 = v24 + 32;
          std::string::size_type v30 = v31;
          int v32 = v29[23];
          if (v32 >= 0) {
            long long v33 = v29;
          }
          else {
            long long v33 = v30;
          }
          if (v32 >= 0) {
            size_t v34 = v29[23];
          }
          else {
            size_t v34 = *((void *)v29 + 1);
          }
          if (v34 >= size) {
            size_t v35 = size;
          }
          else {
            size_t v35 = v34;
          }
          int v36 = memcmp(v27, v33, v35);
          if (v36)
          {
            if (v36 < 0) {
              goto LABEL_26;
            }
LABEL_40:
            int v37 = memcmp(v33, v27, v35);
            if (v37)
            {
              if ((v37 & 0x80000000) == 0) {
                goto LABEL_53;
              }
            }
            else if (v34 >= size)
            {
LABEL_53:
              long long v38 = v26;
              uint64_t v5 = v23;
              long long v42 = (void **)(v26 + 56);
              if (v26 + 56 != (char *)v77) {
                goto LABEL_54;
              }
              goto LABEL_76;
            }
            uint64_t v24 = (char *)*((void *)v26 + 1);
            if (!v24)
            {
              uint64_t v25 = (uint64_t **)(v26 + 8);
              break;
            }
          }
          else
          {
            if (size >= v34) {
              goto LABEL_40;
            }
LABEL_26:
            uint64_t v24 = *(char **)v26;
            uint64_t v25 = (uint64_t **)v26;
            if (!*(void *)v26) {
              break;
            }
          }
        }
      }
      uint64_t v5 = v23;
      long long v38 = (char *)operator new(0x100uLL);
      long long v39 = (std::string *)(v38 + 32);
      if (SHIBYTE(v77[0].__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(v39, v77[0].__r_.__value_.__l.__data_, v77[0].__r_.__value_.__l.__size_);
      }
      else
      {
        *(_OWORD *)&v39->__r_.__value_.__l.__data_ = *(_OWORD *)&v77[0].__r_.__value_.__l.__data_;
        *((void *)v38 + 6) = *((void *)&v77[0].__r_.__value_.__l + 2);
      }
      *((void *)v38 + 31) = 0;
      *(_OWORD *)(v38 + 232) = 0u;
      *(_OWORD *)(v38 + 216) = 0u;
      *(_OWORD *)(v38 + 200) = 0u;
      *(_OWORD *)(v38 + 184) = 0u;
      *(_OWORD *)(v38 + 168) = 0u;
      *(_OWORD *)(v38 + 152) = 0u;
      *(_OWORD *)(v38 + 136) = 0u;
      *(_OWORD *)(v38 + 120) = 0u;
      *(_OWORD *)(v38 + 104) = 0u;
      *(_OWORD *)(v38 + 88) = 0u;
      *(_OWORD *)(v38 + 72) = 0u;
      *(_OWORD *)(v38 + 56) = 0u;
      *(void *)long long v38 = 0;
      *((void *)v38 + 1) = 0;
      *((void *)v38 + 2) = v26;
      std::string *v25 = (uint64_t *)v38;
      long long v40 = (uint64_t *)v38;
      long long v41 = **(void ***)v23;
      if (v41)
      {
        *(void *)uint64_t v23 = v41;
        long long v40 = *v25;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 12), v40);
      ++*((void *)this + 13);
      long long v42 = (void **)(v38 + 56);
      if (v38 + 56 != (char *)v77)
      {
LABEL_54:
        if (v38[79] < 0)
        {
          if ((v77[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            unint64_t v43 = v77;
          }
          else {
            unint64_t v43 = (std::string *)v77[0].__r_.__value_.__r.__words[0];
          }
          if ((v77[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v44 = HIBYTE(v77[0].__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v44 = v77[0].__r_.__value_.__l.__size_;
          }
          std::string::__assign_no_alias<false>(v42, v43, v44);
        }
        else if ((*((unsigned char *)&v77[0].__r_.__value_.__s + 23) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(v42, v77[0].__r_.__value_.__l.__data_, v77[0].__r_.__value_.__l.__size_);
        }
        else
        {
          *(std::string *)long long v42 = v77[0];
        }
        char v45 = (void **)(v38 + 80);
        if (v38[103] < 0)
        {
          if ((v77[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::pointer data = &v77[1];
          }
          else {
            std::string::pointer data = (std::string *)v77[1].__r_.__value_.__l.__data_;
          }
          if ((v77[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v47 = HIBYTE(v77[1].__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v47 = v77[1].__r_.__value_.__l.__size_;
          }
          std::string::__assign_no_alias<false>(v45, data, v47);
        }
        else if ((*((unsigned char *)&v77[1].__r_.__value_.__s + 23) & 0x80) != 0)
        {
          std::string::__assign_no_alias<true>(v45, v77[1].__r_.__value_.__l.__data_, v77[1].__r_.__value_.__l.__size_);
        }
        else
        {
          *(_OWORD *)char v45 = *(_OWORD *)&v77[1].__r_.__value_.__l.__data_;
          *((void *)v38 + 12) = *((void *)&v77[1].__r_.__value_.__l + 2);
        }
      }
LABEL_76:
      int8x16_t v48 = v82;
      *(int8x16_t *)(v38 + 184) = v83;
      *(int8x16_t *)(v38 + 168) = v48;
      int8x16_t v49 = v80;
      *(int8x16_t *)(v38 + 152) = v81;
      *(int8x16_t *)(v38 + 136) = v49;
      unint64_t v50 = v87;
      *(int8x16_t *)(v38 + 232) = v86;
      int8x16_t v51 = v84;
      *(int8x16_t *)(v38 + 216) = v85;
      *(int8x16_t *)(v38 + 200) = v51;
      int8x16_t v52 = v79;
      *(int8x16_t *)(v38 + 104) = v78;
      *((void *)v38 + 31) = v50;
      *(int8x16_t *)(v38 + 120) = v52;
      std::string::size_type v53 = (void *)*((void *)this + 8);
      if (!v53)
      {
LABEL_92:
        uint64_t v58 = __cxa_allocate_exception(0x210uLL);
        _BBUException::_BBUException((uint64_t)v58, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0x6Fu, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v62, v63, v64, v75);
        goto LABEL_94;
      }
      if (v53[14])
      {
        uint64_t v54 = v53[9];
        uint64_t v55 = v53[12] + 1;
        if (v54 == 0xFFFF || v55 != v54)
        {
          uint64_t v56 = v53[26] + v53[27] + v53[28] + v53[13] + 46;
          v53[12] = v55;
          v53[13] = v56;
          int v57 = unzlocal_GetCurrentFileInfoInternal((uint64_t)v53, (uint64_t)(v53 + 18), v53 + 35, 0, 0, 0, 0, 0, 0);
          v53[14] = v57 == 0;
          if (v57 != -100) {
            break;
          }
        }
      }
      char v17 = 0;
      if (SHIBYTE(v77[1].__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_83;
      }
LABEL_10:
      if (SHIBYTE(v77[0].__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_84;
      }
LABEL_11:
      if ((v17 & 1) == 0) {
        return;
      }
    }
    if (v57) {
      goto LABEL_92;
    }
    char v17 = 1;
    if ((SHIBYTE(v77[1].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_10;
    }
LABEL_83:
    operator delete(v77[1].__r_.__value_.__l.__data_);
    if ((SHIBYTE(v77[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_11;
    }
LABEL_84:
    operator delete(v77[0].__r_.__value_.__l.__data_);
  }
  while ((v17 & 1) != 0);
}

void sub_21DF08B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  __cxa_free_exception(v24);
  if (*(char *)(v23 + 135) < 0) {
    operator delete(*a12);
  }
  std::__tree<std::__value_type<std::string,BBUZipFile::FileInfo>,std::__map_value_compare<std::string,std::__value_type<std::string,BBUZipFile::FileInfo>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,BBUZipFile::FileInfo>>>::destroy(v25, *(void *)(v23 + 96));
  pthread_mutex_destroy((pthread_mutex_t *)v23);
  _Unwind_Resume(a1);
}

void BBUZipFile::~BBUZipFile(BBUZipFile *this)
{
  uint64_t v2 = *((void *)this + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 288);
    if (v3)
    {
      if (*(void *)v3) {
        free(*(void **)v3);
      }
      *(void *)uint64_t v3 = 0;
      if (*(void *)(v3 + 128)) {
        inflateEnd((z_streamp)(v3 + 8));
      }
      free((void *)v3);
      *(void *)(v2 + 288) = 0;
    }
    (*(void (**)(void, void))(v2 + 40))(*(void *)(v2 + 56), *(void *)(v2 + 64));
    free((void *)v2);
    *((void *)this + 8) = 0;
  }
  uint64_t v4 = (const void *)*((void *)this + 18);
  if (v4) {
    CFRelease(v4);
  }
  if (*((char *)this + 135) < 0) {
    operator delete(*((void **)this + 14));
  }
  std::__tree<std::__value_type<std::string,BBUZipFile::FileInfo>,std::__map_value_compare<std::string,std::__value_type<std::string,BBUZipFile::FileInfo>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,BBUZipFile::FileInfo>>>::destroy((uint64_t)this + 88, *((void *)this + 12));
  pthread_mutex_destroy((pthread_mutex_t *)this);
}

uint64_t BBUZipFile::containsFile(uint64_t a1, void *a2)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v4 = *(uint64_t ***)(a1 + 96);
  if (!v4)
  {
LABEL_24:
    uint64_t v13 = 0;
    goto LABEL_25;
  }
  size_t v5 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    size_t v6 = v5;
  }
  while (1)
  {
    int v7 = *((char *)v4 + 55);
    if (v7 >= 0) {
      uint64_t v8 = (uint64_t *)(v4 + 4);
    }
    else {
      uint64_t v8 = v4[4];
    }
    if (v7 >= 0) {
      size_t v9 = *((unsigned __int8 *)v4 + 55);
    }
    else {
      size_t v9 = (size_t)v4[5];
    }
    if (v9 >= v6) {
      size_t v10 = v6;
    }
    else {
      size_t v10 = v9;
    }
    int v11 = memcmp(a2, v8, v10);
    if (v11)
    {
      if (v11 < 0) {
        goto LABEL_7;
      }
    }
    else if (v6 < v9)
    {
      goto LABEL_7;
    }
    int v12 = memcmp(v8, a2, v10);
    if (!v12)
    {
      if (v9 >= v6) {
        break;
      }
      goto LABEL_6;
    }
    if ((v12 & 0x80000000) == 0) {
      break;
    }
LABEL_6:
    ++v4;
LABEL_7:
    uint64_t v4 = (uint64_t **)*v4;
    if (!v4) {
      goto LABEL_24;
    }
  }
  uint64_t v13 = 1;
LABEL_25:
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  return v13;
}

uint64_t BBUZipFile::getFileSize(pthread_mutex_t *a1, const void **a2)
{
  pthread_mutex_lock(a1);
  uint64_t v4 = std::__tree<std::__value_type<std::string,BBUZipFile::FileInfo>,std::__map_value_compare<std::string,std::__value_type<std::string,BBUZipFile::FileInfo>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,BBUZipFile::FileInfo>>>::find<std::string>((uint64_t)&a1[1].__opaque[16], a2);
  if (&a1[1].__opaque[24] == (char *)v4)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0x124u, (ctu::LogMessageBuffer *)"Assertion failure(i != fFileMap.end())", v8, v9, v10, v11);
  }
  uint64_t v5 = v4[22];
  pthread_mutex_unlock(a1);
  return v5;
}

void sub_21DF08E50(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUZipFile::copyDataFromFile(uint64_t a1, const void **a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v10 = std::__tree<std::__value_type<std::string,BBUZipFile::FileInfo>,std::__map_value_compare<std::string,std::__value_type<std::string,BBUZipFile::FileInfo>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,BBUZipFile::FileInfo>>>::find<std::string>(a1 + 88, a2);
  if ((uint64_t *)(a1 + 96) == v10)
  {
    exception = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)exception, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0x124u, (ctu::LogMessageBuffer *)"Assertion failure(i != fFileMap.end())", v57, v58, v59, v69);
  }
  uint64_t v14 = v10;
  uint64_t v15 = (const void **)(a1 + 112);
  uint64_t v16 = *(unsigned __int8 *)(a1 + 135);
  if ((v16 & 0x80u) == 0) {
    char v17 = (const void *)*(unsigned __int8 *)(a1 + 135);
  }
  else {
    char v17 = *(const void **)(a1 + 120);
  }
  int8x16_t v18 = (const void *)*((unsigned __int8 *)a2 + 23);
  int v19 = (char)v18;
  if ((char)v18 < 0) {
    int8x16_t v18 = a2[1];
  }
  if (v17 != v18) {
    goto LABEL_18;
  }
  if (v19 >= 0) {
    uint64_t v20 = (unsigned __int8 *)a2;
  }
  else {
    uint64_t v20 = (unsigned __int8 *)*a2;
  }
  if ((v16 & 0x80) != 0)
  {
    if (memcmp(*v15, v20, *(void *)(a1 + 120))) {
      goto LABEL_18;
    }
  }
  else if (*(unsigned char *)(a1 + 135))
  {
    uint64_t v21 = (unsigned __int8 *)(a1 + 112);
    while (*v21 == *v20)
    {
      ++v21;
      ++v20;
      if (!--v16) {
        goto LABEL_27;
      }
    }
LABEL_18:
    if (gBBULogMaskGet(void)::once == -1)
    {
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        goto LABEL_24;
      }
    }
    else
    {
      dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
      if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
        goto LABEL_24;
      }
    }
    if ((gBBULogVerbosity & 0x80000000) == 0)
    {
      LOBYTE(v22) = a1 + 112;
      if (*(char *)(a1 + 135) < 0) {
        uint64_t v22 = *v15;
      }
      _BBULog(15, 0, "BBUZipFile", (const char *)&str_4_3, "Switch from file %s to %s\n", v11, v12, v13, (char)v22);
    }
LABEL_24:
    if (*(char *)(a1 + 135) < 0)
    {
      if (!*(void *)(a1 + 120))
      {
LABEL_52:
        if (v15 != a2)
        {
          signed __int8 v36 = *((unsigned char *)a2 + 23);
          if (*(char *)(a1 + 135) < 0)
          {
            if (v36 >= 0) {
              long long v38 = a2;
            }
            else {
              long long v38 = (void *)*a2;
            }
            if (v36 >= 0) {
              size_t v39 = *((unsigned __int8 *)a2 + 23);
            }
            else {
              size_t v39 = (size_t)a2[1];
            }
            std::string::__assign_no_alias<false>((void **)(a1 + 112), v38, v39);
          }
          else if ((*((unsigned char *)a2 + 23) & 0x80) != 0)
          {
            std::string::__assign_no_alias<true>((void *)(a1 + 112), (void *)*a2, (size_t)a2[1]);
          }
          else
          {
            long long v37 = *(_OWORD *)a2;
            *(void *)(a1 + 128) = a2[2];
            *(_OWORD *)uint64_t v15 = v37;
          }
        }
        *(_DWORD *)(a1 + 136) = 0;
        long long v40 = *(int8x16_t **)(a1 + 64);
        if (!v40
          || (v40[6] = vextq_s8(*(int8x16_t *)(v14 + 13), *(int8x16_t *)(v14 + 13), 8uLL),
              int CurrentFileInfoInternal = unzlocal_GetCurrentFileInfoInternal((uint64_t)v40, (uint64_t)v40[9].i64, &v40[17].i64[1], 0, 0, 0, 0, 0, 0), v40[7].i64[0] = CurrentFileInfoInternal == 0, CurrentFileInfoInternal))
        {
          int8x16_t v49 = __cxa_allocate_exception(0x210uLL);
          _BBUException::_BBUException((uint64_t)v49, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0xB7u, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v50, v51, v52, v69);
        }
        goto LABEL_66;
      }
    }
    else if (!*(unsigned char *)(a1 + 135))
    {
      goto LABEL_52;
    }
    uint64_t v32 = *(void *)(a1 + 64);
    if (!v32 || (uint64_t v33 = *(void *)(v32 + 288)) == 0)
    {
LABEL_93:
      uint64_t v28 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v28, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0xAFu, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v53, v54, v55, v69);
      goto LABEL_98;
    }
    if (*(void *)(v33 + 184) || *(_DWORD *)(v33 + 280))
    {
      int v34 = 0;
      size_t v35 = *(void **)v33;
      if (!*(void *)v33) {
        goto LABEL_49;
      }
    }
    else
    {
      if (*(void *)(v33 + 160) == *(void *)(v33 + 168)) {
        int v34 = 0;
      }
      else {
        int v34 = -105;
      }
      size_t v35 = *(void **)v33;
      if (!*(void *)v33)
      {
LABEL_49:
        *(void *)uint64_t v33 = 0;
        if (*(void *)(v33 + 128)) {
          inflateEnd((z_streamp)(v33 + 8));
        }
        free((void *)v33);
        *(void *)(v32 + 288) = 0;
        if (!v34) {
          goto LABEL_52;
        }
        goto LABEL_93;
      }
    }
    free(v35);
    goto LABEL_49;
  }
LABEL_27:
  unsigned int v23 = *(_DWORD *)(a1 + 136);
  if (v23 <= a5) {
    goto LABEL_68;
  }
  if (gBBULogMaskGet(void)::once == -1)
  {
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
      goto LABEL_32;
    }
  }
  else
  {
    dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
    if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
      goto LABEL_32;
    }
  }
  if (gBBULogVerbosity >= 1) {
    _BBULog(15, 1, "BBUZipFile", (const char *)&str_4_3, "Reset offset for %u, current %u, file %s\n", v11, v12, v13, a5);
  }
LABEL_32:
  *(_DWORD *)(a1 + 136) = 0;
  uint64_t v24 = *(void *)(a1 + 64);
  if (!v24 || (uint64_t v25 = *(char **)(v24 + 288)) == 0)
  {
LABEL_41:
    uint64_t v28 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v28, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0x9Eu, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v29, v30, v31, v69);
    goto LABEL_98;
  }
  if (*((void *)v25 + 23) || *((_DWORD *)v25 + 70))
  {
    int v26 = 0;
    uint64_t v27 = *(void **)v25;
    if (!*(void *)v25) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  if (*((void *)v25 + 20) == *((void *)v25 + 21)) {
    int v26 = 0;
  }
  else {
    int v26 = -105;
  }
  uint64_t v27 = *(void **)v25;
  if (*(void *)v25) {
LABEL_37:
  }
    free(v27);
LABEL_38:
  *(void *)uint64_t v25 = 0;
  if (*((void *)v25 + 16)) {
    inflateEnd((z_streamp)(v25 + 8));
  }
  free(v25);
  *(void *)(v24 + 288) = 0;
  if (v26) {
    goto LABEL_41;
  }
LABEL_66:
  if (unzOpenCurrentFile3(*(void *)(a1 + 64), 0, 0, 0, 0))
  {
    uint64_t v28 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v28, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0xBDu, (ctu::LogMessageBuffer *)"Assertion failure(ret == (0))", v66, v67, v68, v69);
LABEL_98:
  }
  unsigned int v23 = *(_DWORD *)(a1 + 136);
LABEL_68:
  unsigned int v42 = a5 - v23;
  if (a5 < v23)
  {
    uint64_t v28 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v28, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0xC0u, (ctu::LogMessageBuffer *)"Assertion failure(fCurrentFileOffset <= offset)", v60, v61, v62, v69);
    goto LABEL_98;
  }
  memset(__b, 170, sizeof(__b));
  for (; v42; v42 -= v43)
  {
    if (v42 >= 0x400) {
      unsigned int v43 = 1024;
    }
    else {
      unsigned int v43 = v42;
    }
    if (unzReadCurrentFile(*(void *)(a1 + 64), (uint64_t)__b, v43) != v43)
    {
      char v45 = __cxa_allocate_exception(0x210uLL);
      _BBUException::_BBUException((uint64_t)v45, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0xCBu, (ctu::LogMessageBuffer *)"Assertion failure(err == chunk)", v46, v47, v48, v69);
    }
  }
  *(_DWORD *)(a1 + 136) = a5;
  if (unzReadCurrentFile(*(void *)(a1 + 64), a3, a4) != a4)
  {
    uint64_t v28 = __cxa_allocate_exception(0x210uLL);
    _BBUException::_BBUException((uint64_t)v28, 2, "/Library/Caches/com.apple.xbs/Sources/AppleBasebandServices/BBUpdater/Legacy/Framework/Support/BBUZipFile.cpp", 0xD3u, (ctu::LogMessageBuffer *)"Assertion failure(ret == static_cast<SInt32>( amount))", v63, v64, v65, v69);
    goto LABEL_98;
  }
  *(_DWORD *)(a1 + 136) += a4;
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  return 0;
}

void sub_21DF09508(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t BBUZipFile::copyEntireFile(pthread_mutex_t *a1, const void **a2, __CFData **a3)
{
  if (!BBUZipFile::containsFile((uint64_t)a1, a2)) {
    return 15;
  }
  CFIndex FileSize = BBUZipFile::getFileSize(a1, a2);
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0, FileSize);
  if (!Mutable) {
    return 19;
  }
  uint64_t v8 = Mutable;
  CFDataSetLength(Mutable, FileSize);
  MutableBytePtr = CFDataGetMutableBytePtr(v8);
  BBUZipFile::copyDataFromFile((uint64_t)a1, a2, (uint64_t)MutableBytePtr, FileSize, 0);
  *a3 = v8;
  CFRetain(v8);
  CFRelease(v8);
  return 0;
}

uint64_t BBUZipFile::saveDataToFile(uint64_t a1, uint64_t a2)
{
  CFDataRef v3 = *(const __CFData **)(a1 + 144);
  if (v3)
  {
    CFDataGetBytePtr(v3);
    char Length = CFDataGetLength(*(CFDataRef *)(a1 + 144));
    size_t v6 = *(char *)(a2 + 23) >= 0 ? (const char *)a2 : *(const char **)a2;
    int v7 = open(v6, 1537, 420);
    if ((v7 & 0x80000000) == 0)
    {
      int v8 = v7;
      int v33 = -1431655766;
      uint64_t v9 = TelephonyUtilWriteToCompletion();
      if (!v9)
      {
        if (gBBULogMaskGet(void)::once == -1)
        {
          uint64_t v26 = 0;
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
            goto LABEL_39;
          }
        }
        else
        {
          dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
          uint64_t v26 = 0;
          if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) == 0) {
            goto LABEL_39;
          }
        }
        if ((gBBULogVerbosity & 0x80000000) == 0)
        {
          _BBULog(15, 0, "BBUZipFile", (const char *)&str_4_3, "Wrote %u bytes to %s\n", v10, v11, v12, v33);
          uint64_t v26 = 0;
        }
        goto LABEL_39;
      }
      uint64_t v13 = (BBUpdaterCommon *)v9;
      pthread_mutex_lock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
      uint64_t v14 = qword_26AA89AB0;
      if (!qword_26AA89AB0)
      {
        uint64_t v15 = (std::__shared_weak_count_vtbl *)operator new(0x38uLL);
        block[0] = 0;
        ctu::SharedSynchronizable<BBUError>::SharedSynchronizable(v15, "BBUError", QOS_CLASS_UTILITY, block);
        if (block[0]) {
          dispatch_release(block[0]);
        }
        v15->__on_zero_shared_weauint64_t k = 0;
        v15[1].~__shared_weak_count = 0;
        v15[1].~__shared_weak_count_0 = 0;
        std::shared_ptr<BBUError>::shared_ptr[abi:ne180100]<BBUError,std::shared_ptr<BBUError> ctu::SharedSynchronizable<BBUError>::make_shared_ptr<BBUError>(BBUError*)::{lambda(BBUError*)#1},void>((std::__shared_weak_count_vtbl **)&v34, v15);
        long long v16 = v34;
        long long v34 = 0uLL;
        char v17 = (std::__shared_weak_count *)off_26AA89AB8;
        *(_OWORD *)&qword_26AA89AB0 = v16;
        if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
        int8x16_t v18 = (std::__shared_weak_count *)*((void *)&v34 + 1);
        if (*((void *)&v34 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v34 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
        uint64_t v14 = qword_26AA89AB0;
      }
      int v19 = (std::__shared_weak_count *)off_26AA89AB8;
      uint64_t v31 = v14;
      uint64_t v32 = off_26AA89AB8;
      if (off_26AA89AB8) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)off_26AA89AB8 + 1, 1uLL, memory_order_relaxed);
      }
      pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
      BBUpdaterCommon::BBUStrError(v13, &v28);
      uint64_t v20 = std::string::insert(&v28, 0, "Failed to write file: ", 0x16uLL);
      long long v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
      std::string::size_type v30 = v20->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = v21;
      v20->__r_.__value_.__l.__size_ = 0;
      v20->__r_.__value_.__r.__words[2] = 0;
      v20->__r_.__value_.__r.__words[0] = 0;
      *(void *)&long long v34 = MEMORY[0x263EF8330];
      *((void *)&v34 + 1) = 0x40000000;
      size_t v35 = ___ZN8BBUError8addErrorERKNSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEE9BBUReturn_block_invoke;
      signed __int8 v36 = &__block_descriptor_tmp_8;
      long long v37 = v14;
      long long v38 = __p;
      int v39 = 35;
      long long v40 = &v34;
      block[0] = MEMORY[0x263EF8330];
      block[1] = 0x40000000;
      block[2] = ___ZNK3ctu20SharedSynchronizableI8BBUErrorE20execute_wrapped_syncIRU13block_pointerFvvEEEDTclsr8dispatchE4syncLDnEclsr3stdE7forwardIT_Efp_EEEOS7__block_invoke;
      block[3] = &__block_descriptor_tmp_13_0;
      block[4] = v14;
      void block[5] = &v40;
      isa = v14[2].isa;
      if (v14[3].isa)
      {
        dispatch_async_and_wait(isa, block);
        if ((SHIBYTE(v30) & 0x80000000) == 0) {
          goto LABEL_22;
        }
      }
      else
      {
        dispatch_sync(isa, block);
        if ((SHIBYTE(v30) & 0x80000000) == 0)
        {
LABEL_22:
          if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v28.__r_.__value_.__l.__data_);
            if (!v19) {
              goto LABEL_35;
            }
          }
          else if (!v19)
          {
            goto LABEL_35;
          }
          if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
LABEL_35:
          if (gBBULogMaskGet(void)::once == -1)
          {
            uint64_t v26 = 35;
            if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) != 0) {
              goto LABEL_37;
            }
          }
          else
          {
            dispatch_once(&gBBULogMaskGet(void)::once, &__block_literal_global_5);
            uint64_t v26 = 35;
            if ((*(unsigned char *)(gBBULogMaskGet(void)::sBBULogMask + 1) & 0x80) != 0)
            {
LABEL_37:
              if ((gBBULogVerbosity & 0x80000000) == 0) {
                _BBULog(15, 0, "BBUZipFile", (const char *)&str_4_3, "Failed writing %u bytes to %s - wrote only %u\n", v23, v24, v25, Length);
              }
            }
          }
LABEL_39:
          close(v8);
          return v26;
        }
      }
      operator delete(__p[0]);
      goto LABEL_22;
    }
  }
  return 35;
}

void sub_21DF09AC8(_Unwind_Exception *a1)
{
  uint64_t v4 = *(NSObject **)(v2 - 112);
  if (v4) {
    dispatch_release(v4);
  }
  operator delete(v1);
  pthread_mutex_unlock(&ctu::Singleton<BBUError,BBUError,ctu::PthreadMutexGuardPolicy<BBUError>>::sInstance);
  _Unwind_Resume(a1);
}

void sub_21DF09B00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  if (a17 < 0)
  {
    operator delete(__p);
    std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
    _Unwind_Resume(a1);
  }
  std::shared_ptr<boost::msm::back::state_machine<BBUpdaterControllerFSM::ControllerFSM_TOP,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_,boost::parameter::void_>>::~shared_ptr[abi:ne180100]((uint64_t)&a21);
  _Unwind_Resume(a1);
}