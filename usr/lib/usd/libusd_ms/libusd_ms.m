BOOL tbb::internal::hash_map_segment_base::internal_grow_predicate(tbb::internal::hash_map_segment_base *this)
{
  unint64_t v1;
  unint64_t v2;

  v1 = *((void *)this + 1);
  __dmb(0xBu);
  v2 = *((void *)this + 2);
  return v1 >= v2 && v2 >> 58 == 0;
}

uint64_t tbb::internal::micro_queue::push(uint64_t result, uint64_t a2, unint64_t a3, void *a4, int a5)
{
  uint64_t v8 = result;
  unint64_t v9 = a3 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v10 = (a4[3] - 1) & (a3 >> 3);
  if (v10)
  {
    uint64_t v11 = 0;
  }
  else
  {
    result = (*(uint64_t (**)(void *))(*a4 + 32))(a4);
    uint64_t v11 = result;
    *(void *)result = 0;
    *(void *)(result + 8) = 0;
  }
  uint64_t v12 = *(void *)(v8 + 24);
  __dmb(0xBu);
  if (v12 != v9)
  {
    result = sched_yield();
    uint64_t v13 = *(void *)(v8 + 24);
    __dmb(0xBu);
    while (v13 != v9)
    {
      if (v13)
      {
        atomic_fetch_add((atomic_ullong *volatile)(a4[1] + 48), 1uLL);
        tbb::internal::throw_exception_v4(2);
      }
      result = sched_yield();
      uint64_t v13 = *(void *)(v8 + 24);
      __dmb(0xBu);
    }
  }
  if (v11)
  {
    v14 = (atomic_uint *)((v8 + 32) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_8:
    int v15 = *v14 & ~(255 << (8 * ((v8 + 32) & 3)));
    while (1)
    {
      int v16 = v15;
      atomic_compare_exchange_strong(v14, (unsigned int *)&v16, v15 | (1 << (8 * ((v8 + 32) & 3))));
      if (v16 == v15) {
        break;
      }
      if (*v14 != v15)
      {
        result = sched_yield();
        goto LABEL_8;
      }
    }
    v17 = *(uint64_t **)(v8 + 16);
    __dmb(0xBu);
    if (v17)
    {
      uint64_t *v17 = v11;
    }
    else
    {
      __dmb(0xBu);
      *(void *)uint64_t v8 = v11;
    }
    __dmb(0xBu);
    *(void *)(v8 + 16) = v11;
    __dmb(0xBu);
    *(unsigned char *)(v8 + 32) = 0;
  }
  if (a2)
  {
    uint64_t v18 = *(void *)(v8 + 16);
    __dmb(0xBu);
    if (a5) {
      v19 = (uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))(*a4 + 64);
    }
    else {
      v19 = (uint64_t (**)(void *, uint64_t, uint64_t, uint64_t))*a4;
    }
    result = (*v19)(a4, v18, v10, a2);
    *(void *)(v18 + 8) |= 1 << v10;
  }
  else
  {
    atomic_fetch_add((atomic_ullong *volatile)(a4[1] + 48), 1uLL);
  }
  atomic_fetch_add((atomic_ullong *volatile)(v8 + 24), 8uLL);
  return result;
}

void sub_21675DA38(void *a1)
{
  __cxa_begin_catch(a1);
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(v2 + 8) + 48), 1uLL);
  tbb::internal::micro_queue::make_invalid(v1, v3);
  __cxa_rethrow();
}

void sub_21675DA5C()
{
}

void sub_21675DA94()
{
}

uint64_t tbb::internal::micro_queue::make_invalid(uint64_t this, uint64_t a2)
{
  uint64_t v3 = this;
  qword_26798E010 = (uint64_t)&unk_26798AF60;
  v4 = (atomic_uint *)((this + 32) & 0xFFFFFFFFFFFFFFFCLL);
  int v5 = 1 << (8 * ((this + 32) & 3));
  int v6 = ~(255 << (8 * ((this + 32) & 3)));
LABEL_2:
  int v7 = *v4 & v6;
  while (1)
  {
    int v8 = v7;
    atomic_compare_exchange_strong(v4, (unsigned int *)&v8, v7 | v5);
    if (v8 == v7) {
      break;
    }
    if (*v4 != v7)
    {
      this = sched_yield();
      goto LABEL_2;
    }
  }
  __dmb(0xBu);
  *(void *)(v3 + 24) = a2 + 9;
  unint64_t v9 = *(void **)(v3 + 16);
  __dmb(0xBu);
  if (v9)
  {
    *unint64_t v9 = &unk_26798AF60;
  }
  else
  {
    __dmb(0xBu);
    *(void *)uint64_t v3 = &unk_26798AF60;
  }
  __dmb(0xBu);
  *(void *)(v3 + 16) = &unk_26798AF60;
  __dmb(0xBu);
  *(unsigned char *)(v3 + 32) = 0;
  return this;
}

void sub_21675DB74(void *a1)
{
}

uint64_t tbb::internal::micro_queue::abort_push(tbb::internal::micro_queue *this, unint64_t a2, tbb::internal::concurrent_queue_base_v3 *a3)
{
  return tbb::internal::micro_queue::push((uint64_t)this, 0, a2, a3, 0);
}

BOOL tbb::internal::micro_queue::pop(tbb::internal::micro_queue *this, void *a2, unint64_t a3, tbb::internal::concurrent_queue_base_v3 *a4)
{
  unint64_t v8 = a3 & 0xFFFFFFFFFFFFFFF8;
  for (uint64_t i = *((void *)this + 1); ; uint64_t i = *((void *)this + 1))
  {
    __dmb(0xBu);
    if (i == v8) {
      break;
    }
    sched_yield();
  }
  while (1)
  {
    uint64_t v10 = *((void *)this + 3);
    __dmb(0xBu);
    if (v10 != v8) {
      break;
    }
    sched_yield();
  }
  uint64_t v11 = *(void *)this;
  __dmb(0xBu);
  uint64_t v12 = *((void *)a4 + 3) - 1;
  uint64_t v13 = v12 & (a3 >> 3);
  if (v13 == v12) {
    uint64_t v14 = v11;
  }
  else {
    uint64_t v14 = 0;
  }
  v17[0] = v8 + 8;
  v17[1] = (uint64_t)this;
  v17[2] = v14;
  v17[3] = (uint64_t)a4;
  uint64_t v15 = *(void *)(v11 + 8) & (1 << v13);
  if (v15) {
    (*(void (**)(tbb::internal::concurrent_queue_base_v3 *, void *))(*(void *)a4 + 8))(a4, a2);
  }
  else {
    atomic_fetch_add((atomic_ullong *volatile)(*((void *)a4 + 1) + 48), 0xFFFFFFFFFFFFFFFFLL);
  }
  sub_21675F22C(v17);
  return v15 != 0;
}

void sub_21675DCA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *tbb::internal::micro_queue::assign(void *a1, uint64_t *a2, void *a3, int a4)
{
  v4 = a1;
  uint64_t v5 = a2[1];
  __dmb(0xBu);
  a1[1] = v5;
  uint64_t v6 = a2[3];
  __dmb(0xBu);
  a1[3] = v6;
  uint64_t v7 = *a2;
  __dmb(0xBu);
  if (v7)
  {
    uint64_t v11 = a1[1];
    __dmb(0xBu);
    uint64_t v12 = a1[3];
    __dmb(0xBu);
    uint64_t v13 = a1[1];
    __dmb(0xBu);
    unint64_t v14 = a1[1];
    __dmb(0xBu);
    unint64_t v15 = v12 - v13;
    unint64_t v16 = a3[3];
    uint64_t v17 = (v16 - 1) & (v14 >> 3);
    unint64_t v18 = v17 + (v15 >> 3);
    if (v18 >= v16) {
      unint64_t v19 = a3[3];
    }
    else {
      unint64_t v19 = v18;
    }
    v20 = (void *)(*(uint64_t (**)(void *))(*a3 + 32))(a3);
    uint64_t v21 = *(void *)(v7 + 8);
    void *v20 = 0;
    v20[1] = v21;
    if (v17 != v19)
    {
      uint64_t v22 = v11 + v19 - v17;
      do
      {
        if ((v20[1] >> v17))
        {
          uint64_t v23 = *a3;
          if (a4) {
            v24 = (void (**)(void *, void *, uint64_t, uint64_t, uint64_t))(v23 + 56);
          }
          else {
            v24 = (void (**)(void *, void *, uint64_t, uint64_t, uint64_t))(v23 + 48);
          }
          (*v24)(a3, v20, v17, v7, v17);
        }
        ++v17;
        ++v11;
      }
      while (v19 != v17);
      uint64_t v11 = v22;
    }
    __dmb(0xBu);
    void *v4 = v20;
    v25 = (void *)*v4;
    __dmb(0xBu);
    uint64_t v26 = a2[2];
    __dmb(0xBu);
    if (v7 != v26)
    {
      v27 = *(void **)v7;
      v28 = (void *)a2[2];
      __dmb(0xBu);
      if (v27 == v28)
      {
        v29 = v25;
      }
      else
      {
        do
        {
          uint64_t v38 = a3[3];
          v29 = (void *)(*(uint64_t (**)(void *))(*a3 + 32))(a3);
          uint64_t v39 = v27[1];
          void *v29 = 0;
          v29[1] = v39;
          if (v38)
          {
            for (uint64_t i = 0; i != v38; ++i)
            {
              if ((v29[1] >> i))
              {
                uint64_t v41 = *a3;
                if (a4) {
                  v42 = (void (**)(void *, void *, uint64_t, void *, uint64_t))(v41 + 56);
                }
                else {
                  v42 = (void (**)(void *, void *, uint64_t, void *, uint64_t))(v41 + 48);
                }
                (*v42)(a3, v29, i, v27, i);
              }
            }
            v11 += v38;
          }
          void *v25 = v29;
          v27 = (void *)*v27;
          v37 = (void *)a2[2];
          __dmb(0xBu);
          v25 = v29;
        }
        while (v27 != v37);
      }
      v4 = a1;
      unint64_t v30 = a1[3];
      __dmb(0xBu);
      uint64_t v31 = (a3[3] - 1) & (v30 >> 3);
      if (v31) {
        uint64_t v32 = v31;
      }
      else {
        uint64_t v32 = a3[3];
      }
      v25 = (void *)(*(uint64_t (**)(void *))(*a3 + 32))(a3);
      uint64_t v33 = v27[1];
      void *v25 = 0;
      v25[1] = v33;
      if (v32)
      {
        for (uint64_t j = 0; j != v32; ++j)
        {
          if ((v25[1] >> j))
          {
            uint64_t v35 = *a3;
            if (a4) {
              v36 = (void (**)(void *, void *, uint64_t, void *, uint64_t))(v35 + 56);
            }
            else {
              v36 = (void (**)(void *, void *, uint64_t, void *, uint64_t))(v35 + 48);
            }
            (*v36)(a3, v25, j, v27, j);
          }
        }
      }
      void *v29 = v25;
    }
    __dmb(0xBu);
    v4[2] = v25;
  }
  else
  {
    __dmb(0xBu);
    a1[2] = 0;
    __dmb(0xBu);
    *a1 = 0;
  }
  return v4;
}

void sub_21675E04C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, tbb::internal::micro_queue *a10)
{
  __cxa_begin_catch(a1);
  tbb::internal::micro_queue::make_invalid((uint64_t)a10, v10);
  __cxa_rethrow();
}

void sub_21675E080(_Unwind_Exception *a1)
{
}

void *tbb::internal::micro_queue::make_copy(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, int a7)
{
  uint64_t v13 = (void *)(*(uint64_t (**)(uint64_t *))(*a2 + 32))(a2);
  uint64_t v14 = *(void *)(a3 + 8);
  *uint64_t v13 = 0;
  for (v13[1] = v14; a5 != a4; ++*a6)
  {
    if ((v13[1] >> a4))
    {
      uint64_t v16 = *a2;
      if (a7) {
        (*(void (**)(uint64_t *, void *, uint64_t, uint64_t, uint64_t))(v16 + 56))(a2, v13, a4, a3, a4);
      }
      else {
        (*(void (**)(uint64_t *, void *, uint64_t, uint64_t, uint64_t))(v16 + 48))(a2, v13, a4, a3, a4);
      }
    }
    ++a4;
  }
  return v13;
}

tbb::internal::concurrent_queue_base_v3 *tbb::internal::concurrent_queue_base_v3::concurrent_queue_base_v3(tbb::internal::concurrent_queue_base_v3 *this, unint64_t a2, uint64_t a3, void *a4)
{
  *(void *)this = &unk_26C746538;
  if (a2 >= 9)
  {
    if (a2 >= 0x11)
    {
      if (a2 >= 0x21)
      {
        if (a2 >= 0x41)
        {
          uint64_t v6 = 1;
          if (a2 < 0x81) {
            uint64_t v6 = 2;
          }
        }
        else
        {
          uint64_t v6 = 4;
        }
      }
      else
      {
        uint64_t v6 = 8;
      }
    }
    else
    {
      uint64_t v6 = 16;
    }
  }
  else
  {
    uint64_t v6 = 32;
  }
  unint64_t v7 = 2;
  if (a2 > 2) {
    unint64_t v7 = a2;
  }
  *((void *)this + 2) = 0xFFFFFFFFFFFFFFFFLL / v7;
  *((void *)this + 3) = v6;
  unint64_t v8 = (void *)tbb::internal::NFS_Allocate(1uLL, 584, 0, a4);
  *((void *)this + 1) = v8;
  bzero(v8, 0x248uLL);
  uint64_t v9 = *((void *)this + 1);
  *(unsigned char *)(v9 + 9) = 0;
  *(void *)(v9 + 24) = v9 + 24;
  *(void *)(v9 + 32) = v9 + 24;
  *(void *)(v9 + 16) = 0;
  *(_DWORD *)(v9 + 40) = 0;
  *(unsigned char *)(v9 + 137) = 0;
  *(void *)(v9 + 152) = v9 + 152;
  *(void *)(v9 + 160) = v9 + 152;
  *(void *)(v9 + 144) = 0;
  *(_DWORD *)(v9 + 168) = 0;
  *((void *)this + 4) = a2;
  return this;
}

void tbb::internal::concurrent_queue_base_v3::~concurrent_queue_base_v3(tbb::internal **this, void *a2)
{
  *this = (tbb::internal *)&unk_26C746538;
  tbb::internal::NFS_Free(this[1], a2);
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_push(tbb::internal::concurrent_queue_base_v3 *this, uint64_t a2)
{
  return tbb::internal::concurrent_queue_base_v3::internal_insert_item(this, a2, 0);
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_insert_item(void *a1, uint64_t a2, int a3)
{
  uint64_t v6 = (uint64_t *)a1[1];
  int v7 = *((_DWORD *)v6 + 144);
  __dmb(0xBu);
  unint64_t add = atomic_fetch_add(v6 + 16, 1uLL);
  int64_t v9 = a1[2];
  uint64_t v10 = *v6;
  __dmb(0xBu);
  if ((uint64_t)(add - v10) >= v9)
  {
    v15[0] = 3452816845;
    v15[1] = 3452816845;
    __int16 v19 = 0;
    char v20 = 0;
    uint64_t v21 = 0;
    int v17 = 0;
    __dmb(0xBu);
    char v18 = 0;
    tbb::internal::concurrent_monitor::prepare_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v15, add - v9);
    while (1)
    {
      uint64_t v11 = *v6;
      __dmb(0xBu);
      int64_t v12 = a1[2];
      if ((uint64_t)(add - v11) < v12)
      {
        tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v15);
        goto LABEL_12;
      }
      int v13 = *((_DWORD *)v6 + 144);
      __dmb(0xBu);
      if (v13 != v7)
      {
        tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v15);
        tbb::internal::throw_exception_v4(18);
      }
      if (v17 == *((_DWORD *)v6 + 42)) {
        break;
      }
      tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v15);
      tbb::internal::concurrent_monitor::prepare_wait((uint64_t)(v6 + 17), (tbb::internal::concurrent_monitor::thread_context *)v15, add - v12);
    }
    while (MEMORY[0x21D448B00](semaphore) == 14)
      ;
    if (HIBYTE(v19)) {
      tbb::internal::throw_exception_v4(18);
    }
LABEL_12:
    if (v20)
    {
      if ((_BYTE)v19)
      {
        while (MEMORY[0x21D448B00](semaphore) == 14)
          ;
      }
      semaphore_destroy(*MEMORY[0x263EF8960], semaphore);
    }
  }
  tbb::internal::micro_queue::push((uint64_t)&v6[5 * ((3 * add) & 7) + 32], a2, add, a1, a3);
  v15[0] = add;
  __dmb(0xBu);
  return sub_21675F334((uint64_t)(v6 + 1), v15);
}

void sub_21675E4C8(void *a1, int a2)
{
  __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    tbb::internal::micro_queue::push(v4 + 40 * ((3 * (_BYTE)v3) & 7) + 256, 0, v3, v2, 0);
    __cxa_rethrow();
  }
  __cxa_rethrow();
}

void sub_21675E52C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  __cxa_end_catch();
  sub_21675E55C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21675E538()
{
}

uint64_t tbb::internal::concurrent_queue_base_v8::internal_push_move(tbb::internal::concurrent_queue_base_v8 *this, uint64_t a2)
{
  return tbb::internal::concurrent_queue_base_v3::internal_insert_item(this, a2, 1);
}

uint64_t sub_21675E55C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 27))
  {
    if (*(unsigned char *)(a1 + 25))
    {
      while (MEMORY[0x21D448B00](*(unsigned int *)(a1 + 16)) == 14)
        ;
    }
    semaphore_destroy(*MEMORY[0x263EF8960], *(_DWORD *)(a1 + 16));
  }
  return a1;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_pop(tbb::internal::concurrent_queue_base_v3 *this, void *a2)
{
  uint64_t v4 = *((void *)this + 1);
  int v5 = *(_DWORD *)(v4 + 576);
  __dmb(0xBu);
  uint64_t v6 = (task_t *)MEMORY[0x263EF8960];
  do
  {
    unint64_t add = atomic_fetch_add((atomic_ullong *volatile)v4, 1uLL);
    uint64_t v8 = *(void *)(v4 + 128);
    __dmb(0xBu);
    if ((uint64_t)(v8 - add) <= 0)
    {
      v12[0] = 3452816845;
      v12[1] = 3452816845;
      __int16 v16 = 0;
      char v17 = 0;
      uint64_t v18 = 0;
      int v14 = 0;
      __dmb(0xBu);
      char v15 = 0;
      tbb::internal::concurrent_monitor::prepare_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12, add);
      while (1)
      {
        uint64_t v9 = *(void *)(v4 + 128);
        __dmb(0xBu);
        if ((uint64_t)(v9 - add) > 0)
        {
          tbb::internal::concurrent_monitor::cancel_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12);
          goto LABEL_15;
        }
        int v10 = *(_DWORD *)(v4 + 576);
        __dmb(0xBu);
        if (v10 != v5)
        {
          tbb::internal::concurrent_monitor::cancel_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12);
          tbb::internal::throw_exception_v4(18);
        }
        if (v14 == *(_DWORD *)(v4 + 40)) {
          break;
        }
        tbb::internal::concurrent_monitor::cancel_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12);
        tbb::internal::concurrent_monitor::prepare_wait(v4 + 8, (tbb::internal::concurrent_monitor::thread_context *)v12, add);
      }
      while (MEMORY[0x21D448B00](semaphore) == 14)
        ;
      if (HIBYTE(v16)) {
        tbb::internal::throw_exception_v4(18);
      }
LABEL_15:
      if (v17)
      {
        if ((_BYTE)v16)
        {
          while (MEMORY[0x21D448B00](semaphore) == 14)
            ;
        }
        semaphore_destroy(*v6, semaphore);
      }
    }
  }
  while (!tbb::internal::micro_queue::pop((tbb::internal::micro_queue *)(v4 + 40 * ((3 * (_BYTE)add) & 7) + 256), a2, add, this));
  v12[0] = add;
  __dmb(0xBu);
  return sub_21675F334(v4 + 136, v12);
}

void sub_21675E778(void *a1, int a2)
{
  __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    atomic_fetch_add(v2, 0xFFFFFFFFFFFFFFFFLL);
    __cxa_rethrow();
  }
  __cxa_rethrow();
}

void sub_21675E7BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  __cxa_end_catch();
  sub_21675E55C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_21675E7C8()
{
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_abort(tbb::internal::concurrent_queue_base_v3 *this)
{
  uint64_t v1 = *((void *)this + 1);
  atomic_fetch_add((atomic_uint *volatile)(v1 + 576), 1u);
  __dmb(0xBu);
  tbb::internal::concurrent_monitor::abort_all_relaxed(v1 + 8);
  __dmb(0xBu);

  return tbb::internal::concurrent_monitor::abort_all_relaxed(v1 + 136);
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_pop_if_present(tbb::internal::concurrent_queue_base_v3 *this, void *a2)
{
  uint64_t v4 = (atomic_ullong *)*((void *)this + 1);
  do
  {
    unint64_t v5 = *v4;
    __dmb(0xBu);
    atomic_ullong v6 = v4[16];
    __dmb(0xBu);
    if ((uint64_t)(v6 - v5) < 1) {
      return 0;
    }
    while (1)
    {
      unint64_t v7 = v5;
      atomic_compare_exchange_strong(v4, &v7, v5 + 1);
      if (v7 == v5) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit(v4, 0, memory_order_relaxed);
      if (add_explicit != v5)
      {
        atomic_ullong v9 = v4[16];
        __dmb(0xBu);
        unint64_t v5 = add_explicit;
        if ((uint64_t)(v9 - add_explicit) < 1) {
          return 0;
        }
      }
    }
  }
  while (!tbb::internal::micro_queue::pop((tbb::internal::micro_queue *)&v4[5 * ((3 * v5) & 7) + 32], a2, v5, this));
  unint64_t v11 = v5;
  __dmb(0xBu);
  sub_21675F334((uint64_t)(v4 + 17), &v11);
  return 1;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_push_if_not_full(tbb::internal::concurrent_queue_base_v3 *this, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  unint64_t v3 = v2[16];
  __dmb(0xBu);
  uint64_t v4 = *v2;
  __dmb(0xBu);
  if ((int64_t)(v3 - v4) >= *((void *)this + 2)) {
    return 0;
  }
  while (1)
  {
    unint64_t v6 = v3;
    atomic_compare_exchange_strong(v2 + 16, &v6, v3 + 1);
    if (v6 == v3) {
      break;
    }
    unint64_t add_explicit = atomic_fetch_add_explicit(v2 + 16, 0, memory_order_relaxed);
    if (add_explicit != v3)
    {
      uint64_t result = 0;
      uint64_t v9 = *v2;
      __dmb(0xBu);
      unint64_t v3 = add_explicit;
      if ((int64_t)(add_explicit - v9) >= *((void *)this + 2)) {
        return result;
      }
    }
  }
  tbb::internal::micro_queue::push((uint64_t)&v2[5 * ((3 * v3) & 7) + 32], a2, v3, this, 0);
  unint64_t v10 = v3;
  __dmb(0xBu);
  sub_21675F334((uint64_t)(v2 + 1), &v10);
  return 1;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_insert_if_not_full(void *a1, uint64_t a2, int a3)
{
  unint64_t v3 = (uint64_t *)a1[1];
  unint64_t v4 = v3[16];
  __dmb(0xBu);
  uint64_t v5 = *v3;
  __dmb(0xBu);
  if ((int64_t)(v4 - v5) >= a1[2]) {
    return 0;
  }
  while (1)
  {
    unint64_t v7 = v4;
    atomic_compare_exchange_strong(v3 + 16, &v7, v4 + 1);
    if (v7 == v4) {
      break;
    }
    unint64_t add_explicit = atomic_fetch_add_explicit(v3 + 16, 0, memory_order_relaxed);
    if (add_explicit != v4)
    {
      uint64_t result = 0;
      uint64_t v10 = *v3;
      __dmb(0xBu);
      unint64_t v4 = add_explicit;
      if ((int64_t)(add_explicit - v10) >= a1[2]) {
        return result;
      }
    }
  }
  tbb::internal::micro_queue::push((uint64_t)&v3[5 * ((3 * v4) & 7) + 32], a2, v4, a1, a3);
  unint64_t v11 = v4;
  __dmb(0xBu);
  sub_21675F334((uint64_t)(v3 + 1), &v11);
  return 1;
}

uint64_t tbb::internal::concurrent_queue_base_v8::internal_push_move_if_not_full(tbb::internal::concurrent_queue_base_v8 *this, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  unint64_t v3 = v2[16];
  __dmb(0xBu);
  uint64_t v4 = *v2;
  __dmb(0xBu);
  if ((int64_t)(v3 - v4) >= *((void *)this + 2)) {
    return 0;
  }
  while (1)
  {
    unint64_t v5 = v3;
    atomic_compare_exchange_strong(v2 + 16, &v5, v3 + 1);
    if (v5 == v3) {
      break;
    }
    unint64_t add_explicit = atomic_fetch_add_explicit(v2 + 16, 0, memory_order_relaxed);
    if (add_explicit != v3)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *v2;
      __dmb(0xBu);
      unint64_t v3 = add_explicit;
      if ((int64_t)(add_explicit - v8) >= *((void *)this + 2)) {
        return v7;
      }
    }
  }
  uint64_t v7 = 1;
  tbb::internal::micro_queue::push((uint64_t)&v2[5 * ((3 * v3) & 7) + 32], a2, v3, this, 1);
  unint64_t v10 = v3;
  __dmb(0xBu);
  sub_21675F334((uint64_t)(v2 + 1), &v10);
  return v7;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_size(tbb::internal::concurrent_queue_base_v3 *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 1) + 128);
  __dmb(0xBu);
  uint64_t v2 = **((void **)this + 1);
  __dmb(0xBu);
  uint64_t v3 = *(void *)(*((void *)this + 1) + 48);
  __dmb(0xBu);
  return v1 - (v2 + v3);
}

BOOL tbb::internal::concurrent_queue_base_v3::internal_empty(tbb::internal::concurrent_queue_base_v3 *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 1) + 128);
  __dmb(0xBu);
  uint64_t v2 = **((void **)this + 1);
  __dmb(0xBu);
  uint64_t v3 = *(void *)(*((void *)this + 1) + 128);
  __dmb(0xBu);
  if (v1 != v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(*((void *)this + 1) + 48);
  __dmb(0xBu);
  return v1 - (v2 + v4) < 1;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_set_capacity(uint64_t this, unint64_t a2)
{
  uint64_t v2 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 < 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v2 = a2;
  }
  *(void *)(this + 16) = v2;
  return this;
}

void *tbb::internal::concurrent_queue_base_v3::internal_finish_clear(void *this)
{
  uint64_t v1 = this;
  for (uint64_t i = 272; i != 592; i += 40)
  {
    uint64_t v4 = *(void *)(v1[1] + i);
    __dmb(0xBu);
    if (v4)
    {
      if (qword_26798E010 != v4) {
        this = (void *)(*(uint64_t (**)(void *))(*v1 + 40))(v1);
      }
      uint64_t v3 = v1[1];
      __dmb(0xBu);
      *(void *)(v3 + i) = 0;
    }
  }
  return this;
}

uint64_t tbb::internal::concurrent_queue_base_v3::internal_throw_exception(tbb::internal::concurrent_queue_base_v3 *this)
{
  return tbb::internal::throw_exception_v4(1);
}

void *tbb::internal::concurrent_queue_base_v3::internal_assign(uint64_t a1, uint64_t a2, int a3)
{
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  unint64_t v6 = *(void **)(a1 + 8);
  uint64_t v7 = **(void **)(a2 + 8);
  __dmb(0xBu);
  *unint64_t v6 = v7;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(*(void *)(a2 + 8) + 128);
  __dmb(0xBu);
  *(void *)(v8 + 128) = v9;
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(*(void *)(a2 + 8) + 48);
  __dmb(0xBu);
  *(void *)(v10 + 48) = v11;
  uint64_t v12 = *(void *)(a1 + 8);
  LODWORD(v11) = *(_DWORD *)(*(void *)(a2 + 8) + 576);
  __dmb(0xBu);
  *(_DWORD *)(v12 + 576) = v11;
  tbb::internal::micro_queue::assign((void *)(*(void *)(a1 + 8) + 256), (uint64_t *)(*(void *)(a2 + 8) + 256), (void *)a1, a3);
  tbb::internal::micro_queue::assign((void *)(*(void *)(a1 + 8) + 296), (uint64_t *)(*(void *)(a2 + 8) + 296), (void *)a1, a3);
  tbb::internal::micro_queue::assign((void *)(*(void *)(a1 + 8) + 336), (uint64_t *)(*(void *)(a2 + 8) + 336), (void *)a1, a3);
  tbb::internal::micro_queue::assign((void *)(*(void *)(a1 + 8) + 376), (uint64_t *)(*(void *)(a2 + 8) + 376), (void *)a1, a3);
  tbb::internal::micro_queue::assign((void *)(*(void *)(a1 + 8) + 416), (uint64_t *)(*(void *)(a2 + 8) + 416), (void *)a1, a3);
  tbb::internal::micro_queue::assign((void *)(*(void *)(a1 + 8) + 456), (uint64_t *)(*(void *)(a2 + 8) + 456), (void *)a1, a3);
  tbb::internal::micro_queue::assign((void *)(*(void *)(a1 + 8) + 496), (uint64_t *)(*(void *)(a2 + 8) + 496), (void *)a1, a3);
  int v13 = (void *)(*(void *)(a1 + 8) + 536);
  int v14 = (uint64_t *)(*(void *)(a2 + 8) + 536);

  return tbb::internal::micro_queue::assign(v13, v14, (void *)a1, a3);
}

void *tbb::internal::concurrent_queue_base_v3::assign(tbb::internal::concurrent_queue_base_v3 *this, const tbb::internal::concurrent_queue_base_v3 *a2)
{
  return tbb::internal::concurrent_queue_base_v3::internal_assign((uint64_t)this, (uint64_t)a2, 0);
}

void *tbb::internal::concurrent_queue_base_v8::move_content(uint64_t a1, uint64_t a2)
{
  return tbb::internal::concurrent_queue_base_v3::internal_assign(a1, a2, 1);
}

unint64_t *tbb::internal::concurrent_queue_iterator_base_v3::initialize(unint64_t **this, const tbb::internal::concurrent_queue_base_v3 *a2, unint64_t a3, void *a4)
{
  uint64_t result = (unint64_t *)tbb::internal::NFS_Allocate(1uLL, 88, 0, a4);
  *this = result;
  unint64_t v8 = **((void **)a2 + 1);
  __dmb(0xBu);
  *uint64_t result = v8;
  result[1] = (unint64_t)a2;
  result[2] = a3;
  uint64_t v9 = (void *)*((void *)a2 + 1);
  unint64_t v10 = v9[32];
  __dmb(0xBu);
  result[3] = v10;
  unint64_t v11 = v9[37];
  __dmb(0xBu);
  result[4] = v11;
  unint64_t v12 = v9[42];
  __dmb(0xBu);
  result[5] = v12;
  unint64_t v13 = v9[47];
  __dmb(0xBu);
  result[6] = v13;
  unint64_t v14 = v9[52];
  __dmb(0xBu);
  result[7] = v14;
  unint64_t v15 = v9[57];
  __dmb(0xBu);
  result[8] = v15;
  unint64_t v16 = v9[62];
  __dmb(0xBu);
  result[9] = v16;
  unint64_t v17 = v9[67];
  __dmb(0xBu);
  result[10] = v17;
  uint64_t v18 = *this;
  unint64_t v19 = **this;
  uint64_t v20 = *(void *)(*(void *)((*this)[1] + 8) + 128);
  __dmb(0xBu);
  if (v20 == v19)
  {
LABEL_2:
    this[1] = 0;
    return result;
  }
  unint64_t v21 = v18[((3 * v19) & 7) + 3];
  unint64_t v22 = v18[1];
  uint64_t v23 = (*(void *)(v22 + 24) - 1) & (v19 >> 3);
  uint64_t v24 = v21 + v18[2] + *(void *)(v22 + 32) * v23;
  unint64_t v25 = *(void *)(v21 + 8);
  this[1] = (unint64_t *)v24;
  if (((v25 >> v23) & 1) == 0)
  {
    while (1)
    {
      uint64_t v31 = *this;
      unint64_t v32 = **this;
      unint64_t v33 = (*this)[1];
      if (((*(void *)(v33 + 24) - 1) & ~(v32 >> 3)) == 0)
      {
        v34 = &v31[(3 * (_BYTE)v32) & 7];
        v34[3] = *(void *)v34[3];
        uint64_t v31 = *this;
        unint64_t v33 = (*this)[1];
      }
      unint64_t v35 = v32 + 1;
      *uint64_t v31 = v35;
      uint64_t v36 = *(void *)(*(void *)(v33 + 8) + 128);
      __dmb(0xBu);
      if (v36 == v35) {
        break;
      }
      unint64_t v26 = v31[((3 * v35) & 7) + 3];
      unint64_t v27 = v31[1];
      uint64_t v28 = (*(void *)(v27 + 24) - 1) & (v35 >> 3);
      uint64_t v29 = v26 + v31[2] + *(void *)(v27 + 32) * v28;
      unint64_t v30 = *(void *)(v26 + 8);
      this[1] = (unint64_t *)v29;
      if ((v30 >> v28)) {
        return result;
      }
    }
    goto LABEL_2;
  }
  return result;
}

unint64_t **tbb::internal::concurrent_queue_iterator_base_v3::advance(unint64_t **this)
{
  while (1)
  {
    uint64_t v1 = *this;
    unint64_t v2 = **this;
    unint64_t v3 = (*this)[1];
    if (((*(void *)(v3 + 24) - 1) & ~(v2 >> 3)) == 0)
    {
      uint64_t v4 = &v1[(3 * (_BYTE)v2) & 7];
      v4[3] = *(void *)v4[3];
      uint64_t v1 = *this;
      unint64_t v3 = (*this)[1];
    }
    unint64_t v5 = v2 + 1;
    *uint64_t v1 = v5;
    uint64_t v6 = *(void *)(*(void *)(v3 + 8) + 128);
    __dmb(0xBu);
    if (v6 == v5) {
      break;
    }
    unint64_t v7 = v1[((3 * v5) & 7) + 3];
    unint64_t v8 = v1[1];
    uint64_t v9 = (*(void *)(v8 + 24) - 1) & (v5 >> 3);
    uint64_t v10 = v7 + v1[2] + *(void *)(v8 + 32) * v9;
    unint64_t v11 = *(void *)(v7 + 8);
    this[1] = (unint64_t *)v10;
    if ((v11 >> v9)) {
      return this;
    }
  }
  this[1] = 0;
  return this;
}

unint64_t **tbb::internal::concurrent_queue_iterator_base_v3::concurrent_queue_iterator_base_v3(unint64_t **this, const tbb::internal::concurrent_queue_base_v3 *a2, uint64_t a3, void *a4)
{
  return this;
}

{
  tbb::internal::concurrent_queue_iterator_base_v3::initialize(this, a2, 0, a4);
  return this;
}

unint64_t **tbb::internal::concurrent_queue_iterator_base_v3::concurrent_queue_iterator_base_v3(unint64_t **this, const tbb::internal::concurrent_queue_base_v3 *a2, unint64_t a3, void *a4)
{
  return this;
}

{
  tbb::internal::concurrent_queue_iterator_base_v3::initialize(this, a2, a3, a4);
  return this;
}

uint64_t tbb::internal::concurrent_queue_iterator_base_v3::assign(tbb::internal::concurrent_queue_iterator_base_v3 *this, const tbb::internal::concurrent_queue_iterator_base_v3 *a2, uint64_t a3, void *a4)
{
  uint64_t result = *(void *)this;
  uint64_t v7 = *(void *)a2;
  if (result != *(void *)a2)
  {
    if (result)
    {
      uint64_t result = tbb::internal::NFS_Free((tbb::internal *)result, a2);
      *(void *)this = 0;
      uint64_t v7 = *(void *)a2;
    }
    if (v7)
    {
      uint64_t result = tbb::internal::NFS_Allocate(1uLL, 88, 0, a4);
      *(void *)this = result;
      uint64_t v8 = *(void *)a2;
      long long v9 = *(_OWORD *)(*(void *)a2 + 16);
      *(_OWORD *)uint64_t result = *(_OWORD *)*(void *)a2;
      *(_OWORD *)(result + 16) = v9;
      long long v10 = *(_OWORD *)(v8 + 32);
      long long v11 = *(_OWORD *)(v8 + 48);
      long long v12 = *(_OWORD *)(v8 + 64);
      *(void *)(result + 80) = *(void *)(v8 + 80);
      *(_OWORD *)(result + 48) = v11;
      *(_OWORD *)(result + 64) = v12;
      *(_OWORD *)(result + 32) = v10;
    }
  }
  *((void *)this + 1) = *((void *)a2 + 1);
  return result;
}

void tbb::internal::concurrent_queue_iterator_base_v3::~concurrent_queue_iterator_base_v3(tbb::internal **this, void *a2)
{
  *this = 0;
}

{
  tbb::internal::NFS_Free(*this, a2);
  *this = 0;
}

uint64_t *sub_21675F22C(uint64_t *a1)
{
  unint64_t v2 = (uint64_t *)a1[2];
  if (v2)
  {
    uint64_t v3 = a1[1] + 32;
    uint64_t v4 = (atomic_uint *)(v3 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_3:
    int v5 = *v4 & ~(255 << (8 * (v3 & 3)));
    while (1)
    {
      int v6 = v5;
      atomic_compare_exchange_strong(v4, (unsigned int *)&v6, v5 | (1 << (8 * (v3 & 3))));
      if (v6 == v5) {
        break;
      }
      if (*v4 != v5)
      {
        sched_yield();
        goto LABEL_3;
      }
    }
    uint64_t v7 = *v2;
    uint64_t v8 = (void *)a1[1];
    __dmb(0xBu);
    *uint64_t v8 = v7;
    if (!v7)
    {
      uint64_t v9 = a1[1];
      __dmb(0xBu);
      *(void *)(v9 + 16) = 0;
    }
    __dmb(0xBu);
    *(unsigned char *)uint64_t v3 = 0;
    uint64_t v10 = *a1;
    uint64_t v11 = a1[1];
    __dmb(0xBu);
    *(void *)(v11 + 8) = v10;
    (*(void (**)(uint64_t, uint64_t *))(*(void *)a1[3] + 40))(a1[3], v2);
  }
  else
  {
    uint64_t v12 = *a1;
    uint64_t v13 = a1[1];
    __dmb(0xBu);
    *(void *)(v13 + 8) = v12;
  }
  return a1;
}

uint64_t sub_21675F334(uint64_t result, void *a2)
{
  if (*(void *)(result + 8))
  {
    uint64_t v3 = result;
    unint64_t v16 = &v16;
    unint64_t v17 = &v16;
    uint64_t v15 = 0;
    uint64_t v4 = (unsigned char *)(result + 1);
    int v5 = (atomic_uint *)((result + 1) & 0xFFFFFFFFFFFFFFFCLL);
    int v6 = 1 << (8 * ((result + 1) & 3));
    int v7 = ~(255 << (8 * ((result + 1) & 3)));
LABEL_3:
    int v8 = *v5 & v7;
    while (1)
    {
      int v9 = v8;
      atomic_compare_exchange_strong(v5, (unsigned int *)&v9, v8 | v6);
      if (v9 == v8) {
        break;
      }
      if (*v5 != v8)
      {
        uint64_t result = sched_yield();
        goto LABEL_3;
      }
    }
    ++*(_DWORD *)(v3 + 32);
    uint64_t v10 = *(void **)(v3 + 24);
    if (v10 != (void *)(v3 + 16))
    {
      do
      {
        uint64_t v13 = (void *)v10[1];
        if (*a2 >= v10[4])
        {
          --*(void *)(v3 + 8);
          *uint64_t v13 = *v10;
          *(void *)(*v10 + 8) = v13;
          __dmb(0xBu);
          *((unsigned char *)v10 + 24) = 0;
          ++v15;
          unint64_t v14 = v17;
          *uint64_t v10 = &v16;
          v10[1] = v14;
          void *v17 = v10;
          unint64_t v17 = v10;
        }
        uint64_t v10 = v13;
      }
      while (v13 != (void *)(v3 + 16));
    }
    __dmb(0xBu);
    unsigned char *v4 = 0;
    uint64_t v11 = v16;
    if (v16 != &v16)
    {
      do
      {
        uint64_t v12 = (void *)*v11;
        uint64_t result = MEMORY[0x21D448AF0](*((unsigned int *)v11 + 4));
        uint64_t v11 = v12;
      }
      while (v12 != &v16);
    }
  }
  return result;
}

unint64_t tbb::internal::concurrent_vector_base_v3::helper::extend_segment_table(unint64_t this, tbb::internal::concurrent_vector_base_v3 *a2, unint64_t a3, void *a4)
{
  uint64_t v4 = (atomic_ullong *)this;
  if ((unint64_t)a2 >= 8) {
    unint64_t v5 = 8;
  }
  else {
    unint64_t v5 = (unint64_t)a2;
  }
  if (v5)
  {
    uint64_t v6 = 0;
    unint64_t v7 = this + 32;
    do
    {
      atomic_ullong v8 = v4[3];
      __dmb(0xBu);
      if (v7 != v8) {
        break;
      }
      int v9 = &v4[v6];
      atomic_ullong v11 = v9[4];
      uint64_t v10 = v9 + 4;
      if (!v11)
      {
        do
        {
          this = sched_yield();
          atomic_ullong v12 = v4[3];
          __dmb(0xBu);
        }
        while (v7 == v12 && !*v10);
      }
      ++v6;
    }
    while (((1 << v6) & 0xFFFFFFFFFFFFFFFELL) < v5);
  }
  uint64_t v13 = (atomic_ullong *)v4[3];
  __dmb(0xBu);
  unint64_t v14 = v4 + 4;
  if (v4 + 4 == v13)
  {
    this = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
    for (uint64_t i = 0; i != 512; i += 8)
      *(void *)(this + i) = 0;
    *(void *)this = v4[4];
    *(void *)(this + 8) = v4[5];
    *(void *)(this + 16) = v4[6];
    while (1)
    {
      unint64_t v17 = v4 + 4;
      atomic_compare_exchange_strong(v4 + 3, (unint64_t *)&v17, this);
      if (v17 == v14) {
        break;
      }
      if ((atomic_ullong *)atomic_fetch_add_explicit(v4 + 3, 0, memory_order_relaxed) != v14)
      {
        return tbb::internal::NFS_Free((tbb::internal *)this, v15);
      }
    }
  }
  return this;
}

uint64_t tbb::internal::concurrent_vector_base_v3::helper::enable_segment(tbb::internal::concurrent_vector_base_v3::helper *this, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = (unint64_t *)*((void *)this + 3);
  __dmb(0xBu);
  uint64_t v7 = 1 << a2;
  uint64_t v8 = *((void *)this + 1);
  __dmb(0xBu);
  if (!a2)
  {
    if (!v8)
    {
      do
      {
        uint64_t v12 = 0;
        atomic_compare_exchange_strong((atomic_ullong *volatile)this + 1, (unint64_t *)&v12, 1uLL);
      }
      while (v12 && !atomic_fetch_add_explicit((atomic_ullong *volatile)this + 1, 0, memory_order_relaxed));
    }
    uint64_t v13 = *((void *)this + 1);
    __dmb(0xBu);
    uint64_t v9 = 1 << v13;
    uint64_t v10 = 2;
    goto LABEL_20;
  }
  if (v8)
  {
    uint64_t v9 = 1 << a2;
    uint64_t v10 = v7;
  }
  else
  {
    do
    {
      sched_yield();
      uint64_t v11 = *((void *)this + 1);
      __dmb(0xBu);
    }
    while (!v11);
    uint64_t v10 = v7;
    uint64_t v9 = v7;
    if (!a2) {
      goto LABEL_20;
    }
  }
  unint64_t v14 = *((void *)this + 1);
  __dmb(0xBu);
  if (v14 > a2)
  {
    unint64_t v15 = *v6;
    __dmb(0xBu);
    if (!v15)
    {
      while (!*v6)
        sched_yield();
      unint64_t v15 = *v6;
      __dmb(0xBu);
    }
    unint64_t v16 = (uint64_t *)&v6[a2];
    if (v15 <= 0x3F) {
      tbb::internal::throw_exception_v4(2);
    }
    uint64_t v17 = v15 + (v7 & 0xFFFFFFFFFFFFFFFELL) * a3;
    goto LABEL_22;
  }
LABEL_20:
  unint64_t v16 = (uint64_t *)&v6[a2];
  uint64_t v17 = (*(uint64_t (**)(tbb::internal::concurrent_vector_base_v3::helper *, uint64_t))this)(this, v9);
  if (!v17) {
    tbb::internal::throw_exception_v4(1);
  }
LABEL_22:
  __dmb(0xBu);
  *unint64_t v16 = v17;
  return v10;
}

void sub_21675F73C(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *uint64_t v1 = 63;
  _Unwind_Resume(a1);
}

void tbb::internal::concurrent_vector_base_v3::helper::cleanup(tbb::internal::concurrent_vector_base_v3::helper *this)
{
  unint64_t v2 = *((void *)this + 3);
  if (v2) {
    goto LABEL_61;
  }
  unint64_t v3 = *((void *)this + 2);
  unint64_t v4 = *((void *)this + 5) - 1;
  uint64_t v5 = v4 | 1;
  unint64_t v6 = HIDWORD(v4);
  BOOL v7 = v6 != 0;
  if (!v6) {
    unint64_t v6 = v5;
  }
  uint64_t v8 = 32 * v7;
  if (v6 >= 0x10000)
  {
    v6 >>= 16;
    uint64_t v8 = (32 * v7) | 0x10;
  }
  if (v6 >= 0x100)
  {
    v6 >>= 8;
    v8 |= 8uLL;
  }
  if (v6 >= 0x10)
  {
    v6 >>= 4;
    v8 |= 4uLL;
  }
  if (v6 < 4)
  {
    uint64_t v9 = v8;
  }
  else
  {
    v6 >>= 2;
    uint64_t v9 = v8 + 2;
  }
  uint64_t v10 = (v6 >> 1) & 1;
  if (((1 << v3) & 0xFFFFFFFFFFFFFFFELL) < *((void *)this + 4))
  {
    uint64_t v11 = *(void *)this;
    uint64_t v12 = *(void *)(*(void *)this + 8 * v3);
    __dmb(0xBu);
    if (!v12)
    {
      while (!*(void *)(v11 + 8 * v3))
        sched_yield();
    }
    ++v3;
  }
  unint64_t v13 = v10 + v9;
  unint64_t v14 = *((void *)this + 1);
  if (v3 < v14)
  {
    unint64_t v15 = *(unint64_t **)this;
    if (*((void *)this + 4))
    {
      unint64_t v16 = *v15;
      __dmb(0xBu);
      if (!v16)
      {
        while (!*v15)
          sched_yield();
      }
    }
    unint64_t v17 = *v15;
    if (v3) {
      BOOL v18 = 1;
    }
    else {
      BOOL v18 = v17 == 0;
    }
    if (!v18) {
      ++v3;
    }
    unint64_t v14 = *((void *)this + 1);
    BOOL v20 = v3 < v14 && v3 <= v13;
    if (v17 <= 0x3F)
    {
      if (v20)
      {
        do
        {
          unint64_t v25 = v3;
          uint64_t v26 = *(void *)this;
          __dmb(0xBu);
          *(void *)(v26 + 8 * v3++) = 63;
          unint64_t v14 = *((void *)this + 1);
        }
        while (v3 < v14 && v25 < v13);
      }
    }
    else if (v20)
    {
      do
      {
        unint64_t v21 = v3;
        uint64_t v22 = *(void *)this;
        unint64_t v23 = v17 + *((void *)this + 6) * ((1 << v3) & 0xFFFFFFFFFFFFFFFELL);
        __dmb(0xBu);
        *(void *)(v22 + 8 * v3++) = v23;
        unint64_t v14 = *((void *)this + 1);
      }
      while (v3 < v14 && v21 < v13);
    }
  }
  if (v3 <= v13)
  {
    do
    {
      uint64_t v28 = *(void *)(*(void *)this + 8 * v3);
      __dmb(0xBu);
      if (!v28)
      {
        uint64_t v29 = *(void *)this;
        __dmb(0xBu);
        *(void *)(v29 + 8 * v3) = 63;
      }
      ++v3;
    }
    while (v3 <= v13);
    unint64_t v14 = *((void *)this + 1);
  }
  unint64_t v30 = *((void *)this + 2);
  if (v30 < v14)
  {
    unint64_t v30 = 0;
    *((void *)this + 2) = 0;
  }
  unint64_t v31 = (1 << v30) & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v32 = *((void *)this + 5) - v31;
  unint64_t v33 = *((void *)this + 4) - v31;
  unint64_t v2 = 1 << v14;
  if (v30) {
    unint64_t v2 = (1 << v30) & 0xFFFFFFFFFFFFFFFELL;
  }
  *((void *)this + 4) = v33;
  *((void *)this + 5) = v32;
  *((void *)this + 3) = v2;
  while (1)
  {
    unint64_t v36 = *(void *)(*(void *)this + 8 * v30);
    if (v36 >= 0x40)
    {
      if (v2 >= v32) {
        unint64_t v2 = v32;
      }
      bzero((void *)(v36 + v33 * *((void *)this + 6)), (v2 - v33) * *((void *)this + 6));
      unint64_t v2 = *((void *)this + 3);
    }
LABEL_61:
    unint64_t v34 = *((void *)this + 5);
    unint64_t v32 = v34 - v2;
    if (v34 < v2) {
      break;
    }
    *((void *)this + 4) = 0;
    *((void *)this + 5) = v32;
    uint64_t v35 = *((void *)this + 2);
    if (v35)
    {
      unint64_t v30 = v35 + 1;
      unint64_t v2 = 1 << v30;
      *((void *)this + 3) = 1 << v30;
    }
    else
    {
      unint64_t v30 = *((void *)this + 1);
    }
    unint64_t v33 = 0;
    *((void *)this + 2) = v30;
  }
}

void tbb::internal::concurrent_vector_base_v3::~concurrent_vector_base_v3(tbb::internal::concurrent_vector_base_v3 *this, void *a2)
{
  unint64_t v3 = (tbb::internal *)*((void *)this + 3);
  __dmb(0xBu);
  if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) != v3)
  {
    __dmb(0xBu);
    *((void *)this + 3) = (char *)this + 32;
    tbb::internal::NFS_Free(v3, a2);
  }
}

{
  tbb::internal *v3;

  unint64_t v3 = (tbb::internal *)*((void *)this + 3);
  __dmb(0xBu);
  if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) != v3)
  {
    __dmb(0xBu);
    *((void *)this + 3) = (char *)this + 32;
    tbb::internal::NFS_Free(v3, a2);
  }
}

unint64_t tbb::internal::concurrent_vector_base_v3::internal_capacity(tbb::internal::concurrent_vector_base_v3 *this)
{
  uint64_t v1 = 0;
  unint64_t v2 = (tbb::internal::concurrent_vector_base_v3 *)*((void *)this + 3);
  __dmb(0xBu);
  uint64_t v3 = 64;
  if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v2) {
    uint64_t v3 = 3;
  }
  while (*((void *)v2 + v1) >= 0x40uLL)
  {
    if (v3 == ++v1)
    {
      LOBYTE(v1) = v3;
      return (1 << v1) & 0xFFFFFFFFFFFFFFFELL;
    }
  }
  return (1 << v1) & 0xFFFFFFFFFFFFFFFELL;
}

uint64_t tbb::internal::concurrent_vector_base_v3::internal_throw_exception(tbb::internal::concurrent_vector_base_v3 *this, uint64_t a2)
{
  return tbb::internal::throw_exception_v4(dword_217405B1C[a2]);
}

atomic_ullong *tbb::internal::concurrent_vector_base_v3::internal_reserve(atomic_ullong *this, unint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v6 = this;
  if (a2 > (unint64_t)a4) {
    this = (atomic_ullong *)tbb::internal::throw_exception_v4(16);
  }
  atomic_ullong v7 = v6[1];
  __dmb(0xBu);
  if (!v7)
  {
    unint64_t v8 = (a2 - 1) >> 32;
    BOOL v9 = v8 != 0;
    if (!v8) {
      unint64_t v8 = (a2 - 1) | 1;
    }
    if (v8 < 0x10000)
    {
      uint64_t v10 = 32 * v9;
    }
    else
    {
      v8 >>= 16;
      uint64_t v10 = (32 * v9) | 0x10;
    }
    if (v8 >= 0x100)
    {
      v8 >>= 8;
      v10 |= 8uLL;
    }
    if (v8 >= 0x10)
    {
      v8 >>= 4;
      v10 |= 4uLL;
    }
    BOOL v11 = v8 >= 4;
    if (v8 >= 4) {
      v8 >>= 2;
    }
    uint64_t v12 = (v8 >> 1) & 1;
    uint64_t v13 = v10 + 2;
    if (!v11) {
      uint64_t v13 = v10;
    }
    unint64_t v14 = v13 + v12 + 1;
    do
    {
      uint64_t v15 = 0;
      atomic_compare_exchange_strong(v6 + 1, (unint64_t *)&v15, v14);
    }
    while (v15 && !atomic_fetch_add_explicit(v6 + 1, 0, memory_order_relaxed));
  }
  unint64_t v16 = 0;
  unint64_t v17 = (atomic_ullong *)v6[3];
  __dmb(0xBu);
  BOOL v18 = v6 + 4;
  uint64_t v19 = 64;
  if (v6 + 4 == v17) {
    uint64_t v19 = 3;
  }
  while ((unint64_t)v17[v16] >= 0x40)
  {
    if (v19 == ++v16)
    {
      unint64_t v16 = v19;
      break;
    }
  }
  while (((1 << v16) & 0xFFFFFFFFFFFFFFFELL) < a2)
  {
    if (v16 >= 3)
    {
      atomic_ullong v20 = v6[3];
      __dmb(0xBu);
      if (v18 == (atomic_ullong *)v20)
      {
        atomic_ullong v21 = v6[3];
        __dmb(0xBu);
        if (v18 == (atomic_ullong *)v21)
        {
          this = (atomic_ullong *)tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          for (uint64_t i = 0; i != 64; ++i)
            this[i] = 0;
          *this = v6[4];
          this[1] = v6[5];
          this[2] = v6[6];
          while (1)
          {
            uint64_t v24 = v6 + 4;
            atomic_compare_exchange_strong(v6 + 3, (unint64_t *)&v24, (unint64_t)this);
            if (v24 == v18) {
              break;
            }
            if ((atomic_ullong *)atomic_fetch_add_explicit(v6 + 3, 0, memory_order_relaxed) != v18)
            {
              this = (atomic_ullong *)tbb::internal::NFS_Free((tbb::internal *)this, v22);
              break;
            }
          }
        }
      }
    }
    atomic_ullong v25 = v6[3];
    __dmb(0xBu);
    if (*(void *)(v25 + 8 * v16) <= 0x3FuLL) {
      this = (atomic_ullong *)tbb::internal::concurrent_vector_base_v3::helper::enable_segment((tbb::internal::concurrent_vector_base_v3::helper *)v6, v16, a3);
    }
    ++v16;
  }
  return this;
}

atomic_ullong *tbb::internal::concurrent_vector_base_v3::internal_copy(atomic_ullong *this, const tbb::internal::concurrent_vector_base_v3 *a2, uint64_t a3, void (*a4)(void *, const void *, unint64_t))
{
  unint64_t v4 = *((void *)a2 + 2);
  __dmb(0xBu);
  if (v4)
  {
    unint64_t v8 = this;
    atomic_ullong v9 = this[1];
    __dmb(0xBu);
    if (!v9)
    {
      unint64_t v10 = (v4 - 1) >> 32;
      BOOL v11 = v10 != 0;
      if (!v10) {
        unint64_t v10 = (v4 - 1) | 1;
      }
      if (v10 < 0x10000)
      {
        uint64_t v12 = 32 * v11;
      }
      else
      {
        v10 >>= 16;
        uint64_t v12 = (32 * v11) | 0x10;
      }
      if (v10 >= 0x100)
      {
        v10 >>= 8;
        v12 |= 8uLL;
      }
      if (v10 >= 0x10)
      {
        v10 >>= 4;
        v12 |= 4uLL;
      }
      BOOL v13 = v10 >= 4;
      if (v10 >= 4) {
        v10 >>= 2;
      }
      uint64_t v14 = (v10 >> 1) & 1;
      uint64_t v15 = v12 + 2;
      if (!v13) {
        uint64_t v15 = v12;
      }
      unint64_t v16 = v15 + v14 + 1;
      do
      {
        uint64_t v17 = 0;
        atomic_compare_exchange_strong(this + 1, (unint64_t *)&v17, v16);
      }
      while (v17 && !atomic_fetch_add_explicit(this + 1, 0, memory_order_relaxed));
    }
    unint64_t v18 = 0;
    unint64_t v19 = 0;
    atomic_ullong v20 = (char *)a2 + 32;
    atomic_ullong v21 = this + 4;
    while (1)
    {
      unint64_t v27 = (char *)*((void *)a2 + 3);
      __dmb(0xBu);
      if (v19 >= 3 && v20 == v27) {
        break;
      }
      uint64_t v28 = *((void *)a2 + 3);
      __dmb(0xBu);
      if (*(void *)(v28 + 8 * v19) <= 0x3FuLL) {
        break;
      }
      if (v19 >= 3)
      {
        atomic_ullong v29 = v8[3];
        __dmb(0xBu);
        if (v21 == (void *)v29)
        {
          atomic_ullong v30 = v8[3];
          __dmb(0xBu);
          if (v21 == (void *)v30)
          {
            unint64_t v31 = (tbb::internal *)tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
            for (uint64_t i = 0; i != 512; i += 8)
              *(void *)((char *)v31 + i) = 0;
            *(void *)unint64_t v31 = v8[4];
            *((void *)v31 + 1) = v8[5];
            *((void *)v31 + 2) = v8[6];
            while (1)
            {
              unint64_t v34 = v8 + 4;
              atomic_compare_exchange_strong(v8 + 3, (unint64_t *)&v34, (unint64_t)v31);
              if (v34 == v21) {
                break;
              }
              if ((void *)atomic_fetch_add_explicit(v8 + 3, 0, memory_order_relaxed) != v21)
              {
                tbb::internal::NFS_Free(v31, v32);
                break;
              }
            }
          }
        }
      }
      unint64_t v22 = tbb::internal::concurrent_vector_base_v3::helper::enable_segment((tbb::internal::concurrent_vector_base_v3::helper *)v8, v19, a3);
      if (v22 >= v4 - v18) {
        unint64_t v23 = v4 - v18;
      }
      else {
        unint64_t v23 = v22;
      }
      __dmb(0xBu);
      v8[2] = v23 + v18;
      atomic_ullong v24 = v8[3];
      __dmb(0xBu);
      uint64_t v25 = *(void *)(v24 + 8 * v19);
      uint64_t v26 = *((void *)a2 + 3);
      __dmb(0xBu);
      this = (atomic_ullong *)((uint64_t (*)(uint64_t, void))a4)(v25, *(void *)(v26 + 8 * v19++));
      unint64_t v18 = (1 << v19) & 0xFFFFFFFFFFFFFFFELL;
      if (v18 >= v4) {
        return this;
      }
    }
    __dmb(0xBu);
    v8[2] = v18;
  }
  return this;
}

atomic_ullong *tbb::internal::concurrent_vector_base_v3::internal_assign(atomic_ullong *this, const tbb::internal::concurrent_vector_base_v3 *a2, uint64_t a3, uint64_t (*a4)(unint64_t, unint64_t), void (*a5)(void *, const void *, unint64_t), uint64_t (*a6)(uint64_t, uint64_t, unint64_t))
{
  unint64_t v8 = this;
  unint64_t v9 = *((void *)a2 + 2);
  __dmb(0xBu);
  unint64_t v10 = this[2];
  __dmb(0xBu);
  if (v10 > v9)
  {
    do
    {
      unint64_t v16 = v8[2];
      __dmb(0xBu);
      uint64_t v17 = --v16 | 1;
      unint64_t v18 = HIDWORD(v16);
      BOOL v19 = v18 != 0;
      if (!v18) {
        unint64_t v18 = v17;
      }
      uint64_t v20 = 32 * v19;
      if (v18 >= 0x10000)
      {
        v18 >>= 16;
        uint64_t v20 = (32 * v19) | 0x10;
      }
      if (v18 >= 0x100)
      {
        v18 >>= 8;
        v20 |= 8uLL;
      }
      if (v18 >= 0x10)
      {
        v18 >>= 4;
        v20 |= 4uLL;
      }
      if (v18 >= 4)
      {
        v18 >>= 2;
        v20 += 2;
      }
      unint64_t v21 = ((v18 >> 1) & 1) + v20;
      unint64_t v22 = (1 << v21) & 0xFFFFFFFFFFFFFFFELL;
      if (v22 <= v9) {
        unint64_t v23 = v9;
      }
      else {
        unint64_t v23 = (1 << v21) & 0xFFFFFFFFFFFFFFFELL;
      }
      atomic_ullong v24 = v8[3];
      __dmb(0xBu);
      if (*(void *)(v24 + 8 * v21) <= 0x3FuLL) {
        tbb::internal::throw_exception_v4(2);
      }
      atomic_ullong v12 = v8[3];
      __dmb(0xBu);
      unint64_t v13 = *(void *)(v12 + 8 * v21) + (v23 - v22) * a3;
      atomic_ullong v14 = v8[2];
      __dmb(0xBu);
      this = (atomic_ullong *)a4(v13, v14 - v23);
      __dmb(0xBu);
      v8[2] = v23;
      unint64_t v15 = v8[2];
      __dmb(0xBu);
    }
    while (v15 > v9);
  }
  unint64_t v25 = v8[2];
  __dmb(0xBu);
  v8[2] = v9;
  atomic_ullong v26 = v8[1];
  __dmb(0xBu);
  if (!v26)
  {
    unint64_t v27 = v9 | 1;
    if (HIDWORD(v9)) {
      unint64_t v27 = HIDWORD(v9);
    }
    if (v27 < 0x10000)
    {
      uint64_t v28 = 32 * (HIDWORD(v9) != 0);
    }
    else
    {
      v27 >>= 16;
      uint64_t v28 = (32 * (HIDWORD(v9) != 0)) | 0x10;
    }
    if (v27 >= 0x100)
    {
      v27 >>= 8;
      v28 |= 8uLL;
    }
    if (v27 >= 0x10)
    {
      v27 >>= 4;
      v28 |= 4uLL;
    }
    BOOL v29 = v27 >= 4;
    if (v27 >= 4) {
      v27 >>= 2;
    }
    uint64_t v30 = (v27 >> 1) & 1;
    uint64_t v31 = v28 + 2;
    if (!v29) {
      uint64_t v31 = v28;
    }
    unint64_t v32 = v31 + v30 + 1;
    do
    {
      uint64_t v33 = 0;
      atomic_compare_exchange_strong(v8 + 1, (unint64_t *)&v33, v32);
    }
    while (v33 && !atomic_fetch_add_explicit(v8 + 1, 0, memory_order_relaxed));
  }
  if (v9)
  {
    unint64_t v34 = 0;
    unint64_t v35 = 0;
    unint64_t v36 = v8 + 4;
    uint64_t v37 = 1;
    while (1)
    {
      uint64_t v38 = (const tbb::internal::concurrent_vector_base_v3 *)*((void *)a2 + 3);
      __dmb(0xBu);
      if (v35 >= 3 && (const tbb::internal::concurrent_vector_base_v3 *)((char *)a2 + 32) == v38
        || (uint64_t v39 = *((void *)a2 + 3), __dmb(0xBu), *(void *)(v39 + 8 * v35) <= 0x3FuLL))
      {
        __dmb(0xBu);
        v8[2] = v34;
        return this;
      }
      if (v35 >= 3)
      {
        atomic_ullong v40 = v8[3];
        __dmb(0xBu);
        if (v36 == (atomic_ullong *)v40)
        {
          atomic_ullong v41 = v8[3];
          __dmb(0xBu);
          if (v36 == (atomic_ullong *)v41)
          {
            this = (atomic_ullong *)tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
            for (uint64_t i = 0; i != 64; ++i)
              this[i] = 0;
            *this = v8[4];
            this[1] = v8[5];
            this[2] = v8[6];
            while (1)
            {
              v44 = v8 + 4;
              atomic_compare_exchange_strong(v8 + 3, (unint64_t *)&v44, (unint64_t)this);
              if (v44 == v36) {
                break;
              }
              if ((atomic_ullong *)atomic_fetch_add_explicit(v8 + 3, 0, memory_order_relaxed) != v36)
              {
                this = (atomic_ullong *)tbb::internal::NFS_Free((tbb::internal *)this, v42);
                break;
              }
            }
          }
        }
      }
      atomic_ullong v45 = v8[3];
      __dmb(0xBu);
      if (*(void *)(v45 + 8 * v35))
      {
        atomic_ullong v46 = v8[3];
        __dmb(0xBu);
        if (*(void *)(v46 + 8 * v35) <= 0x3FuLL) {
          this = (atomic_ullong *)tbb::internal::throw_exception_v4(2);
        }
      }
      else
      {
        this = (atomic_ullong *)tbb::internal::concurrent_vector_base_v3::helper::enable_segment((tbb::internal::concurrent_vector_base_v3::helper *)v8, v35, a3);
      }
      unint64_t v47 = 2;
      if (v35) {
        unint64_t v47 = v37;
      }
      unint64_t v48 = v47 >= v9 - v34 ? v9 - v34 : v47;
      if (v25 > v34) {
        break;
      }
      uint64_t v53 = 0;
      if (v48) {
        goto LABEL_67;
      }
LABEL_38:
      uint64_t v37 = 1 << ++v35;
      unint64_t v34 = (1 << v35) & 0xFFFFFFFFFFFFFFFELL;
      if (v34 >= v9) {
        return this;
      }
    }
    if (v25 - v34 >= v48) {
      unint64_t v49 = v48;
    }
    else {
      unint64_t v49 = v25 - v34;
    }
    atomic_ullong v50 = v8[3];
    __dmb(0xBu);
    uint64_t v51 = *(void *)(v50 + 8 * v35);
    uint64_t v52 = *((void *)a2 + 3);
    __dmb(0xBu);
    this = (atomic_ullong *)((uint64_t (*)(uint64_t, void, unint64_t))a5)(v51, *(void *)(v52 + 8 * v35), v49);
    v48 -= v49;
    uint64_t v53 = v49 * a3;
    if (!v48) {
      goto LABEL_38;
    }
LABEL_67:
    atomic_ullong v54 = v8[3];
    __dmb(0xBu);
    uint64_t v55 = *(void *)(v54 + 8 * v35) + v53;
    uint64_t v56 = *((void *)a2 + 3);
    __dmb(0xBu);
    this = (atomic_ullong *)a6(v55, *(void *)(v56 + 8 * v35) + v53, v48);
    goto LABEL_38;
  }
  return this;
}

unint64_t tbb::internal::concurrent_vector_base_v3::internal_push_back(atomic_ullong *this, uint64_t a2, unint64_t *a3, void *a4)
{
  unint64_t add = atomic_fetch_add(this + 2, 1uLL);
  *a3 = add;
  unint64_t v7 = add | 1;
  if (HIDWORD(add)) {
    unint64_t v7 = HIDWORD(add);
  }
  uint64_t v8 = 32 * (HIDWORD(add) != 0);
  if (v7 >= 0x10000)
  {
    v7 >>= 16;
    uint64_t v8 = (32 * (HIDWORD(add) != 0)) | 0x10;
  }
  if (v7 >= 0x100)
  {
    v7 >>= 8;
    v8 |= 8uLL;
  }
  if (v7 >= 0x10)
  {
    v7 >>= 4;
    v8 |= 4uLL;
  }
  if (v7 >= 4)
  {
    v7 >>= 2;
    v8 += 2;
  }
  uint64_t v9 = (v7 >> 1) & 1;
  unint64_t v10 = v9 + v8;
  uint64_t v11 = 1 << (v9 + v8);
  if ((unint64_t)(v9 + v8) >= 3)
  {
    atomic_ullong v12 = (tbb::internal::concurrent_vector_base_v3 *)this[3];
    __dmb(0xBu);
    if (this + 4 == (atomic_ullong *)v12) {
      tbb::internal::concurrent_vector_base_v3::helper::extend_segment_table((unint64_t)this, (tbb::internal::concurrent_vector_base_v3 *)add, (unint64_t)a3, a4);
    }
  }
  unint64_t v13 = v11 & 0xFFFFFFFFFFFFFFFELL;
  atomic_ullong v14 = this[3];
  __dmb(0xBu);
  uint64_t v15 = *(void *)(v14 + 8 * v10);
  __dmb(0xBu);
  if (!v15)
  {
    if (add == v13)
    {
      tbb::internal::concurrent_vector_base_v3::helper::enable_segment((tbb::internal::concurrent_vector_base_v3::helper *)this, v10, a2);
    }
    else
    {
      while (!*(void *)(v14 + 8 * v10))
        sched_yield();
    }
  }
  if (*(void *)(v14 + 8 * v10) <= 0x3FuLL) {
    tbb::internal::throw_exception_v4(2);
  }
  return *(void *)(v14 + 8 * v10) + (add - v13) * a2;
}

unint64_t tbb::internal::concurrent_vector_base_v3::internal_grow_to_at_least_with_result(tbb::internal::concurrent_vector_base_v3 *this, unint64_t a2, void *a3, void (*a4)(void *, const void *, unint64_t), const void *a5)
{
  unint64_t v7 = (tbb::internal::concurrent_vector_base_v3 *)*((void *)this + 2);
  __dmb(0xBu);
  if ((unint64_t)v7 < a2)
  {
    while (1)
    {
      uint64_t v8 = v7;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 2, (unint64_t *)&v8, a2);
      if (v8 == v7) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)this + 2, 0, memory_order_relaxed);
      if ((tbb::internal::concurrent_vector_base_v3 *)add_explicit != v7)
      {
        unint64_t v7 = (tbb::internal::concurrent_vector_base_v3 *)add_explicit;
        if (add_explicit >= a2) {
          goto LABEL_8;
        }
      }
    }
    tbb::internal::concurrent_vector_base_v3::internal_grow(this, v7, a2, a3, a4, a5);
  }
  unint64_t add_explicit = (unint64_t)v7;
LABEL_8:
  unint64_t v10 = (a2 - 1) >> 32;
  BOOL v11 = v10 != 0;
  if (!v10) {
    unint64_t v10 = (a2 - 1) | 1;
  }
  uint64_t v12 = 32 * v11;
  if (v10 >= 0x10000)
  {
    v10 >>= 16;
    uint64_t v12 = (32 * v11) | 0x10;
  }
  if (v10 >= 0x100)
  {
    v10 >>= 8;
    v12 |= 8uLL;
  }
  if (v10 >= 0x10)
  {
    v10 >>= 4;
    v12 |= 4uLL;
  }
  if (v10 >= 4)
  {
    v10 >>= 2;
    v12 += 2;
  }
  unint64_t v13 = ((v10 >> 1) & 1) + v12;
  if (v13 >= 3)
  {
    atomic_ullong v14 = (tbb::internal::concurrent_vector_base_v3 *)*((void *)this + 3);
    __dmb(0xBu);
    if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v14)
    {
      while (1)
      {
        uint64_t v15 = (tbb::internal::concurrent_vector_base_v3 *)*((void *)this + 3);
        __dmb(0xBu);
        if (v14 != v15) {
          break;
        }
        sched_yield();
      }
    }
  }
  unint64_t v16 = 0;
  do
  {
    uint64_t v17 = *((void *)this + 3);
    __dmb(0xBu);
    if (!*(void *)(v17 + 8 * v16))
    {
      do
      {
        sched_yield();
        uint64_t v18 = *((void *)this + 3);
        __dmb(0xBu);
        uint64_t v19 = *(void *)(v18 + 8 * v16);
        __dmb(0xBu);
      }
      while (!v19);
    }
    uint64_t v20 = *((void *)this + 3);
    __dmb(0xBu);
    if (*(void *)(v20 + 8 * v16) <= 0x3FuLL) {
      tbb::internal::throw_exception_v4(2);
    }
    ++v16;
  }
  while (v16 <= v13);
  return add_explicit;
}

void tbb::internal::concurrent_vector_base_v3::internal_grow(tbb::internal::concurrent_vector_base_v3 *this, tbb::internal::concurrent_vector_base_v3 *a2, unint64_t a3, void *a4, void (*a5)(void *, const void *, unint64_t), const void *a6)
{
  unint64_t v12 = (unint64_t)a2 | 1;
  if ((unint64_t)a2 >> 32) {
    unint64_t v12 = (unint64_t)a2 >> 32;
  }
  uint64_t v13 = 32 * ((unint64_t)a2 >> 32 != 0);
  if (v12 >= 0x10000)
  {
    v12 >>= 16;
    uint64_t v13 = (32 * ((unint64_t)a2 >> 32 != 0)) | 0x10;
  }
  if (v12 >= 0x100)
  {
    v12 >>= 8;
    v13 |= 8uLL;
  }
  if (v12 >= 0x10)
  {
    v12 >>= 4;
    v13 |= 4uLL;
  }
  if (v12 >= 4)
  {
    v12 >>= 2;
    v13 += 2;
  }
  unint64_t v14 = ((v12 >> 1) & 1) + v13;
  unint64_t v15 = (a3 - 1) >> 32;
  BOOL v16 = v15 != 0;
  if (!v15) {
    unint64_t v15 = (a3 - 1) | 1;
  }
  uint64_t v17 = 32 * v16;
  if (v15 >= 0x10000)
  {
    v15 >>= 16;
    uint64_t v17 = (32 * v16) | 0x10;
  }
  if (v15 >= 0x100)
  {
    v15 >>= 8;
    v17 |= 8uLL;
  }
  if (v15 >= 0x10)
  {
    v15 >>= 4;
    v17 |= 4uLL;
  }
  if (v15 >= 4)
  {
    v15 >>= 2;
    v17 += 2;
  }
  unint64_t v18 = ((v15 >> 1) & 1) + v17;
  uint64_t v19 = *((void *)this + 1);
  __dmb(0xBu);
  if (!v19)
  {
    do
    {
      uint64_t v20 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 1, (unint64_t *)&v20, v18 + 1);
    }
    while (v20 && !atomic_fetch_add_explicit((atomic_ullong *volatile)this + 1, 0, memory_order_relaxed));
  }
  if (v18 >= 3)
  {
    unint64_t v21 = (tbb::internal::concurrent_vector_base_v3 *)*((void *)this + 3);
    __dmb(0xBu);
    if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v21) {
      tbb::internal::concurrent_vector_base_v3::helper::extend_segment_table((unint64_t)this, a2, a3, a4);
    }
  }
  uint64_t v22 = *((void *)this + 3);
  __dmb(0xBu);
  unint64_t v23 = *((void *)this + 1);
  __dmb(0xBu);
  uint64_t v35 = v22;
  unint64_t v36 = v23;
  unint64_t v37 = v14;
  unint64_t v38 = 0;
  uint64_t v39 = a2;
  unint64_t v40 = a3;
  atomic_ullong v41 = a4;
  while (v18 > v14 && v18 >= v23)
  {
    uint64_t v24 = *((void *)this + 3);
    __dmb(0xBu);
    uint64_t v25 = *(void *)(v24 + 8 * v18);
    __dmb(0xBu);
    if (!v25) {
      tbb::internal::concurrent_vector_base_v3::helper::enable_segment(this, v18, (uint64_t)a4);
    }
    if (*(void *)(v24 + 8 * v18) <= 0x3FuLL) {
      tbb::internal::throw_exception_v4(2);
    }
    --v18;
    unint64_t v23 = v36;
  }
  if (v14 <= v18)
  {
    do
    {
      uint64_t v26 = *((void *)this + 3);
      __dmb(0xBu);
      uint64_t v27 = *(void *)(v26 + 8 * v14);
      __dmb(0xBu);
      if (!v27)
      {
        if (((1 << v14) & 0xFFFFFFFFFFFFFFFELL) >= (unint64_t)a2)
        {
          tbb::internal::concurrent_vector_base_v3::helper::enable_segment(this, v14, (uint64_t)a4);
        }
        else
        {
          while (!*(void *)(v26 + 8 * v14))
            sched_yield();
        }
      }
      if (*(void *)(v26 + 8 * v14) <= 0x3FuLL) {
        tbb::internal::throw_exception_v4(2);
      }
      ++v14;
    }
    while (v14 <= v18);
    unint64_t v23 = v36;
  }
  unint64_t v28 = v37;
  if (v37 < v23)
  {
    unint64_t v28 = 0;
    unint64_t v37 = 0;
  }
  unint64_t v29 = (1 << v28) & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v30 = v40 - v29;
  uint64_t v31 = (char *)v39 - v29;
  if (v28) {
    unint64_t v32 = (1 << v28) & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t v32 = 1 << v23;
  }
  uint64_t v39 = (tbb::internal::concurrent_vector_base_v3 *)((char *)v39 - v29);
  v40 -= v29;
  unint64_t v38 = v32;
  unint64_t v33 = v30 - v32;
  if (v30 <= v32)
  {
    unint64_t v33 = v30;
  }
  else
  {
    a5((void *)(*(void *)(v35 + 8 * v28) + (void)v41 * (void)v31), a6, v32 - (void)v31);
    uint64_t v39 = 0;
    unint64_t v40 = v33;
    unint64_t v34 = v23;
    if (v28)
    {
      unint64_t v34 = v28 + 1;
      unint64_t v32 = 1 << (v28 + 1);
      unint64_t v38 = v32;
    }
    unint64_t v37 = v34;
    if (v32 >= v33)
    {
      uint64_t v31 = 0;
      unint64_t v28 = v34;
    }
    else
    {
      do
      {
        a5(*(void **)(v35 + 8 * v34), a6, v32);
        v33 -= v32;
        uint64_t v39 = 0;
        unint64_t v40 = v33;
        unint64_t v28 = v23;
        if (v34)
        {
          unint64_t v28 = v34 + 1;
          unint64_t v32 = 1 << (v34 + 1);
          unint64_t v38 = v32;
        }
        unint64_t v37 = v28;
        unint64_t v34 = v28;
      }
      while (v32 < v33);
      uint64_t v31 = 0;
    }
  }
  a5((void *)(*(void *)(v35 + 8 * v28) + (void)v41 * (void)v31), a6, v33 - (void)v31);
  if (v32 < v33) {
    tbb::internal::concurrent_vector_base_v3::helper::cleanup((tbb::internal::concurrent_vector_base_v3::helper *)&v35);
  }
}

void sub_216760A24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216760A8C((tbb::internal::concurrent_vector_base_v3::helper *)va);
  _Unwind_Resume(a1);
}

tbb::internal::concurrent_vector_base_v3 *tbb::internal::concurrent_vector_base_v3::internal_grow_by(atomic_ullong *this, unint64_t a2, void *a3, void (*a4)(void *, const void *, unint64_t), const void *a5)
{
  unint64_t add = (tbb::internal::concurrent_vector_base_v3 *)atomic_fetch_add(this + 2, a2);
  tbb::internal::concurrent_vector_base_v3::internal_grow((tbb::internal::concurrent_vector_base_v3 *)this, add, (unint64_t)add + a2, a3, a4, a5);
  return add;
}

tbb::internal::concurrent_vector_base_v3::helper *sub_216760A8C(tbb::internal::concurrent_vector_base_v3::helper *this)
{
  if (*((void *)this + 3) < *((void *)this + 5)) {
    tbb::internal::concurrent_vector_base_v3::helper::cleanup(this);
  }
  return this;
}

void tbb::internal::concurrent_vector_base_v3::internal_resize(tbb::internal::concurrent_vector_base_v3 *this, unint64_t a2, uint64_t a3, void *a4, const void *a5, void (*a6)(void *, unint64_t), void (*a7)(void *, const void *, unint64_t))
{
  uint64_t v7 = a3;
  unint64_t v10 = *((void *)this + 2);
  __dmb(0xBu);
  if (v10 >= a2)
  {
    __dmb(0xBu);
    *((void *)this + 2) = a2;
    uint64_t v27 = *((void *)this + 3);
    __dmb(0xBu);
    unint64_t v28 = *((void *)this + 1);
    __dmb(0xBu);
    unint64_t v29 = a2 | 1;
    if (HIDWORD(a2)) {
      unint64_t v29 = HIDWORD(a2);
    }
    uint64_t v30 = 32 * (HIDWORD(a2) != 0);
    if (v29 >= 0x10000)
    {
      v29 >>= 16;
      uint64_t v30 = (32 * (HIDWORD(a2) != 0)) | 0x10;
    }
    if (v29 >= 0x100)
    {
      v29 >>= 8;
      v30 |= 8uLL;
    }
    if (v29 >= 0x10)
    {
      v29 >>= 4;
      v30 |= 4uLL;
    }
    if (v29 >= 4)
    {
      v29 >>= 2;
      v30 += 2;
    }
    uint64_t v40 = v27;
    unint64_t v41 = v28;
    unint64_t v31 = ((v29 >> 1) & 1) + v30;
    unint64_t v42 = v31;
    uint64_t v46 = a3;
    if (v31 < v28)
    {
      unint64_t v31 = 0;
      unint64_t v42 = 0;
    }
    unint64_t v32 = (1 << v31) & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v33 = v10 - v32;
    unint64_t v34 = a2 - v32;
    if (v31) {
      unint64_t v35 = (1 << v31) & 0xFFFFFFFFFFFFFFFELL;
    }
    else {
      unint64_t v35 = 1 << v28;
    }
    unint64_t v44 = a2 - v32;
    unint64_t v45 = v10 - v32;
    uint64_t v43 = v35;
    unint64_t v36 = v33 - v35;
    if (v33 <= v35)
    {
      unint64_t v36 = v10 - v32;
    }
    else
    {
      if (*(void *)(v27 + 8 * v31) >= 0x40uLL) {
        a6((void *)(*(void *)(v27 + 8 * v31) + v34 * a3), v35 - v34);
      }
      unint64_t v44 = 0;
      unint64_t v45 = v36;
      unint64_t v37 = v28;
      if (v31)
      {
        unint64_t v37 = v31 + 1;
        unint64_t v35 = 1 << (v31 + 1);
        uint64_t v43 = v35;
      }
      unint64_t v42 = v37;
      if (v35 >= v36)
      {
        unint64_t v34 = 0;
        unint64_t v31 = v37;
      }
      else
      {
        do
        {
          if (*(void *)(v27 + 8 * v37) >= 0x40uLL) {
            a6(*(void **)(v27 + 8 * v37), v35);
          }
          v36 -= v35;
          unint64_t v44 = 0;
          unint64_t v45 = v36;
          unint64_t v31 = v28;
          if (v37)
          {
            unint64_t v31 = v37 + 1;
            unint64_t v35 = 1 << (v37 + 1);
            uint64_t v43 = v35;
          }
          unint64_t v42 = v31;
          unint64_t v37 = v31;
        }
        while (v35 < v36);
        unint64_t v34 = 0;
      }
    }
    if (*(void *)(v27 + 8 * v31) >= 0x40uLL) {
      a6((void *)(*(void *)(v27 + 8 * v31) + v34 * v7), v36 - v34);
    }
    if (v35 < v36) {
      goto LABEL_70;
    }
  }
  else
  {
    tbb::internal::concurrent_vector_base_v3::internal_reserve((atomic_ullong *)this, a2, a3, a4);
    __dmb(0xBu);
    *((void *)this + 2) = a2;
    uint64_t v13 = *((void *)this + 3);
    __dmb(0xBu);
    unint64_t v14 = *((void *)this + 1);
    __dmb(0xBu);
    unint64_t v15 = v10 | 1;
    if (HIDWORD(v10)) {
      unint64_t v15 = HIDWORD(v10);
    }
    uint64_t v16 = 32 * (HIDWORD(v10) != 0);
    if (v15 >= 0x10000)
    {
      v15 >>= 16;
      uint64_t v16 = (32 * (HIDWORD(v10) != 0)) | 0x10;
    }
    if (v15 >= 0x100)
    {
      v15 >>= 8;
      v16 |= 8uLL;
    }
    if (v15 >= 0x10)
    {
      v15 >>= 4;
      v16 |= 4uLL;
    }
    if (v15 >= 4)
    {
      v15 >>= 2;
      v16 += 2;
    }
    uint64_t v40 = v13;
    unint64_t v41 = v14;
    unint64_t v17 = ((v15 >> 1) & 1) + v16;
    unint64_t v42 = v17;
    uint64_t v46 = v7;
    if (v17 < v14)
    {
      unint64_t v17 = 0;
      unint64_t v42 = 0;
    }
    unint64_t v18 = (1 << v17) & 0xFFFFFFFFFFFFFFFELL;
    unint64_t v19 = a2 - v18;
    unint64_t v20 = v10 - v18;
    if (v17) {
      unint64_t v21 = (1 << v17) & 0xFFFFFFFFFFFFFFFELL;
    }
    else {
      unint64_t v21 = 1 << v14;
    }
    unint64_t v44 = v10 - v18;
    unint64_t v45 = v19;
    uint64_t v43 = v21;
    unint64_t v22 = v19 - v21;
    if (v19 <= v21)
    {
      unint64_t v22 = v19;
    }
    else
    {
      unint64_t v23 = *(void *)(v13 + 8 * v17);
      if (v23 <= 0x3F) {
        tbb::internal::throw_exception_v4(2);
      }
      a7((void *)(v23 + v20 * v7), a5, v21 - v20);
      uint64_t v39 = v7;
      unint64_t v44 = 0;
      unint64_t v45 = v22;
      unint64_t v24 = v14;
      if (v17)
      {
        unint64_t v24 = v17 + 1;
        unint64_t v21 = 2 << v17;
        uint64_t v43 = 2 << v17;
      }
      unint64_t v42 = v24;
      if (v21 >= v22)
      {
        unint64_t v20 = 0;
        unint64_t v17 = v24;
      }
      else
      {
        do
        {
          uint64_t v25 = *(void **)(v13 + 8 * v24);
          if ((unint64_t)v25 <= 0x3F) {
            tbb::internal::throw_exception_v4(2);
          }
          a7(v25, a5, v21);
          v22 -= v21;
          unint64_t v44 = 0;
          unint64_t v45 = v22;
          unint64_t v17 = v14;
          if (v24)
          {
            unint64_t v17 = v24 + 1;
            unint64_t v21 = 1 << (v24 + 1);
            uint64_t v43 = v21;
          }
          unint64_t v42 = v17;
          unint64_t v24 = v17;
        }
        while (v21 < v22);
        unint64_t v20 = 0;
      }
      uint64_t v7 = v39;
    }
    unint64_t v38 = *(void *)(v13 + 8 * v17);
    if (v38 <= 0x3F) {
      tbb::internal::throw_exception_v4(2);
    }
    a7((void *)(v38 + v20 * v7), a5, v22 - v20);
    if (v21 < v22) {
LABEL_70:
    }
      tbb::internal::concurrent_vector_base_v3::helper::cleanup((tbb::internal::concurrent_vector_base_v3::helper *)&v40);
  }
}

void sub_216760EF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216760A8C((tbb::internal::concurrent_vector_base_v3::helper *)va);
  _Unwind_Resume(a1);
}

unint64_t sub_216760F24(void *a1, void (**a2)(unint64_t, unint64_t))
{
  unint64_t result = a1[2];
  unint64_t v5 = a1[1];
  if (result < v5)
  {
    unint64_t result = 0;
    a1[2] = 0;
  }
  unint64_t v6 = (1 << result) & 0xFFFFFFFFFFFFFFFELL;
  unint64_t v7 = a1[5] - v6;
  unint64_t v8 = a1[4] - v6;
  uint64_t v9 = 1 << v5;
  if (result) {
    unint64_t v10 = (1 << result) & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t v10 = v9;
  }
  a1[4] = v8;
  a1[5] = v7;
  a1[3] = v10;
  if (v10 < v7)
  {
    if (*(void *)(*a1 + 8 * result) >= 0x40uLL)
    {
      (*a2)(*(void *)(*a1 + 8 * result) + v8 * a1[6], v10 - v8);
      unint64_t v7 = a1[5];
      unint64_t result = a1[2];
      unint64_t v10 = a1[3];
    }
    v7 -= v10;
    a1[4] = 0;
    a1[5] = v7;
    if (result)
    {
      unint64_t v10 = 1 << ++result;
      a1[3] = 1 << result;
    }
    else
    {
      unint64_t result = a1[1];
    }
    for (a1[2] = result; v10 < v7; a1[2] = result)
    {
      if (*(void *)(*a1 + 8 * result) >= 0x40uLL)
      {
        ((void (*)(void))*a2)(*(void *)(*a1 + 8 * result));
        unint64_t v7 = a1[5];
        unint64_t result = a1[2];
        unint64_t v10 = a1[3];
      }
      v7 -= v10;
      a1[4] = 0;
      a1[5] = v7;
      if (result)
      {
        unint64_t v10 = 1 << ++result;
        a1[3] = 1 << result;
      }
      else
      {
        unint64_t result = a1[1];
      }
    }
    unint64_t v8 = 0;
  }
  if (*(void *)(*a1 + 8 * result) >= 0x40uLL)
  {
    (*a2)(*(void *)(*a1 + 8 * result) + v8 * a1[6], v7 - v8);
    return a1[2];
  }
  return result;
}

unint64_t tbb::internal::concurrent_vector_base_v3::internal_clear(tbb::internal::concurrent_vector_base_v3 *this, void (*a2)(void *, unint64_t))
{
  unint64_t v4 = *((void *)this + 2);
  __dmb(0xBu);
  *((void *)this + 2) = 0;
  uint64_t v5 = *((void *)this + 3);
  __dmb(0xBu);
  unint64_t v6 = *((void *)this + 1);
  __dmb(0xBu);
  v14[0] = v5;
  v14[1] = v6;
  unint64_t v18 = v4;
  uint64_t v19 = 0;
  unint64_t v7 = 1 << v6;
  unint64_t v15 = 0;
  unint64_t v16 = 1 << v6;
  uint64_t v17 = 0;
  if (1 << v6 >= v4)
  {
    unint64_t v9 = 0;
  }
  else
  {
    unint64_t v8 = 0;
    do
    {
      if (*(void *)(v5 + 8 * v8) >= 0x40uLL) {
        a2(*(void **)(v5 + 8 * v8), v7);
      }
      v4 -= v7;
      uint64_t v17 = 0;
      unint64_t v18 = v4;
      unint64_t v9 = v6;
      if (v8)
      {
        unint64_t v9 = v8 + 1;
        unint64_t v7 = 1 << (v8 + 1);
        unint64_t v16 = v7;
      }
      unint64_t v15 = v9;
      unint64_t v8 = v9;
    }
    while (v7 < v4);
  }
  if (*(void *)(v5 + 8 * v9) >= 0x40uLL) {
    a2(*(void **)(v5 + 8 * v9), v4);
  }
  unint64_t v10 = 0;
  BOOL v11 = (tbb::internal::concurrent_vector_base_v3 *)*((void *)this + 3);
  __dmb(0xBu);
  uint64_t v12 = 64;
  if ((tbb::internal::concurrent_vector_base_v3 *)((char *)this + 32) == v11) {
    uint64_t v12 = 3;
  }
  while (*((void *)v11 + v10) >= 0x40uLL)
  {
    if (v12 == ++v10)
    {
      unint64_t v10 = v12;
      break;
    }
  }
  if (v16 < v18) {
    tbb::internal::concurrent_vector_base_v3::helper::cleanup((tbb::internal::concurrent_vector_base_v3::helper *)v14);
  }
  if (v9 >= v10) {
    return v9 + 1;
  }
  else {
    return v10;
  }
}

void sub_2167611F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216760A8C((tbb::internal::concurrent_vector_base_v3::helper *)va);
  _Unwind_Resume(a1);
}

unint64_t *tbb::internal::concurrent_vector_base_v3::internal_compact(tbb::internal::concurrent_vector_base_v3 **this, uint64_t a2, unint64_t *a3, void (*a4)(void *, unint64_t), void (*a5)(void *, const void *, unint64_t))
{
  uint64_t v5 = a3;
  unint64_t v6 = (tbb::internal::concurrent_vector_base_v3 *)this;
  unint64_t v7 = 0;
  unint64_t v8 = (unint64_t)this[2];
  __dmb(0xBu);
  unint64_t v9 = this[3];
  uint64_t v10 = 64;
  if (this + 4 == (tbb::internal::concurrent_vector_base_v3 **)v9) {
    uint64_t v10 = 3;
  }
  __dmb(0xBu);
  while (*((void *)v9 + v7) >= 0x40uLL)
  {
    if (v10 == ++v7)
    {
      unint64_t v7 = v10;
      break;
    }
  }
  if (v8)
  {
    unint64_t v11 = (v8 - 1) >> 32;
    BOOL v12 = v11 != 0;
    if (!v11) {
      unint64_t v11 = (v8 - 1) | 1;
    }
    uint64_t v13 = 32 * v12;
    if (v11 >= 0x10000)
    {
      v11 >>= 16;
      uint64_t v13 = (32 * v12) | 0x10;
    }
    if (v11 >= 0x100)
    {
      v11 >>= 8;
      v13 |= 8uLL;
    }
    if (v11 >= 0x10)
    {
      v11 >>= 4;
      v13 |= 4uLL;
    }
    if (v11 >= 4)
    {
      v11 >>= 2;
      v13 += 2;
    }
    unint64_t v14 = v13 + ((v11 >> 1) & 1) + 1;
  }
  else
  {
    unint64_t v14 = 0;
  }
  unint64_t v15 = (unint64_t)this[1];
  __dmb(0xBu);
  unint64_t v16 = v14;
  unint64_t v48 = v15;
  if (v14 >= v15)
  {
    unint64_t v16 = v15;
    if (v15 < v14)
    {
      unint64_t v16 = v15;
      while (1)
      {
        unint64_t v17 = a2 << v16;
        if ((unint64_t)(a2 << v16) >= 0x1000 && (v17 >> 19 || ((v17 - 1) & 0x800) != 0)) {
          break;
        }
        if (v14 == ++v16)
        {
          unint64_t v16 = v14;
          break;
        }
      }
    }
  }
  if (v14 == v7 && v16 == v48) {
    return 0;
  }
  unint64_t v45 = v14;
  unint64_t v18 = this[3];
  __dmb(0xBu);
  for (uint64_t i = 1; i != 65; ++i)
    a3[i] = 0;
  *a3 = 0;
  if (v16 != v48 && v16)
  {
    uint64_t v20 = ((uint64_t (*)(tbb::internal::concurrent_vector_base_v3 **, uint64_t))*this)(this, 1 << v16);
    if (!v20) {
      tbb::internal::throw_exception_v4(1);
    }
    v5[1] = v20;
    *uint64_t v5 = v16;
    if (v8)
    {
      unint64_t v21 = 0;
      unint64_t v22 = 0;
      uint64_t v23 = 1 << v48;
      do
      {
        unint64_t v24 = v21 + v23;
        unint64_t v25 = v8 - v21;
        if (v24 >= v8) {
          unint64_t v26 = v25;
        }
        else {
          unint64_t v26 = v23;
        }
        a5((void *)(v20 + ((1 << v22) & 0xFFFFFFFFFFFFFFFELL) * a2), *((const void **)v18 + v22), v26);
        unint64_t v21 = 2 << v22;
        BOOL v27 = v22 == 0;
        if (v22) {
          ++v22;
        }
        else {
          unint64_t v22 = v48;
        }
        if (v27) {
          unint64_t v21 = 1 << v48;
        }
        if (v22 >= v16) {
          break;
        }
        uint64_t v23 = v21;
      }
      while (v21 < v8);
    }
    for (uint64_t j = 0; j != v16; ++j)
      v5[j + 1] = *(void *)((char *)v18 + j * 8);
    uint64_t v29 = 0;
    if (v16 <= 1) {
      uint64_t v30 = 1;
    }
    else {
      uint64_t v30 = v16;
    }
    do
    {
      *((void *)v18 + v29) = v20 + ((1 << v29) & 0xFFFFFFFFFFFFFFFELL) * a2;
      ++v29;
    }
    while (v30 != v29);
    *uint64_t v5 = v48;
    __dmb(0xBu);
    unint64_t v6 = (tbb::internal::concurrent_vector_base_v3 *)this;
    this[1] = (tbb::internal::concurrent_vector_base_v3 *)v16;
    if (v8)
    {
      unint64_t v31 = 0;
      unint64_t v32 = 0;
      uint64_t v33 = 1 << v48;
      do
      {
        unint64_t v34 = v31 + v33;
        unint64_t v35 = v8 - v31;
        if (v34 >= v8) {
          unint64_t v36 = v35;
        }
        else {
          unint64_t v36 = v33;
        }
        a4((void *)v5[v32 + 1], v36);
        unint64_t v31 = 2 << v32;
        BOOL v37 = v32 == 0;
        if (v32) {
          ++v32;
        }
        else {
          unint64_t v32 = v48;
        }
        if (v37) {
          unint64_t v31 = 1 << v48;
        }
        if (v32 >= v16) {
          break;
        }
        uint64_t v33 = v31;
      }
      while (v31 < v8);
    }
  }
  unint64_t v38 = v45 - v7;
  if (v45 < v7)
  {
    *uint64_t v5 = v48;
    uint64_t v39 = v45;
    uint64_t v40 = (void *)((char *)v18 + 8 * v45);
    do
    {
      v5[v39 + 1] = *(void *)((char *)v18 + v39 * 8);
      ++v39;
    }
    while (v7 != v39);
    if (v7 != v45)
    {
      do
        *v40++ = 0;
      while (!__CFADD__(v38++, 1));
    }
    if (!v16)
    {
      __dmb(0xBu);
      *((void *)v6 + 1) = 0;
    }
  }
  return v5;
}

void sub_2167615BC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void (*a12)(unint64_t, unint64_t), uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void (*a17)(unint64_t, unint64_t), uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  __cxa_begin_catch(a1);
  uint64_t v27 = *v24;
  a18 = a10;
  a19 = v27;
  a20 = 0;
  a21 = 0;
  a22 = 0;
  a23 = v26 + v25;
  a24 = a14;
  a17 = a12;
  sub_216760F24(&a18, &a17);
  __cxa_rethrow();
}

void sub_2167615FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  sub_216760A8C((tbb::internal::concurrent_vector_base_v3::helper *)va);
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void *tbb::internal::concurrent_vector_base_v3::internal_swap(void *this, tbb::internal::concurrent_vector_base_v3 *a2)
{
  uint64_t v2 = this[2];
  __dmb(0xBu);
  uint64_t v3 = *((void *)a2 + 2);
  if (v2 | v3)
  {
    unint64_t v4 = (void *)this[3];
    uint64_t v5 = (char *)*((void *)a2 + 3);
    uint64_t v6 = this[4];
    unint64_t v7 = (char *)a2 + 32;
    this[4] = *((void *)a2 + 4);
    *((void *)a2 + 4) = v6;
    uint64_t v8 = this[5];
    this[5] = *((void *)a2 + 5);
    *((void *)a2 + 5) = v8;
    uint64_t v9 = this[6];
    this[6] = *((void *)a2 + 6);
    *((void *)a2 + 6) = v9;
    uint64_t v10 = this[1];
    this[1] = *((void *)a2 + 1);
    *((void *)a2 + 1) = v10;
    uint64_t v11 = this[3];
    this[3] = *((void *)a2 + 3);
    *((void *)a2 + 3) = v11;
    if (this + 4 == v4)
    {
      *((void *)a2 + 3) = v7;
      if (v7 != v5) {
        goto LABEL_4;
      }
    }
    else if (v7 != v5)
    {
LABEL_4:
      this[2] = v3;
      __dmb(0xBu);
      *((void *)a2 + 2) = v2;
      return this;
    }
    this[3] = this + 4;
    goto LABEL_4;
  }
  return this;
}

uint64_t tbb::internal::dynamic_link(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4) {
    *a4 = 0;
  }
  return 0;
}

const char *tbb::internal::initialize_handler_pointers(tbb::internal *this)
{
  if (tbb::internal::dynamic_link((uint64_t)"libtbbmalloc.dylib", (uint64_t)&off_2642940F8, 4, 0))
  {
    uint64_t v2 = "scalable_malloc";
  }
  else
  {
    off_26B4AF078 = (uint64_t (*)(void))MEMORY[0x263EF88C0];
    off_26B4AF080[0] = (uint64_t (*)())MEMORY[0x263EF8970];
    off_26B4AF088 = (uint64_t (*)(void, void))sub_216761790;
    off_26B4AF090 = (uint64_t (*)(void))sub_2167617D8;
    uint64_t v2 = "malloc";
  }

  return tbb::internal::PrintExtraVersionInfo("ALLOCATOR", v2, v1);
}

unint64_t sub_216761790(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = malloc(a2 + a1);
  if (!v3) {
    return 0;
  }
  unint64_t v4 = ((unint64_t)v3 + a2) & -a2;
  *(void *)(v4 - 8) = v3;
  return v4;
}

void sub_2167617D8(uint64_t a1)
{
  if (a1) {
    free(*(void **)(a1 - 8));
  }
}

void tbb::internal::initialize_cache_aligned_allocator(tbb::internal *this)
{
  int v1 = dword_26798E018;
  __dmb(0xBu);
  if (v1 != 2)
  {
    while (1)
    {
      int v2 = dword_26798E018;
      __dmb(0xBu);
      if (!v2) {
        break;
      }
LABEL_7:
      while (1)
      {
        int v4 = dword_26798E018;
        __dmb(0xBu);
        if (v4 != 1) {
          break;
        }
        sched_yield();
      }
      int v5 = dword_26798E018;
      __dmb(0xBu);
      if (v5 == 2) {
        return;
      }
    }
    while (1)
    {
      int v3 = 0;
      atomic_compare_exchange_strong(&dword_26798E018, (unsigned int *)&v3, 1u);
      if (!v3) {
        break;
      }
      if (dword_26798E018) {
        goto LABEL_7;
      }
    }
    if (tbb::internal::dynamic_link((uint64_t)"libtbbmalloc.dylib", (uint64_t)&off_2642940F8, 4, 0))
    {
      unint64_t v7 = "scalable_malloc";
    }
    else
    {
      off_26B4AF078 = (uint64_t (*)(void))MEMORY[0x263EF88C0];
      off_26B4AF080[0] = (uint64_t (*)())MEMORY[0x263EF8970];
      off_26B4AF088 = (uint64_t (*)(void, void))sub_216761790;
      off_26B4AF090 = (uint64_t (*)(void))sub_2167617D8;
      unint64_t v7 = "malloc";
    }
    tbb::internal::PrintExtraVersionInfo("ALLOCATOR", v7, v6);
    __dmb(0xBu);
    dword_26798E018 = 2;
  }
}

uint64_t tbb::internal::NFS_GetLineSize(tbb::internal *this)
{
  return 128;
}

uint64_t tbb::internal::NFS_Allocate(unint64_t this, uint64_t a2, unint64_t a3, void *a4)
{
  unint64_t v4 = a2 * this;
  if (a2 * this < this || v4 >= 0xFFFFFFFFFFFFFF80) {
    tbb::internal::throw_exception_v4(1);
  }
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = off_26B4AF088(v5, 128);
  if (!v6) {
    tbb::internal::throw_exception_v4(1);
  }
  return v6;
}

uint64_t tbb::internal::NFS_Free(tbb::internal *this, void *a2)
{
  return off_26B4AF090(this);
}

uint64_t tbb::internal::allocate_via_handler_v3(tbb::internal *this)
{
  uint64_t v1 = ((uint64_t (*)(tbb::internal *))off_26B4AF080[0])(this);
  if (!v1) {
    tbb::internal::throw_exception_v4(1);
  }
  return v1;
}

uint64_t tbb::internal::deallocate_via_handler_v3(uint64_t this, void *a2)
{
  if (this) {
    return off_26B4AF078();
  }
  return this;
}

BOOL tbb::internal::is_malloc_used_v3(tbb::internal *this)
{
  uint64_t v1 = off_26B4AF080[0];
  if ((uint64_t (*)(tbb::internal *))off_26B4AF080[0] == sub_216761A50)
  {
    tbb::internal::initialize_cache_aligned_allocator(this);
    uint64_t v2 = ((uint64_t (*)(tbb::internal *))off_26B4AF080[0])((tbb::internal *)1);
    off_26B4AF078(v2);
    uint64_t v1 = off_26B4AF080[0];
  }
  return v1 == (uint64_t (*)())MEMORY[0x263EF8970];
}

uint64_t sub_216761A50(tbb::internal *a1)
{
  tbb::internal::initialize_cache_aligned_allocator(a1);
  uint64_t v2 = off_26B4AF080[0];

  return ((uint64_t (*)(tbb::internal *))v2)(a1);
}

uint64_t sub_216761A90(tbb::internal *a1)
{
  tbb::internal::initialize_cache_aligned_allocator(a1);
  uint64_t v2 = (uint64_t (*)(tbb::internal *))off_26B4AF078;

  return v2(a1);
}

uint64_t sub_216761AD0(tbb::internal *a1, uint64_t a2)
{
  tbb::internal::initialize_cache_aligned_allocator(a1);
  unint64_t v4 = (uint64_t (*)(tbb::internal *, uint64_t))off_26B4AF088;

  return v4(a1, a2);
}

uint64_t sub_216761B18(tbb::internal *a1)
{
  tbb::internal::initialize_cache_aligned_allocator(a1);
  uint64_t v2 = (uint64_t (*)(tbb::internal *))off_26B4AF090;

  return v2(a1);
}

tbb::internal *tbb::internal::input_buffer::grow(tbb::internal::input_buffer *this, unint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = *((void *)this + 2);
  uint64_t v6 = 2 * v5;
  if (!v5) {
    uint64_t v6 = 4;
  }
  do
  {
    unint64_t v7 = v6;
    v6 *= 2;
  }
  while (v7 < a2);
  uint64_t v9 = tbb::internal::NFS_Allocate(v7, 24, 0, a4);
  unint64_t result = *(tbb::internal **)this;
  if (v7)
  {
    uint64_t v11 = (unsigned char *)(v9 + 41);
    unint64_t v12 = v7;
    do
    {
      *(v11 - 24) = 0;
      *uint64_t v11 = 0;
      v11 += 48;
      v12 -= 2;
    }
    while (v12);
  }
  if (v5)
  {
    uint64_t v13 = *((void *)this + 3);
    uint64_t v14 = v5 - 1;
    do
    {
      unint64_t v15 = (char *)result + 24 * (v13 & v14);
      long long v16 = *(_OWORD *)v15;
      unint64_t v17 = v9 + 24 * (v13 & (v7 - 1));
      *(void *)(v17 + 16) = *((void *)v15 + 2);
      *(_OWORD *)unint64_t v17 = v16;
      ++v13;
      --v5;
    }
    while (v5);
    *(void *)this = v9;
    *((void *)this + 2) = v7;
  }
  else
  {
    *(void *)this = v9;
    *((void *)this + 2) = v7;
    if (!result) {
      return result;
    }
  }

  return (tbb::internal *)tbb::internal::NFS_Free(result, v8);
}

tbb::internal::stage_task *tbb::internal::stage_task::execute(tbb::internal::stage_task *this)
{
  uint64_t v1 = this;
  int v2 = *((unsigned __int8 *)this + 48);
  uint64_t v3 = *((void *)this + 5);
  if (v2)
  {
    if (*(unsigned char *)(v3 + 24))
    {
      uint64_t v14 = (**(uint64_t (***)(uint64_t, void))v3)(v3, *((void *)v1 + 1));
      *((void *)v1 + 1) = v14;
      int v15 = *(unsigned __int8 *)(*((void *)v1 + 5) + 24);
      if (!v14)
      {
        uint64_t v16 = *((void *)v1 + 4);
        if ((v15 & 0x40) == 0 || *(unsigned char *)(v16 + 48))
        {
          uint64_t v1 = 0;
          *(unsigned char *)(v16 + 48) = 1;
          return v1;
        }
      }
      if ((v15 & 0x11111111) == 1)
      {
        *((void *)v1 + 2) = atomic_fetch_add((atomic_ullong *volatile)(*((void *)v1 + 4) + 40), 1uLL);
        *((unsigned char *)v1 + 24) = 1;
      }
      else if ((v15 & 0xEu) >= 6)
      {
        uint64_t v17 = *((void *)v1 + 4);
        if (*(unsigned char *)(v17 + 49)) {
          atomic_fetch_add((atomic_ullong *volatile)(v17 + 40), 1uLL);
        }
      }
      if (!*(void *)(*((void *)v1 + 5) + 8))
      {
        *((void *)v1 + 1) = 0;
        *((void *)v1 + 2) = 0;
        *((_WORD *)v1 + 12) = 0;
        uint64_t v30 = *((void *)v1 + 4);
LABEL_50:
        *((void *)v1 + 5) = *(void *)(v30 + 8);
        *((unsigned char *)v1 + 48) = 1;
LABEL_51:
        *((unsigned char *)v1 - 12) = 3;
        return v1;
      }
      if (atomic_fetch_add((atomic_ullong *volatile)(*((void *)v1 + 4) + 32), 0xFFFFFFFFFFFFFFFFLL) != 1)
      {
        uint64_t v18 = *((void *)v1 - 4);
        uint64_t v39 = 0;
        uint64_t v40 = v18;
        uint64_t v19 = tbb::internal::allocate_additional_child_of_proxy::allocate((tbb::internal::allocate_additional_child_of_proxy *)&v39, 0x38uLL);
        uint64_t v20 = *((void *)v1 + 4);
        *(unsigned char *)(v19 - 11) = 1;
        *(void *)uint64_t v19 = &unk_26C746658;
        *(void *)(v19 + 32) = v20;
        *(void *)(v19 + 40) = *(void *)(v20 + 8);
        *(unsigned char *)(v19 + 48) = 1;
        *(void *)(v19 + 8) = 0;
        *(void *)(v19 + 16) = 0;
        *(_WORD *)(v19 + 24) = 0;
        (***(void (****)(void))(v19 - 40))();
      }
    }
    else
    {
      uint64_t v4 = *((void *)v1 + 4);
      if (*(unsigned char *)(v4 + 48)) {
        return 0;
      }
      if ((*(unsigned char *)(v3 + 24) & 0xEu) >= 6 && *(unsigned char *)(v4 + 49))
      {
        atomic_fetch_add((atomic_ullong *volatile)(v4 + 40), 1uLL);
        uint64_t v4 = *((void *)v1 + 4);
      }
      if (atomic_fetch_add((atomic_ullong *volatile)(v4 + 32), 0xFFFFFFFFFFFFFFFFLL) != 1)
      {
        uint64_t v5 = *((void *)v1 - 4);
        uint64_t v39 = 0;
        uint64_t v40 = v5;
        uint64_t v6 = tbb::internal::allocate_additional_child_of_proxy::allocate((tbb::internal::allocate_additional_child_of_proxy *)&v39, 0x38uLL);
        uint64_t v7 = *((void *)v1 + 4);
        *(unsigned char *)(v6 - 11) = 1;
        *(void *)uint64_t v6 = &unk_26C746658;
        *(void *)(v6 + 32) = v7;
        *(void *)(v6 + 40) = *(void *)(v7 + 8);
        *(unsigned char *)(v6 + 48) = 1;
        *(void *)(v6 + 8) = 0;
        *(void *)(v6 + 16) = 0;
        *(_WORD *)(v6 + 24) = 0;
        (***(void (****)(void))(v6 - 40))();
      }
      uint64_t v8 = (***((uint64_t (****)(void, void))v1 + 5))(*((void *)v1 + 5), *((void *)v1 + 1));
      *((void *)v1 + 1) = v8;
      if (!v8)
      {
        uint64_t v10 = *((void *)v1 + 5);
        char v11 = *(unsigned char *)(v10 + 24);
        if ((v11 & 0x40) == 0)
        {
LABEL_13:
          uint64_t v12 = *((void *)v1 + 4);
          *(unsigned char *)(v12 + 48) = 1;
          if ((v11 & 0xEu) >= 6 && *(unsigned char *)(v12 + 49))
          {
            uint64_t v1 = 0;
            atomic_fetch_add((atomic_ullong *volatile)(v12 + 40), 0xFFFFFFFFFFFFFFFFLL);
            return v1;
          }
          return 0;
        }
        if (pthread_getspecific(*(void *)(*(void *)(v10 + 16) + 56)))
        {
          char v11 = *(unsigned char *)(*((void *)v1 + 5) + 24);
          goto LABEL_13;
        }
      }
    }
    *((unsigned char *)v1 + 48) = 0;
  }
  else
  {
    *((void *)v1 + 1) = (**(uint64_t (***)(uint64_t, void))v3)(v3, *((void *)v1 + 1));
    uint64_t v13 = *((void *)v1 + 5);
    if (*(unsigned char *)(v13 + 24)) {
      sub_216762160(*(void *)(v13 + 16), *((void *)v1 + 2), (uint64_t)v1);
    }
  }
  uint64_t v21 = *(void *)(*((void *)v1 + 5) + 8);
  *((void *)v1 + 5) = v21;
  if (!v21)
  {
    unint64_t add = atomic_fetch_add((atomic_ullong *volatile)(*((void *)v1 + 4) + 32), 1uLL);
    uint64_t v30 = *((void *)v1 + 4);
    uint64_t v31 = *(void *)(v30 + 8);
    if ((*(unsigned char *)(v31 + 24) & 0x20) != 0)
    {
      if (!add)
      {
        MEMORY[0x21D448AF0](**(unsigned int **)(*(void *)(v31 + 16) + 8));
        return 0;
      }
      return 0;
    }
    if (add - 1 < 0xFFFFFFFFFFFFFFFELL || *(unsigned char *)(v30 + 48)) {
      return 0;
    }
    *((void *)v1 + 1) = 0;
    *((void *)v1 + 2) = 0;
    *((_WORD *)v1 + 12) = 0;
    goto LABEL_50;
  }
  if ((*(unsigned char *)(v21 + 24) & 1) == 0
    || !sub_216762354(*(void *)(v21 + 16), (long long *)((char *)v1 + 8), 0, v9))
  {
    goto LABEL_51;
  }
  uint64_t v22 = *((void *)v1 + 5);
  if ((*(unsigned char *)(v22 + 24) & 0x20) != 0)
  {
    while (1)
    {
      uint64_t v22 = *(void *)(v22 + 8);
      if (!v22) {
        break;
      }
      char v23 = *(unsigned char *)(v22 + 24);
      if ((v23 & 0x20) == 0)
      {
        *((void *)v1 + 5) = v22;
        unint64_t v24 = *(void **)(v22 + 16);
        uint64_t v25 = v24 + 4;
        uint64_t v26 = (atomic_uint *)((unint64_t)(v24 + 4) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_39:
        int v27 = *v26 & ~(255 << (8 * (((_BYTE)v24 + 32) & 3)));
        while (1)
        {
          int v28 = v27;
          atomic_compare_exchange_strong(v26, (unsigned int *)&v28, v27 | (1 << (8 * (((_BYTE)v24 + 32) & 3))));
          if (v28 == v27) {
            break;
          }
          if (*v26 != v27)
          {
            sched_yield();
            goto LABEL_39;
          }
        }
        uint64_t v33 = (v24[2] - 1) & v24[3];
        uint64_t v34 = *v24 + 24 * v33;
        int v36 = *(unsigned __int8 *)(v34 + 17);
        unint64_t v35 = (unsigned char *)(v34 + 17);
        if (!v36)
        {
          __dmb(0xBu);
          unsigned char *v25 = 0;
          break;
        }
        uint64_t v37 = *v24 + 24 * v33;
        long long v38 = *(_OWORD *)v37;
        *((void *)v1 + 3) = *(void *)(v37 + 16);
        *(_OWORD *)((char *)v1 + 8) = v38;
        *unint64_t v35 = 0;
        if ((v23 & 1) == 0) {
          ++v24[3];
        }
        __dmb(0xBu);
        unsigned char *v25 = 0;
        goto LABEL_51;
      }
    }
  }
  *((void *)v1 + 5) = 0;
  return 0;
}

uint64_t sub_216762160(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v23 = *MEMORY[0x263EF8340];
  long long v21 = 0uLL;
  char v22 = 0;
  uint64_t v6 = (unsigned char *)(result + 32);
  uint64_t v7 = (atomic_uint *)((result + 32) & 0xFFFFFFFFFFFFFFFCLL);
  int v8 = 1 << (8 * ((result + 32) & 3));
  int v9 = ~(255 << (8 * ((result + 32) & 3)));
LABEL_2:
  int v10 = *v7 & v9;
  while (1)
  {
    int v11 = v10;
    atomic_compare_exchange_strong(v7, (unsigned int *)&v11, v10 | v8);
    if (v11 == v10) {
      break;
    }
    if (*v7 != v10)
    {
      unint64_t result = sched_yield();
      goto LABEL_2;
    }
  }
  if (*(unsigned char *)(v5 + 48))
  {
    if (*(void *)(v5 + 24) != a2)
    {
      __dmb(0xBu);
      *uint64_t v6 = 0;
      return result;
    }
  }
  else
  {
    a2 = *(void *)(v5 + 24);
  }
  uint64_t v12 = *(void *)v5;
  *(void *)(v5 + 24) = a2 + 1;
  uint64_t v13 = (long long *)(v12 + 24 * ((*(void *)(v5 + 16) - 1) & (a2 + 1)));
  long long v21 = *v13;
  char v22 = *((unsigned char *)v13 + 16);
  int v14 = *((unsigned __int8 *)v13 + 17);
  int v18 = *(_DWORD *)((char *)v13 + 18);
  __int16 v19 = *((_WORD *)v13 + 11);
  *((unsigned char *)v13 + 17) = 0;
  __dmb(0xBu);
  *(unsigned char *)(v5 + 32) = 0;
  if (v14)
  {
    uint64_t v15 = *(void *)(a3 - 32);
    v20[0] = 0;
    v20[1] = v15;
    uint64_t v16 = tbb::internal::allocate_additional_child_of_proxy::allocate((tbb::internal::allocate_additional_child_of_proxy *)v20, 0x38uLL);
    *(unsigned char *)(v16 - 11) = 1;
    long long v17 = *(_OWORD *)(a3 + 32);
    *(unsigned char *)(v16 + 24) = v22;
    *(_OWORD *)(v16 + 8) = v21;
    *(unsigned char *)(v16 + 25) = v14;
    *(_WORD *)(v16 + 30) = v19;
    *(_DWORD *)(v16 + 26) = v18;
    *(void *)uint64_t v16 = &unk_26C746658;
    *(_OWORD *)(v16 + 32) = v17;
    *(unsigned char *)(v16 + 48) = 0;
    return (***(uint64_t (****)(void))(v16 - 40))();
  }
  return result;
}

uint64_t sub_216762354(uint64_t a1, long long *a2, int a3, void *a4)
{
  *((unsigned char *)a2 + 17) = 1;
  uint64_t v7 = (unsigned char *)(a1 + 32);
  int v8 = (atomic_uint *)((a1 + 32) & 0xFFFFFFFFFFFFFFFCLL);
  int v9 = 1 << (8 * ((a1 + 32) & 3));
  int v10 = ~(255 << (8 * ((a1 + 32) & 3)));
LABEL_2:
  int v11 = *v8 & v10;
  while (1)
  {
    int v12 = v11;
    atomic_compare_exchange_strong(v8, (unsigned int *)&v12, v11 | v9);
    if (v12 == v11) {
      break;
    }
    if (*v8 != v11)
    {
      sched_yield();
      goto LABEL_2;
    }
  }
  uint64_t v13 = *(void *)a1;
  unint64_t v15 = *(void *)(a1 + 16);
  uint64_t v14 = *(void *)(a1 + 24);
  unint64_t v16 = v15 - 1;
  int v17 = *(unsigned __int8 *)(*(void *)a1 + 24 * ((v15 - 1) & v14) + 17);
  if (*(unsigned char *)(a1 + 48))
  {
    if (*((unsigned char *)a2 + 16))
    {
      uint64_t v18 = *((void *)a2 + 1);
      unint64_t v19 = v18 - v14;
      if (v19) {
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v18 = *(void *)(a1 + 40);
      *(void *)(a1 + 40) = v18 + 1;
      *((void *)a2 + 1) = v18;
      *((unsigned char *)a2 + 16) = 1;
      unint64_t v19 = v18 - v14;
      if (v19) {
        goto LABEL_16;
      }
    }
  }
  else
  {
    uint64_t v18 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = v18 + 1;
    unint64_t v19 = v18 - v14;
    if (v19) {
      goto LABEL_16;
    }
  }
  if (!*(unsigned char *)(a1 + 49) && !a3)
  {
    uint64_t result = 0;
    goto LABEL_34;
  }
LABEL_16:
  if (v19 < v15)
  {
    unint64_t v21 = v15;
    goto LABEL_30;
  }
  unint64_t v22 = v19 + 1;
  uint64_t v23 = 2 * v15;
  if (!v15) {
    uint64_t v23 = 4;
  }
  do
  {
    unint64_t v21 = v23;
    v23 *= 2;
  }
  while (v21 < v22);
  uint64_t v13 = tbb::internal::NFS_Allocate(v21, 24, 0, a4);
  uint64_t v25 = *(tbb::internal **)a1;
  if (v21)
  {
    uint64_t v26 = (unsigned char *)(v13 + 41);
    unint64_t v27 = v21;
    do
    {
      *(v26 - 24) = 0;
      *uint64_t v26 = 0;
      v26 += 48;
      v27 -= 2;
    }
    while (v27);
  }
  if (v15)
  {
    uint64_t v28 = *(void *)(a1 + 24);
    do
    {
      uint64_t v29 = (char *)v25 + 24 * (v28 & v16);
      long long v30 = *(_OWORD *)v29;
      unint64_t v31 = v13 + 24 * (v28 & (v21 - 1));
      *(void *)(v31 + 16) = *((void *)v29 + 2);
      *(_OWORD *)unint64_t v31 = v30;
      ++v28;
      --v15;
    }
    while (v15);
    *(void *)a1 = v13;
    *(void *)(a1 + 16) = v21;
  }
  else
  {
    *(void *)a1 = v13;
    *(void *)(a1 + 16) = v21;
    if (!v25) {
      goto LABEL_30;
    }
  }
  tbb::internal::NFS_Free(v25, v24);
  uint64_t v13 = *(void *)a1;
  unint64_t v21 = *(void *)(a1 + 16);
LABEL_30:
  long long v32 = *a2;
  unint64_t v33 = v13 + 24 * ((v21 - 1) & v18);
  *(void *)(v33 + 16) = *((void *)a2 + 2);
  *(_OWORD *)unint64_t v33 = v32;
  if (!v17 && *(unsigned char *)(a1 + 49)) {
    MEMORY[0x21D448AF0](**(unsigned int **)(a1 + 8));
  }
  uint64_t result = 1;
LABEL_34:
  __dmb(0xBu);
  *uint64_t v7 = 0;
  return result;
}

void sub_21676257C(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::pipeline::clear_filters(uint64_t this)
{
  for (uint64_t i = *(void *)(this + 8); i; uint64_t i = *(void *)(i + 8))
  {
    if ((*(unsigned char *)(i + 24) & 0xC) != 0)
    {
      int v2 = *(void **)(i + 16);
      if (v2)
      {
        unint64_t v3 = v2[2];
        if (v3)
        {
          unint64_t v4 = 0;
          uint64_t v5 = v2[3];
          do
          {
            uint64_t v6 = (v3 - 1) & (v5 + v4);
            uint64_t v7 = *v2 + 24 * v6;
            int v9 = *(unsigned __int8 *)(v7 + 17);
            int v8 = (unsigned char *)(v7 + 17);
            if (v9)
            {
              this = (*(uint64_t (**)(uint64_t, void))(*(void *)i + 24))(i, *(void *)(*v2 + 24 * v6));
              *int v8 = 0;
              unint64_t v3 = v2[2];
            }
            ++v4;
          }
          while (v4 < v3);
        }
      }
    }
  }
  return this;
}

uint64_t tbb::pipeline::pipeline(uint64_t this)
{
  *(_WORD *)(this + 48) = 0;
  *(void *)this = &unk_26C7465E0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  __dmb(0xBu);
  *(void *)(this + 40) = 0;
  __dmb(0xBu);
  *(void *)(this + 32) = 0;
  return this;
}

{
  *(_WORD *)(this + 48) = 0;
  *(void *)this = &unk_26C7465E0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  __dmb(0xBu);
  *(void *)(this + 40) = 0;
  __dmb(0xBu);
  *(void *)(this + 32) = 0;
  return this;
}

void tbb::pipeline::~pipeline(tbb::pipeline *this, void *a2)
{
  *(void *)this = &unk_26C7465E0;
  unint64_t v3 = (void *)((char *)this + 8);
  uint64_t v2 = *((void *)this + 1);
  while (v2)
  {
    uint64_t v4 = v2;
    uint64_t v5 = *(void *)(v2 + 16);
    if (v5)
    {
      uint64_t v6 = (void *)sub_21676330C(v5, a2);
      operator delete(v6);
      *(void *)(v4 + 16) = 0;
    }
    uint64_t v2 = *(void *)(v4 + 8);
    *(void *)(v4 + 8) = -1;
    unsigned int v7 = *(unsigned char *)(v4 + 24) & 0xE;
    if ((*(unsigned char *)(v4 + 24) & 0xE) != 0)
    {
      *(void *)(v4 + 32) = -1;
      *(void *)(v4 + 40) = 0;
      if (v7 >= 6) {
        *(void *)(v4 + 48) = 0;
      }
    }
  }
  *unint64_t v3 = 0;
  v3[1] = 0;
}

{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;

  *(void *)this = &unk_26C7465E0;
  unint64_t v3 = (void *)((char *)this + 8);
  uint64_t v2 = *((void *)this + 1);
  while (v2)
  {
    uint64_t v4 = v2;
    uint64_t v5 = *(void *)(v2 + 16);
    if (v5)
    {
      uint64_t v6 = (void *)sub_21676330C(v5, a2);
      operator delete(v6);
      *(void *)(v4 + 16) = 0;
    }
    uint64_t v2 = *(void *)(v4 + 8);
    *(void *)(v4 + 8) = -1;
    unsigned int v7 = *(unsigned char *)(v4 + 24) & 0xE;
    if ((*(unsigned char *)(v4 + 24) & 0xE) != 0)
    {
      *(void *)(v4 + 32) = -1;
      *(void *)(v4 + 40) = 0;
      if (v7 >= 6) {
        *(void *)(v4 + 48) = 0;
      }
    }
  }
  *unint64_t v3 = 0;
  v3[1] = 0;
}

{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;
  uint64_t vars8;

  *(void *)this = &unk_26C7465E0;
  unint64_t v3 = *((void *)this + 1);
  while (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = *(void *)(v3 + 16);
    if (v5)
    {
      uint64_t v6 = (void *)sub_21676330C(v5, a2);
      operator delete(v6);
      *(void *)(v4 + 16) = 0;
    }
    unint64_t v3 = *(void *)(v4 + 8);
    *(void *)(v4 + 8) = -1;
    unsigned int v7 = *(unsigned char *)(v4 + 24) & 0xE;
    if ((*(unsigned char *)(v4 + 24) & 0xE) != 0)
    {
      *(void *)(v4 + 32) = -1;
      *(void *)(v4 + 40) = 0;
      if (v7 >= 6) {
        *(void *)(v4 + 48) = 0;
      }
    }
  }

  operator delete(this);
}

void tbb::pipeline::clear(tbb::pipeline *this, void *a2)
{
  unint64_t v3 = (void *)((char *)this + 8);
  uint64_t v2 = *((void *)this + 1);
  while (v2)
  {
    uint64_t v4 = v2;
    uint64_t v5 = *(void *)(v2 + 16);
    if (v5)
    {
      uint64_t v6 = (void *)sub_21676330C(v5, a2);
      operator delete(v6);
      *(void *)(v4 + 16) = 0;
    }
    uint64_t v2 = *(void *)(v4 + 8);
    *(void *)(v4 + 8) = -1;
    unsigned int v7 = *(unsigned char *)(v4 + 24) & 0xE;
    if ((*(unsigned char *)(v4 + 24) & 0xE) != 0)
    {
      *(void *)(v4 + 32) = -1;
      *(void *)(v4 + 40) = 0;
      if (v7 >= 6) {
        *(void *)(v4 + 48) = 0;
      }
    }
  }
  *unint64_t v3 = 0;
  v3[1] = 0;
}

uint64_t tbb::pipeline::add_filter(uint64_t this, tbb::filter *a2)
{
  int v3 = *((unsigned __int8 *)a2 + 24);
  if ((v3 & 0xE) == 0)
  {
    int v9 = *(void **)(this + 16);
    if (!v9)
    {
      int v9 = (void *)(this + 8);
      *(void *)(this + 16) = this + 8;
    }
    *int v9 = a2;
    *(void *)(this + 16) = (char *)a2 + 8;
    *((void *)a2 + 1) = 0;
    goto LABEL_13;
  }
  uint64_t v5 = *(void *)(this + 8);
  uint64_t v4 = *(void *)(this + 16);
  *((void *)a2 + 4) = v4;
  *((void *)a2 + 5) = this;
  if (v5) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = this;
  }
  *(void *)(v6 + 8) = a2;
  *((void *)a2 + 1) = 0;
  *(void *)(this + 16) = a2;
  if ((v3 & 0xEu) <= 5)
  {
LABEL_13:
    if ((v3 & 1) == 0) {
      return this;
    }
    unsigned int v7 = operator new(0x48uLL);
    this = sub_216763384((uint64_t)v7, (v3 & 0x11111111) == 1, 0, v10);
    goto LABEL_18;
  }
  if (v3)
  {
    if ((v3 & 0x20) != 0) {
      *(unsigned char *)(this + 49) = 1;
    }
    unsigned int v7 = operator new(0x48uLL);
    this = sub_216763384((uint64_t)v7, (v3 & 0x11111111) == 1, (v3 & 0x20) != 0, v11);
LABEL_18:
    *((void *)a2 + 2) = v7;
    return this;
  }
  if (v4)
  {
    if ((*(unsigned char *)(v4 + 24) & 0x20) == 0) {
      return this;
    }
    unsigned int v7 = operator new(0x48uLL);
    this = sub_216763384((uint64_t)v7, 0, 0, v8);
    goto LABEL_18;
  }
  if ((v3 & 0x40) != 0)
  {
    int v12 = (pthread_key_t *)operator new(0x48uLL);
    sub_216763384((uint64_t)v12, 0, 0, v13);
    *((void *)a2 + 2) = v12;
    this = pthread_key_create(v12 + 7, 0);
    if (this) {
      tbb::internal::handle_perror((tbb::internal *)this, "TLS not allocated for filter", v14);
    }
    *((unsigned char *)v12 + 64) = 1;
  }
  return this;
}

void sub_216762A88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void tbb::pipeline::remove_filter(tbb::filter **this, tbb::filter *a2)
{
  if (this[1] == a2) {
    int v3 = this;
  }
  else {
    int v3 = (tbb::filter **)*((void *)a2 + 4);
  }
  v3[1] = (tbb::filter *)*((void *)a2 + 1);
  uint64_t v5 = this[2];
  uint64_t v4 = (char *)(this + 2);
  if (v5 == a2) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = (void *)(*((void *)a2 + 1) + 32);
  }
  *uint64_t v6 = *((void *)a2 + 4);
  uint64_t v7 = *((void *)a2 + 2);
  if (v7)
  {
    int v8 = (void *)sub_21676330C(v7, a2);
    operator delete(v8);
    *((void *)a2 + 2) = 0;
  }
  *((void *)a2 + 4) = -1;
  *((void *)a2 + 1) = -1;
  if ((*((unsigned char *)a2 + 24) & 0xEu) >= 6) {
    *((void *)a2 + 6) = 0;
  }
  *((void *)a2 + 5) = 0;
}

uint64_t *tbb::pipeline::run(uint64_t *this, uint64_t a2, tbb::task_group_context *a3)
{
  if (this[1])
  {
    uint64_t v4 = this;
    int v11 = this;
    *((unsigned char *)this + 48) = 0;
    __dmb(0xBu);
    this[4] = a2;
    if (*((unsigned char *)this + 49))
    {
      uint64_t v5 = this[1];
      if ((*(unsigned char *)(v5 + 24) & 0x20) != 0) {
        MEMORY[0x21D448AF0](**(unsigned int **)(*(void *)(v5 + 16) + 8));
      }
    }
    int v10 = a3;
    uint64_t v6 = tbb::internal::allocate_root_with_context_proxy::allocate(&v10, 0x18uLL);
    *(unsigned char *)(v6 - 11) = 1;
    *(void *)uint64_t v6 = &unk_26C7466E0;
    *(void *)(v6 + 8) = v4;
    *(unsigned char *)(v6 + 16) = 0;
    uint64_t v7 = v4[1];
    if ((*(unsigned char *)(v7 + 24) & 0xEu) >= 6)
    {
      for (uint64_t i = *(void *)(v7 + 8); i; uint64_t i = *(void *)(i + 8))
      {
        if ((*(unsigned char *)(*(void *)(i + 32) + 24) & 0x20) != 0 && (*(unsigned char *)(i + 24) & 0x20) == 0)
        {
          *(unsigned char *)(v6 + 16) = 1;
          *(void *)(v7 + 48) = i;
          uint64_t v7 = i;
        }
      }
    }
    v4[3] = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 - 40) + 16))(*(void *)(v6 - 40), v6, v6 - 8);
    if (*((unsigned char *)v4 + 49))
    {
      for (uint64_t j = *(void *)(v4[1] + 8); j; uint64_t j = *(void *)(j + 8))
      {
        if ((*(unsigned char *)(j + 24) & 0x20) != 0) {
          MEMORY[0x21D448AF0](**(unsigned int **)(*(void *)(j + 16) + 8));
        }
      }
    }
    return sub_216763758((uint64_t *)&v11);
  }
  return this;
}

void sub_216762C98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216763758((uint64_t *)va);
  _Unwind_Resume(a1);
}

void tbb::pipeline::run(tbb::pipeline *this, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    unint64_t v7 = (unint64_t)(*(unsigned char *)(v4 + 24) & 0x80) >> 7;
    v8[0] = 1;
    uint64_t v9 = ((v7 & 1) << 16) | 3;
    int v10 = 55;
    tbb::task_group_context::init((uint64_t)v8, a2, a3, a4);
    tbb::pipeline::run((uint64_t *)this, a2, (tbb::task_group_context *)v8);
    tbb::task_group_context::~task_group_context((tbb::task_group_context *)v8);
  }
}

void sub_216762D64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  tbb::task_group_context::~task_group_context((tbb::task_group_context *)va);
  _Unwind_Resume(a1);
}

BOOL tbb::filter::has_more_work(tbb::filter *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 5) + 40);
  __dmb(0xBu);
  return v1 != *(void *)(*((void *)this + 2) + 24);
}

void tbb::filter::~filter(tbb::filter *this, void *a2)
{
  *(void *)this = &unk_26C746600;
  unsigned int v3 = *((unsigned char *)this + 24) & 0xE;
  if ((*((unsigned char *)this + 24) & 0xE) != 0)
  {
    uint64_t v4 = *((void *)this + 1);
    if (v4 != -1)
    {
      uint64_t v6 = *((void *)this + 4);
      uint64_t v5 = *((void *)this + 5);
      if (*(tbb::filter **)(v5 + 8) == this) {
        uint64_t v6 = *((void *)this + 5);
      }
      *(void *)(v6 + 8) = v4;
      int v8 = *(tbb::filter **)(v5 + 16);
      unint64_t v7 = (void *)(v5 + 16);
      if (v8 == this) {
        uint64_t v9 = v7;
      }
      else {
        uint64_t v9 = (void *)(*((void *)this + 1) + 32);
      }
      *uint64_t v9 = *((void *)this + 4);
      uint64_t v10 = *((void *)this + 2);
      if (v10)
      {
        uint64_t v11 = (void *)sub_21676330C(v10, a2);
        operator delete(v11);
        *((void *)this + 2) = 0;
        unsigned int v3 = *((unsigned char *)this + 24) & 0xE;
      }
      *((void *)this + 4) = -1;
      *((void *)this + 1) = -1;
      if (v3 >= 6) {
        *((void *)this + 6) = 0;
      }
      *((void *)this + 5) = 0;
    }
  }
}

uint64_t tbb::filter::set_end_of_input(uint64_t this)
{
  if ((*(unsigned char *)(this + 24) & 1) == 0) {
    return pthread_setspecific(*(void *)(*(void *)(this + 16) + 56), (const void *)1);
  }
  *(unsigned char *)(*(void *)(this + 40) + 48) = 1;
  return this;
}

uint64_t tbb::thread_bound_filter::process_item(tbb::thread_bound_filter *this)
{
  return tbb::thread_bound_filter::internal_process_item(this, 1);
}

uint64_t tbb::thread_bound_filter::internal_process_item(tbb::thread_bound_filter *this, int a2)
{
  long long v36 = 0uLL;
  LOWORD(v37) = 0;
  uint64_t v4 = *((void *)this + 5);
  if (*(unsigned char *)(v4 + 48))
  {
    uint64_t v5 = *(void *)(v4 + 40);
    __dmb(0xBu);
    if (v5 == *(void *)(*((void *)this + 2) + 24)) {
      return 2;
    }
  }
  if (*((void *)this + 4))
  {
    while (1)
    {
      uint64_t v6 = *((void *)this + 2);
      unint64_t v7 = (atomic_uint *)((v6 + 32) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_5:
      int v8 = *v7 & ~(255 << (8 * ((v6 + 32) & 3)));
      while (1)
      {
        int v9 = v8;
        atomic_compare_exchange_strong(v7, (unsigned int *)&v9, v8 | (1 << (8 * ((v6 + 32) & 3))));
        if (v9 == v8) {
          break;
        }
        if (*v7 != v8)
        {
          sched_yield();
          goto LABEL_5;
        }
      }
      int v10 = *(unsigned __int8 *)(*(void *)v6 + 24 * ((*(void *)(v6 + 16) - 1) & *(void *)(v6 + 24)) + 17);
      __dmb(0xBu);
      *(unsigned char *)(v6 + 32) = 0;
      if (v10) {
        break;
      }
      if (!a2) {
        return 1;
      }
      uint64_t v11 = *(unsigned int **)(*((void *)this + 2) + 8);
      while (MEMORY[0x21D448B00](*v11) == 14)
        ;
      uint64_t v12 = *((void *)this + 5);
      if (*(unsigned char *)(v12 + 48))
      {
        uint64_t v13 = *(void *)(v12 + 40);
        __dmb(0xBu);
        if (v13 == *(void *)(*((void *)this + 2) + 24)) {
          return 2;
        }
      }
    }
    uint64_t v16 = *((void *)this + 2);
    int v17 = (atomic_uint *)((v16 + 32) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_19:
    int v18 = *v17 & ~(255 << (8 * ((v16 + 32) & 3)));
    while (1)
    {
      int v19 = v18;
      atomic_compare_exchange_strong(v17, (unsigned int *)&v19, v18 | (1 << (8 * ((v16 + 32) & 3))));
      if (v19 == v18) {
        break;
      }
      if (*v17 != v18)
      {
        sched_yield();
        goto LABEL_19;
      }
    }
    uint64_t v20 = *(void *)(v16 + 24);
    uint64_t v21 = (*(void *)(v16 + 16) - 1) & v20;
    uint64_t v22 = *(void *)v16 + 24 * v21;
    int v24 = *(unsigned __int8 *)(v22 + 17);
    uint64_t v23 = (unsigned char *)(v22 + 17);
    if (v24)
    {
      uint64_t v25 = *(void *)v16 + 24 * v21;
      long long v26 = *(_OWORD *)v25;
      uint64_t v37 = *(void *)(v25 + 16);
      long long v36 = v26;
      *uint64_t v23 = 0;
      *(void *)(v16 + 24) = v20 + 1;
    }
    __dmb(0xBu);
    *(unsigned char *)(v16 + 32) = 0;
    *(void *)&long long v36 = (**(uint64_t (***)(tbb::thread_bound_filter *, void))this)(this, v36);
    uint64_t v28 = *((void *)this + 1);
    if (v28) {
      goto LABEL_26;
    }
    goto LABEL_36;
  }
  uint64_t v14 = *((void *)this + 5);
  if (*(unsigned char *)(v14 + 48)) {
    return 2;
  }
  uint64_t v29 = *(void *)(v14 + 32);
  __dmb(0xBu);
  if (!v29)
  {
    if (!a2) {
      return 1;
    }
    do
    {
      long long v30 = *(unsigned int **)(*((void *)this + 2) + 8);
      while (MEMORY[0x21D448B00](*v30) == 14)
        ;
      uint64_t v31 = *(void *)(*((void *)this + 5) + 32);
      __dmb(0xBu);
    }
    while (!v31);
  }
  *(void *)&long long v36 = (**(uint64_t (***)(tbb::thread_bound_filter *, void))this)(this, v36);
  uint64_t v32 = *((void *)this + 5);
  if (!(void)v36)
  {
    *(unsigned char *)(v32 + 48) = 1;
    return 2;
  }
  atomic_fetch_add((atomic_ullong *volatile)(v32 + 32), 0xFFFFFFFFFFFFFFFFLL);
  if ((*((unsigned char *)this + 24) & 0x11) == 1)
  {
    uint64_t v33 = *(void *)(*((void *)this + 5) + 40);
    __dmb(0xBu);
    *((void *)&v36 + 1) = v33;
    LOBYTE(v37) = 1;
  }
  atomic_fetch_add((atomic_ullong *volatile)(*((void *)this + 5) + 40), 1uLL);
  uint64_t v28 = *((void *)this + 1);
  if (v28)
  {
LABEL_26:
    sub_216762354(*(void *)(v28 + 16), &v36, 1, v27);
    return 0;
  }
LABEL_36:
  uint64_t result = 0;
  unint64_t add = atomic_fetch_add((atomic_ullong *volatile)(*((void *)this + 5) + 32), 1uLL);
  uint64_t v35 = *(void *)(*((void *)this + 5) + 8);
  if ((*(unsigned char *)(v35 + 24) & 0x20) != 0 && !add)
  {
    MEMORY[0x21D448AF0](**(unsigned int **)(*(void *)(v35 + 16) + 8));
    return 0;
  }
  return result;
}

uint64_t tbb::thread_bound_filter::try_process_item(tbb::thread_bound_filter *this)
{
  return tbb::thread_bound_filter::internal_process_item(this, 0);
}

void *sub_2167631F0(void *a1)
{
  *a1 = &unk_26C746658;
  uint64_t v2 = (unsigned char *)a1[5];
  if (v2 && a1[1] && (v2[24] & 0xC) != 0)
  {
    (*(void (**)(unsigned char *))(*(void *)v2 + 24))(v2);
    a1[1] = 0;
  }
  return a1;
}

void sub_216763278(void *__p)
{
  *__p = &unk_26C746658;
  uint64_t v2 = (unsigned char *)__p[5];
  if (v2 && __p[1] && (v2[24] & 0xC) != 0) {
    (*(void (**)(unsigned char *))(*(void *)v2 + 24))(v2);
  }

  operator delete(__p);
}

uint64_t sub_21676330C(uint64_t a1, void *a2)
{
  tbb::internal::NFS_Free(*(tbb::internal **)a1, a2);
  unsigned int v3 = *(semaphore_t **)(a1 + 8);
  if (v3)
  {
    semaphore_destroy(*MEMORY[0x263EF8960], *v3);
    operator delete(v3);
  }
  if (*(unsigned char *)(a1 + 64))
  {
    uint64_t v4 = (tbb::internal *)pthread_key_delete(*(void *)(a1 + 56));
    if (v4) {
      tbb::internal::handle_perror(v4, "Failed to destroy filter TLS", v5);
    }
  }
  return a1;
}

uint64_t sub_216763384(uint64_t a1, char a2, char a3, void *a4)
{
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 48) = a2;
  *(unsigned char *)(a1 + 49) = a3;
  *(unsigned char *)(a1 + 64) = 0;
  uint64_t v6 = (unsigned char *)tbb::internal::NFS_Allocate(4uLL, 24, 0, a4);
  unint64_t v7 = *(tbb::internal **)a1;
  v6[17] = 0;
  v6[41] = 0;
  v6[65] = 0;
  v6[89] = 0;
  *(void *)a1 = v6;
  *(void *)(a1 + 16) = 4;
  if (v7) {
    tbb::internal::NFS_Free(v7, v5);
  }
  if (*(unsigned char *)(a1 + 49))
  {
    int v8 = (semaphore_t *)operator new(4uLL);
    *int v8 = 0;
    semaphore_create(*MEMORY[0x263EF8960], v8, 0, 0);
    *(void *)(a1 + 8) = v8;
  }
  return a1;
}

void sub_216763438(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

tbb::internal::allocate_child_proxy *sub_216763450(tbb::internal::allocate_child_proxy *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 1);
  if (!*(unsigned char *)(v2 + 48) && (*(unsigned char *)(*(void *)(v2 + 8) + 24) & 0x20) == 0)
  {
    uint64_t v3 = *(void *)(v2 + 32);
    __dmb(0xBu);
    if (v3)
    {
      *((unsigned char *)this - 12) = 3;
      *((void *)this - 3) = 1;
      uint64_t v4 = tbb::internal::allocate_child_proxy::allocate(this, 0x38uLL);
      uint64_t v5 = *((void *)v1 + 1);
      *(unsigned char *)(v4 - 11) = 1;
      *(void *)uint64_t v4 = &unk_26C746658;
      *(void *)(v4 + 32) = v5;
      *(void *)(v4 + 40) = *(void *)(v5 + 8);
      *(unsigned char *)(v4 + 48) = 1;
      *(void *)(v4 + 8) = 0;
      *(void *)(v4 + 16) = 0;
      *(_WORD *)(v4 + 24) = 0;
      return (tbb::internal::allocate_child_proxy *)v4;
    }
  }
  uint64_t v6 = *((void *)this + 1);
  if (!*((unsigned char *)this + 16))
  {
    if (!*(unsigned char *)(v6 + 48))
    {
      *((unsigned char *)this - 12) = 3;
      return v1;
    }
    return 0;
  }
  uint64_t v7 = *(void *)(v6 + 8);
  uint64_t v8 = *(void *)(v7 + 48);
  if (!v8) {
    return 0;
  }
  uint64_t v27 = *(void *)(v7 + 48);
  while (1)
  {
    if (*(unsigned char *)(*((void *)v1 + 1) + 48))
    {
      uint64_t v9 = *(void *)(*(void *)(v8 + 40) + 40);
      __dmb(0xBu);
      if (v9 == *(void *)(*(void *)(v8 + 16) + 24))
      {
        uint64_t v8 = *(void *)(v27 + 48);
        uint64_t v27 = v8;
        goto LABEL_9;
      }
    }
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    unsigned int v10 = 0;
    long long v31 = 0uLL;
    LOWORD(v32) = 0;
    long long v30 = &v29;
    while (1)
    {
      uint64_t v13 = *(void **)(v8 + 16);
      char v14 = *(unsigned char *)(v8 + 24);
      unint64_t v15 = v13 + 4;
      uint64_t v16 = (atomic_uint *)((unint64_t)(v13 + 4) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_17:
      int v17 = *v16 & ~(255 << (8 * (((_BYTE)v13 + 32) & 3)));
      while (1)
      {
        int v18 = v17;
        atomic_compare_exchange_strong(v16, (unsigned int *)&v18, v17 | (1 << (8 * (((_BYTE)v13 + 32) & 3))));
        if (v18 == v17) {
          break;
        }
        if (*v16 != v17)
        {
          sched_yield();
          goto LABEL_17;
        }
      }
      uint64_t v19 = v13[3];
      uint64_t v20 = (v13[2] - 1) & v19;
      uint64_t v21 = *v13 + 24 * v20;
      int v23 = *(unsigned __int8 *)(v21 + 17);
      uint64_t v22 = (unsigned char *)(v21 + 17);
      if (!v23) {
        break;
      }
      uint64_t v24 = *v13 + 24 * v20;
      long long v31 = *(_OWORD *)v24;
      uint64_t v32 = *(void *)(v24 + 16);
      *uint64_t v22 = 0;
      if ((v14 & 1) == 0) {
        v13[3] = v19 + 1;
      }
      __dmb(0xBu);
      *unint64_t v15 = 0;
      uint64_t v11 = tbb::internal::allocate_child_proxy::allocate(v1, 0x38uLL);
      uint64_t v12 = *((void *)v1 + 1);
      *(unsigned char *)(v11 - 11) = 1;
      *(void *)(v11 + 24) = v32;
      *(void *)(v11 + 32) = v12;
      *(_OWORD *)(v11 + 8) = v31;
      *(void *)uint64_t v11 = &unk_26C746658;
      *(void *)(v11 + 40) = v8;
      *(unsigned char *)(v11 + 48) = 0;
      if (v10)
      {
        *(void *)(v11 - 8) = 0;
        *long long v30 = v11;
        long long v30 = (uint64_t *)(v11 - 8);
      }
      else
      {
        uint64_t v28 = v11;
      }
      ++v10;
      long long v31 = 0uLL;
      LOWORD(v32) = 0;
    }
    __dmb(0xBu);
    *unint64_t v15 = 0;
    if (v10) {
      break;
    }
    uint64_t v8 = *(void *)(v8 + 48);
    if (!v8)
    {
      if (!*(unsigned char *)(*((void *)v1 + 1) + 48))
      {
        uint64_t v25 = v1;
        goto LABEL_37;
      }
      sched_yield();
      uint64_t v8 = v27;
    }
LABEL_9:
    if (!v8) {
      return 0;
    }
  }
  *((void *)v1 - 3) = v10;
  if (v10 != 1 && v29) {
    (***(void (****)(void, uint64_t, uint64_t *))(v29 - 40))(*(void *)(v29 - 40), v29, v30);
  }
  uint64_t v25 = (tbb::internal::allocate_child_proxy *)v28;
LABEL_37:
  *((unsigned char *)v1 - 12) = 3;
  return v25;
}

uint64_t *sub_216763758(uint64_t *a1)
{
  BOOL is_group_execution_cancelled = tbb::task_group_context::is_group_execution_cancelled(*(tbb::task_group_context **)(*(void *)(*a1 + 24) - 56));
  uint64_t v3 = *a1;
  if (is_group_execution_cancelled)
  {
    uint64_t v4 = *(void *)(v3 + 8);
    if (v4)
    {
      do
      {
        if ((*(unsigned char *)(v4 + 24) & 0xC) != 0)
        {
          uint64_t v5 = *(void **)(v4 + 16);
          if (v5)
          {
            unint64_t v6 = v5[2];
            if (v6)
            {
              unint64_t v7 = 0;
              uint64_t v8 = v5[3];
              do
              {
                uint64_t v9 = (v6 - 1) & (v8 + v7);
                uint64_t v10 = *v5 + 24 * v9;
                int v12 = *(unsigned __int8 *)(v10 + 17);
                uint64_t v11 = (unsigned char *)(v10 + 17);
                if (v12)
                {
                  (*(void (**)(uint64_t, void))(*(void *)v4 + 24))(v4, *(void *)(*v5 + 24 * v9));
                  *uint64_t v11 = 0;
                  unint64_t v6 = v5[2];
                }
                ++v7;
              }
              while (v7 < v6);
            }
          }
        }
        uint64_t v4 = *(void *)(v4 + 8);
      }
      while (v4);
      uint64_t v3 = *a1;
    }
  }
  *(void *)(v3 + 24) = 0;
  return a1;
}

atomic_ullong **tbb::queuing_mutex::scoped_lock::acquire(atomic_ullong **result, atomic_ullong *a2)
{
  unint64_t v3 = (unint64_t)result;
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = a2;
LABEL_2:
  atomic_ullong v4 = *a2;
  while (1)
  {
    atomic_ullong v5 = v4;
    atomic_compare_exchange_strong(a2, (unint64_t *)&v5, v3);
    if (v5 == v4) {
      break;
    }
    if (atomic_fetch_add_explicit(a2, 0, memory_order_relaxed) != v4)
    {
      uint64_t result = (atomic_ullong **)sched_yield();
      goto LABEL_2;
    }
  }
  if (v4)
  {
    for (*(void *)(v4 + 8) = v3; !*(void *)(v3 + 16); uint64_t result = (atomic_ullong **)sched_yield())
      ;
  }
  __dmb(0xBu);
  return result;
}

BOOL tbb::queuing_mutex::scoped_lock::try_acquire(atomic_ullong **a1, atomic_ullong *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  while (1)
  {
    uint64_t v2 = 0;
    atomic_compare_exchange_strong(a2, (unint64_t *)&v2, (unint64_t)a1);
    BOOL v3 = v2 == 0;
    BOOL v4 = v2 == 0;
    if (v3) {
      break;
    }
    if (atomic_fetch_add_explicit(a2, 0, memory_order_relaxed)) {
      return v4;
    }
  }
  __dmb(0xBu);
  *a1 = a2;
  return v4;
}

uint64_t tbb::queuing_mutex::scoped_lock::release(uint64_t this)
{
  uint64_t v1 = (void *)this;
  uint64_t i = *(void *)(this + 8);
  if (i)
  {
LABEL_2:
    __dmb(0xBu);
    *(void *)(i + 16) = 1;
    goto LABEL_3;
  }
  BOOL v3 = *(atomic_ullong **)this;
  while (1)
  {
    uint64_t v4 = this;
    atomic_compare_exchange_strong(v3, (unint64_t *)&v4, 0);
    if (v4 == this) {
      break;
    }
    unint64_t add_explicit = atomic_fetch_add_explicit(v3, 0, memory_order_relaxed);
    if (add_explicit != this) {
      goto LABEL_9;
    }
  }
  unint64_t add_explicit = this;
LABEL_9:
  if (add_explicit != this)
  {
    for (uint64_t i = *(void *)(this + 8); !i; uint64_t i = v1[1])
      this = sched_yield();
    goto LABEL_2;
  }
LABEL_3:
  *uint64_t v1 = 0;
  v1[2] = 0;
  return this;
}

unint64_t tbb::queuing_rw_mutex::scoped_lock::acquire(unint64_t result, atomic_ullong *a2, int a3)
{
  unint64_t v5 = result;
  *(void *)uint64_t result = a2;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(unsigned char *)(result + 25) = 0;
  if (a3) {
    char v6 = 1;
  }
  else {
    char v6 = 2;
  }
  __dmb(0xBu);
  *(unsigned char *)(result + 24) = v6;
  unint64_t v7 = result + 24;
  *(unsigned char *)(result + 26) = 0;
LABEL_5:
  atomic_ullong v8 = *a2;
  while (1)
  {
    atomic_ullong v9 = v8;
    atomic_compare_exchange_strong(a2, (unint64_t *)&v9, v5);
    if (v9 == v8) {
      break;
    }
    if (atomic_fetch_add_explicit(a2, 0, memory_order_relaxed) != v8)
    {
      uint64_t result = sched_yield();
      goto LABEL_5;
    }
  }
  if (a3)
  {
    if (v8)
    {
      __dmb(0xBu);
      *(void *)((v8 & 0xFFFFFFFFFFFFFFFELL) + 16) = v5;
      while (*(unsigned char *)(v5 + 25) != 1)
        uint64_t result = sched_yield();
    }
    goto LABEL_39;
  }
  if (v8)
  {
    if (v8)
    {
      *(void *)(v5 + 8) = v8 & 0xFFFFFFFFFFFFFFFELL;
      __dmb(0xBu);
      *(void *)((v8 & 0xFFFFFFFFFFFFFFFELL) + 16) = v5;
    }
    else
    {
      uint64_t v10 = (atomic_uint *)((v8 + 24) & 0xFFFFFFFFFFFFFFFCLL);
      int v11 = 255 << (8 * ((v8 + 24) & 3));
LABEL_17:
      int v12 = *v10 & ~v11;
      int v13 = v12 | (2 << (8 * ((v8 + 24) & 3)));
      unsigned int v14 = v12 | (4 << (8 * ((v8 + 24) & 3)));
      while (1)
      {
        int v15 = v13;
        atomic_compare_exchange_strong(v10, (unsigned int *)&v15, v14);
        if (v15 == v13) {
          break;
        }
        if (*v10 != v13)
        {
          if (((*v10 ^ v13) & v11) == 0)
          {
            uint64_t result = sched_yield();
            goto LABEL_17;
          }
          int v13 = *v10;
          break;
        }
      }
      *(void *)(v5 + 8) = v8;
      __dmb(0xBu);
      *(void *)(v8 + 16) = v5;
      if (((v13 & v11) >> (8 * ((v8 + 24) & 3))) == 8) {
        goto LABEL_28;
      }
    }
    while (*(unsigned char *)(v5 + 25) != 1)
      uint64_t result = sched_yield();
  }
LABEL_28:
  uint64_t v16 = (atomic_uint *)(v7 & 0xFFFFFFFFFFFFFFFCLL);
  char v17 = 8 * (v7 & 3);
  int v18 = 255 << v17;
LABEL_29:
  int v19 = *v16 & ~v18;
  int v20 = v19 | (2 << v17);
  unsigned int v21 = v19 | (8 << v17);
  while (1)
  {
    int v22 = v20;
    atomic_compare_exchange_strong(v16, (unsigned int *)&v22, v21);
    if (v22 == v20) {
      break;
    }
    if (*v16 != v20)
    {
      if (((*v16 ^ v20) & v18) == 0)
      {
        uint64_t result = sched_yield();
        goto LABEL_29;
      }
      int v20 = *v16;
      break;
    }
  }
  if (((v20 & v18) >> v17) != 2)
  {
    for (; !*(void *)(v5 + 16); uint64_t result = sched_yield())
      ;
    __dmb(0xBu);
    *(unsigned char *)(v5 + 24) = 8;
    uint64_t v23 = *(void *)(v5 + 16);
    __dmb(0xBu);
    *(unsigned char *)(v23 + 25) = 1;
  }
LABEL_39:
  __dmb(0xBu);
  return result;
}

uint64_t tbb::queuing_rw_mutex::scoped_lock::try_acquire(unint64_t a1, atomic_ullong *a2, int a3)
{
  if (*a2) {
    return 0;
  }
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 25) = 0;
  if (a3) {
    char v4 = 1;
  }
  else {
    char v4 = 8;
  }
  __dmb(0xBu);
  *(unsigned char *)(a1 + 24) = v4;
  *(unsigned char *)(a1 + 26) = 0;
  while (1)
  {
    uint64_t v5 = 0;
    atomic_compare_exchange_strong(a2, (unint64_t *)&v5, a1);
    if (!v5) {
      break;
    }
    if (atomic_fetch_add_explicit(a2, 0, memory_order_relaxed)) {
      return 0;
    }
  }
  __dmb(0xBu);
  *(void *)a1 = a2;
  return 1;
}

uint64_t tbb::queuing_rw_mutex::scoped_lock::release(uint64_t this)
{
  uint64_t v1 = this;
  int v2 = *(unsigned __int8 *)(this + 24);
  __dmb(0xBu);
  if (v2 != 1)
  {
    unint64_t add = atomic_fetch_add((atomic_ullong *volatile)(this + 8), 1uLL);
    if (add)
    {
      while (2)
      {
        atomic_ullong v8 = (unsigned char *)(add + 26);
        atomic_ullong v9 = (atomic_uint *)((add + 26) & 0xFFFFFFFFFFFFFFFCLL);
        int v10 = 255 << (8 * ((add + 26) & 3));
        while (2)
        {
          int v11 = *v9 & ~v10;
          do
          {
            int v12 = v11;
            atomic_compare_exchange_strong(v9, (unsigned int *)&v12, v11 | (1 << (8 * ((add + 26) & 3))));
            if (v12 == v11)
            {
              *(void *)(v1 + 8) = add;
              int v19 = (atomic_uint *)((v1 + 26) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_30:
              int v20 = *v19 & ~(255 << (8 * ((v1 + 26) & 3)));
              while (1)
              {
                int v21 = v20;
                atomic_compare_exchange_strong(v19, (unsigned int *)&v21, v20 | (1 << (8 * ((v1 + 26) & 3))));
                if (v21 == v20) {
                  break;
                }
                if (*v19 != v20)
                {
                  this = sched_yield();
                  goto LABEL_30;
                }
              }
              __dmb(0xBu);
              *(void *)(add + 16) = 0;
              if (!*(void *)(v1 + 16))
              {
                long long v31 = *(atomic_ullong **)v1;
                while (1)
                {
                  uint64_t v32 = v1;
                  atomic_compare_exchange_strong(v31, (unint64_t *)&v32, add);
                  if (v32 == v1) {
                    break;
                  }
                  unint64_t add_explicit = atomic_fetch_add_explicit(v31, 0, memory_order_relaxed);
                  if (add_explicit != v1) {
                    goto LABEL_83;
                  }
                }
                unint64_t add_explicit = v1;
LABEL_83:
                if (add_explicit != v1 && !*(void *)(v1 + 16))
                {
                  do
                    this = sched_yield();
                  while (!*(void *)(v1 + 16));
                }
              }
              uint64_t v22 = *(void *)(v1 + 16);
              __dmb(0xBu);
              if (v22)
              {
LABEL_36:
                uint64_t v23 = *(void *)(v22 + 8);
                while (1)
                {
                  uint64_t v24 = v23;
                  atomic_compare_exchange_strong((atomic_ullong *volatile)(v22 + 8), (unint64_t *)&v24, add);
                  if (v24 == v23) {
                    break;
                  }
                  if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 0, memory_order_relaxed) != v23)
                  {
                    this = sched_yield();
                    goto LABEL_36;
                  }
                }
                uint64_t v25 = *(void *)(v1 + 16);
                __dmb(0xBu);
                *(void *)(add + 16) = v25;
              }
              else
              {
                LOBYTE(v23) = 0;
              }
              __dmb(0xBu);
              *atomic_ullong v8 = 0;
              if (v23) {
                goto LABEL_88;
              }
              goto LABEL_61;
            }
          }
          while (*v9 == v11);
          if ((*v9 & v10) == 0)
          {
            this = sched_yield();
            continue;
          }
          break;
        }
        uint64_t v13 = add | 1;
        while (1)
        {
          uint64_t v14 = add | 1;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v1 + 8), (unint64_t *)&v14, add);
          if (v14 == v13) {
            break;
          }
          unint64_t v15 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 8), 0, memory_order_relaxed);
          if (v15 != v13)
          {
            if ((v15 & 1) == 0)
            {
              while (*(void *)(v1 + 8) == v13)
                this = sched_yield();
              __dmb(0xBu);
              *atomic_ullong v8 = 0;
            }
            break;
          }
        }
        unint64_t add = atomic_fetch_add((atomic_ullong *volatile)(v1 + 8), 1uLL);
        if (add) {
          continue;
        }
        break;
      }
    }
    uint64_t v16 = (atomic_uint *)((v1 + 26) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_25:
    int v17 = *v16 & ~(255 << (8 * ((v1 + 26) & 3)));
    while (1)
    {
      int v18 = v17;
      atomic_compare_exchange_strong(v16, (unsigned int *)&v18, v17 | (1 << (8 * ((v1 + 26) & 3))));
      if (v18 == v17) {
        break;
      }
      if (*v16 != v17)
      {
        this = sched_yield();
        goto LABEL_25;
      }
    }
    uint64_t v26 = *(void *)(v1 + 16);
    __dmb(0xBu);
    if (v26)
    {
LABEL_48:
      *(unsigned char *)(v26 + 25) = 2;
LABEL_49:
      uint64_t v29 = *(void *)(v26 + 8);
      while (1)
      {
        uint64_t v30 = v29;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v26 + 8), (unint64_t *)&v30, 0);
        if (v30 == v29) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 0, memory_order_relaxed) != v29)
        {
          this = sched_yield();
          goto LABEL_49;
        }
      }
      __dmb(0xBu);
      *(unsigned char *)(v26 + 25) = 1;
      if (v29)
      {
LABEL_88:
        while (*(unsigned char *)(v1 + 26))
          this = sched_yield();
        goto LABEL_92;
      }
    }
    else
    {
      uint64_t v27 = *(atomic_ullong **)v1;
      while (1)
      {
        uint64_t v28 = v1;
        atomic_compare_exchange_strong(v27, (unint64_t *)&v28, 0);
        if (v28 == v1) {
          break;
        }
        if (atomic_fetch_add_explicit(v27, 0, memory_order_relaxed) != v1)
        {
          for (; !*(void *)(v1 + 16); this = sched_yield())
            ;
          uint64_t v26 = *(void *)(v1 + 16);
          goto LABEL_48;
        }
      }
    }
LABEL_61:
    __dmb(0xBu);
    *(unsigned char *)(v1 + 26) = 0;
    goto LABEL_92;
  }
  uint64_t v3 = *(void *)(this + 16);
  __dmb(0xBu);
  if (v3) {
    goto LABEL_67;
  }
  char v4 = *(atomic_ullong **)this;
  while (1)
  {
    uint64_t v5 = this;
    atomic_compare_exchange_strong(v4, (unint64_t *)&v5, 0);
    if (v5 == this) {
      break;
    }
    unint64_t v6 = atomic_fetch_add_explicit(v4, 0, memory_order_relaxed);
    if (v6 != this) {
      goto LABEL_63;
    }
  }
  unint64_t v6 = this;
LABEL_63:
  if (v6 != this)
  {
    if (!*(void *)(this + 16))
    {
      do
        this = sched_yield();
      while (!*(void *)(v1 + 16));
    }
    uint64_t v3 = *(void *)(v1 + 16);
    __dmb(0xBu);
LABEL_67:
    *(unsigned char *)(v3 + 25) = 2;
    int v34 = *(unsigned __int8 *)(v3 + 24);
    __dmb(0xBu);
    if (v34 == 32)
    {
      uint64_t v35 = (unsigned char *)(v1 + 26);
      long long v36 = (atomic_uint *)((v1 + 26) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_69:
      int v37 = *v36 & ~(255 << (8 * ((v1 + 26) & 3)));
      while (1)
      {
        int v38 = v37;
        atomic_compare_exchange_strong(v36, (unsigned int *)&v38, v37 | (1 << (8 * ((v1 + 26) & 3))));
        if (v38 == v37) {
          break;
        }
        if (*v36 != v37)
        {
          this = sched_yield();
          goto LABEL_69;
        }
      }
LABEL_73:
      uint64_t v39 = *(void *)(v3 + 8);
      while (1)
      {
        uint64_t v40 = v39;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v3 + 8), (unint64_t *)&v40, 0);
        if (v40 == v39) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 0, memory_order_relaxed) != v39)
        {
          this = sched_yield();
          goto LABEL_73;
        }
      }
      __dmb(0xBu);
      *(unsigned char *)(v3 + 24) = 64;
      __dmb(0xBu);
      *(unsigned char *)(v3 + 25) = 1;
      if (v39)
      {
        while (*v35)
          this = sched_yield();
      }
      else
      {
        __dmb(0xBu);
        *uint64_t v35 = 0;
      }
    }
    else
    {
      *(void *)(v3 + 8) = 0;
      __dmb(0xBu);
      *(unsigned char *)(v3 + 25) = 1;
    }
  }
LABEL_92:
  while (*(unsigned char *)(v1 + 25) == 2)
    this = sched_yield();
  *(void *)uint64_t v1 = 0;
  *(_WORD *)(v1 + 25) = 0;
  return this;
}

uint64_t tbb::queuing_rw_mutex::scoped_lock::downgrade_to_reader(tbb::queuing_rw_mutex::scoped_lock *this)
{
  unint64_t v2 = (unint64_t)this + 24;
  int v1 = *((unsigned __int8 *)this + 24);
  __dmb(0xBu);
  if (v1 == 8) {
    return 1;
  }
  __dmb(0xBu);
  *((unsigned char *)this + 24) = 2;
  if (*((void *)this + 2)) {
    goto LABEL_15;
  }
  char v4 = *(tbb::queuing_rw_mutex::scoped_lock ***)this;
  __dmb(0xBu);
  uint64_t v5 = *v4;
  __dmb(0xBu);
  if (v5 != this) {
    goto LABEL_14;
  }
  unint64_t v6 = (atomic_uint *)(v2 & 0xFFFFFFFFFFFFFFFCLL);
  int v7 = 255 << (8 * (v2 & 3));
LABEL_5:
  int v8 = *v6 & ~v7;
  int v9 = v8 | (2 << (8 * (v2 & 3)));
  unsigned int v10 = v8 | (8 << (8 * (v2 & 3)));
  while (1)
  {
    int v11 = v9;
    atomic_compare_exchange_strong(v6, (unsigned int *)&v11, v10);
    if (v11 == v9) {
      break;
    }
    if (*v6 != v9)
    {
      if (((*v6 ^ v9) & v7) == 0)
      {
        sched_yield();
        goto LABEL_5;
      }
      int v9 = *v6;
      break;
    }
  }
  if (((v9 & v7) >> (8 * (v2 & 3))) != 2)
  {
LABEL_14:
    while (!*((void *)this + 2))
      sched_yield();
LABEL_15:
    uint64_t v12 = *((void *)this + 2);
    __dmb(0xBu);
    char v13 = *(unsigned char *)(v12 + 24);
    __dmb(0xBu);
    if ((v13 & 6) != 0)
    {
      __dmb(0xBu);
      *(unsigned char *)(v12 + 25) = 1;
    }
    else
    {
      int v14 = *(unsigned __int8 *)(v12 + 24);
      __dmb(0xBu);
      if (v14 == 32)
      {
        __dmb(0xBu);
        *(unsigned char *)(v12 + 24) = 64;
      }
    }
    __dmb(0xBu);
    *(unsigned char *)unint64_t v2 = 8;
  }
  return 1;
}

BOOL tbb::queuing_rw_mutex::scoped_lock::upgrade_to_writer(tbb::queuing_rw_mutex::scoped_lock *this)
{
  unint64_t v2 = (unint64_t)this + 24;
  int v1 = *((unsigned __int8 *)this + 24);
  __dmb(0xBu);
  BOOL v3 = 1;
  if (v1 == 1) {
    return v3;
  }
  __dmb(0xBu);
  *((unsigned char *)this + 24) = 16;
  uint64_t v5 = (atomic_uint *)(((unint64_t)this + 26) & 0xFFFFFFFFFFFFFFFCLL);
  atomic_ullong v50 = (char *)this + 26;
  int v6 = 1 << (8 * (((_BYTE)this + 26) & 3));
  int v7 = ~(255 << (8 * (((_BYTE)this + 26) & 3)));
  unint64_t v8 = (unint64_t)this | 1;
LABEL_3:
  int v9 = *v5 & v7;
  while (1)
  {
    int v10 = v9;
    atomic_compare_exchange_strong(v5, (unsigned int *)&v10, v9 | v6);
    if (v10 == v9) {
      break;
    }
    if (*v5 != v9)
    {
      sched_yield();
      goto LABEL_3;
    }
  }
  int v11 = *(atomic_ullong **)this;
  uint64_t v12 = v50;
  do
  {
    char v13 = this;
    atomic_compare_exchange_strong(v11, (unint64_t *)&v13, v8);
    if (v13 == this)
    {
      __dmb(0xBu);
      *atomic_ullong v50 = 0;
LABEL_71:
      unint64_t v41 = (atomic_uint *)(v2 & 0xFFFFFFFFFFFFFFFCLL);
      char v42 = 8 * (v2 & 3);
      int v43 = 255 << v42;
      int v44 = 16 << v42;
      int v45 = 32 << v42;
      while (1)
      {
        int v46 = *v41 & ~v43;
        int v47 = v46 | v44;
        unsigned int v48 = v46 | v45;
        do
        {
          int v49 = v47;
          atomic_compare_exchange_strong(v41, (unsigned int *)&v49, v48);
          if (v49 == v47) {
            goto LABEL_34;
          }
        }
        while (*v41 == v47);
        if (((*v41 ^ v47) & v43) != 0) {
          goto LABEL_34;
        }
        sched_yield();
      }
    }
  }
  while ((tbb::queuing_rw_mutex::scoped_lock *)atomic_fetch_add_explicit(v11, 0, memory_order_relaxed) == this);
  while (!*((void *)this + 2))
    sched_yield();
  unint64_t add = atomic_fetch_add((atomic_ullong *volatile)this + 2, 1uLL);
  char v15 = *(unsigned char *)(add + 24);
  __dmb(0xBu);
  if ((v15 & 6) != 0)
  {
    __dmb(0xBu);
    *(unsigned char *)(add + 25) = 1;
  }
LABEL_14:
  uint64_t v16 = *(void *)(add + 8);
  while (1)
  {
    uint64_t v17 = v16;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(add + 8), (unint64_t *)&v17, (unint64_t)this);
    if (v17 == v16) {
      break;
    }
    if (atomic_fetch_add_explicit((atomic_ullong *volatile)(add + 8), 0, memory_order_relaxed) != v16)
    {
      sched_yield();
      goto LABEL_14;
    }
  }
  if (v16)
  {
    while (*v50)
      sched_yield();
  }
  else
  {
    __dmb(0xBu);
    *atomic_ullong v50 = 0;
  }
  if ((v15 & 0x1E) == 0)
  {
    *((void *)this + 2) = add;
    goto LABEL_71;
  }
  uint64_t v18 = add | 1;
  while (1)
  {
    if (*((void *)this + 2) != v18) {
      goto LABEL_3;
    }
    char v19 = *(unsigned char *)v2;
    __dmb(0xBu);
    if ((v19 & 0x60) != 0) {
      break;
    }
    sched_yield();
  }
  uint64_t v20 = *((void *)this + 2);
  __dmb(0xBu);
  BOOL v21 = v20 == v18;
  uint64_t v12 = v50;
  if (v21) {
    *((void *)this + 2) = add;
  }
LABEL_34:
  while (1)
  {
    uint64_t v22 = *(atomic_ullong **)this;
    do
    {
      unint64_t v23 = v8;
      atomic_compare_exchange_strong(v22, &v23, (unint64_t)this);
    }
    while (v23 != v8 && atomic_fetch_add_explicit(v22, 0, memory_order_relaxed) == v8);
    unint64_t v24 = atomic_fetch_add((atomic_ullong *volatile)this + 1, 1uLL);
    if (!v24) {
      break;
    }
    uint64_t v25 = (atomic_uint *)((v24 + 26) & 0xFFFFFFFFFFFFFFFCLL);
    int v26 = 255 << (8 * ((v24 + 26) & 3));
LABEL_39:
    int v27 = *v25 & ~v26;
    while (1)
    {
      int v28 = v27;
      atomic_compare_exchange_strong(v25, (unsigned int *)&v28, v27 | (1 << (8 * ((v24 + 26) & 3))));
      BOOL v29 = v28 == v27;
      if (v28 == v27) {
        break;
      }
      if (*v25 != v27)
      {
        if ((*v25 & v26) != 0) {
          break;
        }
        sched_yield();
        goto LABEL_39;
      }
    }
    int v30 = 255 << (8 * ((v24 + 24) & 3));
    long long v31 = (atomic_uint *)((v24 + 24) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_47:
    int v32 = *v31 & ~v30;
    int v33 = v32 | (16 << (8 * ((v24 + 24) & 3)));
    unsigned int v34 = v32 | (32 << (8 * ((v24 + 24) & 3)));
    while (1)
    {
      int v35 = v33;
      atomic_compare_exchange_strong(v31, (unsigned int *)&v35, v34);
      if (v35 == v33) {
        break;
      }
      if (*v31 != v33)
      {
        if (((*v31 ^ v33) & v30) != 0) {
          break;
        }
        sched_yield();
        goto LABEL_47;
      }
    }
    if (v29)
    {
      *((void *)this + 1) = v24;
      __dmb(0xBu);
      *(unsigned char *)(v24 + 26) = 0;
      uint64_t v12 = v50;
      while (*((void *)this + 1) == v24)
        sched_yield();
LABEL_33:
      if (!*((void *)this + 1)) {
        goto LABEL_64;
      }
    }
    else
    {
      uint64_t v36 = v24 | 1;
      uint64_t v12 = v50;
      do
      {
        uint64_t v37 = v24 | 1;
        atomic_compare_exchange_strong((atomic_ullong *volatile)this + 1, (unint64_t *)&v37, v24);
        if (v37 == v36) {
          goto LABEL_59;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)this + 1, 0, memory_order_relaxed);
      }
      while (add_explicit == v36);
      if (add_explicit)
      {
LABEL_59:
        while (*((void *)this + 1) == v24)
          sched_yield();
        goto LABEL_33;
      }
      while (*((void *)this + 1) == v36)
        sched_yield();
      __dmb(0xBu);
      *(unsigned char *)(v24 + 26) = 0;
    }
  }
  *((void *)this + 1) = 0;
LABEL_64:
  while (*v12)
    sched_yield();
  while (*((unsigned char *)this + 25) == 2)
    sched_yield();
  __dmb(0xBu);
  int v39 = *((unsigned __int8 *)this + 24);
  __dmb(0xBu);
  BOOL v3 = v39 != 64;
  __dmb(0xBu);
  *((unsigned char *)this + 24) = 1;
  *((unsigned char *)this + 25) = 1;
  return v3;
}

void *tbb::interface5::reader_writer_lock::internal_construct(void *this)
{
  *this = 0;
  __dmb(0xBu);
  this[1] = 0;
  __dmb(0xBu);
  this[2] = 0;
  __dmb(0xBu);
  this[4] = 0;
  this[3] = 0;
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::lock(tbb::interface5::reader_writer_lock *this)
{
  unint64_t v2 = (_opaque_pthread_t *)*((void *)this + 3);
  if (v2 == tbb::internal::thread_get_id_v3())
  {
    return tbb::internal::throw_exception_v4(9);
  }
  else
  {
    uint64_t v3 = tbb::internal::allocate_via_handler_v3((tbb::internal *)0x18);
    *(void *)uint64_t v3 = 0;
    *(void *)(v3 + 8) = 0;
    __dmb(0xBu);
    *(_DWORD *)(v3 + 16) = 1;
    return tbb::interface5::reader_writer_lock::start_write((atomic_ullong *)this, (tbb::interface5::reader_writer_lock::scoped_lock *)v3);
  }
}

BOOL tbb::interface5::reader_writer_lock::is_current_writer(tbb::interface5::reader_writer_lock *this)
{
  pthread_t v1 = (pthread_t)*((void *)this + 3);
  return v1 == tbb::internal::thread_get_id_v3();
}

uint64_t tbb::interface5::reader_writer_lock::scoped_lock::scoped_lock(uint64_t this)
{
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(this + 16) = 1;
  return this;
}

{
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(this + 16) = 1;
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::start_write(atomic_ullong *this, tbb::interface5::reader_writer_lock::scoped_lock *a2)
{
  id_uint64_t v3 = tbb::internal::thread_get_id_v3();
  int v6 = *((_DWORD *)a2 + 4);
  __dmb(0xBu);
  if (!v6)
  {
    while (1)
    {
      uint64_t v9 = 0;
      atomic_compare_exchange_strong(this + 2, (unint64_t *)&v9, (unint64_t)a2);
      if (!v9) {
        break;
      }
      if (atomic_fetch_add_explicit(this + 2, 0, memory_order_relaxed))
      {
        if (!a2) {
          return 0;
        }
        if (*(void *)a2) {
          tbb::interface5::reader_writer_lock::end_write(*(tbb::interface5::reader_writer_lock **)a2, a2);
        }
        goto LABEL_35;
      }
    }
LABEL_11:
    tbb::interface5::reader_writer_lock::set_next_writer((tbb::interface5::reader_writer_lock *)this, a2);
    int v10 = *((_DWORD *)a2 + 4);
    __dmb(0xBu);
    if (v10) {
      goto LABEL_18;
    }
    char v4 = (void *)*((void *)a2 + 1);
    if (!v4)
    {
LABEL_13:
      atomic_ullong v11 = this[1];
      while (1)
      {
        atomic_ullong v12 = v11;
        atomic_compare_exchange_strong(this + 1, (unint64_t *)&v12, 0);
        if (v12 == v11) {
          break;
        }
        if (atomic_fetch_add_explicit(this + 1, 0, memory_order_relaxed) != v11)
        {
          sched_yield();
          goto LABEL_13;
        }
      }
      while (1)
      {
        uint64_t v16 = a2;
        atomic_compare_exchange_strong(this + 2, (unint64_t *)&v16, 0);
        if (v16 == a2) {
          break;
        }
        unint64_t add_explicit = (tbb::interface5::reader_writer_lock::scoped_lock *)atomic_fetch_add_explicit(this + 2, 0, memory_order_relaxed);
        if (add_explicit != a2) {
          goto LABEL_23;
        }
      }
      unint64_t add_explicit = a2;
LABEL_23:
      if (add_explicit == a2)
      {
        if (!a2) {
          return 0;
        }
LABEL_29:
        if (*(void *)a2) {
          tbb::interface5::reader_writer_lock::end_write(*(tbb::interface5::reader_writer_lock **)a2, a2);
        }
LABEL_35:
        __dmb(0xBu);
        *((_DWORD *)a2 + 4) = 3;
        tbb::internal::deallocate_via_handler_v3((uint64_t)a2, v4);
        return 0;
      }
      while (1)
      {
        char v4 = (void *)*((void *)a2 + 1);
        if (v4) {
          break;
        }
        sched_yield();
      }
    }
    tbb::interface5::reader_writer_lock::set_next_writer((tbb::interface5::reader_writer_lock *)this, (tbb::interface5::reader_writer_lock::scoped_lock *)v4);
    goto LABEL_29;
  }
LABEL_2:
  atomic_ullong v7 = this[2];
  while (1)
  {
    atomic_ullong v8 = v7;
    atomic_compare_exchange_strong(this + 2, (unint64_t *)&v8, (unint64_t)a2);
    if (v8 == v7) {
      break;
    }
    if (atomic_fetch_add_explicit(this + 2, 0, memory_order_relaxed) != v7)
    {
      sched_yield();
      goto LABEL_2;
    }
  }
  if (!v7) {
    goto LABEL_11;
  }
  *(void *)(v7 + 8) = a2;
LABEL_18:
  while (1)
  {
    int v13 = *((_DWORD *)a2 + 4);
    __dmb(0xBu);
    if (v13 != 1) {
      break;
    }
    sched_yield();
  }
  this[3] = (atomic_ullong)id_v3;
  return 1;
}

uint64_t tbb::interface5::reader_writer_lock::try_lock(tbb::interface5::reader_writer_lock *this)
{
  unint64_t v2 = (_opaque_pthread_t *)*((void *)this + 3);
  if (v2 == tbb::internal::thread_get_id_v3()) {
    return 0;
  }
  uint64_t v3 = tbb::internal::allocate_via_handler_v3((tbb::internal *)0x18);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(v3 + 16) = 1;
  __dmb(0xBu);
  *(_DWORD *)(v3 + 16) = 0;

  return tbb::interface5::reader_writer_lock::start_write((atomic_ullong *)this, (tbb::interface5::reader_writer_lock::scoped_lock *)v3);
}

void tbb::interface5::reader_writer_lock::set_next_writer(tbb::interface5::reader_writer_lock *this, tbb::interface5::reader_writer_lock::scoped_lock *a2)
{
  __dmb(0xBu);
  *((void *)this + 1) = a2;
  int v4 = *((_DWORD *)a2 + 4);
  __dmb(0xBu);
  if (v4)
  {
LABEL_2:
    uint64_t v5 = *((void *)this + 4);
    __dmb(0xBu);
    while (1)
    {
      uint64_t v6 = v5;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 4, (unint64_t *)&v6, v5 | 1);
      if (v6 == v5) {
        break;
      }
      if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 4, 0, memory_order_relaxed) != v5)
      {
        sched_yield();
        goto LABEL_2;
      }
    }
    if ((v5 & 4) != 0)
    {
      while (1)
      {
        uint64_t v9 = *((void *)this + 4);
        __dmb(0xBu);
        if ((v9 & 2) != 0) {
          break;
        }
        sched_yield();
      }
    }
    else
    {
LABEL_7:
      uint64_t v7 = *((void *)this + 4);
      while (1)
      {
        uint64_t v8 = v7;
        atomic_compare_exchange_strong((atomic_ullong *volatile)this + 4, (unint64_t *)&v8, v7 | 2);
        if (v8 == v7) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 4, 0, memory_order_relaxed) != v7)
        {
          sched_yield();
          goto LABEL_7;
        }
      }
    }
    unint64_t v10 = *((void *)this + 4);
    __dmb(0xBu);
    if (v10 >= 8)
    {
      do
      {
        sched_yield();
        unint64_t v11 = *((void *)this + 4);
        __dmb(0xBu);
      }
      while (v11 > 7);
    }
  }
  else
  {
    while (1)
    {
      uint64_t v12 = 0;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 4, (unint64_t *)&v12, 3uLL);
      if (!v12) {
        break;
      }
      if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 4, 0, memory_order_relaxed)) {
        return;
      }
    }
  }
  __dmb(0xBu);
  *((_DWORD *)a2 + 4) = 2;
}

atomic_ullong *tbb::interface5::reader_writer_lock::lock_read(tbb::interface5::reader_writer_lock *this)
{
  unint64_t v2 = (_opaque_pthread_t *)*((void *)this + 3);
  if (v2 == tbb::internal::thread_get_id_v3())
  {
    return (atomic_ullong *)tbb::internal::throw_exception_v4(9);
  }
  else
  {
    v4[0] = 0;
    v4[1] = 0;
    __dmb(0xBu);
    int v5 = 1;
    uint64_t result = tbb::interface5::reader_writer_lock::start_read((atomic_ullong *)this, (tbb::interface5::reader_writer_lock::scoped_lock_read *)v4);
    if (v4[0]) {
      atomic_fetch_add((atomic_ullong *volatile)(v4[0] + 32), 0xFFFFFFFFFFFFFFF8);
    }
    __dmb(0xBu);
    int v5 = 3;
  }
  return result;
}

void sub_216764AEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    atomic_fetch_add((atomic_ullong *volatile)(a10 + 32), 0xFFFFFFFFFFFFFFF8);
  }
  __dmb(0xBu);
  _Unwind_Resume(a1);
}

uint64_t tbb::interface5::reader_writer_lock::scoped_lock_read::scoped_lock_read(uint64_t this)
{
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(this + 16) = 1;
  return this;
}

{
  *(void *)this = 0;
  *(void *)(this + 8) = 0;
  __dmb(0xBu);
  *(_DWORD *)(this + 16) = 1;
  return this;
}

atomic_ullong *tbb::interface5::reader_writer_lock::start_read(atomic_ullong *this, tbb::interface5::reader_writer_lock::scoped_lock_read *a2)
{
  uint64_t v3 = this;
LABEL_2:
  atomic_ullong v4 = *v3;
  while (1)
  {
    atomic_ullong v5 = v4;
    atomic_compare_exchange_strong(v3, (unint64_t *)&v5, (unint64_t)a2);
    if (v5 == v4) {
      break;
    }
    if (atomic_fetch_add_explicit(v3, 0, memory_order_relaxed) != v4)
    {
      this = (atomic_ullong *)sched_yield();
      goto LABEL_2;
    }
  }
  *((void *)a2 + 1) = v4;
  if (!v4)
  {
LABEL_7:
    atomic_ullong v6 = v3[4];
    __dmb(0xBu);
    while (1)
    {
      atomic_ullong v7 = v6;
      atomic_compare_exchange_strong(v3 + 4, (unint64_t *)&v7, v6 | 4);
      if (v7 == v6) {
        break;
      }
      if (atomic_fetch_add_explicit(v3 + 4, 0, memory_order_relaxed) != v6)
      {
        this = (atomic_ullong *)sched_yield();
        goto LABEL_7;
      }
    }
    if ((v6 & 3) == 0)
    {
      atomic_fetch_add(v3 + 4, 4uLL);
      atomic_ullong v8 = v3[4];
      __dmb(0xBu);
      if (v8)
      {
        atomic_ullong v9 = v3[4];
        __dmb(0xBu);
        if ((v9 & 2) == 0)
        {
LABEL_14:
          atomic_ullong v10 = v3[4];
          while (1)
          {
            atomic_ullong v11 = v10;
            atomic_compare_exchange_strong(v3 + 4, (unint64_t *)&v11, v10 | 2);
            if (v11 == v10) {
              break;
            }
            if (atomic_fetch_add_explicit(v3 + 4, 0, memory_order_relaxed) != v10)
            {
              this = (atomic_ullong *)sched_yield();
              goto LABEL_14;
            }
          }
        }
      }
LABEL_18:
      atomic_ullong v12 = *v3;
      while (1)
      {
        atomic_ullong v13 = v12;
        atomic_compare_exchange_strong(v3, (unint64_t *)&v13, 0);
        if (v13 == v12) {
          break;
        }
        if (atomic_fetch_add_explicit(v3, 0, memory_order_relaxed) != v12)
        {
          this = (atomic_ullong *)sched_yield();
          goto LABEL_18;
        }
      }
      __dmb(0xBu);
      *(_DWORD *)(v12 + 16) = 2;
    }
  }
  while (1)
  {
    int v14 = *((_DWORD *)a2 + 4);
    __dmb(0xBu);
    if (v14 != 1) {
      break;
    }
    this = (atomic_ullong *)sched_yield();
  }
  if (*((void *)a2 + 1))
  {
    atomic_fetch_add(v3 + 4, 8uLL);
    uint64_t v15 = *((void *)a2 + 1);
    __dmb(0xBu);
    *(_DWORD *)(v15 + 16) = 2;
  }
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::try_lock_read(tbb::interface5::reader_writer_lock *this)
{
  unint64_t v2 = (_opaque_pthread_t *)*((void *)this + 3);
  if (v2 == tbb::internal::thread_get_id_v3()) {
    return 0;
  }
  if ((atomic_fetch_add((atomic_ullong *volatile)this + 4, 8uLL) & 3) == 0) {
    return 1;
  }
  uint64_t result = 0;
  atomic_fetch_add((atomic_ullong *volatile)this + 4, 0xFFFFFFFFFFFFFFF8);
  return result;
}

atomic_ullong *tbb::interface5::reader_writer_lock::unblock_readers(atomic_ullong *this)
{
  pthread_t v1 = this;
  atomic_fetch_add(this + 4, 4uLL);
  atomic_ullong v2 = this[4];
  __dmb(0xBu);
  if (v2)
  {
    atomic_ullong v3 = this[4];
    __dmb(0xBu);
    if ((v3 & 2) == 0)
    {
LABEL_3:
      atomic_ullong v4 = v1[4];
      while (1)
      {
        atomic_ullong v5 = v4;
        atomic_compare_exchange_strong(v1 + 4, (unint64_t *)&v5, v4 | 2);
        if (v5 == v4) {
          break;
        }
        if (atomic_fetch_add_explicit(v1 + 4, 0, memory_order_relaxed) != v4)
        {
          this = (atomic_ullong *)sched_yield();
          goto LABEL_3;
        }
      }
    }
  }
LABEL_7:
  atomic_ullong v6 = *v1;
  while (1)
  {
    atomic_ullong v7 = v6;
    atomic_compare_exchange_strong(v1, (unint64_t *)&v7, 0);
    if (v7 == v6) {
      break;
    }
    if (atomic_fetch_add_explicit(v1, 0, memory_order_relaxed) != v6)
    {
      this = (atomic_ullong *)sched_yield();
      goto LABEL_7;
    }
  }
  __dmb(0xBu);
  *(_DWORD *)(v6 + 16) = 2;
  return this;
}

void tbb::interface5::reader_writer_lock::unlock(tbb::interface5::reader_writer_lock *this)
{
  if (*((void *)this + 3))
  {
    pthread_t v1 = (tbb::interface5::reader_writer_lock::scoped_lock *)*((void *)this + 1);
    __dmb(0xBu);
    tbb::interface5::reader_writer_lock::end_write(this, v1);
    if (v1)
    {
      if (*(void *)v1) {
        tbb::interface5::reader_writer_lock::end_write(*(tbb::interface5::reader_writer_lock **)v1, v1);
      }
      __dmb(0xBu);
      *((_DWORD *)v1 + 4) = 3;
      tbb::internal::deallocate_via_handler_v3((uint64_t)v1, v2);
    }
  }
  else
  {
    atomic_fetch_add((atomic_ullong *volatile)this + 4, 0xFFFFFFFFFFFFFFF8);
  }
}

void tbb::interface5::reader_writer_lock::end_write(tbb::interface5::reader_writer_lock *this, tbb::interface5::reader_writer_lock::scoped_lock *a2)
{
  *((void *)this + 3) = 0;
  uint64_t v3 = *((void *)a2 + 1);
  if (v3)
  {
    __dmb(0xBu);
    *((void *)this + 1) = v3;
    uint64_t v4 = *((void *)this + 1);
    __dmb(0xBu);
    __dmb(0xBu);
    *(_DWORD *)(v4 + 16) = 2;
  }
  else
  {
LABEL_4:
    uint64_t v6 = *((void *)this + 4);
    __dmb(0xBu);
    while (1)
    {
      uint64_t v7 = v6;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 4, (unint64_t *)&v7, v6 & 0xFFFFFFFFFFFFFFFCLL);
      if (v7 == v6) {
        break;
      }
      if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 4, 0, memory_order_relaxed) != v6)
      {
        sched_yield();
        goto LABEL_4;
      }
    }
    if ((v6 & 4) != 0)
    {
      atomic_fetch_add((atomic_ullong *volatile)this + 4, 4uLL);
      uint64_t v8 = *((void *)this + 4);
      __dmb(0xBu);
      if (v8)
      {
        uint64_t v9 = *((void *)this + 4);
        __dmb(0xBu);
        if ((v9 & 2) == 0)
        {
LABEL_11:
          uint64_t v10 = *((void *)this + 4);
          while (1)
          {
            uint64_t v11 = v10;
            atomic_compare_exchange_strong((atomic_ullong *volatile)this + 4, (unint64_t *)&v11, v10 | 2);
            if (v11 == v10) {
              break;
            }
            if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 4, 0, memory_order_relaxed) != v10)
            {
              sched_yield();
              goto LABEL_11;
            }
          }
        }
      }
LABEL_15:
      uint64_t v12 = *(void *)this;
      while (1)
      {
        uint64_t v13 = v12;
        atomic_compare_exchange_strong((atomic_ullong *volatile)this, (unint64_t *)&v13, 0);
        if (v13 == v12) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)this, 0, memory_order_relaxed) != v12)
        {
          sched_yield();
          goto LABEL_15;
        }
      }
      __dmb(0xBu);
      *(_DWORD *)(v12 + 16) = 2;
    }
LABEL_20:
    uint64_t v14 = *((void *)this + 1);
    while (1)
    {
      uint64_t v15 = v14;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 1, (unint64_t *)&v15, 0);
      if (v15 == v14) {
        break;
      }
      if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 1, 0, memory_order_relaxed) != v14)
      {
        sched_yield();
        goto LABEL_20;
      }
    }
    while (1)
    {
      uint64_t v17 = a2;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 2, (unint64_t *)&v17, 0);
      if (v17 == a2) {
        break;
      }
      unint64_t add_explicit = (tbb::interface5::reader_writer_lock::scoped_lock *)atomic_fetch_add_explicit((atomic_ullong *volatile)this + 2, 0, memory_order_relaxed);
      if (add_explicit != a2) {
        goto LABEL_27;
      }
    }
    unint64_t add_explicit = a2;
LABEL_27:
    if (add_explicit != a2)
    {
      for (uint64_t i = (tbb::interface5::reader_writer_lock::scoped_lock *)*((void *)a2 + 1);
            !i;
            uint64_t i = (tbb::interface5::reader_writer_lock::scoped_lock *)*((void *)a2 + 1))
      {
        sched_yield();
      }
      tbb::interface5::reader_writer_lock::set_next_writer(this, i);
    }
  }
}

uint64_t tbb::interface5::reader_writer_lock::end_read(uint64_t this)
{
  return this;
}

uint64_t tbb::interface5::reader_writer_lock::scoped_lock::internal_construct(tbb::interface5::reader_writer_lock::scoped_lock *this, tbb::interface5::reader_writer_lock *a2)
{
  *(void *)this = a2;
  *((void *)this + 1) = 0;
  __dmb(0xBu);
  *((_DWORD *)this + 4) = 1;
  uint64_t v3 = *(_opaque_pthread_t **)(*(void *)this + 24);
  if (v3 == tbb::internal::thread_get_id_v3())
  {
    return tbb::internal::throw_exception_v4(9);
  }
  else
  {
    uint64_t v4 = *(atomic_ullong **)this;
    return tbb::interface5::reader_writer_lock::start_write(v4, this);
  }
}

atomic_ullong *tbb::interface5::reader_writer_lock::scoped_lock_read::internal_construct(tbb::interface5::reader_writer_lock::scoped_lock_read *this, tbb::interface5::reader_writer_lock *a2)
{
  *(void *)this = a2;
  *((void *)this + 1) = 0;
  __dmb(0xBu);
  *((_DWORD *)this + 4) = 1;
  uint64_t v3 = *(_opaque_pthread_t **)(*(void *)this + 24);
  if (v3 == tbb::internal::thread_get_id_v3())
  {
    return (atomic_ullong *)tbb::internal::throw_exception_v4(9);
  }
  else
  {
    uint64_t v4 = *(atomic_ullong **)this;
    return tbb::interface5::reader_writer_lock::start_read(v4, this);
  }
}

void tbb::interface5::reader_writer_lock::scoped_lock::internal_destroy(tbb::interface5::reader_writer_lock **this)
{
  atomic_ullong v2 = *this;
  if (v2) {
    tbb::interface5::reader_writer_lock::end_write(v2, (tbb::interface5::reader_writer_lock::scoped_lock *)this);
  }
  __dmb(0xBu);
  *((_DWORD *)this + 4) = 3;
}

_DWORD *tbb::interface5::reader_writer_lock::scoped_lock_read::internal_destroy(_DWORD *this)
{
  if (*(void *)this) {
    atomic_fetch_add((atomic_ullong *volatile)(*(void *)this + 32), 0xFFFFFFFFFFFFFFF8);
  }
  __dmb(0xBu);
  this[4] = 3;
  return this;
}

uint64_t tbb::spin_rw_mutex_v3::internal_acquire_writer(atomic_ullong *this)
{
  while (1)
  {
    atomic_ullong v2 = *this;
    if ((*this & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      if ((v2 & 2) == 0)
      {
LABEL_6:
        atomic_ullong v3 = *this;
        unint64_t v4 = *this | 2;
        while (1)
        {
          atomic_ullong v5 = v3;
          atomic_compare_exchange_strong(this, (unint64_t *)&v5, v4);
          if (v5 == v3) {
            break;
          }
          if (atomic_fetch_add_explicit(this, 0, memory_order_relaxed) != v3)
          {
            sched_yield();
            goto LABEL_6;
          }
        }
      }
      goto LABEL_3;
    }
    atomic_ullong v6 = *this;
    while (1)
    {
      atomic_ullong v7 = v2;
      atomic_compare_exchange_strong(this, (unint64_t *)&v7, 1uLL);
      if (v7 == v2) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit(this, 0, memory_order_relaxed);
      if (add_explicit != v2)
      {
        atomic_ullong v6 = add_explicit;
        break;
      }
    }
    if (v6 == v2) {
      return 0;
    }
LABEL_3:
    sched_yield();
  }
}

atomic_ullong *tbb::spin_rw_mutex_v3::internal_release_writer(atomic_ullong *this)
{
  pthread_t v1 = this;
LABEL_2:
  atomic_ullong v2 = *v1;
  unint64_t v3 = *v1 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v4 = v2;
    atomic_compare_exchange_strong(v1, (unint64_t *)&v4, v3);
    if (v4 == v2) {
      return this;
    }
    if (atomic_fetch_add_explicit(v1, 0, memory_order_relaxed) != v2)
    {
      this = (atomic_ullong *)sched_yield();
      goto LABEL_2;
    }
  }
}

atomic_ullong *tbb::spin_rw_mutex_v3::internal_acquire_reader(atomic_ullong *this)
{
  pthread_t v1 = this;
  while (1)
  {
    if ((*(unsigned char *)v1 & 3) != 0) {
      goto LABEL_2;
    }
    if ((atomic_fetch_add(v1, 4uLL) & 1) == 0) {
      return this;
    }
    atomic_fetch_add(v1, 0xFFFFFFFFFFFFFFFCLL);
LABEL_2:
    this = (atomic_ullong *)sched_yield();
  }
}

uint64_t tbb::spin_rw_mutex_v3::internal_upgrade(atomic_ullong *this)
{
  atomic_ullong v2 = *this;
  do
  {
    BOOL v3 = (v2 & 2) == 0 || (v2 & 0xFFFFFFFFFFFFFFFCLL) == 4;
    uint64_t v4 = v3;
    if (!v3)
    {
      atomic_fetch_add(this, 0xFFFFFFFFFFFFFFFCLL);
      while (1)
      {
        atomic_ullong v9 = *this;
        if ((*this & 0xFFFFFFFFFFFFFFFDLL) != 0)
        {
          if ((v9 & 2) == 0)
          {
LABEL_23:
            atomic_ullong v10 = *this;
            unint64_t v11 = *this | 2;
            while (1)
            {
              atomic_ullong v12 = v10;
              atomic_compare_exchange_strong(this, (unint64_t *)&v12, v11);
              if (v12 == v10) {
                break;
              }
              if (atomic_fetch_add_explicit(this, 0, memory_order_relaxed) != v10)
              {
                sched_yield();
                goto LABEL_23;
              }
            }
          }
        }
        else
        {
          atomic_ullong v13 = *this;
          while (1)
          {
            atomic_ullong v14 = v9;
            atomic_compare_exchange_strong(this, (unint64_t *)&v14, 1uLL);
            if (v14 == v9) {
              break;
            }
            unint64_t add_explicit = atomic_fetch_add_explicit(this, 0, memory_order_relaxed);
            if (add_explicit != v9)
            {
              atomic_ullong v13 = add_explicit;
              break;
            }
          }
          if (v13 == v9) {
            return v4;
          }
        }
        sched_yield();
      }
    }
    atomic_ullong v5 = v2;
    while (1)
    {
      atomic_ullong v6 = v2;
      atomic_compare_exchange_strong(this, (unint64_t *)&v6, v2 | 3);
      if (v6 == v2) {
        break;
      }
      unint64_t v7 = atomic_fetch_add_explicit(this, 0, memory_order_relaxed);
      if (v7 != v2)
      {
        atomic_ullong v5 = v7;
        break;
      }
    }
    BOOL v3 = v5 == v2;
    atomic_ullong v2 = v5;
  }
  while (!v3);
  while ((*this & 0xFFFFFFFFFFFFFFFCLL) != 4)
    sched_yield();
  atomic_fetch_add(this, 0xFFFFFFFFFFFFFFFALL);
  return v4;
}

atomic_ullong *tbb::spin_rw_mutex_v3::internal_release_reader(atomic_ullong *this)
{
  return this;
}

atomic_ullong *tbb::spin_rw_mutex_v3::internal_downgrade(atomic_ullong *this)
{
  return this;
}

BOOL tbb::spin_rw_mutex_v3::internal_try_acquire_writer(atomic_ullong *this)
{
  atomic_ullong v1 = *this;
  if ((*this & 0xFFFFFFFFFFFFFFFDLL) != 0) {
    return 0;
  }
  unint64_t v2 = *this;
  while (1)
  {
    atomic_ullong v3 = v1;
    atomic_compare_exchange_strong(this, (unint64_t *)&v3, 1uLL);
    if (v3 == v1) {
      break;
    }
    unint64_t add_explicit = atomic_fetch_add_explicit(this, 0, memory_order_relaxed);
    if (add_explicit != v1)
    {
      unint64_t v2 = add_explicit;
      return v2 == v1;
    }
  }
  return v2 == v1;
}

uint64_t tbb::spin_rw_mutex_v3::internal_try_acquire_reader(atomic_ullong *this)
{
  if ((*(unsigned char *)this & 3) != 0) {
    return 0;
  }
  if ((atomic_fetch_add(this, 4uLL) & 1) == 0) {
    return 1;
  }
  uint64_t result = 0;
  atomic_fetch_add(this, 0xFFFFFFFFFFFFFFFCLL);
  return result;
}

void *tbb::spin_mutex::scoped_lock::internal_acquire(void *result, uint64_t a2)
{
  atomic_ullong v3 = result;
  uint64_t v4 = (atomic_uint *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  int v5 = 1 << (8 * (a2 & 3));
  int v6 = ~(255 << (8 * (a2 & 3)));
LABEL_2:
  int v7 = *v4 & v6;
  while (1)
  {
    int v8 = v7;
    atomic_compare_exchange_strong(v4, (unsigned int *)&v8, v7 | v5);
    if (v8 == v7) {
      break;
    }
    if (*v4 != v7)
    {
      uint64_t result = (void *)sched_yield();
      goto LABEL_2;
    }
  }
  *atomic_ullong v3 = a2;
  return result;
}

unsigned char **tbb::spin_mutex::scoped_lock::internal_release(unsigned char **this)
{
  atomic_ullong v1 = *this;
  __dmb(0xBu);
  *atomic_ullong v1 = 0;
  *this = 0;
  return this;
}

BOOL tbb::spin_mutex::scoped_lock::internal_try_acquire(void *a1, uint64_t a2)
{
  uint64_t v4 = (atomic_uint *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  int v5 = 255 << (8 * (a2 & 3));
  int v6 = 1 << (8 * (a2 & 3));
LABEL_2:
  int v7 = *v4 & ~v5;
  while (1)
  {
    int v8 = v7;
    atomic_compare_exchange_strong(v4, (unsigned int *)&v8, v7 | v6);
    BOOL result = v8 == v7;
    if (v8 == v7) {
      break;
    }
    if (*v4 != v7)
    {
      if ((*v4 & v5) != 0) {
        return result;
      }
      sched_yield();
      goto LABEL_2;
    }
  }
  *a1 = a2;
  return result;
}

tbb::internal *tbb::mutex::scoped_lock::internal_acquire(tbb::mutex::scoped_lock *this, pthread_mutex_t *a2)
{
  BOOL result = (tbb::internal *)pthread_mutex_lock(a2);
  if (result) {
    tbb::internal::handle_perror(result, "mutex::scoped_lock: pthread_mutex_lock failed", v5);
  }
  *(void *)this = a2;
  return result;
}

uint64_t tbb::mutex::scoped_lock::internal_release(pthread_mutex_t **this)
{
  uint64_t result = pthread_mutex_unlock(*this);
  *this = 0;
  return result;
}

BOOL tbb::mutex::scoped_lock::internal_try_acquire(tbb::mutex::scoped_lock *this, pthread_mutex_t *a2)
{
  int v4 = pthread_mutex_trylock(a2);
  if (!v4) {
    *(void *)this = a2;
  }
  return v4 == 0;
}

tbb::internal *tbb::mutex::internal_construct(pthread_mutex_t *this)
{
  uint64_t result = (tbb::internal *)pthread_mutex_init(this, 0);
  if (result)
  {
    tbb::internal::handle_perror(result, "mutex: pthread_mutex_init failed", v2);
  }
  return result;
}

tbb::internal *tbb::recursive_mutex::scoped_lock::internal_acquire(void *a1, pthread_mutex_t *a2)
{
  uint64_t result = (tbb::internal *)pthread_mutex_lock(a2);
  if (result) {
    tbb::internal::handle_perror(result, "recursive_mutex::scoped_lock: pthread_mutex_lock failed", v5);
  }
  *a1 = a2;
  return result;
}

uint64_t tbb::recursive_mutex::scoped_lock::internal_release(pthread_mutex_t **this)
{
  uint64_t result = pthread_mutex_unlock(*this);
  *this = 0;
  return result;
}

BOOL tbb::recursive_mutex::scoped_lock::internal_try_acquire(void *a1, pthread_mutex_t *a2)
{
  int v4 = pthread_mutex_trylock(a2);
  if (!v4) {
    *a1 = a2;
  }
  return v4 == 0;
}

uint64_t tbb::recursive_mutex::internal_construct(pthread_mutex_t *this)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  unint64_t v2 = (tbb::internal *)pthread_mutexattr_init(&v7);
  if (v2) {
    tbb::internal::handle_perror(v2, "recursive_mutex: pthread_mutexattr_init failed", v3);
  }
  pthread_mutexattr_settype(&v7, 2);
  int v4 = (tbb::internal *)pthread_mutex_init(this, &v7);
  if (v4) {
    tbb::internal::handle_perror(v4, "recursive_mutex: pthread_mutex_init failed", v5);
  }
  return pthread_mutexattr_destroy(&v7);
}

tbb::internal *tbb::internal::tbb_thread_v3::join(pthread_t *this, uint64_t a2, const char *a3)
{
  if (!*this) {
    tbb::internal::handle_perror((tbb::internal *)0x16, "tbb_thread::join", a3);
  }
  if (pthread_self() == *this) {
    tbb::internal::handle_perror((tbb::internal *)0xB, "tbb_thread::join", v4);
  }
  uint64_t result = (tbb::internal *)pthread_join(*this, 0);
  if (result) {
    tbb::internal::handle_perror(result, "pthread_join", v6);
  }
  *this = 0;
  return result;
}

tbb::internal *tbb::internal::tbb_thread_v3::detach(_opaque_pthread_t **this, uint64_t a2, const char *a3)
{
  int v4 = *this;
  if (!v4) {
    tbb::internal::handle_perror((tbb::internal *)0x16, "tbb_thread::detach", a3);
  }
  uint64_t result = (tbb::internal *)pthread_detach(v4);
  if (result) {
    tbb::internal::handle_perror(result, "pthread_detach", v6);
  }
  *this = 0;
  return result;
}

void sub_2167658FC()
{
  if (!pthread_detach(*v0)) {
    JUMPOUT(0x2167658DCLL);
  }
  JUMPOUT(0x2167658D0);
}

tbb::internal *tbb::internal::tbb_thread_v3::internal_start(tbb::internal::tbb_thread_v3 *this, void *(__cdecl *a2)(void *), void *a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  pthread_t v18 = 0;
  int v6 = (tbb::internal *)pthread_attr_init(&v19);
  if (v6) {
    tbb::internal::handle_perror(v6, "pthread_attr_init", v8);
  }
  size_t active = tbb::interface9::global_control::active_value((tbb::interface9::global_control *)1, v7, (uint64_t)v8, v9, v10);
  atomic_ullong v12 = (tbb::internal *)pthread_attr_setstacksize(&v19, active);
  if (v12) {
    tbb::internal::handle_perror(v12, "pthread_attr_setstacksize", v13);
  }
  atomic_ullong v14 = (tbb::internal *)pthread_create(&v18, &v19, a2, a3);
  if (v14) {
    tbb::internal::handle_perror(v14, "pthread_create", v15);
  }
  uint64_t result = (tbb::internal *)pthread_attr_destroy(&v19);
  if (result) {
    tbb::internal::handle_perror(result, "pthread_attr_destroy", v17);
  }
  *(void *)this = v18;
  return result;
}

uint64_t tbb::internal::tbb_thread_v3::hardware_concurrency(tbb::internal::tbb_thread_v3 *this)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  uint64_t result = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(void *)int v4 = 0x1900000006;
    int v3 = 0;
    size_t v2 = 4;
    sysctl(v4, 2u, &v3, &v2, 0, 0);
    if (v3 <= 1) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = v3;
    }
    tbb::internal::governor::DefaultNumberOfThreads = result;
  }
  return result;
}

void sub_216765A98(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_21675DB74(a1);
}

_opaque_pthread_t *tbb::internal::move_v3(_opaque_pthread_t **this, _opaque_pthread_t **a2, tbb::internal::tbb_thread_v3 *a3)
{
  uint64_t result = *this;
  if (result)
  {
    uint64_t result = (_opaque_pthread_t *)pthread_detach(result);
    if (result) {
      tbb::internal::handle_perror((tbb::internal *)result, "pthread_detach", v6);
    }
    *this = 0;
  }
  *this = *a2;
  *a2 = 0;
  return result;
}

uint64_t tbb::internal::thread_sleep_v3(uint64_t *a1)
{
  double v1 = (double)*a1 * 0.000001;
  v3.tv_sec = (uint64_t)v1;
  v3.tv_nsec = (uint64_t)((v1 - (double)(uint64_t)v1) * 1000000000.0);
  return nanosleep(&v3, 0);
}

uint64_t tbb::internal::concurrent_monitor::thread_context::init(tbb::internal::concurrent_monitor::thread_context *this)
{
  *((_DWORD *)this + 4) = 0;
  double v1 = (char *)this + 16;
  uint64_t result = semaphore_create(*MEMORY[0x263EF8960], (semaphore_t *)this + 4, 0, 0);
  v1[11] = 1;
  return result;
}

void tbb::internal::concurrent_monitor::~concurrent_monitor(tbb::internal::concurrent_monitor *this)
{
}

{
  __dmb(0xBu);
  tbb::internal::concurrent_monitor::abort_all_relaxed((uint64_t)this);
}

uint64_t tbb::internal::concurrent_monitor::prepare_wait(uint64_t this, tbb::internal::concurrent_monitor::thread_context *a2, uint64_t a3)
{
  uint64_t v5 = this;
  if (*((unsigned char *)a2 + 27))
  {
    if (*((unsigned char *)a2 + 25))
    {
      *((unsigned char *)a2 + 25) = 0;
      do
        this = MEMORY[0x21D448B00](*((unsigned int *)a2 + 4));
      while (this == 14);
    }
  }
  else
  {
    this = tbb::internal::concurrent_monitor::thread_context::init(a2);
  }
  *((void *)a2 + 4) = a3;
  __dmb(0xBu);
  *((unsigned char *)a2 + 24) = 1;
  int v6 = (atomic_uint *)((v5 + 1) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_8:
  int v7 = *v6 & ~(255 << (8 * ((v5 + 1) & 3)));
  while (1)
  {
    int v8 = v7;
    atomic_compare_exchange_strong(v6, (unsigned int *)&v8, v7 | (1 << (8 * ((v5 + 1) & 3))));
    if (v8 == v7) {
      break;
    }
    if (*v6 != v7)
    {
      this = sched_yield();
      goto LABEL_8;
    }
  }
  *((_DWORD *)a2 + 5) = *(_DWORD *)(v5 + 32);
  ++*(void *)(v5 + 8);
  uint64_t v9 = *(void *)(v5 + 24);
  *(void *)a2 = v5 + 16;
  *((void *)a2 + 1) = v9;
  **(void **)(v5 + 24) = a2;
  *(void *)(v5 + 24) = a2;
  __dmb(0xBu);
  *(unsigned char *)(v5 + 1) = 0;
  __dmb(0xBu);
  return this;
}

uint64_t tbb::internal::concurrent_monitor::cancel_wait(uint64_t this, tbb::internal::concurrent_monitor::thread_context *a2)
{
  *((unsigned char *)a2 + 25) = 1;
  char v2 = *((unsigned char *)a2 + 24);
  __dmb(0xBu);
  if (v2)
  {
    uint64_t v4 = this;
    uint64_t v5 = (unsigned char *)(this + 1);
    int v6 = (atomic_uint *)((this + 1) & 0xFFFFFFFFFFFFFFFCLL);
    int v7 = 1 << (8 * ((this + 1) & 3));
    int v8 = ~(255 << (8 * ((this + 1) & 3)));
LABEL_3:
    int v9 = *v6 & v8;
    while (1)
    {
      int v10 = v9;
      atomic_compare_exchange_strong(v6, (unsigned int *)&v10, v9 | v7);
      if (v10 == v9) {
        break;
      }
      if (*v6 != v9)
      {
        this = sched_yield();
        goto LABEL_3;
      }
    }
    char v11 = *((unsigned char *)a2 + 24);
    __dmb(0xBu);
    if (v11)
    {
      --*(void *)(v4 + 8);
      atomic_ullong v12 = (void *)*((void *)a2 + 1);
      *atomic_ullong v12 = *(void *)a2;
      *(void *)(*(void *)a2 + 8) = v12;
      __dmb(0xBu);
      *((unsigned char *)a2 + 24) = 0;
      *((unsigned char *)a2 + 25) = 0;
    }
    __dmb(0xBu);
    *uint64_t v5 = 0;
  }
  return this;
}

uint64_t tbb::internal::concurrent_monitor::notify_one_relaxed(uint64_t this)
{
  if (*(void *)(this + 8))
  {
    uint64_t v1 = this;
    char v2 = (unsigned char *)(this + 1);
    timespec v3 = (atomic_uint *)((this + 1) & 0xFFFFFFFFFFFFFFFCLL);
    int v4 = 1 << (8 * ((this + 1) & 3));
    int v5 = ~(255 << (8 * ((this + 1) & 3)));
LABEL_3:
    int v6 = *v3 & v5;
    while (1)
    {
      int v7 = v6;
      atomic_compare_exchange_strong(v3, (unsigned int *)&v7, v6 | v4);
      if (v7 == v6) {
        break;
      }
      if (*v3 != v6)
      {
        this = sched_yield();
        goto LABEL_3;
      }
    }
    uint64_t v8 = *(void *)(v1 + 16);
    ++*(_DWORD *)(v1 + 32);
    if (v8 != v1 + 16)
    {
      --*(void *)(v1 + 8);
      int v9 = *(void **)(v8 + 8);
      *int v9 = *(void *)v8;
      *(void *)(*(void *)v8 + 8) = v9;
      __dmb(0xBu);
      *(unsigned char *)(v8 + 24) = 0;
      __dmb(0xBu);
      *(unsigned char *)(v1 + 1) = 0;
      JUMPOUT(0x21D448AF0);
    }
    __dmb(0xBu);
    *char v2 = 0;
  }
  return this;
}

uint64_t tbb::internal::concurrent_monitor::notify_all_relaxed(uint64_t this)
{
  if (*(void *)(this + 8))
  {
    uint64_t v1 = this;
    *(void *)&long long v13 = &v13;
    *((void *)&v13 + 1) = &v13;
    char v2 = (unsigned char *)(this + 1);
    timespec v3 = (atomic_uint *)((this + 1) & 0xFFFFFFFFFFFFFFFCLL);
    int v4 = 1 << (8 * ((this + 1) & 3));
    int v5 = ~(255 << (8 * ((this + 1) & 3)));
LABEL_3:
    int v6 = *v3 & v5;
    while (1)
    {
      int v7 = v6;
      atomic_compare_exchange_strong(v3, (unsigned int *)&v7, v6 | v4);
      if (v7 == v6) {
        break;
      }
      if (*v3 != v6)
      {
        this = sched_yield();
        goto LABEL_3;
      }
    }
    ++*(_DWORD *)(v1 + 32);
    if (*(void *)(v1 + 8))
    {
      long long v9 = *(_OWORD *)(v1 + 16);
      uint64_t v8 = v1 + 16;
      long long v13 = v9;
      *(void *)(v9 + 8) = &v13;
      **(void **)(v8 + 8) = &v13;
      *(void *)uint64_t v8 = v8;
      *(void *)(v8 + 8) = v8;
      *(void *)(v8 - 8) = 0;
    }
    for (uint64_t i = (long long *)v13; i != &v13; uint64_t i = *(long long **)i)
    {
      __dmb(0xBu);
      *((unsigned char *)i + 24) = 0;
    }
    __dmb(0xBu);
    *char v2 = 0;
    char v11 = (long long *)v13;
    if ((long long *)v13 != &v13)
    {
      do
      {
        atomic_ullong v12 = *(long long **)v11;
        this = MEMORY[0x21D448AF0](*((unsigned int *)v11 + 4));
        char v11 = v12;
      }
      while (v12 != &v13);
    }
  }
  return this;
}

uint64_t tbb::internal::concurrent_monitor::abort_all_relaxed(uint64_t this)
{
  if (*(void *)(this + 8))
  {
    uint64_t v1 = this;
    *(void *)&long long v13 = &v13;
    *((void *)&v13 + 1) = &v13;
    char v2 = (unsigned char *)(this + 1);
    timespec v3 = (atomic_uint *)((this + 1) & 0xFFFFFFFFFFFFFFFCLL);
    int v4 = 1 << (8 * ((this + 1) & 3));
    int v5 = ~(255 << (8 * ((this + 1) & 3)));
LABEL_3:
    int v6 = *v3 & v5;
    while (1)
    {
      int v7 = v6;
      atomic_compare_exchange_strong(v3, (unsigned int *)&v7, v6 | v4);
      if (v7 == v6) {
        break;
      }
      if (*v3 != v6)
      {
        this = sched_yield();
        goto LABEL_3;
      }
    }
    ++*(_DWORD *)(v1 + 32);
    if (*(void *)(v1 + 8))
    {
      long long v9 = *(_OWORD *)(v1 + 16);
      uint64_t v8 = v1 + 16;
      long long v13 = v9;
      *(void *)(v9 + 8) = &v13;
      **(void **)(v8 + 8) = &v13;
      *(void *)uint64_t v8 = v8;
      *(void *)(v8 + 8) = v8;
      *(void *)(v8 - 8) = 0;
    }
    for (uint64_t i = (long long *)v13; i != &v13; uint64_t i = *(long long **)i)
    {
      __dmb(0xBu);
      *((unsigned char *)i + 24) = 0;
    }
    __dmb(0xBu);
    *char v2 = 0;
    char v11 = (long long *)v13;
    if ((long long *)v13 != &v13)
    {
      do
      {
        atomic_ullong v12 = *(long long **)v11;
        *((unsigned char *)v11 + 26) = 1;
        this = MEMORY[0x21D448AF0](*((unsigned int *)v11 + 4));
        char v11 = v12;
      }
      while (v12 != &v13);
    }
  }
  return this;
}

uint64_t rml::internal::thread_monitor::join(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  uint64_t result = pthread_join(this, 0);
  if (result)
  {
    timespec v3 = (FILE *)*MEMORY[0x263EF8348];
    int v4 = strerror(result);
    fprintf(v3, "thread_monitor %s in %s\n", v4, "pthread_join");
    exit(1);
  }
  return result;
}

uint64_t rml::internal::thread_monitor::detach_thread(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  uint64_t result = pthread_detach(this);
  if (result)
  {
    timespec v3 = (FILE *)*MEMORY[0x263EF8348];
    int v4 = strerror(result);
    fprintf(v3, "thread_monitor %s in %s\n", v4, "pthread_detach");
    exit(1);
  }
  return result;
}

uint64_t tbb::internal::rml::private_worker::thread_routine(tbb::internal::rml::private_worker *this, void *a2)
{
  return 0;
}

uint64_t tbb::internal::rml::private_worker::run(tbb::internal::rml::private_worker *this)
{
  char v2 = (tbb::internal::rml::private_server *)*((void *)this + 1);
  uint64_t v3 = *((void *)v2 + 6);
  __dmb(0xBu);
  if (v3) {
    tbb::internal::rml::private_server::wake_some(v2, 0);
  }
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)this + 2) + 24))(*((void *)this + 2));
  uint64_t v5 = v4;
  int v6 = *(_DWORD *)this;
  __dmb(0xBu);
  if (v6 != 3)
  {
    int v10 = (unsigned __int8 *)this + 40;
    char v11 = (atomic_uint *)(((unint64_t)this + 40) & 0xFFFFFFFFFFFFFFFCLL);
    char v12 = 8 * (((_BYTE)this + 40) & 3);
    int v13 = 255 << v12;
    int v14 = ~(255 << v12);
    uint64_t v40 = v4;
    do
    {
      int v16 = *(_DWORD *)(*((void *)this + 1) + 32);
      __dmb(0xBu);
      if (v16 < 0)
      {
        if (*((unsigned char *)this + 41))
        {
          *((unsigned char *)this + 41) = 0;
          while (MEMORY[0x21D448B00](*((unsigned int *)this + 11)) == 14)
            ;
        }
        uint64_t v17 = *((void *)this + 4);
        __dmb(0xBu);
        uint64_t v41 = v17;
        __dmb(0xBu);
        *((unsigned char *)this + 40) = 1;
        __dmb(0xBu);
        LODWORD(v17) = *(_DWORD *)this;
        __dmb(0xBu);
        if (v17 != 3)
        {
          uint64_t v18 = *((void *)this + 1);
          pthread_attr_t v19 = (atomic_uint *)((v18 + 56) & 0xFFFFFFFFFFFFFFFCLL);
          int v20 = 255 << (8 * ((v18 + 56) & 3));
          int v21 = ~v20;
LABEL_17:
          int v22 = *v19 & v21;
          while (1)
          {
            int v23 = v22;
            atomic_compare_exchange_strong(v19, (unsigned int *)&v23, v22 | (1 << (8 * ((v18 + 56) & 3))));
            if (v23 == v22) {
              break;
            }
            if (*v19 != v22)
            {
              if ((*v19 & v20) != 0) {
                goto LABEL_25;
              }
              int v39 = v20;
              sched_yield();
              int v20 = v39;
              goto LABEL_17;
            }
          }
          if ((atomic_fetch_add((atomic_uint *volatile)(v18 + 32), 1u) & 0x80000000) != 0)
          {
            uint64_t v29 = *(void *)(v18 + 48);
            __dmb(0xBu);
            *((void *)this + 7) = v29;
            __dmb(0xBu);
            *(void *)(v18 + 48) = this;
            __dmb(0xBu);
            *(unsigned char *)(v18 + 56) = 0;
            uint64_t v30 = v41;
            __dmb(0xBu);
            uint64_t v31 = *((void *)this + 4);
            __dmb(0xBu);
            if (v30 == v31)
            {
              uint64_t v5 = v40;
              while (MEMORY[0x21D448B00](*((unsigned int *)this + 11)) == 14)
                ;
            }
            else
            {
              while (2)
              {
                int v32 = *v10;
                int v33 = v32 << v12;
LABEL_39:
                unsigned int v34 = *v11 & v14;
                int v35 = v34 | v33;
                while (1)
                {
                  int v36 = v34 | v33;
                  atomic_compare_exchange_strong(v11, (unsigned int *)&v36, v34);
                  if (v36 == v35) {
                    break;
                  }
                  if (*v11 != v35)
                  {
                    if (((*v11 ^ v35) & v13) == 0)
                    {
                      sched_yield();
                      goto LABEL_39;
                    }
                    int v35 = *v11;
                    break;
                  }
                }
                if (v32 != ((v35 & v13) >> v12))
                {
                  sched_yield();
                  continue;
                }
                break;
              }
              *((unsigned char *)this + 41) = (v32 & 1) == 0;
              uint64_t v5 = v40;
            }
            uint64_t v37 = (tbb::internal::rml::private_server *)*((void *)this + 1);
            uint64_t v38 = *((void *)v37 + 6);
            __dmb(0xBu);
            if (v38) {
              tbb::internal::rml::private_server::wake_some(v37, 0);
            }
            goto LABEL_10;
          }
          atomic_fetch_add((atomic_uint *volatile)(v18 + 32), 0xFFFFFFFF);
          __dmb(0xBu);
          *(unsigned char *)(v18 + 56) = 0;
        }
LABEL_25:
        while (2)
        {
          int v24 = *v10;
          int v25 = v24 << v12;
LABEL_26:
          unsigned int v26 = *v11 & v14;
          int v27 = v26 | v25;
          while (1)
          {
            int v28 = v26 | v25;
            atomic_compare_exchange_strong(v11, (unsigned int *)&v28, v26);
            if (v28 == v27) {
              break;
            }
            if (*v11 != v27)
            {
              if (((*v11 ^ v27) & v13) == 0)
              {
                sched_yield();
                goto LABEL_26;
              }
              int v27 = *v11;
              break;
            }
          }
          if (v24 != ((v27 & v13) >> v12))
          {
            sched_yield();
            continue;
          }
          break;
        }
        *((unsigned char *)this + 41) = (v24 & 1) == 0;
        uint64_t v5 = v40;
      }
      else
      {
        (*(void (**)(void, uint64_t))(**((void **)this + 2) + 56))(*((void *)this + 2), v5);
      }
LABEL_10:
      int v15 = *(_DWORD *)this;
      __dmb(0xBu);
    }
    while (v15 != 3);
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(**((void **)this + 2) + 48))(*((void *)this + 2), v5);
  atomic_fetch_add((atomic_uint *volatile)(*((void *)this + 1) + 32), 1u);
  uint64_t v8 = (atomic_uint *)*((void *)this + 1);
  if (atomic_fetch_add(v8 + 9, 0xFFFFFFFF) == 1)
  {
    (*(void (**)(void))(**((void **)v8 + 1) + 32))(*((void *)v8 + 1));
    (*(void (**)(atomic_uint *))(*(void *)v8 + 48))(v8);
    return tbb::internal::NFS_Free((tbb::internal *)v8, v9);
  }
  return result;
}

uint64_t tbb::internal::rml::private_worker::release_handle(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  if (a2)
  {
    uint64_t result = pthread_join(this, 0);
    if (result)
    {
      uint64_t v3 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v4 = strerror(result);
      uint64_t v5 = "pthread_join";
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t result = pthread_detach(this);
    if (result)
    {
      uint64_t v3 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v4 = strerror(result);
      uint64_t v5 = "pthread_detach";
LABEL_7:
      fprintf(v3, "thread_monitor %s in %s\n", v4, v5);
      exit(1);
    }
  }
  return result;
}

uint64_t tbb::internal::rml::private_worker::start_shutdown(uint64_t this)
{
  uint64_t v1 = this;
LABEL_2:
  atomic_uint v2 = *(_DWORD *)this;
  __dmb(0xBu);
  while (1)
  {
    atomic_uint v3 = v2;
    atomic_compare_exchange_strong((atomic_uint *volatile)this, (unsigned int *)&v3, 3u);
    if (v3 == v2) {
      break;
    }
    if (*(_DWORD *)this != v2) {
      goto LABEL_2;
    }
  }
  if ((v2 - 1) > 1)
  {
    if (!v2)
    {
      int v13 = *(atomic_uint **)(this + 8);
      if (atomic_fetch_add(v13 + 9, 0xFFFFFFFF) == 1)
      {
        (*(void (**)(void))(**((void **)v13 + 1) + 32))(*((void *)v13 + 1));
        (*(void (**)(atomic_uint *))(*(void *)v13 + 48))(v13);
        return tbb::internal::NFS_Free((tbb::internal *)v13, v14);
      }
    }
  }
  else
  {
    uint64_t v4 = *(void *)(this + 32);
    __dmb(0xBu);
    __dmb(0xBu);
    *(void *)(this + 32) = v4 + 1;
    uint64_t v5 = (atomic_uint *)((this + 40) & 0xFFFFFFFFFFFFFFFCLL);
    char v6 = 8 * ((this + 40) & 3);
    int v7 = 255 << v6;
    while (2)
    {
      int v8 = *(unsigned __int8 *)(v1 + 40);
      int v9 = v8 << v6;
LABEL_9:
      unsigned int v10 = *v5 & ~v7;
      int v11 = v10 | v9;
      while (1)
      {
        int v12 = v10 | v9;
        atomic_compare_exchange_strong(v5, (unsigned int *)&v12, v10);
        if (v12 == v11) {
          break;
        }
        if (*v5 != v11)
        {
          if (((*v5 ^ v11) & v7) == 0)
          {
            this = sched_yield();
            goto LABEL_9;
          }
          int v11 = *v5;
          break;
        }
      }
      if (v8 != ((v11 & v7) >> v6))
      {
        this = sched_yield();
        continue;
      }
      break;
    }
    if (v8) {
      this = MEMORY[0x21D448AF0](*(unsigned int *)(v1 + 44));
    }
    if (v2 == 2)
    {
      int v15 = *(_opaque_pthread_t **)(v1 + 48);
      does_client_join_workers = (_opaque_pthread_t *)tbb::internal::governor::does_client_join_workers(*(void *)(v1 + 16));
      return tbb::internal::rml::private_worker::release_handle(v15, does_client_join_workers);
    }
  }
  return this;
}

uint64_t tbb::internal::rml::private_server::private_server(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C746728;
  *(void *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 56) = 0;
  int v4 = *(_DWORD *)(a1 + 16) + 1;
  __dmb(0xBu);
  *(_DWORD *)(a1 + 36) = v4;
  __dmb(0xBu);
  *(_DWORD *)(a1 + 32) = 0;
  __dmb(0xBu);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = tbb::internal::NFS_Allocate(*(unsigned int *)(a1 + 16), 128, 0, v5);
  if (*(_DWORD *)(a1 + 16))
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    int v8 = (task_t *)MEMORY[0x263EF8960];
    do
    {
      uint64_t v9 = *(void *)(a1 + 40) + v6;
      *(void *)(v9 + 8) = a1;
      *(void *)(v9 + 16) = a2;
      *(void *)(v9 + 24) = v7;
      *(unsigned char *)(v9 + 41) = 0;
      *(_DWORD *)(v9 + 44) = 0;
      semaphore_create(*v8, (semaphore_t *)(v9 + 44), 0, 0);
      __dmb(0xBu);
      *(void *)(v9 + 32) = 0;
      __dmb(0xBu);
      *(unsigned char *)(v9 + 40) = 0;
      *(void *)(v9 + 48) = 0;
      *(void *)(v9 + 56) = 0;
      __dmb(0xBu);
      *(_DWORD *)uint64_t v9 = 0;
      uint64_t v10 = *(void *)(a1 + 48);
      __dmb(0xBu);
      *(void *)(v9 + 56) = v10;
      __dmb(0xBu);
      *(void *)(a1 + 48) = v9;
      ++v7;
      v6 += 128;
    }
    while (v7 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

void tbb::internal::rml::private_server::~private_server(tbb::internal::rml::private_server *this, void *a2)
{
  *(void *)this = &unk_26C746728;
  unint64_t v3 = ((unint64_t)*((unsigned int *)this + 4) << 7) - 84;
  int v4 = (task_t *)MEMORY[0x263EF8960];
  while (1)
  {
    unint64_t v5 = v3 - 128;
    if (v3 == -84) {
      break;
    }
    semaphore_destroy(*v4, *(_DWORD *)(*((void *)this + 5) + v3));
    unint64_t v3 = v5;
  }
  tbb::internal::NFS_Free(*((tbb::internal **)this + 5), a2);
}

{
  unint64_t v3;
  task_t *v4;
  unint64_t v5;

  *(void *)this = &unk_26C746728;
  unint64_t v3 = ((unint64_t)*((unsigned int *)this + 4) << 7) - 84;
  int v4 = (task_t *)MEMORY[0x263EF8960];
  while (1)
  {
    unint64_t v5 = v3 - 128;
    if (v3 == -84) {
      break;
    }
    semaphore_destroy(*v4, *(_DWORD *)(*((void *)this + 5) + v3));
    unint64_t v3 = v5;
  }
  tbb::internal::NFS_Free(*((tbb::internal **)this + 5), a2);
}

{
  unint64_t v3;
  task_t *v4;
  unint64_t v5;
  uint64_t vars8;

  *(void *)this = &unk_26C746728;
  unint64_t v3 = ((unint64_t)*((unsigned int *)this + 4) << 7) - 84;
  int v4 = (task_t *)MEMORY[0x263EF8960];
  while (1)
  {
    unint64_t v5 = v3 - 128;
    if (v3 == -84) {
      break;
    }
    semaphore_destroy(*v4, *(_DWORD *)(*((void *)this + 5) + v3));
    unint64_t v3 = v5;
  }
  tbb::internal::NFS_Free(*((tbb::internal **)this + 5), a2);

  operator delete(this);
}

pthread_t tbb::internal::rml::private_server::wake_some(pthread_t this, signed int a2)
{
  uint64_t v3 = (uint64_t)this;
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  int v4 = &this->__opaque[40];
  unint64_t v5 = (atomic_uint *)((unint64_t)&this->__opaque[40] & 0xFFFFFFFFFFFFFFFCLL);
  int v6 = 1 << (8 * (((_BYTE)this + 56) & 3));
  int v7 = ~(255 << (8 * (((_BYTE)this + 56) & 3)));
LABEL_2:
  int v8 = *v5 & v7;
  while (1)
  {
    int v9 = v8;
    atomic_compare_exchange_strong(v5, (unsigned int *)&v9, v8 | v6);
    if (v9 == v8) {
      break;
    }
    if (*v5 != v8)
    {
      this = (pthread_t)sched_yield();
      goto LABEL_2;
    }
  }
  uint64_t v10 = *(void *)(v3 + 48);
  __dmb(0xBu);
  if (!v10)
  {
    int v14 = &v22;
LABEL_16:
    if (!a2) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  int v11 = *(_DWORD *)(v3 + 32);
  __dmb(0xBu);
  if (a2 <= 0)
  {
    if (v11 < 1)
    {
      int v14 = &v22;
      goto LABEL_25;
    }
    while (1)
    {
      int v19 = v11;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v3 + 32), (unsigned int *)&v19, v11 - 1);
      if (v19 == v11) {
        break;
      }
      if (*(_DWORD *)(v3 + 32) != v11)
      {
        int v11 = *(_DWORD *)(v3 + 32);
        __dmb(0xBu);
        int v14 = &v22;
        if (v11 <= 0) {
          goto LABEL_25;
        }
      }
    }
  }
  else
  {
    if (v11 + a2 < 1)
    {
      int v14 = &v22;
      goto LABEL_24;
    }
    --a2;
  }
  uint64_t v12 = *(void *)(v3 + 48);
  __dmb(0xBu);
  uint64_t v22 = v12;
  uint64_t v13 = *(void *)(v12 + 56);
  __dmb(0xBu);
  *(void *)(v3 + 48) = v13;
  int v14 = &v23;
  uint64_t v15 = *(void *)(v3 + 48);
  __dmb(0xBu);
  if (!v15) {
    goto LABEL_16;
  }
  int v16 = *(_DWORD *)(v3 + 32);
  __dmb(0xBu);
  if (a2 <= 0)
  {
    if (v16 < 1) {
      goto LABEL_25;
    }
    while (1)
    {
      int v21 = v16;
      atomic_compare_exchange_strong((atomic_uint *volatile)(v3 + 32), (unsigned int *)&v21, v16 - 1);
      if (v21 == v16) {
        goto LABEL_14;
      }
      if (*(_DWORD *)(v3 + 32) != v16)
      {
        int v16 = *(_DWORD *)(v3 + 32);
        __dmb(0xBu);
        if (v16 <= 0) {
          goto LABEL_25;
        }
      }
    }
  }
  if (v16 + a2 >= 1)
  {
    --a2;
LABEL_14:
    uint64_t v17 = *(void *)(v3 + 48);
    __dmb(0xBu);
    uint64_t v23 = v17;
    uint64_t v18 = *(void *)(v17 + 56);
    __dmb(0xBu);
    *(void *)(v3 + 48) = v18;
    int v14 = &v24;
    __dmb(0xBu);
    goto LABEL_16;
  }
LABEL_24:
  atomic_fetch_add((atomic_uint *volatile)(v3 + 32), a2);
LABEL_25:
  __dmb(0xBu);
  char *v4 = 0;
  while (v14 > &v22)
  {
    uint64_t v20 = *--v14;
    *(void *)(v20 + 56) = 0;
    this = sub_216766DDC((pthread_t)v20);
  }
  return this;
}

pthread_t sub_216766DDC(pthread_t result)
{
  pthread_t v1 = result;
  atomic_uint sig = result->__sig;
  __dmb(0xBu);
  if (sig)
  {
LABEL_4:
    uint64_t v4 = *(void *)&result->__opaque[16];
    __dmb(0xBu);
    __dmb(0xBu);
    *(void *)&result->__opaque[16] = v4 + 1;
    unint64_t v5 = (atomic_uint *)((unint64_t)&result->__opaque[24] & 0xFFFFFFFFFFFFFFFCLL);
    char v6 = 8 * (((_BYTE)result + 40) & 3);
    int v7 = 255 << v6;
    while (2)
    {
      int v8 = v1->__opaque[24];
      int v9 = v8 << v6;
LABEL_6:
      unsigned int v10 = *v5 & ~v7;
      int v11 = v10 | v9;
      while (1)
      {
        int v12 = v10 | v9;
        atomic_compare_exchange_strong(v5, (unsigned int *)&v12, v10);
        if (v12 == v11) {
          break;
        }
        if (*v5 != v11)
        {
          if (((*v5 ^ v11) & v7) == 0)
          {
            uint64_t result = (pthread_t)sched_yield();
            goto LABEL_6;
          }
          int v11 = *v5;
          break;
        }
      }
      if (v8 != ((v11 & v7) >> v6))
      {
        uint64_t result = (pthread_t)sched_yield();
        continue;
      }
      break;
    }
    if (v8)
    {
      JUMPOUT(0x21D448AF0);
    }
  }
  else
  {
    while (1)
    {
      int v3 = 0;
      atomic_compare_exchange_strong((atomic_uint *volatile)result, (unsigned int *)&v3, 1u);
      if (!v3) {
        break;
      }
      if (LODWORD(result->__sig)) {
        goto LABEL_4;
      }
    }
    uint64_t result = sub_216767168((void *(__cdecl *)(void *))tbb::internal::rml::private_worker::thread_routine, result, (size_t)result->__cleanup_stack[1].__routine);
    *(void *)&v1->__opaque[32] = result;
    while (1)
    {
      int v13 = 1;
      atomic_compare_exchange_strong((atomic_uint *volatile)v1, (unsigned int *)&v13, 2u);
      if (v13 == 1) {
        break;
      }
      if (LODWORD(v1->__sig) != 1)
      {
        int v14 = *(_opaque_pthread_t **)&v1->__opaque[32];
        does_client_join_workers = (_opaque_pthread_t *)tbb::internal::governor::does_client_join_workers(*(void *)v1->__opaque);
        return (pthread_t)tbb::internal::rml::private_worker::release_handle(v14, does_client_join_workers);
      }
    }
  }
  return result;
}

pthread_t tbb::internal::rml::private_server::adjust_job_count_estimate(pthread_t this, signed int a2)
{
  if (a2 < 0)
  {
    atomic_fetch_add((atomic_uint *volatile)&this->__opaque[16], a2);
  }
  else if (a2)
  {
    return tbb::internal::rml::private_server::wake_some(this, a2);
  }
  return this;
}

uint64_t tbb::internal::rml::make_private_server(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = tbb::internal::NFS_Allocate(1uLL, 64, 0, a4);

  return tbb::internal::rml::private_server::private_server(v5, a1);
}

uint64_t sub_216766FD4()
{
  return 0;
}

uint64_t sub_216766FDC(uint64_t result)
{
  pthread_t v1 = (atomic_uint *)result;
  if (*(_DWORD *)(result + 16))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      uint64_t result = tbb::internal::rml::private_worker::start_shutdown(*((void *)v1 + 5) + v2);
      ++v3;
      v2 += 128;
    }
    while (v3 < v1[4]);
  }
  if (atomic_fetch_add(v1 + 9, 0xFFFFFFFF) == 1)
  {
    (*(void (**)(void))(**((void **)v1 + 1) + 32))(*((void *)v1 + 1));
    (*(void (**)(atomic_uint *))(*(void *)v1 + 48))(v1);
    return tbb::internal::NFS_Free((tbb::internal *)v1, v4);
  }
  return result;
}

uint64_t sub_2167670C0()
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  int v0 = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(void *)uint64_t v4 = 0x1900000006;
    int v3 = 0;
    size_t v2 = 4;
    sysctl(v4, 2u, &v3, &v2, 0, 0);
    int v0 = v3;
    if (v3 <= 1) {
      int v0 = 1;
    }
    tbb::internal::governor::DefaultNumberOfThreads = v0;
  }
  return (v0 - 1);
}

pthread_t sub_216767168(void *(__cdecl *a1)(void *), void *a2, size_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v6 = pthread_attr_init(&v15);
  if (v6)
  {
    int v11 = (FILE *)*MEMORY[0x263EF8348];
    int v12 = strerror(v6);
    int v13 = "pthread_attr_init";
    goto LABEL_11;
  }
  if (a3)
  {
    int v7 = pthread_attr_setstacksize(&v15, a3);
    if (v7)
    {
      int v11 = (FILE *)*MEMORY[0x263EF8348];
      int v12 = strerror(v7);
      int v13 = "pthread_attr_setstack_size";
LABEL_11:
      fprintf(v11, "thread_monitor %s in %s\n", v12, v13);
      exit(1);
    }
  }
  pthread_t v14 = 0;
  int v8 = pthread_create(&v14, &v15, a1, a2);
  if (v8)
  {
    int v11 = (FILE *)*MEMORY[0x263EF8348];
    int v12 = strerror(v8);
    int v13 = "pthread_create";
    goto LABEL_11;
  }
  int v9 = pthread_attr_destroy(&v15);
  if (v9)
  {
    int v11 = (FILE *)*MEMORY[0x263EF8348];
    int v12 = strerror(v9);
    int v13 = "pthread_attr_destroy";
    goto LABEL_11;
  }
  return v14;
}

uint64_t tbb::internal::rml::tbb_factory::open(tbb::internal::rml::tbb_factory *this)
{
  v6[8] = *MEMORY[0x263EF8340];
  size_t v2 = (void *)((char *)this + 16);
  uint64_t v5 = 0;
  v6[0] = "__RML_open_factory";
  v6[1] = &v5;
  v6[2] = "__TBB_make_rml_server";
  v6[3] = (char *)this + 24;
  v6[4] = "__RML_close_factory";
  v6[5] = (char *)this + 8;
  v6[6] = "__TBB_call_with_my_server_info";
  v6[7] = (char *)this + 32;
  if (tbb::internal::dynamic_link((uint64_t)"libirml.dylib", (uint64_t)v6, 4, (void *)this + 2))
  {
    int v4 = 0;
    return v5(this, &v4, 2);
  }
  else
  {
    *size_t v2 = 0;
    return 2;
  }
}

unint64_t tbb::internal::rml::tbb_factory::close(unint64_t this)
{
  if (*(void *)(this + 16))
  {
    unint64_t v1 = this;
    (*(void (**)(void))(this + 8))();
    this = *(void *)(v1 + 16);
    if (this >= 2)
    {
      this = tbb::internal::dynamic_unlink((tbb::internal *)this, v2);
      *(void *)(v1 + 16) = 0;
    }
  }
  return this;
}

uint64_t tbb::internal::rml::tbb_factory::make_server(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 24))();
}

uint64_t tbb::internal::rml::tbb_factory::call_with_server_info(tbb::internal::rml::tbb_factory *this, void (*a2)(void *, const char *), void *a3)
{
  return (*((uint64_t (**)(void, void *))this + 4))(a2, a3);
}

void *tbb::set_assertion_handler(tbb *this, void (*a2)(const char *, int, const char *, const char *))
{
  size_t v2 = off_26798E020;
  off_26798E020 = this;
  return v2;
}

const char *tbb::assertion_failure(const char *this, const char *a2, const char *a3, const char *a4, const char *a5)
{
  uint64_t v5 = (uint64_t (*)(const char *, const char *, const char *, const char *))off_26798E020;
  if (off_26798E020)
  {
    return (const char *)v5(this, a2, a3, a4);
  }
  else if ((byte_26798E028 & 1) == 0)
  {
    sub_2173239B0(a3, (int)a2, this, a4);
  }
  return this;
}

uint64_t tbb::internal::runtime_warning(tbb::internal *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v5 = *MEMORY[0x263EF8340];
  bzero(__str, 0x400uLL);
  vsnprintf(__str, 0x3FFuLL, (const char *)this, va);
  return fprintf((FILE *)*MEMORY[0x263EF8348], "TBB Warning: %s\n", __str);
}

const char *tbb::bad_last_alloc::what(tbb::bad_last_alloc *this)
{
  return "bad allocation in previous or concurrent attempt";
}

const char *tbb::improper_lock::what(tbb::improper_lock *this)
{
  return "attempted recursive lock on critical section or non-recursive mutex";
}

const char *tbb::user_abort::what(tbb::user_abort *this)
{
  return "User-initiated abort has terminated this operation";
}

const char *tbb::invalid_multiple_scheduling::what(tbb::invalid_multiple_scheduling *this)
{
  return "The same task_handle object cannot be executed more than once";
}

const char *tbb::missing_wait::what(tbb::missing_wait *this)
{
  return "wait() was not called on the structured_task_group";
}

uint64_t tbb::internal::DefaultSystemPageSize(tbb::internal *this)
{
  return sysconf(29);
}

void tbb::internal::handle_perror(tbb::internal *this, const char *a2, const char *a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v4 = strerror((int)this);
  snprintf(__str, 0x100uLL, "%s: %s", a2, v4);
  __str[255] = 0;
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::runtime_error::runtime_error(exception, __str);
  __cxa_throw(exception, MEMORY[0x263F8C1F0], MEMORY[0x263F8C070]);
}

void sub_2167675B8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void tbb::internal::throw_bad_last_alloc_exception_v4(tbb::internal *this)
{
  exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
  exception->__vftable = 0;
  size_t v2 = sub_216767A2C(exception);
}

uint64_t tbb::internal::throw_exception_v4(uint64_t result)
{
  if (!(!v2 & v1))
  {
    switch((int)result)
    {
      case 1:
        exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
        int v4 = std::bad_alloc::bad_alloc(exception);
        __cxa_throw(v4, MEMORY[0x263F8C218], MEMORY[0x263F8C170]);
      case 2:
        uint64_t v5 = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
        v5->__vftable = 0;
        int v6 = sub_216767A2C(v5);
      case 3:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767A64(v7, "Step must be positive");
        goto LABEL_21;
      case 4:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767A98(v7, "Index out of requested size range");
        goto LABEL_24;
      case 5:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767ACC((std::runtime_error *)v7, "Index out of allocated segment slots");
        goto LABEL_11;
      case 6:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767ACC((std::runtime_error *)v7, "Index is not allocated");
LABEL_11:
        int v8 = (struct type_info *)off_264293918;
        int v9 = (void (*)(void *))MEMORY[0x263F8C050];
        goto LABEL_29;
      case 7:
        unsigned int v10 = __cxa_allocate_exception(8uLL);
        *unsigned int v10 = &unk_26C746908;
      case 8:
        int v11 = __cxa_allocate_exception(8uLL);
        *int v11 = &unk_26C7468E0;
      case 9:
        int v12 = __cxa_allocate_exception(8uLL);
        *int v12 = &unk_26C746890;
      case 10:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error((std::runtime_error *)v7, "Resource deadlock would occur");
        goto LABEL_28;
      case 11:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error((std::runtime_error *)v7, "Operation not permitted");
        goto LABEL_28;
      case 12:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error((std::runtime_error *)v7, "Wait on condition variable failed");
        goto LABEL_28;
      case 13:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767A98(v7, "Invalid hash load factor");
        goto LABEL_24;
      case 14:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767A98(v7, "[backward compatibility] Invalid number of buckets");
        goto LABEL_24;
      case 15:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767A64(v7, "swap() is invalid on non-equal allocators");
LABEL_21:
        int v8 = (struct type_info *)off_264293940;
        int v9 = (void (*)(void *))MEMORY[0x263F8C080];
        goto LABEL_29;
      case 16:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767B04(v7, "reservation size exceeds permitted max size");
        int v8 = (struct type_info *)off_264293928;
        int v9 = (void (*)(void *))MEMORY[0x263F8C060];
        goto LABEL_29;
      case 17:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_216767A98(v7, "invalid key");
LABEL_24:
        int v8 = (struct type_info *)off_264293930;
        int v9 = (void (*)(void *))MEMORY[0x263F8C068];
        goto LABEL_29;
      case 18:
        int v13 = __cxa_allocate_exception(8uLL);
        *int v13 = &unk_26C7468B8;
      case 19:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error((std::runtime_error *)v7, "Blocking terminate failed");
        goto LABEL_28;
      case 20:
        uint64_t v7 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error((std::runtime_error *)v7, "Illegal tagged_msg cast");
LABEL_28:
        int v8 = (struct type_info *)MEMORY[0x263F8C1F0];
        int v9 = (void (*)(void *))MEMORY[0x263F8C070];
LABEL_29:
        __cxa_throw(v7, v8, v9);
      default:
        JUMPOUT(0);
    }
  }
  return result;
}

void sub_216767994(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::bad_alloc *sub_216767A2C(std::bad_alloc *a1)
{
  uint64_t result = std::bad_alloc::bad_alloc(a1);
  result->__vftable = (std::bad_alloc_vtbl *)&unk_26C746868;
  return result;
}

std::logic_error *sub_216767A64(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
  return result;
}

std::logic_error *sub_216767A98(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C390] + 16);
  return result;
}

std::runtime_error *sub_216767ACC(std::runtime_error *a1, const char *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x263F8C370] + 16);
  return result;
}

std::logic_error *sub_216767B04(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

uint64_t tbb::internal::gcc_rethrow_exception_broken(tbb::internal *this)
{
  return 0;
}

uint64_t tbb::internal::PrintVersion(tbb::internal *this)
{
  byte_26798E029 = 1;
  return fputs("TBB: VERSION\t\t2020.3\nTBB: INTERFACE VERSION\t11103\nTBB: BUILD_DATE\t\tSun Nov 10 10:17:49 UTC 2024\nTBB: BUILD_HOST\t\ttsgjh (i386)\nTBB: BUILD_OS\t\tmacOS version 13.0\nTBB: BUILD_KERNEL\tDarwin Kernel Version 22.1.0: Thu Dec 15 17:42:24 PST 2022; root:xnu-8792.41.9.100.2~1/DEV"
           "ELOPMENT_X86_64\n"
           "TBB: BUILD_CLANG\tApple clang version 16.0.0 (clang-1600.0.26.6) [+internal-os]\n"
           "TBB: BUILD_XCODE\tXcode 16.0\n"
           "TBB: BUILD_TARGET\tarm64 arm64e on cc_ios\n"
           "TBB: BUILD_COMMAND\tclang++ -g -O2 -Werror=global-constructors -DUSE_PTHREAD -stdlib=libc++ -arch arm64 -arch"
           " arm64e -isysroot /AppleInternal/Library/BuildRoots/cb09429a-9ee5-11ef-b491-ce2c30f2a3e7/Applications/Xcode.a"
           "pp/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS18.2.Internal.sdk -fPIC -D__TBB_BUIL"
           "D=1 -Wall -Wno-non-virtual-dtor -Wno-dangling-else -D__TBB_DYNAMIC_LOAD_ENABLED=0 -D__TBB_SOURCE_DIRECTLY_INC"
           "LUDED=1 -DTBB_SUPPRESS_DEPRECATED_MESSAGES=1 -std=c++14 -I/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB"
           "-2020.3/./src -I/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/rml/include -I/Library/Cache"
           "s/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./include -I.\n"
           "TBB: TBB_USE_DEBUG\t0\n"
           "TBB: TBB_USE_ASSERT\t0\n"
           "TBB: DO_ITT_NOTIFY\tundefined\n",
           (FILE *)*MEMORY[0x263EF8348]);
}

const char *tbb::internal::PrintExtraVersionInfo(const char *this, const char *a2, const char *a3, ...)
{
  va_start(va, a3);
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (byte_26798E029 == 1)
  {
    int v4 = this;
    bzero(__str, 0x400uLL);
    vsnprintf(__str, 0x3FFuLL, a2, va);
    return (const char *)fprintf((FILE *)*MEMORY[0x263EF8348], "TBB: %s\t%s\n", v4, __str);
  }
  return this;
}

const char *tbb::internal::PrintRMLVersionInfo(tbb::internal *this, tbb::internal *a2, const char *a3)
{
  return tbb::internal::PrintExtraVersionInfo((const char *)a2, (const char *)this, a3);
}

uint64_t tbb::internal::cpu_has_speculation(tbb::internal *this)
{
  return 0;
}

uint64_t TBB_runtime_interface_version()
{
  return 11103;
}

void sub_216767C40(std::bad_alloc *a1)
{
  std::bad_alloc::~bad_alloc(a1);

  operator delete(v1);
}

void sub_216767C68(std::exception *a1)
{
  std::exception::~exception(a1);

  operator delete(v1);
}

uint64_t tbb::internal::allocate_root_proxy::allocate(tbb::internal::allocate_root_proxy *this)
{
  unint64_t v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v2) {
    inited = (tbb::internal::generic_scheduler *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  }
  int v4 = *(tbb::task_group_context **)(*((void *)inited + 7) - 56);

  return tbb::internal::generic_scheduler::allocate_task(inited, (unint64_t)this, 0, v4);
}

unint64_t tbb::internal::allocate_root_proxy::free(tbb::internal::allocate_root_proxy *this, tbb::task *a2)
{
  unint64_t v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3) {
    unint64_t result = v3 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t result = tbb::internal::governor::init_scheduler_weak(0);
  }
  *((unsigned char *)this - 12) = 4;
  if (*((void *)this - 6) == result)
  {
    *((void *)this - 1) = *(void *)(result + 136);
    *(void *)(result + 136) = this;
  }
  else
  {
    return tbb::internal::NFS_Free((tbb::internal::allocate_root_proxy *)((char *)this - 64), v4);
  }
  return result;
}

uint64_t tbb::internal::allocate_root_with_context_proxy::allocate(tbb::task_group_context **this, unint64_t a2)
{
  unint64_t v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4) {
    unint64_t inited = v4 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t inited = tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t task = tbb::internal::generic_scheduler::allocate_task((tbb::internal::generic_scheduler *)inited, a2, 0, *this);
  int v9 = *this;
  if (*(_DWORD *)*this != 1)
  {
LABEL_7:
    if (*(_DWORD *)v9) {
      return task;
    }
    goto LABEL_8;
  }
  if ((~*(unsigned __int8 *)(inited + 74) & 3) == 0)
  {
    *(_DWORD *)int v9 = 0;
    goto LABEL_7;
  }
  tbb::task_group_context::bind_to((uint64_t)v9, (tbb::internal::generic_scheduler *)inited, v6, v7);
  int v9 = *this;
  if (*(_DWORD *)*this) {
    return task;
  }
LABEL_8:
  if ((*((unsigned char *)v9 + 130) & 2) == 0) {
    tbb::task_group_context::copy_fp_settings(v9, *(const tbb::task_group_context **)(*(void *)(inited + 144) - 56), v6, v7);
  }
  return task;
}

unint64_t tbb::internal::allocate_root_with_context_proxy::free(tbb::internal::allocate_root_with_context_proxy *this, tbb::task *a2)
{
  unint64_t v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3) {
    unint64_t result = v3 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t result = tbb::internal::governor::init_scheduler_weak(0);
  }
  *((unsigned char *)a2 - 12) = 4;
  if (*((void *)a2 - 6) == result)
  {
    *((void *)a2 - 1) = *(void *)(result + 136);
    *(void *)(result + 136) = a2;
  }
  else
  {
    return tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), v4);
  }
  return result;
}

uint64_t tbb::internal::allocate_continuation_proxy::allocate(tbb::internal::allocate_continuation_proxy *this, unint64_t a2)
{
  unint64_t v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4) {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t v6 = (tbb::task *)*((void *)this - 4);
  *((void *)this - 4) = 0;
  uint64_t v7 = (tbb::task_group_context *)*((void *)this - 7);

  return tbb::internal::generic_scheduler::allocate_task(inited, a2, v6, v7);
}

unint64_t tbb::internal::allocate_continuation_proxy::free(tbb::internal::allocate_continuation_proxy *this, tbb::task *a2)
{
  *((void *)this - 4) = *((void *)a2 - 4);
  unint64_t v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3) {
    unint64_t result = v3 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t result = tbb::internal::governor::init_scheduler_weak(0);
  }
  *((unsigned char *)a2 - 12) = 4;
  if (*((void *)a2 - 6) == result)
  {
    *((void *)a2 - 1) = *(void *)(result + 136);
    *(void *)(result + 136) = a2;
  }
  else
  {
    return tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), v4);
  }
  return result;
}

uint64_t tbb::internal::allocate_child_proxy::allocate(tbb::internal::allocate_child_proxy *this, unint64_t a2)
{
  unint64_t v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4) {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t v6 = (tbb::task_group_context *)*((void *)this - 7);

  return tbb::internal::generic_scheduler::allocate_task(inited, a2, this, v6);
}

unint64_t tbb::internal::allocate_child_proxy::free(tbb::internal::allocate_child_proxy *this, tbb::task *a2)
{
  unint64_t v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3) {
    unint64_t result = v3 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t result = tbb::internal::governor::init_scheduler_weak(0);
  }
  *((unsigned char *)a2 - 12) = 4;
  if (*((void *)a2 - 6) == result)
  {
    *((void *)a2 - 1) = *(void *)(result + 136);
    *(void *)(result + 136) = a2;
  }
  else
  {
    return tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), v4);
  }
  return result;
}

uint64_t tbb::internal::allocate_additional_child_of_proxy::allocate(tbb::internal::allocate_additional_child_of_proxy *this, unint64_t a2)
{
  atomic_fetch_add((atomic_ullong *volatile)(*((void *)this + 1) - 24), 1uLL);
  unint64_t v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4) {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t v6 = (tbb::task *)*((void *)this + 1);
  uint64_t v7 = (tbb::task_group_context *)*((void *)v6 - 7);

  return tbb::internal::generic_scheduler::allocate_task(inited, a2, v6, v7);
}

unint64_t tbb::internal::allocate_additional_child_of_proxy::free(tbb::internal::allocate_additional_child_of_proxy *this, tbb::task *a2)
{
  atomic_fetch_add((atomic_ullong *volatile)(*((void *)this + 1) - 24), 0xFFFFFFFFFFFFFFFFLL);
  unint64_t v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3) {
    unint64_t result = v3 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t result = tbb::internal::governor::init_scheduler_weak(0);
  }
  *((unsigned char *)a2 - 12) = 4;
  if (*((void *)a2 - 6) == result)
  {
    *((void *)a2 - 1) = *(void *)(result + 136);
    *(void *)(result + 136) = a2;
  }
  else
  {
    return tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), v4);
  }
  return result;
}

unint64_t tbb::task::internal_decrement_ref_count(atomic_ullong *this)
{
  return atomic_fetch_add(this - 3, 0xFFFFFFFFFFFFFFFFLL) - 1;
}

uint64_t tbb::internal::get_initial_auto_partitioner_divisor(tbb::internal *this)
{
  unint64_t v1 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v1) {
    unint64_t inited = v1 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t inited = tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  }
  return 4 * *(unsigned int *)(*(void *)(inited + 48) + 328);
}

void tbb::internal::affinity_partitioner_base_v3::resize(tbb::internal **this, void *a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v5 = (int)a2;
    unint64_t v6 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
    if (v6) {
      unint64_t inited = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
    else {
      unint64_t inited = tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
    }
    unint64_t v8 = (*(_DWORD *)(*(void *)(inited + 48) + 328) * v5);
  }
  else
  {
    unint64_t v8 = 0;
  }
  if ((tbb::internal *)v8 != this[1])
  {
    if (*this)
    {
      tbb::internal::NFS_Free(*this, a2);
      *this = 0;
      this[1] = 0;
    }
    if (v8)
    {
      int v9 = (tbb::internal *)tbb::internal::NFS_Allocate(v8, 2, 0, a4);
      *this = v9;
      bzero(v9, 2 * v8);
      this[1] = (tbb::internal *)v8;
    }
  }
}

uint64_t tbb::task::internal_set_ref_count(uint64_t this, int a2)
{
  *(void *)(this - 24) = a2;
  return this;
}

uint64_t tbb::task::self(tbb::task *this)
{
  unint64_t v1 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v1) {
    unint64_t inited = v1 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t inited = tbb::internal::governor::init_scheduler_weak(0);
  }
  return *(void *)(inited + 56);
}

uint64_t tbb::task::is_owned_by_current_thread(tbb::task *this)
{
  return 1;
}

void tbb::interface5::internal::task_base::destroy(tbb::interface5::internal::task_base *this, tbb::task *a2)
{
  uint64_t v3 = *((void *)this - 4);
  (**(void (***)(tbb::interface5::internal::task_base *, tbb::task *))this)(this, a2);
  if (v3) {
    atomic_fetch_add((atomic_ullong *volatile)(v3 - 24), 0xFFFFFFFFFFFFFFFFLL);
  }
  unint64_t v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4) {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  }
  *((unsigned char *)this - 12) = 4;
  unint64_t v7 = *((void *)this - 6);
  if ((tbb::internal::generic_scheduler *)v7 == inited)
  {
    *((void *)this - 1) = *((void *)inited + 17);
    *((void *)inited + 17) = this;
  }
  else if (!v7 || v7 >= 0x1000)
  {
    if (v7)
    {
      tbb::internal::generic_scheduler::free_nonlocal_small_task(inited, this);
    }
    else
    {
      tbb::internal::NFS_Free((tbb::interface5::internal::task_base *)((char *)this - 64), v5);
    }
  }
}

uint64_t tbb::task::spawn_and_wait_for_all(uint64_t a1, uint64_t *a2)
{
  unint64_t v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4)
  {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v4 & 0xFFFFFFFFFFFFFFFELL);
    uint64_t v7 = *a2;
    if (!*a2) {
      goto LABEL_8;
    }
  }
  else
  {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
    uint64_t v7 = *a2;
    if (!*a2) {
      goto LABEL_8;
    }
  }
  unint64_t v8 = (tbb::task **)a2[1];
  if ((tbb::task **)(v7 - 8) != v8) {
    tbb::internal::generic_scheduler::local_spawn(inited, *(tbb::task **)(v7 - 8), v8, v5);
  }
  *a2 = 0;
  a2[1] = (uint64_t)a2;
LABEL_8:
  int v9 = *(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, uint64_t))(*(void *)inited + 48);

  return v9(inited, a1, v7);
}

void tbb::task::change_group(tbb::task *this, tbb::task_group_context *a2)
{
  *((void *)this - 7) = a2;
  unint64_t v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v3) {
    unint64_t inited = v3 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t inited = tbb::internal::governor::init_scheduler_weak(0);
  }
  if (*(_DWORD *)a2 == 1)
  {
    if ((~*(unsigned __int8 *)(inited + 74) & 3) != 0)
    {
      tbb::task_group_context::bind_to((uint64_t)a2, (tbb::internal::generic_scheduler *)inited, v4, v5);
      if (*(_DWORD *)a2) {
        return;
      }
      goto LABEL_8;
    }
    *(_DWORD *)a2 = 0;
  }
  if (*(_DWORD *)a2) {
    return;
  }
LABEL_8:
  if ((*((unsigned char *)a2 + 130) & 2) == 0)
  {
    uint64_t v7 = *(const tbb::task_group_context **)(*(void *)(inited + 144) - 56);
    tbb::task_group_context::copy_fp_settings(a2, v7, v4, v5);
  }
}

void tbb::captured_exception::~captured_exception(tbb::captured_exception *this, void *a2)
{
  *(void *)this = &unk_26C7469A0;
  tbb::internal::deallocate_via_handler_v3(*((void *)this + 2), a2);
  tbb::internal::deallocate_via_handler_v3(*((void *)this + 3), v3);
  *(void *)this = &unk_26C746A18;

  std::exception::~exception((std::exception *)this);
}

{
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_26C7469A0;
  tbb::internal::deallocate_via_handler_v3(*((void *)this + 2), a2);
  tbb::internal::deallocate_via_handler_v3(*((void *)this + 3), v3);
  *(void *)this = &unk_26C746A18;

  std::exception::~exception((std::exception *)this);
}

{
  void *v3;
  uint64_t v4;
  void *v5;

  *(void *)this = &unk_26C7469A0;
  tbb::internal::deallocate_via_handler_v3(*((void *)this + 2), a2);
  tbb::internal::deallocate_via_handler_v3(*((void *)this + 3), v3);
  *(void *)this = &unk_26C746A18;
  std::exception::~exception((std::exception *)this);
  tbb::internal::deallocate_via_handler_v3(v4, v5);
}

uint64_t tbb::captured_exception::clear(tbb::captured_exception *this, void *a2)
{
  tbb::internal::deallocate_via_handler_v3(*((void *)this + 2), a2);
  return tbb::internal::deallocate_via_handler_v3(*((void *)this + 3), v3);
}

char *tbb::captured_exception::set(tbb::captured_exception *this, const char *__s, const char *a3)
{
  if (!__s)
  {
    *((void *)this + 2) = 0;
    if (a3) {
      goto LABEL_3;
    }
LABEL_5:
    unint64_t result = 0;
    goto LABEL_6;
  }
  unint64_t v6 = (tbb::internal *)(strlen(__s) + 1);
  uint64_t v7 = (char *)tbb::internal::allocate_via_handler_v3(v6);
  *((void *)this + 2) = strncpy(v7, __s, (size_t)v6);
  if (!a3) {
    goto LABEL_5;
  }
LABEL_3:
  unint64_t v8 = (tbb::internal *)(strlen(a3) + 1);
  int v9 = (char *)tbb::internal::allocate_via_handler_v3(v8);
  unint64_t result = strncpy(v9, a3, (size_t)v8);
LABEL_6:
  *((void *)this + 3) = result;
  return result;
}

__n128 tbb::captured_exception::move(__n128 *this)
{
  uint64_t v2 = tbb::internal::allocate_via_handler_v3((tbb::internal *)0x20);
  if (v2)
  {
    *(void *)uint64_t v2 = &unk_26C7469A0;
    *(void *)(v2 + 16) = 0;
    *(void *)(v2 + 24) = 0;
    __n128 result = this[1];
    *(__n128 *)(v2 + 16) = result;
    *(unsigned char *)(v2 + 8) = 1;
    this[1].n128_u64[0] = 0;
    this[1].n128_u64[1] = 0;
  }
  return result;
}

uint64_t tbb::captured_exception::destroy(uint64_t this, void *a2)
{
  if (*(unsigned char *)(this + 8))
  {
    uint64_t v2 = this;
    *(void *)this = &unk_26C7469A0;
    tbb::internal::deallocate_via_handler_v3(*(void *)(this + 16), a2);
    tbb::internal::deallocate_via_handler_v3(*(void *)(v2 + 24), v3);
    *(void *)uint64_t v2 = &unk_26C746A18;
    std::exception::~exception((std::exception *)v2);
    return tbb::internal::deallocate_via_handler_v3(v4, v5);
  }
  return this;
}

tbb::captured_exception *tbb::captured_exception::allocate(tbb::captured_exception *this, const char *a2, const char *a3)
{
  int v5 = (tbb::captured_exception *)tbb::internal::allocate_via_handler_v3((tbb::internal *)0x20);
  unint64_t v6 = v5;
  if (v5)
  {
    *(void *)int v5 = &unk_26C7469A0;
    *((unsigned char *)v5 + 8) = 0;
    tbb::captured_exception::set(v5, (const char *)this, a2);
    *((unsigned char *)v6 + 8) = 1;
  }
  return v6;
}

uint64_t tbb::captured_exception::name(tbb::captured_exception *this)
{
  return *((void *)this + 2);
}

uint64_t tbb::captured_exception::what(tbb::captured_exception *this)
{
  return *((void *)this + 3);
}

std::exception_ptr *tbb::internal::tbb_exception_ptr::allocate(tbb::internal::tbb_exception_ptr *this)
{
  std::current_exception();
  unint64_t v1 = (std::exception_ptr *)tbb::internal::allocate_via_handler_v3((tbb::internal *)8);
  uint64_t v2 = v1;
  if (v1) {
    std::exception_ptr::exception_ptr(v1, &v4);
  }
  std::exception_ptr::~exception_ptr(&v4);
  return v2;
}

void sub_216768948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
}

std::exception_ptr *tbb::internal::tbb_exception_ptr::allocate()
{
  std::current_exception();
  int v0 = (std::exception_ptr *)tbb::internal::allocate_via_handler_v3((tbb::internal *)8);
  unint64_t v1 = v0;
  if (v0) {
    std::exception_ptr::exception_ptr(v0, &v3);
  }
  std::exception_ptr::~exception_ptr(&v3);
  return v1;
}

void sub_2167689B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
}

uint64_t tbb::internal::tbb_exception_ptr::allocate(tbb::internal::tbb_exception_ptr *this, tbb::captured_exception *a2)
{
  uint64_t v3 = tbb::internal::allocate_via_handler_v3((tbb::internal *)8);
  if (v3) {
    sub_216769890(v3, (uint64_t)this);
  }
  (*(void (**)(tbb::internal::tbb_exception_ptr *))(*(void *)this + 32))(this);
  return 0;
}

uint64_t tbb::internal::tbb_exception_ptr::destroy(std::exception_ptr *this)
{
  std::exception_ptr::~exception_ptr(this);
  return tbb::internal::deallocate_via_handler_v3(v1, v2);
}

void tbb::task_group_context::~task_group_context(tbb::task_group_context *this, void *a2)
{
  if (*(_DWORD *)this == 2)
  {
    if (tbb::internal::governor::is_set(*((void *)this + 18)))
    {
      uint64_t v3 = *((void *)this + 18);
      uint64_t v4 = *(void *)(v3 + 320);
      *(void *)(v3 + 328) = 1;
      __dmb(0xBu);
      uint64_t v5 = *((void *)this + 18);
      if (*(void *)(v5 + 368))
      {
        uint64_t v6 = v5 + 312;
        uint64_t v7 = (atomic_uint *)((v5 + 312) & 0xFFFFFFFFFFFFFFFCLL);
        int v8 = 1 << (8 * ((v5 + 56) & 3));
        int v9 = ~(255 << (8 * ((v5 + 56) & 3)));
LABEL_5:
        int v10 = *v7 & v9;
        while (1)
        {
          int v11 = v10;
          atomic_compare_exchange_strong(v7, (unsigned int *)&v11, v10 | v8);
          if (v11 == v10) {
            break;
          }
          if (*v7 != v10)
          {
            sched_yield();
            goto LABEL_5;
          }
        }
        uint64_t v15 = *((void *)this + 2);
        *(void *)(v15 + 8) = *((void *)this + 3);
        **((void **)this + 3) = v15;
        *(void *)(*((void *)this + 18) + 328) = 0;
LABEL_16:
        __dmb(0xBu);
        *(unsigned char *)uint64_t v6 = 0;
        goto LABEL_27;
      }
      uint64_t v26 = *((void *)this + 2);
      *(void *)(v26 + 8) = *((void *)this + 3);
      **((void **)this + 3) = v26;
      __dmb(0xBu);
      *(void *)(v5 + 328) = 0;
      if (v4 != tbb::internal::the_context_state_propagation_epoch)
      {
        uint64_t v6 = *((void *)this + 18) + 312;
        uint64_t v31 = (atomic_uint *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_33:
        int v32 = *v31 & ~(255 << (8 * (v6 & 3)));
        while (1)
        {
          int v33 = v32;
          atomic_compare_exchange_strong(v31, (unsigned int *)&v33, v32 | (1 << (8 * (v6 & 3))));
          if (v33 == v32) {
            goto LABEL_16;
          }
          if (*v31 != v32)
          {
            sched_yield();
            goto LABEL_33;
          }
        }
      }
    }
    else
    {
LABEL_9:
      int v12 = *(_DWORD *)this;
      while (1)
      {
        int v13 = v12;
        atomic_compare_exchange_strong((atomic_uint *volatile)this, (unsigned int *)&v13, 4u);
        if (v13 == v12) {
          break;
        }
        if (*(_DWORD *)this != v12)
        {
          sched_yield();
          goto LABEL_9;
        }
      }
      if (v12 == 3)
      {
        uint64_t v14 = *((void *)this + 2);
        *(void *)(v14 + 8) = *((void *)this + 3);
        **((void **)this + 3) = v14;
      }
      else
      {
        atomic_fetch_add((atomic_ullong *volatile)(*((void *)this + 18) + 368), 1uLL);
        uint64_t v16 = *((void *)this + 18);
        while (1)
        {
          uint64_t v17 = *(void *)(v16 + 328);
          __dmb(0xBu);
          if (!v17) {
            break;
          }
          sched_yield();
        }
        uint64_t v18 = *((void *)this + 18) + 312;
        int v19 = (atomic_uint *)(v18 & 0xFFFFFFFFFFFFFFFCLL);
        LOBYTE(v18) = 8 * (v18 & 3);
        int v20 = 1 << v18;
        int v21 = ~(255 << v18);
LABEL_21:
        int v22 = *v19 & v21;
        while (1)
        {
          int v23 = v22;
          atomic_compare_exchange_strong(v19, (unsigned int *)&v23, v22 | v20);
          if (v23 == v22) {
            break;
          }
          if (*v19 != v22)
          {
            sched_yield();
            goto LABEL_21;
          }
        }
        uint64_t v24 = *((void *)this + 2);
        *(void *)(v24 + 8) = *((void *)this + 3);
        **((void **)this + 3) = v24;
        uint64_t v25 = *((void *)this + 18);
        __dmb(0xBu);
        *(unsigned char *)(v25 + 312) = 0;
        atomic_fetch_add((atomic_ullong *volatile)(*((void *)this + 18) + 368), 0xFFFFFFFFFFFFFFFFLL);
      }
    }
  }
LABEL_27:
  int v27 = (tbb::internal *)*((void *)this + 14);
  if (v27) {
    tbb::internal::NFS_Free(v27, a2);
  }
  int v28 = (std::exception_ptr *)*((void *)this + 17);
  if (v28)
  {
    std::exception_ptr::~exception_ptr(v28);
    tbb::internal::deallocate_via_handler_v3(v29, v30);
  }
}

uint64_t tbb::task_group_context::init(uint64_t this, uint64_t a2, uint64_t a3, void *a4)
{
  *(_OWORD *)(this + 8) = 0u;
  *(_OWORD *)(this + 24) = 0u;
  *(void *)(this + 136) = 0;
  *(void *)(this + 144) = 0;
  *(void *)(this + 152) = 0;
  *(void *)(this + 160) = 1;
  *(void *)(this + 112) = 0;
  *(void *)(this + 120) = 0;
  if ((*(unsigned char *)(this + 130) & 2) != 0)
  {
    uint64_t v4 = this;
    uint64_t v5 = (fenv_t *)tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
    *(void *)(v4 + 112) = v5;
    return fegetenv(v5);
  }
  return this;
}

void *tbb::task_group_context::register_with(void *result, void *a2)
{
  uint64_t v3 = result;
  result[2] = a2 + 37;
  uint64_t v4 = result + 2;
  result[18] = a2;
  a2[41] = 1;
  __dmb(0xBu);
  if (a2[46])
  {
    uint64_t v5 = result[18] + 312;
    uint64_t v6 = (atomic_uint *)(v5 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_3:
    int v7 = *v6 & ~(255 << (8 * (v5 & 3)));
    while (1)
    {
      int v8 = v7;
      atomic_compare_exchange_strong(v6, (unsigned int *)&v8, v7 | (1 << (8 * (v5 & 3))));
      if (v8 == v7) {
        break;
      }
      if (*v6 != v7)
      {
        __n128 result = (void *)sched_yield();
        goto LABEL_3;
      }
    }
    int v9 = (void *)a2[38];
    *int v9 = v4;
    v3[3] = v9;
    *(void *)(v3[18] + 328) = 0;
    a2[38] = v4;
    __dmb(0xBu);
    *(unsigned char *)uint64_t v5 = 0;
  }
  else
  {
    int v10 = (void *)a2[38];
    *int v10 = v4;
    result[3] = v10;
    uint64_t v11 = result[18];
    __dmb(0xBu);
    *(void *)(v11 + 328) = 0;
    __dmb(0xBu);
    a2[38] = v4;
  }
  return result;
}

uint64_t tbb::task_group_context::bind_to(uint64_t this, tbb::internal::generic_scheduler *a2, uint64_t a3, void *a4)
{
  uint64_t v5 = this;
  uint64_t v6 = *(void **)(*((void *)a2 + 7) - 56);
  *(void *)(this + 8) = v6;
  if ((*(unsigned char *)(this + 130) & 2) != 0)
  {
    uint64_t v7 = v6[19];
    if (v7) {
      goto LABEL_3;
    }
LABEL_11:
    v6[19] = v7 | 1;
    if (v6[1]) {
      goto LABEL_4;
    }
    goto LABEL_12;
  }
  *(void *)(this + 112) = 0;
  this = tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
  *(void *)(v5 + 112) = this;
  *(_OWORD *)this = *(_OWORD *)v6[14];
  *(void *)(v5 + 128) |= 0x20000uLL;
  uint64_t v6 = *(void **)(v5 + 8);
  uint64_t v7 = v6[19];
  if ((v7 & 1) == 0) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6[1])
  {
LABEL_4:
    uint64_t v8 = *(void *)(v6[18] + 320);
    __dmb(0xBu);
    *(void *)(v5 + 16) = (char *)a2 + 296;
    uint64_t v9 = v5 + 16;
    uint64_t v10 = *(void *)(v5 + 8);
    *(void *)(v5 + 120) = *(void *)(v10 + 120);
    *(void *)(v5 + 160) = *(void *)(v10 + 160);
    *(void *)(v5 + 144) = a2;
    *((void *)a2 + 41) = 1;
    __dmb(0xBu);
    if (*((void *)a2 + 46))
    {
      uint64_t v11 = *(void *)(v5 + 144) + 312;
      int v12 = (atomic_uint *)(v11 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_6:
      int v13 = *v12 & ~(255 << (8 * (v11 & 3)));
      while (1)
      {
        int v14 = v13;
        atomic_compare_exchange_strong(v12, (unsigned int *)&v14, v13 | (1 << (8 * (v11 & 3))));
        if (v14 == v13) {
          break;
        }
        if (*v12 != v13)
        {
          this = sched_yield();
          goto LABEL_6;
        }
      }
      int v20 = (uint64_t *)*((void *)a2 + 38);
      uint64_t *v20 = v9;
      *(void *)(v5 + 24) = v20;
      *(void *)(*(void *)(v5 + 144) + 328) = 0;
      *((void *)a2 + 38) = v9;
      __dmb(0xBu);
      *(unsigned char *)uint64_t v11 = 0;
    }
    else
    {
      int v21 = (uint64_t *)*((void *)a2 + 38);
      *int v21 = v9;
      *(void *)(v5 + 24) = v21;
      uint64_t v22 = *(void *)(v5 + 144);
      __dmb(0xBu);
      *(void *)(v22 + 328) = 0;
      __dmb(0xBu);
      *((void *)a2 + 38) = v9;
    }
    if (v8 != tbb::internal::the_context_state_propagation_epoch)
    {
LABEL_21:
      char v23 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
      int v24 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v23);
      unsigned int v25 = v24 | (1 << v23);
      while (1)
      {
        int v26 = v24;
        atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v26, v25);
        if (v26 == v24) {
          break;
        }
        if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v24)
        {
          this = sched_yield();
          goto LABEL_21;
        }
      }
      uint64_t v27 = *(void *)(v5 + 8);
      *(void *)(v5 + 120) = *(void *)(v27 + 120);
      *(void *)(v5 + 160) = *(void *)(v27 + 160);
      __dmb(0xBu);
      LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
    }
    goto LABEL_29;
  }
LABEL_12:
  *(void *)(v5 + 16) = (char *)a2 + 296;
  uint64_t v15 = v5 + 16;
  *(void *)(v5 + 144) = a2;
  *((void *)a2 + 41) = 1;
  __dmb(0xBu);
  if (*((void *)a2 + 46))
  {
    uint64_t v16 = *(void *)(v5 + 144) + 312;
    uint64_t v17 = (atomic_uint *)(v16 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_14:
    int v18 = *v17 & ~(255 << (8 * (v16 & 3)));
    while (1)
    {
      int v19 = v18;
      atomic_compare_exchange_strong(v17, (unsigned int *)&v19, v18 | (1 << (8 * (v16 & 3))));
      if (v19 == v18) {
        break;
      }
      if (*v17 != v18)
      {
        this = sched_yield();
        goto LABEL_14;
      }
    }
    int v28 = (uint64_t *)*((void *)a2 + 38);
    uint64_t *v28 = v15;
    *(void *)(v5 + 24) = v28;
    *(void *)(*(void *)(v5 + 144) + 328) = 0;
    *((void *)a2 + 38) = v15;
    __dmb(0xBu);
    *(unsigned char *)uint64_t v16 = 0;
  }
  else
  {
    uint64_t v29 = (uint64_t *)*((void *)a2 + 38);
    uint64_t *v29 = v15;
    *(void *)(v5 + 24) = v29;
    uint64_t v30 = *(void *)(v5 + 144);
    __dmb(0xBu);
    *(void *)(v30 + 328) = 0;
    __dmb(0xBu);
    *((void *)a2 + 38) = v15;
  }
  uint64_t v31 = *(void *)(v5 + 8);
  *(void *)(v5 + 120) = *(void *)(v31 + 120);
  *(void *)(v5 + 160) = *(void *)(v31 + 160);
LABEL_29:
  *(_DWORD *)uint64_t v5 = 2;
  return this;
}

__n128 tbb::task_group_context::copy_fp_settings(tbb::task_group_context *this, const tbb::task_group_context *a2, uint64_t a3, void *a4)
{
  *((void *)this + 14) = 0;
  uint64_t v6 = (__n128 *)tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
  *((void *)this + 14) = v6;
  __n128 result = *(__n128 *)*((void *)a2 + 14);
  *uint64_t v6 = result;
  *((void *)this + 16) |= 0x20000uLL;
  return result;
}

uint64_t tbb::task_group_context::cancel_group_execution(tbb::task_group_context *this)
{
  if (*((void *)this + 15)) {
    return 0;
  }
  while (1)
  {
    uint64_t v2 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 15, (unint64_t *)&v2, 1uLL);
    if (!v2) {
      break;
    }
    if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 15, 0, memory_order_relaxed)) {
      return 0;
    }
  }
  unint64_t v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v5) {
    unint64_t inited = v5 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t inited = tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t v3 = 1;
  sub_216769200(*(void *)(inited + 120), 120, (uint64_t)this, 1);
  return v3;
}

uint64_t sub_216769200(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 1;
  if (*(unsigned char *)(a3 + 152))
  {
LABEL_2:
    char v9 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
    int v10 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v9);
    unsigned int v11 = v10 | (1 << v9);
    while (1)
    {
      int v12 = v10;
      atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v12, v11);
      if (v12 == v10) {
        break;
      }
      if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v10)
      {
        sched_yield();
        goto LABEL_2;
      }
    }
    BOOL v36 = *(void *)(a3 + a2) == a4;
    if (*(void *)(a3 + a2) == a4)
    {
      atomic_fetch_add(&tbb::internal::the_context_state_propagation_epoch, 1uLL);
      uint64_t v13 = *(unsigned int *)(a1 + 36);
      __dmb(0xBu);
      if (v13)
      {
        for (uint64_t i = 0; i != v13; ++i)
        {
          uint64_t v16 = *(void *)(a1 + 8 * i + 248);
          if (v16)
          {
            uint64_t v17 = (atomic_uint *)((v16 + 312) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_13:
            int v18 = *v17 & ~(255 << (8 * ((v16 + 56) & 3)));
            while (1)
            {
              int v19 = v18;
              atomic_compare_exchange_strong(v17, (unsigned int *)&v19, v18 | (1 << (8 * ((v16 + 56) & 3))));
              if (v19 == v18) {
                break;
              }
              if (*v17 != v18)
              {
                sched_yield();
                goto LABEL_13;
              }
            }
            uint64_t v20 = *(void *)(v16 + 304);
            __dmb(0xBu);
            while (v20 != v16 + 296)
            {
              uint64_t v21 = v20 - 16;
              if (v20 - 16 != a3 && *(void *)(v20 - 16 + a2) != a4)
              {
                uint64_t v23 = v20 - 16;
                while (1)
                {
                  uint64_t v23 = *(void *)(v23 + 8);
                  if (!v23) {
                    break;
                  }
                  if (v23 == a3)
                  {
                    do
                    {
                      *(void *)(v21 + a2) = a4;
                      uint64_t v21 = *(void *)(v21 + 8);
                    }
                    while (v21 != a3);
                    break;
                  }
                }
              }
              uint64_t v20 = *(void *)(v20 + 8);
            }
            uint64_t v15 = tbb::internal::the_context_state_propagation_epoch;
            __dmb(0xBu);
            *(void *)(v16 + 320) = v15;
            __dmb(0xBu);
            *(unsigned char *)(v16 + 312) = 0;
          }
        }
      }
      uint64_t v24 = a1 + 224;
      for (uint64_t j = *(void *)(a1 + 232); j != v24; uint64_t j = *(void *)(j + 8))
      {
        if (j) {
          uint64_t v27 = j - 16;
        }
        else {
          uint64_t v27 = 0;
        }
        int v28 = (atomic_uint *)((v27 + 312) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_36:
        int v29 = *v28 & ~(255 << (8 * ((v27 + 56) & 3)));
        while (1)
        {
          int v30 = v29;
          atomic_compare_exchange_strong(v28, (unsigned int *)&v30, v29 | (1 << (8 * ((v27 + 56) & 3))));
          if (v30 == v29) {
            break;
          }
          if (*v28 != v29)
          {
            sched_yield();
            goto LABEL_36;
          }
        }
        uint64_t v31 = *(void *)(v27 + 304);
        __dmb(0xBu);
        while (v31 != v27 + 296)
        {
          uint64_t v32 = v31 - 16;
          if (v31 - 16 != a3 && *(void *)(v31 - 16 + a2) != a4)
          {
            uint64_t v34 = v31 - 16;
            while (1)
            {
              uint64_t v34 = *(void *)(v34 + 8);
              if (!v34) {
                break;
              }
              if (v34 == a3)
              {
                do
                {
                  *(void *)(v32 + a2) = a4;
                  uint64_t v32 = *(void *)(v32 + 8);
                }
                while (v32 != a3);
                break;
              }
            }
          }
          uint64_t v31 = *(void *)(v31 + 8);
        }
        uint64_t v26 = tbb::internal::the_context_state_propagation_epoch;
        __dmb(0xBu);
        *(void *)(v27 + 320) = v26;
        __dmb(0xBu);
        *(unsigned char *)(v27 + 312) = 0;
      }
    }
    __dmb(0xBu);
    LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
    return v36;
  }
  return v4;
}

void sub_2167694CC(_Unwind_Exception *a1)
{
  LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
  _Unwind_Resume(a1);
}

BOOL tbb::task_group_context::is_group_execution_cancelled(tbb::task_group_context *this)
{
  return *((void *)this + 15) != 0;
}

std::exception_ptr *tbb::task_group_context::reset(tbb::task_group_context *this)
{
  __n128 result = (std::exception_ptr *)*((void *)this + 17);
  if (result)
  {
    std::exception_ptr::~exception_ptr(result);
    __n128 result = (std::exception_ptr *)tbb::internal::deallocate_via_handler_v3(v3, v4);
    *((void *)this + 17) = 0;
  }
  *((void *)this + 15) = 0;
  return result;
}

uint64_t tbb::task_group_context::capture_fp_settings(tbb::task_group_context *this, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = *((void *)this + 16);
  if ((v5 & 0x20000) != 0)
  {
    uint64_t v6 = (fenv_t *)*((void *)this + 14);
    if (v6) {
      goto LABEL_5;
    }
  }
  else
  {
    *((void *)this + 14) = 0;
    *((void *)this + 16) = v5 | 0x20000;
  }
  uint64_t v6 = (fenv_t *)tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
  *((void *)this + 14) = v6;
LABEL_5:

  return fegetenv(v6);
}

uint64_t tbb::task_group_context::register_pending_exception(uint64_t this)
{
  if (!*(void *)(this + 120)) {
    __cxa_rethrow();
  }
  return this;
}

uint64_t tbb::task_group_context::set_priority(uint64_t result, int a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (a2 - 0x1FFFFFFF) / 0x1FFFFFFF;
  if (*(void *)(result + 160) != v3 || (*(unsigned char *)(result + 152) & 1) != 0)
  {
    *(void *)(result + 160) = v3;
    __n128 result = (uint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
    uint64_t v4 = (void *)(result & 0xFFFFFFFFFFFFFFFELL);
    if ((result & 0xFFFFFFFFFFFFFFFELL) != 0)
    {
      if (v4[6])
      {
        __n128 result = sub_216769200(v4[15], 160, v2, v3);
        if (result)
        {
          if (!*(unsigned char *)(v4[7] - 12))
          {
            uint64_t v5 = v4[15];
            uint64_t v6 = v4[6];
            return tbb::internal::market::update_arena_priority(v5, v6, v3);
          }
        }
      }
    }
  }
  return result;
}

uint64_t tbb::task_group_context::priority(tbb::task_group_context *this)
{
  return dword_217406198[*((void *)this + 20)];
}

void sub_2167697E4(uint64_t a1)
{
  exception = (tbb::captured_exception *)__cxa_allocate_exception(0x20uLL);
  sub_216769840(exception, a1);
}

void sub_21676982C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

tbb::captured_exception *sub_216769840(tbb::captured_exception *a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C7469A0;
  *((unsigned char *)a1 + 8) = 0;
  tbb::captured_exception::set(a1, *(const char **)(a2 + 16), *(const char **)(a2 + 24));
  return a1;
}

void sub_216769890(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = &unk_26C7469A0;
  char v3 = 0;
  tbb::captured_exception::set((tbb::captured_exception *)&v2, *(const char **)(a2 + 16), *(const char **)(a2 + 24));
  sub_216769940((uint64_t)&v2);
}

uint64_t sub_2167698EC(int a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, tbb::internal *a11, tbb::internal *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  tbb::internal::deallocate_via_handler_v3((uint64_t)v19[2].__vftable, a2);
  tbb::internal::deallocate_via_handler_v3((uint64_t)v19[3].__vftable, v17);
  v19[0].__vftable = (std::exception_vtbl *)&unk_26C746A18;
  std::exception::~exception(v19);
  return v16;
}

void sub_216769940(uint64_t a1)
{
  exception = (tbb::captured_exception *)__cxa_allocate_exception(0x20uLL);
  *(void *)exception = &unk_26C7469A0;
  *((unsigned char *)exception + 8) = 0;
  tbb::captured_exception::set(exception, *(const char **)(a1 + 16), *(const char **)(a1 + 24));
}

void sub_2167699B4(void *a1)
{
}

uint64_t tbb::internal::initialize_cilk_interop(tbb::internal *this)
{
  return tbb::internal::dynamic_link((uint64_t)"libcilkrts.so", (uint64_t)&off_264294138, 1, 0);
}

tbb::internal *tbb::internal::governor::acquire_resources(tbb::internal::governor *this)
{
  uint64_t v1 = (tbb::internal *)pthread_key_create((pthread_key_t *)&tbb::internal::governor::theTLS, (void (__cdecl *)(void *))tbb::internal::governor::auto_terminate);
  uint64_t v2 = v1;
  if (v1)
  {
    if (qword_26798E068 != -1) {
      dispatch_once(&qword_26798E068, &unk_26C746A50);
    }
    char v3 = qword_26798E060;
    uint64_t v1 = (tbb::internal *)os_log_type_enabled((os_log_t)qword_26798E060, OS_LOG_TYPE_ERROR);
    if (v1) {
      sub_217323A20((int)v2, v3);
    }
  }
  has_speculation = (tbb::internal *)tbb::internal::cpu_has_speculation(v1);
  tbb::internal::governor::is_speculation_enabled = (char)has_speculation;
  tbb::internal::governor::is_rethrow_broken = tbb::internal::gcc_rethrow_exception_broken(has_speculation);
  return v2;
}

uint64_t tbb::internal::governor::auto_terminate(uint64_t this, void *a2)
{
  unint64_t v2 = this & 0xFFFFFFFFFFFFFFFELL;
  if ((this & 0xFFFFFFFFFFFFFFFELL) == 0) {
    return this;
  }
  if (!*(unsigned char *)(v2 + 160)) {
    return this;
  }
  uint64_t v3 = *(void *)(v2 + 152) - 1;
  *(void *)(v2 + 152) = v3;
  if (v3) {
    return this;
  }
  uint64_t v4 = this;
  uint64_t v5 = pthread_getspecific(tbb::internal::governor::theTLS);
  if (*(void *)(v2 + 48))
  {
    if ((void *)(v4 | 1) != v5)
    {
      BOOL v6 = 1;
LABEL_9:
      pthread_setspecific(tbb::internal::governor::theTLS, (const void *)(v6 | v2));
    }
  }
  else
  {
    BOOL v6 = (*(unsigned char *)(v2 + 74) & 1) == 0;
    if ((void *)(v2 | v6) != v5) {
      goto LABEL_9;
    }
  }

  return tbb::internal::generic_scheduler::cleanup_master(v2, 0);
}

uint64_t tbb::internal::governor::release_resources(tbb::internal::governor *this)
{
  tbb::internal::rml::tbb_factory::close((unint64_t)&tbb::internal::governor::theRMLServerFactory);
  uint64_t v1 = (tbb::internal *)pthread_key_delete(tbb::internal::governor::theTLS);
  if (v1)
  {
    unint64_t v2 = strerror((int)v1);
    uint64_t v1 = (tbb::internal *)tbb::internal::runtime_warning((tbb::internal *)"failed to destroy task scheduler TLS: %s", v3, v2);
  }

  return tbb::internal::dynamic_unlink_all(v1);
}

uint64_t tbb::internal::governor::create_rml_server(uint64_t a1, const char *a2, uint64_t a3, void *a4)
{
  if (!tbb::internal::governor::UsePrivateRML)
  {
    uint64_t server = tbb::internal::rml::tbb_factory::make_server((uint64_t)&tbb::internal::governor::theRMLServerFactory);
    if (server)
    {
      tbb::internal::governor::UsePrivateRML = 1;
      tbb::internal::runtime_warning((tbb::internal *)"rml::tbb_factory::make_server failed with status %x, falling back on private rml", a2, server);
    }
  }
  return tbb::internal::rml::make_private_server(a1, (uint64_t)a2, a3, a4);
}

unint64_t tbb::internal::governor::tls_value_of(unint64_t result)
{
  if (result)
  {
    if (*(void *)(result + 48)) {
      result |= 1uLL;
    }
    else {
      result |= (*(unsigned char *)(result + 74) & 1) == 0;
    }
  }
  return result;
}

uint64_t tbb::internal::governor::assume_scheduler(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 48)) {
      BOOL v1 = 1;
    }
    else {
      BOOL v1 = (*(unsigned char *)(a1 + 74) & 1) == 0;
    }
  }
  else
  {
    BOOL v1 = 0;
  }
  return pthread_setspecific(tbb::internal::governor::theTLS, (const void *)(v1 | a1));
}

BOOL tbb::internal::governor::is_set(uint64_t a1)
{
  unint64_t v2 = pthread_getspecific(tbb::internal::governor::theTLS);
  if (a1)
  {
    if (*(void *)(a1 + 48)) {
      BOOL v3 = 1;
    }
    else {
      BOOL v3 = (*(unsigned char *)(a1 + 74) & 1) == 0;
    }
  }
  else
  {
    BOOL v3 = 0;
  }
  return (v3 | a1) == (void)v2;
}

uint64_t tbb::internal::governor::sign_on(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 48)) {
      BOOL v2 = 1;
    }
    else {
      BOOL v2 = (*(unsigned char *)(a1 + 74) & 1) == 0;
    }
  }
  else
  {
    BOOL v2 = 0;
  }
  uint64_t result = pthread_setspecific(tbb::internal::governor::theTLS, (const void *)(v2 | a1));
  if (off_26798E030)
  {
    uint64_t result = off_26798E030(a1 + 376, tbb::internal::governor::stack_op_handler, a1);
    if (result) {
      *(void *)(a1 + 376) = 0;
    }
  }
  return result;
}

uint64_t tbb::internal::governor::stack_op_handler(int a1, uint64_t this)
{
  switch(a1)
  {
    case 0:
      pthread_key_t v3 = tbb::internal::governor::theTLS;
      uint64_t v4 = 0;
LABEL_12:
      pthread_setspecific(v3, v4);
      return 0;
    case 2:
      *(void *)(this + 376) = 0;
      tbb::internal::governor::auto_terminate(this, (void *)this);
      break;
    case 1:
      if (this)
      {
        if (*(void *)(this + 48)) {
          BOOL v2 = 1;
        }
        else {
          BOOL v2 = (*(unsigned char *)(this + 74) & 1) == 0;
        }
      }
      else
      {
        BOOL v2 = 0;
      }
      uint64_t v4 = (const void *)(v2 | this);
      pthread_key_t v3 = tbb::internal::governor::theTLS;
      goto LABEL_12;
  }
  return 0;
}

uint64_t tbb::internal::governor::sign_off(uint64_t a1)
{
  uint64_t result = pthread_setspecific(tbb::internal::governor::theTLS, 0);
  pthread_key_t v3 = *(uint64_t (**)(uint64_t))(a1 + 376);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 384);
    return v3(v4);
  }
  return result;
}

uint64_t tbb::internal::governor::one_time_init(uint64_t this)
{
  int v1 = tbb::internal::__TBB_InitOnce::InitializationDone;
  __dmb(0xBu);
  if (!v1) {
    this = (uint64_t)tbb::internal::DoOneTimeInitializations((tbb::internal *)this);
  }
  int v2 = dword_26798E038;
  __dmb(0xBu);
  if (v2 != 2)
  {
    while (1)
    {
      int v3 = dword_26798E038;
      __dmb(0xBu);
      if (!v3) {
        break;
      }
LABEL_9:
      while (1)
      {
        int v5 = dword_26798E038;
        __dmb(0xBu);
        if (v5 != 1) {
          break;
        }
        this = sched_yield();
      }
      int v6 = dword_26798E038;
      __dmb(0xBu);
      if (v6 == 2) {
        return this;
      }
    }
    while (1)
    {
      int v4 = 0;
      atomic_compare_exchange_strong(&dword_26798E038, (unsigned int *)&v4, 1u);
      if (!v4) {
        break;
      }
      if (dword_26798E038) {
        goto LABEL_9;
      }
    }
    this = tbb::internal::dynamic_link((uint64_t)"libcilkrts.so", (uint64_t)&off_264294138, 1, 0);
    if (this) {
      int v7 = 2;
    }
    else {
      int v7 = 0;
    }
    __dmb(0xBu);
    dword_26798E038 = v7;
  }
  return this;
}

uint64_t tbb::internal::governor::init_scheduler_weak(tbb::internal::governor *this)
{
  tbb::internal::governor::one_time_init((uint64_t)this);
  uint64_t result = tbb::internal::generic_scheduler::create_master(0, v1, v2, v3, v4);
  *(unsigned char *)(result + 160) = 1;
  return result;
}

uint64_t tbb::internal::governor::init_scheduler(tbb::internal::governor *this, uint64_t a2, char a3)
{
  unint64_t v5 = (unint64_t)this;
  uint64_t v22 = *MEMORY[0x263EF8340];
  tbb::internal::governor::one_time_init((uint64_t)this);
  unint64_t v6 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v6)
  {
    unint64_t v9 = v6;
    uint64_t master = v6 & 0xFFFFFFFFFFFFFFFELL;
    if ((v6 & 1) == 0)
    {
      uint64_t v11 = tbb::internal::governor::DefaultNumberOfThreads;
      if (!tbb::internal::governor::DefaultNumberOfThreads)
      {
        *(void *)uint64_t v21 = 0x1900000006;
        int v20 = 0;
        size_t v19 = 4;
        sysctl(v21, 2u, &v20, &v19, 0, 0);
        if (v20 <= 1) {
          uint64_t v11 = 1;
        }
        else {
          uint64_t v11 = v20;
        }
        tbb::internal::governor::DefaultNumberOfThreads = v11;
      }
      arena = tbb::internal::market::create_arena((tbb::internal::market *)v11, 1, 0, v7, v8);
      tbb::internal::generic_scheduler::attach_arena(master, (uint64_t)arena, 0, 1);
      **(void **)(master + 40) = master;
      *(void *)(*(void *)(master + 48) + 320) = *(void *)(*(void *)(master + 144) - 56);
      pthread_setspecific(tbb::internal::governor::theTLS, (const void *)(v9 | 1));
    }
    if ((a3 & 1) == 0) {
      ++*(void *)(master + 152);
    }
  }
  else
  {
    if (v5 == -1)
    {
      unint64_t v5 = tbb::internal::governor::DefaultNumberOfThreads;
      if (!tbb::internal::governor::DefaultNumberOfThreads)
      {
        *(void *)uint64_t v21 = 0x1900000006;
        int v20 = 0;
        size_t v19 = 4;
        sysctl(v21, 2u, &v20, &v19, 0, 0);
        if (v20 <= 1) {
          unint64_t v5 = 1;
        }
        else {
          unint64_t v5 = v20;
        }
        tbb::internal::governor::DefaultNumberOfThreads = v5;
      }
    }
    uint64_t v13 = tbb::internal::market::create_arena((tbb::internal::market *)v5, 1, a2, v7, v8);
    uint64_t master = tbb::internal::generic_scheduler::create_master(v13, v14, v15, v16, v17);
    *(unsigned char *)(master + 160) = a3;
  }
  return master;
}

uint64_t sub_21676A158()
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  uint64_t result = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(void *)uint64_t v3 = 0x1900000006;
    int v2 = 0;
    size_t v1 = 4;
    sysctl(v3, 2u, &v2, &v1, 0, 0);
    if (v2 <= 1) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = v2;
    }
    tbb::internal::governor::DefaultNumberOfThreads = result;
  }
  return result;
}

uint64_t tbb::internal::governor::terminate_scheduler(tbb::internal::governor *this, tbb::internal::generic_scheduler *a2)
{
  uint64_t v2 = *((void *)this + 19) - 1;
  *((void *)this + 19) = v2;
  if (v2) {
    return 0;
  }
  else {
    return tbb::internal::generic_scheduler::cleanup_master((uint64_t)this, (uint64_t)a2);
  }
}

const char *tbb::internal::governor::print_version_info(tbb::internal::governor *this, uint64_t a2, const char *a3)
{
  if (tbb::internal::governor::UsePrivateRML)
  {
    uint64_t result = tbb::internal::PrintExtraVersionInfo("RML", "private", a3);
  }
  else
  {
    tbb::internal::PrintExtraVersionInfo("RML", "shared", a3);
    uint64_t result = (const char *)tbb::internal::rml::tbb_factory::call_with_server_info((tbb::internal::rml::tbb_factory *)&tbb::internal::governor::theRMLServerFactory, (void (*)(void *, const char *))tbb::internal::PrintRMLVersionInfo, "");
  }
  if (off_26798E030)
  {
    return tbb::internal::PrintExtraVersionInfo("CILK", "libcilkrts.so", v4);
  }
  return result;
}

uint64_t tbb::internal::governor::initialize_rml_factory(tbb::internal::governor *this)
{
  uint64_t result = tbb::internal::rml::tbb_factory::open((tbb::internal::rml::tbb_factory *)&tbb::internal::governor::theRMLServerFactory);
  tbb::internal::governor::UsePrivateRML = result != 0;
  return result;
}

void tbb::internal::numa_topology::initialization_impl(tbb::internal::numa_topology *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E040, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26798E040))
  {
    dword_26798E03C = sub_21676A158();
    __cxa_guard_release(&qword_26798E040);
  }
  byte_26798E048 = 1;
  qword_26798E050 = (uint64_t)&dword_26798E03C;
}

void sub_21676A36C(_Unwind_Exception *a1)
{
}

void tbb::internal::numa_topology::initialize(uint64_t this)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  int v1 = dword_26798E058;
  __dmb(0xBu);
  if (v1 != 2)
  {
    while (1)
    {
      int v2 = dword_26798E058;
      __dmb(0xBu);
      if (!v2) {
        break;
      }
LABEL_7:
      while (1)
      {
        int v4 = dword_26798E058;
        __dmb(0xBu);
        if (v4 != 1) {
          break;
        }
        this = sched_yield();
      }
      int v5 = dword_26798E058;
      __dmb(0xBu);
      if (v5 == 2) {
        return;
      }
    }
    while (1)
    {
      int v3 = 0;
      atomic_compare_exchange_strong(&dword_26798E058, (unsigned int *)&v3, 1u);
      if (!v3) {
        break;
      }
      if (dword_26798E058) {
        goto LABEL_7;
      }
    }
    tbb::internal::governor::one_time_init(this);
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E040, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26798E040))
    {
      int v6 = tbb::internal::governor::DefaultNumberOfThreads;
      if (!tbb::internal::governor::DefaultNumberOfThreads)
      {
        *(void *)unint64_t v9 = 0x1900000006;
        int v8 = 0;
        size_t v7 = 4;
        sysctl(v9, 2u, &v8, &v7, 0, 0);
        int v6 = v8;
        if (v8 <= 1) {
          int v6 = 1;
        }
        tbb::internal::governor::DefaultNumberOfThreads = v6;
      }
      dword_26798E03C = v6;
      __cxa_guard_release(&qword_26798E040);
    }
    byte_26798E048 = 1;
    qword_26798E050 = (uint64_t)&dword_26798E03C;
    __dmb(0xBu);
    dword_26798E058 = 2;
  }
}

void sub_21676A504(_Unwind_Exception *a1)
{
}

uint64_t tbb::internal::numa_topology::nodes_count(tbb::internal::numa_topology *this)
{
  return byte_26798E048;
}

void tbb::internal::numa_topology::fill(tbb::internal::numa_topology *this, int *a2)
{
  if (byte_26798E048 == 1) {
    *(_DWORD *)this = -1;
  }
}

uint64_t tbb::internal::numa_topology::default_concurrency(tbb::internal::numa_topology *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if ((this & 0x80000000) != 0)
  {
    uint64_t result = tbb::internal::governor::DefaultNumberOfThreads;
    if (!tbb::internal::governor::DefaultNumberOfThreads)
    {
      *(void *)int v5 = 0x1900000006;
      int v4 = 0;
      size_t v3 = 4;
      sysctl(v5, 2u, &v4, &v3, 0, 0);
      if (v4 <= 1) {
        uint64_t result = 1;
      }
      else {
        uint64_t result = v4;
      }
      tbb::internal::governor::DefaultNumberOfThreads = result;
    }
  }
  else
  {
    unsigned int v1 = this;
    tbb::internal::numa_topology::initialize((uint64_t)this);
    return *(unsigned int *)(qword_26798E050 + 4 * v1);
  }
  return result;
}

uint64_t tbb::internal::construct_binding_handler(tbb::internal *this)
{
  return 0;
}

uint64_t tbb::task_scheduler_init::initialize(uint64_t this, tbb::internal::governor *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  if (a2 != -2)
  {
    uint64_t v6 = (void *)this;
    if (*(void *)this) {
      tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x1FF, "!my_scheduler", "task_scheduler_init already initialized", a5);
    }
    if (a2 != -1 && (int)a2 <= 0) {
      tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x201, "number_of_threads==automatic || number_of_threads > 0", "number_of_threads for task_scheduler_init must be automatic or positive", a5);
    }
    this = tbb::internal::governor::init_scheduler(a2, 0, 0);
    if ((~*(unsigned __int8 *)(this + 74) & 3) == 0) {
      this |= (*(void *)(*(void *)(*(void *)(this + 144) - 56) + 128) >> 16) & 1;
    }
    *uint64_t v6 = this;
  }
  return this;
}

{
  unint64_t v5;
  char v6;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t vars8;

  int v5 = a3 & 0xFFFFFFFFFFFFFFFCLL;
  if (a2 == -2)
  {
    if (v5)
    {
      return (uint64_t)tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x212, "!thread_stack_size", "deferred initialization ignores stack size setting", a5);
    }
  }
  else
  {
    uint64_t v6 = a3;
    int v8 = (void *)this;
    if (*(void *)this) {
      tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x1FF, "!my_scheduler", "task_scheduler_init already initialized", a5);
    }
    if (a2 != -1 && (int)a2 <= 0) {
      tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x201, "number_of_threads==automatic || number_of_threads > 0", "number_of_threads for task_scheduler_init must be automatic or positive", a5);
    }
    this = tbb::internal::governor::init_scheduler(a2, v5, 0);
    if ((~*(unsigned __int8 *)(this + 74) & 3) == 0)
    {
      unint64_t v9 = *(void *)(*(void *)(this + 144) - 56);
      uint64_t v10 = *(void *)(v9 + 128);
      uint64_t v11 = (v10 >> 16) & 1;
      int v12 = v10 & 0xFFFFFFFFFFFEFFFFLL;
      if ((v6 & 2) == 0) {
        int v12 = *(void *)(v9 + 128);
      }
      uint64_t v13 = v10 | 0x10000;
      if ((v6 & 1) == 0) {
        uint64_t v13 = v12;
      }
      *(void *)(v9 + 128) = v13;
      this |= v11;
    }
    *int v8 = this;
  }
  return this;
}

uint64_t tbb::task_scheduler_init::internal_terminate(tbb::task_scheduler_init *this, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v6 = *(void *)this;
  *(void *)this = 0;
  unint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
  if ((v6 & 0xFFFFFFFFFFFFFFFELL) == 0) {
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x21D, "s", "task_scheduler_init::terminate without corresponding task_scheduler_init::initialize()", a5);
  }
  if ((~*(unsigned __int8 *)(v7 + 74) & 3) == 0) {
    *(void *)(*(void *)(*(void *)(v7 + 144) - 56) + 128) = *(void *)(*(void *)(*(void *)(v7 + 144) - 56)
  }
                                                                               + 128) & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(v6 & 1) << 16);
  uint64_t v8 = *(void *)(v7 + 152) - 1;
  *(void *)(v7 + 152) = v8;
  if (v8) {
    return 0;
  }

  return tbb::internal::generic_scheduler::cleanup_master(v6 & 0xFFFFFFFFFFFFFFFELL, a2);
}

const char *tbb::task_scheduler_init::terminate(const char *this, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v5 = *(void *)this;
  *(void *)this = 0;
  unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFFELL;
  if ((v5 & 0xFFFFFFFFFFFFFFFELL) == 0) {
    this = tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x21D, "s", "task_scheduler_init::terminate without corresponding task_scheduler_init::initialize()", a5);
  }
  if ((~*(unsigned __int8 *)(v6 + 74) & 3) == 0) {
    *(void *)(*(void *)(*(void *)(v6 + 144) - 56) + 128) = *(void *)(*(void *)(*(void *)(v6 + 144) - 56)
  }
                                                                               + 128) & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(v5 & 1) << 16);
  uint64_t v7 = *(void *)(v6 + 152) - 1;
  *(void *)(v6 + 152) = v7;
  if (!v7)
  {
    return (const char *)tbb::internal::generic_scheduler::cleanup_master(v5 & 0xFFFFFFFFFFFFFFFELL, 0);
  }
  return this;
}

uint64_t tbb::task_scheduler_init::internal_blocking_terminate(tbb::task_scheduler_init *this, int a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v6 = *(void *)this;
  *(void *)this = 0;
  unint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
  if ((v6 & 0xFFFFFFFFFFFFFFFELL) == 0) {
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/governor.cpp", (const char *)0x21D, "s", "task_scheduler_init::terminate without corresponding task_scheduler_init::initialize()", a5);
  }
  if ((~*(unsigned __int8 *)(v7 + 74) & 3) == 0) {
    *(void *)(*(void *)(*(void *)(v7 + 144) - 56) + 128) = *(void *)(*(void *)(*(void *)(v7 + 144) - 56)
  }
                                                                               + 128) & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(v6 & 1) << 16);
  uint64_t v8 = *(void *)(v7 + 152) - 1;
  *(void *)(v7 + 152) = v8;
  if (v8)
  {
    uint64_t v9 = 0;
    if (!a2) {
      return v9;
    }
  }
  else
  {
    uint64_t v9 = tbb::internal::generic_scheduler::cleanup_master(v6 & 0xFFFFFFFFFFFFFFFELL, 1);
    if (!a2) {
      return v9;
    }
  }
  if ((v9 & 1) == 0) {
    tbb::internal::throw_exception_v4(19);
  }
  return v9;
}

uint64_t tbb::task_scheduler_init::default_num_threads(tbb::task_scheduler_init *this)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  uint64_t result = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(void *)int v4 = 0x1900000006;
    int v3 = 0;
    size_t v2 = 4;
    sysctl(v4, 2u, &v3, &v2, 0, 0);
    if (v3 <= 1) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = v3;
    }
    tbb::internal::governor::DefaultNumberOfThreads = result;
  }
  return result;
}

os_log_t sub_21676AAF0()
{
  os_log_t result = os_log_create("com.apple.usdlib", "tbbgovernor");
  qword_26798E060 = (uint64_t)result;
  return result;
}

uint64_t tbb::internal::market::insert_arena_into_list(uint64_t result, void *a2)
{
  uint64_t v2 = result + 40 * a2[17];
  uint64_t v3 = a2[17];
  uint64_t v4 = *(void *)(v2 + 80);
  uint64_t v5 = *(void *)(v2 + 88);
  *a2 = v2 + 72;
  a2[1] = v4;
  **(void **)(v2 + 80) = a2;
  *(void *)(v2 + 80) = a2;
  *(void *)(v2 + 88) = v5 + 1;
  if (!v5) {
    *(void *)(result + 40 * v3 + 96) = a2;
  }
  return result;
}

uint64_t tbb::internal::market::remove_arena_from_list(uint64_t result, void *a2)
{
  uint64_t v2 = (void *)(result + 72 + 40 * a2[17]);
  if ((void *)v2[3] == a2)
  {
    uint64_t v3 = a2[1];
    if ((void *)v3 == v2)
    {
      uint64_t v3 = result + 72 + 40 * a2[17];
      if (v2[2] >= 2uLL) {
        uint64_t v3 = v2[1];
      }
    }
    v2[3] = v3;
  }
  --v2[2];
  uint64_t v4 = (void *)a2[1];
  void *v4 = *a2;
  *(void *)(*a2 + 8) = v4;
  return result;
}

int64x2_t *tbb::internal::market::market(int64x2_t *this, const char *a2, uint64_t a3, void *a4)
{
  this->i64[0] = (uint64_t)&unk_26C746A80;
  this->i64[1] = 0;
  this[1].i32[2] = a3;
  this[1].i32[3] = (int)a2;
  this[3] = vdupq_n_s64(1uLL);
  this[5].i64[0] = (uint64_t)&this[4].i64[1];
  this[5].i64[1] = 0;
  this[4].i64[1] = (uint64_t)&this[4].i64[1];
  this[7].i64[1] = (uint64_t)this[7].i64;
  this[8].i64[0] = 0;
  this[7].i64[0] = (uint64_t)this[7].i64;
  this[10].i64[0] = (uint64_t)&this[9].i64[1];
  this[10].i64[1] = 0;
  this[9].i64[1] = (uint64_t)&this[9].i64[1];
  this[12].i32[2] = 1;
  this[13].i64[0] = (uint64_t)a4;
  this[13].i32[3] = (int)a2;
  this[14].i64[1] = (uint64_t)this[14].i64;
  this[15].i64[0] = 0;
  this[14].i64[0] = (uint64_t)this[14].i64;
  this[9].i32[1] = (int)a2;
  this[1].i64[0] = tbb::internal::governor::create_rml_server((uint64_t)this, a2, a3, a4);
  return this;
}

{
  this->i64[0] = (uint64_t)&unk_26C746A80;
  this->i64[1] = 0;
  this[1].i32[2] = a3;
  this[1].i32[3] = (int)a2;
  this[3] = vdupq_n_s64(1uLL);
  this[5].i64[0] = (uint64_t)&this[4].i64[1];
  this[5].i64[1] = 0;
  this[4].i64[1] = (uint64_t)&this[4].i64[1];
  this[7].i64[1] = (uint64_t)this[7].i64;
  this[8].i64[0] = 0;
  this[7].i64[0] = (uint64_t)this[7].i64;
  this[10].i64[0] = (uint64_t)&this[9].i64[1];
  this[10].i64[1] = 0;
  this[9].i64[1] = (uint64_t)&this[9].i64[1];
  this[12].i32[2] = 1;
  this[13].i64[0] = (uint64_t)a4;
  this[13].i32[3] = (int)a2;
  this[14].i64[1] = (uint64_t)this[14].i64;
  this[15].i64[0] = 0;
  this[14].i64[0] = (uint64_t)this[14].i64;
  this[9].i32[1] = (int)a2;
  this[1].i64[0] = tbb::internal::governor::create_rml_server((uint64_t)this, a2, a3, a4);
  return this;
}

int64x2_t *tbb::internal::market::global_market(uint64_t this, const char *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  unint64_t v5 = a3;
  int v7 = this;
  uint64_t v42 = *MEMORY[0x263EF8340];
LABEL_2:
  char v8 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  int v9 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v8);
  unsigned int v10 = v9 | (1 << v8);
  while (1)
  {
    int v11 = v9;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v11, v10);
    if (v11 == v9) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v9)
    {
      this = sched_yield();
      goto LABEL_2;
    }
  }
  int v12 = (int64x2_t *)tbb::internal::market::theMarket;
  if (tbb::internal::market::theMarket)
  {
    ++*(_DWORD *)(tbb::internal::market::theMarket + 200);
    if (v7)
    {
      __int32 v13 = v12[12].i32[3];
      v12[12].i32[3] = v13 + 1;
      __dmb(0xBu);
      LOBYTE(tbb::internal::market::theMarketMutex) = 0;
      if (!v13)
      {
        unsigned int v14 = v12[1].u32[2];
        int v15 = tbb::internal::market::app_parallelism_limit((tbb::internal::market *)this);
        if (v15)
        {
          unsigned int v16 = v15 - 1;
        }
        else
        {
          int v33 = tbb::internal::governor::DefaultNumberOfThreads;
          if (!tbb::internal::governor::DefaultNumberOfThreads)
          {
            *(void *)uint64_t v41 = 0x1900000006;
            int v40 = 0;
            size_t v39 = 4;
            sysctl(v41, 2u, &v40, &v39, 0, 0);
            int v33 = v40;
            if (v40 <= 1) {
              int v33 = 1;
            }
            tbb::internal::governor::DefaultNumberOfThreads = v33;
          }
          unsigned int v16 = v33 - 1;
          if (v16 <= a2) {
            unsigned int v16 = a2;
          }
        }
        if (v16 >= v14) {
          uint64_t v34 = v14 - 1;
        }
        else {
          uint64_t v34 = v16;
        }
        tbb::internal::market::set_active_num_workers(v34);
      }
    }
    else
    {
      __dmb(0xBu);
      LOBYTE(tbb::internal::market::theMarketMutex) = 0;
    }
    int v35 = tbb::internal::governor::DefaultNumberOfThreads;
    if (!tbb::internal::governor::DefaultNumberOfThreads)
    {
      *(void *)uint64_t v41 = 0x1900000006;
      int v40 = 0;
      size_t v39 = 4;
      sysctl(v41, 2u, &v40, &v39, 0, 0);
      int v35 = v40;
      if (v40 <= 1) {
        int v35 = 1;
      }
      tbb::internal::governor::DefaultNumberOfThreads = v35;
    }
    if (v35 - 1 != a2)
    {
      unsigned int v36 = v12[13].u32[3];
      if (v36 < a2)
      {
        tbb::internal::runtime_warning((tbb::internal *)"The number of workers is currently limited to %u. The request for %u workers is ignored. Further requests for more workers will be silently ignored until the limit changes.\n", a2, v12[13].u32[3], a2);
        do
        {
          unsigned int v37 = v36;
          atomic_compare_exchange_strong(&v12[13].i32[3], &v37, 0xFFFFFFFF);
        }
        while (v37 != v36 && v12[13].i32[3] == v36);
      }
    }
    if (v12[13].i64[0] < v5) {
      tbb::internal::runtime_warning((tbb::internal *)"Thread stack size has been already set to %u. The request for larger stack (%u) cannot be satisfied.\n", a2, v12[13].i64[0], v5);
    }
  }
  else
  {
    if (!v5)
    {
      this = tbb::interface9::global_control::active_value((tbb::interface9::global_control *)1, (int)a2, a3, a4, a5);
      unint64_t v5 = this;
    }
    unsigned int v17 = tbb::internal::governor::DefaultNumberOfThreads;
    if (!tbb::internal::governor::DefaultNumberOfThreads)
    {
      *(void *)uint64_t v41 = 0x1900000006;
      int v40 = 0;
      size_t v39 = 4;
      this = sysctl(v41, 2u, &v40, &v39, 0, 0);
      if (v40 <= 1) {
        unsigned int v17 = 1;
      }
      else {
        unsigned int v17 = v40;
      }
      tbb::internal::governor::DefaultNumberOfThreads = v17;
    }
    int v18 = (tbb::internal::market *)tbb::internal::market::app_parallelism_limit((tbb::internal::market *)this);
    if (v17 >= 0x81) {
      char v19 = 1;
    }
    else {
      char v19 = 2;
    }
    unsigned int v20 = v17 << v19;
    if (v20 <= v18) {
      unsigned int v20 = v18;
    }
    if (v20 <= 0x100) {
      unsigned int v21 = 256;
    }
    else {
      unsigned int v21 = v20;
    }
    uint64_t v22 = (tbb::internal::__TBB_InitOnce *)tbb::internal::market::app_parallelism_limit(v18);
    if (v22)
    {
      unsigned int v23 = v22 - 1;
    }
    else
    {
      int v24 = tbb::internal::governor::DefaultNumberOfThreads;
      if (!tbb::internal::governor::DefaultNumberOfThreads)
      {
        *(void *)uint64_t v41 = 0x1900000006;
        int v40 = 0;
        size_t v39 = 4;
        uint64_t v22 = (tbb::internal::__TBB_InitOnce *)sysctl(v41, 2u, &v40, &v39, 0, 0);
        int v24 = v40;
        if (v40 <= 1) {
          int v24 = 1;
        }
        tbb::internal::governor::DefaultNumberOfThreads = v24;
      }
      unsigned int v23 = v24 - 1;
      if (v23 <= a2) {
        unsigned int v23 = a2;
      }
    }
    if (v23 >= v21) {
      uint64_t v25 = v21 - 1;
    }
    else {
      uint64_t v25 = v23;
    }
    tbb::internal::__TBB_InitOnce::add_ref(v22);
    int v12 = (int64x2_t *)tbb::internal::NFS_Allocate(1uLL, 8 * (v21 - 1) + 256, 0, v26);
    bzero(v12, 8 * (v21 - 1) + 256);
    v12->i64[0] = (uint64_t)&unk_26C746A80;
    v12->i64[1] = 0;
    v12[1].i32[2] = v21;
    v12[1].i32[3] = v25;
    v12[3] = vdupq_n_s64(1uLL);
    v12[5].i64[0] = (uint64_t)&v12[4].i64[1];
    v12[5].i64[1] = 0;
    v12[4].i64[1] = (uint64_t)&v12[4].i64[1];
    v12[7].i64[1] = (uint64_t)v12[7].i64;
    v12[8].i64[0] = 0;
    v12[7].i64[0] = (uint64_t)v12[7].i64;
    v12[10].i64[0] = (uint64_t)&v12[9].i64[1];
    v12[10].i64[1] = 0;
    v12[9].i64[1] = (uint64_t)&v12[9].i64[1];
    v12[12].i32[2] = 1;
    v12[13].i64[0] = v5;
    v12[13].i32[3] = v25;
    v12[14].i64[1] = (uint64_t)v12[14].i64;
    v12[15].i64[0] = 0;
    v12[14].i64[0] = (uint64_t)v12[14].i64;
    v12[9].i32[1] = v25;
    rml_uint64_t server = tbb::internal::governor::create_rml_server((uint64_t)v12, v27, v28, v29);
    v12[1].i64[0] = rml_server;
    if (v7) {
      v12[12].i32[3] = 1;
    }
    tbb::internal::market::theMarket = (uint64_t)v12;
    if (!tbb::internal::governor::UsePrivateRML
      && (*(unsigned int (**)(uint64_t))(*(void *)rml_server + 32))(rml_server) < v25)
    {
      uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v12[1].i64[0] + 32))(v12[1].i64[0]);
      tbb::internal::runtime_warning((tbb::internal *)"RML might limit the number of workers to %u while %u is requested.\n", v32, v31, v25);
    }
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  }
  return v12;
}

void sub_21676B17C(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *unsigned int v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::market::set_active_num_workers(uint64_t this)
{
  int v1 = this;
LABEL_2:
  char v2 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  int v3 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v2);
  unsigned int v4 = v3 | (1 << v2);
  while (1)
  {
    int v5 = v3;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v5, v4);
    if (v5 == v3) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v3)
    {
      this = sched_yield();
      goto LABEL_2;
    }
  }
  uint64_t v6 = tbb::internal::market::theMarket;
  if (!tbb::internal::market::theMarket || *(_DWORD *)(tbb::internal::market::theMarket + 28) == v1) {
    goto LABEL_27;
  }
  ++*(_DWORD *)(tbb::internal::market::theMarket + 200);
  __dmb(0xBu);
  LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  int v7 = (atomic_ullong *)(v6 + 8);
  tbb::spin_rw_mutex_v3::internal_acquire_writer((atomic_ullong *)(v6 + 8));
  if (!*(_DWORD *)(v6 + 28))
  {
    int v22 = *(_DWORD *)(v6 + 44);
    if (v22 >= 1)
    {
      uint64_t v23 = *(int *)(v6 + 48);
      for (uint64_t i = *(void *)(v6 + 56); i <= v23; --v23)
      {
        uint64_t v25 = v6 + 40 * v23;
        uint64_t v26 = v25 + 72;
        for (uint64_t j = *(void *)(v25 + 80); j != v26; uint64_t j = *(void *)(j + 8))
        {
          if (*(unsigned char *)(j + 337))
          {
            *(unsigned char *)(j + 337) = 0;
            *(_DWORD *)(v6 + 44) = --v22;
          }
        }
      }
    }
  }
  __dmb(0xBu);
  *(_DWORD *)(v6 + 28) = v1;
  *(_DWORD *)(v6 + 220) = v1;
  uint64_t v8 = *(void *)(v6 + 48);
  if (!v1)
  {
    uint64_t v9 = *(void *)(v6 + 56);
    for (uint64_t k = (int)v8; v9 <= k; --k)
    {
      uint64_t v29 = v6 + 40 * k;
      uint64_t v30 = v29 + 72;
      for (uint64_t m = *(void *)(v29 + 80); m != v30; uint64_t m = *(void *)(m + 8))
      {
        if (*(void *)(m + 8 * k + 152))
        {
          *(unsigned char *)(m + 337) = 1;
          ++*(_DWORD *)(v6 + 44);
        }
      }
    }
  }
  int v11 = *(_DWORD *)(v6 + 32);
  int v12 = *(_DWORD *)(v6 + 40);
  if (v12 >= v1) {
    int v12 = v1;
  }
  if (*(int *)(v6 + 44) >= 1) {
    int v12 = 1;
  }
  *(_DWORD *)(v6 + 32) = v12;
  *(_DWORD *)(v6 + 40 * v8 + 108) = v12;
  this = tbb::internal::market::update_allotment(v6, v8);
  int v13 = *(_DWORD *)(v6 + 32);
LABEL_16:
  atomic_ullong v14 = *v7;
  unint64_t v15 = *v7 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v16 = v14;
    atomic_compare_exchange_strong(v7, (unint64_t *)&v16, v15);
    if (v16 == v14) {
      break;
    }
    if (atomic_fetch_add_explicit(v7, 0, memory_order_relaxed) != v14)
    {
      this = sched_yield();
      goto LABEL_16;
    }
  }
  if (v13 != v11) {
    this = (*(uint64_t (**)(void, void))(**(void **)(v6 + 16) + 40))(*(void *)(v6 + 16), (v13 - v11));
  }
LABEL_22:
  char v17 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  int v18 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v17);
  unsigned int v19 = v18 | (1 << v17);
  while (1)
  {
    int v20 = v18;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v20, v19);
    if (v20 == v18) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v18)
    {
      this = sched_yield();
      goto LABEL_22;
    }
  }
  int v21 = *(_DWORD *)(v6 + 200) - 1;
  *(_DWORD *)(v6 + 200) = v21;
  if (v21)
  {
LABEL_27:
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  }
  else
  {
    tbb::internal::market::theMarket = 0;
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
    *(unsigned char *)(v6 + 216) = 0;
    uint64_t v28 = *(uint64_t (**)(void))(**(void **)(v6 + 16) + 8);
    return v28();
  }
  return this;
}

tbb::internal::governor *tbb::internal::market::destroy(tbb::internal::market *this, void *a2)
{
  char v2 = (tbb::internal::governor *)tbb::internal::NFS_Free(this, a2);

  return tbb::internal::__TBB_InitOnce::remove_ref(v2);
}

uint64_t tbb::internal::market::release(tbb::internal::market *this, int a2, uint64_t a3)
{
LABEL_1:
  char v6 = 8 * (&tbb::internal::market::theMarketMutex & 3);
  int v7 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v6);
  unsigned int v8 = v7 | (1 << v6);
  while (1)
  {
    int v9 = v7;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v9, v8);
    if (v9 == v7) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v7)
    {
      sched_yield();
      goto LABEL_1;
    }
  }
  if (a3 && *((_DWORD *)this + 51) == 1)
  {
    do
    {
      if (*((_DWORD *)this + 50) < 2u) {
        break;
      }
      __dmb(0xBu);
      LOBYTE(tbb::internal::market::theMarketMutex) = 0;
      while (1)
      {
        int v10 = *((_DWORD *)this + 51);
        __dmb(0xBu);
        if (v10 != 1) {
          break;
        }
        unsigned int v11 = *((_DWORD *)this + 50);
        __dmb(0xBu);
        if (v11 < 2) {
          break;
        }
        sched_yield();
      }
LABEL_14:
      char v12 = 8 * (&tbb::internal::market::theMarketMutex & 3);
      int v13 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v12);
      unsigned int v14 = v13 | (1 << v12);
      while (1)
      {
        int v15 = v13;
        atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v15, v14);
        if (v15 == v13) {
          break;
        }
        if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v13)
        {
          sched_yield();
          goto LABEL_14;
        }
      }
    }
    while (*((_DWORD *)this + 51) == 1);
  }
  if (a2) {
    --*((_DWORD *)this + 51);
  }
  int v16 = *((_DWORD *)this + 50) - 1;
  *((_DWORD *)this + 50) = v16;
  if (v16)
  {
    a3 = 0;
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
  }
  else
  {
    tbb::internal::market::theMarket = 0;
    __dmb(0xBu);
    LOBYTE(tbb::internal::market::theMarketMutex) = 0;
    *((unsigned char *)this + 216) = a3;
    (*(void (**)(void, void))(**((void **)this + 2) + 8))(*((void *)this + 2), 0);
  }
  return a3;
}

  unsigned int v11 = (long long *)((char *)a2 - 24);
  char v12 = (const void **)a1;
LABEL_2:
  int v13 = 1 - a4;
  while (1)
  {
    a1 = (uint64_t)v12;
    unsigned int v14 = v13;
    int v15 = (char *)a2 - (char *)v12;
    int v16 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)v12) >> 3);
    if (!(!v6 & v5))
    {
      switch(v16)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (sub_21677B108(a3, (const void **)a2 - 3, v12))
          {
            uint64_t v31 = v12[2];
            uint64_t v29 = *(_OWORD *)v12;
            uint64_t v27 = *v11;
            void v12[2] = (const void *)*((void *)a2 - 1);
            *(_OWORD *)char v12 = v27;
            *unsigned int v11 = v29;
            *((void *)a2 - 1) = v31;
          }
          break;
        case 3uLL:
          sub_2168793B4(v12, v12 + 3, (const void **)a2 - 3, a3);
          break;
        case 4uLL:
          sub_216879A78((uint64_t)v12, v12 + 3, v12 + 6, (long long *)((char *)a2 - 24), a3);
          break;
        case 5uLL:
          sub_216879B64((uint64_t)v12, v12 + 3, v12 + 6, (long long *)(v12 + 9), (long long *)((char *)a2 - 24), a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v15 <= 575) {
      break;
    }
    if (v14 == 1)
    {
      if (v12 != (const void **)a2)
      {
        sub_216879C88((uint64_t)v12, a2, a2, a3);
      }
      return;
    }
    char v17 = v16 >> 1;
    int v18 = &v12[3 * (v16 >> 1)];
    if ((unint64_t)v15 >= 0xC01)
    {
      sub_2168793B4(v12, &v12[3 * (v16 >> 1)], (const void **)a2 - 3, a3);
      unsigned int v19 = 3 * v17;
      int v20 = &v12[3 * v17 - 3];
      sub_2168793B4(v12 + 3, v20, (const void **)a2 - 6, a3);
      int v21 = v12 + 6;
      int v22 = &v12[v19 + 3];
      sub_2168793B4(v21, v22, (const void **)a2 - 9, a3);
      sub_2168793B4(v20, v18, v22, a3);
      uint64_t v30 = *(const void **)(a1 + 16);
      uint64_t v28 = *(_OWORD *)a1;
      uint64_t v23 = *(_OWORD *)v18;
      *(void *)(a1 + 16) = v18[2];
      *(_OWORD *)a1 = v23;
      v18[2] = v30;
      *(_OWORD *)int v18 = v28;
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_2168793B4(&v12[3 * (v16 >> 1)], v12, (const void **)a2 - 3, a3);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (!sub_21677B108(a3, (const void **)(a1 - 24), (const void **)a1))
    {
      char v12 = sub_216879500((const void **)a1, (unint64_t)a2, a3);
      goto LABEL_18;
    }
LABEL_13:
    int v24 = sub_216879694((long long *)a1, (const void **)a2, a3);
    if ((v25 & 1) == 0) {
      goto LABEL_16;
    }
    uint64_t v26 = sub_216879824(a1, v24, a3);
    char v12 = (const void **)(v24 + 24);
    if (sub_216879824(v24 + 24, (uint64_t)a2, a3))
    {
      a4 = -v14;
      a2 = (long long *)v24;
      if (v26) {
        return;
      }
      goto LABEL_1;
    }
    int v13 = v14 + 1;
    if (!v26)
    {
LABEL_16:
      sub_216878D58(a1, v24, a3, -v14, a5 & 1);
      char v12 = (const void **)(v24 + 24);
LABEL_18:
      a5 = 0;
      a4 = -v14;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_216879180((uint64_t)v12, (const void **)a2, a3);
  }
  else
  {
    sub_2168792A8(v12, (const void **)a2, a3);
  }
}

  unsigned int v11 = a1;
LABEL_2:
  char v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    int v13 = v12;
    unsigned int v14 = (char *)a2 - (char *)v11;
    int v15 = ((char *)a2 - (char *)v11) >> 5;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          uint64_t v26 = *(a2 - 4);
          uint64_t v27 = *v11;
          if (v26 < *v11) {
            goto LABEL_25;
          }
          if (v27 >= v26 && pxrInternal__aapl__pxrReserved__::TraceThreadId::operator<(a2 - 3, v11 + 1))
          {
            uint64_t v27 = *v11;
            uint64_t v26 = *(a2 - 4);
LABEL_25:
            *unsigned int v11 = v26;
            *(a2 - 4) = v27;
            uint64_t v28 = v11[1];
            *(void *)((char *)&v32 + 7) = *(unint64_t *)((char *)v11 + 23);
            *(void *)&uint64_t v32 = v11[2];
            uint64_t v29 = *((unsigned char *)v11 + 31);
            v11[2] = 0;
            v11[3] = 0;
            v11[1] = 0;
            uint64_t v30 = *(_OWORD *)(a2 - 3);
            v11[3] = *(a2 - 1);
            *(_OWORD *)(v11 + 1) = v30;
            *(a2 - 3) = v28;
            *(a2 - 2) = v32;
            *(unint64_t *)((char *)a2 - 9) = *(void *)((char *)&v32 + 7);
            *((unsigned char *)a2 - 1) = v29;
          }
          break;
        case 3uLL:
          sub_2168C14B4(v11, v11 + 4, a2 - 4);
          return;
        case 4uLL:
          sub_2168C2058((uint64_t)v11, (uint64_t)(v11 + 4), (uint64_t)(v11 + 8), (uint64_t)(a2 - 4));
          return;
        case 5uLL:
          sub_2168C2274((uint64_t)v11, (uint64_t)(v11 + 4), (uint64_t)(v11 + 8), (uint64_t)(v11 + 12), a2 - 4);
          return;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 767) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        sub_2168C2524((uint64_t)v11, (uint64_t)a2, (uint64_t)a2, a3);
      }
      return;
    }
    int v16 = v15 >> 1;
    char v17 = &v11[4 * (v15 >> 1)];
    if ((unint64_t)v14 > 0x1000)
    {
      sub_2168C14B4(v11, &v11[4 * (v15 >> 1)], a2 - 4);
      sub_2168C14B4(v11 + 4, v17 - 4, a2 - 8);
      sub_2168C14B4(v11 + 8, &v11[4 * v16 + 4], a2 - 12);
      sub_2168C14B4(v17 - 4, v17, &v11[4 * v16 + 4]);
      int v18 = *v11;
      unsigned int v19 = v11[1];
      *unsigned int v11 = *v17;
      const char *v17 = v18;
      *(void *)((char *)&v31 + 7) = *(unint64_t *)((char *)v11 + 23);
      *(void *)&uint64_t v31 = v11[2];
      int v20 = *((unsigned char *)v11 + 31);
      v11[2] = 0;
      v11[3] = 0;
      v11[1] = 0;
      int v21 = *(_OWORD *)(v17 + 1);
      v11[3] = v17[3];
      *(_OWORD *)(v11 + 1) = v21;
      v17[1] = v19;
      *(unint64_t *)((char *)v17 + 23) = *(void *)((char *)&v31 + 7);
      v17[2] = v31;
      *((unsigned char *)v17 + 31) = v20;
      if (a5) {
        goto LABEL_15;
      }
    }
    else
    {
      sub_2168C14B4(&v11[4 * (v15 >> 1)], v11, a2 - 4);
      if (a5) {
        goto LABEL_15;
      }
    }
    int v22 = *(v11 - 4);
    if (v22 >= *v11 && (*v11 < v22 || !pxrInternal__aapl__pxrReserved__::TraceThreadId::operator<(v11 - 3, v11 + 1)))
    {
      unsigned int v11 = sub_2168C17BC((uint64_t *)v11, (unint64_t)a2);
      goto LABEL_20;
    }
LABEL_15:
    uint64_t v23 = sub_2168C1A74((uint64_t *)v11, (unint64_t)a2);
    if ((v24 & 1) == 0) {
      goto LABEL_18;
    }
    uint64_t v25 = sub_2168C1D24((uint64_t)v11, (unint64_t *)v23);
    unsigned int v11 = (unint64_t *)(v23 + 4);
    if (sub_2168C1D24((uint64_t)(v23 + 4), a2))
    {
      a4 = -v13;
      a2 = (unint64_t *)v23;
      if (v25) {
        return;
      }
      goto LABEL_1;
    }
    char v12 = v13 + 1;
    if (!v25)
    {
LABEL_18:
      sub_2168C0C64(a1, v23, a3, -v13, a5 & 1);
      unsigned int v11 = (unint64_t *)(v23 + 4);
LABEL_20:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_2168C11A4(v11, a2);
  }
  else
  {
    sub_2168C1344(v11, a2);
  }
}

  unsigned int v4 = 8 * (&dword_267B8E668 & 3);
  int v5 = *(_DWORD *)((unint64_t)&dword_267B8E668 & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v4);
  char v6 = v5 | (1 << v4);
  while (1)
  {
    int v7 = v5;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&dword_267B8E668 & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v7, v6);
    if (v7 == v5) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&dword_267B8E668 & 0xFFFFFFFFFFFFFFFCLL) != v5)
    {
      sched_yield();
      goto LABEL_1;
    }
  }
  sub_2168514A0(a1 + 8, a2, (uint64_t)a2);
  os_log_t result = v8 & 1;
  __dmb(0xBu);
  LOBYTE(dword_267B8E668) = 0;
  return result;
}

  unsigned int v11 = a1;
LABEL_2:
  char v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    int v13 = v12;
    unsigned int v14 = (char *)a2 - (char *)v11;
    int v15 = 0x6DB6DB6DB6DB6DB7 * (((char *)a2 - (char *)v11) >> 3);
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (pxrInternal__aapl__pxrReserved__::SdfReference::operator<((unsigned __int8 *)a2 - 56, v11))
          {
            sub_2169D66C8((uint64_t)v11, (long long *)((char *)a2 - 56));
          }
          break;
        case 3uLL:
          sub_2169D5D58(v11, v11 + 56, (unsigned __int8 *)a2 - 56);
          break;
        case 4uLL:
          sub_2169D688C(v11, v11 + 56, v11 + 112, (long long *)((char *)a2 - 56));
          break;
        case 5uLL:
          sub_2169D6938(v11, v11 + 56, v11 + 112, (long long *)(v11 + 168), (long long *)((char *)a2 - 56));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 1343) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != (unsigned __int8 *)a2)
      {
        sub_2169D6A10((long long *)v11, a2, (unsigned __int8 *)a2, a3);
      }
      return;
    }
    int v16 = v15 >> 1;
    char v17 = &v11[56 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x1C01)
    {
      sub_2169D5D58(v11, &v11[56 * (v15 >> 1)], (unsigned __int8 *)a2 - 56);
      int v18 = 56 * v16;
      unsigned int v19 = &v11[56 * v16 - 56];
      sub_2169D5D58(v11 + 56, v19, (unsigned __int8 *)a2 - 112);
      int v20 = v11 + 112;
      int v21 = &v11[v18 + 56];
      sub_2169D5D58(v20, v21, (unsigned __int8 *)a2 - 168);
      sub_2169D5D58(v19, v17, v21);
      sub_2169D66C8((uint64_t)a1, (long long *)v17);
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_2169D5D58(&v11[56 * (v15 >> 1)], v11, (unsigned __int8 *)a2 - 56);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (!pxrInternal__aapl__pxrReserved__::SdfReference::operator<(a1 - 56, a1))
    {
      unsigned int v11 = sub_2169D5E1C((uint64_t)a1, (unsigned __int8 *)a2);
      goto LABEL_18;
    }
LABEL_13:
    int v22 = sub_2169D60B4((uint64_t)a1, (unsigned __int8 *)a2);
    if ((v23 & 1) == 0) {
      goto LABEL_16;
    }
    int v24 = sub_2169D6360((uint64_t)a1, (uint64_t)v22);
    unsigned int v11 = v22 + 56;
    if (sub_2169D6360((uint64_t)(v22 + 56), (uint64_t)a2))
    {
      a4 = -v13;
      a2 = (long long *)v22;
      if (v24) {
        return;
      }
      goto LABEL_1;
    }
    char v12 = v13 + 1;
    if (!v24)
    {
LABEL_16:
      sub_2169D54C8(a1, v22, a3, -v13, a5 & 1);
      unsigned int v11 = v22 + 56;
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_2169D58E0(v11, (unsigned __int8 *)a2);
  }
  else
  {
    sub_2169D5B38((uint64_t)v11, (unsigned __int8 *)a2);
  }
}

  unsigned int v11 = a1;
LABEL_2:
  char v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    int v13 = v12;
    unsigned int v14 = (char *)a2 - (char *)v11;
    int v15 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)v11) >> 4);
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (pxrInternal__aapl__pxrReserved__::SdfPayload::operator<((const void **)a2 - 6, v11))
          {
            sub_2169D953C((uint64_t)v11, a2 - 3);
          }
          break;
        case 3uLL:
          sub_2169D8CB4(v11, (const void **)v11 + 6, (const void **)a2 - 6);
          break;
        case 4uLL:
          sub_2169D96B0(v11, (const void **)v11 + 6, (const void **)v11 + 12, a2 - 3);
          break;
        case 5uLL:
          sub_2169D975C(v11, (const void **)v11 + 6, (const void **)v11 + 12, (long long *)v11 + 9, a2 - 3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 1151) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != (unsigned __int8 *)a2)
      {
        sub_2169D9834((long long *)v11, a2, (const void **)a2, a3);
      }
      return;
    }
    int v16 = v15 >> 1;
    char v17 = (const void **)&v11[48 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x1801)
    {
      sub_2169D8CB4(v11, (const void **)&v11[48 * (v15 >> 1)], (const void **)a2 - 6);
      int v18 = 3 * v16;
      unsigned int v19 = (const void **)&v11[48 * v16 - 48];
      sub_2169D8CB4(v11 + 48, v19, (const void **)a2 - 12);
      int v20 = v11 + 96;
      int v21 = (const void **)&v11[16 * v18 + 48];
      sub_2169D8CB4(v20, v21, (const void **)a2 - 18);
      sub_2169D8CB4((unsigned __int8 *)v19, v17, v21);
      sub_2169D953C((uint64_t)a1, (long long *)v17);
      if (a5) {
        goto LABEL_13;
      }
    }
    else
    {
      sub_2169D8CB4(&v11[48 * (v15 >> 1)], (const void **)v11, (const void **)a2 - 6);
      if (a5) {
        goto LABEL_13;
      }
    }
    if (!pxrInternal__aapl__pxrReserved__::SdfPayload::operator<((const void **)a1 - 6, a1))
    {
      unsigned int v11 = sub_2169D8D78((uint64_t)a1, (unsigned __int8 *)a2);
      goto LABEL_18;
    }
LABEL_13:
    int v22 = sub_2169D8FCC((uint64_t)a1, (const void **)a2);
    if ((v23 & 1) == 0) {
      goto LABEL_16;
    }
    int v24 = sub_2169D9228((uint64_t)a1, (uint64_t)v22);
    unsigned int v11 = (unsigned __int8 *)(v22 + 6);
    if (sub_2169D9228((uint64_t)(v22 + 6), (uint64_t)a2))
    {
      a4 = -v13;
      a2 = (long long *)v22;
      if (v24) {
        return;
      }
      goto LABEL_1;
    }
    char v12 = v13 + 1;
    if (!v24)
    {
LABEL_16:
      sub_2169D84D0(a1, v22, a3, -v13, a5 & 1);
      unsigned int v11 = (unsigned __int8 *)(v22 + 6);
LABEL_18:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_2169D88D4((const void **)v11, (const void **)a2);
  }
  else
  {
    sub_2169D8AD4((const void **)v11, (const void **)a2);
  }
}

  unsigned int v11 = a1;
LABEL_2:
  char v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    int v13 = v12;
    unsigned int v14 = a2 - v11;
    int v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v11) >> 3);
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          unsigned int v36 = *(char **)(a2 - 24);
          int v35 = a2 - 24;
          uint64_t v34 = v36;
          if (*(char *)(v35 + 23) >= 0) {
            uint64_t v34 = (char *)v35;
          }
          unsigned int v37 = *v34;
          if (*(char *)(v11 + 23) >= 0) {
            uint64_t v38 = (char *)v11;
          }
          else {
            uint64_t v38 = *(char **)v11;
          }
          if (v37 < 0
            || (size_t v39 = *v38, v39 < 0)
            || ((int v40 = v37,
                 uint64_t v41 = v39,
                 uint64_t v42 = (v39 ^ v40) & 0xFFFFFFDF,
                 v40 >= 0x40)
              ? (int v43 = v42 == 0)
              : (int v43 = 1),
                v43 || v41 < 0x40))
          {
            if (!pxrInternal__aapl__pxrReserved__::TfDictionaryLessThan::_LessImpl(a3, v35, v11)) {
              return;
            }
          }
          else if ((((_BYTE)v40 + 5) & 0x1Fu) >= (((_BYTE)v41 + 5) & 0x1Fu))
          {
            return;
          }
          unsigned int v48 = *(void *)(v11 + 16);
          int v46 = *(_OWORD *)v11;
          int v44 = *(_OWORD *)v35;
          *(void *)(v11 + 16) = *(void *)(v35 + 16);
          *(_OWORD *)unsigned int v11 = v44;
          *(_OWORD *)int v35 = v46;
          *(void *)(v35 + 16) = v48;
          return;
        case 3uLL:
          sub_216C86E84(v11, v11 + 24, a2 - 24, a3);
          return;
        case 4uLL:
          sub_216C87EAC(v11, v11 + 24, v11 + 48, a2 - 24, a3);
          return;
        case 5uLL:
          sub_216C880E4(v11, v11 + 24, v11 + 48, v11 + 72, a2 - 24, a3);
          return;
        default:
          JUMPOUT(0);
      }
    }
    if (v14 <= 575) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        sub_216C883C8(v11, a2, a2, a3);
      }
      return;
    }
    int v16 = v15 >> 1;
    char v17 = v11 + 24 * (v15 >> 1);
    if ((unint64_t)v14 >= 0xC01)
    {
      sub_216C86E84(v11, v11 + 24 * (v15 >> 1), a2 - 24, a3);
      int v18 = 3 * v16;
      unsigned int v19 = v11 + 24 * v16 - 24;
      sub_216C86E84(v11 + 24, v19, a2 - 48, a3);
      int v20 = v11 + 48;
      int v21 = v11 + 24 + 8 * v18;
      sub_216C86E84(v20, v21, a2 - 72, a3);
      sub_216C86E84(v19, v17, v21, a3);
      int v47 = *(void *)(a1 + 16);
      int v45 = *(_OWORD *)a1;
      int v22 = *(_OWORD *)v17;
      *(void *)(a1 + 16) = *(void *)(v17 + 16);
      *(_OWORD *)a1 = v22;
      *(void *)(v17 + 16) = v47;
      *(_OWORD *)char v17 = v45;
      if (a5) {
        goto LABEL_25;
      }
    }
    else
    {
      sub_216C86E84(v11 + 24 * (v15 >> 1), v11, a2 - 24, a3);
      if (a5) {
        goto LABEL_25;
      }
    }
    uint64_t v23 = *(char **)(a1 - 24);
    if (*(char *)(a1 - 1) >= 0) {
      uint64_t v23 = (char *)(a1 - 24);
    }
    int v24 = *v23;
    if (*(char *)(a1 + 23) >= 0) {
      uint64_t v25 = (char *)a1;
    }
    else {
      uint64_t v25 = *(char **)a1;
    }
    if (v24 < 0
      || (uint64_t v26 = *v25, v26 < 0)
      || ((uint64_t v27 = v24,
           uint64_t v28 = v26,
           uint64_t v29 = (v26 ^ v27) & 0xFFFFFFDF,
           v27 >= 0x40)
        ? (uint64_t v30 = v29 == 0)
        : (uint64_t v30 = 1),
          v30 || v28 < 0x40))
    {
      if ((pxrInternal__aapl__pxrReserved__::TfDictionaryLessThan::_LessImpl(a3, a1 - 24, a1) & 1) == 0)
      {
LABEL_30:
        unsigned int v11 = sub_216C87204((long long *)a1, a2, a3);
LABEL_32:
        a5 = 0;
        a4 = -v13;
        goto LABEL_2;
      }
    }
    else if ((((_BYTE)v27 + 5) & 0x1Fu) >= (((_BYTE)v28 + 5) & 0x1Fu))
    {
      goto LABEL_30;
    }
LABEL_25:
    uint64_t v31 = sub_216C876A4((long long *)a1, a2, a3);
    if ((v32 & 1) == 0) {
      goto LABEL_31;
    }
    int v33 = sub_216C87AE0(a1, v31, a3);
    unsigned int v11 = v31 + 24;
    if (sub_216C87AE0(v31 + 24, a2, a3))
    {
      a4 = -v13;
      a2 = v31;
      if (v33) {
        return;
      }
      goto LABEL_1;
    }
    char v12 = v13 + 1;
    if (!v33)
    {
LABEL_31:
      sub_216C8653C(a1, v31, a3, -v13, a5 & 1);
      unsigned int v11 = v31 + 24;
      goto LABEL_32;
    }
  }
  if (a5)
  {
    sub_216C86A40(v11, a2, a3);
  }
  else
  {
    sub_216C86C74(v11, a2, a3);
  }
}

  int v10 = (uint64_t)(a2 - 6);
  unsigned int v11 = a1;
LABEL_2:
  char v12 = 1 - a4;
  while (1)
  {
    a1 = v11;
    int v13 = v12;
    unsigned int v14 = (uint64_t)a2 - v11;
    int v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v11) >> 4);
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          if (sub_217061310(a3, (const void **)v10, (const void **)v11))
          {
            int v35 = *(void *)(v11 + 16);
            int v33 = *(_OWORD *)v11;
            uint64_t v27 = *(_OWORD *)v10;
            *(void *)(v11 + 16) = *(void *)(v10 + 16);
            *(_OWORD *)unsigned int v11 = v27;
            *(_OWORD *)int v10 = v33;
            *(void *)(v10 + 16) = v35;
            uint64_t v28 = *(const void **)(v11 + 40);
            uint64_t v29 = *(_OWORD *)(v11 + 24);
            uint64_t v30 = (uint64_t)*(a2 - 1);
            *(_OWORD *)(v11 + 24) = *(_OWORD *)(a2 - 3);
            *(void *)(v11 + 40) = v30;
            *(_OWORD *)(a2 - 3) = v29;
            *(a2 - 1) = v28;
          }
          break;
        case 3uLL:
          sub_217061698((long long *)v11, (long long *)(v11 + 48), (long long *)v10, a3);
          break;
        case 4uLL:
          sub_217061ED0(v11, v11 + 48, v11 + 96, v10, a3);
          break;
        case 5uLL:
          sub_217062024(v11, v11 + 48, v11 + 96, v11 + 144, v10, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v14 <= 1151) {
      break;
    }
    if (v13 == 1)
    {
      if ((const void **)v11 != a2)
      {
        sub_2170621DC(v11, (uint64_t)a2, (uint64_t)a2, a3);
      }
      return;
    }
    int v16 = v15 >> 1;
    char v17 = v11 + 48 * (v15 >> 1);
    if ((unint64_t)v14 >= 0x1801)
    {
      sub_217061698((long long *)v11, (long long *)(v11 + 48 * (v15 >> 1)), (long long *)v10, a3);
      int v18 = v10;
      unsigned int v19 = v11 + 48 * v16;
      sub_217061698((long long *)(v11 + 48), (long long *)(v19 - 48), (long long *)a2 - 6, a3);
      sub_217061698((long long *)(v11 + 96), (long long *)(v11 + 48 + 48 * v16), (long long *)a2 - 9, a3);
      sub_217061698((long long *)(v19 - 48), (long long *)v17, (long long *)(v11 + 48 + 48 * v16), a3);
      uint64_t v34 = *(void *)(v11 + 16);
      uint64_t v32 = *(_OWORD *)v11;
      int v20 = *(_OWORD *)v17;
      *(void *)(v11 + 16) = *(void *)(v17 + 16);
      *(_OWORD *)unsigned int v11 = v20;
      *(void *)(v17 + 16) = v34;
      *(_OWORD *)char v17 = v32;
      int v21 = *(_OWORD *)(v11 + 24);
      int v22 = *(void *)(v11 + 40);
      uint64_t v23 = *(void *)(v19 + 40);
      *(_OWORD *)(v11 + 24) = *(_OWORD *)(v19 + 24);
      *(void *)(v11 + 40) = v23;
      *(void *)(v19 + 40) = v22;
      *(_OWORD *)(v19 + 24) = v21;
      int v10 = v18;
    }
    else
    {
      sub_217061698((long long *)(v11 + 48 * (v15 >> 1)), (long long *)v11, (long long *)v10, a3);
    }
    if ((a5 & 1) == 0 && (sub_217061310(a3, (const void **)(v11 - 48), (const void **)v11) & 1) == 0)
    {
      unsigned int v11 = sub_217061890(v11, (unint64_t)a2, a3);
      goto LABEL_17;
    }
    int v24 = sub_217061A6C(v11, a2, a3);
    if ((v25 & 1) == 0) {
      goto LABEL_15;
    }
    uint64_t v26 = sub_217061C4C(v11, (uint64_t)v24, a3);
    unsigned int v11 = (unint64_t)(v24 + 3);
    if (sub_217061C4C((uint64_t)(v24 + 3), (uint64_t)a2, a3))
    {
      a4 = -v13;
      a2 = (const void **)v24;
      if (v26) {
        return;
      }
      goto LABEL_1;
    }
    char v12 = v13 + 1;
    if (!v26)
    {
LABEL_15:
      sub_217060E7C(a1, v24, a3, -v13, a5 & 1);
      unsigned int v11 = (unint64_t)(v24 + 3);
LABEL_17:
      a5 = 0;
      a4 = -v13;
      goto LABEL_2;
    }
  }
  if (a5)
  {
    sub_21706143C(v11, a2, a3);
  }
  else
  {
    sub_217061580((const void **)v11, a2, a3);
  }
}

  unsigned int v8 = a2;
  v488 = a2 - 2;
  while (1)
  {
    int v9 = j;
    int v10 = (char *)v8 - (char *)j;
    unsigned int v11 = ((char *)v8 - (char *)j) >> 4;
    if (v5 || !v4)
    {
      switch(v11)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          v214 = *(a2 - 2);
          v215 = (std::__shared_weak_count *)*(a2 - 1);
          if (v215) {
            atomic_fetch_add_explicit(&v215->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v216 = *j;
          v217 = (std::__shared_weak_count *)j[1];
          if (v217) {
            atomic_fetch_add_explicit(&v217->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v220 = *(const void **)(v214 + 48);
          v218 = v214 + 48;
          v219 = v220;
          v221 = *(char *)(v218 + 23);
          v224 = *(const void **)(v216 + 48);
          v222 = v216 + 48;
          v223 = v224;
          v225 = *(char *)(v222 + 23);
          if (v225 >= 0) {
            v226 = *(unsigned __int8 *)(v222 + 23);
          }
          else {
            v226 = *(void *)(v222 + 8);
          }
          if (v225 >= 0) {
            v227 = (const void *)v222;
          }
          else {
            v227 = v223;
          }
          if (v221 >= 0) {
            v228 = *(unsigned __int8 *)(v218 + 23);
          }
          else {
            v228 = *(void *)(v218 + 8);
          }
          if (v221 >= 0) {
            v229 = (const void *)v218;
          }
          else {
            v229 = v219;
          }
          if (v228 >= v226) {
            v230 = v226;
          }
          else {
            v230 = v228;
          }
          v231 = memcmp(v227, v229, v230);
          if (v231) {
            v232 = v231 < 0;
          }
          else {
            v232 = v226 < v228;
          }
          if (v217) {
            sub_216784EC4(v217);
          }
          if (v215) {
            sub_216784EC4(v215);
          }
          if (v232)
          {
            v233 = *j;
            *uint64_t j = *(a2 - 2);
            *(a2 - 2) = v233;
            v234 = j[1];
            j[1] = *(a2 - 1);
            *(a2 - 1) = v234;
          }
          break;
        case 3uLL:
          sub_21730B67C(j, j + 2, v488);
          break;
        case 4uLL:
          sub_21730BE28(j, j + 2, j + 4, v488);
          break;
        case 5uLL:
          sub_21730B338(j, j + 2, j + 4, j + 6, v488);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    v497 = j;
    if (v10 <= 383) {
      break;
    }
    if (!a3)
    {
      if (j == v8) {
        return;
      }
      v483 = (char *)v8 - (char *)j;
      v484 = ((char *)v8 - (char *)j) >> 4;
      v282 = (v11 - 2) >> 1;
      v283 = v282;
      v489 = v282;
      while (1)
      {
        v284 = v283;
        if (v282 < v283) {
          goto LABEL_611;
        }
        v486 = v283;
        v285 = &v9[2 * ((2 * v283) | 1)];
        v286 = 2 * v283 + 2;
        v494 = (2 * v283) | 1;
        if (v286 >= (uint64_t)v11) {
          goto LABEL_520;
        }
        v287 = *v285;
        v288 = (std::__shared_weak_count *)v285[1];
        if (v288) {
          atomic_fetch_add_explicit(&v288->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v289 = v285[2];
        v290 = (std::__shared_weak_count *)v285[3];
        if (v290) {
          atomic_fetch_add_explicit(&v290->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v293 = *(const void **)(v287 + 48);
        v291 = v287 + 48;
        v292 = v293;
        v294 = *(char *)(v291 + 23);
        v297 = *(const void **)(v289 + 48);
        v295 = v289 + 48;
        v296 = v297;
        v298 = *(char *)(v295 + 23);
        if (v298 >= 0) {
          v299 = *(unsigned __int8 *)(v295 + 23);
        }
        else {
          v299 = *(void *)(v295 + 8);
        }
        if (v298 >= 0) {
          v300 = (const void *)v295;
        }
        else {
          v300 = v296;
        }
        if (v294 >= 0) {
          v301 = *(unsigned __int8 *)(v291 + 23);
        }
        else {
          v301 = *(void *)(v291 + 8);
        }
        if (v294 >= 0) {
          v302 = (const void *)v291;
        }
        else {
          v302 = v292;
        }
        if (v301 >= v299) {
          v303 = v299;
        }
        else {
          v303 = v301;
        }
        v304 = memcmp(v300, v302, v303);
        if (v304) {
          v305 = v304 < 0;
        }
        else {
          v305 = v299 < v301;
        }
        if (v290) {
          sub_216784EC4(v290);
        }
        if (!v288) {
          break;
        }
        sub_216784EC4(v288);
        if (v305) {
          goto LABEL_519;
        }
LABEL_520:
        v306 = *v285;
        v307 = (std::__shared_weak_count *)v285[1];
        if (v307) {
          atomic_fetch_add_explicit(&v307->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v308 = &v9[2 * v486];
        v309 = *v308;
        v310 = (std::__shared_weak_count *)v308[1];
        if (v310) {
          atomic_fetch_add_explicit(&v310->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v313 = *(const void **)(v306 + 48);
        v311 = v306 + 48;
        v312 = v313;
        v314 = *(char *)(v311 + 23);
        v317 = *(const void **)(v309 + 48);
        v315 = v309 + 48;
        v316 = v317;
        v318 = *(char *)(v315 + 23);
        if (v318 >= 0) {
          v319 = *(unsigned __int8 *)(v315 + 23);
        }
        else {
          v319 = *(void *)(v315 + 8);
        }
        if (v318 >= 0) {
          v320 = (const void *)v315;
        }
        else {
          v320 = v316;
        }
        if (v314 >= 0) {
          v321 = *(unsigned __int8 *)(v311 + 23);
        }
        else {
          v321 = *(void *)(v311 + 8);
        }
        if (v314 >= 0) {
          v322 = (const void *)v311;
        }
        else {
          v322 = v312;
        }
        if (v321 >= v319) {
          v323 = v319;
        }
        else {
          v323 = v321;
        }
        v324 = memcmp(v320, v322, v323);
        if (v324) {
          v325 = v324 < 0;
        }
        else {
          v325 = v319 < v321;
        }
        if (v310) {
          sub_216784EC4(v310);
        }
        v282 = v489;
        if (v307) {
          sub_216784EC4(v307);
        }
        v284 = v486;
        if (!v325)
        {
          v326 = *v308;
          v327 = (std::__shared_weak_count *)v308[1];
          *v308 = 0;
          v308[1] = 0;
          v328 = v494;
          while (1)
          {
            v329 = v308;
            v308 = v285;
            v330 = *(_OWORD *)v285;
            *v285 = 0;
            v285[1] = 0;
            v331 = (std::__shared_weak_count *)v329[1];
            *(_OWORD *)v329 = v330;
            if (v331) {
              sub_216784EC4(v331);
            }
            if (v282 < v328)
            {
LABEL_609:
              v366 = (std::__shared_weak_count *)v308[1];
              *v308 = v326;
              v308[1] = (uint64_t)v327;
              int v9 = v497;
              v284 = v486;
              if (v366) {
                sub_216784EC4(v366);
              }
              break;
            }
            v495 = (2 * v328) | 1;
            v285 = &v497[2 * v495];
            v332 = 2 * v328 + 2;
            if (v332 < (uint64_t)v11)
            {
              v333 = *v285;
              v334 = (std::__shared_weak_count *)v285[1];
              if (v334) {
                atomic_fetch_add_explicit(&v334->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v335 = v285[2];
              v336 = (std::__shared_weak_count *)v285[3];
              if (v336) {
                atomic_fetch_add_explicit(&v336->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v339 = *(const void **)(v333 + 48);
              v337 = v333 + 48;
              v338 = v339;
              v340 = *(char *)(v337 + 23);
              v343 = *(const void **)(v335 + 48);
              v341 = v335 + 48;
              v342 = v343;
              v344 = *(char *)(v341 + 23);
              if (v344 >= 0) {
                v345 = *(unsigned __int8 *)(v341 + 23);
              }
              else {
                v345 = *(void *)(v341 + 8);
              }
              if (v344 >= 0) {
                v346 = (const void *)v341;
              }
              else {
                v346 = v342;
              }
              if (v340 >= 0) {
                v347 = *(unsigned __int8 *)(v337 + 23);
              }
              else {
                v347 = *(void *)(v337 + 8);
              }
              if (v340 >= 0) {
                v348 = (const void *)v337;
              }
              else {
                v348 = v338;
              }
              if (v347 >= v345) {
                v349 = v345;
              }
              else {
                v349 = v347;
              }
              v350 = memcmp(v346, v348, v349);
              if (v350) {
                v351 = v350 < 0;
              }
              else {
                v351 = v345 < v347;
              }
              if (v336) {
                sub_216784EC4(v336);
              }
              unsigned int v11 = v484;
              if (!v334)
              {
                v282 = v489;
                if (!v351) {
                  goto LABEL_579;
                }
LABEL_578:
                v285 += 2;
                v495 = v332;
                goto LABEL_579;
              }
              sub_216784EC4(v334);
              v282 = v489;
              if (v351) {
                goto LABEL_578;
              }
            }
LABEL_579:
            v352 = *v285;
            v353 = (std::__shared_weak_count *)v285[1];
            if (v353) {
              atomic_fetch_add_explicit(&v353->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v327) {
              atomic_fetch_add_explicit(&v327->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v356 = *(const void **)(v352 + 48);
            v354 = v352 + 48;
            v355 = v356;
            v357 = *(char *)(v354 + 23);
            v358 = *(char *)(v326 + 71);
            if (v358 >= 0) {
              v359 = *(unsigned __int8 *)(v326 + 71);
            }
            else {
              v359 = *(void *)(v326 + 56);
            }
            if (v358 >= 0) {
              v360 = (const void *)(v326 + 48);
            }
            else {
              v360 = *(const void **)(v326 + 48);
            }
            if (v357 >= 0) {
              v361 = *(unsigned __int8 *)(v354 + 23);
            }
            else {
              v361 = *(void *)(v354 + 8);
            }
            if (v357 >= 0) {
              v362 = (const void *)v354;
            }
            else {
              v362 = v355;
            }
            if (v361 >= v359) {
              v363 = v359;
            }
            else {
              v363 = v361;
            }
            v364 = memcmp(v360, v362, v363);
            if (v364) {
              v365 = v364 < 0;
            }
            else {
              v365 = v359 < v361;
            }
            if (v327) {
              sub_216784EC4(v327);
            }
            v328 = v495;
            if (v353) {
              sub_216784EC4(v353);
            }
            if (v365) {
              goto LABEL_609;
            }
          }
        }
LABEL_611:
        v283 = v284 - 1;
        if (!v284)
        {
          v367 = v483 >> 4;
          while (1)
          {
            v368 = v9;
            v369 = 0;
            v487 = *v368;
            v490 = a2;
            v492 = v368[1];
            *v368 = 0;
            v368[1] = 0;
            v370 = (unint64_t)(v367 - 2) >> 1;
            do
            {
              v371 = &v368[2 * v369 + 2];
              v372 = 2 * v369;
              v369 = (2 * v369) | 1;
              v373 = v372 + 2;
              if (v372 + 2 >= v367) {
                goto LABEL_644;
              }
              v374 = *v371;
              v375 = (std::__shared_weak_count *)v371[1];
              if (v375) {
                atomic_fetch_add_explicit(&v375->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v376 = v371[2];
              v377 = (std::__shared_weak_count *)v371[3];
              if (v377) {
                atomic_fetch_add_explicit(&v377->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v380 = *(const void **)(v374 + 48);
              v378 = v374 + 48;
              v379 = v380;
              v381 = *(char *)(v378 + 23);
              v384 = *(const void **)(v376 + 48);
              v382 = v376 + 48;
              v383 = v384;
              v385 = *(char *)(v382 + 23);
              if (v385 >= 0) {
                v386 = *(unsigned __int8 *)(v382 + 23);
              }
              else {
                v386 = *(void *)(v382 + 8);
              }
              if (v385 >= 0) {
                v387 = (const void *)v382;
              }
              else {
                v387 = v383;
              }
              if (v381 >= 0) {
                v388 = *(unsigned __int8 *)(v378 + 23);
              }
              else {
                v388 = *(void *)(v378 + 8);
              }
              if (v381 >= 0) {
                v389 = (const void *)v378;
              }
              else {
                v389 = v379;
              }
              if (v388 >= v386) {
                v390 = v386;
              }
              else {
                v390 = v388;
              }
              v391 = memcmp(v387, v389, v390);
              if (v391) {
                v392 = v391 < 0;
              }
              else {
                v392 = v386 < v388;
              }
              if (v377) {
                sub_216784EC4(v377);
              }
              if (v375)
              {
                sub_216784EC4(v375);
                v370 = (unint64_t)(v367 - 2) >> 1;
                if (!v392) {
                  goto LABEL_644;
                }
LABEL_643:
                v371 += 2;
                v369 = v373;
                goto LABEL_644;
              }
              v370 = (unint64_t)(v367 - 2) >> 1;
              if (v392) {
                goto LABEL_643;
              }
LABEL_644:
              v393 = *(_OWORD *)v371;
              *v371 = 0;
              v371[1] = 0;
              v394 = (std::__shared_weak_count *)v368[1];
              *(_OWORD *)v368 = v393;
              if (v394) {
                sub_216784EC4(v394);
              }
              v368 = v371;
            }
            while (v369 <= v370);
            v395 = a2 - 2;
            a2 -= 2;
            if (v371 == v490 - 2)
            {
              v440 = (std::__shared_weak_count *)v371[1];
              *v371 = v487;
              v371[1] = v492;
              int v9 = v497;
              if (!v440) {
                goto LABEL_718;
              }
LABEL_717:
              sub_216784EC4(v440);
              goto LABEL_718;
            }
            v396 = *((_OWORD *)v490 - 1);
            *v395 = 0;
            v395[1] = 0;
            v397 = (std::__shared_weak_count *)v371[1];
            *(_OWORD *)v371 = v396;
            int v9 = v497;
            if (v397) {
              sub_216784EC4(v397);
            }
            v398 = (std::__shared_weak_count *)*(v490 - 1);
            *(v490 - 2) = v487;
            *(v490 - 1) = v492;
            if (v398) {
              sub_216784EC4(v398);
            }
            v399 = (char *)(v371 + 2) - (char *)v497;
            if (v399 >= 17)
            {
              v496 = v367;
              v400 = (((unint64_t)v399 >> 4) - 2) >> 1;
              v401 = &v497[2 * v400];
              v402 = *v401;
              v403 = (std::__shared_weak_count *)v401[1];
              if (v403) {
                atomic_fetch_add_explicit(&v403->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v404 = *v371;
              v405 = (std::__shared_weak_count *)v371[1];
              if (v405) {
                atomic_fetch_add_explicit(&v405->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              v408 = *(const void **)(v402 + 48);
              v406 = v402 + 48;
              v407 = v408;
              v409 = *(char *)(v406 + 23);
              v412 = *(const void **)(v404 + 48);
              v410 = v404 + 48;
              v411 = v412;
              v413 = *(char *)(v410 + 23);
              if (v413 >= 0) {
                v414 = *(unsigned __int8 *)(v410 + 23);
              }
              else {
                v414 = *(void *)(v410 + 8);
              }
              if (v413 >= 0) {
                v415 = (const void *)v410;
              }
              else {
                v415 = v411;
              }
              if (v409 >= 0) {
                v416 = *(unsigned __int8 *)(v406 + 23);
              }
              else {
                v416 = *(void *)(v406 + 8);
              }
              if (v409 >= 0) {
                v417 = (const void *)v406;
              }
              else {
                v417 = v407;
              }
              if (v416 >= v414) {
                v418 = v414;
              }
              else {
                v418 = v416;
              }
              v419 = memcmp(v415, v417, v418);
              if (v419) {
                v420 = v419 < 0;
              }
              else {
                v420 = v414 < v416;
              }
              if (v405) {
                sub_216784EC4(v405);
              }
              if (v403) {
                sub_216784EC4(v403);
              }
              v367 = v496;
              if (v420)
              {
                v422 = *v371;
                v421 = (std::__shared_weak_count *)v371[1];
                *v371 = 0;
                v371[1] = 0;
                do
                {
                  v423 = v371;
                  v371 = v401;
                  v424 = *(_OWORD *)v401;
                  *v401 = 0;
                  v401[1] = 0;
                  v425 = (std::__shared_weak_count *)v423[1];
                  *(_OWORD *)v423 = v424;
                  if (v425) {
                    sub_216784EC4(v425);
                  }
                  if (!v400) {
                    break;
                  }
                  v400 = (v400 - 1) >> 1;
                  v401 = &v497[2 * v400];
                  v426 = *v401;
                  v427 = (std::__shared_weak_count *)v401[1];
                  if (v427) {
                    atomic_fetch_add_explicit(&v427->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  if (v421) {
                    atomic_fetch_add_explicit(&v421->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  v430 = *(const void **)(v426 + 48);
                  v428 = v426 + 48;
                  v429 = v430;
                  v431 = *(char *)(v428 + 23);
                  v432 = *(char *)(v422 + 71);
                  if (v432 >= 0) {
                    v433 = *(unsigned __int8 *)(v422 + 71);
                  }
                  else {
                    v433 = *(void *)(v422 + 56);
                  }
                  if (v432 >= 0) {
                    v434 = (const void *)(v422 + 48);
                  }
                  else {
                    v434 = *(const void **)(v422 + 48);
                  }
                  if (v431 >= 0) {
                    v435 = *(unsigned __int8 *)(v428 + 23);
                  }
                  else {
                    v435 = *(void *)(v428 + 8);
                  }
                  if (v431 >= 0) {
                    v436 = (const void *)v428;
                  }
                  else {
                    v436 = v429;
                  }
                  if (v435 >= v433) {
                    v437 = v433;
                  }
                  else {
                    v437 = v435;
                  }
                  v438 = memcmp(v434, v436, v437);
                  if (v438) {
                    v439 = v438 < 0;
                  }
                  else {
                    v439 = v433 < v435;
                  }
                  if (v421) {
                    sub_216784EC4(v421);
                  }
                  if (v427) {
                    sub_216784EC4(v427);
                  }
                }
                while (v439);
                v440 = (std::__shared_weak_count *)v371[1];
                *v371 = v422;
                v371[1] = (uint64_t)v421;
                v367 = v496;
                int v9 = v497;
                if (v440) {
                  goto LABEL_717;
                }
              }
            }
LABEL_718:
            if (v367-- <= 2) {
              return;
            }
          }
        }
      }
      if (!v305) {
        goto LABEL_520;
      }
LABEL_519:
      v285 += 2;
      v494 = v286;
      goto LABEL_520;
    }
    char v12 = &j[2 * (v11 >> 1)];
    if ((unint64_t)v10 >= 0x801)
    {
      sub_21730B67C(v9, &v9[2 * (v11 >> 1)], v488);
      sub_21730B67C(v9 + 2, v12 - 2, a2 - 4);
      int v13 = &v9[2 * (v11 >> 1) + 2];
      sub_21730B67C(v497 + 4, v13, a2 - 6);
      int v9 = v497;
      sub_21730B67C(v12 - 2, v12, v13);
      unsigned int v14 = *(_OWORD *)v497;
      *(_OWORD *)v497 = *(_OWORD *)v12;
      *(_OWORD *)char v12 = v14;
    }
    else
    {
      sub_21730B67C(&v9[2 * (v11 >> 1)], v9, v488);
    }
    --a3;
    if (a4) {
      goto LABEL_36;
    }
    int v15 = *(v9 - 2);
    int v16 = (std::__shared_weak_count *)*(v9 - 1);
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    char v17 = *v9;
    int v18 = (std::__shared_weak_count *)v9[1];
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v21 = *(const void **)(v15 + 48);
    unsigned int v19 = v15 + 48;
    int v20 = v21;
    int v22 = *(char *)(v19 + 23);
    uint64_t v25 = *(const void **)(v17 + 48);
    uint64_t v23 = v17 + 48;
    int v24 = v25;
    uint64_t v26 = *(char *)(v23 + 23);
    if (v26 >= 0) {
      uint64_t v27 = *(unsigned __int8 *)(v23 + 23);
    }
    else {
      uint64_t v27 = *(void *)(v23 + 8);
    }
    if (v26 >= 0) {
      uint64_t v28 = (const void *)v23;
    }
    else {
      uint64_t v28 = v24;
    }
    if (v22 >= 0) {
      uint64_t v29 = *(unsigned __int8 *)(v19 + 23);
    }
    else {
      uint64_t v29 = *(void *)(v19 + 8);
    }
    if (v22 >= 0) {
      uint64_t v30 = (const void *)v19;
    }
    else {
      uint64_t v30 = v20;
    }
    if (v29 >= v27) {
      uint64_t v31 = v27;
    }
    else {
      uint64_t v31 = v29;
    }
    uint64_t v32 = memcmp(v28, v30, v31);
    if (v32) {
      int v33 = v32 >= 0;
    }
    else {
      int v33 = v27 >= v29;
    }
    if (v18) {
      sub_216784EC4(v18);
    }
    if (v16)
    {
      sub_216784EC4(v16);
      if (v33) {
        goto LABEL_197;
      }
LABEL_36:
      uint64_t v34 = 0;
      int v35 = *v9;
      unsigned int v36 = (std::__shared_weak_count *)v9[1];
      *int v9 = 0;
      v9[1] = 0;
      do
      {
        unsigned int v37 = v9[v34 + 2];
        uint64_t v38 = (std::__shared_weak_count *)v9[v34 + 3];
        if (v38) {
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v36) {
          atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v41 = *(const void **)(v37 + 48);
        size_t v39 = v37 + 48;
        int v40 = v41;
        uint64_t v42 = *(char *)(v39 + 23);
        int v43 = *(char *)(v35 + 71);
        if (v43 >= 0) {
          int v44 = *(unsigned __int8 *)(v35 + 71);
        }
        else {
          int v44 = *(void *)(v35 + 56);
        }
        if (v43 >= 0) {
          int v45 = (const void *)(v35 + 48);
        }
        else {
          int v45 = *(const void **)(v35 + 48);
        }
        if (v42 >= 0) {
          int v46 = *(unsigned __int8 *)(v39 + 23);
        }
        else {
          int v46 = *(void *)(v39 + 8);
        }
        if (v42 >= 0) {
          int v47 = (const void *)v39;
        }
        else {
          int v47 = v40;
        }
        if (v46 >= v44) {
          unsigned int v48 = v44;
        }
        else {
          unsigned int v48 = v46;
        }
        int v49 = memcmp(v45, v47, v48);
        if (v49) {
          atomic_ullong v50 = v49 < 0;
        }
        else {
          atomic_ullong v50 = v44 < v46;
        }
        if (v36) {
          sub_216784EC4(v36);
        }
        if (v38) {
          sub_216784EC4(v38);
        }
        v34 += 2;
      }
      while (v50);
      uint64_t v51 = &v9[v34];
      uint64_t i = a2;
      if (v34 == 2)
      {
        uint64_t i = a2;
        if (v51 < a2)
        {
          for (uint64_t i = a2 - 2; ; i -= 2)
          {
            v67 = *i;
            v68 = (std::__shared_weak_count *)i[1];
            if (v68) {
              atomic_fetch_add_explicit(&v68->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v36) {
              atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v71 = *(const void **)(v67 + 48);
            v69 = v67 + 48;
            v70 = v71;
            v72 = *(char *)(v69 + 23);
            v73 = *(char *)(v35 + 71);
            if (v73 >= 0) {
              v74 = *(unsigned __int8 *)(v35 + 71);
            }
            else {
              v74 = *(void *)(v35 + 56);
            }
            if (v73 >= 0) {
              v75 = (const void *)(v35 + 48);
            }
            else {
              v75 = *(const void **)(v35 + 48);
            }
            if (v72 >= 0) {
              v76 = *(unsigned __int8 *)(v69 + 23);
            }
            else {
              v76 = *(void *)(v69 + 8);
            }
            if (v72 >= 0) {
              v77 = (const void *)v69;
            }
            else {
              v77 = v70;
            }
            if (v76 >= v74) {
              v78 = v74;
            }
            else {
              v78 = v76;
            }
            v79 = memcmp(v75, v77, v78);
            if (v79) {
              v80 = v79 >= 0;
            }
            else {
              v80 = v74 >= v76;
            }
            if (v36) {
              sub_216784EC4(v36);
            }
            if (v68)
            {
              sub_216784EC4(v68);
              if (v51 >= i || !v80) {
                break;
              }
            }
            else
            {
              v82 = !v80;
              if (v51 >= i) {
                v82 = 1;
              }
              if (v82) {
                break;
              }
            }
          }
        }
      }
      else
      {
        do
        {
          uint64_t v53 = *(i - 2);
          atomic_ullong v54 = (std::__shared_weak_count *)*(i - 1);
          i -= 2;
          if (v54) {
            atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v36) {
            atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v57 = *(const void **)(v53 + 48);
          uint64_t v55 = v53 + 48;
          uint64_t v56 = v57;
          v58 = *(char *)(v55 + 23);
          v59 = *(char *)(v35 + 71);
          if (v59 >= 0) {
            v60 = *(unsigned __int8 *)(v35 + 71);
          }
          else {
            v60 = *(void *)(v35 + 56);
          }
          if (v59 >= 0) {
            v61 = (const void *)(v35 + 48);
          }
          else {
            v61 = *(const void **)(v35 + 48);
          }
          if (v58 >= 0) {
            v62 = *(unsigned __int8 *)(v55 + 23);
          }
          else {
            v62 = *(void *)(v55 + 8);
          }
          if (v58 >= 0) {
            v63 = (const void *)v55;
          }
          else {
            v63 = v56;
          }
          if (v62 >= v60) {
            v64 = v60;
          }
          else {
            v64 = v62;
          }
          v65 = memcmp(v61, v63, v64);
          if (v65) {
            v66 = v65 < 0;
          }
          else {
            v66 = v60 < v62;
          }
          if (v36) {
            sub_216784EC4(v36);
          }
          if (v54) {
            sub_216784EC4(v54);
          }
        }
        while (!v66);
      }
      v491 = (unint64_t)v51;
      uint64_t j = v51;
      if (v51 < i)
      {
        v83 = i;
        do
        {
          v84 = *j;
          *uint64_t j = *v83;
          *v83 = v84;
          v85 = j[1];
          j[1] = v83[1];
          v83[1] = v85;
          do
          {
            v86 = j[2];
            v87 = (std::__shared_weak_count *)j[3];
            j += 2;
            if (v87) {
              atomic_fetch_add_explicit(&v87->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v36) {
              atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v90 = *(const void **)(v86 + 48);
            v88 = v86 + 48;
            v89 = v90;
            v91 = *(char *)(v88 + 23);
            v92 = *(char *)(v35 + 71);
            if (v92 >= 0) {
              v93 = *(unsigned __int8 *)(v35 + 71);
            }
            else {
              v93 = *(void *)(v35 + 56);
            }
            if (v92 >= 0) {
              v94 = (const void *)(v35 + 48);
            }
            else {
              v94 = *(const void **)(v35 + 48);
            }
            if (v91 >= 0) {
              v95 = *(unsigned __int8 *)(v88 + 23);
            }
            else {
              v95 = *(void *)(v88 + 8);
            }
            if (v91 >= 0) {
              v96 = (const void *)v88;
            }
            else {
              v96 = v89;
            }
            if (v95 >= v93) {
              v97 = v93;
            }
            else {
              v97 = v95;
            }
            v98 = memcmp(v94, v96, v97);
            if (v98) {
              v99 = v98 < 0;
            }
            else {
              v99 = v93 < v95;
            }
            if (v36) {
              sub_216784EC4(v36);
            }
            if (v87) {
              sub_216784EC4(v87);
            }
          }
          while (v99);
          do
          {
            v100 = *(v83 - 2);
            v101 = (std::__shared_weak_count *)*(v83 - 1);
            v83 -= 2;
            if (v101) {
              atomic_fetch_add_explicit(&v101->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            if (v36) {
              atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v104 = *(const void **)(v100 + 48);
            v102 = v100 + 48;
            v103 = v104;
            v105 = *(char *)(v102 + 23);
            v106 = *(char *)(v35 + 71);
            if (v106 >= 0) {
              v107 = *(unsigned __int8 *)(v35 + 71);
            }
            else {
              v107 = *(void *)(v35 + 56);
            }
            if (v106 >= 0) {
              v108 = (const void *)(v35 + 48);
            }
            else {
              v108 = *(const void **)(v35 + 48);
            }
            if (v105 >= 0) {
              v109 = *(unsigned __int8 *)(v102 + 23);
            }
            else {
              v109 = *(void *)(v102 + 8);
            }
            if (v105 >= 0) {
              v110 = (const void *)v102;
            }
            else {
              v110 = v103;
            }
            if (v109 >= v107) {
              v111 = v107;
            }
            else {
              v111 = v109;
            }
            v112 = memcmp(v108, v110, v111);
            if (v112) {
              v113 = v112 < 0;
            }
            else {
              v113 = v107 < v109;
            }
            if (v36) {
              sub_216784EC4(v36);
            }
            if (v101) {
              sub_216784EC4(v101);
            }
          }
          while (!v113);
        }
        while (j < v83);
      }
      v114 = j - 2;
      if (j - 2 != v497)
      {
        v115 = *(_OWORD *)v114;
        *v114 = 0;
        *(j - 1) = 0;
        v116 = (std::__shared_weak_count *)v497[1];
        *(_OWORD *)v497 = v115;
        if (v116) {
          sub_216784EC4(v116);
        }
      }
      v117 = (std::__shared_weak_count *)*(j - 1);
      *(j - 2) = v35;
      *(j - 1) = (uint64_t)v36;
      unsigned int v8 = a2;
      if (v117) {
        sub_216784EC4(v117);
      }
      if (v491 < (unint64_t)i)
      {
LABEL_195:
        sub_217309D38(v497, j - 2, a3, a4 & 1);
        a4 = 0;
      }
      else
      {
        v118 = sub_21730BA74(v497, j - 2);
        if (sub_21730BA74(j, a2))
        {
          a2 = j - 2;
          uint64_t j = v497;
          if (v118) {
            return;
          }
          goto LABEL_1;
        }
        if (!v118) {
          goto LABEL_195;
        }
      }
    }
    else
    {
      if (!v33) {
        goto LABEL_36;
      }
LABEL_197:
      v119 = v9;
      v120 = *v9;
      v121 = (std::__shared_weak_count *)v119[1];
      *v119 = 0;
      v119[1] = 0;
      if (v121) {
        atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v122 = a3;
      v123 = *(a2 - 2);
      v124 = (std::__shared_weak_count *)*(a2 - 1);
      if (v124) {
        atomic_fetch_add_explicit(&v124->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v125 = *(char *)(v120 + 71);
      v128 = *(const void **)(v123 + 48);
      v126 = v123 + 48;
      v127 = v128;
      v129 = *(char *)(v126 + 23);
      if (v129 >= 0) {
        v130 = *(unsigned __int8 *)(v126 + 23);
      }
      else {
        v130 = *(void *)(v126 + 8);
      }
      if (v129 >= 0) {
        v131 = (const void *)v126;
      }
      else {
        v131 = v127;
      }
      if (v125 >= 0) {
        v132 = *(unsigned __int8 *)(v120 + 71);
      }
      else {
        v132 = *(void *)(v120 + 56);
      }
      if (v125 >= 0) {
        v133 = (const void *)(v120 + 48);
      }
      else {
        v133 = *(const void **)(v120 + 48);
      }
      if (v132 >= v130) {
        v134 = v130;
      }
      else {
        v134 = v132;
      }
      v135 = memcmp(v131, v133, v134);
      if (v135) {
        v136 = v135 < 0;
      }
      else {
        v136 = v130 < v132;
      }
      if (v124) {
        sub_216784EC4(v124);
      }
      if (v121) {
        sub_216784EC4(v121);
      }
      if (v136)
      {
        uint64_t j = v497;
        do
        {
          if (v121) {
            atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v137 = j[2];
          v138 = (std::__shared_weak_count *)j[3];
          if (v138) {
            atomic_fetch_add_explicit(&v138->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v139 = *(char *)(v120 + 71);
          v142 = *(const void **)(v137 + 48);
          v140 = v137 + 48;
          v141 = v142;
          v143 = *(char *)(v140 + 23);
          if (v143 >= 0) {
            v144 = *(unsigned __int8 *)(v140 + 23);
          }
          else {
            v144 = *(void *)(v140 + 8);
          }
          if (v143 >= 0) {
            v145 = (const void *)v140;
          }
          else {
            v145 = v141;
          }
          if (v139 >= 0) {
            v146 = *(unsigned __int8 *)(v120 + 71);
          }
          else {
            v146 = *(void *)(v120 + 56);
          }
          if (v139 >= 0) {
            v147 = (const void *)(v120 + 48);
          }
          else {
            v147 = *(const void **)(v120 + 48);
          }
          if (v146 >= v144) {
            v148 = v144;
          }
          else {
            v148 = v146;
          }
          v149 = memcmp(v145, v147, v148);
          if (v149) {
            v150 = v149 < 0;
          }
          else {
            v150 = v144 < v146;
          }
          if (v138) {
            sub_216784EC4(v138);
          }
          if (v121) {
            sub_216784EC4(v121);
          }
          j += 2;
        }
        while (!v150);
      }
      else
      {
        for (uint64_t j = v497 + 2; j < a2; j += 2)
        {
          if (v121) {
            atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v200 = *j;
          v201 = (std::__shared_weak_count *)j[1];
          if (v201) {
            atomic_fetch_add_explicit(&v201->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v202 = *(char *)(v120 + 71);
          v205 = *(const void **)(v200 + 48);
          v203 = v200 + 48;
          v204 = v205;
          v206 = *(char *)(v203 + 23);
          if (v206 >= 0) {
            v207 = *(unsigned __int8 *)(v203 + 23);
          }
          else {
            v207 = *(void *)(v203 + 8);
          }
          if (v206 >= 0) {
            v208 = (const void *)v203;
          }
          else {
            v208 = v204;
          }
          if (v202 >= 0) {
            v209 = *(unsigned __int8 *)(v120 + 71);
          }
          else {
            v209 = *(void *)(v120 + 56);
          }
          if (v202 >= 0) {
            v210 = (const void *)(v120 + 48);
          }
          else {
            v210 = *(const void **)(v120 + 48);
          }
          if (v209 >= v207) {
            v211 = v207;
          }
          else {
            v211 = v209;
          }
          v212 = memcmp(v208, v210, v211);
          if (v212) {
            v213 = v212 >= 0;
          }
          else {
            v213 = v207 >= v209;
          }
          if (v201) {
            sub_216784EC4(v201);
          }
          if (v121)
          {
            sub_216784EC4(v121);
            if (!v213) {
              break;
            }
          }
          else if (!v213)
          {
            break;
          }
        }
      }
      v151 = a2;
      if (j < a2)
      {
        v151 = a2;
        do
        {
          if (v121) {
            atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v152 = *(v151 - 2);
          v153 = (std::__shared_weak_count *)*(v151 - 1);
          if (v153) {
            atomic_fetch_add_explicit(&v153->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v154 = *(char *)(v120 + 71);
          v157 = *(const void **)(v152 + 48);
          v155 = v152 + 48;
          v156 = v157;
          v158 = *(char *)(v155 + 23);
          if (v158 >= 0) {
            v159 = *(unsigned __int8 *)(v155 + 23);
          }
          else {
            v159 = *(void *)(v155 + 8);
          }
          if (v158 >= 0) {
            v160 = (const void *)v155;
          }
          else {
            v160 = v156;
          }
          if (v154 >= 0) {
            v161 = *(unsigned __int8 *)(v120 + 71);
          }
          else {
            v161 = *(void *)(v120 + 56);
          }
          if (v154 >= 0) {
            v162 = (const void *)(v120 + 48);
          }
          else {
            v162 = *(const void **)(v120 + 48);
          }
          if (v161 >= v159) {
            v163 = v159;
          }
          else {
            v163 = v161;
          }
          v164 = memcmp(v160, v162, v163);
          if (v164) {
            v165 = v164 < 0;
          }
          else {
            v165 = v159 < v161;
          }
          if (v153) {
            sub_216784EC4(v153);
          }
          if (v121) {
            sub_216784EC4(v121);
          }
          v151 -= 2;
        }
        while (v165);
      }
      while (j < v151)
      {
        v166 = *j;
        *uint64_t j = *v151;
        *v151 = v166;
        v167 = j[1];
        j[1] = v151[1];
        v151[1] = v167;
        do
        {
          if (v121) {
            atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v168 = j[2];
          v169 = (std::__shared_weak_count *)j[3];
          if (v169) {
            atomic_fetch_add_explicit(&v169->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v170 = *(char *)(v120 + 71);
          v173 = *(const void **)(v168 + 48);
          v171 = v168 + 48;
          v172 = v173;
          v174 = *(char *)(v171 + 23);
          if (v174 >= 0) {
            v175 = *(unsigned __int8 *)(v171 + 23);
          }
          else {
            v175 = *(void *)(v171 + 8);
          }
          if (v174 >= 0) {
            v176 = (const void *)v171;
          }
          else {
            v176 = v172;
          }
          if (v170 >= 0) {
            v177 = *(unsigned __int8 *)(v120 + 71);
          }
          else {
            v177 = *(void *)(v120 + 56);
          }
          if (v170 >= 0) {
            v178 = (const void *)(v120 + 48);
          }
          else {
            v178 = *(const void **)(v120 + 48);
          }
          if (v177 >= v175) {
            v179 = v175;
          }
          else {
            v179 = v177;
          }
          v180 = memcmp(v176, v178, v179);
          if (v180) {
            v181 = v180 < 0;
          }
          else {
            v181 = v175 < v177;
          }
          if (v169) {
            sub_216784EC4(v169);
          }
          if (v121) {
            sub_216784EC4(v121);
          }
          j += 2;
        }
        while (!v181);
        do
        {
          if (v121) {
            atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v182 = *(v151 - 2);
          v183 = (std::__shared_weak_count *)*(v151 - 1);
          if (v183) {
            atomic_fetch_add_explicit(&v183->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v184 = *(char *)(v120 + 71);
          v187 = *(const void **)(v182 + 48);
          v185 = v182 + 48;
          v186 = v187;
          v188 = *(char *)(v185 + 23);
          if (v188 >= 0) {
            v189 = *(unsigned __int8 *)(v185 + 23);
          }
          else {
            v189 = *(void *)(v185 + 8);
          }
          if (v188 >= 0) {
            v190 = (const void *)v185;
          }
          else {
            v190 = v186;
          }
          if (v184 >= 0) {
            v191 = *(unsigned __int8 *)(v120 + 71);
          }
          else {
            v191 = *(void *)(v120 + 56);
          }
          if (v184 >= 0) {
            v192 = (const void *)(v120 + 48);
          }
          else {
            v192 = *(const void **)(v120 + 48);
          }
          if (v191 >= v189) {
            v193 = v189;
          }
          else {
            v193 = v191;
          }
          v194 = memcmp(v190, v192, v193);
          if (v194) {
            v195 = v194 < 0;
          }
          else {
            v195 = v189 < v191;
          }
          if (v183) {
            sub_216784EC4(v183);
          }
          if (v121) {
            sub_216784EC4(v121);
          }
          v151 -= 2;
        }
        while (v195);
      }
      v196 = j - 2;
      unsigned int v4 = j - 2 >= v497;
      int v5 = j - 2 == v497;
      unsigned int v8 = a2;
      if (j - 2 != v497)
      {
        v197 = *(_OWORD *)v196;
        *v196 = 0;
        *(j - 1) = 0;
        v198 = (std::__shared_weak_count *)v497[1];
        *(_OWORD *)v497 = v197;
        if (v198) {
          sub_216784EC4(v198);
        }
      }
      a4 = 0;
      v199 = (std::__shared_weak_count *)*(j - 1);
      *(j - 2) = v120;
      *(j - 1) = (uint64_t)v121;
      a3 = v122;
      if (v199)
      {
        sub_216784EC4(v199);
        a4 = 0;
      }
    }
  }
  v235 = j + 2;
  v237 = j == v8 || v235 == v8;
  if ((a4 & 1) == 0)
  {
    if (!v237)
    {
      v442 = (std::__shared_weak_count **)(j + 3);
      do
      {
        v443 = v9;
        int v9 = v235;
        v444 = v443[2];
        v445 = (std::__shared_weak_count *)v443[3];
        if (v445) {
          atomic_fetch_add_explicit(&v445->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v446 = *v443;
        v447 = (std::__shared_weak_count *)v443[1];
        if (v447) {
          atomic_fetch_add_explicit(&v447->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v450 = *(const void **)(v444 + 48);
        v448 = v444 + 48;
        v449 = v450;
        v451 = *(char *)(v448 + 23);
        v454 = *(const void **)(v446 + 48);
        v452 = v446 + 48;
        v453 = v454;
        v455 = *(char *)(v452 + 23);
        if (v455 >= 0) {
          v456 = *(unsigned __int8 *)(v452 + 23);
        }
        else {
          v456 = *(void *)(v452 + 8);
        }
        if (v455 >= 0) {
          v457 = (const void *)v452;
        }
        else {
          v457 = v453;
        }
        if (v451 >= 0) {
          v458 = *(unsigned __int8 *)(v448 + 23);
        }
        else {
          v458 = *(void *)(v448 + 8);
        }
        if (v451 >= 0) {
          v459 = (const void *)v448;
        }
        else {
          v459 = v449;
        }
        if (v458 >= v456) {
          v460 = v456;
        }
        else {
          v460 = v458;
        }
        v461 = memcmp(v457, v459, v460);
        if (v461) {
          v462 = v461 < 0;
        }
        else {
          v462 = v456 < v458;
        }
        if (v447) {
          sub_216784EC4(v447);
        }
        if (v445) {
          sub_216784EC4(v445);
        }
        if (v462)
        {
          v463 = *v9;
          v464 = (std::__shared_weak_count *)v443[3];
          *int v9 = 0;
          v9[1] = 0;
          v465 = v442;
          do
          {
            v466 = *(_OWORD *)(v465 - 3);
            *(v465 - 3) = 0;
            *(v465 - 2) = 0;
            v467 = *v465;
            *(_OWORD *)(v465 - 1) = v466;
            if (v467) {
              sub_216784EC4(v467);
            }
            if (v464) {
              atomic_fetch_add_explicit(&v464->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v468 = (uint64_t)*(v465 - 5);
            v469 = *(v465 - 4);
            if (v469) {
              atomic_fetch_add_explicit(&v469->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v470 = *(char *)(v463 + 71);
            v473 = *(const void **)(v468 + 48);
            v471 = v468 + 48;
            v472 = v473;
            v474 = *(char *)(v471 + 23);
            if (v474 >= 0) {
              v475 = *(unsigned __int8 *)(v471 + 23);
            }
            else {
              v475 = *(void *)(v471 + 8);
            }
            if (v474 >= 0) {
              v476 = (const void *)v471;
            }
            else {
              v476 = v472;
            }
            if (v470 >= 0) {
              v477 = *(unsigned __int8 *)(v463 + 71);
            }
            else {
              v477 = *(void *)(v463 + 56);
            }
            if (v470 >= 0) {
              v478 = (const void *)(v463 + 48);
            }
            else {
              v478 = *(const void **)(v463 + 48);
            }
            if (v477 >= v475) {
              v479 = v475;
            }
            else {
              v479 = v477;
            }
            v480 = memcmp(v476, v478, v479);
            if (v480) {
              v481 = v480 < 0;
            }
            else {
              v481 = v475 < v477;
            }
            if (v469) {
              sub_216784EC4(v469);
            }
            if (v464) {
              sub_216784EC4(v464);
            }
            v465 -= 2;
          }
          while (v481);
          v482 = *v465;
          *(v465 - 1) = (std::__shared_weak_count *)v463;
          *v465 = v464;
          if (v482) {
            sub_216784EC4(v482);
          }
        }
        v235 = v9 + 2;
        v442 += 2;
      }
      while (v9 + 2 != a2);
    }
    return;
  }
  if (v237) {
    return;
  }
  v238 = 0;
  v239 = j;
  while (2)
  {
    v240 = v239;
    v239 = v235;
    v241 = v240[2];
    v242 = (std::__shared_weak_count *)v240[3];
    if (v242) {
      atomic_fetch_add_explicit(&v242->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v243 = *v240;
    v244 = (std::__shared_weak_count *)v240[1];
    if (v244) {
      atomic_fetch_add_explicit(&v244->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v247 = *(const void **)(v241 + 48);
    v245 = v241 + 48;
    v246 = v247;
    v248 = *(char *)(v245 + 23);
    v251 = *(const void **)(v243 + 48);
    v249 = v243 + 48;
    v250 = v251;
    v252 = *(char *)(v249 + 23);
    if (v252 >= 0) {
      v253 = *(unsigned __int8 *)(v249 + 23);
    }
    else {
      v253 = *(void *)(v249 + 8);
    }
    if (v252 >= 0) {
      v254 = (const void *)v249;
    }
    else {
      v254 = v250;
    }
    if (v248 >= 0) {
      v255 = *(unsigned __int8 *)(v245 + 23);
    }
    else {
      v255 = *(void *)(v245 + 8);
    }
    if (v248 >= 0) {
      v256 = (const void *)v245;
    }
    else {
      v256 = v246;
    }
    if (v255 >= v253) {
      v257 = v253;
    }
    else {
      v257 = v255;
    }
    v258 = memcmp(v254, v256, v257);
    if (v258) {
      v259 = v258 < 0;
    }
    else {
      v259 = v253 < v255;
    }
    if (v244) {
      sub_216784EC4(v244);
    }
    if (v242) {
      sub_216784EC4(v242);
    }
    if (!v259) {
      goto LABEL_487;
    }
    v260 = *v239;
    v261 = (std::__shared_weak_count *)v240[3];
    *v239 = 0;
    v239[1] = 0;
    v262 = v238;
    while (2)
    {
      v263 = (char *)v9 + v262;
      v264 = *(_OWORD *)((char *)v9 + v262);
      *(void *)v263 = 0;
      *((void *)v263 + 1) = 0;
      v265 = *(std::__shared_weak_count **)((char *)v9 + v262 + 24);
      *((_OWORD *)v263 + 1) = v264;
      if (v265) {
        sub_216784EC4(v265);
      }
      if (!v262)
      {
        v280 = v9;
        goto LABEL_485;
      }
      if (v261) {
        atomic_fetch_add_explicit(&v261->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v266 = *(uint64_t *)((char *)v9 + v262 - 16);
      v267 = *(std::__shared_weak_count **)((char *)v9 + v262 - 8);
      if (v267) {
        atomic_fetch_add_explicit(&v267->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v268 = *(char *)(v260 + 71);
      v271 = *(const void **)(v266 + 48);
      v269 = v266 + 48;
      v270 = v271;
      v272 = *(char *)(v269 + 23);
      if (v272 >= 0) {
        v273 = *(unsigned __int8 *)(v269 + 23);
      }
      else {
        v273 = *(void *)(v269 + 8);
      }
      if (v272 >= 0) {
        v274 = (const void *)v269;
      }
      else {
        v274 = v270;
      }
      if (v268 >= 0) {
        v275 = *(unsigned __int8 *)(v260 + 71);
      }
      else {
        v275 = *(void *)(v260 + 56);
      }
      if (v268 >= 0) {
        v276 = (const void *)(v260 + 48);
      }
      else {
        v276 = *(const void **)(v260 + 48);
      }
      if (v275 >= v273) {
        v277 = v273;
      }
      else {
        v277 = v275;
      }
      v278 = memcmp(v274, v276, v277);
      if (v278) {
        v279 = v278 < 0;
      }
      else {
        v279 = v273 < v275;
      }
      if (v267) {
        sub_216784EC4(v267);
      }
      if (v261)
      {
        sub_216784EC4(v261);
        if (!v279) {
          break;
        }
        goto LABEL_482;
      }
      if (v279)
      {
LABEL_482:
        v262 -= 16;
        int v9 = v497;
        continue;
      }
      break;
    }
    int v9 = v497;
    v280 = (uint64_t *)((char *)v497 + v262);
LABEL_485:
    v281 = (std::__shared_weak_count *)v280[1];
    *v280 = v260;
    v280[1] = (uint64_t)v261;
    if (v281) {
      sub_216784EC4(v281);
    }
LABEL_487:
    v235 = v239 + 2;
    v238 += 16;
    if (v239 + 2 != a2) {
      continue;
    }
    break;
  }
}

void sub_21676B680(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *int v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::market::update_workers_request(tbb::internal::market *this)
{
  int v2 = *((_DWORD *)this + 7);
  int v3 = *((_DWORD *)this + 8);
  if (*((_DWORD *)this + 10) < v2) {
    int v2 = *((_DWORD *)this + 10);
  }
  if (*((int *)this + 11) >= 1) {
    int v2 = 1;
  }
  *((_DWORD *)this + 8) = v2;
  uint64_t v4 = *((void *)this + 6);
  *((_DWORD *)this + 10 * v4 + 27) = v2;
  tbb::internal::market::update_allotment((uint64_t)this, v4);
  return (*((_DWORD *)this + 8) - v3);
}

uint64_t tbb::internal::market::update_allotment(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(void *)(this + 56);
  if (v2 <= a2)
  {
    int v7 = *(_DWORD *)(this + 40 * a2 + 108);
    while (1)
    {
      uint64_t v9 = this + 40 * a2;
      *(_DWORD *)(v9 + 108) = v7;
      int v10 = *(_DWORD *)(v9 + 104);
      if (v10)
      {
        uint64_t v11 = this + 40 * a2;
        uint64_t v12 = v11 + 72;
        int v13 = v10 >= v7 ? v7 : v10;
        uint64_t v14 = *(void *)(v11 + 80);
        if (v14 == v12)
        {
          int v8 = 0;
        }
        else
        {
          int v8 = 0;
          int v15 = 0;
          do
          {
            int v18 = *(_DWORD *)(v14 + 212);
            if (v18 >= 1)
            {
              if (*(_DWORD *)(this + 28))
              {
                int v16 = v15 + v18 * v13;
                int v17 = v16 / v10;
                int v15 = v16 % v10;
                if (v17 >= *(_DWORD *)(v14 + 208)) {
                  int v17 = *(_DWORD *)(v14 + 208);
                }
              }
              else
              {
                if (*(unsigned char *)(v14 + 337)) {
                  BOOL v19 = v8 < v13;
                }
                else {
                  BOOL v19 = 0;
                }
                int v17 = v19;
              }
              *(_DWORD *)(v14 + 128) = v17;
              v8 += v17;
            }
            uint64_t v14 = *(void *)(v14 + 8);
          }
          while (v14 != v12);
        }
        v7 -= v8;
        if (v7 < 1) {
          break;
        }
      }
      uint64_t v3 = a2 - 1;
      BOOL v19 = a2-- <= v2;
      if (v19) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v3 = a2;
LABEL_3:
  while (v3 > v2)
  {
    --v3;
    uint64_t v4 = this + 40 * v3;
    uint64_t v5 = v4 + 72;
    *(_DWORD *)(v4 + 108) = 0;
    for (uint64_t i = *(void *)(v4 + 80); i != v5; uint64_t i = *(void *)(i + 8))
      *(_DWORD *)(i + 128) = 0;
  }
  return this;
}

uint64_t tbb::internal::market::disable_mandatory_concurrency_impl(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(a2 + 337) = 0;
  --*(_DWORD *)(result + 44);
  return result;
}

uint64_t tbb::internal::market::enable_mandatory_concurrency_impl(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(a2 + 337) = 1;
  ++*(_DWORD *)(result + 44);
  return result;
}

uint64_t sub_21676B828(uint64_t a1)
{
  uint64_t v2 = *(atomic_ullong **)a1;
  if (*(void *)a1)
  {
    *(void *)a1 = 0;
    if (*(unsigned char *)(a1 + 8))
    {
LABEL_3:
      atomic_ullong v3 = *v2;
      unint64_t v4 = *v2 & 0xFFFFFFFFFFFFFFFCLL;
      while (1)
      {
        atomic_ullong v5 = v3;
        atomic_compare_exchange_strong(v2, (unint64_t *)&v5, v4);
        if (v5 == v3) {
          break;
        }
        if (atomic_fetch_add_explicit(v2, 0, memory_order_relaxed) != v3)
        {
          sched_yield();
          goto LABEL_3;
        }
      }
    }
    else
    {
      atomic_fetch_add(v2, 0xFFFFFFFFFFFFFFFCLL);
    }
  }
  return a1;
}

uint64_t tbb::internal::governor::does_client_join_workers(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 216);
}

tbb::internal::arena *tbb::internal::market::create_arena(tbb::internal::market *this, int a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v7 = tbb::internal::market::global_market(1, (const char *)(this - a2), a3, a4, a5);
  arena = tbb::internal::arena::allocate_arena((tbb::internal::arena *)v7, this, a2, v8);
  int v10 = &v7->i64[1];
  tbb::spin_rw_mutex_v3::internal_acquire_writer(&v7->i64[1]);
  uint64_t v11 = &v7->i8[40 * *((void *)arena + 17)];
  uint64_t v12 = *((void *)arena + 17);
  uint64_t v13 = *((void *)v11 + 10);
  uint64_t v14 = *((void *)v11 + 11);
  *(void *)arena = v11 + 72;
  *((void *)arena + 1) = v13;
  **((void **)v11 + 10) = arena;
  *((void *)v11 + 10) = arena;
  *((void *)v11 + 11) = v14 + 1;
  if (!v14) {
    v7[6].i64[5 * v12] = (uint64_t)arena;
  }
LABEL_3:
  atomic_ullong v15 = *v10;
  unint64_t v16 = *v10 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v17 = v15;
    atomic_compare_exchange_strong(v10, (unint64_t *)&v17, v16);
    if (v17 == v15) {
      return arena;
    }
    if (atomic_fetch_add_explicit(v10, 0, memory_order_relaxed) != v15)
    {
      sched_yield();
      goto LABEL_3;
    }
  }
}

uint64_t tbb::internal::market::detach_arena(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 337))
  {
    *(unsigned char *)(a2 + 337) = 0;
    --*(_DWORD *)(result + 44);
  }
  uint64_t v2 = (void *)(result + 72 + 40 * *(void *)(a2 + 136));
  if (v2[3] == a2)
  {
    uint64_t v3 = *(void *)(a2 + 8);
    if ((void *)v3 == v2)
    {
      uint64_t v3 = result + 72 + 40 * *(void *)(a2 + 136);
      if (v2[2] >= 2uLL) {
        uint64_t v3 = v2[1];
      }
    }
    v2[3] = v3;
  }
  --v2[2];
  unint64_t v4 = *(void **)(a2 + 8);
  void *v4 = *(void *)a2;
  *(void *)(*(void *)a2 + 8) = v4;
  uint64_t v5 = *(void *)(a2 + 312);
  if (v5 == *(void *)(result + 192)) {
    *(void *)(result + 192) = v5 + 1;
  }
  return result;
}

uint64_t tbb::internal::market::try_destroy_arena(atomic_ullong *this, atomic_ullong *a2, uint64_t a3)
{
  char v6 = this + 1;
  uint64_t result = tbb::spin_rw_mutex_v3::internal_acquire_writer(this + 1);
  uint64_t v9 = this + 19;
  do
  {
    uint64_t v9 = (atomic_ullong *)v9[1];
    if (v9 == this + 19)
    {
      int v10 = this + 14;
      while (1)
      {
        int v10 = (atomic_ullong *)v10[1];
        if (v10 == this + 14) {
          break;
        }
        if (v10 == a2) {
          goto LABEL_12;
        }
      }
      uint64_t v11 = this + 9;
      while (1)
      {
        uint64_t v11 = (atomic_ullong *)v11[1];
        if (v11 == this + 9) {
          break;
        }
        if (v11 == a2) {
          goto LABEL_12;
        }
      }
      if ((*(unsigned char *)v6 & 1) == 0) {
        goto LABEL_16;
      }
LABEL_23:
      atomic_ullong v16 = *v6;
      unint64_t v17 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
      while (1)
      {
        atomic_ullong v18 = v16;
        atomic_compare_exchange_strong(v6, (unint64_t *)&v18, v17);
        if (v18 == v16) {
          return result;
        }
        if (atomic_fetch_add_explicit(v6, 0, memory_order_relaxed) != v16)
        {
          uint64_t result = sched_yield();
          goto LABEL_23;
        }
      }
    }
  }
  while (v9 != a2);
LABEL_12:
  if (a2[39] != a3 || *((_DWORD *)a2 + 53) || (int v12 = *((_DWORD *)a2 + 33), __dmb(0xBu), v12))
  {
    if ((*(unsigned char *)v6 & 1) == 0)
    {
LABEL_16:
      atomic_fetch_add(v6, 0xFFFFFFFFFFFFFFFCLL);
      return result;
    }
LABEL_18:
    atomic_ullong v13 = *v6;
    unint64_t v14 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
    while (1)
    {
      atomic_ullong v15 = v13;
      atomic_compare_exchange_strong(v6, (unint64_t *)&v15, v14);
      if (v15 == v13) {
        break;
      }
      if (atomic_fetch_add_explicit(v6, 0, memory_order_relaxed) != v13)
      {
        uint64_t result = sched_yield();
        goto LABEL_18;
      }
    }
  }
  else
  {
    if (*((unsigned char *)a2 + 337))
    {
      *((unsigned char *)a2 + 337) = 0;
      --*((_DWORD *)this + 11);
    }
    BOOL v19 = &this[5 * a2[17] + 9];
    if ((atomic_ullong *)v19[3] == a2)
    {
      int v20 = (atomic_ullong *)a2[1];
      if (v20 == v19)
      {
        int v20 = &this[5 * a2[17] + 9];
        if ((unint64_t)v19[2] >= 2) {
          int v20 = (atomic_ullong *)v19[1];
        }
      }
      v19[3] = (atomic_ullong)v20;
    }
    --v19[2];
    int v21 = (atomic_ullong *)a2[1];
    *int v21 = *a2;
    *(void *)(*a2 + 8) = v21;
    atomic_ullong v22 = a2[39];
    if (v22 == this[24]) {
      this[24] = v22 + 1;
    }
    if (*(unsigned char *)v6)
    {
LABEL_41:
      atomic_ullong v23 = *v6;
      unint64_t v24 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
      while (1)
      {
        atomic_ullong v25 = v23;
        atomic_compare_exchange_strong(v6, (unint64_t *)&v25, v24);
        if (v25 == v23) {
          break;
        }
        if (atomic_fetch_add_explicit(v6, 0, memory_order_relaxed) != v23)
        {
          sched_yield();
          goto LABEL_41;
        }
      }
    }
    else
    {
      atomic_fetch_add(v6, 0xFFFFFFFFFFFFFFFCLL);
    }
    return tbb::internal::arena::free_arena((tbb::internal::arena *)a2, v8);
  }
  return result;
}

uint64_t tbb::internal::market::arena_in_need(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a2 + 8) == a2) {
    return 0;
  }
  uint64_t result = a3;
  while (1)
  {
    uint64_t v4 = *(void *)(result + 8);
    uint64_t v5 = *(void *)(a2 + 8);
    unsigned int v6 = *(_DWORD *)(result + 132);
    __dmb(0xBu);
    if (*(_DWORD *)(result + 128) > v6 >> 12) {
      break;
    }
    if (v4 == a2) {
      uint64_t result = v5;
    }
    else {
      uint64_t result = v4;
    }
    if (result == a3) {
      return 0;
    }
  }
  atomic_fetch_add((atomic_uint *volatile)(result + 132), 0x1000u);
  return result;
}

uint64_t tbb::internal::market::update_allotment(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 >= a4) {
    int v4 = a4;
  }
  else {
    int v4 = a3;
  }
  uint64_t v5 = *(void *)(a2 + 8);
  if (v5 == a2) {
    return 0;
  }
  uint64_t v6 = 0;
  int v7 = 0;
  do
  {
    int v10 = *(_DWORD *)(v5 + 212);
    if (v10 >= 1)
    {
      if (*(_DWORD *)(a1 + 28))
      {
        int v8 = v7 + v10 * v4;
        int v9 = v8 / a3;
        int v7 = v8 % a3;
        if (v9 >= *(_DWORD *)(v5 + 208)) {
          int v9 = *(_DWORD *)(v5 + 208);
        }
      }
      else
      {
        if (*(unsigned char *)(v5 + 337)) {
          BOOL v11 = (int)v6 < v4;
        }
        else {
          BOOL v11 = 0;
        }
        int v9 = v11;
      }
      *(_DWORD *)(v5 + 128) = v9;
      uint64_t v6 = (v9 + v6);
    }
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5 != a2);
  return v6;
}

BOOL tbb::internal::market::is_arena_in_list(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v3 = a2;
  do
  {
    uint64_t v3 = *(void *)(v3 + 8);
    BOOL result = v3 != a2;
  }
  while (v3 != a3 && v3 != a2);
  return result;
}

void *tbb::internal::market::arena_in_need(uint64_t a1, void *a2)
{
  int v2 = *(_DWORD *)(a1 + 40);
  __dmb(0xBu);
  if (v2 < 1) {
    return 0;
  }
  uint64_t v5 = (atomic_ullong *)(a1 + 8);
  tbb::spin_rw_mutex_v3::internal_acquire_reader((atomic_ullong *)(a1 + 8));
  uint64_t v6 = *(int *)(a1 + 48);
  if (a2)
  {
    uint64_t v7 = a1 + 40 * (int)v6 + 72;
    uint64_t v8 = v7;
    while (1)
    {
      uint64_t v8 = *(void *)(v8 + 8);
      if (v8 == v7) {
        break;
      }
      if ((void *)v8 == a2)
      {
        if (*(void *)(a1 + 40 * (int)v6 + 80) == v7) {
          break;
        }
        BOOL result = a2;
        while (1)
        {
          int v10 = (void *)result[1];
          BOOL v11 = *(void **)(a1 + 40 * (int)v6 + 80);
          unsigned int v12 = *((_DWORD *)result + 33);
          __dmb(0xBu);
          if (*((_DWORD *)result + 32) > v12 >> 12) {
            break;
          }
          if (v10 == (void *)v7) {
            BOOL result = v11;
          }
          else {
            BOOL result = v10;
          }
          if (result == a2) {
            goto LABEL_13;
          }
        }
        atomic_fetch_add((atomic_uint *volatile)result + 33, 0x1000u);
        goto LABEL_28;
      }
    }
  }
LABEL_13:
  if (*(void *)(a1 + 56) <= v6)
  {
    while (1)
    {
      uint64_t v13 = a1 + 40 * v6;
      atomic_ullong v16 = *(void **)(v13 + 96);
      unint64_t v14 = (void *)(v13 + 96);
      atomic_ullong v15 = v16;
      if ((void *)*(v14 - 2) != v14 - 3) {
        break;
      }
LABEL_17:
      if (*(void *)(a1 + 56) > --v6) {
        goto LABEL_14;
      }
    }
    BOOL result = v15;
    while (1)
    {
      unint64_t v17 = (void *)result[1];
      atomic_ullong v18 = (void *)*(v14 - 2);
      unsigned int v19 = *((_DWORD *)result + 33);
      __dmb(0xBu);
      if (*((_DWORD *)result + 32) > v19 >> 12) {
        break;
      }
      if (v17 == v14 - 3) {
        BOOL result = v18;
      }
      else {
        BOOL result = v17;
      }
      if (result == v15) {
        goto LABEL_17;
      }
    }
    atomic_fetch_add((atomic_uint *volatile)result + 33, 0x1000u);
    __dmb(0xBu);
    void *v14 = result;
  }
  else
  {
LABEL_14:
    BOOL result = 0;
  }
LABEL_28:
  atomic_fetch_add(v5, 0xFFFFFFFFFFFFFFFCLL);
  return result;
}

uint64_t tbb::internal::market::enable_mandatory_concurrency(uint64_t a1, uint64_t a2)
{
  int v4 = (atomic_ullong *)(a1 + 8);
  uint64_t result = tbb::spin_rw_mutex_v3::internal_acquire_writer((atomic_ullong *)(a1 + 8));
  if (*(_DWORD *)(a1 + 28))
  {
    int v6 = 0;
    char v7 = 1;
  }
  else
  {
    char v7 = 1;
    if (*(unsigned char *)(a2 + 337))
    {
      int v6 = 0;
    }
    else
    {
      *(unsigned char *)(a2 + 337) = 1;
      int v9 = *(_DWORD *)(a1 + 40);
      int v8 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)(a1 + 44) = v8 + 1;
      int v10 = *(_DWORD *)(a1 + 32);
      int v11 = v9 & (v9 >> 31);
      if (v8 >= 0) {
        int v12 = 1;
      }
      else {
        int v12 = v11;
      }
      *(_DWORD *)(a1 + 32) = v12;
      uint64_t v13 = *(void *)(a1 + 48);
      *(_DWORD *)(a1 + 40 * v13 + 108) = v12;
      uint64_t result = tbb::internal::market::update_allotment(a1, v13);
      char v7 = 0;
      int v6 = *(_DWORD *)(a1 + 32) - v10;
    }
  }
LABEL_9:
  atomic_ullong v14 = *v4;
  unint64_t v15 = *v4 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v16 = v14;
    atomic_compare_exchange_strong(v4, (unint64_t *)&v16, v15);
    if (v16 == v14) {
      break;
    }
    if (atomic_fetch_add_explicit(v4, 0, memory_order_relaxed) != v14)
    {
      uint64_t result = sched_yield();
      goto LABEL_9;
    }
  }
  if (v6) {
    char v17 = v7;
  }
  else {
    char v17 = 1;
  }
  if ((v17 & 1) == 0)
  {
    atomic_ullong v18 = *(uint64_t (**)(void))(**(void **)(a1 + 16) + 40);
    return v18();
  }
  return result;
}

uint64_t tbb::internal::market::mandatory_concurrency_disable(atomic_ullong *this, tbb::internal::arena *a2)
{
  int v4 = this + 1;
  char v5 = 1;
  uint64_t result = tbb::spin_rw_mutex_v3::internal_acquire_writer(this + 1);
  if (*((unsigned char *)a2 + 337) && (uint64_t result = tbb::internal::arena::has_enqueued_tasks(a2), (result & 1) == 0))
  {
    *((unsigned char *)a2 + 337) = 0;
    int v9 = *((_DWORD *)this + 10);
    int v8 = *((_DWORD *)this + 11);
    int v10 = *((_DWORD *)this + 8);
    if (v9 >= *((_DWORD *)this + 7)) {
      int v9 = *((_DWORD *)this + 7);
    }
    BOOL v11 = __OFSUB__(v8, 1);
    int v12 = v8 - 1;
    *((_DWORD *)this + 11) = v12;
    if ((v12 < 0) ^ v11 | (v12 == 0)) {
      int v13 = v9;
    }
    else {
      int v13 = 1;
    }
    *((_DWORD *)this + 8) = v13;
    uint64_t v14 = this[6];
    HIDWORD(this[5 * v14 + 13]) = v13;
    uint64_t result = tbb::internal::market::update_allotment((uint64_t)this, v14);
    char v5 = 0;
    int v7 = *((_DWORD *)this + 8) - v10;
  }
  else
  {
    int v7 = 0;
  }
LABEL_10:
  atomic_ullong v15 = *v4;
  unint64_t v16 = *v4 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v17 = v15;
    atomic_compare_exchange_strong(v4, (unint64_t *)&v17, v16);
    if (v17 == v15) {
      break;
    }
    if (atomic_fetch_add_explicit(v4, 0, memory_order_relaxed) != v15)
    {
      uint64_t result = sched_yield();
      goto LABEL_10;
    }
  }
  if (v7) {
    char v18 = v5;
  }
  else {
    char v18 = 1;
  }
  if ((v18 & 1) == 0)
  {
    unsigned int v19 = *(uint64_t (**)(void))(*(void *)this[2] + 40);
    return v19();
  }
  return result;
}

void sub_21676C0DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t tbb::internal::market::adjust_demand(uint64_t result, uint64_t a2, int a3)
{
  if (!a3) {
    return result;
  }
  int v3 = a3;
  uint64_t v5 = result;
  int v6 = (atomic_ullong *)(result + 8);
  uint64_t result = tbb::spin_rw_mutex_v3::internal_acquire_writer((atomic_ullong *)(result + 8));
  int v7 = *(_DWORD *)(a2 + 212);
  int v8 = v7 + v3;
  *(_DWORD *)(a2 + 212) = v7 + v3;
  if (!((v7 + v3 < 0) ^ __OFADD__(v7, v3) | (v7 + v3 == 0)))
  {
    if (v7 < 0) {
      v3 += v7;
    }
LABEL_8:
    int v9 = *(_DWORD *)(v5 + 44);
    *(_DWORD *)(v5 + 40) += v3;
    if (v9 >= 1) {
      int v10 = 1;
    }
    else {
      int v10 = *(_DWORD *)(v5 + 28);
    }
    uint64_t v11 = *(void *)(a2 + 136);
    uint64_t v12 = v5 + 40 * v11;
    int v14 = *(_DWORD *)(v12 + 104);
    int v13 = (_DWORD *)(v12 + 104);
    *int v13 = v14 + v3;
    if (v8 <= 0)
    {
      if (*(void *)(a2 + 136) != 1)
      {
        uint64_t v15 = *(void *)(a2 + 136);
        unint64_t v16 = (void *)(v5 + 72 + 40 * v15);
        if (v16[3] == a2)
        {
          uint64_t v17 = *(void *)(a2 + 8);
          if ((void *)v17 == v16)
          {
            uint64_t v17 = v5 + 72 + 40 * *(void *)(a2 + 136);
            if (v16[2] >= 2uLL) {
              uint64_t v17 = v16[1];
            }
          }
          v16[3] = v17;
        }
        --v16[2];
        char v18 = *(void **)(a2 + 8);
        *char v18 = *(void *)a2;
        *(void *)(*(void *)a2 + 8) = v18;
        *(void *)(a2 + 136) = 1;
        uint64_t v19 = v5 + 40 * *(void *)(a2 + 136);
        uint64_t v20 = *(void *)(a2 + 136);
        uint64_t v21 = *(void *)(v19 + 80);
        uint64_t v22 = *(void *)(v19 + 88);
        *(void *)a2 = v19 + 72;
        *(void *)(a2 + 8) = v21;
        **(void **)(v19 + 80) = a2;
        *(void *)(v19 + 80) = a2;
        *(void *)(v19 + 88) = v22 + 1;
        if (!v22) {
          *(void *)(v5 + 40 * v20 + 96) = a2;
        }
        atomic_fetch_add((atomic_ullong *volatile)(a2 + 272), 1uLL);
        int v23 = *(_DWORD *)(a2 + 212);
        *(_DWORD *)(v5 + 40 * v15 + 104) -= v23;
        *(_DWORD *)(v5 + 144) += v23;
      }
      *(void *)(a2 + 264) = 1;
    }
    uint64_t v24 = *(void *)(v5 + 48);
    if (v11 == v24)
    {
      if (!*v13)
      {
        atomic_ullong v25 = (int *)(v5 + 40 * v11 + 64);
        while (v11 > *(void *)(v5 + 56))
        {
          --v11;
          int v26 = *v25;
          v25 -= 10;
          if (v26) {
            goto LABEL_54;
          }
        }
        uint64_t v11 = 1;
        *(void *)(v5 + 56) = 1;
LABEL_54:
        *(void *)(v5 + 48) = v11;
        if (*(_DWORD *)(v5 + 28)) {
          BOOL v38 = 1;
        }
        else {
          BOOL v38 = *(_DWORD *)(v5 + 44) == 0;
        }
        if (v38) {
          int v39 = *(_DWORD *)(v5 + 28);
        }
        else {
          int v39 = 1;
        }
        *(_DWORD *)(v5 + 40 * v11 + 108) = v39;
        uint64_t v40 = *(void *)(v5 + 64) + 1;
        __dmb(0xBu);
        *(void *)(v5 + 64) = v40;
      }
      uint64_t v11 = *(void *)(v5 + 48);
      *(_DWORD *)(v5 + 40 * v11 + 108) = v10;
    }
    else if (v11 <= v24)
    {
      uint64_t v32 = *(void *)(v5 + 56);
      if (v11 == v32)
      {
        if (!*v13)
        {
          int v33 = (int *)(v5 + 40 * v11 + 144);
          while (v24 != v11)
          {
            ++v11;
            int v34 = *v33;
            v33 += 10;
            if (v34)
            {
              *(void *)(v5 + 56) = v11;
              goto LABEL_63;
            }
          }
          *(int64x2_t *)(v5 + 48) = vdupq_n_s64(1uLL);
          if (*(_DWORD *)(v5 + 28)) {
            BOOL v51 = 1;
          }
          else {
            BOOL v51 = *(_DWORD *)(v5 + 44) == 0;
          }
          if (v51) {
            int v52 = *(_DWORD *)(v5 + 28);
          }
          else {
            int v52 = 1;
          }
          *(_DWORD *)(v5 + 148) = v52;
          uint64_t v53 = *(void *)(v5 + 64) + 1;
          __dmb(0xBu);
          *(void *)(v5 + 64) = v53;
          goto LABEL_63;
        }
      }
      else if (v11 < v32)
      {
        *(void *)(v5 + 56) = v11;
        uint64_t v11 = (int)v32;
      }
    }
    else
    {
      *(void *)(v5 + 48) = v11;
      if (*(_DWORD *)(v5 + 28)) {
        BOOL v27 = 1;
      }
      else {
        BOOL v27 = *(_DWORD *)(v5 + 44) == 0;
      }
      if (v27) {
        int v28 = *(_DWORD *)(v5 + 28);
      }
      else {
        int v28 = 1;
      }
      uint64_t v29 = v5 + 40 * v11;
      *(_DWORD *)(v29 + 108) = v28;
      uint64_t v30 = *(void *)(v5 + 64) + 1;
      __dmb(0xBu);
      *(void *)(v5 + 64) = v30;
      int v31 = *(_DWORD *)(a2 + 212);
      if (v10 < v31) {
        int v31 = v10;
      }
      *(_DWORD *)(a2 + 128) = v31;
      --v11;
      *(_DWORD *)(v29 + 68) = v10 - v31;
    }
    tbb::internal::market::update_allotment(v5, v11);
LABEL_63:
    int v41 = *(_DWORD *)(v5 + 32);
    int v42 = v41 + v3;
    if (v3 < 1)
    {
      int v44 = *(_DWORD *)(v5 + 40);
      if (v44 >= v10) {
        int v45 = v10;
      }
      else {
        int v45 = *(_DWORD *)(v5 + 40);
      }
      int v46 = v45 - v41;
      if (v42 < v44) {
        int v43 = v46;
      }
      else {
        int v43 = v3;
      }
    }
    else if (v42 <= v10)
    {
      int v43 = v3;
    }
    else
    {
      int v43 = v10 - v41;
    }
    *(_DWORD *)(v5 + 32) = v41 + v43;
    if (*(unsigned char *)(v5 + 8))
    {
LABEL_78:
      atomic_ullong v48 = *v6;
      unint64_t v49 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
      while (1)
      {
        atomic_ullong v50 = v48;
        atomic_compare_exchange_strong(v6, (unint64_t *)&v50, v49);
        if (v50 == v48) {
          break;
        }
        if (atomic_fetch_add_explicit(v6, 0, memory_order_relaxed) != v48)
        {
          sched_yield();
          goto LABEL_78;
        }
      }
    }
    else
    {
      atomic_fetch_add(v6, 0xFFFFFFFFFFFFFFFCLL);
    }
    int v47 = *(uint64_t (**)(void))(**(void **)(v5 + 16) + 40);
    return v47();
  }
  *(_DWORD *)(a2 + 128) = 0;
  if (v7 > 0)
  {
    int v3 = -v7;
    goto LABEL_8;
  }
  if (*(unsigned char *)v6)
  {
LABEL_47:
    atomic_ullong v35 = *v6;
    unint64_t v36 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
    while (1)
    {
      atomic_ullong v37 = v35;
      atomic_compare_exchange_strong(v6, (unint64_t *)&v37, v36);
      if (v37 == v35) {
        break;
      }
      if (atomic_fetch_add_explicit(v6, 0, memory_order_relaxed) != v35)
      {
        uint64_t result = sched_yield();
        goto LABEL_47;
      }
    }
  }
  else
  {
    atomic_fetch_add(v6, 0xFFFFFFFFFFFFFFFCLL);
  }
  return result;
}

uint64_t tbb::internal::market::update_arena_top_priority(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 136);
  int v4 = (void *)(result + 72 + 40 * v3);
  if (v4[3] == a2)
  {
    uint64_t v5 = *(void *)(a2 + 8);
    if ((void *)v5 == v4)
    {
      uint64_t v5 = result + 72 + 40 * *(void *)(a2 + 136);
      if (v4[2] >= 2uLL) {
        uint64_t v5 = v4[1];
      }
    }
    v4[3] = v5;
  }
  --v4[2];
  int v6 = *(void **)(a2 + 8);
  *int v6 = *(void *)a2;
  *(void *)(*(void *)a2 + 8) = v6;
  *(void *)(a2 + 136) = a3;
  uint64_t v7 = result + 40 * *(void *)(a2 + 136);
  uint64_t v8 = *(void *)(a2 + 136);
  uint64_t v9 = *(void *)(v7 + 80);
  uint64_t v10 = *(void *)(v7 + 88);
  *(void *)a2 = v7 + 72;
  *(void *)(a2 + 8) = v9;
  **(void **)(v7 + 80) = a2;
  *(void *)(v7 + 80) = a2;
  *(void *)(v7 + 88) = v10 + 1;
  if (!v10) {
    *(void *)(result + 40 * v8 + 96) = a2;
  }
  atomic_fetch_add((atomic_ullong *volatile)(a2 + 272), 1uLL);
  int v11 = *(_DWORD *)(a2 + 212);
  *(_DWORD *)(result + 72 + 40 * v3 + 32) -= v11;
  *(_DWORD *)(result + 72 + 40 * a3 + 32) += v11;
  return result;
}

tbb::internal::arena *tbb::internal::market::process(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (tbb::internal::generic_scheduler *)(a2 - 8);
  for (uint64_t i = (tbb::internal::arena *)tbb::internal::market::arena_in_need(a1, *(void **)(a2 + 40));
        i;
        uint64_t i = (tbb::internal::arena *)tbb::internal::market::arena_in_need(a1, 0))
  {
    tbb::internal::arena::process(i, v3);
  }
  sched_yield();
  while (1)
  {
    uint64_t result = (tbb::internal::arena *)tbb::internal::market::arena_in_need(a1, 0);
    if (!result) {
      break;
    }
    tbb::internal::arena::process(result, v3);
  }
  return result;
}

uint64_t tbb::internal::market::cleanup(uint64_t a1, uint64_t a2)
{
  int v2 = (tbb::internal::observer_proxy **)(a2 - 8);
  unint64_t v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS) & 0xFFFFFFFFFFFFFFFELL;
  if (v2 == (tbb::internal::observer_proxy **)v3)
  {
    return tbb::internal::generic_scheduler::cleanup_worker(v2, (void *)1);
  }
  else
  {
    tbb::internal::governor::assume_scheduler((uint64_t)v2);
    tbb::internal::generic_scheduler::cleanup_worker(v2, (void *)(v3 != 0));
    return tbb::internal::governor::assume_scheduler(v3);
  }
}

tbb::internal::governor *tbb::internal::market::acknowledge_close_connection(tbb::internal::market *this, void *a2)
{
  int v2 = (tbb::internal::governor *)tbb::internal::NFS_Free(this, a2);

  return tbb::internal::__TBB_InitOnce::remove_ref(v2);
}

uint64_t tbb::internal::market::create_one_job(atomic_uint *this)
{
  unsigned int add = atomic_fetch_add(this + 9, 1u);
  uint64_t worker = tbb::internal::generic_scheduler::create_worker((tbb::internal::generic_scheduler *)this, (tbb::internal::market *)(add + 1), 1);
  *(void *)&this[2 * add + 62] = worker;
  if (worker) {
    return worker + 8;
  }
  else {
    return 0;
  }
}

BOOL tbb::internal::market::lower_arena_priority(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (atomic_ullong *)(a1 + 8);
  tbb::spin_rw_mutex_v3::internal_acquire_writer((atomic_ullong *)(a1 + 8));
  uint64_t v9 = *(void *)(a2 + 272);
  if (v9 == a4)
  {
    uint64_t v10 = *(void *)(a2 + 136);
    int v11 = (void *)(a1 + 72 + 40 * v10);
    if (v11[3] == a2)
    {
      uint64_t v12 = *(void *)(a2 + 8);
      if ((void *)v12 == v11)
      {
        uint64_t v12 = a1 + 72 + 40 * *(void *)(a2 + 136);
        if (v11[2] >= 2uLL) {
          uint64_t v12 = v11[1];
        }
      }
      v11[3] = v12;
    }
    --v11[2];
    int v13 = *(void **)(a2 + 8);
    *int v13 = *(void *)a2;
    *(void *)(*(void *)a2 + 8) = v13;
    *(void *)(a2 + 136) = a3;
    uint64_t v14 = a1 + 40 * *(void *)(a2 + 136);
    uint64_t v15 = *(void *)(a2 + 136);
    uint64_t v16 = *(void *)(v14 + 80);
    uint64_t v17 = *(void *)(v14 + 88);
    *(void *)a2 = v14 + 72;
    *(void *)(a2 + 8) = v16;
    **(void **)(v14 + 80) = a2;
    *(void *)(v14 + 80) = a2;
    *(void *)(v14 + 88) = v17 + 1;
    if (!v17) {
      *(void *)(a1 + 40 * v15 + 96) = a2;
    }
    atomic_fetch_add((atomic_ullong *volatile)(a2 + 272), 1uLL);
    int v18 = *(_DWORD *)(a2 + 212);
    *(_DWORD *)(a1 + 72 + 40 * v10 + 32) -= v18;
    *(_DWORD *)(a1 + 72 + 40 * a3 + 32) += v18;
    if (v18 >= 1)
    {
      uint64_t v19 = *(void *)(a1 + 56);
      if (v19 > a3)
      {
        *(void *)(a1 + 56) = a3;
        uint64_t v19 = a3;
      }
      if (v10 == *(void *)(a1 + 48) && !*(_DWORD *)(a1 + 40 * v10 + 104))
      {
        uint64_t v20 = v10 - 1;
        if (v19 < v10 - 1) {
          uint64_t v20 = v19;
        }
        uint64_t v21 = (int *)(a1 + 40 * v10 + 64);
        while (--v10 > v19)
        {
          int v22 = *v21;
          v21 -= 10;
          if (v22) {
            goto LABEL_21;
          }
        }
        uint64_t v10 = v20;
LABEL_21:
        *(void *)(a1 + 48) = v10;
        if (*(_DWORD *)(a1 + 28)) {
          BOOL v23 = 1;
        }
        else {
          BOOL v23 = *(_DWORD *)(a1 + 44) == 0;
        }
        if (v23) {
          int v24 = *(_DWORD *)(a1 + 28);
        }
        else {
          int v24 = 1;
        }
        *(_DWORD *)(a1 + 40 * v10 + 108) = v24;
        uint64_t v25 = *(void *)(a1 + 64) + 1;
        __dmb(0xBu);
        *(void *)(a1 + 64) = v25;
      }
      tbb::internal::market::update_allotment(a1, v10);
    }
  }
LABEL_29:
  atomic_ullong v26 = *v8;
  unint64_t v27 = *v8 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v28 = v26;
    atomic_compare_exchange_strong(v8, (unint64_t *)&v28, v27);
    if (v28 == v26) {
      return v9 == a4;
    }
    if (atomic_fetch_add_explicit(v8, 0, memory_order_relaxed) != v26)
    {
      sched_yield();
      goto LABEL_29;
    }
  }
}

uint64_t tbb::internal::market::update_arena_priority(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (atomic_ullong *)(a1 + 8);
  tbb::spin_rw_mutex_v3::internal_acquire_writer((atomic_ullong *)(a1 + 8));
  if (*(void *)(a2 + 136) != a3)
  {
    if (*(void *)(a2 + 136) > a3)
    {
      uint64_t v7 = 0;
      if (*(void *)(a2 + 264) > a3) {
        *(void *)(a2 + 264) = a3;
      }
      goto LABEL_35;
    }
    if (*(int *)(a2 + 212) < 1)
    {
      uint64_t v7 = 0;
      goto LABEL_35;
    }
    uint64_t v8 = *(void *)(a2 + 136);
    if (v8 <= a3) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = *(void *)(a2 + 136);
    }
    uint64_t v10 = *(void *)(a2 + 136);
    int v11 = (void *)(a1 + 72 + 40 * v10);
    if (v11[3] == a2)
    {
      uint64_t v12 = *(void *)(a2 + 8);
      if ((void *)v12 == v11)
      {
        uint64_t v12 = a1 + 72 + 40 * *(void *)(a2 + 136);
        if (v11[2] >= 2uLL) {
          uint64_t v12 = v11[1];
        }
      }
      v11[3] = v12;
    }
    --v11[2];
    int v13 = *(void **)(a2 + 8);
    *int v13 = *(void *)a2;
    *(void *)(*(void *)a2 + 8) = v13;
    *(void *)(a2 + 136) = a3;
    uint64_t v14 = a1 + 40 * *(void *)(a2 + 136);
    uint64_t v15 = *(void *)(a2 + 136);
    uint64_t v16 = *(void *)(v14 + 80);
    uint64_t v17 = *(void *)(v14 + 88);
    *(void *)a2 = v14 + 72;
    *(void *)(a2 + 8) = v16;
    **(void **)(v14 + 80) = a2;
    *(void *)(v14 + 80) = a2;
    *(void *)(v14 + 88) = v17 + 1;
    if (!v17) {
      *(void *)(a1 + 40 * v15 + 96) = a2;
    }
    atomic_fetch_add((atomic_ullong *volatile)(a2 + 272), 1uLL);
    int v18 = *(_DWORD *)(a2 + 212);
    *(_DWORD *)(a1 + 72 + 40 * v10 + 32) -= v18;
    *(_DWORD *)(a1 + 72 + 40 * a3 + 32) += v18;
    uint64_t v19 = *(void *)(a1 + 48);
    if (v19 >= a3)
    {
      if (v19 == a3)
      {
LABEL_28:
        uint64_t v22 = *(void *)(a1 + 64) + 1;
        __dmb(0xBu);
        *(void *)(a1 + 64) = v22;
LABEL_29:
        if (v8 == *(void *)(a1 + 56))
        {
          uint64_t v23 = *(void *)(a1 + 48);
          if (v8 < v23)
          {
            int v24 = (int *)(a1 + 40 * v8 + 104);
            do
            {
              int v25 = *v24;
              v24 += 10;
              if (v25) {
                break;
              }
              *(void *)(a1 + 56) = ++v8;
            }
            while (v23 != v8);
          }
        }
        tbb::internal::market::update_allotment(a1, v9);
        uint64_t v7 = 1;
        goto LABEL_35;
      }
      if (v8 != v19 || *(_DWORD *)(a1 + 40 * v8 + 104)) {
        goto LABEL_29;
      }
      uint64_t v30 = (int *)(a1 + 40 * v8 + 64);
      a3 = v8;
      do
      {
        --a3;
        int v31 = *v30;
        v30 -= 10;
        uint64_t v8 = a3;
        uint64_t v9 = a3;
      }
      while (!v31);
    }
    *(void *)(a1 + 48) = a3;
    if (*(_DWORD *)(a1 + 28)) {
      BOOL v20 = 1;
    }
    else {
      BOOL v20 = *(_DWORD *)(a1 + 44) == 0;
    }
    if (v20) {
      int v21 = *(_DWORD *)(a1 + 28);
    }
    else {
      int v21 = 1;
    }
    *(_DWORD *)(a1 + 40 * a3 + 108) = v21;
    goto LABEL_28;
  }
  uint64_t v7 = 0;
LABEL_35:
  atomic_ullong v26 = *v6;
  unint64_t v27 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v28 = v26;
    atomic_compare_exchange_strong(v6, (unint64_t *)&v28, v27);
    if (v28 == v26) {
      return v7;
    }
    if (atomic_fetch_add_explicit(v6, 0, memory_order_relaxed) != v26)
    {
      sched_yield();
      goto LABEL_35;
    }
  }
}

uint64_t sub_21676CBE4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_21676CBEC(uint64_t a1)
{
  return *(void *)(a1 + 208);
}

uint64_t sub_21676CBF4()
{
  return 1;
}

tbb::internal::task_scheduler_observer_v3 *tbb::internal::construct_binding_observer(tbb::internal::numa_topology *a1, int a2, tbb::internal *a3)
{
  if (a2 < 0 || tbb::internal::numa_topology::nodes_count(a1) < 2) {
    return 0;
  }
  int v6 = (tbb::internal::task_scheduler_observer_v3 *)operator new(0x30uLL);
  sub_21676CC94((uint64_t)v6, (uint64_t)a1, a2, a3);
  if (!*((void *)v6 + 1)) {
    *((void *)v6 + 2) = 0x8000000000000000;
  }
  tbb::internal::task_scheduler_observer_v3::observe(v6, 1);
  return v6;
}

void sub_21676CC80(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_21676CC94(uint64_t a1, uint64_t a2, int a3, tbb::internal *this)
{
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a2;
  *(void *)a1 = &unk_26C746B78;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = tbb::internal::construct_binding_handler(this);
  return a1;
}

void sub_21676CCEC(_Unwind_Exception *exception_object)
{
  *(void *)int v1 = &unk_26C746BE8;
  if (!*((void *)v1 + 1))
  {
    *(void *)int v1 = &unk_26C746C18;
    _Unwind_Resume(exception_object);
  }
  tbb::internal::task_scheduler_observer_v3::observe(v1, 0);
  uint64_t v3 = *((void *)v1 + 1);
  *(void *)int v1 = &unk_26C746C18;
  if (v3) {
    tbb::internal::task_scheduler_observer_v3::observe(v1, 0);
  }
  _Unwind_Resume(exception_object);
}

void tbb::internal::destroy_binding_observer(tbb::internal::task_scheduler_observer_v3 *a1)
{
  tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
  if (a1)
  {
    int v2 = *(void (**)(tbb::internal::task_scheduler_observer_v3 *))(*(void *)a1 + 24);
    v2(a1);
  }
}

uint64_t tbb::internal::generic_scheduler::attach_arena(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(void *)(result + 32) = a3;
  *(void *)(result + 40) = a2 + (a3 << 8) + 384;
  *(void *)(result + 48) = a2;
  uint64_t v4 = a2 - ((unint64_t)(unsigned __int16)(a3 + 1) << 7);
  *(void *)(result + 64) = v4;
  *(_WORD *)(result + 72) = a3 + 1;
  if (a4)
  {
    if (a2 && *(unsigned char *)(v4 + 20)) {
      *(unsigned char *)(v4 + 20) = 0;
    }
    uint64_t v5 = (void *)(a2 + 272);
    *(void *)(result + 96) = a2 + 136;
    *(void *)(result + 104) = a2 + 272;
  }
  else
  {
    *(void *)(*(void *)(result + 144) - 56) = *(void *)(a2 + 320);
    uint64_t v5 = *(void **)(result + 104);
  }
  *(void *)(result + 352) = *v5;
  return result;
}

uint64_t tbb::internal::arena::occupy_free_slot_in_range(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a4 <= a3) {
    return -1;
  }
  unint64_t v4 = *(void *)(a2 + 32);
  if (v4 < a3 || v4 >= a4)
  {
    unint64_t v6 = *(unsigned int *)(a2 + 128);
    *(_DWORD *)(a2 + 128) = *(_DWORD *)(a2 + 132) - 1640531535 * v6;
    unint64_t v4 = (v6 >> 16) % (a4 - a3) + a3;
  }
  if (v4 < a4)
  {
    uint64_t v7 = v4;
    while (1)
    {
      uint64_t v8 = a1 + (v7 << 8);
      if (!*(void *)(v8 + 384)) {
        break;
      }
LABEL_10:
      if (++v7 == a4) {
        goto LABEL_16;
      }
    }
    uint64_t v9 = (atomic_ullong *)(v8 + 384);
    while (1)
    {
      uint64_t v10 = 0;
      atomic_compare_exchange_strong(v9, (unint64_t *)&v10, a2);
      if (!v10) {
        return v7;
      }
      if (atomic_fetch_add_explicit(v9, 0, memory_order_relaxed)) {
        goto LABEL_10;
      }
    }
  }
LABEL_16:
  if (v4 <= a3) {
    return -1;
  }
  while (1)
  {
    uint64_t v12 = a1 + (a3 << 8);
    if (!*(void *)(v12 + 384)) {
      break;
    }
LABEL_19:
    ++a3;
    uint64_t v7 = -1;
    if (a3 == v4) {
      return v7;
    }
  }
  int v13 = (atomic_ullong *)(v12 + 384);
  while (1)
  {
    uint64_t v14 = 0;
    atomic_compare_exchange_strong(v13, (unint64_t *)&v14, a2);
    if (!v14) {
      return a3;
    }
    if (atomic_fetch_add_explicit(v13, 0, memory_order_relaxed)) {
      goto LABEL_19;
    }
  }
}

atomic_ullong *tbb::internal::arena::process(tbb::internal::arena *this, tbb::internal::generic_scheduler *a2)
{
  uint64_t v4 = sub_21676D154((unsigned int *)this, (unint64_t)a2);
  if (v4 != -1)
  {
    uint64_t v5 = v4;
    *(void *)(*((void *)a2 + 18) - 56) = *((void *)this + 40);
    uint64_t v7 = (tbb::internal::observer_proxy **)((char *)a2 + 88);
    uint64_t v6 = *((void *)a2 + 11);
    uint64_t v8 = (char *)this + 256 * v4 + 384;
    *((void *)a2 + 4) = v4;
    *((void *)a2 + 5) = v8;
    *((void *)a2 + 6) = this;
    *((void *)a2 + 8) = (char *)this - 128 * (unint64_t)(unsigned __int16)(v4 + 1);
    *((_WORD *)a2 + 36) = v4 + 1;
    *((void *)a2 + 44) = **((void **)a2 + 13);
    if (v6 != *((void *)this + 29))
    {
      tbb::internal::observer_list::do_notify_entry_observers((atomic_ullong *)this + 28, (atomic_ullong *)a2 + 11, 1);
      uint64_t v8 = (char *)*((void *)a2 + 5);
    }
    if (*((void *)v8 + 1)) {
      (*(void (**)(tbb::internal::generic_scheduler *, void, void))(*(void *)a2 + 48))(a2, *((void *)a2 + 18), 0);
    }
    while (1)
    {
      unsigned int v9 = *((_DWORD *)this + 33);
      __dmb(0xBu);
      if (*((_DWORD *)this + 32) < v9 >> 12) {
        break;
      }
      uint64_t v10 = (*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, void))(*(void *)a2 + 56))(a2, *((void *)a2 + 18) - 24, 0);
      if (v10)
      {
        uint64_t v11 = *((void *)a2 + 18);
        *((void *)a2 + 7) = v11;
        (*(void (**)(tbb::internal::generic_scheduler *, uint64_t, uint64_t))(*(void *)a2 + 48))(a2, v11, v10);
      }
    }
    if (*v7) {
      tbb::internal::observer_list::do_notify_exit_observers((atomic_ullong *)this + 28, *v7, 1);
    }
    *((void *)a2 + 11) = 0;
    if (*((void *)a2 + 42))
    {
      atomic_fetch_add((atomic_ullong *volatile)this + 36, 1uLL);
      do
      {
        unint64_t v13 = *((void *)this + 35);
        **((void **)a2 + 43) = v13;
        unint64_t v14 = *((void *)a2 + 42);
        while (1)
        {
          unint64_t v15 = v13;
          atomic_compare_exchange_strong((atomic_ullong *volatile)this + 35, &v15, v14);
          if (v15 == v13) {
            break;
          }
          unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)this + 35, 0, memory_order_relaxed);
          if (add_explicit != v13) {
            goto LABEL_14;
          }
        }
        unint64_t add_explicit = v13;
LABEL_14:
        ;
      }
      while (v13 != add_explicit);
      *((void *)a2 + 42) = 0;
    }
    __dmb(0xBu);
    *((void *)this + 32 * v5 + 48) = 0;
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 8) = 0;
  }
  uint64_t result = (atomic_ullong *)*((void *)this + 38);
  uint64_t v17 = *((void *)this + 39);
  if (atomic_fetch_add((atomic_uint *volatile)this + 33, 0xFFFFF000) == 4096)
  {
    return (atomic_ullong *)tbb::internal::market::try_destroy_arena(result, (atomic_ullong *)this, v17);
  }
  return result;
}

uint64_t sub_21676D154(unsigned int *a1, unint64_t a2)
{
  unint64_t v2 = a1[83];
  unint64_t v3 = a1[82];
  if (v2 >= v3) {
    return -1;
  }
  unint64_t v4 = *(void *)(a2 + 32);
  if (v4 < v2 || v4 >= v3)
  {
    unint64_t v6 = *(unsigned int *)(a2 + 128);
    *(_DWORD *)(a2 + 128) = *(_DWORD *)(a2 + 132) - 1640531535 * v6;
    unint64_t v4 = (v6 >> 16) % (v3 - v2) + v2;
  }
  if (v4 < v3)
  {
    uint64_t v7 = v4;
    while (1)
    {
      uint64_t v8 = &a1[64 * v7];
      if (!*((void *)v8 + 48)) {
        break;
      }
LABEL_10:
      if (++v7 == v3) {
        goto LABEL_16;
      }
    }
    unsigned int v9 = (atomic_ullong *)(v8 + 96);
    while (1)
    {
      uint64_t v10 = 0;
      atomic_compare_exchange_strong(v9, (unint64_t *)&v10, a2);
      if (!v10) {
        goto LABEL_25;
      }
      if (atomic_fetch_add_explicit(v9, 0, memory_order_relaxed)) {
        goto LABEL_10;
      }
    }
  }
LABEL_16:
  if (v4 <= v2) {
    return -1;
  }
  while (1)
  {
    uint64_t v12 = &a1[64 * v2];
    if (!*((void *)v12 + 48)) {
      break;
    }
LABEL_18:
    ++v2;
    uint64_t v7 = -1;
    if (v2 == v4) {
      return v7;
    }
  }
  unint64_t v13 = (atomic_ullong *)(v12 + 96);
  while (1)
  {
    uint64_t v14 = 0;
    atomic_compare_exchange_strong(v13, (unint64_t *)&v14, a2);
    if (!v14) {
      break;
    }
    if (atomic_fetch_add_explicit(v13, 0, memory_order_relaxed)) {
      goto LABEL_18;
    }
  }
  uint64_t v7 = v2;
LABEL_25:
  if (v7 != -1)
  {
    unsigned int v15 = v7 + 1;
LABEL_27:
    unsigned int v16 = a1[36];
    __dmb(0xBu);
    if (v16 < v15)
    {
      while (1)
      {
        unsigned int v17 = v16;
        atomic_compare_exchange_strong((atomic_uint *volatile)a1 + 36, &v17, v15);
        if (v17 == v16) {
          break;
        }
        if (a1[36] != v16) {
          goto LABEL_27;
        }
      }
    }
  }
  return v7;
}

uint64_t tbb::internal::arena::orphan_offloaded_tasks(uint64_t result, uint64_t a2)
{
  atomic_fetch_add((atomic_ullong *volatile)(result + 288), 1uLL);
  do
  {
    unint64_t v3 = *(void *)(result + 280);
    **(void **)(a2 + 344) = v3;
    unint64_t v4 = *(void *)(a2 + 336);
    while (1)
    {
      unint64_t v5 = v3;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(result + 280), &v5, v4);
      if (v5 == v3) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(result + 280), 0, memory_order_relaxed);
      if (add_explicit != v3) {
        goto LABEL_3;
      }
    }
    unint64_t add_explicit = v3;
LABEL_3:
    ;
  }
  while (v3 != add_explicit);
  *(void *)(a2 + 336) = 0;
  return result;
}

tbb::internal::arena *tbb::internal::arena::arena(tbb::internal::arena *this, tbb::internal::market *a2, unsigned int a3, int a4)
{
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_DWORD *)this + 50) = 0;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  *((unsigned char *)this + 345) = 0;
  *((void *)this + 45) = (char *)this + 360;
  *((void *)this + 46) = (char *)this + 360;
  *((void *)this + 44) = 0;
  *((_DWORD *)this + 94) = 0;
  *((void *)this + 38) = a2;
  __dmb(0xBu);
  *((_DWORD *)this + 36) = 1;
  if (a3 <= 2) {
    int v5 = 2;
  }
  else {
    int v5 = a3;
  }
  *((_DWORD *)this + 82) = v5;
  *((_DWORD *)this + 83) = a4;
  *((_DWORD *)this + 52) = a3 - a4;
  __dmb(0xBu);
  *((_DWORD *)this + 33) = 1;
  *((void *)this + 17) = 1;
  *((void *)this + 33) = *((void *)this + 17);
  *((void *)this + 39) = *((void *)a2 + 24);
  *((void *)this + 31) = this;
  uint64_t v6 = *((unsigned int *)this + 82);
  if (v6)
  {
    if (v6 == 1)
    {
      uint64_t v7 = 0;
LABEL_7:
      uint64_t v8 = (_DWORD *)((char *)this + 256 * v7 + 512);
      do
      {
        *uint64_t v8 = v7;
        ((void *)this - 16 * (unint64_t)(unsigned __int16)(v7 + 1))[1] = (char *)this
                                                                                - 128
                                                                                * (unint64_t)(unsigned __int16)(v7 + 1);
        v8 += 64;
        ++v7;
      }
      while (v6 != v7);
      goto LABEL_9;
    }
    uint64_t v7 = 0;
    if (!(_WORD)v6) {
      goto LABEL_7;
    }
    if ((unint64_t)(v6 - 1) >> 16) {
      goto LABEL_7;
    }
    uint64_t v10 = 0;
    uint64_t v7 = v6 & 0xFFFFFFFE;
    uint64_t v11 = (_DWORD *)((char *)this + 768);
    do
    {
      int v12 = v10 + 1;
      *(v11 - 64) = v10;
      uint64_t v13 = v10 + 2;
      uint64_t v14 = (char *)this + ((~v10 << 7) | 0xFFFFFFFFFF800080);
      *((void *)v14 + 1) = v14;
      ((void *)this - 16 * (unint64_t)((unsigned __int16)v13 & 0xFFFE))[1] = (char *)this
                                                                                    - 128
                                                                                    * (unint64_t)((unsigned __int16)v13 & 0xFFFE);
      *uint64_t v11 = v12;
      v11 += 128;
      uint64_t v10 = v13;
    }
    while (v7 != v13);
    if (v7 != v6) {
      goto LABEL_7;
    }
  }
LABEL_9:
  sub_21676D460((uint64_t)this + 152, v6);
  *((_WORD *)this + 168) = 0;
  return this;
}

void sub_21676D444(_Unwind_Exception *a1)
{
  tbb::internal::concurrent_monitor::~concurrent_monitor((tbb::internal::concurrent_monitor *)(v2 + 344));
  sub_21676FB94(v1, v4);
  _Unwind_Resume(a1);
}

void *sub_21676D460(uint64_t a1, unsigned int a2)
{
  if (a2 <= 0x3F)
  {
    unsigned int v3 = 2;
    if (a2 >= 3)
    {
      unint64_t v4 = a2 - 1;
      if (a2 >= 0x11) {
        v4 >>= 4;
      }
      if (v4 >= 4) {
        unint64_t v5 = v4 >> 2;
      }
      else {
        LOBYTE(v5) = v4;
      }
      if (v4 >= 4) {
        char v6 = (4 * (a2 > 0x10)) | 2;
      }
      else {
        char v6 = 4 * (a2 > 0x10);
      }
      unsigned int v3 = 2 << (v6 & 0xFE | ((v5 & 2) != 0));
    }
  }
  else
  {
    unsigned int v3 = 64;
  }
  *(_DWORD *)(a1 + 48) = v3;
  uint64_t v7 = v3;
  unint64_t v8 = (unint64_t)v3 << 7;
  size_t v9 = v8 | 0x10;
  uint64_t v10 = operator new[](v9);
  *uint64_t v10 = 128;
  v10[1] = v7;
  uint64_t v11 = v10 + 2;
  do
  {
    *((unsigned char *)v11 + 48) = 0;
    *((_OWORD *)v11 + 1) = 0uLL;
    *((_OWORD *)v11 + 2) = 0uLL;
    *(_OWORD *)uint64_t v11 = 0uLL;
    v11 += 16;
    v8 -= 128;
  }
  while (v8);
  *(void *)(a1 + 24) = v10 + 2;
  int v12 = operator new[](v9);
  *int v12 = 128;
  v12[1] = v7;
  uint64_t v13 = v7 << 7;
  uint64_t v14 = v7 << 7;
  unsigned int v15 = v12 + 2;
  do
  {
    *((unsigned char *)v15 + 48) = 0;
    *((_OWORD *)v15 + 1) = 0uLL;
    *((_OWORD *)v15 + 2) = 0uLL;
    *(_OWORD *)unsigned int v15 = 0uLL;
    v15 += 16;
    v14 -= 128;
  }
  while (v14);
  *(void *)(a1 + 32) = v12 + 2;
  uint64_t result = operator new[](v9);
  *uint64_t result = 128;
  result[1] = v7;
  unsigned int v17 = result + 2;
  do
  {
    *((unsigned char *)v17 + 48) = 0;
    *((_OWORD *)v17 + 1) = 0uLL;
    *((_OWORD *)v17 + 2) = 0uLL;
    *(_OWORD *)unsigned int v17 = 0uLL;
    v17 += 16;
    v13 -= 128;
  }
  while (v13);
  *(void *)(a1 + 40) = result + 2;
  return result;
}

tbb::internal::arena *tbb::internal::arena::allocate_arena(tbb::internal::arena *this, tbb::internal::market *a2, int a3, void *a4)
{
  unsigned int v5 = a2;
  if (a2 <= 2) {
    uint64_t v7 = 2;
  }
  else {
    uint64_t v7 = a2;
  }
  size_t v8 = 384 * (int)v7 + 384;
  size_t v9 = (char *)tbb::internal::NFS_Allocate(1uLL, v8, 0, a4);
  bzero(v9, v8);

  return tbb::internal::arena::arena((tbb::internal::arena *)&v9[128 * v7], this, v5, a3);
}

uint64_t tbb::internal::arena::free_arena(tbb::internal::arena *this, void *a2)
{
  if (*((_DWORD *)this + 82))
  {
    unint64_t v3 = 0;
    do
    {
      unint64_t v4 = (char *)this + 256 * v3;
      unsigned int v5 = (tbb::internal *)*((void *)v4 + 67);
      if (v5)
      {
        char v6 = v4 + 384;
        tbb::internal::NFS_Free(v5, a2);
        *((void *)v6 + 18) = 0;
        *((void *)v6 + 19) = 0;
      }
      uint64_t v7 = (uint64_t *)((char *)this - 128 * (unint64_t)(unsigned __int16)++v3);
      for (uint64_t i = *v7; *v7; uint64_t i = *v7)
      {
        *uint64_t v7 = *(void *)(i + 16);
        tbb::internal::NFS_Free((tbb::internal *)(i - 64), a2);
      }
    }
    while (v3 < *((unsigned int *)this + 82));
  }
  tbb::internal::market::release(*((tbb::internal::market **)this + 38), 0, 0);
  tbb::task_group_context::~task_group_context(*((tbb::task_group_context **)this + 40));
  tbb::internal::NFS_Free(*((tbb::internal **)this + 40), v9);
  if (*((void *)this + 28)) {
    tbb::internal::observer_list::clear((atomic_ullong *)this + 28);
  }
  uint64_t v10 = (tbb::internal::arena *)((char *)this - 128 * (unint64_t)*((unsigned __int16 *)this + 164));
  tbb::internal::concurrent_monitor::~concurrent_monitor((tbb::internal::arena *)((char *)this + 344));
  sub_21676FB94((void *)this + 19, v11);

  return tbb::internal::NFS_Free(v10, v12);
}

BOOL tbb::internal::arena::has_enqueued_tasks(tbb::internal::arena *this)
{
  if (*((void *)this + 19)) {
    return 1;
  }
  if (*((void *)this + 20)) {
    return 1;
  }
  return *((void *)this + 21) != 0;
}

void *tbb::internal::arena::restore_priority_if_need(void *this)
{
  int v1 = this;
  if (this[19] || this[20] || this[21])
  {
    this = (void *)sub_21676D830((uint64_t)this);
    if (v1[19] && ((uint64_t)v1[33] > 0 || (v1[17] & 0x8000000000000000) != 0)) {
      this = (void *)tbb::internal::market::update_arena_priority(v1[38], (uint64_t)v1, 0);
    }
    if (v1[20] && ((uint64_t)v1[33] > 1 || (uint64_t)v1[17] <= 0)) {
      this = (void *)tbb::internal::market::update_arena_priority(v1[38], (uint64_t)v1, 1);
    }
    if (v1[21] && ((uint64_t)v1[33] > 2 || (uint64_t)v1[17] <= 1))
    {
      uint64_t v2 = v1[38];
      return (void *)tbb::internal::market::update_arena_priority(v2, (uint64_t)v1, 2);
    }
  }
  return this;
}

uint64_t sub_21676D830(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(*(void *)(result + 304) + 28);
  __dmb(0xBu);
  if (!v2)
  {
    int v3 = *(unsigned __int8 *)(result + 337);
    __dmb(0xBu);
    if ((v3 & 1) == 0) {
      uint64_t result = tbb::internal::market::enable_mandatory_concurrency(*(void *)(result + 304), result);
    }
  }
  if (*(_DWORD *)(v1 + 208) || *(_DWORD *)(v1 + 332) != 1)
  {
    __dmb(0xBu);
    uint64_t v7 = *(void *)(v1 + 216);
    __dmb(0xBu);
    if (v7 == -1) {
      return result;
    }
    while (1)
    {
      uint64_t v8 = v7;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v1 + 216), (unint64_t *)&v8, 0xFFFFFFFFFFFFFFFFLL);
      if (v8 == v7) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 216), 0, memory_order_relaxed);
      if (add_explicit != v7)
      {
        if (add_explicit) {
          return result;
        }
        goto LABEL_13;
      }
    }
    if (v7) {
      return result;
    }
LABEL_13:
    if (v7)
    {
      while (1)
      {
        uint64_t v10 = 0;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v1 + 216), (unint64_t *)&v10, 0xFFFFFFFFFFFFFFFFLL);
        if (!v10) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 216), 0, memory_order_relaxed)) {
          return result;
        }
      }
    }
    uint64_t v4 = *(void *)(v1 + 304);
    int v6 = *(_DWORD *)(v1 + 208);
    uint64_t v5 = v1;
  }
  else
  {
    *(unsigned char *)(v1 + 336) = 1;
    __dmb(0xBu);
    *(void *)(v1 + 216) = -1;
    *(_DWORD *)(v1 + 208) = 1;
    uint64_t v4 = *(void *)(v1 + 304);
    uint64_t v5 = v1;
    int v6 = 1;
  }

  return tbb::internal::market::adjust_demand(v4, v5, v6);
}

uint64_t tbb::internal::arena::is_out_of_work(tbb::internal::arena *this)
{
  uint64_t v1 = *((void *)this + 27);
  __dmb(0xBu);
  if (!v1) {
    return 1;
  }
  if (v1 != -1) {
    return 0;
  }
  uint64_t v39 = (uint64_t)&v39;
  while (1)
  {
    uint64_t v3 = -1;
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 27, (unint64_t *)&v3, (unint64_t)&v39);
    if (v3 == -1) {
      break;
    }
    if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 27, 0, memory_order_relaxed) != -1) {
      return 0;
    }
  }
  unint64_t v5 = *((unsigned int *)this + 36);
  __dmb(0xBu);
  uint64_t v6 = *((void *)this + 34);
  __dmb(0xBu);
  int64_t v7 = *((void *)this + 17);
  uint64_t v8 = 0;
  if (v5)
  {
    size_t v9 = (void *)((char *)this + 392);
    while (!*v9 || v9[1] >= v9[16])
    {
      uint64_t v10 = *((void *)this + 27);
      __dmb(0xBu);
      if (v10 != v39) {
        return 0;
      }
      ++v8;
      v9 += 32;
      if (v5 == v8) {
        goto LABEL_15;
      }
    }
  }
  if (v8 != v5)
  {
    uint64_t v21 = *((void *)this + 27);
    __dmb(0xBu);
    if (v21 == v39) {
      goto LABEL_63;
    }
    return 0;
  }
LABEL_15:
  BOOL v11 = *((void *)this + 35) != 0;
  uint64_t v12 = *((void *)this + 36);
  __dmb(0xBu);
LABEL_16:
  char v13 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
  int v14 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v13);
  unsigned int v15 = v14 | (1 << v13);
  while (1)
  {
    int v16 = v14;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v16, v15);
    if (v16 == v14) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v14)
    {
      sched_yield();
      goto LABEL_16;
    }
  }
  uint64_t v17 = *((void *)this + 48);
  if (v17 && *(tbb::internal::arena **)(v17 + 48) == this)
  {
    int v26 = *(unsigned char *)(v17 + 74) & 3;
    char v18 = v26 == 2;
    if (!*(unsigned char *)(v17 + 360))
    {
      if (!*(void *)(v17 + 336)) {
        goto LABEL_23;
      }
      if (*(void *)(v17 + 352) >= **(void **)(v17 + 104))
      {
        BOOL v11 = 1;
        goto LABEL_23;
      }
    }
    BOOL v20 = 0;
    char v18 = v26 == 2;
    __dmb(0xBu);
    LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
LABEL_39:
    BOOL v11 = 1;
    goto LABEL_41;
  }
  char v18 = 0;
LABEL_23:
  __dmb(0xBu);
  LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
  if (v5 >= 2)
  {
    unint64_t v22 = 1;
    uint64_t v23 = 640;
    do
    {
      uint64_t v24 = *((void *)this + 27);
      __dmb(0xBu);
      if (v24 != v39) {
        return 0;
      }
      uint64_t v25 = *(void *)((char *)this + v23);
      if (v25 && *(tbb::internal::arena **)(v25 + 48) == this)
      {
        v18 |= (*(unsigned char *)(v25 + 74) & 3) == 2;
        if (*(unsigned char *)(v25 + 360))
        {
          BOOL v20 = 0;
          goto LABEL_39;
        }
        if (*(void *)(v25 + 336))
        {
          BOOL v11 = 1;
          if (*(void *)(v25 + 352) < **(void **)(v25 + 104)) {
            goto LABEL_25;
          }
        }
      }
      ++v22;
      v23 += 256;
    }
    while (v22 < v5);
  }
  uint64_t v19 = *((void *)this + 35);
  __dmb(0xBu);
  if (v19)
  {
LABEL_25:
    BOOL v20 = 0;
  }
  else
  {
    uint64_t v27 = *((void *)this + 36);
    __dmb(0xBu);
    BOOL v20 = v12 == v27;
  }
LABEL_41:
  unint64_t v28 = *((void *)this + 27);
  __dmb(0xBu);
  if (v28 != v39) {
    return 0;
  }
  uint64_t v29 = *((void *)this + (int)v7 + 19);
  if (v18) {
    BOOL v30 = v29 == 0;
  }
  else {
    BOOL v30 = 1;
  }
  BOOL v31 = v30 && v20;
  if (!v31 || v7 != *((void *)this + 17) || v6 != *((void *)this + 34)) {
    goto LABEL_63;
  }
  if (v7 > *((void *)this + 33))
  {
    if (tbb::internal::market::lower_arena_priority(*((void *)this + 38), (uint64_t)this, v7 - 1, v6)
      && *((void *)this + (int)v7 + 19))
    {
LABEL_54:
      int64_t v32 = *((void *)this + 37);
      __dmb(0xBu);
      if (v32 < v7)
      {
        while (1)
        {
          int64_t v33 = v32;
          atomic_compare_exchange_strong((atomic_ullong *volatile)this + 37, (unint64_t *)&v33, v7);
          if (v33 == v32) {
            break;
          }
          if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 37, 0, memory_order_relaxed) != v32) {
            goto LABEL_54;
          }
        }
      }
    }
    goto LABEL_63;
  }
  if (v11 || *((void *)this + 35) || v29)
  {
LABEL_63:
    uint64_t v34 = v39;
    do
    {
      uint64_t v35 = v34;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 27, (unint64_t *)&v35, 0xFFFFFFFFFFFFFFFFLL);
    }
    while (v35 != v34
         && atomic_fetch_add_explicit((atomic_ullong *volatile)this + 27, 0, memory_order_relaxed) == v34);
    return 0;
  }
  int v36 = *((_DWORD *)this + 52);
  while (1)
  {
    unint64_t v37 = v28;
    atomic_compare_exchange_strong((atomic_ullong *volatile)this + 27, &v37, 0);
    if (v37 == v28) {
      break;
    }
    unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)this + 27, 0, memory_order_relaxed);
    if (add_explicit != v28)
    {
      unint64_t v28 = add_explicit;
      break;
    }
  }
  if (v28 != v39) {
    return 0;
  }
  tbb::internal::market::adjust_demand(*((void *)this + 38), (uint64_t)this, -v36);
  tbb::internal::arena::restore_priority_if_need(this);
  return 1;
}

uint64_t tbb::internal::arena::enqueue_task(void *a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  *(unsigned char *)(a2 - 12) = 2;
  *(unsigned char *)(a2 - 11) |= 0x10u;
  if (a3) {
    uint64_t v5 = ((int)a3 - 0x1FFFFFFF) / 0x1FFFFFFF;
  }
  else {
    uint64_t v5 = 1;
  }
  sub_21676DDF4(a1 + 19, a2, v5, a4);
  if (v5 != a1[17]) {
    tbb::internal::market::update_arena_priority(a1[38], (uint64_t)a1, v5);
  }
  uint64_t result = sub_21676D830((uint64_t)a1);
  if (v5 != a1[17])
  {
    uint64_t v7 = a1[38];
    return tbb::internal::market::update_arena_priority(v7, (uint64_t)a1, v5);
  }
  return result;
}

uint64_t *sub_21676DDF4(uint64_t *result, uint64_t a2, int a3, unsigned int *a4)
{
  uint64_t v5 = result;
  uint64_t v6 = a3;
  uint64_t v7 = &result[a3 + 3];
LABEL_2:
  unsigned int v8 = *a4;
  *a4 = a4[1] - 1640531535 * *a4;
  uint64_t v9 = (*((_DWORD *)v5 + 12) - 1) & HIWORD(v8);
  uint64_t v10 = *v7 + (v9 << 7) + 48;
  BOOL v11 = (atomic_uint *)(v10 & 0xFFFFFFFFFFFFFFFCLL);
  int v12 = 255 << (8 * (v10 & 3));
LABEL_3:
  int v13 = *v11 & ~v12;
  while (1)
  {
    int v14 = v13;
    atomic_compare_exchange_strong(v11, (unsigned int *)&v14, v13 | (1 << (8 * (v10 & 3))));
    if (v14 == v13) {
      break;
    }
    if (*v11 != v13)
    {
      if ((*v11 & v12) != 0) {
        goto LABEL_2;
      }
      uint64_t result = (uint64_t *)sched_yield();
      goto LABEL_3;
    }
  }
  unsigned int v15 = (void *)(*v7 + (v9 << 7));
  uint64_t v16 = v15[2];
  uint64_t v17 = v15[1];
  if (v16 == v17) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = ((v16 - v17) << 6) - 1;
  }
  uint64_t v19 = v15[5];
  unint64_t v20 = v19 + v15[4];
  if (v18 == v20)
  {
    uint64_t result = sub_2167700B0((uint64_t *)(*v7 + (v9 << 7)));
    uint64_t v17 = v15[1];
    uint64_t v19 = v15[5];
    unint64_t v20 = v15[4] + v19;
  }
  *(void *)(*(void *)(v17 + ((v20 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v20 & 0x1FF)) = a2;
  v15[5] = v19 + 1;
LABEL_14:
  uint64_t v21 = v5[v6];
  while (1)
  {
    uint64_t v22 = v21;
    atomic_compare_exchange_strong(&v5[v6], (unint64_t *)&v22, v21 | (1 << v9));
    if (v22 == v21) {
      break;
    }
    if (atomic_fetch_add_explicit(&v5[v6], 0, memory_order_relaxed) != v21)
    {
      uint64_t result = (uint64_t *)sched_yield();
      goto LABEL_14;
    }
  }
  __dmb(0xBu);
  *(unsigned char *)uint64_t v10 = 0;
  return result;
}

void sub_21676DF8C(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

void tbb::internal::generic_scheduler::nested_arena_entry(tbb::internal::generic_scheduler *this, tbb::internal::arena *a2, unint64_t a3)
{
  if (*((void *)this + 42))
  {
    uint64_t v5 = *((void *)this + 6);
    atomic_fetch_add((atomic_ullong *volatile)(v5 + 288), 1uLL);
    do
    {
      unint64_t v7 = *(void *)(v5 + 280);
      **((void **)this + 43) = v7;
      unint64_t v8 = *((void *)this + 42);
      while (1)
      {
        unint64_t v9 = v7;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v5 + 280), &v9, v8);
        if (v9 == v7) {
          break;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 280), 0, memory_order_relaxed);
        if (add_explicit != v7) {
          goto LABEL_4;
        }
      }
      unint64_t add_explicit = v7;
LABEL_4:
      ;
    }
    while (v7 != add_explicit);
  }
  *((void *)this + 42) = 0;
  *((void *)this + 4) = a3;
  *((void *)this + 5) = (char *)a2 + 256 * a3 + 384;
  *((void *)this + 6) = a2;
  uint64_t v10 = (char *)a2 - 128 * (unint64_t)(unsigned __int16)(a3 + 1);
  *((void *)this + 8) = v10;
  *((_WORD *)this + 36) = a3 + 1;
  if (a2 && v10[20]) {
    v10[20] = 0;
  }
  *((void *)this + 12) = (char *)a2 + 136;
  *((void *)this + 13) = (char *)a2 + 272;
  *((void *)this + 44) = *((void *)a2 + 34);
  tbb::internal::governor::assume_scheduler((uint64_t)this);
  uint64_t v11 = *((void *)this + 6);
  if ((*((unsigned char *)this + 74) & 1) != 0 && *(unsigned int *)(v11 + 332) <= a3)
  {
    tbb::internal::market::adjust_demand(*(void *)(v11 + 304), v11, -1);
    uint64_t v11 = *((void *)this + 6);
  }
  *((void *)this + 11) = 0;
  int v12 = (atomic_ullong *)((char *)this + 88);
  if (*(void *)(v11 + 232))
  {
    tbb::internal::observer_list::do_notify_entry_observers((atomic_ullong *)(v11 + 224), v12, 0);
  }
}

uint64_t tbb::internal::generic_scheduler::nested_arena_exit(tbb::internal::generic_scheduler *this)
{
  int v2 = (tbb::internal::observer_proxy *)*((void *)this + 11);
  if (v2) {
    tbb::internal::observer_list::do_notify_exit_observers((atomic_ullong *)(*((void *)this + 6) + 224), v2, 0);
  }
  if (*((void *)this + 42))
  {
    uint64_t v3 = *((void *)this + 6);
    atomic_fetch_add((atomic_ullong *volatile)(v3 + 288), 1uLL);
    do
    {
      unint64_t v5 = *(void *)(v3 + 280);
      **((void **)this + 43) = v5;
      unint64_t v6 = *((void *)this + 42);
      while (1)
      {
        unint64_t v7 = v5;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v3 + 280), &v7, v6);
        if (v7 == v5) {
          break;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 280), 0, memory_order_relaxed);
        if (add_explicit != v5) {
          goto LABEL_6;
        }
      }
      unint64_t add_explicit = v5;
LABEL_6:
      ;
    }
    while (v5 != add_explicit);
    *((void *)this + 42) = 0;
  }
  uint64_t v8 = *((void *)this + 6);
  unint64_t v9 = *((void *)this + 4);
  if ((*((unsigned char *)this + 74) & 1) != 0 && v9 >= *(unsigned int *)(v8 + 332))
  {
    tbb::internal::market::adjust_demand(*(void *)(v8 + 304), v8, 1);
    uint64_t v8 = *((void *)this + 6);
    unint64_t v9 = *((void *)this + 4);
  }
  __dmb(0xBu);
  *(void *)(v8 + (v9 << 8) + 384) = 0;
  uint64_t v10 = *((void *)this + 6) + 344;
  __dmb(0xBu);

  return tbb::internal::concurrent_monitor::notify_one_relaxed(v10);
}

void *tbb::internal::generic_scheduler::wait_until_empty(void *this)
{
  uint64_t v1 = this;
  ++*(void *)(this[18] - 24);
  for (uint64_t i = this[6]; ; uint64_t i = v1[6])
  {
    uint64_t v3 = *(void *)(i + 216);
    __dmb(0xBu);
    if (!v3) {
      break;
    }
    this = (void *)(*(uint64_t (**)(void *, void, void))(*v1 + 48))(v1, v1[18], 0);
  }
  --*(void *)(v1[18] - 24);
  return this;
}

void *tbb::interface7::internal::task_arena_base::internal_initialize(tbb::interface7::internal::task_arena_base *this)
{
  tbb::internal::governor::one_time_init((uint64_t)this);
  uint64_t v4 = *((unsigned int *)this + 4);
  if ((int)v4 <= 0)
  {
    if (*((unsigned char *)this + 24)) {
      uint64_t v5 = *((unsigned int *)this + 9);
    }
    else {
      uint64_t v5 = 0xFFFFFFFFLL;
    }
    uint64_t v4 = tbb::internal::numa_topology::default_concurrency((tbb::internal::numa_topology *)v5);
    *((_DWORD *)this + 4) = v4;
  }
  arena = tbb::internal::market::create_arena((tbb::internal::market *)v4, *((_DWORD *)this + 5), 0, v2, v3);
  unint64_t v9 = tbb::internal::market::global_market(0, 0, 0, v7, v8);
  uint64_t v11 = tbb::internal::NFS_Allocate(1uLL, 256, 0, v10);
  *(_DWORD *)uint64_t v11 = 0;
  *(void *)(v11 + 128) = 65539;
  *(_DWORD *)(v11 + 168) = 55;
  tbb::task_group_context::init(v11, v12, v13, v14);
  *((void *)arena + 40) = v11;
  uint64_t v18 = (tbb::internal::numa_topology *)tbb::task_group_context::capture_fp_settings((tbb::task_group_context *)v11, v15, v16, v17);
  while (1)
  {
    uint64_t v19 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)this, (unint64_t *)&v19, (unint64_t)arena);
    if (!v19) {
      break;
    }
    if (atomic_fetch_add_explicit((atomic_ullong *volatile)this, 0, memory_order_relaxed))
    {
      tbb::internal::market::release((tbb::internal::market *)v9, 1, 0);
      uint64_t v21 = *((void *)arena + 38);
      uint64_t v20 = *((void *)arena + 39);
      if (*((_DWORD *)arena + 82) != *((_DWORD *)arena + 83)
        && !*(_DWORD *)(v21 + 28)
        && !*((unsigned char *)arena + 337)
        && (tbb::internal::arena::is_out_of_work(arena) & 1) == 0
        && (tbb::internal::arena::is_out_of_work(arena) & 1) == 0)
      {
        tbb::internal::arena::is_out_of_work(arena);
      }
      if (atomic_fetch_add((atomic_uint *volatile)arena + 33, 0xFFFFFFFF) == 1) {
        tbb::internal::market::try_destroy_arena((atomic_ullong *)v21, (atomic_ullong *)arena, v20);
      }
      while (!*((void *)this + 1))
        sched_yield();
      goto LABEL_28;
    }
  }
  if ((*((unsigned char *)this + 24) & 1) == 0
    || (int v22 = *((_DWORD *)this + 9), v22 < 0)
    || (uint64_t v23 = (tbb::internal *)*(unsigned int *)(*(void *)this + 328),
        tbb::internal::numa_topology::nodes_count(v18) < 2))
  {
    uint64_t v24 = 0;
  }
  else
  {
    uint64_t v24 = (tbb::internal::task_scheduler_observer_v3 *)operator new(0x30uLL);
    sub_21676CC94((uint64_t)v24, (uint64_t)this, v22, v23);
    if (!*((void *)v24 + 1)) {
      *((void *)v24 + 2) = 0x8000000000000000;
    }
    tbb::internal::task_scheduler_observer_v3::observe(v24, 1);
  }
  *(void *)(*(void *)this + 256) = v24;
  uint64_t v25 = *((void *)arena + 40);
  *(void *)(v25 + 128) |= *((void *)this + 3) & 0x10000;
  __dmb(0xBu);
  *((void *)this + 1) = v25;
LABEL_28:
  uint64_t result = pthread_getspecific(tbb::internal::governor::theTLS);
  if (!result)
  {
    return (void *)tbb::internal::governor::init_scheduler_weak(0);
  }
  return result;
}

void sub_21676E468(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t tbb::interface7::internal::task_arena_base::internal_terminate(uint64_t this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    uint64_t v2 = this;
    uint64_t v3 = *(void *)(v1 + 256);
    if (v3)
    {
      tbb::internal::task_scheduler_observer_v3::observe(*(tbb::internal::task_scheduler_observer_v3 **)(v1 + 256), 0);
      (*(void (**)(uint64_t))(*(void *)v3 + 24))(v3);
      uint64_t v1 = *(void *)v2;
      *(void *)(*(void *)v2 + 256) = 0;
    }
    this = tbb::internal::market::release(*(tbb::internal::market **)(v1 + 304), 1, 0);
    uint64_t v4 = *(void *)v2;
    uint64_t v6 = *(void *)(*(void *)v2 + 304);
    uint64_t v5 = *(void *)(*(void *)v2 + 312);
    if (*(_DWORD *)(*(void *)v2 + 328) != *(_DWORD *)(*(void *)v2 + 332)
      && !*(_DWORD *)(v6 + 28)
      && !*(unsigned char *)(v4 + 337))
    {
      this = tbb::internal::arena::is_out_of_work(*(tbb::internal::arena **)v2);
      if ((this & 1) == 0)
      {
        this = tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4);
        if ((this & 1) == 0) {
          this = tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4);
        }
      }
    }
    if (atomic_fetch_add((atomic_uint *volatile)(v4 + 132), 0xFFFFFFFF) == 1) {
      this = tbb::internal::market::try_destroy_arena((atomic_ullong *)v6, (atomic_ullong *)v4, v5);
    }
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
  }
  return this;
}

int64x2_t *tbb::interface7::internal::task_arena_base::internal_attach(tbb::interface7::internal::task_arena_base *this)
{
  uint64_t result = (int64x2_t *)pthread_getspecific(tbb::internal::governor::theTLS);
  if (((unint64_t)result & 0xFFFFFFFFFFFFFFFELL) != 0)
  {
    uint64_t v5 = *(void *)(((unint64_t)result & 0xFFFFFFFFFFFFFFFELL) + 48);
    if (v5)
    {
      *(void *)this = v5;
      atomic_fetch_add((atomic_uint *volatile)(v5 + 132), 1u);
      uint64_t v6 = *(void *)this;
      uint64_t v7 = *(void *)(*(void *)this + 320);
      *((void *)this + 1) = v7;
      *((void *)this + 3) |= *(void *)(v7 + 128) & 0x10000;
      LODWORD(v7) = *(_DWORD *)(v6 + 332);
      *((_DWORD *)this + 4) = *(_DWORD *)(v6 + 208) + v7;
      *((_DWORD *)this + 5) = v7;
      return tbb::internal::market::global_market(1, 0, 0, v3, v4);
    }
  }
  return result;
}

uint64_t tbb::interface7::internal::task_arena_base::internal_enqueue(tbb::interface7::internal::task_arena_base *this, tbb::task *a2, uint64_t a3)
{
  unint64_t v6 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v6) {
    unint64_t inited = v6 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t inited = tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t v8 = *(void **)this;
  *((unsigned char *)a2 - 12) = 2;
  *((unsigned char *)a2 - 11) |= 0x10u;
  if (a3) {
    uint64_t v9 = ((int)a3 - 0x1FFFFFFF) / 0x1FFFFFFF;
  }
  else {
    uint64_t v9 = 1;
  }
  sub_21676DDF4(v8 + 19, (uint64_t)a2, v9, (unsigned int *)(inited + 128));
  if (v9 != v8[17]) {
    tbb::internal::market::update_arena_priority(v8[38], (uint64_t)v8, v9);
  }
  uint64_t result = sub_21676D830((uint64_t)v8);
  if (v9 != v8[17])
  {
    uint64_t v11 = v8[38];
    return tbb::internal::market::update_arena_priority(v11, (uint64_t)v8, v9);
  }
  return result;
}

void tbb::interface7::internal::task_arena_base::internal_execute(tbb::interface7::internal::task_arena_base *a1, void (***a2)(void))
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  unint64_t v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4) {
    uint64_t inited = v4 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    uint64_t inited = tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t v10 = (long long *)(inited + 32);
  unint64_t v9 = *(void *)(inited + 32);
  uint64_t v11 = *(unsigned int **)(inited + 48);
  uint64_t v12 = *(unsigned int **)a1;
  if (v11 != *(unsigned int **)a1 && (unint64_t v9 = sub_21676EEBC(*(unsigned int **)a1, inited), v9 == -1))
  {
    unint64_t v28 = __dynamic_cast(a2, (const struct __class_type_info *)&unk_26C746B28, (const struct __class_type_info *)&unk_26C746B50, 0);
    if (v28)
    {
      int64_t v32 = v28;
      v74 = (tbb::task_group_context *)*((void *)a1 + 1);
      int64_t v33 = (void *)tbb::internal::allocate_root_with_context_proxy::allocate(&v74, 0x10uLL);
      uint64_t v34 = (void *)v32[1];
      *((unsigned char *)v33 - 11) = 1;
      *int64_t v33 = &unk_26C746D20;
      v33[1] = *v34;
      tbb::interface7::internal::task_arena_base::internal_enqueue(a1, (tbb::task *)v33, 0);
    }
    else
    {
      v67[0] = 3452816845;
      v67[1] = 3452816845;
      __int16 v71 = 0;
      char v72 = 0;
      uint64_t v73 = 0;
      int v69 = 0;
      __dmb(0xBu);
      char v70 = 0;
      uint64_t v35 = *((void *)a1 + 3) & 0x10000;
      LODWORD(v74) = 0;
      uint64_t v82 = v35 | 3;
      int v84 = 55;
      tbb::task_group_context::init((uint64_t)&v74, v29, v30, v31);
      tbb::task_group_context::copy_fp_settings((tbb::task_group_context *)&v74, *((const tbb::task_group_context **)a1 + 1), v36, v37);
      uint64_t task = (void *)tbb::internal::generic_scheduler::allocate_task((tbb::internal::generic_scheduler *)inited, 8uLL, 0, (tbb::task_group_context *)&v74);
      *((unsigned char *)task - 11) = 1;
      *uint64_t task = &unk_26C746C48;
      *(task - 3) = 2;
      uint64_t v39 = *(unsigned int **)a1;
      v59.__ptr_ = &v74;
      uint64_t v40 = (void *)tbb::internal::allocate_root_with_context_proxy::allocate((tbb::task_group_context **)&v59, 0x20uLL);
      uint64_t v41 = *(void *)a1 + 344;
      *uint64_t v40 = &unk_26C746C90;
      v40[1] = a2;
      v40[2] = v41;
      v40[3] = task;
      *((_WORD *)v40 - 6) = 4354;
      sub_21676DDF4((uint64_t *)v39 + 19, (uint64_t)v40, 1, (unsigned int *)(inited + 128));
      if (*((void *)v39 + 17) != 1) {
        tbb::internal::market::update_arena_priority(*((void *)v39 + 38), (uint64_t)v39, 1);
      }
      sub_21676D830((uint64_t)v39);
      if (*((void *)v39 + 17) != 1) {
        tbb::internal::market::update_arena_priority(*((void *)v39 + 38), (uint64_t)v39, 1);
      }
      while (1)
      {
        tbb::internal::concurrent_monitor::prepare_wait(*(void *)a1 + 344, (tbb::internal::concurrent_monitor::thread_context *)v67, (uint64_t)a2);
        uint64_t v43 = *(task - 3);
        __dmb(0xBu);
        int v44 = *(unsigned int **)a1;
        if (v43 <= 1)
        {
          tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v44 + 86), (tbb::internal::concurrent_monitor::thread_context *)v67);
LABEL_36:
          uint64_t v47 = *(void *)a1 + 344;
          __dmb(0xBu);
          atomic_ullong v48 = (tbb::internal *)tbb::internal::concurrent_monitor::notify_one_relaxed(v47);
          goto LABEL_38;
        }
        unint64_t v45 = sub_21676EEBC(v44, inited);
        int v46 = *(unsigned int **)a1;
        if (v45 != -1) {
          break;
        }
        if (v69 == v46[94])
        {
          while (MEMORY[0x21D448B00](semaphore) == 14)
            ;
          if (HIBYTE(v71)) {
            tbb::internal::throw_exception_v4(18);
          }
        }
        else
        {
          tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v46 + 86), (tbb::internal::concurrent_monitor::thread_context *)v67);
        }
        uint64_t v42 = *(task - 3);
        __dmb(0xBu);
        if (v42 != 2) {
          goto LABEL_36;
        }
      }
      tbb::internal::concurrent_monitor::cancel_wait((uint64_t)(v46 + 86), (tbb::internal::concurrent_monitor::thread_context *)v67);
      unint64_t v49 = *(tbb::internal::arena **)a1;
      v59.__ptr_ = (void *)inited;
      char v66 = 0;
      long long v50 = *(_OWORD *)(inited + 48);
      long long v51 = *(_OWORD *)(inited + 64);
      long long v52 = *(_OWORD *)(inited + 96);
      long long v63 = *(_OWORD *)(inited + 80);
      long long v64 = v52;
      long long v61 = v50;
      long long v62 = v51;
      long long v60 = *v10;
      *(unsigned char *)(inited + 74) |= 3u;
      uint64_t v53 = *(void *)(inited + 144);
      *(void *)(inited + 56) = v53;
      uint64_t v65 = *(void *)(v53 - 56);
      uint64_t v54 = v65;
      *(void *)(v53 - 56) = *((void *)v49 + 40);
      tbb::internal::generic_scheduler::nested_arena_entry((tbb::internal::generic_scheduler *)inited, v49, v45);
      (*(void (**)(uint64_t, void *, void))(*(void *)inited + 48))(inited, task, 0);
      *(void *)(*(void *)(inited + 144) - 56) = v54;
      tbb::internal::generic_scheduler::nested_arena_exit((tbb::internal::generic_scheduler *)inited);
      *uint64_t v10 = v60;
      long long v55 = v64;
      *(_OWORD *)(inited + 80) = v63;
      *(_OWORD *)(inited + 96) = v55;
      long long v56 = v62;
      *(_OWORD *)(inited + 48) = v61;
      *(_OWORD *)(inited + 64) = v56;
      *(void *)(inited + 352) = **((void **)&v64 + 1);
      atomic_ullong v48 = (tbb::internal *)tbb::internal::governor::assume_scheduler(inited);
LABEL_38:
      v57 = v83;
      if (v83)
      {
        if (tbb::internal::governor::is_rethrow_broken) {
          tbb::internal::fix_broken_rethrow(v48);
        }
        std::exception_ptr::exception_ptr(&v59, v57);
        v58.__ptr_ = &v59;
        std::rethrow_exception(v58);
        __break(1u);
      }
      else
      {
        *((unsigned char *)task - 12) = 4;
        *(task - 1) = *(void *)(inited + 136);
        *(void *)(inited + 136) = task;
        tbb::task_group_context::~task_group_context((tbb::task_group_context *)&v74);
        if (v72)
        {
          if ((_BYTE)v71)
          {
            while (MEMORY[0x21D448B00](semaphore) == 14)
              ;
          }
          semaphore_destroy(*MEMORY[0x263EF8960], semaphore);
        }
      }
    }
  }
  else
  {
    sub_21676F178(&v59, v5, v6, v7);
    uint64_t v14 = *((void *)a1 + 1);
    uint64_t v15 = *(void *)(v14 + 112);
    uint64_t v16 = (_OWORD *)*((void *)&v60 + 1);
    if (*(void *)v15 != **((void **)&v60 + 1) || *(void *)(v15 + 8) != *(void *)(*((void *)&v60 + 1) + 8))
    {
      if (!*((void *)&v60 + 1))
      {
        uint64_t v16 = (_OWORD *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v13);
        *((void *)&v60 + 1) = v16;
        uint64_t v15 = *(void *)(v14 + 112);
      }
      *uint64_t v16 = *(_OWORD *)v15;
      fesetenv(*((const fenv_t **)&v60 + 1));
    }
    uint64_t v18 = *(tbb::internal::arena **)a1;
    v74 = (tbb::task_group_context *)inited;
    *(void *)&long long v77 = 0;
    BOOL v81 = v11 == v12;
    if (v11 == v12)
    {
      BYTE10(v77) = *(unsigned char *)(inited + 74);
      *((void *)&v76 + 1) = *(void *)(inited + 56);
      *(unsigned char *)(inited + 74) = BYTE10(v77) | 3;
      uint64_t v24 = *(void *)(inited + 144);
      *(void *)(inited + 56) = v24;
      uint64_t v23 = *(void *)(v24 - 56);
      uint64_t v80 = v23;
      *(void *)(v24 - 56) = *((void *)v18 + 40);
    }
    else
    {
      long long v20 = *(_OWORD *)(inited + 48);
      long long v19 = *(_OWORD *)(inited + 64);
      long long v21 = *(_OWORD *)(inited + 96);
      long long v78 = *(_OWORD *)(inited + 80);
      long long v79 = v21;
      long long v76 = v20;
      long long v77 = v19;
      long long v75 = *v10;
      *(unsigned char *)(inited + 74) |= 3u;
      uint64_t v22 = *(void *)(inited + 144);
      *(void *)(inited + 56) = v22;
      uint64_t v23 = *(void *)(v22 - 56);
      uint64_t v80 = v23;
      *(void *)(v22 - 56) = *((void *)v18 + 40);
      tbb::internal::generic_scheduler::nested_arena_entry((tbb::internal::generic_scheduler *)inited, v18, v9);
    }
    (**a2)(a2);
    *(void *)(*(void *)(inited + 144) - 56) = v23;
    if (v11 == v12)
    {
      *(unsigned char *)(inited + 74) = BYTE10(v77);
      *(void *)(inited + 56) = *((void *)&v76 + 1);
    }
    else
    {
      tbb::internal::generic_scheduler::nested_arena_exit((tbb::internal::generic_scheduler *)inited);
      *uint64_t v10 = v75;
      long long v26 = v79;
      *(_OWORD *)(inited + 80) = v78;
      *(_OWORD *)(inited + 96) = v26;
      long long v27 = v77;
      *(_OWORD *)(inited + 48) = v76;
      *(_OWORD *)(inited + 64) = v27;
      *(void *)(inited + 352) = **((void **)&v79 + 1);
      tbb::internal::governor::assume_scheduler(inited);
    }
    sub_216770B7C((uint64_t)&v59, v25);
  }
}

void sub_21676EE28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  __cxa_end_catch();
  sub_216770B7C((uint64_t)va, v3);
  _Unwind_Resume(a1);
}

void sub_21676EE64(_Unwind_Exception *exception_object)
{
}

void sub_21676EE70(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_21675DB74(exception_object);
}

void sub_21676EE88(_Unwind_Exception *a1)
{
  *(unsigned char *)(v2 - 12) = 4;
  *(void *)(v2 - 8) = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = v2;
  tbb::task_group_context::~task_group_context((tbb::task_group_context *)&v5);
  sub_21675E55C(&v4);
  _Unwind_Resume(a1);
}

uint64_t sub_21676EEBC(unsigned int *a1, unint64_t a2)
{
  unint64_t v2 = a1[83];
  if (v2)
  {
    unint64_t v3 = *(void *)(a2 + 32);
    if (v3 >= v2)
    {
      unsigned int v4 = *(_DWORD *)(a2 + 128);
      *(_DWORD *)(a2 + 128) = *(_DWORD *)(a2 + 132) - 1640531535 * v4;
      unint64_t v3 = HIWORD(v4) % v2;
    }
    uint64_t v5 = v3;
    do
    {
      uint64_t v6 = &a1[64 * v5];
      if (!*((void *)v6 + 48))
      {
        uint64_t v7 = (atomic_ullong *)(v6 + 96);
        do
        {
          uint64_t v8 = 0;
          atomic_compare_exchange_strong(v7, (unint64_t *)&v8, a2);
          if (!v8) {
            goto LABEL_19;
          }
        }
        while (!atomic_fetch_add_explicit(v7, 0, memory_order_relaxed));
      }
      ++v5;
    }
    while (v5 != v2);
    if (!v3) {
      goto LABEL_20;
    }
    uint64_t v5 = 0;
    while (1)
    {
      unint64_t v9 = &a1[64 * v5];
      if (!*((void *)v9 + 48)) {
        break;
      }
LABEL_13:
      if (++v5 == v3) {
        goto LABEL_20;
      }
    }
    uint64_t v10 = (atomic_ullong *)(v9 + 96);
    while (1)
    {
      uint64_t v11 = 0;
      atomic_compare_exchange_strong(v10, (unint64_t *)&v11, a2);
      if (!v11) {
        break;
      }
      if (atomic_fetch_add_explicit(v10, 0, memory_order_relaxed)) {
        goto LABEL_13;
      }
    }
LABEL_19:
    if (v5 != -1) {
      goto LABEL_45;
    }
  }
LABEL_20:
  unint64_t v12 = a1[83];
  unint64_t v13 = a1[82];
  if (v12 >= v13) {
    return -1;
  }
  unint64_t v14 = *(void *)(a2 + 32);
  if (v14 < v12 || v14 >= v13)
  {
    unint64_t v16 = *(unsigned int *)(a2 + 128);
    *(_DWORD *)(a2 + 128) = *(_DWORD *)(a2 + 132) - 1640531535 * v16;
    unint64_t v14 = (v16 >> 16) % (v13 - v12) + v12;
  }
  if (v14 >= v13)
  {
LABEL_35:
    if (v14 > v12)
    {
      while (1)
      {
        long long v21 = &a1[64 * v12];
        if (!*((void *)v21 + 48)) {
          break;
        }
LABEL_37:
        ++v12;
        uint64_t v5 = -1;
        if (v12 == v14) {
          return v5;
        }
      }
      uint64_t v22 = (atomic_ullong *)(v21 + 96);
      while (1)
      {
        uint64_t v23 = 0;
        atomic_compare_exchange_strong(v22, (unint64_t *)&v23, a2);
        if (!v23) {
          break;
        }
        if (atomic_fetch_add_explicit(v22, 0, memory_order_relaxed)) {
          goto LABEL_37;
        }
      }
      uint64_t v5 = v12;
      goto LABEL_44;
    }
    return -1;
  }
  uint64_t v5 = v14;
  while (1)
  {
    uint64_t v17 = &a1[64 * v5];
    if (!*((void *)v17 + 48)) {
      break;
    }
LABEL_29:
    if (++v5 == v13) {
      goto LABEL_35;
    }
  }
  uint64_t v18 = (atomic_ullong *)(v17 + 96);
  while (1)
  {
    uint64_t v19 = 0;
    atomic_compare_exchange_strong(v18, (unint64_t *)&v19, a2);
    if (!v19) {
      break;
    }
    if (atomic_fetch_add_explicit(v18, 0, memory_order_relaxed)) {
      goto LABEL_29;
    }
  }
LABEL_44:
  if (v5 != -1)
  {
LABEL_45:
    unsigned int v24 = v5 + 1;
LABEL_46:
    unsigned int v25 = a1[36];
    __dmb(0xBu);
    if (v25 < v24)
    {
      while (1)
      {
        unsigned int v26 = v25;
        atomic_compare_exchange_strong((atomic_uint *volatile)a1 + 36, &v26, v24);
        if (v26 == v25) {
          break;
        }
        if (a1[36] != v25) {
          goto LABEL_46;
        }
      }
    }
  }
  return v5;
}

uint64_t *sub_21676F0A4(uint64_t *a1)
{
  uint64_t v2 = a1[11];
  uint64_t v3 = *a1;
  *(void *)(*(void *)(v3 + 144) - 56) = v2;
  if (*((unsigned char *)a1 + 96))
  {
    *(unsigned char *)(v3 + 74) = *((unsigned char *)a1 + 50);
    *(void *)(*a1 + 56) = a1[4];
  }
  else
  {
    tbb::internal::generic_scheduler::nested_arena_exit((tbb::internal::generic_scheduler *)v3);
    unsigned int v4 = (_OWORD *)*a1;
    int v4[2] = *(_OWORD *)(a1 + 1);
    long long v5 = *(_OWORD *)(a1 + 3);
    long long v6 = *(_OWORD *)(a1 + 5);
    long long v7 = *(_OWORD *)(a1 + 9);
    v4[5] = *(_OWORD *)(a1 + 7);
    v4[6] = v7;
    v4[3] = v5;
    v4[4] = v6;
    uint64_t v8 = *a1;
    *(void *)(v8 + 352) = *(void *)a1[10];
    tbb::internal::governor::assume_scheduler(v8);
  }
  return a1;
}

void sub_21676F138(std::exception_ptr *a1)
{
  std::exception_ptr::exception_ptr(&v2, a1);
  v1.__ptr_ = &v2;
  std::rethrow_exception(v1);
  __break(1u);
}

void sub_21676F164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::exception_ptr a10)
{
}

void *sub_21676F178(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  long long v5 = (fenv_t *)tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
  a1[1] = v5;
  fegetenv(v5);
  long long v7 = (_OWORD *)a1[2];
  if (!v7)
  {
    long long v7 = (_OWORD *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v6);
    a1[2] = v7;
  }
  *long long v7 = *(_OWORD *)a1[1];
  return a1;
}

void sub_21676F1E4(_Unwind_Exception *exception_object, void *a2)
{
  unsigned int v4 = *(tbb::internal **)(v2 + 16);
  if (v4) {
    tbb::internal::NFS_Free(v4, a2);
  }
  long long v5 = *(tbb::internal **)(v2 + 8);
  if (v5) {
    tbb::internal::NFS_Free(v5, a2);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_21676F210(uint64_t a1)
{
  uint64_t v4 = a1 + 8;
  uint64_t v2 = *(const fenv_t **)(a1 + 8);
  uint64_t v3 = *(uint64_t **)(v4 + 8);
  uint64_t v6 = *v3;
  uint64_t v5 = v3[1];
  if (v6 != v2->__fpsr || v5 != v2->__fpcr)
  {
    fesetenv(v2);
    unint64_t v9 = *(_OWORD **)(a1 + 16);
    if (!v9)
    {
      unint64_t v9 = (_OWORD *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v8);
      *(void *)(a1 + 16) = v9;
    }
    uint64_t v10 = *(__n128 **)(a1 + 8);
    __n128 result = *v10;
    *unint64_t v9 = *v10;
  }
  return result;
}

void tbb::interface7::internal::task_arena_base::internal_wait(tbb::internal::generic_scheduler **this)
{
  unint64_t v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v2) {
    uint64_t inited = (tbb::internal::generic_scheduler *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t v4 = (unsigned int *)*((void *)inited + 6);
  uint64_t v5 = *this;
  if (v4 == (unsigned int *)*this)
  {
    if (!*((void *)inited + 4))
    {
      for (unsigned int i = v4[33]; ; unsigned int i = *((_DWORD *)*this + 33))
      {
        __dmb(0xBu);
        if (i < 0x1000) {
          break;
        }
        ++*(void *)(*((void *)inited + 18) - 24);
        while (1)
        {
          uint64_t v23 = *(void *)(*((void *)inited + 6) + 216);
          __dmb(0xBu);
          if (!v23) {
            break;
          }
          (*(void (**)(tbb::internal::generic_scheduler *, void, void))(*(void *)inited + 48))(inited, *((void *)inited + 18), 0);
        }
        --*(void *)(*((void *)inited + 18) - 24);
      }
    }
  }
  else
  {
    uint64_t v6 = (task_t *)MEMORY[0x263EF8960];
    while (1)
    {
      while (1)
      {
        uint64_t v8 = *((void *)v5 + 27);
        __dmb(0xBu);
        if (!v8) {
          break;
        }
        uint64_t v9 = *((void *)*this + 48);
        __dmb(0xBu);
        if (v9)
        {
LABEL_14:
          semaphore_t semaphore = 0;
          semaphore_create(*v6, &semaphore, 0, 0);
          unsigned int v25 = this[1];
          unint64_t v12 = (void *)tbb::internal::allocate_root_with_context_proxy::allocate(&v25, 0x10uLL);
          *((unsigned char *)v12 - 11) = 1;
          *unint64_t v12 = &unk_26C746CD8;
          v12[1] = &semaphore;
          tbb::interface7::internal::task_arena_base::internal_enqueue((tbb::interface7::internal::task_arena_base *)this, (tbb::task *)v12, 0);
          while (MEMORY[0x21D448B00](semaphore) == 14)
            ;
          semaphore_destroy(*v6, semaphore);
        }
        else
        {
          uint64_t v10 = *this;
          while (1)
          {
            uint64_t v11 = 0;
            atomic_compare_exchange_strong((atomic_ullong *volatile)v10 + 48, (unint64_t *)&v11, (unint64_t)inited);
            if (!v11) {
              break;
            }
            if (atomic_fetch_add_explicit((atomic_ullong *volatile)v10 + 48, 0, memory_order_relaxed)) {
              goto LABEL_14;
            }
          }
          unint64_t v13 = *this;
          unsigned int v25 = inited;
          char v32 = 0;
          long long v14 = *((_OWORD *)inited + 3);
          long long v15 = *((_OWORD *)inited + 4);
          long long v16 = *((_OWORD *)inited + 6);
          long long v29 = *((_OWORD *)inited + 5);
          long long v30 = v16;
          long long v27 = v14;
          long long v28 = v15;
          long long v26 = *((_OWORD *)inited + 2);
          *((unsigned char *)inited + 74) = *((unsigned char *)inited + 74) & 0xFC | 2;
          uint64_t v17 = *((void *)inited + 18);
          *((void *)inited + 7) = v17;
          uint64_t v31 = *(void *)(v17 - 56);
          *(void *)(v17 - 56) = *((void *)v13 + 40);
          tbb::internal::generic_scheduler::nested_arena_entry(inited, v13, 0);
          ++*(void *)(*((void *)inited + 18) - 24);
          while (1)
          {
            uint64_t v18 = *(void *)(*((void *)inited + 6) + 216);
            __dmb(0xBu);
            if (!v18) {
              break;
            }
            (*(void (**)(tbb::internal::generic_scheduler *, void, void))(*(void *)inited + 48))(inited, *((void *)inited + 18), 0);
          }
          --*(void *)(*((void *)inited + 18) - 24);
          long long v7 = v25;
          *(void *)(*((void *)v25 + 18) - 56) = v31;
          if (v32)
          {
            *((unsigned char *)v7 + 74) = BYTE10(v28);
            *((void *)v7 + 7) = *((void *)&v27 + 1);
          }
          else
          {
            tbb::internal::generic_scheduler::nested_arena_exit(v7);
            *((_OWORD *)v7 + 2) = v26;
            long long v19 = v30;
            *((_OWORD *)v7 + 5) = v29;
            *((_OWORD *)v7 + 6) = v19;
            long long v20 = v28;
            *((_OWORD *)v7 + 3) = v27;
            *((_OWORD *)v7 + 4) = v20;
            *((void *)v7 + 44) = **((void **)&v30 + 1);
            tbb::internal::governor::assume_scheduler((uint64_t)v7);
          }
        }
        uint64_t v5 = *this;
      }
      unsigned int v21 = *((_DWORD *)*this + 33);
      __dmb(0xBu);
      if (v21 <= 0xFFF && !*((void *)*this + 48)) {
        break;
      }
      sched_yield();
      uint64_t v5 = *this;
    }
  }
}

void sub_21676F59C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, semaphore_t a10)
{
}

semaphore_t *sub_21676F5C8(semaphore_t *a1)
{
  return a1;
}

uint64_t tbb::interface7::internal::task_arena_base::internal_current_slot(tbb::interface7::internal::task_arena_base *this)
{
  unint64_t v1 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v1 & 0xFFFFFFFFFFFFFFFELL) != 0) {
    return *(unsigned int *)((v1 & 0xFFFFFFFFFFFFFFFELL) + 32);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t tbb::interface7::internal::isolate_within_arena(uint64_t (***a1)(void), uint64_t (***a2)(void))
{
  unint64_t v4 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v4) {
    unint64_t inited = v4 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t inited = tbb::internal::governor::init_scheduler_weak(0);
  }
  uint64_t v6 = *(void *)(inited + 56);
  uint64_t v7 = *(void *)(v6 - 64);
  if (a2) {
    uint64_t v8 = a2;
  }
  else {
    uint64_t v8 = a1;
  }
  *(void *)(v6 - 64) = v8;
  uint64_t result = (**a1)(a1);
  *(void *)(v6 - 64) = v7;
  return result;
}

void sub_21676F6CC(_Unwind_Exception *a1)
{
  *(void *)(v1 - 64) = v2;
  _Unwind_Resume(a1);
}

uint64_t tbb::interface7::internal::task_arena_base::internal_max_concurrency(uint64_t *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v1 = *a1;
    if (!*a1) {
      goto LABEL_7;
    }
    return (*(_DWORD *)(v1 + 208) + *(_DWORD *)(v1 + 332));
  }
  unint64_t v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS) & 0xFFFFFFFFFFFFFFFELL;
  if (v2)
  {
    uint64_t v1 = *(void *)(v2 + 48);
    if (v1) {
      return (*(_DWORD *)(v1 + 208) + *(_DWORD *)(v1 + 332));
    }
  }
LABEL_7:
  uint64_t result = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(void *)uint64_t v6 = 0x1900000006;
    int v5 = 0;
    size_t v4 = 4;
    sysctl(v6, 2u, &v5, &v4, 0, 0);
    if (v5 <= 1) {
      uint64_t result = 1;
    }
    else {
      uint64_t result = v5;
    }
    tbb::internal::governor::DefaultNumberOfThreads = result;
  }
  return result;
}

uint64_t sub_21676F7BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  unint64_t v3 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v3 & 0xFFFFFFFFFFFFFFFELL) != 0) {
    unsigned int v4 = *(_DWORD *)((v3 & 0xFFFFFFFFFFFFFFFELL) + 32);
  }
  else {
    unsigned int v4 = -1;
  }
  if (v4 >= 0xFFFFFFFE) {
    uint64_t v5 = 4294967294;
  }
  else {
    uint64_t v5 = v4;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 32);

  return tbb::internal::bind_thread_to_node(v2, v5, v6);
}

uint64_t sub_21676F828(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  unint64_t v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if ((v2 & 0xFFFFFFFFFFFFFFFELL) != 0) {
    unsigned int v3 = *(_DWORD *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 32);
  }
  else {
    unsigned int v3 = -1;
  }
  if (v3 >= 0xFFFFFFFE) {
    uint64_t v4 = 4294967294;
  }
  else {
    uint64_t v4 = v3;
  }

  return tbb::internal::restore_affinity_mask(v1, v4);
}

void sub_21676F890(tbb::internal::task_scheduler_observer_v3 *a1)
{
  uint64_t v1 = sub_21676FAC0(a1);

  operator delete(v1);
}

tbb::internal::task_scheduler_observer_v3 *sub_21676F8B8(tbb::internal::task_scheduler_observer_v3 *a1)
{
  *(void *)a1 = &unk_26C746BE8;
  if (*((void *)a1 + 1))
  {
    tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
    uint64_t v2 = *((void *)a1 + 1);
    *(void *)a1 = &unk_26C746C18;
    if (v2) {
      tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
    }
  }
  else
  {
    *(void *)a1 = &unk_26C746C18;
  }
  return a1;
}

void sub_21676F964(tbb::internal::task_scheduler_observer_v3 *__p)
{
  *(void *)__p = &unk_26C746BE8;
  if (*((void *)__p + 1))
  {
    tbb::internal::task_scheduler_observer_v3::observe(__p, 0);
    uint64_t v2 = *((void *)__p + 1);
    *(void *)__p = &unk_26C746C18;
    if (v2) {
      tbb::internal::task_scheduler_observer_v3::observe(__p, 0);
    }
  }

  operator delete(__p);
}

tbb::internal::task_scheduler_observer_v3 *sub_21676FA00(tbb::internal::task_scheduler_observer_v3 *a1)
{
  *(void *)a1 = &unk_26C746C18;
  if (*((void *)a1 + 1)) {
    tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
  }
  return a1;
}

void sub_21676FA58(tbb::internal::task_scheduler_observer_v3 *__p)
{
  *(void *)__p = &unk_26C746C18;
  if (*((void *)__p + 1)) {
    tbb::internal::task_scheduler_observer_v3::observe(__p, 0);
  }

  operator delete(__p);
}

tbb::internal::task_scheduler_observer_v3 *sub_21676FAC0(tbb::internal::task_scheduler_observer_v3 *a1)
{
  *(void *)a1 = &unk_26C746B78;
  tbb::internal::destroy_binding_handler(*((void *)a1 + 5));
  *(void *)a1 = &unk_26C746BE8;
  if (*((void *)a1 + 1))
  {
    tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
    uint64_t v2 = *((void *)a1 + 1);
    *(void *)a1 = &unk_26C746C18;
    if (v2) {
      tbb::internal::task_scheduler_observer_v3::observe(a1, 0);
    }
  }
  else
  {
    *(void *)a1 = &unk_26C746C18;
  }
  return a1;
}

void *sub_21676FB94(void *a1, void *a2)
{
  uint64_t v3 = a1[3];
  if (v3)
  {
    uint64_t v4 = (void *)(v3 - 16);
    uint64_t v5 = *(void *)(v3 - 8);
    if (v5)
    {
      uint64_t v6 = v3 - 128;
      uint64_t v7 = v5 << 7;
      do
      {
        sub_21676FC5C((uint64_t *)(v6 + v7), a2);
        v7 -= 128;
      }
      while (v7);
    }
    operator delete[](v4);
  }
  uint64_t v8 = a1[4];
  if (v8)
  {
    uint64_t v9 = (void *)(v8 - 16);
    uint64_t v10 = *(void *)(v8 - 8);
    if (v10)
    {
      uint64_t v11 = v10 << 7;
      uint64_t v12 = v8 - 128;
      do
      {
        sub_21676FC5C((uint64_t *)(v12 + v11), a2);
        v11 -= 128;
      }
      while (v11);
    }
    operator delete[](v9);
  }
  uint64_t v13 = a1[5];
  if (v13)
  {
    long long v14 = (void *)(v13 - 16);
    uint64_t v15 = *(void *)(v13 - 8);
    if (v15)
    {
      uint64_t v16 = v15 << 7;
      uint64_t v17 = v13 - 128;
      do
      {
        sub_21676FC5C((uint64_t *)(v17 + v16), a2);
        v16 -= 128;
      }
      while (v16);
    }
    operator delete[](v14);
  }
  return a1;
}

uint64_t *sub_21676FC5C(uint64_t *a1, void *a2)
{
  uint64_t v3 = (uint64_t *)a1[1];
  uint64_t v4 = (uint64_t *)a1[2];
  a1[5] = 0;
  unint64_t v5 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      tbb::internal::deallocate_via_handler_v3(*v3, a2);
      uint64_t v4 = (uint64_t *)a1[2];
      uint64_t v3 = (uint64_t *)(a1[1] + 8);
      a1[1] = (uint64_t)v3;
      unint64_t v5 = (char *)v4 - (char *)v3;
    }
    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }
  unint64_t v6 = v5 >> 3;
  if (v6 == 1)
  {
    uint64_t v7 = 256;
    goto LABEL_7;
  }
  if (v6 == 2)
  {
    uint64_t v7 = 512;
LABEL_7:
    a1[4] = v7;
  }
  if (v3 != v4)
  {
    do
      tbb::internal::deallocate_via_handler_v3(*v3++, a2);
    while (v3 != v4);
    uint64_t v9 = a1[1];
    uint64_t v8 = a1[2];
    if (v8 != v9) {
      a1[2] = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*a1) {
    tbb::internal::deallocate_via_handler_v3(*a1, a2);
  }
  return a1;
}

void *sub_21676FD34(void *a1)
{
  *a1 = &unk_26C746C90;
  uint64_t v2 = a1[3];
  __dmb(0xBu);
  *(void *)(v2 - 24) = 1;
  uint64_t v3 = a1[2];
  __dmb(0xBu);
  sub_21676FEC4(v3, (uint64_t)a1);
  return a1;
}

void sub_21676FD98(void *a1)
{
  *a1 = &unk_26C746C90;
  uint64_t v2 = a1[3];
  __dmb(0xBu);
  *(void *)(v2 - 24) = 1;
  uint64_t v3 = a1[2];
  __dmb(0xBu);
  sub_21676FEC4(v3, (uint64_t)a1);

  operator delete(a1);
}

uint64_t sub_21676FE0C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 - 40);
  uint64_t v3 = *(void *)(v2 + 144);
  char v4 = *(unsigned char *)(v2 + 74);
  uint64_t v5 = *(void *)(a1 - 56);
  *(void *)(a1 - 56) = *(void *)(*(void *)(v2 + 48) + 320);
  *(void *)(v2 + 144) = a1;
  *(unsigned char *)(v2 + 74) |= 1u;
  (***(void (****)(void))(a1 + 8))();
  *(void *)(a1 - 56) = v5;
  *(unsigned char *)(v2 + 74) = v4;
  *(void *)(v2 + 144) = v3;
  return 0;
}

void sub_21676FEB4(_Unwind_Exception *a1)
{
  *(void *)(v1 - 56) = v5;
  *(unsigned char *)(v2 + 74) = v4;
  *(void *)(v2 + 144) = v3;
  _Unwind_Resume(a1);
}

uint64_t sub_21676FEC4(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 8))
  {
    uint64_t v3 = result;
    uint64_t v16 = &v16;
    uint64_t v17 = &v16;
    uint64_t v15 = 0;
    char v4 = (unsigned char *)(result + 1);
    uint64_t v5 = (atomic_uint *)((result + 1) & 0xFFFFFFFFFFFFFFFCLL);
    int v6 = 1 << (8 * ((result + 1) & 3));
    int v7 = ~(255 << (8 * ((result + 1) & 3)));
LABEL_3:
    int v8 = *v5 & v7;
    while (1)
    {
      int v9 = v8;
      atomic_compare_exchange_strong(v5, (unsigned int *)&v9, v8 | v6);
      if (v9 == v8) {
        break;
      }
      if (*v5 != v8)
      {
        uint64_t result = sched_yield();
        goto LABEL_3;
      }
    }
    ++*(_DWORD *)(v3 + 32);
    uint64_t v10 = *(void **)(v3 + 24);
    if (v10 != (void *)(v3 + 16))
    {
      do
      {
        uint64_t v13 = (void *)v10[1];
        if (*(void *)(a2 + 8) == v10[4])
        {
          --*(void *)(v3 + 8);
          *uint64_t v13 = *v10;
          *(void *)(*v10 + 8) = v13;
          __dmb(0xBu);
          *((unsigned char *)v10 + 24) = 0;
          ++v15;
          long long v14 = v17;
          *uint64_t v10 = &v16;
          v10[1] = v14;
          void *v17 = v10;
          uint64_t v17 = v10;
        }
        uint64_t v10 = v13;
      }
      while (v13 != (void *)(v3 + 16));
    }
    __dmb(0xBu);
    unsigned char *v4 = 0;
    uint64_t v11 = v16;
    if (v16 != &v16)
    {
      do
      {
        uint64_t v12 = (void *)*v11;
        uint64_t result = MEMORY[0x21D448AF0](*((unsigned int *)v11 + 4));
        uint64_t v11 = v12;
      }
      while (v12 != &v16);
    }
  }
  return result;
}

uint64_t sub_216770020(uint64_t a1)
{
  unint64_t v2 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
  if (*(unsigned char *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 74))
  {
    tbb::internal::arena::is_out_of_work(*(tbb::internal::arena **)(v3 + 48));
  }
  else
  {
    *(void *)(v3 + 56) = *(void *)(v3 + 144);
    (*(void (**)(unint64_t))(*(void *)v3 + 48))(v2 & 0xFFFFFFFFFFFFFFFELL);
    *(void *)(v3 + 56) = a1;
  }
  MEMORY[0x21D448AF0](**(unsigned int **)(a1 + 8));
  return 0;
}

uint64_t *sub_2167700B0(uint64_t *result)
{
  uint64_t v1 = result;
  unint64_t v2 = result[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    result[4] = v4;
    uint64_t v5 = (uint64_t *)result[1];
    int v6 = (uint64_t *)result[2];
    uint64_t v9 = *v5;
    int v7 = v5 + 1;
    uint64_t v8 = v9;
    result[1] = (uint64_t)v7;
    if (v6 != (uint64_t *)result[3]) {
      goto LABEL_50;
    }
    uint64_t v10 = (uint64_t)v7 - *result;
    if ((unint64_t)v7 > *result) {
      goto LABEL_5;
    }
    unint64_t v37 = ((uint64_t)v6 - *result) >> 2;
    if (v6 == (uint64_t *)*result) {
      unint64_t v37 = 1;
    }
    unint64_t v38 = v37 >> 2;
    uint64_t v39 = v37;
    uint64_t result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v37));
    uint64_t v41 = &result[v38];
    uint64_t v42 = (uint64_t *)v1[1];
    int v6 = v41;
    uint64_t v43 = v1[2] - (void)v42;
    if (v43)
    {
      int v6 = (uint64_t *)((char *)v41 + (v43 & 0xFFFFFFFFFFFFFFF8));
      unint64_t v44 = v43 - 8;
      if ((unint64_t)(v43 - 8) < 0x38)
      {
        unint64_t v45 = &result[v38];
        do
        {
LABEL_46:
          uint64_t v72 = *v42++;
          *v45++ = v72;
        }
        while (v45 != v6);
        goto LABEL_47;
      }
      long long v64 = &result[v38];
      unint64_t v45 = v64;
      if ((unint64_t)((char *)v64 - (char *)v42) < 0x20) {
        goto LABEL_46;
      }
      uint64_t v65 = (v44 >> 3) + 1;
      uint64_t v66 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      unint64_t v45 = &v41[v66];
      v67 = &v42[v66];
      v68 = (long long *)(v42 + 2);
      int v69 = v64 + 2;
      uint64_t v70 = v65 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v71 = *v68;
        *(v69 - 1) = *(v68 - 1);
        *int v69 = v71;
        v68 += 2;
        v69 += 2;
        v70 -= 4;
      }
      while (v70);
      uint64_t v42 = v67;
      if (v65 != (v65 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_46;
      }
    }
LABEL_47:
    uint64_t v73 = *v1;
    *uint64_t v1 = (uint64_t)result;
    v1[1] = (uint64_t)v41;
    v1[2] = (uint64_t)v6;
    v1[3] = (uint64_t)&result[v39];
    if (v73)
    {
      uint64_t result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v73, v40);
LABEL_49:
      int v6 = (uint64_t *)v1[2];
    }
LABEL_50:
    *int v6 = v8;
    v1[2] += 8;
    return result;
  }
  uint64_t v19 = result[2];
  unint64_t v20 = (v19 - result[1]) >> 3;
  uint64_t v21 = result[3];
  uint64_t v22 = v21 - *result;
  if (v20 < v22 >> 3)
  {
    if (v21 != v19)
    {
      v98[0] = (tbb::internal *)tbb::internal::allocate_via_handler_v3((tbb::internal *)0x1000);
      return sub_216770604(v1, v98);
    }
    v98[0] = (tbb::internal *)tbb::internal::allocate_via_handler_v3((tbb::internal *)0x1000);
    uint64_t result = sub_216770788(v1, (uint64_t *)v98);
    int v46 = (uint64_t *)v1[1];
    int v6 = (uint64_t *)v1[2];
    uint64_t v47 = *v46;
    int v7 = v46 + 1;
    uint64_t v8 = v47;
    v1[1] = (uint64_t)v7;
    if (v6 != (uint64_t *)v1[3]) {
      goto LABEL_50;
    }
    uint64_t v10 = (uint64_t)v7 - *v1;
    if ((unint64_t)v7 <= *v1)
    {
      unint64_t v48 = ((uint64_t)v6 - *v1) >> 2;
      if (v6 == (uint64_t *)*v1) {
        unint64_t v48 = 1;
      }
      unint64_t v49 = v48 >> 2;
      uint64_t v50 = v48;
      uint64_t result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v48));
      long long v52 = &result[v49];
      uint64_t v53 = (uint64_t *)v1[1];
      int v6 = v52;
      uint64_t v54 = v1[2] - (void)v53;
      if (!v54) {
        goto LABEL_73;
      }
      int v6 = (uint64_t *)((char *)v52 + (v54 & 0xFFFFFFFFFFFFFFF8));
      unint64_t v55 = v54 - 8;
      if ((unint64_t)(v54 - 8) >= 0x38)
      {
        v88 = &result[v49];
        long long v56 = v88;
        if ((unint64_t)((char *)v88 - (char *)v53) >= 0x20)
        {
          uint64_t v89 = (v55 >> 3) + 1;
          uint64_t v90 = v89 & 0x3FFFFFFFFFFFFFFCLL;
          long long v56 = &v52[v90];
          v91 = &v53[v90];
          v92 = (long long *)(v53 + 2);
          v93 = v88 + 2;
          uint64_t v94 = v89 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v95 = *v92;
            *(v93 - 1) = *(v92 - 1);
            _OWORD *v93 = v95;
            v92 += 2;
            v93 += 2;
            v94 -= 4;
          }
          while (v94);
          uint64_t v53 = v91;
          if (v89 == (v89 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_73;
          }
        }
      }
      else
      {
        long long v56 = &result[v49];
      }
      do
      {
        uint64_t v96 = *v53++;
        *v56++ = v96;
      }
      while (v56 != v6);
LABEL_73:
      uint64_t v97 = *v1;
      *uint64_t v1 = (uint64_t)result;
      v1[1] = (uint64_t)v52;
      v1[2] = (uint64_t)v6;
      v1[3] = (uint64_t)&result[v50];
      if (!v97) {
        goto LABEL_50;
      }
      uint64_t result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v97, v51);
      goto LABEL_49;
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    BOOL v12 = v10 >> 3 < -1;
    uint64_t v13 = (v10 >> 3) + 2;
    if (v12) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = v11 + 1;
    }
    uint64_t v15 = v14 >> 1;
    uint64_t v16 = -v15;
    uint64_t v17 = &v7[-v15];
    int64_t v18 = (char *)v6 - (char *)v7;
    if (v6 != v7)
    {
      uint64_t result = (uint64_t *)memmove(&v7[-v15], v7, (char *)v6 - (char *)v7);
      int v7 = (uint64_t *)v1[1];
    }
    int v6 = (uint64_t *)((char *)v17 + v18);
    v1[1] = (uint64_t)&v7[v16];
    v1[2] = (uint64_t)v17 + v18;
    goto LABEL_50;
  }
  uint64_t v23 = (unint64_t)v22 >> 2;
  if (v21 == *result) {
    uint64_t v23 = 1;
  }
  v100 = result + 3;
  uint64_t v24 = 8 * v23;
  v98[0] = (tbb::internal *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v23));
  v98[1] = (tbb::internal *)((char *)v98[0] + 8 * v20);
  *(tbb::internal **)&long long v99 = v98[1];
  *((void *)&v99 + 1) = (char *)v98[0] + v24;
  uint64_t v26 = tbb::internal::allocate_via_handler_v3((tbb::internal *)0x1000);
  long long v27 = v98[1];
  if (v98[1] == *((tbb::internal **)&v99 + 1))
  {
    int64_t v28 = v98[1] - v98[0];
    if (v98[1] > v98[0])
    {
      uint64_t v29 = v28 >> 3;
      BOOL v12 = v28 >> 3 < -1;
      uint64_t v30 = (v28 >> 3) + 2;
      if (v12) {
        uint64_t v31 = v30;
      }
      else {
        uint64_t v31 = v29 + 1;
      }
      uint64_t v32 = v31 >> 1;
      uint64_t v33 = -v32;
      uint64_t v34 = (char *)v98[1] - 8 * v32;
      uint64_t v35 = v99 - (unint64_t)v98[1];
      if ((tbb::internal *)v99 != v98[1])
      {
        memmove((char *)v98[1] - 8 * v32, v98[1], v99 - (unint64_t)v98[1]);
        long long v27 = v98[1];
      }
      uint64_t v36 = (tbb::internal *)((char *)v27 + 8 * v33);
      long long v27 = (tbb::internal *)&v34[v35];
      v98[1] = v36;
      *(void *)&long long v99 = &v34[v35];
      goto LABEL_58;
    }
    if ((tbb::internal *)v99 == v98[0]) {
      unint64_t v57 = 1;
    }
    else {
      unint64_t v57 = (uint64_t)(v99 - (unint64_t)v98[0]) >> 2;
    }
    std::exception_ptr v58 = (tbb::internal *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v57));
    std::exception_ptr v59 = (tbb::internal *)((char *)v58 + 8 * (v57 >> 2));
    long long v60 = v98[1];
    long long v27 = v59;
    uint64_t v61 = v99 - (unint64_t)v98[1];
    if ((tbb::internal *)v99 != v98[1])
    {
      long long v27 = (tbb::internal *)((char *)v59 + (v61 & 0xFFFFFFFFFFFFFFF8));
      unint64_t v62 = v61 - 8;
      if (v62 < 0x38)
      {
        long long v63 = (tbb::internal *)((char *)v58 + 8 * (v57 >> 2));
        do
        {
LABEL_55:
          uint64_t v82 = *(void *)v60;
          long long v60 = (tbb::internal *)((char *)v60 + 8);
          *(void *)long long v63 = v82;
          long long v63 = (tbb::internal *)((char *)v63 + 8);
        }
        while (v63 != v27);
        goto LABEL_56;
      }
      v74 = (char *)v58 + 8 * (v57 >> 2);
      long long v63 = (tbb::internal *)v74;
      if ((unint64_t)(v74 - (char *)v98[1]) < 0x20) {
        goto LABEL_55;
      }
      uint64_t v75 = (v62 >> 3) + 1;
      uint64_t v76 = 8 * (v75 & 0x3FFFFFFFFFFFFFFCLL);
      long long v63 = (tbb::internal *)((char *)v59 + v76);
      long long v77 = (tbb::internal *)((char *)v98[1] + v76);
      long long v78 = (long long *)((char *)v98[1] + 16);
      long long v79 = v74 + 16;
      uint64_t v80 = v75 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v81 = *v78;
        *(v79 - 1) = *(v78 - 1);
        *long long v79 = v81;
        v78 += 2;
        v79 += 2;
        v80 -= 4;
      }
      while (v80);
      long long v60 = v77;
      if (v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_55;
      }
    }
LABEL_56:
    v83 = v98[0];
    v98[0] = v58;
    v98[1] = (tbb::internal *)((char *)v58 + 8 * (v57 >> 2));
    *(void *)&long long v99 = v27;
    *((void *)&v99 + 1) = (char *)v58 + 8 * v57;
    if (v83)
    {
      tbb::internal::deallocate_via_handler_v3((uint64_t)v83, v25);
      long long v27 = (tbb::internal *)v99;
    }
  }
LABEL_58:
  *(void *)long long v27 = v26;
  *(void *)&long long v99 = v99 + 8;
  for (unsigned int i = (uint64_t *)v1[2]; i != (uint64_t *)v1[1]; sub_216770918((uint64_t *)v98, i))
    --i;
  long long v85 = *(_OWORD *)v98;
  long long v86 = v99;
  v98[0] = (tbb::internal *)*v1;
  v98[1] = (tbb::internal *)i;
  long long v87 = *((_OWORD *)v1 + 1);
  *(_OWORD *)uint64_t v1 = v85;
  *((_OWORD *)v1 + 1) = v86;
  long long v99 = v87;
  if ((uint64_t *)v87 != i) {
    *(void *)&long long v99 = v87 + (((unint64_t)i - v87 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  uint64_t result = (uint64_t *)v98[0];
  if (v98[0]) {
    return (uint64_t *)tbb::internal::deallocate_via_handler_v3((uint64_t)v98[0], v25);
  }
  return result;
}

void sub_2167705D0(_Unwind_Exception *a1, void *a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_216770AA8((uint64_t *)va, a2);
  sub_216770AE0((uint64_t *)va1, v4);
  _Unwind_Resume(a1);
}

uint64_t *sub_216770604(uint64_t *result, void *a2)
{
  BOOL v3 = result;
  unint64_t v4 = (char *)result[2];
  if (v4 != (char *)result[3]) {
    goto LABEL_21;
  }
  uint64_t v5 = (char *)result[1];
  uint64_t v6 = (uint64_t)&v5[-*result];
  if ((unint64_t)v5 > *result)
  {
    uint64_t v7 = v6 >> 3;
    BOOL v8 = v6 >> 3 < -1;
    uint64_t v9 = (v6 >> 3) + 2;
    if (v8) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = v7 + 1;
    }
    uint64_t v11 = v10 >> 1;
    uint64_t v12 = -v11;
    uint64_t v13 = &v5[-8 * v11];
    int64_t v14 = v4 - v5;
    if (v4 != v5)
    {
      uint64_t result = (uint64_t *)memmove(&v5[-8 * v11], v5, v4 - v5);
      unint64_t v4 = (char *)v3[1];
    }
    uint64_t v15 = &v4[8 * v12];
    unint64_t v4 = &v13[v14];
    v3[1] = (uint64_t)v15;
    int v3[2] = (uint64_t)&v13[v14];
    goto LABEL_21;
  }
  unint64_t v16 = (uint64_t)&v4[-*result] >> 2;
  if (v4 == (char *)*result) {
    unint64_t v16 = 1;
  }
  unint64_t v17 = v16 >> 2;
  uint64_t v18 = v16;
  uint64_t result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v16));
  unint64_t v20 = (char *)&result[v17];
  uint64_t v21 = (uint64_t *)v3[1];
  unint64_t v4 = v20;
  uint64_t v22 = v3[2] - (void)v21;
  if (v22)
  {
    unint64_t v4 = &v20[v22 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v23 = v22 - 8;
    if ((unint64_t)(v22 - 8) < 0x38)
    {
      uint64_t v24 = (char *)&result[v17];
      do
      {
LABEL_18:
        uint64_t v33 = *v21++;
        *(void *)uint64_t v24 = v33;
        v24 += 8;
      }
      while (v24 != v4);
      goto LABEL_19;
    }
    unsigned int v25 = &result[v17];
    uint64_t v24 = (char *)v25;
    if ((unint64_t)((char *)v25 - (char *)v21) < 0x20) {
      goto LABEL_18;
    }
    uint64_t v26 = (v23 >> 3) + 1;
    uint64_t v27 = v26 & 0x3FFFFFFFFFFFFFFCLL;
    uint64_t v24 = &v20[v27 * 8];
    int64_t v28 = &v21[v27];
    uint64_t v29 = (long long *)(v21 + 2);
    uint64_t v30 = v25 + 2;
    uint64_t v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v32 = *v29;
      *(v30 - 1) = *(v29 - 1);
      *uint64_t v30 = v32;
      v29 += 2;
      v30 += 2;
      v31 -= 4;
    }
    while (v31);
    uint64_t v21 = v28;
    if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_18;
    }
  }
LABEL_19:
  uint64_t v34 = *v3;
  *BOOL v3 = (uint64_t)result;
  v3[1] = (uint64_t)v20;
  int v3[2] = (uint64_t)v4;
  v3[3] = (uint64_t)&result[v18];
  if (v34)
  {
    uint64_t result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v34, v19);
    unint64_t v4 = (char *)v3[2];
  }
LABEL_21:
  *(void *)unint64_t v4 = *a2;
  v3[2] += 8;
  return result;
}

uint64_t *sub_216770788(uint64_t *result, uint64_t *a2)
{
  BOOL v3 = result;
  unint64_t v4 = (char *)result[1];
  if (v4 != (char *)*result)
  {
    uint64_t v5 = (uint64_t *)result[1];
    goto LABEL_22;
  }
  uint64_t v6 = (unsigned char *)result[2];
  uint64_t v7 = (unsigned char *)result[3];
  if (v6 < v7)
  {
    uint64_t v8 = (v7 - v6) >> 3;
    if (v8 >= -1) {
      uint64_t v9 = v8 + 1;
    }
    else {
      uint64_t v9 = v8 + 2;
    }
    uint64_t v10 = v9 >> 1;
    uint64_t v5 = (uint64_t *)&v4[8 * (v9 >> 1)];
    if (v6 != v4)
    {
      uint64_t result = (uint64_t *)memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
      unint64_t v4 = (char *)v3[2];
    }
    v3[1] = (uint64_t)v5;
    int v3[2] = (uint64_t)&v4[8 * v10];
    goto LABEL_22;
  }
  uint64_t v11 = (v7 - v4) >> 2;
  if (v7 == v4) {
    uint64_t v11 = 1;
  }
  unint64_t v12 = (unint64_t)(v11 + 3) >> 2;
  uint64_t v13 = v11;
  uint64_t result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v11));
  uint64_t v5 = &result[v12];
  uint64_t v15 = (uint64_t *)v3[1];
  unint64_t v16 = (char *)v5;
  uint64_t v17 = v3[2] - (void)v15;
  if (v17)
  {
    unint64_t v16 = (char *)v5 + (v17 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v18 = v17 - 8;
    if ((unint64_t)(v17 - 8) < 0x38)
    {
      uint64_t v19 = &result[v12];
      do
      {
LABEL_19:
        uint64_t v28 = *v15++;
        *v19++ = v28;
      }
      while (v19 != (uint64_t *)v16);
      goto LABEL_20;
    }
    unint64_t v20 = &result[v12];
    uint64_t v19 = v20;
    if ((unint64_t)((char *)v20 - (char *)v15) < 0x20) {
      goto LABEL_19;
    }
    uint64_t v21 = (v18 >> 3) + 1;
    uint64_t v22 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    uint64_t v19 = &v5[v22];
    unint64_t v23 = &v15[v22];
    uint64_t v24 = (long long *)(v15 + 2);
    unsigned int v25 = v20 + 2;
    uint64_t v26 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v27 = *v24;
      *(v25 - 1) = *(v24 - 1);
      _OWORD *v25 = v27;
      v24 += 2;
      v25 += 2;
      v26 -= 4;
    }
    while (v26);
    uint64_t v15 = v23;
    if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_19;
    }
  }
LABEL_20:
  uint64_t v29 = *v3;
  *BOOL v3 = (uint64_t)result;
  v3[1] = (uint64_t)v5;
  int v3[2] = (uint64_t)v16;
  v3[3] = (uint64_t)&result[v13];
  if (v29)
  {
    uint64_t result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v29, v14);
    uint64_t v5 = (uint64_t *)v3[1];
  }
LABEL_22:
  *(v5 - 1) = *a2;
  v3[1] -= 8;
  return result;
}

uint64_t *sub_216770918(uint64_t *result, uint64_t *a2)
{
  BOOL v3 = result;
  unint64_t v4 = (char *)result[1];
  if (v4 != (char *)*result)
  {
    uint64_t v5 = (uint64_t *)result[1];
    goto LABEL_22;
  }
  uint64_t v6 = (unsigned char *)result[2];
  uint64_t v7 = (unsigned char *)result[3];
  if (v6 < v7)
  {
    uint64_t v8 = (v7 - v6) >> 3;
    if (v8 >= -1) {
      uint64_t v9 = v8 + 1;
    }
    else {
      uint64_t v9 = v8 + 2;
    }
    uint64_t v10 = v9 >> 1;
    uint64_t v5 = (uint64_t *)&v4[8 * (v9 >> 1)];
    if (v6 != v4)
    {
      uint64_t result = (uint64_t *)memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
      unint64_t v4 = (char *)v3[2];
    }
    v3[1] = (uint64_t)v5;
    int v3[2] = (uint64_t)&v4[8 * v10];
    goto LABEL_22;
  }
  uint64_t v11 = (v7 - v4) >> 2;
  if (v7 == v4) {
    uint64_t v11 = 1;
  }
  unint64_t v12 = (unint64_t)(v11 + 3) >> 2;
  uint64_t v13 = v11;
  uint64_t result = (uint64_t *)tbb::internal::allocate_via_handler_v3((tbb::internal *)(8 * v11));
  uint64_t v5 = &result[v12];
  uint64_t v15 = (uint64_t *)v3[1];
  unint64_t v16 = (char *)v5;
  uint64_t v17 = v3[2] - (void)v15;
  if (v17)
  {
    unint64_t v16 = (char *)v5 + (v17 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v18 = v17 - 8;
    if ((unint64_t)(v17 - 8) < 0x38)
    {
      uint64_t v19 = &result[v12];
      do
      {
LABEL_19:
        uint64_t v28 = *v15++;
        *v19++ = v28;
      }
      while (v19 != (uint64_t *)v16);
      goto LABEL_20;
    }
    unint64_t v20 = &result[v12];
    uint64_t v19 = v20;
    if ((unint64_t)((char *)v20 - (char *)v15) < 0x20) {
      goto LABEL_19;
    }
    uint64_t v21 = (v18 >> 3) + 1;
    uint64_t v22 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    uint64_t v19 = &v5[v22];
    unint64_t v23 = &v15[v22];
    uint64_t v24 = (long long *)(v15 + 2);
    unsigned int v25 = v20 + 2;
    uint64_t v26 = v21 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v27 = *v24;
      *(v25 - 1) = *(v24 - 1);
      _OWORD *v25 = v27;
      v24 += 2;
      v25 += 2;
      v26 -= 4;
    }
    while (v26);
    uint64_t v15 = v23;
    if (v21 != (v21 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_19;
    }
  }
LABEL_20:
  uint64_t v29 = *v3;
  *BOOL v3 = (uint64_t)result;
  v3[1] = (uint64_t)v5;
  int v3[2] = (uint64_t)v16;
  v3[3] = (uint64_t)&result[v13];
  if (v29)
  {
    uint64_t result = (uint64_t *)tbb::internal::deallocate_via_handler_v3(v29, v14);
    uint64_t v5 = (uint64_t *)v3[1];
  }
LABEL_22:
  *(v5 - 1) = *a2;
  v3[1] -= 8;
  return result;
}

uint64_t *sub_216770AA8(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  *a1 = 0;
  if (v3) {
    tbb::internal::deallocate_via_handler_v3(v3, a2);
  }
  return a1;
}

uint64_t *sub_216770AE0(uint64_t *a1, void *a2)
{
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  if (v3 != v4) {
    a1[2] = v3 + ((v4 - v3 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  uint64_t v5 = *a1;
  if (*a1) {
    tbb::internal::deallocate_via_handler_v3(v5, a2);
  }
  return a1;
}

uint64_t sub_216770B34(uint64_t a1)
{
  return 0;
}

uint64_t sub_216770B7C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(tbb::internal **)(a1 + 16);
  uint64_t v4 = *(void **)(a1 + 8);
  if (*(void *)v3 != *v4 || *((void *)v3 + 1) != v4[1])
  {
    fesetenv(*(const fenv_t **)(a1 + 8));
    uint64_t v3 = *(tbb::internal **)(a1 + 16);
  }
  if (v3) {
    tbb::internal::NFS_Free(v3, a2);
  }
  uint64_t v6 = *(tbb::internal **)(a1 + 8);
  if (v6) {
    tbb::internal::NFS_Free(v6, a2);
  }
  return a1;
}

uint64_t tbb::internal::Scheduler_OneTimeInitialization(tbb::internal *this)
{
  uint64_t v1 = tbb::internal::custom_scheduler<tbb::internal::IntelSchedulerTraits>::allocate_scheduler;
  if (this) {
    uint64_t v1 = tbb::internal::custom_scheduler<tbb::internal::DefaultSchedulerTraits>::allocate_scheduler;
  }
  tbb::internal::AllocateSchedulerPtr = v1;
  *(void *)(sub_216770D68() + 152) = 2;
  uint64_t result = sub_216770D68();
  *(void *)(result + 160) = 2;
  return result;
}

tbb::internal::generic_scheduler *tbb::internal::custom_scheduler<tbb::internal::DefaultSchedulerTraits>::allocate_scheduler(tbb::internal::market *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = tbb::internal::NFS_Allocate(1uLL, 392, 0, a4);
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_OWORD *)(v5 + 240) = 0u;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  *(_OWORD *)(v5 + 304) = 0u;
  *(_OWORD *)(v5 + 320) = 0u;
  *(_OWORD *)(v5 + 336) = 0u;
  *(_OWORD *)(v5 + 352) = 0u;
  *(_OWORD *)(v5 + 368) = 0u;
  *(void *)(v5 + 384) = 0;
  uint64_t result = tbb::internal::generic_scheduler::generic_scheduler((tbb::internal::generic_scheduler *)v5, a1);
  *(void *)uint64_t result = &unk_26C746E68;
  return result;
}

tbb::internal::generic_scheduler *tbb::internal::custom_scheduler<tbb::internal::IntelSchedulerTraits>::allocate_scheduler(tbb::internal::market *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = tbb::internal::NFS_Allocate(1uLL, 392, 0, a4);
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_OWORD *)(v5 + 144) = 0u;
  *(_OWORD *)(v5 + 160) = 0u;
  *(_OWORD *)(v5 + 176) = 0u;
  *(_OWORD *)(v5 + 192) = 0u;
  *(_OWORD *)(v5 + 208) = 0u;
  *(_OWORD *)(v5 + 224) = 0u;
  *(_OWORD *)(v5 + 240) = 0u;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  *(_OWORD *)(v5 + 304) = 0u;
  *(_OWORD *)(v5 + 320) = 0u;
  *(_OWORD *)(v5 + 336) = 0u;
  *(_OWORD *)(v5 + 352) = 0u;
  *(_OWORD *)(v5 + 368) = 0u;
  *(void *)(v5 + 384) = 0;
  uint64_t result = tbb::internal::generic_scheduler::generic_scheduler((tbb::internal::generic_scheduler *)v5, a1);
  *(void *)uint64_t result = &unk_26C746EE0;
  return result;
}

uint64_t sub_216770D68()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E078, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26798E078))
  {
    uint64_t v1 = operator new(0x100uLL);
    *(_DWORD *)uint64_t v1 = 0;
    v1[16] = 65539;
    *((_DWORD *)v1 + 42) = 55;
    tbb::task_group_context::init((uint64_t)v1, v2, v3, v4);
    qword_26798E070 = (uint64_t)v1;
    __cxa_guard_release(&qword_26798E078);
  }
  return qword_26798E070;
}

void sub_216770DE8(_Unwind_Exception *a1)
{
  operator delete(v1);
  __cxa_guard_abort(&qword_26798E078);
  _Unwind_Resume(a1);
}

tbb::internal::generic_scheduler *tbb::internal::generic_scheduler::generic_scheduler(tbb::internal::generic_scheduler *this, tbb::internal::market *a2)
{
  *((void *)this + 8) = 0;
  *(void *)this = &unk_26C746D68;
  *((void *)this + 15) = a2;
  int v4 = -1168702475 * ((HIDWORD(this) + this) | 1);
  *((_DWORD *)this + 32) = v4 ^ ((HIDWORD(this) + this) >> 1);
  *((_DWORD *)this + 33) = v4;
  *((void *)this + 19) = 1;
  *((void *)this + 21) = 1;
  *((unsigned char *)this + 312) = 0;
  uint64_t v6 = sub_216770D68();
  uint64_t v7 = *((void *)this + 17);
  if (!v7)
  {
    if (!*((void *)this + 22))
    {
      uint64_t v10 = tbb::internal::NFS_Allocate(1uLL, 256, 0, v5);
      uint64_t v7 = v10 + 64;
      *(void *)(v10 + 16) = this;
      *(void *)(v10 + 56) = 0;
      ++*((void *)this + 21);
      goto LABEL_3;
    }
LABEL_5:
    uint64_t v7 = *((void *)this + 22);
    while (1)
    {
      uint64_t v9 = v7;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 22, (unint64_t *)&v9, 0);
      if (v9 == v7) {
        break;
      }
      if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 22, 0, memory_order_relaxed) != v7)
      {
        sched_yield();
        goto LABEL_5;
      }
    }
  }
  *((void *)this + 17) = *(void *)(v7 - 8);
LABEL_3:
  *(void *)(v7 - 24) = 0;
  *(void *)(v7 - 16) = 0x300000000;
  *(void *)(v7 - 40) = this;
  *(void *)(v7 - 32) = 0;
  *(void *)(v7 - 64) = 0;
  *(void *)(v7 - 56) = v6;
  *((void *)this + 18) = v7;
  *((void *)this + 7) = v7;
  *((unsigned char *)this + 74) |= 2u;
  *((void *)this + 12) = (char *)a2 + 48;
  *((void *)this + 13) = (char *)a2 + 64;
  *((void *)this + 40) = tbb::internal::the_context_state_propagation_epoch;
  *((void *)this + 37) = (char *)this + 296;
  *((void *)this + 38) = (char *)this + 296;
  return this;
}

uint64_t tbb::internal::generic_scheduler::allocate_task(tbb::internal::generic_scheduler *this, unint64_t a2, tbb::task *a3, tbb::task_group_context *a4)
{
  if (a2 > 0xC0)
  {
    uint64_t v8 = tbb::internal::NFS_Allocate(1uLL, a2 + 64, 0, a4);
    uint64_t result = v8 + 64;
    *(void *)(v8 + 16) = 0;
  }
  else
  {
    uint64_t result = *((void *)this + 17);
    if (!result)
    {
      if (!*((void *)this + 22))
      {
        uint64_t v10 = tbb::internal::NFS_Allocate(1uLL, 256, 0, a4);
        uint64_t result = v10 + 64;
        *(void *)(v10 + 16) = this;
        *(void *)(v10 + 56) = 0;
        ++*((void *)this + 21);
        goto LABEL_5;
      }
LABEL_7:
      uint64_t result = *((void *)this + 22);
      while (1)
      {
        uint64_t v9 = result;
        atomic_compare_exchange_strong((atomic_ullong *volatile)this + 22, (unint64_t *)&v9, 0);
        if (v9 == result) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 22, 0, memory_order_relaxed) != result)
        {
          sched_yield();
          goto LABEL_7;
        }
      }
    }
    *((void *)this + 17) = *(void *)(result - 8);
  }
LABEL_5:
  *(void *)(result - 24) = 0;
  *(void *)(result - 16) = 0x300000000;
  *(void *)(result - 40) = this;
  *(void *)(result - 32) = a3;
  *(void *)(result - 64) = 0;
  *(void *)(result - 56) = a4;
  return result;
}

uint64_t tbb::internal::generic_scheduler::init_stack_info(uint64_t this)
{
  *(void *)(this + 112) = &v1 - (*(void *)(*(void *)(this + 120) + 208) >> 1);
  return this;
}

uint64_t tbb::internal::generic_scheduler::cleanup_local_context_list(uint64_t this)
{
  char v1 = (void *)this;
  uint64_t v2 = *(void *)(this + 320);
  *(void *)(this + 328) = 1;
  __dmb(0xBu);
  if (*(void *)(this + 368)) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = v2 == tbb::internal::the_context_state_propagation_epoch;
  }
  if (v3)
  {
    int v4 = 0;
  }
  else
  {
    int v4 = (unsigned char *)(this + 312);
    uint64_t v5 = (atomic_uint *)((this + 312) & 0xFFFFFFFFFFFFFFFCLL);
    int v6 = 1 << (8 * ((this + 56) & 3));
    int v7 = ~(255 << (8 * ((this + 56) & 3)));
LABEL_6:
    int v8 = *v5 & v7;
    while (1)
    {
      int v9 = v8;
      atomic_compare_exchange_strong(v5, (unsigned int *)&v9, v8 | v6);
      if (v9 == v8) {
        break;
      }
      if (*v5 != v8)
      {
        this = sched_yield();
        goto LABEL_6;
      }
    }
  }
  uint64_t v10 = (void *)v1[38];
  if (v10 == v1 + 37)
  {
    char v11 = 0;
  }
  else
  {
    char v11 = 0;
    do
    {
      unint64_t v12 = (void *)v10[1];
LABEL_15:
      int v13 = *((_DWORD *)v10 - 4);
      while (1)
      {
        int v14 = v13;
        atomic_compare_exchange_strong((atomic_uint *volatile)v10 - 4, (unsigned int *)&v14, 3u);
        if (v14 == v13) {
          break;
        }
        if (*((_DWORD *)v10 - 4) != v13)
        {
          this = sched_yield();
          goto LABEL_15;
        }
      }
      v11 |= v13 == 4;
      uint64_t v10 = v12;
    }
    while (v12 != v1 + 37);
  }
  if (v4)
  {
    __dmb(0xBu);
    unsigned char *v4 = 0;
  }
  __dmb(0xBu);
  v1[41] = 0;
  if (v11)
  {
    while (1)
    {
      uint64_t v15 = v1[46];
      __dmb(0xBu);
      if (!v15) {
        break;
      }
      this = sched_yield();
    }
  }
  return this;
}

void sub_21677119C(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *char v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::internal::generic_scheduler::destroy(tbb::internal::generic_scheduler *this)
{
  (*(void (**)(tbb::internal::generic_scheduler *))(*(void *)this + 24))(this);

  return tbb::internal::NFS_Free(this, v2);
}

uint64_t tbb::internal::generic_scheduler::cleanup_scheduler(tbb::internal::generic_scheduler *this)
{
  tbb::internal::generic_scheduler::cleanup_local_context_list((uint64_t)this);
  uint64_t v4 = *((void *)this + 17);
  uint64_t v3 = *((void *)this + 18);
  *(unsigned char *)(v3 - 12) = 4;
  *(void *)(v3 - 8) = v4;
  uint64_t v5 = 1;
  while (1)
  {
    for (*((void *)this + 17) = v3; v3; uint64_t v3 = *((void *)this + 17))
    {
      *((void *)this + 17) = *(void *)(v3 - 8);
      tbb::internal::NFS_Free((tbb::internal *)(v3 - 64), v2);
      ++v5;
    }
    if (*((void *)this + 22) == -1) {
      break;
    }
LABEL_5:
    uint64_t v3 = *((void *)this + 22);
    while (1)
    {
      uint64_t v6 = v3;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 22, (unint64_t *)&v6, 0xFFFFFFFFFFFFFFFFLL);
      if (v6 == v3) {
        break;
      }
      if (atomic_fetch_add_explicit((atomic_ullong *volatile)this + 22, 0, memory_order_relaxed) != v3)
      {
        sched_yield();
        goto LABEL_5;
      }
    }
  }
  uint64_t result = tbb::internal::governor::sign_off((uint64_t)this);
  if (atomic_fetch_add((atomic_ullong *volatile)this + 21, -v5) == v5)
  {
    (*(void (**)(tbb::internal::generic_scheduler *))(*(void *)this + 24))(this);
    return tbb::internal::NFS_Free(this, v8);
  }
  return result;
}

void tbb::internal::generic_scheduler::free_nonlocal_small_task(tbb::internal::generic_scheduler *this, tbb::task *a2)
{
  uint64_t v2 = (atomic_ullong *)*((void *)a2 - 6);
  while (1)
  {
    unint64_t v4 = v2[22];
    if (v4 == -1) {
      break;
    }
    *((void *)a2 - 1) = v4;
    while (1)
    {
      unint64_t v5 = v4;
      atomic_compare_exchange_strong(v2 + 22, &v5, (unint64_t)a2);
      if (v5 == v4) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit(v2 + 22, 0, memory_order_relaxed);
      if (add_explicit != v4) {
        goto LABEL_3;
      }
    }
    unint64_t add_explicit = v4;
LABEL_3:
    if (v4 == add_explicit) {
      return;
    }
  }
  tbb::internal::NFS_Free((tbb::task *)((char *)a2 - 64), a2);
  if (atomic_fetch_add(v2 + 21, 0xFFFFFFFFFFFFFFFFLL) == 1)
  {
    (*(void (**)(atomic_ullong *))(*v2 + 24))(v2);
    tbb::internal::NFS_Free((tbb::internal *)v2, v6);
  }
}

unsigned char *tbb::internal::generic_scheduler::local_spawn(tbb::internal::generic_scheduler *this, tbb::task *a2, tbb::task **a3, void *a4)
{
  unint64_t v4 = a2;
  uint64_t v46 = *MEMORY[0x263EF8340];
  if ((tbb::task **)((char *)a2 - 8) == a3)
  {
    unint64_t v28 = sub_216771764((uint64_t)this, (void *)1, (uint64_t)a3, a4);
    uint64_t result = sub_2167719A0((uint64_t)this, (uint64_t)v4, v29, v30);
    *(void *)(*(void *)(*((void *)this + 5) + 152) + 8 * v28) = result;
    uint64_t v31 = *((void *)this + 5);
    __dmb(0xBu);
    *(void *)(v31 + 136) = v28 + 1;
    uint64_t v32 = *((void *)this + 5);
    if (!*(void *)(v32 + 8))
    {
      uint64_t v33 = *(void *)(v32 + 152);
      __dmb(0xBu);
      *(void *)(v32 + 8) = v33;
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    int v9 = v45;
    memset(v45, 0, 512);
    uint64_t v40 = v45;
    unint64_t v10 = 64;
    int64x2_t v41 = vdupq_n_s64(0x40uLL);
    uint64_t v11 = 64;
    unint64_t v43 = 0;
    uint64_t v44 = 0;
    do
    {
      unint64_t v16 = (tbb::task **)((char *)v4 - 8);
      uint64_t v15 = (tbb::task *)*((void *)v4 - 1);
      uint64_t result = sub_2167719A0((uint64_t)this, (uint64_t)v4, (uint64_t)a3, a4);
      uint64_t v17 = (uint64_t)result;
      if (!v11)
      {
        if (!v8)
        {
          unint64_t v43 = 1;
          uint64_t v42 = v9;
          uint64_t v8 = 1;
        }
        v7 += v10;
        uint64_t v44 = v7;
        v10 *= 2;
        v41.i64[0] = v10;
        v41.i64[1] = v10;
        uint64_t result = (unsigned char *)tbb::internal::NFS_Allocate(v10, 8, 0, a4);
        int v14 = &(&v40)[v8++];
        uint64_t v40 = result;
        unint64_t v43 = v8;
        v14[3] = result;
        int v9 = v40;
        uint64_t v11 = v10;
      }
      v41.i64[1] = --v11;
      *(void *)&v9[8 * v11] = v17;
      unint64_t v4 = v15;
    }
    while (v16 != a3);
    unint64_t v18 = v10 + v7 - v11;
    if (v10 + v7 != v11)
    {
      unint64_t v19 = sub_216771764((uint64_t)this, (void *)(v10 + v7 - v11), (uint64_t)a3, a4);
      unint64_t v20 = (char *)(*(void *)(*((void *)this + 5) + 152) + 8 * v19);
      uint64_t result = memcpy(v20, &v40[8 * v11], 8 * (v10 - v11));
      if (v8 >= 2)
      {
        uint64_t v21 = &v20[8 * (v10 - v11)];
        do
        {
          v10 >>= 1;
          uint64_t result = memcpy(v21, (const void *)v41.i64[v8], 8 * v10);
          v21 += 8 * v10;
          --v8;
        }
        while (v8 != 1);
      }
      uint64_t v22 = *((void *)this + 5);
      __dmb(0xBu);
      *(void *)(v22 + 136) = v19 + v18;
      uint64_t v23 = *((void *)this + 5);
      if (!*(void *)(v23 + 8))
      {
        uint64_t v24 = *(void *)(v23 + 152);
        __dmb(0xBu);
        *(void *)(v23 + 8) = v24;
      }
    }
    unint64_t v25 = v43;
    if (v43 >= 2)
    {
      uint64_t v26 = 4;
      do
      {
        uint64_t result = (unsigned char *)tbb::internal::NFS_Free((tbb::internal *)(&v40)[v26], v13);
        unint64_t v27 = v26 - 2;
        ++v26;
      }
      while (v27 < v25);
    }
  }
  uint64_t v34 = *((void *)this + 6);
  uint64_t v35 = *(void *)(v34 + 216);
  __dmb(0xBu);
  if (v35 != -1)
  {
    while (1)
    {
      uint64_t v36 = v35;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v34 + 216), (unint64_t *)&v36, 0xFFFFFFFFFFFFFFFFLL);
      if (v36 == v35) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 216), 0, memory_order_relaxed);
      if (add_explicit != v35)
      {
        if (add_explicit) {
          return result;
        }
        goto LABEL_26;
      }
    }
    if (v35) {
      return result;
    }
LABEL_26:
    if (v35)
    {
      while (1)
      {
        uint64_t v38 = 0;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v34 + 216), (unint64_t *)&v38, 0xFFFFFFFFFFFFFFFFLL);
        if (!v38) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 216), 0, memory_order_relaxed)) {
          return result;
        }
      }
    }
    if (*(unsigned char *)(v34 + 336))
    {
      *(_DWORD *)(v34 + 208) = 0;
      *(unsigned char *)(v34 + 336) = 0;
    }
    else
    {
      char v39 = *(unsigned char *)(v34 + 337);
      __dmb(0xBu);
      if (v39) {
        tbb::internal::market::mandatory_concurrency_disable(*(atomic_ullong **)(v34 + 304), (tbb::internal::arena *)v34);
      }
      return (unsigned char *)tbb::internal::market::adjust_demand(*(void *)(v34 + 304), v34, *(_DWORD *)(v34 + 208));
    }
  }
  return result;
}

void sub_216771728(_Unwind_Exception *exception_object)
{
}

void sub_216771734(_Unwind_Exception *a1, void *a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_216771AFC((uint64_t)va, a2);
  _Unwind_Resume(a1);
}

unint64_t sub_216771764(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  unint64_t v4 = *(atomic_ullong **)(a1 + 40);
  unint64_t v5 = v4[17];
  unint64_t v6 = v4[18];
  if ((unint64_t)a2 + v5 <= v6) {
    return v5;
  }
  unint64_t v7 = (unint64_t)a2;
  if (v6)
  {
    atomic_ullong v9 = v4[1];
    if (v9)
    {
      while (1)
      {
        if (v9 != -1)
        {
          unint64_t v10 = (tbb::internal *)v4[19];
          while (1)
          {
            uint64_t v11 = v10;
            atomic_compare_exchange_strong(v4 + 1, (unint64_t *)&v11, 0xFFFFFFFFFFFFFFFFLL);
            if (v11 == v10) {
              break;
            }
            unint64_t add_explicit = atomic_fetch_add_explicit(v4 + 1, 0, memory_order_relaxed);
            if ((tbb::internal *)add_explicit != v10)
            {
              unint64_t v10 = (tbb::internal *)add_explicit;
              break;
            }
          }
          unint64_t v4 = *(atomic_ullong **)(a1 + 40);
          if ((tbb::internal *)v4[19] == v10) {
            break;
          }
        }
        sched_yield();
        unint64_t v4 = *(atomic_ullong **)(a1 + 40);
        atomic_ullong v9 = v4[1];
      }
    }
    else
    {
      unint64_t v10 = (tbb::internal *)v4[19];
    }
    unint64_t v15 = v4[2];
    unint64_t v16 = v5 - v15;
    if (v5 <= v15) {
      goto LABEL_26;
    }
    if (v16 >= 4)
    {
      atomic_ullong v17 = v15 + (v16 & 0xFFFFFFFFFFFFFFFCLL);
      int64x2_t v18 = 0uLL;
      int64x2_t v19 = (int64x2_t)v7;
      unint64_t v20 = (int64x2_t *)((char *)v10 + 8 * v15 + 16);
      unint64_t v21 = v16 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        int64x2_t v19 = vsubq_s64(v19, vtstq_s64(v20[-1], v20[-1]));
        int64x2_t v18 = vsubq_s64(v18, vtstq_s64(*v20, *v20));
        v20 += 2;
        v21 -= 4;
      }
      while (v21);
      unint64_t v7 = vaddvq_s64(vaddq_s64(v18, v19));
      if (v16 == (v16 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_26:
        atomic_ullong v25 = v4[18];
        unint64_t v26 = v25 - 16;
        if (v7 > v25 - 16)
        {
          unint64_t v27 = 2 * v25;
          if (v7 > v27) {
            unint64_t v27 = v7;
          }
          unint64_t v28 = (8 * v27 + 127) & 0xFFFFFFFFFFFFFF80;
          v4[18] = v28 >> 3;
          v4[19] = tbb::internal::NFS_Allocate(1uLL, v28, 0, a4);
        }
        unint64_t v29 = v5 - v15;
        if (v5 <= v15)
        {
          unint64_t v5 = 0;
        }
        else
        {
          unint64_t v5 = 0;
          uint64_t v30 = (void *)((char *)v10 + 8 * v15);
          do
          {
            if (*v30) {
              *(void *)(*(void *)(*(void *)(a1 + 40) + 152) + 8 * v5++) = *v30;
            }
            ++v30;
            --v29;
          }
          while (v29);
        }
        if (v7 > v26) {
          tbb::internal::NFS_Free(v10, a2);
        }
        uint64_t v31 = *(void *)(a1 + 40);
        *(void *)(v31 + 16) = 0;
        __dmb(0xBu);
        *(void *)(v31 + 136) = v5;
        uint64_t v32 = *(void *)(a1 + 40);
        if (*(void *)(v32 + 8))
        {
          uint64_t v33 = *(void *)(v32 + 152);
          __dmb(0xBu);
          *(void *)(v32 + 8) = v33;
        }
        return v5;
      }
    }
    else
    {
      atomic_ullong v17 = v4[2];
    }
    unint64_t v22 = v5 - v17;
    uint64_t v23 = (void *)((char *)v10 + 8 * v17);
    do
    {
      if (*v23++) {
        ++v7;
      }
      --v22;
    }
    while (v22);
    goto LABEL_26;
  }
  uint64_t v13 = 64;
  if ((unint64_t)a2 > 0x40) {
    uint64_t v13 = (uint64_t)a2;
  }
  unint64_t v14 = (8 * v13 + 127) & 0xFFFFFFFFFFFFFF80;
  v4[18] = v14 >> 3;
  unint64_t v5 = 0;
  v4[19] = tbb::internal::NFS_Allocate(1uLL, v14, 0, a4);
  return v5;
}

void *sub_2167719A0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *(unsigned char *)(a2 - 12) = 2;
  uint64_t v5 = *(unsigned __int16 *)(a2 - 10);
  uint64_t v6 = *(void *)(*(void *)(a1 + 56) - 64);
  *(void *)(a2 - 64) = v6;
  if (!v5 || v5 == *(unsigned __int16 *)(a1 + 72)) {
    return (void *)a2;
  }
  uint64_t v8 = *(void **)(a1 + 136);
  if (v8) {
    goto LABEL_4;
  }
  if (*(void *)(a1 + 176))
  {
LABEL_16:
    uint64_t v8 = *(void **)(a1 + 176);
    while (1)
    {
      unint64_t v14 = v8;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 176), (unint64_t *)&v14, 0);
      if (v14 == v8) {
        break;
      }
      if ((void *)atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 176), 0, memory_order_relaxed) != v8)
      {
        sched_yield();
        goto LABEL_16;
      }
    }
LABEL_4:
    *(void *)(a1 + 136) = *(v8 - 1);
    goto LABEL_5;
  }
  uint64_t v15 = tbb::internal::NFS_Allocate(1uLL, 256, 0, a4);
  uint64_t v8 = (void *)(v15 + 64);
  *(void *)(v15 + 16) = a1;
  *(void *)(v15 + 56) = 0;
  ++*(void *)(a1 + 168);
LABEL_5:
  *(v8 - 5) = a1;
  *(v8 - 4) = 0;
  *(v8 - 3) = 0;
  *(v8 - 2) = 0x200300000000;
  uint64_t v9 = *(void *)(a1 + 48) - (v5 << 7);
  v8[3] = v9;
  v8[1] = a2 | 3;
  *(v8 - 8) = v6;
  *(v8 - 7) = 0;
  int v10 = *(_DWORD *)(v9 + 16);
  __dmb(0xBu);
  if (v10 > 32)
  {
    sub_2167729D0(a1, v8);
    return (void *)a2;
  }
  atomic_fetch_add((atomic_uint *volatile)(v9 + 16), 1u);
  v8[2] = 0;
LABEL_7:
  uint64_t v11 = *(void **)(v9 + 8);
  while (1)
  {
    unint64_t v12 = v11;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(v9 + 8), (unint64_t *)&v12, (unint64_t)(v8 + 2));
    if (v12 == v11) {
      break;
    }
    if ((void *)atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 0, memory_order_relaxed) != v11)
    {
      sched_yield();
      goto LABEL_7;
    }
  }
  *uint64_t v11 = v8;
  return v8;
}

uint64_t sub_216771AFC(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 152) >= 2uLL)
  {
    uint64_t v3 = 4;
    do
    {
      tbb::internal::NFS_Free(*(tbb::internal **)(a1 + 8 * v3), a2);
      unint64_t v4 = v3 - 2;
      ++v3;
    }
    while (v4 < *(void *)(a1 + 152));
  }
  return a1;
}

uint64_t tbb::internal::generic_scheduler::local_spawn_root_and_wait(tbb::internal::generic_scheduler *this, tbb::task *a2, tbb::task **a3, void *a4)
{
  uint64_t v7 = *((void *)a2 - 7);
  uint64_t v8 = (void *)*((void *)this + 17);
  if (v8)
  {
LABEL_2:
    *((void *)this + 17) = *(v8 - 1);
    goto LABEL_3;
  }
  if (*((void *)this + 22))
  {
LABEL_8:
    uint64_t v8 = (void *)*((void *)this + 22);
    while (1)
    {
      unint64_t v12 = v8;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 22, (unint64_t *)&v12, 0);
      if (v12 == v8) {
        goto LABEL_2;
      }
      if ((void *)atomic_fetch_add_explicit((atomic_ullong *volatile)this + 22, 0, memory_order_relaxed) != v8)
      {
        sched_yield();
        goto LABEL_8;
      }
    }
  }
  uint64_t v14 = tbb::internal::NFS_Allocate(1uLL, 256, 0, a4);
  uint64_t v8 = (void *)(v14 + 64);
  *(void *)(v14 + 16) = this;
  *(void *)(v14 + 56) = 0;
  ++*((void *)this + 21);
LABEL_3:
  *(v8 - 5) = this;
  *(v8 - 4) = 0;
  *(v8 - 3) = 0;
  *(v8 - 2) = 0x10300000000;
  *(v8 - 8) = 0;
  *(v8 - 7) = v7;
  *uint64_t v8 = &unk_26C746C48;
  *((void *)a2 - 4) = v8;
  if ((tbb::task **)((char *)a2 - 8) == a3)
  {
    *(v8 - 3) = 2;
  }
  else
  {
    uint64_t v9 = 2;
    int v10 = (tbb::task **)((char *)a2 - 8);
    do
    {
      uint64_t v11 = *v10;
      *((void *)v11 - 4) = v8;
      int v10 = (tbb::task **)((char *)v11 - 8);
      ++v9;
    }
    while (v10 != a3);
    *(v8 - 3) = v9;
    tbb::internal::generic_scheduler::local_spawn(this, *((tbb::task **)a2 - 1), a3, a4);
  }
  uint64_t result = (*(uint64_t (**)(tbb::internal::generic_scheduler *, void *, tbb::task *))(*(void *)this + 48))(this, v8, a2);
  *((unsigned char *)v8 - 12) = 4;
  *(v8 - 1) = *((void *)this + 17);
  *((void *)this + 17) = v8;
  return result;
}

void sub_216771CBC(_Unwind_Exception *a1)
{
  *(unsigned char *)(v2 - 12) = 4;
  *(void *)(v2 - 8) = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = v2;
  _Unwind_Resume(a1);
}

unsigned char *tbb::internal::generic_scheduler::spawn(tbb::internal::generic_scheduler *this, tbb::task *a2, tbb::task **a3)
{
  unint64_t v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v5) {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  }

  return tbb::internal::generic_scheduler::local_spawn(inited, a2, a3, v6);
}

uint64_t tbb::internal::generic_scheduler::spawn_root_and_wait(tbb::internal::generic_scheduler *this, tbb::task *a2, tbb::task **a3)
{
  unint64_t v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v5) {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  }

  return tbb::internal::generic_scheduler::local_spawn_root_and_wait(inited, a2, a3, v6);
}

uint64_t tbb::internal::generic_scheduler::enqueue(tbb::internal::generic_scheduler *this, tbb::task *a2, uint64_t a3)
{
  unint64_t v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v5) {
    unint64_t inited = v5 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    unint64_t inited = tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  }
  uint64_t v7 = (unsigned int *)(inited + 128);
  uint64_t v8 = *(void **)(inited + 48);

  return tbb::internal::arena::enqueue_task(v8, (uint64_t)a2, a3, v7);
}

unint64_t tbb::internal::generic_scheduler::get_task_and_activate_task_pool(tbb::internal::generic_scheduler *this, unint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4 = a3;
  unint64_t v5 = a2;
  if (a3 <= a2)
  {
    unint64_t v10 = 0;
    BOOL v15 = 1;
    goto LABEL_34;
  }
  int v8 = 0;
  unint64_t v9 = a3;
  do
  {
    --v4;
    unint64_t v12 = *(void **)(*(void *)(*((void *)this + 5) + 152) + 8 * v4);
    if (!v12)
    {
LABEL_3:
      if (v8)
      {
LABEL_4:
        unint64_t v10 = (unint64_t)v12;
        goto LABEL_5;
      }
LABEL_25:
      int v8 = 0;
      --v9;
      goto LABEL_4;
    }
    if (a4 && *(v12 - 8) != a4)
    {
      unint64_t v10 = 0;
      int v8 = 1;
    }
    else
    {
      if (*((unsigned char *)v12 - 11) != 32) {
        goto LABEL_3;
      }
      uint64_t v13 = v12[1];
      __dmb(0xBu);
      if (v13 == 1) {
        goto LABEL_22;
      }
      while (1)
      {
        uint64_t v14 = v13;
        atomic_compare_exchange_strong(v12 + 1, (unint64_t *)&v14, 2uLL);
        if (v14 == v13) {
          break;
        }
        if (atomic_fetch_add_explicit(v12 + 1, 0, memory_order_relaxed) != v13) {
          goto LABEL_22;
        }
      }
      unint64_t v10 = v13 & 0xFFFFFFFFFFFFFFFCLL;
      if ((v13 & 0xFFFFFFFFFFFFFFFCLL) == 0)
      {
LABEL_22:
        sub_2167729D0((uint64_t)this, v12);
        if (!v8)
        {
          unint64_t v12 = 0;
          goto LABEL_25;
        }
        unint64_t v10 = 0;
        *(void *)(*(void *)(*((void *)this + 5) + 152) + 8 * v4) = 0;
      }
      else
      {
        *((void *)this + 7) = v10;
        if (!v8)
        {
          (*(void (**)(unint64_t, void))(*(void *)v10 + 24))(v10, *((unsigned __int16 *)this + 36));
          unint64_t v12 = (void *)v10;
          goto LABEL_25;
        }
      }
    }
LABEL_5:
    if (v10) {
      BOOL v11 = 0;
    }
    else {
      BOOL v11 = v4 > v5;
    }
  }
  while (v11);
  BOOL v15 = v8 == 0;
  if (v10) {
    BOOL v16 = v8 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16)
  {
    BOOL v15 = 0;
    *(void *)(*(void *)(*((void *)this + 5) + 152) + 8 * v4) = 0;
    if (v4 == v5) {
      ++v5;
    }
  }
  unint64_t v4 = v9;
LABEL_34:
  atomic_ullong v17 = (void *)*((void *)this + 5);
  if (v5 < v4)
  {
    v17[2] = v5;
    v17[17] = v4;
    uint64_t v18 = v17[19];
    __dmb(0xBu);
    goto LABEL_37;
  }
  uint64_t v18 = 0;
  v17[2] = 0;
  v17[17] = 0;
  if (v17[1]) {
LABEL_37:
  }
    v17[1] = v18;
  if (!v15 && *((void *)this + 7) == v10) {
    (*(void (**)(unint64_t, void))(*(void *)v10 + 24))(v10, *((unsigned __int16 *)this + 36));
  }
  return v10;
}

unint64_t tbb::internal::generic_scheduler::winnow_task_pool(tbb::internal::generic_scheduler *this, uint64_t a2)
{
  *((unsigned char *)this + 360) = 1;
  unint64_t v4 = (atomic_ullong *)*((void *)this + 5);
  atomic_ullong v5 = v4[1];
  if (v5)
  {
    if (v5 == -1) {
      goto LABEL_8;
    }
    while (1)
    {
      unint64_t v6 = v4[19];
      while (1)
      {
        unint64_t v7 = v6;
        atomic_compare_exchange_strong(v4 + 1, &v7, 0xFFFFFFFFFFFFFFFFLL);
        if (v7 == v6) {
          break;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit(v4 + 1, 0, memory_order_relaxed);
        if (add_explicit != v6)
        {
          unint64_t v6 = add_explicit;
          break;
        }
      }
      unint64_t v4 = (atomic_ullong *)*((void *)this + 5);
      if (v4[19] == v6) {
        break;
      }
      do
      {
LABEL_8:
        sched_yield();
        unint64_t v4 = (atomic_ullong *)*((void *)this + 5);
      }
      while (v4[1] == -1);
    }
  }
  unint64_t v9 = v4[17];
  unint64_t v10 = v4[2];
  if (v10 >= v9)
  {
    unint64_t v11 = 0;
  }
  else
  {
    unint64_t v11 = 0;
    do
    {
      uint64_t v13 = *(void *)(*((void *)this + 5) + 152);
      uint64_t v14 = *(void *)(v13 + 8 * v10);
      if (v14)
      {
        if (*(unsigned char *)(v14 - 11) == 32 || *(void *)(*(void *)(v14 - 56) + 160) >= **((void **)this + 12))
        {
          unint64_t v12 = (void *)(v13 + 8 * v11++);
        }
        else
        {
          *(void *)(v14 - 40) = *((void *)this + 42);
          unint64_t v12 = (void *)((char *)this + 336);
        }
        *unint64_t v12 = v14;
      }
      ++v10;
    }
    while (v9 != v10);
  }
  unint64_t result = tbb::internal::generic_scheduler::get_task_and_activate_task_pool(this, 0, v11, a2);
  *((unsigned char *)this + 360) = 0;
  return result;
}

void sub_21677214C(_Unwind_Exception *a1)
{
  *(unsigned char *)(v1 + 360) = 0;
  _Unwind_Resume(a1);
}

void sub_216772154(_Unwind_Exception *a1)
{
  *(unsigned char *)(v1 + 360) = 0;
  _Unwind_Resume(a1);
}

unint64_t tbb::internal::generic_scheduler::reload_tasks(tbb::internal::generic_scheduler *this, tbb::task **a2, tbb::task ***a3, void *a4, uint64_t a5)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  uint64_t v9 = *((void *)this + 5);
  uint64_t v10 = *(void *)(v9 + 8);
  if (v10)
  {
    while (1)
    {
      if (v10 != -1)
      {
        unint64_t v11 = *(void *)(v9 + 152);
        while (1)
        {
          unint64_t v12 = v11;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v9 + 8), &v12, 0xFFFFFFFFFFFFFFFFLL);
          if (v12 == v11) {
            break;
          }
          unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 0, memory_order_relaxed);
          if (add_explicit != v11)
          {
            unint64_t v11 = add_explicit;
            break;
          }
        }
        if (*(void *)(*((void *)this + 5) + 152) == v11) {
          break;
        }
      }
      sched_yield();
      uint64_t v9 = *((void *)this + 5);
      uint64_t v10 = *(void *)(v9 + 8);
    }
  }
  memset(v48, 0, 512);
  unint64_t v43 = v48;
  unint64_t v14 = 64;
  int64x2_t v44 = vdupq_n_s64(0x40uLL);
  unint64_t v46 = 0;
  uint64_t v47 = 0;
  BOOL v15 = *a2;
  if (*a2)
  {
    int64x2_t v41 = a3;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    unint64_t v14 = 64;
    uint64_t v18 = 64;
    int64x2_t v19 = a2;
    do
    {
      while (*(void *)(*((void *)v15 - 7) + 160) < (uint64_t)a4)
      {
        int64x2_t v19 = (tbb::task **)((char *)v15 - 40);
        BOOL v15 = (tbb::task *)*((void *)v15 - 5);
        if (!v15) {
          goto LABEL_19;
        }
      }
      if (!v18)
      {
        if (!v17)
        {
          unint64_t v46 = 1;
          unint64_t v45 = v43;
          uint64_t v17 = 1;
        }
        v16 += v14;
        uint64_t v47 = v16;
        v14 *= 2;
        v44.i64[0] = v14;
        v44.i64[1] = v14;
        uint64_t v20 = tbb::internal::NFS_Allocate(v14, 8, 0, a4);
        unint64_t v21 = &(&v43)[v17++];
        unint64_t v43 = (unsigned char *)v20;
        unint64_t v46 = v17;
        v21[3] = v20;
        uint64_t v18 = v14;
      }
      v44.i64[1] = --v18;
      *(void *)&v43[8 * v18] = v15;
      unint64_t v22 = (tbb::task *)*((void *)v15 - 5);
      *((void *)v15 - 5) = this;
      *int64x2_t v19 = v22;
      BOOL v15 = v22;
    }
    while (v22);
LABEL_19:
    if (v19 != a2)
    {
      *int64x2_t v19 = 0;
      *int64x2_t v41 = v19;
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v18 = 64;
  }
  *a2 = 0;
LABEL_23:
  unint64_t v23 = v14 + v47 - v18;
  if (v14 + v47 == v18)
  {
    uint64_t v24 = *((void *)this + 5);
    unint64_t v25 = 0;
    if (*(void *)(v24 + 8))
    {
      uint64_t v26 = *(void *)(v24 + 152);
      __dmb(0xBu);
      *(void *)(v24 + 8) = v26;
    }
  }
  else
  {
    unint64_t v27 = sub_216771764((uint64_t)this, (void *)(v14 + v47 - v18), (uint64_t)a3, a4);
    unint64_t v28 = (char *)(*(void *)(*((void *)this + 5) + 152) + 8 * v27);
    memcpy(v28, &v43[8 * v18], 8 * (v14 - v18));
    if (v17 >= 2)
    {
      unint64_t v29 = &v28[8 * (v14 - v18)];
      do
      {
        v14 >>= 1;
        memcpy(v29, (const void *)v44.i64[v17], 8 * v14);
        v29 += 8 * v14;
        --v17;
      }
      while (v17 != 1);
    }
    unint64_t task_and_activate_task_pool = tbb::internal::generic_scheduler::get_task_and_activate_task_pool(this, *(void *)(*((void *)this + 5) + 16), v27 + v23, a5);
    unint64_t v25 = task_and_activate_task_pool;
    if (v23 != 1 || !task_and_activate_task_pool)
    {
      uint64_t v31 = *((void *)this + 6);
      uint64_t v32 = *(void *)(v31 + 216);
      __dmb(0xBu);
      if (v32 != -1)
      {
        while (1)
        {
          uint64_t v33 = v32;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 216), (unint64_t *)&v33, 0xFFFFFFFFFFFFFFFFLL);
          if (v33 == v32) {
            break;
          }
          unint64_t v34 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 216), 0, memory_order_relaxed);
          if (v34 != v32)
          {
            if (v34) {
              goto LABEL_47;
            }
            goto LABEL_38;
          }
        }
        if (v32) {
          goto LABEL_47;
        }
LABEL_38:
        if (v32)
        {
          while (1)
          {
            uint64_t v35 = 0;
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 216), (unint64_t *)&v35, 0xFFFFFFFFFFFFFFFFLL);
            if (!v35) {
              break;
            }
            if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 216), 0, memory_order_relaxed)) {
              goto LABEL_47;
            }
          }
        }
        if (*(unsigned char *)(v31 + 336))
        {
          *(_DWORD *)(v31 + 208) = 0;
          *(unsigned char *)(v31 + 336) = 0;
        }
        else
        {
          char v36 = *(unsigned char *)(v31 + 337);
          __dmb(0xBu);
          if (v36) {
            tbb::internal::market::mandatory_concurrency_disable(*(atomic_ullong **)(v31 + 304), (tbb::internal::arena *)v31);
          }
          tbb::internal::market::adjust_demand(*(void *)(v31 + 304), v31, *(_DWORD *)(v31 + 208));
        }
      }
    }
  }
LABEL_47:
  unint64_t v37 = v46;
  if (v46 >= 2)
  {
    uint64_t v38 = 4;
    do
    {
      tbb::internal::NFS_Free((tbb::internal *)(&v43)[v38], a2);
      unint64_t v39 = v38 - 2;
      ++v38;
    }
    while (v39 < v37);
  }
  return v25;
}

void sub_21677252C(_Unwind_Exception *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_216771AFC((uint64_t)va, a2);
  _Unwind_Resume(a1);
}

void sub_216772548(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_21675DB74(exception_object);
}

unint64_t tbb::internal::generic_scheduler::reload_tasks(tbb::internal::generic_scheduler *this, uint64_t a2)
{
  uint64_t v2 = **((void **)this + 13);
  if (*((void *)this + 44) == v2) {
    return 0;
  }
  if ((*((unsigned char *)this + 74) & 3) == 2
    && (uint64_t v5 = *((void *)this + 6),
        unsigned int v6 = *(_DWORD *)(v5 + 128),
        LODWORD(v5) = *(_DWORD *)(v5 + 132),
        __dmb(0xBu),
        v6 >= v5 >> 12))
  {
    unint64_t v7 = (void **)(*((void *)this + 6) + 136);
  }
  else
  {
    unint64_t v7 = (void **)*((void *)this + 12);
  }
  int v8 = *v7;
  unint64_t v3 = tbb::internal::generic_scheduler::reload_tasks(this, (tbb::task **)this + 42, (tbb::task ***)this + 43, *v7, a2);
  uint64_t v9 = *((void *)this + 42);
  if (v9)
  {
    uint64_t v10 = *((void *)this + 6);
    if (*(void *)(v10 + 264) >= (uint64_t)v8 || !*(_DWORD *)(v10 + 212))
    {
      tbb::internal::market::update_arena_priority(*((void *)this + 15), v10, *(void *)(*(void *)(v9 - 56) + 160));
      uint64_t v11 = *((void *)this + 6);
      __dmb(0xBu);
      uint64_t v12 = *(void *)(v11 + 216);
      __dmb(0xBu);
      if (v12 != -1)
      {
        while (1)
        {
          uint64_t v13 = v12;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v11 + 216), (unint64_t *)&v13, 0xFFFFFFFFFFFFFFFFLL);
          if (v13 == v12) {
            break;
          }
          unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 216), 0, memory_order_relaxed);
          if (add_explicit != v12)
          {
            if (add_explicit) {
              goto LABEL_21;
            }
            goto LABEL_16;
          }
        }
        if (v12) {
          goto LABEL_21;
        }
LABEL_16:
        if (v12)
        {
          while (1)
          {
            uint64_t v15 = 0;
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v11 + 216), (unint64_t *)&v15, 0xFFFFFFFFFFFFFFFFLL);
            if (!v15) {
              break;
            }
            if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 216), 0, memory_order_relaxed)) {
              goto LABEL_21;
            }
          }
        }
        tbb::internal::market::adjust_demand(*(void *)(v11 + 304), v11, *(_DWORD *)(v11 + 208));
      }
    }
  }
LABEL_21:
  *((void *)this + 44) = v2;
  return v3;
}

void *tbb::internal::generic_scheduler::steal_task(tbb::internal::generic_scheduler *this, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)this + 32);
  unsigned int v3 = HIWORD(v2);
  *((_DWORD *)this + 32) = *((_DWORD *)this + 33) - 1640531535 * v2;
  int v4 = *(_DWORD *)(*((void *)this + 6) + 144);
  __dmb(0xBu);
  unint64_t v5 = *((void *)this + 6)
     + ((unint64_t)(v3 % (v4 - 1)) << 8)
     + ((unint64_t)(*((void *)this + 4) <= (unint64_t)(v3 % (v4 - 1))) << 8);
  if (!*(void *)(v5 + 392)) {
    return 0;
  }
  unint64_t v7 = (void *)tbb::internal::generic_scheduler::steal_task_from((uint64_t)this, (atomic_ullong *)(v5 + 384), a2);
  int v8 = v7;
  if (!v7) {
    return v8;
  }
  int v9 = *((unsigned __int8 *)v7 - 11);
  if (v9 == 32)
  {
    uint64_t v10 = v7[1];
    __dmb(0xBu);
    if (v10 != 1)
    {
      while (1)
      {
        uint64_t v11 = v10;
        atomic_compare_exchange_strong(v7 + 1, (unint64_t *)&v11, 2uLL);
        if (v11 == v10) {
          break;
        }
        if (atomic_fetch_add_explicit(v7 + 1, 0, memory_order_relaxed) != v10) {
          goto LABEL_12;
        }
      }
      unint64_t v12 = v10 & 0xFFFFFFFFFFFFFFFCLL;
      if ((v10 & 0xFFFFFFFFFFFFFFFCLL) != 0)
      {
        LOBYTE(v9) = *(unsigned char *)(v12 - 11);
        int v8 = (void *)v12;
        goto LABEL_10;
      }
    }
LABEL_12:
    sub_2167729D0((uint64_t)this, v7);
    return 0;
  }
LABEL_10:
  *((unsigned char *)v8 - 11) = v9 | 0x80;
  if ((v9 & 0xF) != 0)
  {
    *((void *)this + 7) = v8;
    *(v8 - 5) = this;
    (*(void (**)(void *, void))(*v8 + 24))(v8, *((unsigned __int16 *)this + 36));
  }
  return v8;
}

uint64_t tbb::internal::generic_scheduler::steal_task_from(uint64_t a1, atomic_ullong *a2, uint64_t a3)
{
  while (1)
  {
    unint64_t v7 = a2[1];
    if (v7 != -1)
    {
      if (!v7) {
        return 0;
      }
      while (1)
      {
        unint64_t v8 = v7;
        atomic_compare_exchange_strong(a2 + 1, &v8, 0xFFFFFFFFFFFFFFFFLL);
        if (v8 == v7) {
          break;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit(a2 + 1, 0, memory_order_relaxed);
        if (add_explicit != v7) {
          goto LABEL_3;
        }
      }
      unint64_t add_explicit = v7;
LABEL_3:
      if (v7 == add_explicit) {
        break;
      }
    }
    sched_yield();
  }
  atomic_ullong v9 = a2[2];
  a2[2] = v9 + 1;
  __dmb(0xBu);
  if (v9 + 1 <= a2[17])
  {
    char v11 = 0;
    atomic_ullong v12 = v9;
    do
    {
      __dmb(0xBu);
      uint64_t v10 = *(void *)(v7 + 8 * v9);
      if (v10)
      {
        if ((!a3 || *(void *)(v10 - 64) == a3)
          && (*(unsigned char *)(v10 - 11) != 32
           || (~*(_DWORD *)(v10 + 8) & 3) != 0
           || !*(unsigned char *)(*(void *)(v10 + 24) + 20)))
        {
          if ((v11 & 1) == 0) {
            goto LABEL_26;
          }
          *(void *)(v7 + 8 * v9) = 0;
          a2[2] = v12;
          __dmb(0xBu);
          a2[1] = v7;
          goto LABEL_29;
        }
        char v11 = 1;
      }
      else if ((v11 & 1) == 0)
      {
        atomic_ullong v12 = v9 + 1;
      }
      atomic_ullong v13 = v9 + 2;
      a2[2] = v9 + 2;
      __dmb(0xBu);
      ++v9;
    }
    while (v13 <= a2[17]);
    uint64_t v10 = 0;
    a2[2] = v12;
    __dmb(0xBu);
    a2[1] = v7;
    if ((v11 & 1) == 0) {
      return v10;
    }
LABEL_29:
    uint64_t v15 = *(void *)(a1 + 48);
    __dmb(0xBu);
    unint64_t v16 = *(void *)(v15 + 216);
    __dmb(0xBu);
    if (v16 != -1)
    {
      while (1)
      {
        unint64_t v17 = v16;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v15 + 216), &v17, 0xFFFFFFFFFFFFFFFFLL);
        if (v17 == v16) {
          break;
        }
        unint64_t v18 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 216), 0, memory_order_relaxed);
        if (v18 != v16) {
          goto LABEL_34;
        }
      }
      unint64_t v18 = v16;
LABEL_34:
      if (!v18)
      {
        if (v16)
        {
          while (1)
          {
            uint64_t v19 = 0;
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v15 + 216), (unint64_t *)&v19, 0xFFFFFFFFFFFFFFFFLL);
            if (!v19) {
              break;
            }
            if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 216), 0, memory_order_relaxed)) {
              return v10;
            }
          }
        }
        tbb::internal::market::adjust_demand(*(void *)(v15 + 304), v15, *(_DWORD *)(v15 + 208));
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    a2[2] = v9;
LABEL_26:
    __dmb(0xBu);
    a2[1] = v7;
  }
  return v10;
}

uint64_t sub_2167729D0(uint64_t result, void *a2)
{
  *((unsigned char *)a2 - 12) = 4;
  unsigned int v2 = (atomic_ullong *)*(a2 - 6);
  if (v2 == (atomic_ullong *)result)
  {
    *(a2 - 1) = *(void *)(result + 136);
    *(void *)(result + 136) = a2;
    return result;
  }
  if (!v2 || (unint64_t)v2 >= 0x1000)
  {
    if (!v2)
    {
      unsigned int v3 = (tbb::internal *)(a2 - 8);
LABEL_17:
      return tbb::internal::NFS_Free(v3, a2);
    }
    while (1)
    {
      unint64_t v5 = v2[22];
      if (v5 == -1) {
        break;
      }
      *(a2 - 1) = v5;
      while (1)
      {
        unint64_t v6 = v5;
        atomic_compare_exchange_strong(v2 + 22, &v6, (unint64_t)a2);
        if (v6 == v5) {
          break;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit(v2 + 22, 0, memory_order_relaxed);
        if (add_explicit != v5) {
          goto LABEL_7;
        }
      }
      unint64_t add_explicit = v5;
LABEL_7:
      if (v5 == add_explicit) {
        return result;
      }
    }
    unint64_t result = tbb::internal::NFS_Free((tbb::internal *)(a2 - 8), a2);
    if (atomic_fetch_add(v2 + 21, 0xFFFFFFFFFFFFFFFFLL) == 1)
    {
      (*(void (**)(atomic_ullong *))(*v2 + 24))(v2);
      unsigned int v3 = (tbb::internal *)v2;
      goto LABEL_17;
    }
  }
  return result;
}

unint64_t tbb::internal::generic_scheduler::get_mailbox_task(tbb::internal::generic_scheduler *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 8);
  unsigned int v3 = *(void **)v2;
  if (*(void *)v2)
  {
    while (1)
    {
      if (a2)
      {
        unint64_t v7 = (void *)v2;
        if (*(v3 - 8) != a2)
        {
          while (1)
          {
            unint64_t v8 = v3;
            unsigned int v3 = (void *)v3[2];
            if (!v3) {
              return 0;
            }
            if (*(v3 - 8) == a2)
            {
              unint64_t v7 = v8 + 2;
              break;
            }
          }
        }
      }
      else
      {
        unint64_t v7 = (void *)v2;
      }
      __dmb(0xBu);
      uint64_t v10 = v3 + 2;
      uint64_t v9 = v3[2];
      if (v9) {
        goto LABEL_21;
      }
      *unint64_t v7 = 0;
      while (1)
      {
        char v11 = v3 + 2;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v2 + 8), (unint64_t *)&v11, (unint64_t)v7);
        if (v11 == v10) {
          break;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 0, memory_order_relaxed);
        if ((uint64_t *)add_explicit != v10) {
          goto LABEL_17;
        }
      }
      unint64_t add_explicit = (unint64_t)(v3 + 2);
LABEL_17:
      if (v10 != (uint64_t *)add_explicit) {
        break;
      }
LABEL_22:
      atomic_fetch_add((atomic_uint *volatile)(v2 + 16), 0xFFFFFFFF);
      uint64_t v13 = v3[1];
      __dmb(0xBu);
      if (v13 != 2)
      {
        while (1)
        {
          uint64_t v14 = v13;
          atomic_compare_exchange_strong(v3 + 1, (unint64_t *)&v14, 1uLL);
          if (v14 == v13) {
            break;
          }
          if (atomic_fetch_add_explicit(v3 + 1, 0, memory_order_relaxed) != v13) {
            goto LABEL_4;
          }
        }
        unint64_t result = v13 & 0xFFFFFFFFFFFFFFFCLL;
        if ((v13 & 0xFFFFFFFFFFFFFFFCLL) != 0)
        {
          *(unsigned char *)(result - 11) |= 0x80u;
          return result;
        }
      }
LABEL_4:
      sub_2167729D0((uint64_t)this, v3);
      uint64_t v2 = *((void *)this + 8);
      unsigned int v3 = *(void **)v2;
      if (!*(void *)v2) {
        return 0;
      }
    }
    while (1)
    {
      uint64_t v9 = *v10;
      if (*v10) {
        break;
      }
      sched_yield();
    }
LABEL_21:
    *unint64_t v7 = v9;
    goto LABEL_22;
  }
  return 0;
}

uint64_t tbb::internal::generic_scheduler::create_worker(tbb::internal::generic_scheduler *this, tbb::internal::market *a2, uint64_t a3)
{
  int v3 = a3;
  uint64_t SchedulerPtr = tbb::internal::AllocateSchedulerPtr(this, a3);
  uint64_t v6 = SchedulerPtr;
  *(void *)(SchedulerPtr + 32) = a2;
  *(void *)(*(void *)(SchedulerPtr + 144) - 24) = 2;
  *(unsigned char *)(SchedulerPtr + 74) &= ~1u;
  if (v3) {
    *(void *)(SchedulerPtr + 112) = &v8[-(*(void *)(*(void *)(SchedulerPtr + 120) + 208) >> 1)];
  }
  tbb::internal::governor::sign_on(SchedulerPtr);
  return v6;
}

uint64_t tbb::internal::generic_scheduler::create_master(tbb::internal::generic_scheduler *this, tbb::internal::arena *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  uint64_t v6 = tbb::internal::market::global_market(0, 0, 0, a4, a5);
  uint64_t SchedulerPtr = tbb::internal::AllocateSchedulerPtr(v6, 1);
  uint64_t v8 = *(void *)(SchedulerPtr + 144);
  *(unsigned char *)(SchedulerPtr + 74) |= 1u;
  *(void *)(v8 - 24) = 1;
  uint64_t v10 = tbb::internal::NFS_Allocate(1uLL, 256, 0, v9);
  *(_DWORD *)uint64_t v10 = 0;
  *(void *)(v10 + 128) = 65539;
  *(_DWORD *)(v10 + 168) = 55;
  tbb::task_group_context::init(v10, v11, v12, v13);
  *(void *)(v8 - 56) = v10;
  tbb::task_group_context::capture_fp_settings(*(tbb::task_group_context **)(*(void *)(SchedulerPtr + 144) - 56), v14, v15, v16);
  *(void *)(SchedulerPtr + 112) = &v26[-(*(void *)(*(void *)(SchedulerPtr + 120) + 208) >> 1)];
LABEL_2:
  char v17 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
  int v18 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v17);
  unsigned int v19 = v18 | (1 << v17);
  while (1)
  {
    int v20 = v18;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v20, v19);
    if (v20 == v18) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v18)
    {
      sched_yield();
      goto LABEL_2;
    }
  }
  uint64_t v21 = *(void *)(SchedulerPtr + 120);
  *(void *)(SchedulerPtr + 16) = v21 + 224;
  uint64_t v22 = *(void *)(v21 + 240);
  *(void *)(SchedulerPtr + 24) = *(void *)(v21 + 232);
  **(void **)(v21 + 232) = SchedulerPtr + 16;
  *(void *)(v21 + 232) = SchedulerPtr + 16;
  *(void *)(v21 + 240) = v22 + 1;
  __dmb(0xBu);
  LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
  if (this)
  {
    tbb::internal::generic_scheduler::attach_arena(SchedulerPtr, (uint64_t)this, 0, 1);
    **(void **)(SchedulerPtr + 40) = SchedulerPtr;
    *((void *)this + 40) = *(void *)(*(void *)(SchedulerPtr + 144) - 56);
  }
  unint64_t v23 = (tbb::internal *)tbb::internal::governor::sign_on(SchedulerPtr);
  uint64_t v24 = (atomic_ullong *)tbb::internal::the_global_observer_list(v23);
  if (*(void *)(SchedulerPtr + 80) != v24[1]) {
    tbb::internal::observer_list::do_notify_entry_observers(v24, (atomic_ullong *)(SchedulerPtr + 80), 0);
  }
  return SchedulerPtr;
}

uint64_t tbb::internal::generic_scheduler::cleanup_worker(tbb::internal::observer_proxy **this, void *a2)
{
  if (a2)
  {
    int v3 = (atomic_ullong *)tbb::internal::the_global_observer_list((tbb::internal *)this);
    int v4 = this[10];
    if (v4) {
      tbb::internal::observer_list::do_notify_exit_observers(v3, v4, 1);
    }
  }

  return tbb::internal::generic_scheduler::cleanup_scheduler((tbb::internal::generic_scheduler *)this);
}

uint64_t tbb::internal::generic_scheduler::cleanup_master(uint64_t this, uint64_t a2)
{
  int v3 = (tbb::internal::generic_scheduler *)this;
  uint64_t v4 = *(void *)(this + 48);
  unint64_t v5 = *(tbb::internal::market **)(this + 120);
  if (v4)
  {
    uint64_t v6 = *(void *)(this + 40);
    uint64_t v7 = *(void *)(v6 + 8);
    if (v7)
    {
      while (1)
      {
        if (v7 != -1)
        {
          unint64_t v9 = *(void *)(v6 + 152);
          while (1)
          {
            unint64_t v10 = v9;
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v6 + 8), &v10, 0xFFFFFFFFFFFFFFFFLL);
            if (v10 == v9) {
              break;
            }
            unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 0, memory_order_relaxed);
            if (add_explicit != v9)
            {
              unint64_t v9 = add_explicit;
              break;
            }
          }
          uint64_t v8 = (void *)*((void *)v3 + 5);
          if (v8[19] == v9) {
            break;
          }
        }
        this = sched_yield();
        uint64_t v6 = *((void *)v3 + 5);
        uint64_t v7 = *(void *)(v6 + 8);
      }
      if (v8[1] && v8[2] < v8[17])
      {
        __dmb(0xBu);
        v8[1] = v9;
        *(void *)(*((void *)v3 + 18) - 24) = 2;
        this = (*(uint64_t (**)(tbb::internal::generic_scheduler *))(*(void *)v3 + 48))(v3);
      }
      else
      {
        v8[1] = 0;
      }
    }
    uint64_t v15 = (tbb::internal::observer_proxy *)*((void *)v3 + 11);
    if (v15) {
      tbb::internal::observer_list::do_notify_exit_observers((atomic_ullong *)(v4 + 224), v15, 0);
    }
    unint64_t v16 = (atomic_ullong *)tbb::internal::the_global_observer_list((tbb::internal *)this);
    char v17 = (tbb::internal::observer_proxy *)*((void *)v3 + 10);
    if (v17) {
      tbb::internal::observer_list::do_notify_exit_observers(v16, v17, 0);
    }
    int v18 = (void *)*((void *)v3 + 5);
    __dmb(0xBu);
    *int v18 = 0;
  }
  else
  {
    uint64_t v12 = (atomic_ullong *)tbb::internal::the_global_observer_list((tbb::internal *)this);
    uint64_t v13 = (tbb::internal::observer_proxy *)*((void *)v3 + 10);
    if (v13) {
      tbb::internal::observer_list::do_notify_exit_observers(v12, v13, 0);
    }
    tbb::task_group_context::~task_group_context(*(tbb::task_group_context **)(*((void *)v3 + 18) - 56));
    tbb::internal::NFS_Free(*(tbb::internal **)(*((void *)v3 + 18) - 56), v14);
  }
LABEL_23:
  char v19 = 8 * (&tbb::internal::the_context_state_propagation_mutex & 3);
  int v20 = *(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v19);
  unsigned int v21 = v20 | (1 << v19);
  while (1)
  {
    int v22 = v20;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v22, v21);
    if (v22 == v20) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&tbb::internal::the_context_state_propagation_mutex & 0xFFFFFFFFFFFFFFFCLL) != v20)
    {
      sched_yield();
      goto LABEL_23;
    }
  }
  --*(void *)(*((void *)v3 + 15) + 240);
  unint64_t v23 = (void *)*((void *)v3 + 3);
  *unint64_t v23 = *((void *)v3 + 2);
  *(void *)(*((void *)v3 + 2) + 8) = v23;
  __dmb(0xBu);
  LOBYTE(tbb::internal::the_context_state_propagation_mutex) = 0;
  *((void *)v3 + 5) = 0;
  tbb::internal::generic_scheduler::cleanup_scheduler(v3);
  if (v4)
  {
    uint64_t v25 = *(void *)(v4 + 304);
    uint64_t v24 = *(void *)(v4 + 312);
    if (*(_DWORD *)(v4 + 328) != *(_DWORD *)(v4 + 332)
      && !*(_DWORD *)(v25 + 28)
      && !*(unsigned char *)(v4 + 337)
      && (tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4) & 1) == 0
      && (tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4) & 1) == 0)
    {
      tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v4);
    }
    if (atomic_fetch_add((atomic_uint *volatile)(v4 + 132), 0xFFFFFFFF) == 1) {
      tbb::internal::market::try_destroy_arena((atomic_ullong *)v25, (atomic_ullong *)v4, v24);
    }
  }

  return tbb::internal::market::release(v5, v4 != 0, a2);
}

uint64_t sub_216773124(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v5) {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  }

  return sub_21677318C(inited, a2, a3, v6);
}

uint64_t sub_21677318C(tbb::internal::generic_scheduler *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = (tbb::task *)a3;
  sub_21676F178(&v27, a2, a3, a4);
  uint64_t v7 = *((void *)a1 + 7);
  unsigned int v8 = *((unsigned __int8 *)a1 + 74);
  uint64_t v9 = *((void *)a1 + 18);
  BOOL v10 = v9 == a2;
  int v11 = (v7 == v9) & (v8 >> 1);
  if (v11) {
    char v12 = 2;
  }
  else {
    char v12 = 0;
  }
  *((unsigned char *)a1 + 74) = v12 | v8 & 0xFD;
  uint64_t v13 = *((void *)a1 + 12);
  uint64_t v14 = (void *)*((void *)a1 + 13);
  if ((v11 & 1) == 0)
  {
    uint64_t v15 = (void *)(*((void *)a1 + 6) + 272);
    *((void *)a1 + 12) = *(void *)(a2 - 56) + 160;
    *((void *)a1 + 13) = v15;
    if (v15 != v14) {
      *((void *)a1 + 44) = *v15 - 1;
    }
  }
  unint64_t v16 = *(void **)(v7 - 64);
  if (v4 && v16) {
    *((void *)v4 - 8) = v16;
  }
  int v17 = v8 & v10;
  int v18 = (void *)(a2 - 24);
  while ((sub_2167739E4(a1, &v27, v4, v16) & 1) != 0)
  {
    if (*v18 == 1)
    {
      __dmb(0xBu);
LABEL_19:
      *((void *)a1 + 7) = v7;
      *((unsigned char *)a1 + 74) = v8;
      *((void *)a1 + 12) = v13;
      if (*((void **)a1 + 13) != v14) {
        *((void *)a1 + 44) = *v14 - 1;
      }
      *((void *)a1 + 13) = v14;
      uint64_t v20 = *(void *)(a2 - 56);
      if ((*(unsigned char *)(v20 + 130) & 4) == 0)
      {
        if (*v18 != 1) {
          return sub_216770B7C((uint64_t)&v27, v19);
        }
        *int v18 = 0;
      }
      if (*(void *)(v20 + 120))
      {
        unsigned int v21 = *(const std::exception_ptr **)(v20 + 136);
        if ((~*((unsigned __int8 *)a1 + 74) & 3) == 0 && v20 == *(void *)(*((void *)a1 + 18) - 56))
        {
          *(void *)(v20 + 120) = 0;
          *(void *)(v20 + 152) &= ~1uLL;
        }
        if (v21)
        {
          int v22 = (tbb::internal *)v28;
          if (*(void *)v29 != v28->__fpsr || *((void *)v29 + 1) != v28->__fpcr)
          {
            fesetenv(v28);
            int v22 = v29;
            if (!v29)
            {
              int v22 = (tbb::internal *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v24);
              unint64_t v29 = v22;
            }
            *(fenv_t *)int v22 = *v28;
          }
          if (tbb::internal::governor::is_rethrow_broken) {
            tbb::internal::fix_broken_rethrow(v22);
          }
          std::exception_ptr::exception_ptr(&v30, v21);
          v25.__ptr_ = &v30;
          std::rethrow_exception(v25);
          __break(1u);
LABEL_39:
          *((void *)a1 + 7) = v7;
          *((unsigned char *)a1 + 74) = v8;
          *((void *)a1 + 12) = v13;
          if (*((void **)a1 + 13) != v14) {
            *((void *)a1 + 44) = *v14 - 1;
          }
          *((void *)a1 + 13) = v14;
          return sub_216770B7C((uint64_t)&v27, v19);
        }
      }
      return sub_216770B7C((uint64_t)&v27, v19);
    }
    if (*(void *)(*((void *)a1 + 5) + 8))
    {
      uint64_t v4 = (tbb::task *)sub_216773DD4((uint64_t)a1, (uint64_t)v16);
      if (v4) {
        continue;
      }
    }
    if (v17) {
      goto LABEL_39;
    }
    uint64_t v4 = (tbb::task *)(*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, void *))(*(void *)a1 + 56))(a1, a2 - 24, v16);
    if (!v4) {
      goto LABEL_19;
    }
  }
  return sub_216770B7C((uint64_t)&v27, v19);
}

void sub_216773574(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, std::exception_ptr a14)
{
}

unint64_t sub_2167735CC(tbb::internal::generic_scheduler *this, void *a2, uint64_t a3)
{
  char v6 = *((unsigned char *)this + 74);
  unint64_t v7 = *((void *)this + 14);
  uint64_t v8 = *((void *)this + 8);
  if (v8) {
    *(unsigned char *)(v8 + 20) = 1;
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v9 = *(void *)(*((void *)this + 6) + 296);
    __dmb(0xBu);
    if (v9)
    {
      uint64_t v10 = *((void *)this + 6);
      while (1)
      {
        uint64_t v11 = v9;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v10 + 296), (unint64_t *)&v11, 0);
        if (v11 == v9) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 296), 0, memory_order_relaxed) != v9) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *((void *)this + 6);
      if (v9 > *(void *)(v12 + 136)) {
        tbb::internal::market::update_arena_priority(*((void *)this + 15), v12, v9);
      }
    }
  }
LABEL_11:
  int v13 = *(_DWORD *)(*((void *)this + 6) + 144);
  __dmb(0xBu);
  if (*a2 == 1)
  {
LABEL_12:
    unint64_t v14 = 0;
    __dmb(0xBu);
    goto LABEL_13;
  }
  int v16 = 0;
  int v17 = v6 & 3;
  uint64_t v18 = (v13 - 1);
  BOOL v20 = (v6 & 2) == 0 || a3 != 0;
  BOOL v43 = v20;
  int v21 = -1;
  while (1)
  {
    if (v17 == 2)
    {
      uint64_t v25 = *((void *)this + 6);
      unsigned int v26 = *(_DWORD *)(v25 + 128);
      LODWORD(v25) = *(_DWORD *)(v25 + 132);
      __dmb(0xBu);
      if (v26 < v25 >> 12) {
        return 0;
      }
    }
    uint64_t v27 = *(void **)(*((void *)this + 6) + 136);
    if (v18 && **((void **)this + 8))
    {
      mailbox_uint64_t task = (tbb::internal *)tbb::internal::generic_scheduler::get_mailbox_task(this, a3);
      unint64_t v14 = (unint64_t)mailbox_task;
      if (a3 && !mailbox_task)
      {
        uint64_t v29 = *((void *)this + 8);
        if (*(void *)v29 && *(unsigned char *)(v29 + 20)) {
          *(unsigned char *)(v29 + 20) = 0;
        }
        goto LABEL_39;
      }
      if (mailbox_task) {
        goto LABEL_78;
      }
    }
    if (!v43)
    {
      uint64_t v30 = *((void *)this + 6) + 152;
      if (*(void *)(v30 + 8 * (int)v27))
      {
        mailbox_uint64_t task = (tbb::internal *)sub_216774188(v30, v27, (unsigned int *)(*((void *)this + 5) + 128));
        if (mailbox_task) {
          break;
        }
      }
    }
LABEL_39:
    if (*((void *)this + 42))
    {
      mailbox_uint64_t task = (tbb::internal *)tbb::internal::generic_scheduler::reload_tasks(this, a3);
      if (mailbox_task) {
        break;
      }
    }
    if (v7 < (unint64_t)&v45)
    {
      if (v18)
      {
        mailbox_uint64_t task = (tbb::internal *)tbb::internal::generic_scheduler::steal_task(this, a3);
        if (mailbox_task) {
          break;
        }
      }
    }
    if (v21 == -1) {
      int v24 = 0;
    }
    else {
      int v24 = v21;
    }
    sched_yield();
    int v31 = 2 * v18 + 2;
    if (v24 < v31) {
      goto LABEL_25;
    }
    sched_yield();
    uint64_t v22 = *((void *)this + 6);
    if (*(void *)(v22 + 280))
    {
      atomic_fetch_add((atomic_ullong *volatile)(v22 + 288), 1uLL);
      unint64_t v45 = 0;
      uint64_t v32 = *((void *)this + 6);
LABEL_50:
      uint64_t v33 = *(tbb::task **)(v32 + 280);
      while (1)
      {
        unint64_t v34 = v33;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v32 + 280), (unint64_t *)&v34, 0);
        if (v34 == v33) {
          break;
        }
        if ((tbb::task *)atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 280), 0, memory_order_relaxed) != v33)
        {
          sched_yield();
          goto LABEL_50;
        }
      }
      unint64_t v45 = v33;
      if (v33)
      {
        int64x2_t v44 = 0;
        --*((void *)this + 44);
        if ((*((unsigned char *)this + 74) & 3) == 2
          && (uint64_t v35 = *((void *)this + 6),
              unsigned int v36 = *(_DWORD *)(v35 + 128),
              LODWORD(v35) = *(_DWORD *)(v35 + 132),
              __dmb(0xBu),
              v36 >= v35 >> 12))
        {
          unint64_t v37 = (void **)(*((void *)this + 6) + 136);
        }
        else
        {
          unint64_t v37 = (void **)*((void *)this + 12);
        }
        unint64_t v38 = tbb::internal::generic_scheduler::reload_tasks(this, &v45, &v44, *v37, a3);
        unint64_t v14 = v38;
        if (v45)
        {
          unint64_t v39 = v44;
          unsigned int *v44 = (tbb::task *)*((void *)this + 42);
          if (!*((void *)this + 42)) {
            *((void *)this + 43) = v39;
          }
          *((void *)this + 42) = v45;
        }
        if (v38) {
          goto LABEL_13;
        }
      }
      uint64_t v22 = *((void *)this + 6);
    }
    if (v16 >= 10)
    {
      if (v17 == 2)
      {
        if (tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v22)) {
          return 0;
        }
        if (*((void *)this + 42)) {
          --*((void *)this + 44);
        }
        goto LABEL_23;
      }
      if (*(void *)(v22 + 136) <= *(void *)(v22 + 264))
      {
        if (!*((void *)this + 42)) {
          goto LABEL_24;
        }
        --*((void *)this + 44);
      }
      else
      {
        tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v22);
        if (!*((void *)this + 42))
        {
LABEL_23:
          uint64_t v22 = *((void *)this + 6);
          goto LABEL_24;
        }
        --*((void *)this + 44);
        uint64_t v22 = *((void *)this + 6);
      }
      if (**((void **)this + 12) > *(void *)(v22 + 136)) {
        *((void *)this + 12) = v22 + 136;
      }
    }
LABEL_24:
    ++v16;
    int v23 = *(_DWORD *)(v22 + 144);
    __dmb(0xBu);
    uint64_t v18 = (v23 - 1);
    int v24 = v31;
LABEL_25:
    int v21 = v24 + 1;
    if (*a2 == 1) {
      goto LABEL_12;
    }
  }
  unint64_t v14 = (unint64_t)mailbox_task;
LABEL_78:
  uint64_t v40 = *((void *)this + 6);
  if (*((void *)this + 11) != *(void *)(v40 + 232)) {
    tbb::internal::observer_list::do_notify_entry_observers((atomic_ullong *)(v40 + 224), (atomic_ullong *)this + 11, (*((unsigned char *)this + 74) & 1) == 0);
  }
  int64x2_t v41 = (atomic_ullong *)tbb::internal::the_global_observer_list(mailbox_task);
  if (*((void *)this + 10) != v41[1]) {
    tbb::internal::observer_list::do_notify_entry_observers(v41, (atomic_ullong *)this + 10, (*((unsigned char *)this + 74) & 1) == 0);
  }
LABEL_13:
  uint64_t v15 = *((void *)this + 8);
  if (v15 && *(unsigned char *)(v15 + 20)) {
    *(unsigned char *)(v15 + 20) = 0;
  }
  return v14;
}

uint64_t sub_2167739E4(tbb::internal::generic_scheduler *this, void *a2, tbb::task *a3, void *a4)
{
  if (!a3) {
    return 1;
  }
  unint64_t v5 = a3;
  uint64_t v8 = (unsigned int *)((char *)this + 128);
  while (1)
  {
    uint64_t v9 = *((void *)v5 - 7);
    uint64_t v10 = *(void *)(v9 + 160);
    if (v10 == **((void **)this + 12) || (*((unsigned char *)v5 - 11) & 0x10) != 0) {
      goto LABEL_20;
    }
    uint64_t v11 = *((void *)this + 6);
    if (v10 != *(void *)(v11 + 136)) {
      tbb::internal::market::update_arena_priority(*((void *)this + 15), v11, *(void *)(v9 + 160));
    }
    if ((*((unsigned char *)this + 74) & 3) == 2
      && (uint64_t v12 = *((void *)this + 6),
          unsigned int v13 = *(_DWORD *)(v12 + 128),
          LODWORD(v12) = *(_DWORD *)(v12 + 132),
          __dmb(0xBu),
          v13 >= v12 >> 12))
    {
      unint64_t v14 = (void *)(*((void *)this + 6) + 136);
    }
    else
    {
      unint64_t v14 = (void *)*((void *)this + 12);
    }
    if (v10 >= *v14)
    {
      uint64_t v9 = *((void *)v5 - 7);
LABEL_20:
      *((void *)this + 7) = v5;
      *((void *)v5 - 5) = this;
      *((unsigned char *)v5 - 12) = 0;
      uint64_t v17 = *(void *)(v9 + 112);
      uint64_t v18 = a2[2];
      if (*(void *)v17 != *(void *)v18 || *(void *)(v17 + 8) != *(void *)(v18 + 8))
      {
        if (!v18)
        {
          uint64_t v18 = tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
          a2[2] = v18;
          uint64_t v17 = *(void *)(v9 + 112);
        }
        *(_OWORD *)uint64_t v18 = *(_OWORD *)v17;
        fesetenv((const fenv_t *)a2[2]);
      }
      if (*a2 != v9) {
        *a2 = v9;
      }
      if (*(void *)(*((void *)v5 - 7) + 120))
      {
        unint64_t v16 = 0;
      }
      else
      {
        uint64_t v20 = (*(uint64_t (**)(tbb::task *))(*(void *)v5 + 16))(v5);
        unint64_t v16 = v20;
        if (v20)
        {
          *(unsigned char *)(v20 - 11) &= 0x6Fu;
          *(void *)(v20 - 64) = *((void *)v5 - 8);
        }
      }
      switch(*((unsigned char *)v5 - 12))
      {
        case 0:
          int v21 = (tbb::task *)*((void *)v5 - 4);
          (**(void (***)(tbb::task *))v5)(v5);
          if (v21)
          {
            uint64_t v23 = *((void *)v5 - 8);
            if ((uint64_t)atomic_fetch_add((atomic_ullong *volatile)v21 - 3, 0xFFFFFFFFFFFFFFFFLL) <= 1)
            {
              __dmb(0xBu);
              if (v23) {
                *((void *)v21 - 8) = v23;
              }
              if (*((unsigned char *)v21 - 12) == 6)
              {
                tbb::internal::arena::enqueue_task(*((void **)this + 6), (uint64_t)v21, 0, v8);
              }
              else if (v16)
              {
                tbb::internal::generic_scheduler::local_spawn(this, v21, (tbb::task **)v21 - 1, v22);
              }
              else
              {
                unint64_t v16 = (unint64_t)v21;
              }
            }
          }
          sub_2167729D0((uint64_t)this, v5);
          goto LABEL_4;
        case 1:
          *((unsigned char *)v5 - 12) = 3;
          *((unsigned char *)v5 - 11) &= 0x6Fu;
          goto LABEL_48;
        case 3:
          *((unsigned char *)v5 - 11) &= 0x6Fu;
          goto LABEL_4;
        case 5:
          *((unsigned char *)v5 - 12) = 3;
          goto LABEL_42;
        case 6:
LABEL_42:
          *((unsigned char *)v5 - 11) &= 0x6Fu;
          uint64_t v24 = *((void *)v5 - 8);
          if ((uint64_t)atomic_fetch_add((atomic_ullong *volatile)v5 - 3, 0xFFFFFFFFFFFFFFFFLL) <= 1)
          {
            __dmb(0xBu);
            if (v24) {
              *((void *)v5 - 8) = v24;
            }
            if (*((unsigned char *)v5 - 12) == 6)
            {
              tbb::internal::arena::enqueue_task(*((void **)this + 6), (uint64_t)v5, 0, v8);
            }
            else if (v16)
            {
LABEL_48:
              tbb::internal::generic_scheduler::local_spawn(this, v5, (tbb::task **)v5 - 1, a4);
            }
            else
            {
              unint64_t v16 = (unint64_t)v5;
            }
          }
          break;
        default:
          goto LABEL_4;
      }
      goto LABEL_4;
    }
    uint64_t v15 = *((void *)this + 42);
    if (!v15)
    {
      *((void *)this + 43) = (char *)v5 - 40;
      *((void *)v5 - 5) = 0;
      uint64_t v15 = *((void *)this + 42);
    }
    *((void *)v5 - 5) = v15;
    *((void *)this + 42) = v5;
    if (!*(void *)(*((void *)this + 5) + 8)) {
      break;
    }
    unint64_t v16 = tbb::internal::generic_scheduler::winnow_task_pool(this, (uint64_t)a4);
    if (!v16) {
      return 1;
    }
LABEL_4:
    unint64_t v5 = (tbb::task *)v16;
    if (!v16) {
      return 1;
    }
  }
  uint64_t v25 = *((void *)this + 6);
  __dmb(0xBu);
  unint64_t v26 = *(void *)(v25 + 216);
  __dmb(0xBu);
  if (v26 != -1)
  {
    while (1)
    {
      unint64_t v27 = v26;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v25 + 216), &v27, 0xFFFFFFFFFFFFFFFFLL);
      if (v27 == v26) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 216), 0, memory_order_relaxed);
      if (add_explicit != v26) {
        goto LABEL_59;
      }
    }
    unint64_t add_explicit = v26;
LABEL_59:
    if (!add_explicit)
    {
      if (v26)
      {
        while (1)
        {
          uint64_t v29 = 0;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v25 + 216), (unint64_t *)&v29, 0xFFFFFFFFFFFFFFFFLL);
          if (!v29) {
            break;
          }
          if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 216), 0, memory_order_relaxed)) {
            return 1;
          }
        }
      }
      tbb::internal::market::adjust_demand(*(void *)(v25 + 304), v25, *(_DWORD *)(v25 + 208));
    }
  }
  return 1;
}

void *sub_216773DD4(uint64_t a1, uint64_t a2)
{
  int v4 = 0;
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 136);
  uint64_t v6 = -1;
  unint64_t v32 = v5;
  do
  {
    *(void *)(*(void *)(a1 + 40) + 136) = --v5;
    __dmb(0xBu);
    unint64_t v7 = *(atomic_ullong **)(a1 + 40);
    if (v7[2] <= v5) {
      goto LABEL_18;
    }
    atomic_ullong v8 = v7[1];
    if (v8)
    {
      while (1)
      {
        if (v8 != -1)
        {
          unint64_t v10 = v7[19];
          while (1)
          {
            unint64_t v11 = v10;
            atomic_compare_exchange_strong(v7 + 1, &v11, 0xFFFFFFFFFFFFFFFFLL);
            if (v11 == v10) {
              break;
            }
            unint64_t add_explicit = atomic_fetch_add_explicit(v7 + 1, 0, memory_order_relaxed);
            if (add_explicit != v10)
            {
              unint64_t v10 = add_explicit;
              break;
            }
          }
          unint64_t v7 = *(atomic_ullong **)(a1 + 40);
          if (v7[19] == v10) {
            break;
          }
        }
        sched_yield();
        unint64_t v7 = *(atomic_ullong **)(a1 + 40);
        atomic_ullong v8 = v7[1];
      }
    }
    uint64_t v6 = v7[2];
    if (v6 > v5)
    {
      unint64_t v14 = 0;
      v7[17] = 0;
      v7[2] = 0;
      v7[1] = 0;
      if (!v4) {
        return v14;
      }
      goto LABEL_42;
    }
    if (v6 == v5)
    {
      v7[17] = 0;
      v7[2] = 0;
      int v9 = 1;
      uint64_t v6 = v5;
      v7[1] = 0;
      goto LABEL_19;
    }
    if (v7[1])
    {
      int v9 = 0;
      atomic_ullong v13 = v7[19];
      __dmb(0xBu);
      v7[1] = v13;
    }
    else
    {
LABEL_18:
      int v9 = 0;
    }
LABEL_19:
    __dmb(0xBu);
    unint64_t v14 = *(void **)(*(void *)(*(void *)(a1 + 40) + 152) + 8 * v5);
    if (v14)
    {
      if (a2 && *(v14 - 8) != a2)
      {
        int v4 = 1;
      }
      else
      {
        if (*((unsigned char *)v14 - 11) != 32) {
          goto LABEL_34;
        }
        uint64_t v15 = v14[1];
        __dmb(0xBu);
        if (v15 != 1)
        {
          while (1)
          {
            uint64_t v16 = v15;
            atomic_compare_exchange_strong(v14 + 1, (unint64_t *)&v16, 2uLL);
            if (v16 == v15) {
              break;
            }
            if (atomic_fetch_add_explicit(v14 + 1, 0, memory_order_relaxed) != v15) {
              goto LABEL_31;
            }
          }
          unint64_t v17 = v15 & 0xFFFFFFFFFFFFFFFCLL;
          if ((v15 & 0xFFFFFFFFFFFFFFFCLL) != 0)
          {
            *(void *)(a1 + 56) = v17;
            if (!v4)
            {
              (*(void (**)(unint64_t, void))(*(void *)v17 + 24))(v17, *(unsigned __int16 *)(a1 + 72));
              return (void *)v17;
            }
            unint64_t v14 = (void *)(v15 & 0xFFFFFFFFFFFFFFFCLL);
            if (v9) {
              goto LABEL_42;
            }
LABEL_36:
            *(void *)(*(void *)(*(void *)(a1 + 40) + 152) + 8 * v5) = 0;
            uint64_t v18 = *(void *)(a1 + 40);
            __dmb(0xBu);
            *(void *)(v18 + 136) = v32;
            uint64_t v19 = *(void *)(a1 + 48);
            __dmb(0xBu);
            uint64_t v20 = *(void *)(v19 + 216);
            __dmb(0xBu);
            if (v20 == -1) {
              goto LABEL_62;
            }
            while (1)
            {
              uint64_t v21 = v20;
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v19 + 216), (unint64_t *)&v21, 0xFFFFFFFFFFFFFFFFLL);
              if (v21 == v20) {
                break;
              }
              unint64_t v22 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 216), 0, memory_order_relaxed);
              if (v22 != v20)
              {
                if (v22) {
                  goto LABEL_62;
                }
                goto LABEL_52;
              }
            }
            if (v20) {
              goto LABEL_62;
            }
LABEL_52:
            if (v20)
            {
              while (1)
              {
                uint64_t v29 = 0;
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v19 + 216), (unint64_t *)&v29, 0xFFFFFFFFFFFFFFFFLL);
                if (!v29) {
                  break;
                }
                if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 216), 0, memory_order_relaxed)) {
                  goto LABEL_62;
                }
              }
            }
LABEL_61:
            tbb::internal::market::adjust_demand(*(void *)(v19 + 304), v19, *(_DWORD *)(v19 + 208));
            goto LABEL_62;
          }
        }
LABEL_31:
        sub_2167729D0(a1, v14);
        if (!v4)
        {
LABEL_2:
          int v4 = 0;
          unint64_t v32 = v5;
          continue;
        }
        *(void *)(*(void *)(*(void *)(a1 + 40) + 152) + 8 * v5) = 0;
      }
    }
    else if (!v4)
    {
      goto LABEL_2;
    }
  }
  while (!v9);
  unint64_t v14 = 0;
LABEL_34:
  if (!v4) {
    return v14;
  }
  if (!v9) {
    goto LABEL_36;
  }
LABEL_42:
  if (v14) {
    unint64_t v23 = v6 + 1;
  }
  else {
    unint64_t v23 = v6;
  }
  if (v23 < v32)
  {
    uint64_t v24 = *(void **)(a1 + 40);
    v24[2] = v23;
    v24[17] = v32;
    uint64_t v25 = v24[19];
    __dmb(0xBu);
    v24[1] = v25;
    uint64_t v19 = *(void *)(a1 + 48);
    __dmb(0xBu);
    uint64_t v26 = *(void *)(v19 + 216);
    __dmb(0xBu);
    if (v26 != -1)
    {
      while (1)
      {
        uint64_t v27 = v26;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v19 + 216), (unint64_t *)&v27, 0xFFFFFFFFFFFFFFFFLL);
        if (v27 == v26) {
          break;
        }
        unint64_t v28 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 216), 0, memory_order_relaxed);
        if (v28 != v26)
        {
          if (v28) {
            goto LABEL_62;
          }
          goto LABEL_57;
        }
      }
      if (v26) {
        goto LABEL_62;
      }
LABEL_57:
      if (v26)
      {
        while (1)
        {
          uint64_t v30 = 0;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v19 + 216), (unint64_t *)&v30, 0xFFFFFFFFFFFFFFFFLL);
          if (!v30) {
            break;
          }
          if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 216), 0, memory_order_relaxed)) {
            goto LABEL_62;
          }
        }
      }
      goto LABEL_61;
    }
  }
LABEL_62:
  if (*(void **)(a1 + 56) == v14) {
    (*(void (**)(void *, void))(*v14 + 24))(v14, *(unsigned __int16 *)(a1 + 72));
  }
  return v14;
}

uint64_t sub_216774188(uint64_t a1, void *a2, unsigned int *a3)
{
  unsigned int v3 = (*(_DWORD *)(a1 + 48) - 1) & (*a3 + 1);
  uint64_t v4 = *(void *)(a1 + 8 * (int)a2);
  if (!v4)
  {
    uint64_t v13 = 0;
    goto LABEL_20;
  }
  uint64_t v22 = (int)a2;
  uint64_t v20 = a3;
  uint64_t v21 = (void *)(a1 + 8 * (int)a2 + 24);
  while (((1 << v3) & v4) == 0)
  {
LABEL_3:
    unsigned int v3 = (*(_DWORD *)(a1 + 48) - 1) & (v3 + 1);
    uint64_t v4 = *(void *)(a1 + 8 * v22);
    if (!v4)
    {
      uint64_t v13 = 0;
      goto LABEL_19;
    }
  }
  uint64_t v6 = (void *)(*v21 + ((unint64_t)v3 << 7));
  unint64_t v7 = v6 + 6;
  atomic_ullong v8 = (atomic_uint *)((unint64_t)(v6 + 6) & 0xFFFFFFFFFFFFFFFCLL);
  int v9 = 255 << (8 * (((_BYTE)v6 + 48) & 3));
LABEL_6:
  int v10 = *v8 & ~v9;
  while (1)
  {
    int v11 = v10;
    atomic_compare_exchange_strong(v8, (unsigned int *)&v11, v10 | (1 << (8 * (((_BYTE)v6 + 48) & 3))));
    if (v11 == v10) {
      break;
    }
    if (*v8 != v10)
    {
      if ((*v8 & v9) != 0) {
        goto LABEL_3;
      }
      sched_yield();
      goto LABEL_6;
    }
  }
  uint64_t v12 = v6[5];
  if (!v12)
  {
    __dmb(0xBu);
    *unint64_t v7 = 0;
    goto LABEL_3;
  }
  unint64_t v14 = (uint64_t *)v6[1];
  uint64_t v13 = *(void *)(*(uint64_t *)((char *)v14 + ((v6[4] >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v6[4] & 0x1FFLL));
  uint64_t v15 = v12 - 1;
  unint64_t v16 = v6[4] + 1;
  v6[4] = v16;
  v6[5] = v15;
  if (v16 >= 0x400)
  {
    tbb::internal::deallocate_via_handler_v3(*v14, a2);
    v6[1] += 8;
    uint64_t v15 = v6[5];
    v6[4] -= 512;
  }
  if (!v15)
  {
LABEL_21:
    uint64_t v18 = *(void *)(a1 + 8 * v22);
    while (1)
    {
      uint64_t v19 = v18;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 8 * v22), (unint64_t *)&v19, v18 & ~(1 << v3));
      if (v19 == v18) {
        break;
      }
      if (atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 8 * v22), 0, memory_order_relaxed) != v18)
      {
        sched_yield();
        goto LABEL_21;
      }
    }
  }
  __dmb(0xBu);
  *unint64_t v7 = 0;
LABEL_19:
  a3 = v20;
LABEL_20:
  *a3 = v3;
  return v13;
}

void sub_21677435C(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t sub_21677436C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS);
  if (v5) {
    unint64_t inited = (tbb::internal::generic_scheduler *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t inited = (tbb::internal::generic_scheduler *)tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
  }

  return sub_2167743D4(inited, a2, a3, v6);
}

uint64_t sub_2167743D4(tbb::internal::generic_scheduler *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = (tbb::task *)a3;
  sub_21676F178(&v27, a2, a3, a4);
  uint64_t v7 = *((void *)a1 + 7);
  unsigned int v8 = *((unsigned __int8 *)a1 + 74);
  uint64_t v9 = *((void *)a1 + 18);
  BOOL v10 = v9 == a2;
  int v11 = (v7 == v9) & (v8 >> 1);
  if (v11) {
    char v12 = 2;
  }
  else {
    char v12 = 0;
  }
  *((unsigned char *)a1 + 74) = v12 | v8 & 0xFD;
  uint64_t v13 = *((void *)a1 + 12);
  unint64_t v14 = (void *)*((void *)a1 + 13);
  if ((v11 & 1) == 0)
  {
    uint64_t v15 = (void *)(*((void *)a1 + 6) + 272);
    *((void *)a1 + 12) = *(void *)(a2 - 56) + 160;
    *((void *)a1 + 13) = v15;
    if (v15 != v14) {
      *((void *)a1 + 44) = *v15 - 1;
    }
  }
  unint64_t v16 = *(void **)(v7 - 64);
  if (v4 && v16) {
    *((void *)v4 - 8) = v16;
  }
  int v17 = v8 & v10;
  uint64_t v18 = (void *)(a2 - 24);
  while ((sub_216774C24(a1, (uint64_t)&v27, v4, v16) & 1) != 0)
  {
    if (*v18 == 1)
    {
      __dmb(0xBu);
LABEL_19:
      *((void *)a1 + 7) = v7;
      *((unsigned char *)a1 + 74) = v8;
      *((void *)a1 + 12) = v13;
      if (*((void **)a1 + 13) != v14) {
        *((void *)a1 + 44) = *v14 - 1;
      }
      *((void *)a1 + 13) = v14;
      uint64_t v20 = *(void *)(a2 - 56);
      if ((*(unsigned char *)(v20 + 130) & 4) == 0)
      {
        if (*v18 != 1) {
          return sub_216770B7C((uint64_t)&v27, v19);
        }
        *uint64_t v18 = 0;
      }
      if (*(void *)(v20 + 120))
      {
        uint64_t v21 = *(const std::exception_ptr **)(v20 + 136);
        if ((~*((unsigned __int8 *)a1 + 74) & 3) == 0 && v20 == *(void *)(*((void *)a1 + 18) - 56))
        {
          *(void *)(v20 + 120) = 0;
          *(void *)(v20 + 152) &= ~1uLL;
        }
        if (v21)
        {
          uint64_t v22 = (tbb::internal *)v28;
          if (*(void *)v29 != v28->__fpsr || *((void *)v29 + 1) != v28->__fpcr)
          {
            fesetenv(v28);
            uint64_t v22 = v29;
            if (!v29)
            {
              uint64_t v22 = (tbb::internal *)tbb::internal::NFS_Allocate(1uLL, 16, 0, v24);
              uint64_t v29 = v22;
            }
            *(fenv_t *)uint64_t v22 = *v28;
          }
          if (tbb::internal::governor::is_rethrow_broken) {
            tbb::internal::fix_broken_rethrow(v22);
          }
          std::exception_ptr::exception_ptr(&v30, v21);
          v25.__ptr_ = &v30;
          std::rethrow_exception(v25);
          __break(1u);
LABEL_39:
          *((void *)a1 + 7) = v7;
          *((unsigned char *)a1 + 74) = v8;
          *((void *)a1 + 12) = v13;
          if (*((void **)a1 + 13) != v14) {
            *((void *)a1 + 44) = *v14 - 1;
          }
          *((void *)a1 + 13) = v14;
          return sub_216770B7C((uint64_t)&v27, v19);
        }
      }
      return sub_216770B7C((uint64_t)&v27, v19);
    }
    if (*(void *)(*((void *)a1 + 5) + 8))
    {
      uint64_t v4 = (tbb::task *)sub_216773DD4((uint64_t)a1, (uint64_t)v16);
      if (v4) {
        continue;
      }
    }
    if (v17) {
      goto LABEL_39;
    }
    uint64_t v4 = (tbb::task *)(*(uint64_t (**)(tbb::internal::generic_scheduler *, uint64_t, void *))(*(void *)a1 + 56))(a1, a2 - 24, v16);
    if (!v4) {
      goto LABEL_19;
    }
  }
  return sub_216770B7C((uint64_t)&v27, v19);
}

void sub_2167747BC(_Unwind_Exception *a1, void *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, std::exception_ptr a14)
{
}

unint64_t sub_216774814(tbb::internal::generic_scheduler *this, void *a2, uint64_t a3)
{
  char v6 = *((unsigned char *)this + 74);
  unint64_t v7 = *((void *)this + 14);
  uint64_t v8 = *((void *)this + 8);
  if (v8) {
    *(unsigned char *)(v8 + 20) = 1;
  }
  if ((v6 & 2) != 0)
  {
    uint64_t v9 = *(void *)(*((void *)this + 6) + 296);
    __dmb(0xBu);
    if (v9)
    {
      uint64_t v10 = *((void *)this + 6);
      while (1)
      {
        uint64_t v11 = v9;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v10 + 296), (unint64_t *)&v11, 0);
        if (v11 == v9) {
          break;
        }
        if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 296), 0, memory_order_relaxed) != v9) {
          goto LABEL_11;
        }
      }
      uint64_t v12 = *((void *)this + 6);
      if (v9 > *(void *)(v12 + 136)) {
        tbb::internal::market::update_arena_priority(*((void *)this + 15), v12, v9);
      }
    }
  }
LABEL_11:
  int v13 = *(_DWORD *)(*((void *)this + 6) + 144);
  __dmb(0xBu);
  if (*a2 == 1)
  {
LABEL_12:
    unint64_t v14 = 0;
    __dmb(0xBu);
    goto LABEL_13;
  }
  int v16 = 0;
  int v17 = 0;
  int v18 = v6 & 3;
  uint64_t v19 = (v13 - 1);
  BOOL v21 = (v6 & 2) == 0 || a3 != 0;
  BOOL v42 = v21;
  while (1)
  {
    if (v18 == 2)
    {
      uint64_t v24 = *((void *)this + 6);
      unsigned int v25 = *(_DWORD *)(v24 + 128);
      LODWORD(v24) = *(_DWORD *)(v24 + 132);
      __dmb(0xBu);
      if (v25 < v24 >> 12) {
        return 0;
      }
    }
    uint64_t v26 = *(void **)(*((void *)this + 6) + 136);
    if (v19 && **((void **)this + 8))
    {
      mailbox_uint64_t task = (tbb::internal *)tbb::internal::generic_scheduler::get_mailbox_task(this, a3);
      unint64_t v14 = (unint64_t)mailbox_task;
      if (a3 && !mailbox_task)
      {
        uint64_t v28 = *((void *)this + 8);
        if (*(void *)v28 && *(unsigned char *)(v28 + 20)) {
          *(unsigned char *)(v28 + 20) = 0;
        }
        goto LABEL_39;
      }
      if (mailbox_task) {
        goto LABEL_75;
      }
    }
    if (!v42)
    {
      uint64_t v29 = *((void *)this + 6) + 152;
      if (*(void *)(v29 + 8 * (int)v26))
      {
        mailbox_uint64_t task = (tbb::internal *)sub_216774188(v29, v26, (unsigned int *)(*((void *)this + 5) + 128));
        if (mailbox_task) {
          break;
        }
      }
    }
LABEL_39:
    if (*((void *)this + 42))
    {
      mailbox_uint64_t task = (tbb::internal *)tbb::internal::generic_scheduler::reload_tasks(this, a3);
      if (mailbox_task) {
        break;
      }
    }
    if (v7 < (unint64_t)&v44)
    {
      if (v19)
      {
        mailbox_uint64_t task = (tbb::internal *)tbb::internal::generic_scheduler::steal_task(this, a3);
        if (mailbox_task) {
          break;
        }
      }
    }
    sched_yield();
    int v30 = 2 * v19 + 2;
    if (v16 < v30) {
      goto LABEL_25;
    }
    sched_yield();
    uint64_t v22 = *((void *)this + 6);
    if (*(void *)(v22 + 280))
    {
      atomic_fetch_add((atomic_ullong *volatile)(v22 + 288), 1uLL);
      int64x2_t v44 = 0;
      uint64_t v31 = *((void *)this + 6);
LABEL_47:
      unint64_t v32 = *(tbb::task **)(v31 + 280);
      while (1)
      {
        uint64_t v33 = v32;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 280), (unint64_t *)&v33, 0);
        if (v33 == v32) {
          break;
        }
        if ((tbb::task *)atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 280), 0, memory_order_relaxed) != v32)
        {
          sched_yield();
          goto LABEL_47;
        }
      }
      int64x2_t v44 = v32;
      if (v32)
      {
        BOOL v43 = 0;
        --*((void *)this + 44);
        if ((*((unsigned char *)this + 74) & 3) == 2
          && (uint64_t v34 = *((void *)this + 6),
              unsigned int v35 = *(_DWORD *)(v34 + 128),
              LODWORD(v34) = *(_DWORD *)(v34 + 132),
              __dmb(0xBu),
              v35 >= v34 >> 12))
        {
          unsigned int v36 = (void **)(*((void *)this + 6) + 136);
        }
        else
        {
          unsigned int v36 = (void **)*((void *)this + 12);
        }
        unint64_t v37 = tbb::internal::generic_scheduler::reload_tasks(this, &v44, &v43, *v36, a3);
        unint64_t v14 = v37;
        if (v44)
        {
          unint64_t v38 = v43;
          *BOOL v43 = (tbb::task *)*((void *)this + 42);
          if (!*((void *)this + 42)) {
            *((void *)this + 43) = v38;
          }
          *((void *)this + 42) = v44;
        }
        if (v37) {
          goto LABEL_13;
        }
      }
      uint64_t v22 = *((void *)this + 6);
    }
    if (v17 >= 10)
    {
      if (v18 == 2)
      {
        if (tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v22)) {
          return 0;
        }
        if (*((void *)this + 42)) {
          --*((void *)this + 44);
        }
        goto LABEL_23;
      }
      if (*(void *)(v22 + 136) <= *(void *)(v22 + 264))
      {
        if (!*((void *)this + 42)) {
          goto LABEL_24;
        }
        --*((void *)this + 44);
      }
      else
      {
        tbb::internal::arena::is_out_of_work((tbb::internal::arena *)v22);
        if (!*((void *)this + 42))
        {
LABEL_23:
          uint64_t v22 = *((void *)this + 6);
          goto LABEL_24;
        }
        --*((void *)this + 44);
        uint64_t v22 = *((void *)this + 6);
      }
      if (**((void **)this + 12) > *(void *)(v22 + 136)) {
        *((void *)this + 12) = v22 + 136;
      }
    }
LABEL_24:
    ++v17;
    int v23 = *(_DWORD *)(v22 + 144);
    __dmb(0xBu);
    uint64_t v19 = (v23 - 1);
    int v16 = v30;
LABEL_25:
    ++v16;
    if (*a2 == 1) {
      goto LABEL_12;
    }
  }
  unint64_t v14 = (unint64_t)mailbox_task;
LABEL_75:
  uint64_t v39 = *((void *)this + 6);
  if (*((void *)this + 11) != *(void *)(v39 + 232)) {
    tbb::internal::observer_list::do_notify_entry_observers((atomic_ullong *)(v39 + 224), (atomic_ullong *)this + 11, (*((unsigned char *)this + 74) & 1) == 0);
  }
  uint64_t v40 = (atomic_ullong *)tbb::internal::the_global_observer_list(mailbox_task);
  if (*((void *)this + 10) != v40[1]) {
    tbb::internal::observer_list::do_notify_entry_observers(v40, (atomic_ullong *)this + 10, (*((unsigned char *)this + 74) & 1) == 0);
  }
LABEL_13:
  uint64_t v15 = *((void *)this + 8);
  if (v15 && *(unsigned char *)(v15 + 20)) {
    *(unsigned char *)(v15 + 20) = 0;
  }
  return v14;
}

uint64_t sub_216774C24(tbb::internal::generic_scheduler *this, uint64_t a2, tbb::task *a3, void *a4)
{
  if (!a3) {
    return 1;
  }
  unint64_t v5 = a3;
  uint64_t v8 = (unsigned int *)((char *)this + 128);
  while (1)
  {
    uint64_t v9 = (void *)*((void *)v5 - 7);
    uint64_t v10 = v9[20];
    if (v10 == **((void **)this + 12) || (*((unsigned char *)v5 - 11) & 0x10) != 0) {
      goto LABEL_20;
    }
    uint64_t v11 = *((void *)this + 6);
    if (v10 != *(void *)(v11 + 136)) {
      tbb::internal::market::update_arena_priority(*((void *)this + 15), v11, v9[20]);
    }
    if ((*((unsigned char *)this + 74) & 3) == 2
      && (uint64_t v12 = *((void *)this + 6),
          unsigned int v13 = *(_DWORD *)(v12 + 128),
          LODWORD(v12) = *(_DWORD *)(v12 + 132),
          __dmb(0xBu),
          v13 >= v12 >> 12))
    {
      unint64_t v14 = (void *)(*((void *)this + 6) + 136);
    }
    else
    {
      unint64_t v14 = (void *)*((void *)this + 12);
    }
    if (v10 >= *v14)
    {
      uint64_t v9 = (void *)*((void *)v5 - 7);
LABEL_20:
      *((void *)this + 7) = v5;
      *((void *)v5 - 5) = this;
      *((unsigned char *)v5 - 12) = 0;
      uint64_t v17 = v9[14];
      uint64_t v18 = *(void *)(a2 + 16);
      if (*(void *)v17 != *(void *)v18 || *(void *)(v17 + 8) != *(void *)(v18 + 8))
      {
        if (!v18)
        {
          uint64_t v18 = tbb::internal::NFS_Allocate(1uLL, 16, 0, a4);
          *(void *)(a2 + 16) = v18;
          uint64_t v17 = v9[14];
        }
        *(_OWORD *)uint64_t v18 = *(_OWORD *)v17;
        fesetenv(*(const fenv_t **)(a2 + 16));
        uint64_t v9 = (void *)*((void *)v5 - 7);
      }
      if (v9[15])
      {
        unint64_t v16 = 0;
      }
      else
      {
        uint64_t v20 = (*(uint64_t (**)(tbb::task *))(*(void *)v5 + 16))(v5);
        unint64_t v16 = v20;
        if (v20)
        {
          *(unsigned char *)(v20 - 11) &= 0x6Fu;
          *(void *)(v20 - 64) = *((void *)v5 - 8);
        }
      }
      switch(*((unsigned char *)v5 - 12))
      {
        case 0:
          BOOL v21 = (tbb::task *)*((void *)v5 - 4);
          (**(void (***)(tbb::task *))v5)(v5);
          if (v21)
          {
            uint64_t v23 = *((void *)v5 - 8);
            if ((uint64_t)atomic_fetch_add((atomic_ullong *volatile)v21 - 3, 0xFFFFFFFFFFFFFFFFLL) <= 1)
            {
              __dmb(0xBu);
              if (v23) {
                *((void *)v21 - 8) = v23;
              }
              if (*((unsigned char *)v21 - 12) == 6)
              {
                tbb::internal::arena::enqueue_task(*((void **)this + 6), (uint64_t)v21, 0, v8);
              }
              else if (v16)
              {
                tbb::internal::generic_scheduler::local_spawn(this, v21, (tbb::task **)v21 - 1, v22);
              }
              else
              {
                unint64_t v16 = (unint64_t)v21;
              }
            }
          }
          sub_2167729D0((uint64_t)this, v5);
          goto LABEL_4;
        case 1:
          *((unsigned char *)v5 - 12) = 3;
          *((unsigned char *)v5 - 11) &= 0x6Fu;
          goto LABEL_46;
        case 3:
          *((unsigned char *)v5 - 11) &= 0x6Fu;
          goto LABEL_4;
        case 5:
          *((unsigned char *)v5 - 12) = 3;
          goto LABEL_40;
        case 6:
LABEL_40:
          *((unsigned char *)v5 - 11) &= 0x6Fu;
          uint64_t v24 = *((void *)v5 - 8);
          if ((uint64_t)atomic_fetch_add((atomic_ullong *volatile)v5 - 3, 0xFFFFFFFFFFFFFFFFLL) <= 1)
          {
            __dmb(0xBu);
            if (v24) {
              *((void *)v5 - 8) = v24;
            }
            if (*((unsigned char *)v5 - 12) == 6)
            {
              tbb::internal::arena::enqueue_task(*((void **)this + 6), (uint64_t)v5, 0, v8);
            }
            else if (v16)
            {
LABEL_46:
              tbb::internal::generic_scheduler::local_spawn(this, v5, (tbb::task **)v5 - 1, a4);
            }
            else
            {
              unint64_t v16 = (unint64_t)v5;
            }
          }
          break;
        default:
          goto LABEL_4;
      }
      goto LABEL_4;
    }
    uint64_t v15 = *((void *)this + 42);
    if (!v15)
    {
      *((void *)this + 43) = (char *)v5 - 40;
      *((void *)v5 - 5) = 0;
      uint64_t v15 = *((void *)this + 42);
    }
    *((void *)v5 - 5) = v15;
    *((void *)this + 42) = v5;
    if (!*(void *)(*((void *)this + 5) + 8)) {
      break;
    }
    unint64_t v16 = tbb::internal::generic_scheduler::winnow_task_pool(this, (uint64_t)a4);
    if (!v16) {
      return 1;
    }
LABEL_4:
    unint64_t v5 = (tbb::task *)v16;
    if (!v16) {
      return 1;
    }
  }
  uint64_t v25 = *((void *)this + 6);
  __dmb(0xBu);
  unint64_t v26 = *(void *)(v25 + 216);
  __dmb(0xBu);
  if (v26 != -1)
  {
    while (1)
    {
      unint64_t v27 = v26;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v25 + 216), &v27, 0xFFFFFFFFFFFFFFFFLL);
      if (v27 == v26) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 216), 0, memory_order_relaxed);
      if (add_explicit != v26) {
        goto LABEL_57;
      }
    }
    unint64_t add_explicit = v26;
LABEL_57:
    if (!add_explicit)
    {
      if (v26)
      {
        while (1)
        {
          uint64_t v29 = 0;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v25 + 216), (unint64_t *)&v29, 0xFFFFFFFFFFFFFFFFLL);
          if (!v29) {
            break;
          }
          if (atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 216), 0, memory_order_relaxed)) {
            return 1;
          }
        }
      }
      tbb::internal::market::adjust_demand(*(void *)(v25 + 304), v25, *(_DWORD *)(v25 + 208));
    }
  }
  return 1;
}

uint64_t tbb::internal::the_global_observer_list(tbb::internal *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E088, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26798E088))
  {
    uint64_t v2 = operator new(0x80uLL);
    v2[6] = 0u;
    v2[7] = 0u;
    v2[4] = 0u;
    v2[5] = 0u;
    v2[2] = 0u;
    v2[3] = 0u;
    *uint64_t v2 = 0u;
    v2[1] = 0u;
    qword_26798E080 = (uint64_t)v2;
    __cxa_guard_release(&qword_26798E088);
  }
  return qword_26798E080;
}

void sub_216775078(_Unwind_Exception *a1)
{
}

uint64_t tbb::internal::observer_proxy::get_v6_observer(tbb::internal::observer_proxy *this)
{
  if (*((unsigned char *)this + 40) == 6) {
    return *((void *)this + 4);
  }
  else {
    return 0;
  }
}

BOOL tbb::internal::observer_proxy::is_global(tbb::internal::observer_proxy *this)
{
  return *((unsigned char *)this + 40) != 6 || (uint64_t v1 = *((void *)this + 4)) == 0 || *(void *)(v1 + 24) == 0;
}

uint64_t tbb::internal::observer_proxy::observer_proxy(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = a2;
  __dmb(0xBu);
  *(_DWORD *)unint64_t result = 1;
  if (*(void *)(*(void *)(result + 32) + 16) == 0x8000000000000000) {
    char v2 = 6;
  }
  else {
    char v2 = 0;
  }
  *(unsigned char *)(result + 40) = v2;
  return result;
}

{
  char v2;

  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = a2;
  __dmb(0xBu);
  *(_DWORD *)unint64_t result = 1;
  if (*(void *)(*(void *)(result + 32) + 16) == 0x8000000000000000) {
    char v2 = 6;
  }
  else {
    char v2 = 0;
  }
  *(unsigned char *)(result + 40) = v2;
  return result;
}

void tbb::internal::observer_list::clear(atomic_ullong *this)
{
  char v2 = this + 2;
  uint64_t v12 = this + 2;
  tbb::spin_rw_mutex_v3::internal_acquire_writer(this + 2);
  atomic_ullong v3 = *this;
  if (!*this) {
    goto LABEL_16;
  }
  do
  {
    uint64_t v4 = *(void *)(v3 + 32);
    atomic_ullong v3 = *(void *)(v3 + 16);
    if (v4)
    {
LABEL_6:
      unint64_t v5 = *(void **)(v4 + 8);
      while (1)
      {
        char v6 = v5;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v4 + 8), (unint64_t *)&v6, 0);
        if (v6 == v5) {
          break;
        }
        if ((void *)atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 0, memory_order_relaxed) != v5)
        {
          sched_yield();
          goto LABEL_6;
        }
      }
      if (v5)
      {
        unint64_t v7 = this + 1;
        if ((void *)this[1] != v5) {
          unint64_t v7 = (void *)(v5[2] + 24);
        }
        *unint64_t v7 = v5[3];
        uint64_t v8 = this;
        if ((void *)*this != v5) {
          uint64_t v8 = (atomic_ullong *)(v5[3] + 16);
        }
        *uint64_t v8 = v5[2];
        operator delete(v5);
      }
    }
  }
  while (v3);
  char v2 = v12;
  if (v12)
  {
LABEL_16:
    atomic_ullong v9 = *v2;
    unint64_t v10 = *v2 & 0xFFFFFFFFFFFFFFFCLL;
    while (1)
    {
      atomic_ullong v11 = v9;
      atomic_compare_exchange_strong(v2, (unint64_t *)&v11, v10);
      if (v11 == v9) {
        break;
      }
      if (atomic_fetch_add_explicit(v2, 0, memory_order_relaxed) != v9)
      {
        sched_yield();
        goto LABEL_16;
      }
    }
  }
  while (*this)
    sched_yield();
}

void sub_216775280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

tbb::internal::observer_proxy **tbb::internal::observer_list::remove(tbb::internal::observer_proxy **this, tbb::internal::observer_proxy *a2)
{
  char v2 = this + 1;
  if (this[1] != a2) {
    char v2 = (void *)(*((void *)a2 + 2) + 24);
  }
  *char v2 = *((void *)a2 + 3);
  if (*this != a2) {
    this = (tbb::internal::observer_proxy **)(*((void *)a2 + 3) + 16);
  }
  *this = (tbb::internal::observer_proxy *)*((void *)a2 + 2);
  return this;
}

uint64_t tbb::internal::observer_list::insert(atomic_ullong *this, tbb::internal::observer_proxy *a2)
{
  uint64_t v4 = this + 2;
  uint64_t result = tbb::spin_rw_mutex_v3::internal_acquire_writer(this + 2);
  char v6 = this;
  if (*this)
  {
    atomic_ullong v7 = this[1];
    *((void *)a2 + 3) = v7;
    char v6 = (atomic_ullong *)(v7 + 16);
  }
  *char v6 = (atomic_ullong)a2;
  this[1] = (atomic_ullong)a2;
LABEL_4:
  atomic_ullong v8 = *v4;
  unint64_t v9 = *v4 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v10 = v8;
    atomic_compare_exchange_strong(v4, (unint64_t *)&v10, v9);
    if (v10 == v8) {
      return result;
    }
    if (atomic_fetch_add_explicit(v4, 0, memory_order_relaxed) != v8)
    {
      uint64_t result = sched_yield();
      goto LABEL_4;
    }
  }
}

void tbb::internal::observer_list::remove_ref(atomic_ullong *this, tbb::internal::observer_proxy *a2)
{
  atomic_ullong v3 = (tbb::internal::observer_proxy **)this;
  int v4 = *(_DWORD *)a2;
  __dmb(0xBu);
  if (v4 < 2)
  {
LABEL_5:
    char v6 = this + 2;
    tbb::spin_rw_mutex_v3::internal_acquire_writer(this + 2);
    if (atomic_fetch_add((atomic_uint *volatile)a2, 0xFFFFFFFF) == 1)
    {
      atomic_ullong v7 = v3 + 1;
      if (v3[1] != a2) {
        atomic_ullong v7 = (void *)(*((void *)a2 + 2) + 24);
      }
      *atomic_ullong v7 = *((void *)a2 + 3);
      if (*v3 != a2) {
        atomic_ullong v3 = (tbb::internal::observer_proxy **)(*((void *)a2 + 3) + 16);
      }
      *atomic_ullong v3 = (tbb::internal::observer_proxy *)*((void *)a2 + 2);
LABEL_11:
      atomic_ullong v8 = *v6;
      unint64_t v9 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
      while (1)
      {
        atomic_ullong v10 = v8;
        atomic_compare_exchange_strong(v6, (unint64_t *)&v10, v9);
        if (v10 == v8) {
          break;
        }
        if (atomic_fetch_add_explicit(v6, 0, memory_order_relaxed) != v8)
        {
          sched_yield();
          goto LABEL_11;
        }
      }
      operator delete(a2);
    }
    else
    {
LABEL_15:
      atomic_ullong v11 = *v6;
      unint64_t v12 = *v6 & 0xFFFFFFFFFFFFFFFCLL;
      while (1)
      {
        atomic_ullong v13 = v11;
        atomic_compare_exchange_strong(v6, (unint64_t *)&v13, v12);
        if (v13 == v11) {
          break;
        }
        if (atomic_fetch_add_explicit(v6, 0, memory_order_relaxed) != v11)
        {
          sched_yield();
          goto LABEL_15;
        }
      }
    }
  }
  else
  {
    while (1)
    {
      int v5 = v4;
      atomic_compare_exchange_strong((atomic_uint *volatile)a2, (unsigned int *)&v5, v4 - 1);
      if (v5 == v4) {
        break;
      }
      if (*(_DWORD *)a2 != v4)
      {
        int v4 = *(_DWORD *)a2;
        if (*(int *)a2 <= 1) {
          goto LABEL_5;
        }
      }
    }
  }
}

void tbb::internal::observer_list::do_notify_entry_observers(atomic_ullong *this, atomic_ullong *a2, uint64_t a3)
{
  atomic_ullong v5 = *a2;
  char v6 = this + 2;
  while (2)
  {
    atomic_ullong v13 = v6;
    tbb::spin_rw_mutex_v3::internal_acquire_reader(v6);
    atomic_ullong v7 = v5;
    while (1)
    {
      if (!v5)
      {
        atomic_ullong v5 = *this;
        if (!*this)
        {
          uint64_t v8 = 0;
          int v10 = 0;
          atomic_ullong v11 = v6;
          if (!v6) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }
        goto LABEL_5;
      }
      atomic_ullong v9 = *(void *)(v5 + 16);
      if (!v9) {
        break;
      }
      if (v5 == v7 && *(void *)(v7 + 32))
      {
        atomic_fetch_add((atomic_uint *volatile)v7, 0xFFFFFFFF);
        atomic_ullong v5 = v9;
        atomic_ullong v7 = 0;
      }
      else
      {
        atomic_ullong v5 = *(void *)(v5 + 16);
      }
LABEL_5:
      uint64_t v8 = *(void *)(v5 + 32);
      if (v8)
      {
        int v10 = 1;
        atomic_fetch_add((atomic_uint *volatile)v5, 1u);
        atomic_fetch_add((atomic_ullong *volatile)(v8 + 16), 1uLL);
        atomic_ullong v11 = v6;
        if (!v6) {
          goto LABEL_21;
        }
        goto LABEL_20;
      }
    }
    if (v5 != v7)
    {
      atomic_fetch_add((atomic_uint *volatile)v5, 1u);
      if (v7)
      {
        atomic_ullong v13 = 0;
        atomic_fetch_add(v6, 0xFFFFFFFFFFFFFFFCLL);
        tbb::internal::observer_list::remove_ref(this, (tbb::internal::observer_proxy *)v7);
      }
    }
    uint64_t v8 = 0;
    int v10 = 0;
    *a2 = v5;
    atomic_ullong v11 = v13;
    if (v13) {
LABEL_20:
    }
      atomic_fetch_add(v11, 0xFFFFFFFFFFFFFFFCLL);
LABEL_21:
    if (v10)
    {
      if (v7) {
        tbb::internal::observer_list::remove_ref(this, (tbb::internal::observer_proxy *)v7);
      }
      (**(void (***)(uint64_t, uint64_t))v8)(v8, a3);
      atomic_fetch_add((atomic_ullong *volatile)(v8 + 16), 0xFFFFFFFFFFFFFFFFLL);
      continue;
    }
    break;
  }
}

void sub_216775698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_21676B828((uint64_t)va);
  _Unwind_Resume(a1);
}

void tbb::internal::observer_list::do_notify_exit_observers(atomic_ullong *this, tbb::internal::observer_proxy *a2, uint64_t a3)
{
  char v6 = 0;
  atomic_ullong v7 = this + 2;
  while (1)
  {
    tbb::spin_rw_mutex_v3::internal_acquire_reader(v7);
    uint64_t v8 = v6;
    do
    {
      if (v6)
      {
        if (v6 == a2)
        {
          if (!*((void *)a2 + 4))
          {
            atomic_fetch_add(v7, 0xFFFFFFFFFFFFFFFCLL);
            tbb::internal::observer_list::remove_ref(this, a2);
            int v11 = 0;
            int v10 = 0;
            char v6 = a2;
            goto LABEL_21;
          }
          char v6 = 0;
          int v11 = 0;
          int v10 = 0;
          atomic_fetch_add((atomic_uint *volatile)a2, 0xFFFFFFFF);
          unint64_t v12 = v7;
          if (!v7) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }
        if (v6 == v8)
        {
          uint64_t v8 = v6;
          if (*((void *)v6 + 4))
          {
            uint64_t v8 = 0;
            atomic_fetch_add((atomic_uint *volatile)v6, 0xFFFFFFFF);
          }
        }
        atomic_ullong v9 = (atomic_ullong *)((char *)v6 + 16);
      }
      else
      {
        atomic_ullong v9 = this;
      }
      char v6 = (tbb::internal::observer_proxy *)*v9;
      int v10 = *(atomic_ullong **)(*v9 + 32);
    }
    while (!v10);
    if (v6 != a2) {
      atomic_fetch_add((atomic_uint *volatile)v6, 1u);
    }
    int v11 = 1;
    atomic_fetch_add(v10 + 2, 1uLL);
    unint64_t v12 = v7;
    if (v7) {
LABEL_20:
    }
      atomic_fetch_add(v12, 0xFFFFFFFFFFFFFFFCLL);
LABEL_21:
    if (!v11) {
      break;
    }
    if (v8) {
      tbb::internal::observer_list::remove_ref(this, v8);
    }
    (*(void (**)(atomic_ullong *, uint64_t))(*v10 + 8))(v10, a3);
    atomic_fetch_add(v10 + 2, 0xFFFFFFFFFFFFFFFFLL);
  }
}

void sub_2167758B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void tbb::internal::task_scheduler_observer_v3::observe(tbb::internal::task_scheduler_observer_v3 *this, char a2)
{
  if ((a2 & 1) == 0)
  {
LABEL_14:
    int v11 = (void *)*((void *)this + 1);
    while (1)
    {
      unint64_t v12 = v11;
      atomic_compare_exchange_strong((atomic_ullong *volatile)this + 1, (unint64_t *)&v12, 0);
      if (v12 == v11) {
        break;
      }
      if ((void *)atomic_fetch_add_explicit((atomic_ullong *volatile)this + 1, 0, memory_order_relaxed) != v11)
      {
        sched_yield();
        goto LABEL_14;
      }
    }
    if (v11)
    {
      atomic_ullong v13 = (void *)v11[1];
      unint64_t v14 = v13 + 2;
      tbb::spin_rw_mutex_v3::internal_acquire_writer(v13 + 2);
      v11[4] = 0;
      if (atomic_fetch_add((atomic_uint *volatile)v11, 0xFFFFFFFF) == 1)
      {
        uint64_t v15 = v13 + 1;
        if ((void *)v13[1] != v11) {
          uint64_t v15 = (void *)(v11[2] + 24);
        }
        *uint64_t v15 = v11[3];
        if ((void *)*v13 != v11) {
          atomic_ullong v13 = (void *)(v11[3] + 16);
        }
        *atomic_ullong v13 = v11[2];
        operator delete(v11);
      }
LABEL_25:
      atomic_ullong v16 = *v14;
      unint64_t v17 = *v14 & 0xFFFFFFFFFFFFFFFCLL;
      while (1)
      {
        atomic_ullong v18 = v16;
        atomic_compare_exchange_strong(v14, (unint64_t *)&v18, v17);
        if (v18 == v16) {
          break;
        }
        if (atomic_fetch_add_explicit(v14, 0, memory_order_relaxed) != v16)
        {
          sched_yield();
          goto LABEL_25;
        }
      }
      while (1)
      {
        uint64_t v19 = *((void *)this + 2);
        __dmb(0xBu);
        if (!v19) {
          break;
        }
        sched_yield();
      }
    }
    return;
  }
  if (*((void *)this + 1)) {
    return;
  }
  atomic_ullong v3 = operator new(0x30uLL);
  v3[1] = 0;
  int v3[2] = 0;
  v3[3] = 0;
  v3[4] = this;
  __dmb(0xBu);
  *(_DWORD *)atomic_ullong v3 = 1;
  if (*(void *)(v3[4] + 16) == 0x8000000000000000) {
    char v4 = 6;
  }
  else {
    char v4 = 0;
  }
  *((unsigned char *)v3 + 40) = v4;
  *((void *)this + 1) = v3;
  __dmb(0xBu);
  *((void *)this + 2) = 0;
  uint64_t v5 = *((void *)this + 1);
  if (*(unsigned char *)(v5 + 40) == 6)
  {
    uint64_t v6 = *(void *)(v5 + 32);
    if (v6)
    {
      if (*(void *)(v6 + 24))
      {
        unint64_t inited = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS) & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v8 = (void *)*((void *)this + 1);
        atomic_ullong v9 = *(tbb::interface7::internal::task_arena_base **)(v8[4] + 24);
        if (v9 == (tbb::interface7::internal::task_arena_base *)1)
        {
          if (inited)
          {
            int v10 = *(void **)(inited + 48);
            if (v10) {
              goto LABEL_52;
            }
          }
          unint64_t inited = tbb::internal::governor::init_scheduler((tbb::internal::governor *)0xFFFFFFFFLL, 0, 1);
          atomic_ullong v9 = (tbb::interface7::internal::task_arena_base *)(inited + 48);
        }
        else
        {
          int v10 = *(void **)v9;
          if (*(void *)v9) {
            goto LABEL_52;
          }
          if (*((unsigned char *)v9 + 32))
          {
            int v10 = 0;
            goto LABEL_52;
          }
          tbb::interface7::internal::task_arena_base::internal_initialize(v9);
          *((unsigned char *)v9 + 32) = 1;
        }
        int v10 = *(void **)v9;
        uint64_t v8 = (void *)*((void *)this + 1);
LABEL_52:
        uint64_t v33 = v10 + 28;
        v8[1] = v10 + 28;
        uint64_t v34 = v10 + 30;
        tbb::spin_rw_mutex_v3::internal_acquire_writer(v10 + 30);
        if (v10[28])
        {
          uint64_t v35 = v10[29];
          v8[3] = v35;
          uint64_t v33 = (void *)(v35 + 16);
        }
        *uint64_t v33 = v8;
        v10[29] = v8;
LABEL_55:
        atomic_ullong v36 = *v34;
        unint64_t v37 = *v34 & 0xFFFFFFFFFFFFFFFCLL;
        while (1)
        {
          atomic_ullong v38 = v36;
          atomic_compare_exchange_strong(v34, (unint64_t *)&v38, v37);
          if (v38 == v36) {
            break;
          }
          if (atomic_fetch_add_explicit(v34, 0, memory_order_relaxed) != v36)
          {
            sched_yield();
            goto LABEL_55;
          }
        }
        if (inited)
        {
          uint64_t v39 = *(void *)(inited + 48);
          int v30 = (atomic_ullong *)(v39 + 224);
          if (v39 + 224 == *(void *)(*((void *)this + 1) + 8))
          {
            uint64_t v31 = (atomic_ullong *)(inited + 88);
            if (*(void *)(inited + 88) != *(void *)(v39 + 232))
            {
              char v32 = *(unsigned char *)(inited + 74);
              goto LABEL_46;
            }
          }
        }
        return;
      }
    }
  }
  int v20 = tbb::internal::__TBB_InitOnce::InitializationDone;
  __dmb(0xBu);
  if (!v20) {
    tbb::internal::DoOneTimeInitializations((tbb::internal *)v3);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E088, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26798E088))
  {
    uint64_t v40 = operator new(0x80uLL);
    v40[6] = 0u;
    v40[7] = 0u;
    v40[4] = 0u;
    v40[5] = 0u;
    v40[2] = 0u;
    v40[3] = 0u;
    *uint64_t v40 = 0u;
    v40[1] = 0u;
    qword_26798E080 = (uint64_t)v40;
    __cxa_guard_release(&qword_26798E088);
  }
  BOOL v21 = (void *)qword_26798E080;
  uint64_t v22 = *((void *)this + 1);
  *(void *)(v22 + 8) = qword_26798E080;
  uint64_t v23 = v21 + 2;
  tbb::spin_rw_mutex_v3::internal_acquire_writer(v21 + 2);
  uint64_t v24 = v21;
  if (*v21)
  {
    uint64_t v25 = v21[1];
    *(void *)(v22 + 24) = v25;
    uint64_t v24 = (void *)(v25 + 16);
  }
  *uint64_t v24 = v22;
  v21[1] = v22;
LABEL_38:
  atomic_ullong v26 = *v23;
  unint64_t v27 = *v23 & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    atomic_ullong v28 = v26;
    atomic_compare_exchange_strong(v23, (unint64_t *)&v28, v27);
    if (v28 == v26) {
      break;
    }
    if (atomic_fetch_add_explicit(v23, 0, memory_order_relaxed) != v26)
    {
      sched_yield();
      goto LABEL_38;
    }
  }
  unint64_t v29 = (unint64_t)pthread_getspecific(tbb::internal::governor::theTLS) & 0xFFFFFFFFFFFFFFFELL;
  if (v29)
  {
    if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E088, memory_order_acquire) & 1) == 0
      && __cxa_guard_acquire(&qword_26798E088))
    {
      int64x2_t v41 = operator new(0x80uLL);
      v41[6] = 0u;
      v41[7] = 0u;
      v41[4] = 0u;
      v41[5] = 0u;
      int v41[2] = 0u;
      v41[3] = 0u;
      *int64x2_t v41 = 0u;
      v41[1] = 0u;
      qword_26798E080 = (uint64_t)v41;
      __cxa_guard_release(&qword_26798E088);
    }
    int v30 = (atomic_ullong *)qword_26798E080;
    uint64_t v31 = (atomic_ullong *)(v29 + 80);
    if (*(void *)(v29 + 80) != *(void *)(qword_26798E080 + 8))
    {
      char v32 = *(unsigned char *)(v29 + 74);
LABEL_46:
      tbb::internal::observer_list::do_notify_entry_observers(v30, v31, (v32 & 1) == 0);
    }
  }
}

void sub_216775CCC(_Unwind_Exception *a1)
{
}

tbb::internal *tbb::internal::__TBB_InitOnce::add_ref(tbb::internal::__TBB_InitOnce *this)
{
  if (atomic_fetch_add(&tbb::internal::__TBB_InitOnce::count, 1u))
  {
    if (qword_26798E098 != -1) {
      dispatch_once(&qword_26798E098, &unk_26C746F48);
    }
    uint64_t v1 = qword_26798E090;
    if (os_log_type_enabled((os_log_t)qword_26798E090, OS_LOG_TYPE_ERROR)) {
      sub_217323A98(v1);
    }
    return (tbb::internal *)0xFFFFFFFFLL;
  }
  else
  {
    return tbb::internal::governor::acquire_resources(this);
  }
}

tbb::internal::governor *tbb::internal::__TBB_InitOnce::remove_ref(tbb::internal::governor *this)
{
  if (atomic_fetch_add(&tbb::internal::__TBB_InitOnce::count, 0xFFFFFFFF) == 1) {
    return (tbb::internal::governor *)tbb::internal::governor::release_resources(this);
  }
  return this;
}

tbb::internal *tbb::internal::DoOneTimeInitializations(tbb::internal *this)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
LABEL_2:
  char v1 = 8 * (&tbb::internal::__TBB_InitOnce::InitializationLock & 3);
  int v2 = *(_DWORD *)((unint64_t)&tbb::internal::__TBB_InitOnce::InitializationLock & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v1);
  unsigned int v3 = v2 | (1 << v1);
  while (1)
  {
    int v4 = v2;
    atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::__TBB_InitOnce::InitializationLock & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v4, v3);
    if (v4 == v2) {
      break;
    }
    if (*(_DWORD *)((unint64_t)&tbb::internal::__TBB_InitOnce::InitializationLock & 0xFFFFFFFFFFFFFFFCLL) != v2)
    {
      this = (tbb::internal *)sched_yield();
      goto LABEL_2;
    }
  }
  if (tbb::internal::__TBB_InitOnce::InitializationDone)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = tbb::internal::__TBB_InitOnce::add_ref(this);
    uint64_t v6 = getenv("TBB_VERSION");
    if (v6)
    {
      atomic_ullong v7 = v6;
      uint64_t v6 = (char *)strspn(v6, " ");
      if (v6[(void)v7] == 49)
      {
        uint64_t v8 = v6 + 1;
        uint64_t v6 = (char *)strspn(&v6[(void)v7 + 1], " ");
        if (!v7[(unint64_t)&v8[(void)v6]]) {
          uint64_t v6 = (char *)tbb::internal::PrintVersion((tbb::internal *)v6);
        }
      }
    }
    tbb::internal::initialize_cache_aligned_allocator((tbb::internal *)v6);
    tbb::internal::governor::initialize_rml_factory(v9);
    uint64_t v10 = tbb::internal::Scheduler_OneTimeInitialization(0);
    if (!tbb::internal::governor::DefaultNumberOfThreads)
    {
      *(void *)atomic_ullong v18 = 0x1900000006;
      int v17 = 0;
      size_t v16 = 4;
      uint64_t v10 = sysctl(v18, 2u, &v17, &v16, 0, 0);
      int v13 = v17;
      if (v17 <= 1) {
        int v13 = 1;
      }
      tbb::internal::governor::DefaultNumberOfThreads = v13;
    }
    if (!tbb::internal::governor::DefaultPageSize)
    {
      uint64_t v10 = tbb::internal::DefaultSystemPageSize((tbb::internal *)v10);
      tbb::internal::governor::DefaultPageSize = v10;
    }
    tbb::internal::governor::print_version_info((tbb::internal::governor *)v10, v11, v12);
    tbb::internal::PrintExtraVersionInfo("Tools support", "disabled", v14);
    tbb::internal::__TBB_InitOnce::InitializationDone = 1;
  }
  __dmb(0xBu);
  tbb::internal::__TBB_InitOnce::InitializationLocuint64_t k = 0;
  return v5;
}

void *tbb::internal::itt_store_pointer_with_release_v3(void *this, void *a2, void *a3)
{
  *this = a2;
  return this;
}

uint64_t tbb::internal::itt_load_pointer_with_acquire_v3(tbb::internal *this, const void *a2)
{
  uint64_t result = *(void *)this;
  __dmb(0xBu);
  return result;
}

uint64_t tbb::internal::itt_load_pointer_v3(tbb::internal *this, const void *a2)
{
  return *(void *)this;
}

uint64_t tbb::internal::market::app_parallelism_limit(tbb::internal::market *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E0A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26798E0A8))
  {
    int v4 = operator new(0x80uLL);
    int v4[2] = 0;
    *((unsigned char *)v4 + 24) = 0;
    void *v4 = &unk_26C746F78;
    qword_26798E0A0 = (uint64_t)v4;
    __cxa_guard_release(&qword_26798E0A8);
  }
  uint64_t v1 = qword_26798E0A0;
  uint64_t v2 = *(void *)(qword_26798E0A0 + 16);
  __dmb(0xBu);
  if (v2) {
    return *(unsigned int *)(v1 + 8);
  }
  else {
    return 0;
  }
}

void sub_216776054(_Unwind_Exception *a1)
{
}

uint64_t sub_21677606C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E0A8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26798E0A8))
  {
    uint64_t v1 = operator new(0x80uLL);
    v1[2] = 0;
    *((unsigned char *)v1 + 24) = 0;
    *uint64_t v1 = &unk_26C746F78;
    qword_26798E0A0 = (uint64_t)v1;
    __cxa_guard_release(&qword_26798E0A8);
  }
  return qword_26798E0A0;
}

void sub_2167760F0(_Unwind_Exception *a1)
{
}

uint64_t tbb::interface9::global_control::internal_create(tbb::interface9::global_control *this, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  if (*((int *)this + 4) >= 2) {
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/tbb_main.cpp", (const char *)0x226, "my_param < global_control::parameter_max", 0, a5);
  }
  uint64_t v6 = *(void *)(sub_216776250() + 8 * *((unsigned int *)this + 4));
  atomic_ullong v7 = (atomic_uint *)((v6 + 24) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_4:
  int v8 = *v7 & ~(255 << (8 * ((v6 + 24) & 3)));
  while (1)
  {
    int v9 = v8;
    atomic_compare_exchange_strong(v7, (unsigned int *)&v9, v8 | (1 << (8 * ((v6 + 24) & 3))));
    if (v9 == v8) {
      break;
    }
    if (*v7 != v8)
    {
      sched_yield();
      goto LABEL_4;
    }
  }
  uint64_t v10 = *(void *)(v6 + 16);
  __dmb(0xBu);
  if (!v10
    || (uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v6 + 16))(v6, *(void *)this, *(void *)(v6 + 8)), result))
  {
    *(void *)(v6 + 8) = *(void *)this;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v12 = *(void *)(v6 + 16);
  __dmb(0xBu);
  *((void *)this + 1) = v12;
  __dmb(0xBu);
  *(void *)(v6 + 16) = this;
  __dmb(0xBu);
  *(unsigned char *)(v6 + 24) = 0;
  return result;
}

void sub_216776244(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t sub_216776250()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E0B8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26798E0B8))
  {
    uint64_t v1 = operator new(0x10uLL);
    *uint64_t v1 = sub_21677606C();
    v1[1] = sub_2167767A8();
    qword_26798E0B0 = (uint64_t)v1;
    __cxa_guard_release(&qword_26798E0B8);
  }
  return qword_26798E0B0;
}

void sub_2167762C4(_Unwind_Exception *a1)
{
}

uint64_t tbb::interface9::global_control::internal_destroy(tbb::interface9::global_control *this, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  if (*((int *)this + 4) >= 2) {
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/tbb_main.cpp", (const char *)0x238, "my_param < global_control::parameter_max", 0, a5);
  }
  uint64_t result = sub_216776250();
  atomic_ullong v7 = *(void **)(result + 8 * *((unsigned int *)this + 4));
  int v8 = (atomic_uint *)((unint64_t)(v7 + 3) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_4:
  int v9 = *v8 & ~(255 << (8 * (((_BYTE)v7 + 24) & 3)));
  while (1)
  {
    int v10 = v9;
    atomic_compare_exchange_strong(v8, (unsigned int *)&v10, v9 | (1 << (8 * (((_BYTE)v7 + 24) & 3))));
    if (v10 == v9) {
      break;
    }
    if (*v8 != v9)
    {
      uint64_t result = sched_yield();
      goto LABEL_4;
    }
  }
  uint64_t v11 = v7[1];
  uint64_t v12 = (tbb::interface9::global_control *)v7[2];
  __dmb(0xBu);
  int v13 = (uint64_t *)v7[2];
  __dmb(0xBu);
  if (v12 != this) {
    goto LABEL_11;
  }
  if (v13[1])
  {
    uint64_t v14 = v7[2];
    __dmb(0xBu);
    int v13 = *(uint64_t **)(v14 + 8);
LABEL_11:
    uint64_t v15 = *v13;
    goto LABEL_12;
  }
  uint64_t v15 = -1;
LABEL_12:
  size_t v16 = (tbb::interface9::global_control *)v7[2];
  __dmb(0xBu);
  if (v16)
  {
    int v17 = 0;
    do
    {
      uint64_t v19 = v17;
      int v17 = (uint64_t *)v16;
      if (v16 == this)
      {
        uint64_t v18 = *((void *)this + 1);
        if (v19)
        {
          v19[1] = v18;
        }
        else
        {
          __dmb(0xBu);
          v7[2] = v18;
        }
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(void *, void, uint64_t))(*v7 + 16))(v7, *(void *)v16, v15);
        if (result) {
          uint64_t v15 = *v17;
        }
      }
      size_t v16 = (tbb::interface9::global_control *)v17[1];
    }
    while (v16);
  }
  uint64_t v20 = v7[2];
  __dmb(0xBu);
  if (v20)
  {
    if (v15 == v11) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  uint64_t result = (*(uint64_t (**)(void *))*v7)(v7);
  uint64_t v15 = result;
  if (result != v11)
  {
LABEL_25:
    v7[1] = v15;
    uint64_t result = (*(uint64_t (**)(void *))(*v7 + 8))(v7);
  }
LABEL_26:
  __dmb(0xBu);
  *((unsigned char *)v7 + 24) = 0;
  return result;
}

void sub_2167764DC(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

uint64_t tbb::interface9::global_control::active_value(tbb::interface9::global_control *this, int a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v5 = (int)this;
  if ((int)this >= 2) {
    tbb::assertion_failure("/Library/Caches/com.apple.xbs/Sources/USDLib/oneTBB-2020.3/./src/tbb/tbb_main.cpp", (const char *)0x25E, "param < global_control::parameter_max", 0, a5);
  }
  uint64_t v6 = *(uint64_t (**)(void))(**(void **)(sub_216776250() + 8 * v5) + 24);

  return v6();
}

os_log_t sub_216776568()
{
  os_log_t result = os_log_create("com.apple.usdlib", "tbbmain");
  qword_26798E090 = (uint64_t)result;
  return result;
}

uint64_t sub_216776598()
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  unsigned int v0 = tbb::internal::governor::DefaultNumberOfThreads;
  if (!tbb::internal::governor::DefaultNumberOfThreads)
  {
    *(void *)int v4 = 0x1900000006;
    int v3 = 0;
    size_t v2 = 4;
    sysctl(v4, 2u, &v3, &v2, 0, 0);
    unsigned int v0 = v3;
    if (v3 <= 1) {
      unsigned int v0 = 1;
    }
    tbb::internal::governor::DefaultNumberOfThreads = v0;
  }
  return v0;
}

uint64_t sub_21677663C(uint64_t a1)
{
  return tbb::internal::market::set_active_num_workers((*(_DWORD *)(a1 + 8) - 1));
}

BOOL sub_216776648(uint64_t a1, unint64_t a2, unint64_t a3)
{
  return a2 < a3;
}

uint64_t sub_216776654(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  __dmb(0xBu);
  if (v2)
  {
LABEL_2:
    char v3 = 8 * (&tbb::internal::market::theMarketMutex & 3);
    int v4 = *(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) & ~(255 << v3);
    unsigned int v5 = v4 | (1 << v3);
    while (1)
    {
      int v6 = v4;
      atomic_compare_exchange_strong((atomic_uint *volatile)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL), (unsigned int *)&v6, v5);
      if (v6 == v4) {
        break;
      }
      if (*(_DWORD *)((unint64_t)&tbb::internal::market::theMarketMutex & 0xFFFFFFFFFFFFFFFCLL) != v4)
      {
        sched_yield();
        goto LABEL_2;
      }
    }
    if (tbb::internal::market::theMarket)
    {
      uint64_t v7 = *(unsigned int *)(tbb::internal::market::theMarket + 24);
      __dmb(0xBu);
      LOBYTE(tbb::internal::market::theMarketMutex) = 0;
      if (v7)
      {
        if ((unint64_t)(v7 + 1) < *(void *)(a1 + 8)) {
          return v7 + 1;
        }
        else {
          return *(void *)(a1 + 8);
        }
      }
    }
    else
    {
      __dmb(0xBu);
      LOBYTE(tbb::internal::market::theMarketMutex) = 0;
    }
    return *(void *)(a1 + 8);
  }
  int v9 = **(uint64_t (***)(void))a1;

  return v9();
}

BOOL sub_216776764(uint64_t a1, unint64_t a2, unint64_t a3)
{
  return a2 > a3;
}

uint64_t sub_216776770(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  __dmb(0xBu);
  if (v1) {
    return *(void *)(a1 + 8);
  }
  else {
    return (**(uint64_t (***)(uint64_t))a1)(a1);
  }
}

uint64_t sub_2167767A8()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E0C8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_26798E0C8))
  {
    uint64_t v1 = operator new(0x80uLL);
    v1[2] = 0;
    *((unsigned char *)v1 + 24) = 0;
    *uint64_t v1 = &unk_26C747000;
    qword_26798E0C0 = (uint64_t)v1;
    __cxa_guard_release(&qword_26798E0C8);
  }
  return qword_26798E0C0;
}

void sub_21677682C(_Unwind_Exception *a1)
{
}

uint64_t sub_216776844()
{
  return 0x400000;
}

atomic_ullong *tbb::internal::concurrent_vector_base::internal_grow_to_at_least(atomic_ullong *this, unint64_t a2, uint64_t a3, uint64_t (*a4)(unint64_t, unint64_t))
{
  unint64_t v7 = *this;
  __dmb(0xBu);
  if (v7 < a2)
  {
    while (1)
    {
      unint64_t v8 = v7;
      atomic_compare_exchange_strong(this, &v8, a2);
      if (v8 == v7) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit(this, 0, memory_order_relaxed);
      if (add_explicit != v7)
      {
        unint64_t v7 = add_explicit;
        if (add_explicit >= a2) {
          return this;
        }
      }
    }
    return (atomic_ullong *)tbb::internal::concurrent_vector_base::internal_grow((tbb::internal::concurrent_vector_base *)this, v7, a2, a3, a4);
  }
  return this;
}

uint64_t tbb::internal::concurrent_vector_base::internal_grow(tbb::internal::concurrent_vector_base *this, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(unint64_t, unint64_t))
{
  unint64_t v8 = (void *)((char *)this + 16);
  int v9 = (void *)((char *)this + 24);
  do
  {
    unint64_t v16 = a2 | 8;
    if (HIDWORD(a2)) {
      unint64_t v16 = HIDWORD(a2);
    }
    uint64_t v17 = 32 * (HIDWORD(a2) != 0);
    if (v16 >= 0x10000)
    {
      v16 >>= 16;
      uint64_t v17 = (32 * (HIDWORD(a2) != 0)) | 0x10;
    }
    if (v16 >= 0x100)
    {
      v16 >>= 8;
      v17 |= 8uLL;
    }
    if (v16 >= 0x10)
    {
      v16 >>= 4;
      v17 |= 4uLL;
    }
    if (v16 >= 4)
    {
      v16 >>= 2;
      v17 += 2;
    }
    unint64_t v18 = v17 + ((v16 >> 1) & 1);
    unint64_t v19 = v18 - 3;
    int v20 = 8 << (v18 - 3);
    if (v18 == 3) {
      unint64_t v21 = 16;
    }
    else {
      unint64_t v21 = v20;
    }
    if (v19 >= 2)
    {
      uint64_t v22 = (void *)*((void *)this + 1);
      __dmb(0xBu);
      if (v8 == v22)
      {
        unint64_t v24 = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, (void *)a4);
        *(_OWORD *)unint64_t v24 = 0u;
        *(_OWORD *)(v24 + 16) = 0u;
        *(_OWORD *)(v24 + 32) = 0u;
        *(_OWORD *)(v24 + 48) = 0u;
        *(_OWORD *)(v24 + 64) = 0u;
        *(_OWORD *)(v24 + 80) = 0u;
        *(_OWORD *)(v24 + 96) = 0u;
        *(_OWORD *)(v24 + 112) = 0u;
        *(_OWORD *)(v24 + 128) = 0u;
        *(_OWORD *)(v24 + 144) = 0u;
        *(_OWORD *)(v24 + 160) = 0u;
        *(_OWORD *)(v24 + 176) = 0u;
        *(_OWORD *)(v24 + 192) = 0u;
        *(_OWORD *)(v24 + 208) = 0u;
        *(_OWORD *)(v24 + 224) = 0u;
        *(_OWORD *)(v24 + 240) = 0u;
        *(_OWORD *)(v24 + 256) = 0u;
        *(_OWORD *)(v24 + 272) = 0u;
        *(_OWORD *)(v24 + 288) = 0u;
        *(_OWORD *)(v24 + 304) = 0u;
        *(_OWORD *)(v24 + 320) = 0u;
        *(_OWORD *)(v24 + 336) = 0u;
        *(_OWORD *)(v24 + 352) = 0u;
        *(_OWORD *)(v24 + 368) = 0u;
        *(_OWORD *)(v24 + 384) = 0u;
        *(_OWORD *)(v24 + 400) = 0u;
        *(_OWORD *)(v24 + 416) = 0u;
        *(_OWORD *)(v24 + 432) = 0u;
        *(_OWORD *)(v24 + 448) = 0u;
        *(_OWORD *)(v24 + 464) = 0u;
        *(_OWORD *)(v24 + 480) = 0u;
        *(_OWORD *)(v24 + 496) = 0u;
        while (!*v8 || !*v9)
          sched_yield();
        *(void *)unint64_t v24 = *v8;
        *(void *)(v24 + 8) = *v9;
        while (1)
        {
          uint64_t v25 = v22;
          atomic_compare_exchange_strong((atomic_ullong *volatile)this + 1, (unint64_t *)&v25, v24);
          if (v25 == v22) {
            break;
          }
          unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)this + 1, 0, memory_order_relaxed);
          if ((void *)add_explicit != v22)
          {
            if (v8 != (void *)add_explicit) {
              tbb::internal::NFS_Free((tbb::internal *)v24, v23);
            }
            break;
          }
        }
      }
    }
    unsigned int v10 = v20 & 0xFFFFFFF0;
    uint64_t v11 = (int)(v20 & 0xFFFFFFF0);
    uint64_t v12 = *((void *)this + 1);
    __dmb(0xBu);
    uint64_t v13 = *(void *)(v12 + 8 * v19);
    if (!v13)
    {
      if (a2 == v10)
      {
        uint64_t v13 = tbb::internal::NFS_Allocate(v21, a4, 0, (void *)a4);
        *(void *)(v12 + 8 * v19) = v13;
      }
      else
      {
        while (!*(void *)(v12 + 8 * v19))
          sched_yield();
        uint64_t v13 = *(void *)(v12 + 8 * v19);
      }
    }
    if (v21 >= a3 - v11) {
      unint64_t v14 = a3 - v11;
    }
    else {
      unint64_t v14 = v21;
    }
    uint64_t result = a5(v13 + (a2 - v11) * a4, v14 - (a2 - v11));
    a2 = v14 + v11;
  }
  while (v14 + v11 < a3);
  return result;
}

uint64_t tbb::internal::concurrent_vector_base::helper::extend_segment(atomic_ullong *this, tbb::internal::concurrent_vector_base *a2, uint64_t a3, void *a4)
{
  uint64_t result = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
  unint64_t v7 = (tbb::internal *)result;
  *(_OWORD *)uint64_t result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  *(_OWORD *)(result + 144) = 0u;
  *(_OWORD *)(result + 160) = 0u;
  *(_OWORD *)(result + 176) = 0u;
  *(_OWORD *)(result + 192) = 0u;
  *(_OWORD *)(result + 208) = 0u;
  *(_OWORD *)(result + 224) = 0u;
  *(_OWORD *)(result + 240) = 0u;
  *(_OWORD *)(result + 256) = 0u;
  *(_OWORD *)(result + 272) = 0u;
  *(_OWORD *)(result + 288) = 0u;
  *(_OWORD *)(result + 304) = 0u;
  *(_OWORD *)(result + 320) = 0u;
  *(_OWORD *)(result + 336) = 0u;
  *(_OWORD *)(result + 352) = 0u;
  *(_OWORD *)(result + 368) = 0u;
  *(_OWORD *)(result + 384) = 0u;
  *(_OWORD *)(result + 400) = 0u;
  *(_OWORD *)(result + 416) = 0u;
  *(_OWORD *)(result + 432) = 0u;
  *(_OWORD *)(result + 448) = 0u;
  *(_OWORD *)(result + 464) = 0u;
  unint64_t v8 = this + 3;
  int v9 = (char *)(this + 2);
  *(_OWORD *)(result + 480) = 0u;
  *(_OWORD *)(result + 496) = 0u;
  while (!*(void *)v9 || !*v8)
    uint64_t result = sched_yield();
  *(void *)unint64_t v7 = *(void *)v9;
  *((void *)v7 + 1) = *v8;
  while (1)
  {
    unsigned int v10 = (char *)(this + 2);
    atomic_compare_exchange_strong(this + 1, (unint64_t *)&v10, (unint64_t)v7);
    if (v10 == v9) {
      break;
    }
    if ((char *)atomic_fetch_add_explicit(this + 1, 0, memory_order_relaxed) != v9)
    {
      return tbb::internal::NFS_Free(v7, v6);
    }
  }
  return result;
}

uint64_t tbb::internal::concurrent_vector_base::internal_capacity(tbb::internal::concurrent_vector_base *this)
{
  uint64_t v1 = 0;
  uint64_t v2 = (tbb::internal::concurrent_vector_base *)*((void *)this + 1);
  __dmb(0xBu);
  BOOL v3 = (tbb::internal::concurrent_vector_base *)((char *)this + 16) == v2;
  uint64_t v4 = 64;
  if (v3) {
    uint64_t v4 = 2;
  }
  while (1)
  {
    uint64_t v5 = *((void *)this + 1);
    __dmb(0xBu);
    if (!*(void *)(v5 + 8 * v1)) {
      break;
    }
    if (v4 == ++v1)
    {
      LOBYTE(v1) = v4;
      return (int)((8 << v1) & 0xFFFFFFF0);
    }
  }
  return (int)((8 << v1) & 0xFFFFFFF0);
}

void *tbb::internal::concurrent_vector_base::internal_reserve(void *this, unint64_t a2, uint64_t a3, void *a4)
{
  if (a2 > (unint64_t)a4)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_216767B04(exception, "argument to concurrent_vector::reserve exceeds concurrent_vector::max_size()");
    __cxa_throw(exception, (struct type_info *)off_264293928, MEMORY[0x263F8C060]);
  }
  uint64_t v6 = (uint64_t)this;
  unint64_t v7 = 0;
  unint64_t v8 = (void *)this[1];
  __dmb(0xBu);
  int v9 = this + 2;
  BOOL v10 = this + 2 == v8;
  uint64_t v11 = 64;
  if (v10) {
    uint64_t v11 = 2;
  }
  while (1)
  {
    uint64_t v12 = this[1];
    __dmb(0xBu);
    if (!*(void *)(v12 + 8 * v7)) {
      break;
    }
    if (v11 == ++v7)
    {
      unint64_t v7 = v11;
      break;
    }
  }
  int v13 = 8 << v7;
  if ((int)((8 << v7) & 0xFFFFFFF0) < a2)
  {
    unint64_t v14 = this + 3;
    do
    {
      if (v7 >= 2)
      {
        uint64_t v17 = *(void **)(v6 + 8);
        __dmb(0xBu);
        if (v9 == v17)
        {
          unint64_t v19 = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          *(_OWORD *)unint64_t v19 = 0u;
          *(_OWORD *)(v19 + 16) = 0u;
          *(_OWORD *)(v19 + 32) = 0u;
          *(_OWORD *)(v19 + 48) = 0u;
          *(_OWORD *)(v19 + 64) = 0u;
          *(_OWORD *)(v19 + 80) = 0u;
          *(_OWORD *)(v19 + 96) = 0u;
          *(_OWORD *)(v19 + 112) = 0u;
          *(_OWORD *)(v19 + 128) = 0u;
          *(_OWORD *)(v19 + 144) = 0u;
          *(_OWORD *)(v19 + 160) = 0u;
          *(_OWORD *)(v19 + 176) = 0u;
          *(_OWORD *)(v19 + 192) = 0u;
          *(_OWORD *)(v19 + 208) = 0u;
          *(_OWORD *)(v19 + 224) = 0u;
          *(_OWORD *)(v19 + 240) = 0u;
          *(_OWORD *)(v19 + 256) = 0u;
          *(_OWORD *)(v19 + 272) = 0u;
          *(_OWORD *)(v19 + 288) = 0u;
          *(_OWORD *)(v19 + 304) = 0u;
          *(_OWORD *)(v19 + 320) = 0u;
          *(_OWORD *)(v19 + 336) = 0u;
          *(_OWORD *)(v19 + 352) = 0u;
          *(_OWORD *)(v19 + 368) = 0u;
          *(_OWORD *)(v19 + 384) = 0u;
          *(_OWORD *)(v19 + 400) = 0u;
          *(_OWORD *)(v19 + 416) = 0u;
          *(_OWORD *)(v19 + 432) = 0u;
          *(_OWORD *)(v19 + 448) = 0u;
          *(_OWORD *)(v19 + 464) = 0u;
          *(_OWORD *)(v19 + 480) = 0u;
          *(_OWORD *)(v19 + 496) = 0u;
          while (!*v9 || !*v14)
            sched_yield();
          *(void *)unint64_t v19 = *v9;
          *(void *)(v19 + 8) = *v14;
          while (1)
          {
            int v20 = v17;
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v6 + 8), (unint64_t *)&v20, v19);
            if (v20 == v17) {
              break;
            }
            unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 0, memory_order_relaxed);
            if ((void *)add_explicit != v17)
            {
              if (v9 != (void *)add_explicit) {
                tbb::internal::NFS_Free((tbb::internal *)v19, v18);
              }
              break;
            }
          }
        }
      }
      if (v7) {
        unint64_t v15 = v13;
      }
      else {
        unint64_t v15 = 16;
      }
      this = (void *)tbb::internal::NFS_Allocate(v15, a3, 0, a4);
      uint64_t v16 = *(void *)(v6 + 8);
      __dmb(0xBu);
      *(void *)(v16 + 8 * v7++) = this;
      int v13 = 8 << v7;
    }
    while ((int)((8 << v7) & 0xFFFFFFF0) < a2);
  }
  return this;
}

void sub_216776E24(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unint64_t *tbb::internal::concurrent_vector_base::internal_copy(unint64_t *this, const tbb::internal::concurrent_vector_base *a2, uint64_t a3, void (*a4)(void *, const void *, unint64_t))
{
  unint64_t v4 = *(void *)a2;
  __dmb(0xBu);
  *this = v4;
  uint64_t v5 = this + 2;
  __dmb(0xBu);
  this[1] = (unint64_t)(this + 2);
  if (v4)
  {
    unint64_t v7 = this;
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    BOOL v10 = this + 3;
    int v11 = 8;
    do
    {
      if (v9 >= 2)
      {
        unint64_t v19 = (void *)v7[1];
        __dmb(0xBu);
        if (v5 == v19)
        {
          unint64_t v21 = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          *(_OWORD *)unint64_t v21 = 0u;
          *(_OWORD *)(v21 + 16) = 0u;
          *(_OWORD *)(v21 + 32) = 0u;
          *(_OWORD *)(v21 + 48) = 0u;
          *(_OWORD *)(v21 + 64) = 0u;
          *(_OWORD *)(v21 + 80) = 0u;
          *(_OWORD *)(v21 + 96) = 0u;
          *(_OWORD *)(v21 + 112) = 0u;
          *(_OWORD *)(v21 + 128) = 0u;
          *(_OWORD *)(v21 + 144) = 0u;
          *(_OWORD *)(v21 + 160) = 0u;
          *(_OWORD *)(v21 + 176) = 0u;
          *(_OWORD *)(v21 + 192) = 0u;
          *(_OWORD *)(v21 + 208) = 0u;
          *(_OWORD *)(v21 + 224) = 0u;
          *(_OWORD *)(v21 + 240) = 0u;
          *(_OWORD *)(v21 + 256) = 0u;
          *(_OWORD *)(v21 + 272) = 0u;
          *(_OWORD *)(v21 + 288) = 0u;
          *(_OWORD *)(v21 + 304) = 0u;
          *(_OWORD *)(v21 + 320) = 0u;
          *(_OWORD *)(v21 + 336) = 0u;
          *(_OWORD *)(v21 + 352) = 0u;
          *(_OWORD *)(v21 + 368) = 0u;
          *(_OWORD *)(v21 + 384) = 0u;
          *(_OWORD *)(v21 + 400) = 0u;
          *(_OWORD *)(v21 + 416) = 0u;
          *(_OWORD *)(v21 + 432) = 0u;
          *(_OWORD *)(v21 + 448) = 0u;
          *(_OWORD *)(v21 + 464) = 0u;
          *(_OWORD *)(v21 + 480) = 0u;
          *(_OWORD *)(v21 + 496) = 0u;
          while (!*v5 || !*v10)
            sched_yield();
          *(void *)unint64_t v21 = *v5;
          *(void *)(v21 + 8) = *v10;
          while (1)
          {
            uint64_t v22 = v19;
            atomic_compare_exchange_strong((atomic_ullong *volatile)v7 + 1, (unint64_t *)&v22, v21);
            if (v22 == v19) {
              break;
            }
            unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 0, memory_order_relaxed);
            if ((void *)add_explicit != v19)
            {
              if (v5 != (void *)add_explicit) {
                tbb::internal::NFS_Free((tbb::internal *)v21, v20);
              }
              break;
            }
          }
        }
      }
      if (v9) {
        unint64_t v12 = v11;
      }
      else {
        unint64_t v12 = 16;
      }
      uint64_t v13 = tbb::internal::NFS_Allocate(v12, a3, 0, a4);
      unint64_t v14 = v7[1];
      __dmb(0xBu);
      *(void *)(v14 + 8 * v9) = v13;
      if (v12 >= v4 - v8) {
        unint64_t v15 = v4 - v8;
      }
      else {
        unint64_t v15 = v12;
      }
      unint64_t v16 = v7[1];
      __dmb(0xBu);
      uint64_t v17 = *(void *)(v16 + 8 * v9);
      uint64_t v18 = *((void *)a2 + 1);
      __dmb(0xBu);
      this = (unint64_t *)((uint64_t (*)(uint64_t, void, unint64_t))a4)(v17, *(void *)(v18 + 8 * v9++), v15);
      int v11 = 8 << v9;
      unint64_t v8 = (int)((8 << v9) & 0xFFFFFFF0);
    }
    while (v4 > v8);
  }
  return this;
}

uint64_t tbb::internal::concurrent_vector_base::internal_assign(uint64_t this, const tbb::internal::concurrent_vector_base *a2, uint64_t a3, uint64_t (*a4)(uint64_t, atomic_ullong), void (*a5)(void *, const void *, unint64_t), uint64_t (*a6)(uint64_t, uint64_t, unint64_t))
{
  unint64_t v7 = (atomic_ullong *)this;
  unint64_t v8 = *(void *)a2;
  __dmb(0xBu);
  unint64_t v9 = *(void *)this;
  __dmb(0xBu);
  if (v9 > v8)
  {
    do
    {
      unint64_t v11 = *v7;
      __dmb(0xBu);
      uint64_t v12 = --v11 | 8;
      unint64_t v13 = HIDWORD(v11);
      BOOL v14 = v13 != 0;
      if (!v13) {
        unint64_t v13 = v12;
      }
      uint64_t v15 = 32 * v14;
      if (v13 >= 0x10000)
      {
        v13 >>= 16;
        uint64_t v15 = (32 * v14) | 0x10;
      }
      if (v13 >= 0x100)
      {
        v13 >>= 8;
        v15 |= 8uLL;
      }
      if (v13 >= 0x10)
      {
        v13 >>= 4;
        v15 |= 4uLL;
      }
      if (v13 >= 4)
      {
        v13 >>= 2;
        v15 += 2;
      }
      uint64_t v16 = v15 + ((v13 >> 1) & 1) - 3;
      unint64_t v17 = (int)((8 << v16) & 0xFFFFFFF0);
      atomic_ullong v18 = v7[1];
      __dmb(0xBu);
      uint64_t v19 = *(void *)(v18 + 8 * v16);
      if (v17 <= v8) {
        atomic_ullong v20 = v8;
      }
      else {
        atomic_ullong v20 = v17;
      }
      uint64_t v21 = v19 + (v20 - v17) * a3;
      atomic_ullong v22 = *v7;
      __dmb(0xBu);
      this = a4(v21, v22 - v20);
      __dmb(0xBu);
      *unint64_t v7 = v20;
      unint64_t v23 = *v7;
      __dmb(0xBu);
    }
    while (v23 > v8);
  }
  unint64_t v47 = *v7;
  __dmb(0xBu);
  *unint64_t v7 = v8;
  if (v8)
  {
    unint64_t v24 = 0;
    unint64_t v25 = 0;
    atomic_ullong v26 = v7 + 2;
    unint64_t v27 = v7 + 3;
    int v28 = 8;
    while (1)
    {
      if (v25 >= 2)
      {
        unint64_t v29 = (void *)v7[1];
        __dmb(0xBu);
        if (v26 == v29)
        {
          this = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
          BOOL v42 = (tbb::internal *)this;
          *(_OWORD *)this = 0u;
          *(_OWORD *)(this + 16) = 0u;
          *(_OWORD *)(this + 32) = 0u;
          *(_OWORD *)(this + 48) = 0u;
          *(_OWORD *)(this + 64) = 0u;
          *(_OWORD *)(this + 80) = 0u;
          *(_OWORD *)(this + 96) = 0u;
          *(_OWORD *)(this + 112) = 0u;
          *(_OWORD *)(this + 128) = 0u;
          *(_OWORD *)(this + 144) = 0u;
          *(_OWORD *)(this + 160) = 0u;
          *(_OWORD *)(this + 176) = 0u;
          *(_OWORD *)(this + 192) = 0u;
          *(_OWORD *)(this + 208) = 0u;
          *(_OWORD *)(this + 224) = 0u;
          *(_OWORD *)(this + 240) = 0u;
          *(_OWORD *)(this + 256) = 0u;
          *(_OWORD *)(this + 272) = 0u;
          *(_OWORD *)(this + 288) = 0u;
          *(_OWORD *)(this + 304) = 0u;
          *(_OWORD *)(this + 320) = 0u;
          *(_OWORD *)(this + 336) = 0u;
          *(_OWORD *)(this + 352) = 0u;
          *(_OWORD *)(this + 368) = 0u;
          *(_OWORD *)(this + 384) = 0u;
          *(_OWORD *)(this + 400) = 0u;
          *(_OWORD *)(this + 416) = 0u;
          *(_OWORD *)(this + 432) = 0u;
          *(_OWORD *)(this + 448) = 0u;
          *(_OWORD *)(this + 464) = 0u;
          *(_OWORD *)(this + 480) = 0u;
          *(_OWORD *)(this + 496) = 0u;
          while (!*v26 || !*v27)
            this = sched_yield();
          *(void *)BOOL v42 = *v26;
          *((void *)v42 + 1) = *v27;
          while (1)
          {
            BOOL v43 = v29;
            atomic_compare_exchange_strong(v7 + 1, (unint64_t *)&v43, (unint64_t)v42);
            if (v43 == v29) {
              break;
            }
            unint64_t add_explicit = atomic_fetch_add_explicit(v7 + 1, 0, memory_order_relaxed);
            if ((void *)add_explicit != v29)
            {
              if (v26 != (void *)add_explicit) {
                this = tbb::internal::NFS_Free(v42, v41);
              }
              break;
            }
          }
        }
      }
      if (v25) {
        unint64_t v30 = v28;
      }
      else {
        unint64_t v30 = 16;
      }
      atomic_ullong v31 = v7[1];
      __dmb(0xBu);
      if (!*(void *)(v31 + 8 * v25))
      {
        this = tbb::internal::NFS_Allocate(v30, a3, 0, a4);
        atomic_ullong v32 = v7[1];
        __dmb(0xBu);
        *(void *)(v32 + 8 * v25) = this;
      }
      if (v30 >= v8 - v24) {
        unint64_t v30 = v8 - v24;
      }
      if (v47 > v24) {
        break;
      }
      uint64_t v37 = 0;
      if (v30) {
        goto LABEL_35;
      }
LABEL_18:
      int v28 = 8 << ++v25;
      unint64_t v24 = (int)((8 << v25) & 0xFFFFFFF0);
      if (v8 <= v24) {
        return this;
      }
    }
    if (v47 - v24 >= v30) {
      unint64_t v33 = v30;
    }
    else {
      unint64_t v33 = v47 - v24;
    }
    atomic_ullong v34 = v7[1];
    __dmb(0xBu);
    uint64_t v35 = *(void *)(v34 + 8 * v25);
    uint64_t v36 = *((void *)a2 + 1);
    __dmb(0xBu);
    this = ((uint64_t (*)(uint64_t, void, unint64_t))a5)(v35, *(void *)(v36 + 8 * v25), v33);
    v30 -= v33;
    uint64_t v37 = v33 * a3;
    if (!v30) {
      goto LABEL_18;
    }
LABEL_35:
    atomic_ullong v38 = v7[1];
    __dmb(0xBu);
    uint64_t v39 = *(void *)(v38 + 8 * v25) + v37;
    uint64_t v40 = *((void *)a2 + 1);
    __dmb(0xBu);
    this = a6(v39, *(void *)(v40 + 8 * v25) + v37, v30);
    goto LABEL_18;
  }
  return this;
}

unint64_t tbb::internal::concurrent_vector_base::internal_push_back(atomic_ullong *this, uint64_t a2, unint64_t *a3, void *a4)
{
  unint64_t add = atomic_fetch_add(this, 1uLL);
  *a3 = add;
  unint64_t v7 = add | 8;
  if (HIDWORD(add)) {
    unint64_t v7 = HIDWORD(add);
  }
  uint64_t v8 = 32 * (HIDWORD(add) != 0);
  if (v7 >= 0x10000)
  {
    v7 >>= 16;
    uint64_t v8 = (32 * (HIDWORD(add) != 0)) | 0x10;
  }
  if (v7 >= 0x100)
  {
    v7 >>= 8;
    v8 |= 8uLL;
  }
  if (v7 >= 0x10)
  {
    v7 >>= 4;
    v8 |= 4uLL;
  }
  if (v7 >= 4)
  {
    v7 >>= 2;
    v8 += 2;
  }
  unint64_t v9 = v8 + ((v7 >> 1) & 1) - 3;
  signed int v10 = (8 << v9) & 0xFFFFFFF0;
  if (v9 >= 2)
  {
    unint64_t v11 = (tbb::internal::concurrent_vector_base *)this[1];
    __dmb(0xBu);
    if (this + 2 == (atomic_ullong *)v11)
    {
      unint64_t v16 = tbb::internal::NFS_Allocate(0x40uLL, 8, 0, a4);
      *(_OWORD *)unint64_t v16 = 0u;
      *(_OWORD *)(v16 + 16) = 0u;
      *(_OWORD *)(v16 + 32) = 0u;
      *(_OWORD *)(v16 + 48) = 0u;
      *(_OWORD *)(v16 + 64) = 0u;
      *(_OWORD *)(v16 + 80) = 0u;
      *(_OWORD *)(v16 + 96) = 0u;
      *(_OWORD *)(v16 + 112) = 0u;
      *(_OWORD *)(v16 + 128) = 0u;
      *(_OWORD *)(v16 + 144) = 0u;
      *(_OWORD *)(v16 + 160) = 0u;
      *(_OWORD *)(v16 + 176) = 0u;
      *(_OWORD *)(v16 + 192) = 0u;
      *(_OWORD *)(v16 + 208) = 0u;
      *(_OWORD *)(v16 + 224) = 0u;
      *(_OWORD *)(v16 + 240) = 0u;
      *(_OWORD *)(v16 + 256) = 0u;
      *(_OWORD *)(v16 + 272) = 0u;
      *(_OWORD *)(v16 + 288) = 0u;
      *(_OWORD *)(v16 + 304) = 0u;
      *(_OWORD *)(v16 + 320) = 0u;
      *(_OWORD *)(v16 + 336) = 0u;
      *(_OWORD *)(v16 + 352) = 0u;
      *(_OWORD *)(v16 + 368) = 0u;
      *(_OWORD *)(v16 + 384) = 0u;
      *(_OWORD *)(v16 + 400) = 0u;
      *(_OWORD *)(v16 + 416) = 0u;
      *(_OWORD *)(v16 + 432) = 0u;
      *(_OWORD *)(v16 + 448) = 0u;
      *(_OWORD *)(v16 + 464) = 0u;
      unint64_t v17 = this + 3;
      *(_OWORD *)(v16 + 480) = 0u;
      *(_OWORD *)(v16 + 496) = 0u;
      while (!*(void *)v11 || !*v17)
        sched_yield();
      *(void *)unint64_t v16 = *(void *)v11;
      *(void *)(v16 + 8) = *v17;
      while (1)
      {
        atomic_ullong v18 = v11;
        atomic_compare_exchange_strong(this + 1, (unint64_t *)&v18, v16);
        if (v18 == v11) {
          break;
        }
        if ((tbb::internal::concurrent_vector_base *)atomic_fetch_add_explicit(this + 1, 0, memory_order_relaxed) != v11)
        {
          tbb::internal::NFS_Free((tbb::internal *)v16, v15);
          break;
        }
      }
    }
  }
  atomic_ullong v12 = this[1];
  __dmb(0xBu);
  uint64_t v13 = *(void *)(v12 + 8 * v9);
  if (!v13)
  {
    if (add == v10)
    {
      if (v9) {
        unint64_t v14 = 8 << v9;
      }
      else {
        unint64_t v14 = 16;
      }
      uint64_t v13 = tbb::internal::NFS_Allocate(v14, a2, 0, a4);
      *(void *)(v12 + 8 * v9) = v13;
    }
    else
    {
      while (!*(void *)(v12 + 8 * v9))
        sched_yield();
      uint64_t v13 = *(void *)(v12 + 8 * v9);
    }
  }
  return v13 + (add - v10) * a2;
}

unint64_t tbb::internal::concurrent_vector_base::internal_grow_by(atomic_ullong *this, unint64_t a2, uint64_t a3, uint64_t (*a4)(unint64_t, unint64_t))
{
  unint64_t add = atomic_fetch_add(this, a2);
  tbb::internal::concurrent_vector_base::internal_grow((tbb::internal::concurrent_vector_base *)this, add, add + a2, a3, a4);
  return add;
}

tbb::internal *tbb::internal::concurrent_vector_base::internal_clear(tbb::internal *this, void (*a2)(void *, unint64_t), int a3)
{
  unint64_t v4 = this;
  uint64_t v5 = *(void *)this;
  __dmb(0xBu);
  *(void *)this = 0;
  if (v5)
  {
    do
    {
      unint64_t v7 = (unint64_t)(v5 - 1) >> 32;
      BOOL v8 = v7 != 0;
      if (!v7) {
        unint64_t v7 = (v5 - 1) | 8;
      }
      uint64_t v9 = 32 * v8;
      if (v7 >= 0x10000)
      {
        v7 >>= 16;
        uint64_t v9 = (32 * v8) | 0x10;
      }
      if (v7 >= 0x100)
      {
        v7 >>= 8;
        v9 |= 8uLL;
      }
      if (v7 >= 0x10)
      {
        v7 >>= 4;
        v9 |= 4uLL;
      }
      if (v7 >= 4)
      {
        v7 >>= 2;
        v9 += 2;
      }
      uint64_t v10 = v9 + ((v7 >> 1) & 1) - 3;
      uint64_t v11 = *((void *)v4 + 1);
      __dmb(0xBu);
      signed int v12 = (8 << v10) & 0xFFFFFFF0;
      this = (tbb::internal *)((uint64_t (*)(void, uint64_t))a2)(*(void *)(v11 + 8 * v10), v5 - v12);
      uint64_t v5 = v12;
    }
    while (v12);
  }
  if (a3)
  {
    uint64_t v13 = 0;
    unint64_t v14 = (tbb::internal *)*((void *)v4 + 1);
    __dmb(0xBu);
    uint64_t v15 = (tbb::internal *)((char *)v4 + 16);
    BOOL v16 = (tbb::internal *)((char *)v4 + 16) == v14;
    uint64_t v17 = 64;
    if (v16) {
      uint64_t v17 = 2;
    }
    while (1)
    {
      uint64_t v18 = *((void *)v4 + 1);
      __dmb(0xBu);
      if (!*(void *)(v18 + 8 * v13)) {
        break;
      }
      if (v17 == ++v13)
      {
        uint64_t v13 = v17;
        goto LABEL_20;
      }
    }
    if (!v13) {
      goto LABEL_22;
    }
LABEL_20:
    uint64_t v19 = v13 - 1;
    do
    {
      uint64_t v20 = *((void *)v4 + 1);
      __dmb(0xBu);
      uint64_t v21 = *(tbb::internal **)(v20 + 8 * v19);
      *(void *)(v20 + 8 * v19) = 0;
      tbb::internal::NFS_Free(v21, a2);
      --v19;
    }
    while (v19 != -1);
LABEL_22:
    *((void *)v4 + 2) = 0;
    *((void *)v4 + 3) = 0;
    this = (tbb::internal *)*((void *)v4 + 1);
    __dmb(0xBu);
    if (v15 != this)
    {
      __dmb(0xBu);
      *((void *)v4 + 1) = v15;
      return (tbb::internal *)tbb::internal::NFS_Free(this, a2);
    }
  }
  return this;
}

uint64_t tbb::internal::micro_queue::push(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v7 = a3 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v8 = *(void *)(a4 + 24);
  uint64_t v9 = (v8 - 1) & (a3 >> 3);
  if (v9)
  {
    uint64_t v10 = 0;
  }
  else
  {
    uint64_t v10 = operator new(*(void *)(a4 + 32) * v8 + 16);
    *uint64_t v10 = 0;
    v10[1] = 0;
  }
  unint64_t v11 = v7 + 8;
  while (1)
  {
    uint64_t v12 = *(void *)(a1 + 24);
    __dmb(0xBu);
    if (v12 == v7) {
      break;
    }
    sched_yield();
  }
  if (v10)
  {
    uint64_t v13 = (atomic_uint *)((a1 + 32) & 0xFFFFFFFFFFFFFFFCLL);
LABEL_9:
    int v14 = *v13 & ~(255 << (8 * ((a1 + 32) & 3)));
    while (1)
    {
      int v15 = v14;
      atomic_compare_exchange_strong(v13, (unsigned int *)&v15, v14 | (1 << (8 * ((a1 + 32) & 3))));
      if (v15 == v14) {
        break;
      }
      if (*v13 != v14)
      {
        sched_yield();
        goto LABEL_9;
      }
    }
    BOOL v16 = *(void **)(a1 + 16);
    __dmb(0xBu);
    if (v16)
    {
      *BOOL v16 = v10;
    }
    else
    {
      __dmb(0xBu);
      *(void *)a1 = v10;
    }
    __dmb(0xBu);
    *(void *)(a1 + 16) = v10;
    __dmb(0xBu);
    *(unsigned char *)(a1 + 32) = 0;
  }
  else
  {
    uint64_t v10 = *(void **)(a1 + 16);
    __dmb(0xBu);
  }
  uint64_t result = (**(uint64_t (***)(uint64_t, void *, uint64_t, uint64_t))a4)(a4, v10, v9, a2);
  v10[1] |= 1 << v9;
  __dmb(0xBu);
  *(void *)(a1 + 24) = v11;
  return result;
}

void sub_216777880(_Unwind_Exception *a1)
{
  __dmb(0xBu);
  *(void *)(v1 + 24) = v2;
  _Unwind_Resume(a1);
}

BOOL tbb::internal::micro_queue::pop(tbb::internal::micro_queue *this, void *a2, unint64_t a3, tbb::internal::concurrent_queue_base *a4)
{
  unint64_t v8 = a3 & 0xFFFFFFFFFFFFFFF8;
  for (uint64_t i = *((void *)this + 1); ; uint64_t i = *((void *)this + 1))
  {
    __dmb(0xBu);
    if (i == v8) {
      break;
    }
    sched_yield();
  }
  while (1)
  {
    uint64_t v10 = *((void *)this + 3);
    __dmb(0xBu);
    if (v10 != v8) {
      break;
    }
    sched_yield();
  }
  uint64_t v11 = *(void *)this;
  __dmb(0xBu);
  uint64_t v12 = *((void *)a4 + 3) - 1;
  uint64_t v13 = v12 & (a3 >> 3);
  if (v13 == v12) {
    uint64_t v14 = v11;
  }
  else {
    uint64_t v14 = 0;
  }
  v17[0] = v8 + 8;
  v17[1] = (uint64_t)this;
  v17[2] = v14;
  uint64_t v15 = *(void *)(v11 + 8) & (1 << v13);
  if (v15) {
    (*(void (**)(tbb::internal::concurrent_queue_base *, void *))(*(void *)a4 + 8))(a4, a2);
  }
  sub_216778080(v17);
  return v15 != 0;
}

void sub_216777988(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216778080((uint64_t *)va);
  _Unwind_Resume(a1);
}

tbb::internal::concurrent_queue_base *tbb::internal::concurrent_queue_base::concurrent_queue_base(tbb::internal::concurrent_queue_base *this, unint64_t a2, uint64_t a3, void *a4)
{
  *(void *)this = &unk_26C747048;
  if (a2 >= 9)
  {
    if (a2 >= 0x11)
    {
      if (a2 >= 0x21)
      {
        if (a2 >= 0x41)
        {
          uint64_t v6 = 1;
          if (a2 < 0x81) {
            uint64_t v6 = 2;
          }
        }
        else
        {
          uint64_t v6 = 4;
        }
      }
      else
      {
        uint64_t v6 = 8;
      }
    }
    else
    {
      uint64_t v6 = 16;
    }
  }
  else
  {
    uint64_t v6 = 32;
  }
  unint64_t v7 = 2;
  if (a2 > 2) {
    unint64_t v7 = a2;
  }
  *((void *)this + 2) = 0xFFFFFFFFFFFFFFFFLL / v7;
  *((void *)this + 3) = v6;
  unint64_t v8 = (void *)tbb::internal::NFS_Allocate(1uLL, 576, 0, a4);
  *((void *)this + 1) = v8;
  bzero(v8, 0x240uLL);
  *((void *)this + 4) = a2;
  return this;
}

void tbb::internal::concurrent_queue_base::~concurrent_queue_base(tbb::internal::concurrent_queue_base *this, void *a2)
{
  *(void *)this = &unk_26C747048;
  BOOL v3 = *(void **)(*((void *)this + 1) + 272);
  __dmb(0xBu);
  if (v3) {
    operator delete(v3);
  }
  unint64_t v4 = *(void **)(*((void *)this + 1) + 312);
  __dmb(0xBu);
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(*((void *)this + 1) + 352);
  __dmb(0xBu);
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(*((void *)this + 1) + 392);
  __dmb(0xBu);
  if (v6) {
    operator delete(v6);
  }
  unint64_t v7 = *(void **)(*((void *)this + 1) + 432);
  __dmb(0xBu);
  if (v7) {
    operator delete(v7);
  }
  unint64_t v8 = *(void **)(*((void *)this + 1) + 472);
  __dmb(0xBu);
  if (v8) {
    operator delete(v8);
  }
  uint64_t v9 = *(void **)(*((void *)this + 1) + 512);
  __dmb(0xBu);
  if (v9) {
    operator delete(v9);
  }
  uint64_t v10 = *(void **)(*((void *)this + 1) + 552);
  __dmb(0xBu);
  if (v10) {
    operator delete(v10);
  }
  tbb::internal::NFS_Free(*((tbb::internal **)this + 1), a2);
}

uint64_t tbb::internal::concurrent_queue_base::internal_push(tbb::internal::concurrent_queue_base *this, uint64_t a2)
{
  unint64_t v4 = (uint64_t *)*((void *)this + 1);
  unint64_t add = atomic_fetch_add(v4 + 16, 1uLL);
  if (*((void *)this + 2) != 0x7FFFFFFFFFFFFFFFLL)
  {
    while (1)
    {
      uint64_t v7 = *v4;
      __dmb(0xBu);
      if ((int64_t)(add - v7) < *((void *)this + 2)) {
        break;
      }
      sched_yield();
    }
  }

  return tbb::internal::micro_queue::push((uint64_t)&v4[5 * ((3 * add) & 7) + 32], a2, add, (uint64_t)this);
}

BOOL tbb::internal::concurrent_queue_base::internal_pop(tbb::internal::concurrent_queue_base *this, void *a2)
{
  unint64_t v4 = (atomic_ullong *)*((void *)this + 1);
  do
  {
    unint64_t add = atomic_fetch_add(v4, 1uLL);
    BOOL result = tbb::internal::micro_queue::pop((tbb::internal::micro_queue *)&v4[5 * ((3 * add) & 7) + 32], a2, add, this);
  }
  while (!result);
  return result;
}

BOOL tbb::internal::concurrent_queue_base::internal_pop_if_present(tbb::internal::concurrent_queue_base *this, void *a2)
{
  unint64_t v4 = (atomic_ullong *)*((void *)this + 1);
  while (1)
  {
    unint64_t v5 = *v4;
    __dmb(0xBu);
    unint64_t v6 = v4[16];
    __dmb(0xBu);
    BOOL v7 = v6 > v5;
    if (v6 <= v5) {
      break;
    }
    while (1)
    {
      unint64_t v8 = v5;
      atomic_compare_exchange_strong(v4, &v8, v5 + 1);
      if (v8 == v5) {
        break;
      }
      if (atomic_fetch_add_explicit(v4, 0, memory_order_relaxed) != v5)
      {
        sched_yield();
        unint64_t v5 = *v4;
        __dmb(0xBu);
        unint64_t v9 = v4[16];
        __dmb(0xBu);
        if (v9 <= v5) {
          return 0;
        }
      }
    }
    if (tbb::internal::micro_queue::pop((tbb::internal::micro_queue *)&v4[5 * ((3 * v5) & 7) + 32], a2, v5, this))
    {
      return v7;
    }
  }
  return 0;
}

uint64_t tbb::internal::concurrent_queue_base::internal_push_if_not_full(tbb::internal::concurrent_queue_base *this, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  unint64_t v3 = v2[16];
  __dmb(0xBu);
  uint64_t v4 = *v2;
  __dmb(0xBu);
  if ((int64_t)(v3 - v4) >= *((void *)this + 2)) {
    return 0;
  }
  while (1)
  {
    unint64_t v7 = v3;
    atomic_compare_exchange_strong(v2 + 16, &v7, v3 + 1);
    if (v7 == v3) {
      break;
    }
    if (atomic_fetch_add_explicit(v2 + 16, 0, memory_order_relaxed) != v3)
    {
      sched_yield();
      uint64_t result = 0;
      unint64_t v3 = v2[16];
      __dmb(0xBu);
      uint64_t v9 = *v2;
      __dmb(0xBu);
      if ((int64_t)(v3 - v9) >= *((void *)this + 2)) {
        return result;
      }
    }
  }
  tbb::internal::micro_queue::push((uint64_t)&v2[5 * ((3 * v3) & 7) + 32], a2, v3, (uint64_t)this);
  return 1;
}

uint64_t tbb::internal::concurrent_queue_base::internal_size(tbb::internal::concurrent_queue_base *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 1) + 128);
  __dmb(0xBu);
  uint64_t v2 = **((void **)this + 1);
  __dmb(0xBu);
  return v1 - v2;
}

uint64_t tbb::internal::concurrent_queue_base::internal_set_capacity(uint64_t this, unint64_t a2)
{
  uint64_t v2 = 0x7FFFFFFFFFFFFFFFLL;
  if (a2 < 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v2 = a2;
  }
  *(void *)(this + 16) = v2;
  return this;
}

tbb::internal::concurrent_queue_iterator_base *tbb::internal::concurrent_queue_iterator_base::concurrent_queue_iterator_base(tbb::internal::concurrent_queue_iterator_base *this, const tbb::internal::concurrent_queue_base *a2)
{
  uint64_t v4 = (unint64_t *)operator new(0x50uLL);
  unint64_t v5 = **((void **)a2 + 1);
  __dmb(0xBu);
  unint64_t *v4 = v5;
  v4[1] = (unint64_t)a2;
  unint64_t v6 = (void *)*((void *)a2 + 1);
  unint64_t v7 = v6[32];
  __dmb(0xBu);
  int v4[2] = v7;
  unint64_t v8 = v6[37];
  __dmb(0xBu);
  v4[3] = v8;
  unint64_t v9 = v6[42];
  __dmb(0xBu);
  v4[4] = v9;
  unint64_t v10 = v6[47];
  __dmb(0xBu);
  v4[5] = v10;
  unint64_t v11 = v6[52];
  __dmb(0xBu);
  v4[6] = v11;
  unint64_t v12 = v6[57];
  __dmb(0xBu);
  v4[7] = v12;
  unint64_t v13 = v6[62];
  __dmb(0xBu);
  v4[8] = v13;
  unint64_t v14 = v6[67];
  __dmb(0xBu);
  v4[9] = v14;
  *(void *)this = v4;
  unint64_t v15 = *v4;
  uint64_t v16 = *(void *)(*(void *)(v4[1] + 8) + 128);
  __dmb(0xBu);
  if (v16 == v15) {
    uint64_t v17 = 0;
  }
  else {
    uint64_t v17 = v4[((3 * v15) & 7) + 2]
  }
        + ((*(void *)(v4[1] + 24) - 1) & (v15 >> 3)) * *(void *)(v4[1] + 32)
        + 16;
  *((void *)this + 1) = v17;
  return this;
}

void tbb::internal::concurrent_queue_iterator_base::assign(tbb::internal::concurrent_queue_iterator_base *this, const tbb::internal::concurrent_queue_iterator_base *a2)
{
  uint64_t v4 = *(void **)this;
  unint64_t v5 = *(_OWORD **)a2;
  if (v4 != *(void **)a2)
  {
    if (v4)
    {
      operator delete(v4);
      *(void *)this = 0;
      unint64_t v5 = *(_OWORD **)a2;
    }
    if (v5)
    {
      unint64_t v6 = operator new(0x50uLL);
      *unint64_t v6 = *v5;
      long long v7 = v5[1];
      long long v8 = v5[2];
      long long v9 = v5[4];
      v6[3] = v5[3];
      v6[4] = v9;
      v6[1] = v7;
      int v6[2] = v8;
      *(void *)this = v6;
    }
  }
  *((void *)this + 1) = *((void *)a2 + 1);
}

unint64_t **tbb::internal::concurrent_queue_iterator_base::advance(unint64_t **this)
{
  uint64_t v1 = *this;
  unint64_t v2 = **this;
  unint64_t v3 = (*this)[1];
  if (((*(void *)(v3 + 24) - 1) & ~(v2 >> 3)) == 0)
  {
    uint64_t v4 = &v1[(3 * (_BYTE)v2) & 7];
    int v4[2] = *(void *)v4[2];
    uint64_t v1 = *this;
    unint64_t v3 = (*this)[1];
  }
  unint64_t v5 = v2 + 1;
  *uint64_t v1 = v5;
  uint64_t v6 = *(void *)(*(void *)(v3 + 8) + 128);
  __dmb(0xBu);
  if (v6 == v5) {
    this[1] = 0;
  }
  else {
    this[1] = (unint64_t *)(v1[((3 * v5) & 7) + 2]
  }
                                 + ((*(void *)(v1[1] + 24) - 1) & (v5 >> 3)) * *(void *)(v1[1] + 32)
                                 + 16);
  return this;
}

void tbb::internal::concurrent_queue_iterator_base::~concurrent_queue_iterator_base(void **this)
{
  unint64_t v2 = *this;
  if (v2) {
    operator delete(v2);
  }
  *this = 0;
}

{
  void *v2;

  unint64_t v2 = *this;
  if (v2) {
    operator delete(v2);
  }
  *this = 0;
}

uint64_t *sub_216778080(uint64_t *a1)
{
  unint64_t v2 = (uint64_t *)a1[2];
  if (v2)
  {
    uint64_t v3 = a1[1] + 32;
    uint64_t v4 = (atomic_uint *)(v3 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_3:
    int v5 = *v4 & ~(255 << (8 * (v3 & 3)));
    while (1)
    {
      int v6 = v5;
      atomic_compare_exchange_strong(v4, (unsigned int *)&v6, v5 | (1 << (8 * (v3 & 3))));
      if (v6 == v5) {
        break;
      }
      if (*v4 != v5)
      {
        sched_yield();
        goto LABEL_3;
      }
    }
    uint64_t v7 = *v2;
    long long v8 = (void *)a1[1];
    __dmb(0xBu);
    *long long v8 = v7;
    if (!v7)
    {
      uint64_t v9 = a1[1];
      __dmb(0xBu);
      *(void *)(v9 + 16) = 0;
    }
    __dmb(0xBu);
    *(unsigned char *)uint64_t v3 = 0;
    uint64_t v10 = *a1;
    uint64_t v11 = a1[1];
    __dmb(0xBu);
    *(void *)(v11 + 8) = v10;
    operator delete(v2);
  }
  else
  {
    uint64_t v12 = *a1;
    uint64_t v13 = a1[1];
    __dmb(0xBu);
    *(void *)(v13 + 8) = v12;
  }
  return a1;
}

uint64_t tbb::spin_rw_mutex::internal_acquire_writer(atomic_ullong *a1)
{
  while (1)
  {
    atomic_ullong v2 = *a1;
    if ((*a1 & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      if ((v2 & 2) == 0)
      {
LABEL_6:
        atomic_ullong v3 = *a1;
        unint64_t v4 = *a1 | 2;
        while (1)
        {
          atomic_ullong v5 = v3;
          atomic_compare_exchange_strong(a1, (unint64_t *)&v5, v4);
          if (v5 == v3) {
            break;
          }
          if (atomic_fetch_add_explicit(a1, 0, memory_order_relaxed) != v3)
          {
            sched_yield();
            goto LABEL_6;
          }
        }
      }
      goto LABEL_3;
    }
    atomic_ullong v6 = *a1;
    while (1)
    {
      atomic_ullong v7 = v2;
      atomic_compare_exchange_strong(a1, (unint64_t *)&v7, 1uLL);
      if (v7 == v2) {
        break;
      }
      unint64_t add_explicit = atomic_fetch_add_explicit(a1, 0, memory_order_relaxed);
      if (add_explicit != v2)
      {
        atomic_ullong v6 = add_explicit;
        break;
      }
    }
    if (v6 == v2) {
      return 0;
    }
LABEL_3:
    sched_yield();
  }
}

void *tbb::spin_rw_mutex::internal_release_writer(void *result)
{
  *uint64_t result = 0;
  return result;
}

atomic_ullong *tbb::spin_rw_mutex::internal_acquire_reader(atomic_ullong *result)
{
  uint64_t v1 = result;
  while (1)
  {
    atomic_ullong v2 = *v1;
    if ((*v1 & 3) == 0)
    {
      unint64_t v3 = *v1;
      while (1)
      {
        atomic_ullong v4 = v2;
        atomic_compare_exchange_strong(v1, (unint64_t *)&v4, v2 + 4);
        if (v4 == v2) {
          break;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit(v1, 0, memory_order_relaxed);
        if (add_explicit != v2)
        {
          unint64_t v3 = add_explicit;
          break;
        }
      }
      if (v3 == v2) {
        return result;
      }
    }
    uint64_t result = (atomic_ullong *)sched_yield();
  }
}

uint64_t tbb::spin_rw_mutex::internal_upgrade(atomic_ullong *a1)
{
  do
  {
    atomic_ullong v2 = *a1;
    BOOL v3 = (*a1 & 2) == 0 || (*a1 & 0xFFFFFFFFFFFFFFFCLL) == 4;
    uint64_t v4 = v3;
    if (!v3)
    {
      atomic_fetch_add(a1, 0xFFFFFFFFFFFFFFFCLL);
      while (1)
      {
        atomic_ullong v9 = *a1;
        if ((*a1 & 0xFFFFFFFFFFFFFFFDLL) != 0)
        {
          if ((v9 & 2) == 0)
          {
LABEL_23:
            atomic_ullong v10 = *a1;
            unint64_t v11 = *a1 | 2;
            while (1)
            {
              atomic_ullong v12 = v10;
              atomic_compare_exchange_strong(a1, (unint64_t *)&v12, v11);
              if (v12 == v10) {
                break;
              }
              if (atomic_fetch_add_explicit(a1, 0, memory_order_relaxed) != v10)
              {
                sched_yield();
                goto LABEL_23;
              }
            }
          }
        }
        else
        {
          atomic_ullong v13 = *a1;
          while (1)
          {
            atomic_ullong v14 = v9;
            atomic_compare_exchange_strong(a1, (unint64_t *)&v14, 1uLL);
            if (v14 == v9) {
              break;
            }
            unint64_t add_explicit = atomic_fetch_add_explicit(a1, 0, memory_order_relaxed);
            if (add_explicit != v9)
            {
              atomic_ullong v13 = add_explicit;
              break;
            }
          }
          if (v13 == v9) {
            return v4;
          }
        }
        sched_yield();
      }
    }
    atomic_ullong v5 = *a1;
    while (1)
    {
      atomic_ullong v6 = v2;
      atomic_compare_exchange_strong(a1, (unint64_t *)&v6, v2 | 2);
      if (v6 == v2) {
        break;
      }
      unint64_t v7 = atomic_fetch_add_explicit(a1, 0, memory_order_relaxed);
      if (v7 != v2)
      {
        atomic_ullong v5 = v7;
        break;
      }
    }
  }
  while (v5 != v2);
  while ((*a1 & 0xFFFFFFFFFFFFFFFCLL) != 4)
    sched_yield();
  *a1 = 1;
  return v4;
}

atomic_ullong *tbb::spin_rw_mutex::internal_release_reader(atomic_ullong *result)
{
  return result;
}

void *tbb::spin_rw_mutex::internal_downgrade(void *result)
{
  *uint64_t result = 4;
  return result;
}

BOOL tbb::spin_rw_mutex::internal_try_acquire_writer(atomic_ullong *a1)
{
  atomic_ullong v1 = *a1;
  if ((*a1 & 0xFFFFFFFFFFFFFFFDLL) != 0) {
    return 0;
  }
  unint64_t v2 = *a1;
  while (1)
  {
    atomic_ullong v3 = v1;
    atomic_compare_exchange_strong(a1, (unint64_t *)&v3, 1uLL);
    if (v3 == v1) {
      break;
    }
    unint64_t add_explicit = atomic_fetch_add_explicit(a1, 0, memory_order_relaxed);
    if (add_explicit != v1)
    {
      unint64_t v2 = add_explicit;
      return v2 == v1;
    }
  }
  return v2 == v1;
}

BOOL tbb::spin_rw_mutex::internal_try_acquire_reader(atomic_ullong *a1)
{
  atomic_ullong v1 = *a1;
  uint64_t v2 = *a1 & 3;
  if (!v2)
  {
    do
    {
      unint64_t v4 = v1;
      while (1)
      {
        atomic_ullong v5 = v1;
        atomic_compare_exchange_strong(a1, (unint64_t *)&v5, v1 + 4);
        if (v5 == v1) {
          break;
        }
        unint64_t add_explicit = atomic_fetch_add_explicit(a1, 0, memory_order_relaxed);
        if (add_explicit != v1)
        {
          unint64_t v4 = add_explicit;
          break;
        }
      }
    }
    while (v4 != v1);
  }
  return v2 == 0;
}

void tbb::task::destroy(tbb::task *this, tbb::task *a2)
{
}

uint64_t Alembic::Util::v12::MurmurHash3_x64_128(uint64_t this, unint64_t a2, unint64_t a3, unint64_t *a4, void *a5)
{
  if (a2 >= 0x10)
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    unint64_t v7 = a2 >> 4;
    long long v8 = (void *)(this + 8);
    do
    {
      uint64_t v5 = 5
         * (__ROR8__((0x4CF5AD432745937FLL * ((0x88A129EA80000000 * *(v8 - 1)) | ((0x87C37B91114253D5 * *(v8 - 1)) >> 33))) ^ v5, 37)+ v6)+ 1390208809;
      uint64_t v6 = 5
         * (v5
          + __ROR8__((0x87C37B91114253D5* ((0x4E8B26FE00000000 * *v8) | ((unint64_t)(0x4CF5AD432745937FLL * *v8) >> 31))) ^ v6, 33))+ 944331445;
      v8 += 2;
      --v7;
    }
    while (v7);
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  unint64_t v13 = 0;
  unint64_t v14 = 0;
  unint64_t v15 = 0;
  unint64_t v16 = 0;
  unint64_t v17 = 0;
  unint64_t v18 = 0;
  unint64_t v19 = 0;
  unint64_t v20 = 0;
  unint64_t v21 = 0;
  atomic_ullong v22 = (unsigned __int8 *)(this + (a2 & 0xFFFFFFFFFFFFFFF0));
  switch(a2 & 0xF)
  {
    case 1uLL:
      goto LABEL_20;
    case 2uLL:
      goto LABEL_19;
    case 3uLL:
      goto LABEL_18;
    case 4uLL:
      goto LABEL_17;
    case 5uLL:
      goto LABEL_16;
    case 6uLL:
      goto LABEL_15;
    case 7uLL:
      goto LABEL_14;
    case 8uLL:
      goto LABEL_13;
    case 9uLL:
      goto LABEL_12;
    case 0xAuLL:
      goto LABEL_11;
    case 0xBuLL:
      goto LABEL_10;
    case 0xCuLL:
      goto LABEL_9;
    case 0xDuLL:
      goto LABEL_8;
    case 0xEuLL:
      goto LABEL_7;
    case 0xFuLL:
      unint64_t v9 = (unint64_t)v22[14] << 48;
LABEL_7:
      unint64_t v10 = v9 | ((unint64_t)v22[13] << 40);
LABEL_8:
      unint64_t v11 = v10 ^ ((unint64_t)v22[12] << 32);
LABEL_9:
      unint64_t v12 = v11 ^ ((unint64_t)v22[11] << 24);
LABEL_10:
      unint64_t v13 = v12 ^ ((unint64_t)v22[10] << 16);
LABEL_11:
      unint64_t v14 = v13 ^ ((unint64_t)v22[9] << 8);
LABEL_12:
      v6 ^= 0x87C37B91114253D5
          * ((0x4E8B26FE00000000 * (v14 ^ v22[8])) | ((0x4CF5AD432745937FLL * (v14 ^ v22[8])) >> 31));
LABEL_13:
      unint64_t v15 = (unint64_t)v22[7] << 56;
LABEL_14:
      unint64_t v16 = v15 | ((unint64_t)v22[6] << 48);
LABEL_15:
      unint64_t v17 = v16 ^ ((unint64_t)v22[5] << 40);
LABEL_16:
      unint64_t v18 = v17 ^ ((unint64_t)v22[4] << 32);
LABEL_17:
      unint64_t v19 = v18 ^ ((unint64_t)v22[3] << 24);
LABEL_18:
      unint64_t v20 = v19 ^ ((unint64_t)v22[2] << 16);
LABEL_19:
      unint64_t v21 = v20 ^ ((unint64_t)v22[1] << 8);
LABEL_20:
      v5 ^= 0x4CF5AD432745937FLL
          * ((0x88A129EA80000000 * (v21 ^ *v22)) | ((0x87C37B91114253D5 * (v21 ^ *v22)) >> 33));
      break;
    default:
      break;
  }
  unint64_t v23 = v6 ^ a2;
  unint64_t v24 = v23 + (v5 ^ a2);
  unint64_t v25 = v24 + v23;
  unint64_t v26 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v24 ^ (v24 >> 33))) >> 33));
  unint64_t v27 = 0xC4CEB9FE1A85EC53
      * ((0xFF51AFD7ED558CCDLL * (v25 ^ (v25 >> 33))) ^ ((0xFF51AFD7ED558CCDLL * (v25 ^ (v25 >> 33))) >> 33));
  unint64_t v28 = v27 ^ (v27 >> 33);
  unint64_t v29 = v28 + (v26 ^ (v26 >> 33));
  *a4 = v29;
  a4[1] = v29 + v28;
  return this;
}

BOOL Alembic::Util::v12::isStandardName(unsigned __int8 *a1)
{
  if ((char)a1[23] < 0)
  {
    unint64_t v1 = *((void *)a1 + 1);
    if (!v1) {
      return 0;
    }
    uint64_t v2 = *(unsigned __int8 **)a1;
  }
  else
  {
    unint64_t v1 = a1[23];
    uint64_t v2 = a1;
    if (!a1[23]) {
      return 0;
    }
  }
  int v3 = *v2;
  if (v3 != 95 && (v3 & 0xFFFFFFDF) - 65 > 0x19) {
    return 0;
  }
  if (v1 < 2) {
    return 1;
  }
  uint64_t v6 = (a1[23] & 0x80u) == 0 ? a1 : *(unsigned __int8 **)a1;
  int v7 = v6[1];
  if ((v7 - 48) >= 0xA && v7 != 95 && (v7 & 0xFFFFFFDF) - 65 > 0x19) {
    return 0;
  }
  uint64_t v9 = 2;
  do
  {
    unint64_t v10 = v9;
    if (v1 == v9) {
      break;
    }
    int v11 = v6[v9++];
  }
  while ((v11 - 48) < 0xA || v11 == 95 || (v11 & 0xFFFFFFDF) - 65 < 0x1A);
  return v10 >= v1;
}

std::string *Alembic::Util::v12::makeStandardName(std::string *result, int a2)
{
  if (a2 != 95 && ((a2 & 0xDF) - 65) >= 0x1Au)
  {
    sub_216778A5C((uint64_t)v18);
    sub_216779180(v19, (uint64_t)"Cannot fix bad name (bad fix character).", 40);
    std::stringbuf::str();
    sub_216778E70(v17, &__p);
    if (v16 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v14 = sub_216779038(exception, (uint64_t)v17);
    __cxa_throw(v14, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (SHIBYTE(result->__r_.__value_.__r.__words[2]) < 0)
  {
    unint64_t size = result->__r_.__value_.__l.__size_;
    if (size)
    {
      uint64_t v6 = (std::string *)result->__r_.__value_.__r.__words[0];
      int v11 = *(unsigned __int8 *)result->__r_.__value_.__l.__data_;
      if (*result->__r_.__value_.__l.__data_)
      {
        if (v11 == 95 || (v11 & 0xFFFFFFDF) - 65 < 0x1A)
        {
LABEL_14:
          if (size >= 2)
          {
            for (uint64_t i = 1; i != size; ++i)
            {
              if ((result->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                long long v8 = result;
              }
              else {
                long long v8 = (std::string *)result->__r_.__value_.__r.__words[0];
              }
              int v9 = v8->__r_.__value_.__s.__data_[i];
              if ((v9 - 48) >= 0xA && v9 != 95 && (v9 & 0xFFFFFFDF) - 65 >= 0x1A) {
                v8->__r_.__value_.__s.__data_[i] = a2;
              }
            }
          }
          return result;
        }
LABEL_13:
        v6->__r_.__value_.__s.__data_[0] = a2;
        goto LABEL_14;
      }
    }
  }
  else
  {
    unint64_t size = HIBYTE(result->__r_.__value_.__r.__words[2]);
    int v3 = result->__r_.__value_.__s.__data_[0];
    if (*((unsigned char *)&result->__r_.__value_.__s + 23)) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4)
    {
      BOOL v5 = v3 != 95 && (v3 & 0xFFFFFFDF) - 65 >= 0x1A;
      uint64_t v6 = result;
      if (!v5) {
        goto LABEL_14;
      }
      goto LABEL_13;
    }
  }

  return std::string::operator=(result, a2);
}

void sub_216778A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_216778A5C(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C328] + 104;
  *(void *)(a1 + 128) = MEMORY[0x263F8C328] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x263F8C328] + 64;
  *(void *)(a1 + 16) = MEMORY[0x263F8C328] + 64;
  std::exception v5 = (void *)MEMORY[0x263F8C2B8];
  uint64_t v6 = *(void *)(MEMORY[0x263F8C2B8] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x263F8C2B8] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x263F8C328] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_216778D0C(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x21D447E60](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_216778D38(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B8];
  uint64_t v3 = *MEMORY[0x263F8C2B8];
  *(void *)a1 = *MEMORY[0x263F8C2B8];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x21D447E60](a1 + 128);
  return a1;
}

void *sub_216778E70(void *a1, long long *a2)
{
  uint64_t v3 = a1 + 1;
  if (*((char *)a2 + 23) < 0)
  {
    sub_216778F24(v3, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    int v3[2] = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  *a1 = &unk_26C7470E8;
  return a1;
}

void sub_216778EE0(std::exception *a1)
{
  uint64_t v1 = sub_216779148(a1);

  operator delete(v1);
}

uint64_t sub_216778F08(uint64_t a1)
{
  uint64_t result = a1 + 8;
  if (*(char *)(a1 + 31) < 0) {
    return *(void *)result;
  }
  return result;
}

void *sub_216778F24(unsigned char *__dst, void *__src, unint64_t a3)
{
  std::exception v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_216778FC4();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v8 = operator new(v6 + 1);
    v5[1] = a3;
    int v5[2] = v7 | 0x8000000000000000;
    *std::exception v5 = v8;
    std::exception v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }

  return memmove(v5, __src, a3 + 1);
}

void sub_216778FC4()
{
}

void sub_216778FDC(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_216767B04(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_264293928, MEMORY[0x263F8C060]);
}

void sub_216779024(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_216779038(void *a1, uint64_t a2)
{
  uint64_t v3 = a1 + 1;
  uint64_t v6 = *(char **)(a2 + 8);
  long long v4 = (char *)(a2 + 8);
  std::exception v5 = v6;
  if (v4[23] < 0) {
    long long v4 = v5;
  }
  sub_216779094(v3, v4);
  *a1 = &unk_26C7470E8;
  return a1;
}

void *sub_216779094(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_216778FC4();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

std::exception *sub_216779148(std::exception *a1)
{
  std::exception::~exception(a1);
  if (*(char *)(v2 + 31) < 0) {
    operator delete(a1[1].__vftable);
  }
  return a1;
}

void *sub_216779180(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x21D447A00](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&v14, MEMORY[0x263F8C108]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!sub_216779324(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x21D447A10](v13);
  return a1;
}

void sub_2167792BC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x21D447A10](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x21677929CLL);
}

void sub_216779310(_Unwind_Exception *a1)
{
}

uint64_t sub_216779324(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      sub_2167794AC(__p, v12, __c);
      unint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_216779490(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_2167794AC(void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_216778FC4();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

unsigned __int8 *Alembic::Util::v12::SpookyHash::Short(unsigned __int8 *this, unint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v5 = a2 & 0x1F;
  uint64_t v6 = *a3;
  unint64_t v7 = *a4;
  if (a2 < 0x10)
  {
    unint64_t v10 = 0xDEADBEEFDEADBEEFLL;
    unint64_t v9 = 0xDEADBEEFDEADBEEFLL;
  }
  else
  {
    if (((a2 >> 3) & 0x1FFFFFFFFFFFFFFCLL) != 0)
    {
      unint64_t v8 = (unint64_t)&this[8 * ((a2 >> 3) & 0x1FFFFFFFFFFFFFFCLL)];
      unint64_t v9 = 0xDEADBEEFDEADBEEFLL;
      unint64_t v10 = 0xDEADBEEFDEADBEEFLL;
      do
      {
        unint64_t v11 = *((void *)this + 1) + v9;
        unint64_t v12 = v11 + __ROR8__(*(void *)this + v10, 14);
        unint64_t v13 = v12 ^ v6;
        unint64_t v14 = v13 + __ROR8__(v11, 12);
        unint64_t v15 = v14 ^ v7;
        unint64_t v16 = v15 + __ROR8__(v13, 34);
        unint64_t v17 = v16 ^ v12;
        unint64_t v18 = v17 + __ROR8__(v15, 23);
        uint64_t v19 = v18 ^ v14;
        uint64_t v20 = v19 + __ROR8__(v17, 10);
        uint64_t v21 = v20 ^ v16;
        uint64_t v22 = v21 + __ROR8__(v19, 16);
        uint64_t v23 = v22 ^ v18;
        uint64_t v24 = v23 + __ROR8__(v21, 26);
        uint64_t v25 = v24 ^ v20;
        uint64_t v26 = v25 + __ROR8__(v23, 27);
        uint64_t v27 = v26 ^ v22;
        uint64_t v28 = v27 + __ROR8__(v25, 2);
        uint64_t v29 = v28 ^ v24;
        uint64_t v30 = v29 + __ROR8__(v27, 30);
        uint64_t v31 = v30 ^ v26;
        uint64_t v32 = v31 + __ROR8__(v29, 59);
        unint64_t v10 = v32 ^ v28;
        uint64_t v33 = __ROR8__(v31, 28);
        uint64_t v6 = v32 + *((void *)this + 2);
        unint64_t v9 = (v10 + v33) ^ v30;
        unint64_t v7 = v10 + v33 + *((void *)this + 3);
        this += 32;
      }
      while ((unint64_t)this < v8);
    }
    else
    {
      unint64_t v10 = 0xDEADBEEFDEADBEEFLL;
      unint64_t v9 = 0xDEADBEEFDEADBEEFLL;
    }
    if (v5 >= 0x10)
    {
      uint64_t v34 = *(void *)this;
      uint64_t v35 = *((void *)this + 1);
      this += 16;
      uint64_t v36 = v35 + v9;
      uint64_t v37 = v36 + __ROR8__(v34 + v10, 14);
      uint64_t v38 = v37 ^ v6;
      uint64_t v39 = v38 + __ROR8__(v36, 12);
      unint64_t v40 = v39 ^ v7;
      unint64_t v41 = v40 + __ROR8__(v38, 34);
      uint64_t v42 = v41 ^ v37;
      uint64_t v43 = v42 + __ROR8__(v40, 23);
      uint64_t v44 = v43 ^ v39;
      uint64_t v45 = v44 + __ROR8__(v42, 10);
      uint64_t v46 = v45 ^ v41;
      uint64_t v47 = v46 + __ROR8__(v44, 16);
      uint64_t v48 = v47 ^ v43;
      uint64_t v49 = v48 + __ROR8__(v46, 26);
      uint64_t v50 = v49 ^ v45;
      uint64_t v51 = v50 + __ROR8__(v48, 27);
      uint64_t v52 = v51 ^ v47;
      uint64_t v53 = v52 + __ROR8__(v50, 2);
      uint64_t v54 = v53 ^ v49;
      uint64_t v55 = v54 + __ROR8__(v52, 30);
      uint64_t v56 = v55 ^ v51;
      uint64_t v6 = v56 + __ROR8__(v54, 59);
      unint64_t v10 = v6 ^ v53;
      unint64_t v7 = v10 + __ROR8__(v56, 28);
      unint64_t v9 = v7 ^ v55;
      v5 -= 16;
    }
  }
  unint64_t v57 = v9 + (a2 << 56);
  switch(v5)
  {
    case 0uLL:
      v10 -= 0x2152411021524111;
      v57 -= 0x2152411021524111;
      break;
    case 1uLL:
      goto LABEL_14;
    case 2uLL:
      goto LABEL_13;
    case 3uLL:
      v10 += (unint64_t)this[2] << 16;
LABEL_13:
      v10 += (unint64_t)this[1] << 8;
LABEL_14:
      uint64_t v58 = *this;
      goto LABEL_19;
    case 4uLL:
      goto LABEL_18;
    case 5uLL:
      goto LABEL_17;
    case 6uLL:
      goto LABEL_16;
    case 7uLL:
      v10 += (unint64_t)this[6] << 48;
LABEL_16:
      v10 += (unint64_t)this[5] << 40;
LABEL_17:
      v10 += (unint64_t)this[4] << 32;
LABEL_18:
      uint64_t v58 = *(unsigned int *)this;
LABEL_19:
      v10 += v58;
      break;
    case 8uLL:
      goto LABEL_28;
    case 9uLL:
      goto LABEL_22;
    case 0xAuLL:
      goto LABEL_21;
    case 0xBuLL:
      v57 += (unint64_t)this[10] << 16;
LABEL_21:
      v57 += (unint64_t)this[9] << 8;
LABEL_22:
      uint64_t v59 = this[8];
      goto LABEL_27;
    case 0xCuLL:
      goto LABEL_26;
    case 0xDuLL:
      goto LABEL_25;
    case 0xEuLL:
      goto LABEL_24;
    case 0xFuLL:
      v57 += (unint64_t)this[14] << 48;
LABEL_24:
      v57 += (unint64_t)this[13] << 40;
LABEL_25:
      v57 += (unint64_t)this[12] << 32;
LABEL_26:
      uint64_t v59 = *((unsigned int *)this + 2);
LABEL_27:
      v57 += v59;
LABEL_28:
      v10 += *(void *)this;
      break;
    default:
      break;
  }
  unint64_t v60 = (v57 ^ v10) + __ROR8__(v10, 49);
  unint64_t v61 = (v60 ^ v6) + __ROR8__(v60, 12);
  unint64_t v62 = (v61 ^ v7) + __ROR8__(v61, 38);
  unint64_t v63 = (v62 ^ __ROR8__(v10, 49)) + __ROR8__(v62, 13);
  uint64_t v64 = (v63 ^ __ROR8__(v60, 12)) + __ROR8__(v63, 36);
  uint64_t v65 = (v64 ^ __ROR8__(v61, 38)) + __ROR8__(v64, 55);
  uint64_t v66 = (v65 ^ __ROR8__(v62, 13)) + __ROR8__(v65, 17);
  uint64_t v67 = (v66 ^ __ROR8__(v63, 36)) + __ROR8__(v66, 10);
  uint64_t v68 = (v67 ^ __ROR8__(v64, 55)) + __ROR8__(v67, 32);
  uint64_t v69 = (v68 ^ __ROR8__(v65, 17)) + __ROR8__(v68, 39);
  uint64_t v70 = v69 ^ __ROR8__(v66, 10);
  uint64_t v71 = __ROR8__(v69, 1);
  *a3 = v71;
  *a4 = v70 + v71;
  return this;
}

unsigned __int8 *Alembic::Util::v12::SpookyHash::Hash128(Alembic::Util::v12::SpookyHash *this, unint64_t a2, uint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v103 = *MEMORY[0x263EF8340];
  if (a2 > 0xBF)
  {
    unint64_t v6 = 0xDEADBEEFDEADBEEFLL;
    uint64_t v7 = *a3;
    unint64_t v8 = *a4;
    unint64_t v9 = (Alembic::Util::v12::SpookyHash *)((char *)this + 96 * (a2 / 0x60));
    if ((uint64_t)(96 * (a2 / 0x60)) < 1)
    {
      unint64_t v18 = *a3;
      unint64_t v17 = *a4;
      unint64_t v16 = 0xDEADBEEFDEADBEEFLL;
      uint64_t v15 = *a3;
      unint64_t v14 = *a4;
      unint64_t v13 = 0xDEADBEEFDEADBEEFLL;
      uint64_t v12 = *a3;
      unint64_t v11 = *a4;
      unint64_t v10 = 0xDEADBEEFDEADBEEFLL;
    }
    else
    {
      unint64_t v10 = 0xDEADBEEFDEADBEEFLL;
      unint64_t v11 = *a4;
      uint64_t v12 = *a3;
      unint64_t v13 = 0xDEADBEEFDEADBEEFLL;
      unint64_t v14 = *a4;
      uint64_t v15 = *a3;
      unint64_t v16 = 0xDEADBEEFDEADBEEFLL;
      unint64_t v17 = *a4;
      unint64_t v18 = *a3;
      do
      {
        unint64_t v19 = *(void *)this + v18;
        unint64_t v20 = (v19 ^ v6) + v17;
        unint64_t v21 = *((void *)this + 1) + v17;
        unint64_t v22 = (v21 ^ __ROR8__(v19, 53)) + (v8 ^ v16);
        unint64_t v23 = *((void *)this + 2) + (v8 ^ v16);
        unint64_t v24 = (v23 ^ __ROR8__(v21, 32)) + (v20 ^ v15);
        uint64_t v25 = (v20 ^ v15) + *((void *)this + 3);
        unint64_t v16 = (v25 ^ __ROR8__(v23, 21)) + (v22 ^ v14);
        unint64_t v26 = (v22 ^ v14) + *((void *)this + 4);
        uint64_t v15 = (v26 ^ __ROR8__(v25, 33)) + (v24 ^ v13);
        unint64_t v27 = (v24 ^ v13) + *((void *)this + 5);
        unint64_t v14 = (v27 ^ __ROR8__(v26, 47)) + (v16 ^ v12);
        unint64_t v28 = (v16 ^ v12) + *((void *)this + 6);
        unint64_t v13 = (v28 ^ __ROR8__(v27, 36)) + (v15 ^ v11);
        unint64_t v29 = (v15 ^ v11) + *((void *)this + 7);
        uint64_t v12 = (v29 ^ __ROR8__(v28, 25)) + (v14 ^ v10);
        unint64_t v30 = (v14 ^ v10) + *((void *)this + 8);
        unint64_t v11 = (v30 ^ __ROR8__(v29, 7)) + (v13 ^ v7);
        unint64_t v31 = (v13 ^ v7) + *((void *)this + 9);
        unint64_t v10 = (v31 ^ __ROR8__(v30, 9)) + (v12 ^ v8);
        unint64_t v32 = (v12 ^ v8) + *((void *)this + 10);
        unint64_t v33 = v11 ^ v20;
        unint64_t v18 = v10 ^ v22;
        uint64_t v7 = (v32 ^ __ROR8__(v31, 10)) + v33;
        unint64_t v34 = v33 + *((void *)this + 11);
        unint64_t v17 = v7 ^ v24;
        unint64_t v6 = __ROR8__(v34, 18);
        unint64_t v8 = (v34 ^ __ROR8__(v32, 42)) + v18;
        this = (Alembic::Util::v12::SpookyHash *)((char *)this + 96);
      }
      while (this < v9);
    }
    unint64_t v86 = v8;
    unint64_t v87 = v6;
    unint64_t v90 = a2 % 0x60;
    memcpy(&__dst, v9, a2 % 0x60);
    bzero((char *)&__dst + v90, 96 - v90);
    HIBYTE(v102) = v90;
    unint64_t v35 = v92 + v17 + v87 + v102;
    unint64_t v36 = __dst + v18 + (v35 ^ (v93 + v16));
    unint64_t v37 = (v36 ^ (v94 + v15)) + __ROR8__(v92 + v17, 20);
    unint64_t v38 = (v37 ^ (v95 + v14)) + __ROR8__(v35 ^ (v93 + v16), 49);
    unint64_t v39 = (v38 ^ (v96 + v13)) + __ROR8__(v36 ^ (v94 + v15), 30);
    unint64_t v40 = (v39 ^ (v97 + v12)) + __ROR8__(v37 ^ (v95 + v14), 43);
    unint64_t v41 = (v40 ^ (v98 + v11)) + __ROR8__(v38 ^ (v96 + v13), 26);
    unint64_t v42 = (v41 ^ (v99 + v10)) + __ROR8__(v39 ^ (v97 + v12), 31);
    uint64_t v43 = (v42 ^ (v100 + v7)) + __ROR8__(v40 ^ (v98 + v11), 54);
    unint64_t v44 = (v43 ^ (v101 + v86)) + __ROR8__(v41 ^ (v99 + v10), 51);
    unint64_t v45 = v44 ^ v35;
    unint64_t v46 = v45 + __ROR8__(v42 ^ (v100 + v7), 26);
    unint64_t v47 = v46 ^ v36;
    unint64_t v48 = v47 + __ROR8__(v43 ^ (v101 + v86), 11);
    unint64_t v49 = v48 ^ v37;
    unint64_t v50 = v49 + __ROR8__(v45, 22);
    unint64_t v51 = v50 ^ v38;
    unint64_t v52 = v51 + __ROR8__(v47, 10);
    unint64_t v53 = v52 ^ v39;
    unint64_t v54 = v53 + __ROR8__(v49, 20);
    unint64_t v55 = v54 ^ v40;
    unint64_t v56 = v55 + __ROR8__(v51, 49);
    unint64_t v57 = v56 ^ v41;
    unint64_t v58 = v57 + __ROR8__(v53, 30);
    unint64_t v59 = v58 ^ v42;
    unint64_t v60 = v59 + __ROR8__(v55, 43);
    uint64_t v61 = v60 ^ v43;
    uint64_t v62 = v61 + __ROR8__(v57, 26);
    unint64_t v63 = v62 ^ v44;
    unint64_t v64 = v63 + __ROR8__(v59, 31);
    uint64_t v65 = v64 ^ v46;
    uint64_t v66 = v65 + __ROR8__(v61, 54);
    uint64_t v67 = v66 ^ v48;
    uint64_t v68 = v67 + __ROR8__(v63, 51);
    uint64_t v69 = v68 ^ v50;
    uint64_t v70 = v69 + __ROR8__(v65, 26);
    uint64_t v71 = v70 ^ v52;
    uint64_t result = (unsigned __int8 *)(v71 + __ROR8__(v67, 11));
    uint64_t v72 = (unint64_t)result ^ v54;
    uint64_t v73 = v72 + __ROR8__(v69, 22);
    uint64_t v74 = v73 ^ v56;
    uint64_t v75 = v74 + __ROR8__(v71, 10);
    uint64_t v76 = v75 ^ v58;
    uint64_t v77 = v76 + __ROR8__(v72, 20);
    uint64_t v78 = v77 ^ v60;
    uint64_t v79 = (v78 + __ROR8__(v74, 49)) ^ v62;
    uint64_t v80 = (v79 + __ROR8__(v76, 30)) ^ v64;
    uint64_t v81 = (v80 + __ROR8__(v78, 43)) ^ v66;
    uint64_t v82 = (v81 + __ROR8__(v79, 26)) ^ v68;
    uint64_t v83 = (v82 + __ROR8__(v80, 31)) ^ v70;
    uint64_t v84 = (v83 + __ROR8__(v81, 54)) ^ (unint64_t)result;
    uint64_t v85 = (((v84 + __ROR8__(v82, 51)) ^ v73) + __ROR8__(v83, 26)) ^ v75;
    *a3 = __ROR8__(v85, 10);
    *a4 = (v85 + __ROR8__(v84, 11)) ^ v77;
  }
  else
  {
    return Alembic::Util::v12::SpookyHash::Short((unsigned __int8 *)this, a2, a3, a4, a5);
  }
  return result;
}

uint64_t Alembic::Util::v12::SpookyHash::Init(uint64_t this, uint64_t a2, uint64_t a3)
{
  *(void *)(this + 288) = 0;
  *(unsigned char *)(this + 296) = 0;
  *(void *)(this + 192) = a2;
  *(void *)(this + 200) = a3;
  return this;
}

void *Alembic::Util::v12::SpookyHash::Update(Alembic::Util::v12::SpookyHash *this, void *__src, size_t __n)
{
  size_t v3 = __n;
  size_t v4 = __src;
  uint64_t v5 = *((unsigned __int8 *)this + 296);
  char v6 = v5 + __n;
  if (v5 + __n > 0xBF)
  {
    unint64_t v10 = *((void *)this + 36);
    unint64_t v12 = *((void *)this + 24);
    unint64_t v11 = *((void *)this + 25);
    if (v10 >= 0xC0)
    {
      unint64_t v13 = *((void *)this + 26);
      unint64_t v14 = *((void *)this + 27);
      unint64_t v15 = *((void *)this + 28);
      unint64_t v16 = *((void *)this + 29);
      unint64_t v17 = *((void *)this + 30);
      unint64_t v18 = *((void *)this + 31);
      unint64_t v19 = *((void *)this + 32);
      unint64_t v20 = *((void *)this + 33);
      unint64_t v21 = *((void *)this + 34);
      unint64_t v22 = *((void *)this + 35);
    }
    else
    {
      unint64_t v13 = 0xDEADBEEFDEADBEEFLL;
      unint64_t v14 = *((void *)this + 24);
      unint64_t v15 = *((void *)this + 25);
      unint64_t v16 = 0xDEADBEEFDEADBEEFLL;
      unint64_t v17 = v14;
      unint64_t v18 = v15;
      unint64_t v19 = 0xDEADBEEFDEADBEEFLL;
      unint64_t v20 = v14;
      unint64_t v21 = v15;
      unint64_t v22 = 0xDEADBEEFDEADBEEFLL;
    }
    *((void *)this + 36) = v10 + v3;
    if (v5)
    {
      unsigned __int8 v91 = -64 - v5;
      size_t v92 = v3;
      unint64_t v97 = v17;
      uint64_t __dst = this;
      unint64_t v93 = v13;
      unint64_t v95 = v15;
      memcpy((char *)this + v5, __src, (-64 - v5));
      unint64_t v23 = *(void *)__dst + v12;
      unint64_t v24 = (v23 ^ v22) + v11;
      unint64_t v25 = *((void *)__dst + 1) + v11;
      unint64_t v26 = (v25 ^ __ROR8__(v23, 53)) + (v21 ^ v93);
      unint64_t v27 = *((void *)__dst + 2) + (v21 ^ v93);
      unint64_t v28 = (v27 ^ __ROR8__(v25, 32)) + (v24 ^ v14);
      unint64_t v29 = (v24 ^ v14) + *((void *)__dst + 3);
      unint64_t v30 = (v29 ^ __ROR8__(v27, 21)) + (v26 ^ v95);
      unint64_t v31 = (v26 ^ v95) + *((void *)__dst + 4);
      unint64_t v32 = (v31 ^ __ROR8__(v29, 33)) + (v28 ^ v16);
      unint64_t v33 = (v28 ^ v16) + *((void *)__dst + 5);
      unint64_t v34 = (v33 ^ __ROR8__(v31, 47)) + (v30 ^ v97);
      unint64_t v35 = (v30 ^ v97) + *((void *)__dst + 6);
      unint64_t v36 = (v35 ^ __ROR8__(v33, 36)) + (v32 ^ v18);
      unint64_t v37 = (v32 ^ v18) + *((void *)__dst + 7);
      unint64_t v38 = (v37 ^ __ROR8__(v35, 25)) + (v34 ^ v19);
      unint64_t v39 = (v34 ^ v19) + *((void *)__dst + 8);
      unint64_t v40 = (v39 ^ __ROR8__(v37, 7)) + (v36 ^ v20);
      unint64_t v41 = (v36 ^ v20) + *((void *)__dst + 9);
      unint64_t v42 = v40 ^ v24;
      unint64_t v43 = (v41 ^ __ROR8__(v39, 9)) + (v38 ^ v21);
      unint64_t v44 = (v38 ^ v21) + *((void *)__dst + 10);
      unint64_t v45 = v43 ^ v26;
      unint64_t v46 = (v44 ^ __ROR8__(v41, 10)) + v42;
      unint64_t v47 = v42 + *((void *)__dst + 11);
      unint64_t v48 = v46 ^ v28;
      unint64_t v49 = (v47 ^ __ROR8__(v44, 42)) + v45;
      unint64_t v50 = v45 + *((void *)__dst + 12);
      uint64_t v51 = v49 ^ v30;
      unint64_t v52 = (v50 ^ __ROR8__(v47, 18)) + (v46 ^ v28);
      unint64_t v53 = v48 + *((void *)__dst + 13);
      unint64_t v54 = v52 ^ v32;
      unint64_t v55 = (v53 ^ __ROR8__(v50, 53)) + v51;
      uint64_t v56 = v51 + *((void *)__dst + 14);
      unint64_t v57 = v55 ^ v34;
      unint64_t v58 = (v56 ^ __ROR8__(v53, 32)) + v54;
      unint64_t v59 = v54 + *((void *)__dst + 15);
      unint64_t v60 = v58 ^ v36;
      unint64_t v13 = (v59 ^ __ROR8__(v56, 21)) + v57;
      unint64_t v61 = v57 + *((void *)__dst + 16);
      unint64_t v14 = (v61 ^ __ROR8__(v59, 33)) + v60;
      unint64_t v62 = v60 + *((void *)__dst + 17);
      unint64_t v15 = (v62 ^ __ROR8__(v61, 47)) + (v13 ^ v38);
      unint64_t v63 = (v13 ^ v38) + *((void *)__dst + 18);
      unint64_t v64 = v15 ^ v43;
      unint64_t v16 = (v63 ^ __ROR8__(v62, 36)) + (v14 ^ v40);
      unint64_t v65 = (v14 ^ v40) + *((void *)__dst + 19);
      unint64_t v66 = v16 ^ v46;
      this = __dst;
      unint64_t v17 = (v65 ^ __ROR8__(v63, 25)) + (v15 ^ v43);
      unint64_t v67 = v64 + *((void *)__dst + 20);
      unint64_t v18 = (v67 ^ __ROR8__(v65, 7)) + v66;
      unint64_t v68 = v66 + *((void *)__dst + 21);
      unint64_t v19 = (v68 ^ __ROR8__(v67, 9)) + (v17 ^ v49);
      unint64_t v69 = (v17 ^ v49) + *((void *)__dst + 22);
      unint64_t v70 = v18 ^ v52;
      unint64_t v71 = v70 + *((void *)__dst + 23);
      unint64_t v22 = __ROR8__(v71, 18);
      unint64_t v12 = v19 ^ v55;
      unint64_t v20 = (v69 ^ __ROR8__(v68, 10)) + v70;
      unint64_t v11 = v20 ^ v58;
      unint64_t v21 = (v71 ^ __ROR8__(v69, 42)) + (v19 ^ v55);
      size_t v4 = (void *)((char *)v4 + v91);
      size_t v3 = v92 - v91;
    }
    uint64_t v72 = &v4[12 * (v3 / 0x60)];
    size_t v73 = v3 + 160 * (v3 / 0x60);
    if ((uint64_t)(96 * (v3 / 0x60)) >= 1)
    {
      do
      {
        unint64_t v74 = *v4 + v12;
        unint64_t v75 = (v74 ^ v22) + v11;
        unint64_t v76 = v4[1] + v11;
        unint64_t v77 = (v76 ^ __ROR8__(v74, 53)) + (v21 ^ v13);
        unint64_t v78 = v4[2] + (v21 ^ v13);
        unint64_t v79 = (v78 ^ __ROR8__(v76, 32)) + (v75 ^ v14);
        unint64_t v80 = (v75 ^ v14) + v4[3];
        unint64_t v13 = (v80 ^ __ROR8__(v78, 21)) + (v77 ^ v15);
        unint64_t v81 = (v77 ^ v15) + v4[4];
        unint64_t v14 = (v81 ^ __ROR8__(v80, 33)) + (v79 ^ v16);
        unint64_t v82 = (v79 ^ v16) + v4[5];
        unint64_t v15 = (v82 ^ __ROR8__(v81, 47)) + (v13 ^ v17);
        unint64_t v83 = (v13 ^ v17) + v4[6];
        unint64_t v16 = (v83 ^ __ROR8__(v82, 36)) + (v14 ^ v18);
        unint64_t v84 = (v14 ^ v18) + v4[7];
        unint64_t v17 = (v84 ^ __ROR8__(v83, 25)) + (v15 ^ v19);
        unint64_t v85 = (v15 ^ v19) + v4[8];
        unint64_t v18 = (v85 ^ __ROR8__(v84, 7)) + (v16 ^ v20);
        unint64_t v86 = (v16 ^ v20) + v4[9];
        unint64_t v19 = (v86 ^ __ROR8__(v85, 9)) + (v17 ^ v21);
        unint64_t v87 = (v17 ^ v21) + v4[10];
        unint64_t v88 = v18 ^ v75;
        unint64_t v12 = v19 ^ v77;
        unint64_t v20 = (v87 ^ __ROR8__(v86, 10)) + v88;
        unint64_t v89 = v88 + v4[11];
        unint64_t v11 = v20 ^ v79;
        unint64_t v22 = __ROR8__(v89, 18);
        unint64_t v21 = (v89 ^ __ROR8__(v87, 42)) + v12;
        v4 += 12;
      }
      while (v4 < v72);
    }
    unint64_t v94 = v13;
    unint64_t v96 = v15;
    unint64_t v98 = v17;
    *((unsigned char *)this + 296) = v73;
    unint64_t v90 = this;
    uint64_t result = memcpy(this, v72, v73);
    *((void *)v90 + 24) = v12;
    *((void *)v90 + 25) = v11;
    *((void *)v90 + 26) = v94;
    *((void *)v90 + 27) = v14;
    *((void *)v90 + 28) = v96;
    *((void *)v90 + 29) = v16;
    *((void *)v90 + 30) = v98;
    *((void *)v90 + 31) = v18;
    *((void *)v90 + 32) = v19;
    *((void *)v90 + 33) = v20;
    *((void *)v90 + 34) = v21;
    *((void *)v90 + 35) = v22;
  }
  else
  {
    uint64_t v7 = this;
    uint64_t result = memcpy((char *)this + v5, __src, __n);
    *((void *)v7 + 36) += __n;
    *((unsigned char *)v7 + 296) = v6;
  }
  return result;
}

unsigned __int8 *Alembic::Util::v12::SpookyHash::Final(Alembic::Util::v12::SpookyHash *this, unint64_t *a2, unint64_t *a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v7 = this;
  unint64_t v8 = *((void *)this + 36);
  if (v8 > 0xBF)
  {
    unsigned int v10 = *((unsigned __int8 *)this + 296);
    uint64_t v11 = *((void *)this + 24);
    uint64_t v12 = *((void *)this + 25);
    uint64_t v13 = *((void *)this + 28);
    uint64_t v14 = *((void *)this + 29);
    uint64_t v16 = *((void *)this + 30);
    uint64_t v15 = *((void *)this + 31);
    uint64_t v18 = *((void *)this + 32);
    uint64_t v17 = *((void *)this + 33);
    uint64_t v19 = *((void *)this + 34);
    uint64_t v20 = *((void *)this + 35);
    unint64_t v97 = a2;
    unint64_t v98 = a3;
    if (v10 < 0x60)
    {
      uint64_t v93 = *((void *)this + 34);
      uint64_t v94 = *((void *)this + 27);
      uint64_t v95 = *((void *)this + 28);
      uint64_t v96 = *((void *)this + 26);
    }
    else
    {
      uint64_t v21 = *(void *)this + v11;
      uint64_t v22 = v19 ^ *((void *)this + 26);
      uint64_t v23 = (v21 ^ v20) + v12;
      uint64_t v24 = *((void *)this + 1) + v12;
      uint64_t v25 = v23 ^ *((void *)this + 27);
      uint64_t v26 = (v24 ^ __ROR8__(v21, 53)) + v22;
      uint64_t v27 = *((void *)this + 2) + v22;
      uint64_t v28 = (v27 ^ __ROR8__(v24, 32)) + v25;
      uint64_t v29 = v25 + *((void *)this + 3);
      uint64_t v30 = (v29 ^ __ROR8__(v27, 21)) + (v26 ^ v13);
      uint64_t v31 = (v26 ^ v13) + *((void *)this + 4);
      uint64_t v96 = v30;
      uint64_t v32 = __ROR8__(v29, 33);
      uint64_t v33 = (v28 ^ v14) + *((void *)this + 5);
      uint64_t v94 = (v31 ^ v32) + (v28 ^ v14);
      uint64_t v34 = __ROR8__(v31, 47);
      uint64_t v35 = (v30 ^ v16) + *((void *)this + 6);
      uint64_t v95 = (v33 ^ v34) + (v30 ^ v16);
      uint64_t v14 = (v35 ^ __ROR8__(v33, 36)) + (v94 ^ v15);
      uint64_t v36 = (v94 ^ v15) + *((void *)this + 7);
      uint64_t v16 = (v36 ^ __ROR8__(v35, 25)) + (v95 ^ v18);
      uint64_t v37 = (v95 ^ v18) + *((void *)this + 8);
      uint64_t v15 = (v37 ^ __ROR8__(v36, 7)) + (v14 ^ v17);
      uint64_t v38 = (v14 ^ v17) + *((void *)this + 9);
      uint64_t v18 = (v38 ^ __ROR8__(v37, 9)) + (v16 ^ v19);
      uint64_t v39 = *((void *)this + 11);
      uint64_t v40 = (v16 ^ v19) + *((void *)this + 10);
      uint64_t v41 = v15 ^ v23;
      uint64_t v11 = v18 ^ v26;
      uint64_t v17 = (v40 ^ __ROR8__(v38, 10)) + v41;
      uint64_t v12 = v17 ^ v28;
      uint64_t v20 = __ROR8__(v41 + v39, 18);
      uint64_t v93 = ((v41 + v39) ^ __ROR8__(v40, 42)) + (v18 ^ v26);
      uint64_t v7 = (Alembic::Util::v12::SpookyHash *)((char *)this + 96);
      LOBYTE(v10) = v10 - 96;
    }
    bzero((char *)v7 + v10, 96 - v10);
    *((unsigned char *)v7 + 95) = v10;
    uint64_t v42 = *((void *)v7 + 1) + v12 + v20 + *((void *)v7 + 11);
    uint64_t v43 = *(void *)v7 + v11 + (v42 ^ (*((void *)v7 + 2) + v96));
    uint64_t v44 = (v43 ^ (*((void *)v7 + 3) + v94)) + __ROR8__(*((void *)v7 + 1) + v12, 20);
    uint64_t v45 = (v44 ^ (*((void *)v7 + 4) + v95)) + __ROR8__(v42 ^ (*((void *)v7 + 2) + v96), 49);
    uint64_t v46 = (v45 ^ (*((void *)v7 + 5) + v14)) + __ROR8__(v43 ^ (*((void *)v7 + 3) + v94), 30);
    uint64_t v47 = (v46 ^ (*((void *)v7 + 6) + v16)) + __ROR8__(v44 ^ (*((void *)v7 + 4) + v95), 43);
    uint64_t v48 = (v47 ^ (*((void *)v7 + 7) + v15)) + __ROR8__(v45 ^ (*((void *)v7 + 5) + v14), 26);
    uint64_t v49 = (v48 ^ (*((void *)v7 + 8) + v18)) + __ROR8__(v46 ^ (*((void *)v7 + 6) + v16), 31);
    uint64_t v50 = (v49 ^ (*((void *)v7 + 9) + v17)) + __ROR8__(v47 ^ (*((void *)v7 + 7) + v15), 54);
    uint64_t v51 = (v50 ^ (*((void *)v7 + 10) + v93)) + __ROR8__(v48 ^ (*((void *)v7 + 8) + v18), 51);
    uint64_t v52 = v51 ^ v42;
    uint64_t v53 = v52 + __ROR8__(v49 ^ (*((void *)v7 + 9) + v17), 26);
    uint64_t v54 = v53 ^ v43;
    uint64_t v55 = v54 + __ROR8__(v50 ^ (*((void *)v7 + 10) + v93), 11);
    uint64_t v56 = v55 ^ v44;
    uint64_t v57 = v56 + __ROR8__(v52, 22);
    uint64_t v58 = v57 ^ v45;
    uint64_t v59 = v58 + __ROR8__(v54, 10);
    uint64_t v60 = v59 ^ v46;
    uint64_t v61 = v60 + __ROR8__(v56, 20);
    uint64_t v62 = v61 ^ v47;
    uint64_t v63 = v62 + __ROR8__(v58, 49);
    uint64_t v64 = v63 ^ v48;
    uint64_t v65 = v64 + __ROR8__(v60, 30);
    uint64_t v66 = v65 ^ v49;
    uint64_t v67 = v66 + __ROR8__(v62, 43);
    uint64_t v68 = v67 ^ v50;
    uint64_t v69 = v68 + __ROR8__(v64, 26);
    uint64_t v70 = v69 ^ v51;
    uint64_t v71 = v70 + __ROR8__(v66, 31);
    uint64_t v72 = v71 ^ v53;
    uint64_t v73 = v72 + __ROR8__(v68, 54);
    uint64_t v74 = v73 ^ v55;
    uint64_t v75 = v74 + __ROR8__(v70, 51);
    uint64_t v76 = v75 ^ v57;
    uint64_t v77 = v76 + __ROR8__(v72, 26);
    uint64_t v78 = v77 ^ v59;
    uint64_t result = (unsigned __int8 *)(v78 + __ROR8__(v74, 11));
    uint64_t v79 = (unint64_t)result ^ v61;
    uint64_t v80 = v79 + __ROR8__(v76, 22);
    uint64_t v81 = v80 ^ v63;
    uint64_t v82 = v81 + __ROR8__(v78, 10);
    uint64_t v83 = v82 ^ v65;
    uint64_t v84 = v83 + __ROR8__(v79, 20);
    uint64_t v85 = v84 ^ v67;
    uint64_t v86 = (v85 + __ROR8__(v81, 49)) ^ v69;
    uint64_t v87 = (v86 + __ROR8__(v83, 30)) ^ v71;
    uint64_t v88 = (v87 + __ROR8__(v85, 43)) ^ v73;
    uint64_t v89 = (v88 + __ROR8__(v86, 26)) ^ v75;
    uint64_t v90 = (v89 + __ROR8__(v87, 31)) ^ v77;
    uint64_t v91 = (v90 + __ROR8__(v88, 54)) ^ (unint64_t)result;
    uint64_t v92 = (((v91 + __ROR8__(v89, 51)) ^ v80) + __ROR8__(v90, 26)) ^ v82;
    *unint64_t v97 = __ROR8__(v92, 10);
    *unint64_t v98 = (v92 + __ROR8__(v91, 11)) ^ v84;
  }
  else
  {
    *a2 = *((void *)this + 24);
    *a3 = *((void *)this + 25);
    return Alembic::Util::v12::SpookyHash::Short((unsigned __int8 *)this, v8, (uint64_t *)a2, a3, a5);
  }
  return result;
}

void Alembic::Util::v12::TokenMap::set(uint64_t **a1, std::string *this, std::string::value_type __c, std::string::value_type a4)
{
  std::string::size_type v8 = 0;
  do
  {
    std::string::size_type v9 = std::string::find(this, __c, v8);
    std::string::size_type v10 = std::string::find(this, a4, v8);
    if (v10 != -1)
    {
      std::string::size_type v11 = v10;
      if (v9 == -1) {
        std::string::size_type v12 = -1;
      }
      else {
        std::string::size_type v12 = v9 + ~v10;
      }
      std::string::basic_string(&v16, this, v10 + 1, v12, (std::allocator<char> *)&__p);
      std::string::basic_string(&__p, this, v8, v11 - v8, (std::allocator<char> *)&p_p);
      p_p = &__p;
      uint64_t v13 = sub_21677B5F8(a1, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&unk_2174065E2, (_OWORD **)&p_p);
      uint64_t v14 = (void **)v13 + 7;
      if (*((char *)v13 + 79) < 0) {
        operator delete(*v14);
      }
      *(std::string *)uint64_t v14 = v16;
      *((unsigned char *)&v16.__r_.__value_.__s + 23) = 0;
      v16.__r_.__value_.__s.__data_[0] = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v16.__r_.__value_.__l.__data_);
        }
      }
    }
    std::string::size_type v8 = v9 + 1;
  }
  while (v9 != -1);
}

void sub_21677A7A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::Util::v12::TokenMap::setUnique(uint64_t **a1, std::string *this, std::string::value_type __c, std::string::value_type a4, char a5)
{
  std::string::size_type v10 = 0;
  while (1)
  {
    std::string::size_type v11 = std::string::find(this, __c, v10);
    std::string::size_type v12 = std::string::find(this, a4, v10);
    if (v12 > v11) {
      break;
    }
    std::string::size_type v13 = v12;
    if (v12 != -1)
    {
      if (v11 == -1) {
        std::string::size_type v14 = -1;
      }
      else {
        std::string::size_type v14 = v11 + ~v12;
      }
      std::string::basic_string(&v30, this, v10, v12 - v10, (std::allocator<char> *)&v32);
      if (sub_21677B088((uint64_t)a1, (const void **)&v30.__r_.__value_.__l.__data_))
      {
        if ((a5 & 1) == 0)
        {
          sub_216778A5C((uint64_t)&v32);
          uint64_t v17 = sub_216779180(&v32.__r_.__value_.__r.__words[2], (uint64_t)"TokenMap::setUnique: token: ", 28);
          if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v18 = &v30;
          }
          else {
            uint64_t v18 = (std::string *)v30.__r_.__value_.__r.__words[0];
          }
          if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(v30.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = v30.__r_.__value_.__l.__size_;
          }
          uint64_t v20 = sub_216779180(v17, (uint64_t)v18, size);
          sub_216779180(v20, (uint64_t)" is not unique.", 15);
          std::stringbuf::str();
          sub_216778E70(v31, &__p);
          if (v29 < 0) {
            operator delete((void *)__p);
          }
          exception = __cxa_allocate_exception(0x20uLL);
          uint64_t v22 = sub_216779038(exception, (uint64_t)v31);
          __cxa_throw(v22, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
        }
      }
      else
      {
        std::string::basic_string(&v32, this, v13 + 1, v14, (std::allocator<char> *)v31);
        v31[0] = (long long *)&v30;
        uint64_t v15 = sub_21677B174(a1, (const void **)&v30.__r_.__value_.__l.__data_, (uint64_t)&unk_2174065E2, v31);
        std::string v16 = (void **)(v15 + 7);
        if (*((char *)v15 + 79) < 0) {
          operator delete(*v16);
        }
        *(std::string *)std::string v16 = v32;
      }
      if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v30.__r_.__value_.__l.__data_);
      }
    }
    std::string::size_type v10 = v11 + 1;
    if (v11 == -1) {
      return;
    }
  }
  if ((a5 & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v32);
    uint64_t v23 = sub_216779180(&v32.__r_.__value_.__r.__words[2], (uint64_t)"TokenMap::setUnique: malformed string found:", 44);
    LOBYTE(v31[0]) = a4;
    uint64_t v24 = sub_216779180(v23, (uint64_t)v31, 1);
    uint64_t v25 = sub_216779180(v24, (uint64_t)" before: ", 9);
    LOBYTE(v31[0]) = __c;
    sub_216779180(v25, (uint64_t)v31, 1);
    std::stringbuf::str();
    sub_216778E70(v31, (long long *)&v30);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    uint64_t v26 = __cxa_allocate_exception(0x20uLL);
    uint64_t v27 = sub_216779038(v26, (uint64_t)v31);
    __cxa_throw(v27, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
}

void sub_21677AA8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, std::exception a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
}

void Alembic::Util::v12::TokenMap::get(Alembic::Util::v12::TokenMap *this, unsigned __int8 a2, std::string::value_type a3, int a4)
{
  *(_WORD *)__s = a2;
  sub_216779094(&v58, __s);
  __s[0] = a3;
  sub_216779094(&v55, __s);
  sub_216778A5C((uint64_t)v51);
  std::string::size_type v10 = *(char **)this;
  std::string::size_type v8 = (char *)this + 8;
  std::string::size_type v9 = v10;
  if (v10 != v8)
  {
    char v11 = 1;
    while (1)
    {
      if (*((char *)v9 + 55) < 0) {
        sub_216778F24(&__dst, (void *)v9[4], v9[5]);
      }
      else {
        std::string __dst = *(std::string *)(v9 + 4);
      }
      if (*((char *)v9 + 79) < 0) {
        sub_216778F24(&v49, (void *)v9[7], v9[8]);
      }
      else {
        std::string v49 = *(std::string *)(v9 + 7);
      }
      if (a4
        && (std::string::find(&__dst, a2, 0) != -1
         || std::string::find(&__dst, a3, 0) != -1
         || std::string::find(&v49, a2, 0) != -1
         || std::string::find(&v49, a3, 0) != -1))
      {
        sub_216778A5C((uint64_t)v47);
        uint64_t v26 = sub_216779180(v48, (uint64_t)"TokenMap::get: Token-Value pair ", 32);
        uint64_t v27 = sub_216779180(v26, (uint64_t)" contains separator characters: ", 32);
        if ((v60 & 0x80u) == 0) {
          uint64_t v28 = (void **)&v58;
        }
        else {
          uint64_t v28 = v58;
        }
        if ((v60 & 0x80u) == 0) {
          uint64_t v29 = v60;
        }
        else {
          uint64_t v29 = v59;
        }
        std::string v30 = sub_216779180(v27, (uint64_t)v28, v29);
        uint64_t v31 = sub_216779180(v30, (uint64_t)" or ", 4);
        if ((v57 & 0x80u) == 0) {
          std::string v32 = (void **)&v55;
        }
        else {
          std::string v32 = v55;
        }
        if ((v57 & 0x80u) == 0) {
          uint64_t v33 = v57;
        }
        else {
          uint64_t v33 = v56;
        }
        uint64_t v34 = sub_216779180(v31, (uint64_t)v32, v33);
        uint64_t v35 = sub_216779180(v34, (uint64_t)" for ", 5);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_dst = &__dst;
        }
        else {
          p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
        }
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __dst.__r_.__value_.__l.__size_;
        }
        uint64_t v38 = sub_216779180(v35, (uint64_t)p_dst, size);
        uint64_t v39 = sub_216779180(v38, (uint64_t)" or ", 4);
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v40 = &v49;
        }
        else {
          uint64_t v40 = (std::string *)v49.__r_.__value_.__r.__words[0];
        }
        if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v41 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v41 = v49.__r_.__value_.__l.__size_;
        }
        sub_216779180(v39, (uint64_t)v40, v41);
        std::stringbuf::str();
        sub_216778E70(v46, &v44);
        if (v45 < 0) {
          operator delete((void *)v44);
        }
        exception = __cxa_allocate_exception(0x20uLL);
        uint64_t v43 = sub_216779038(exception, (uint64_t)v46);
        __cxa_throw(v43, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
      }
      if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        break;
      }
      if (v49.__r_.__value_.__l.__size_) {
        goto LABEL_18;
      }
LABEL_45:
      operator delete(v49.__r_.__value_.__l.__data_);
LABEL_46:
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      uint64_t v22 = (char *)v9[1];
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          uint64_t v22 = *(char **)v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          uint64_t v23 = (char *)v9[2];
          BOOL v24 = *(void *)v23 == (void)v9;
          std::string::size_type v9 = v23;
        }
        while (!v24);
      }
      std::string::size_type v9 = v23;
      if (v23 == v8) {
        goto LABEL_54;
      }
    }
    if (!*((unsigned char *)&v49.__r_.__value_.__s + 23)) {
      goto LABEL_46;
    }
LABEL_18:
    if ((v11 & 1) == 0)
    {
      if ((v60 & 0x80u) == 0) {
        std::string::size_type v12 = (void **)&v58;
      }
      else {
        std::string::size_type v12 = v58;
      }
      if ((v60 & 0x80u) == 0) {
        uint64_t v13 = v60;
      }
      else {
        uint64_t v13 = v59;
      }
      sub_216779180(v52, (uint64_t)v12, v13);
    }
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v14 = &__dst;
    }
    else {
      std::string::size_type v14 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v15 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v15 = __dst.__r_.__value_.__l.__size_;
    }
    std::string v16 = sub_216779180(v52, (uint64_t)v14, v15);
    if ((v57 & 0x80u) == 0) {
      uint64_t v17 = (void **)&v55;
    }
    else {
      uint64_t v17 = v55;
    }
    if ((v57 & 0x80u) == 0) {
      uint64_t v18 = v57;
    }
    else {
      uint64_t v18 = v56;
    }
    uint64_t v19 = sub_216779180(v16, (uint64_t)v17, v18);
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v20 = &v49;
    }
    else {
      uint64_t v20 = (std::string *)v49.__r_.__value_.__r.__words[0];
    }
    if ((v49.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v21 = HIBYTE(v49.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v21 = v49.__r_.__value_.__l.__size_;
    }
    sub_216779180(v19, (uint64_t)v20, v21);
    char v11 = 0;
    if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
LABEL_54:
  std::stringbuf::str();
  v51[0] = *MEMORY[0x263F8C2B8];
  uint64_t v25 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v51 + *(void *)(v51[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v52[0] = v25;
  v52[1] = MEMORY[0x263F8C318] + 16;
  if (v53 < 0) {
    operator delete((void *)v52[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x21D447E60](&v54);
  if ((char)v57 < 0) {
    operator delete(v55);
  }
  if ((char)v60 < 0) {
    operator delete(v58);
  }
}

void sub_21677AFE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::exception a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58,uint64_t a59,void *a60,uint64_t a61,int a62,__int16 a63)
{
  sub_216779148(&a14);
  sub_216778D38((uint64_t)&a18);
  if (a58 < 0) {
    operator delete(__p);
  }
  if (a65 < 0) {
    operator delete(a60);
  }
  sub_216778D38((uint64_t)&a66);
  if (*(char *)(v66 - 121) < 0) {
    operator delete(*(void **)(v66 - 144));
  }
  if (*(char *)(v66 - 97) < 0) {
    operator delete(*(void **)(v66 - 120));
  }
  _Unwind_Resume(a1);
}

uint64_t sub_21677B088(uint64_t a1, const void **a2)
{
  uint64_t v2 = *(const void ***)(a1 + 8);
  if (v2)
  {
    uint64_t v4 = a1 + 16;
    uint64_t v5 = 1;
    do
    {
      if (!sub_21677B108(v4, a2, v2 + 4))
      {
        if (!sub_21677B108(v4, v2 + 4, a2)) {
          return v5;
        }
        ++v2;
      }
      uint64_t v2 = (const void **)*v2;
    }
    while (v2);
  }
  return 0;
}

BOOL sub_21677B108(uint64_t a1, const void **a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    char v6 = a2;
  }
  else {
    char v6 = *a2;
  }
  if (v3 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v3 >= 0) {
    std::string::size_type v8 = a3;
  }
  else {
    std::string::size_type v8 = *a3;
  }
  if (v7 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v7;
  }
  int v10 = memcmp(v6, v8, v9);
  if (v10) {
    return v10 < 0;
  }
  else {
    return v5 < v7;
  }
}

uint64_t *sub_21677B174(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  char v6 = (uint64_t **)sub_21677B220((uint64_t)a1, &v11, a2);
  size_t v7 = *v6;
  if (!*v6)
  {
    std::string::size_type v8 = v6;
    sub_21677B2C0((uint64_t)a1, a4, (uint64_t)v10);
    sub_21677B358(a1, v11, v8, v10[0]);
    size_t v7 = v10[0];
    v10[0] = 0;
    sub_21677B548((uint64_t)v10, 0);
  }
  return v7;
}

void *sub_21677B220(uint64_t a1, void *a2, const void **a3)
{
  size_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        std::string::size_type v8 = (void *)v4;
        size_t v9 = (const void **)(v4 + 32);
        if (!sub_21677B108(v7, a3, (const void **)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v8;
        size_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!sub_21677B108(v7, v9, a3)) {
        break;
      }
      size_t v5 = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    std::string::size_type v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

unsigned char *sub_21677B2C0@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  char v6 = operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 4;
  std::string::size_type v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_216778F24(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    v6[6] = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  void v6[9] = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_21677B340(_Unwind_Exception *a1)
{
  sub_21677B548(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t *sub_21677B358(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = sub_21677B3B0(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_21677B3B0(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      int v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            long long v9 = (uint64_t **)a2[2];
          }
          else
          {
            long long v9 = (uint64_t **)v2[1];
            int v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              int v3 = (uint64_t *)v2[2];
            }
            int v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *long long v9 = v2;
            v2[2] = (uint64_t)v9;
            int v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *int v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), uint64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            int v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          int v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        int v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *uint64_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void sub_21677B548(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_21677B5A0((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void sub_21677B5A0(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

_OWORD *sub_21677B5F8(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  int v6 = (void **)sub_21677B220((uint64_t)a1, &v14, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x50uLL);
    v12[1] = a1 + 1;
    long long v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0;
    int v9[2] = 0;
    *long long v9 = 0;
    *((void *)v7 + 8) = 0;
    *((void *)v7 + 9) = 0;
    *((void *)v7 + 7) = 0;
    char v13 = 1;
    sub_21677B358(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0;
    sub_21677B548((uint64_t)v12, 0);
  }
  return v7;
}

uint64_t Alembic::AbcCoreAbstract::v12::GetLibraryVersionShort(Alembic::AbcCoreAbstract::v12 *this)
{
  sub_21677B834((uint64_t)v4);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_216779180(v1, (uint64_t)".", 1);
  uint64_t v2 = (void *)std::ostream::operator<<();
  sub_216779180(v2, (uint64_t)".", 1);
  std::ostream::operator<<();
  std::stringbuf::str();
  v4[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v4 + *(void *)(v4[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  v4[1] = MEMORY[0x263F8C318] + 16;
  if (v5 < 0) {
    operator delete((void *)v4[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x21D447E60](&v6);
}

void sub_21677B820(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_21677B9CC((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_21677B834(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C340] + 64;
  *(void *)(a1 + 112) = MEMORY[0x263F8C340] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x263F8C2C8] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x263F8C2C8] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  char v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x263F8C340] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_21677B9A4(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x21D447E60](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_21677B9CC(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2C8];
  uint64_t v3 = *MEMORY[0x263F8C2C8];
  *(void *)a1 = *MEMORY[0x263F8C2C8];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x21D447E60](a1 + 112);
  return a1;
}

void Alembic::AbcCoreAbstract::v12::GetLibraryVersion(Alembic::AbcCoreAbstract::v12 *this)
{
  Alembic::AbcCoreAbstract::v12::GetLibraryVersionShort((uint64_t *)v11, this);
  sub_21677B834((uint64_t)v8);
  uint64_t v1 = sub_216779180(v8, (uint64_t)"Alembic ", 8);
  if ((v12 & 0x80u) == 0) {
    uint64_t v2 = v11;
  }
  else {
    uint64_t v2 = (void **)v11[0];
  }
  if ((v12 & 0x80u) == 0) {
    uint64_t v3 = v12;
  }
  else {
    uint64_t v3 = (uint64_t)v11[1];
  }
  uint64_t v4 = sub_216779180(v1, (uint64_t)v2, v3);
  char v5 = sub_216779180(v4, (uint64_t)" (built ", 8);
  uint64_t v6 = sub_216779180(v5, (uint64_t)"Nov 10 2024", 11);
  uint64_t v7 = sub_216779180(v6, (uint64_t)" ", 1);
  sub_216779180(v7, (uint64_t)"02:18:17)", 9);
  std::stringbuf::str();
  v8[0] = *MEMORY[0x263F8C2C8];
  *(void *)((char *)v8 + *(void *)(v8[0] - 24)) = *(void *)(MEMORY[0x263F8C2C8] + 24);
  v8[1] = MEMORY[0x263F8C318] + 16;
  if (v9 < 0) {
    operator delete((void *)v8[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x21D447E60](&v10);
  if ((char)v12 < 0) {
    operator delete(v11[0]);
  }
}

void sub_21677BC80(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 33) < 0) {
    operator delete(*(void **)(v1 - 56));
  }
  _Unwind_Resume(exception_object);
}

Alembic::AbcCoreAbstract::v12::TimeSampling *Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(Alembic::AbcCoreAbstract::v12::TimeSampling *a1, _OWORD *a2, uint64_t a3)
{
  *(_OWORD *)a1 = *a2;
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 4) = 0;
  sub_21677CA50((void *)a1 + 2, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
  Alembic::AbcCoreAbstract::v12::TimeSampling::init(a1);
  return a1;
}

void sub_21677BD08(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

double Alembic::AbcCoreAbstract::v12::TimeSampling::init(Alembic::AbcCoreAbstract::v12::TimeSampling *this)
{
  uint64_t v2 = *((void *)this + 3) - *((void *)this + 2);
  unint64_t v3 = v2 >> 3;
  int v4 = *(_DWORD *)this;
  char v5 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(this);
  if (v4 != v5 && v3 != *(_DWORD *)this)
  {
    sub_216778A5C((uint64_t)v25);
    sub_216779180(v26, (uint64_t)"Incorrect number of time samples specified, expected ", 53);
    std::string v16 = (void *)std::ostream::operator<<();
    sub_216779180(v16, (uint64_t)", got: ", 7);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v24, (long long *)__p);
    if (v23 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v18 = sub_216779038(exception, (uint64_t)v24);
    __cxa_throw(v18, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if ((unint64_t)v2 >= 9)
  {
    uint64_t v7 = (double *)*((void *)this + 2);
    double result = *v7;
    uint64_t v8 = 2;
    if (v3 > 2) {
      uint64_t v8 = v2 >> 3;
    }
    uint64_t v9 = 1;
    do
    {
      double v10 = v7[v9];
      if (result >= v10)
      {
        sub_216778A5C((uint64_t)v25);
        sub_216779180(v26, (uint64_t)"Sample ", 7);
        unsigned __int8 v12 = (void *)std::ostream::operator<<();
        sub_216779180(v12, (uint64_t)" value: ", 8);
        char v13 = (void *)std::ostream::operator<<();
        sub_216779180(v13, (uint64_t)" is not greater than the previous sample: ", 42);
        std::ostream::operator<<();
        std::stringbuf::str();
        sub_216778E70(v24, (long long *)__p);
        if (v23 < 0) {
          operator delete(__p[0]);
        }
        uint64_t v14 = __cxa_allocate_exception(0x20uLL);
        std::string::size_type v15 = sub_216779038(v14, (uint64_t)v24);
        __cxa_throw(v15, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
      }
      ++v9;
      double result = v10;
    }
    while (v8 != v9);
    if (*(_DWORD *)this >= 2u)
    {
      unsigned int v11 = *(_DWORD *)this;
      if (v11 < Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v5))
      {
        double result = *(double *)(*((void *)this + 3) - 8) - **((double **)this + 2);
        if (result > *((double *)this + 1))
        {
          sub_216778A5C((uint64_t)v25);
          sub_216779180(v26, (uint64_t)"Cyclic samples provided are greater than the time per cycle. Expected: ", 71);
          uint64_t v19 = (void *)std::ostream::operator<<();
          sub_216779180(v19, (uint64_t)" Found: ", 8);
          std::ostream::operator<<();
          std::stringbuf::str();
          sub_216778E70(v24, (long long *)__p);
          if (v23 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v20 = __cxa_allocate_exception(0x20uLL);
          std::string::size_type v21 = sub_216779038(v20, (uint64_t)v24);
          __cxa_throw(v21, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
        }
      }
    }
  }
  return result;
}

void sub_21677BFE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

Alembic::AbcCoreAbstract::v12::TimeSampling *Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(Alembic::AbcCoreAbstract::v12::TimeSampling *this, double a2, double a3)
{
  char v5 = sub_21677C910((double *)this, a2);
  int v5[2] = 0.0;
  v5[3] = 0.0;
  v5[4] = 0.0;
  sub_21677C0AC((uint64_t)(v5 + 2), 1uLL);
  **((double **)this + 2) = a3;
  Alembic::AbcCoreAbstract::v12::TimeSampling::init(this);
  return this;
}

void sub_21677C090(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void sub_21677C0AC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_21677CB60((char **)a1, a2 - v2);
  }
}

Alembic::AbcCoreAbstract::v12::TimeSampling *Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(Alembic::AbcCoreAbstract::v12::TimeSampling *this)
{
  *(_DWORD *)this = 1;
  *((void *)this + 1) = 0x3FF0000000000000;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  sub_21677C0AC((uint64_t)this + 16, 1uLL);
  **((void **)this + 2) = 0;
  return this;
}

void sub_21677C13C(_Unwind_Exception *exception_object)
{
  int v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

Alembic::AbcCoreAbstract::v12::TimeSampling *Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(Alembic::AbcCoreAbstract::v12::TimeSampling *this, const Alembic::AbcCoreAbstract::v12::TimeSampling *a2)
{
  *(_OWORD *)this = *(_OWORD *)a2;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  sub_21677CA50((void *)this + 2, *((const void **)a2 + 2), *((void *)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 3);
  return this;
}

{
  *(_OWORD *)this = *(_OWORD *)a2;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  sub_21677CA50((void *)this + 2, *((const void **)a2 + 2), *((void *)a2 + 3), (uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 3);
  return this;
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSampling::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  if (a1 != a2) {
    sub_21677CC7C((char *)(a1 + 16), *(char **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
  }
  return a1;
}

double Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(double **this, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)this;
  if (*(_DWORD *)this == 1)
  {
    double v5 = *this[2];
    double v6 = *((double *)this + 1);
    double v7 = (double)a2;
    return v5 + v6 * v7;
  }
  uint64_t v8 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)this);
  if (v4 != v8)
  {
    if (*(_DWORD *)this < 2u
      || (unsigned int v11 = *(_DWORD *)this,
          v11 >= Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v8)))
    {
      sub_216778A5C((uint64_t)v22);
      sub_216779180(v23, (uint64_t)"should be cyclic", 16);
      std::stringbuf::str();
      sub_216778E70(v21, (long long *)__p);
      if (v20 < 0) {
        operator delete(__p[0]);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v14 = sub_216779038(exception, (uint64_t)v21);
      __cxa_throw(v14, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    uint64_t v12 = *(unsigned int *)this;
    double v5 = this[2][a2 % v12];
    double v6 = *((double *)this + 1);
    double v7 = (double)(a2 / v12);
    return v5 + v6 * v7;
  }
  uint64_t v9 = this[2];
  if (a2 >= (unint64_t)(this[3] - v9))
  {
    sub_216778A5C((uint64_t)v22);
    sub_216779180(v23, (uint64_t)"Out-of-range acyclic index: ", 28);
    std::string::size_type v15 = (void *)std::ostream::operator<<();
    sub_216779180(v15, (uint64_t)", range [0-", 11);
    std::string v16 = (void *)std::ostream::operator<<();
    sub_216779180(v16, (uint64_t)"]", 1);
    std::stringbuf::str();
    sub_216778E70(v21, (long long *)__p);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v17 = __cxa_allocate_exception(0x20uLL);
    uint64_t v18 = sub_216779038(v17, (uint64_t)v21);
    __cxa_throw(v18, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return v9[a2];
}

void sub_21677C418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(double **this, double a2, uint64_t a3)
{
  unint64_t v3 = a3 - 1;
  if (a3 < 1) {
    return 0;
  }
  double SampleTime = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, 0);
  if (SampleTime >= a2) {
    return 0;
  }
  if (Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, v3) <= a2) {
    return v3;
  }
  unsigned int v9 = *(_DWORD *)this;
  uint64_t v10 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v8);
  if (v9 == v10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = this[2];
    uint64_t v13 = (char *)this[3] - (char *)v12;
    uint64_t v14 = v13 >> 3;
    uint64_t v15 = (v13 >> 3) - 1;
    if (v13 >> 3 >= 1) {
      uint64_t v14 = (v13 >> 3) - 1;
    }
    if (v13 < 17 || (uint64_t result = v14 >> 1, v14 >> 1 >= v15))
    {
LABEL_20:
      double v20 = v12[v15];
      double v21 = a2 - v20;
      if (v20 >= a2) {
        double v21 = v20 - a2;
      }
      uint64_t result = v15;
      if (v21 > 0.00001) {
        return v11;
      }
    }
    else
    {
      uint64_t v11 = 0;
      while (1)
      {
        double v17 = v12[result];
        if (v17 == a2) {
          break;
        }
        if (v17 > a2) {
          uint64_t v15 = result;
        }
        else {
          uint64_t v11 = result;
        }
        uint64_t v18 = v15 + v11;
        if (v15 + v11 < 0 != __OFADD__(v15, v11)) {
          ++v18;
        }
        uint64_t result = v18 >> 1;
        if (v11 >= v18 >> 1 || result >= v15) {
          goto LABEL_20;
        }
      }
    }
  }
  else
  {
    unsigned int v22 = *(_DWORD *)this;
    if (*(_DWORD *)this == 1)
    {
      double v36 = *((double *)this + 1);
      uint64_t v37 = (uint64_t)((a2 - SampleTime) / v36);
      if (v37 >= a3) {
        uint64_t result = v3;
      }
      else {
        uint64_t result = v37 & ~(v37 >> 63);
      }
      double v38 = SampleTime + v36 * (double)result;
      if (v38 <= a2 || result == 0) {
        goto LABEL_61;
      }
      double v40 = a2 - v38;
      if (v38 >= a2) {
        double v40 = v38 - a2;
      }
      if (v40 <= 0.00001)
      {
LABEL_61:
        if (result < v3)
        {
          double v41 = SampleTime + v36 * (double)(result + 1);
          double v42 = a2 - v41;
          if (v41 >= a2) {
            double v42 = v41 - a2;
          }
          if (v42 <= 0.00001) {
            ++result;
          }
        }
      }
      else
      {
        --result;
      }
    }
    else
    {
      if (!v22 || v22 >= Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v10))
      {
        sub_216778A5C((uint64_t)__y);
        sub_216779180(v49, (uint64_t)"should be cyclic", 16);
        std::stringbuf::str();
        sub_216778E70(v47, &__p);
        if (v46 < 0) {
          operator delete((void *)__p);
        }
        exception = __cxa_allocate_exception(0x20uLL);
        long long v44 = sub_216779038(exception, (uint64_t)v47);
        __cxa_throw(v44, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
      }
      uint64_t v23 = *(unsigned int *)this;
      double v24 = *((double *)this + 1);
      __y[0] = 0.0;
      double v25 = modf((a2 - SampleTime) / v24, __y);
      if (v25 <= 1.0) {
        double v26 = 1.0 - v25;
      }
      else {
        double v26 = v25 + -1.0;
      }
      if (v26 <= 0.00001) {
        double v27 = __y[0] + 1.0;
      }
      else {
        double v27 = __y[0];
      }
      double v28 = v24 * (double)(uint64_t)v27;
      uint64_t v29 = this[2];
      uint64_t v30 = 0;
      if (v23)
      {
        while (v29[v30] < a2 - v28)
        {
          if (v23 == ++v30)
          {
            uint64_t v30 = v23;
            break;
          }
        }
      }
      uint64_t v31 = (uint64_t)v27 * v23;
      uint64_t v32 = v30 - (v30 == v23);
      double v33 = v28 + v29[v32];
      double v34 = a2 - v33;
      if (v33 >= a2) {
        double v34 = v33 - a2;
      }
      BOOL v35 = v33 <= a2 || v32 < 1;
      if (!v35 && v34 > 0.00001) {
        --v32;
      }
      return v32 + v31;
    }
  }
  return result;
}

void sub_21677C794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSampling::getCeilIndex(double **this, double a2, uint64_t a3)
{
  if (Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, 0) >= a2) {
    return 0;
  }
  uint64_t v6 = a3 - 1;
  if (Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, a3 - 1) > a2)
  {
    uint64_t FloorIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(this, a2, a3);
    uint64_t v6 = FloorIndex;
    if (FloorIndex != a3 - 1)
    {
      double v9 = a2 - v8;
      if (v8 >= a2) {
        double v9 = v8 - a2;
      }
      if (v9 > 0.00001)
      {
        uint64_t v6 = FloorIndex + 1;
        Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, FloorIndex + 1);
      }
    }
  }
  return v6;
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSampling::getNearIndex(double **this, double a2, uint64_t a3)
{
  uint64_t v3 = a3 - 1;
  if (a3 < 1) {
    return 0;
  }
  uint64_t FloorIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(this, a2, a3);
  if (FloorIndex != v3
    && vabdd_f64(a2, v6) > vabdd_f64(Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime(this, FloorIndex + 1), a2))
  {
    ++FloorIndex;
  }
  return FloorIndex;
}

double *sub_21677C910(double *a1, double a2)
{
  *(_DWORD *)a1 = 1;
  a1[1] = a2;
  if (a2 <= 0.0
    || Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) <= a2)
  {
    sub_216778A5C((uint64_t)v10);
    unsigned int v4 = sub_216779180(v11, (uint64_t)"Time per cycle must be greater than 0 ", 38);
    sub_216779180(v4, (uint64_t)"and can not be ACYCLIC_TIME_PER_CYCLE.", 38);
    std::stringbuf::str();
    sub_216778E70(v9, &__p);
    if (v8 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    double v6 = sub_216779038(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return a1;
}

void sub_21677C9F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21677CA1C()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x263F8C208], MEMORY[0x263F8C090]);
}

void *sub_21677CA50(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    double v6 = result;
    uint64_t result = sub_21677CACC(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21677CAB0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_21677CACC(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_21677CB10();
  }
  uint64_t result = (char *)sub_21677CB28((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void sub_21677CB10()
{
}

void *sub_21677CB28(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_21677CA1C();
  }
  return operator new(8 * a2);
}

void sub_21677CB60(char **a1, unint64_t a2)
{
  double v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  std::exception v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    size_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      sub_21677CB10();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)sub_21677CB28(v4, v13);
      size_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[8 * v11];
    std::string v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    double v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

char *sub_21677CC7C(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61) {
      sub_21677CB10();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = sub_21677CACC(v7, v11);
    unint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  std::string v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(Alembic::AbcCoreAbstract::v12::TimeSamplingType *this)
{
  return 0xFFFFFFFFLL;
}

double Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle(Alembic::AbcCoreAbstract::v12::TimeSamplingType *this)
{
  return 5.61779105e306;
}

BOOL Alembic::AbcCoreAbstract::v12::TimeSamplingType::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return 0;
  }
  double v2 = *(double *)(a1 + 8);
  double v3 = *(double *)(a2 + 8);
  if (v2 <= v3) {
    double v4 = v3 - v2;
  }
  else {
    double v4 = v2 - v3;
  }
  return v4 <= 0.000000001;
}

void *Alembic::AbcCoreAbstract::v12::operator<<(void *a1, _DWORD *a2)
{
  sub_216779094(__p, "");
  if ((*a2 - 2) >= 0xFFFFFFFD) {
    double v4 = "Acyclic";
  }
  else {
    double v4 = "Cyclic";
  }
  if (*a2 == 1) {
    std::exception v5 = "Uniform";
  }
  else {
    std::exception v5 = v4;
  }
  MEMORY[0x21D4477E0](__p, v5);
  if ((v16 & 0x80u) == 0) {
    double v6 = __p;
  }
  else {
    double v6 = (void **)__p[0];
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v7 = v16;
  }
  else {
    uint64_t v7 = (uint64_t)__p[1];
  }
  uint64_t v8 = sub_216779180(a1, (uint64_t)v6, v7);
  sub_216779180(v8, (uint64_t)" time sampling", 14);
  if (*a2 == 1)
  {
    uint64_t v9 = " with ";
    uint64_t v10 = 6;
    unint64_t v11 = a1;
  }
  else
  {
    if ((*a2 - 2) > 0xFFFFFFFC) {
      goto LABEL_18;
    }
    sub_216779180(a1, (uint64_t)" with ", 6);
    uint64_t v12 = (void *)std::ostream::operator<<();
    unint64_t v11 = sub_216779180(v12, (uint64_t)" samps/cycle ", 13);
    uint64_t v9 = "and ";
    uint64_t v10 = 4;
  }
  sub_216779180(v11, (uint64_t)v9, v10);
  unint64_t v13 = (void *)std::ostream::operator<<();
  sub_216779180(v13, (uint64_t)" chrono_ts/cycle", 16);
LABEL_18:
  if ((char)v16 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_21677CF24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::AbcCoreAbstract::v12::ArraySample::getKey(Alembic::AbcCoreAbstract::v12::ArraySample *this@<X0>, uint64_t a2@<X8>)
{
  double v2 = this;
  double v4 = (uint64_t *)*((void *)this + 2);
  uint64_t v5 = *((void *)this + 3) - (void)v4;
  if (v5)
  {
    unint64_t v6 = v5 >> 3;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    uint64_t v7 = 1;
    do
    {
      uint64_t v8 = *v4++;
      v7 *= v8;
      --v6;
    }
    while (v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v9 = *((unsigned __int8 *)this + 12);
  unint64_t v10 = sub_21677D584((int *)this + 2) * v7;
  *(void *)(a2 + 16) = 0;
  uint64_t v12 = (unint64_t *)(a2 + 16);
  *(void *)(a2 + 24) = 0;
  *(void *)a2 = v10;
  unsigned int v13 = *((_DWORD *)v2 + 2);
  *(_DWORD *)(a2 + 8) = v13;
  *(_DWORD *)(a2 + 12) = v13;
  if (v13 < 0xC)
  {
    uint64_t v14 = *(void *)v2;
    unint64_t v15 = qword_2174071D8[v13];
    Alembic::Util::v12::MurmurHash3_x64_128(v14, v10, v15, v12, v11);
    return;
  }
  uint64_t v16 = v7 * v9;
  uint64_t v78 = v7 * v9;
  uint64_t v79 = v2;
  if (v13 == 12)
  {
    long long __p = 0;
    uint64_t v84 = 0;
    v85[0] = 0;
    if (!v16)
    {
      double v42 = 0;
      uint64_t v70 = 0;
LABEL_107:
      if (v42 == v70) {
        uint64_t v71 = 0;
      }
      else {
        uint64_t v71 = (uint64_t)v70;
      }
      Alembic::Util::v12::MurmurHash3_x64_128(v71, v42 - v70, 1uLL, v12, v11);
      uint64_t v72 = __p;
      if (__p) {
        goto LABEL_118;
      }
      return;
    }
    uint64_t v77 = (unint64_t *)(a2 + 16);
    double v42 = 0;
    uint64_t v43 = 0;
    while (1)
    {
      uint64_t v44 = *(void *)v2 + 24 * v43;
      if (*(char *)(v44 + 23) < 0)
      {
        uint64_t v45 = *(void *)(v44 + 8);
        if (v45)
        {
LABEL_63:
          uint64_t v46 = 0;
          do
          {
            uint64_t v47 = v44;
            if (*(char *)(v44 + 23) < 0) {
              uint64_t v47 = *(void *)v44;
            }
            char v48 = *(unsigned char *)(v47 + v46);
            if ((unint64_t)v42 >= v85[0])
            {
              unint64_t v50 = (unint64_t)__p;
              uint64_t v51 = v42 - (unsigned char *)__p;
              uint64_t v52 = v42 - (unsigned char *)__p + 1;
              if (v52 < 0) {
                sub_21677CB10();
              }
              unint64_t v53 = v85[0] - (void)__p;
              if (2 * (v85[0] - (void)__p) > (unint64_t)v52) {
                uint64_t v52 = 2 * v53;
              }
              if (v53 >= 0x3FFFFFFFFFFFFFFFLL) {
                size_t v54 = 0x7FFFFFFFFFFFFFFFLL;
              }
              else {
                size_t v54 = v52;
              }
              if (v54) {
                uint64_t v55 = (char *)operator new(v54);
              }
              else {
                uint64_t v55 = 0;
              }
              uint64_t v56 = &v55[v51];
              unsigned __int8 v57 = &v55[v51];
              char *v57 = v48;
              std::string v49 = v57 + 1;
              if (v42 != (char *)v50)
              {
                uint64_t v58 = &v42[~v50];
                do
                {
                  char v59 = *--v42;
                  (v58--)[(void)v55] = v59;
                }
                while (v42 != (char *)v50);
                double v42 = (char *)__p;
                uint64_t v56 = v55;
              }
              long long __p = v56;
              v85[0] = &v55[v54];
              if (v42) {
                operator delete(v42);
              }
            }
            else
            {
              char *v42 = v48;
              std::string v49 = v42 + 1;
            }
            uint64_t v84 = v49;
            ++v46;
            double v42 = v49;
          }
          while (v46 != v45);
          goto LABEL_87;
        }
      }
      else
      {
        uint64_t v45 = *(unsigned __int8 *)(v44 + 23);
        if (*(unsigned char *)(v44 + 23)) {
          goto LABEL_63;
        }
      }
      std::string v49 = v42;
LABEL_87:
      if ((unint64_t)v49 >= v85[0])
      {
        unint64_t v61 = (unint64_t)__p;
        uint64_t v62 = v49 - (unsigned char *)__p;
        uint64_t v63 = v49 - (unsigned char *)__p + 1;
        double v2 = v79;
        if (v63 < 0) {
          sub_21677CB10();
        }
        unint64_t v64 = v85[0] - (void)__p;
        if (2 * (v85[0] - (void)__p) > (unint64_t)v63) {
          uint64_t v63 = 2 * v64;
        }
        if (v64 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v65 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v65 = v63;
        }
        if (v65) {
          uint64_t v66 = (char *)operator new(v65);
        }
        else {
          uint64_t v66 = 0;
        }
        uint64_t v67 = &v66[v62];
        v66[v62] = 0;
        double v42 = &v66[v62 + 1];
        if (v49 != (unsigned char *)v61)
        {
          uint64_t v68 = &v49[~v61];
          do
          {
            char v69 = *--v49;
            (v68--)[(void)v66] = v69;
          }
          while (v49 != (unsigned char *)v61);
          std::string v49 = __p;
          uint64_t v67 = v66;
        }
        long long __p = v67;
        v85[0] = &v66[v65];
        uint64_t v60 = v78;
        if (v49) {
          operator delete(v49);
        }
      }
      else
      {
        *std::string v49 = 0;
        double v42 = v49 + 1;
        uint64_t v60 = v78;
        double v2 = v79;
      }
      uint64_t v84 = v42;
      if (++v43 == v60)
      {
        uint64_t v70 = (char *)__p;
        uint64_t v12 = v77;
        goto LABEL_107;
      }
    }
  }
  if (v13 != 13)
  {
    sub_216778A5C((uint64_t)&__p);
    uint64_t v74 = sub_216779180(v85, (uint64_t)"Can't calculate key for: ", 25);
    sub_21677D5B0(v74, (int *)v2 + 2);
    std::stringbuf::str();
    sub_216778E70(v82, &v80);
    if (v81 < 0) {
      operator delete((void *)v80);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v76 = sub_216779038(exception, (uint64_t)v82);
    __cxa_throw(v76, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  long long __p = 0;
  uint64_t v84 = 0;
  v85[0] = 0;
  if (v16)
  {
    size_t v17 = 0;
    uint64_t v18 = 0;
    while (1)
    {
      uint64_t v19 = *(void *)v2 + 24 * v18;
      if (*(char *)(v19 + 23) < 0)
      {
        uint64_t v20 = *(void *)(v19 + 8);
        if (v20)
        {
LABEL_18:
          uint64_t v21 = 0;
          do
          {
            uint64_t v22 = v19;
            if (*(char *)(v19 + 23) < 0) {
              uint64_t v22 = *(void *)v19;
            }
            int v23 = *(_DWORD *)(v22 + 4 * v21);
            if ((unint64_t)v17 >= v85[0])
            {
              double v25 = __p;
              uint64_t v26 = ((char *)v17 - (unsigned char *)__p) >> 2;
              unint64_t v27 = v26 + 1;
              if ((unint64_t)(v26 + 1) >> 62) {
                sub_21677CB10();
              }
              uint64_t v28 = v85[0] - (void)__p;
              if ((uint64_t)(v85[0] - (void)__p) >> 1 > v27) {
                unint64_t v27 = v28 >> 1;
              }
              if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v29 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v29 = v27;
              }
              if (v29)
              {
                uint64_t v30 = (char *)sub_21677EA28((uint64_t)v85, v29);
                double v25 = __p;
                size_t v17 = v84;
              }
              else
              {
                uint64_t v30 = 0;
              }
              uint64_t v31 = &v30[4 * v26];
              *(_DWORD *)uint64_t v31 = v23;
              double v24 = v31 + 4;
              while (v17 != v25)
              {
                int v32 = *--v17;
                *((_DWORD *)v31 - 1) = v32;
                v31 -= 4;
              }
              long long __p = v31;
              uint64_t v84 = v24;
              v85[0] = &v30[4 * v29];
              if (v25) {
                operator delete(v25);
              }
            }
            else
            {
              _DWORD *v17 = v23;
              double v24 = v17 + 1;
            }
            uint64_t v84 = v24;
            ++v21;
            size_t v17 = v24;
          }
          while (v21 != v20);
          goto LABEL_41;
        }
      }
      else
      {
        uint64_t v20 = *(unsigned __int8 *)(v19 + 23);
        if (*(unsigned char *)(v19 + 23)) {
          goto LABEL_18;
        }
      }
      double v24 = v17;
LABEL_41:
      double v2 = v79;
      if ((unint64_t)v24 >= v85[0])
      {
        double v33 = __p;
        uint64_t v34 = ((char *)v24 - (unsigned char *)__p) >> 2;
        unint64_t v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 62) {
          sub_21677CB10();
        }
        uint64_t v36 = v85[0] - (void)__p;
        if ((uint64_t)(v85[0] - (void)__p) >> 1 > v35) {
          unint64_t v35 = v36 >> 1;
        }
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v37 = v35;
        }
        if (v37)
        {
          double v38 = (char *)sub_21677EA28((uint64_t)v85, v37);
          double v33 = __p;
          double v24 = v84;
        }
        else
        {
          double v38 = 0;
        }
        uint64_t v39 = &v38[4 * v34];
        *(_DWORD *)uint64_t v39 = 0;
        size_t v17 = v39 + 4;
        while (v24 != v33)
        {
          int v40 = *--v24;
          *((_DWORD *)v39 - 1) = v40;
          v39 -= 4;
        }
        long long __p = v39;
        uint64_t v84 = v17;
        v85[0] = &v38[4 * v37];
        if (v33) {
          operator delete(v33);
        }
      }
      else
      {
        *double v24 = 0;
        size_t v17 = v24 + 1;
      }
      uint64_t v84 = v17;
      if (++v18 == v78)
      {
        double v41 = __p;
        uint64_t v12 = (unint64_t *)(a2 + 16);
        goto LABEL_113;
      }
    }
  }
  size_t v17 = 0;
  double v41 = 0;
LABEL_113:
  if (v17 == (_DWORD *)v41) {
    uint64_t v73 = 0;
  }
  else {
    uint64_t v73 = (uint64_t)v41;
  }
  Alembic::Util::v12::MurmurHash3_x64_128(v73, ((char *)v17 - v41) >> 2, 4uLL, v12, v11);
  uint64_t v72 = __p;
  if (__p)
  {
    uint64_t v84 = __p;
LABEL_118:
    operator delete(v72);
  }
}

void sub_21677D520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::exception a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
}

uint64_t sub_21677D584(int *a1)
{
  uint64_t v1 = *a1;
  if (v1 > 0xD) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = qword_217407238[v1];
  }
  return v2 * *((unsigned __int8 *)a1 + 4);
}

void *sub_21677D5B0(void *a1, int *a2)
{
  uint64_t v4 = *a2;
  if (v4 > 0xD) {
    uint64_t v5 = "UNKNOWN";
  }
  else {
    uint64_t v5 = off_264294188[v4];
  }
  size_t v6 = strlen(v5);
  sub_216779180(a1, (uint64_t)v5, v6);
  if (*((unsigned __int8 *)a2 + 4) >= 2u)
  {
    sub_216779180(a1, (uint64_t)"[", 1);
    uint64_t v7 = (void *)std::ostream::operator<<();
    sub_216779180(v7, (uint64_t)"]", 1);
  }
  return a1;
}

void *Alembic::AbcCoreAbstract::v12::AllocateArraySample@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  switch(*(_DWORD *)result)
  {
    case 0:
      uint64_t result = sub_21677D730(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 1:
      uint64_t result = sub_21677D878(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 2:
      uint64_t result = sub_21677D9BC(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 3:
      uint64_t result = sub_21677DB00(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 4:
      uint64_t result = sub_21677DC50(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 5:
      uint64_t result = sub_21677DDA0(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 6:
      uint64_t result = sub_21677DEF4(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 7:
      uint64_t result = sub_21677E048(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 8:
      uint64_t result = sub_21677E19C(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 9:
      uint64_t result = sub_21677E2F0(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 0xA:
      uint64_t result = sub_21677E440(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 0xB:
      uint64_t result = sub_21677E594(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 0xC:
      uint64_t result = sub_21677E6E8(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    case 0xD:
      uint64_t result = sub_21677E888(*((unsigned __int8 *)result + 4), a2, a3);
      break;
    default:
      *a3 = 0;
      a3[1] = 0;
      break;
  }
  return result;
}

void *sub_21677D730@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  size_t v12 = v9 * a1;
  if (v9 * a1)
  {
    unsigned int v13 = operator new[](v9 * a1);
    bzero(v13, v12);
    uint64_t v14 = operator new(0x28uLL);
    void *v14 = v13;
    v14[1] = (unint64_t)v3 << 32;
    v14[3] = 0;
    v14[4] = 0;
    void v14[2] = 0;
    sub_21677EA60(v14 + 2, v6, v5, v7 >> 3);
    return sub_21677EADC(a3, (uint64_t)v14);
  }
  else
  {
    uint64_t v16 = operator new(0x28uLL);
    *uint64_t v16 = 0;
    v16[1] = (unint64_t)v3 << 32;
    v16[3] = 0;
    v16[4] = 0;
    v16[2] = 0;
    sub_21677EA60(v16 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v16);
  }
}

void sub_21677D860(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677D878@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  size_t v12 = v9 * a1;
  if (v9 * a1)
  {
    unsigned int v13 = operator new[](v12);
    uint64_t v14 = operator new(0x28uLL);
    void *v14 = v13;
    v14[1] = ((unint64_t)a1 << 32) | 1;
    v14[3] = 0;
    v14[4] = 0;
    void v14[2] = 0;
    sub_21677EA60(v14 + 2, v6, v5, v7 >> 3);
    return sub_21677EDE4(a3, (uint64_t)v14);
  }
  else
  {
    uint64_t v16 = operator new(0x28uLL);
    *uint64_t v16 = 0;
    v16[1] = ((unint64_t)a1 << 32) | 1;
    v16[3] = 0;
    v16[4] = 0;
    v16[2] = 0;
    sub_21677EA60(v16 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v16);
  }
}

void sub_21677D9A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677D9BC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  size_t v12 = v9 * a1;
  if (v9 * a1)
  {
    unsigned int v13 = operator new[](v12);
    uint64_t v14 = operator new(0x28uLL);
    void *v14 = v13;
    v14[1] = ((unint64_t)a1 << 32) | 2;
    v14[3] = 0;
    v14[4] = 0;
    void v14[2] = 0;
    sub_21677EA60(v14 + 2, v6, v5, v7 >> 3);
    return sub_21677EEE8(a3, (uint64_t)v14);
  }
  else
  {
    uint64_t v16 = operator new(0x28uLL);
    *uint64_t v16 = 0;
    v16[1] = ((unint64_t)a1 << 32) | 2;
    v16[3] = 0;
    v16[4] = 0;
    v16[2] = 0;
    sub_21677EA60(v16 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v16);
  }
}

void sub_21677DAE8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677DB00@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  uint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 < 0) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 2 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 3;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677EFEC(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 3;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677DC38(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677DC50@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  uint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 < 0) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 2 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 4;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677F0F0(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 4;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677DD88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677DDA0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  unint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 62) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 4 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 5;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677F1F4(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 5;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677DEDC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677DEF4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  unint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 62) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 4 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 6;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677F2F8(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 6;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677E030(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677E048@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  unint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 61) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 8 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 7;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677F3FC(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 7;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677E184(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677E19C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  unint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 61) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 8 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 8;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677F500(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 8;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677E2D8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677E2F0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  uint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 < 0) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 2 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 9;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677F604(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 9;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677E428(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677E440@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  unint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 62) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 4 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 0xA;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677F708(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 0xA;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677E57C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677E594@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  unint64_t v12 = v9 * a1;
  if (v12)
  {
    if (v12 >> 61) {
      size_t v13 = -1;
    }
    else {
      size_t v13 = 8 * v12;
    }
    uint64_t v14 = operator new[](v13);
    unint64_t v15 = operator new(0x28uLL);
    *unint64_t v15 = v14;
    v15[1] = ((unint64_t)v3 << 32) | 0xB;
    v15[3] = 0;
    v15[4] = 0;
    void v15[2] = 0;
    sub_21677EA60(v15 + 2, v6, v5, v7 >> 3);
    return sub_21677F80C(a3, (uint64_t)v15);
  }
  else
  {
    size_t v17 = operator new(0x28uLL);
    void *v17 = 0;
    v17[1] = ((unint64_t)v3 << 32) | 0xB;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v17);
  }
}

void sub_21677E6D0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677E6E8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  unint64_t v12 = v9 * a1;
  if (v9 * a1)
  {
    BOOL v13 = !is_mul_ok(v12, 0x18uLL);
    if (24 * v12 >= 0xFFFFFFFFFFFFFFF0) {
      BOOL v13 = 1;
    }
    if (v13) {
      size_t v14 = -1;
    }
    else {
      size_t v14 = 24 * v12 + 16;
    }
    unint64_t v15 = operator new[](v14);
    *unint64_t v15 = 24;
    v15[1] = v12;
    uint64_t v16 = v15 + 2;
    bzero(v15 + 2, 24 * ((24 * v12 - 24) / 0x18) + 24);
    size_t v17 = operator new(0x28uLL);
    void *v17 = v16;
    v17[1] = ((unint64_t)v3 << 32) | 0xC;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677F910(a3, (uint64_t)v17);
  }
  else
  {
    uint64_t v19 = operator new(0x28uLL);
    *uint64_t v19 = 0;
    v19[1] = ((unint64_t)v3 << 32) | 0xC;
    v19[3] = 0;
    v19[4] = 0;
    v19[2] = 0;
    sub_21677EA60(v19 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v19);
  }
}

void sub_21677E870(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677E888@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unsigned __int8 v3 = a1;
  size_t v6 = *(uint64_t **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t v7 = v5 - *(void *)a2;
  if (v5 == *(void *)a2)
  {
    uint64_t v9 = 0;
  }
  else
  {
    if ((unint64_t)(v7 >> 3) <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7 >> 3;
    }
    uint64_t v9 = 1;
    unint64_t v10 = *(uint64_t **)a2;
    do
    {
      uint64_t v11 = *v10++;
      v9 *= v11;
      --v8;
    }
    while (v8);
  }
  unint64_t v12 = v9 * a1;
  if (v9 * a1)
  {
    BOOL v13 = !is_mul_ok(v12, 0x18uLL);
    if (24 * v12 >= 0xFFFFFFFFFFFFFFF0) {
      BOOL v13 = 1;
    }
    if (v13) {
      size_t v14 = -1;
    }
    else {
      size_t v14 = 24 * v12 + 16;
    }
    unint64_t v15 = operator new[](v14);
    *unint64_t v15 = 24;
    v15[1] = v12;
    uint64_t v16 = v15 + 2;
    bzero(v15 + 2, 24 * ((24 * v12 - 24) / 0x18) + 24);
    size_t v17 = operator new(0x28uLL);
    void *v17 = v16;
    v17[1] = ((unint64_t)v3 << 32) | 0xD;
    uint64_t v17[3] = 0;
    void v17[4] = 0;
    v17[2] = 0;
    sub_21677EA60(v17 + 2, v6, v5, v7 >> 3);
    return sub_21677FAA8(a3, (uint64_t)v17);
  }
  else
  {
    uint64_t v19 = operator new(0x28uLL);
    *uint64_t v19 = 0;
    v19[1] = ((unint64_t)v3 << 32) | 0xD;
    v19[3] = 0;
    v19[4] = 0;
    v19[2] = 0;
    sub_21677EA60(v19 + 2, v6, v5, v7 >> 3);
    return sub_21677ECA0(a3, (uint64_t)v19);
  }
}

void sub_21677EA10(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_21677EA28(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_21677CA1C();
  }
  return operator new(4 * a2);
}

void *sub_21677EA60(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    size_t v6 = result;
    uint64_t result = sub_21677CACC(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21677EAC0(_Unwind_Exception *exception_object)
{
  unsigned __int8 v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_21677EADC(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747110;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677EB3C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677EB54(_Unwind_Exception *a1)
{
}

void sub_21677EB68(int a1, void **__p)
{
  if (__p)
  {
    if (*__p) {
      operator delete[](*__p);
    }
    unsigned __int8 v3 = __p[2];
    if (v3)
    {
      __p[3] = v3;
      operator delete(v3);
    }
    operator delete(__p);
  }
}

void sub_21677EBC4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677EBEC(uint64_t a1)
{
}

uint64_t sub_21677EC0C(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747150)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

BOOL sub_21677EC50(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void *sub_21677ECA0(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747170;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677ED00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_21677ED98((int)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_21677ED24(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677ED4C(uint64_t a1)
{
}

uint64_t sub_21677ED54(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7471C0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_21677ED98(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v3 = (void *)__p[2];
    if (v3)
    {
      __p[3] = v3;
      operator delete(v3);
    }
    operator delete(__p);
  }
}

void *sub_21677EDE4(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7471E8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677EE44(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677EE5C(_Unwind_Exception *a1)
{
}

void sub_21677EE74(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677EE9C(uint64_t a1)
{
}

uint64_t sub_21677EEA4(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747228)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677EEE8(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747248;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677EF48(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677EF60(_Unwind_Exception *a1)
{
}

void sub_21677EF78(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677EFA0(uint64_t a1)
{
}

uint64_t sub_21677EFA8(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747288)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677EFEC(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7472A8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F04C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F064(_Unwind_Exception *a1)
{
}

void sub_21677F07C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F0A4(uint64_t a1)
{
}

uint64_t sub_21677F0AC(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7472E8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F0F0(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747308;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F150(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F168(_Unwind_Exception *a1)
{
}

void sub_21677F180(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F1A8(uint64_t a1)
{
}

uint64_t sub_21677F1B0(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747348)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F1F4(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747368;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F254(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F26C(_Unwind_Exception *a1)
{
}

void sub_21677F284(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F2AC(uint64_t a1)
{
}

uint64_t sub_21677F2B4(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7473A8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F2F8(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7473C8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F358(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F370(_Unwind_Exception *a1)
{
}

void sub_21677F388(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F3B0(uint64_t a1)
{
}

uint64_t sub_21677F3B8(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747408)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F3FC(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747428;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F45C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F474(_Unwind_Exception *a1)
{
}

void sub_21677F48C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F4B4(uint64_t a1)
{
}

uint64_t sub_21677F4BC(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747468)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F500(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747488;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F560(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F578(_Unwind_Exception *a1)
{
}

void sub_21677F590(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F5B8(uint64_t a1)
{
}

uint64_t sub_21677F5C0(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7474C8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F604(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7474E8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F664(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F67C(_Unwind_Exception *a1)
{
}

void sub_21677F694(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F6BC(uint64_t a1)
{
}

uint64_t sub_21677F6C4(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747528)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F708(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747548;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F768(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F780(_Unwind_Exception *a1)
{
}

void sub_21677F798(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F7C0(uint64_t a1)
{
}

uint64_t sub_21677F7C8(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747588)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F80C(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7475A8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F86C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677EB68((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F884(_Unwind_Exception *a1)
{
}

void sub_21677F89C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677F8C4(uint64_t a1)
{
}

uint64_t sub_21677F8CC(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7475E8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677F910(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747608;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677F970(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677F99C((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677F988(_Unwind_Exception *a1)
{
}

void sub_21677F99C(int a1, uint64_t *__p)
{
  if (__p)
  {
    uint64_t v3 = *__p;
    if (*__p)
    {
      uint64_t v4 = *(void *)(v3 - 8);
      if (v4)
      {
        uint64_t v5 = 24 * v4;
        do
        {
          if (*(char *)(v3 + v5 - 1) < 0) {
            operator delete(*(void **)(v3 + v5 - 24));
          }
          v5 -= 24;
        }
        while (v5);
      }
      operator delete[]((void *)(v3 - 16));
    }
    size_t v6 = (void *)__p[2];
    if (v6)
    {
      __p[3] = (uint64_t)v6;
      operator delete(v6);
    }
    operator delete(__p);
  }
}

void sub_21677FA34(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677FA5C(uint64_t a1)
{
}

uint64_t sub_21677FA64(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C747648)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21677FAA8(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C747668;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21677FB08(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  sub_21677F99C((int)&a13, v13);
  __cxa_rethrow();
}

void sub_21677FB20(_Unwind_Exception *a1)
{
}

void sub_21677FB38(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21677FB60(uint64_t a1)
{
}

uint64_t sub_21677FB68(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7476A8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void Alembic::AbcCoreAbstract::v12::ReadArraySampleCache::~ReadArraySampleCache(Alembic::AbcCoreAbstract::v12::ReadArraySampleCache *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t Alembic::AbcCoreAbstract::v12::ScalarSample::ScalarSample(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = 0;
  if (v3 == 127 || (v3 & 0xFF00000000) == 0)
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Degenerate data type in scalar sample", 37);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v12 = sub_216779038(exception, (uint64_t)v18);
    __cxa_throw(v12, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  size_t v5 = BYTE4(v3);
  switch((int)v3)
  {
    case 0:
      size_t v6 = operator new(0x20uLL);
      sub_2167800E8(v6, v5);
      break;
    case 1:
      size_t v6 = operator new(0x20uLL);
      sub_2167804D4(v6, v5);
      break;
    case 2:
      size_t v6 = operator new(0x20uLL);
      sub_216780814(v6, v5);
      break;
    case 3:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C747898;
      sub_216780DB8(v6 + 1, v5);
      goto LABEL_13;
    case 4:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C747900;
      sub_216781108(v6 + 1, v5);
      goto LABEL_13;
    case 5:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C747968;
      sub_2167813E0(v6 + 1, v5);
      goto LABEL_20;
    case 6:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C7479D0;
      sub_2167816FC(v6 + 1, v5);
      goto LABEL_20;
    case 7:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C747A38;
      sub_2167819D4(v6 + 1, v5);
      goto LABEL_22;
    case 8:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C747AA0;
      sub_216781CAC(v6 + 1, v5);
      goto LABEL_22;
    case 9:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C747B08;
      sub_216782194(v6 + 1, v5);
LABEL_13:
      uint64_t v7 = (void *)v6[1];
      size_t v8 = 2 * v5;
      goto LABEL_23;
    case 10:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C747B70;
      sub_21678247C(v6 + 1, v5);
LABEL_20:
      uint64_t v7 = (void *)v6[1];
      size_t v8 = 4 * v5;
      goto LABEL_23;
    case 11:
      size_t v6 = operator new(0x20uLL);
      *size_t v6 = &unk_26C747BD8;
      sub_21678275C(v6 + 1, v5);
LABEL_22:
      uint64_t v7 = (void *)v6[1];
      size_t v8 = 8 * v5;
LABEL_23:
      bzero(v7, v8);
      break;
    case 12:
      size_t v6 = operator new(0x20uLL);
      sub_2167827D4(v6, v5);
      break;
    case 13:
      size_t v6 = operator new(0x20uLL);
      sub_216782FC4(v6, v5);
      break;
    default:
      sub_216778A5C((uint64_t)v19);
      BOOL v13 = sub_216779180(v20, (uint64_t)"Unknown datatype in ScalarSample: ", 34);
      sub_21677D5B0(v13, (int *)a1);
      std::stringbuf::str();
      sub_216778E70(v18, (long long *)__p);
      if (v17 < 0) {
        operator delete(__p[0]);
      }
      size_t v14 = __cxa_allocate_exception(0x20uLL);
      unint64_t v15 = sub_216779038(v14, (uint64_t)v18);
      __cxa_throw(v15, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v9 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v6;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  return a1;
}

void sub_21677FFF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v6 = *(void *)(v4 + 8);
  *(void *)(v4 + 8) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  _Unwind_Resume(a1);
}

void *sub_2167800E8(void *a1, size_t a2)
{
  *a1 = &unk_26C747750;
  uint64_t v4 = sub_21678041C(a1 + 1, a2);
  if (a2)
  {
    uint64_t v5 = 0;
    do
      *(unsigned char *)(*v4 + v5++) = 0;
    while (a2 != v5);
  }
  return a1;
}

void *sub_21678014C(void *a1)
{
  *a1 = &unk_26C747750;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_21678019C(void *__p)
{
  *long long __p = &unk_26C747750;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_2167801FC(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 16) - *(void *)(result + 8);
  if (v1)
  {
    uint64_t v2 = 0;
    if (v1 <= 1) {
      unint64_t v1 = 1;
    }
    do
      *(unsigned char *)(*(void *)(result + 8) + v2++) = 0;
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_21678022C(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void *)(result + 16) - *(void *)(result + 8);
  if (v2)
  {
    uint64_t v3 = 0;
    if (v2 <= 1) {
      unint64_t v2 = 1;
    }
    do
    {
      *(unsigned char *)(*(void *)(result + 8) + v3) = *(unsigned char *)(a2 + v3);
      ++v3;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL sub_216780260(uint64_t a1, unsigned char *a2)
{
  unint64_t v2 = *(unsigned char **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  if (v3 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
  }
  if ((*v2 != 0) != (*a2 != 0)) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v4 == v6) {
      break;
    }
    int v8 = v2[v6] != 0;
    int v9 = a2[v6++] != 0;
  }
  while (v8 == v9);
  return v7 >= v3;
}

BOOL sub_2167802E4(uint64_t a1, unsigned char *a2)
{
  unint64_t v2 = *(unsigned char **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  if (v3 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
  }
  if ((*v2 == 0) == (*a2 != 0)) {
    return 0;
  }
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v4 == v5) {
      break;
    }
    char v7 = (v2[v5] == 0) ^ (a2[v5] != 0);
    ++v5;
  }
  while ((v7 & 1) != 0);
  return v6 >= v3;
}

uint64_t sub_216780368(uint64_t a1, unsigned char *a2)
{
  unint64_t v2 = *(unsigned char **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    if (v3 <= 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
    }
    BOOL v5 = *v2 != 0;
    BOOL v6 = *a2 == 0;
    if (*v2) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = *a2 == 0;
    }
    if (v7)
    {
      unint64_t v8 = 1;
      BOOL v9 = 1;
      while (!v5 || !v6)
      {
        BOOL v9 = v8 < v3;
        if (v4 == v8) {
          goto LABEL_21;
        }
        int v10 = v2[v8];
        int v11 = a2[v8];
        BOOL v5 = v2[v8] != 0;
        BOOL v6 = v11 == 0;
        ++v8;
        if (v10) {
          BOOL v12 = 1;
        }
        else {
          BOOL v12 = v11 == 0;
        }
        if (!v12)
        {
          LOBYTE(v2) = 1;
          goto LABEL_21;
        }
      }
      LOBYTE(v2) = 0;
LABEL_21:
      char v13 = v9 & v2;
    }
    else
    {
      char v13 = 1;
    }
  }
  else
  {
    char v13 = 0;
  }
  return v13 & 1;
}

uint64_t sub_216780414(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_21678041C(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216780490(a1, a2);
    uint64_t v4 = (char *)a1[1];
    BOOL v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_216780474(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_216780490(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_21677CB10();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void *sub_2167804D4(void *a1, size_t a2)
{
  *a1 = &unk_26C7477C8;
  uint64_t v4 = sub_2167807A0(a1 + 1, a2);
  if (a2)
  {
    uint64_t v5 = 0;
    do
      *(unsigned char *)(*v4 + v5++) = 0;
    while (a2 != v5);
  }
  return a1;
}

void *sub_216780538(void *a1)
{
  *a1 = &unk_26C7477C8;
  unint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_216780588(void *__p)
{
  *long long __p = &unk_26C7477C8;
  unint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_2167805E8(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 16) - *(void *)(result + 8);
  if (v1)
  {
    uint64_t v2 = 0;
    if (v1 <= 1) {
      unint64_t v1 = 1;
    }
    do
      *(unsigned char *)(*(void *)(result + 8) + v2++) = 0;
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_216780618(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void *)(result + 16) - *(void *)(result + 8);
  if (v2)
  {
    uint64_t v3 = 0;
    if (v2 <= 1) {
      unint64_t v2 = 1;
    }
    do
    {
      *(unsigned char *)(*(void *)(result + 8) + v3) = *(unsigned char *)(a2 + v3);
      ++v3;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL sub_21678064C(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  if (v3 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v4 == v5) {
      break;
    }
    int v7 = v2[v5];
    int v8 = a2[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

BOOL sub_2167806B0(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  if (v3 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v4 == v5) {
      break;
    }
    int v7 = v2[v5];
    int v8 = a2[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

uint64_t sub_216780714(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    if (v3 <= 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
    }
    unsigned int v5 = *v2;
    unsigned int v6 = *a2;
    if (v5 >= v6)
    {
      unint64_t v8 = 1;
      BOOL v9 = 1;
      while (v5 <= v6)
      {
        BOOL v9 = v8 < v3;
        if (v4 == v8) {
          goto LABEL_14;
        }
        unsigned int v5 = v2[v8];
        unsigned int v6 = a2[v8++];
        if (v5 < v6)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v7 = v9 & v2;
    }
    else
    {
      char v7 = 1;
    }
  }
  else
  {
    char v7 = 0;
  }
  return v7 & 1;
}

uint64_t sub_216780798(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_2167807A0(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216780490(a1, a2);
    uint64_t v4 = (char *)a1[1];
    unsigned int v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_2167807F8(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_216780814(void *a1, size_t a2)
{
  *a1 = &unk_26C747830;
  uint64_t v4 = sub_216780AE4(a1 + 1, a2);
  if (a2)
  {
    uint64_t v5 = 0;
    do
      *(unsigned char *)(*v4 + v5++) = 0;
    while (a2 != v5);
  }
  return a1;
}

void *sub_216780878(void *a1)
{
  *a1 = &unk_26C747830;
  unint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_2167808C8(void *__p)
{
  *long long __p = &unk_26C747830;
  unint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

uint64_t sub_216780928(uint64_t result)
{
  unint64_t v1 = *(void *)(result + 16) - *(void *)(result + 8);
  if (v1)
  {
    uint64_t v2 = 0;
    if (v1 <= 1) {
      unint64_t v1 = 1;
    }
    do
      *(unsigned char *)(*(void *)(result + 8) + v2++) = 0;
    while (v1 != v2);
  }
  return result;
}

uint64_t sub_216780958(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(void *)(result + 16) - *(void *)(result + 8);
  if (v2)
  {
    uint64_t v3 = 0;
    if (v2 <= 1) {
      unint64_t v2 = 1;
    }
    do
    {
      *(unsigned char *)(*(void *)(result + 8) + v3) = *(unsigned char *)(a2 + v3);
      ++v3;
    }
    while (v2 != v3);
  }
  return result;
}

BOOL sub_21678098C(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  if (v3 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v4 == v5) {
      break;
    }
    int v7 = v2[v5];
    int v8 = a2[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

BOOL sub_2167809F0(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v2 = *(unsigned __int8 **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  if (v3 <= 1) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v4 == v5) {
      break;
    }
    int v7 = v2[v5];
    int v8 = a2[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

uint64_t sub_216780A54(uint64_t a1, char *a2)
{
  unint64_t v2 = *(char **)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    if (v3 <= 1) {
      uint64_t v4 = 1;
    }
    else {
      uint64_t v4 = *(void *)(a1 + 16) - (void)v2;
    }
    int v5 = *v2;
    int v6 = *a2;
    if (v5 >= v6)
    {
      unint64_t v8 = 1;
      BOOL v9 = 1;
      while ((char)v5 <= (char)v6)
      {
        BOOL v9 = v8 < v3;
        if (v4 == v8) {
          goto LABEL_14;
        }
        int v5 = v2[v8];
        int v6 = a2[v8++];
        if (v5 < v6)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v7 = v9 & v2;
    }
    else
    {
      char v7 = 1;
    }
  }
  else
  {
    char v7 = 0;
  }
  return v7 & 1;
}

uint64_t sub_216780ADC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_216780AE4(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216780490(a1, a2);
    uint64_t v4 = (char *)a1[1];
    int v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_216780B3C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_216780B58(void *a1)
{
  *a1 = &unk_26C747898;
  unint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_216780BA8(void *__p)
{
  *long long __p = &unk_26C747898;
  unint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_216780C08(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 1;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 2 * v4);
  }
}

uint64_t sub_216780C2C(uint64_t result, __int16 *a2)
{
  uint64_t v2 = *(_WORD **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 1;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      __int16 v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_216780C58(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 1;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    int v8 = v2[v6];
    int v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_216780CC0(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 1;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    int v8 = v2[v6];
    int v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_216780D28(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 1;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    unsigned int v6 = *v2;
    unsigned int v7 = *a2;
    if (v6 >= v7)
    {
      unint64_t v9 = 1;
      BOOL v10 = 1;
      while (v6 <= v7)
      {
        BOOL v10 = v9 < v4;
        if (v5 == v9) {
          goto LABEL_14;
        }
        unsigned int v6 = v2[v9];
        unsigned int v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v8 = v10 & v2;
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_216780DB0(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_216780DB8(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216780E30(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_216780E14(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_216780E30(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_21677CB10();
  }
  uint64_t result = (char *)sub_216780E70((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void *sub_216780E70(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_21677CA1C();
  }
  return operator new(2 * a2);
}

void *sub_216780EA4(void *a1)
{
  *a1 = &unk_26C747900;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_216780EF4(void *__p)
{
  *long long __p = &unk_26C747900;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_216780F54(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 1;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 2 * v4);
  }
}

uint64_t sub_216780F78(uint64_t result, __int16 *a2)
{
  uint64_t v2 = *(_WORD **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 1;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      __int16 v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_216780FA4(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 1;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    int v8 = v2[v6];
    int v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_21678100C(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2 = *(unsigned __int16 **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 1;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    int v8 = v2[v6];
    int v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_216781074(uint64_t a1, __int16 *a2)
{
  uint64_t v2 = *(__int16 **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 1;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    int v6 = *v2;
    int v7 = *a2;
    if (v6 >= v7)
    {
      unint64_t v9 = 1;
      BOOL v10 = 1;
      while ((__int16)v6 <= (__int16)v7)
      {
        BOOL v10 = v9 < v4;
        if (v5 == v9) {
          goto LABEL_14;
        }
        int v6 = v2[v9];
        int v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v8 = v10 & v2;
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_216781100(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_216781108(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216780E30(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_216781164(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_216781180(void *a1)
{
  *a1 = &unk_26C747968;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_2167811D0(void *__p)
{
  *long long __p = &unk_26C747968;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_216781230(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 4 * v4);
  }
}

uint64_t sub_216781254(uint64_t result, int *a2)
{
  uint64_t v2 = *(_DWORD **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      int v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_216781280(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 2;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    int v8 = v2[v6];
    int v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_2167812E8(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 2;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    int v8 = v2[v6];
    int v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_216781350(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(unsigned int **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    unsigned int v6 = *v2;
    unsigned int v7 = *a2;
    if (*v2 >= *a2)
    {
      unint64_t v9 = 1;
      BOOL v10 = 1;
      while (v6 <= v7)
      {
        BOOL v10 = v9 < v4;
        if (v5 == v9) {
          goto LABEL_14;
        }
        unsigned int v6 = v2[v9];
        unsigned int v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v8 = v10 & v2;
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_2167813D8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_2167813E0(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216781458(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_21678143C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_216781458(void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_21677CB10();
  }
  uint64_t result = (char *)sub_21677EA28((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *sub_21678149C(void *a1)
{
  *a1 = &unk_26C7479D0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_2167814EC(void *__p)
{
  *long long __p = &unk_26C7479D0;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_21678154C(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 4 * v4);
  }
}

uint64_t sub_216781570(uint64_t result, int *a2)
{
  uint64_t v2 = *(_DWORD **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      int v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_21678159C(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 2;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    int v8 = v2[v6];
    int v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_216781604(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 2;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    int v8 = v2[v6];
    int v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_21678166C(uint64_t a1, int *a2)
{
  uint64_t v2 = *(int **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    int v6 = *v2;
    int v7 = *a2;
    if (*v2 >= *a2)
    {
      unint64_t v9 = 1;
      BOOL v10 = 1;
      while (v6 <= v7)
      {
        BOOL v10 = v9 < v4;
        if (v5 == v9) {
          goto LABEL_14;
        }
        int v6 = v2[v9];
        int v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v8 = v10 & v2;
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_2167816F4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_2167816FC(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216781458(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_216781758(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_216781774(void *a1)
{
  *a1 = &unk_26C747A38;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_2167817C4(void *__p)
{
  *long long __p = &unk_26C747A38;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_216781824(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 8 * v4);
  }
}

uint64_t sub_216781848(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(void **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      uint64_t v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_216781874(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 3;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    uint64_t v8 = v2[v6];
    uint64_t v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_2167818DC(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 3;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    uint64_t v8 = v2[v6];
    uint64_t v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_216781944(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(unint64_t **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    unint64_t v6 = *v2;
    unint64_t v7 = *a2;
    if (*v2 >= *a2)
    {
      unint64_t v9 = 1;
      BOOL v10 = 1;
      while (v6 <= v7)
      {
        BOOL v10 = v9 < v4;
        if (v5 == v9) {
          goto LABEL_14;
        }
        unint64_t v6 = v2[v9];
        unint64_t v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v8 = v10 & v2;
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_2167819CC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_2167819D4(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_21677CACC(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_216781A30(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_216781A4C(void *a1)
{
  *a1 = &unk_26C747AA0;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_216781A9C(void *__p)
{
  *long long __p = &unk_26C747AA0;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_216781AFC(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 8 * v4);
  }
}

uint64_t sub_216781B20(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(void **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      uint64_t v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_216781B4C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 3;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    uint64_t v8 = v2[v6];
    uint64_t v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

BOOL sub_216781BB4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 3;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v6 = 1;
  do
  {
    unint64_t v7 = v6;
    if (v5 == v6) {
      break;
    }
    uint64_t v8 = v2[v6];
    uint64_t v9 = a2[v6++];
  }
  while (v8 == v9);
  return v7 >= v4;
}

uint64_t sub_216781C1C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    uint64_t v6 = *v2;
    uint64_t v7 = *a2;
    if (*v2 >= *a2)
    {
      unint64_t v9 = 1;
      BOOL v10 = 1;
      while (v6 <= v7)
      {
        BOOL v10 = v9 < v4;
        if (v5 == v9) {
          goto LABEL_14;
        }
        uint64_t v6 = v2[v9];
        uint64_t v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v8 = v10 & v2;
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_216781CA4(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_216781CAC(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_21677CACC(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_216781D08(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_216781D24(void *a1)
{
  *a1 = &unk_26C747B08;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_216781D74(void *__p)
{
  *long long __p = &unk_26C747B08;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_216781DD4(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 1;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 2 * v4);
  }
}

uint64_t sub_216781DF8(uint64_t result, __int16 *a2)
{
  uint64_t v2 = *(_WORD **)(result + 8);
  uint64_t v3 = *(void *)(result + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 1;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      __int16 v5 = *a2++;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_216781E24(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = v3 - v2;
  if (v3 == v2)
  {
    return 1;
  }
  else
  {
    BOOL v5 = 0;
    uint64_t v6 = 0;
    unint64_t v7 = v4 >> 1;
    if (v7 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = v7;
    }
    do
    {
      int v9 = *(__int16 *)(v2 + 2 * v6);
      unsigned int v10 = (v9 & 0x7FFF) << 13;
      unsigned int v11 = v9 & 0x80000000;
      unsigned int v12 = __clz(v10) - 8;
      int v13 = (v11 | 0x38800000 | (v10 << v12)) - (v12 << 23);
      if (!v10) {
        int v13 = v11;
      }
      int v14 = v10 | v11;
      int v15 = v14 | 0x7F800000;
      int v16 = v14 + 939524096;
      if (v10 >> 23 > 0x1E) {
        int v16 = v15;
      }
      if (v10 < 0x800000) {
        int v16 = v13;
      }
      float v17 = *(float *)&v16;
      int v18 = *(__int16 *)(a2 + 2 * v6);
      unsigned int v19 = (v18 & 0x7FFF) << 13;
      unsigned int v20 = v18 & 0x80000000;
      unsigned int v21 = __clz(v19) - 8;
      int v22 = (v20 | 0x38800000 | (v19 << v21)) - (v21 << 23);
      if (!v19) {
        int v22 = v20;
      }
      int v23 = v19 | v20;
      int v24 = v23 | 0x7F800000;
      LODWORD(v25) = v23 + 939524096;
      if (v19 >> 23 > 0x1E) {
        float v25 = *(float *)&v24;
      }
      if (v19 < 0x800000) {
        float v25 = *(float *)&v22;
      }
      if (v17 != v25) {
        break;
      }
      BOOL v5 = ++v6 >= v7;
    }
    while (v8 != v6);
  }
  return v5;
}

BOOL sub_216781F18(uint64_t a1, uint64_t a2, double a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = v4 - v3;
  if (v4 == v3)
  {
    return 1;
  }
  else
  {
    BOOL v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = v5 >> 1;
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v8;
    }
    do
    {
      int v10 = *(__int16 *)(v3 + 2 * v7);
      unsigned int v11 = (v10 & 0x7FFF) << 13;
      unsigned int v12 = v10 & 0x80000000;
      unsigned int v13 = __clz(v11) - 8;
      int v14 = (v12 | 0x38800000 | (v11 << v13)) - (v13 << 23);
      if (!v11) {
        int v14 = v12;
      }
      int v15 = v11 | v12;
      int v16 = v15 | 0x7F800000;
      LODWORD(v17) = v15 + 939524096;
      if (v11 >> 23 > 0x1E) {
        float v17 = *(float *)&v16;
      }
      BOOL v18 = v11 >= 0x800000;
      int v19 = *(__int16 *)(a2 + 2 * v7);
      if (!v18) {
        float v17 = *(float *)&v14;
      }
      unsigned int v20 = (v19 & 0x7FFF) << 13;
      unsigned int v21 = v19 & 0x80000000;
      unsigned int v22 = __clz(v20) - 8;
      int v23 = (v21 | 0x38800000 | (v20 << v22)) - (v22 << 23);
      if (!v20) {
        int v23 = v21;
      }
      int v24 = v20 | v21;
      int v25 = v24 | 0x7F800000;
      LODWORD(v26) = v24 + 939524096;
      if (v20 >> 23 > 0x1E) {
        float v26 = *(float *)&v25;
      }
      if (v20 < 0x800000) {
        float v26 = *(float *)&v23;
      }
      if (vabds_f32(v17, v26) >= a3) {
        break;
      }
      BOOL v6 = ++v7 >= v8;
    }
    while (v9 != v7);
  }
  return v6;
}

uint64_t sub_216782014(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - v2;
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = v3 >> 1;
    if ((unint64_t)(v3 >> 1) <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = v3 >> 1;
    }
    BOOL v7 = 1;
    while (1)
    {
      int v8 = *(__int16 *)(v2 + 2 * v4);
      unsigned int v9 = (v8 & 0x7FFF) << 13;
      unsigned int v10 = v8 & 0x80000000;
      unsigned int v11 = v9 >> 23;
      if (v9 < 0x800000)
      {
        unsigned int v31 = __clz(v9) - 8;
        int v12 = (v10 | 0x38800000 | (v9 << v31)) - (v31 << 23);
        if (!v9) {
          int v12 = v10;
        }
      }
      else
      {
        int v12 = (v9 | v10) + 939524096;
        if (v11 > 0x1E) {
          int v12 = v9 | v10 | 0x7F800000;
        }
      }
      float v13 = *(float *)&v12;
      int v14 = *(__int16 *)(a2 + 2 * v4);
      unsigned int v15 = (v14 & 0x7FFF) << 13;
      unsigned int v16 = v14 & 0x80000000;
      unsigned int v17 = __clz(v15) - 8;
      int v18 = (v16 | 0x38800000 | (v15 << v17)) - (v17 << 23);
      if (v15) {
        float v19 = *(float *)&v18;
      }
      else {
        float v19 = *(float *)&v16;
      }
      if (v15 >> 23 <= 0x1E) {
        int v20 = (v15 | v16) + 939524096;
      }
      else {
        int v20 = v15 | v16 | 0x7F800000;
      }
      if (v15 >= 0x800000) {
        float v19 = *(float *)&v20;
      }
      if (v13 < v19)
      {
        LOBYTE(v29) = 1;
        goto LABEL_42;
      }
      unsigned int v21 = __clz(v9) - 8;
      int v22 = (v10 | 0x38800000 | (v9 << v21)) - (v21 << 23);
      if (!v9) {
        int v22 = v10;
      }
      int v23 = v9 | v10;
      BOOL v24 = v11 > 0x1E;
      int v25 = v23 | 0x7F800000;
      int v26 = v23 + 939524096;
      if (v24) {
        int v26 = v25;
      }
      float v27 = v9 >= 0x800000 ? *(float *)&v26 : *(float *)&v22;
      float v28 = v27;
      float v29 = v15 ? *(float *)&v18 : *(float *)&v16;
      int v30 = v15 >> 23 <= 0x1E ? (v15 | v16) + 939524096 : v15 | v16 | 0x7F800000;
      if (v15 >= 0x800000) {
        float v29 = *(float *)&v30;
      }
      if (v28 > v29) {
        break;
      }
      BOOL v7 = ++v4 < v5;
      if (v6 == v4) {
        goto LABEL_42;
      }
    }
    LOBYTE(v29) = 0;
LABEL_42:
    char v32 = v7 & LOBYTE(v29);
  }
  else
  {
    char v32 = 0;
  }
  return v32 & 1;
}

uint64_t sub_21678218C(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_216782194(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216780E30(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_2167821F0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_21678220C(void *a1)
{
  *a1 = &unk_26C747B70;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_21678225C(void *__p)
{
  *long long __p = &unk_26C747B70;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_2167822BC(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 4 * v4);
  }
}

float sub_2167822E0(uint64_t a1, float *a2)
{
  uint64_t v2 = *(float **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      float v5 = *a2++;
      float result = v5;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_21678230C(uint64_t a1, float *a2)
{
  uint64_t v2 = *(float **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 2;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v7 = 1;
  do
  {
    unint64_t v8 = v7;
    if (v5 == v7) {
      break;
    }
    float v9 = v2[v7];
    float v10 = a2[v7++];
  }
  while (v9 == v10);
  return v8 >= v4;
}

BOOL sub_216782374(uint64_t a1, float *a2, double a3)
{
  uint64_t v3 = *(float **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16) - (void)v3;
  if (!v4) {
    return 1;
  }
  unint64_t v5 = v4 >> 2;
  if (v5 <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = v5;
  }
  if (vabds_f32(*v3, *a2) >= a3) {
    return 0;
  }
  uint64_t v7 = 1;
  do
  {
    unint64_t v8 = v7;
    if (v6 == v7) {
      break;
    }
    double v9 = vabds_f32(v3[v7], a2[v7]);
    ++v7;
  }
  while (v9 < a3);
  return v8 >= v5;
}

uint64_t sub_2167823EC(uint64_t a1, float *a2)
{
  uint64_t v2 = *(float **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 2;
    if ((unint64_t)(v3 >> 2) <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v3 >> 2;
    }
    float v6 = *v2;
    float v7 = *a2;
    if (*v2 >= *a2)
    {
      unint64_t v9 = 1;
      BOOL v10 = 1;
      while (v6 <= v7)
      {
        BOOL v10 = v9 < v4;
        if (v5 == v9) {
          goto LABEL_14;
        }
        float v6 = v2[v9];
        float v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v8 = v10 & v2;
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_216782474(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_21678247C(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216781458(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_2167824D8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_2167824F4(void *a1)
{
  *a1 = &unk_26C747BD8;
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

void sub_216782544(void *__p)
{
  *long long __p = &unk_26C747BD8;
  uint64_t v2 = (void *)__p[1];
  if (v2)
  {
    __p[2] = v2;
    operator delete(v2);
  }

  operator delete(__p);
}

void sub_2167825A4(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 8) - (void)v1;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    bzero(v1, 8 * v4);
  }
}

double sub_2167825C8(uint64_t a1, double *a2)
{
  uint64_t v2 = *(double **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    do
    {
      double v5 = *a2++;
      double result = v5;
      *v2++ = v5;
      --v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_2167825F4(uint64_t a1, double *a2)
{
  uint64_t v2 = *(double **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (!v3) {
    return 1;
  }
  unint64_t v4 = v3 >> 3;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = v4;
  }
  if (*v2 != *a2) {
    return 0;
  }
  uint64_t v7 = 1;
  do
  {
    unint64_t v8 = v7;
    if (v5 == v7) {
      break;
    }
    double v9 = v2[v7];
    double v10 = a2[v7++];
  }
  while (v9 == v10);
  return v8 >= v4;
}

BOOL sub_21678265C(uint64_t a1, double *a2, double a3)
{
  uint64_t v3 = *(double **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16) - (void)v3;
  if (!v4) {
    return 1;
  }
  unint64_t v5 = v4 >> 3;
  if (v5 <= 1) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = v5;
  }
  if (vabdd_f64(*v3, *a2) >= a3) {
    return 0;
  }
  uint64_t v7 = 1;
  do
  {
    unint64_t v8 = v7;
    if (v6 == v7) {
      break;
    }
    double v9 = vabdd_f64(v3[v7], a2[v7]);
    ++v7;
  }
  while (v9 < a3);
  return v8 >= v5;
}

uint64_t sub_2167826CC(uint64_t a1, double *a2)
{
  uint64_t v2 = *(double **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if ((unint64_t)(v3 >> 3) <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v3 >> 3;
    }
    double v6 = *v2;
    double v7 = *a2;
    if (*v2 >= *a2)
    {
      unint64_t v9 = 1;
      BOOL v10 = 1;
      while (v6 <= v7)
      {
        BOOL v10 = v9 < v4;
        if (v5 == v9) {
          goto LABEL_14;
        }
        double v6 = v2[v9];
        double v7 = a2[v9++];
        if (v6 < v7)
        {
          LOBYTE(v2) = 1;
          goto LABEL_14;
        }
      }
      LOBYTE(v2) = 0;
LABEL_14:
      char v8 = v10 & v2;
    }
    else
    {
      char v8 = 1;
    }
  }
  else
  {
    char v8 = 0;
  }
  return v8 & 1;
}

uint64_t sub_216782754(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_21678275C(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_21677CACC(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_2167827B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_2167827D4(void *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  *a1 = &unk_26C747C40;
  unint64_t v4 = a1 + 1;
  sub_216782DE0(a1 + 1, a2);
  if (v2)
  {
    uint64_t v5 = 0;
    do
    {
      sub_216779094(&v9, "");
      uint64_t v6 = *v4 + v5;
      if (*(char *)(v6 + 23) < 0) {
        operator delete(*(void **)v6);
      }
      long long v7 = v9;
      *(void *)(v6 + 16) = v10;
      *(_OWORD *)uint64_t v6 = v7;
      v5 += 24;
      --v2;
    }
    while (v2);
  }
  return a1;
}

void sub_21678288C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216782F20((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_2167828A4(uint64_t a1)
{
  *(void *)a1 = &unk_26C747C40;
  uint64_t v3 = (void **)(a1 + 8);
  sub_216782F20(&v3);
  return a1;
}

void sub_2167828FC(char *a1)
{
  *(void *)a1 = &unk_26C747C40;
  unint64_t v2 = (void **)(a1 + 8);
  sub_216782F20(&v2);
  operator delete(a1);
}

__n128 sub_216782958(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16) - *(void *)(a1 + 8);
  if (v1)
  {
    uint64_t v3 = 0;
    unint64_t v4 = v1 / 24;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    do
    {
      sub_216779094(&v8, "");
      uint64_t v6 = *(void *)(a1 + 8) + v3;
      if (*(char *)(v6 + 23) < 0) {
        operator delete(*(void **)v6);
      }
      __n128 result = v8;
      *(void *)(v6 + 16) = v9;
      *(__n128 *)uint64_t v6 = result;
      v3 += 24;
      --v5;
    }
    while (v5);
  }
  return result;
}

std::string *sub_216782A08(std::string *result, uint64_t a2)
{
  int64_t v2 = result->__r_.__value_.__r.__words[2] - result->__r_.__value_.__l.__size_;
  if (v2)
  {
    unint64_t v4 = result;
    uint64_t v5 = 0;
    unint64_t v6 = v2 / 24;
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v6;
    }
    do
    {
      __n128 result = std::string::operator=((std::string *)(v4->__r_.__value_.__l.__size_ + v5), (const std::string *)(a2 + v5));
      v5 += 24;
      --v7;
    }
    while (v7);
  }
  return result;
}

BOOL sub_216782A80(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - v2;
  if (v3)
  {
    BOOL v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = (unsigned __int128)(v3 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    unint64_t v8 = (v7 >> 2) + ((unint64_t)v7 >> 63);
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = (v7 >> 2) + ((unint64_t)v7 >> 63);
    }
    do
    {
      uint64_t v10 = (unsigned __int8 *)(v2 + 24 * v6);
      unsigned int v11 = (unsigned __int8 **)(a2 + 24 * v6);
      uint64_t v12 = v10[23];
      if ((v12 & 0x80u) == 0) {
        float v13 = (unsigned __int8 *)v10[23];
      }
      else {
        float v13 = (unsigned __int8 *)*((void *)v10 + 1);
      }
      int v14 = (unsigned __int8 *)*((unsigned __int8 *)v11 + 23);
      int v15 = (char)v14;
      if ((char)v14 < 0) {
        int v14 = v11[1];
      }
      if (v13 != v14) {
        break;
      }
      if (v15 >= 0) {
        unsigned int v16 = (unsigned __int8 *)(a2 + 24 * v6);
      }
      else {
        unsigned int v16 = *v11;
      }
      if ((v12 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v10, v16, *((void *)v10 + 1))) {
          return v5;
        }
      }
      else if (v10[23])
      {
        while (*v10 == *v16)
        {
          ++v10;
          ++v16;
          if (!--v12) {
            goto LABEL_20;
          }
        }
        return v5;
      }
LABEL_20:
      BOOL v5 = ++v6 >= v8;
    }
    while (v6 != v9);
  }
  else
  {
    return 1;
  }
  return v5;
}

BOOL sub_216782B84(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - v2;
  if (v3)
  {
    BOOL v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = (unsigned __int128)(v3 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    unint64_t v8 = (v7 >> 2) + ((unint64_t)v7 >> 63);
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = (v7 >> 2) + ((unint64_t)v7 >> 63);
    }
    do
    {
      uint64_t v10 = (unsigned __int8 *)(v2 + 24 * v6);
      unsigned int v11 = (unsigned __int8 **)(a2 + 24 * v6);
      uint64_t v12 = v10[23];
      if ((v12 & 0x80u) == 0) {
        float v13 = (unsigned __int8 *)v10[23];
      }
      else {
        float v13 = (unsigned __int8 *)*((void *)v10 + 1);
      }
      int v14 = (unsigned __int8 *)*((unsigned __int8 *)v11 + 23);
      int v15 = (char)v14;
      if ((char)v14 < 0) {
        int v14 = v11[1];
      }
      if (v13 != v14) {
        break;
      }
      if (v15 >= 0) {
        unsigned int v16 = (unsigned __int8 *)(a2 + 24 * v6);
      }
      else {
        unsigned int v16 = *v11;
      }
      if ((v12 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v10, v16, *((void *)v10 + 1))) {
          return v5;
        }
      }
      else if (v10[23])
      {
        while (*v10 == *v16)
        {
          ++v10;
          ++v16;
          if (!--v12) {
            goto LABEL_20;
          }
        }
        return v5;
      }
LABEL_20:
      BOOL v5 = ++v6 >= v8;
    }
    while (v6 != v9);
  }
  else
  {
    return 1;
  }
  return v5;
}

uint64_t sub_216782C88(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16) - v2;
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    uint64_t v6 = (unsigned __int128)(v3 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    unint64_t v7 = (v6 >> 2) + ((unint64_t)v6 >> 63);
    if (v7 <= 1) {
      uint64_t v8 = 1;
    }
    else {
      uint64_t v8 = (v6 >> 2) + ((unint64_t)v6 >> 63);
    }
    uint64_t v21 = v8;
    BOOL v9 = 1;
    while (1)
    {
      int v10 = *(char *)(a2 + v4 + 23);
      int v11 = *(char *)(v2 + v4 + 23);
      if (v11 >= 0) {
        size_t v12 = *(unsigned __int8 *)(v2 + v4 + 23);
      }
      else {
        size_t v12 = *(void *)(v2 + v4 + 8);
      }
      if (v11 >= 0) {
        float v13 = (const void *)(v2 + v4);
      }
      else {
        float v13 = *(const void **)(v2 + v4);
      }
      if (v10 >= 0) {
        size_t v14 = *(unsigned __int8 *)(a2 + v4 + 23);
      }
      else {
        size_t v14 = *(void *)(a2 + v4 + 8);
      }
      if (v10 >= 0) {
        int v15 = (const void *)(a2 + v4);
      }
      else {
        int v15 = *(const void **)(a2 + v4);
      }
      if (v14 >= v12) {
        size_t v16 = v12;
      }
      else {
        size_t v16 = v14;
      }
      int v17 = memcmp(v13, v15, v16);
      BOOL v18 = v12 < v14;
      if (v17) {
        BOOL v18 = v17 < 0;
      }
      if (v18)
      {
        LOBYTE(v3) = 1;
        goto LABEL_31;
      }
      int v19 = memcmp(v15, v13, v16);
      LODWORD(v3) = v14 < v12;
      if (v19) {
        LODWORD(v3) = v19 < 0;
      }
      if (v3 == 1) {
        break;
      }
      BOOL v9 = ++v5 < v7;
      v4 += 24;
      if (v21 == v5) {
        goto LABEL_31;
      }
    }
    LOBYTE(v3) = 0;
LABEL_31:
    LOBYTE(v3) = v9 & v3;
  }
  return v3 & 1;
}

uint64_t sub_216782DD8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_216782DE0(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216782E84(a1, a2);
    uint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_216782E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *sub_216782E84(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_21677CB10();
  }
  __n128 result = (char *)sub_216782ED8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *sub_216782ED8(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_21677CA1C();
  }
  return operator new(24 * a2);
}

void sub_216782F20(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_216782F74((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_216782F74(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void *sub_216782FC4(void *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  *a1 = &unk_26C747CA8;
  uint64_t v4 = a1 + 1;
  sub_2167836C0(a1 + 1, a2);
  if (v2)
  {
    uint64_t v5 = 0;
    do
    {
      sub_216783764((uint64_t)&v9, &dword_21740775C);
      uint64_t v6 = *v4 + v5;
      if (*(char *)(v6 + 23) < 0) {
        operator delete(*(void **)v6);
      }
      long long v7 = v9;
      *(void *)(v6 + 16) = v10;
      *(_OWORD *)uint64_t v6 = v7;
      v5 += 24;
      --v2;
    }
    while (v2);
  }
  return a1;
}

void sub_21678307C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216782F20((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_216783094(uint64_t a1)
{
  *(void *)a1 = &unk_26C747CA8;
  uint64_t v3 = (void **)(a1 + 8);
  sub_216782F20(&v3);
  return a1;
}

void sub_2167830EC(char *a1)
{
  *(void *)a1 = &unk_26C747CA8;
  unint64_t v2 = (void **)(a1 + 8);
  sub_216782F20(&v2);
  operator delete(a1);
}

__n128 sub_216783148(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16) - *(void *)(a1 + 8);
  if (v1)
  {
    uint64_t v3 = 0;
    unint64_t v4 = v1 / 24;
    if (v4 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v4;
    }
    do
    {
      sub_216783764((uint64_t)&v8, &dword_21740775C);
      uint64_t v6 = *(void *)(a1 + 8) + v3;
      if (*(char *)(v6 + 23) < 0) {
        operator delete(*(void **)v6);
      }
      __n128 result = v8;
      *(void *)(v6 + 16) = v9;
      *(__n128 *)uint64_t v6 = result;
      v3 += 24;
      --v5;
    }
    while (v5);
  }
  return result;
}

std::wstring *sub_2167831F8(std::wstring *result, uint64_t a2)
{
  int64_t v2 = result->__r_.__value_.__r.__words[2] - result->__r_.__value_.__l.__size_;
  if (v2)
  {
    unint64_t v4 = result;
    uint64_t v5 = 0;
    unint64_t v6 = v2 / 24;
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = v6;
    }
    do
    {
      __n128 result = std::wstring::operator=((std::wstring *)(v4->__r_.__value_.__l.__size_ + v5), (const std::wstring *)(a2 + v5));
      v5 += 24;
      --v7;
    }
    while (v7);
  }
  return result;
}

BOOL sub_216783270(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16) - *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = (unsigned __int128)(v2 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    unint64_t v6 = (v5 >> 2) + ((unint64_t)v5 >> 63);
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = (v5 >> 2) + ((unint64_t)v5 >> 63);
    }
    uint64_t v8 = *(void *)(a1 + 8);
    BOOL v9 = *(char *)(v8 + 23) < 0;
    if (*(char *)(v8 + 23) >= 0) {
      size_t v10 = *(unsigned __int8 *)(v8 + 23);
    }
    else {
      size_t v10 = *(void *)(v8 + 8);
    }
    BOOL v11 = *(char *)(a2 + 23) < 0;
    uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
    if ((v12 & 0x80u) != 0) {
      uint64_t v12 = *(void *)(a2 + 8);
    }
    if (v10 == v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      BOOL v15 = 0;
      unint64_t v16 = 1;
      do
      {
        if (v10)
        {
          int v17 = v11 ? *(const __int32 **)(a2 + v13) : (const __int32 *)(a2 + v13);
          BOOL v18 = v9 ? *(const __int32 **)v8 : (const __int32 *)v8;
          if (wmemcmp(v18, v17, v10)) {
            break;
          }
        }
        BOOL v15 = v16 >= v6;
        if (v7 == v16) {
          break;
        }
        ++v14;
        uint64_t v19 = *(void *)(a1 + 8);
        uint64_t v8 = v19 + 24 * v14;
        uint64_t v20 = v19 + v13;
        int v21 = *(char *)(v19 + v13 + 47);
        BOOL v9 = v21 < 0;
        uint64_t v22 = *(void *)(v20 + 32);
        size_t v10 = v21 >= 0 ? v21 : v22;
        BOOL v11 = *(char *)(a2 + v13 + 47) < 0;
        uint64_t v23 = *(void *)(a2 + v13 + 32);
        if (*(char *)(a2 + v13 + 47) >= 0) {
          uint64_t v23 = *(unsigned __int8 *)(a2 + v13 + 47);
        }
        v13 += 24;
        ++v16;
      }
      while (v10 == v23);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
  return v15;
}

BOOL sub_2167833D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16) - *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = (unsigned __int128)(v2 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    unint64_t v6 = (v5 >> 2) + ((unint64_t)v5 >> 63);
    if (v6 <= 1) {
      uint64_t v7 = 1;
    }
    else {
      uint64_t v7 = (v5 >> 2) + ((unint64_t)v5 >> 63);
    }
    uint64_t v8 = *(void *)(a1 + 8);
    BOOL v9 = *(char *)(v8 + 23) < 0;
    if (*(char *)(v8 + 23) >= 0) {
      size_t v10 = *(unsigned __int8 *)(v8 + 23);
    }
    else {
      size_t v10 = *(void *)(v8 + 8);
    }
    BOOL v11 = *(char *)(a2 + 23) < 0;
    uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
    if ((v12 & 0x80u) != 0) {
      uint64_t v12 = *(void *)(a2 + 8);
    }
    if (v10 == v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      BOOL v15 = 0;
      unint64_t v16 = 1;
      do
      {
        if (v10)
        {
          int v17 = v11 ? *(const __int32 **)(a2 + v13) : (const __int32 *)(a2 + v13);
          BOOL v18 = v9 ? *(const __int32 **)v8 : (const __int32 *)v8;
          if (wmemcmp(v18, v17, v10)) {
            break;
          }
        }
        BOOL v15 = v16 >= v6;
        if (v7 == v16) {
          break;
        }
        ++v14;
        uint64_t v19 = *(void *)(a1 + 8);
        uint64_t v8 = v19 + 24 * v14;
        uint64_t v20 = v19 + v13;
        int v21 = *(char *)(v19 + v13 + 47);
        BOOL v9 = v21 < 0;
        uint64_t v22 = *(void *)(v20 + 32);
        size_t v10 = v21 >= 0 ? v21 : v22;
        BOOL v11 = *(char *)(a2 + v13 + 47) < 0;
        uint64_t v23 = *(void *)(a2 + v13 + 32);
        if (*(char *)(a2 + v13 + 47) >= 0) {
          uint64_t v23 = *(unsigned __int8 *)(a2 + v13 + 47);
        }
        v13 += 24;
        ++v16;
      }
      while (v10 == v23);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
  return v15;
}

uint64_t sub_216783530(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16) - *(void *)(a1 + 8);
  if (!v2) {
    return v2 & 1;
  }
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = (unsigned __int128)(v2 * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
  unint64_t v8 = (v7 >> 2) + ((unint64_t)v7 >> 63);
  if (v8 <= 1) {
    uint64_t v9 = 1;
  }
  else {
    uint64_t v9 = (v7 >> 2) + ((unint64_t)v7 >> 63);
  }
  BOOL v10 = 1;
  while (1)
  {
    uint64_t v11 = *(void *)(a1 + 8) + v5;
    uint64_t v12 = a2 + v5;
    int v13 = *(char *)(a2 + v5 + 23);
    unint64_t v14 = v13 >= 0 ? *(unsigned __int8 *)(a2 + v5 + 23) : *(void *)(a2 + v5 + 8);
    int v15 = *(char *)(v11 + 23);
    unint64_t v16 = v15 >= 0 ? *(unsigned __int8 *)(v11 + 23) : *(void *)(v11 + 8);
    size_t v17 = v14 >= v16 ? v16 : v14;
    if (v17
      && (v15 >= 0 ? (BOOL v18 = (const __int32 *)(*(void *)(a1 + 8) + v5)) : (BOOL v18 = *(const __int32 **)v11),
          v13 >= 0 ? (uint64_t v19 = (const __int32 *)(a2 + v5)) : (uint64_t v19 = *(const __int32 **)v12),
          (int v20 = wmemcmp(v18, v19, v17)) != 0))
    {
      if (v20 < 0) {
        goto LABEL_48;
      }
    }
    else if (v16 < v14)
    {
LABEL_48:
      LOBYTE(v2) = 1;
      goto LABEL_50;
    }
    uint64_t v2 = *(void *)(a1 + 8) + v5;
    int v21 = *(char *)(v2 + 23);
    unint64_t v22 = v21 >= 0 ? *(unsigned __int8 *)(v2 + 23) : *(void *)(v2 + 8);
    int v23 = *(char *)(v12 + 23);
    unint64_t v24 = v23 >= 0 ? *(unsigned __int8 *)(v12 + 23) : *(void *)(v12 + 8);
    size_t v25 = v22 >= v24 ? v24 : v22;
    if (!v25) {
      break;
    }
    int v26 = v23 >= 0 ? (const __int32 *)(a2 + v5) : *(const __int32 **)v12;
    float v27 = v21 >= 0 ? (const __int32 *)(*(void *)(a1 + 8) + v5) : *(const __int32 **)v2;
    int v28 = wmemcmp(v26, v27, v25);
    if (!v28) {
      break;
    }
    if (v28 < 0) {
      goto LABEL_49;
    }
LABEL_46:
    BOOL v10 = ++v6 < v8;
    v5 += 24;
    if (v9 == v6) {
      goto LABEL_50;
    }
  }
  if (v24 >= v22) {
    goto LABEL_46;
  }
LABEL_49:
  LOBYTE(v2) = 0;
LABEL_50:
  LOBYTE(v2) = v10 & v2;
  return v2 & 1;
}

uint64_t sub_2167836B8(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *sub_2167836C0(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216782E84(a1, a2);
    unint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_216783750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_216783764(uint64_t a1, __int32 *a2)
{
  size_t v4 = wcslen(a2);
  if (v4 >= 0x3FFFFFFFFFFFFFF8) {
    sub_216778FC4();
  }
  size_t v5 = v4;
  if (v4 >= 5)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFFELL) + 2;
    if ((v4 | 1) != 5) {
      uint64_t v7 = v4 | 1;
    }
    uint64_t v6 = sub_21677EA28(a1, v7 + 1);
    *(void *)(a1 + 8) = v5;
    *(void *)(a1 + 16) = v8 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(unsigned char *)(a1 + 23) = v4;
    uint64_t v6 = (void *)a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, a2, 4 * v5);
LABEL_9:
  *((_DWORD *)v6 + v5) = 0;
  return a1;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyWriter::asScalarPtr(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyWriter::asArrayPtr(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyWriter::asCompoundPtr(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::getProperty(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *this)
{
  uint64_t v2 = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *))(*(void *)this + 72))(this);
  uint64_t v3 = *(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *, uint64_t))(*(void *)this
                                                                                                  + 88);

  return v3(this, v2);
}

uint64_t Alembic::AbcCoreAbstract::v12::ObjectWriter::getChild(Alembic::AbcCoreAbstract::v12::ObjectWriter *this)
{
  uint64_t v2 = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::ObjectWriter *))(*(void *)this + 56))(this);
  uint64_t v3 = *(uint64_t (**)(Alembic::AbcCoreAbstract::v12::ObjectWriter *, uint64_t))(*(void *)this + 72);

  return v3(this, v2);
}

void Alembic::AbcCoreAbstract::v12::BasePropertyReader::asScalarPtr(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyReader::asArrayPtr(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void Alembic::AbcCoreAbstract::v12::BasePropertyReader::asCompoundPtr(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

double Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getProperty@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 80))(a1);
  if (v4)
  {
    int v6 = *(_DWORD *)(v4 + 24);
    if (v6)
    {
      if (v6 == 2) {
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 96))(&v7, a1, v4);
      }
      else {
        (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 88))(&v7, a1, v4);
      }
    }
    else
    {
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 104))(&v7, a1, v4);
    }
    double result = *(double *)&v7;
    *(_OWORD *)a2 = v7;
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getScalarProperty@<X0>(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *))(*(void *)this + 72))(this);
  if (*(_DWORD *)(result + 24) == 1)
  {
    size_t v5 = *(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(void *)this + 88);
    return v5(this, result);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getArrayProperty@<X0>(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *))(*(void *)this + 72))(this);
  if (*(_DWORD *)(result + 24) == 2)
  {
    size_t v5 = *(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(void *)this + 96);
    return v5(this, result);
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getCompoundProperty@<X0>(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *))(*(void *)this + 72))(this);
  if (*(_DWORD *)(result + 24))
  {
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    size_t v5 = *(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(void *)this + 104);
    return v5(this, result);
  }
  return result;
}

double Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::getProperty@<D0>(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this@<X0>, _OWORD *a2@<X8>)
{
  uint64_t v4 = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *))(*(void *)this + 72))(this);
  int v5 = *(_DWORD *)(v4 + 24);
  if (v5)
  {
    if (v5 == 2) {
      (*(void (**)(long long *__return_ptr, Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(void *)this + 96))(&v7, this, v4);
    }
    else {
      (*(void (**)(long long *__return_ptr, Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(void *)this + 88))(&v7, this, v4);
    }
  }
  else
  {
    (*(void (**)(long long *__return_ptr, Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *, uint64_t))(*(void *)this + 104))(&v7, this, v4);
  }
  double result = *(double *)&v7;
  *a2 = v7;
  return result;
}

uint64_t Alembic::AbcCoreAbstract::v12::ObjectReader::getPropertiesHash()
{
  return 0;
}

uint64_t Alembic::AbcCoreAbstract::v12::ObjectReader::getChildrenHash()
{
  return 0;
}

void *sub_216783DC0(void *result, void *a2, void *a3, void *a4)
{
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_26C748400;
  result[3] = *a2;
  uint64_t v4 = a2[1];
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  result[5] = *a3;
  uint64_t v5 = a3[1];
  result[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  result[7] = *a4;
  uint64_t v6 = a4[1];
  result[8] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  if (!result[3])
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v9 = sub_216779038(exception, (uint64_t)v18);
    __cxa_throw(v9, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!result[5])
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Invalid array property group", 28);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    BOOL v10 = __cxa_allocate_exception(0x20uLL);
    uint64_t v11 = sub_216779038(v10, (uint64_t)v18);
    __cxa_throw(v11, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v7 = result[7];
  if (!v7)
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v12 = __cxa_allocate_exception(0x20uLL);
    int v13 = sub_216779038(v12, (uint64_t)v18);
    __cxa_throw(v13, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*(_DWORD *)(v7 + 24) != 2)
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Attempted to create a ArrayPropertyReader from a non-array property type", 72);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v14 = __cxa_allocate_exception(0x20uLL);
    int v15 = sub_216779038(v14, (uint64_t)v18);
    __cxa_throw(v15, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_216784088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v10.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 8);
  if (v6) {
    sub_216784EC4(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)v4 + 6);
  if (v7) {
    sub_216784EC4(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)v4 + 4);
  if (v8) {
    sub_216784EC4(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)v4 + 2);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  Alembic::AbcCoreAbstract::v12::ArrayPropertyReader::~ArrayPropertyReader(v4);
  _Unwind_Resume(a1);
}

uint64_t sub_216784124(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_21678412C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 24))();
}

uint64_t sub_216784154@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *a2 = *(void *)(result + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

double sub_216784170@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_2167841AC(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 56) + 84);
}

BOOL sub_2167841B8(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 56) + 88) == 0;
}

void sub_2167841CC(uint64_t a1, unint64_t a2, uint64_t **a3)
{
  uint64_t v5 = sub_21678444C(*(unsigned int **)(a1 + 56), a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 24))(&v15, a1);
  (*(void (**)(void **__return_ptr))(*(void *)v15 + 24))(&lpsrc);
  uint64_t v6 = lpsrc;
  if (lpsrc
  {
    uint64_t v7 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  sub_216787674((uint64_t)v6, &v19);
  if (v7) {
    sub_216784EC4(v7);
  }
  if (v18) {
    sub_216784EC4(v18);
  }
  unint64_t v8 = 2 * v5;
  if (v16) {
    sub_216784EC4(v16);
  }
  unint64_t v9 = *(void *)(v19 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v8 | 1, v9, &lpsrc);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v8, v9, &v15);
  if (lpsrc)
  {
    uint64_t v10 = v15;
    if (v15)
    {
      uint64_t v13 = lpsrc;
      uint64_t v14 = v18;
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v11 = v10;
      uint64_t v12 = v16;
      if (v16) {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_216798608((uint64_t)&v13, (uint64_t)&v11, v9, (int *)(*(void *)(a1 + 56) + 56), a3);
      if (v12) {
        sub_216784EC4(v12);
      }
      if (v14) {
        sub_216784EC4(v14);
      }
    }
  }
  if (v16) {
    sub_216784EC4(v16);
  }
  if (v18) {
    sub_216784EC4(v18);
  }
  if (v20) {
    sub_216784EC4(v20);
  }
}

void sub_2167843C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  if (a12) {
    sub_216784EC4(a12);
  }
  if (a14) {
    sub_216784EC4(a14);
  }
  if (a16) {
    sub_216784EC4(a16);
  }
  BOOL v18 = *(std::__shared_weak_count **)(v16 - 40);
  if (v18) {
    sub_216784EC4(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678441C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (v16) {
    sub_216784EC4(v16);
  }
  if (a16) {
    sub_216784EC4(a16);
  }
  if (!a14) {
    JUMPOUT(0x216784414);
  }
  JUMPOUT(0x216784410);
}

uint64_t sub_21678444C(unsigned int *a1, unint64_t a2)
{
  if ((a2 & 0x8000000000000000) != 0 || a1[21] <= a2)
  {
    sub_216778A5C((uint64_t)v14);
    sub_216779180(v15, (uint64_t)"Invalid sample index: ", 22);
    unint64_t v8 = (void *)std::ostream::operator<<();
    sub_216779180(v8, (uint64_t)", should be between 0 and ", 26);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v13, &__p);
    if (v12 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v10 = sub_216779038(exception, (uint64_t)v13);
    __cxa_throw(v10, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  unsigned int v2 = a1[22];
  if (v2 <= a2)
  {
    unsigned int v4 = a1[23];
    int v5 = v4 | v2;
    int v6 = a2 - v2;
    unsigned int v3 = v4 - v2 + 1;
    if (v4 > a2) {
      unsigned int v3 = v6 + 1;
    }
    if (!v5) {
      return 0;
    }
  }
  else
  {
    return 0;
  }
  return v3;
}

void sub_216784570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_216784598(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  unsigned int v4 = *(double ***)(v3 + 64);
  int v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void *)(a1 + 56);
  }
  uint64_t FloorIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5) {
    sub_216784EC4(v5);
  }
  return FloorIndex;
}

void sub_216784600(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216784618(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  unsigned int v4 = *(double ***)(v3 + 64);
  int v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void *)(a1 + 56);
  }
  uint64_t CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getCeilIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5) {
    sub_216784EC4(v5);
  }
  return CeilIndex;
}

void sub_216784680(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216784698(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  unsigned int v4 = *(double ***)(v3 + 64);
  int v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void *)(a1 + 56);
  }
  uint64_t v6 = Alembic::AbcCoreAbstract::v12::TimeSampling::getNearIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5) {
    sub_216784EC4(v5);
  }
  return v6;
}

void sub_216784700(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_216784718(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v5 = *(unsigned int **)(a1 + 56);
  unsigned int v6 = v5[14];
  *(_DWORD *)(a3 + 8) = v6;
  *(_DWORD *)(a3 + 12) = v6;
  *(void *)a3 = 0;
  uint64_t v7 = sub_21678444C(v5, a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 24))(&v14, a1);
  (*(void (**)(void **__return_ptr))(*(void *)v14 + 24))(&lpsrc);
  unint64_t v8 = lpsrc;
  if (lpsrc
  {
    uint64_t v9 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  sub_216787674((uint64_t)v8, &v18);
  if (v9) {
    sub_216784EC4(v9);
  }
  unint64_t v10 = 2 * v7;
  if (v17) {
    sub_216784EC4(v17);
  }
  if (v15) {
    sub_216784EC4(v15);
  }
  unint64_t v11 = *(void *)(v18 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v10, v11, &lpsrc);
  char v12 = lpsrc;
  if (lpsrc && (unint64_t)Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)lpsrc) >= 0x10)
  {
    *(void *)a3 = Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)lpsrc) - 16;
    Alembic::Ogawa::v12::IData::read((unint64_t **)lpsrc, 16, (void *)(a3 + 16), 0, v11);
  }
  if (v17) {
    sub_216784EC4(v17);
  }
  if (v19) {
    sub_216784EC4(v19);
  }
  return v12 != 0;
}

void sub_2167848D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_21678492C(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 56) + 80);
}

void sub_216784938(uint64_t a1, unint64_t a2, void **a3)
{
  uint64_t v5 = sub_21678444C(*(unsigned int **)(a1 + 56), a2);
  (*(void (**)(Alembic::Ogawa::v12::IData **__return_ptr, uint64_t))(*(void *)a1 + 24))(&v14, a1);
  (*(void (**)(void **__return_ptr))(*(void *)v14 + 24))(&lpsrc);
  unsigned int v6 = lpsrc;
  if (lpsrc
  {
    uint64_t v7 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  sub_216787674((uint64_t)v6, &v18);
  if (v7) {
    sub_216784EC4(v7);
  }
  if (v17) {
    sub_216784EC4(v17);
  }
  unint64_t v8 = 2 * v5;
  if (v15) {
    sub_216784EC4(v15);
  }
  unint64_t v9 = *(void *)(v18 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v8 | 1, v9, &lpsrc);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v8, v9, &v14);
  char v12 = (Alembic::Ogawa::v12::IData *)lpsrc;
  uint64_t v13 = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v10 = v14;
  unint64_t v11 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216794F90(&v12, &v10, v9, (int *)(*(void *)(a1 + 56) + 56), a3);
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v13) {
    sub_216784EC4(v13);
  }
  if (v15) {
    sub_216784EC4(v15);
  }
  if (v17) {
    sub_216784EC4(v17);
  }
  if (v19) {
    sub_216784EC4(v19);
  }
}

void sub_216784B20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  if (a12) {
    sub_216784EC4(a12);
  }
  if (a14) {
    sub_216784EC4(a14);
  }
  if (a16) {
    sub_216784EC4(a16);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(v16 - 40);
  if (v18) {
    sub_216784EC4(v18);
  }
  _Unwind_Resume(exception_object);
}

void sub_216784B78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (v16) {
    sub_216784EC4(v16);
  }
  if (a16) {
    sub_216784EC4(a16);
  }
  if (!a14) {
    JUMPOUT(0x216784B70);
  }
  JUMPOUT(0x216784B6CLL);
}

void sub_216784BA8(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7 = sub_21678444C(*(unsigned int **)(a1 + 56), a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 24))(&v15, a1);
  (*(void (**)(void **__return_ptr))(*(void *)v15 + 24))(&lpsrc);
  unint64_t v8 = lpsrc;
  if (lpsrc
  {
    unint64_t v9 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    unint64_t v9 = 0;
  }
  sub_216787674((uint64_t)v8, &v19);
  if (v9) {
    sub_216784EC4(v9);
  }
  unint64_t v10 = 2 * v7;
  if (v18) {
    sub_216784EC4(v18);
  }
  if (v16) {
    sub_216784EC4(v16);
  }
  unint64_t v11 = *(void *)(v19 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v10, v11, &lpsrc);
  uint64_t v13 = (Alembic::Ogawa::v12::IData *)lpsrc;
  uint64_t v14 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216798190(a3, &v13, v11, (int *)(*(void *)(a1 + 56) + 56), a4, v12);
  if (v14) {
    sub_216784EC4(v14);
  }
  if (v18) {
    sub_216784EC4(v18);
  }
  if (v20) {
    sub_216784EC4(v20);
  }
}

void sub_216784D58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  if (a14) {
    sub_216784EC4(a14);
  }
  if (a16) {
    sub_216784EC4(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_216784D90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    sub_216784EC4(v14);
  }
  if (a14) {
    sub_216784EC4(a14);
  }
  if (!a12) {
    JUMPOUT(0x216784D88);
  }
  JUMPOUT(0x216784D84);
}

void sub_216784DC0(Alembic::AbcCoreAbstract::v12::ArrayPropertyReader *this)
{
  *(void *)this = &unk_26C748400;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    sub_216784EC4(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v3) {
    sub_216784EC4(v3);
  }
  unsigned int v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4) {
    sub_216784EC4(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  Alembic::AbcCoreAbstract::v12::ArrayPropertyReader::~ArrayPropertyReader(this);
}

void sub_216784E40(Alembic::AbcCoreAbstract::v12::ArrayPropertyReader *this)
{
  *(void *)this = &unk_26C748400;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    sub_216784EC4(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v3) {
    sub_216784EC4(v3);
  }
  unsigned int v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4) {
    sub_216784EC4(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  Alembic::AbcCoreAbstract::v12::ArrayPropertyReader::~ArrayPropertyReader(this);

  operator delete(v6);
}

void sub_216784EC4(std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void *sub_216784F38(void *a1, void *a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  *a1 = *a2;
  if (!v3)
  {
    a1[1] = 0;
LABEL_5:
    sub_216784F7C();
  }
  unsigned int v4 = std::__shared_weak_count::lock(v3);
  a1[1] = v4;
  if (!v4) {
    goto LABEL_5;
  }
  return a1;
}

void sub_216784F7C()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x263F8C2D8] + 16;
  __cxa_throw(exception, MEMORY[0x263F8C198], MEMORY[0x263F8C0A0]);
}

void *sub_216784FC8(void *a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C7484E8;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = *a2;
  uint64_t v7 = a2[1];
  a1[6] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  a1[7] = *a4;
  uint64_t v8 = a4[1];
  a1[8] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = *a3;
  uint64_t v9 = a3[1];
  a1[12] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  v23[0] = 1;
  sub_2167864B4(a1 + 13, 1uLL, v23);
  a1[16] = a5;
  if (!a1[5])
  {
    sub_216778A5C((uint64_t)v23);
    sub_216779180(v24, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v22, (long long *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v13 = sub_216779038(exception, (uint64_t)v22);
    __cxa_throw(v13, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v10 = a1[7];
  if (!v10)
  {
    sub_216778A5C((uint64_t)v23);
    sub_216779180(v24, (uint64_t)"Invalid property header", 23);
    std::stringbuf::str();
    sub_216778E70(v22, (long long *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v14 = __cxa_allocate_exception(0x20uLL);
    uint64_t v15 = sub_216779038(v14, (uint64_t)v22);
    __cxa_throw(v15, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!a1[11])
  {
    sub_216778A5C((uint64_t)v23);
    sub_216779180(v24, (uint64_t)"Invalid group", 13);
    std::stringbuf::str();
    sub_216778E70(v22, (long long *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v16 = __cxa_allocate_exception(0x20uLL);
    char v17 = sub_216779038(v16, (uint64_t)v22);
    __cxa_throw(v17, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*(_DWORD *)(v10 + 24) != 2)
  {
    sub_216778A5C((uint64_t)v23);
    sub_216779180(v24, (uint64_t)"Attempted to create a ArrayPropertyWriter from a non-array property type", 72);
    std::stringbuf::str();
    sub_216778E70(v22, (long long *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v18 = __cxa_allocate_exception(0x20uLL);
    uint64_t v19 = sub_216779038(v18, (uint64_t)v22);
    __cxa_throw(v19, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return a1;
}

void sub_2167852BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v13.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v7 = *v5;
  if (*v5)
  {
    *((void *)v4 + 14) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)v4 + 12);
  if (v8) {
    sub_216784EC4(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)v4 + 8);
  if (v9) {
    sub_216784EC4(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)v4 + 6);
  if (v10) {
    sub_216784EC4(v10);
  }
  unint64_t v11 = (std::__shared_weak_count *)*((void *)v4 + 4);
  if (v11) {
    sub_216784EC4(v11);
  }
  __n64 v12 = (std::__shared_weak_count *)*((void *)v4 + 2);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  Alembic::AbcCoreAbstract::v12::ArrayPropertyWriter::~ArrayPropertyWriter(v4);
  _Unwind_Resume(a1);
}

void sub_21678537C(uint64_t a1)
{
  *(void *)a1 = &unk_26C7484E8;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 24))(&v18);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v18 + 24))(&v20);
  if (v19) {
    sub_216784EC4(v19);
  }
  uint64_t v2 = (*(uint64_t (**)(uint64_t, void))(*(void *)v20 + 72))(v20, *(unsigned int *)(*(void *)(a1 + 56) + 96));
  uint64_t v3 = *(_DWORD **)(a1 + 56);
  unsigned int v4 = v3[21];
  if (v3[23]) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = v4 != 0;
  }
  if (v2 < v5) {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v20 + 80))(v20, v3[24], v5);
  }
  Alembic::Util::v12::SpookyHash::Init((uint64_t)&v18, 0, 0);
  sub_21679D428(*(void *)(a1 + 56), (Alembic::Util::v12::SpookyHash *)&v18);
  if (v5) {
    Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)&v18, (void *)(a1 + 72), 0x10uLL);
  }
  uint64_t v16 = 0;
  unint64_t v17 = 0;
  Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)&v18, &v17, (unint64_t *)&v16, v6, v7);
  uint64_t v8 = *(void **)(a1 + 40);
  if (v8
  {
    uint64_t v9 = *(std::__shared_weak_count **)(a1 + 48);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  sub_216790220((uint64_t)v8, *(void *)(a1 + 128), v17, v16);
  if (v9) {
    sub_216784EC4(v9);
  }
  if (v21) {
    sub_216784EC4(v21);
  }
  uint64_t v10 = *(void **)(a1 + 104);
  if (v10)
  {
    *(void *)(a1 + 112) = v10;
    operator delete(v10);
  }
  unint64_t v11 = *(std::__shared_weak_count **)(a1 + 96);
  if (v11) {
    sub_216784EC4(v11);
  }
  __n64 v12 = *(std::__shared_weak_count **)(a1 + 64);
  if (v12) {
    sub_216784EC4(v12);
  }
  std::exception v13 = *(std::__shared_weak_count **)(a1 + 48);
  if (v13) {
    sub_216784EC4(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 32);
  if (v14) {
    sub_216784EC4(v14);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 16);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  Alembic::AbcCoreAbstract::v12::ArrayPropertyWriter::~ArrayPropertyWriter((Alembic::AbcCoreAbstract::v12::ArrayPropertyWriter *)a1);
}

void sub_2167855DC(uint64_t a1)
{
  sub_21678537C(a1);

  operator delete(v1);
}

unsigned __int8 *sub_216785604(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(uint64_t **)(v2 + 64);
  unsigned int v4 = *(std::__shared_weak_count **)(v2 + 72);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *v3;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) != v5)
  {
    BOOL v9 = 0;
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v7 = *(std::__shared_weak_count **)(v6 + 72);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v9 = *(unsigned int *)(*(void *)(a1 + 56) + 84) >= (unint64_t)((uint64_t)(*(void *)(v8 + 24)
                                                                                      - *(void *)(v8 + 16)) >> 3);
    sub_216784EC4(v7);
    if (!v4) {
      goto LABEL_9;
    }
LABEL_8:
    sub_216784EC4(v4);
    goto LABEL_9;
  }
  BOOL v9 = *(unsigned int *)(v6 + 84) >= (unint64_t)((uint64_t)(*(void *)(v8 + 24) - *(void *)(v8 + 16)) >> 3);
  if (v4) {
    goto LABEL_8;
  }
LABEL_9:
  if (v9)
  {
    sub_216778A5C((uint64_t)&v29);
    sub_216779180(v30, (uint64_t)"Can not set more samples than we have times for when using Acyclic sampling.", 76);
    std::stringbuf::str();
    sub_216778E70(v28, (long long *)__p);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    int v23 = sub_216779038(exception, (uint64_t)v28);
    __cxa_throw(v23, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!*(_DWORD *)(*(void *)(a1 + 56) + 84))
  {
    sub_216778A5C((uint64_t)&v29);
    sub_216779180(v30, (uint64_t)"Can't set from previous sample before any samples have been written", 67);
    std::stringbuf::str();
    sub_216778E70(v28, (long long *)__p);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v24 = __cxa_allocate_exception(0x20uLL);
    size_t v25 = sub_216779038(v24, (uint64_t)v28);
    __cxa_throw(v25, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  long long v29 = *(_OWORD *)(*(void *)(a1 + 24) + 16);
  double result = sub_21679D854((unsigned __int8 *)(a1 + 104), (unint64_t *)&v29);
  uint64_t v11 = (*((void *)&v29 + 1) ^ v29) + __ROR8__(v29, 49);
  uint64_t v12 = (*(void *)(a1 + 72) ^ v11) + __ROR8__(v11, 12);
  uint64_t v13 = (*(void *)(a1 + 80) ^ v12) + __ROR8__(v12, 38);
  uint64_t v14 = (v13 ^ __ROR8__(v29, 49)) + __ROR8__(v13, 13);
  uint64_t v15 = (v14 ^ __ROR8__(v11, 12)) + __ROR8__(v14, 36);
  uint64_t v16 = (v15 ^ __ROR8__(v12, 38)) + __ROR8__(v15, 55);
  uint64_t v17 = (v16 ^ __ROR8__(v13, 13)) + __ROR8__(v16, 17);
  uint64_t v18 = (v17 ^ __ROR8__(v14, 36)) + __ROR8__(v17, 10);
  uint64_t v19 = (v18 ^ __ROR8__(v15, 55)) + __ROR8__(v18, 32);
  uint64_t v20 = (v19 ^ __ROR8__(v16, 17)) + __ROR8__(v19, 39);
  uint64_t v21 = __ROR8__(v20, 1);
  *(void *)(a1 + 72) = v21;
  *(void *)(a1 + 80) = (v20 ^ __ROR8__(v17, 10)) + v21;
  ++*(_DWORD *)(*(void *)(a1 + 56) + 84);
  return result;
}

void sub_21678587C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  v6.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_2167858C4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(uint64_t **)(v4 + 64);
  std::exception v6 = *(std::__shared_weak_count **)(v4 + 72);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *v5;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) != v7)
  {
    BOOL v11 = 1;
    if (!v6) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v8 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(v8 + 64);
  uint64_t v9 = *(std::__shared_weak_count **)(v8 + 72);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v11 = *(unsigned int *)(*(void *)(a1 + 56) + 84) < (unint64_t)((uint64_t)(*(void *)(v10 + 24)
                                                                                      - *(void *)(v10 + 16)) >> 3);
    sub_216784EC4(v9);
    if (!v6) {
      goto LABEL_9;
    }
LABEL_8:
    sub_216784EC4(v6);
    goto LABEL_9;
  }
  BOOL v11 = *(unsigned int *)(v8 + 84) < (unint64_t)((uint64_t)(*(void *)(v10 + 24) - *(void *)(v10 + 16)) >> 3);
  if (v6) {
    goto LABEL_8;
  }
LABEL_9:
  if (!v11)
  {
    sub_216778A5C((uint64_t)&v80);
    sub_216779180(&v82, (uint64_t)"Can not write more samples than we have times for when using Acyclic sampling.", 78);
    std::stringbuf::str();
    sub_216778E70(v79, (long long *)__p);
    if (v78 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    size_t v65 = sub_216779038(exception, (uint64_t)v79);
    __cxa_throw(v65, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v12 = (int *)(a2 + 8);
  uint64_t v13 = *(void *)(a1 + 56);
  if (*(_DWORD *)(a2 + 8) != *(_DWORD *)(v13 + 56) || *(unsigned __int8 *)(a2 + 12) != *(unsigned __int8 *)(v13 + 60))
  {
    sub_216778A5C((uint64_t)&v80);
    char v59 = sub_216779180(&v82, (uint64_t)"DataType on ArraySample iSamp: ", 31);
    uint64_t v60 = sub_21677D5B0(v59, v12);
    unint64_t v61 = sub_216779180(v60, (uint64_t)", does not match the DataType of the Array property: ", 53);
    sub_21677D5B0(v61, (int *)(*(void *)(a1 + 56) + 56));
    std::stringbuf::str();
    sub_216778E70(v79, (long long *)__p);
    if (v78 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v62 = __cxa_allocate_exception(0x20uLL);
    uint64_t v63 = sub_216779038(v62, (uint64_t)v79);
    __cxa_throw(v63, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  Alembic::AbcCoreAbstract::v12::ArraySample::getKey((Alembic::AbcCoreAbstract::v12::ArraySample *)a2, (uint64_t)&v80);
  int v14 = v81;
  if ((v81 - 14) <= 0xFFFFFFFD)
  {
    uint64_t v81 = 0x200000002;
    int v14 = 2;
  }
  uint64_t v15 = *(_DWORD **)(a1 + 56);
  unsigned int v16 = v15[21];
  if (!v16
    || (uint64_t v17 = *(void *)(a1 + 24)) == 0
    || __PAIR128__(__PAIR64__(HIDWORD(v81), v14), v80) != *(_OWORD *)v17
    || (uint64_t v18 = v82, v82 != *(void *)(v17 + 16))
    || (uint64_t v19 = v83, v83 != *(void *)(v17 + 24)))
  {
    if (v15[22])
    {
      unint64_t v20 = (v15[23] + 1);
      if (v20 < v16)
      {
        do
        {
          uint64_t v21 = *(std::__shared_weak_count **)(a1 + 96);
          uint64_t v75 = *(void *)(a1 + 88);
          uint64_t v76 = v21;
          if (v21) {
            atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          unint64_t v22 = *(std::__shared_weak_count **)(a1 + 32);
          uint64_t v73 = *(void *)(a1 + 24);
          uint64_t v74 = v22;
          if (v22) {
            atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_21679E3F8(&v75, &v73);
          if (v74) {
            sub_216784EC4(v74);
          }
          if (v76) {
            sub_216784EC4(v76);
          }
          int v23 = *(std::__shared_weak_count **)(a1 + 96);
          uint64_t v71 = *(Alembic::Ogawa::v12::OGroup **)(a1 + 88);
          uint64_t v72 = v23;
          if (v23) {
            atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          sub_21679D9F4(&v71, a1 + 104, *v12);
          if (v72) {
            sub_216784EC4(v72);
          }
          ++v20;
        }
        while (v20 < *(unsigned int *)(*(void *)(a1 + 56) + 84));
      }
    }
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 24))(__p, a1);
    (*(void (**)(_OWORD *__return_ptr))(*(void *)__p[0] + 24))(v79);
    if (__p[1]) {
      sub_216784EC4((std::__shared_weak_count *)__p[1]);
    }
    long long v70 = v79[0];
    if (*((void *)&v79[0] + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v79[0] + 1) + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v24 = sub_21679D8E0((const void **)&v70);
    size_t v25 = *(std::__shared_weak_count **)(a1 + 96);
    uint64_t v68 = *(void *)(a1 + 88);
    char v69 = v25;
    if (v25) {
      atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_21679DA60(v24, (uint64_t)&v68, a2, (uint64_t)&v80, (uint64_t *)__p);
    long long v26 = *(_OWORD *)__p;
    __p[0] = 0;
    __p[1] = 0;
    char v27 = *(std::__shared_weak_count **)(a1 + 32);
    *(_OWORD *)(a1 + 24) = v26;
    if (v27)
    {
      sub_216784EC4(v27);
      if (__p[1]) {
        sub_216784EC4((std::__shared_weak_count *)__p[1]);
      }
    }
    if (v69) {
      sub_216784EC4(v69);
    }
    if (*((void *)&v70 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v70 + 1));
    }
    if (a1 + 104 != a2 + 16) {
      sub_21677CC7C((char *)(a1 + 104), *(char **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
    }
    int v28 = *(std::__shared_weak_count **)(a1 + 96);
    uint64_t v66 = *(Alembic::Ogawa::v12::OGroup **)(a1 + 88);
    uint64_t v67 = v28;
    if (v28) {
      atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_21679D9F4(&v66, a1 + 104, *v12);
    if (v67) {
      sub_216784EC4(v67);
    }
    uint64_t v29 = *(void *)(a1 + 56);
    if (*(unsigned char *)(v29 + 80))
    {
      int v30 = *(uint64_t **)(a1 + 104);
      uint64_t v31 = *(void *)(a1 + 112) - (void)v30;
      if (!v31) {
        goto LABEL_61;
      }
      unint64_t v32 = v31 >> 3;
      uint64_t v33 = v32 <= 1 ? 1 : v32;
      uint64_t v34 = 1;
      do
      {
        uint64_t v35 = *v30++;
        v34 *= v35;
        --v33;
      }
      while (v33);
      if (v34 != 1) {
LABEL_61:
      }
        *(unsigned char *)(v29 + 80) = 0;
    }
    if (*(unsigned char *)(v29 + 81))
    {
      uint64_t v36 = *(void *)(a1 + 24);
      if (v36)
      {
        unint64_t v37 = *(uint64_t **)(a1 + 104);
        uint64_t v38 = *(void *)(a1 + 112) - (void)v37;
        if (v38)
        {
          unint64_t v39 = v38 >> 3;
          if (v39 <= 1) {
            uint64_t v40 = 1;
          }
          else {
            uint64_t v40 = v39;
          }
          uint64_t v38 = 1;
          do
          {
            uint64_t v41 = *v37++;
            v38 *= v41;
            --v40;
          }
          while (v40);
        }
        if (v38 != *(void *)(v36 + 48)) {
          *(unsigned char *)(v29 + 81) = 0;
        }
      }
    }
    int v42 = *(_DWORD *)(v29 + 84);
    if (!*(_DWORD *)(v29 + 88)) {
      *(_DWORD *)(v29 + 88) = v42;
    }
    *(_DWORD *)(v29 + 92) = v42;
    if (*((void *)&v79[0] + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v79[0] + 1));
    }
    uint64_t v43 = *(void *)(a1 + 24);
    uint64_t v18 = *(void *)(v43 + 16);
    uint64_t v19 = *(void *)(v43 + 24);
  }
  *(void *)&v79[0] = v18;
  *((void *)&v79[0] + 1) = v19;
  double result = sub_21679D854((unsigned __int8 *)(a1 + 104), (unint64_t *)v79);
  uint64_t v45 = *(void *)(a1 + 56);
  int v46 = *(_DWORD *)(v45 + 84);
  if (v46)
  {
    uint64_t v47 = (*((void *)&v79[0] + 1) ^ *(void *)&v79[0]) + __ROR8__(*(void *)&v79[0], 49);
    uint64_t v48 = (*(void *)(a1 + 72) ^ v47) + __ROR8__(v47, 12);
    uint64_t v49 = (*(void *)(a1 + 80) ^ v48) + __ROR8__(v48, 38);
    uint64_t v50 = (v49 ^ __ROR8__(*(void *)&v79[0], 49)) + __ROR8__(v49, 13);
    uint64_t v51 = (v50 ^ __ROR8__(v47, 12)) + __ROR8__(v50, 36);
    uint64_t v52 = (v51 ^ __ROR8__(v48, 38)) + __ROR8__(v51, 55);
    uint64_t v53 = (v52 ^ __ROR8__(v49, 13)) + __ROR8__(v52, 17);
    uint64_t v54 = (v53 ^ __ROR8__(v50, 36)) + __ROR8__(v53, 10);
    uint64_t v55 = (v54 ^ __ROR8__(v51, 55)) + __ROR8__(v54, 32);
    uint64_t v56 = (v55 ^ __ROR8__(v52, 17)) + __ROR8__(v55, 39);
    uint64_t v57 = v56 ^ __ROR8__(v53, 10);
    uint64_t v58 = __ROR8__(v56, 1);
    *(void *)(a1 + 72) = v58;
    *(void *)(a1 + 80) = v57 + v58;
  }
  else
  {
    *(_OWORD *)(a1 + 72) = v79[0];
    int v46 = *(_DWORD *)(v45 + 84);
  }
  *(_DWORD *)(v45 + 84) = v46 + 1;
  return result;
}

void sub_216785ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::exception a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

double sub_216785F9C@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_216785FD8(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 56) + 84);
}

void sub_216785FE4(uint64_t a1, int a2)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 24))(&v14);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v14 + 24))(&v16);
  (*(void (**)(void **__return_ptr))(*(void *)v16 + 56))(&v19);
  if (v17) {
    sub_216784EC4(v17);
  }
  long long v4 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)v15;
  if (v15) {
    sub_216784EC4(v15);
  }
  uint64_t v5 = *v19;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v4) == v5)
  {
    std::exception v6 = v19;
    uint64_t v7 = *(void *)(a1 + 56);
    if (*(unsigned int *)(v7 + 84) > (unint64_t)((uint64_t)(v6[3] - v6[2]) >> 3))
    {
      sub_216778A5C((uint64_t)&v16);
      sub_216779180(v18, (uint64_t)"Already have written more samples than we have times for when using Acyclic sampling.", 85);
      std::stringbuf::str();
      sub_216778E70(&v14, &__p);
      if (v13 < 0) {
        operator delete((void *)__p);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v9 = sub_216779038(exception, (uint64_t)&v14);
      __cxa_throw(v9, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 56);
    std::exception v6 = v19;
  }
  uint64_t v10 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v11 = *(std::__shared_weak_count **)(v7 + 72);
  *(void *)(v7 + 64) = v6;
  *(void *)(v7 + 72) = v10;
  if (v11) {
    sub_216784EC4(v11);
  }
  *(_DWORD *)(*(void *)(a1 + 56) + 96) = a2;
  if (v20) {
    sub_216784EC4(v20);
  }
}

void sub_2167861A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  std::exception v6 = *(std::__shared_weak_count **)(v4 - 40);
  if (v6) {
    sub_216784EC4(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_216786208(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 56);
  if (!result)
  {
    sub_216778A5C((uint64_t)v7);
    sub_216779180(v8, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_216778E70(v6, &__p);
    if (v5 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v3 = sub_216779038(exception, (uint64_t)v6);
    __cxa_throw(v3, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_2167862AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_2167862D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 24);

  return v2();
}

void sub_2167863A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_2167863D0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 40);
  if (!v2)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v3 = *(void *)(result + 48);
  *a2 = v2;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_21678648C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void *sub_2167864B4(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_21677CACC(a1, a2);
    std::exception v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_21678651C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216786538(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C7485A0;
  uint64_t v8 = (_OWORD *)(a1 + 24);
  if (*((char *)a2 + 23) < 0)
  {
    sub_216778F24((unsigned char *)(a1 + 24), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v9 = *a2;
    *(void *)(a1 + 40) = *((void *)a2 + 2);
    *uint64_t v8 = v9;
  }
  Alembic::Ogawa::v12::IArchive::IArchive(a1 + 56, a2, a3, a4);
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 120), 0);
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  uint64_t v10 = operator new(0x48uLL);
  v10[7] = 0;
  v10[8] = 0;
  *(_OWORD *)uint64_t v10 = 0u;
  *((_OWORD *)v10 + 1) = 0u;
  *((_OWORD *)v10 + 2) = 0u;
  v10[6] = v10 + 7;
  sub_216787808((void *)(a1 + 240), (uint64_t)v10);
  sub_21679CA1C(a1 + 256, a3);
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  if (Alembic::Ogawa::v12::IArchive::isValid((Alembic::Ogawa::v12::IStreams **)(a1 + 56)))
  {
    if ((Alembic::Ogawa::v12::IArchive::isValid((Alembic::Ogawa::v12::IStreams **)(a1 + 56)) & 1) == 0)
    {
      sub_216778A5C((uint64_t)v27);
      uint64_t v12 = sub_216779180(v28, (uint64_t)"Could not open as Ogawa file: ", 30);
      int v13 = *(char *)(a1 + 47);
      if (v13 >= 0) {
        uint64_t v14 = (uint64_t)v8;
      }
      else {
        uint64_t v14 = *(void *)(a1 + 24);
      }
      if (v13 >= 0) {
        uint64_t v15 = *(unsigned __int8 *)(a1 + 47);
      }
      else {
        uint64_t v15 = *(void *)(a1 + 32);
      }
      sub_216779180(v12, v14, v15);
      std::stringbuf::str();
      sub_216778E70(v26, (long long *)__p);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v17 = sub_216779038(exception, (uint64_t)v26);
      __cxa_throw(v17, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    if ((Alembic::Ogawa::v12::IArchive::isFrozen((Alembic::Ogawa::v12::IStreams **)(a1 + 56)) & 1) == 0)
    {
      sub_216778A5C((uint64_t)v27);
      uint64_t v18 = sub_216779180(v28, (uint64_t)"Ogawa file not cleanly closed while being written: ", 51);
      int v19 = *(char *)(a1 + 47);
      if (v19 >= 0) {
        uint64_t v20 = (uint64_t)v8;
      }
      else {
        uint64_t v20 = *(void *)(a1 + 24);
      }
      if (v19 >= 0) {
        uint64_t v21 = *(unsigned __int8 *)(a1 + 47);
      }
      else {
        uint64_t v21 = *(void *)(a1 + 32);
      }
      sub_216779180(v18, v20, v21);
      std::stringbuf::str();
      sub_216778E70(v26, (long long *)__p);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
      unint64_t v22 = __cxa_allocate_exception(0x20uLL);
      int v23 = sub_216779038(v22, (uint64_t)v26);
      __cxa_throw(v23, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    sub_2167868C4(a1);
  }
  else
  {
    *(_DWORD *)(a1 + 184) = -1;
  }
  return a1;
}

void sub_2167867C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  sub_216779148(&a12);
  sub_216778D38((uint64_t)&a16);
  a16 = (void **)(v16 + 384);
  sub_216787A08(&a16);
  sub_21679CA6C(v20);
  unint64_t v22 = *(std::__shared_weak_count **)(v16 + 248);
  if (v22) {
    sub_216784EC4(v22);
  }
  int v23 = *(void **)(v16 + 216);
  if (v23)
  {
    *(void *)(v16 + 224) = v23;
    operator delete(v23);
  }
  sub_216787968(&a16);
  pthread_mutex_destroy(v19);
  unint64_t v24 = *(std::__shared_weak_count **)(v16 + 112);
  if (v24) {
    sub_216784EC4(v24);
  }
  char v25 = *(std::__shared_weak_count **)(v16 + 96);
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  Alembic::Ogawa::v12::IArchive::~IArchive(v18);
  if (*(char *)(v16 + 47) < 0) {
    operator delete(*v17);
  }
  long long v26 = *(std::__shared_weak_count **)(v16 + 16);
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)v16);
  _Unwind_Resume(a1);
}

void sub_2167868C4(uint64_t a1)
{
  Alembic::Ogawa::v12::IArchive::getGroup(a1 + 56, &v32);
  int v31 = -1;
  if ((unint64_t)Alembic::Ogawa::v12::IGroup::getNumChildren((Alembic::Ogawa::v12::IGroup *)v32) < 6
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v32, 0)
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v32, 1uLL)
    || !Alembic::Ogawa::v12::IGroup::isChildGroup((Alembic::Ogawa::v12::IGroup *)v32, 2uLL)
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v32, 3uLL)
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v32, 4uLL)
    || !Alembic::Ogawa::v12::IGroup::isChildData((Alembic::Ogawa::v12::IGroup *)v32, 5uLL))
  {
    sub_216778A5C((uint64_t)__p);
    sub_216779180(&__p[0].__r_.__value_.__r.__words[2], (uint64_t)"Invalid Alembic file.", 21);
    std::stringbuf::str();
    sub_216778E70(v29, (long long *)v27);
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v14 = sub_216779038(exception, (uint64_t)v29);
    __cxa_throw(v14, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  Alembic::Ogawa::v12::IGroup::getData(v32, 0, 0, __p);
  if (Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)__p[0].__r_.__value_.__l.__data_) == 4) {
    Alembic::Ogawa::v12::IData::read((unint64_t **)__p[0].__r_.__value_.__l.__data_, 4, &v31, 0, 0);
  }
  if (__p[0].__r_.__value_.__l.__size_) {
    sub_216784EC4((std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_);
  }
  if (v31)
  {
    sub_216778A5C((uint64_t)__p);
    sub_216779180(&__p[0].__r_.__value_.__r.__words[2], (uint64_t)"Unsupported file version detected: ", 35);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v29, (long long *)v27);
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    uint64_t v15 = __cxa_allocate_exception(0x20uLL);
    uint64_t v16 = sub_216779038(v15, (uint64_t)v29);
    __cxa_throw(v16, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  int v26 = 0;
  Alembic::Ogawa::v12::IGroup::getData(v32, 1uLL, 0, v25);
  if (Alembic::Ogawa::v12::IData::getSize(v25[0]) == 4) {
    Alembic::Ogawa::v12::IData::read((unint64_t **)v25[0], 4, &v26, 0, 0);
  }
  if (v26 <= 9998)
  {
    sub_216778A5C((uint64_t)__p);
    sub_216779180(&__p[0].__r_.__value_.__r.__words[2], (uint64_t)"Unsupported Alembic version detected: ", 38);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v29, (long long *)v27);
    if (v28 < 0) {
      operator delete(v27[0]);
    }
    uint64_t v17 = __cxa_allocate_exception(0x20uLL);
    uint64_t v18 = sub_216779038(v17, (uint64_t)v29);
    __cxa_throw(v18, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  *(_DWORD *)(a1 + 184) = v26;
  Alembic::Ogawa::v12::IGroup::getData(v32, 4uLL, 0, &v23);
  sub_21679881C(&v23, (uint64_t *)(a1 + 192), a1 + 216);
  if (v24) {
    sub_216784EC4(v24);
  }
  Alembic::Ogawa::v12::IGroup::getData(v32, 5uLL, 0, &v21);
  sub_216799794(&v21, a1 + 384);
  if (v22) {
    sub_216784EC4(v22);
  }
  uint64_t v2 = operator new(0xA0uLL);
  Alembic::Ogawa::v12::IGroup::getGroup(v32, 2uLL, 0, 0, &v19);
  sub_216779094(__p, "");
  sub_216791620(v2, &v19, __p, 0, a1, a1 + 384);
  sub_216787A94(v29, v2);
  long long v3 = v29[0];
  v29[0] = 0uLL;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 112);
  *(_OWORD *)(a1 + 104) = v3;
  if (v4)
  {
    sub_216784EC4(v4);
    if (*((void *)&v29[0] + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v29[0] + 1));
    }
  }
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  if (v20) {
    sub_216784EC4(v20);
  }
  std::exception v5 = *(std::string **)(a1 + 240);
  sub_216779094(__p, "ABC");
  std::string::operator=(v5, __p);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  std::exception v6 = *(std::string **)(a1 + 240);
  sub_216779094(__p, "/");
  std::string::operator=(v6 + 1, __p);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  Alembic::Ogawa::v12::IGroup::getData(v32, 3uLL, 0, __p);
  long long v7 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
  *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v8 = (std::__shared_weak_count *)v25[1];
  *(_OWORD *)char v25 = v7;
  if (v8)
  {
    sub_216784EC4(v8);
    if (__p[0].__r_.__value_.__l.__size_) {
      sub_216784EC4((std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_);
    }
  }
  if (Alembic::Ogawa::v12::IData::getSize(v25[0]))
  {
    size_t Size = Alembic::Ogawa::v12::IData::getSize(v25[0]);
    sub_2167794AC(__p, Size, 0);
    uint64_t v10 = (unint64_t **)v25[0];
    uint64_t v11 = Alembic::Ogawa::v12::IData::getSize(v25[0]);
    uint64_t v12 = (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? __p
        : (std::string *)__p[0].__r_.__value_.__r.__words[0];
    Alembic::Ogawa::v12::IData::read(v10, v11, v12, 0, 0);
    sub_216787230(*(void *)(a1 + 240) + 48, __p);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p[0].__r_.__value_.__l.__data_);
    }
  }
  if (v25[1]) {
    sub_216784EC4((std::__shared_weak_count *)v25[1]);
  }
  if (v33) {
    sub_216784EC4(v33);
  }
}

void sub_216786DD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::exception a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  sub_216779148(&a21);
  sub_216778D38((uint64_t)&__p);
  if (a16) {
    sub_216784EC4(a16);
  }
  unint64_t v32 = *(std::__shared_weak_count **)(v30 - 56);
  if (v32) {
    sub_216784EC4(v32);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_216786F24(uint64_t a1, void *a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C7485A0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v4 = (Alembic::Ogawa::v12::IStreams **)(a1 + 56);
  Alembic::Ogawa::v12::IArchive::IArchive(a1 + 56);
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 120), 0);
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  std::exception v5 = operator new(0x48uLL);
  v5[7] = 0;
  v5[8] = 0;
  *(_OWORD *)std::exception v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  v5[6] = v5 + 7;
  sub_216787808((void *)(a1 + 240), (uint64_t)v5);
  sub_21679CA1C(a1 + 256, (uint64_t)(a2[1] - *a2) >> 3);
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  if ((Alembic::Ogawa::v12::IArchive::isValid(v4) & 1) == 0)
  {
    sub_216778A5C((uint64_t)v14);
    sub_216779180(v15, (uint64_t)"Could not open as Ogawa file from provided streams.", 51);
    std::stringbuf::str();
    sub_216778E70(v13, (long long *)__p);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v8 = sub_216779038(exception, (uint64_t)v13);
    __cxa_throw(v8, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if ((Alembic::Ogawa::v12::IArchive::isFrozen(v4) & 1) == 0)
  {
    sub_216778A5C((uint64_t)v14);
    sub_216779180(v15, (uint64_t)"Ogawa streams not cleanly closed while being written. ", 54);
    std::stringbuf::str();
    sub_216778E70(v13, (long long *)__p);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    long long v9 = __cxa_allocate_exception(0x20uLL);
    uint64_t v10 = sub_216779038(v9, (uint64_t)v13);
    __cxa_throw(v10, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_2167868C4(a1);
  return a1;
}

void sub_216787138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  sub_216779148(&a12);
  sub_216778D38((uint64_t)&a16);
  a16 = (void **)(v16 + 384);
  sub_216787A08(&a16);
  sub_21679CA6C(v19);
  unint64_t v22 = *(std::__shared_weak_count **)(v16 + 248);
  if (v22) {
    sub_216784EC4(v22);
  }
  int v23 = *(void **)(v16 + 216);
  if (v23)
  {
    *(void *)(v16 + 224) = v23;
    operator delete(v23);
  }
  sub_216787968(&a16);
  pthread_mutex_destroy(v18);
  unint64_t v24 = *(std::__shared_weak_count **)(v16 + 112);
  if (v24) {
    sub_216784EC4(v24);
  }
  char v25 = *(std::__shared_weak_count **)(v16 + 96);
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  Alembic::Ogawa::v12::IArchive::~IArchive(v17);
  if (*(char *)(v16 + 47) < 0) {
    operator delete(*v20);
  }
  int v26 = *(std::__shared_weak_count **)(v16 + 16);
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)v16);
  _Unwind_Resume(a1);
}

void sub_216787230(uint64_t a1, std::string *a2)
{
  uint64_t v4 = (void *)(a1 + 8);
  sub_2167877AC(a1, *(void **)(a1 + 8));
  *(void *)a1 = v4;
  *(void *)(a1 + 16) = 0;
  void *v4 = 0;

  Alembic::Util::v12::TokenMap::setUnique((uint64_t **)a1, a2, 59, 61, 1);
}

uint64_t sub_216787298(uint64_t a1)
{
  return a1 + 24;
}

uint64_t sub_2167872A0(uint64_t a1)
{
  return *(void *)(a1 + 240) + 48;
}

uint64_t sub_2167872AC@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 120);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 120));
  *a2 = 0;
  a2[1] = 0;
  std::exception v5 = *(std::__shared_weak_count **)(a1 + 96);
  if (v5)
  {
    std::exception v6 = std::__shared_weak_count::lock(v5);
    a2[1] = (uint64_t)v6;
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 88);
      *a2 = v7;
      if (v7) {
        return pthread_mutex_unlock(v4);
      }
    }
  }
  else
  {
    std::exception v6 = 0;
  }
  uint64_t v8 = operator new(0x58uLL);
  sub_216784F38(&v19, (void *)(a1 + 8));
  long long v9 = *(std::__shared_weak_count **)(a1 + 112);
  uint64_t v17 = *(void *)(a1 + 104);
  uint64_t v18 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 248);
  uint64_t v15 = *(void *)(a1 + 240);
  uint64_t v16 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216792708(v8, &v19, &v17, &v15);
  sub_216787C48(&v21, (uint64_t)v8);
  uint64_t v12 = v21;
  uint64_t v11 = v22;
  uint64_t v21 = 0;
  unint64_t v22 = 0;
  *a2 = v12;
  a2[1] = (uint64_t)v11;
  if (v6)
  {
    sub_216784EC4(v6);
    if (v22) {
      sub_216784EC4(v22);
    }
  }
  if (v16) {
    sub_216784EC4(v16);
  }
  if (v18) {
    sub_216784EC4(v18);
  }
  if (v20) {
    sub_216784EC4(v20);
  }
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  int v13 = *(std::__shared_weak_count **)(a1 + 96);
  *(void *)(a1 + 88) = v12;
  *(void *)(a1 + 96) = v11;
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  return pthread_mutex_unlock(v4);
}

void sub_216787404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  operator delete(v16);
  if (v15) {
    sub_216784EC4(v15);
  }
  pthread_mutex_unlock(v14);
  _Unwind_Resume(a1);
}

void sub_216787474(void *a1@<X0>, unsigned int a2@<W1>, _OWORD *a3@<X8>)
{
  uint64_t v5 = a1[24];
  uint64_t v7 = (_OWORD *)a1[25];
  std::exception v6 = a1 + 24;
  if (v7 == (_OWORD *)v5)
  {
    long long v9 = (Alembic::AbcCoreAbstract::v12::TimeSampling *)operator new(0x28uLL);
    Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v9);
    sub_216787D70(&v22, (uint64_t)v9);
    unint64_t v10 = a1[26];
    uint64_t v11 = (_OWORD *)a1[25];
    if ((unint64_t)v11 >= v10)
    {
      uint64_t v12 = ((uint64_t)v11 - *v6) >> 4;
      if ((unint64_t)(v12 + 1) >> 60) {
        sub_21677CB10();
      }
      uint64_t v13 = v10 - *v6;
      uint64_t v14 = v13 >> 3;
      if (v13 >> 3 <= (unint64_t)(v12 + 1)) {
        uint64_t v14 = v12 + 1;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v15 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v15 = v14;
      }
      v23[4] = a1 + 26;
      uint64_t v16 = (char *)sub_216787EE0((uint64_t)(a1 + 26), v15);
      uint64_t v17 = &v16[16 * v12];
      v23[0] = v16;
      v23[1] = v17;
      v23[3] = &v16[16 * v18];
      *(_OWORD *)uint64_t v17 = v22;
      long long v22 = 0uLL;
      void v23[2] = v17 + 16;
      sub_216787E68(v6, v23);
      uint64_t v7 = (_OWORD *)a1[25];
      sub_216788028(v23);
      uint64_t v19 = (std::__shared_weak_count *)*((void *)&v22 + 1);
      a1[25] = v7;
      if (v19)
      {
        sub_216784EC4(v19);
        uint64_t v7 = (_OWORD *)a1[25];
      }
    }
    else
    {
      *uint64_t v11 = v22;
      uint64_t v7 = v11 + 1;
      a1[25] = v7;
    }
    uint64_t v5 = *v6;
  }
  unint64_t v20 = ((uint64_t)v7 - v5) >> 4;
  if (v20 <= a2) {
    long long v21 = *(_OWORD *)(v5 + 16 * v20 - 16);
  }
  else {
    long long v21 = *(_OWORD *)(v5 + 16 * a2);
  }
  *a3 = v21;
  if (*((void *)&v21 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v21 + 1) + 8), 1uLL, memory_order_relaxed);
  }
}

void sub_2167875DC(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_216788028((void **)va);
  if (a3) {
    sub_216784EC4(a3);
  }
  _Unwind_Resume(a1);
}

double sub_216787614@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_216787650(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 216);
  if (a2 >= (unint64_t)((*(void *)(a1 + 224) - v2) >> 3)) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

void *sub_216787674@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_21679CA70((void *)(a1 + 256), a2);
}

void sub_21678767C(uint64_t a1)
{
  *(void *)a1 = &unk_26C7485A0;
  uint64_t v7 = (void **)(a1 + 384);
  sub_216787A08(&v7);
  sub_21679CA6C(a1 + 256);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 248);
  if (v2) {
    sub_216784EC4(v2);
  }
  long long v3 = *(void **)(a1 + 216);
  if (v3)
  {
    *(void *)(a1 + 224) = v3;
    operator delete(v3);
  }
  uint64_t v7 = (void **)(a1 + 192);
  sub_216787968(&v7);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 120));
  long long v4 = *(std::__shared_weak_count **)(a1 + 112);
  if (v4) {
    sub_216784EC4(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 96);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  Alembic::Ogawa::v12::IArchive::~IArchive((Alembic::Ogawa::v12::IArchive *)(a1 + 56));
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  std::exception v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)a1);
}

void sub_216787758(uint64_t a1)
{
  sub_21678767C(a1);

  operator delete(v1);
}

uint64_t sub_216787780(uint64_t a1)
{
  return a1 + 384;
}

void sub_216787788(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_216787794(uint64_t a1)
{
  return (*(void *)(a1 + 200) - *(void *)(a1 + 192)) >> 4;
}

uint64_t sub_2167877A4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 184);
}

void sub_2167877AC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_2167877AC(a1, *a2);
    sub_2167877AC(a1, a2[1]);
    sub_21677B5A0((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void *sub_216787808(void *a1, uint64_t a2)
{
  *a1 = a2;
  long long v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748658;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_216787868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_216787900((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678788C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_2167878B4(uint64_t a1)
{
}

uint64_t sub_2167878BC(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7486A8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_216787900(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_2167877AC(a2 + 48, *(void **)(a2 + 56));
    if (*(char *)(a2 + 47) < 0) {
      operator delete(*(void **)(a2 + 24));
    }
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    operator delete((void *)a2);
  }
}

void sub_216787968(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_2167879BC((uint64_t *)v2);
    long long v3 = **a1;
    operator delete(v3);
  }
}

void sub_2167879BC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    long long v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      sub_216784EC4(v4);
    }
  }
  a1[1] = v2;
}

void sub_216787A08(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    long long v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        std::exception v6 = v4 - 24;
        sub_2167877AC((uint64_t)(v4 - 24), *((void **)v4 - 2));
        long long v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_216787A94(void *a1, void *a2)
{
  *a1 = a2;
  long long v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7486D0;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  sub_216787B18((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_216787AFC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    long long v3 = (void *)sub_2167916A4(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_216787B18(uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    long long v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        long long v4 = (std::__shared_weak_count *)a2[1];
      }
      *a2 = a3;
      a2[1] = v5;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v5)
      {
        sub_216784EC4(v5);
      }
    }
  }
}

void sub_216787BA4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_216787BCC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = (void *)sub_2167916A4(v1);
    operator delete(v2);
  }
}

uint64_t sub_216787C04(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748720)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t *sub_216787C48(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  long long v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748748;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_216787CB8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323B20(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_216787CD4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_216787CFC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_216787D2C(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748798)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_216787D70(void *a1, uint64_t a2)
{
  *a1 = a2;
  long long v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7487C0;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_216787DD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_21677ED98((int)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_216787DF4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_216787E1C(uint64_t a1)
{
}

uint64_t sub_216787E24(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748810)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_216787E68(uint64_t *a1, void *a2)
{
  uint64_t result = sub_216787F18((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_216787EE0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_21677CA1C();
  }
  return operator new(16 * a2);
}

uint64_t sub_216787F18(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_216787FAC((uint64_t)v12);
  return v10;
}

uint64_t sub_216787FAC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_216787FE4(a1);
  }
  return a1;
}

void sub_216787FE4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    long long v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_216784EC4(v3);
    }
    v1 += 16;
  }
}

void **sub_216788028(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_21678805C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    long long v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      sub_216784EC4(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

uint64_t sub_2167880B0(uint64_t a1, long long *a2, const void ***a3)
{
  *(unsigned char *)(a1 + 8) = -1;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_26C748838;
  uint64_t v6 = (_OWORD *)(a1 + 32);
  if (*((char *)a2 + 23) < 0)
  {
    sub_216778F24((unsigned char *)(a1 + 32), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    *(void *)(a1 + 48) = *((void *)a2 + 2);
    *uint64_t v6 = v7;
  }
  sub_2167898D0((uint64_t *)(a1 + 56), a3);
  Alembic::Ogawa::v12::OArchive::OArchive(a1 + 80, a2);
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  uint64_t v8 = (void **)(a1 + 168);
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 224) = 1065353216;
  long long v9 = operator new(0x18uLL);
  int v9[2] = 0;
  v9[1] = 0;
  *long long v9 = v9 + 1;
  sub_21678A34C((void *)(a1 + 232), (uint64_t)v9);
  uint64_t v10 = (Alembic::AbcCoreAbstract::v12::TimeSampling *)operator new(0x28uLL);
  Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v10);
  sub_216787D70(&v35, (uint64_t)v10);
  sub_216788460((uint64_t *)(a1 + 144), &v35);
  unint64_t v11 = *(void *)(a1 + 184);
  uint64_t v12 = *(char **)(a1 + 176);
  if ((unint64_t)v12 >= v11)
  {
    long long v14 = (char *)*v8;
    uint64_t v15 = (v12 - (unsigned char *)*v8) >> 3;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v17 = v11 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      uint64_t v19 = (char *)sub_21677CB28(a1 + 184, v18);
      long long v14 = *(char **)(a1 + 168);
      uint64_t v12 = *(char **)(a1 + 176);
    }
    else
    {
      uint64_t v19 = 0;
    }
    unint64_t v20 = &v19[8 * v15];
    long long v21 = &v19[8 * v18];
    *(void *)unint64_t v20 = 0;
    char v13 = v20 + 8;
    while (v12 != v14)
    {
      uint64_t v22 = *((void *)v12 - 1);
      v12 -= 8;
      *((void *)v20 - 1) = v22;
      v20 -= 8;
    }
    *(void *)(a1 + 168) = v20;
    *(void *)(a1 + 176) = v13;
    *(void *)(a1 + 184) = v21;
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    *(void *)uint64_t v12 = 0;
    char v13 = v12 + 8;
  }
  *(void *)(a1 + 176) = v13;
  if (!Alembic::Ogawa::v12::OArchive::isValid((Alembic::Ogawa::v12::OStream **)(a1 + 80)))
  {
    sub_216778A5C((uint64_t)v33);
    unint64_t v24 = sub_216779180(v34, (uint64_t)"Could not open file: ", 21);
    int v25 = *(char *)(a1 + 55);
    if (v25 >= 0) {
      uint64_t v26 = (uint64_t)v6;
    }
    else {
      uint64_t v26 = *(void *)(a1 + 32);
    }
    if (v25 >= 0) {
      uint64_t v27 = *(unsigned __int8 *)(a1 + 55);
    }
    else {
      uint64_t v27 = *(void *)(a1 + 40);
    }
    sub_216779180(v24, v26, v27);
    std::stringbuf::str();
    sub_216778E70(v32, &__p);
    if (v31 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v29 = sub_216779038(exception, (uint64_t)v32);
    __cxa_throw(v29, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_21678857C(a1);
  if (*((void *)&v35 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v35 + 1));
  }
  return a1;
}

void sub_216788360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v18.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v20 = va_arg(va1, void);
  uint64_t v21 = va_arg(va1, void);
  uint64_t v22 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v12 = *(std::__shared_weak_count **)(v10 - 88);
  if (v12) {
    sub_216784EC4(v12);
  }
  char v13 = *(std::__shared_weak_count **)(v4 + 240);
  if (v13) {
    sub_216784EC4(v13);
  }
  sub_216789CFC(v9);
  long long v14 = *v8;
  if (*v8)
  {
    *(void *)(v4 + 176) = v14;
    operator delete(v14);
  }
  sub_216787968((void ***)va1);
  uint64_t v15 = *(std::__shared_weak_count **)(v4 + 136);
  if (v15) {
    sub_216784EC4(v15);
  }
  unint64_t v16 = *(std::__shared_weak_count **)(v4 + 120);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  Alembic::Ogawa::v12::OArchive::~OArchive(v7);
  sub_2167877AC(v6, *(void **)(v4 + 64));
  if (*(char *)(v4 + 55) < 0) {
    operator delete(*v5);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(v4 + 24);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  Alembic::AbcCoreAbstract::v12::ArchiveWriter::~ArchiveWriter((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)v4);
  _Unwind_Resume(a1);
}

void **sub_216788460(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  long long v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_21677CB10();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    void v18[4] = result;
    long long v14 = (char *)sub_216787EE0((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    int v18[2] = v15 + 16;
    sub_216787E68(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = sub_216788028(v18);
  }
  else
  {
    *long long v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_216788568(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216788028((void **)va);
  _Unwind_Resume(a1);
}

void sub_21678857C(uint64_t a1)
{
  int v31 = 0;
  uint64_t v2 = a1 + 80;
  Alembic::Ogawa::v12::OArchive::getGroup(a1 + 80, &__p);
  Alembic::Ogawa::v12::OGroup::addData((Alembic::Ogawa::v12::OGroup *)__p, &v31, 4, &v29);
  if (v30) {
    sub_216784EC4(v30);
  }
  if (v24) {
    sub_216784EC4(v24);
  }
  int v28 = 10803;
  Alembic::Ogawa::v12::OArchive::getGroup(v2, &__p);
  Alembic::Ogawa::v12::OGroup::addData((Alembic::Ogawa::v12::OGroup *)__p, &v28, 4, &v26);
  if (v27) {
    sub_216784EC4(v27);
  }
  if (v24) {
    sub_216784EC4(v24);
  }
  long long v3 = (Alembic::AbcCoreAbstract::v12 *)sub_216779094(&__p, "_ai_AlembicVersion");
  Alembic::AbcCoreAbstract::v12::GetLibraryVersion(v3);
  p_p = &__p;
  uint64_t v4 = sub_21677B174((uint64_t **)(a1 + 56), (const void **)&__p, (uint64_t)&unk_217407F23, (long long **)&p_p);
  std::string::operator=((std::string *)(v4 + 7), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v25 < 0) {
    operator delete(__p);
  }
  unint64_t v5 = operator new(0x88uLL);
  Alembic::Ogawa::v12::OArchive::getGroup(v2, &__p);
  Alembic::Ogawa::v12::OGroup::addGroup((Alembic::Ogawa::v12::OGroup *)__p, &v20);
  sub_216792E48(v5, &v20);
  sub_216788D74((void *)(a1 + 128), v5);
  if (v21) {
    sub_216784EC4(v21);
  }
  if (v24) {
    sub_216784EC4(v24);
  }
  unint64_t v6 = (Alembic::Ogawa::v12::OData *)operator new(8uLL);
  Alembic::Ogawa::v12::OData::OData(v6);
  sub_21678A67C(&__p, (uint64_t)v6);
  long long v7 = operator new(0x38uLL);
  uint64_t v8 = __p;
  uint64_t v9 = v24;
  if (v24)
  {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    *long long v7 = 0;
    v7[1] = 0x200000002;
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = v8;
    v7[5] = v9;
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    *long long v7 = 0;
    v7[1] = 0x200000002;
    v7[2] = 0;
    v7[3] = 0;
    v7[4] = v8;
    v7[5] = 0;
  }
  v7[6] = 0;
  sub_21678A798(&__str, (uint64_t)v7);
  if (v9) {
    sub_216784EC4(v9);
  }
  uint64_t v10 = a1 + 192;
  long long v19 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
  if (__str.__r_.__value_.__l.__size_) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(__str.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
  }
  sub_216788DBC(v10, (uint64_t)&v19);
  if (*((void *)&v19 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v19 + 1));
  }
  unint64_t v11 = operator new(0x38uLL);
  uint64_t v12 = __p;
  unint64_t v13 = v24;
  if (v24)
  {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    *unint64_t v11 = 0;
    v11[1] = 0xC0000000CLL;
    v11[2] = 0;
    v11[3] = 0;
    v11[4] = v12;
    v11[5] = v13;
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    *unint64_t v11 = 0;
    v11[1] = 0xC0000000CLL;
    v11[2] = 0;
    v11[3] = 0;
    v11[4] = v12;
    v11[5] = 0;
  }
  v11[6] = 0;
  sub_216788ECC(&__str, (uint64_t)v11);
  if (v13) {
    sub_216784EC4(v13);
  }
  long long v18 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
  if (__str.__r_.__value_.__l.__size_) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(__str.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
  }
  sub_216788DBC(v10, (uint64_t)&v18);
  if (*((void *)&v18 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v18 + 1));
  }
  long long v14 = operator new(0x38uLL);
  uint64_t v15 = __p;
  uint64_t v16 = v24;
  if (v24)
  {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    void *v14 = 0;
    v14[1] = 0xD0000000DLL;
    void v14[2] = 0;
    v14[3] = 0;
    v14[4] = v15;
    v14[5] = v16;
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    void *v14 = 0;
    v14[1] = 0xD0000000DLL;
    void v14[2] = 0;
    v14[3] = 0;
    v14[4] = v15;
    v14[5] = 0;
  }
  v14[6] = 0;
  sub_216788ECC(&__str, (uint64_t)v14);
  if (v16) {
    sub_216784EC4(v16);
  }
  long long v17 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
  if (__str.__r_.__value_.__l.__size_) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(__str.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
  }
  sub_216788DBC(v10, (uint64_t)&v17);
  if (*((void *)&v17 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v17 + 1));
  }
  if (__str.__r_.__value_.__l.__size_) {
    sub_216784EC4((std::__shared_weak_count *)__str.__r_.__value_.__l.__size_);
  }
  if (v24) {
    sub_216784EC4(v24);
  }
}

void sub_2167888F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::__shared_weak_count *a25,int a26,__int16 a27,char a28,char a29)
{
  if (a11) {
    sub_216784EC4(a11);
  }
  if (a19) {
    sub_216784EC4(a19);
  }
  if (a25) {
    sub_216784EC4(a25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216788A08(uint64_t a1, uint64_t a2, const void ***a3)
{
  *(unsigned char *)(a1 + 8) = -1;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)a1 = &unk_26C748838;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  sub_2167898D0((uint64_t *)(a1 + 56), a3);
  Alembic::Ogawa::v12::OArchive::OArchive(a1 + 80, a2);
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  unint64_t v5 = (void **)(a1 + 168);
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 224) = 1065353216;
  unint64_t v6 = operator new(0x18uLL);
  int v6[2] = 0;
  v6[1] = 0;
  *unint64_t v6 = v6 + 1;
  sub_21678A34C((void *)(a1 + 232), (uint64_t)v6);
  long long v7 = (Alembic::AbcCoreAbstract::v12::TimeSampling *)operator new(0x28uLL);
  Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v7);
  sub_216787D70(&v28, (uint64_t)v7);
  sub_216788460((uint64_t *)(a1 + 144), &v28);
  unint64_t v8 = *(void *)(a1 + 184);
  uint64_t v9 = *(char **)(a1 + 176);
  if ((unint64_t)v9 >= v8)
  {
    unint64_t v11 = (char *)*v5;
    uint64_t v12 = (v9 - (unsigned char *)*v5) >> 3;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v14 = v8 - (void)v11;
    if (v14 >> 2 > v13) {
      unint64_t v13 = v14 >> 2;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v15 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      uint64_t v16 = (char *)sub_21677CB28(a1 + 184, v15);
      unint64_t v11 = *(char **)(a1 + 168);
      uint64_t v9 = *(char **)(a1 + 176);
    }
    else
    {
      uint64_t v16 = 0;
    }
    long long v17 = &v16[8 * v12];
    long long v18 = &v16[8 * v15];
    *(void *)long long v17 = 0;
    uint64_t v10 = v17 + 8;
    while (v9 != v11)
    {
      uint64_t v19 = *((void *)v9 - 1);
      v9 -= 8;
      *((void *)v17 - 1) = v19;
      v17 -= 8;
    }
    *(void *)(a1 + 168) = v17;
    *(void *)(a1 + 176) = v10;
    *(void *)(a1 + 184) = v18;
    if (v11) {
      operator delete(v11);
    }
  }
  else
  {
    *(void *)uint64_t v9 = 0;
    uint64_t v10 = v9 + 8;
  }
  *(void *)(a1 + 176) = v10;
  if (!Alembic::Ogawa::v12::OArchive::isValid((Alembic::Ogawa::v12::OStream **)(a1 + 80)))
  {
    sub_216778A5C((uint64_t)v26);
    sub_216779180(v27, (uint64_t)"Could not use the given ostream.", 32);
    std::stringbuf::str();
    sub_216778E70(v25, &__p);
    if (v24 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v22 = sub_216779038(exception, (uint64_t)v25);
    __cxa_throw(v22, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_21678857C(a1);
  if (*((void *)&v28 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v28 + 1));
  }
  return a1;
}

void sub_216788C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v18.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v20 = va_arg(va1, void);
  uint64_t v21 = va_arg(va1, void);
  uint64_t v22 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v12 = *(std::__shared_weak_count **)(v10 - 88);
  if (v12) {
    sub_216784EC4(v12);
  }
  unint64_t v13 = *(std::__shared_weak_count **)(v4 + 240);
  if (v13) {
    sub_216784EC4(v13);
  }
  sub_216789CFC(v8);
  uint64_t v14 = *v7;
  if (*v7)
  {
    *(void *)(v4 + 176) = v14;
    operator delete(v14);
  }
  sub_216787968((void ***)va1);
  unint64_t v15 = *(std::__shared_weak_count **)(v4 + 136);
  if (v15) {
    sub_216784EC4(v15);
  }
  uint64_t v16 = *(std::__shared_weak_count **)(v4 + 120);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  Alembic::Ogawa::v12::OArchive::~OArchive(v6);
  sub_2167877AC(v5, *(void **)(v4 + 64));
  if (*(char *)(v4 + 55) < 0) {
    operator delete(*v9);
  }
  long long v17 = *(std::__shared_weak_count **)(v4 + 24);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  Alembic::AbcCoreAbstract::v12::ArchiveWriter::~ArchiveWriter((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)v4);
  _Unwind_Resume(a1);
}

void sub_216788D74(void *a1, void *a2)
{
  sub_21678A550(&v5, a2);
  long long v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v5;
  *(void *)&long long v5 = *a1;
  *((void *)&v5 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_216784EC4(v3);
  }
}

void sub_216788DBC(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD **)a2;
  if (!v3)
  {
    sub_216778A5C((uint64_t)v13);
    sub_216779180(v14, (uint64_t)"Invalid WrittenSampleIDPtr", 26);
    std::stringbuf::str();
    sub_216778E70(v12, &__p);
    if (v11 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v9 = sub_216779038(exception, (uint64_t)v12);
    __cxa_throw(v9, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  v13[0] = v3;
  long long v4 = sub_216789D80(a1, (uint64_t)v3, (uint64_t)&unk_217407F23, v13);
  unint64_t v6 = *(_OWORD **)a2;
  uint64_t v5 = *(void *)(a2 + 8);
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  long long v7 = (std::__shared_weak_count *)v4[7];
  v4[6] = v6;
  v4[7] = v5;
  if (v7) {
    sub_216784EC4(v7);
  }
}

void sub_216788EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_216788ECC(void *a1, uint64_t a2)
{
  sub_21678A798(&v5, a2);
  long long v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v5;
  *(void *)&long long v5 = *a1;
  *((void *)&v5 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_216784EC4(v3);
  }
}

uint64_t sub_216788F14(uint64_t a1)
{
  return a1 + 32;
}

uint64_t sub_216788F1C(uint64_t a1)
{
  return a1 + 56;
}

double sub_216788F24@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 16));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_216788F60(void *a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  long long v4 = (std::__shared_weak_count *)a1[15];
  if (v4)
  {
    long long v5 = std::__shared_weak_count::lock(v4);
    a2[1] = (uint64_t)v5;
    if (v5)
    {
      uint64_t v6 = a1[14];
      *a2 = v6;
      if (v6) {
        return;
      }
    }
  }
  else
  {
    long long v5 = 0;
  }
  uint64_t v7 = operator new(0x60uLL);
  (*(void (**)(uint64_t *__return_ptr, void *))(*a1 + 40))(&v14, a1);
  uint64_t v8 = (std::__shared_weak_count *)a1[17];
  uint64_t v12 = a1[16];
  unint64_t v13 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_2167946D0(v7, &v14, &v12, a1 + 7);
  sub_21678A938(&v16, (uint64_t)v7);
  uint64_t v10 = v16;
  uint64_t v9 = v17;
  uint64_t v16 = 0;
  long long v17 = 0;
  *a2 = v10;
  a2[1] = (uint64_t)v9;
  if (v5)
  {
    sub_216784EC4(v5);
    if (v17) {
      sub_216784EC4(v17);
    }
  }
  if (v13) {
    sub_216784EC4(v13);
  }
  if (v15) {
    sub_216784EC4(v15);
  }
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  char v11 = (std::__shared_weak_count *)a1[15];
  a1[14] = v10;
  a1[15] = v9;
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_2167890A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  operator delete(v13);
  if (v12) {
    sub_216784EC4(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_2167890F4(void *a1, const Alembic::AbcCoreAbstract::v12::TimeSampling *a2)
{
  long long v4 = a1 + 18;
  uint64_t v5 = a1[19] - a1[18];
  if (v5 < 1)
  {
LABEL_7:
    uint64_t v10 = (Alembic::AbcCoreAbstract::v12::TimeSampling *)operator new(0x28uLL);
    Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v10, a2);
    sub_216787D70(&v32, (uint64_t)v10);
    sub_216788460(v4, &v32);
    unint64_t v11 = a1[23];
    uint64_t v12 = (char *)a1[22];
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v14 = (char *)a1[21];
      uint64_t v15 = (v12 - v14) >> 3;
      if ((unint64_t)(v15 + 1) >> 61) {
        sub_21677CB10();
      }
      unint64_t v16 = v11 - (void)v14;
      unint64_t v17 = (uint64_t)(v11 - (void)v14) >> 2;
      if (v17 <= v15 + 1) {
        unint64_t v17 = v15 + 1;
      }
      if (v16 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v17;
      }
      if (v18)
      {
        uint64_t v19 = (char *)sub_21677CB28((uint64_t)(a1 + 23), v18);
        uint64_t v14 = (char *)a1[21];
        uint64_t v12 = (char *)a1[22];
      }
      else
      {
        uint64_t v19 = 0;
      }
      uint64_t v20 = &v19[8 * v15];
      uint64_t v21 = &v19[8 * v18];
      *(void *)uint64_t v20 = 0;
      unint64_t v13 = v20 + 8;
      while (v12 != v14)
      {
        uint64_t v22 = *((void *)v12 - 1);
        v12 -= 8;
        *((void *)v20 - 1) = v22;
        v20 -= 8;
      }
      a1[21] = v20;
      a1[22] = v13;
      a1[23] = v21;
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *(void *)uint64_t v12 = 0;
      unint64_t v13 = v12 + 8;
    }
    a1[22] = v13;
    uint64_t v24 = a1[18];
    uint64_t v23 = a1[19];
    sub_216778A5C((uint64_t)v29);
    uint64_t v7 = ((v23 - v24) >> 4) - 1;
    std::ostream::operator<<();
    std::stringbuf::str();
    if (v28 < 0) {
      operator delete(__p);
    }
    v29[0] = *MEMORY[0x263F8C2B8];
    uint64_t v25 = *(void *)(MEMORY[0x263F8C2B8] + 72);
    *(void *)((char *)v29 + *(void *)(v29[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
    _OWORD v29[2] = v25;
    v29[3] = MEMORY[0x263F8C318] + 16;
    if (v30 < 0) {
      operator delete((void *)v29[11]);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x21D447E60](&v31);
    if (*((void *)&v32 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v32 + 1));
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = (unint64_t)v5 >> 4;
    if (v8 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v8;
    }
    while (!sub_216789418((uint64_t)a2, *(void *)(*v4 + v6)))
    {
      ++v7;
      v6 += 16;
      if (v9 == v7) {
        goto LABEL_7;
      }
    }
  }
  return v7;
}

void sub_2167893D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  uint64_t v14 = *(std::__shared_weak_count **)(v12 - 72);
  if (v14) {
    sub_216784EC4(v14);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_216789418(uint64_t a1, uint64_t a2)
{
  BOOL result = Alembic::AbcCoreAbstract::v12::TimeSamplingType::operator==(a1, a2);
  if (result)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(a1 + 24);
    uint64_t v7 = *(double **)(a2 + 16);
    if (v5 - v6 == *(void *)(a2 + 24) - (void)v7)
    {
      if (v6 == v5)
      {
        return 1;
      }
      else
      {
        uint64_t v8 = v6 + 8;
        do
        {
          double v9 = *v7++;
          BOOL result = *(double *)(v8 - 8) == v9;
          BOOL v10 = *(double *)(v8 - 8) != v9 || v8 == v5;
          v8 += 8;
        }
        while (!v10);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_216789494@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, _OWORD *a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 144);
  if (a2 >= (unint64_t)((*(void *)(result + 152) - v3) >> 4))
  {
    sub_216778A5C((uint64_t)v10);
    sub_216779180(v11, (uint64_t)"Invalid index provided to getTimeSampling.", 42);
    std::stringbuf::str();
    sub_216778E70(v9, &__p);
    if (v8 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v6 = sub_216779038(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  long long v4 = *(_OWORD *)(v3 + 16 * a2);
  *a3 = v4;
  if (*((void *)&v4 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_216789560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_216789588(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 168);
  if (a2 >= (unint64_t)((*(void *)(a1 + 176) - v2) >> 3)) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t sub_2167895AC(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 168);
  if (a2 < (unint64_t)((*(void *)(result + 176) - v3) >> 3)) {
    *(void *)(v3 + 8 * a2) = a3;
  }
  return result;
}

void sub_2167895C8(Alembic::AbcCoreAbstract::v12::ArchiveWriter *a1)
{
  *(void *)a1 = &unk_26C748838;
  uint64_t v2 = (uint64_t)a1 + 192;
  sub_21678A2F4((uint64_t)a1 + 192);
  uint64_t v3 = *((void *)a1 + 16);
  if (v3)
  {
    long long v4 = (std::__shared_weak_count *)*((void *)a1 + 30);
    uint64_t v29 = *((void *)a1 + 29);
    char v30 = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216793BEC(v3, &v29, (Alembic::Util::v12::SpookyHash *)v31);
    if (v30) {
      sub_216784EC4(v30);
    }
  }
  std::exception v5 = (std::__shared_weak_count *)*((void *)a1 + 17);
  *((void *)a1 + 16) = 0;
  *((void *)a1 + 17) = 0;
  if (v5) {
    sub_216784EC4(v5);
  }
  if (Alembic::Ogawa::v12::OArchive::isValid((Alembic::Ogawa::v12::OStream **)a1 + 10))
  {
    Alembic::Util::v12::TokenMap::get((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)((char *)a1 + 56), 0x3Bu, 61, 1);
    Alembic::Ogawa::v12::OArchive::getGroup((uint64_t)a1 + 80, &__p);
    if ((v32 & 0x80u) == 0) {
      uint64_t v6 = v32;
    }
    else {
      uint64_t v6 = (uint64_t)v31[1];
    }
    if ((v32 & 0x80u) == 0) {
      uint64_t v7 = v31;
    }
    else {
      uint64_t v7 = (void **)v31[0];
    }
    Alembic::Ogawa::v12::OGroup::addData((Alembic::Ogawa::v12::OGroup *)__p, v7, v6, &v27);
    if (v28) {
      sub_216784EC4(v28);
    }
    if (v25) {
      sub_216784EC4(v25);
    }
    long long __p = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    unsigned int v8 = (*(uint64_t (**)(Alembic::AbcCoreAbstract::v12::ArchiveWriter *))(*(void *)a1 + 64))(a1);
    if (v8)
    {
      uint64_t v9 = 0;
      uint64_t v10 = v8;
      do
      {
        uint64_t v11 = *(void *)(*((void *)a1 + 21) + 8 * v9);
        (*(void (**)(Alembic::Ogawa::v12::OGroup **__return_ptr, Alembic::AbcCoreAbstract::v12::ArchiveWriter *, uint64_t))(*(void *)a1 + 56))(&v22, a1, v9);
        sub_21679EB1C((unint64_t *)&__p, v11, (uint64_t)v22);
        if (v23) {
          sub_216784EC4(v23);
        }
        ++v9;
      }
      while (v10 != v9);
    }
    Alembic::Ogawa::v12::OArchive::getGroup((uint64_t)a1 + 80, &v22);
    Alembic::Ogawa::v12::OGroup::addData(v22, __p, (char *)v25 - (unsigned char *)__p, &v20);
    if (v21) {
      sub_216784EC4(v21);
    }
    if (v23) {
      sub_216784EC4(v23);
    }
    uint64_t v12 = (void *)*((void *)a1 + 29);
    Alembic::Ogawa::v12::OArchive::getGroup((uint64_t)a1 + 80, &v18);
    sub_2167906E8(v12, &v18);
    if (v19) {
      sub_216784EC4(v19);
    }
    if (__p)
    {
      uint64_t v25 = (std::__shared_weak_count *)__p;
      operator delete(__p);
    }
    if ((char)v32 < 0) {
      operator delete(v31[0]);
    }
  }
  unint64_t v13 = (std::__shared_weak_count *)*((void *)a1 + 30);
  if (v13) {
    sub_216784EC4(v13);
  }
  sub_216789CFC(v2);
  uint64_t v14 = (void *)*((void *)a1 + 21);
  if (v14)
  {
    *((void *)a1 + 22) = v14;
    operator delete(v14);
  }
  v31[0] = (char *)a1 + 144;
  sub_216787968((void ***)v31);
  uint64_t v15 = (std::__shared_weak_count *)*((void *)a1 + 17);
  if (v15) {
    sub_216784EC4(v15);
  }
  unint64_t v16 = (std::__shared_weak_count *)*((void *)a1 + 15);
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  Alembic::Ogawa::v12::OArchive::~OArchive((Alembic::AbcCoreAbstract::v12::ArchiveWriter *)((char *)a1 + 80));
  sub_2167877AC((uint64_t)a1 + 56, *((void **)a1 + 8));
  if (*((char *)a1 + 55) < 0) {
    operator delete(*((void **)a1 + 4));
  }
  unint64_t v17 = (std::__shared_weak_count *)*((void *)a1 + 3);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  Alembic::AbcCoreAbstract::v12::ArchiveWriter::~ArchiveWriter(a1);
}

void sub_216789898(Alembic::AbcCoreAbstract::v12::ArchiveWriter *a1)
{
  sub_2167895C8(a1);

  operator delete(v1);
}

uint64_t sub_2167898C0(uint64_t a1)
{
  return (*(void *)(a1 + 152) - *(void *)(a1 + 144)) >> 4;
}

uint64_t *sub_2167898D0(uint64_t *a1, const void ***a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_216789928(a1, *a2, a2 + 1);
  return a1;
}

void sub_216789910(_Unwind_Exception *a1)
{
  sub_2167877AC(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_216789928(uint64_t *result, const void **a2, const void ***a3)
{
  if (a2 != (const void **)a3)
  {
    long long v4 = a2;
    std::exception v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      BOOL result = sub_2167899B4(v5, v6, v4 + 4, (long long *)v4 + 2);
      uint64_t v7 = (const void **)v4[1];
      if (v7)
      {
        do
        {
          unsigned int v8 = (const void ***)v7;
          uint64_t v7 = (const void **)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unsigned int v8 = (const void ***)v4[2];
          BOOL v9 = *v8 == v4;
          long long v4 = (const void **)v8;
        }
        while (!v9);
      }
      long long v4 = (const void **)v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_2167899B4(uint64_t **a1, uint64_t *a2, const void **a3, long long *a4)
{
  uint64_t v6 = sub_216789A4C(a1, a2, &v12, &v11, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unsigned int v8 = (uint64_t **)v6;
    sub_216789BF8((uint64_t)a1, a4, (uint64_t)v10);
    sub_21677B358(a1, (uint64_t)v12, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_21677B548((uint64_t)v10, 0);
  }
  return v7;
}

const void **sub_216789A4C(void *a1, uint64_t *a2, const void ***a3, uint64_t *a4, const void **a5)
{
  BOOL v9 = (const void **)(a1 + 1);
  if (a1 + 1 != a2 && !sub_21677B108((uint64_t)(a1 + 2), a5, (const void **)a2 + 4))
  {
    if (!sub_21677B108((uint64_t)(a1 + 2), (const void **)a2 + 4, a5))
    {
      *a3 = (const void **)a2;
      *a4 = (uint64_t)a2;
      return (const void **)a4;
    }
    a4 = a2 + 1;
    uint64_t v13 = a2[1];
    if (v13)
    {
      uint64_t v14 = (const void **)a2[1];
      do
      {
        uint64_t v15 = v14;
        uint64_t v14 = (const void **)*v14;
      }
      while (v14);
    }
    else
    {
      unint64_t v18 = (const void **)a2;
      do
      {
        uint64_t v15 = (const void **)v18[2];
        BOOL v17 = *v15 == v18;
        unint64_t v18 = v15;
      }
      while (!v17);
    }
    if (v15 != v9)
    {
      if (!sub_21677B108((uint64_t)(a1 + 2), a5, v15 + 4)) {
        goto LABEL_28;
      }
      uint64_t v13 = *a4;
    }
    if (v13)
    {
      *a3 = v15;
      return v15;
    }
    else
    {
      *a3 = (const void **)a2;
    }
    return (const void **)a4;
  }
  if ((uint64_t *)*a1 == a2)
  {
    uint64_t v12 = (const void **)a2;
LABEL_16:
    if (*a2)
    {
      *a3 = v12;
      return v12 + 1;
    }
    else
    {
      *a3 = (const void **)a2;
      return (const void **)a2;
    }
  }
  uint64_t v11 = (const void **)*a2;
  if (*a2)
  {
    do
    {
      uint64_t v12 = v11;
      uint64_t v11 = (const void **)v11[1];
    }
    while (v11);
  }
  else
  {
    unint64_t v16 = a2;
    do
    {
      uint64_t v12 = (const void **)v16[2];
      BOOL v17 = *v12 == v16;
      unint64_t v16 = (uint64_t *)v12;
    }
    while (v17);
  }
  if (sub_21677B108((uint64_t)(a1 + 2), v12 + 4, a5)) {
    goto LABEL_16;
  }
LABEL_28:

  return (const void **)sub_21677B220((uint64_t)a1, a3, a5);
}

char *sub_216789BF8@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  BOOL result = sub_216789C64(v6 + 32, a2);
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_216789C4C(_Unwind_Exception *a1)
{
  sub_21677B548(v1, 0);
  _Unwind_Resume(a1);
}

char *sub_216789C64(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_216778F24(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  uint64_t v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_216778F24(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)uint64_t v5 = v6;
  }
  return __dst;
}

void sub_216789CE0(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216789CFC(uint64_t a1)
{
  sub_216789D38(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_216789D38(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      long long v4 = (std::__shared_weak_count *)v2[7];
      if (v4) {
        sub_216784EC4(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void *sub_216789D80(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v7 = *(void *)(a2 + 16);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = *(void *)(a2 + 16);
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v7)
          {
            if (sub_216789FF0((uint64_t)(v13 + 2), a2)) {
              return v13;
            }
          }
          else
          {
            if (v11 > 1)
            {
              if (v14 >= v8) {
                v14 %= v8;
              }
            }
            else
            {
              v14 &= v8 - 1;
            }
            if (v14 != v4) {
              break;
            }
          }
          uint64_t v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
  uint64_t v15 = (void *)(a1 + 16);
  uint64_t v13 = operator new(0x40uLL);
  *uint64_t v13 = 0;
  v13[1] = v7;
  unint64_t v16 = *a4;
  *((_OWORD *)v13 + 1) = **a4;
  void v13[4] = *((void *)v16 + 2);
  v13[5] = *((void *)v16 + 3);
  v13[6] = 0;
  v13[7] = 0;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    BOOL v19 = 1;
    if (v8 >= 3) {
      BOOL v19 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v8);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_21678A04C(a1, v22);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    *uint64_t v13 = *v24;
LABEL_38:
    *uint64_t v24 = v13;
    goto LABEL_39;
  }
  *uint64_t v13 = *v15;
  *uint64_t v15 = v13;
  *(void *)(v23 + 8 * v4) = v15;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v25 >= v8) {
        v25 %= v8;
      }
    }
    else
    {
      v25 &= v8 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_216789FD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  sub_21678A298(v11, v10);
  _Unwind_Resume(a1);
}

BOOL sub_216789FF0(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2
      && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8)
      && *(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 12)
      && *(void *)(a1 + 16) == *(void *)(a2 + 16)
      && *(void *)(a1 + 24) == *(void *)(a2 + 24);
}

void sub_21678A04C(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      sub_21678A13C(a1, prime);
    }
  }
}

void sub_21678A13C(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_21677CA1C();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      uint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *uint64_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint8x8_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void sub_21678A298(uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = (std::__shared_weak_count *)__p[7];
    if (v3) {
      sub_216784EC4(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_21678A2F4(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_216789D38(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void *sub_21678A34C(void *a1, uint64_t a2)
{
  *a1 = a2;
  int8x8_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7488E8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  uint64_t v6 = 0;
  sub_21678A4FC(&v6, 0);
  return a1;
}

void sub_21678A3C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_21678A4FC((char ***)va, 0);
  _Unwind_Resume(a1);
}

void sub_21678A3DC(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21678A404(uint64_t a1)
{
}

uint64_t sub_21678A40C(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748938)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_21678A450(uint64_t a1, char **a2)
{
  if (a2)
  {
    sub_21678A498((uint64_t)a2, a2[1]);
    operator delete(a2);
  }
}

void sub_21678A498(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_21678A498(a1, *(void *)a2);
    sub_21678A498(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

void sub_21678A4FC(char ***a1, char **a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    sub_21678A498((uint64_t)v2, v2[1]);
    operator delete(v2);
  }
}

void *sub_21678A550(void *a1, void *a2)
{
  *a1 = a2;
  int8x8_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748960;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  sub_216787B18((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_21678A5B8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    uint64_t v3 = (void *)sub_216792ED4(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678A5D8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21678A600(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = (void *)sub_216792ED4(v1);
    operator delete(v2);
  }
}

uint64_t sub_21678A638(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7489B0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21678A67C(void *a1, uint64_t a2)
{
  *a1 = a2;
  int8x8_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7489D8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21678A6D4(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    Alembic::Ogawa::v12::OData::~OData(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678A6F4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21678A71C(uint64_t a1)
{
  uint64_t v1 = *(Alembic::Ogawa::v12::OData **)(a1 + 24);
  if (v1)
  {
    Alembic::Ogawa::v12::OData::~OData(v1);
    operator delete(v2);
  }
}

uint64_t sub_21678A754(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748A28)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21678A798(void *a1, uint64_t a2)
{
  *a1 = a2;
  int8x8_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748A50;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  uint64_t v6 = 0;
  sub_21678A8E4(&v6, 0);
  return a1;
}

void sub_21678A80C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_21678A8E4((void **)va, 0);
  _Unwind_Resume(a1);
}

void sub_21678A828(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21678A850(uint64_t a1)
{
}

uint64_t sub_21678A858(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748AA0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_21678A89C(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v3 = (std::__shared_weak_count *)__p[5];
    if (v3) {
      sub_216784EC4(v3);
    }
    operator delete(__p);
  }
}

void sub_21678A8E4(void **a1, void *a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)v2[5];
    if (v3) {
      sub_216784EC4(v3);
    }
    operator delete(v2);
  }
}

uint64_t *sub_21678A938(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  int8x8_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748AC8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    unint64_t v5 = (void *)(a2 + 8);
  }
  else {
    unint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21678A9A8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323B44(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678A9C4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21678A9EC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21678AA1C(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748B18)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_21678AA60(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = a1 + 48;
  uint64_t v6 = (uint64_t **)(a1 + 40);
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 32) = 0;
  uint64_t v7 = *(Alembic::Ogawa::v12::IGroup **)a2;
  if (!*(void *)a2)
  {
    sub_216778A5C((uint64_t)&v41);
    sub_216779180(v43, (uint64_t)"invalid compound data group", 27);
    std::stringbuf::str();
    sub_216778E70(v40, (long long *)__p);
    if (v39 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    long long v35 = sub_216779038(exception, (uint64_t)v40);
    __cxa_throw(v35, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v11 = *(void *)(a2 + 8);
  if (v11)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    unint64_t v12 = *(std::__shared_weak_count **)(a1 + 24);
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = v11;
    if (v12)
    {
      sub_216784EC4(v12);
      uint64_t v7 = *(Alembic::Ogawa::v12::IGroup **)(a1 + 16);
    }
  }
  else
  {
    *(void *)(a1 + 16) = v7;
    *(void *)(a1 + 24) = 0;
  }
  uint64_t NumChildren = Alembic::Ogawa::v12::IGroup::getNumChildren(v7);
  if (NumChildren)
  {
    unint64_t v14 = NumChildren - 1;
    if (Alembic::Ogawa::v12::IGroup::isChildData(*(Alembic::Ogawa::v12::IGroup **)(a1 + 16), NumChildren - 1))
    {
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      v43[0] = 0;
      uint64_t v15 = *(std::__shared_weak_count **)(a1 + 24);
      uint64_t v36 = *(unint64_t ***)(a1 + 16);
      unint64_t v37 = v15;
      if (v15) {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_216798F58(&v36, v14, a3, a4, a5, &v41);
      if (v37) {
        sub_216784EC4(v37);
      }
      uint64_t v17 = v41;
      uint64_t v16 = v42;
      unint64_t v18 = (v42 - v41) >> 4;
      if (is_mul_ok(v18, 0x60uLL)) {
        size_t v19 = (96 * ((v42 - v41) >> 4)) | 0x10;
      }
      else {
        size_t v19 = -1;
      }
      unint64_t v20 = operator new[](v19);
      void *v20 = 96;
      v20[1] = v18;
      unint64_t v21 = v20 + 2;
      if (v16 == v17)
      {
        *(void *)(a1 + 32) = v21;
      }
      else
      {
        unint64_t v22 = 0;
        uint64_t v23 = 96 * v18;
        do
        {
          uint64_t v24 = &v20[v22 / 8];
          *((_OWORD *)v24 + 1) = 0u;
          *((_OWORD *)v24 + 2) = 0u;
          pthread_mutex_init((pthread_mutex_t *)&v20[v22 / 8 + 6], 0);
          v22 += 96;
        }
        while (v23 != v22);
        uint64_t v25 = v41;
        uint64_t v26 = v42;
        *(void *)(a1 + 32) = v21;
        if (v26 != v25)
        {
          unint64_t v27 = 0;
          do
          {
            __p[0] = *(void **)(v25 + 16 * v27);
            sub_21678C138(v6, (const void **)__p[0], (uint64_t)&unk_217408524, (long long **)__p)[7] = v27;
            uint64_t v28 = *(void *)(a1 + 32);
            long long v29 = *(_OWORD *)(v41 + 16 * v27);
            uint64_t v30 = *(void *)(v41 + 16 * v27 + 8);
            if (v30) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v30 + 8), 1uLL, memory_order_relaxed);
            }
            uint64_t v31 = v28 + 96 * v27;
            unsigned __int8 v32 = *(std::__shared_weak_count **)(v31 + 8);
            *(_OWORD *)uint64_t v31 = v29;
            if (v32) {
              sub_216784EC4(v32);
            }
            ++v27;
            uint64_t v25 = v41;
          }
          while (v27 < (v42 - v41) >> 4);
        }
      }
      v40[0] = (void **)&v41;
      sub_216787968(v40);
    }
  }
  return a1;
}

void sub_21678AD0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  sub_21678A498(v8, *(char **)(v7 + 48));
  uint8x8_t v10 = *(std::__shared_weak_count **)(v7 + 24);
  if (v10) {
    sub_216784EC4(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(v7 + 8);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_21678ADBC(uint64_t a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_216784EC4(v3);
  }
  return a1;
}

uint64_t sub_21678AE08(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 96 * v3;
      do
      {
        pthread_mutex_destroy((pthread_mutex_t *)(v2 + v4 - 64));
        unint64_t v5 = *(std::__shared_weak_count **)(v2 + v4 - 72);
        if (v5) {
          std::__shared_weak_count::__release_weak(v5);
        }
        uint64_t v6 = *(std::__shared_weak_count **)(v2 + v4 - 88);
        if (v6) {
          sub_216784EC4(v6);
        }
        v4 -= 96;
      }
      while (v4);
    }
    operator delete[]((void *)(v2 - 16));
  }
  sub_21678A498(a1 + 40, *(char **)(a1 + 48));
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 24);
  if (v7) {
    sub_216784EC4(v7);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 8);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  return a1;
}

uint64_t sub_21678AEB0(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_21678AEB8(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a1 + 56) < a3)
  {
    sub_216778A5C((uint64_t)v10);
    uint64_t v4 = sub_216779180(v11, (uint64_t)"Out of range index in ", 22);
    sub_216779180(v4, (uint64_t)"CprData::getPropertyHeader: ", 28);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v9, &__p);
    if (v8 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v6 = sub_216779038(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return *(void *)(*(void *)(a1 + 32) + 96 * a3);
}

void sub_21678AF90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_21678AFB8(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v5 = sub_21678C2D8(a1 + 40, a3);
  if (a1 + 48 == v5) {
    return 0;
  }
  std::exception v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = sub_21678AEB8(a1, v6, *(void *)(v5 + 56));
  if (v7) {
    sub_216784EC4(v7);
  }
  return v8;
}

void sub_21678B030(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_21678B048@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t result = sub_21678C2D8(a1 + 40, (const void **)a3);
  if (a1 + 48 == result)
  {
    *a4 = 0;
    a4[1] = 0;
    return result;
  }
  uint64_t v9 = result;
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(result + 56);
  std::exception v12 = (void *)(v10 + 96 * v11);
  if (*(_DWORD *)(*v12 + 24) != 1)
  {
    sub_216778A5C((uint64_t)&lpsrc);
    uint64_t v31 = sub_216779180(v57, (uint64_t)"Tried to read a scalar property from a non-scalar: ", 51);
    int v32 = *(char *)(a3 + 23);
    if (v32 >= 0) {
      uint64_t v33 = (const void *)a3;
    }
    else {
      uint64_t v33 = *(const void **)a3;
    }
    if (v32 >= 0) {
      uint64_t v34 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v34 = *(void *)(a3 + 8);
    }
    long long v35 = sub_216779180(v31, (uint64_t)v33, v34);
    sub_216779180(v35, (uint64_t)", type: ", 8);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(&v53, (long long *)__p);
    if (v52 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v37 = sub_216779038(exception, (uint64_t)&v53);
    __cxa_throw(v37, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = v10 + 96 * v11;
  uint64_t v40 = (pthread_mutex_t *)(v13 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 32));
  uint64_t v16 = *(std::__shared_weak_count **)(v13 + 24);
  uint64_t v15 = (std::__shared_weak_count **)(v13 + 24);
  uint64_t v14 = v16;
  uint64_t v17 = (void **)(v15 - 1);
  if (v16)
  {
    unint64_t v18 = std::__shared_weak_count::lock(v14);
    size_t v19 = v18;
    if (v18)
    {
      unint64_t v20 = *v17;
      unint64_t v21 = v18;
      if (*v17) {
        goto LABEL_45;
      }
    }
  }
  else
  {
    size_t v19 = 0;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 24))(&v53);
  (*(void (**)(void **__return_ptr))(*(void *)v53 + 24))(&lpsrc);
  unint64_t v22 = lpsrc;
  if (lpsrc
  {
    uint64_t v23 = v56;
    if (v56) {
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  sub_216787674((uint64_t)v22, &v49);
  if (v23) {
    sub_216784EC4(v23);
  }
  if (v56) {
    sub_216784EC4(v56);
  }
  if (v54) {
    sub_216784EC4(v54);
  }
  Alembic::Ogawa::v12::IGroup::getGroup(*(unint64_t ***)(a1 + 16), *(void *)(v9 + 56), 1, *(void *)(v49 + 8), &v47);
  uint64_t v24 = v47;
  if (!v47)
  {
    sub_216778A5C((uint64_t)&lpsrc);
    sub_216779180(v57, (uint64_t)"Scalar Property not backed by a valid group.", 44);
    std::stringbuf::str();
    sub_216778E70(&v53, (long long *)__p);
    if (v52 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v38 = __cxa_allocate_exception(0x20uLL);
    char v39 = sub_216779038(v38, (uint64_t)&v53);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v25 = operator new(0x48uLL);
  uint64_t v26 = (uint64_t)v25;
  unint64_t v27 = (std::__shared_weak_count *)a2[1];
  uint64_t v45 = *a2;
  int v46 = v27;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v43 = v24;
  uint64_t v44 = v48;
  if (v48) {
    atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v41 = *v12;
  uint64_t v28 = (std::__shared_weak_count *)v12[1];
  uint64_t v42 = v28;
  if (v28) {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_21679B004(v25, &v45, &v43, &v41);
  sub_21678C368((uint64_t *)&lpsrc, v26);
  unint64_t v20 = lpsrc;
  unint64_t v21 = v56;
  lpsrc = 0;
  uint64_t v56 = 0;
  if (v19)
  {
    sub_216784EC4(v19);
    if (v56) {
      sub_216784EC4(v56);
    }
  }
  if (v42) {
    sub_216784EC4(v42);
  }
  if (v44) {
    sub_216784EC4(v44);
  }
  if (v46) {
    sub_216784EC4(v46);
  }
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  std::__shared_weak_count *v17 = v20;
  long long v29 = *v15;
  *uint64_t v15 = v21;
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  if (v48) {
    sub_216784EC4(v48);
  }
  if (v50) {
    sub_216784EC4(v50);
  }
  if (!v20)
  {
LABEL_48:
    *a4 = 0;
    a4[1] = 0;
    if (v21) {
      goto LABEL_49;
    }
    return pthread_mutex_unlock(v40);
  }
LABEL_45:
  if (!v30) {
    goto LABEL_48;
  }
  *a4 = v30;
  a4[1] = v21;
  if (v21)
  {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_49:
    sub_216784EC4(v21);
  }
  return pthread_mutex_unlock(v40);
}

void sub_21678B4E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, pthread_mutex_t *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::exception a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28)
{
}

uint64_t sub_21678B5E4@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t result = sub_21678C2D8(a1 + 40, (const void **)a3);
  if (a1 + 48 == result)
  {
    *a4 = 0;
    a4[1] = 0;
    return result;
  }
  uint64_t v9 = result;
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(result + 56);
  std::exception v12 = (void *)(v10 + 96 * v11);
  if (*(_DWORD *)(*v12 + 24) != 2)
  {
    sub_216778A5C((uint64_t)&lpsrc);
    uint64_t v31 = sub_216779180(v57, (uint64_t)"Tried to read an array property from a non-array: ", 50);
    int v32 = *(char *)(a3 + 23);
    if (v32 >= 0) {
      uint64_t v33 = (const void *)a3;
    }
    else {
      uint64_t v33 = *(const void **)a3;
    }
    if (v32 >= 0) {
      uint64_t v34 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v34 = *(void *)(a3 + 8);
    }
    long long v35 = sub_216779180(v31, (uint64_t)v33, v34);
    sub_216779180(v35, (uint64_t)", type: ", 8);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(&v53, (long long *)__p);
    if (v52 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v37 = sub_216779038(exception, (uint64_t)&v53);
    __cxa_throw(v37, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = v10 + 96 * v11;
  uint64_t v40 = (pthread_mutex_t *)(v13 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 32));
  uint64_t v16 = *(std::__shared_weak_count **)(v13 + 24);
  uint64_t v15 = (std::__shared_weak_count **)(v13 + 24);
  uint64_t v14 = v16;
  uint64_t v17 = (void **)(v15 - 1);
  if (v16)
  {
    unint64_t v18 = std::__shared_weak_count::lock(v14);
    size_t v19 = v18;
    if (v18)
    {
      unint64_t v20 = *v17;
      unint64_t v21 = v18;
      if (*v17) {
        goto LABEL_45;
      }
    }
  }
  else
  {
    size_t v19 = 0;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 24))(&v53);
  (*(void (**)(void **__return_ptr))(*(void *)v53 + 24))(&lpsrc);
  unint64_t v22 = lpsrc;
  if (lpsrc
  {
    uint64_t v23 = v56;
    if (v56) {
      atomic_fetch_add_explicit(&v56->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v23 = 0;
  }
  sub_216787674((uint64_t)v22, &v49);
  if (v23) {
    sub_216784EC4(v23);
  }
  if (v56) {
    sub_216784EC4(v56);
  }
  if (v54) {
    sub_216784EC4(v54);
  }
  Alembic::Ogawa::v12::IGroup::getGroup(*(unint64_t ***)(a1 + 16), *(void *)(v9 + 56), 1, *(void *)(v49 + 8), &v47);
  uint64_t v24 = v47;
  if (!v47)
  {
    sub_216778A5C((uint64_t)&lpsrc);
    sub_216779180(v57, (uint64_t)"Array Property not backed by a valid group.", 43);
    std::stringbuf::str();
    sub_216778E70(&v53, (long long *)__p);
    if (v52 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v38 = __cxa_allocate_exception(0x20uLL);
    char v39 = sub_216779038(v38, (uint64_t)&v53);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v25 = operator new(0x48uLL);
  uint64_t v26 = (uint64_t)v25;
  unint64_t v27 = (std::__shared_weak_count *)a2[1];
  uint64_t v45 = *a2;
  int v46 = v27;
  if (v27) {
    atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v43 = v24;
  uint64_t v44 = v48;
  if (v48) {
    atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v41 = *v12;
  uint64_t v28 = (std::__shared_weak_count *)v12[1];
  uint64_t v42 = v28;
  if (v28) {
    atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216784120(v25, &v45, &v43, &v41);
  sub_21678C490((uint64_t *)&lpsrc, v26);
  unint64_t v20 = lpsrc;
  unint64_t v21 = v56;
  lpsrc = 0;
  uint64_t v56 = 0;
  if (v19)
  {
    sub_216784EC4(v19);
    if (v56) {
      sub_216784EC4(v56);
    }
  }
  if (v42) {
    sub_216784EC4(v42);
  }
  if (v44) {
    sub_216784EC4(v44);
  }
  if (v46) {
    sub_216784EC4(v46);
  }
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  std::__shared_weak_count *v17 = v20;
  long long v29 = *v15;
  *uint64_t v15 = v21;
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  if (v48) {
    sub_216784EC4(v48);
  }
  if (v50) {
    sub_216784EC4(v50);
  }
  if (!v20)
  {
LABEL_48:
    *a4 = 0;
    a4[1] = 0;
    if (v21) {
      goto LABEL_49;
    }
    return pthread_mutex_unlock(v40);
  }
LABEL_45:
  if (!v30) {
    goto LABEL_48;
  }
  *a4 = v30;
  a4[1] = v21;
  if (v21)
  {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_49:
    sub_216784EC4(v21);
  }
  return pthread_mutex_unlock(v40);
}

void sub_21678BA7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, pthread_mutex_t *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::exception a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28)
{
}

uint64_t sub_21678BB80@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t result = sub_21678C2D8(a1 + 40, (const void **)a3);
  if (a1 + 48 == result)
  {
    *a4 = 0;
    a4[1] = 0;
    return result;
  }
  uint64_t v9 = result;
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(result + 56);
  std::exception v12 = (void *)(v10 + 96 * v11);
  if (*(_DWORD *)(*v12 + 24))
  {
    sub_216778A5C((uint64_t)&lpsrc);
    uint64_t v31 = sub_216779180(v58, (uint64_t)"Tried to read a compound property from a non-compound: ", 55);
    int v32 = *(char *)(a3 + 23);
    if (v32 >= 0) {
      uint64_t v33 = (const void *)a3;
    }
    else {
      uint64_t v33 = *(const void **)a3;
    }
    if (v32 >= 0) {
      uint64_t v34 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v34 = *(void *)(a3 + 8);
    }
    long long v35 = sub_216779180(v31, (uint64_t)v33, v34);
    sub_216779180(v35, (uint64_t)", type: ", 8);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(&v54, (long long *)__p);
    if (v53 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v37 = sub_216779038(exception, (uint64_t)&v54);
    __cxa_throw(v37, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = v10 + 96 * v11;
  uint64_t v41 = (pthread_mutex_t *)(v13 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v13 + 32));
  uint64_t v16 = *(std::__shared_weak_count **)(v13 + 24);
  uint64_t v15 = (std::__shared_weak_count **)(v13 + 24);
  uint64_t v14 = v16;
  uint64_t v17 = (void **)(v15 - 1);
  if (v16)
  {
    unint64_t v18 = std::__shared_weak_count::lock(v14);
    size_t v19 = v18;
    if (v18)
    {
      unint64_t v20 = *v17;
      unint64_t v21 = v18;
      if (*v17) {
        goto LABEL_46;
      }
    }
  }
  else
  {
    size_t v19 = 0;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 24))(&v54);
  (*(void (**)(void **__return_ptr))(*(void *)v54 + 24))(&lpsrc);
  if (lpsrc)
  {
    if (v22 && v57)
    {
      uint64_t v40 = v57;
      atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
      goto LABEL_15;
    }
  }
  else
  {
    unint64_t v22 = 0;
  }
  uint64_t v40 = 0;
LABEL_15:
  if (v57) {
    sub_216784EC4(v57);
  }
  if (v55) {
    sub_216784EC4(v55);
  }
  sub_216787674((uint64_t)v22, &v50);
  Alembic::Ogawa::v12::IGroup::getGroup(*(unint64_t ***)(a1 + 16), *(void *)(v9 + 56), 0, *(void *)(v50 + 8), &v48);
  uint64_t v23 = v48;
  if (!v48)
  {
    sub_216778A5C((uint64_t)&lpsrc);
    sub_216779180(v58, (uint64_t)"Compound Property not backed by a valid group.", 46);
    std::stringbuf::str();
    sub_216778E70(&v54, (long long *)__p);
    if (v53 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v38 = __cxa_allocate_exception(0x20uLL);
    char v39 = sub_216779038(v38, (uint64_t)&v54);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v24 = operator new(0x58uLL);
  uint64_t v25 = (std::__shared_weak_count *)a2[1];
  uint64_t v46 = *a2;
  uint64_t v47 = v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v44 = v23;
  uint64_t v45 = v49;
  if (v49) {
    atomic_fetch_add_explicit(&v49->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v42 = *v12;
  uint64_t v26 = (std::__shared_weak_count *)v12[1];
  uint64_t v43 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v27 = *(void *)(v50 + 8);
  uint64_t v28 = (void *)sub_216787780((uint64_t)v22);
  sub_21678CBFC((uint64_t)v24, &v46, &v44, &v42, v27, v28);
  sub_21678C5B8((uint64_t *)&lpsrc, (uint64_t)v24);
  unint64_t v20 = lpsrc;
  unint64_t v21 = v57;
  lpsrc = 0;
  uint64_t v57 = 0;
  if (v19)
  {
    sub_216784EC4(v19);
    if (v57) {
      sub_216784EC4(v57);
    }
  }
  if (v43) {
    sub_216784EC4(v43);
  }
  if (v45) {
    sub_216784EC4(v45);
  }
  if (v47) {
    sub_216784EC4(v47);
  }
  if (v21) {
    atomic_fetch_add_explicit(&v21->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  std::__shared_weak_count *v17 = v20;
  long long v29 = *v15;
  *uint64_t v15 = v21;
  if (v29) {
    std::__shared_weak_count::__release_weak(v29);
  }
  if (v49) {
    sub_216784EC4(v49);
  }
  if (v51) {
    sub_216784EC4(v51);
  }
  if (v40) {
    sub_216784EC4(v40);
  }
  if (!v20)
  {
LABEL_49:
    *a4 = 0;
    a4[1] = 0;
    if (v21) {
      goto LABEL_50;
    }
    return pthread_mutex_unlock(v41);
  }
LABEL_46:
  if (!v30) {
    goto LABEL_49;
  }
  *a4 = v30;
  a4[1] = v21;
  if (v21)
  {
    atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_50:
    sub_216784EC4(v21);
  }
  return pthread_mutex_unlock(v41);
}

void sub_21678C03C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, pthread_mutex_t *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,std::exception a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t *sub_21678C138(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v6 = (uint64_t **)sub_21677B220((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_21678C1D0((uint64_t)a1, a4, (uint64_t)&v8);
    sub_21677B358(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

unsigned char *sub_21678C1D0@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_216778F24(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  *((void *)v6 + 7) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_21678C25C(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_21678C278(v3, v2);
  _Unwind_Resume(a1);
}

void sub_21678C278(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t sub_21678C2D8(uint64_t a1, const void **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = sub_21677B108(v5, (const void **)(v3 + 32), a2);
    uint64_t v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      uint64_t v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || sub_21677B108(v5, a2, (const void **)(v6 + 32))) {
    return v2;
  }
  return v6;
}

uint64_t *sub_21678C368(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748B40;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21678C3D8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323BC8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678C3F4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21678C41C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21678C44C(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748B90)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t *sub_21678C490(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748BB8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21678C500(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323BC8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678C51C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21678C544(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21678C574(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748C08)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t *sub_21678C5B8(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748C30;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21678C628(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323BC8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678C644(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21678C66C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21678C69C(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748C80)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_21678C6E0(uint64_t a1, void *a2, uint64_t *a3, void *a4, unint64_t a5, void *a6)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C748CA8;
  *(void *)(a1 + 24) = *a2;
  uint64_t v10 = a2[1];
  *(void *)(a1 + 32) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 40) = *a4;
  uint64_t v11 = a4[1];
  *(void *)(a1 + 48) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 56) = 0u;
  uint64_t v12 = a1 + 56;
  *(_OWORD *)(a1 + 72) = 0u;
  uint64_t v13 = *(void *)(a1 + 24);
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v36);
    sub_216779180(v38, (uint64_t)"Invalid parent in CprImpl(Compound)", 35);
    std::stringbuf::str();
    sub_216778E70(v35, (long long *)__p);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v22 = sub_216779038(exception, (uint64_t)v35);
    __cxa_throw(v22, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v14 = *(void *)(a1 + 40);
  if (!v14)
  {
    sub_216778A5C((uint64_t)&v36);
    sub_216779180(v38, (uint64_t)"invalid header in CprImpl(Compound)", 35);
    std::stringbuf::str();
    sub_216778E70(v35, (long long *)__p);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v23 = __cxa_allocate_exception(0x20uLL);
    uint64_t v24 = sub_216779038(v23, (uint64_t)v35);
    __cxa_throw(v24, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*(_DWORD *)(v14 + 24))
  {
    sub_216778A5C((uint64_t)&v36);
    sub_216779180(v38, (uint64_t)"Tried to create compound property with the wrong property type: ", 64);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v35, (long long *)__p);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v25 = __cxa_allocate_exception(0x20uLL);
    uint64_t v26 = sub_216779038(v25, (uint64_t)v35);
    __cxa_throw(v26, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v13 + 24))(&v31);
  uint64_t v15 = v31;
  if (!v31)
  {
    sub_216778A5C((uint64_t)&v36);
    sub_216779180(v38, (uint64_t)"Invalid object in CprImpl::CprImpl(Compound)", 44);
    std::stringbuf::str();
    sub_216778E70(v35, (long long *)__p);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v27 = __cxa_allocate_exception(0x20uLL);
    uint64_t v28 = sub_216779038(v27, (uint64_t)v35);
    __cxa_throw(v28, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v16 = v32;
  if (v32) {
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 64);
  *(void *)(a1 + 56) = v15;
  *(void *)(a1 + 64) = v16;
  if (v17) {
    sub_216784EC4(v17);
  }
  unint64_t v18 = operator new(0x40uLL);
  size_t v19 = (std::__shared_weak_count *)a3[1];
  uint64_t v29 = *a3;
  uint64_t v30 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)v12 + 24))(&v36);
  sub_21678AE04((uint64_t)v18, (uint64_t)&v29, a5, v36, a6);
  sub_21678CBB4((void *)(a1 + 72), v18);
  if (v37) {
    sub_216784EC4(v37);
  }
  if (v30) {
    sub_216784EC4(v30);
  }
  if (v32) {
    sub_216784EC4(v32);
  }
  return a1;
}

void sub_21678CAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  v15.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v10 = (std::__shared_weak_count *)*((void *)v8 + 10);
  if (v10) {
    sub_216784EC4(v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)v8 + 8);
  if (v11) {
    sub_216784EC4(v11);
  }
  uint64_t v12 = (std::__shared_weak_count *)*((void *)v8 + 6);
  if (v12) {
    sub_216784EC4(v12);
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)v8 + 4);
  if (v13) {
    sub_216784EC4(v13);
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)v8 + 2);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader(v8);
  _Unwind_Resume(a1);
}

void sub_21678CBB4(void *a1, void *a2)
{
  sub_21678D49C(&v5, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v5;
  *(void *)&long long v5 = *a1;
  *((void *)&v5 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_216784EC4(v3);
  }
}

uint64_t sub_21678CC00(uint64_t a1, void *a2, void *a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  long long v4 = (void *)(a1 + 40);
  *(void *)a1 = &unk_26C748CA8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 56) = *a2;
  uint64_t v5 = a2[1];
  *(void *)(a1 + 64) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = *a3;
  uint64_t v6 = a3[1];
  *(void *)(a1 + 80) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(void *)(a1 + 56);
  if (!v7)
  {
    sub_216778A5C((uint64_t)&__p);
    sub_216779180(v19, (uint64_t)"Invalid object in CprImpl(Object)", 33);
    std::stringbuf::str();
    sub_216778E70(v17, (long long *)v15);
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v12 = sub_216779038(exception, (uint64_t)v17);
    __cxa_throw(v12, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!*(void *)(a1 + 72))
  {
    sub_216778A5C((uint64_t)&__p);
    sub_216779180(v19, (uint64_t)"Invalid data in CprImpl(Object)", 31);
    std::stringbuf::str();
    sub_216778E70(v17, (long long *)v15);
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    uint64_t v13 = __cxa_allocate_exception(0x20uLL);
    uint64_t v14 = sub_216779038(v13, (uint64_t)v17);
    __cxa_throw(v14, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  long long __p = 0uLL;
  v19[0] = 0;
  uint64_t v8 = (char *)operator new(0x68uLL);
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
  sub_21678D40C(v8, &__p, (const void ***)(v9 + 48));
  *((_WORD *)v8 + 40) = 257;
  *(void *)(v8 + 92) = 0;
  *(void *)(v8 + 84) = 0;
  sub_21678CED8(v4, (uint64_t)v8);
  if (SHIBYTE(v19[0]) < 0) {
    operator delete((void *)__p);
  }
  return a1;
}

void sub_21678CE2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_216779148(&a12);
  sub_216778D38((uint64_t)&__p);
  uint64_t v23 = (std::__shared_weak_count *)*((void *)v21 + 10);
  if (v23) {
    sub_216784EC4(v23);
  }
  uint64_t v24 = (std::__shared_weak_count *)*((void *)v21 + 8);
  if (v24) {
    sub_216784EC4(v24);
  }
  uint64_t v25 = (std::__shared_weak_count *)*((void *)v21 + 6);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v26 = (std::__shared_weak_count *)*((void *)v21 + 4);
  if (v26) {
    sub_216784EC4(v26);
  }
  unint64_t v27 = (std::__shared_weak_count *)*((void *)v21 + 2);
  if (v27) {
    std::__shared_weak_count::__release_weak(v27);
  }
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader(v21);
  _Unwind_Resume(a1);
}

void sub_21678CED8(void *a1, uint64_t a2)
{
  sub_21678D5C8(&v5, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v5;
  *(void *)&long long v5 = *a1;
  *((void *)&v5 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_216784EC4(v3);
  }
}

void sub_21678CF24(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *this)
{
  *(void *)this = &unk_26C748CA8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v2) {
    sub_216784EC4(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v3) {
    sub_216784EC4(v3);
  }
  long long v4 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v4) {
    sub_216784EC4(v4);
  }
  long long v5 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v5) {
    sub_216784EC4(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }

  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader(this);
}

void sub_21678CFB4(Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *a1)
{
  sub_21678CF24(a1);

  operator delete(v1);
}

uint64_t sub_21678CFDC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (!result)
  {
    sub_216778A5C((uint64_t)v7);
    sub_216779180(v8, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_216778E70(v6, &__p);
    if (v5 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v3 = sub_216779038(exception, (uint64_t)v6);
    __cxa_throw(v3, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_21678D080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_21678D0A8@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 64);
  *a2 = *(void *)(result + 56);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_21678D0C4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *a2 = *(void *)(result + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

double sub_21678D0E0@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_21678D11C(uint64_t a1)
{
  return sub_21678AEB0(*(void *)(a1 + 72));
}

uint64_t sub_21678D124(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v6);
  uint64_t v4 = sub_21678AEB8(v3, (uint64_t)&v6, a2);
  if (v7) {
    sub_216784EC4(v7);
  }
  return v4;
}

void sub_21678D19C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_21678D1B4(void *a1, const void **a2)
{
  uint64_t v3 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v6);
  uint64_t v4 = sub_21678AFB8(v3, (uint64_t)&v6, a2);
  if (v7) {
    sub_216784EC4(v7);
  }
  return v4;
}

void sub_21678D22C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678D244(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v6);
  sub_21678B048(v5, &v6, a2, a3);
  if (v7) {
    sub_216784EC4(v7);
  }
}

void sub_21678D2C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678D2DC(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v6);
  sub_21678B5E4(v5, &v6, a2, a3);
  if (v7) {
    sub_216784EC4(v7);
  }
}

void sub_21678D35C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678D374(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v6);
  sub_21678BB80(v5, &v6, a2, a3);
  if (v7) {
    sub_216784EC4(v7);
  }
}

void sub_21678D3F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_21678D40C(void *__dst, long long *a2, const void ***a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_216778F24(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }
  *((_DWORD *)__dst + 6) = 0;
  sub_2167898D0(__dst + 4, a3);
  *((_DWORD *)__dst + 14) = 127;
  *((unsigned char *)__dst + 60) = 0;
  __dst[8] = 0;
  __dst[9] = 0;
  return __dst;
}

void sub_21678D480(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_21678D49C(void *a1, void *a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748D70;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  sub_216787B18((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_21678D504(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    uint64_t v3 = (void *)sub_21678AEAC(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678D524(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21678D54C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = (void *)sub_21678AEAC(v1);
    operator delete(v2);
  }
}

uint64_t sub_21678D584(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748DC0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21678D5C8(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748DE8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21678D628(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_21678D6C0((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678D64C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21678D674(uint64_t a1)
{
}

uint64_t sub_21678D67C(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748E38)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_21678D6C0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a2 + 72);
    if (v3) {
      sub_216784EC4(v3);
    }
    sub_2167877AC(a2 + 32, *(void **)(a2 + 40));
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    operator delete((void *)a2);
  }
}

void *sub_21678D724(void *result, void *a2)
{
  *double result = 0;
  result[1] = 0;
  uint64_t v2 = a2[1];
  result[2] = *a2;
  result[3] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  result[4] = 0;
  result[5] = 0;
  result[8] = 0;
  result[9] = 0;
  result[10] = 0;
  result[6] = 0;
  result[7] = result + 8;
  result[11] = 0;
  result[12] = 0;
  return result;
}

uint64_t sub_21678D75C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(void *)(a1 + 88) = v2;
    operator delete(v2);
  }
  sub_21678F14C(a1 + 56, *(void **)(a1 + 64));
  uint64_t v6 = (void **)(a1 + 32);
  sub_216787968(&v6);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3) {
    sub_216784EC4(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

uint64_t sub_21678D7D0(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4;
}

uint64_t sub_21678D7E0(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2 > (*(void *)(a1 + 40) - v2) >> 4)
  {
    sub_216778A5C((uint64_t)v15);
    uint64_t v7 = sub_216779180(v16, (uint64_t)"Out of range index in ", 22);
    sub_216779180(v7, (uint64_t)"CpwImpl::getPropertyHeader: ", 28);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v14, (long long *)__p);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v9 = sub_216779038(exception, (uint64_t)v14);
    __cxa_throw(v9, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v3 = (uint64_t *)(v2 + 16 * a2);
  uint64_t v5 = *v3;
  uint64_t v4 = (std::__shared_weak_count *)v3[1];
  if (!v4)
  {
    if (v5) {
      return v5;
    }
LABEL_10:
    sub_216778A5C((uint64_t)v15);
    sub_216779180(v16, (uint64_t)"Invalid property header ptr in CpwImpl", 38);
    std::stringbuf::str();
    sub_216778E70(v14, (long long *)__p);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v10 = __cxa_allocate_exception(0x20uLL);
    uint64_t v11 = sub_216779038(v10, (uint64_t)v14);
    __cxa_throw(v11, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  if (!v5) {
    goto LABEL_10;
  }
  sub_216784EC4(v4);
  return v5;
}

void sub_21678D960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

const void **sub_21678D9C0(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v2 = *(const void ****)(a1 + 32);
  uint64_t v3 = *(const void ****)(a1 + 40);
  if (v2 != v3)
  {
    char v4 = *((unsigned char *)a2 + 23);
    if (v4 >= 0) {
      std::exception v5 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    }
    else {
      std::exception v5 = a2[1];
    }
    if (v4 >= 0) {
      uint64_t v6 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v6 = *a2;
    }
    do
    {
      uint64_t v7 = *v2;
      uint64_t v8 = *((unsigned __int8 *)*v2 + 23);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = (unsigned __int8 *)*((unsigned __int8 *)*v2 + 23);
      }
      else {
        uint64_t v9 = (unsigned __int8 *)(*v2)[1];
      }
      if (v9 == v5)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*v7, v6, (size_t)(*v2)[1])) {
            return v7;
          }
        }
        else
        {
          if (!*((unsigned char *)*v2 + 23)) {
            return v7;
          }
          uint64_t v10 = 0;
          while (*((unsigned __int8 *)v7 + v10) == v6[v10])
          {
            if (v8 == ++v10) {
              return v7;
            }
          }
        }
      }
      v2 += 2;
    }
    while (v2 != v3);
  }
  return 0;
}

void sub_21678DA80(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = sub_21678C2D8(a1 + 56, a2);
  if (a1 + 64 == v5 || (uint64_t v6 = *(std::__shared_weak_count **)(v5 + 64)) == 0)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    uint64_t v7 = *(void *)(v5 + 56);
    atomic_fetch_add_explicit(&v6->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    *a3 = 0;
    uint64_t v8 = std::__shared_weak_count::lock(v6);
    a3[1] = v8;
    if (v8) {
      *a3 = v7;
    }
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_21678DB18(uint64_t a1@<X0>, void *a2@<X1>, const void **a3@<X2>, const void ***a4@<X3>, uint64_t a5@<X4>, int a6@<W5>, _OWORD *a7@<X8>)
{
  uint64_t v14 = (uint64_t **)(a1 + 56);
  if (sub_21677B088(a1 + 56, a3))
  {
    sub_216778A5C((uint64_t)&v63);
    uint64_t v49 = sub_216779180(v65, (uint64_t)"Already have a property named: ", 31);
    int v50 = *((char *)a3 + 23);
    if (v50 >= 0) {
      uint64_t v51 = (uint64_t)a3;
    }
    else {
      uint64_t v51 = (uint64_t)*a3;
    }
    if (v50 >= 0) {
      uint64_t v52 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      uint64_t v52 = (uint64_t)a3[1];
    }
    sub_216779180(v49, v51, v52);
    std::stringbuf::str();
    sub_216778E70(v62, (long long *)__p);
    if (v61 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v54 = sub_216779038(exception, (uint64_t)v62);
    __cxa_throw(v54, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!*(unsigned char *)(a5 + 4) || (*(_DWORD *)a5 != 127 ? (BOOL v15 = *(_DWORD *)a5 == 14) : (BOOL v15 = 1), v15))
  {
    sub_216778A5C((uint64_t)&v63);
    sub_216779180(v65, (uint64_t)"createScalarProperty, illegal DataType provided.", 48);
    std::stringbuf::str();
    sub_216778E70(v62, (long long *)__p);
    if (v61 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v45 = __cxa_allocate_exception(0x20uLL);
    uint64_t v46 = sub_216779038(v45, (uint64_t)v62);
    __cxa_throw(v46, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*((char *)a3 + 23) < 0)
  {
    if (!a3[1]) {
      goto LABEL_70;
    }
  }
  else if (!*((unsigned char *)a3 + 23))
  {
LABEL_70:
    sub_216778A5C((uint64_t)&v63);
    sub_216779180(v65, (uint64_t)"Invalid name", 12);
    std::stringbuf::str();
    sub_216778E70(v62, (long long *)__p);
    if (v61 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v47 = __cxa_allocate_exception(0x20uLL);
    uint64_t v48 = sub_216779038(v47, (uint64_t)v62);
    __cxa_throw(v48, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (std::string::find((const std::string *)a3, 47, 0) != -1) {
    goto LABEL_70;
  }
  (*(void (**)(void **__return_ptr))(*(void *)*a2 + 24))(__p);
  (*(void (**)(long long *__return_ptr))(*(void *)__p[0] + 24))(v62);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)&v62[0] + 56))(&v63);
  if (*((void *)&v62[0] + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v62[0] + 1));
  }
  if (__p[1]) {
    sub_216784EC4((std::__shared_weak_count *)__p[1]);
  }
  char v16 = operator new(0x68uLL);
  sub_21678F090(v16, (long long *)a3, 1, a4, (void *)a5, &v63);
  v16[40] = 257;
  *((void *)v16 + 11) = 0;
  *((_DWORD *)v16 + 21) = 0;
  *((_DWORD *)v16 + 24) = a6;
  sub_21678D5C8(v62, (uint64_t)v16);
  uint64_t v17 = operator new(0x70uLL);
  uint64_t v18 = (std::__shared_weak_count *)a2[1];
  uint64_t v58 = *a2;
  char v59 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Ogawa::v12::OGroup::addGroup(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), &v56);
  long long v55 = v62[0];
  if (*((void *)&v62[0] + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v62[0] + 1) + 8), 1uLL, memory_order_relaxed);
  }
  sub_21679B95C(v17, &v58, &v56, &v55, (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4);
  sub_21678F1FC((uint64_t *)__p, (uint64_t)v17);
  if (*((void *)&v55 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v55 + 1));
  }
  if (v57) {
    sub_216784EC4(v57);
  }
  if (v59) {
    sub_216784EC4(v59);
  }
  sub_21678E1D4((uint64_t *)(a1 + 32), v62);
  unint64_t v20 = __p[0];
  uint64_t v19 = __p[1];
  if (__p[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 2, 1uLL, memory_order_relaxed);
  }
  uint64_t v66 = a3;
  unint64_t v21 = sub_21678F468(v14, a3, (uint64_t)&unk_217408C31, (long long **)&v66);
  unint64_t v22 = (std::__shared_weak_count *)v21[8];
  v21[7] = (uint64_t)v20;
  v21[8] = (uint64_t)v19;
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *(char **)(a1 + 96);
  uint64_t v24 = (void **)(a1 + 80);
  uint64_t v25 = *(char **)(a1 + 88);
  if (v25 >= v23)
  {
    unint64_t v27 = (char *)*v24;
    uint64_t v28 = (v25 - (unsigned char *)*v24) >> 3;
    unint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v30 = v23 - v27;
    if (v30 >> 2 > v29) {
      unint64_t v29 = v30 >> 2;
    }
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v31 = v29;
    }
    if (v31)
    {
      int v32 = (char *)sub_21677CB28(a1 + 96, v31);
      unint64_t v27 = *(char **)(a1 + 80);
      uint64_t v25 = *(char **)(a1 + 88);
    }
    else
    {
      int v32 = 0;
    }
    uint64_t v33 = &v32[8 * v28];
    uint64_t v23 = &v32[8 * v31];
    *(void *)uint64_t v33 = 0;
    uint64_t v26 = v33 + 8;
    while (v25 != v27)
    {
      uint64_t v34 = *((void *)v25 - 1);
      v25 -= 8;
      *((void *)v33 - 1) = v34;
      v33 -= 8;
    }
    *(void *)(a1 + 80) = v33;
    *(void *)(a1 + 88) = v26;
    *(void *)(a1 + 96) = v23;
    if (v27)
    {
      operator delete(v27);
      uint64_t v23 = *(char **)(a1 + 96);
    }
  }
  else
  {
    *(void *)uint64_t v25 = 0;
    uint64_t v26 = v25 + 8;
  }
  *(void *)(a1 + 88) = v26;
  if (v26 >= v23)
  {
    uint64_t v36 = (char *)*v24;
    uint64_t v37 = (v26 - (unsigned char *)*v24) >> 3;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v39 = v23 - v36;
    if (v39 >> 2 > v38) {
      unint64_t v38 = v39 >> 2;
    }
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v40 = v38;
    }
    if (v40)
    {
      uint64_t v41 = (char *)sub_21677CB28(a1 + 96, v40);
      uint64_t v36 = *(char **)(a1 + 80);
      uint64_t v26 = *(char **)(a1 + 88);
    }
    else
    {
      uint64_t v41 = 0;
    }
    uint64_t v42 = &v41[8 * v37];
    uint64_t v43 = &v41[8 * v40];
    *(void *)uint64_t v42 = 0;
    long long v35 = v42 + 8;
    while (v26 != v36)
    {
      uint64_t v44 = *((void *)v26 - 1);
      v26 -= 8;
      *((void *)v42 - 1) = v44;
      v42 -= 8;
    }
    *(void *)(a1 + 80) = v42;
    *(void *)(a1 + 88) = v35;
    *(void *)(a1 + 96) = v43;
    if (v36) {
      operator delete(v36);
    }
  }
  else
  {
    *(void *)uint64_t v26 = 0;
    long long v35 = v26 + 8;
  }
  *(void *)(a1 + 88) = v35;
  *a7 = *(_OWORD *)__p;
  if (*((void *)&v62[0] + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v62[0] + 1));
  }
  if (v64) {
    sub_216784EC4(v64);
  }
}

void sub_21678E0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void **sub_21678E1D4(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  double result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_21677CB10();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    void v18[4] = result;
    uint64_t v14 = (char *)sub_216787EE0((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    int v18[2] = v15 + 16;
    sub_21678F324(a1, v18);
    uint64_t v9 = (void *)a1[1];
    double result = sub_216788028(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_21678E2DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216788028((void **)va);
  _Unwind_Resume(a1);
}

void sub_21678E2F0(uint64_t a1@<X0>, void *a2@<X1>, const void **a3@<X2>, const void ***a4@<X3>, uint64_t a5@<X4>, int a6@<W5>, _OWORD *a7@<X8>)
{
  uint64_t v14 = (uint64_t **)(a1 + 56);
  if (sub_21677B088(a1 + 56, a3))
  {
    sub_216778A5C((uint64_t)&v63);
    uint64_t v49 = sub_216779180(v65, (uint64_t)"Already have a property named: ", 31);
    int v50 = *((char *)a3 + 23);
    if (v50 >= 0) {
      uint64_t v51 = (uint64_t)a3;
    }
    else {
      uint64_t v51 = (uint64_t)*a3;
    }
    if (v50 >= 0) {
      uint64_t v52 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      uint64_t v52 = (uint64_t)a3[1];
    }
    sub_216779180(v49, v51, v52);
    std::stringbuf::str();
    sub_216778E70(v62, (long long *)__p);
    if (v61 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v54 = sub_216779038(exception, (uint64_t)v62);
    __cxa_throw(v54, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!*(unsigned char *)(a5 + 4) || (*(_DWORD *)a5 != 127 ? (BOOL v15 = *(_DWORD *)a5 == 14) : (BOOL v15 = 1), v15))
  {
    sub_216778A5C((uint64_t)&v63);
    sub_216779180(v65, (uint64_t)"createArrayProperty, illegal DataType provided.", 47);
    std::stringbuf::str();
    sub_216778E70(v62, (long long *)__p);
    if (v61 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v45 = __cxa_allocate_exception(0x20uLL);
    uint64_t v46 = sub_216779038(v45, (uint64_t)v62);
    __cxa_throw(v46, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*((char *)a3 + 23) < 0)
  {
    if (!a3[1]) {
      goto LABEL_70;
    }
  }
  else if (!*((unsigned char *)a3 + 23))
  {
LABEL_70:
    sub_216778A5C((uint64_t)&v63);
    sub_216779180(v65, (uint64_t)"Invalid name", 12);
    std::stringbuf::str();
    sub_216778E70(v62, (long long *)__p);
    if (v61 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v47 = __cxa_allocate_exception(0x20uLL);
    uint64_t v48 = sub_216779038(v47, (uint64_t)v62);
    __cxa_throw(v48, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (std::string::find((const std::string *)a3, 47, 0) != -1) {
    goto LABEL_70;
  }
  (*(void (**)(void **__return_ptr))(*(void *)*a2 + 24))(__p);
  (*(void (**)(long long *__return_ptr))(*(void *)__p[0] + 24))(v62);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)&v62[0] + 56))(&v63);
  if (*((void *)&v62[0] + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v62[0] + 1));
  }
  if (__p[1]) {
    sub_216784EC4((std::__shared_weak_count *)__p[1]);
  }
  uint64_t v16 = operator new(0x68uLL);
  sub_21678F090(v16, (long long *)a3, 2, a4, (void *)a5, &v63);
  v16[40] = 257;
  *((void *)v16 + 11) = 0;
  *((_DWORD *)v16 + 21) = 0;
  *((_DWORD *)v16 + 24) = a6;
  sub_21678D5C8(v62, (uint64_t)v16);
  long long v17 = operator new(0x88uLL);
  uint64_t v18 = (std::__shared_weak_count *)a2[1];
  uint64_t v58 = *a2;
  char v59 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Ogawa::v12::OGroup::addGroup(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), &v56);
  long long v55 = v62[0];
  if (*((void *)&v62[0] + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v62[0] + 1) + 8), 1uLL, memory_order_relaxed);
  }
  sub_216785378(v17, &v58, &v56, &v55, (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4);
  sub_21678F600((uint64_t *)__p, (uint64_t)v17);
  if (*((void *)&v55 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v55 + 1));
  }
  if (v57) {
    sub_216784EC4(v57);
  }
  if (v59) {
    sub_216784EC4(v59);
  }
  sub_21678E1D4((uint64_t *)(a1 + 32), v62);
  unint64_t v20 = __p[0];
  uint64_t v19 = __p[1];
  if (__p[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 2, 1uLL, memory_order_relaxed);
  }
  uint64_t v66 = a3;
  unint64_t v21 = sub_21678F468(v14, a3, (uint64_t)&unk_217408C31, (long long **)&v66);
  unint64_t v22 = (std::__shared_weak_count *)v21[8];
  v21[7] = (uint64_t)v20;
  v21[8] = (uint64_t)v19;
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v23 = *(char **)(a1 + 96);
  uint64_t v24 = (void **)(a1 + 80);
  uint64_t v25 = *(char **)(a1 + 88);
  if (v25 >= v23)
  {
    unint64_t v27 = (char *)*v24;
    uint64_t v28 = (v25 - (unsigned char *)*v24) >> 3;
    unint64_t v29 = v28 + 1;
    if ((unint64_t)(v28 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v30 = v23 - v27;
    if (v30 >> 2 > v29) {
      unint64_t v29 = v30 >> 2;
    }
    if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v31 = v29;
    }
    if (v31)
    {
      int v32 = (char *)sub_21677CB28(a1 + 96, v31);
      unint64_t v27 = *(char **)(a1 + 80);
      uint64_t v25 = *(char **)(a1 + 88);
    }
    else
    {
      int v32 = 0;
    }
    uint64_t v33 = &v32[8 * v28];
    uint64_t v23 = &v32[8 * v31];
    *(void *)uint64_t v33 = 0;
    uint64_t v26 = v33 + 8;
    while (v25 != v27)
    {
      uint64_t v34 = *((void *)v25 - 1);
      v25 -= 8;
      *((void *)v33 - 1) = v34;
      v33 -= 8;
    }
    *(void *)(a1 + 80) = v33;
    *(void *)(a1 + 88) = v26;
    *(void *)(a1 + 96) = v23;
    if (v27)
    {
      operator delete(v27);
      uint64_t v23 = *(char **)(a1 + 96);
    }
  }
  else
  {
    *(void *)uint64_t v25 = 0;
    uint64_t v26 = v25 + 8;
  }
  *(void *)(a1 + 88) = v26;
  if (v26 >= v23)
  {
    uint64_t v36 = (char *)*v24;
    uint64_t v37 = (v26 - (unsigned char *)*v24) >> 3;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v39 = v23 - v36;
    if (v39 >> 2 > v38) {
      unint64_t v38 = v39 >> 2;
    }
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v40 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v40 = v38;
    }
    if (v40)
    {
      uint64_t v41 = (char *)sub_21677CB28(a1 + 96, v40);
      uint64_t v36 = *(char **)(a1 + 80);
      uint64_t v26 = *(char **)(a1 + 88);
    }
    else
    {
      uint64_t v41 = 0;
    }
    uint64_t v42 = &v41[8 * v37];
    uint64_t v43 = &v41[8 * v40];
    *(void *)uint64_t v42 = 0;
    long long v35 = v42 + 8;
    while (v26 != v36)
    {
      uint64_t v44 = *((void *)v26 - 1);
      v26 -= 8;
      *((void *)v42 - 1) = v44;
      v42 -= 8;
    }
    *(void *)(a1 + 80) = v42;
    *(void *)(a1 + 88) = v35;
    *(void *)(a1 + 96) = v43;
    if (v36) {
      operator delete(v36);
    }
  }
  else
  {
    *(void *)uint64_t v26 = 0;
    long long v35 = v26 + 8;
  }
  *(void *)(a1 + 88) = v35;
  *a7 = *(_OWORD *)__p;
  if (*((void *)&v62[0] + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v62[0] + 1));
  }
  if (v64) {
    sub_216784EC4(v64);
  }
}

void sub_21678E89C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21678E9AC(uint64_t a1@<X0>, uint64_t *a2@<X1>, const void **a3@<X2>, const void ***a4@<X3>, _OWORD *a5@<X8>)
{
  uint64_t v10 = (uint64_t **)(a1 + 56);
  if (sub_21677B088(a1 + 56, a3))
  {
    sub_216778A5C((uint64_t)&v53);
    uint64_t v39 = sub_216779180(v54, (uint64_t)"Already have a property named: ", 31);
    int v40 = *((char *)a3 + 23);
    if (v40 >= 0) {
      uint64_t v41 = (uint64_t)a3;
    }
    else {
      uint64_t v41 = (uint64_t)*a3;
    }
    if (v40 >= 0) {
      uint64_t v42 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      uint64_t v42 = (uint64_t)a3[1];
    }
    sub_216779180(v39, v41, v42);
    std::stringbuf::str();
    sub_216778E70(v52, (long long *)__p);
    if (v51 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v44 = sub_216779038(exception, (uint64_t)v52);
    __cxa_throw(v44, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  std::exception v11 = (char *)operator new(0x68uLL);
  sub_21678D40C(v11, (long long *)a3, a4);
  *((_WORD *)v11 + 40) = 257;
  *(void *)(v11 + 92) = 0;
  *(void *)(v11 + 84) = 0;
  sub_21678D5C8(&v53, (uint64_t)v11);
  uint64_t v12 = operator new(0x60uLL);
  uint64_t v13 = (std::__shared_weak_count *)a2[1];
  uint64_t v48 = *a2;
  uint64_t v49 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Ogawa::v12::OGroup::addGroup(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), &v46);
  long long v45 = v53;
  if (*((void *)&v53 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v53 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  sub_21678FFC4(v12, &v48, &v46, &v45, (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4);
  sub_21678F728(v52, (uint64_t)v12);
  if (*((void *)&v45 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v45 + 1));
  }
  if (v47) {
    sub_216784EC4(v47);
  }
  if (v49) {
    sub_216784EC4(v49);
  }
  sub_21678E1D4((uint64_t *)(a1 + 32), &v53);
  long long v14 = *(_OWORD *)v52;
  if (v52[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v52[1] + 16), 1uLL, memory_order_relaxed);
  }
  __p[0] = a3;
  uint64_t v15 = sub_21678F468(v10, a3, (uint64_t)&unk_217408C31, (long long **)__p);
  uint64_t v16 = (std::__shared_weak_count *)v15[8];
  *(_OWORD *)(v15 + 7) = v14;
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  long long v17 = *(char **)(a1 + 96);
  uint64_t v18 = (void **)(a1 + 80);
  uint64_t v19 = *(char **)(a1 + 88);
  if (v19 >= v17)
  {
    unint64_t v21 = (char *)*v18;
    uint64_t v22 = (v19 - (unsigned char *)*v18) >> 3;
    unint64_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v24 = v17 - v21;
    if (v24 >> 2 > v23) {
      unint64_t v23 = v24 >> 2;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      uint64_t v26 = (char *)sub_21677CB28(a1 + 96, v25);
      unint64_t v21 = *(char **)(a1 + 80);
      uint64_t v19 = *(char **)(a1 + 88);
    }
    else
    {
      uint64_t v26 = 0;
    }
    unint64_t v27 = &v26[8 * v22];
    long long v17 = &v26[8 * v25];
    *(void *)unint64_t v27 = 0;
    unint64_t v20 = v27 + 8;
    while (v19 != v21)
    {
      uint64_t v28 = *((void *)v19 - 1);
      v19 -= 8;
      *((void *)v27 - 1) = v28;
      v27 -= 8;
    }
    *(void *)(a1 + 80) = v27;
    *(void *)(a1 + 88) = v20;
    *(void *)(a1 + 96) = v17;
    if (v21)
    {
      operator delete(v21);
      long long v17 = *(char **)(a1 + 96);
    }
  }
  else
  {
    *(void *)uint64_t v19 = 0;
    unint64_t v20 = v19 + 8;
  }
  *(void *)(a1 + 88) = v20;
  if (v20 >= v17)
  {
    uint64_t v30 = (char *)*v18;
    uint64_t v31 = (v20 - (unsigned char *)*v18) >> 3;
    unint64_t v32 = v31 + 1;
    if ((unint64_t)(v31 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v33 = v17 - v30;
    if (v33 >> 2 > v32) {
      unint64_t v32 = v33 >> 2;
    }
    if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v34 = v32;
    }
    if (v34)
    {
      long long v35 = (char *)sub_21677CB28(a1 + 96, v34);
      uint64_t v30 = *(char **)(a1 + 80);
      unint64_t v20 = *(char **)(a1 + 88);
    }
    else
    {
      long long v35 = 0;
    }
    uint64_t v36 = &v35[8 * v31];
    uint64_t v37 = &v35[8 * v34];
    *(void *)uint64_t v36 = 0;
    unint64_t v29 = v36 + 8;
    while (v20 != v30)
    {
      uint64_t v38 = *((void *)v20 - 1);
      v20 -= 8;
      *((void *)v36 - 1) = v38;
      v36 -= 8;
    }
    *(void *)(a1 + 80) = v36;
    *(void *)(a1 + 88) = v29;
    *(void *)(a1 + 96) = v37;
    if (v30) {
      operator delete(v30);
    }
  }
  else
  {
    *(void *)unint64_t v20 = 0;
    unint64_t v29 = v20 + 8;
  }
  *(void *)(a1 + 88) = v29;
  *a5 = *(_OWORD *)v52;
  if (*((void *)&v53 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v53 + 1));
  }
}

void sub_21678ED54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21678EE14(uint64_t a1, uint64_t *a2)
{
  long long __p = 0;
  unint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 40) != v2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = (uint64_t *)(v2 + v5);
      uint64_t v8 = *v7;
      uint64_t v9 = (std::__shared_weak_count *)v7[1];
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v10 = *(unsigned __int8 *)(v8 + 80);
      int v11 = *(unsigned __int8 *)(v8 + 81);
      unsigned int v12 = *(_DWORD *)(v8 + 84);
      unsigned int v13 = *(_DWORD *)(v8 + 88);
      unsigned int v15 = *(_DWORD *)(v8 + 92);
      unsigned int v14 = *(_DWORD *)(v8 + 96);
      uint64_t v16 = (std::__shared_weak_count *)a2[1];
      uint64_t v20 = *a2;
      unint64_t v21 = v16;
      if (v16) {
        atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_21679E590((uint64_t)&__p, v8, v10 != 0, v11 != 0, v14, v12, v13, v15, &v20);
      if (v21) {
        sub_216784EC4(v21);
      }
      if (v9) {
        sub_216784EC4(v9);
      }
      ++v6;
      uint64_t v2 = *(void *)(a1 + 32);
      v5 += 16;
    }
    while (v6 < (*(void *)(a1 + 40) - v2) >> 4);
    long long v17 = v23;
    if (__p != v23)
    {
      Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), __p, (unsigned char *)v23 - (unsigned char *)__p, &v18);
      if (v19) {
        sub_216784EC4(v19);
      }
      long long v17 = __p;
    }
    if (v17)
    {
      unint64_t v23 = v17;
      operator delete(v17);
    }
  }
}

void sub_21678EF3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_21678EF78(void *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= (uint64_t)(result[5] - result[4]) >> 4 || (uint64_t v4 = result[10], 2 * a2 >= (result[11] - v4) >> 3))
  {
    sub_216778A5C((uint64_t)v10);
    sub_216779180(v11, (uint64_t)"Invalid property requested in CpwData::fillHash", 47);
    std::stringbuf::str();
    sub_216778E70(v9, &__p);
    if (v8 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v6 = sub_216779038(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  *(void *)(v4 + 16 * a2) = a3;
  *(void *)(v4 + ((16 * a2) | 8)) = a4;
  return result;
}

void sub_21678F048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void *sub_21678F070(void *result, Alembic::Util::v12::SpookyHash *this)
{
  uint64_t v2 = (char *)result[10];
  uint64_t v3 = (char *)result[11];
  if (v2 != v3) {
    return Alembic::Util::v12::SpookyHash::Update(this, v2, v3 - v2);
  }
  return result;
}

void *sub_21678F090(void *__dst, long long *a2, int a3, const void ***a4, void *a5, void *a6)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_216778F24(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v11 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v11;
  }
  *((_DWORD *)__dst + 6) = a3;
  sub_2167898D0(__dst + 4, a4);
  __dst[7] = *a5;
  uint64_t v12 = a6[1];
  __dst[8] = *a6;
  __dst[9] = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  return __dst;
}

void sub_21678F130(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678F14C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_21678F14C(a1, *a2);
    sub_21678F14C(a1, a2[1]);
    sub_21678F1A8((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_21678F1A8(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t *sub_21678F1FC(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748E60;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    std::exception v5 = (void *)(a2 + 8);
  }
  else {
    std::exception v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21678F26C(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323BEC(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678F288(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21678F2B0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21678F2E0(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748EB0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_21678F324(uint64_t *a1, void *a2)
{
  uint64_t result = sub_21678F39C((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_21678F39C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_21678F430((uint64_t)v12);
  return v10;
}

uint64_t sub_21678F430(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_216787FE4(a1);
  }
  return a1;
}

uint64_t *sub_21678F468(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v6 = (uint64_t **)sub_21677B220((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    sub_21678F514((uint64_t)a1, a4, (uint64_t)v10);
    sub_21677B358(a1, v11, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_21678F5A8((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_21678F514@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 4;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_216778F24(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    v6[6] = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_21678F590(_Unwind_Exception *a1)
{
  sub_21678F5A8(v1, 0);
  _Unwind_Resume(a1);
}

void sub_21678F5A8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_21678F1A8((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

uint64_t *sub_21678F600(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748ED8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21678F670(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323BEC(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678F68C(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21678F6B4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21678F6E4(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748F28)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t *sub_21678F728(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C748F50;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21678F798(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323BEC(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21678F7B4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21678F7DC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21678F80C(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C748FA0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21678F850(void *a1, void *a2, void *a3, const void ***a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C748FC8;
  a1[3] = *a2;
  uint64_t v7 = a2[1];
  a1[4] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  a1[5] = 0;
  a1[6] = 0;
  uint64_t v8 = (char *)operator new(0x68uLL);
  sub_216779094(&__p, "");
  sub_21678D40C(v8, &__p, a4);
  *((_WORD *)v8 + 40) = 257;
  *(void *)(v8 + 92) = 0;
  *(void *)(v8 + 84) = 0;
  sub_21678D5C8(a1 + 7, (uint64_t)v8);
  if (SHIBYTE(v19[0]) < 0) {
    operator delete((void *)__p);
  }
  a1[9] = *a3;
  uint64_t v9 = a3[1];
  a1[10] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  a1[11] = 0;
  if (!a1[3])
  {
    sub_216778A5C((uint64_t)&__p);
    sub_216779180(v19, (uint64_t)"Invalid object", 14);
    std::stringbuf::str();
    sub_216778E70(v17, (long long *)v15);
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v12 = sub_216779038(exception, (uint64_t)v17);
    __cxa_throw(v12, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!a1[9])
  {
    sub_216778A5C((uint64_t)&__p);
    sub_216779180(v19, (uint64_t)"Invalid compound data", 21);
    std::stringbuf::str();
    sub_216778E70(v17, (long long *)v15);
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    char v13 = __cxa_allocate_exception(0x20uLL);
    long long v14 = sub_216779038(v13, (uint64_t)v17);
    __cxa_throw(v14, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return a1;
}

void sub_21678FA64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_216779148(&a12);
  sub_216778D38((uint64_t)&__p);
  unint64_t v23 = (std::__shared_weak_count *)*((void *)v21 + 10);
  if (v23) {
    sub_216784EC4(v23);
  }
  uint64_t v24 = (std::__shared_weak_count *)*((void *)v21 + 8);
  if (v24) {
    sub_216784EC4(v24);
  }
  unint64_t v25 = (std::__shared_weak_count *)*((void *)v21 + 6);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v26 = (std::__shared_weak_count *)*((void *)v21 + 4);
  if (v26) {
    sub_216784EC4(v26);
  }
  unint64_t v27 = (std::__shared_weak_count *)*((void *)v21 + 2);
  if (v27) {
    std::__shared_weak_count::__release_weak(v27);
  }
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::~CompoundPropertyWriter(v21);
  _Unwind_Resume(a1);
}

void *sub_21678FB28(void *a1, void *a2, uint64_t *a3, void *a4, uint64_t a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C748FC8;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = *a2;
  uint64_t v7 = a2[1];
  a1[6] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  a1[7] = *a4;
  uint64_t v8 = a4[1];
  a1[8] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = a5;
  if (!a1[5])
  {
    sub_216778A5C((uint64_t)&v29);
    sub_216779180(v30, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v28, (long long *)__p);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v19 = sub_216779038(exception, (uint64_t)v28);
    __cxa_throw(v19, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!a1[7])
  {
    sub_216778A5C((uint64_t)&v29);
    sub_216779180(v30, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_216778E70(v28, (long long *)__p);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v20 = __cxa_allocate_exception(0x20uLL);
    unint64_t v21 = sub_216779038(v20, (uint64_t)v28);
    __cxa_throw(v21, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 24))(&v29);
  long long v9 = v29;
  long long v29 = 0uLL;
  uint64_t v10 = (std::__shared_weak_count *)a1[4];
  *(_OWORD *)(a1 + 3) = v9;
  if (v10)
  {
    sub_216784EC4(v10);
    if (*((void *)&v29 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v29 + 1));
    }
  }
  if (!a1[5])
  {
    sub_216778A5C((uint64_t)&v29);
    sub_216779180(v30, (uint64_t)"Invalid parent object", 21);
    std::stringbuf::str();
    sub_216778E70(v28, (long long *)__p);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v22 = __cxa_allocate_exception(0x20uLL);
    unint64_t v23 = sub_216779038(v22, (uint64_t)v28);
    __cxa_throw(v23, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v11 = a1[7];
  if (*(char *)(v11 + 23) < 0)
  {
    if (!*(void *)(v11 + 8)) {
      goto LABEL_21;
    }
  }
  else if (!*(unsigned char *)(v11 + 23))
  {
LABEL_21:
    sub_216778A5C((uint64_t)&v29);
    sub_216779180(v30, (uint64_t)"Invalid name", 12);
    std::stringbuf::str();
    sub_216778E70(v28, (long long *)__p);
    if (v27 < 0) {
      operator delete(__p[0]);
    }
    char v16 = __cxa_allocate_exception(0x20uLL);
    long long v17 = sub_216779038(v16, (uint64_t)v28);
    __cxa_throw(v17, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (std::string::find((const std::string *)v11, 47, 0) != -1) {
    goto LABEL_21;
  }
  uint64_t v12 = operator new(0x68uLL);
  char v13 = v12;
  long long v14 = (std::__shared_weak_count *)a3[1];
  uint64_t v24 = *a3;
  unint64_t v25 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_21678D724(v12, &v24);
  sub_21678FF7C(a1 + 9, v13);
  if (v25) {
    sub_216784EC4(v25);
  }
  return a1;
}

void sub_21678FEB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  v14.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  long long v9 = (std::__shared_weak_count *)*((void *)v7 + 10);
  if (v9) {
    sub_216784EC4(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)v7 + 8);
  if (v10) {
    sub_216784EC4(v10);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)v7 + 6);
  if (v11) {
    sub_216784EC4(v11);
  }
  uint64_t v12 = (std::__shared_weak_count *)*((void *)v7 + 4);
  if (v12) {
    sub_216784EC4(v12);
  }
  char v13 = (std::__shared_weak_count *)*((void *)v7 + 2);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::~CompoundPropertyWriter(v7);
  _Unwind_Resume(a1);
}

void sub_21678FF5C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_216784EC4(a11);
  }
  if (v12) {
    operator delete(v11);
  }
  JUMPOUT(0x21678FF10);
}

void sub_21678FF7C(void *a1, void *a2)
{
  sub_216790500(&v5, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v5;
  *(void *)&long long v5 = *a1;
  *((void *)&v5 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_216784EC4(v3);
  }
}

void sub_21678FFC8(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *this)
{
  *(void *)this = &unk_26C748FC8;
  if (*((void *)this + 5))
  {
    uint64_t v2 = *((void *)this + 3);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 4);
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    (*(void (**)(void **__return_ptr))(*(void *)v2 + 24))(&lpsrc);
    long long v5 = v21;
    if (v21) {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = *((void *)v4 + 29);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 30);
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v5) {
      sub_216784EC4(v5);
    }
    if (v21) {
      sub_216784EC4(v21);
    }
    if (v3) {
      sub_216784EC4(v3);
    }
    uint64_t v8 = *((void *)this + 9);
    uint64_t v22 = v7;
    unint64_t v23 = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_21678EE14(v8, &v22);
    if (v23) {
      sub_216784EC4(v23);
    }
    Alembic::Util::v12::SpookyHash::Init((uint64_t)&lpsrc, 0, 0);
    sub_21678F070(*((void **)this + 9), (Alembic::Util::v12::SpookyHash *)&lpsrc);
    sub_21679D428(*((void *)this + 7), (Alembic::Util::v12::SpookyHash *)&lpsrc);
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)&lpsrc, &v19, (unint64_t *)&v18, v9, v10);
    int v12 = (std::__shared_weak_count *)*((void *)this + 6);
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_21678EF78(v11[9], *((void *)this + 11), v19, v18);
    if (v12) {
      sub_216784EC4(v12);
    }
    if (v6) {
      sub_216784EC4(v6);
    }
  }
  char v13 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v13) {
    sub_216784EC4(v13);
  }
  std::exception v14 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v14) {
    sub_216784EC4(v14);
  }
  long long v15 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v15) {
    sub_216784EC4(v15);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v16) {
    sub_216784EC4(v16);
  }
  uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::~CompoundPropertyWriter(this);
}

void *sub_216790220(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_21678EF78(*(void **)(a1 + 72), a2, a3, a4);
}

void sub_21679022C(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter *a1)
{
  sub_21678FFC8(a1);

  operator delete(v1);
}

uint64_t sub_216790254(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_21679025C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *a2 = *(void *)(result + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_216790278@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 48);
  *a2 = *(void *)(result + 40);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

double sub_216790294@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_2167902D0(uint64_t a1)
{
  return sub_21678D7D0(*(void *)(a1 + 72));
}

uint64_t sub_2167902D8(uint64_t a1, unint64_t a2)
{
  return sub_21678D7E0(*(void *)(a1 + 72), a2);
}

const void **sub_2167902E0(uint64_t a1, unsigned __int8 **a2)
{
  return sub_21678D9C0(*(void *)(a1 + 72), a2);
}

void sub_2167902E8(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
}

void sub_2167902F0(void *a1@<X0>, const void **a2@<X1>, const void ***a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, _OWORD *a6@<X8>)
{
  uint64_t v11 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v12);
  sub_21678DB18(v11, &v12, a2, a3, a4, a5, a6);
  if (v13) {
    sub_216784EC4(v13);
  }
}

void sub_216790390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167903A8(void *a1@<X0>, const void **a2@<X1>, const void ***a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, _OWORD *a6@<X8>)
{
  uint64_t v11 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v12);
  sub_21678E2F0(v11, &v12, a2, a3, a4, a5, a6);
  if (v13) {
    sub_216784EC4(v13);
  }
}

void sub_216790448(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_216790460(void *a1@<X0>, const void **a2@<X1>, const void ***a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v7 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 56))(&v8);
  sub_21678E9AC(v7, &v8, a2, a3, a4);
  if (v9) {
    sub_216784EC4(v9);
  }
}

void sub_2167904E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_216790500(void *a1, void *a2)
{
  *a1 = a2;
  long long v4 = operator new(0x20uLL);
  void *v4 = &unk_26C749098;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  sub_216787B18((uint64_t)a1, a2, (uint64_t)a2);
  return a1;
}

void sub_216790568(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    uint64_t v3 = (void *)sub_21678D7CC(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_216790588(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_2167905B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = (void *)sub_21678D7CC(v1);
    operator delete(v2);
  }
}

uint64_t sub_2167905E8(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7490E8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_21679062C(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    unint64_t v4 = *(void *)(a2 + 8);
    if (!v4) {
      return 0;
    }
    if (v4 > 0xFF) {
      return 255;
    }
  }
  else if (!*(unsigned char *)(a2 + 23))
  {
    return 0;
  }
  uint64_t v5 = sub_21678C2D8(a1, (const void **)a2);
  if (a1 + 8 != v5) {
    return (*(_DWORD *)(v5 + 56) + 1);
  }
  unint64_t v7 = *(void *)(a1 + 16);
  if (v7 <= 0xFD)
  {
    uint64_t v8 = (long long *)a2;
    *((_DWORD *)sub_216790A24((uint64_t **)a1, (const void **)a2, (uint64_t)&unk_217409035, &v8) + 14) = v7;
    return (v7 + 1);
  }
  return 255;
}

void sub_2167906E8(void *a1, Alembic::Ogawa::v12::OGroup **a2)
{
  unint64_t v3 = a1[2];
  if (v3)
  {
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    sub_216790984(&v36, v3);
    unint64_t v7 = (void *)*a1;
    uint64_t v5 = a1 + 1;
    uint64_t v6 = v7;
    if (v7 != v5)
    {
      do
      {
        std::string::operator=((std::string *)(v36 + 24 * *((unsigned int *)v6 + 14)), (const std::string *)(v6 + 4));
        uint64_t v8 = (void *)v6[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v6[2];
            BOOL v10 = *v9 == (void)v6;
            uint64_t v6 = v9;
          }
          while (!v10);
        }
        uint64_t v6 = v9;
      }
      while (v9 != v5);
    }
    long long __p = 0;
    unint64_t v34 = 0;
    long long v35 = 0;
    uint64_t v11 = v36;
    uint64_t v12 = v37;
    if (v36 == v37)
    {
      uint64_t v28 = 0;
      long long v29 = 0;
    }
    else
    {
      do
      {
        if (*(char *)(v11 + 23) < 0) {
          uint64_t v13 = *(void *)(v11 + 8);
        }
        else {
          LOBYTE(v13) = *(unsigned char *)(v11 + 23);
        }
        std::exception v14 = v34;
        if (v34 >= v35)
        {
          unint64_t v16 = (unint64_t)__p;
          int64_t v17 = v34 - (unsigned char *)__p;
          uint64_t v18 = v34 - (unsigned char *)__p + 1;
          if (v18 < 0) {
            sub_21677CB10();
          }
          unint64_t v19 = v35 - (unsigned char *)__p;
          if (2 * (v35 - (unsigned char *)__p) > (unint64_t)v18) {
            uint64_t v18 = 2 * v19;
          }
          if (v19 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v20 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v20 = v18;
          }
          if (v20) {
            unint64_t v21 = (char *)operator new(v20);
          }
          else {
            unint64_t v21 = 0;
          }
          uint64_t v22 = &v21[v17];
          unint64_t v23 = &v21[v17];
          *unint64_t v23 = v13;
          long long v15 = v23 + 1;
          if (v14 != (char *)v16)
          {
            uint64_t v24 = &v14[~v16];
            do
            {
              char v25 = *--v14;
              (v24--)[(void)v21] = v25;
            }
            while (v14 != (char *)v16);
            std::exception v14 = (char *)__p;
            uint64_t v22 = v21;
          }
          long long __p = v22;
          unint64_t v34 = v15;
          long long v35 = &v21[v20];
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          char *v34 = v13;
          long long v15 = v14 + 1;
        }
        unint64_t v34 = v15;
        if (*(char *)(v11 + 23) < 0)
        {
          char v27 = *(char **)v11;
          uint64_t v26 = *(void *)(v11 + 8);
        }
        else
        {
          uint64_t v26 = *(unsigned __int8 *)(v11 + 23);
          char v27 = (char *)v11;
        }
        sub_216790EF4((char **)&__p, v15, v27, &v27[v26], v26);
        v11 += 24;
      }
      while (v11 != v12);
      uint64_t v28 = __p;
      long long v29 = v34;
    }
    Alembic::Ogawa::v12::OGroup::addData(*a2, v28, v29 - (unsigned char *)v28, &v31);
    if (v32) {
      sub_216784EC4(v32);
    }
    if (__p)
    {
      unint64_t v34 = (char *)__p;
      operator delete(__p);
    }
    long long __p = &v36;
    sub_216782F20((void ***)&__p);
  }
  else
  {
    uint64_t v30 = *a2;
    Alembic::Ogawa::v12::OGroup::addEmptyData(v30);
  }
}

void sub_216790940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *__p, char *a12, uint64_t a13, char a14)
{
  if (__p)
  {
    a12 = __p;
    operator delete(__p);
  }
  long long __p = &a14;
  sub_216782F20((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_216790984(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_216790B64(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 1) < 0) {
        operator delete(*(void **)(v3 - 24));
      }
      v3 -= 24;
    }
    a1[1] = v7;
  }
}

uint64_t *sub_216790A24(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  unint64_t v6 = (uint64_t **)sub_21677B220((uint64_t)a1, &v9, a2);
  double result = *v6;
  if (!*v6)
  {
    sub_216790ABC((uint64_t)a1, a4, (uint64_t)&v8);
    sub_21677B358(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

unsigned char *sub_216790ABC@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  double result = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    double result = sub_216778F24(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)double result = v9;
  }
  *((_DWORD *)v6 + 14) = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_216790B48(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_21678C278(v3, v2);
  _Unwind_Resume(a1);
}

void sub_216790B64(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_21677CB10();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)sub_216782ED8(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    long long v15 = v12;
    unint64_t v16 = &v12[24 * v8];
    uint64_t v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    int64_t v17 = &v16[v14];
    sub_216790CCC(a1, &v15);
    sub_216790E64((uint64_t)&v15);
  }
}

void sub_216790CB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216790E64((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_216790CCC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_216790D44((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_216790D44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  char v13 = 1;
  sub_216790DE4((uint64_t)v12);
  return a6;
}

uint64_t sub_216790DE4(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_216790E1C(a1);
  }
  return a1;
}

void sub_216790E1C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

uint64_t sub_216790E64(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_216790E9C(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

char *sub_216790EF4(char **a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = __dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v6 = a5;
  uint64_t v7 = __src;
  long long v10 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 - v10 >= a5)
  {
    uint64_t v17 = v10 - __dst;
    if (v10 - __dst >= a5)
    {
      uint64_t v18 = &__src[a5];
      size_t v20 = a1[1];
    }
    else
    {
      uint64_t v18 = &__src[v17];
      if (&__src[v17] == a4)
      {
        size_t v20 = a1[1];
      }
      else
      {
        int64_t v19 = __src - __dst;
        size_t v20 = a1[1];
        unint64_t v21 = v20;
        do
          *v21++ = (v20++)[v19];
        while (&v20[v19] != a4);
      }
      a1[1] = v20;
      if (v17 < 1) {
        return v5;
      }
    }
    unint64_t v32 = &__dst[a5];
    uint64_t v33 = &v20[-a5];
    unint64_t v34 = v20;
    if (&v20[-a5] < v10)
    {
      uint64_t v35 = &v10[a5] - v20;
      unint64_t v34 = v20;
      do
      {
        char v36 = *v33++;
        *v34++ = v36;
        --v35;
      }
      while (v35);
    }
    a1[1] = v34;
    if (v20 != v32) {
      memmove(&__dst[a5], __dst, v20 - v32);
    }
    if (v18 != v7) {
      memmove(v5, v7, v18 - v7);
    }
  }
  else
  {
    unint64_t v11 = *a1;
    uint64_t v12 = v10 - *a1 + a5;
    if (v12 < 0) {
      sub_21677CB10();
    }
    char v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15) {
      unint64_t v16 = operator new(v15);
    }
    else {
      unint64_t v16 = 0;
    }
    uint64_t v22 = &v13[(void)v16];
    unint64_t v23 = &v13[(void)v16 + v6];
    uint64_t v24 = v22;
    do
    {
      char v25 = *v7++;
      *v24++ = v25;
      --v6;
    }
    while (v6);
    uint64_t v26 = *a1;
    if (*a1 == v5)
    {
      uint64_t v28 = v22;
    }
    else
    {
      char v27 = v5;
      uint64_t v28 = v22;
      do
      {
        char v29 = *--v27;
        *--uint64_t v28 = v29;
      }
      while (v27 != v26);
      long long v10 = a1[1];
    }
    uint64_t v30 = (char *)v16 + v15;
    if (v10 != v5) {
      memmove(v23, v5, v10 - v5);
    }
    uint64_t v31 = *a1;
    *a1 = v28;
    a1[1] = &v23[v10 - v5];
    a1[2] = v30;
    if (v31) {
      operator delete(v31);
    }
    return v22;
  }
  return v5;
}

uint64_t sub_2167910EC(uint64_t a1, uint64_t a2, const void **a3, unint64_t a4, uint64_t a5, void *a6)
{
  *(void *)(a1 + 32) = 0;
  uint64_t v12 = (uint64_t *)(a1 + 32);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = a1 + 48;
  char v13 = (uint64_t **)(a1 + 40);
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 96), 0);
  unint64_t v14 = *(Alembic::Ogawa::v12::IGroup **)a2;
  if (!*(void *)a2)
  {
    sub_216778A5C((uint64_t)&v51);
    sub_216779180(v53, (uint64_t)"Invalid object data group", 25);
    std::stringbuf::str();
    sub_216778E70(v50, (long long *)__p);
    if (v49 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v41 = sub_216779038(exception, (uint64_t)v50);
    __cxa_throw(v41, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v15 = *(void *)(a2 + 8);
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v16 = *(std::__shared_weak_count **)(a1 + 24);
  *(void *)(a1 + 16) = v14;
  *(void *)(a1 + 24) = v15;
  if (v16)
  {
    sub_216784EC4(v16);
    unint64_t v14 = *(Alembic::Ogawa::v12::IGroup **)(a1 + 16);
  }
  uint64_t NumChildren = Alembic::Ogawa::v12::IGroup::getNumChildren(v14);
  if (NumChildren)
  {
    unint64_t v18 = NumChildren - 1;
    if (Alembic::Ogawa::v12::IGroup::isChildData(*(Alembic::Ogawa::v12::IGroup **)(a1 + 16), NumChildren - 1))
    {
      char v51 = 0;
      uint64_t v52 = 0;
      v53[0] = 0;
      int64_t v19 = *(std::__shared_weak_count **)(a1 + 24);
      uint64_t v46 = *(unint64_t ***)(a1 + 16);
      uint64_t v47 = v19;
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_216798AF8(&v46, v18, a4, a3, a6, (uint64_t *)&v51);
      uint64_t v42 = a5;
      uint64_t v43 = a6;
      if (v47) {
        sub_216784EC4(v47);
      }
      if (v51 != v52)
      {
        unint64_t v20 = ((char *)v52 - (char *)v51) >> 4;
        if (is_mul_ok(v20, 0x60uLL)) {
          size_t v21 = (96 * v20) | 0x10;
        }
        else {
          size_t v21 = -1;
        }
        uint64_t v22 = operator new[](v21);
        unint64_t v23 = 0;
        *uint64_t v22 = 96;
        v22[1] = v20;
        uint64_t v24 = 96 * v20;
        do
        {
          char v25 = &v22[v23 / 8];
          *((_OWORD *)v25 + 1) = 0u;
          *((_OWORD *)v25 + 2) = 0u;
          pthread_mutex_init((pthread_mutex_t *)&v22[v23 / 8 + 6], 0);
          v23 += 96;
        }
        while (v24 != v23);
        *(void *)&v50[0] = 0;
        uint64_t v26 = *v12;
        *uint64_t v12 = (uint64_t)(v22 + 2);
        if (v26)
        {
          sub_216791EE4((uint64_t)v12, v26);
          uint64_t v27 = *(void *)&v50[0];
          *(void *)&v50[0] = 0;
          if (v27) {
            sub_216791EE4((uint64_t)v50, v27);
          }
        }
        uint64_t v28 = v51;
        if (v52 != v51)
        {
          unint64_t v29 = 0;
          do
          {
            __p[0] = *((void **)&v28->__vftable + 2 * v29);
            sub_21678C138(v13, (const void **)__p[0], (uint64_t)&unk_217409036, (long long **)__p)[7] = v29;
            uint64_t v30 = *v12;
            long long v31 = *((_OWORD *)&v51->std::__shared_count + v29);
            uint64_t v32 = *(&v51->__shared_owners_ + 2 * v29);
            if (v32) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
            }
            unint64_t v33 = v30 + 96 * v29;
            unint64_t v34 = *(std::__shared_weak_count **)(v33 + 8);
            *(_OWORD *)unint64_t v33 = v31;
            if (v34) {
              sub_216784EC4(v34);
            }
            ++v29;
            uint64_t v28 = v51;
          }
          while (v29 < ((char *)v52 - (char *)v51) >> 4);
        }
      }
      *(void *)&v50[0] = &v51;
      sub_216787968((void ***)v50);
      a5 = v42;
      a6 = v43;
    }
    if (Alembic::Ogawa::v12::IGroup::isChildGroup(*(Alembic::Ogawa::v12::IGroup **)(a1 + 16), 0))
    {
      Alembic::Ogawa::v12::IGroup::getGroup(*(unint64_t ***)(a1 + 16), 0, 0, a4, &v51);
      uint64_t v35 = operator new(0x40uLL);
      char v36 = v35;
      uint64_t v44 = v51;
      long long v45 = v52;
      if (v52) {
        atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_21678AE04((uint64_t)v35, (uint64_t)&v44, a4, a5, a6);
      sub_21678D49C(v50, v36);
      long long v37 = v50[0];
      v50[0] = 0uLL;
      uint64_t v38 = *(std::__shared_weak_count **)(a1 + 88);
      *(_OWORD *)(a1 + 80) = v37;
      if (v38)
      {
        sub_216784EC4(v38);
        if (*((void *)&v50[0] + 1)) {
          sub_216784EC4(*((std::__shared_weak_count **)&v50[0] + 1));
        }
      }
      if (v45) {
        sub_216784EC4(v45);
      }
      if (v52) {
        sub_216784EC4(v52);
      }
    }
  }
  return a1;
}

void sub_2167914A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, pthread_mutex_t *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25)
{
  sub_216779148((std::exception *)&a19);
  sub_216778D38((uint64_t)&a24);
  pthread_mutex_destroy(a9);
  uint64_t v30 = (std::__shared_weak_count *)v25[11];
  if (v30) {
    sub_216784EC4(v30);
  }
  long long v31 = (std::__shared_weak_count *)v25[9];
  if (v31) {
    std::__shared_weak_count::__release_weak(v31);
  }
  sub_21678A498(v27, *v28);
  uint64_t v32 = *v26;
  *uint64_t v26 = 0;
  if (v32) {
    sub_216791EE4((uint64_t)v26, v32);
  }
  unint64_t v33 = (std::__shared_weak_count *)v25[3];
  if (v33) {
    sub_216784EC4(v33);
  }
  unint64_t v34 = (std::__shared_weak_count *)v25[1];
  if (v34) {
    std::__shared_weak_count::__release_weak(v34);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_2167915D8(uint64_t a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    sub_216784EC4(v3);
  }
  return a1;
}

uint64_t sub_216791624(uint64_t a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 96));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 88);
  if (v2) {
    sub_216784EC4(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  sub_21678A498(a1 + 40, *(char **)(a1 + 48));
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v4) {
    sub_216791EE4(a1 + 32, v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    sub_216784EC4(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 8);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  return a1;
}

uint64_t sub_2167916A8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 96);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  *a3 = 0;
  a3[1] = 0;
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7)
  {
    uint64_t v8 = std::__shared_weak_count::lock(v7);
    a3[1] = (uint64_t)v8;
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 64);
      *a3 = v9;
      if (v9) {
        return pthread_mutex_unlock(v6);
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  long long v10 = operator new(0x58uLL);
  uint64_t v11 = (uint64_t)v10;
  uint64_t v12 = (std::__shared_weak_count *)a2[1];
  uint64_t v20 = *a2;
  size_t v21 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v13 = *(std::__shared_weak_count **)(a1 + 88);
  uint64_t v18 = *(void *)(a1 + 80);
  int64_t v19 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_21678CF20((uint64_t)v10, &v20, &v18);
  sub_21678C5B8(&v22, v11);
  uint64_t v15 = v22;
  unint64_t v14 = v23;
  uint64_t v22 = 0;
  unint64_t v23 = 0;
  *a3 = v15;
  a3[1] = (uint64_t)v14;
  if (v8)
  {
    sub_216784EC4(v8);
    if (v23) {
      sub_216784EC4(v23);
    }
  }
  if (v19) {
    sub_216784EC4(v19);
  }
  if (v21) {
    sub_216784EC4(v21);
  }
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v16 = *(std::__shared_weak_count **)(a1 + 72);
  *(void *)(a1 + 64) = v15;
  *(void *)(a1 + 72) = v14;
  if (v16) {
    std::__shared_weak_count::__release_weak(v16);
  }
  return pthread_mutex_unlock(v6);
}

void sub_2167917E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v13) {
    sub_216784EC4(v13);
  }
  pthread_mutex_unlock(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_21679184C(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a1 + 56) <= a3)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Out of range index in OrData::getChildHeader: ", 46);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return *(void *)(*(void *)(a1 + 32) + 96 * a3);
}

void sub_21679191C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_216791944(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v5 = sub_21678C2D8(a1 + 40, a3);
  if (a1 + 48 == v5) {
    return 0;
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 8);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = sub_21679184C(a1, v6, *(void *)(v5 + 56));
  if (v7) {
    sub_216784EC4(v7);
  }
  return v8;
}

void sub_2167919BC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167919D4(void *a1@<X0>, uint64_t *a2@<X1>, const void **a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v7 = sub_21678C2D8((uint64_t)(a1 + 5), a3);
  if (a1 + 6 == (void *)v7)
  {
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    uint64_t v8 = *a2;
    uint64_t v9 = (std::__shared_weak_count *)a2[1];
    v10[0] = v8;
    v10[1] = (uint64_t)v9;
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216791A98(a1, v10, *(void *)(v7 + 56), a4);
    if (v9)
    {
      sub_216784EC4(v9);
    }
  }
}

void sub_216791A80(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216791A98@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  if (a1[7] <= a3)
  {
    sub_216778A5C((uint64_t)&v36);
    sub_216779180(v38, (uint64_t)"Out of range index in OrData::getChild: ", 40);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v35, &__p);
    if (v34 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v26 = sub_216779038(exception, (uint64_t)v35);
    __cxa_throw(v26, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v8 = (pthread_mutex_t *)(a1[4] + 96 * a3 + 32);
  pthread_mutex_lock(v8);
  uint64_t v9 = a1[4] + 96 * a3;
  *a4 = 0;
  a4[1] = 0;
  long long v10 = *(std::__shared_weak_count **)(v9 + 24);
  if (v10)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v10);
    a4[1] = (uint64_t)v11;
    if (v11)
    {
      uint64_t v12 = *(void *)(v9 + 16);
      *a4 = v12;
      if (v12) {
        return pthread_mutex_unlock(v8);
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  char v13 = operator new(0x58uLL);
  uint64_t v14 = (uint64_t)v13;
  uint64_t v15 = (std::__shared_weak_count *)a2[1];
  uint64_t v31 = *a2;
  uint64_t v32 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v16 = (std::__shared_weak_count *)a1[3];
  unint64_t v29 = (unint64_t **)a1[2];
  uint64_t v30 = v16;
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = (uint64_t *)(a1[4] + 96 * a3);
  uint64_t v27 = *v17;
  uint64_t v18 = (std::__shared_weak_count *)v17[1];
  uint64_t v28 = v18;
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_21679242C((uint64_t)v13, (uint64_t)&v31, &v29, a3 + 1, &v27);
  sub_216787C48(&v36, v14);
  uint64_t v20 = v36;
  int64_t v19 = v37;
  uint64_t v36 = 0;
  long long v37 = 0;
  *a4 = v20;
  a4[1] = (uint64_t)v19;
  if (v11)
  {
    sub_216784EC4(v11);
    if (v37) {
      sub_216784EC4(v37);
    }
  }
  if (v28) {
    sub_216784EC4(v28);
  }
  if (v30) {
    sub_216784EC4(v30);
  }
  if (v32) {
    sub_216784EC4(v32);
  }
  uint64_t v21 = a1[4];
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v21 + 96 * a3 + 16) = v20;
  uint64_t v22 = v21 + 96 * a3;
  unint64_t v23 = *(std::__shared_weak_count **)(v22 + 24);
  *(void *)(v22 + 24) = v19;
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  return pthread_mutex_unlock(v8);
}

void sub_216791CE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_216791D7C(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t NumChildren = Alembic::Ogawa::v12::IGroup::getNumChildren(*(Alembic::Ogawa::v12::IGroup **)(a1 + 16));
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 16), NumChildren - 1, a3, &v9);
  if (v9 && (unint64_t)Alembic::Ogawa::v12::IData::getSize(v9) >= 0x20)
  {
    uint64_t v7 = (unint64_t **)v9;
    uint64_t Size = Alembic::Ogawa::v12::IData::getSize(v9);
    Alembic::Ogawa::v12::IData::read(v7, 16, a2, Size - 32, a3);
  }
  if (v10) {
    sub_216784EC4(v10);
  }
}

void sub_216791E18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_216791E30(uint64_t a1, void *a2, unint64_t a3)
{
  uint64_t NumChildren = Alembic::Ogawa::v12::IGroup::getNumChildren(*(Alembic::Ogawa::v12::IGroup **)(a1 + 16));
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 16), NumChildren - 1, a3, &v9);
  if (v9 && (unint64_t)Alembic::Ogawa::v12::IData::getSize(v9) >= 0x20)
  {
    uint64_t v7 = (unint64_t **)v9;
    uint64_t Size = Alembic::Ogawa::v12::IData::getSize(v9);
    Alembic::Ogawa::v12::IData::read(v7, 16, a2, Size - 16, a3);
  }
  if (v10) {
    sub_216784EC4(v10);
  }
}

void sub_216791ECC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_216791EE4(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 - 8);
    if (v3)
    {
      uint64_t v4 = 96 * v3;
      do
      {
        pthread_mutex_destroy((pthread_mutex_t *)(a2 + v4 - 64));
        uint64_t v5 = *(std::__shared_weak_count **)(a2 + v4 - 72);
        if (v5) {
          std::__shared_weak_count::__release_weak(v5);
        }
        uint64_t v6 = *(std::__shared_weak_count **)(a2 + v4 - 88);
        if (v6) {
          sub_216784EC4(v6);
        }
        v4 -= 96;
      }
      while (v4);
    }
    operator delete[]((void *)(a2 - 16));
  }
}

uint64_t sub_216791F78(uint64_t a1, uint64_t a2, unint64_t ***a3, unint64_t a4, void *a5)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  long long v10 = (void **)(a1 + 24);
  *(_OWORD *)(a1 + 56) = 0u;
  std::exception v11 = (void *)(a1 + 56);
  *(void *)a1 = &unk_26C749110;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 72) = *a5;
  uint64_t v12 = a5[1];
  *(void *)(a1 + 80) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(void **)a2;
  if (*(void *)a2
  {
    uint64_t v14 = *(void *)(a2 + 8);
    if (v14) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 32);
  *(void *)(a1 + 24) = v13;
  *(void *)(a1 + 32) = v14;
  if (v15)
  {
    sub_216784EC4(v15);
    uint64_t v13 = *v10;
  }
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v37);
    sub_216779180(v39, (uint64_t)"Invalid parent in OrImpl(Object)", 32);
    std::stringbuf::str();
    sub_216778E70(&v35, (long long *)__p);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v26 = sub_216779038(exception, (uint64_t)&v35);
    __cxa_throw(v26, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!*(void *)(a1 + 72))
  {
    sub_216778A5C((uint64_t)&v37);
    sub_216779180(v39, (uint64_t)"Invalid header in OrImpl(Object)", 32);
    std::stringbuf::str();
    sub_216778E70(&v35, (long long *)__p);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v27 = __cxa_allocate_exception(0x20uLL);
    uint64_t v28 = sub_216779038(v27, (uint64_t)&v35);
    __cxa_throw(v28, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v17 = v13[5];
  uint64_t v16 = v13[6];
  if (v16) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 48);
  *(void *)(a1 + 40) = v17;
  *(void *)(a1 + 48) = v16;
  if (v18)
  {
    sub_216784EC4(v18);
    uint64_t v17 = *(void *)(a1 + 40);
  }
  if (!v17)
  {
    sub_216778A5C((uint64_t)&v37);
    sub_216779180(v39, (uint64_t)"Invalid archive in OrImpl(Object)", 33);
    std::stringbuf::str();
    sub_216778E70(&v35, (long long *)__p);
    if (v34 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v29 = __cxa_allocate_exception(0x20uLL);
    uint64_t v30 = sub_216779038(v29, (uint64_t)&v35);
    __cxa_throw(v30, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_216787674(v17, &v37);
  unint64_t v19 = *(void *)(v37 + 8);
  Alembic::Ogawa::v12::IGroup::getGroup(*a3, a4, 0, v19, &v35);
  uint64_t v20 = operator new(0xA0uLL);
  uint64_t v31 = v35;
  uint64_t v32 = v36;
  if (v36) {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v21 = *a5;
  uint64_t v22 = *(void *)(a1 + 40);
  uint64_t v23 = sub_216787780(v22);
  sub_216791620(v20, &v31, v21 + 24, v19, v22, v23);
  sub_2167923E4(v11, v20);
  if (v32) {
    sub_216784EC4(v32);
  }
  if (v36) {
    sub_216784EC4(v36);
  }
  if (v38) {
    sub_216784EC4(v38);
  }
  return a1;
}

void sub_216792304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v13.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v8 = (std::__shared_weak_count *)*((void *)v6 + 10);
  if (v8) {
    sub_216784EC4(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)v6 + 8);
  if (v9) {
    sub_216784EC4(v9);
  }
  long long v10 = (std::__shared_weak_count *)*((void *)v6 + 6);
  if (v10) {
    sub_216784EC4(v10);
  }
  std::exception v11 = (std::__shared_weak_count *)*((void *)v6 + 4);
  if (v11) {
    sub_216784EC4(v11);
  }
  uint64_t v12 = (std::__shared_weak_count *)*((void *)v6 + 2);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader(v6);
  _Unwind_Resume(a1);
}

void sub_2167923E4(void *a1, void *a2)
{
  sub_216787A94(&v5, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v5;
  *(void *)&long long v5 = *a1;
  *((void *)&v5 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_216784EC4(v3);
  }
}

void *sub_216792430(void *result, void *a2, void *a3, void *a4)
{
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C749110;
  result[3] = 0;
  result[4] = 0;
  result[5] = *a2;
  uint64_t v4 = a2[1];
  result[6] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  result[7] = *a3;
  uint64_t v5 = a3[1];
  result[8] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  result[9] = *a4;
  uint64_t v6 = a4[1];
  result[10] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  if (!result[5])
  {
    sub_216778A5C((uint64_t)v16);
    sub_216779180(v17, (uint64_t)"Invalid archive in OrImpl(Archive)", 34);
    std::stringbuf::str();
    sub_216778E70(v15, (long long *)__p);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v8 = sub_216779038(exception, (uint64_t)v15);
    __cxa_throw(v8, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!result[7])
  {
    sub_216778A5C((uint64_t)v16);
    sub_216779180(v17, (uint64_t)"Invalid data in OrImpl(Archive)", 31);
    std::stringbuf::str();
    sub_216778E70(v15, (long long *)__p);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v9 = __cxa_allocate_exception(0x20uLL);
    long long v10 = sub_216779038(v9, (uint64_t)v15);
    __cxa_throw(v10, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!result[9])
  {
    sub_216778A5C((uint64_t)v16);
    sub_216779180(v17, (uint64_t)"Invalid header in OrImpl(Archive)", 33);
    std::stringbuf::str();
    sub_216778E70(v15, (long long *)__p);
    if (v14 < 0) {
      operator delete(__p[0]);
    }
    std::exception v11 = __cxa_allocate_exception(0x20uLL);
    uint64_t v12 = sub_216779038(v11, (uint64_t)v15);
    __cxa_throw(v12, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_216792674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 10);
  if (v6) {
    sub_216784EC4(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)v4 + 8);
  if (v7) {
    sub_216784EC4(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)v4 + 6);
  if (v8) {
    sub_216784EC4(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)v4 + 4);
  if (v9) {
    sub_216784EC4(v9);
  }
  long long v10 = (std::__shared_weak_count *)*((void *)v4 + 2);
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader(v4);
  _Unwind_Resume(a1);
}

void sub_21679270C(Alembic::AbcCoreAbstract::v12::ObjectReader *this)
{
  *(void *)this = &unk_26C749110;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v2) {
    sub_216784EC4(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v3) {
    sub_216784EC4(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v4) {
    sub_216784EC4(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v5) {
    sub_216784EC4(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }

  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader(this);
}

void sub_21679279C(Alembic::AbcCoreAbstract::v12::ObjectReader *a1)
{
  sub_21679270C(a1);

  operator delete(v1);
}

uint64_t sub_2167927C4(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t sub_2167927CC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 48);
  *a2 = *(void *)(result + 40);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_2167927E8@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *a2 = *(void *)(result + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_216792804(void *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v4);
  sub_2167916A8(v3, &v4, a2);
  if (v5) {
    sub_216784EC4(v5);
  }
}

void sub_216792874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_21679288C(uint64_t a1)
{
  return sub_21678AEB0(*(void *)(a1 + 56));
}

uint64_t sub_216792894(void *a1, unint64_t a2)
{
  uint64_t v3 = a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v6);
  uint64_t v4 = sub_21679184C(v3, (uint64_t)&v6, a2);
  if (v7) {
    sub_216784EC4(v7);
  }
  return v4;
}

void sub_21679290C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216792924(void *a1, const void **a2)
{
  uint64_t v3 = a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v6);
  uint64_t v4 = sub_216791944(v3, (uint64_t)&v6, a2);
  if (v7) {
    sub_216784EC4(v7);
  }
  return v4;
}

void sub_21679299C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167929B4(void *a1@<X0>, const void **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5 = (void *)a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v6);
  sub_2167919D4(v5, &v6, a2, a3);
  if (v7) {
    sub_216784EC4(v7);
  }
}

void sub_216792A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_216792A4C(void *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v5 = (void *)a1[7];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 104))(&v6);
  sub_216791A98(v5, &v6, a2, a3);
  if (v7) {
    sub_216784EC4(v7);
  }
}

void sub_216792ACC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

double sub_216792AE4@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_216792B20(uint64_t a1, void *a2)
{
  sub_216787674(*(void *)(a1 + 40), &v5);
  sub_216791D7C(*(void *)(a1 + 56), a2, *(void *)(v5 + 8));
  if (v6) {
    sub_216784EC4(v6);
  }
  return 1;
}

void sub_216792B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216792B94(uint64_t a1, void *a2)
{
  sub_216787674(*(void *)(a1 + 40), &v5);
  sub_216791E30(*(void *)(a1 + 56), a2, *(void *)(v5 + 8));
  if (v6) {
    sub_216784EC4(v6);
  }
  return 1;
}

void sub_216792BF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216792C08(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = *(Alembic::Ogawa::v12::OGroup **)a2;
  *(void *)(a1 + 16) = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)(a1 + 24) = v4;
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    uint64_t v3 = *(Alembic::Ogawa::v12::OGroup **)(a1 + 16);
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 128) = 0;
  if (!v3)
  {
    sub_216778A5C((uint64_t)&v16);
    sub_216779180(v17, (uint64_t)"Invalid parent group", 20);
    std::stringbuf::str();
    sub_216778E70(v15, &__p);
    if (v14 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    long long v10 = sub_216779038(exception, (uint64_t)v15);
    __cxa_throw(v10, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v5 = operator new(0x68uLL);
  Alembic::Ogawa::v12::OGroup::addGroup(v3, &v11);
  sub_21678D724(v5, &v11);
  sub_216790500(&v16, v5);
  long long v6 = v16;
  long long v16 = 0uLL;
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 104);
  *(_OWORD *)(a1 + 96) = v6;
  if (v7)
  {
    sub_216784EC4(v7);
    if (*((void *)&v16 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v16 + 1));
    }
  }
  if (v12) {
    sub_216784EC4(v12);
  }
  return a1;
}

void sub_216792D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  v15.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  long long v10 = *(void **)(v7 + 112);
  if (v10)
  {
    *(void *)(v7 + 120) = v10;
    operator delete(v10);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(v7 + 104);
  if (v11) {
    sub_216784EC4(v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(v7 + 88);
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
  sub_21678F14C(v8, *(void **)(v7 + 64));
  sub_216787968((void ***)va1);
  uint64_t v13 = *(std::__shared_weak_count **)(v7 + 24);
  if (v13) {
    sub_216784EC4(v13);
  }
  char v14 = *(std::__shared_weak_count **)(v7 + 8);
  if (v14) {
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_216792E4C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 112);
  if (v2)
  {
    *(void *)(a1 + 120) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 104);
  if (v3) {
    sub_216784EC4(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 88);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  sub_21678F14C(a1 + 56, *(void **)(a1 + 64));
  uint64_t v8 = (void **)(a1 + 32);
  sub_216787968(&v8);
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  if (v5) {
    sub_216784EC4(v5);
  }
  long long v6 = *(std::__shared_weak_count **)(a1 + 8);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  return a1;
}

void sub_216792ED8(void *a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  long long v6 = (std::__shared_weak_count *)a1[11];
  if (v6)
  {
    uint64_t v7 = std::__shared_weak_count::lock(v6);
    a3[1] = (uint64_t)v7;
    if (v7)
    {
      uint64_t v8 = a1[10];
      *a3 = v8;
      if (v8) {
        return;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v9 = operator new(0x60uLL);
  long long v10 = (std::__shared_weak_count *)a2[1];
  uint64_t v18 = *a2;
  uint64_t v19 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = (std::__shared_weak_count *)a1[13];
  uint64_t v16 = a1[12];
  uint64_t v17 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = (*(uint64_t (**)(void))(*(void *)*a2 + 16))(*a2);
  sub_21678FB24(v9, &v18, &v16, (const void ***)(v12 + 48));
  sub_21678F728(&v20, (uint64_t)v9);
  uint64_t v14 = v20;
  uint64_t v13 = v21;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  *a3 = v14;
  a3[1] = (uint64_t)v13;
  if (v7)
  {
    sub_216784EC4(v7);
    if (v21) {
      sub_216784EC4(v21);
    }
  }
  if (v17) {
    sub_216784EC4(v17);
  }
  if (v19) {
    sub_216784EC4(v19);
  }
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  std::exception v15 = (std::__shared_weak_count *)a1[11];
  a1[10] = v14;
  a1[11] = v13;
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
}

void sub_216793030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (v12) {
    sub_216784EC4(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216793084(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2 >= (*(void *)(a1 + 40) - v2) >> 4)
  {
    sub_216778A5C((uint64_t)v11);
    sub_216779180(v12, (uint64_t)"Out of range index in OwData::getChildHeader: ", 46);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v10, (long long *)__p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v5 = sub_216779038(exception, (uint64_t)v10);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t result = *(void *)(v2 + 16 * a2);
  if (!result)
  {
    sub_216778A5C((uint64_t)v11);
    sub_216779180(v12, (uint64_t)"Invalid child header: ", 22);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v10, (long long *)__p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    long long v6 = __cxa_allocate_exception(0x20uLL);
    uint64_t v7 = sub_216779038(v6, (uint64_t)v10);
    __cxa_throw(v7, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_2167931DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_216793210(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40) - v2;
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = v3 >> 4;
    char v6 = *((unsigned char *)a2 + 23);
    if (v6 >= 0) {
      uint64_t v7 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    }
    else {
      uint64_t v7 = a2[1];
    }
    if (v6 >= 0) {
      uint64_t v8 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v8 = *a2;
    }
    if (v5 <= 1) {
      uint64_t v9 = 1;
    }
    else {
      uint64_t v9 = v5;
    }
    do
    {
      uint64_t v10 = *(void *)(v2 + 16 * v4);
      uint64_t v11 = *(unsigned __int8 *)(v10 + 23);
      if ((v11 & 0x80u) == 0) {
        uint64_t v12 = (unsigned __int8 *)*(unsigned __int8 *)(v10 + 23);
      }
      else {
        uint64_t v12 = *(unsigned __int8 **)(v10 + 8);
      }
      if (v12 == v7)
      {
        if ((v11 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v10, v8, *(void *)(v10 + 8))) {
            return v10;
          }
        }
        else
        {
          if (!*(unsigned char *)(v10 + 23)) {
            return v10;
          }
          uint64_t v13 = 0;
          while (*(unsigned __int8 *)(v10 + v13) == v8[v13])
          {
            if (v11 == ++v13) {
              return v10;
            }
          }
        }
      }
      ++v4;
    }
    while (v4 != v9);
  }
  return 0;
}

void sub_2167932E4(uint64_t a1@<X0>, uint64_t *a2@<X1>, void **a3@<X2>, long long *a4@<X3>, _OWORD *a5@<X8>)
{
  if (*((char *)a4 + 23) < 0)
  {
    sub_216778F24(&__dst, *(void **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long __dst = *a4;
    uint64_t v70 = *((void *)a4 + 2);
  }
  if (sub_21677B088(a1 + 56, (const void **)&__dst))
  {
    sub_216778A5C((uint64_t)&v68);
    uint64_t v41 = sub_216779180(&v68.__r_.__value_.__r.__words[2], (uint64_t)"Already have an Object named: ", 30);
    if (v70 >= 0) {
      p_dst = &__dst;
    }
    else {
      p_dst = (long long *)__dst;
    }
    if (v70 >= 0) {
      uint64_t v43 = HIBYTE(v70);
    }
    else {
      uint64_t v43 = *((void *)&__dst + 1);
    }
    sub_216779180(v41, (uint64_t)p_dst, v43);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v64);
    if (v65 < 0) {
      operator delete(v64[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    long long v45 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v45, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v10 = HIBYTE(v70);
  if (v70 < 0) {
    uint64_t v10 = *((void *)&__dst + 1);
  }
  if (!v10)
  {
    sub_216778A5C((uint64_t)&v68);
    uint64_t v46 = sub_216779180(&v68.__r_.__value_.__r.__words[2], (uint64_t)"Object not given a name, parent is: ", 36);
    int v47 = *((char *)a3 + 23);
    if (v47 >= 0) {
      uint64_t v48 = a3;
    }
    else {
      uint64_t v48 = *a3;
    }
    if (v47 >= 0) {
      uint64_t v49 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      uint64_t v49 = (uint64_t)a3[1];
    }
    sub_216779180(v46, (uint64_t)v48, v49);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v64);
    if (v65 < 0) {
      operator delete(v64[0]);
    }
    int v50 = __cxa_allocate_exception(0x20uLL);
    char v51 = sub_216779038(v50, (uint64_t)__p);
    __cxa_throw(v51, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (std::string::find((const std::string *)a4, 47, 0) != -1)
  {
    sub_216778A5C((uint64_t)&v68);
    uint64_t v52 = sub_216779180(&v68.__r_.__value_.__r.__words[2], (uint64_t)"Object has illegal name: ", 25);
    int v53 = *((char *)a4 + 23);
    if (v53 >= 0) {
      uint64_t v54 = (uint64_t)a4;
    }
    else {
      uint64_t v54 = *(void *)a4;
    }
    if (v53 >= 0) {
      uint64_t v55 = *((unsigned __int8 *)a4 + 23);
    }
    else {
      uint64_t v55 = *((void *)a4 + 1);
    }
    sub_216779180(v52, v54, v55);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v64);
    if (v65 < 0) {
      operator delete(v64[0]);
    }
    uint64_t v56 = __cxa_allocate_exception(0x20uLL);
    uint64_t v57 = sub_216779038(v56, (uint64_t)__p);
    __cxa_throw(v57, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*((char *)a3 + 23) < 0) {
    sub_216778F24(&v68, *a3, (unint64_t)a3[1]);
  }
  else {
    std::string v68 = *(std::string *)a3;
  }
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0)
  {
    if (v68.__r_.__value_.__l.__size_ == 1)
    {
      uint64_t v11 = (std::string *)v68.__r_.__value_.__r.__words[0];
LABEL_17:
      if (v11->__r_.__value_.__s.__data_[0] == 47) {
        goto LABEL_19;
      }
    }
  }
  else if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) == 1)
  {
    uint64_t v11 = &v68;
    goto LABEL_17;
  }
  std::string::append(&v68, "/");
LABEL_19:
  uint64_t v12 = (char *)operator new(0x48uLL);
  pxrInternal__aapl__pxrReserved__::Sdf_CreateIdentifier((const void **)&v68.__r_.__value_.__l.__data_, (const void **)a4, (uint64_t)__p);
  sub_216793FE8(v12, a4, (long long *)__p, (const void ***)a4 + 6);
  sub_216787808(v64, (uint64_t)v12);
  if (v67 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v13 = operator new(0x60uLL);
  uint64_t v14 = (std::__shared_weak_count *)a2[1];
  uint64_t v62 = *a2;
  uint64_t v63 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Ogawa::v12::OGroup::addGroup(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), &v60);
  uint64_t v58 = v64[0];
  char v59 = (std::__shared_weak_count *)v64[1];
  if (v64[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v64[1] + 1, 1uLL, memory_order_relaxed);
  }
  sub_216794A74(v13, &v62, &v60, &v58, (uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4);
  sub_21678A938((uint64_t *)__p, (uint64_t)v13);
  if (v59) {
    sub_216784EC4(v59);
  }
  if (v61) {
    sub_216784EC4(v61);
  }
  if (v63) {
    sub_216784EC4(v63);
  }
  sub_216793AD0((uint64_t *)(a1 + 32), (long long *)v64);
  uint64_t v16 = __p[0];
  std::exception v15 = __p[1];
  if (__p[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 2, 1uLL, memory_order_relaxed);
  }
  uint64_t v71 = a4;
  uint64_t v17 = sub_216794280((uint64_t **)(a1 + 56), (const void **)a4, (uint64_t)&unk_2174090A2, &v71);
  uint64_t v18 = (std::__shared_weak_count *)v17[8];
  v17[7] = (uint64_t)v16;
  v17[8] = (uint64_t)v15;
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
  uint64_t v19 = *(char **)(a1 + 128);
  uint64_t v20 = (void **)(a1 + 112);
  uint64_t v21 = *(char **)(a1 + 120);
  if (v21 >= v19)
  {
    uint64_t v23 = (char *)*v20;
    uint64_t v24 = (v21 - (unsigned char *)*v20) >> 3;
    unint64_t v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v26 = v19 - v23;
    if (v26 >> 2 > v25) {
      unint64_t v25 = v26 >> 2;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27)
    {
      uint64_t v28 = (char *)sub_21677CB28(a1 + 128, v27);
      uint64_t v23 = *(char **)(a1 + 112);
      uint64_t v21 = *(char **)(a1 + 120);
    }
    else
    {
      uint64_t v28 = 0;
    }
    unint64_t v29 = &v28[8 * v24];
    uint64_t v19 = &v28[8 * v27];
    *(void *)unint64_t v29 = 0;
    uint64_t v22 = v29 + 8;
    while (v21 != v23)
    {
      uint64_t v30 = *((void *)v21 - 1);
      v21 -= 8;
      *((void *)v29 - 1) = v30;
      v29 -= 8;
    }
    *(void *)(a1 + 112) = v29;
    *(void *)(a1 + 120) = v22;
    *(void *)(a1 + 128) = v19;
    if (v23)
    {
      operator delete(v23);
      uint64_t v19 = *(char **)(a1 + 128);
    }
  }
  else
  {
    *(void *)uint64_t v21 = 0;
    uint64_t v22 = v21 + 8;
  }
  *(void *)(a1 + 120) = v22;
  if (v22 >= v19)
  {
    uint64_t v32 = (char *)*v20;
    uint64_t v33 = (v22 - (unsigned char *)*v20) >> 3;
    unint64_t v34 = v33 + 1;
    if ((unint64_t)(v33 + 1) >> 61) {
      sub_21677CB10();
    }
    uint64_t v35 = v19 - v32;
    if (v35 >> 2 > v34) {
      unint64_t v34 = v35 >> 2;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v36 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v36 = v34;
    }
    if (v36)
    {
      uint64_t v37 = (char *)sub_21677CB28(a1 + 128, v36);
      uint64_t v32 = *(char **)(a1 + 112);
      uint64_t v22 = *(char **)(a1 + 120);
    }
    else
    {
      uint64_t v37 = 0;
    }
    uint64_t v38 = &v37[8 * v33];
    uint64_t v39 = &v37[8 * v36];
    *(void *)uint64_t v38 = 0;
    uint64_t v31 = v38 + 8;
    while (v22 != v32)
    {
      uint64_t v40 = *((void *)v22 - 1);
      v22 -= 8;
      *((void *)v38 - 1) = v40;
      v38 -= 8;
    }
    *(void *)(a1 + 112) = v38;
    *(void *)(a1 + 120) = v31;
    *(void *)(a1 + 128) = v39;
    if (v32) {
      operator delete(v32);
    }
  }
  else
  {
    *(void *)uint64_t v22 = 0;
    uint64_t v31 = v22 + 8;
  }
  *(void *)(a1 + 120) = v31;
  *a5 = *(_OWORD *)__p;
  if (v64[1]) {
    sub_216784EC4((std::__shared_weak_count *)v64[1]);
  }
  if (SHIBYTE(v68.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v68.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v70) < 0) {
    operator delete((void *)__dst);
  }
}

void sub_2167938C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  sub_216779148((std::exception *)&a19);
  sub_216778D38((uint64_t)&__p);
  if (*(char *)(v31 - 89) < 0) {
    operator delete(*(void **)(v31 - 112));
  }
  _Unwind_Resume(a1);
}

uint64_t pxrInternal__aapl__pxrReserved__::Sdf_CreateIdentifier@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = sub_2167940B4(a3, v6 + v5);
  if (*(char *)(result + 23) >= 0) {
    uint64_t v8 = (char *)result;
  }
  else {
    uint64_t v8 = *(char **)result;
  }
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0) {
      uint64_t v9 = a1;
    }
    else {
      uint64_t v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }
  uint64_t v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

void **sub_216793AD0(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_21677CB10();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    void v18[4] = result;
    uint64_t v14 = (char *)sub_216787EE0((uint64_t)result, v13);
    std::exception v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)std::exception v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    int v18[2] = v15 + 16;
    sub_21679413C(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = sub_216788028(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_216793BD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216788028((void **)va);
  _Unwind_Resume(a1);
}

void sub_216793BEC(uint64_t a1, uint64_t *a2, Alembic::Util::v12::SpookyHash *a3)
{
  v46[1] = *MEMORY[0x263EF8340];
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v6 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 40) != v6)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = *(void *)(v6 + v7);
      uint64_t v10 = (std::__shared_weak_count *)a2[1];
      uint64_t v38 = *a2;
      uint64_t v39 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_21679E9DC((uint64_t)&v40, v9, &v38);
      if (v39) {
        sub_216784EC4(v39);
      }
      ++v8;
      uint64_t v6 = *(void *)(a1 + 32);
      v7 += 16;
    }
    while (v8 < (*(void *)(a1 + 40) - v6) >> 4);
  }
  Alembic::Util::v12::SpookyHash::Init((uint64_t)v37, 0, 0);
  sub_21678F070(*(void **)(a1 + 96), (Alembic::Util::v12::SpookyHash *)v37);
  Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)v37, &__src, &v44, v11, v12);
  Alembic::Util::v12::SpookyHash::Init((uint64_t)a3, 0, 0);
  unint64_t v13 = *(char **)(a1 + 112);
  uint64_t v14 = *(char **)(a1 + 120);
  if (v13 == v14)
  {
    unint64_t v45 = 0;
    v46[0] = 0;
  }
  else
  {
    Alembic::Util::v12::SpookyHash::Update(a3, v13, v14 - v13);
    Alembic::Util::v12::SpookyHash::Final(a3, &v45, v46, v15, v16);
  }
  uint64_t v32 = a3;
  uint64_t v17 = 0;
  uint64_t v18 = v41;
  do
  {
    if (v18 >= v42)
    {
      unint64_t v20 = (unint64_t)v40;
      uint64_t v21 = v18 - v40;
      uint64_t v22 = v18 - v40 + 1;
      if (v22 < 0) {
        sub_21677CB10();
      }
      unint64_t v23 = v42 - v40;
      if (2 * (v42 - v40) > (unint64_t)v22) {
        uint64_t v22 = 2 * v23;
      }
      if (v23 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v24 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v24 = v22;
      }
      if (v24) {
        unint64_t v25 = (char *)operator new(v24);
      }
      else {
        unint64_t v25 = 0;
      }
      uint64_t v26 = &v25[v21];
      unint64_t v27 = &v25[v21];
      char *v27 = *((unsigned char *)&__src + v17);
      uint64_t v19 = v27 + 1;
      if (v18 != (char *)v20)
      {
        uint64_t v28 = &v18[~v20];
        do
        {
          char v29 = *--v18;
          (v28--)[(void)v25] = v29;
        }
        while (v18 != (char *)v20);
        uint64_t v18 = v40;
        uint64_t v26 = v25;
      }
      uint64_t v40 = v26;
      uint64_t v41 = v19;
      uint64_t v42 = &v25[v24];
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *uint64_t v18 = *((unsigned char *)&__src + v17);
      uint64_t v19 = v18 + 1;
    }
    uint64_t v41 = v19;
    ++v17;
    uint64_t v18 = v19;
  }
  while (v17 != 32);
  Alembic::Util::v12::SpookyHash::Update(v32, &__src, 0x10uLL);
  if (v40 != v41)
  {
    Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)(a1 + 16), v40, v41 - v40, &v35);
    if (v36) {
      sub_216784EC4(v36);
    }
  }
  uint64_t v30 = *(void *)(a1 + 96);
  uint64_t v31 = (std::__shared_weak_count *)a2[1];
  uint64_t v33 = *a2;
  unint64_t v34 = v31;
  if (v31) {
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_21678EE14(v30, &v33);
  if (v34) {
    sub_216784EC4(v34);
  }
  if (v40)
  {
    uint64_t v41 = v40;
    operator delete(v40);
  }
}

void sub_216793EA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    sub_216784EC4(a11);
  }
  unint64_t v13 = *(void **)(v11 - 152);
  if (v13)
  {
    *(void *)(v11 - 144) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

void *sub_216793EF0(void *result, unint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= (uint64_t)(result[5] - result[4]) >> 4 || (uint64_t v4 = result[14], 2 * a2 >= (result[15] - v4) >> 3))
  {
    sub_216778A5C((uint64_t)v10);
    sub_216779180(v11, (uint64_t)"Invalid property index requested in OwData::fillHash", 52);
    std::stringbuf::str();
    sub_216778E70(v9, &__p);
    if (v8 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v6 = sub_216779038(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  *(void *)(v4 + 16 * a2) = a3;
  *(void *)(v4 + ((16 * a2) | 8)) = a4;
  return result;
}

void sub_216793FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

char *sub_216793FE8(char *__dst, long long *a2, long long *a3, const void ***a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_216778F24(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v7;
  }
  if (*((char *)a3 + 23) < 0)
  {
    sub_216778F24(__dst + 24, *(void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v8 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)(__dst + 24) = v8;
  }
  sub_2167898D0((uint64_t *)__dst + 6, a4);
  return __dst;
}

void sub_216794080(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167940B4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    sub_216778FC4();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    uint64_t v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

uint64_t sub_21679413C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167941B4((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_2167941B4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_216794248((uint64_t)v12);
  return v10;
}

uint64_t sub_216794248(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_216787FE4(a1);
  }
  return a1;
}

uint64_t *sub_216794280(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v6 = (uint64_t **)sub_21677B220((uint64_t)a1, &v11, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    sub_21679432C((uint64_t)a1, a4, (uint64_t)v10);
    sub_21677B358(a1, v11, v8, v10[0]);
    uint64_t v7 = v10[0];
    v10[0] = 0;
    sub_21678F5A8((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_21679432C@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 4;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_216778F24(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    v6[6] = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_2167943A8(_Unwind_Exception *a1)
{
  sub_21678F5A8(v1, 0);
  _Unwind_Resume(a1);
}

void *sub_2167943C0(void *a1, void *a2, void *a3, const void ***a4)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C7491D8;
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = *a2;
  uint64_t v7 = a2[1];
  a1[6] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = (char *)operator new(0x48uLL);
  sub_216779094(&v19, "ABC");
  sub_216779094(__p, "/");
  sub_216793FE8(v8, &v19, (long long *)__p, a4);
  sub_216787808(a1 + 7, (uint64_t)v8);
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v20[0]) < 0) {
    operator delete((void *)v19);
  }
  a1[9] = *a3;
  uint64_t v9 = a3[1];
  a1[10] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  a1[11] = 0;
  if (!a1[5])
  {
    sub_216778A5C((uint64_t)&v19);
    sub_216779180(v20, (uint64_t)"Invalid archive", 15);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v15);
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v12 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v12, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!a1[9])
  {
    sub_216778A5C((uint64_t)&v19);
    sub_216779180(v20, (uint64_t)"Invalid data", 12);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v15);
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    char v13 = __cxa_allocate_exception(0x20uLL);
    long long v14 = sub_216779038(v13, (uint64_t)__p);
    __cxa_throw(v14, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return a1;
}

void sub_2167945E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  sub_216779148((std::exception *)&a12);
  sub_216778D38((uint64_t)&__p);
  uint64_t v26 = (std::__shared_weak_count *)*((void *)v24 + 10);
  if (v26) {
    sub_216784EC4(v26);
  }
  unint64_t v27 = (std::__shared_weak_count *)*((void *)v24 + 8);
  if (v27) {
    sub_216784EC4(v27);
  }
  uint64_t v28 = (std::__shared_weak_count *)*((void *)v24 + 6);
  if (v28) {
    sub_216784EC4(v28);
  }
  char v29 = (std::__shared_weak_count *)*((void *)v24 + 4);
  if (v29) {
    sub_216784EC4(v29);
  }
  uint64_t v30 = (std::__shared_weak_count *)*((void *)v24 + 2);
  if (v30) {
    std::__shared_weak_count::__release_weak(v30);
  }
  Alembic::AbcCoreAbstract::v12::ObjectWriter::~ObjectWriter(v24);
  _Unwind_Resume(a1);
}

void *sub_2167946D4(void *a1, void *a2, uint64_t *a3, void *a4, uint64_t a5)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26C7491D8;
  a1[3] = *a2;
  uint64_t v7 = a2[1];
  a1[4] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  a1[5] = 0;
  a1[6] = 0;
  uint64_t v8 = a1 + 5;
  a1[7] = *a4;
  uint64_t v9 = a4[1];
  a1[8] = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = a5;
  uint64_t v10 = a1[3];
  if (!v10)
  {
    sub_216778A5C((uint64_t)&v28);
    sub_216779180(v29, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v27, (long long *)__p);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v20 = sub_216779038(exception, (uint64_t)v27);
    __cxa_throw(v20, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!a1[7])
  {
    sub_216778A5C((uint64_t)&v28);
    sub_216779180(v29, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_216778E70(v27, (long long *)__p);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v21 = __cxa_allocate_exception(0x20uLL);
    uint64_t v22 = sub_216779038(v21, (uint64_t)v27);
    __cxa_throw(v22, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr))(*(void *)v10 + 24))(&v28);
  long long v11 = v28;
  long long v28 = 0uLL;
  uint64_t v12 = (std::__shared_weak_count *)a1[6];
  *(_OWORD *)(a1 + 5) = v11;
  if (!v12)
  {
    if ((void)v11) {
      goto LABEL_11;
    }
LABEL_17:
    sub_216778A5C((uint64_t)&v28);
    sub_216779180(v29, (uint64_t)"Invalid archive", 15);
    std::stringbuf::str();
    sub_216778E70(v27, (long long *)__p);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v17 = __cxa_allocate_exception(0x20uLL);
    char v18 = sub_216779038(v17, (uint64_t)v27);
    __cxa_throw(v18, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_216784EC4(v12);
  if (*((void *)&v28 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v28 + 1));
  }
  if (!*v8) {
    goto LABEL_17;
  }
LABEL_11:
  char v13 = operator new(0x88uLL);
  long long v14 = v13;
  long long v15 = (std::__shared_weak_count *)a3[1];
  uint64_t v23 = *a3;
  size_t v24 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216792E48(v13, &v23);
  sub_216788D74(a1 + 9, v14);
  if (v24) {
    sub_216784EC4(v24);
  }
  return a1;
}

void sub_2167949B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  v14.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v9 = (std::__shared_weak_count *)*((void *)v7 + 10);
  if (v9) {
    sub_216784EC4(v9);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)v7 + 8);
  if (v10) {
    sub_216784EC4(v10);
  }
  long long v11 = (std::__shared_weak_count *)*((void *)v7 + 6);
  if (v11) {
    sub_216784EC4(v11);
  }
  uint64_t v12 = (std::__shared_weak_count *)*((void *)v7 + 4);
  if (v12) {
    sub_216784EC4(v12);
  }
  char v13 = (std::__shared_weak_count *)*((void *)v7 + 2);
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }
  Alembic::AbcCoreAbstract::v12::ObjectWriter::~ObjectWriter(v7);
  _Unwind_Resume(a1);
}

void sub_216794A78(Alembic::AbcCoreAbstract::v12::ObjectWriter *this)
{
  *(void *)this = &unk_26C7491D8;
  if (!*((void *)this + 3)) {
    goto LABEL_29;
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *((void *)v2 + 29);
  uint64_t v4 = (std::__shared_weak_count *)*((void *)v2 + 30);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v3) {
    sub_216784EC4(v3);
  }
  Alembic::Util::v12::SpookyHash::Init((uint64_t)v27, 0, 0);
  uint64_t v6 = *((void *)this + 9);
  uint64_t v25 = v5;
  char v26 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216793BEC(v6, &v25, (Alembic::Util::v12::SpookyHash *)v27);
  if (v26) {
    sub_216784EC4(v26);
  }
  Alembic::Util::v12::TokenMap::get((Alembic::Util::v12::TokenMap *)(*((void *)this + 7) + 48), 0x3Bu, 61, 1);
  if ((char)v24 < 0)
  {
    size_t v7 = __n;
    if (__n)
    {
      p_p = __p;
      goto LABEL_17;
    }
  }
  else
  {
    size_t v7 = v24;
    if (v24)
    {
      p_p = &__p;
LABEL_17:
      Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)v27, p_p, v7);
    }
  }
  uint64_t v9 = (uint64_t **)*((void *)this + 7);
  if (*((char *)v9 + 23) < 0)
  {
    uint64_t v9 = (uint64_t **)*v9;
    size_t v10 = *(void *)(*((void *)this + 7) + 8);
  }
  else
  {
    size_t v10 = *((unsigned __int8 *)v9 + 23);
  }
  Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)v27, v9, v10);
  unint64_t v20 = 0;
  unint64_t v21 = 0;
  Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)v27, &v21, &v20, v11, v12);
  std::exception v14 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216793EF0(v13[9], *((void *)this + 11), v21, v20);
  if (v14) {
    sub_216784EC4(v14);
  }
  if ((char)v24 < 0) {
    operator delete(__p);
  }
  if (v4) {
    sub_216784EC4(v4);
  }
LABEL_29:
  long long v15 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v15) {
    sub_216784EC4(v15);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v16) {
    sub_216784EC4(v16);
  }
  uint64_t v17 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v17) {
    sub_216784EC4(v17);
  }
  uint64_t v18 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v18) {
    sub_216784EC4(v18);
  }
  long long v19 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v19) {
    std::__shared_weak_count::__release_weak(v19);
  }
  Alembic::AbcCoreAbstract::v12::ObjectWriter::~ObjectWriter(this);
}

void sub_216794CDC(Alembic::AbcCoreAbstract::v12::ObjectWriter *a1)
{
  sub_216794A78(a1);

  operator delete(v1);
}

uint64_t sub_216794D04(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 56);
  if (!result)
  {
    sub_216778A5C((uint64_t)v7);
    sub_216779180(v8, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_216778E70(v6, &__p);
    if (v5 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v3 = sub_216779038(exception, (uint64_t)v6);
    __cxa_throw(v3, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_216794DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_216794DD0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 48);
  *a2 = *(void *)(result + 40);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_216794DEC@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *a2 = *(void *)(result + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_216794E08(void *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3 = (void *)a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 88))(&v4);
  sub_216792ED8(v3, &v4, a2);
  if (v5) {
    sub_216784EC4(v5);
  }
}

void sub_216794E78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_216794E90(uint64_t a1)
{
  return sub_21678D7D0(*(void *)(a1 + 72));
}

uint64_t sub_216794E98(uint64_t a1, unint64_t a2)
{
  return sub_216793084(*(void *)(a1 + 72), a2);
}

uint64_t sub_216794EA0(uint64_t a1, unsigned __int8 **a2)
{
  return sub_216793210(*(void *)(a1 + 72), a2);
}

void sub_216794EA8(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
}

void sub_216794EB0(void *a1@<X0>, long long *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v6 = a1[9];
  (*(void (**)(uint64_t *__return_ptr))(*a1 + 88))(&v7);
  sub_2167932E4(v6, &v7, (void **)(a1[7] + 24), a2, a3);
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_216794F3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

double sub_216794F54@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

void sub_216794F90(Alembic::Ogawa::v12::IData **a1, Alembic::Ogawa::v12::IData **a2, unint64_t a3, int *a4, void **a5)
{
  if (!Alembic::Ogawa::v12::IData::getSize(*a1))
  {
    if (Alembic::Ogawa::v12::IData::getSize(*a2))
    {
      unint64_t v12 = sub_21677D584(a4);
      if ((unint64_t)Alembic::Ogawa::v12::IData::getSize(*a2) > 0xF)
      {
        if (v12)
        {
          unint64_t v17 = (Alembic::Ogawa::v12::IData::getSize(*a2) - 16) / v12;
          sub_2167864B4(&__p, 1uLL, &v17);
          if (&__p != a5) {
            goto LABEL_21;
          }
        }
        else
        {
          unint64_t v17 = 0;
          sub_2167864B4(&__p, 1uLL, &v17);
          if (&__p != a5) {
LABEL_21:
          }
            sub_21677CC7C((char *)a5, (char *)__p, (uint64_t)v19, (v19 - (unsigned char *)__p) >> 3);
        }
      }
      else
      {
        unint64_t v17 = 0;
        sub_2167864B4(&__p, 1uLL, &v17);
        if (&__p != a5) {
          goto LABEL_21;
        }
      }
    }
    else
    {
      unint64_t v17 = 0;
      sub_2167864B4(&__p, 1uLL, &v17);
      if (&__p != a5) {
        goto LABEL_21;
      }
    }
    uint64_t v16 = __p;
    if (!__p) {
      return;
    }
    long long v19 = __p;
    goto LABEL_24;
  }
  unint64_t Size = Alembic::Ogawa::v12::IData::getSize(*a1);
  sub_2167951C4(a5, Size >> 3);
  sub_2167819D4(&__p, Size >> 3);
  uint64_t v11 = __p;
  if (__p != v19)
  {
    Alembic::Ogawa::v12::IData::read((unint64_t **)*a1, Size & 0xFFFFFFFFFFFFFFF8, __p, 0, a3);
    uint64_t v11 = __p;
    if (Size >= 8)
    {
      uint64_t v13 = 0;
      std::exception v14 = *a5;
      if (Size >> 3 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = Size >> 3;
      }
      do
      {
        v14[v13] = v11[v13];
        ++v13;
      }
      while (v15 != v13);
      goto LABEL_14;
    }
  }
  if (v11)
  {
LABEL_14:
    long long v19 = v11;
    uint64_t v16 = v11;
LABEL_24:
    operator delete(v16);
  }
}

void sub_216795198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167951C4(void *a1, unint64_t a2)
{
  uint64_t v4 = a1[1] - *a1;
  sub_21679A004((uint64_t)a1, a2);
  if (a2 > v4 >> 3)
  {
    std::exception v5 = (void *)(*a1 + (v4 & 0xFFFFFFFFFFFFFFF8));
    bzero(v5, 8 * a2 - (v4 & 0xFFFFFFFFFFFFFFF8));
  }
}

__n64 sub_216795238(int a1, int a2, int *a3, char *a4, unint64_t a5, __n64 result)
{
  switch(a1)
  {
    case 0:
      switch(a2)
      {
        case 1:
          for (; a5; --a5)
            a4[a5 - 1] = *((unsigned char *)a3 + a5 - 1) != 0;
          break;
        case 2:
          for (; a5; --a5)
            a4[a5 - 1] = *((unsigned char *)a3 + a5 - 1) != 0;
          break;
        case 3:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((unsigned char *)a3 + a5 - 1) != 0;
          break;
        case 4:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((unsigned char *)a3 + a5 - 1) != 0;
          break;
        case 5:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((unsigned char *)a3 + a5 - 1) != 0;
          break;
        case 6:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((unsigned char *)a3 + a5 - 1) != 0;
          break;
        case 7:
          for (; a5; --a5)
            *(void *)&a4[8 * a5 - 8] = *((unsigned char *)a3 + a5 - 1) != 0;
          break;
        case 8:
          for (; a5; --a5)
            *(void *)&a4[8 * a5 - 8] = *((unsigned char *)a3 + a5 - 1) != 0;
          break;
        case 9:
          sub_216796AD0((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          if (a5)
          {
            result.n64_f64[0] = 0.0;
            do
            {
              if (*((unsigned char *)a3 + a5 - 1)) {
                float v81 = 1.0;
              }
              else {
                float v81 = 0.0;
              }
              *(float *)&a4[4 * a5-- - 4] = v81;
            }
            while (a5);
          }
          break;
        case 11:
          if (a5)
          {
            result.n64_f64[0] = 0.0;
            do
            {
              if (*((unsigned char *)a3 + a5 - 1)) {
                double v82 = 1.0;
              }
              else {
                double v82 = 0.0;
              }
              *(double *)&a4[8 * a5-- - 8] = v82;
            }
            while (a5);
          }
          break;
        default:
          return result;
      }
      break;
    case 1:
      switch(a2)
      {
        case 0:
          for (; a5; --a5)
          {
            int v6 = *(unsigned __int8 *)a3;
            a3 = (int *)((char *)a3 + 1);
            *a4++ = v6 != 0;
          }
          break;
        case 2:
          for (; a5; --a5)
          {
            unsigned int v83 = *((unsigned __int8 *)a3 + a5 - 1);
            if (v83 >= 0x7F) {
              LOBYTE(v83) = 127;
            }
            a4[a5 - 1] = v83;
          }
          break;
        case 3:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 4:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 5:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 6:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 7:
          for (; a5; --a5)
            *(void *)&a4[8 * a5 - 8] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 8:
          for (; a5; --a5)
            *(void *)&a4[8 * a5 - 8] = *((unsigned __int8 *)a3 + a5 - 1);
          break;
        case 9:
          sub_216796BD0((uint64_t)a3, (uint64_t)a4, a5, result.n64_f32[0]);
          break;
        case 10:
          for (; a5; --a5)
          {
            result.n64_u8[0] = *((unsigned char *)a3 + a5 - 1);
            result.n64_f32[0] = (float)result.n64_u32[0];
            *(_DWORD *)&a4[4 * a5 - 4] = result.n64_u32[0];
          }
          break;
        case 11:
          for (; a5; --a5)
          {
            result.n64_u8[0] = *((unsigned char *)a3 + a5 - 1);
            result.n64_f64[0] = (double)result.n64_u64[0];
            *(double *)&a4[8 * a5 - 8] = result.n64_f64[0];
          }
          break;
        default:
          return result;
      }
      break;
    case 2:
      switch(a2)
      {
        case 0:
          for (; a5; --a5)
          {
            int v7 = *(unsigned __int8 *)a3;
            a3 = (int *)((char *)a3 + 1);
            *a4++ = v7 != 0;
          }
          break;
        case 1:
          for (; a5; --a5)
            a4[a5 - 1] = *((unsigned char *)a3 + a5 - 1) & ~(*((char *)a3 + a5 - 1) >> 31);
          break;
        case 3:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((char *)a3 + a5 - 1) & (unsigned __int16)~(unsigned __int16)(*((char *)a3 + a5 - 1) >> 31);
          break;
        case 4:
          for (; a5; --a5)
            *(_WORD *)&a4[2 * a5 - 2] = *((char *)a3 + a5 - 1);
          break;
        case 5:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((char *)a3 + a5 - 1) & ~(*((char *)a3 + a5 - 1) >> 31);
          break;
        case 6:
          for (; a5; --a5)
            *(_DWORD *)&a4[4 * a5 - 4] = *((char *)a3 + a5 - 1);
          break;
        case 7:
          for (; a5; --a5)
            *(void *)&a4[8 * a5 - 8] = *((char *)a3 + a5 - 1) & ~(*((char *)a3 + a5 - 1) >> 31);
          break;
        case 8:
          for (; a5; --a5)
            *(void *)&a4[8 * a5 - 8] = *((char *)a3 + a5 - 1);
          break;
        case 9:
          sub_216796CC8((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          for (; a5; --a5)
          {
            result.n64_f32[0] = (float)*((char *)a3 + a5 - 1);
            *(float *)&a4[4 * a5 - 4] = result.n64_f32[0];
          }
          break;
        case 11:
          for (; a5; --a5)
          {
            result.n64_f64[0] = (double)*((char *)a3 + a5 - 1);
            *(double *)&a4[8 * a5 - 8] = result.n64_f64[0];
          }
          break;
        default:
          return result;
      }
      break;
    case 3:
      switch(a2)
      {
        case 0:
          if (a5 >= 2)
          {
            unint64_t v8 = a5 >> 1;
            do
            {
              int v9 = *(unsigned __int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              *a4++ = v9 != 0;
              --v8;
            }
            while (v8);
          }
          break;
        case 1:
          if (a5 >= 2)
          {
            unint64_t v84 = a5 >> 1;
            do
            {
              unsigned int v86 = *(unsigned __int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              char v85 = v86;
              if (v86 >= 0xFF) {
                char v85 = -1;
              }
              *a4++ = v85;
              --v84;
            }
            while (v84);
          }
          break;
        case 2:
          if (a5 >= 2)
          {
            unint64_t v87 = a5 >> 1;
            do
            {
              unsigned int v89 = *(unsigned __int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              char v88 = v89;
              if (v89 >= 0x7F) {
                char v88 = 127;
              }
              *a4++ = v88;
              --v87;
            }
            while (v87);
          }
          break;
        case 4:
          if (a5 >= 2)
          {
            unint64_t v90 = a5 >> 1;
            do
            {
              unsigned int v91 = *((unsigned __int16 *)a3 + v90 - 1);
              if (v91 >= 0x7FFF) {
                LOWORD(v91) = 0x7FFF;
              }
              *(_WORD *)&a4[2 * v90-- - 2] = v91;
            }
            while (v90);
          }
          break;
        case 5:
          if (a5 >= 2)
          {
            unint64_t v92 = a5 >> 1;
            do
            {
              *(_DWORD *)&a4[4 * v92 - 4] = *((unsigned __int16 *)a3 + v92 - 1);
              --v92;
            }
            while (v92);
          }
          break;
        case 6:
          if (a5 >= 2)
          {
            unint64_t v93 = a5 >> 1;
            do
            {
              *(_DWORD *)&a4[4 * v93 - 4] = *((unsigned __int16 *)a3 + v93 - 1);
              --v93;
            }
            while (v93);
          }
          break;
        case 7:
          if (a5 >= 2)
          {
            unint64_t v94 = a5 >> 1;
            do
            {
              *(void *)&a4[8 * v94 - 8] = *((unsigned __int16 *)a3 + v94 - 1);
              --v94;
            }
            while (v94);
          }
          break;
        case 8:
          if (a5 >= 2)
          {
            unint64_t v95 = a5 >> 1;
            do
            {
              *(void *)&a4[8 * v95 - 8] = *((unsigned __int16 *)a3 + v95 - 1);
              --v95;
            }
            while (v95);
          }
          break;
        case 9:
          sub_216796DC0((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          if (a5 >= 2)
          {
            unint64_t v96 = a5 >> 1;
            do
            {
              result.n64_u16[0] = *((_WORD *)a3 + v96 - 1);
              result.n64_f32[0] = (float)result.n64_u32[0];
              *(_DWORD *)&a4[4 * v96-- - 4] = result.n64_u32[0];
            }
            while (v96);
          }
          break;
        case 11:
          if (a5 >= 2)
          {
            unint64_t v97 = a5 >> 1;
            do
            {
              result.n64_u16[0] = *((_WORD *)a3 + v97 - 1);
              result.n64_f64[0] = (double)result.n64_u64[0];
              *(double *)&a4[8 * v97-- - 8] = result.n64_f64[0];
            }
            while (v97);
          }
          break;
        default:
          return result;
      }
      break;
    case 4:
      switch(a2)
      {
        case 0:
          if (a5 >= 2)
          {
            unint64_t v10 = a5 >> 1;
            do
            {
              int v11 = *(unsigned __int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              *a4++ = v11 != 0;
              --v10;
            }
            while (v10);
          }
          break;
        case 1:
          if (a5 >= 2)
          {
            unint64_t v98 = a5 >> 1;
            do
            {
              int v100 = *(__int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              int v99 = v100;
              if (v100 >= 255) {
                int v99 = 255;
              }
              *a4++ = v99 & ~(v99 >> 31);
              --v98;
            }
            while (v98);
          }
          break;
        case 2:
          if (a5 >= 2)
          {
            unint64_t v101 = a5 >> 1;
            do
            {
              int v103 = *(__int16 *)a3;
              a3 = (int *)((char *)a3 + 2);
              int v102 = v103;
              if (v103 >= 127) {
                int v102 = 127;
              }
              if (v102 <= -128) {
                LOBYTE(v102) = 0x80;
              }
              *a4++ = v102;
              --v101;
            }
            while (v101);
          }
          break;
        case 3:
          if (a5 >= 2)
          {
            unint64_t v104 = a5 >> 1;
            do
            {
              *(_WORD *)&a4[2 * v104 - 2] = *((_WORD *)a3 + v104 - 1) & ~(*((__int16 *)a3 + v104 - 1) >> 15);
              --v104;
            }
            while (v104);
          }
          break;
        case 5:
          if (a5 >= 2)
          {
            unint64_t v105 = a5 >> 1;
            do
            {
              *(_DWORD *)&a4[4 * v105 - 4] = *((__int16 *)a3 + v105 - 1) & ~(*((__int16 *)a3 + v105 - 1) >> 31);
              --v105;
            }
            while (v105);
          }
          break;
        case 6:
          if (a5 >= 2)
          {
            unint64_t v106 = a5 >> 1;
            do
            {
              *(_DWORD *)&a4[4 * v106 - 4] = *((__int16 *)a3 + v106 - 1);
              --v106;
            }
            while (v106);
          }
          break;
        case 7:
          if (a5 >= 2)
          {
            unint64_t v107 = a5 >> 1;
            do
            {
              *(void *)&a4[8 * v107 - 8] = *((__int16 *)a3 + v107 - 1) & ~(*((__int16 *)a3 + v107 - 1) >> 31);
              --v107;
            }
            while (v107);
          }
          break;
        case 8:
          if (a5 >= 2)
          {
            unint64_t v108 = a5 >> 1;
            do
            {
              *(void *)&a4[8 * v108 - 8] = *((__int16 *)a3 + v108 - 1);
              --v108;
            }
            while (v108);
          }
          break;
        case 9:
          sub_216796ECC((unint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          if (a5 >= 2)
          {
            unint64_t v109 = a5 >> 1;
            do
            {
              result.n64_f32[0] = (float)*((__int16 *)a3 + v109 - 1);
              *(float *)&a4[4 * v109-- - 4] = result.n64_f32[0];
            }
            while (v109);
          }
          break;
        case 11:
          if (a5 >= 2)
          {
            unint64_t v110 = a5 >> 1;
            do
            {
              result.n64_f64[0] = (double)*((__int16 *)a3 + v110 - 1);
              *(double *)&a4[8 * v110-- - 8] = result.n64_f64[0];
            }
            while (v110);
          }
          break;
        default:
          return result;
      }
      break;
    case 5:
      switch(a2)
      {
        case 0:
          if (a5 >= 4)
          {
            unint64_t v12 = a5 >> 2;
            do
            {
              int v13 = *a3++;
              *a4++ = v13 != 0;
              --v12;
            }
            while (v12);
          }
          break;
        case 1:
          if (a5 >= 4)
          {
            unint64_t v44 = a5 >> 2;
            do
            {
              unsigned int v46 = *a3++;
              char v45 = v46;
              if (v46 >= 0xFF) {
                char v45 = -1;
              }
              *a4++ = v45;
              --v44;
            }
            while (v44);
          }
          break;
        case 2:
          if (a5 >= 4)
          {
            unint64_t v47 = a5 >> 2;
            do
            {
              unsigned int v49 = *a3++;
              char v48 = v49;
              if (v49 >= 0x7F) {
                char v48 = 127;
              }
              *a4++ = v48;
              --v47;
            }
            while (v47);
          }
          break;
        case 3:
          if (a5 >= 4)
          {
            unint64_t v50 = a5 >> 2;
            do
            {
              unsigned int v52 = *a3++;
              __int16 v51 = v52;
              if (v52 >= 0xFFFF) {
                __int16 v51 = -1;
              }
              *(_WORD *)a4 = v51;
              a4 += 2;
              --v50;
            }
            while (v50);
          }
          break;
        case 4:
          if (a5 >= 4)
          {
            unint64_t v53 = a5 >> 2;
            do
            {
              unsigned int v55 = *a3++;
              __int16 v54 = v55;
              if (v55 >= 0x7FFF) {
                __int16 v54 = 0x7FFF;
              }
              *(_WORD *)a4 = v54;
              a4 += 2;
              --v53;
            }
            while (v53);
          }
          break;
        case 6:
          if (a5 >= 4)
          {
            unint64_t v56 = a5 >> 2;
            do
            {
              unsigned int v57 = a3[v56 - 1];
              if (v57 >= 0x7FFFFFFF) {
                unsigned int v57 = 0x7FFFFFFF;
              }
              *(_DWORD *)&a4[4 * v56-- - 4] = v57;
            }
            while (v56);
          }
          break;
        case 7:
          if (a5 >= 4)
          {
            unint64_t v58 = a5 >> 2;
            do
            {
              *(void *)&a4[8 * v58 - 8] = a3[v58 - 1];
              --v58;
            }
            while (v58);
          }
          break;
        case 8:
          if (a5 >= 4)
          {
            unint64_t v59 = a5 >> 2;
            do
            {
              *(void *)&a4[8 * v59 - 8] = a3[v59 - 1];
              --v59;
            }
            while (v59);
          }
          break;
        case 9:
          if (a5 >= 4)
          {
            while (1)
              ;
          }
          break;
        case 11:
          if (a5 >= 4)
          {
            unint64_t v60 = a5 >> 2;
            do
            {
              result.n64_u32[0] = a3[v60 - 1];
              result.n64_f64[0] = (double)result.n64_u64[0];
              *(double *)&a4[8 * v60-- - 8] = result.n64_f64[0];
            }
            while (v60);
          }
          break;
        default:
          return result;
      }
      break;
    case 6:
      switch(a2)
      {
        case 0:
          if (a5 >= 4)
          {
            unint64_t v14 = a5 >> 2;
            do
            {
              int v15 = *a3++;
              *a4++ = v15 != 0;
              --v14;
            }
            while (v14);
          }
          break;
        case 1:
          if (a5 >= 4)
          {
            unint64_t v111 = a5 >> 2;
            do
            {
              int v113 = *a3++;
              int v112 = v113;
              if (v113 >= 255) {
                int v112 = 255;
              }
              *a4++ = v112 & ~(v112 >> 31);
              --v111;
            }
            while (v111);
          }
          break;
        case 2:
          if (a5 >= 4)
          {
            unint64_t v114 = a5 >> 2;
            do
            {
              int v116 = *a3++;
              int v115 = v116;
              if (v116 >= 127) {
                int v115 = 127;
              }
              if (v115 <= -128) {
                LOBYTE(v115) = 0x80;
              }
              *a4++ = v115;
              --v114;
            }
            while (v114);
          }
          break;
        case 3:
          if (a5 >= 4)
          {
            unint64_t v117 = a5 >> 2;
            do
            {
              int v119 = *a3++;
              int v118 = v119;
              if (v119 >= 0xFFFF) {
                int v118 = 0xFFFF;
              }
              *(_WORD *)a4 = v118 & ~(unsigned __int16)(v118 >> 31);
              a4 += 2;
              --v117;
            }
            while (v117);
          }
          break;
        case 4:
          if (a5 >= 4)
          {
            unint64_t v120 = a5 >> 2;
            do
            {
              int v122 = *a3++;
              int v121 = v122;
              if (v122 >= 0x7FFF) {
                int v121 = 0x7FFF;
              }
              if (v121 <= -32768) {
                LOWORD(v121) = 0x8000;
              }
              *(_WORD *)a4 = v121;
              a4 += 2;
              --v120;
            }
            while (v120);
          }
          break;
        case 5:
          if (a5 >= 4)
          {
            unint64_t v123 = a5 >> 2;
            do
            {
              *(_DWORD *)&a4[4 * v123 - 4] = a3[v123 - 1] & ~(a3[v123 - 1] >> 31);
              --v123;
            }
            while (v123);
          }
          break;
        case 7:
          if (a5 >= 4)
          {
            unint64_t v124 = a5 >> 2;
            do
            {
              *(void *)&a4[8 * v124 - 8] = a3[v124 - 1] & ~(a3[v124 - 1] >> 31);
              --v124;
            }
            while (v124);
          }
          break;
        case 8:
          if (a5 >= 4)
          {
            unint64_t v125 = a5 >> 2;
            do
            {
              *(void *)&a4[8 * v125 - 8] = a3[v125 - 1];
              --v125;
            }
            while (v125);
          }
          break;
        case 9:
          sub_216796FCC(a3, a4, a5);
          break;
        case 10:
          if (a5 >= 4)
          {
            unint64_t v126 = a5 >> 2;
            do
            {
              result.n64_f32[0] = (float)a3[v126 - 1];
              *(_DWORD *)&a4[4 * v126-- - 4] = result.n64_u32[0];
            }
            while (v126);
          }
          break;
        case 11:
          if (a5 >= 4)
          {
            unint64_t v127 = a5 >> 2;
            do
            {
              result.n64_f64[0] = (double)a3[v127 - 1];
              *(double *)&a4[8 * v127-- - 8] = result.n64_f64[0];
            }
            while (v127);
          }
          break;
        default:
          return result;
      }
      break;
    case 7:
      switch(a2)
      {
        case 0:
          if (a5 >= 8)
          {
            unint64_t v16 = a5 >> 3;
            do
            {
              unint64_t v17 = *(void *)a3;
              a3 += 2;
              *a4++ = v17 != 0;
              --v16;
            }
            while (v16);
          }
          break;
        case 1:
          if (a5 >= 8)
          {
            unint64_t v24 = a5 >> 3;
            do
            {
              unint64_t v26 = *(void *)a3;
              a3 += 2;
              char v25 = v26;
              if (v26 >= 0xFF) {
                char v25 = -1;
              }
              *a4++ = v25;
              --v24;
            }
            while (v24);
          }
          break;
        case 2:
          if (a5 >= 8)
          {
            unint64_t v27 = a5 >> 3;
            do
            {
              unint64_t v29 = *(void *)a3;
              a3 += 2;
              char v28 = v29;
              if (v29 >= 0x7F) {
                char v28 = 127;
              }
              *a4++ = v28;
              --v27;
            }
            while (v27);
          }
          break;
        case 3:
          if (a5 >= 8)
          {
            unint64_t v30 = a5 >> 3;
            do
            {
              unint64_t v32 = *(void *)a3;
              a3 += 2;
              __int16 v31 = v32;
              if (v32 >= 0xFFFF) {
                __int16 v31 = -1;
              }
              *(_WORD *)a4 = v31;
              a4 += 2;
              --v30;
            }
            while (v30);
          }
          break;
        case 4:
          if (a5 >= 8)
          {
            unint64_t v33 = a5 >> 3;
            do
            {
              unint64_t v35 = *(void *)a3;
              a3 += 2;
              __int16 v34 = v35;
              if (v35 >= 0x7FFF) {
                __int16 v34 = 0x7FFF;
              }
              *(_WORD *)a4 = v34;
              a4 += 2;
              --v33;
            }
            while (v33);
          }
          break;
        case 5:
          if (a5 >= 8)
          {
            unint64_t v36 = a5 >> 3;
            do
            {
              unint64_t v38 = *(void *)a3;
              a3 += 2;
              int v37 = v38;
              if (v38 >= 0xFFFFFFFF) {
                int v37 = -1;
              }
              *(_DWORD *)a4 = v37;
              a4 += 4;
              --v36;
            }
            while (v36);
          }
          break;
        case 6:
          if (a5 >= 8)
          {
            unint64_t v39 = a5 >> 3;
            do
            {
              unint64_t v41 = *(void *)a3;
              a3 += 2;
              int v40 = v41;
              if (v41 >= 0x7FFFFFFF) {
                int v40 = 0x7FFFFFFF;
              }
              *(_DWORD *)a4 = v40;
              a4 += 4;
              --v39;
            }
            while (v39);
          }
          break;
        case 8:
          if (a5 >= 8)
          {
            unint64_t v42 = a5 >> 3;
            do
            {
              unint64_t v43 = *(void *)&a3[2 * v42 - 2];
              if (v43 >= 0x7FFFFFFFFFFFFFFFLL) {
                unint64_t v43 = 0x7FFFFFFFFFFFFFFFLL;
              }
              *(void *)&a4[8 * v42-- - 8] = v43;
            }
            while (v42);
          }
          break;
        case 9:
          if (a5 >= 8)
          {
            while (1)
              ;
          }
          break;
        default:
          return result;
      }
      break;
    case 8:
      switch(a2)
      {
        case 0:
          if (a5 >= 8)
          {
            unint64_t v20 = a5 >> 3;
            do
            {
              unint64_t v21 = *(void *)a3;
              a3 += 2;
              *a4++ = v21 != 0;
              --v20;
            }
            while (v20);
          }
          break;
        case 1:
          if (a5 >= 8)
          {
            unint64_t v61 = a5 >> 3;
            do
            {
              uint64_t v63 = *(void *)a3;
              a3 += 2;
              uint64_t v62 = v63;
              if (v63 >= 255) {
                uint64_t v62 = 255;
              }
              *a4++ = v62 & ~(v62 >> 63);
              --v61;
            }
            while (v61);
          }
          break;
        case 2:
          if (a5 >= 8)
          {
            unint64_t v64 = a5 >> 3;
            do
            {
              uint64_t v66 = *(void *)a3;
              a3 += 2;
              uint64_t v65 = v66;
              if (v66 >= 127) {
                uint64_t v65 = 127;
              }
              if (v65 <= -128) {
                LOBYTE(v65) = 0x80;
              }
              *a4++ = v65;
              --v64;
            }
            while (v64);
          }
          break;
        case 3:
          if (a5 >= 8)
          {
            unint64_t v67 = a5 >> 3;
            do
            {
              uint64_t v69 = *(void *)a3;
              a3 += 2;
              uint64_t v68 = v69;
              if (v69 >= 0xFFFF) {
                uint64_t v68 = 0xFFFFLL;
              }
              *(_WORD *)a4 = v68 & ~(unsigned __int16)(v68 >> 63);
              a4 += 2;
              --v67;
            }
            while (v67);
          }
          break;
        case 4:
          if (a5 >= 8)
          {
            unint64_t v70 = a5 >> 3;
            do
            {
              uint64_t v72 = *(void *)a3;
              a3 += 2;
              uint64_t v71 = v72;
              if (v72 >= 0x7FFF) {
                uint64_t v71 = 0x7FFFLL;
              }
              if (v71 <= -32768) {
                LOWORD(v71) = 0x8000;
              }
              *(_WORD *)a4 = v71;
              a4 += 2;
              --v70;
            }
            while (v70);
          }
          break;
        case 5:
          if (a5 >= 8)
          {
            unint64_t v73 = a5 >> 3;
            do
            {
              uint64_t v75 = *(void *)a3;
              a3 += 2;
              uint64_t v74 = v75;
              if (v75 >= 0xFFFFFFFFLL) {
                uint64_t v74 = 0xFFFFFFFFLL;
              }
              *(_DWORD *)a4 = v74 & ~(v74 >> 63);
              a4 += 4;
              --v73;
            }
            while (v73);
          }
          break;
        case 6:
          if (a5 >= 8)
          {
            unint64_t v76 = a5 >> 3;
            do
            {
              uint64_t v78 = *(void *)a3;
              a3 += 2;
              int64_t v77 = v78;
              if (v78 >= 0x7FFFFFFF) {
                int64_t v77 = 0x7FFFFFFFLL;
              }
              if (v77 <= (uint64_t)0xFFFFFFFF80000000) {
                LODWORD(v77) = 0x80000000;
              }
              *(_DWORD *)a4 = v77;
              a4 += 4;
              --v76;
            }
            while (v76);
          }
          break;
        case 7:
          if (a5 >= 8)
          {
            unint64_t v79 = a5 >> 3;
            do
            {
              *(void *)&a4[8 * v79 - 8] = *(void *)&a3[2 * v79 - 2] & ~(*(uint64_t *)&a3[2 * v79 - 2] >> 63);
              --v79;
            }
            while (v79);
          }
          break;
        case 9:
          sub_2167970D8((uint64_t *)a3, a4, a5);
          break;
        case 11:
          if (a5 >= 8)
          {
            unint64_t v80 = a5 >> 3;
            do
            {
              result.n64_f64[0] = (double)*(uint64_t *)&a3[2 * v80 - 2];
              *(double *)&a4[8 * v80-- - 8] = result.n64_f64[0];
            }
            while (v80);
          }
          break;
        default:
          return result;
      }
      break;
    case 9:
      switch(a2)
      {
        case 0:
          sub_2167971E4((unsigned __int16 *)a3, (BOOL *)a4, a5);
          break;
        case 1:
          result.n64_f32[0] = sub_21679725C((__int16 *)a3, a4, a5);
          break;
        case 2:
          sub_216797354((__int16 *)a3, a4, a5);
          break;
        case 3:
          sub_216797450((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 4:
          sub_216797558((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 5:
          sub_216797684((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 6:
          sub_21679778C((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 7:
          sub_2167978A0((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 8:
          sub_2167979A8((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 10:
          sub_216797ABC((uint64_t)a3, (uint64_t)a4, a5);
          break;
        case 11:
          sub_216797BC8((uint64_t)a3, (uint64_t)a4, a5);
          break;
        default:
          return result;
      }
      break;
    case 10:
      switch(a2)
      {
        case 0:
          if (a5 >= 4)
          {
            unint64_t v22 = a5 >> 2;
            do
            {
              float v23 = *(float *)a3++;
              result.n64_f32[0] = v23;
              *a4++ = v23 != 0.0;
              --v22;
            }
            while (v22);
          }
          break;
        case 1:
          sub_216797CDC((float *)a3, a4, a5);
          break;
        case 2:
          sub_216797D2C((float *)a3, a4, a5);
          break;
        case 3:
          sub_216797D7C((float *)a3, a4, a5);
          break;
        case 4:
          sub_216797DC8((float *)a3, a4, a5);
          break;
        case 5:
          if (a5 >= 4)
          {
            unint64_t v139 = a5 >> 2;
            do
            {
              float v140 = *(float *)&a3[v139 - 1];
              result.n64_f64[0] = 0.0;
              if (v140 >= 0.0)
              {
                result.n64_u32[0] = a3[v139 - 1];
                if (v140 > 3.4028e38) {
                  result.n64_u32[0] = 2139095039;
                }
              }
              *(_DWORD *)&a4[4 * v139-- - 4] = result.n64_f32[0];
            }
            while (v139);
          }
          break;
        case 6:
          if (a5 >= 4)
          {
            unint64_t v141 = a5 >> 2;
            do
            {
              float v142 = *(float *)&a3[v141 - 1];
              result.n64_u32[0] = -8388609;
              if (v142 >= -3.4028e38)
              {
                result.n64_u32[0] = a3[v141 - 1];
                if (v142 > 3.4028e38) {
                  result.n64_u32[0] = 2139095039;
                }
              }
              *(_DWORD *)&a4[4 * v141-- - 4] = (int)result.n64_f32[0];
            }
            while (v141);
          }
          break;
        case 7:
          if (a5 >= 4)
          {
            unint64_t v143 = a5 >> 2;
            do
            {
              float v144 = *(float *)&a3[v143 - 1];
              result.n64_f64[0] = 0.0;
              if (v144 >= 0.0)
              {
                result.n64_u32[0] = a3[v143 - 1];
                if (v144 > 3.4028e38) {
                  result.n64_u32[0] = 2139095039;
                }
              }
              *(void *)&a4[8 * v143-- - 8] = (unint64_t)result.n64_f32[0];
            }
            while (v143);
          }
          break;
        case 8:
          if (a5 >= 4)
          {
            unint64_t v145 = a5 >> 2;
            do
            {
              float v146 = *(float *)&a3[v145 - 1];
              result.n64_u32[0] = -8388609;
              if (v146 >= -3.4028e38)
              {
                result.n64_u32[0] = a3[v145 - 1];
                if (v146 > 3.4028e38) {
                  result.n64_u32[0] = 2139095039;
                }
              }
              *(void *)&a4[8 * v145-- - 8] = (uint64_t)result.n64_f32[0];
            }
            while (v145);
          }
          break;
        case 9:
          sub_216797E14((float *)a3, a4, a5);
          break;
        case 11:
          if (a5 >= 4)
          {
            unint64_t v147 = a5 >> 2;
            do
            {
              float v148 = *(float *)&a3[v147 - 1];
              float v149 = -3.4028e38;
              if (v148 >= -3.4028e38)
              {
                float v149 = *(float *)&a3[v147 - 1];
                if (v148 > 3.4028e38) {
                  float v149 = 3.4028e38;
                }
              }
              result.n64_f64[0] = v149;
              *(double *)&a4[8 * v147-- - 8] = result.n64_f64[0];
            }
            while (v147);
          }
          break;
        default:
          return result;
      }
      break;
    case 11:
      switch(a2)
      {
        case 0:
          if (a5 >= 8)
          {
            unint64_t v18 = a5 >> 3;
            do
            {
              double v19 = *(double *)a3;
              a3 += 2;
              result.n64_f64[0] = v19;
              *a4++ = v19 != 0.0;
              --v18;
            }
            while (v18);
          }
          break;
        case 1:
          sub_216797F34((double *)a3, a4, a5);
          break;
        case 2:
          sub_216797F80((double *)a3, a4, a5);
          break;
        case 3:
          sub_216797FD0((double *)a3, a4, a5);
          break;
        case 4:
          sub_21679801C((double *)a3, a4, a5);
          break;
        case 5:
          if (a5 >= 8)
          {
            unint64_t v128 = a5 >> 3;
            result.n64_f64[0] = 4294967300.0;
            do
            {
              double v129 = 0.0;
              if (*(double *)a3 >= 0.0)
              {
                double v129 = *(double *)a3;
                if (*(double *)a3 > 4294967300.0) {
                  double v129 = 4294967300.0;
                }
              }
              *(_DWORD *)a4 = v129;
              a4 += 4;
              a3 += 2;
              --v128;
            }
            while (v128);
          }
          break;
        case 6:
          if (a5 >= 8)
          {
            unint64_t v130 = a5 >> 3;
            result.n64_f64[0] = 2147483650.0;
            do
            {
              double v131 = -2147483650.0;
              if (*(double *)a3 >= -2147483650.0)
              {
                double v131 = *(double *)a3;
                if (*(double *)a3 > 2147483650.0) {
                  double v131 = 2147483650.0;
                }
              }
              *(_DWORD *)a4 = (int)v131;
              a4 += 4;
              a3 += 2;
              --v130;
            }
            while (v130);
          }
          break;
        case 7:
          if (a5 >= 8)
          {
            unint64_t v132 = a5 >> 3;
            do
            {
              double v133 = *(double *)&a3[2 * v132 - 2];
              result.n64_f64[0] = 0.0;
              if (v133 >= 0.0)
              {
                result.n64_u64[0] = *(unint64_t *)&a3[2 * v132 - 2];
                if (v133 > 1.79769313e308) {
                  result.n64_f64[0] = 1.79769313e308;
                }
              }
              *(void *)&a4[8 * v132-- - 8] = (unint64_t)result.n64_f64[0];
            }
            while (v132);
          }
          break;
        case 8:
          if (a5 >= 8)
          {
            unint64_t v134 = a5 >> 3;
            do
            {
              double v135 = *(double *)&a3[2 * v134 - 2];
              result.n64_f64[0] = -1.79769313e308;
              if (v135 >= -1.79769313e308)
              {
                result.n64_u64[0] = *(unint64_t *)&a3[2 * v134 - 2];
                if (v135 > 1.79769313e308) {
                  result.n64_f64[0] = 1.79769313e308;
                }
              }
              *(void *)&a4[8 * v134-- - 8] = (uint64_t)result.n64_f64[0];
            }
            while (v134);
          }
          break;
        case 9:
          sub_21679806C((double *)a3, a4, a5);
          break;
        case 10:
          if (a5 >= 8)
          {
            unint64_t v136 = a5 >> 3;
            result.n64_f64[0] = -3.40282347e38;
            do
            {
              double v137 = -3.40282347e38;
              if (*(double *)a3 >= -3.40282347e38)
              {
                double v137 = *(double *)a3;
                if (*(double *)a3 > 3.40282347e38) {
                  double v137 = 3.40282347e38;
                }
              }
              float v138 = v137;
              *(float *)a4 = v138;
              a4 += 4;
              a3 += 2;
              --v136;
            }
            while (v136);
          }
          break;
        default:
          return result;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_216796AD0(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = result - 1;
    do
    {
      if (*(unsigned char *)(v3 + a3)) {
        float v4 = 1.0;
      }
      else {
        float v4 = 0.0;
      }
      double result = LODWORD(v4);
      unsigned int v5 = LODWORD(v4) >> 23;
      if (LODWORD(v4) >> 23 < 0x71)
      {
        if (LODWORD(v4) >= 0x33000001)
        {
          unsigned int v7 = LODWORD(v4) & 0x7FFFFF | 0x800000;
          double result = v7 << (v5 - 94);
          unsigned int v6 = v7 >> (126 - (LODWORD(v4) >> 23));
          if (result > 0x80000000
            || (result == 0x80000000 ? (BOOL v8 = ((v7 >> (126 - (LODWORD(v4) >> 23))) & 1) == 0) : (BOOL v8 = 1), !v8))
          {
            LOWORD(v6) = v6 + 1;
          }
        }
        else
        {
          LOWORD(v6) = 0;
        }
      }
      else if (v5 >= 0xFF)
      {
        LOWORD(v6) = 31744;
        if (v4 != INFINITY)
        {
          double result = (((LODWORD(v4) >> 13) & 0x3FF) == 0) | (LODWORD(v4) >> 13) & 0x3FF;
          LOWORD(v6) = (((LODWORD(v4) >> 13) & 0x3FF) == 0) | (LODWORD(v4) >> 13) & 0x3FF | 0x7C00;
        }
      }
      else if (LODWORD(v4) >= 0x477FF000)
      {
        LOWORD(v6) = 31744;
      }
      else
      {
        double result = (LODWORD(v4) + 134221823);
        unsigned int v6 = (result + ((LODWORD(v4) >> 13) & 1)) >> 13;
      }
      *(_WORD *)(a2 - 2 + 2 * a3--) = v6;
    }
    while (a3);
  }
  return result;
}

uint64_t sub_216796BD0(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  if (a3)
  {
    uint64_t v4 = result - 1;
    do
    {
      LOBYTE(a4) = *(unsigned char *)(v4 + a3);
      a4 = (float)LODWORD(a4);
      double result = LODWORD(a4) & 0x7FFFFFFF;
      int v5 = HIWORD(LODWORD(a4)) & 0x8000;
      if ((LODWORD(a4) >> 23) < 0x71u)
      {
        if (result >= 0x33000001)
        {
          unsigned int v7 = 126 - (result >> 23);
          unsigned int v8 = LODWORD(a4) & 0x7FFFFF | 0x800000;
          double result = v8 << ((result >> 23) - 94);
          int v5 = (v8 >> v7) | HIWORD(LODWORD(a4)) & 0x8000;
          if (result > 0x80000000
            || (result == 0x80000000 ? (BOOL v9 = ((v8 >> v7) & 1) == 0) : (BOOL v9 = 1), !v9))
          {
            LOWORD(v5) = v5 + 1;
          }
        }
      }
      else
      {
        unsigned int v6 = v5 | ((LODWORD(a4) + 134221823 + ((LODWORD(a4) >> 13) & 1)) >> 13);
        LOWORD(v5) = v5 | 0x7C00;
        if (result >= 0x477FF000) {
          LOWORD(v6) = v5;
        }
        if (result != 2139095040) {
          LOWORD(v5) = (((LODWORD(a4) >> 13) & 0x3FF) == 0) | (LODWORD(a4) >> 13) & 0x3FF | v5;
        }
        if (result >> 23 < 0xFF) {
          LOWORD(v5) = v6;
        }
      }
      *(_WORD *)(a2 - 2 + 2 * a3--) = v5;
    }
    while (a3);
  }
  return result;
}

uint64_t sub_216796CC8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = result - 1;
    uint64_t v4 = a2 - 2;
    do
    {
      float v5 = (float)*(char *)(v3 + a3);
      double result = COERCE_UNSIGNED_INT(fabs(v5));
      int v6 = HIWORD(LODWORD(v5)) & 0x8000;
      if ((LODWORD(v5) >> 23) < 0x71u)
      {
        if (result >= 0x33000001)
        {
          unsigned int v9 = 126 - (result >> 23);
          unsigned int v10 = LODWORD(v5) & 0x7FFFFF | 0x800000;
          double result = v10 << ((result >> 23) - 94);
          int v6 = (v10 >> v9) | HIWORD(LODWORD(v5)) & 0x8000;
          if (result > 0x80000000
            || (result == 0x80000000 ? (BOOL v11 = ((v10 >> v9) & 1) == 0) : (BOOL v11 = 1), !v11))
          {
            LOWORD(v6) = v6 + 1;
          }
        }
      }
      else
      {
        unsigned int v7 = v6 | ((LODWORD(v5) + 134221823 + ((LODWORD(v5) >> 13) & 1)) >> 13);
        v6 |= 0x7C00u;
        if (result >= 0x477FF000) {
          LOWORD(v7) = v6;
        }
        int v8 = (((LODWORD(v5) >> 13) & 0x3FF) == 0) | (LODWORD(v5) >> 13) & 0x3FF | v6;
        if (result != 2139095040) {
          LOWORD(v6) = v8;
        }
        if (result >> 23 < 0xFF) {
          LOWORD(v6) = v7;
        }
      }
      *(_WORD *)(v4 + 2 * a3--) = v6;
    }
    while (a3);
  }
  return result;
}

uint64_t sub_216796DC0(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 2;
    double result = 0x80000000;
    do
    {
      unsigned int v6 = *(unsigned __int16 *)(v4 + 2 * v3);
      if (v6 >= 0xFFE0) {
        unsigned int v6 = 65504;
      }
      float v7 = (float)v6;
      float v8 = fabs((float)v6);
      unsigned int v9 = HIWORD(COERCE_UNSIGNED_INT((float)v6));
      int v10 = v9 & 0x8000;
      if ((LODWORD(v7) >> 23) < 0x71u)
      {
        if (LODWORD(v8) >= 0x33000001)
        {
          int v13 = 126 - (LODWORD(v8) >> 23);
          unsigned int v14 = LODWORD(v7) & 0x7FFFFF | 0x800000;
          unsigned int v15 = v14 << ((LODWORD(v8) >> 23) - 94);
          int v10 = (v14 >> v13) | v9 & 0x8000;
          if (v15 > 0x80000000 || (v15 == 0x80000000 ? (BOOL v16 = ((v14 >> v13) & 1) == 0) : (BOOL v16 = 1), !v16)) {
            LOWORD(v10) = v10 + 1;
          }
        }
      }
      else
      {
        unsigned int v11 = v10 | ((LODWORD(v7) + 134221823 + ((LODWORD(v7) >> 13) & 1)) >> 13);
        v10 |= 0x7C00u;
        if (LODWORD(v8) >= 0x477FF000) {
          LOWORD(v11) = v10;
        }
        int v12 = (((LODWORD(v7) >> 13) & 0x3FF) == 0) | (LODWORD(v7) >> 13) & 0x3FF | v10;
        if (v8 != INFINITY) {
          LOWORD(v10) = v12;
        }
        if (LODWORD(v8) >> 23 < 0xFF) {
          LOWORD(v10) = v11;
        }
      }
      *(_WORD *)(v5 + 2 * v3--) = v10;
    }
    while (v3);
  }
  return result;
}

unint64_t sub_216796ECC(unint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    unint64_t v4 = result - 2;
    uint64_t v5 = a2 - 2;
    do
    {
      float v6 = (float)*(__int16 *)(v4 + 2 * v3);
      float v7 = fabs(v6);
      int v8 = HIWORD(LODWORD(v6)) & 0x8000;
      if ((LODWORD(v6) >> 23) < 0x71u)
      {
        if (LODWORD(v7) >= 0x33000001)
        {
          int v11 = 126 - (LODWORD(v7) >> 23);
          unsigned int v12 = LODWORD(v6) & 0x7FFFFF | 0x800000;
          unsigned int v13 = v12 << ((LODWORD(v7) >> 23) - 94);
          int v8 = (v12 >> v11) | HIWORD(LODWORD(v6)) & 0x8000;
          if (v13 > 0x80000000 || (v13 == 0x80000000 ? (BOOL v14 = ((v12 >> v11) & 1) == 0) : (BOOL v14 = 1), !v14)) {
            LOWORD(v8) = v8 + 1;
          }
        }
      }
      else
      {
        unsigned int v9 = v8 | ((LODWORD(v6) + 134221823 + ((LODWORD(v6) >> 13) & 1)) >> 13);
        v8 |= 0x7C00u;
        if (LODWORD(v7) >= 0x477FF000) {
          LOWORD(v9) = v8;
        }
        int v10 = (((LODWORD(v6) >> 13) & 0x3FF) == 0) | (LODWORD(v6) >> 13) & 0x3FF | v8;
        if (v7 != INFINITY) {
          LOWORD(v8) = v10;
        }
        if (LODWORD(v7) >> 23 < 0xFF) {
          LOWORD(v8) = v9;
        }
      }
      *(_WORD *)(v5 + 2 * v3) = v8;
      double result = v3 - 1;
      unint64_t v3 = result;
    }
    while (result);
  }
  return result;
}

int *sub_216796FCC(int *result, _WORD *a2, unint64_t a3)
{
  if (a3 >= 4)
  {
    unint64_t v3 = a3 >> 2;
    do
    {
      int v5 = *result++;
      int v4 = v5;
      if (v5 >= 65504) {
        int v4 = 65504;
      }
      if (v4 <= -65504) {
        int v4 = -65504;
      }
      float v6 = (float)v4;
      float v7 = fabs((float)v4);
      unsigned int v8 = HIWORD(COERCE_UNSIGNED_INT((float)v4));
      int v9 = v8 & 0x8000;
      if ((LODWORD(v6) >> 23) < 0x71u)
      {
        if (LODWORD(v7) >= 0x33000001)
        {
          int v12 = 126 - (LODWORD(v7) >> 23);
          unsigned int v13 = LODWORD(v6) & 0x7FFFFF | 0x800000;
          unsigned int v14 = v13 << ((LODWORD(v7) >> 23) - 94);
          int v9 = (v13 >> v12) | v8 & 0x8000;
          if (v14 > 0x80000000 || (v14 == 0x80000000 ? (BOOL v15 = ((v13 >> v12) & 1) == 0) : (BOOL v15 = 1), !v15)) {
            LOWORD(v9) = v9 + 1;
          }
        }
      }
      else
      {
        unsigned int v10 = v9 | ((LODWORD(v6) + 134221823 + ((LODWORD(v6) >> 13) & 1)) >> 13);
        v9 |= 0x7C00u;
        if (LODWORD(v7) >= 0x477FF000) {
          LOWORD(v10) = v9;
        }
        int v11 = (((LODWORD(v6) >> 13) & 0x3FF) == 0) | (LODWORD(v6) >> 13) & 0x3FF | v9;
        if (v7 != INFINITY) {
          LOWORD(v9) = v11;
        }
        if (LODWORD(v7) >> 23 < 0xFF) {
          LOWORD(v9) = v10;
        }
      }
      *a2++ = v9;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t *sub_2167970D8(uint64_t *result, _WORD *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    unint64_t v3 = a3 >> 3;
    do
    {
      uint64_t v5 = *result++;
      uint64_t v4 = v5;
      if (v5 >= 65504) {
        uint64_t v4 = 65504;
      }
      if (v4 <= -65504) {
        uint64_t v4 = -65504;
      }
      float v6 = (float)v4;
      float v7 = fabs((float)v4);
      unsigned int v8 = HIWORD(COERCE_UNSIGNED_INT((float)v4));
      int v9 = v8 & 0x8000;
      if ((LODWORD(v6) >> 23) < 0x71u)
      {
        if (LODWORD(v7) >= 0x33000001)
        {
          int v12 = 126 - (LODWORD(v7) >> 23);
          unsigned int v13 = LODWORD(v6) & 0x7FFFFF | 0x800000;
          unsigned int v14 = v13 << ((LODWORD(v7) >> 23) - 94);
          int v9 = (v13 >> v12) | v8 & 0x8000;
          if (v14 > 0x80000000 || (v14 == 0x80000000 ? (BOOL v15 = ((v13 >> v12) & 1) == 0) : (BOOL v15 = 1), !v15)) {
            LOWORD(v9) = v9 + 1;
          }
        }
      }
      else
      {
        unsigned int v10 = v9 | ((LODWORD(v6) + 134221823 + ((LODWORD(v6) >> 13) & 1)) >> 13);
        v9 |= 0x7C00u;
        if (LODWORD(v7) >= 0x477FF000) {
          LOWORD(v10) = v9;
        }
        int v11 = (((LODWORD(v6) >> 13) & 0x3FF) == 0) | (LODWORD(v6) >> 13) & 0x3FF | v9;
        if (v7 != INFINITY) {
          LOWORD(v9) = v11;
        }
        if (LODWORD(v7) >> 23 < 0xFF) {
          LOWORD(v9) = v10;
        }
      }
      *a2++ = v9;
      --v3;
    }
    while (v3);
  }
  return result;
}

unsigned __int16 *sub_2167971E4(unsigned __int16 *result, BOOL *a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    do
    {
      int v4 = *result++;
      int v5 = v4 << 13;
      unsigned int v6 = (v4 << 13) & 0xFFFE000;
      if (v6 < 0x800000)
      {
        if (v6)
        {
          unsigned int v7 = __clz(v6) - 8;
          unsigned int v6 = ((v6 << v7) | 0x38800000) - (v7 << 23);
        }
      }
      else if (v6 >> 23 > 0x1E)
      {
        unsigned int v6 = v5 | 0x7F800000;
      }
      else
      {
        v6 += 939524096;
      }
      *a2++ = (v6 & 0x7FFFFFFF) != 0;
      --v3;
    }
    while (v3);
  }
  return result;
}

float sub_21679725C(__int16 *a1, unsigned char *a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    for (unint64_t i = a3 >> 1; i; --i)
    {
      int v4 = *a1++;
      unsigned int v5 = (v4 & 0x7FFF) << 13;
      int v6 = v4 & 0x80000000;
      unsigned int v7 = __clz(v5) - 8;
      LODWORD(v8) = (v4 & 0x80000000 | 0x38800000 | (v5 << v7)) - (v7 << 23);
      if (v5) {
        float v9 = v8;
      }
      else {
        float v9 = *(float *)&v6;
      }
      unsigned int v10 = v5 >> 23;
      int v11 = v5 | v6 | 0x7F800000;
      if (v5 >> 23 <= 0x1E) {
        int v12 = (v5 | v6) + 939524096;
      }
      else {
        int v12 = v5 | v6 | 0x7F800000;
      }
      if (v5 >= 0x800000) {
        float v9 = *(float *)&v12;
      }
      if (v9 >= 0.0)
      {
        if (!v5) {
          float v8 = *(float *)&v6;
        }
        if (v10 <= 0x1E) {
          int v11 = (v5 | v6) + 939524096;
        }
        if (v5 >= 0x800000) {
          float v8 = *(float *)&v11;
        }
        if (v8 <= 255.0)
        {
          if (v5 < 0x800000)
          {
            if (v5) {
              int v6 = (v6 | 0x38800000 | (v5 << v7)) - (v7 << 23);
            }
            goto LABEL_24;
          }
          int v13 = v5 | v6;
          if (v10 > 0x1E)
          {
            int v6 = v13 | 0x7F800000;
            goto LABEL_24;
          }
        }
        else
        {
          int v13 = 192872448;
        }
        int v6 = v13 + 939524096;
      }
      else
      {
        *(float *)&int v6 = 0.0;
      }
LABEL_24:
      float result = *(float *)&v6;
      *a2++ = (int)*(float *)&v6;
    }
  }
  return result;
}

__int16 *sub_216797354(__int16 *result, unsigned char *a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    for (unint64_t i = a3 >> 1; i; --i)
    {
      int v4 = *result++;
      unsigned int v5 = (v4 & 0x7FFF) << 13;
      int v6 = v4 & 0x80000000;
      unsigned int v7 = __clz(v5) - 8;
      LODWORD(v8) = (v4 & 0x80000000 | 0x38800000 | (v5 << v7)) - (v7 << 23);
      if (v5) {
        float v9 = v8;
      }
      else {
        float v9 = *(float *)&v6;
      }
      unsigned int v10 = v5 >> 23;
      int v11 = v5 | v6 | 0x7F800000;
      if (v5 >> 23 <= 0x1E) {
        int v12 = (v5 | v6) + 939524096;
      }
      else {
        int v12 = v5 | v6 | 0x7F800000;
      }
      if (v5 >= 0x800000) {
        float v9 = *(float *)&v12;
      }
      if (v9 >= -128.0)
      {
        if (!v5) {
          float v8 = *(float *)&v6;
        }
        if (v10 <= 0x1E) {
          int v11 = (v5 | v6) + 939524096;
        }
        if (v5 >= 0x800000) {
          float v8 = *(float *)&v11;
        }
        if (v8 <= 127.0)
        {
          if (v5 < 0x800000)
          {
            if (v5) {
              int v6 = (v6 | 0x38800000 | (v5 << v7)) - (v7 << 23);
            }
            goto LABEL_24;
          }
          int v13 = v5 | v6;
          if (v10 > 0x1E)
          {
            int v6 = v13 | 0x7F800000;
            goto LABEL_24;
          }
        }
        else
        {
          int v13 = 184418304;
        }
      }
      else
      {
        int v13 = -1962934272;
      }
      int v6 = v13 + 939524096;
LABEL_24:
      *a2++ = (int)*(float *)&v6;
    }
  }
  return result;
}

uint64_t sub_216797450(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 2;
    do
    {
      int v6 = *(__int16 *)(v4 + 2 * v3);
      unsigned int v7 = (v6 & 0x7FFF) << 13;
      int v8 = v6 & 0x80000000;
      unsigned int v9 = __clz(v7) - 8;
      float result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7) {
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      }
      else {
        float v10 = *(float *)&v8;
      }
      unsigned int v11 = v7 >> 23;
      unsigned int v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E) {
        int v13 = (v7 | v8) + 939524096;
      }
      else {
        int v13 = v7 | v8 | 0x7F800000;
      }
      if (v7 >= 0x800000) {
        float v10 = *(float *)&v13;
      }
      if (v10 >= 0.0)
      {
        if (!v7) {
          LODWORD(result) = v8;
        }
        if (v11 <= 0x1E) {
          unsigned int v12 = (v7 | v8) + 939524096;
        }
        if (v7 >= 0x800000) {
          float result = v12;
        }
        else {
          float result = result;
        }
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7) {
              int v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            }
            goto LABEL_25;
          }
          int v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            int v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          int v14 = 260038656;
        }
        int v8 = v14 + 939524096;
      }
      else
      {
        *(float *)&int v8 = 0.0;
      }
LABEL_25:
      *(_WORD *)(v5 + 2 * v3--) = (int)*(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_216797558(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 2;
    do
    {
      int v6 = *(__int16 *)(v4 + 2 * v3);
      unsigned int v7 = (v6 & 0x7FFF) << 13;
      unsigned int v8 = v6 & 0x80000000;
      unsigned int v9 = __clz(v7) - 8;
      unsigned int v10 = (v6 & 0x80000000 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7) {
        float v11 = *(float *)&v10;
      }
      else {
        LODWORD(v11) = v6 & 0x80000000;
      }
      float result = v7 >> 23;
      int v12 = v7 | v8 | 0x7F800000;
      int v13 = (v7 | v8) + 939524096;
      if (result <= 0x1E) {
        int v14 = (v7 | v8) + 939524096;
      }
      else {
        int v14 = v7 | v8 | 0x7F800000;
      }
      if (v7 >= 0x800000) {
        float v11 = *(float *)&v14;
      }
      if (v11 >= -65504.0)
      {
        if (v7) {
          unsigned int v8 = v10;
        }
        if (result <= 0x1E) {
          float v16 = *(float *)&v13;
        }
        else {
          float v16 = *(float *)&v12;
        }
        if (v7 >= 0x800000) {
          float v17 = v16;
        }
        else {
          float v17 = *(float *)&v8;
        }
        if (v17 <= 65504.0) {
          int v18 = *(unsigned __int16 *)(v4 + 2 * v3);
        }
        else {
          int v18 = 31743;
        }
        unsigned int v19 = (v18 & 0x7FFF) << 13;
        int v20 = (v18 << 16) & 0x80000000;
        if (v19 < 0x800000)
        {
          if (v19)
          {
            unsigned int v21 = __clz(v19) - 8;
            int v20 = (v20 | 0x38800000 | (v19 << v21)) - (v21 << 23);
          }
          goto LABEL_27;
        }
        int v15 = v19 | v20;
        if (v19 >> 23 > 0x1E)
        {
          int v20 = v15 | 0x7F800000;
          goto LABEL_27;
        }
      }
      else
      {
        int v15 = -1887444992;
      }
      int v20 = v15 + 939524096;
LABEL_27:
      *(_WORD *)(v5 + 2 * v3--) = (int)*(float *)&v20;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_216797684(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 4;
    do
    {
      int v6 = *(__int16 *)(v4 + 2 * v3);
      unsigned int v7 = (v6 & 0x7FFF) << 13;
      int v8 = v6 & 0x80000000;
      unsigned int v9 = __clz(v7) - 8;
      float result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7) {
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      }
      else {
        float v10 = *(float *)&v8;
      }
      unsigned int v11 = v7 >> 23;
      unsigned int v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E) {
        int v13 = (v7 | v8) + 939524096;
      }
      else {
        int v13 = v7 | v8 | 0x7F800000;
      }
      if (v7 >= 0x800000) {
        float v10 = *(float *)&v13;
      }
      if (v10 >= 0.0)
      {
        if (!v7) {
          LODWORD(result) = v8;
        }
        if (v11 <= 0x1E) {
          unsigned int v12 = (v7 | v8) + 939524096;
        }
        if (v7 >= 0x800000) {
          float result = v12;
        }
        else {
          float result = result;
        }
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7) {
              int v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            }
            goto LABEL_25;
          }
          int v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            int v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          int v14 = 260038656;
        }
        int v8 = v14 + 939524096;
      }
      else
      {
        *(float *)&int v8 = 0.0;
      }
LABEL_25:
      *(_DWORD *)(v5 + 4 * v3--) = *(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_21679778C(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 4;
    do
    {
      int v6 = *(__int16 *)(v4 + 2 * v3);
      unsigned int v7 = (v6 & 0x7FFF) << 13;
      int v8 = v6 & 0x80000000;
      unsigned int v9 = __clz(v7) - 8;
      float result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7) {
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      }
      else {
        float v10 = *(float *)&v8;
      }
      unsigned int v11 = v7 >> 23;
      unsigned int v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E) {
        int v13 = (v7 | v8) + 939524096;
      }
      else {
        int v13 = v7 | v8 | 0x7F800000;
      }
      if (v7 >= 0x800000) {
        float v10 = *(float *)&v13;
      }
      if (v10 >= -65504.0)
      {
        if (!v7) {
          LODWORD(result) = v8;
        }
        if (v11 <= 0x1E) {
          unsigned int v12 = (v7 | v8) + 939524096;
        }
        if (v7 >= 0x800000) {
          float result = v12;
        }
        else {
          float result = result;
        }
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7) {
              int v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            }
            goto LABEL_25;
          }
          int v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            int v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          int v14 = 260038656;
        }
      }
      else
      {
        int v14 = -1887444992;
      }
      int v8 = v14 + 939524096;
LABEL_25:
      *(_DWORD *)(v5 + 4 * v3--) = (int)*(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_2167978A0(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 8;
    do
    {
      int v6 = *(__int16 *)(v4 + 2 * v3);
      unsigned int v7 = (v6 & 0x7FFF) << 13;
      int v8 = v6 & 0x80000000;
      unsigned int v9 = __clz(v7) - 8;
      float result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7) {
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      }
      else {
        float v10 = *(float *)&v8;
      }
      unsigned int v11 = v7 >> 23;
      unsigned int v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E) {
        int v13 = (v7 | v8) + 939524096;
      }
      else {
        int v13 = v7 | v8 | 0x7F800000;
      }
      if (v7 >= 0x800000) {
        float v10 = *(float *)&v13;
      }
      if (v10 >= 0.0)
      {
        if (!v7) {
          LODWORD(result) = v8;
        }
        if (v11 <= 0x1E) {
          unsigned int v12 = (v7 | v8) + 939524096;
        }
        if (v7 >= 0x800000) {
          float result = v12;
        }
        else {
          float result = result;
        }
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7) {
              int v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            }
            goto LABEL_25;
          }
          int v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            int v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          int v14 = 260038656;
        }
        int v8 = v14 + 939524096;
      }
      else
      {
        *(float *)&int v8 = 0.0;
      }
LABEL_25:
      *(void *)(v5 + 8 * v3--) = (unint64_t)*(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_2167979A8(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 8;
    do
    {
      int v6 = *(__int16 *)(v4 + 2 * v3);
      unsigned int v7 = (v6 & 0x7FFF) << 13;
      int v8 = v6 & 0x80000000;
      unsigned int v9 = __clz(v7) - 8;
      float result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7) {
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      }
      else {
        float v10 = *(float *)&v8;
      }
      unsigned int v11 = v7 >> 23;
      unsigned int v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E) {
        int v13 = (v7 | v8) + 939524096;
      }
      else {
        int v13 = v7 | v8 | 0x7F800000;
      }
      if (v7 >= 0x800000) {
        float v10 = *(float *)&v13;
      }
      if (v10 >= -65504.0)
      {
        if (!v7) {
          LODWORD(result) = v8;
        }
        if (v11 <= 0x1E) {
          unsigned int v12 = (v7 | v8) + 939524096;
        }
        if (v7 >= 0x800000) {
          float result = v12;
        }
        else {
          float result = result;
        }
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7) {
              int v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            }
            goto LABEL_25;
          }
          int v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            int v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          int v14 = 260038656;
        }
      }
      else
      {
        int v14 = -1887444992;
      }
      int v8 = v14 + 939524096;
LABEL_25:
      *(void *)(v5 + 8 * v3--) = (uint64_t)*(float *)&v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_216797ABC(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 4;
    do
    {
      int v6 = *(__int16 *)(v4 + 2 * v3);
      unsigned int v7 = (v6 & 0x7FFF) << 13;
      int v8 = v6 & 0x80000000;
      unsigned int v9 = __clz(v7) - 8;
      float result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7) {
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      }
      else {
        float v10 = *(float *)&v8;
      }
      unsigned int v11 = v7 >> 23;
      unsigned int v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E) {
        int v13 = (v7 | v8) + 939524096;
      }
      else {
        int v13 = v7 | v8 | 0x7F800000;
      }
      if (v7 >= 0x800000) {
        float v10 = *(float *)&v13;
      }
      if (v10 >= -65504.0)
      {
        if (!v7) {
          LODWORD(result) = v8;
        }
        if (v11 <= 0x1E) {
          unsigned int v12 = (v7 | v8) + 939524096;
        }
        if (v7 >= 0x800000) {
          float result = v12;
        }
        else {
          float result = result;
        }
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7) {
              int v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            }
            goto LABEL_25;
          }
          int v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            int v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          int v14 = 260038656;
        }
      }
      else
      {
        int v14 = -1887444992;
      }
      int v8 = v14 + 939524096;
LABEL_25:
      *(_DWORD *)(v5 + 4 * v3--) = v8;
    }
    while (v3);
  }
  return result;
}

uint64_t sub_216797BC8(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (a3 >= 2)
  {
    unint64_t v3 = a3 >> 1;
    uint64_t v4 = result - 2;
    uint64_t v5 = a2 - 8;
    do
    {
      int v6 = *(__int16 *)(v4 + 2 * v3);
      unsigned int v7 = (v6 & 0x7FFF) << 13;
      int v8 = v6 & 0x80000000;
      unsigned int v9 = __clz(v7) - 8;
      float result = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      if (v7) {
        LODWORD(v10) = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
      }
      else {
        float v10 = *(float *)&v8;
      }
      unsigned int v11 = v7 >> 23;
      unsigned int v12 = v7 | v8 | 0x7F800000;
      if (v7 >> 23 <= 0x1E) {
        int v13 = (v7 | v8) + 939524096;
      }
      else {
        int v13 = v7 | v8 | 0x7F800000;
      }
      if (v7 >= 0x800000) {
        float v10 = *(float *)&v13;
      }
      if (v10 >= -65504.0)
      {
        if (!v7) {
          LODWORD(result) = v8;
        }
        if (v11 <= 0x1E) {
          unsigned int v12 = (v7 | v8) + 939524096;
        }
        if (v7 >= 0x800000) {
          float result = v12;
        }
        else {
          float result = result;
        }
        if (*(float *)&result <= 65504.0)
        {
          if (v7 < 0x800000)
          {
            if (v7) {
              int v8 = (v8 | 0x38800000 | (v7 << v9)) - (v9 << 23);
            }
            goto LABEL_25;
          }
          int v14 = v7 | v8;
          if (v11 > 0x1E)
          {
            int v8 = v14 | 0x7F800000;
            goto LABEL_25;
          }
        }
        else
        {
          int v14 = 260038656;
        }
      }
      else
      {
        int v14 = -1887444992;
      }
      int v8 = v14 + 939524096;
LABEL_25:
      *(double *)(v5 + 8 * v3--) = *(float *)&v8;
    }
    while (v3);
  }
  return result;
}

float *sub_216797CDC(float *result, unsigned char *a2, unint64_t a3)
{
  if (a3 >= 4)
  {
    unint64_t v3 = a3 >> 2;
    do
    {
      float v4 = 0.0;
      if (*result >= 0.0)
      {
        float v4 = *result;
        if (*result > 255.0) {
          float v4 = 255.0;
        }
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *sub_216797D2C(float *result, unsigned char *a2, unint64_t a3)
{
  if (a3 >= 4)
  {
    unint64_t v3 = a3 >> 2;
    do
    {
      float v4 = -128.0;
      if (*result >= -128.0)
      {
        float v4 = *result;
        if (*result > 127.0) {
          float v4 = 127.0;
        }
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *sub_216797D7C(float *result, _WORD *a2, unint64_t a3)
{
  if (a3 >= 4)
  {
    unint64_t v3 = a3 >> 2;
    do
    {
      float v4 = 0.0;
      if (*result >= 0.0)
      {
        float v4 = *result;
        if (*result > 65535.0) {
          float v4 = 65535.0;
        }
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *sub_216797DC8(float *result, _WORD *a2, unint64_t a3)
{
  if (a3 >= 4)
  {
    unint64_t v3 = a3 >> 2;
    do
    {
      float v4 = -32768.0;
      if (*result >= -32768.0)
      {
        float v4 = *result;
        if (*result > 32767.0) {
          float v4 = 32767.0;
        }
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

float *sub_216797E14(float *result, _WORD *a2, unint64_t a3)
{
  if (a3 >= 4)
  {
    unint64_t v3 = a3 >> 2;
    do
    {
      float v4 = -65504.0;
      if (*result >= -65504.0)
      {
        float v4 = *result;
        if (*result > 65504.0) {
          float v4 = 65504.0;
        }
      }
      unsigned int v5 = LODWORD(v4) & 0x7FFFFFFF;
      int v6 = HIWORD(LODWORD(v4)) & 0x8000;
      if ((LODWORD(v4) >> 23) < 0x71u)
      {
        if (v5 >= 0x33000001)
        {
          int v8 = 126 - (v5 >> 23);
          unsigned int v9 = LODWORD(v4) & 0x7FFFFF | 0x800000;
          unsigned int v10 = v9 << ((v5 >> 23) - 94);
          int v6 = (v9 >> v8) | HIWORD(LODWORD(v4)) & 0x8000;
          if (v10 > 0x80000000 || (v10 == 0x80000000 ? (BOOL v11 = ((v9 >> v8) & 1) == 0) : (BOOL v11 = 1), !v11)) {
            LOWORD(v6) = v6 + 1;
          }
        }
      }
      else
      {
        unsigned int v7 = v6 | ((LODWORD(v4) + 134221823 + ((LODWORD(v4) >> 13) & 1)) >> 13);
        LOWORD(v6) = v6 | 0x7C00;
        if (v5 >= 0x477FF000) {
          LOWORD(v7) = v6;
        }
        if (v5 != 2139095040) {
          LOWORD(v6) = (((LODWORD(v4) >> 13) & 0x3FF) == 0) | (LODWORD(v4) >> 13) & 0x3FF | v6;
        }
        if (v5 >> 23 < 0xFF) {
          LOWORD(v6) = v7;
        }
      }
      *a2++ = v6;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_216797F34(double *result, unsigned char *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    unint64_t v3 = a3 >> 3;
    do
    {
      double v4 = 0.0;
      if (*result >= 0.0)
      {
        double v4 = *result;
        if (*result > 255.0) {
          double v4 = 255.0;
        }
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_216797F80(double *result, unsigned char *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    unint64_t v3 = a3 >> 3;
    do
    {
      double v4 = -128.0;
      if (*result >= -128.0)
      {
        double v4 = *result;
        if (*result > 127.0) {
          double v4 = 127.0;
        }
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_216797FD0(double *result, _WORD *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    unint64_t v3 = a3 >> 3;
    do
    {
      double v4 = 0.0;
      if (*result >= 0.0)
      {
        double v4 = *result;
        if (*result > 65535.0) {
          double v4 = 65535.0;
        }
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_21679801C(double *result, _WORD *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    unint64_t v3 = a3 >> 3;
    do
    {
      double v4 = -32768.0;
      if (*result >= -32768.0)
      {
        double v4 = *result;
        if (*result > 32767.0) {
          double v4 = 32767.0;
        }
      }
      *a2++ = (int)v4;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

double *sub_21679806C(double *result, _WORD *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    unint64_t v3 = a3 >> 3;
    do
    {
      double v4 = -65504.0;
      if (*result >= -65504.0)
      {
        double v4 = *result;
        if (*result > 65504.0) {
          double v4 = 65504.0;
        }
      }
      float v5 = v4;
      unsigned int v6 = LODWORD(v5) & 0x7FFFFFFF;
      int v7 = HIWORD(LODWORD(v5)) & 0x8000;
      if ((LODWORD(v5) >> 23) < 0x71u)
      {
        if (v6 >= 0x33000001)
        {
          int v9 = 126 - (v6 >> 23);
          unsigned int v10 = LODWORD(v5) & 0x7FFFFF | 0x800000;
          unsigned int v11 = v10 << ((v6 >> 23) - 94);
          int v7 = (v10 >> v9) | HIWORD(LODWORD(v5)) & 0x8000;
          if (v11 > 0x80000000 || (v11 == 0x80000000 ? (BOOL v12 = ((v10 >> v9) & 1) == 0) : (BOOL v12 = 1), !v12)) {
            LOWORD(v7) = v7 + 1;
          }
        }
      }
      else
      {
        unsigned int v8 = v7 | ((LODWORD(v5) + 134221823 + ((LODWORD(v5) >> 13) & 1)) >> 13);
        LOWORD(v7) = v7 | 0x7C00;
        if (v6 >= 0x477FF000) {
          LOWORD(v8) = v7;
        }
        if (v6 != 2139095040) {
          LOWORD(v7) = (((LODWORD(v5) >> 13) & 0x3FF) == 0) | (LODWORD(v5) >> 13) & 0x3FF | v7;
        }
        if (v6 >> 23 < 0xFF) {
          LOWORD(v7) = v8;
        }
      }
      *a2++ = v7;
      ++result;
      --v3;
    }
    while (v3);
  }
  return result;
}

__n64 sub_216798190(uint64_t a1, Alembic::Ogawa::v12::IData **a2, unint64_t a3, int *a4, int a5, __n64 result)
{
  uint64_t v10 = *a4;
  if (v10 != a5 && ((a5 - 14) > 0xFFFFFFFD || (v10 - 14) >= 0xFFFFFFFE))
  {
    sub_216778A5C((uint64_t)v44);
    sub_216779180(v45, (uint64_t)"Cannot convert the data to or from a string, or wstring.", 56);
    std::stringbuf::str();
    sub_216778E70(v43, (long long *)__p);
    if (v42 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v38 = sub_216779038(exception, (uint64_t)v43);
    __cxa_throw(v38, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*a2)
  {
    unint64_t Size = Alembic::Ogawa::v12::IData::getSize(*a2);
    if (Size <= 0xF)
    {
      if (Size)
      {
        sub_216778A5C((uint64_t)v44);
        sub_216779180(v45, (uint64_t)"Incorrect data, expected to be empty or to have a key and data", 62);
        std::stringbuf::str();
        sub_216778E70(v43, (long long *)__p);
        if (v42 < 0) {
          operator delete(__p[0]);
        }
        unint64_t v39 = __cxa_allocate_exception(0x20uLL);
        int v40 = sub_216779038(v39, (uint64_t)v43);
        __cxa_throw(v40, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
      }
      return result;
    }
    if (v10 == 13)
    {
      if (Size < 0x11 || (Size & 3) != 0) {
        return result;
      }
      unint64_t v19 = Size - 16;
      int v20 = operator new[]((Size - 16) & 0xFFFFFFFFFFFFFFFCLL);
      Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, v19, v20, 16, a3);
      if (v19 >= 4)
      {
        uint64_t v21 = 0;
        unint64_t v22 = 0;
        unint64_t v23 = v19 >> 2;
        do
        {
          if (*(char *)(a1 + 23) < 0) {
            unint64_t v24 = *(void *)(a1 + 8);
          }
          else {
            unint64_t v24 = *(unsigned __int8 *)(a1 + 23);
          }
          if (v22 >= v24) {
            break;
          }
          std::wstring::value_type v25 = *((_DWORD *)v20 + v21);
          if (v25) {
            std::wstring::push_back((std::wstring *)(a1 + 24 * v22), v25);
          }
          else {
            ++v22;
          }
          ++v21;
        }
        while (v23 != v21);
      }
      int v18 = v20;
      goto LABEL_33;
    }
    if (v10 == 12)
    {
      if (Size < 0x11) {
        return result;
      }
      uint64_t v12 = Size - 16;
      int v13 = (char *)operator new[](Size - 16);
      Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, v12, v13, 16, a3);
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      uint64_t v16 = 0;
      do
      {
        if (!v13[v14])
        {
          unint64_t v17 = *(char *)(a1 + 23) < 0 ? *(void *)(a1 + 8) : *(unsigned __int8 *)(a1 + 23);
          if (v15 < v17)
          {
            MEMORY[0x21D4477E0](a1 + 24 * v15, &v13[v16]);
            uint64_t v16 = v14 + 1;
            ++v15;
          }
        }
        ++v14;
      }
      while (v12 != v14);
      int v18 = v13;
LABEL_33:
      operator delete[](v18);
      return result;
    }
    if (v10 == a5)
    {
      uint64_t v26 = Size - 16;
      unint64_t v27 = *a2;
      Alembic::Ogawa::v12::IData::read((unint64_t **)v27, v26, (void *)a1, 16, a3);
    }
    else
    {
      if (v10 > 0xB) {
        unint64_t v28 = 0;
      }
      else {
        unint64_t v28 = qword_217409388[v10];
      }
      if (a5 > 0xD) {
        unint64_t v29 = 0;
      }
      else {
        unint64_t v29 = qword_2174093E8[a5];
      }
      if (v28 > v29)
      {
        if (v10 > 0xB) {
          unint64_t v30 = 0;
        }
        else {
          unint64_t v30 = qword_217409388[v10];
        }
        if (a5 > 0xD) {
          unint64_t v33 = 0;
        }
        else {
          unint64_t v33 = qword_2174093E8[a5];
        }
        if (v30 <= v33) {
          return result;
        }
        unint64_t v34 = Size - 16;
        unint64_t v35 = operator new[](Size - 16);
        Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, v34, v35, 16, a3);
        sub_216795238(v10, a5, (int *)v35, (char *)a1, v34, v36);
        int v18 = v35;
        goto LABEL_33;
      }
      unint64_t v31 = Size - 16;
      Alembic::Ogawa::v12::IData::read((unint64_t **)*a2, Size - 16, (void *)a1, 16, a3);
      return sub_216795238(v10, a5, (int *)a1, (char *)a1, v31, v32);
    }
  }
  return result;
}

void sub_2167985D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_216798608(uint64_t a1, uint64_t a2, unint64_t a3, int *a4, uint64_t **a5)
{
  long long __p = 0;
  unint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v9 = *(atomic_ullong **)(a1 + 8);
  v28[0] = *(Alembic::Ogawa::v12::IData **)a1;
  v28[1] = (Alembic::Ogawa::v12::IData *)v9;
  if (v9) {
    atomic_fetch_add_explicit(v9 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(atomic_ullong **)(a2 + 8);
  v27[0] = *(Alembic::Ogawa::v12::IData **)a2;
  v27[1] = (Alembic::Ogawa::v12::IData *)v10;
  if (v10) {
    atomic_fetch_add_explicit(v10 + 1, 1uLL, memory_order_relaxed);
  }
  sub_216794F90(v28, v27, a3, a4, &__p);
  if (v10) {
    sub_216784EC4((std::__shared_weak_count *)v10);
  }
  if (v9) {
    sub_216784EC4((std::__shared_weak_count *)v9);
  }
  Alembic::AbcCoreAbstract::v12::AllocateArraySample(a4, (uint64_t)&__p, &v26);
  long long v11 = v26;
  long long v26 = 0uLL;
  uint64_t v12 = (std::__shared_weak_count *)a5[1];
  *(_OWORD *)a5 = v11;
  if (v12)
  {
    sub_216784EC4(v12);
    if (*((void *)&v26 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v26 + 1));
    }
  }
  if (*(void *)a2
    && (unint64_t)Alembic::Ogawa::v12::IData::getSize(*(Alembic::Ogawa::v12::IData **)a2) >= 0x11)
  {
    int v13 = (uint64_t *)(*a5)[2];
    uint64_t v14 = (*a5)[3] - (void)v13;
    if (v14)
    {
      unint64_t v15 = v14 >> 3;
      if (v15 <= 1) {
        unint64_t v15 = 1;
      }
      uint64_t v16 = 1;
      do
      {
        uint64_t v17 = *v13++;
        v16 *= v17;
        --v15;
      }
      while (v15);
    }
    else
    {
      uint64_t v16 = 0;
    }
    uint64_t v18 = *a4;
    if (v18 > 0xD) {
      uint64_t v19 = 0;
    }
    else {
      uint64_t v19 = qword_2174093E8[v18];
    }
    uint64_t v20 = *((unsigned __int8 *)a4 + 4);
    if (v16 * v20 * v19 >= (unint64_t)(Alembic::Ogawa::v12::IData::getSize(*(Alembic::Ogawa::v12::IData **)a2)
                                             - 16))
    {
      uint64_t v22 = **a5;
      unint64_t v23 = *(Alembic::Ogawa::v12::IData **)a2;
      unint64_t v24 = *(atomic_ullong **)(a2 + 8);
      v25[0] = v23;
      v25[1] = (Alembic::Ogawa::v12::IData *)v24;
      if (v24) {
        atomic_fetch_add_explicit(v24 + 1, 1uLL, memory_order_relaxed);
      }
      sub_216798190(v22, v25, a3, a4, *a4, v21);
      if (v24) {
        sub_216784EC4((std::__shared_weak_count *)v24);
      }
    }
  }
  if (__p)
  {
    unint64_t v30 = __p;
    operator delete(__p);
  }
}

void sub_2167987CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (v19) {
    sub_216784EC4(v19);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679881C(Alembic::Ogawa::v12::IData **a1, uint64_t *a2, uint64_t a3)
{
  size_t Size = Alembic::Ogawa::v12::IData::getSize(*a1);
  sub_21679A150(&__p, Size);
  uint64_t v7 = __p;
  if (__p != v39)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = Alembic::Ogawa::v12::IData::getSize(v8);
    Alembic::Ogawa::v12::IData::read((unint64_t **)v8, v9, __p, 0, 0);
    unint64_t v10 = 0;
    unint64_t v11 = v39 - (unsigned char *)__p;
    while (1)
    {
      uint64_t v7 = __p;
      if (v10 >= v11) {
        break;
      }
      unint64_t v12 = v10 + 16;
      if (v10 + 16 > v11) {
        break;
      }
      uint64_t v13 = *(unsigned int *)((char *)__p + v10);
      unint64_t v15 = *(void **)(a3 + 8);
      unint64_t v14 = *(void *)(a3 + 16);
      if ((unint64_t)v15 >= v14)
      {
        uint64_t v17 = *(void **)a3;
        uint64_t v18 = ((uint64_t)v15 - *(void *)a3) >> 3;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 61) {
          sub_21677CB10();
        }
        uint64_t v20 = v14 - (void)v17;
        if (v20 >> 2 > v19) {
          unint64_t v19 = v20 >> 2;
        }
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          uint64_t v22 = (char *)sub_21677CB28(a3 + 16, v21);
          uint64_t v17 = *(void **)a3;
          unint64_t v15 = *(void **)(a3 + 8);
        }
        else
        {
          uint64_t v22 = 0;
        }
        unint64_t v23 = &v22[8 * v18];
        *(void *)unint64_t v23 = v13;
        uint64_t v16 = v23 + 8;
        while (v15 != v17)
        {
          uint64_t v24 = *--v15;
          *((void *)v23 - 1) = v24;
          v23 -= 8;
        }
        *(void *)a3 = v23;
        *(void *)(a3 + 8) = v16;
        *(void *)(a3 + 16) = &v22[8 * v21];
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *unint64_t v15 = v13;
        uint64_t v16 = v15 + 1;
      }
      *(void *)(a3 + 8) = v16;
      uint64_t v7 = __p;
      uint64_t v25 = *(unsigned int *)((char *)__p + v10 + 12);
      unint64_t v26 = v12 + 8 * v25;
      if (v25) {
        BOOL v27 = v26 > v11;
      }
      else {
        BOOL v27 = 1;
      }
      if (v27) {
        goto LABEL_36;
      }
      double v28 = *(double *)((char *)__p + v10 + 4);
      sub_21678275C(__dst, *(unsigned int *)((char *)__p + v10 + 12));
      unint64_t v29 = 8 * v25;
      unint64_t v30 = v39 - ((unsigned char *)__p + v10) - 16;
      v10 += 16;
      if (8 * v25 <= v30)
      {
        uint64_t v31 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)memcpy(__dst[0], (char *)__p + v12, 8 * v25);
        __n64 v32 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v31);
        LODWORD(v36) = v32;
        *((void *)&v36 + 1) = Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle(v32);
        if (v28 != Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle(v33))
        {
          sub_216799AC8((double *)&v35, v25, v28);
          long long v36 = v35;
        }
        unint64_t v34 = operator new(0x28uLL);
        Alembic::AbcCoreAbstract::v12::TimeSampling::TimeSampling(v34, &v36, __dst);
        sub_216787D70(&v35, (uint64_t)v34);
        sub_216788460(a2, &v35);
        if (*((void *)&v35 + 1)) {
          sub_216784EC4(*((std::__shared_weak_count **)&v35 + 1));
        }
        unint64_t v10 = v26;
      }
      if (__dst[0])
      {
        __dst[1] = __dst[0];
        operator delete(__dst[0]);
      }
      if (v29 > v30)
      {
        uint64_t v7 = __p;
        break;
      }
    }
  }
  if (v7)
  {
LABEL_36:
    unint64_t v39 = v7;
    operator delete(v7);
  }
}

void sub_216798A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_216798AF8(unint64_t ***a1, unint64_t a2, unint64_t a3, const void **a4, void *a5, uint64_t *a6)
{
  Alembic::Ogawa::v12::IGroup::getData(*a1, a2, a3, &v41);
  if (!v41)
  {
    sub_216778A5C((uint64_t)&v38);
    sub_216779180(v40, (uint64_t)"ReadObjectHeaders Invalid data at index ", 40);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(&__str, (long long *)&__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v33 = sub_216779038(exception, (uint64_t)&__str);
    __cxa_throw(v33, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if ((unint64_t)Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)v41) >= 0x21)
  {
    uint64_t Size = Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)v41);
    sub_21679A150(&v38, Size - 32);
    unint64_t v11 = v38;
    if (v38 != v39)
    {
      unint64_t v12 = v39 - v38;
      Alembic::Ogawa::v12::IData::read(v41, v39 - v38, v38, 0, a3);
      unint64_t v13 = 0;
      while (1)
      {
        if (v13 >= v12
          || (unint64_t v14 = v13 + 4, v13 + 4 > v12)
          || ((v15 = *(unsigned int *)&v38[v13], v16 = v14 + v15, unint64_t v13 = v14 + v15 + 1, v15)
            ? (BOOL v17 = v13 > v12)
            : (BOOL v17 = 1),
              v17))
        {
LABEL_49:
          unint64_t v11 = v38;
          goto LABEL_50;
        }
        sub_216799F58(&__str, &v38[v14], v15);
        unint64_t v18 = v38[v16];
        unint64_t v19 = operator new(0x48uLL);
        std::exception v19[8] = 0;
        v19[7] = 0;
        *(_OWORD *)unint64_t v19 = 0u;
        *((_OWORD *)v19 + 1) = 0u;
        *((_OWORD *)v19 + 2) = 0u;
        v19[6] = v19 + 7;
        sub_216787808(&v35, (uint64_t)v19);
        std::string::operator=((std::string *)v35, &__str);
        uint64_t v20 = (std::string *)v35;
        if (*((char *)a4 + 23) >= 0) {
          size_t v21 = *((unsigned __int8 *)a4 + 23);
        }
        else {
          size_t v21 = (size_t)a4[1];
        }
        sub_2167940B4((uint64_t)&v34, v21 + 1);
        if ((v34.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v22 = &v34;
        }
        else {
          uint64_t v22 = (std::string *)v34.__r_.__value_.__r.__words[0];
        }
        if (v21)
        {
          if (*((char *)a4 + 23) >= 0) {
            unint64_t v23 = a4;
          }
          else {
            unint64_t v23 = *a4;
          }
          memmove(v22, v23, v21);
        }
        *(_WORD *)((char *)&v22->__r_.__value_.__l.__data_ + v21) = 47;
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_str = &__str;
        }
        else {
          p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v25 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v25 = __str.__r_.__value_.__l.__size_;
        }
        unint64_t v26 = std::string::append(&v34, (const std::string::value_type *)p_str, v25);
        long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
        __dst.__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v27;
        v26->__r_.__value_.__l.__size_ = 0;
        v26->__r_.__value_.__r.__words[2] = 0;
        v26->__r_.__value_.__r.__words[0] = 0;
        std::string::operator=(v20 + 1, &__dst);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v34.__r_.__value_.__l.__data_);
        }
        if (v18 != 255) {
          break;
        }
        unint64_t v29 = v16 + 5;
        if (v16 + 5 <= v12)
        {
          size_t v31 = *(unsigned int *)&v38[v13];
          unint64_t v13 = v29 + v31;
          if (v29 + v31 <= v12)
          {
            sub_216799F58(&__dst, &v38[v29], v31);
            sub_216787230(v35 + 48, &__dst);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__dst.__r_.__value_.__l.__data_);
            }
            goto LABEL_42;
          }
          char v30 = 0;
          unint64_t v13 = v16 + 5;
        }
        else
        {
          char v30 = 0;
        }
LABEL_43:
        if (*((void *)&v35 + 1)) {
          sub_216784EC4(*((std::__shared_weak_count **)&v35 + 1));
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(__str.__r_.__value_.__l.__data_);
          if ((v30 & 1) == 0) {
            goto LABEL_49;
          }
        }
        else if ((v30 & 1) == 0)
        {
          goto LABEL_49;
        }
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a5[1] - *a5) >> 3) > v18)
      {
        uint64_t v28 = *a5 + 24 * v18;
        if ((void)v35 + 48 != v28) {
          sub_216799C1C((uint64_t **)(v35 + 48), *(long long **)v28, (long long *)(v28 + 8));
        }
      }
LABEL_42:
      sub_216793AD0(a6, &v35);
      char v30 = 1;
      goto LABEL_43;
    }
LABEL_50:
    if (v11)
    {
      unint64_t v39 = v11;
      operator delete(v11);
    }
  }
  if (v42) {
    sub_216784EC4(v42);
  }
}

void sub_216798E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,uint64_t a30,void *a31,uint64_t a32)
{
  sub_216779148((std::exception *)&a24);
  sub_216778D38((uint64_t)&a31);
  std::string v34 = *(std::__shared_weak_count **)(v32 - 104);
  if (v34) {
    sub_216784EC4(v34);
  }
  _Unwind_Resume(a1);
}

void sub_216798F58(unint64_t ***a1, unint64_t a2, unint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  Alembic::Ogawa::v12::IGroup::getData(*a1, a2, a3, &v56);
  if (!v56)
  {
    sub_216778A5C((uint64_t)&__str);
    sub_216779180(&__str.__r_.__value_.__r.__words[2], (uint64_t)"ReadObjectHeaders Invalid data at index ", 40);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(&__p, (long long *)v52);
    if (v53 < 0) {
      operator delete(v52[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unsigned int v46 = sub_216779038(exception, (uint64_t)&__p);
    __cxa_throw(v46, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (Alembic::Ogawa::v12::IData::getSize(v56))
  {
    size_t Size = Alembic::Ogawa::v12::IData::getSize(v56);
    sub_21679A150(v52, Size);
    unint64_t v11 = (unint64_t **)v56;
    uint64_t v12 = Alembic::Ogawa::v12::IData::getSize(v56);
    Alembic::Ogawa::v12::IData::read(v11, v12, v52[0], 0, a3);
    unint64_t v13 = v52[1];
    unint64_t v14 = (char *)v52[1] - (char *)v52[0];
    if (v52[1] != v52[0])
    {
      unint64_t v47 = a5;
      char v48 = a6;
      unint64_t v15 = 0;
      while (1)
      {
        unint64_t v16 = operator new(0x68uLL);
        *unint64_t v16 = 0;
        v16[1] = 0;
        v16[2] = 0;
        *((_DWORD *)v16 + 6) = 1;
        v16[6] = 0;
        v16[5] = 0;
        v16[4] = v16 + 5;
        *((_DWORD *)v16 + 14) = 127;
        *((unsigned char *)v16 + 60) = 0;
        v16[8] = 0;
        v16[9] = 0;
        *((_WORD *)v16 + 40) = 257;
        *(void *)((char *)v16 + 92) = 0;
        *(void *)((char *)v16 + 84) = 0;
        sub_21678D5C8(&v51, (uint64_t)v16);
        unint64_t v17 = v15 + 4;
        if (v15 + 4 > v14) {
          goto LABEL_6;
        }
        unint64_t v19 = (char *)v52[0];
        unint64_t v20 = *(unsigned int *)((char *)v52[0] + v15);
        uint64_t v21 = v51;
        *(unsigned char *)(v51 + 80) = v20 & 1;
        int v22 = v20 & 3;
        if ((v20 & 3) == 0)
        {
          *(_DWORD *)(v21 + 24) = 0;
          unsigned int v24 = (v20 >> 2) & 3;
          goto LABEL_67;
        }
        if (v22 != 1) {
          int v22 = 2;
        }
        *(_DWORD *)(v21 + 24) = v22;
        unsigned int v23 = v20 >> 4;
        if (v23 >= 0xE)
        {
          sub_216778A5C((uint64_t)&__str);
          sub_216779180(&__str.__r_.__value_.__r.__words[2], (uint64_t)"Read invalid POD type: ", 23);
          std::ostream::operator<<();
          std::stringbuf::str();
          sub_216778E70(&__p, &v49);
          if (SHIBYTE(v50) < 0) {
            operator delete((void *)v49);
          }
          unint64_t v43 = __cxa_allocate_exception(0x20uLL);
          unint64_t v44 = sub_216779038(v43, (uint64_t)&__p);
          __cxa_throw(v44, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
        }
        unsigned int v24 = (v20 >> 2) & 3;
        *(_DWORD *)(v21 + 56) = v23;
        *(unsigned char *)(v21 + 60) = v20 >> 12;
        *(unsigned char *)(v21 + 81) = (v20 & 0x400) != 0;
        if (v24 == 2)
        {
          unint64_t v25 = v15 + 8;
          if (v15 + 8 > v14) {
            goto LABEL_20;
          }
          int v26 = *(_DWORD *)&v19[v17];
        }
        else if (v24 == 1)
        {
          unint64_t v25 = v15 + 6;
          if (v15 + 6 > v14) {
            goto LABEL_20;
          }
          int v26 = *(unsigned __int16 *)&v19[v17];
        }
        else
        {
          if (v24 || (unint64_t v25 = v15 + 5, v15 + 5 > v14))
          {
LABEL_20:
            int v26 = 0;
            goto LABEL_23;
          }
          int v26 = v19[v17];
        }
        unint64_t v17 = v25;
LABEL_23:
        *(_DWORD *)(v21 + 84) = v26;
        if ((v20 & 0x200) == 0)
        {
          if ((v20 & 0x800) == 0)
          {
            *(_DWORD *)(v21 + 88) = 1;
            int v27 = v26 - 1;
            goto LABEL_47;
          }
LABEL_31:
          int v27 = 0;
          *(_DWORD *)(v21 + 88) = 0;
          goto LABEL_47;
        }
        if (v24 == 2)
        {
          if (v17 + 4 <= v14)
          {
            int v31 = *(_DWORD *)&v19[v17];
            unint64_t v29 = v17 + 8;
            v17 += 4;
          }
          else
          {
            int v31 = 0;
            unint64_t v29 = v17 + 4;
          }
          *(_DWORD *)(v21 + 88) = v31;
          if (v29 > v14) {
            goto LABEL_44;
          }
          int v27 = *(_DWORD *)&v19[v17];
        }
        else if (v24 == 1)
        {
          if (v17 + 2 <= v14)
          {
            int v30 = *(unsigned __int16 *)&v19[v17];
            unint64_t v29 = v17 + 4;
            v17 += 2;
          }
          else
          {
            int v30 = 0;
            unint64_t v29 = v17 + 2;
          }
          *(_DWORD *)(v21 + 88) = v30;
          if (v29 > v14) {
            goto LABEL_44;
          }
          int v27 = *(unsigned __int16 *)&v19[v17];
        }
        else
        {
          if (v24) {
            goto LABEL_31;
          }
          if (v17 + 1 <= v14)
          {
            int v28 = v19[v17];
            unint64_t v29 = v17 + 2;
            ++v17;
          }
          else
          {
            int v28 = 0;
            unint64_t v29 = v17 + 1;
          }
          *(_DWORD *)(v21 + 88) = v28;
          if (v29 > v14)
          {
LABEL_44:
            int v27 = 0;
            goto LABEL_47;
          }
          int v27 = v19[v17];
        }
        unint64_t v17 = v29;
LABEL_47:
        *(_DWORD *)(v21 + 92) = v27;
        if ((v20 & 0x100) != 0)
        {
          if (v24 == 2)
          {
            unint64_t v32 = v17 + 4;
            if (v17 + 4 > v14) {
              goto LABEL_57;
            }
            int v33 = *(_DWORD *)&v19[v17];
          }
          else
          {
            if (v24 != 1)
            {
              if (!v24)
              {
                unint64_t v32 = v17 + 1;
                if (v17 + 1 <= v14)
                {
                  int v33 = v19[v17];
                  goto LABEL_59;
                }
              }
LABEL_57:
              int v33 = 0;
LABEL_60:
              *(_DWORD *)(v21 + 96) = v33;
              (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a4 + 56))(&__str, a4);
              goto LABEL_61;
            }
            unint64_t v32 = v17 + 2;
            if (v17 + 2 > v14) {
              goto LABEL_57;
            }
            int v33 = *(unsigned __int16 *)&v19[v17];
          }
LABEL_59:
          unint64_t v17 = v32;
          goto LABEL_60;
        }
        (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)a4 + 56))(&__str, a4, 0);
LABEL_61:
        long long v34 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
        if (__str.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(__str.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        long long v35 = *(std::__shared_weak_count **)(v21 + 72);
        *(_OWORD *)(v21 + 64) = v34;
        if (v35) {
          sub_216784EC4(v35);
        }
        if (__str.__r_.__value_.__l.__size_) {
          sub_216784EC4((std::__shared_weak_count *)__str.__r_.__value_.__l.__size_);
        }
LABEL_67:
        if (v24 == 2)
        {
          unint64_t v15 = v17 + 4;
          if (v17 + 4 > v14) {
            goto LABEL_77;
          }
          long long v36 = (char *)v52[0];
          size_t v37 = *(unsigned int *)((char *)v52[0] + v17);
          if (*(_DWORD *)((char *)v52[0] + v17)) {
            goto LABEL_84;
          }
        }
        else if (v24 == 1)
        {
          unint64_t v15 = v17 + 2;
          if (v17 + 2 > v14) {
            goto LABEL_77;
          }
          long long v36 = (char *)v52[0];
          size_t v37 = *(unsigned __int16 *)((char *)v52[0] + v17);
          if (*(_WORD *)((char *)v52[0] + v17)) {
            goto LABEL_84;
          }
        }
        else
        {
          if (v24 || (unint64_t v15 = v17 + 1, v17 + 1 > v14))
          {
LABEL_77:
            int v18 = 7;
            unint64_t v15 = v17;
            goto LABEL_78;
          }
          long long v36 = (char *)v52[0];
          size_t v37 = *((unsigned __int8 *)v52[0] + v17);
          if (*((unsigned char *)v52[0] + v17))
          {
LABEL_84:
            unint64_t v38 = v15 + v37;
            if (v15 + v37 <= v14)
            {
              sub_216799F58(&__str, &v36[v15], v37);
              std::string::operator=((std::string *)v51, &__str);
              unint64_t v39 = (v20 >> 20);
              if (v39 == 255)
              {
                if (v24 == 2)
                {
                  unint64_t v15 = v38 + 4;
                  if (v38 + 4 > v14) {
                    goto LABEL_96;
                  }
                  size_t v40 = *(unsigned int *)((char *)v52[0] + v38);
                }
                else if (v24 == 1)
                {
                  unint64_t v15 = v38 + 2;
                  if (v38 + 2 > v14) {
                    goto LABEL_96;
                  }
                  size_t v40 = *(unsigned __int16 *)((char *)v52[0] + v38);
                }
                else
                {
                  unint64_t v15 = v38 + 1;
                  if (v38 + 1 <= v14)
                  {
                    size_t v40 = *((unsigned __int8 *)v52[0] + v38);
                    goto LABEL_97;
                  }
LABEL_96:
                  size_t v40 = 0;
                  unint64_t v15 = v38;
                }
LABEL_97:
                unint64_t v38 = v15 + v40;
                if (v15 + v40 > v14)
                {
                  int v18 = 1;
                  goto LABEL_110;
                }
                if (v15 == v14)
                {
                  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
                  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
                  if ((std::string *)(v51 + 32) == &__p)
                  {
                    char v42 = 0;
                  }
                  else
                  {
                    sub_216799C1C((uint64_t **)(v51 + 32), (long long *)&__p.__r_.__value_.__r.__words[1], (long long *)&__p.__r_.__value_.__r.__words[1]);
                    char v42 = (void *)__p.__r_.__value_.__l.__size_;
                  }
                  sub_2167877AC((uint64_t)&__p, v42);
                }
                else
                {
                  sub_216799F58(&__p, (char *)v52[0] + v15, v40);
                  *((void *)&v49 + 1) = 0;
                  uint64_t v50 = 0;
                  *(void *)&long long v49 = (char *)&v49 + 8;
                  sub_216787230((uint64_t)&v49, &__p);
                  if ((long long *)(v51 + 32) != &v49) {
                    sub_216799C1C((uint64_t **)(v51 + 32), (long long *)v49, (long long *)((char *)&v49 + 8));
                  }
                  sub_2167877AC((uint64_t)&v49, *((void **)&v49 + 1));
                  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__p.__r_.__value_.__l.__data_);
                  }
                }
              }
              else if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v47[1] - *v47) >> 3) > v39)
              {
                uint64_t v41 = *v47 + 24 * (v20 >> 20);
                if ((void)v51 + 32 != v41) {
                  sub_216799C1C((uint64_t **)(v51 + 32), *(long long **)v41, (long long *)(v41 + 8));
                }
              }
              sub_21678E1D4(v48, &v51);
              int v18 = 0;
              unint64_t v15 = v38;
LABEL_110:
              if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str.__r_.__value_.__l.__data_);
              }
              goto LABEL_78;
            }
          }
        }
LABEL_6:
        int v18 = 7;
LABEL_78:
        if (*((void *)&v51 + 1)) {
          sub_216784EC4(*((std::__shared_weak_count **)&v51 + 1));
        }
        if (v18 || v15 >= v14)
        {
          unint64_t v13 = v52[0];
          break;
        }
      }
    }
    if (v13)
    {
      v52[1] = v13;
      operator delete(v13);
    }
  }
  if (v57) {
    sub_216784EC4(v57);
  }
}

void sub_216799698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, void *a18, uint64_t a19, uint64_t a20,void *a21,void *a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  sub_2167877AC((uint64_t)&a21, a22);
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a17) {
    sub_216784EC4(a17);
  }
  if (a18) {
    operator delete(a18);
  }
  long long v35 = *(std::__shared_weak_count **)(v33 - 96);
  if (v35) {
    sub_216784EC4(v35);
  }
  _Unwind_Resume(a1);
}

void sub_216799794(Alembic::Ogawa::v12::IData **a1, uint64_t a2)
{
  unint64_t v25 = 0;
  v26[0] = 0;
  unsigned int v24 = &v25;
  double v4 = *(uint64_t **)(a2 + 8);
  if ((unint64_t)v4 >= *(void *)(a2 + 16))
  {
    uint64_t v5 = sub_21679A1C4((uint64_t *)a2, (const void ***)&v24);
  }
  else
  {
    sub_2167898D0(v4, (const void ***)&v24);
    uint64_t v5 = (uint64_t)(v4 + 3);
    *(void *)(a2 + 8) = v4 + 3;
  }
  *(void *)(a2 + 8) = v5;
  sub_2167877AC((uint64_t)&v24, v25);
  if ((unint64_t)Alembic::Ogawa::v12::IData::getSize(*a1) > 0x10000)
  {
    sub_216778A5C((uint64_t)&v24);
    sub_216779180(v26, (uint64_t)"Read invalid: Indexed MetaData buffer unexpectedly big.", 55);
    std::stringbuf::str();
    sub_216778E70(&__p, &v21);
    if (SHIBYTE(v22) < 0) {
      operator delete((void *)v21);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v20 = sub_216779038(exception, (uint64_t)&__p);
    __cxa_throw(v20, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  size_t Size = Alembic::Ogawa::v12::IData::getSize(*a1);
  sub_21679A150(&v24, Size);
  uint64_t v7 = (char *)v24;
  if (v24 != v25)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = Alembic::Ogawa::v12::IData::getSize(v8);
    Alembic::Ogawa::v12::IData::read((unint64_t **)v8, v9, v24, 0, 0);
    uint64_t v7 = v25;
    unint64_t v10 = v25 - (unsigned char *)v24;
    if (v25 != v24)
    {
      unint64_t v11 = 0;
      do
      {
        unint64_t v12 = v11 + 1;
        size_t v13 = *((unsigned __int8 *)v24 + v11);
        unint64_t v14 = ++v11 + v13;
        if (v14 <= v10)
        {
          if (v12 == v10)
          {
            *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = 0uLL;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p.__r_.__value_.__l.__size_;
            unint64_t v15 = *(void *)(a2 + 8);
            if (v15 >= *(void *)(a2 + 16))
            {
              uint64_t v16 = sub_21679A4F8((uint64_t *)a2, (const void ***)&__p);
            }
            else
            {
              sub_2167898D0(*(uint64_t **)(a2 + 8), (const void ***)&__p);
              uint64_t v16 = v15 + 24;
              *(void *)(a2 + 8) = v15 + 24;
            }
            *(void *)(a2 + 8) = v16;
            sub_2167877AC((uint64_t)&__p, (void *)__p.__r_.__value_.__l.__size_);
          }
          else
          {
            sub_216799F58(&__p, (char *)v24 + v12, v13);
            *((void *)&v21 + 1) = 0;
            uint64_t v22 = 0;
            *(void *)&long long v21 = (char *)&v21 + 8;
            sub_216787230((uint64_t)&v21, &__p);
            unint64_t v17 = *(void *)(a2 + 8);
            if (v17 >= *(void *)(a2 + 16))
            {
              uint64_t v18 = sub_21679A4F8((uint64_t *)a2, (const void ***)&v21);
            }
            else
            {
              sub_2167898D0(*(uint64_t **)(a2 + 8), (const void ***)&v21);
              uint64_t v18 = v17 + 24;
              *(void *)(a2 + 8) = v17 + 24;
            }
            *(void *)(a2 + 8) = v18;
            sub_2167877AC((uint64_t)&v21, *((void **)&v21 + 1));
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
          unint64_t v11 = v14;
        }
      }
      while (v11 < v10);
      uint64_t v7 = (char *)v24;
    }
  }
  if (v7)
  {
    unint64_t v25 = v7;
    operator delete(v7);
  }
}

void sub_216799A14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, void *__p, uint64_t a20)
{
}

double *sub_216799AC8(double *a1, int a2, double a3)
{
  *(_DWORD *)a1 = a2;
  a1[1] = a3;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) != a3
    || (unsigned int v5 = *(_DWORD *)a1,
        double v4 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v4),
        v5 != v4))
  {
    double v6 = a1[1];
    if (v6 <= 0.0
      || v6 >= Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicTimePerCycle(v4)
      || !*(_DWORD *)a1
      || (unsigned int v8 = *(_DWORD *)a1, v8 >= Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v7)))
    {
      sub_216778A5C((uint64_t)v16);
      sub_216779180(v17, (uint64_t)"Invalid Time Sampling Type, time per cycle: ", 44);
      unint64_t v10 = (void *)std::ostream::operator<<();
      sub_216779180(v10, (uint64_t)" samples per cycle: ", 20);
      std::ostream::operator<<();
      std::stringbuf::str();
      sub_216778E70(v15, &__p);
      if (v14 < 0) {
        operator delete((void *)__p);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      unint64_t v12 = sub_216779038(exception, (uint64_t)v15);
      __cxa_throw(v12, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
  }
  return a1;
}

void sub_216799BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t **sub_216799C1C(uint64_t **result, long long *a2, long long *a3)
{
  std::exception v5 = result;
  if (result[2])
  {
    double v6 = *result;
    uint64_t v7 = result[1];
    *float result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1]) {
      uint64_t v8 = (uint64_t *)v6[1];
    }
    else {
      uint64_t v8 = v6;
    }
    unint64_t v15 = result;
    uint64_t v16 = v8;
    unint64_t v17 = (const void **)v8;
    if (v8)
    {
      uint64_t v16 = sub_216799E28((uint64_t)v8);
      if (a2 != a3)
      {
        uint64_t v9 = a2;
        do
        {
          std::string::operator=((std::string *)(v8 + 4), (const std::string *)(v9 + 2));
          std::string::operator=((std::string *)(v8 + 7), (const std::string *)((char *)v9 + 56));
          unint64_t v10 = (uint64_t **)sub_216799DAC((uint64_t)v5, &v18, v17 + 4);
          sub_21677B358(v5, v18, v10, (uint64_t *)v17);
          unint64_t v17 = (const void **)v16;
          if (v16) {
            uint64_t v16 = sub_216799E28((uint64_t)v16);
          }
          unint64_t v11 = (long long *)*((void *)v9 + 1);
          if (v11)
          {
            do
            {
              a2 = v11;
              unint64_t v11 = *(long long **)v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              a2 = (long long *)*((void *)v9 + 2);
              BOOL v12 = *(void *)a2 == (void)v9;
              uint64_t v9 = a2;
            }
            while (!v12);
          }
          uint64_t v8 = (uint64_t *)v17;
          if (v17) {
            BOOL v12 = a2 == a3;
          }
          else {
            BOOL v12 = 1;
          }
          uint64_t v9 = a2;
        }
        while (!v12);
      }
    }
    float result = (uint64_t **)sub_216799E7C((uint64_t)&v15);
  }
  if (a2 != a3)
  {
    do
    {
      float result = (uint64_t **)sub_216799ED4(v5, a2 + 2);
      size_t v13 = (long long *)*((void *)a2 + 1);
      if (v13)
      {
        do
        {
          char v14 = v13;
          size_t v13 = *(long long **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          char v14 = (long long *)*((void *)a2 + 2);
          BOOL v12 = *(void *)v14 == (void)a2;
          a2 = v14;
        }
        while (!v12);
      }
      a2 = v14;
    }
    while (v14 != a3);
  }
  return result;
}

void sub_216799D98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_216799DAC(uint64_t a1, void *a2, const void **a3)
{
  std::exception v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        std::exception v5 = (void *)v4;
        if (!sub_21677B108(v7, a3, (const void **)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v5;
        float result = v5;
        if (!*v5) {
          goto LABEL_9;
        }
      }
      uint64_t v4 = v5[1];
    }
    while (v4);
    float result = v5 + 1;
  }
  else
  {
    float result = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v5;
  return result;
}

void *sub_216799E28(uint64_t a1)
{
  float result = *(void **)(a1 + 16);
  if (result)
  {
    unint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      *float result = 0;
      while (1)
      {
        uint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          float result = v4;
          uint64_t v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; unint64_t v3 = (void *)result[1])
      {
        do
        {
          float result = v3;
          unint64_t v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t sub_216799E7C(uint64_t a1)
{
  sub_2167877AC(*(void *)a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    unint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        unint64_t v3 = (void *)v3[2];
      }
      while (v3);
      *(void *)(a1 + 8) = v2;
    }
    sub_2167877AC(*(void *)a1, v2);
  }
  return a1;
}

uint64_t *sub_216799ED4(uint64_t **a1, long long *a2)
{
  sub_216789BF8((uint64_t)a1, a2, (uint64_t)v7);
  unint64_t v3 = (uint64_t **)sub_216799DAC((uint64_t)a1, &v6, (const void **)v7[0] + 4);
  sub_21677B358(a1, v6, v3, v7[0]);
  uint64_t v4 = v7[0];
  v7[0] = 0;
  sub_21677B548((uint64_t)v7, 0);
  return v4;
}

void sub_216799F40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_21677B548((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void *sub_216799F58(void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_216778FC4();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *std::string __dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void sub_21679A004(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_21679A034((char **)a1, a2 - v2);
  }
}

void sub_21679A034(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  std::exception v5 = v6;
  size_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    size_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      sub_21677CB10();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      char v14 = (char *)sub_21677CB28(v4, v13);
      size_t v8 = *a1;
      size_t v7 = a1[1];
    }
    else
    {
      char v14 = 0;
    }
    unint64_t v15 = &v14[8 * v11];
    uint64_t v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    unint64_t v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void *sub_21679A150(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_216780490(a1, a2);
    uint64_t v4 = (char *)a1[1];
    std::exception v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_21679A1A8(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_21679A1C4(uint64_t *a1, const void ***a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_21677CB10();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_216782ED8(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v13 = v10;
  char v14 = (uint64_t *)&v10[24 * v4];
  uint64_t v16 = &v10[24 * v9];
  sub_2167898D0(v14, a2);
  unint64_t v15 = v14 + 3;
  sub_21679A2CC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_21679A47C(&v13);
  return v11;
}

void sub_21679A2B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_21679A47C((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_21679A2CC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_21679A344((uint64_t)(a1 + 2), a1[1], (const void ***)a1[1], *a1, (const void ***)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_21679A344(uint64_t a1, uint64_t a2, const void ***a3, uint64_t a4, const void ***a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  char v13 = 0;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    unint64_t v9 = a3;
    do
    {
      v9 -= 3;
      sub_2167898D0((uint64_t *)(v7 - 24), v9);
      uint64_t v7 = *((void *)&v15 + 1) - 24;
      *((void *)&v15 + 1) -= 24;
    }
    while (v9 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_21679A400((uint64_t)v12);
  return v10;
}

void sub_21679A3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_21679A400(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_21679A438(a1);
  }
  return a1;
}

void sub_21679A438(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    sub_2167877AC(v1, *(void **)(v1 + 8));
    v1 += 24;
  }
}

void **sub_21679A47C(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_21679A4B0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    sub_2167877AC(i - 24, *(void **)(i - 16));
  }
}

uint64_t sub_21679A4F8(uint64_t *a1, const void ***a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_21677CB10();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_216782ED8(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  char v13 = v10;
  long long v14 = (uint64_t *)&v10[24 * v4];
  uint64_t v16 = &v10[24 * v9];
  sub_2167898D0(v14, a2);
  long long v15 = v14 + 3;
  sub_21679A2CC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_21679A47C(&v13);
  return v11;
}

void sub_21679A5EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_21679A47C((void **)va);
  _Unwind_Resume(a1);
}

double Alembic::AbcCoreOgawa::v12::WriteArchive::operator()@<D0>(long long *a1@<X1>, const void ***a2@<X2>, _OWORD *a3@<X8>)
{
  uint64_t v6 = operator new(0xF8uLL);
  sub_216788A04((uint64_t)v6, a1, a2);
  sub_21679A9D8((uint64_t *)&v8, (uint64_t)v6);
  double result = *(double *)&v8;
  *a3 = v8;
  return result;
}

void sub_21679A66C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

double Alembic::AbcCoreOgawa::v12::WriteArchive::operator()@<D0>(uint64_t a1@<X1>, const void ***a2@<X2>, _OWORD *a3@<X8>)
{
  uint64_t v6 = operator new(0xF8uLL);
  sub_216788D70((uint64_t)v6, a1, a2);
  sub_21679A9D8((uint64_t *)&v8, (uint64_t)v6);
  double result = *(double *)&v8;
  *a3 = v8;
  return result;
}

void sub_21679A6E4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive(uint64_t this)
{
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)this = 1;
  *(unsigned char *)(this + 8) = 1;
  return this;
}

{
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)this = 1;
  *(unsigned char *)(this + 8) = 1;
  return this;
}

uint64_t Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive(uint64_t this, uint64_t a2, char a3)
{
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)this = a2;
  *(unsigned char *)(this + 8) = a3;
  return this;
}

{
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)this = a2;
  *(unsigned char *)(this + 8) = a3;
  return this;
}

uint64_t Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 1;
  *(unsigned char *)(a1 + 8) = 1;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  sub_21679AB00((void *)(a1 + 16), *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  return a1;
}

{
  *(void *)a1 = 1;
  *(unsigned char *)(a1 + 8) = 1;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  sub_21679AB00((void *)(a1 + 16), *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  return a1;
}

double Alembic::AbcCoreOgawa::v12::ReadArchive::operator()@<D0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  unint64_t v4 = (void *)(a1 + 16);
  if (*(void *)(a1 + 16) == *(void *)(a1 + 24))
  {
    long long v8 = operator new(0x198uLL);
    sub_216786F20((uint64_t)v8, a2, *(void *)a1, *(unsigned __int8 *)(a1 + 8));
    sub_21679AB7C((uint64_t *)&v10, (uint64_t)v8);
  }
  else
  {
    unint64_t v5 = operator new(0x198uLL);
    sub_21678722C((uint64_t)v5, v4);
    sub_21679AB7C((uint64_t *)&v10, (uint64_t)v5);
  }
  double result = *(double *)&v10;
  *(_OWORD *)a3 = v10;
  return result;
}

void sub_21679A888(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *Alembic::AbcCoreOgawa::v12::ReadArchive::operator()@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  unint64_t v4 = (void *)(a1 + 16);
  if (*(void *)(a1 + 16) == *(void *)(a1 + 24))
  {
    unint64_t v9 = operator new(0x198uLL);
    sub_216786F20((uint64_t)v9, a2, *(void *)a1, *(unsigned __int8 *)(a1 + 8));
    if ((*(unsigned int (**)(void *))(*(void *)v9 + 80))(v9) == -1)
    {
      double result = (uint64_t *)(*(uint64_t (**)(void *))(*(void *)v9 + 8))(v9);
      *a3 = 0;
      a3[1] = 0;
      return result;
    }
    double result = sub_21679AB7C((uint64_t *)&v10, (uint64_t)v9);
  }
  else
  {
    unint64_t v5 = operator new(0x198uLL);
    sub_21678722C((uint64_t)v5, v4);
    double result = sub_21679AB7C((uint64_t *)&v10, (uint64_t)v5);
  }
  *(_OWORD *)a3 = v10;
  return result;
}

void sub_21679A9B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_21679A9D8(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  unint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C749290;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    unint64_t v5 = (void *)(a2 + 16);
  }
  else {
    unint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21679AA48(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323C70(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679AA64(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21679AA8C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21679AABC(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7492E0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21679AB00(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_21677CACC(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_21679AB60(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_21679AB7C(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  unint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C749308;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    unint64_t v5 = (void *)(a2 + 8);
  }
  else {
    unint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_21679ABEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323C94(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679AC08(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_21679AC30(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_21679AC60(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C749358)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void *sub_21679ACA4(void *result, void *a2, void *a3, void *a4)
{
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_26C749380;
  result[3] = *a2;
  uint64_t v4 = a2[1];
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  result[5] = *a3;
  uint64_t v5 = a3[1];
  result[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  result[7] = *a4;
  uint64_t v6 = a4[1];
  result[8] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  if (!result[3])
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v9 = sub_216779038(exception, (uint64_t)v18);
    __cxa_throw(v9, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!result[5])
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Invalid scalar property group", 29);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    long long v10 = __cxa_allocate_exception(0x20uLL);
    uint64_t v11 = sub_216779038(v10, (uint64_t)v18);
    __cxa_throw(v11, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v7 = result[7];
  if (!v7)
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v12 = __cxa_allocate_exception(0x20uLL);
    char v13 = sub_216779038(v12, (uint64_t)v18);
    __cxa_throw(v13, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*(_DWORD *)(v7 + 24) != 1)
  {
    sub_216778A5C((uint64_t)v19);
    sub_216779180(v20, (uint64_t)"Attempted to create a ScalarPropertyReader from a non-array property type", 73);
    std::stringbuf::str();
    sub_216778E70(v18, (long long *)__p);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    long long v14 = __cxa_allocate_exception(0x20uLL);
    long long v15 = sub_216779038(v14, (uint64_t)v18);
    __cxa_throw(v15, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_21679AF6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v10.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 8);
  if (v6) {
    sub_216784EC4(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)v4 + 6);
  if (v7) {
    sub_216784EC4(v7);
  }
  size_t v8 = (std::__shared_weak_count *)*((void *)v4 + 4);
  if (v8) {
    sub_216784EC4(v8);
  }
  unint64_t v9 = (std::__shared_weak_count *)*((void *)v4 + 2);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  Alembic::AbcCoreAbstract::v12::ScalarPropertyReader::~ScalarPropertyReader(v4);
  _Unwind_Resume(a1);
}

uint64_t sub_21679B008(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_21679B010(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 24))();
}

uint64_t sub_21679B038@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *a2 = *(void *)(result + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

double sub_21679B054@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_21679B090(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 56) + 84);
}

BOOL sub_21679B09C(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 56) + 88) == 0;
}

void sub_21679B0B0(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = sub_21678444C(*(unsigned int **)(a1 + 56), a2);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)a1 + 24))(&v20, a1);
  (*(void (**)(void **__return_ptr))(*(void *)v20 + 24))(&lpsrc);
  size_t v8 = lpsrc;
  if (lpsrc
  {
    unint64_t v9 = v23;
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    unint64_t v9 = 0;
  }
  sub_216787674((uint64_t)v8, &v24);
  if (v9) {
    sub_216784EC4(v9);
  }
  if (v23) {
    sub_216784EC4(v23);
  }
  if (v21) {
    sub_216784EC4(v21);
  }
  unint64_t v10 = *(void *)(v24 + 8);
  Alembic::Ogawa::v12::IGroup::getData(*(unint64_t ***)(a1 + 40), v7, v10, &lpsrc);
  uint64_t v11 = (Alembic::Ogawa::v12::IData *)lpsrc;
  if (lpsrc)
  {
    uint64_t v20 = *(void *)(*(void *)(a1 + 56) + 56);
    if ((int)v20 <= 11)
    {
      uint64_t Size = Alembic::Ogawa::v12::IData::getSize((Alembic::Ogawa::v12::IData *)lpsrc);
      if (Size != sub_21677D584((int *)&v20) + 16) {
        goto LABEL_24;
      }
      uint64_t v11 = (Alembic::Ogawa::v12::IData *)lpsrc;
    }
    unint64_t v13 = Alembic::Ogawa::v12::IData::getSize(v11);
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    unint64_t v15 = sub_21677D584((int *)(v14 + 56));
    unint64_t v17 = v13 - 16;
    if (v13 >= 0x10 && v15 >= v17 && (!a4 || v17 <= a4))
    {
      uint64_t v18 = (Alembic::Ogawa::v12::IData *)lpsrc;
      unint64_t v19 = v23;
      if (v23) {
        atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_216798190(a3, &v18, v10, (int *)&v20, v20, v16);
      if (v19) {
        sub_216784EC4(v19);
      }
    }
  }
LABEL_24:
  if (v23) {
    sub_216784EC4(v23);
  }
  if (v25) {
    sub_216784EC4(v25);
  }
}

void sub_21679B2E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  if (a14) {
    sub_216784EC4(a14);
  }
  if (a16) {
    sub_216784EC4(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679B330(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    sub_216784EC4(v14);
  }
  if (a14) {
    sub_216784EC4(a14);
  }
  if (!a12) {
    JUMPOUT(0x21679B328);
  }
  JUMPOUT(0x21679B324);
}

uint64_t sub_21679B360(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  long long v4 = *(double ***)(v3 + 64);
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void *)(a1 + 56);
  }
  uint64_t FloorIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5) {
    sub_216784EC4(v5);
  }
  return FloorIndex;
}

void sub_21679B3C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_21679B3E0(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  long long v4 = *(double ***)(v3 + 64);
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void *)(a1 + 56);
  }
  uint64_t CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getCeilIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5) {
    sub_216784EC4(v5);
  }
  return CeilIndex;
}

void sub_21679B448(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_21679B460(uint64_t a1, double a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  long long v4 = *(double ***)(v3 + 64);
  uint64_t v5 = *(std::__shared_weak_count **)(v3 + 72);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v3 = *(void *)(a1 + 56);
  }
  uint64_t v6 = Alembic::AbcCoreAbstract::v12::TimeSampling::getNearIndex(v4, a2, *(unsigned int *)(v3 + 84));
  if (v5) {
    sub_216784EC4(v5);
  }
  return v6;
}

void sub_21679B4C8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_216784EC4(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679B4E0(Alembic::AbcCoreAbstract::v12::ScalarPropertyReader *this)
{
  *(void *)this = &unk_26C749380;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    sub_216784EC4(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v3) {
    sub_216784EC4(v3);
  }
  long long v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4) {
    sub_216784EC4(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }

  Alembic::AbcCoreAbstract::v12::ScalarPropertyReader::~ScalarPropertyReader(this);
}

void sub_21679B560(Alembic::AbcCoreAbstract::v12::ScalarPropertyReader *this)
{
  *(void *)this = &unk_26C749380;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    sub_216784EC4(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v3) {
    sub_216784EC4(v3);
  }
  long long v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4) {
    sub_216784EC4(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  Alembic::AbcCoreAbstract::v12::ScalarPropertyReader::~ScalarPropertyReader(this);

  operator delete(v6);
}

void *sub_21679B5E4(void *result, void *a2, void *a3, void *a4, uint64_t a5)
{
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_26C749448;
  result[3] = 0;
  result[4] = 0;
  result[5] = *a2;
  uint64_t v5 = a2[1];
  result[6] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  result[7] = *a4;
  uint64_t v6 = a4[1];
  result[8] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  result[9] = 0;
  result[10] = 0;
  result[11] = *a3;
  uint64_t v7 = a3[1];
  result[12] = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  result[13] = a5;
  if (!result[5])
  {
    sub_216778A5C((uint64_t)v20);
    sub_216779180(v21, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v19, (long long *)__p);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v10 = sub_216779038(exception, (uint64_t)v19);
    __cxa_throw(v10, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v8 = result[7];
  if (!v8)
  {
    sub_216778A5C((uint64_t)v20);
    sub_216779180(v21, (uint64_t)"Invalid property header", 23);
    std::stringbuf::str();
    sub_216778E70(v19, (long long *)__p);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v11 = __cxa_allocate_exception(0x20uLL);
    uint64_t v12 = sub_216779038(v11, (uint64_t)v19);
    __cxa_throw(v12, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!result[11])
  {
    sub_216778A5C((uint64_t)v20);
    sub_216779180(v21, (uint64_t)"Invalid group", 13);
    std::stringbuf::str();
    sub_216778E70(v19, (long long *)__p);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v13 = __cxa_allocate_exception(0x20uLL);
    uint64_t v14 = sub_216779038(v13, (uint64_t)v19);
    __cxa_throw(v14, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (*(_DWORD *)(v8 + 24) != 1)
  {
    sub_216778A5C((uint64_t)v20);
    sub_216779180(v21, (uint64_t)"Attempted to create a ScalarPropertyWriter from a non-scalar property type", 74);
    std::stringbuf::str();
    sub_216778E70(v19, (long long *)__p);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    unint64_t v15 = __cxa_allocate_exception(0x20uLL);
    __n64 v16 = sub_216779038(v15, (uint64_t)v19);
    __cxa_throw(v16, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_21679B8B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v11.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 + 12);
  if (v6) {
    sub_216784EC4(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)v4 + 8);
  if (v7) {
    sub_216784EC4(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)v4 + 6);
  if (v8) {
    sub_216784EC4(v8);
  }
  unint64_t v9 = (std::__shared_weak_count *)*((void *)v4 + 4);
  if (v9) {
    sub_216784EC4(v9);
  }
  unint64_t v10 = (std::__shared_weak_count *)*((void *)v4 + 2);
  if (v10) {
    std::__shared_weak_count::__release_weak(v10);
  }
  Alembic::AbcCoreAbstract::v12::ScalarPropertyWriter::~ScalarPropertyWriter(v4);
  _Unwind_Resume(a1);
}

void sub_21679B960(uint64_t a1)
{
  *(void *)a1 = &unk_26C749448;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 24))(&v18);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v18 + 24))(&v20);
  if (v19) {
    sub_216784EC4(v19);
  }
  uint64_t v2 = (*(uint64_t (**)(uint64_t, void))(*(void *)v20 + 72))(v20, *(unsigned int *)(*(void *)(a1 + 56) + 96));
  uint64_t v3 = *(_DWORD **)(a1 + 56);
  unsigned int v4 = v3[21];
  if (v4) {
    BOOL v5 = v3[23] == 0;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = v4;
  }
  if (v2 < v6) {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)v20 + 80))(v20, v3[24], v6);
  }
  Alembic::Util::v12::SpookyHash::Init((uint64_t)&v18, 0, 0);
  sub_21679D428(*(void *)(a1 + 56), (Alembic::Util::v12::SpookyHash *)&v18);
  if (v6) {
    Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)&v18, (void *)(a1 + 72), 0x10uLL);
  }
  uint64_t v16 = 0;
  unint64_t v17 = 0;
  Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)&v18, &v17, (unint64_t *)&v16, v7, v8);
  unint64_t v9 = *(void **)(a1 + 40);
  if (v9
  {
    unint64_t v10 = *(std::__shared_weak_count **)(a1 + 48);
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    unint64_t v10 = 0;
  }
  sub_216790220((uint64_t)v9, *(void *)(a1 + 104), v17, v16);
  if (v10) {
    sub_216784EC4(v10);
  }
  if (v21) {
    sub_216784EC4(v21);
  }
  std::exception v11 = *(std::__shared_weak_count **)(a1 + 96);
  if (v11) {
    sub_216784EC4(v11);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 64);
  if (v12) {
    sub_216784EC4(v12);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 48);
  if (v13) {
    sub_216784EC4(v13);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 32);
  if (v14) {
    sub_216784EC4(v14);
  }
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 16);
  if (v15) {
    std::__shared_weak_count::__release_weak(v15);
  }
  Alembic::AbcCoreAbstract::v12::ScalarPropertyWriter::~ScalarPropertyWriter((Alembic::AbcCoreAbstract::v12::ScalarPropertyWriter *)a1);
}

void sub_21679BBAC(uint64_t a1)
{
  sub_21679B960(a1);

  operator delete(v1);
}

void sub_21679BBD4(Alembic::AbcCoreAbstract::v12::TimeSamplingType *a1)
{
  uint64_t v2 = *((void *)a1 + 7);
  uint64_t v3 = *(uint64_t **)(v2 + 64);
  unsigned int v4 = *(std::__shared_weak_count **)(v2 + 72);
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = *v3;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(a1) != v5)
  {
    BOOL v9 = 0;
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v6 = *((void *)a1 + 7);
  uint64_t v8 = *(void *)(v6 + 64);
  uint64_t v7 = *(std::__shared_weak_count **)(v6 + 72);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v9 = *(unsigned int *)(*((void *)a1 + 7) + 84) >= (unint64_t)((uint64_t)(*(void *)(v8 + 24)
                                                                                     - *(void *)(v8 + 16)) >> 3);
    sub_216784EC4(v7);
    if (!v4) {
      goto LABEL_9;
    }
LABEL_8:
    sub_216784EC4(v4);
    goto LABEL_9;
  }
  BOOL v9 = *(unsigned int *)(v6 + 84) >= (unint64_t)((uint64_t)(*(void *)(v8 + 24) - *(void *)(v8 + 16)) >> 3);
  if (v4) {
    goto LABEL_8;
  }
LABEL_9:
  if (v9)
  {
    sub_216778A5C((uint64_t)v32);
    sub_216779180(v33, (uint64_t)"Can not set more samples than we have times for when using Acyclic sampling.", 76);
    std::stringbuf::str();
    sub_216778E70(v31, (long long *)__p);
    if (v30 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    int v26 = sub_216779038(exception, (uint64_t)v31);
    __cxa_throw(v26, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v10 = *((void *)a1 + 7);
  int v11 = *(_DWORD *)(v10 + 84);
  if (!v11)
  {
    sub_216778A5C((uint64_t)v32);
    sub_216779180(v33, (uint64_t)"Can't set from previous sample before any samples have been written", 67);
    std::stringbuf::str();
    sub_216778E70(v31, (long long *)__p);
    if (v30 < 0) {
      operator delete(__p[0]);
    }
    int v27 = __cxa_allocate_exception(0x20uLL);
    int v28 = sub_216779038(v27, (uint64_t)v31);
    __cxa_throw(v28, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v12 = *((void *)a1 + 3);
  uint64_t v13 = *(void *)(v12 + 16);
  uint64_t v14 = (*(void *)(v12 + 24) ^ v13) + __ROR8__(v13, 49);
  uint64_t v15 = (v14 ^ *((void *)a1 + 9)) + __ROR8__(v14, 12);
  uint64_t v16 = (v15 ^ *((void *)a1 + 10)) + __ROR8__(v15, 38);
  uint64_t v17 = (v16 ^ __ROR8__(v13, 49)) + __ROR8__(v16, 13);
  uint64_t v18 = (v17 ^ __ROR8__(v14, 12)) + __ROR8__(v17, 36);
  uint64_t v19 = (v18 ^ __ROR8__(v15, 38)) + __ROR8__(v18, 55);
  uint64_t v20 = (v19 ^ __ROR8__(v16, 13)) + __ROR8__(v19, 17);
  uint64_t v21 = (v20 ^ __ROR8__(v17, 36)) + __ROR8__(v20, 10);
  uint64_t v22 = (v21 ^ __ROR8__(v18, 55)) + __ROR8__(v21, 32);
  uint64_t v23 = (v22 ^ __ROR8__(v19, 17)) + __ROR8__(v22, 39);
  uint64_t v24 = __ROR8__(v23, 1);
  *((void *)a1 + 9) = v24;
  *((void *)a1 + 10) = (v23 ^ __ROR8__(v20, 10)) + v24;
  *(_DWORD *)(v10 + 84) = v11 + 1;
}

void sub_21679BE30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21679BE78(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  std::exception v5 = *(uint64_t **)(v4 + 64);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 72);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *v5;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples((Alembic::AbcCoreAbstract::v12::TimeSamplingType *)a1) != v7)
  {
    BOOL v11 = 1;
    if (!v6) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  uint64_t v8 = a1[7];
  uint64_t v10 = *(void *)(v8 + 64);
  uint64_t v9 = *(std::__shared_weak_count **)(v8 + 72);
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    BOOL v11 = *(unsigned int *)(a1[7] + 84) < (unint64_t)((uint64_t)(*(void *)(v10 + 24) - *(void *)(v10 + 16)) >> 3);
    sub_216784EC4(v9);
    if (!v6) {
      goto LABEL_9;
    }
LABEL_8:
    sub_216784EC4(v6);
    goto LABEL_9;
  }
  BOOL v11 = *(unsigned int *)(v8 + 84) < (unint64_t)((uint64_t)(*(void *)(v10 + 24) - *(void *)(v10 + 16)) >> 3);
  if (v6) {
    goto LABEL_8;
  }
LABEL_9:
  if (!v11)
  {
    sub_216778A5C((uint64_t)v59);
    sub_216779180(&v60, (uint64_t)"Can not write more samples than we have times for when using Acyclic sampling.", 78);
    std::stringbuf::str();
    sub_216778E70(&__p, (long long *)v53);
    if (v54 < 0) {
      operator delete(v53[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v43 = sub_216779038(exception, (uint64_t)&__p);
    __cxa_throw(v43, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v12 = a1[7];
  v53[0] = (void *)1;
  sub_2167864B4(&__p, 1uLL, v53);
  uint64_t v13 = *(void *)(v12 + 56);
  v59[0] = a2;
  v59[1] = v13;
  unint64_t v61 = 0;
  uint64_t v62 = 0;
  unint64_t v60 = 0;
  sub_21677EA60(&v60, __p, v56, (v56 - (uint64_t)__p) >> 3);
  if (__p)
  {
    uint64_t v56 = (uint64_t)__p;
    operator delete(__p);
  }
  Alembic::AbcCoreAbstract::v12::ArraySample::getKey((Alembic::AbcCoreAbstract::v12::ArraySample *)v59, (uint64_t)&__p);
  int v14 = v56;
  if ((v56 - 14) <= 0xFFFFFFFD)
  {
    uint64_t v56 = 0x200000002;
    int v14 = 2;
  }
  uint64_t v15 = (_DWORD *)a1[7];
  uint64_t v17 = v15 + 21;
  unsigned int v16 = v15[21];
  if (v16)
  {
    uint64_t v18 = a1[3];
    if (v18)
    {
      if (__p == *(void **)v18
        && __PAIR128__(v57, __PAIR64__(HIDWORD(v56), v14)) == *(_OWORD *)(v18 + 8)
        && v58 == *(void *)(v18 + 24))
      {
        goto LABEL_48;
      }
    }
  }
  if (v15[22])
  {
    unint64_t v19 = (v15[23] + 1);
    if (v19 < v16)
    {
      do
      {
        uint64_t v20 = (std::__shared_weak_count *)a1[12];
        uint64_t v51 = a1[11];
        unsigned int v52 = v20;
        if (v20) {
          atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v21 = (std::__shared_weak_count *)a1[4];
        uint64_t v49 = a1[3];
        uint64_t v50 = v21;
        if (v21) {
          atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        sub_21679E3F8(&v51, &v49);
        if (v50) {
          sub_216784EC4(v50);
        }
        if (v52) {
          sub_216784EC4(v52);
        }
        ++v19;
      }
      while (v19 < *(unsigned int *)(a1[7] + 84));
    }
  }
  (*(void (**)(long long *__return_ptr, void *))(*a1 + 24))(&v48, a1);
  (*(void (**)(void **__return_ptr))(*(void *)v48 + 24))(v53);
  if (*((void *)&v48 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v48 + 1));
  }
  unsigned int v46 = v53[0];
  unint64_t v47 = (std::__shared_weak_count *)v53[1];
  if (v53[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)v53[1] + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = sub_21679D8E0((const void **)&v46);
  uint64_t v23 = (std::__shared_weak_count *)a1[12];
  uint64_t v44 = a1[11];
  char v45 = v23;
  if (v23) {
    atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_21679DA60(v22, (uint64_t)&v44, (uint64_t)v59, (uint64_t)&__p, (uint64_t *)&v48);
  long long v24 = v48;
  long long v48 = 0uLL;
  unint64_t v25 = (std::__shared_weak_count *)a1[4];
  *(_OWORD *)(a1 + 3) = v24;
  if (v25)
  {
    sub_216784EC4(v25);
    if (*((void *)&v48 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v48 + 1));
    }
  }
  if (v45) {
    sub_216784EC4(v45);
  }
  if (v47) {
    sub_216784EC4(v47);
  }
  int v26 = (_DWORD *)a1[7];
  unsigned int v16 = v26[21];
  if (!v26[22]) {
    v26[22] = v16;
  }
  v26[23] = v16;
  if (v53[1])
  {
    sub_216784EC4((std::__shared_weak_count *)v53[1]);
    int v26 = (_DWORD *)a1[7];
    unsigned int v16 = v26[21];
  }
  uint64_t v17 = v26 + 21;
  if (v16)
  {
LABEL_48:
    uint64_t v27 = a1[3];
    uint64_t v28 = *(void *)(v27 + 16);
    uint64_t v29 = (*(void *)(v27 + 24) ^ v28) + __ROR8__(v28, 49);
    uint64_t v30 = (v29 ^ a1[9]) + __ROR8__(v29, 12);
    uint64_t v31 = (v30 ^ a1[10]) + __ROR8__(v30, 38);
    uint64_t v32 = (v31 ^ __ROR8__(v28, 49)) + __ROR8__(v31, 13);
    uint64_t v33 = (v32 ^ __ROR8__(v29, 12)) + __ROR8__(v32, 36);
    uint64_t v34 = (v33 ^ __ROR8__(v30, 38)) + __ROR8__(v33, 55);
    uint64_t v35 = (v34 ^ __ROR8__(v31, 13)) + __ROR8__(v34, 17);
    uint64_t v36 = (v35 ^ __ROR8__(v32, 36)) + __ROR8__(v35, 10);
    uint64_t v37 = (v36 ^ __ROR8__(v33, 55)) + __ROR8__(v36, 32);
    uint64_t v38 = (v37 ^ __ROR8__(v34, 17)) + __ROR8__(v37, 39);
    uint64_t v39 = v38 ^ __ROR8__(v35, 10);
    uint64_t v40 = __ROR8__(v38, 1);
    a1[9] = v40;
    a1[10] = v39 + v40;
  }
  else
  {
    uint64_t v41 = a1[3];
    a1[9] = *(void *)(v41 + 16);
    a1[10] = *(void *)(v41 + 24);
    unsigned int v16 = *v17;
  }
  unsigned int *v17 = v16 + 1;
  if (v60)
  {
    unint64_t v61 = v60;
    operator delete(v60);
  }
}

void sub_21679C300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void *__p,uint64_t a29)
{
}

double sub_21679C3CC@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_21679C408(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 56) + 84);
}

void sub_21679C414(uint64_t a1, int a2)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 40) + 24))(&v14);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v14 + 24))(&v16);
  (*(void (**)(void **__return_ptr))(*(void *)v16 + 56))(&v19);
  if (v17) {
    sub_216784EC4(v17);
  }
  long long v4 = (Alembic::AbcCoreAbstract::v12::TimeSamplingType *)v15;
  if (v15) {
    sub_216784EC4(v15);
  }
  uint64_t v5 = *v19;
  if (Alembic::AbcCoreAbstract::v12::TimeSamplingType::AcyclicNumSamples(v4) == v5)
  {
    uint64_t v6 = v19;
    uint64_t v7 = *(void *)(a1 + 56);
    if (*(unsigned int *)(v7 + 84) > (unint64_t)((uint64_t)(v6[3] - v6[2]) >> 3))
    {
      sub_216778A5C((uint64_t)&v16);
      sub_216779180(v18, (uint64_t)"Already have written more samples than we have times for when using Acyclic sampling.", 85);
      std::stringbuf::str();
      sub_216778E70(&v14, &__p);
      if (v13 < 0) {
        operator delete((void *)__p);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v9 = sub_216779038(exception, (uint64_t)&v14);
      __cxa_throw(v9, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 56);
    uint64_t v6 = v19;
  }
  uint64_t v10 = v20;
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v11 = *(std::__shared_weak_count **)(v7 + 72);
  *(void *)(v7 + 64) = v6;
  *(void *)(v7 + 72) = v10;
  if (v11) {
    sub_216784EC4(v11);
  }
  *(_DWORD *)(*(void *)(a1 + 56) + 96) = a2;
  if (v20) {
    sub_216784EC4(v20);
  }
}

void sub_21679C5D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 - 40);
  if (v6) {
    sub_216784EC4(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_21679C638(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 56);
  if (!result)
  {
    sub_216778A5C((uint64_t)v7);
    sub_216779180(v8, (uint64_t)"Invalid header", 14);
    std::stringbuf::str();
    sub_216778E70(v6, &__p);
    if (v5 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v3 = sub_216779038(exception, (uint64_t)v6);
    __cxa_throw(v3, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return result;
}

void sub_21679C6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_21679C704(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 24);

  return v2();
}

void sub_21679C7D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_21679C800@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 40);
  if (!v2)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v3 = *(void *)(result + 48);
  *a2 = v2;
  a2[1] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_21679C8BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

unint64_t *sub_21679C8E4(unint64_t *a1, unint64_t a2)
{
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = (uint64_t)(a1 + 1);
  a1[3] = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 5), 0);
  a1[14] = 0;
  a1[15] = 0;
  atomic_store(0, a1 + 13);
  a1[4] = 0;
  *a1 = a2;
  if (a2 >= 2)
  {
    sub_21679A004(v4, a2);
    if (*a1)
    {
      unint64_t v5 = 0;
      do
      {
        *(void *)(a1[1] + 8 * v5) = v5;
        unint64_t v6 = *a1;
        if (*a1 <= 0x3F)
        {
          atomic_fetch_or((atomic_ullong *volatile)a1 + 13, 1 << v5);
          unint64_t v6 = *a1;
        }
        ++v5;
      }
      while (v5 < v6);
    }
  }
  uint64_t v7 = operator new(0x10uLL);
  *uint64_t v7 = 0;
  v7[1] = 0;
  sub_21679CC78(&v11, (uint64_t)v7);
  long long v8 = v11;
  long long v11 = 0uLL;
  uint64_t v9 = (std::__shared_weak_count *)a1[15];
  *((_OWORD *)a1 + 7) = v8;
  if (v9)
  {
    sub_216784EC4(v9);
    if (*((void *)&v11 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v11 + 1));
    }
  }
  return a1;
}

void sub_21679C9DC(_Unwind_Exception *a1)
{
  unint64_t v5 = *(std::__shared_weak_count **)(v1 + 120);
  if (v5) {
    sub_216784EC4(v5);
  }
  pthread_mutex_destroy(v3);
  unint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_21679CA20(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 120);
  if (v2) {
    sub_216784EC4(v2);
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 40));
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3)
  {
    *(void *)(a1 + 16) = v3;
    operator delete(v3);
  }
  return a1;
}

void *sub_21679CA70@<X0>(void *result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = result;
  if (*result <= 1uLL)
  {
LABEL_2:
    uint64_t v4 = result[15];
    *a2 = result[14];
    a2[1] = v4;
    if (v4) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    }
    return result;
  }
  if (*result <= 0x40uLL)
  {
    while (1)
    {
      unint64_t v8 = atomic_load(result + 13);
      if (!v8) {
        break;
      }
      unint64_t v9 = __clz(__rbit64(v8));
      unint64_t v10 = v8;
      atomic_compare_exchange_strong(result + 13, &v10, v8 & ~(1 << v9));
      if (v10 == v8)
      {
        long long v11 = operator new(0x10uLL);
        *long long v11 = v2;
        v11[1] = v9;
        return sub_21679CC78(a2, (uint64_t)v11);
      }
    }
    goto LABEL_2;
  }
  pthread_mutex_lock((pthread_mutex_t *)(result + 5));
  unint64_t v5 = v2[4];
  if (v5 >= *v2)
  {
    unint64_t v12 = v2[15];
    *a2 = v2[14];
    a2[1] = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    unint64_t v6 = operator new(0x10uLL);
    v2[4] = v5 + 1;
    uint64_t v7 = *(void *)(v2[1] + 8 * v5);
    *unint64_t v6 = v2;
    v6[1] = v7;
    sub_21679CC78(a2, (uint64_t)v6);
  }
  return (void *)pthread_mutex_unlock((pthread_mutex_t *)(v2 + 5));
}

void sub_21679CB9C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_21679CBB4(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 <= 0x40uLL)
  {
    do
    {
      unint64_t v5 = atomic_load((unint64_t *)(a1 + 104));
      unint64_t v6 = v5;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 104), &v6, v5 | (1 << a2));
    }
    while (v6 != v5);
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 40));
    uint64_t v4 = *(void *)(a1 + 32) - 1;
    *(void *)(a1 + 32) = v4;
    *(void *)(*(void *)(a1 + 8) + 8 * v4) = a2;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 40));
  }
}

uint64_t *sub_21679CC40(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    sub_21679CBB4(v2, a1[1]);
  }
  return a1;
}

void *sub_21679CC78(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C749500;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_21679CCD0(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    uint64_t v3 = sub_21679CC40(v1);
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679CCF0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_21679CD18(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = sub_21679CC40(v1);
    operator delete(v2);
  }
}

uint64_t sub_21679CD50(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C749550)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_21679CD94(unint64_t *a1, int a2, int a3)
{
  switch(a3)
  {
    case 2:
      unint64_t v9 = (unsigned char *)a1[1];
      unint64_t v8 = a1[2];
      if ((unint64_t)v9 >= v8)
      {
        unint64_t v20 = *a1;
        uint64_t v21 = &v9[-*a1];
        unint64_t v22 = (unint64_t)(v21 + 1);
        if ((uint64_t)(v21 + 1) < 0) {
          goto LABEL_134;
        }
        unint64_t v23 = v8 - v20;
        if (2 * v23 > v22) {
          unint64_t v22 = 2 * v23;
        }
        if (v23 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v24 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v24 = v22;
        }
        if (v24) {
          unint64_t v25 = (unint64_t)operator new(v24);
        }
        else {
          unint64_t v25 = 0;
        }
        uint64_t v35 = (char *)(v25 + v24);
        v21[v25] = a2;
        unint64_t v10 = &v21[v25 + 1];
        if (v9 == (unsigned char *)v20)
        {
          v25 += (unint64_t)v21;
        }
        else
        {
          uint64_t v36 = &v9[~v20];
          do
          {
            char v37 = *--v9;
            (v36--)[v25] = v37;
          }
          while (v9 != (unsigned char *)v20);
          unint64_t v9 = (unsigned char *)*a1;
        }
        *a1 = v25;
        a1[1] = (unint64_t)v10;
        a1[2] = (unint64_t)v35;
        if (v9) {
          operator delete(v9);
        }
      }
      else
      {
        *unint64_t v9 = a2;
        unint64_t v10 = v9 + 1;
      }
      a1[1] = (unint64_t)v10;
      unint64_t v41 = a1[2];
      if ((unint64_t)v10 < v41)
      {
        *unint64_t v10 = BYTE1(a2);
        char v42 = v10 + 1;
        goto LABEL_93;
      }
      unint64_t v43 = *a1;
      uint64_t v44 = &v10[-*a1];
      unint64_t v45 = (unint64_t)(v44 + 1);
      if ((uint64_t)(v44 + 1) < 0) {
        goto LABEL_134;
      }
      unint64_t v46 = v41 - v43;
      if (2 * v46 > v45) {
        unint64_t v45 = 2 * v46;
      }
      if (v46 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v47 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v47 = v45;
      }
      if (v47) {
        unint64_t v48 = (unint64_t)operator new(v47);
      }
      else {
        unint64_t v48 = 0;
      }
      unint64_t v57 = (char *)(v48 + v47);
      v44[v48] = BYTE1(a2);
      char v42 = &v44[v48 + 1];
      if (v10 == (unsigned char *)v43)
      {
        *a1 = (unint64_t)&v44[v48];
        a1[1] = (unint64_t)v42;
        a1[2] = (unint64_t)v57;
      }
      else
      {
        uint64_t v58 = &v10[~v43];
        do
        {
          char v59 = *--v10;
          (v58--)[v48] = v59;
        }
        while (v10 != (unsigned char *)v43);
        unint64_t v10 = (unsigned char *)*a1;
        *a1 = v48;
        a1[1] = (unint64_t)v42;
        a1[2] = (unint64_t)v57;
        if (!v10)
        {
LABEL_93:
          a1[1] = (unint64_t)v42;
          unint64_t v63 = a1[2];
          if ((unint64_t)v42 >= v63)
          {
            unint64_t v65 = *a1;
            uint64_t v66 = &v42[-*a1];
            unint64_t v67 = (unint64_t)(v66 + 1);
            if ((uint64_t)(v66 + 1) < 0) {
              goto LABEL_134;
            }
            unint64_t v68 = v63 - v65;
            if (2 * v68 > v67) {
              unint64_t v67 = 2 * v68;
            }
            if (v68 >= 0x3FFFFFFFFFFFFFFFLL) {
              size_t v69 = 0x7FFFFFFFFFFFFFFFLL;
            }
            else {
              size_t v69 = v67;
            }
            if (v69) {
              unint64_t v70 = (unint64_t)operator new(v69);
            }
            else {
              unint64_t v70 = 0;
            }
            uint64_t v72 = (char *)(v70 + v69);
            v66[v70] = BYTE2(a2);
            unint64_t v64 = &v66[v70 + 1];
            if (v42 == (unsigned char *)v65)
            {
              *a1 = (unint64_t)&v66[v70];
              a1[1] = (unint64_t)v64;
              a1[2] = (unint64_t)v72;
            }
            else
            {
              unint64_t v73 = &v42[~v65];
              do
              {
                char v74 = *--v42;
                (v73--)[v70] = v74;
              }
              while (v42 != (unsigned char *)v65);
              char v42 = (unsigned char *)*a1;
              *a1 = v70;
              a1[1] = (unint64_t)v64;
              a1[2] = (unint64_t)v72;
              if (!v42) {
                goto LABEL_113;
              }
            }
            operator delete(v42);
          }
          else
          {
            unsigned char *v42 = BYTE2(a2);
            unint64_t v64 = v42 + 1;
          }
LABEL_113:
          a1[1] = (unint64_t)v64;
          unint64_t v75 = a1[2];
          if ((unint64_t)v64 < v75)
          {
            *unint64_t v64 = HIBYTE(a2);
            uint64_t v50 = (uint64_t)(v64 + 1);
            goto LABEL_132;
          }
          unint64_t v76 = *a1;
          int64_t v77 = &v64[-*a1];
          unint64_t v78 = (unint64_t)(v77 + 1);
          if ((uint64_t)(v77 + 1) < 0) {
            goto LABEL_134;
          }
          unint64_t v79 = v75 - v76;
          if (2 * v79 > v78) {
            unint64_t v78 = 2 * v79;
          }
          if (v79 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v80 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v80 = v78;
          }
          if (v80) {
            unint64_t v81 = (unint64_t)operator new(v80);
          }
          else {
            unint64_t v81 = 0;
          }
          double v82 = (char *)(v81 + v80);
          v77[v81] = HIBYTE(a2);
          uint64_t v50 = (uint64_t)&v77[v81 + 1];
          if (v64 == (unsigned char *)v76)
          {
            *a1 = (unint64_t)&v77[v81];
            a1[1] = v50;
            a1[2] = (unint64_t)v82;
          }
          else
          {
            unsigned int v83 = &v64[~v76];
            do
            {
              char v84 = *--v64;
              (v83--)[v81] = v84;
            }
            while (v64 != (unsigned char *)v76);
            unint64_t v64 = (unsigned char *)*a1;
            *a1 = v81;
            a1[1] = v50;
            a1[2] = (unint64_t)v82;
            if (!v64) {
              goto LABEL_132;
            }
          }
          uint64_t v71 = v64;
LABEL_131:
          operator delete(v71);
          goto LABEL_132;
        }
      }
      operator delete(v10);
      goto LABEL_93;
    case 1:
      unint64_t v12 = (unsigned char *)a1[1];
      unint64_t v11 = a1[2];
      if ((unint64_t)v12 >= v11)
      {
        unint64_t v26 = *a1;
        uint64_t v27 = &v12[-*a1];
        unint64_t v28 = (unint64_t)(v27 + 1);
        if ((uint64_t)(v27 + 1) < 0) {
          goto LABEL_134;
        }
        unint64_t v29 = v11 - v26;
        if (2 * v29 > v28) {
          unint64_t v28 = 2 * v29;
        }
        if (v29 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v30 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v30 = v28;
        }
        if (v30) {
          unint64_t v31 = (unint64_t)operator new(v30);
        }
        else {
          unint64_t v31 = 0;
        }
        uint64_t v38 = (char *)(v31 + v30);
        v27[v31] = a2;
        char v13 = &v27[v31 + 1];
        if (v12 == (unsigned char *)v26)
        {
          v31 += (unint64_t)v27;
        }
        else
        {
          uint64_t v39 = &v12[~v26];
          do
          {
            char v40 = *--v12;
            (v39--)[v31] = v40;
          }
          while (v12 != (unsigned char *)v26);
          unint64_t v12 = (unsigned char *)*a1;
        }
        *a1 = v31;
        a1[1] = (unint64_t)v13;
        a1[2] = (unint64_t)v38;
        if (v12) {
          operator delete(v12);
        }
      }
      else
      {
        *unint64_t v12 = a2;
        char v13 = v12 + 1;
      }
      a1[1] = (unint64_t)v13;
      unint64_t v49 = a1[2];
      if ((unint64_t)v13 < v49)
      {
        *char v13 = BYTE1(a2);
        uint64_t v50 = (uint64_t)(v13 + 1);
LABEL_132:
        a1[1] = v50;
        return;
      }
      unint64_t v51 = *a1;
      unsigned int v52 = &v13[-*a1];
      unint64_t v53 = (unint64_t)(v52 + 1);
      if ((uint64_t)(v52 + 1) < 0) {
        goto LABEL_134;
      }
      unint64_t v54 = v49 - v51;
      if (2 * v54 > v53) {
        unint64_t v53 = 2 * v54;
      }
      if (v54 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v55 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v55 = v53;
      }
      if (v55) {
        unint64_t v56 = (unint64_t)operator new(v55);
      }
      else {
        unint64_t v56 = 0;
      }
      unint64_t v60 = (char *)(v56 + v55);
      v52[v56] = BYTE1(a2);
      uint64_t v50 = (uint64_t)&v52[v56 + 1];
      if (v13 == (unsigned char *)v51)
      {
        *a1 = (unint64_t)&v52[v56];
        a1[1] = v50;
        a1[2] = (unint64_t)v60;
      }
      else
      {
        unint64_t v61 = &v13[~v51];
        do
        {
          char v62 = *--v13;
          (v61--)[v56] = v62;
        }
        while (v13 != (unsigned char *)v51);
        char v13 = (unsigned char *)*a1;
        *a1 = v56;
        a1[1] = v50;
        a1[2] = (unint64_t)v60;
        if (!v13) {
          goto LABEL_132;
        }
      }
      uint64_t v71 = v13;
      goto LABEL_131;
    case 0:
      unint64_t v6 = (unsigned char *)a1[1];
      unint64_t v5 = a1[2];
      if ((unint64_t)v6 < v5)
      {
        *unint64_t v6 = a2;
        uint64_t v7 = (uint64_t)(v6 + 1);
LABEL_52:
        a1[1] = v7;
        return;
      }
      unint64_t v14 = *a1;
      uint64_t v15 = &v6[-*a1];
      unint64_t v16 = (unint64_t)(v15 + 1);
      if ((uint64_t)(v15 + 1) >= 0)
      {
        unint64_t v17 = v5 - v14;
        if (2 * v17 > v16) {
          unint64_t v16 = 2 * v17;
        }
        if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v18 = v16;
        }
        if (v18) {
          unint64_t v19 = (unint64_t)operator new(v18);
        }
        else {
          unint64_t v19 = 0;
        }
        uint64_t v32 = (char *)(v19 + v18);
        v15[v19] = a2;
        uint64_t v7 = (uint64_t)&v15[v19 + 1];
        if (v6 == (unsigned char *)v14)
        {
          v19 += (unint64_t)v15;
        }
        else
        {
          uint64_t v33 = &v6[~v14];
          do
          {
            char v34 = *--v6;
            (v33--)[v19] = v34;
          }
          while (v6 != (unsigned char *)v14);
          unint64_t v6 = (unsigned char *)*a1;
        }
        *a1 = v19;
        a1[1] = v7;
        a1[2] = (unint64_t)v32;
        if (v6) {
          operator delete(v6);
        }
        goto LABEL_52;
      }
LABEL_134:
      sub_21677CB10();
  }
}

void sub_21679D300(unint64_t *a1, double a2)
{
  uint64_t v3 = 0;
  double v17 = a2;
  uint64_t v4 = (unsigned char *)a1[1];
  do
  {
    unint64_t v5 = a1[2];
    if ((unint64_t)v4 >= v5)
    {
      unint64_t v7 = *a1;
      unint64_t v8 = &v4[-*a1];
      unint64_t v9 = (unint64_t)(v8 + 1);
      if ((uint64_t)(v8 + 1) < 0) {
        sub_21677CB10();
      }
      unint64_t v10 = v5 - v7;
      if (2 * v10 > v9) {
        unint64_t v9 = 2 * v10;
      }
      if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v11 = v9;
      }
      if (v11) {
        unint64_t v12 = (char *)operator new(v11);
      }
      else {
        unint64_t v12 = 0;
      }
      char v13 = &v8[(void)v12];
      unint64_t v14 = &v8[(void)v12];
      unsigned char *v14 = *((unsigned char *)&v17 + v3);
      unint64_t v6 = v14 + 1;
      if (v4 != (unsigned char *)v7)
      {
        uint64_t v15 = &v4[~v7];
        do
        {
          char v16 = *--v4;
          (v15--)[(void)v12] = v16;
        }
        while (v4 != (unsigned char *)v7);
        uint64_t v4 = (unsigned char *)*a1;
        char v13 = v12;
      }
      *a1 = (unint64_t)v13;
      a1[1] = (unint64_t)v6;
      a1[2] = (unint64_t)&v12[v11];
      if (v4) {
        operator delete(v4);
      }
    }
    else
    {
      unsigned char *v4 = *((unsigned char *)&v17 + v3);
      unint64_t v6 = v4 + 1;
    }
    a1[1] = (unint64_t)v6;
    ++v3;
    uint64_t v4 = v6;
  }
  while (v3 != 8);
}

void sub_21679D428(uint64_t a1, Alembic::Util::v12::SpookyHash *a2)
{
  long long __p = 0;
  std::string __dst = 0;
  unint64_t v50 = 0;
  int v4 = *(char *)(a1 + 23);
  if (v4 >= 0) {
    unint64_t v5 = (char *)a1;
  }
  else {
    unint64_t v5 = *(char **)a1;
  }
  if (v4 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v6 = *(void *)(a1 + 8);
  }
  sub_216790EF4((char **)&__p, 0, v5, &v5[v6], v6);
  Alembic::Util::v12::TokenMap::get((Alembic::Util::v12::TokenMap *)(a1 + 32), 0x3Bu, 61, 1);
  if ((v47 & 0x80u) == 0) {
    unint64_t v7 = (char *)v46;
  }
  else {
    unint64_t v7 = (char *)v46[0];
  }
  if ((v47 & 0x80u) == 0) {
    uint64_t v8 = v47;
  }
  else {
    uint64_t v8 = (uint64_t)v46[1];
  }
  sub_216790EF4((char **)&__p, (char *)__dst, v7, &v7[v8], v8);
  if (!*(_DWORD *)(a1 + 24)) {
    goto LABEL_77;
  }
  int v9 = *(_DWORD *)(a1 + 56);
  unint64_t v10 = (char *)__dst;
  if ((unint64_t)__dst >= v50)
  {
    unint64_t v12 = (unint64_t)__p;
    int64_t v13 = (unsigned char *)__dst - (unsigned char *)__p;
    int64_t v14 = (unsigned char *)__dst - (unsigned char *)__p + 1;
    if (v14 < 0) {
      sub_21677CB10();
    }
    unint64_t v15 = v50 - (void)__p;
    if (2 * (v50 - (unint64_t)__p) > v14) {
      int64_t v14 = 2 * v15;
    }
    if (v15 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v16 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v16 = v14;
    }
    if (v16) {
      double v17 = operator new(v16);
    }
    else {
      double v17 = 0;
    }
    size_t v18 = (char *)v17 + v16;
    *((unsigned char *)v17 + v13) = v9;
    size_t v11 = (char *)v17 + v13 + 1;
    if (v10 == (char *)v12)
    {
      double v17 = (char *)v17 + v13;
    }
    else
    {
      unint64_t v19 = &v10[~v12];
      do
      {
        char v20 = *--v10;
        (v19--)[(void)v17] = v20;
      }
      while (v10 != (char *)v12);
      unint64_t v10 = (char *)__p;
    }
    long long __p = v17;
    std::string __dst = v11;
    unint64_t v50 = (unint64_t)v18;
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    *(unsigned char *)std::string __dst = v9;
    size_t v11 = v10 + 1;
  }
  std::string __dst = v11;
  char v21 = *(unsigned char *)(a1 + 60);
  if ((unint64_t)v11 < v50)
  {
    *size_t v11 = v21;
    unint64_t v22 = v11 + 1;
    goto LABEL_50;
  }
  unint64_t v23 = (unint64_t)__p;
  uint64_t v24 = v11 - (unsigned char *)__p;
  uint64_t v25 = v11 - (unsigned char *)__p + 1;
  if (v25 < 0) {
    sub_21677CB10();
  }
  unint64_t v26 = v50 - (void)__p;
  if (2 * (v50 - (unint64_t)__p) > v25) {
    uint64_t v25 = 2 * v26;
  }
  if (v26 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v27 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v27 = v25;
  }
  if (v27) {
    unint64_t v28 = operator new(v27);
  }
  else {
    unint64_t v28 = 0;
  }
  unint64_t v29 = (char *)v28 + v27;
  *((unsigned char *)v28 + v24) = v21;
  unint64_t v22 = (char *)v28 + v24 + 1;
  if (v11 == (char *)v23)
  {
    long long __p = (char *)v28 + v24;
    std::string __dst = (char *)v28 + v24 + 1;
    unint64_t v50 = (unint64_t)v29;
LABEL_49:
    operator delete(v11);
    goto LABEL_50;
  }
  size_t v30 = &v11[~v23];
  do
  {
    char v31 = *--v11;
    (v30--)[(void)v28] = v31;
  }
  while (v11 != (char *)v23);
  size_t v11 = (char *)__p;
  long long __p = v28;
  std::string __dst = (char *)v28 + v24 + 1;
  unint64_t v50 = (unint64_t)v29;
  if (v11) {
    goto LABEL_49;
  }
LABEL_50:
  std::string __dst = v22;
  if (*(_DWORD *)(a1 + 24) == 1)
  {
    if ((unint64_t)v22 >= v50)
    {
      unint64_t v33 = (unint64_t)__p;
      int64_t v34 = v22 - (unsigned char *)__p;
      uint64_t v35 = v22 - (unsigned char *)__p + 1;
      if (v35 < 0) {
        sub_21677CB10();
      }
      unint64_t v36 = v50 - (void)__p;
      if (2 * (v50 - (unint64_t)__p) > v35) {
        uint64_t v35 = 2 * v36;
      }
      if (v36 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v37 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v37 = v35;
      }
      if (v37) {
        uint64_t v38 = operator new(v37);
      }
      else {
        uint64_t v38 = 0;
      }
      uint64_t v39 = (char *)v38 + v37;
      *((unsigned char *)v38 + v34) = 0;
      uint64_t v32 = (char *)v38 + v34 + 1;
      if (v22 == (char *)v33)
      {
        long long __p = (char *)v38 + v34;
        std::string __dst = (char *)v38 + v34 + 1;
        unint64_t v50 = (unint64_t)v39;
      }
      else
      {
        char v40 = &v22[~v33];
        do
        {
          char v41 = *--v22;
          (v40--)[(void)v38] = v41;
        }
        while (v22 != (char *)v33);
        unint64_t v22 = (char *)__p;
        long long __p = v38;
        std::string __dst = (char *)v38 + v34 + 1;
        unint64_t v50 = (unint64_t)v39;
        if (!v22) {
          goto LABEL_69;
        }
      }
      operator delete(v22);
    }
    else
    {
      *unint64_t v22 = 0;
      uint64_t v32 = v22 + 1;
    }
LABEL_69:
    std::string __dst = v32;
  }
  uint64_t v43 = *(void *)(a1 + 64);
  char v42 = *(std::__shared_weak_count **)(a1 + 72);
  if (v42) {
    atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_21679D300((unint64_t *)&__p, *(double *)(v43 + 8));
  sub_21679CD94((unint64_t *)&__p, (*(void *)(v43 + 24) - *(void *)(v43 + 16)) >> 3, 2);
  uint64_t v44 = *(void *)(v43 + 16);
  if (*(void *)(v43 + 24) != v44)
  {
    unint64_t v45 = 0;
    do
    {
      sub_21679D300((unint64_t *)&__p, *(double *)(v44 + 8 * v45++));
      uint64_t v44 = *(void *)(v43 + 16);
    }
    while (v45 < (*(void *)(v43 + 24) - v44) >> 3);
  }
  if (v42) {
    sub_216784EC4(v42);
  }
LABEL_77:
  if (__p != __dst) {
    Alembic::Util::v12::SpookyHash::Update(a2, __p, (unsigned char *)__dst - (unsigned char *)__p);
  }
  if ((char)v47 < 0) {
    operator delete(v46[0]);
  }
  if (__p)
  {
    std::string __dst = __p;
    operator delete(__p);
  }
}

void sub_21679D7F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a15) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_21679D854(unsigned __int8 *result, unint64_t *a2)
{
  uint64_t v2 = *((void *)result + 1);
  size_t v3 = v2 - *(void *)result;
  if (v2 != *(void *)result)
  {
    unint64_t v5 = result;
    Alembic::Util::v12::SpookyHash::Init((uint64_t)v11, 0, 0);
    Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)v11, *(void **)v5, v3);
    Alembic::Util::v12::SpookyHash::Update((Alembic::Util::v12::SpookyHash *)v11, a2, 0x10uLL);
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    uint64_t result = Alembic::Util::v12::SpookyHash::Final((Alembic::Util::v12::SpookyHash *)v11, &v10, &v9, v6, v7);
    unint64_t v8 = v9;
    *a2 = v10;
    a2[1] = v8;
  }
  return result;
}

char *sub_21679D8E0(const void **a1)
{
  uint64_t v1 = *a1;
  if (!v1
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"NULL Impl Ptr", 13);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return v2 + 192;
}

void sub_21679D9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21679D9F4(Alembic::Ogawa::v12::OGroup **a1, uint64_t a2, int a3)
{
  int v4 = *(const void **)a2;
  unint64_t v5 = *(void *)(a2 + 8) - *(void *)a2;
  uint64_t v6 = *a1;
  if ((a3 - 14) > 0xFFFFFFFD || v5 > 0xF)
  {
    Alembic::Ogawa::v12::OGroup::addData(v6, v4, v5, &v8);
    if (v9) {
      sub_216784EC4(v9);
    }
  }
  else
  {
    Alembic::Ogawa::v12::OGroup::addEmptyData(v6);
  }
}

void sub_21679DA60(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  unint64_t v5 = (void *)a4;
  v115[33] = *MEMORY[0x263EF8340];
  uint64_t v8 = sub_21679EC50(a1, a4);
  int v99 = a5;
  if (v8)
  {
    uint64_t v9 = v8[6];
    *a5 = v9;
    unint64_t v10 = (std::__shared_weak_count *)v8[7];
    a5[1] = (uint64_t)v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v9)
    {
      size_t v11 = *(Alembic::Ogawa::v12::OGroup **)a2;
      unint64_t v12 = *(std::__shared_weak_count **)(a2 + 8);
      v110[0] = (uint64_t)v11;
      v110[1] = (uint64_t)v12;
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v109[0] = v9;
      v109[1] = (uint64_t)v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_21679E3F8(v110, v109);
      if (v10) {
        sub_216784EC4(v10);
      }
      if (v12)
      {
        sub_216784EC4(v12);
      }
      return;
    }
  }
  else
  {
    *a5 = 0;
    a5[1] = 0;
  }
  int v13 = *(_DWORD *)(a3 + 8);
  if (v13 == 13)
  {
    uint64_t v47 = *(unsigned __int8 *)(a3 + 12);
    unint64_t v48 = *(uint64_t **)(a3 + 16);
    uint64_t v49 = *(void *)(a3 + 24) - (void)v48;
    if (v49)
    {
      unint64_t v50 = v49 >> 3;
      if (v50 <= 1) {
        uint64_t v51 = 1;
      }
      else {
        uint64_t v51 = v50;
      }
      uint64_t v49 = 1;
      do
      {
        uint64_t v52 = *v48++;
        v49 *= v52;
        --v51;
      }
      while (v51);
    }
    uint64_t v53 = v49 * v47;
    __p[0] = 0;
    __p[1] = 0;
    unint64_t v108 = 0;
    if (!(v49 * v47))
    {
      unint64_t v70 = 0;
      unint64_t v79 = 0;
LABEL_148:
      int v113 = v5 + 2;
      unint64_t v114 = v79;
      unint64_t v111 = 16;
      int64_t v112 = v70 - v79;
      a5 = v99;
      Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)a2, &v111, (const void **)&v113, 2, (Alembic::Ogawa::v12::OData **)v105);
      long long v101 = *(_OWORD *)v105;
      double v82 = __p[0];
      if (!__p[0]) {
        goto LABEL_128;
      }
      goto LABEL_127;
    }
    uint64_t v96 = a2;
    uint64_t v54 = 0;
    while (1)
    {
      uint64_t v55 = *(void *)a3 + 24 * v54;
      if (std::wstring::find((const std::wstring *)v55, 0, 0) != -1)
      {
        sub_216778A5C((uint64_t)&v113);
        sub_216779180(v115, (uint64_t)"Illegal NULL character found in wstring data", 44);
        std::stringbuf::str();
        sub_216778E70(&v111, (long long *)v105);
        if (v106 < 0) {
          operator delete(v105[0]);
        }
        exception = __cxa_allocate_exception(0x20uLL);
        unint64_t v95 = sub_216779038(exception, (uint64_t)&v111);
        __cxa_throw(v95, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
      }
      if (*(char *)(v55 + 23) < 0)
      {
        uint64_t v56 = *(void *)(v55 + 8);
        if (v56)
        {
LABEL_83:
          uint64_t v57 = 0;
          do
          {
            uint64_t v58 = v55;
            if (*(char *)(v55 + 23) < 0) {
              uint64_t v58 = *(void *)v55;
            }
            int v59 = *(_DWORD *)(v58 + 4 * v57);
            unint64_t v60 = (char *)__p[1];
            if (__p[1] >= v108)
            {
              char v62 = (char *)__p[0];
              int64_t v63 = ((char *)__p[1] - (char *)__p[0]) >> 2;
              unint64_t v64 = v63 + 1;
              if ((unint64_t)(v63 + 1) >> 62) {
                sub_21677CB10();
              }
              uint64_t v65 = v108 - (char *)__p[0];
              if ((v108 - (char *)__p[0]) >> 1 > v64) {
                unint64_t v64 = v65 >> 1;
              }
              if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v66 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v66 = v64;
              }
              if (v66)
              {
                unint64_t v67 = (char *)sub_21677EA28((uint64_t)&v108, v66);
                char v62 = (char *)__p[0];
                unint64_t v60 = (char *)__p[1];
              }
              else
              {
                unint64_t v67 = 0;
              }
              unint64_t v68 = &v67[4 * v63];
              *(_DWORD *)unint64_t v68 = v59;
              unint64_t v61 = v68 + 4;
              while (v60 != v62)
              {
                int v69 = *((_DWORD *)v60 - 1);
                v60 -= 4;
                *((_DWORD *)v68 - 1) = v69;
                v68 -= 4;
              }
              __p[0] = v68;
              __p[1] = v61;
              unint64_t v108 = &v67[4 * v66];
              if (v62) {
                operator delete(v62);
              }
            }
            else
            {
              *(_DWORD *)__p[1] = v59;
              unint64_t v61 = v60 + 4;
            }
            __p[1] = v61;
            ++v57;
          }
          while (v57 != v56);
          goto LABEL_106;
        }
      }
      else
      {
        uint64_t v56 = *(unsigned __int8 *)(v55 + 23);
        if (*(unsigned char *)(v55 + 23)) {
          goto LABEL_83;
        }
      }
      unint64_t v61 = (char *)__p[1];
LABEL_106:
      if (v61 >= v108)
      {
        uint64_t v71 = (char *)__p[0];
        uint64_t v72 = (v61 - (char *)__p[0]) >> 2;
        unint64_t v73 = v72 + 1;
        if ((unint64_t)(v72 + 1) >> 62) {
          sub_21677CB10();
        }
        uint64_t v74 = v108 - (char *)__p[0];
        if ((v108 - (char *)__p[0]) >> 1 > v73) {
          unint64_t v73 = v74 >> 1;
        }
        if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v75 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v75 = v73;
        }
        if (v75)
        {
          unint64_t v76 = (char *)sub_21677EA28((uint64_t)&v108, v75);
          uint64_t v71 = (char *)__p[0];
          unint64_t v61 = (char *)__p[1];
        }
        else
        {
          unint64_t v76 = 0;
        }
        int64_t v77 = &v76[4 * v72];
        *(_DWORD *)int64_t v77 = 0;
        unint64_t v70 = v77 + 4;
        while (v61 != v71)
        {
          int v78 = *((_DWORD *)v61 - 1);
          v61 -= 4;
          *((_DWORD *)v77 - 1) = v78;
          v77 -= 4;
        }
        __p[0] = v77;
        __p[1] = v70;
        unint64_t v108 = &v76[4 * v75];
        if (v71) {
          operator delete(v71);
        }
      }
      else
      {
        *(_DWORD *)unint64_t v61 = 0;
        unint64_t v70 = v61 + 4;
      }
      __p[1] = v70;
      if (++v54 == v53)
      {
        unint64_t v79 = __p[0];
        a2 = v96;
        goto LABEL_148;
      }
    }
  }
  if (v13 == 12)
  {
    int64_t v14 = *(uint64_t **)(a3 + 16);
    uint64_t v15 = *(void *)(a3 + 24) - (void)v14;
    unint64_t v97 = v5;
    if (v15)
    {
      unint64_t v16 = v15 >> 3;
      if (v16 <= 1) {
        uint64_t v17 = 1;
      }
      else {
        uint64_t v17 = v16;
      }
      uint64_t v15 = 1;
      do
      {
        uint64_t v18 = *v14++;
        v15 *= v18;
        --v17;
      }
      while (v17);
    }
    uint64_t v19 = v15 * *(unsigned __int8 *)(a3 + 12);
    __p[0] = 0;
    __p[1] = 0;
    unint64_t v108 = 0;
    uint64_t v100 = v19;
    if (v19)
    {
      char v20 = 0;
      uint64_t v21 = 0;
      while (1)
      {
        uint64_t v22 = *(void *)a3 + 24 * v21;
        if (std::string::find((const std::string *)v22, 0, 0) != -1)
        {
          sub_216778A5C((uint64_t)&v113);
          sub_216779180(v115, (uint64_t)"Illegal NULL character found in string data ", 44);
          std::stringbuf::str();
          sub_216778E70(&v111, (long long *)v105);
          if (v106 < 0) {
            operator delete(v105[0]);
          }
          unint64_t v92 = __cxa_allocate_exception(0x20uLL);
          unint64_t v93 = sub_216779038(v92, (uint64_t)&v111);
          __cxa_throw(v93, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
        }
        if (*(char *)(v22 + 23) < 0)
        {
          uint64_t v23 = *(void *)(v22 + 8);
          if (v23)
          {
LABEL_29:
            uint64_t v24 = 0;
            do
            {
              uint64_t v25 = v22;
              if (*(char *)(v22 + 23) < 0) {
                uint64_t v25 = *(void *)v22;
              }
              char v26 = *(unsigned char *)(v25 + v24);
              if (v20 >= v108)
              {
                unint64_t v28 = (unint64_t)__p[0];
                int64_t v29 = v20 - (char *)__p[0];
                int64_t v30 = v20 - (char *)__p[0] + 1;
                if (v30 < 0) {
                  sub_21677CB10();
                }
                unint64_t v31 = v108 - (char *)__p[0];
                if (2 * (v108 - (char *)__p[0]) > (unint64_t)v30) {
                  int64_t v30 = 2 * v31;
                }
                if (v31 >= 0x3FFFFFFFFFFFFFFFLL) {
                  size_t v32 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  size_t v32 = v30;
                }
                if (v32) {
                  unint64_t v33 = (char *)operator new(v32);
                }
                else {
                  unint64_t v33 = 0;
                }
                int64_t v34 = &v33[v29];
                uint64_t v35 = &v33[v29];
                *uint64_t v35 = v26;
                size_t v27 = v35 + 1;
                if (v20 != (char *)v28)
                {
                  unint64_t v36 = &v20[~v28];
                  do
                  {
                    char v37 = *--v20;
                    (v36--)[(void)v33] = v37;
                  }
                  while (v20 != (char *)v28);
                  char v20 = (char *)__p[0];
                  int64_t v34 = v33;
                }
                __p[0] = v34;
                unint64_t v108 = &v33[v32];
                if (v20) {
                  operator delete(v20);
                }
              }
              else
              {
                char *v20 = v26;
                size_t v27 = v20 + 1;
              }
              __p[1] = v27;
              ++v24;
              char v20 = v27;
            }
            while (v24 != v23);
            goto LABEL_53;
          }
        }
        else
        {
          uint64_t v23 = *(unsigned __int8 *)(v22 + 23);
          if (*(unsigned char *)(v22 + 23)) {
            goto LABEL_29;
          }
        }
        size_t v27 = v20;
LABEL_53:
        if (v27 >= v108)
        {
          unint64_t v38 = (unint64_t)__p[0];
          int64_t v39 = v27 - (char *)__p[0];
          int64_t v40 = v27 - (char *)__p[0] + 1;
          if (v40 < 0) {
            sub_21677CB10();
          }
          unint64_t v41 = v108 - (char *)__p[0];
          if (2 * (v108 - (char *)__p[0]) > (unint64_t)v40) {
            int64_t v40 = 2 * v41;
          }
          if (v41 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v42 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v42 = v40;
          }
          if (v42) {
            uint64_t v43 = (char *)operator new(v42);
          }
          else {
            uint64_t v43 = 0;
          }
          uint64_t v44 = &v43[v39];
          v43[v39] = 0;
          char v20 = &v43[v39 + 1];
          if (v27 != (char *)v38)
          {
            unint64_t v45 = &v27[~v38];
            do
            {
              char v46 = *--v27;
              (v45--)[(void)v43] = v46;
            }
            while (v27 != (char *)v38);
            size_t v27 = (char *)__p[0];
            uint64_t v44 = v43;
          }
          __p[0] = v44;
          unint64_t v108 = &v43[v42];
          if (v27) {
            operator delete(v27);
          }
        }
        else
        {
          char *v27 = 0;
          char v20 = v27 + 1;
        }
        __p[1] = v20;
        if (++v21 == v100)
        {
          uint64_t v19 = (uint64_t)__p[0];
          goto LABEL_126;
        }
      }
    }
    char v20 = 0;
LABEL_126:
    unint64_t v5 = v97;
    int v113 = v97 + 2;
    unint64_t v114 = (unsigned char *)v19;
    unint64_t v111 = 16;
    int64_t v112 = (int64_t)&v20[-v19];
    Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)a2, &v111, (const void **)&v113, 2, (Alembic::Ogawa::v12::OData **)v105);
    long long v101 = *(_OWORD *)v105;
    double v82 = __p[0];
    a5 = v99;
    if (__p[0])
    {
LABEL_127:
      __p[1] = v82;
      operator delete(v82);
    }
  }
  else
  {
    size_t v80 = *(unsigned char **)a3;
    int v113 = v5 + 2;
    unint64_t v114 = v80;
    int64_t v81 = *v5;
    unint64_t v111 = 16;
    int64_t v112 = v81;
    Alembic::Ogawa::v12::OGroup::addData(*(Alembic::Ogawa::v12::OGroup **)a2, &v111, (const void **)&v113, 2, (Alembic::Ogawa::v12::OData **)__p);
    long long v101 = *(_OWORD *)__p;
  }
LABEL_128:
  unsigned int v83 = operator new(0x38uLL);
  if (*((void *)&v101 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v101 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  char v84 = *(uint64_t **)(a3 + 16);
  uint64_t v85 = *(void *)(a3 + 24) - (void)v84;
  if (v85)
  {
    unint64_t v86 = v85 >> 3;
    if (v86 <= 1) {
      uint64_t v87 = 1;
    }
    else {
      uint64_t v87 = v86;
    }
    uint64_t v85 = 1;
    do
    {
      uint64_t v88 = *v84++;
      v85 *= v88;
      --v87;
    }
    while (v87);
  }
  long long v89 = *((_OWORD *)v5 + 1);
  uint64_t v90 = v85 * *(unsigned __int8 *)(a3 + 12);
  _OWORD *v83 = *(_OWORD *)v5;
  v83[1] = v89;
  v83[2] = v101;
  if (*((void *)&v101 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v101 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)v83 + 6) = v90;
  sub_216788ECC(a5, (uint64_t)v83);
  if (*((void *)&v101 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v101 + 1));
  }
  unsigned int v91 = (std::__shared_weak_count *)a5[1];
  uint64_t v103 = *a5;
  unint64_t v104 = v91;
  if (v91) {
    atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216788DBC((uint64_t)a1, (uint64_t)&v103);
  if (v104) {
    sub_216784EC4(v104);
  }
  if (*((void *)&v101 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v101 + 1));
  }
}

void sub_21679E300(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, long long a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  if (__p) {
    operator delete(__p);
  }
  int64_t v34 = *(std::__shared_weak_count **)(a12 + 8);
  if (v34) {
    sub_216784EC4(v34);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679E3F8(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!*a2)
  {
    sub_216778A5C((uint64_t)v15);
    sub_216779180(v16, (uint64_t)"CopyWrittenData() passed a bogus ref", 36);
    std::stringbuf::str();
    sub_216778E70(v14, (long long *)__p);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v7 = sub_216779038(exception, (uint64_t)v14);
    __cxa_throw(v7, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v3 = *a1;
  if (!v3)
  {
    sub_216778A5C((uint64_t)v15);
    sub_216779180(v16, (uint64_t)"CopyWrittenData() passed in a bogus OGroupPtr", 45);
    std::stringbuf::str();
    sub_216778E70(v14, (long long *)__p);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v8 = __cxa_allocate_exception(0x20uLL);
    uint64_t v9 = sub_216779038(v8, (uint64_t)v14);
    __cxa_throw(v9, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  unint64_t v5 = *(Alembic::Ogawa::v12::OData **)(v2 + 32);
  int v4 = *(std::__shared_weak_count **)(v2 + 40);
  unint64_t v10 = v5;
  size_t v11 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Ogawa::v12::OGroup::addData(v3, &v10);
  if (v11) {
    sub_216784EC4(v11);
  }
}

void sub_21679E548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v7.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_21679E57C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  JUMPOUT(0x21679E574);
}

void sub_21679E590(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, uint64_t *a9)
{
  Alembic::Util::v12::TokenMap::get((Alembic::Util::v12::TokenMap *)(a2 + 32), 0x3Bu, 61, 1);
  if ((v54 & 0x80u) == 0) {
    unsigned int v15 = v54;
  }
  else {
    unsigned int v15 = v53;
  }
  if (*(char *)(a2 + 23) >= 0) {
    unsigned int v16 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unsigned int v16 = *(_DWORD *)(a2 + 8);
  }
  if (v15 <= v16) {
    unsigned int v17 = v16;
  }
  else {
    unsigned int v17 = v15;
  }
  if (v17 <= a6) {
    unsigned int v17 = a6;
  }
  if (v17 <= a5) {
    unsigned int v17 = a5;
  }
  unsigned int v18 = v17 - 256;
  int v19 = 2 * ((v17 & 0xFFFF0000) != 0);
  if (v18 >> 8 < 0xFF) {
    int v20 = 1;
  }
  else {
    int v20 = v19;
  }
  int v21 = sub_21679062C(*a9, (uint64_t)&v52);
  int v22 = (v21 << 20) | (4 * v20);
  if (*(_DWORD *)(a2 + 24))
  {
    unsigned int v23 = *(_DWORD *)(a2 + 24) & 3 | a3 & 0xFFFFFF0F | (16 * (*(_DWORD *)(a2 + 56) & 0xF)) | v22;
    if (a5) {
      v23 |= 0x100u;
    }
    int v24 = a8 | a7;
    int v25 = v23 | 0x800;
    BOOL v26 = a7 == 1 && a6 - 1 == a8;
    int v27 = !v26;
    if (!v26) {
      v23 |= 0x200u;
    }
    if (v24) {
      int v28 = v27;
    }
    else {
      int v28 = 0;
    }
    if (!v24) {
      unsigned int v23 = v25;
    }
    if (a7 > a8 || a7 > a6 || a8 > a6)
    {
      sub_216778A5C((uint64_t)v50);
      unint64_t v36 = sub_216779180(v51, (uint64_t)"Illegal Sampling!", 17);
      char v37 = sub_21679E924(v36);
      sub_216779180(v37, (uint64_t)"Num Samples: ", 13);
      unint64_t v38 = (void *)std::ostream::operator<<();
      int64_t v39 = sub_21679E924(v38);
      sub_216779180(v39, (uint64_t)"First Changed Index: ", 21);
      int64_t v40 = (void *)std::ostream::operator<<();
      unint64_t v41 = sub_21679E924(v40);
      sub_216779180(v41, (uint64_t)"Last Changed Index: ", 20);
      size_t v42 = (void *)std::ostream::operator<<();
      sub_21679E924(v42);
      std::stringbuf::str();
      sub_216778E70(v49, &__p);
      if (v48 < 0) {
        operator delete((void *)__p);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v44 = sub_216779038(exception, (uint64_t)v49);
      __cxa_throw(v44, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    int v29 = v23 | (*(unsigned __int8 *)(a2 + 60) << 12);
    if (a4) {
      int v30 = v29 | 0x400;
    }
    else {
      int v30 = v29;
    }
    sub_21679CD94((unint64_t *)a1, v30, 2);
    sub_21679CD94((unint64_t *)a1, a6, v20);
    if (v28)
    {
      sub_21679CD94((unint64_t *)a1, a7, v20);
      sub_21679CD94((unint64_t *)a1, a8, v20);
    }
    if (a5) {
      sub_21679CD94((unint64_t *)a1, a5, v20);
    }
  }
  else
  {
    sub_21679CD94((unint64_t *)a1, v22, 2);
  }
  sub_21679CD94((unint64_t *)a1, v16, v20);
  int v31 = *(char *)(a2 + 23);
  if (v31 >= 0) {
    size_t v32 = (char *)a2;
  }
  else {
    size_t v32 = *(char **)a2;
  }
  if (v31 >= 0) {
    uint64_t v33 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v33 = *(void *)(a2 + 8);
  }
  sub_216790EF4((char **)a1, *(char **)(a1 + 8), v32, &v32[v33], v33);
  if (v21 == 255)
  {
    sub_21679CD94((unint64_t *)a1, v15, v20);
    if (v15)
    {
      if ((v54 & 0x80u) == 0) {
        int64_t v34 = (char *)&v52;
      }
      else {
        int64_t v34 = v52;
      }
      if ((v54 & 0x80u) == 0) {
        uint64_t v35 = v54;
      }
      else {
        uint64_t v35 = v53;
      }
      sub_216790EF4((char **)a1, *(char **)(a1 + 8), v34, &v34[v35], v35);
    }
  }
  if ((char)v54 < 0) {
    operator delete(v52);
  }
}

void sub_21679E8D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v8.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  if (*(char *)(v6 - 89) < 0) {
    operator delete(*(void **)(v6 - 112));
  }
  _Unwind_Resume(a1);
}

void *sub_21679E924(void *a1)
{
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
  uint64_t v2 = std::locale::use_facet(&v4, MEMORY[0x263F8C108]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  std::ostream::flush();
  return a1;
}

void sub_21679E9C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void sub_21679E9DC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(char *)(a2 + 23) >= 0) {
    int v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    int v6 = *(_DWORD *)(a2 + 8);
  }
  sub_21679CD94((unint64_t *)a1, v6, 2);
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    std::exception v8 = (char *)a2;
  }
  else {
    std::exception v8 = *(char **)a2;
  }
  if (v7 >= 0) {
    uint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v9 = *(void *)(a2 + 8);
  }
  sub_216790EF4((char **)a1, *(char **)(a1 + 8), v8, &v8[v9], v9);
  Alembic::Util::v12::TokenMap::get((Alembic::Util::v12::TokenMap *)(a2 + 48), 0x3Bu, 61, 1);
  if ((v16 & 0x80u) == 0) {
    int v10 = v16;
  }
  else {
    int v10 = v15;
  }
  int v11 = sub_21679062C(*a3, (uint64_t)&__p);
  sub_21679CD94((unint64_t *)a1, v11, 0);
  if (v11 == 255)
  {
    sub_21679CD94((unint64_t *)a1, v10, 2);
    if (v10)
    {
      if ((v16 & 0x80u) == 0) {
        p_p = (char *)&__p;
      }
      else {
        p_p = (char *)__p;
      }
      if ((v16 & 0x80u) == 0) {
        uint64_t v13 = v16;
      }
      else {
        uint64_t v13 = v15;
      }
      sub_216790EF4((char **)a1, *(char **)(a1 + 8), p_p, &p_p[v13], v13);
    }
  }
  if ((char)v16 < 0) {
    operator delete(__p);
  }
}

void sub_21679EAFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679EB1C(unint64_t *a1, int a2, uint64_t a3)
{
  sub_21679CD94(a1, a2, 2);
  sub_21679D300(a1, *(double *)(a3 + 8));
  unint64_t v5 = *(void *)(a3 + 24) - *(void *)(a3 + 16);
  if (!v5)
  {
    sub_216778A5C((uint64_t)v13);
    sub_216779180(v14, (uint64_t)"No TimeSamples to write!", 24);
    std::stringbuf::str();
    sub_216778E70(v12, &__p);
    if (v11 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v9 = sub_216779038(exception, (uint64_t)v12);
    __cxa_throw(v9, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_21679CD94(a1, v5 >> 3, 2);
  uint64_t v6 = *(void *)(a3 + 16);
  if (*(void *)(a3 + 24) != v6)
  {
    unint64_t v7 = 0;
    do
    {
      sub_21679D300(a1, *(double *)(v6 + 8 * v7++));
      uint64_t v6 = *(void *)(a3 + 16);
    }
    while (v7 < (*(void *)(a3 + 24) - v6) >> 3);
  }
}

void sub_21679EC28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void *sub_21679EC50(void *a1, uint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v4 = *(void *)(a2 + 16);
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  unint64_t v6 = v5.u32[0];
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v7 = *(void *)(a2 + 16);
    if (v4 >= *(void *)&v2) {
      unint64_t v7 = v4 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v2 - 1) & v4;
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t v9 = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = v9[1];
      if (v4 == v10)
      {
        if (sub_216789FF0((uint64_t)(v9 + 2), a2)) {
          return v9;
        }
      }
      else
      {
        if (v6 > 1)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t v9 = (void *)*v9;
    }
    while (v9);
  }
  return v9;
}

void Alembic::Abc::v12::GetArchiveInfo(Alembic::Abc::v12::IArchive *a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, double *a7)
{
  uint64_t v15 = *((void *)a1 + 4);
  int64_t v14 = (std::__shared_weak_count *)*((void *)a1 + 5);
  if (!v14)
  {
    if (!v15) {
      return;
    }
    unsigned __int8 v16 = 0;
    goto LABEL_7;
  }
  atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  sub_216784EC4(v14);
  if (!v15) {
    return;
  }
  uint64_t v15 = *((void *)a1 + 4);
  unsigned __int8 v16 = (std::__shared_weak_count *)*((void *)a1 + 5);
  if (!v16)
  {
LABEL_7:
    char v17 = 1;
    goto LABEL_8;
  }
  char v17 = 0;
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_8:
  unsigned int v18 = (const void ***)(*(uint64_t (**)(uint64_t))(*(void *)v15 + 24))(v15);
  sub_2167898D0(v24, v18);
  if ((v17 & 1) == 0) {
    sub_216784EC4(v16);
  }
  sub_216779094(__p, "_ai_Application");
  sub_21679F2AC((uint64_t)v24, (const void **)__p, v22);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(_OWORD *)a2 = *(_OWORD *)v22;
  *(void *)(a2 + 16) = v23;
  HIBYTE(v23) = 0;
  LOBYTE(v22[0]) = 0;
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_216779094(__p, "_ai_AlembicVersion");
  sub_21679F2AC((uint64_t)v24, (const void **)__p, v22);
  if (*(char *)(a3 + 23) < 0) {
    operator delete(*(void **)a3);
  }
  *(_OWORD *)a3 = *(_OWORD *)v22;
  *(void *)(a3 + 16) = v23;
  HIBYTE(v23) = 0;
  LOBYTE(v22[0]) = 0;
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  *a4 = Alembic::Abc::v12::IArchive::getArchiveVersion(a1);
  sub_216779094(__p, "_ai_DateWritten");
  sub_21679F2AC((uint64_t)v24, (const void **)__p, v22);
  if (*(char *)(a5 + 23) < 0) {
    operator delete(*(void **)a5);
  }
  *(_OWORD *)a5 = *(_OWORD *)v22;
  *(void *)(a5 + 16) = v23;
  HIBYTE(v23) = 0;
  LOBYTE(v22[0]) = 0;
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_216779094(__p, "_ai_Description");
  sub_21679F2AC((uint64_t)v24, (const void **)__p, v22);
  if (*(char *)(a6 + 23) < 0) {
    operator delete(*(void **)a6);
  }
  *(_OWORD *)a6 = *(_OWORD *)v22;
  *(void *)(a6 + 16) = v23;
  HIBYTE(v23) = 0;
  LOBYTE(v22[0]) = 0;
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_216779094(__p, "_ai_DCC_FPS");
  sub_21679F2AC((uint64_t)v24, (const void **)__p, v22);
  if (SHIBYTE(v23) < 0)
  {
    int v19 = v22[0];
    *a7 = atof(v22[0]);
    operator delete(v19);
  }
  else
  {
    *a7 = atof((const char *)v22);
  }
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  sub_2167877AC((uint64_t)v24, (void *)v24[1]);
}

void sub_21679EFFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *a20)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_2167877AC((uint64_t)&a19, a20);
  _Unwind_Resume(a1);
}

void sub_21679F050()
{
  if ((v1 & 1) == 0) {
    sub_216784EC4(v0);
  }
  JUMPOUT(0x21679F048);
}

void Alembic::Abc::v12::GetArchiveInfo(Alembic::Abc::v12::IArchive *a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  Alembic::Abc::v12::GetArchiveInfo(a1, a2, a3, a4, a5, a6, &v6);
}

uint64_t Alembic::Abc::v12::GetArchiveStartAndEndTime(Alembic::Abc::v12 *this, Alembic::Abc::v12::IArchive *a2, double *a3, double *a4)
{
  uint64_t result = Alembic::Abc::v12::IArchive::getNumTimeSamplings(this);
  if (!result) {
    goto LABEL_34;
  }
  unsigned int v8 = 0;
  double v9 = 1.79769313e308;
  double v10 = -1.79769313e308;
  double v11 = 1.79769313e308;
  double v12 = -1.79769313e308;
  double v13 = 1.79769313e308;
  double v14 = -1.79769313e308;
  do
  {
    uint64_t MaxNumSamplesForTimeSamplingIndex = Alembic::Abc::v12::IArchive::getMaxNumSamplesForTimeSamplingIndex(this);
    if (MaxNumSamplesForTimeSamplingIndex != 0x7FFFFFFFFFFFFFFFLL)
    {
      uint64_t v16 = MaxNumSamplesForTimeSamplingIndex;
      Alembic::Abc::v12::IArchive::getTimeSampling(this, &v24);
      if (v24)
      {
        if (v16 >= 2 && v8)
        {
          double SampleTime = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v24, 0);
          double v18 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v24, v16 - 1);
          if (v11 >= SampleTime) {
            double v11 = SampleTime;
          }
          if (v18 >= v12) {
            double v12 = v18;
          }
        }
        else if (v16 == 1 && v8)
        {
          double v19 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v24, 0);
          double v20 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v24, 0);
          if (v13 >= v19) {
            double v13 = v19;
          }
          if (v20 >= v14) {
            double v14 = v20;
          }
        }
        else
        {
          BOOL v21 = v16 < 1;
          uint64_t v22 = v16 - 1;
          if (!v21 && !v8)
          {
            double v9 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v24, 0);
            double v10 = Alembic::AbcCoreAbstract::v12::TimeSampling::getSampleTime((double **)v24, v22);
          }
        }
      }
      if (v25) {
        sub_216784EC4(v25);
      }
    }
    ++v8;
    uint64_t result = Alembic::Abc::v12::IArchive::getNumTimeSamplings(this);
  }
  while (v8 < result);
  if (v11 == 1.79769313e308 || v12 == -1.79769313e308)
  {
    if (v13 == 1.79769313e308 || (double v11 = v13, v12 = v14, v14 == -1.79769313e308))
    {
      if (v9 == 1.79769313e308 || (double v11 = v9, v12 = v10, v10 == -1.79769313e308))
      {
LABEL_34:
        double v12 = -1.79769313e308;
        double v11 = 1.79769313e308;
      }
    }
  }
  *(double *)a2 = v11;
  *a3 = v12;
  return result;
}

void sub_21679F284(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_21679F2AC@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  uint64_t result = (void *)sub_21678C2D8(a1, a2);
  if ((void *)(a1 + 8) == result)
  {
    return sub_216779094(a3, "");
  }
  else if (*((char *)result + 79) < 0)
  {
    unint64_t v7 = (void *)result[7];
    unint64_t v8 = result[8];
    return sub_216778F24(a3, v7, v8);
  }
  else
  {
    long long v6 = *(_OWORD *)(result + 7);
    a3[2] = result[9];
    *(_OWORD *)a3 = v6;
  }
  return result;
}

void Alembic::Abc::v12::ErrorHandler::operator()(_DWORD *a1, uint64_t a2, const void **a3)
{
  if (*((char *)a3 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v6 = (size_t)a3[1];
  }
  unint64_t v7 = &v12;
  sub_2167940B4((uint64_t)&v12, v6 + 19);
  if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    unint64_t v7 = (std::string *)v12.__r_.__value_.__r.__words[0];
  }
  if (v6)
  {
    if (*((char *)a3 + 23) >= 0) {
      unint64_t v8 = a3;
    }
    else {
      unint64_t v8 = *a3;
    }
    memmove(v7, v8, v6);
  }
  strcpy((char *)v7 + v6, "\nERROR: EXCEPTION:\n");
  double v9 = (const std::string::value_type *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  double v10 = std::string::append(&v12, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  std::string::size_type v14 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  Alembic::Abc::v12::ErrorHandler::handleIt(a1, (uint64_t)__p);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
}

{
  size_t v6;
  std::string *v7;
  const void *v8;
  int v9;
  const std::string::value_type *v10;
  std::string::size_type v11;
  std::string *v12;
  long long v13;
  std::string v14;
  void *__p[2];
  std::string::size_type v16;

  if (*((char *)a3 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v6 = (size_t)a3[1];
  }
  unint64_t v7 = &v14;
  sub_2167940B4((uint64_t)&v14, v6 + 8);
  if ((v14.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    unint64_t v7 = (std::string *)v14.__r_.__value_.__r.__words[0];
  }
  if (v6)
  {
    if (*((char *)a3 + 23) >= 0) {
      unint64_t v8 = a3;
    }
    else {
      unint64_t v8 = *a3;
    }
    memmove(v7, v8, v6);
  }
  strcpy((char *)v7 + v6, "\nERROR:\n");
  double v9 = *(char *)(a2 + 23);
  if (v9 >= 0) {
    double v10 = (const std::string::value_type *)a2;
  }
  else {
    double v10 = *(const std::string::value_type **)a2;
  }
  if (v9 >= 0) {
    long long v11 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    long long v11 = *(void *)(a2 + 8);
  }
  std::string v12 = std::string::append(&v14, v10, v11);
  double v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  uint64_t v16 = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  Alembic::Abc::v12::ErrorHandler::handleIt(a1, (uint64_t)__p);
  if (SHIBYTE(v16) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
}

{
  size_t v5;
  void **v6;
  const void *v7;
  void *__p[2];
  char v9;

  if (*((char *)a3 + 23) >= 0) {
    uint8x8_t v5 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    uint8x8_t v5 = (size_t)a3[1];
  }
  size_t v6 = __p;
  sub_2167940B4((uint64_t)__p, v5 + 26);
  if (v9 < 0) {
    size_t v6 = (void **)__p[0];
  }
  if (v5)
  {
    if (*((char *)a3 + 23) >= 0) {
      unint64_t v7 = a3;
    }
    else {
      unint64_t v7 = *a3;
    }
    memmove(v6, v7, v5);
  }
  strcpy((char *)v6 + v5, "\nERROR: UNKNOWN EXCEPTION\n");
  Alembic::Abc::v12::ErrorHandler::handleIt(a1, (uint64_t)__p);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_21679F47C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

std::string *Alembic::Abc::v12::ErrorHandler::handleIt(_DWORD *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*a1)
  {
    if (*a1 != 1)
    {
      sub_216778A5C((uint64_t)&v20);
      int v12 = *(char *)(v2 + 23);
      if (v12 >= 0) {
        uint64_t v13 = v2;
      }
      else {
        uint64_t v13 = *(void *)v2;
      }
      if (v12 >= 0) {
        uint64_t v14 = *(unsigned __int8 *)(v2 + 23);
      }
      else {
        uint64_t v14 = *(void *)(v2 + 8);
      }
      sub_216779180(v21, v13, v14);
      std::stringbuf::str();
      sub_216778E70(v19, &__p);
      if (v18 < 0) {
        operator delete((void *)__p);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v16 = sub_216779038(exception, (uint64_t)v19);
      __cxa_throw(v16, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    if (*(char *)(a2 + 23) >= 0)
    {
      uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
    }
    else
    {
      a2 = *(void *)a2;
      uint64_t v4 = *(void *)(v2 + 8);
    }
    uint8x8_t v5 = sub_216779180(MEMORY[0x263F8C0F8], a2, v4);
    std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(void *)(*v5 - 24)));
    size_t v6 = std::locale::use_facet(&v20, MEMORY[0x263F8C108]);
    ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
  }
  unint64_t v7 = (std::string *)(a1 + 2);
  int v8 = *(char *)(v2 + 23);
  if (v8 >= 0) {
    double v9 = (const std::string::value_type *)v2;
  }
  else {
    double v9 = *(const std::string::value_type **)v2;
  }
  if (v8 >= 0) {
    std::string::size_type v10 = *(unsigned __int8 *)(v2 + 23);
  }
  else {
    std::string::size_type v10 = *(void *)(v2 + 8);
  }
  std::string::append(v7, v9, v10);

  return std::string::append(v7, "\n");
}

void sub_21679F660(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, std::locale a16)
{
}

void sub_21679F7B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679F8AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::Abc::v12::IArchive::~IArchive(Alembic::Abc::v12::IArchive *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

char *Alembic::Abc::v12::IArchive::getName@<X0>(Alembic::Abc::v12::IArchive *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (char *)(*(uint64_t (**)(void))(**((void **)this + 4) + 16))(*((void *)this + 4));
  if (result[23] < 0) {
    return (char *)sub_216778F24((unsigned char *)a2, *(void **)result, *((void *)result + 1));
  }
  long long v4 = *(_OWORD *)result;
  *(void *)(a2 + 16) = *((void *)result + 2);
  *(_OWORD *)a2 = v4;
  return result;
}

void sub_21679F990(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  long long v11 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v11);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  sub_216779094(v9, "");
  JUMPOUT(0x21679F980);
}

void sub_21679F9D4(_Unwind_Exception *a1)
{
}

void sub_21679F9F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(_DWORD **)a1;
  sub_216779094(__p, *(char **)(a1 + 8));
  Alembic::Abc::v12::ErrorHandler::operator()(v3, a2, (const void **)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_21679FA48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_21679FA64(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(_DWORD **)a1;
  sub_216779094(__p, *(char **)(a1 + 8));
  Alembic::Abc::v12::ErrorHandler::operator()(v3, a2, (const void **)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_21679FAB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::Abc::v12::IArchive::getTop(Alembic::Abc::v12::IArchive *this@<X0>, uint64_t a2@<X8>)
{
  size_t v6 = this;
  unint64_t v7 = "IArchive::getTop()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 4) + 32))(&v4);
  v3[0] = 0;
  int v3[2] = 0;
  sub_2167A0084(a2, &v4, v3);
  if (v5) {
    sub_216784EC4(v5);
  }
}

void sub_21679FB60(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, char a13)
{
  if (a12) {
    sub_216784EC4(a12);
  }
  uint64_t v16 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a13, (uint64_t)v16);
  }
  else {
    sub_21679F9F4((uint64_t)&a13, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)(v13 + 8) = 2;
  sub_216779094((void *)(v13 + 16), "");
  *(void *)uint64_t v13 = &unk_26C749578;
  *(_OWORD *)(v13 + 40) = 0u;
  *(_OWORD *)(v13 + 56) = 0u;
  *(_OWORD *)(v13 + 72) = 0u;
  *(void *)(v13 + 88) = 0;
  JUMPOUT(0x21679FB4CLL);
}

void sub_21679FBFC(_Unwind_Exception *a1)
{
}

void *Alembic::Abc::v12::IArchive::getReadArraySampleCachePtr@<X0>(Alembic::Abc::v12::IArchive *this@<X0>, void *a2@<X8>)
{
  return (*(void *(**)(void *__return_ptr))(**((void **)this + 4) + 40))(a2);
}

void sub_21679FC7C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  long long v11 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v11);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  *double v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x21679FC6CLL);
}

void sub_21679FCB4(_Unwind_Exception *a1)
{
}

void *Alembic::Abc::v12::IArchive::getTimeSampling@<X0>(Alembic::Abc::v12::IArchive *this@<X0>, void *a2@<X8>)
{
  return (*(void *(**)(void *__return_ptr))(**((void **)this + 4) + 56))(a2);
}

void sub_21679FD34(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  long long v11 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v11);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  *double v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x21679FD24);
}

void sub_21679FD6C(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IArchive::getNumTimeSamplings(Alembic::Abc::v12::IArchive *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 72))(*((void *)this + 4));
}

void sub_21679FDE4(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::string::size_type v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x21679FDD4);
}

void sub_21679FE1C(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IArchive::getMaxNumSamplesForTimeSamplingIndex(Alembic::Abc::v12::IArchive *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 64))(*((void *)this + 4));
}

void sub_21679FE94(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::string::size_type v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x21679FE84);
}

void sub_21679FECC(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IArchive::getArchiveVersion(Alembic::Abc::v12::IArchive *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 80))(*((void *)this + 4));
}

void sub_21679FF44(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::string::size_type v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x21679FF34);
}

void sub_21679FF7C(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IArchive::setReadArraySampleCachePtr(uint64_t a1, uint64_t *a2)
{
  uint64_t v6 = a1;
  unint64_t v7 = "IArchive::setReadArraySampleCachePtr";
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  char v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
  if (v5) {
    sub_216784EC4(v5);
  }
}

void sub_2167A001C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  uint64_t v13 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v13);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A000CLL);
}

void sub_2167A0064(_Unwind_Exception *a1)
{
}

uint64_t sub_2167A0084(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  *(_DWORD *)(a1 + 8) = 2;
  sub_216779094((void *)(a1 + 16), "");
  *(void *)a1 = &unk_26C749578;
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 40) = v7;
  *(void *)(a1 + 48) = v6;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  int v8 = (std::__shared_weak_count *)a2[1];
  uint64_t v13 = *a2;
  uint64_t v14 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v12[0] = 0;
  void v12[2] = 0;
  v11[0] = 0;
  v11[2] = 0;
  v10[0] = 0;
  uint64_t v10[2] = 0;
  *(_DWORD *)(a1 + 8) = sub_2167A01D8((uint64_t)&v13, a3, v12, v11, v10);
  if (v14) {
    sub_216784EC4(v14);
  }
  Alembic::Abc::v12::IObject::initInstance((std::string *)a1);
  return a1;
}

void sub_2167A0180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (*(char *)(v17 + 95) < 0) {
    operator delete(*(void **)(v17 + 72));
  }
  double v19 = *(std::__shared_weak_count **)(v17 + 64);
  if (v19) {
    sub_216784EC4(v19);
  }
  std::locale v20 = *(std::__shared_weak_count **)(v17 + 48);
  if (v20) {
    sub_216784EC4(v20);
  }
  if (*(char *)(v17 + 39) < 0) {
    operator delete(*v16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167A01D8(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  double v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[1] = 0;
  int v12 = (const void **)v13;
  unsigned int v14 = 2;
  sub_2167898D0(v15, &v12);
  v15[3] = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 1;
  sub_2167877AC((uint64_t)&v12, v13[0]);
  if (v9) {
    sub_216784EC4(v9);
  }
  sub_2167A030C(a2, (uint64_t)&v14);
  sub_2167A030C(a3, (uint64_t)&v14);
  sub_2167A030C(a4, (uint64_t)&v14);
  sub_2167A030C(a5, (uint64_t)&v14);
  uint64_t v10 = v14;
  if (v16) {
    sub_216784EC4(v16);
  }
  sub_2167877AC((uint64_t)v15, (void *)v15[1]);
  return v10;
}

void sub_2167A02D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_2167877AC((uint64_t)&a10, a11);
  if (v11) {
    sub_216784EC4(v11);
  }
  _Unwind_Resume(a1);
}

void sub_2167A030C(_DWORD *a1, uint64_t a2)
{
  switch(*a1)
  {
    case 1:
      *(_DWORD *)a2 = a1[2];
      break;
    case 2:
      *(_DWORD *)(a2 + 48) = a1[2];
      break;
    case 3:
      uint64_t v2 = *((void *)a1 + 1);
      if (a2 + 8 != v2) {
        sub_216799C1C((uint64_t **)(a2 + 8), *(long long **)v2, (long long *)(v2 + 8));
      }
      break;
    case 4:
      uint64_t v3 = (uint64_t *)*((void *)a1 + 1);
      uint64_t v5 = *v3;
      uint64_t v4 = v3[1];
      if (v4) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v6 = *(std::__shared_weak_count **)(a2 + 40);
      *(void *)(a2 + 32) = v5;
      *(void *)(a2 + 40) = v4;
      if (v6) {
        sub_216784EC4(v6);
      }
      break;
    case 5:
      *(_DWORD *)(a2 + 52) = a1[2];
      break;
    case 6:
      *(_DWORD *)(a2 + 56) = a1[2];
      break;
    default:
      return;
  }
}

uint64_t sub_2167A03C4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167877AC(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

uint64_t Alembic::Abc::v12::IArrayProperty::IArrayProperty(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v10 = *(std::__shared_weak_count **)(a2 + 40);
  v12[0] = *(void *)(a2 + 32);
  v12[1] = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Abc::v12::IArrayProperty::init(a1, v12, a3, *(_DWORD *)a2, a4, a5);
  if (v10) {
    sub_216784EC4(v10);
  }
  return a1;
}

void sub_2167A04A4(_Unwind_Exception *a1)
{
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IArrayProperty::init(uint64_t a1, void *a2, uint64_t a3, int a4, _DWORD *a5, _DWORD *a6)
{
  *((void *)&v22 + 1) = 0;
  v23[0] = 0;
  *(void *)&long long v22 = (char *)&v22 + 8;
  int v24 = a4;
  sub_2167898D0(v25, (const void ***)&v22);
  v25[3] = 0;
  BOOL v26 = 0;
  int v27 = 0;
  uint64_t v28 = 1;
  sub_2167877AC((uint64_t)&v22, *((void **)&v22 + 1));
  sub_2167A030C(a5, (uint64_t)&v24);
  sub_2167A030C(a6, (uint64_t)&v24);
  *(_DWORD *)a1 = v24;
  v23[34] = a1;
  v23[35] = "IArrayProperty::init()";
  if (!(*(uint64_t (**)(void, uint64_t))(*(void *)*a2 + 80))(*a2, a3))
  {
    sub_216778A5C((uint64_t)&v22);
    uint64_t v13 = sub_216779180(v23, (uint64_t)"Nonexistent array property: ", 28);
    int v14 = *(char *)(a3 + 23);
    if (v14 >= 0) {
      uint64_t v15 = a3;
    }
    else {
      uint64_t v15 = *(void *)a3;
    }
    if (v14 >= 0) {
      uint64_t v16 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v16 = *(void *)(a3 + 8);
    }
    sub_216779180(v13, v15, v16);
    std::stringbuf::str();
    sub_216778E70(v21, &__p);
    if (v20 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v18 = sub_216779038(exception, (uint64_t)v21);
    __cxa_throw(v18, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 96))(&v22);
  long long v11 = v22;
  long long v22 = 0uLL;
  int v12 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v11;
  if (v12)
  {
    sub_216784EC4(v12);
    if (*((void *)&v22 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v22 + 1));
    }
  }
  if (v26) {
    sub_216784EC4(v26);
  }
  sub_2167877AC((uint64_t)v25, (void *)v25[1]);
}

void sub_2167A06BC(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v11 = (uint64_t)v10;
    sub_2167A13A4(v6);
    sub_21679FA64(v7 - 144, v11);
  }
  else
  {
    sub_2167A13A4(v6);
    sub_21679F9F4(v7 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A05F0);
}

void sub_2167A0744(_Unwind_Exception *a1)
{
  sub_2167A03C4(v1 - 128);
  _Unwind_Resume(a1);
}

uint64_t sub_2167A0790(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void Alembic::Abc::v12::IArrayProperty::~IArrayProperty(Alembic::Abc::v12::IArrayProperty *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t Alembic::Abc::v12::IArrayProperty::getNumSamples(Alembic::Abc::v12::IArrayProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 64))(*((void *)this + 4));
}

void sub_2167A0870(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A0860);
}

void sub_2167A08A8(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IArrayProperty::isConstant(Alembic::Abc::v12::IArrayProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 72))(*((void *)this + 4));
}

void sub_2167A0920(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A0910);
}

void sub_2167A0958(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IArrayProperty::isScalarLike(Alembic::Abc::v12::IArrayProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 128))(*((void *)this + 4));
}

void sub_2167A09D0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A09C0);
}

void sub_2167A0A08(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IArrayProperty::getTimeSampling@<X0>(Alembic::Abc::v12::IArrayProperty *this@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 4) + 16))(*((void *)this + 4));
  uint64_t v4 = *(void *)(result + 72);
  *a2 = *(void *)(result + 64);
  a2[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_2167A0A9C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v11);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  *double v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x2167A0A8CLL);
}

void sub_2167A0AD4(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IArrayProperty::get(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = a1;
  uint64_t v14 = "IArrayProperty::get()";
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  int v8 = *(std::__shared_weak_count **)(v7 + 72);
  uint64_t v11 = *(double ***)(v7 + 64);
  std::exception v12 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
  uint64_t Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v11, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 80))(v6, Index, a2);
  if (v12) {
    sub_216784EC4(v12);
  }
}

void sub_2167A0BF0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::exception v12 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v12);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A0BDCLL);
}

void sub_2167A0C44(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IArrayProperty::getAs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = a1;
  uint64_t v16 = "IArrayProperty::getAs(PlainOldDataType)";
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
  uint64_t v10 = *(std::__shared_weak_count **)(v9 + 72);
  uint64_t v13 = *(double ***)(v9 + 64);
  uint64_t v14 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
  uint64_t Index = Alembic::Abc::v12::ISampleSelector::getIndex(a4, &v13, v11);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 136))(v8, Index, a2, a3);
  if (v14) {
    sub_216784EC4(v14);
  }
}

void sub_2167A0D70(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::exception v12 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v12);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A0D58);
}

void sub_2167A0DC4(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IArrayProperty::getAs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = a1;
  uint64_t v15 = "IArrayProperty::getAs()";
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  uint64_t v8 = *(std::__shared_weak_count **)(v7 + 72);
  std::exception v12 = *(double ***)(v7 + 64);
  uint64_t v13 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
  uint64_t Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v12, v9);
  uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32));
  (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)v6 + 136))(v6, Index, a2, *(unsigned int *)(v11 + 56));
  if (v13) {
    sub_216784EC4(v13);
  }
}

void sub_2167A0F10(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::exception v12 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v12);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A0EFCLL);
}

void sub_2167A0F64(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IArrayProperty::getKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v15 = a1;
  uint64_t v16 = "IArrayProperty::getKey()";
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  uint64_t v8 = *(std::__shared_weak_count **)(v7 + 72);
  uint64_t v13 = *(double ***)(v7 + 64);
  uint64_t v14 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
  uint64_t Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v13, v9);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 112))(v6, Index, a2);
  if (v14) {
    sub_216784EC4(v14);
  }
  return v11;
}

void sub_2167A1088(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::exception v12 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v12);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A1070);
}

void sub_2167A10E0(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IArrayProperty::getDimensions(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = a1;
  uint64_t v14 = "IArrayProperty::getDimensions()";
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
  uint64_t v8 = *(std::__shared_weak_count **)(v7 + 72);
  uint64_t v11 = *(double ***)(v7 + 64);
  std::exception v12 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
  uint64_t Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v11, v9);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 120))(v6, Index, a2);
  if (v12) {
    sub_216784EC4(v12);
  }
}

void sub_2167A11FC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::exception v12 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v12);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A11E8);
}

void sub_2167A1250(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IArrayProperty::getParent(Alembic::Abc::v12::IArrayProperty *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v9 = this;
  uint64_t v10 = "IArrayProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 4) + 32))(&v7);
  int v4 = *(_DWORD *)this;
  v6[0] = 1;
  int v6[2] = v4;
  v5[0] = 0;
  int v5[2] = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(a2, &v7, v6, v5);
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167A1314(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  uint64_t v18 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a15, (uint64_t)v18);
  }
  else {
    sub_21679F9F4((uint64_t)&a15, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v15 = 2;
  sub_216779094((void *)(v15 + 8), "");
  *(void *)(v15 + 32) = 0;
  *(void *)(v15 + 40) = 0;
  JUMPOUT(0x2167A1300);
}

void sub_2167A1384(_Unwind_Exception *a1)
{
}

void sub_2167A13A4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  if (v2) {
    sub_216784EC4(v2);
  }

  JUMPOUT(0x21D4477E0);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v8 = *(std::__shared_weak_count **)(a2 + 40);
  v10[0] = *(void *)(a2 + 32);
  v10[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Abc::v12::ICompoundProperty::init(a1, v10, a3, *(_DWORD *)a2, a4);
  if (v8) {
    sub_216784EC4(v8);
  }
  return a1;
}

void sub_2167A148C(_Unwind_Exception *a1)
{
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::ICompoundProperty::init(uint64_t a1, void *a2, uint64_t a3, int a4, _DWORD *a5)
{
  *((void *)&v22 + 1) = 0;
  v23[0] = 0;
  *(void *)&long long v22 = (char *)&v22 + 8;
  int v24 = a4;
  sub_2167898D0(v25, (const void ***)&v22);
  v25[3] = 0;
  BOOL v26 = 0;
  int v27 = 0;
  uint64_t v28 = 1;
  sub_2167877AC((uint64_t)&v22, *((void **)&v22 + 1));
  sub_2167A030C(a5, (uint64_t)&v24);
  *(_DWORD *)a1 = v24;
  v23[34] = a1;
  v23[35] = "ICompoundProperty::init()";
  if (!*a2)
  {
    sub_216778A5C((uint64_t)&v22);
    sub_216779180(v23, (uint64_t)"invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(v21, (long long *)__p);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v12 = sub_216779038(exception, (uint64_t)v21);
    __cxa_throw(v12, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  if (!(*(uint64_t (**)(void, uint64_t))(*(void *)*a2 + 80))(*a2, a3))
  {
    sub_216778A5C((uint64_t)&v22);
    uint64_t v13 = sub_216779180(v23, (uint64_t)"Nonexistent compound property: ", 31);
    int v14 = *(char *)(a3 + 23);
    if (v14 >= 0) {
      uint64_t v15 = a3;
    }
    else {
      uint64_t v15 = *(void *)a3;
    }
    if (v14 >= 0) {
      uint64_t v16 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v16 = *(void *)(a3 + 8);
    }
    sub_216779180(v13, v15, v16);
    std::stringbuf::str();
    sub_216778E70(v21, (long long *)__p);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
    int v17 = __cxa_allocate_exception(0x20uLL);
    uint64_t v18 = sub_216779038(v17, (uint64_t)v21);
    __cxa_throw(v18, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 104))(&v22);
  long long v9 = v22;
  long long v22 = 0uLL;
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v9;
  if (v10)
  {
    sub_216784EC4(v10);
    if (*((void *)&v22 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v22 + 1));
    }
  }
  if (v26) {
    sub_216784EC4(v26);
  }
  sub_2167877AC((uint64_t)v25, (void *)v25[1]);
}

void sub_2167A170C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v11 = (uint64_t)v10;
    sub_2167A13A4(v6);
    sub_21679FA64(v7 - 128, v11);
  }
  else
  {
    sub_2167A13A4(v6);
    sub_21679F9F4(v7 - 128, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A15C8);
}

void sub_2167A17A4(_Unwind_Exception *a1)
{
  sub_2167A03C4(v1 - 112);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t a1, uint64_t *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v6 = *a2;
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v7 = (std::__shared_weak_count *)a2[1];
    uint64_t v12 = *a2;
    uint64_t v13 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = *a2;
    uint64_t v13 = 0;
  }
  v11[0] = 0;
  v11[2] = 0;
  v10[0] = 0;
  void v10[2] = 0;
  int v8 = sub_2167A18F8((uint64_t)&v12, a3, a4, v11, v10);
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 40) = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)a1 = v8;
  if (v13) {
    sub_216784EC4(v13);
  }
  if (v5) {
    sub_216784EC4(v5);
  }
  return a1;
}

void sub_2167A18D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  if (v14) {
    sub_216784EC4(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167A18F8(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  long long v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v12 = (const void **)v13;
  unsigned int v14 = 2;
  sub_2167898D0(v15, &v12);
  v15[3] = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 1;
  sub_2167877AC((uint64_t)&v12, v13[0]);
  if (v9) {
    sub_216784EC4(v9);
  }
  sub_2167A030C(a2, (uint64_t)&v14);
  sub_2167A030C(a3, (uint64_t)&v14);
  sub_2167A030C(a4, (uint64_t)&v14);
  sub_2167A030C(a5, (uint64_t)&v14);
  uint64_t v10 = v14;
  if (v16) {
    sub_216784EC4(v16);
  }
  sub_2167877AC((uint64_t)v15, (void *)v15[1]);
  return v10;
}

void sub_2167A19F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_2167877AC((uint64_t)&a10, a11);
  if (v11) {
    sub_216784EC4(v11);
  }
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v7 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    int v8 = (std::__shared_weak_count *)a2[1];
    uint64_t v13 = *a2;
    unsigned int v14 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v13 = *a2;
    unsigned int v14 = 0;
  }
  v12[0] = 0;
  void v12[2] = 0;
  v11[0] = 0;
  v11[2] = 0;
  int v9 = sub_2167A18F8((uint64_t)&v13, a4, a5, v12, v11);
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 40) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)a1 = v9;
  if (v14) {
    sub_216784EC4(v14);
  }
  if (v6) {
    sub_216784EC4(v6);
  }
  return a1;
}

void sub_2167A1B10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  if (v14) {
    sub_216784EC4(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t a1, Alembic::Abc::v12::IObject *a2, _DWORD *a3, _DWORD *a4)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  Alembic::Abc::v12::ICompoundProperty::init(a1, a2, a3, a4);
  return a1;
}

void sub_2167A1B9C(_Unwind_Exception *a1)
{
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::ICompoundProperty::init(uint64_t a1, Alembic::Abc::v12::IObject *a2, _DWORD *a3, _DWORD *a4)
{
  sub_2167A2320((uint64_t)v16, (uint64_t)a2);
  v11[0] = 0;
  v11[2] = 0;
  LODWORD(v14) = 0;
  LODWORD(v15) = 0;
  *(_DWORD *)a1 = sub_2167A2218((uint64_t)v16, a3, a4, v11, &v14);
  Alembic::Abc::v12::IObject::~IObject((Alembic::Abc::v12::IObject *)v16);
  uint64_t v14 = a1;
  uint64_t v15 = "ICompoundProperty::init( IObject)";
  Alembic::Abc::v12::IObject::getProperties(a2, (uint64_t)v11);
  uint64_t v9 = v12;
  uint64_t v8 = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 40);
  *(void *)(a1 + 32) = v9;
  *(void *)(a1 + 40) = v8;
  if (v10) {
    sub_216784EC4(v10);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v11);
}

void sub_2167A1C6C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v11 = (uint64_t)v10;
    sub_2167A13A4(v8);
    sub_21679FA64((uint64_t)va, v11);
  }
  else
  {
    sub_2167A13A4(v8);
    sub_21679F9F4((uint64_t)va, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A1C58);
}

void sub_2167A1CB4(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(uint64_t a1, Alembic::Abc::v12::IObject *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  Alembic::Abc::v12::ICompoundProperty::init(a1, a2, a4, a5);
  return a1;
}

void sub_2167A1D4C(_Unwind_Exception *a1)
{
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty(Alembic::Abc::v12::ICompoundProperty *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t Alembic::Abc::v12::ICompoundProperty::getNumProperties(Alembic::Abc::v12::ICompoundProperty *this)
{
  uint64_t result = *((void *)this + 4);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 64))(result);
  }
  return result;
}

void sub_2167A1E08(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A1DF8);
}

void sub_2167A1E40(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(Alembic::Abc::v12::ICompoundProperty *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E0D8, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_26798E0D8))
    {
      uint64_t v3 = operator new(0x50uLL);
      *uint64_t v3 = 0;
      v3[1] = 0;
      int v3[2] = 0;
      *((_DWORD *)v3 + 6) = 1;
      v3[6] = 0;
      v3[5] = 0;
      _DWORD v3[4] = v3 + 5;
      *((_DWORD *)v3 + 14) = 127;
      *((unsigned char *)v3 + 60) = 0;
      v3[8] = 0;
      v3[9] = 0;
      qword_26798E0D0 = (uint64_t)v3;
      __cxa_guard_release(&qword_26798E0D8);
    }
  }
  return qword_26798E0D0;
}

void sub_2167A1F34(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __cxa_guard_abort(&qword_26798E0D8);
  uint64_t v11 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v11);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E0E8, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_26798E0E8))
    {
      uint64_t v12 = operator new(0x50uLL);
      *uint64_t v12 = 0;
      v12[1] = 0;
      void v12[2] = 0;
      *((_DWORD *)v12 + 6) = 1;
      v12[6] = 0;
      v12[5] = 0;
      _DWORD v12[4] = v12 + 5;
      *((_DWORD *)v12 + 14) = 127;
      *((unsigned char *)v12 + 60) = 0;
      v12[8] = 0;
      v12[9] = 0;
      qword_26798E0E0 = (uint64_t)v12;
      __cxa_guard_release(&qword_26798E0E8);
    }
  }
  JUMPOUT(0x2167A1EC8);
}

void sub_2167A1FFC(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
  }
  return result;
}

void sub_2167A208C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A207CLL);
}

void sub_2167A20C4(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::ICompoundProperty::getParent(Alembic::Abc::v12::ICompoundProperty *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v9 = this;
  uint64_t v10 = "ICompoundProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 4) + 32))(&v7);
  int v4 = *(_DWORD *)this;
  v6[0] = 1;
  int v6[2] = v4;
  v5[0] = 0;
  int v5[2] = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(a2, &v7, v6, v5);
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167A2188(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  uint64_t v18 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a15, (uint64_t)v18);
  }
  else {
    sub_21679F9F4((uint64_t)&a15, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v15 = 2;
  sub_216779094((void *)(v15 + 8), "");
  *(void *)(v15 + 32) = 0;
  *(void *)(v15 + 40) = 0;
  JUMPOUT(0x2167A2174);
}

void sub_2167A21F8(_Unwind_Exception *a1)
{
}

uint64_t sub_2167A2218(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int v9 = *(_DWORD *)(a1 + 8);
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v12 = (const void **)v13;
  unsigned int v14 = v9;
  sub_2167898D0(v15, &v12);
  v15[3] = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 1;
  sub_2167877AC((uint64_t)&v12, v13[0]);
  sub_2167A030C(a2, (uint64_t)&v14);
  sub_2167A030C(a3, (uint64_t)&v14);
  sub_2167A030C(a4, (uint64_t)&v14);
  sub_2167A030C(a5, (uint64_t)&v14);
  uint64_t v10 = v14;
  if (v16) {
    sub_216784EC4(v16);
  }
  sub_2167877AC((uint64_t)v15, (void *)v15[1]);
  return v10;
}

void sub_2167A22F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t sub_2167A2320(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_216778F24((unsigned char *)(a1 + 16), *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v4;
  }
  *(void *)a1 = &unk_26C749578;
  uint64_t v5 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = (unsigned char *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0)
  {
    sub_216778F24(v7, *(void **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)uint64_t v7 = v8;
  }
  return a1;
}

void sub_2167A2408(_Unwind_Exception *a1)
{
  uint64_t v5 = *(std::__shared_weak_count **)(v1 + 64);
  if (v5) {
    sub_216784EC4(v5);
  }
  sub_217323CB8(v3, v1, v2);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IObject::~IObject(void **this)
{
  *this = &unk_26C749578;
  if (*((char *)this + 95) < 0) {
    operator delete(this[9]);
  }
  uint64_t v2 = (std::__shared_weak_count *)this[8];
  if (v2) {
    sub_216784EC4(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)this[6];
  if (v3) {
    sub_216784EC4(v3);
  }
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
}

{
  void *v1;
  uint64_t vars8;

  Alembic::Abc::v12::IObject::~IObject(this);

  operator delete(v1);
}

uint64_t Alembic::Abc::v12::IObject::getHeader(Alembic::Abc::v12::IObject *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E0F8, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_26798E0F8))
    {
      uint64_t v3 = operator new(0x48uLL);
      v3[8] = 0;
      v3[7] = 0;
      *(_OWORD *)uint64_t v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *((_OWORD *)v3 + 2) = 0u;
      v3[6] = v3 + 7;
      qword_26798E0F0 = (uint64_t)v3;
      __cxa_guard_release(&qword_26798E0F8);
    }
  }
  return qword_26798E0F0;
}

void sub_2167A25C8(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IObject::getName(Alembic::Abc::v12::IObject *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (!v2) {
    uint64_t v2 = *((void *)this + 5);
  }
  return (*(uint64_t (**)(void))(*(void *)v2 + 16))();
}

uint64_t Alembic::Abc::v12::IObject::getFullName(Alembic::Abc::v12::IObject *this)
{
  uint64_t result = (uint64_t)this + 72;
  if ((*((char *)this + 95) & 0x80000000) == 0)
  {
    if (*((unsigned char *)this + 95)) {
      return result;
    }
    return Alembic::Abc::v12::IObject::getHeader(this) + 24;
  }
  if (!*((void *)this + 10)) {
    return Alembic::Abc::v12::IObject::getHeader(this) + 24;
  }
  return result;
}

void Alembic::Abc::v12::IObject::getArchive(Alembic::Abc::v12::IObject *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (int *)((char *)this + 8);
  uint64_t v10 = (char *)this + 8;
  uint64_t v11 = "IObject::getArchive()";
  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 24))(&v8);
    int v5 = *v3;
    *(_DWORD *)a2 = 2;
    sub_216779094((void *)(a2 + 8), "");
    uint64_t v6 = v9;
    *(void *)(a2 + 32) = v8;
    *(void *)(a2 + 40) = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v7 = v9;
      *(_DWORD *)a2 = v5;
      if (v7) {
        sub_216784EC4(v7);
      }
    }
    else
    {
      *(_DWORD *)a2 = v5;
    }
  }
  else
  {
    *(_DWORD *)a2 = 2;
    sub_216779094((void *)(a2 + 8), "");
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
  }
}

void sub_2167A27A0(_Unwind_Exception *a1)
{
}

double Alembic::Abc::v12::IObject::getParent@<D0>(const std::string *this@<X0>, uint64_t a2@<X8>)
{
  std::string::size_type v4 = this[1].__r_.__value_.__r.__words[2];
  if (!v4)
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_216779094((void *)(a2 + 16), "");
    *(void *)a2 = &unk_26C749578;
    double result = 0.0;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(void *)(a2 + 88) = 0;
    return result;
  }
  p_std::string::size_type size = &this->__r_.__value_.__l.__size_;
  int v31 = &this->__r_.__value_.__s.__data_[8];
  size_t v32 = "IObject::getParent()";
  if (SHIBYTE(this[3].__r_.__value_.__r.__words[2]) < 0)
  {
    if (this[3].__r_.__value_.__l.__size_) {
      goto LABEL_4;
    }
  }
  else if (*((unsigned char *)&this[3].__r_.__value_.__s + 23))
  {
LABEL_4:
    std::string::size_type v6 = std::string::rfind(this + 3, 47, 0xFFFFFFFFFFFFFFFFLL);
    if (v6 + 1 > 1) {
      std::string::basic_string(&__str, this + 3, 0, v6, (std::allocator<char> *)&v29);
    }
    else {
      memset(&__str, 0, sizeof(__str));
    }
    (*(void (**)(long long *__return_ptr))(*(void *)this[1].__r_.__value_.__r.__words[2] + 32))(&v29);
    if (!(void)v29) {
      goto LABEL_37;
    }
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    if (!size) {
      goto LABEL_37;
    }
    uint64_t v10 = (*(uint64_t (**)(void))(*(void *)v29 + 16))();
    uint64_t v11 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v12 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v12 = __str.__r_.__value_.__l.__size_;
    }
    uint64_t v13 = *(unsigned __int8 *)(v10 + 47);
    int v14 = (char)v13;
    if ((v13 & 0x80u) != 0) {
      uint64_t v13 = *(void *)(v10 + 32);
    }
    if (v12 == v13)
    {
      int v17 = *(unsigned __int8 **)(v10 + 24);
      uint64_t v15 = (unsigned __int8 *)(v10 + 24);
      uint64_t v16 = v17;
      if (v14 >= 0) {
        uint64_t v18 = v15;
      }
      else {
        uint64_t v18 = v16;
      }
      if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) == 0)
      {
        if (*((unsigned char *)&__str.__r_.__value_.__s + 23))
        {
          p_str = &__str;
          while (p_str->__r_.__value_.__s.__data_[0] == *v18)
          {
            p_str = (std::string *)((char *)p_str + 1);
            ++v18;
            if (!--v11) {
              goto LABEL_37;
            }
          }
          goto LABEL_30;
        }
LABEL_37:
        int v22 = 0;
LABEL_38:
        long long v26 = v29;
        if (*((void *)&v29 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v29 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        int v23 = *(_DWORD *)p_size;
        LODWORD(v28) = 1;
        DWORD2(v28) = v23;
        sub_2167A0084(a2, (uint64_t *)&v26, &v28);
        if (*((void *)&v26 + 1)) {
          sub_216784EC4(*((std::__shared_weak_count **)&v26 + 1));
        }
        if (v22) {
          std::string::operator=((std::string *)(a2 + 72), &__str);
        }
        if (*((void *)&v29 + 1)) {
          sub_216784EC4(*((std::__shared_weak_count **)&v29 + 1));
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        return result;
      }
      if (!memcmp(__str.__r_.__value_.__l.__data_, v18, __str.__r_.__value_.__l.__size_)) {
        goto LABEL_37;
      }
    }
LABEL_30:
    char v20 = (std::__shared_weak_count *)*((void *)&v29 + 1);
    long long v27 = v29;
    if (*((void *)&v29 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v29 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_2167A2BA4((uint64_t *)&v27, &__str, &v28);
    BOOL v21 = (std::__shared_weak_count *)*((void *)&v29 + 1);
    long long v29 = v28;
    if (v21) {
      sub_216784EC4(v21);
    }
    if (v20) {
      sub_216784EC4(v20);
    }
    int v22 = 1;
    goto LABEL_38;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 32))(&v24);
  int v7 = *(_DWORD *)p_size;
  LODWORD(__str.__r_.__value_.__l.__data_) = 1;
  LODWORD(__str.__r_.__value_.__r.__words[1]) = v7;
  sub_2167A0084(a2, &v24, &__str);
  if (v25) {
    sub_216784EC4(v25);
  }
  return result;
}

void sub_2167A2B84(_Unwind_Exception *a1)
{
}

void sub_2167A2BA4(uint64_t *a1@<X0>, const std::string *a2@<X1>, void *a3@<X8>)
{
  std::string::size_type size = HIBYTE(a2->__r_.__value_.__r.__words[2]);
  int v5 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = a2->__r_.__value_.__l.__size_;
  }
  if (size && (uint64_t v6 = *a1) != 0)
  {
    if (v5 >= 0) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = (const std::string *)a2->__r_.__value_.__r.__words[0];
    }
    std::string::size_type v9 = v8->__r_.__value_.__s.__data_[0] == 47;
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v6 + 24))(&v12);
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v12 + 32))(&v14);
    if (v13) {
      sub_216784EC4(v13);
    }
    uint64_t v10 = v15;
    v11[0] = v14;
    v11[1] = v15;
    if (v15) {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_2167A4358((uint64_t)v11, a2, v9, a3);
    if (v10) {
      sub_216784EC4(v10);
    }
    if (v15) {
      sub_216784EC4(v15);
    }
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_2167A2CBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (v14) {
    sub_216784EC4(v14);
  }
  if (a14) {
    sub_216784EC4(a14);
  }
  _Unwind_Resume(exception_object);
}

std::string *Alembic::Abc::v12::IObject::setInstancedFullName(std::string *a1, const std::string *a2)
{
  return std::string::operator=(a1 + 3, a2);
}

uint64_t Alembic::Abc::v12::IObject::getNumChildren(Alembic::Abc::v12::IObject *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48))(v1);
  }
  else {
    return 0;
  }
}

void sub_2167A2D90(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IObject::getChildHeader(Alembic::Abc::v12::IObject *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 56))(v1);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E108, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_26798E108))
    {
      uint64_t v3 = operator new(0x48uLL);
      v3[8] = 0;
      v3[7] = 0;
      *(_OWORD *)uint64_t v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *((_OWORD *)v3 + 2) = 0u;
      v3[6] = v3 + 7;
      qword_26798E100 = (uint64_t)v3;
      __cxa_guard_release(&qword_26798E108);
    }
  }
  return qword_26798E100;
}

void sub_2167A2EA4(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IObject::getChildHeader(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 64))(v1);
  }
  else {
    return 0;
  }
}

void sub_2167A2F70(_Unwind_Exception *a1)
{
}

double Alembic::Abc::v12::IObject::getChild@<D0>(Alembic::Abc::v12::IObject *this@<X0>, uint64_t a2@<X8>)
{
  std::string::size_type v4 = (int *)((char *)this + 8);
  int v25 = (char *)this + 8;
  long long v26 = "IObject::getChild()";
  uint64_t v5 = *((void *)this + 5);
  if (!v5)
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_216779094((void *)(a2 + 16), "");
    *(void *)a2 = &unk_26C749578;
    double result = 0.0;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(void *)(a2 + 88) = 0;
    return result;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v5 + 80))(&v23);
  int v6 = *v4;
  LODWORD(__str.__r_.__value_.__l.__data_) = 1;
  LODWORD(__str.__r_.__value_.__r.__words[1]) = v6;
  sub_2167A0084(a2, &v23, &__str);
  if (v24) {
    sub_216784EC4(v24);
  }
  if (*((char *)this + 95) < 0)
  {
    if (!*((void *)this + 10)) {
      return result;
    }
  }
  else if (!*((unsigned char *)this + 95))
  {
    return result;
  }
  sub_216779094(&v20, "/");
  int v8 = *((char *)this + 95);
  if (v8 >= 0) {
    std::string::size_type v9 = (char *)this + 72;
  }
  else {
    std::string::size_type v9 = (const std::string::value_type *)*((void *)this + 9);
  }
  if (v8 >= 0) {
    std::string::size_type v10 = *((unsigned __int8 *)this + 95);
  }
  else {
    std::string::size_type v10 = *((void *)this + 10);
  }
  uint64_t v11 = std::string::insert(&v20, 0, v9, v10);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (*(void *)(a2 + 56)) {
    uint64_t v13 = *(void *)(a2 + 56);
  }
  else {
    uint64_t v13 = *(void *)(a2 + 40);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = (const std::string::value_type *)v14;
  }
  else {
    uint64_t v16 = *(const std::string::value_type **)v14;
  }
  if (v15 >= 0) {
    std::string::size_type v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    std::string::size_type v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::string::append(&v21, v16, v17);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  __str.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  std::string::operator=((std::string *)(a2 + 72), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  return result;
}

void sub_2167A3248(_Unwind_Exception *a1)
{
}

double Alembic::Abc::v12::IObject::getChild@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  std::string::size_type v4 = (int *)(a1 + 8);
  uint64_t v25 = a1 + 8;
  long long v26 = "IObject::getChild()";
  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_216779094((void *)(a2 + 16), "");
    *(void *)a2 = &unk_26C749578;
    double result = 0.0;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(void *)(a2 + 88) = 0;
    return result;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v5 + 72))(&v23);
  int v6 = *v4;
  LODWORD(__str.__r_.__value_.__l.__data_) = 1;
  LODWORD(__str.__r_.__value_.__r.__words[1]) = v6;
  sub_2167A0084(a2, &v23, &__str);
  if (v24) {
    sub_216784EC4(v24);
  }
  if (*(char *)(a1 + 95) < 0)
  {
    if (!*(void *)(a1 + 80)) {
      return result;
    }
  }
  else if (!*(unsigned char *)(a1 + 95))
  {
    return result;
  }
  sub_216779094(&v20, "/");
  int v8 = *(char *)(a1 + 95);
  if (v8 >= 0) {
    std::string::size_type v9 = (const std::string::value_type *)(a1 + 72);
  }
  else {
    std::string::size_type v9 = *(const std::string::value_type **)(a1 + 72);
  }
  if (v8 >= 0) {
    std::string::size_type v10 = *(unsigned __int8 *)(a1 + 95);
  }
  else {
    std::string::size_type v10 = *(void *)(a1 + 80);
  }
  uint64_t v11 = std::string::insert(&v20, 0, v9, v10);
  long long v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  if (*(void *)(a2 + 56)) {
    uint64_t v13 = *(void *)(a2 + 56);
  }
  else {
    uint64_t v13 = *(void *)(a2 + 40);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 16))(v13);
  int v15 = *(char *)(v14 + 23);
  if (v15 >= 0) {
    uint64_t v16 = (const std::string::value_type *)v14;
  }
  else {
    uint64_t v16 = *(const std::string::value_type **)v14;
  }
  if (v15 >= 0) {
    std::string::size_type v17 = *(unsigned __int8 *)(v14 + 23);
  }
  else {
    std::string::size_type v17 = *(void *)(v14 + 8);
  }
  uint64_t v18 = std::string::append(&v21, v16, v17);
  long long v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  __str.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  std::string::operator=((std::string *)(a2 + 72), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v21.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  return result;
}

void sub_2167A3520(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IObject::reset(Alembic::Abc::v12::IObject *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 95) < 0)
  {
    **((unsigned char **)this + 9) = 0;
    *((void *)this + 10) = 0;
  }
  else
  {
    *((unsigned char *)this + 72) = 0;
    *((unsigned char *)this + 95) = 0;
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 6);
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  if (v3) {
    sub_216784EC4(v3);
  }

  JUMPOUT(0x21D4477E0);
}

void Alembic::Abc::v12::IObject::getProperties(Alembic::Abc::v12::IObject *this@<X0>, uint64_t a2@<X8>)
{
  int v8 = (char *)this + 8;
  std::string::size_type v9 = "IObject::getProperties()";
  uint64_t v3 = *((void *)this + 5);
  if (v3)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 40))(&v6);
    v5[0] = 0;
    int v5[2] = 0;
    v4[0] = 0;
    int v4[2] = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(a2, &v6, v5, v4);
    if (v7) {
      sub_216784EC4(v7);
    }
  }
  else
  {
    *(_DWORD *)a2 = 2;
    sub_216779094((void *)(a2 + 8), "");
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
  }
}

void sub_2167A36CC(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IObject::getPropertiesHash(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 88))(v1);
  }
  else {
    return 0;
  }
}

void sub_2167A3784(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IObject::getChildrenHash(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 96))(v1);
  }
  else {
    return 0;
  }
}

void sub_2167A383C(_Unwind_Exception *a1)
{
}

BOOL Alembic::Abc::v12::IObject::isInstanceRoot(Alembic::Abc::v12::IObject *this)
{
  return *((void *)this + 7) != 0;
}

BOOL Alembic::Abc::v12::IObject::isInstanceDescendant(Alembic::Abc::v12::IObject *this)
{
  if (*((char *)this + 95) < 0) {
    uint64_t v1 = *((void *)this + 10);
  }
  else {
    uint64_t v1 = *((unsigned __int8 *)this + 95);
  }
  return v1 != 0;
}

void Alembic::Abc::v12::IObject::instanceSourcePath(Alembic::Abc::v12::IObject *this@<X0>, void *a2@<X8>)
{
  int v8 = (char *)this + 8;
  std::string::size_type v9 = "IObject::instanceSourcePath()";
  uint64_t v3 = *((void *)this + 7);
  if (v3)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 40))(&v6);
    std::string::size_type v4 = v7;
    v5[0] = v6;
    v5[1] = (uint64_t)v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_2167A39C4(v5, a2);
    if (v4) {
      sub_216784EC4(v4);
    }
    if (v7) {
      sub_216784EC4(v7);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
}

void sub_2167A39A4(_Unwind_Exception *a1)
{
}

void sub_2167A39C4(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = *a1;
  if (!*a1) {
    goto LABEL_14;
  }
  sub_216779094(v18, ".instanceSource");
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void **))(*(void *)v3 + 80))(v3, v18);
  uint64_t v6 = v5;
  if ((SHIBYTE(v19) & 0x80000000) == 0)
  {
    if (v5) {
      goto LABEL_4;
    }
LABEL_14:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    return;
  }
  operator delete(v18[0]);
  if (!v6) {
    goto LABEL_14;
  }
LABEL_4:
  int v7 = (std::__shared_weak_count *)a1[1];
  uint64_t v14 = *a1;
  int v15 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[2] = 0;
  v12[0] = 0;
  void v12[2] = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v16, &v14, v13, v12);
  sub_216779094(__p, ".instanceSource");
  v9[0] = 0;
  int v9[2] = 0;
  v8[0] = 0;
  v8[2] = 0;
  sub_2167A4730((uint64_t)v18, (int *)v16, (uint64_t)__p, v9, v8);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v16);
  if (v15) {
    sub_216784EC4(v15);
  }
  if (v20 < 0)
  {
    if (!v19) {
      goto LABEL_16;
    }
LABEL_18:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    goto LABEL_19;
  }
  if (v20) {
    goto LABEL_18;
  }
LABEL_16:
  if (!v21) {
    goto LABEL_18;
  }
  v16[0] = 0;
  v16[1] = 0;
  int v17 = 2;
  sub_2167A46DC((uint64_t)v18, (uint64_t)v16, a2);
LABEL_19:
  Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)v18);
}

void sub_2167A3B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)(v26 - 80));
  _Unwind_Resume(a1);
}

BOOL Alembic::Abc::v12::IObject::isChildInstance(Alembic::Abc::v12::IObject *this)
{
  int v7 = (char *)this + 8;
  int v8 = "IObject::isChildInstanced(size_t iChildIndex)";
  Alembic::Abc::v12::IObject::getChild(this, (uint64_t)v3);
  if (v4 < 0)
  {
    if (!v3[3]) {
      goto LABEL_5;
    }
LABEL_7:
    Alembic::Abc::v12::IObject::~IObject(v3);
    return 0;
  }
  if (v4) {
    goto LABEL_7;
  }
LABEL_5:
  if (!v5) {
    goto LABEL_7;
  }
  BOOL v1 = v6 != 0;
  Alembic::Abc::v12::IObject::~IObject(v3);
  return v1;
}

void sub_2167A3C38(void *a1, int a2)
{
  char v4 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v2 - 32, (uint64_t)v4);
  }
  else {
    sub_21679F9F4(v2 - 32, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A3C20);
}

void sub_2167A3C6C(_Unwind_Exception *a1)
{
}

BOOL Alembic::Abc::v12::IObject::isChildInstance(uint64_t a1)
{
  uint64_t v7 = a1 + 8;
  int v8 = "IObject::isChildInstance(const std::string &iChildName)";
  Alembic::Abc::v12::IObject::getChild(a1, (uint64_t)v3);
  if (v4 < 0)
  {
    if (!v3[3]) {
      goto LABEL_5;
    }
LABEL_7:
    Alembic::Abc::v12::IObject::~IObject(v3);
    return 0;
  }
  if (v4) {
    goto LABEL_7;
  }
LABEL_5:
  if (!v5) {
    goto LABEL_7;
  }
  BOOL v1 = v6 != 0;
  Alembic::Abc::v12::IObject::~IObject(v3);
  return v1;
}

void sub_2167A3D10(void *a1, int a2)
{
  char v4 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v2 - 32, (uint64_t)v4);
  }
  else {
    sub_21679F9F4(v2 - 32, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A3CF8);
}

void sub_2167A3D44(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IObject::init(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v17 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_216778F24(&v18, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v18 = *(_OWORD *)(a2 + 8);
    uint64_t v19 = *(void *)(a2 + 24);
  }
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v20 = *(void *)(a2 + 32);
  uint64_t v21 = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  LODWORD(v10) = 0;
  int v11 = 0;
  LODWORD(v15) = 0;
  LODWORD(v16) = 0;
  v14[0] = 0;
  void v14[2] = 0;
  *(_DWORD *)(a1 + 8) = sub_2167A3EE8(&v17, a3, &v10, &v15, v14);
  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&v17);
  uint64_t v15 = a1 + 8;
  uint64_t v16 = "IObject::init( IArchive)";
  Alembic::Abc::v12::IArchive::getTop((Alembic::Abc::v12::IArchive *)a2, (uint64_t)&v10);
  uint64_t v8 = v12;
  uint64_t v7 = v13;
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  std::string::size_type v9 = *(std::__shared_weak_count **)(a1 + 48);
  *(void *)(a1 + 40) = v8;
  *(void *)(a1 + 48) = v7;
  if (v9) {
    sub_216784EC4(v9);
  }
  Alembic::Abc::v12::IObject::~IObject(&v10);
}

void sub_2167A3E70(void *a1, int a2)
{
  uint64_t v5 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v6 = (uint64_t)v5;
    Alembic::Abc::v12::IObject::reset(v2);
    sub_21679FA64(v3 - 96, v6);
  }
  else
  {
    Alembic::Abc::v12::IObject::reset(v2);
    sub_21679F9F4(v3 - 96, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A3E5CLL);
}

void sub_2167A3EB8(_Unwind_Exception *a1)
{
}

uint64_t sub_2167A3EE8(unsigned int *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int v9 = *a1;
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v12 = (const void **)v13;
  unsigned int v14 = v9;
  sub_2167898D0(v15, &v12);
  v15[3] = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 1;
  sub_2167877AC((uint64_t)&v12, v13[0]);
  sub_2167A030C(a2, (uint64_t)&v14);
  sub_2167A030C(a3, (uint64_t)&v14);
  sub_2167A030C(a4, (uint64_t)&v14);
  sub_2167A030C(a5, (uint64_t)&v14);
  uint64_t v10 = v14;
  if (v16) {
    sub_216784EC4(v16);
  }
  sub_2167877AC((uint64_t)v15, (void *)v15[1]);
  return v10;
}

void sub_2167A3FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void Alembic::Abc::v12::IObject::init(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(_DWORD *)(a1 + 8) = a4;
  uint64_t v8 = a1 + 8;
  unsigned int v9 = "IObject::init()";
  (*(void (**)(long long *__return_ptr))(**(void **)a2 + 72))(&v7);
  long long v5 = v7;
  long long v7 = 0uLL;
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 48);
  *(_OWORD *)(a1 + 40) = v5;
  if (v6)
  {
    sub_216784EC4(v6);
    if (*((void *)&v7 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v7 + 1));
    }
  }
}

void sub_2167A4080(void *a1, int a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  long long v5 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)va, (uint64_t)v5);
  }
  else {
    sub_21679F9F4((uint64_t)va, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A4070);
}

void sub_2167A40B4(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IObject::initInstance(std::string *this)
{
  std::string::size_type v2 = this[1].__r_.__value_.__r.__words[2];
  if (v2)
  {
    uint64_t v3 = (*(uint64_t (**)(std::string::size_type))(*(void *)v2 + 16))(v2) + 48;
    sub_216779094(&__p, "isInstance");
    sub_21679F2AC(v3, (const void **)&__p, &v22);
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    {
      BOOL v4 = v22.__r_.__value_.__l.__size_ != 1 || *v22.__r_.__value_.__l.__data_ != 49;
      operator delete(v22.__r_.__value_.__l.__data_);
    }
    else
    {
      BOOL v4 = SHIBYTE(v22.__r_.__value_.__r.__words[2]) != 1 || v22.__r_.__value_.__s.__data_[0] != 49;
    }
    if (v21 < 0)
    {
      operator delete(__p);
      if (v4) {
        return;
      }
    }
    else if (v4)
    {
      return;
    }
    (*(void (**)(void **__return_ptr))(*(void *)this[1].__r_.__value_.__r.__words[2] + 40))(&__p);
    long long v5 = v20;
    v18[0] = (uint64_t)__p;
    v18[1] = (uint64_t)v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_2167A39C4(v18, &v22);
    if (v5) {
      sub_216784EC4(v5);
    }
    data = (std::__shared_weak_count *)this[2].__r_.__value_.__l.__data_;
    v15[0] = this[1].__r_.__value_.__r.__words[2];
    v15[1] = (uint64_t)data;
    if (data) {
      atomic_fetch_add_explicit(&data->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_2167A2BA4(v15, &v22, &v16);
    if (data) {
      sub_216784EC4(data);
    }
    std::string::size_type v8 = this[1].__r_.__value_.__r.__words[2];
    std::string::pointer v7 = this[2].__r_.__value_.__l.__data_;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v7 + 1, 1uLL, memory_order_relaxed);
    }
    unsigned int v9 = (std::__shared_weak_count *)this[2].__r_.__value_.__r.__words[2];
    this[2].__r_.__value_.__l.__size_ = v8;
    this[2].__r_.__value_.__r.__words[2] = (std::string::size_type)v7;
    if (v9) {
      sub_216784EC4(v9);
    }
    std::string::size_type v10 = v16;
    int v11 = v17;
    if (v17) {
      atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v12 = (std::__shared_weak_count *)this[2].__r_.__value_.__l.__data_;
    this[1].__r_.__value_.__r.__words[2] = v10;
    this[2].__r_.__value_.__r.__words[0] = (std::string::size_type)v11;
    if (v12) {
      sub_216784EC4(v12);
    }
    std::string::size_type size = this[2].__r_.__value_.__l.__size_;
    if (size)
    {
      unsigned int v14 = (const std::string *)(*(uint64_t (**)(std::string::size_type))(*(void *)size + 16))(size);
      std::string::operator=(this + 3, v14 + 1);
    }
    if (v11) {
      sub_216784EC4(v11);
    }
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v22.__r_.__value_.__l.__data_);
    }
    if (v20) {
      sub_216784EC4(v20);
    }
  }
}

void sub_2167A42F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, std::__shared_weak_count *a16, int a17, __int16 a18, char a19, char a20)
{
  if (v20) {
    sub_216784EC4(v20);
  }
  if (*(char *)(v21 - 17) < 0) {
    operator delete(*(void **)(v21 - 40));
  }
  if (a16) {
    sub_216784EC4(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167A4358(uint64_t a1@<X0>, const std::string *a2@<X1>, std::string::size_type a3@<X2>, void *a4@<X8>)
{
  std::string::size_type v8 = std::string::find(a2, 47, a3);
  std::string::size_type v9 = v8;
  memset(&v28, 0, sizeof(v28));
  if (v8 == -1) {
    std::string::basic_string(&v27, a2, a3, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
  }
  else {
    std::string::basic_string(&v27, a2, a3, v8 - a3, (std::allocator<char> *)&__p);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
  std::string v28 = v27;
  (*(void (**)(long long *__return_ptr))(**(void **)a1 + 72))(&v26);
  if (v9 == -1 || !(void)v26)
  {
    uint64_t v12 = *((void *)&v26 + 1);
    *a4 = v26;
    a4[1] = v12;
    long long v26 = 0uLL;
  }
  else
  {
    uint64_t v10 = (*(uint64_t (**)(void))(*(void *)v26 + 16))();
    sub_216779094(&__p, "isInstance");
    sub_21679F2AC(v10 + 48, (const void **)&__p, &v27);
    if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0)
    {
      BOOL v11 = v27.__r_.__value_.__l.__size_ == 1 && *v27.__r_.__value_.__l.__data_ == 49;
      operator delete(v27.__r_.__value_.__l.__data_);
    }
    else
    {
      BOOL v11 = SHIBYTE(v27.__r_.__value_.__r.__words[2]) == 1 && v27.__r_.__value_.__s.__data_[0] == 49;
    }
    if (v25 < 0) {
      operator delete(__p);
    }
    uint64_t v13 = v26;
    if (v11)
    {
      (*(void (**)(void **__return_ptr))(*(void *)v26 + 40))(&__p);
      unsigned int v14 = v24;
      v22[0] = (uint64_t)__p;
      v22[1] = (uint64_t)v24;
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_2167A39C4(v22, &v27);
      if (v14) {
        sub_216784EC4(v14);
      }
      uint64_t v15 = (std::__shared_weak_count *)*((void *)&v26 + 1);
      long long v20 = v26;
      if (*((void *)&v26 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v26 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      sub_2167A2BA4(&v21, &v20, &v27);
      long long v16 = v21;
      long long v21 = 0uLL;
      int v17 = (std::__shared_weak_count *)*((void *)&v26 + 1);
      long long v26 = v16;
      if (v17)
      {
        sub_216784EC4(v17);
        if (*((void *)&v21 + 1)) {
          sub_216784EC4(*((std::__shared_weak_count **)&v21 + 1));
        }
      }
      if (v15) {
        sub_216784EC4(v15);
      }
      if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v27.__r_.__value_.__l.__data_);
      }
      if (v24) {
        sub_216784EC4(v24);
      }
      uint64_t v13 = v26;
    }
    uint64_t v18 = (std::__shared_weak_count *)*((void *)&v26 + 1);
    v19[0] = v13;
    v19[1] = *((void *)&v26 + 1);
    if (*((void *)&v26 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v26 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    sub_2167A4358(v19, a2, v9 + 1);
    if (v18) {
      sub_216784EC4(v18);
    }
  }
  if (*((void *)&v26 + 1)) {
    sub_216784EC4(*((std::__shared_weak_count **)&v26 + 1));
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
}

void sub_2167A4630(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, std::__shared_weak_count *a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,std::__shared_weak_count *a25)
{
  if (v25) {
    sub_216784EC4(v25);
  }
  if (*(char *)(v26 - 81) < 0) {
    operator delete(*(void **)(v26 - 104));
  }
  if (a19) {
    sub_216784EC4(a19);
  }
  if (a25) {
    sub_216784EC4(a25);
  }
  if (*(char *)(v26 - 57) < 0) {
    operator delete(*(void **)(v26 - 80));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167A46DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  return Alembic::Abc::v12::IScalarProperty::get(a1, (uint64_t)a3, a2, 24);
}

void sub_2167A4714(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167A4730(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v45 + 1) = 0;
  v46[0] = 0;
  *(void *)&long long v45 = (char *)&v45 + 8;
  int v47 = v10;
  sub_2167898D0(v48, (const void ***)&v45);
  v48[3] = 0;
  uint64_t v49 = 0;
  int v50 = 0;
  uint64_t v51 = 1;
  sub_2167877AC((uint64_t)&v45, *((void **)&v45 + 1));
  sub_2167A030C(a4, (uint64_t)&v47);
  sub_2167A030C(a5, (uint64_t)&v47);
  *(_DWORD *)a1 = v47;
  v46[34] = a1;
  v46[35] = "ITypedScalarProperty::ITypedScalarProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  BOOL v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v45);
    int v31 = sub_216779180(v46, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v31, (uint64_t)"ITypedScalarProperty ctor", 25);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v33 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v33, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v45);
    int64_t v34 = sub_216779180(v46, (uint64_t)"Nonexistent scalar property: ", 29);
    int v35 = *(char *)(a3 + 23);
    if (v35 >= 0) {
      uint64_t v36 = a3;
    }
    else {
      uint64_t v36 = *(void *)a3;
    }
    if (v35 >= 0) {
      uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v37 = *(void *)(a3 + 8);
    }
    sub_216779180(v34, v36, v37);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    unint64_t v38 = __cxa_allocate_exception(0x20uLL);
    int64_t v39 = sub_216779038(v38, (uint64_t)__p);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v16 = *(_DWORD *)(v13 + 56) == 12 && *(unsigned char *)(v13 + 60) == 1 && *(_DWORD *)(v13 + 24) == 1;
  if (!v16 || (sub_2167A4CB4(v13 + 32, v51) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v45);
    long long v20 = sub_216779180(v46, (uint64_t)"Incorrect match of header datatype: ", 36);
    long long v21 = sub_21677D5B0(v20, (int *)(v14 + 56));
    std::string v22 = sub_216779180(v21, (uint64_t)" to expected: ", 14);
    uint64_t v40 = 0x10000000CLL;
    uint64_t v23 = sub_21677D5B0(v22, (int *)&v40);
    uint64_t v24 = sub_216779180(v23, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v41, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v41, __p);
    if ((v44 & 0x80u) == 0) {
      char v25 = __p;
    }
    else {
      char v25 = (void **)__p[0];
    }
    if ((v44 & 0x80u) == 0) {
      uint64_t v26 = v44;
    }
    else {
      uint64_t v26 = (uint64_t)__p[1];
    }
    std::string v27 = sub_216779180(v24, (uint64_t)v25, v26);
    std::string v28 = sub_216779180(v27, (uint64_t)" to expected: ", 14);
    sub_216779180(v28, (uint64_t)"", 0);
    if ((char)v44 < 0) {
      operator delete(__p[0]);
    }
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    long long v29 = __cxa_allocate_exception(0x20uLL);
    int v30 = sub_216779038(v29, (uint64_t)__p);
    __cxa_throw(v30, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 88))(&v45, v12, a3);
  long long v17 = v45;
  long long v45 = 0uLL;
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v17;
  if (v18)
  {
    sub_216784EC4(v18);
    if (*((void *)&v45 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v45 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v49) {
    sub_216784EC4(v49);
  }
  sub_2167877AC((uint64_t)v48, (void *)v48[1]);
  return a1;
}

void sub_2167A4B6C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  long long v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A48D0);
}

void sub_2167A4C74()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167A4CA4);
}

uint64_t sub_2167A4CB4(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v7);
  if (v8 < 0)
  {
    BOOL v2 = v7[1] == 0;
    operator delete(v7[0]);
  }
  else
  {
    BOOL v2 = v8 == 0;
  }
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167A4D40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::Abc::v12::ISampleSelector::getIndex(uint64_t a1, double ***a2, uint64_t a3)
{
  uint64_t CeilIndex = *(void *)a1;
  if (CeilIndex < 0)
  {
    int v8 = *(_DWORD *)(a1 + 16);
    if (v8)
    {
      if (v8 == 2) {
        uint64_t CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getNearIndex(*a2, *(double *)(a1 + 8), a3);
      }
      else {
        uint64_t CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getCeilIndex(*a2, *(double *)(a1 + 8), a3);
      }
    }
    else
    {
      uint64_t CeilIndex = Alembic::AbcCoreAbstract::v12::TimeSampling::getFloorIndex(*a2, *(double *)(a1 + 8), a3);
    }
  }
  uint64_t v6 = a3 - 1;
  if (CeilIndex < a3) {
    uint64_t v6 = CeilIndex;
  }
  if (CeilIndex >= 0) {
    return v6;
  }
  else {
    return 0;
  }
}

uint64_t Alembic::Abc::v12::IScalarProperty::IScalarProperty(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v8 = *(std::__shared_weak_count **)(a2 + 40);
  v10[0] = *(void *)(a2 + 32);
  v10[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Abc::v12::IScalarProperty::init(a1, v10, a3, *(_DWORD *)a2, a4);
  if (v8) {
    sub_216784EC4(v8);
  }
  return a1;
}

void sub_2167A4E84(_Unwind_Exception *a1)
{
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IScalarProperty::init(uint64_t a1, void *a2, uint64_t a3, int a4, _DWORD *a5)
{
  *((void *)&v20 + 1) = 0;
  v21[0] = 0;
  *(void *)&long long v20 = (char *)&v20 + 8;
  int v22 = a4;
  sub_2167898D0(v23, (const void ***)&v20);
  v23[3] = 0;
  uint64_t v24 = 0;
  int v25 = 0;
  uint64_t v26 = 1;
  sub_2167877AC((uint64_t)&v20, *((void **)&v20 + 1));
  sub_2167A030C(a5, (uint64_t)&v22);
  *(_DWORD *)a1 = v22;
  v21[34] = a1;
  v21[35] = "IScalarProperty::init()";
  if (!(*(uint64_t (**)(void, uint64_t))(*(void *)*a2 + 80))(*a2, a3))
  {
    sub_216778A5C((uint64_t)&v20);
    BOOL v11 = sub_216779180(v21, (uint64_t)"Nonexistent scalar property: ", 29);
    int v12 = *(char *)(a3 + 23);
    if (v12 >= 0) {
      uint64_t v13 = a3;
    }
    else {
      uint64_t v13 = *(void *)a3;
    }
    if (v12 >= 0) {
      uint64_t v14 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v14 = *(void *)(a3 + 8);
    }
    sub_216779180(v11, v13, v14);
    std::stringbuf::str();
    sub_216778E70(v19, &__p);
    if (v18 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    BOOL v16 = sub_216779038(exception, (uint64_t)v19);
    __cxa_throw(v16, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr))(*(void *)*a2 + 88))(&v20);
  long long v9 = v20;
  long long v20 = 0uLL;
  int v10 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v9;
  if (v10)
  {
    sub_216784EC4(v10);
    if (*((void *)&v20 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v20 + 1));
    }
  }
  if (v24) {
    sub_216784EC4(v24);
  }
  sub_2167877AC((uint64_t)v23, (void *)v23[1]);
}

void sub_2167A5084(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  int v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v11 = (uint64_t)v10;
    sub_2167A13A4(v6);
    sub_21679FA64(v7 - 128, v11);
  }
  else
  {
    sub_2167A13A4(v6);
    sub_21679F9F4(v7 - 128, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A4FBCLL);
}

void sub_2167A510C(_Unwind_Exception *a1)
{
  sub_2167A03C4(v1 - 112);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::IScalarProperty::~IScalarProperty(Alembic::Abc::v12::IScalarProperty *this)
{
  BOOL v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t Alembic::Abc::v12::IScalarProperty::getNumSamples(Alembic::Abc::v12::IScalarProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 64))(*((void *)this + 4));
}

void sub_2167A51F8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A51E8);
}

void sub_2167A5230(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IScalarProperty::isConstant(Alembic::Abc::v12::IScalarProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 72))(*((void *)this + 4));
}

void sub_2167A52A8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A5298);
}

void sub_2167A52E0(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IScalarProperty::getTimeSampling@<X0>(Alembic::Abc::v12::IScalarProperty *this@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 4) + 16))(*((void *)this + 4));
  uint64_t v4 = *(void *)(result + 72);
  *a2 = *(void *)(result + 64);
  a2[1] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_2167A5374(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v11);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  *long long v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x2167A5364);
}

void sub_2167A53AC(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::IScalarProperty::get(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v15 = a1;
  uint64_t v16 = "IScalarProperty::get()";
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32));
  long long v9 = *(std::__shared_weak_count **)(v8 + 72);
  uint64_t v13 = *(double ***)(v8 + 64);
  uint64_t v14 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
  uint64_t Index = Alembic::Abc::v12::ISampleSelector::getIndex(a3, &v13, v10);
  if (v14) {
    sub_216784EC4(v14);
  }
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 32) + 80))(*(void *)(a1 + 32), Index, a2, a4);
}

void sub_2167A54D0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  std::exception v12 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v12);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A54BCLL);
}

void sub_2167A5528(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::IScalarProperty::getParent(Alembic::Abc::v12::IScalarProperty *this@<X0>, uint64_t a2@<X8>)
{
  long long v9 = this;
  uint64_t v10 = "IScalarProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 4) + 32))(&v7);
  int v4 = *(_DWORD *)this;
  v6[0] = 1;
  int v6[2] = v4;
  v5[0] = 0;
  uint64_t v5[2] = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(a2, &v7, v6, v5);
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167A55EC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  char v18 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a15, (uint64_t)v18);
  }
  else {
    sub_21679F9F4((uint64_t)&a15, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v15 = 2;
  sub_216779094((void *)(v15 + 8), "");
  *(void *)(v15 + 32) = 0;
  *(void *)(v15 + 40) = 0;
  JUMPOUT(0x2167A55D8);
}

void sub_2167A565C(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OArchive::~OArchive(Alembic::Abc::v12::OArchive *this)
{
  BOOL v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

char *Alembic::Abc::v12::OArchive::getName@<X0>(Alembic::Abc::v12::OArchive *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (char *)(*(uint64_t (**)(void))(**((void **)this + 4) + 16))(*((void *)this + 4));
  if (result[23] < 0) {
    return (char *)sub_216778F24((unsigned char *)a2, *(void **)result, *((void *)result + 1));
  }
  long long v4 = *(_OWORD *)result;
  *(void *)(a2 + 16) = *((void *)result + 2);
  *(_OWORD *)a2 = v4;
  return result;
}

void sub_2167A5744(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v11);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  sub_216779094(v9, "");
  JUMPOUT(0x2167A5734);
}

void sub_2167A5788(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OArchive::getCompressionHint(Alembic::Abc::v12::OArchive *this)
{
  return *(char *)(*((void *)this + 4) + 8);
}

uint64_t Alembic::Abc::v12::OArchive::setCompressionHint(uint64_t this, int a2)
{
  if (a2 >= 9) {
    int v2 = 9;
  }
  else {
    int v2 = a2;
  }
  if (v2 < 0) {
    LOBYTE(v2) = -1;
  }
  *(unsigned char *)(*(void *)(this + 32) + 8) = v2;
  return this;
}

uint64_t Alembic::Abc::v12::OArchive::addTimeSampling(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))(*(void *)(a1 + 32));
}

void sub_2167A582C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A581CLL);
}

void sub_2167A5864(_Unwind_Exception *a1)
{
}

void *Alembic::Abc::v12::OArchive::getTimeSampling@<X0>(Alembic::Abc::v12::OArchive *this@<X0>, void *a2@<X8>)
{
  return (*(void *(**)(void *__return_ptr))(**((void **)this + 4) + 56))(a2);
}

void sub_2167A58E4(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v11);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  *long long v9 = 0;
  v9[1] = 0;
  JUMPOUT(0x2167A58D4);
}

void sub_2167A591C(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OArchive::getNumTimeSamplings(Alembic::Abc::v12::OArchive *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 64))(*((void *)this + 4));
}

void sub_2167A5994(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A5984);
}

void sub_2167A59CC(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OArchive::getTop(Alembic::Abc::v12::OArchive *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v8 = this;
  long long v9 = "OArchive::getTop()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 4) + 32))(&v6);
  v5[0] = 0;
  uint64_t v5[2] = 0;
  v4[0] = 0;
  int v4[2] = 0;
  v3[0] = 0;
  int v3[2] = 0;
  sub_2167A5B3C(a2, &v6, v5, v4, v3);
  if (v7) {
    sub_216784EC4(v7);
  }
}

void sub_2167A5A90(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_216784EC4(a16);
  }
  long long v20 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v17 - 48, (uint64_t)v20);
  }
  else {
    sub_21679F9F4(v17 - 48, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)(v16 + 8) = 2;
  sub_216779094((void *)(v16 + 16), "");
  *(void *)uint64_t v16 = &unk_26C7495D0;
  *(void *)(v16 + 40) = 0;
  *(void *)(v16 + 48) = 0;
  JUMPOUT(0x2167A5A7CLL);
}

void sub_2167A5B1C(_Unwind_Exception *a1)
{
}

uint64_t sub_2167A5B3C(uint64_t a1, void *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)(a1 + 8) = 2;
  sub_216779094((void *)(a1 + 16), "");
  *(void *)a1 = &unk_26C7495D0;
  *(void *)(a1 + 40) = *a2;
  uint64_t v10 = a2[1];
  *(void *)(a1 + 48) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = (std::__shared_weak_count *)a2[1];
  uint64_t v14 = *a2;
  uint64_t v15 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[2] = 0;
  *(_DWORD *)(a1 + 8) = sub_2167A5C5C((uint64_t)&v14, a3, a4, a5, v13);
  if (v15) {
    sub_216784EC4(v15);
  }
  return a1;
}

void sub_2167A5C34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_216784EC4(a12);
  }
  sub_217323D10(v14, v12, v13);
  _Unwind_Resume(a1);
}

uint64_t sub_2167A5C5C(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  long long v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v12 = (const void **)v13;
  unsigned int v14 = 2;
  sub_2167898D0(v15, &v12);
  v15[3] = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 1;
  sub_2167877AC((uint64_t)&v12, v13[0]);
  if (v9) {
    sub_216784EC4(v9);
  }
  sub_2167A030C(a2, (uint64_t)&v14);
  sub_2167A030C(a3, (uint64_t)&v14);
  sub_2167A030C(a4, (uint64_t)&v14);
  sub_2167A030C(a5, (uint64_t)&v14);
  uint64_t v10 = v14;
  if (v16) {
    sub_216784EC4(v16);
  }
  sub_2167877AC((uint64_t)v15, (void *)v15[1]);
  return v10;
}

void sub_2167A5D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_2167877AC((uint64_t)&a10, a11);
  if (v11) {
    sub_216784EC4(v11);
  }
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OArrayProperty::OArrayProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  unsigned int v14 = *(std::__shared_weak_count **)(a2 + 40);
  v16[0] = *(void *)(a2 + 32);
  v16[1] = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Abc::v12::OArrayProperty::init(a1, (uint64_t)v16, a3, a4, *(_DWORD *)a2, a5, a6, a7);
  if (v14) {
    sub_216784EC4(v14);
  }
  return a1;
}

void sub_2167A5E4C(_Unwind_Exception *a1)
{
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OArrayProperty::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  v21[0] = 0;
  v21[1] = 0;
  long long v20 = (const void **)v21;
  int v22 = a5;
  sub_2167898D0(v23, &v20);
  uint64_t v24 = 0;
  int v25 = 0;
  int v26 = 0;
  uint64_t v27 = 1;
  sub_2167877AC((uint64_t)&v20, v21[0]);
  sub_2167A030C(a6, (uint64_t)&v22);
  sub_2167A030C(a7, (uint64_t)&v22);
  sub_2167A030C(a8, (uint64_t)&v22);
  *(_DWORD *)a1 = v22;
  long long v20 = (const void **)a1;
  v21[0] = "OArrayProperty::init()";
  uint64_t v14 = v24;
  uint64_t v13 = v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v14)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 24))(&v17);
    (*(void (**)(long long *__return_ptr))(*(void *)v17 + 24))(&v19);
    (*(void (**)(void, uint64_t))(*(void *)v19 + 48))(v19, v14);
    if (*((void *)&v19 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v19 + 1));
    }
    if (v18) {
      sub_216784EC4(v18);
    }
  }
  (*(void (**)(long long *__return_ptr))(**(void **)a2 + 104))(&v19);
  long long v15 = v19;
  long long v19 = 0uLL;
  uint64_t v16 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v15;
  if (v16)
  {
    sub_216784EC4(v16);
    if (*((void *)&v19 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v19 + 1));
    }
  }
  if (v13) {
    sub_216784EC4(v13);
  }
  if (v25) {
    sub_216784EC4(v25);
  }
  sub_2167877AC((uint64_t)v23, (void *)v23[1]);
}

void sub_2167A6088(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, char a14)
{
  if (a12) {
    sub_216784EC4(a12);
  }
  if (a10) {
    sub_216784EC4(a10);
  }
  if (v15) {
    sub_216784EC4(v15);
  }
  uint64_t v18 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v19 = (uint64_t)v18;
    sub_2167A13A4(v14);
    sub_21679FA64((uint64_t)&a14, v19);
  }
  else
  {
    sub_2167A13A4(v14);
    sub_21679F9F4((uint64_t)&a14, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A6054);
}

void sub_2167A611C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_2167A03C4((uint64_t)va);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OArrayProperty::~OArrayProperty(Alembic::Abc::v12::OArrayProperty *this)
{
  int v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t Alembic::Abc::v12::OArrayProperty::getNumSamples(Alembic::Abc::v12::OArrayProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 80))(*((void *)this + 4));
}

void sub_2167A6208(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A61F8);
}

void sub_2167A6240(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OArrayProperty::set(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 64))(*(void *)(a1 + 32));
}

void sub_2167A62B8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A62A8);
}

void sub_2167A62EC(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OArrayProperty::setFromPrevious(Alembic::Abc::v12::OArrayProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 72))(*((void *)this + 4));
}

void sub_2167A6364(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A6354);
}

void sub_2167A6398(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OArrayProperty::setTimeSampling(Alembic::Abc::v12::OArrayProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 88))(*((void *)this + 4));
}

void sub_2167A6410(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A6400);
}

void sub_2167A6444(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OArrayProperty::setTimeSampling(uint64_t a1, void *a2)
{
  uint64_t v12 = a1;
  uint64_t v13 = "OArrayProperty::setTimeSampling()";
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 32) + 32))(&v6);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v6 + 24))(&v8);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v8 + 24))(&v10);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)v10 + 48))(v10, *a2);
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v9) {
    sub_216784EC4(v9);
  }
  if (v7) {
    sub_216784EC4(v7);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 32) + 88))(*(void *)(a1 + 32), v4);
}

void sub_2167A65A0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v16 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v14 - 32, (uint64_t)v16);
  }
  else {
    sub_21679F9F4(v14 - 32, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A6590);
}

void sub_2167A6628(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OArrayProperty::getParent(Alembic::Abc::v12::OArrayProperty *this@<X0>, uint64_t a2@<X8>)
{
  long long v9 = this;
  uint64_t v10 = "OArrayProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 4) + 32))(&v7);
  int v4 = *(_DWORD *)this;
  v6[0] = 1;
  int v6[2] = v4;
  v5[0] = 0;
  uint64_t v5[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(a2, &v7, v6, v5);
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167A66EC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  uint64_t v18 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a15, (uint64_t)v18);
  }
  else {
    sub_21679F9F4((uint64_t)&a15, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v15 = 2;
  sub_216779094((void *)(v15 + 8), "");
  *(void *)(v15 + 32) = 0;
  *(void *)(v15 + 40) = 0;
  JUMPOUT(0x2167A66D8);
}

void sub_2167A675C(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v10 = *a2;
  uint64_t v11 = (std::__shared_weak_count *)a2[1];
  v14[0] = v10;
  v14[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::init(a1, (uint64_t)v14, a3, a4, a5, v13);
  if (v11) {
    sub_216784EC4(v11);
  }
  return a1;
}

{
  std::__shared_weak_count *v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  int v9;
  _DWORD v11[4];
  _DWORD v12[4];
  uint64_t v13;
  std::__shared_weak_count *v14;

  uint64_t v7 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v8 = (std::__shared_weak_count *)a2[1];
    uint64_t v13 = *a2;
    uint64_t v14 = v8;
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v13 = *a2;
    uint64_t v14 = 0;
  }
  v12[0] = 0;
  void v12[2] = 0;
  v11[0] = 0;
  void v11[2] = 0;
  long long v9 = sub_2167A6D80((uint64_t)&v13, a4, a5, v12, v11);
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 40) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)a1 = v9;
  if (v14) {
    sub_216784EC4(v14);
  }
  if (v6) {
    sub_216784EC4(v6);
  }
  return a1;
}

void sub_2167A6828(_Unwind_Exception *a1)
{
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::init(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t v28 = a1;
  long long v29 = "OCompoundProperty::init()";
  if (!*(void *)a2)
  {
    sub_216778A5C((uint64_t)&v22);
    sub_216779180(v24, (uint64_t)"invalid parent", 14);
    std::stringbuf::str();
    sub_216778E70(lpsrc, &__p);
    if (v19 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v17 = sub_216779038(exception, (uint64_t)lpsrc);
    __cxa_throw(v17, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  lpsrc[1] = 0;
  uint64_t v21 = 0;
  lpsrc[0] = &lpsrc[1];
  int v22 = 2;
  sub_2167898D0(&v23, (const void ***)lpsrc);
  v24[2] = 0;
  int v25 = 0;
  int v26 = 0;
  uint64_t v27 = 1;
  sub_2167877AC((uint64_t)lpsrc, (void *)lpsrc[1]);
  sub_2167A030C(a4, (uint64_t)&v22);
  sub_2167A030C(a5, (uint64_t)&v22);
  sub_2167A030C(a6, (uint64_t)&v22);
  *(_DWORD *)a1 = v22;
  (*(void (**)(void **__return_ptr))(**(void **)a2 + 88))(lpsrc);
  uint64_t v11 = lpsrc[0];
  if (lpsrc[0]
  {
    uint64_t v12 = lpsrc[1];
    if (lpsrc[1]) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)lpsrc[1] + 1, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 40);
  *(void *)(a1 + 32) = v11;
  *(void *)(a1 + 40) = v12;
  if (v13) {
    sub_216784EC4(v13);
  }
  if (lpsrc[1]) {
    sub_216784EC4((std::__shared_weak_count *)lpsrc[1]);
  }
  if (!*(void *)(a1 + 32))
  {
    (*(void (**)(void **__return_ptr))(**(void **)a2 + 112))(lpsrc);
    long long v14 = *(_OWORD *)lpsrc;
    lpsrc[0] = 0;
    lpsrc[1] = 0;
    uint64_t v15 = *(std::__shared_weak_count **)(a1 + 40);
    *(_OWORD *)(a1 + 32) = v14;
    if (v15)
    {
      sub_216784EC4(v15);
      if (lpsrc[1]) {
        sub_216784EC4((std::__shared_weak_count *)lpsrc[1]);
      }
    }
  }
  if (v25) {
    sub_216784EC4(v25);
  }
  sub_2167877AC((uint64_t)&v23, v24[0]);
}

void sub_2167A6AD8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v11 = (uint64_t)v10;
    sub_2167A13A4(v6);
    sub_21679FA64(v7 - 80, v11);
  }
  else
  {
    sub_2167A13A4(v6);
    sub_21679F9F4(v7 - 80, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A69E4);
}

void sub_2167A6B88(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v10 = *(void *)(a2 + 32);
  uint64_t v11 = *(std::__shared_weak_count **)(a2 + 40);
  v14[0] = v10;
  v14[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::init(a1, (uint64_t)v14, a3, a4, a5, v13);
  if (v11) {
    sub_216784EC4(v11);
  }
  return a1;
}

{
  uint64_t v9;
  uint64_t v10;
  void *v12;
  int v13;
  long long v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v13 = *(_DWORD *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_216778F24(&v14, *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    uint64_t v14 = *(_OWORD *)(a2 + 16);
    uint64_t v15 = *(void *)(a2 + 32);
  }
  uint64_t v10 = *(void *)(a2 + 40);
  long long v9 = *(void *)(a2 + 48);
  std::exception v12 = &unk_26C7495D0;
  uint64_t v16 = v10;
  uint64_t v17 = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  Alembic::Abc::v12::OCompoundProperty::init(a1, (uint64_t)&v12, a4, a5);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&v12);
  return a1;
}

void sub_2167A6C58(_Unwind_Exception *a1)
{
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t a1, uint64_t *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v6 = *a2;
  long long v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v7 = (std::__shared_weak_count *)a2[1];
    uint64_t v12 = *a2;
    uint64_t v13 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
    uint64_t v12 = *a2;
    uint64_t v13 = 0;
  }
  v11[0] = 0;
  void v11[2] = 0;
  v10[0] = 0;
  void v10[2] = 0;
  int v8 = sub_2167A6D80((uint64_t)&v12, a3, a4, v11, v10);
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 40) = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)a1 = v8;
  if (v13) {
    sub_216784EC4(v13);
  }
  if (v5) {
    sub_216784EC4(v5);
  }
  return a1;
}

void sub_2167A6D5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  if (v14) {
    sub_216784EC4(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167A6D80(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  long long v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v12 = (const void **)v13;
  unsigned int v14 = 2;
  sub_2167898D0(v15, &v12);
  v15[3] = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 1;
  sub_2167877AC((uint64_t)&v12, v13[0]);
  if (v9) {
    sub_216784EC4(v9);
  }
  sub_2167A030C(a2, (uint64_t)&v14);
  sub_2167A030C(a3, (uint64_t)&v14);
  sub_2167A030C(a4, (uint64_t)&v14);
  sub_2167A030C(a5, (uint64_t)&v14);
  uint64_t v10 = v14;
  if (v16) {
    sub_216784EC4(v16);
  }
  sub_2167877AC((uint64_t)v15, (void *)v15[1]);
  return v10;
}

void sub_2167A6E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_2167877AC((uint64_t)&a10, a11);
  if (v11) {
    sub_216784EC4(v11);
  }
  _Unwind_Resume(a1);
}

void sub_2167A6F98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  if (v14) {
    sub_216784EC4(v14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v12 = *(_DWORD *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_216778F24(&v13, *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v13 = *(_OWORD *)(a2 + 16);
    uint64_t v14 = *(void *)(a2 + 32);
  }
  uint64_t v9 = *(void *)(a2 + 40);
  uint64_t v8 = *(void *)(a2 + 48);
  uint64_t v11 = &unk_26C7495D0;
  uint64_t v15 = v9;
  uint64_t v16 = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  Alembic::Abc::v12::OCompoundProperty::init(a1, (uint64_t)&v11, a3, a4);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&v11);
  return a1;
}

void sub_2167A70A4(_Unwind_Exception *a1)
{
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::init(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v19 = *(_DWORD *)(a2 + 8);
  if (*(char *)(a2 + 39) < 0)
  {
    sub_216778F24(&v20, *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v20 = *(_OWORD *)(a2 + 16);
    uint64_t v21 = *(void *)(a2 + 32);
  }
  uint64_t v9 = *(void *)(a2 + 40);
  uint64_t v8 = *(void *)(a2 + 48);
  uint64_t v18 = &unk_26C7495D0;
  uint64_t v22 = v9;
  uint64_t v23 = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[2] = 0;
  LODWORD(v16) = 0;
  LODWORD(v17) = 0;
  *(_DWORD *)a1 = sub_2167A79F0((uint64_t)&v18, a3, a4, v13, &v16);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&v18);
  uint64_t v16 = a1;
  int v17 = "OCompoundProperty::init( OObject)";
  Alembic::Abc::v12::OObject::getProperties((Alembic::Abc::v12::OObject *)a2, (uint64_t)v13);
  uint64_t v11 = v14;
  uint64_t v10 = v15;
  if (v15) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  }
  int v12 = *(std::__shared_weak_count **)(a1 + 40);
  *(void *)(a1 + 32) = v11;
  *(void *)(a1 + 40) = v10;
  if (v12) {
    sub_216784EC4(v12);
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v13);
}

void sub_2167A71EC(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  uint64_t v11 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v12 = (uint64_t)v11;
    sub_2167A13A4(v9);
    sub_21679FA64((uint64_t)va, v12);
  }
  else
  {
    sub_2167A13A4(v9);
    sub_21679F9F4((uint64_t)va, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A71D8);
}

void sub_2167A7234(_Unwind_Exception *a1)
{
}

void sub_2167A734C(_Unwind_Exception *a1)
{
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty(Alembic::Abc::v12::OCompoundProperty *this)
{
  int v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t Alembic::Abc::v12::OCompoundProperty::getNumProperties(Alembic::Abc::v12::OCompoundProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 64))(*((void *)this + 4));
}

void sub_2167A7410(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A7400);
}

void sub_2167A7448(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OCompoundProperty::getPropertyHeader(Alembic::Abc::v12::OCompoundProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 72))(*((void *)this + 4));
}

void sub_2167A74C0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E118, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_26798E118))
    {
      uint64_t v11 = operator new(0x50uLL);
      *uint64_t v11 = 0;
      v11[1] = 0;
      void v11[2] = 0;
      *((_DWORD *)v11 + 6) = 1;
      v11[6] = 0;
      v11[5] = 0;
      _DWORD v11[4] = v11 + 5;
      *((_DWORD *)v11 + 14) = 127;
      *((unsigned char *)v11 + 60) = 0;
      _DWORD v11[8] = 0;
      v11[9] = 0;
      qword_26798E110 = (uint64_t)v11;
      __cxa_guard_release(&qword_26798E118);
    }
  }
  JUMPOUT(0x2167A74B0);
}

void sub_2167A7568(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OCompoundProperty::getPropertyHeader(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 80))(*(void *)(a1 + 32));
}

void sub_2167A75F4(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A75E4);
}

void sub_2167A762C(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OCompoundProperty::getProperty(Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter **this@<X0>, uint64_t a2@<X8>)
{
  Alembic::AbcCoreAbstract::v12::CompoundPropertyWriter::getProperty(this[4]);
  int v4 = *(_DWORD *)this;
  *(_DWORD *)a2 = 2;
  sub_216779094((void *)(a2 + 8), "");
  *(void *)(a2 + 32) = v5;
  *(void *)(a2 + 40) = v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    *(_DWORD *)a2 = v4;
    sub_216784EC4(v6);
  }
  else
  {
    *(_DWORD *)a2 = v4;
  }
}

void sub_2167A76E4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  uint64_t v14 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v14);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v11 = 2;
  sub_216779094((void *)(v11 + 8), "");
  *(void *)(v11 + 32) = 0;
  *(void *)(v11 + 40) = 0;
  JUMPOUT(0x2167A76D0);
}

void sub_2167A7754(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OCompoundProperty::getProperty(int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v9 = a1;
  uint64_t v10 = "OCompoundProperty::getProperty( name)";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)a1 + 4) + 88))(&v7);
  int v4 = *a1;
  *(_DWORD *)a2 = 2;
  sub_216779094((void *)(a2 + 8), "");
  uint64_t v5 = v8;
  *(void *)(a2 + 32) = v7;
  *(void *)(a2 + 40) = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v6 = v8;
    *(_DWORD *)a2 = v4;
    if (v6) {
      sub_216784EC4(v6);
    }
  }
  else
  {
    *(_DWORD *)a2 = v4;
  }
}

void sub_2167A782C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, char a11)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  uint64_t v14 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a11, (uint64_t)v14);
  }
  else {
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v11 = 2;
  sub_216779094((void *)(v11 + 8), "");
  *(void *)(v11 + 32) = 0;
  *(void *)(v11 + 40) = 0;
  JUMPOUT(0x2167A7818);
}

void sub_2167A789C(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OCompoundProperty::getParent(Alembic::Abc::v12::OCompoundProperty *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v9 = this;
  uint64_t v10 = "OCompoundProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 4) + 32))(&v7);
  int v4 = *(_DWORD *)this;
  v6[0] = 1;
  int v6[2] = v4;
  v5[0] = 0;
  uint64_t v5[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(a2, &v7, v6, v5);
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167A7960(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  uint64_t v18 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a15, (uint64_t)v18);
  }
  else {
    sub_21679F9F4((uint64_t)&a15, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v15 = 2;
  sub_216779094((void *)(v15 + 8), "");
  *(void *)(v15 + 32) = 0;
  *(void *)(v15 + 40) = 0;
  JUMPOUT(0x2167A794CLL);
}

void sub_2167A79D0(_Unwind_Exception *a1)
{
}

uint64_t sub_2167A79F0(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int v9 = *(_DWORD *)(a1 + 8);
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v12 = (const void **)v13;
  unsigned int v14 = v9;
  sub_2167898D0(v15, &v12);
  v15[3] = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 1;
  sub_2167877AC((uint64_t)&v12, v13[0]);
  sub_2167A030C(a2, (uint64_t)&v14);
  sub_2167A030C(a3, (uint64_t)&v14);
  sub_2167A030C(a4, (uint64_t)&v14);
  sub_2167A030C(a5, (uint64_t)&v14);
  uint64_t v10 = v14;
  if (v16) {
    sub_216784EC4(v16);
  }
  sub_2167877AC((uint64_t)v15, (void *)v15[1]);
  return v10;
}

void sub_2167A7AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t Alembic::Abc::v12::OObject::OObject(uint64_t a1, uint64_t a2, long long *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  *(_DWORD *)(a1 + 8) = 2;
  sub_216779094((void *)(a1 + 16), "");
  *(void *)a1 = &unk_26C7495D0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  uint64_t v12 = *(std::__shared_weak_count **)(a2 + 48);
  v14[0] = *(void *)(a2 + 40);
  v14[1] = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Abc::v12::OObject::init(a1, (uint64_t)v14, a3, *(_DWORD *)(a2 + 8), a4, a5, a6);
  if (v12) {
    sub_216784EC4(v12);
  }
  return a1;
}

void sub_2167A7BD0(_Unwind_Exception *a1)
{
  if (v3) {
    sub_216784EC4(v3);
  }
  sub_217323D50(v1, v2);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::init(uint64_t a1, uint64_t a2, long long *a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  int v17 = 0;
  uint64_t v18 = 0;
  std::string __dst = &v17;
  int v22 = a4;
  sub_2167898D0((uint64_t *)v23, (const void ***)&__dst);
  uint64_t v23[3] = 0;
  uint64_t v24 = 0;
  int v25 = 0;
  uint64_t v26 = 1;
  sub_2167877AC((uint64_t)&__dst, v17);
  sub_2167A030C(a5, (uint64_t)&v22);
  sub_2167A030C(a6, (uint64_t)&v22);
  sub_2167A030C(a7, (uint64_t)&v22);
  *(_DWORD *)(a1 + 8) = v22;
  v21[3] = (void *)(a1 + 8);
  void v21[4] = "OObject::init()";
  sub_2167A94C0(&__dst, a3, v23);
  (*(void (**)(long long *__return_ptr))(**(void **)a2 + 80))(&v15);
  long long v13 = v15;
  long long v15 = 0uLL;
  unsigned int v14 = *(std::__shared_weak_count **)(a1 + 48);
  *(_OWORD *)(a1 + 40) = v13;
  if (v14)
  {
    sub_216784EC4(v14);
    if (*((void *)&v15 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v15 + 1));
    }
  }
  sub_2167877AC((uint64_t)v21, v21[1]);
  if (v20 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete(__dst);
  }
  if (v24) {
    sub_216784EC4(v24);
  }
  sub_2167877AC((uint64_t)v23, v23[1]);
}

void sub_2167A7D78(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  sub_2167A9470((uint64_t)va);
  uint64_t v8 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v9 = (uint64_t)v8;
    sub_2167A9424(v5);
    sub_21679FA64((uint64_t)va1, v9);
  }
  else
  {
    sub_2167A9424(v5);
    sub_21679F9F4((uint64_t)va1, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A7D44);
}

void sub_2167A7DE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  sub_2167A03C4((uint64_t)va);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OObject::~OObject(Alembic::Abc::v12::OObject *this)
{
  *(void *)this = &unk_26C7495D0;
  int v2 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 39) < 0) {
    operator delete(*((void **)this + 2));
  }
}

{
  void *v1;
  uint64_t vars8;

  Alembic::Abc::v12::OObject::~OObject(this);

  operator delete(v1);
}

uint64_t Alembic::Abc::v12::OObject::getHeader(Alembic::Abc::v12::OObject *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 16))(v1);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E128, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_26798E128))
    {
      uint64_t v3 = operator new(0x48uLL);
      v3[8] = 0;
      v3[7] = 0;
      *(_OWORD *)uint64_t v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *((_OWORD *)v3 + 2) = 0u;
      v3[6] = v3 + 7;
      qword_26798E120 = (uint64_t)v3;
      __cxa_guard_release(&qword_26798E128);
    }
  }
  return qword_26798E120;
}

void sub_2167A7FAC(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OObject::getArchive(Alembic::Abc::v12::OObject *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (int *)((char *)this + 8);
  uint64_t v10 = (char *)this + 8;
  uint64_t v11 = "OObject::getArchive()";
  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 24))(&v8);
    int v5 = *v3;
    *(_DWORD *)a2 = 2;
    sub_216779094((void *)(a2 + 8), "");
    uint64_t v6 = v9;
    *(void *)(a2 + 32) = v8;
    *(void *)(a2 + 40) = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v7 = v9;
      *(_DWORD *)a2 = v5;
      if (v7) {
        sub_216784EC4(v7);
      }
    }
    else
    {
      *(_DWORD *)a2 = v5;
    }
  }
  else
  {
    *(_DWORD *)a2 = 2;
    sub_216779094((void *)(a2 + 8), "");
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
  }
}

void sub_2167A810C(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OObject::getParent(Alembic::Abc::v12::OObject *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (int *)((char *)this + 8);
  uint64_t v11 = (char *)this + 8;
  uint64_t v12 = "OObject::getParent()";
  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 32))(&v9);
    int v5 = *v3;
    v8[0] = 1;
    v8[2] = v5;
    v7[0] = 0;
    v7[2] = 0;
    v6[0] = 0;
    int v6[2] = 0;
    sub_2167A5B3C(a2, &v9, v8, v7, v6);
    if (v10) {
      sub_216784EC4(v10);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_216779094((void *)(a2 + 16), "");
    *(void *)a2 = &unk_26C7495D0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
  }
}

void sub_2167A826C(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OObject::getNumChildren(Alembic::Abc::v12::OObject *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48))(v1);
  }
  else {
    return 0;
  }
}

void sub_2167A8324(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OObject::getChildHeader(Alembic::Abc::v12::OObject *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 56))(v1);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_26798E138, memory_order_acquire) & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_26798E138))
    {
      uint64_t v3 = operator new(0x48uLL);
      v3[8] = 0;
      v3[7] = 0;
      *(_OWORD *)uint64_t v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *((_OWORD *)v3 + 2) = 0u;
      v3[6] = v3 + 7;
      qword_26798E130 = (uint64_t)v3;
      __cxa_guard_release(&qword_26798E138);
    }
  }
  return qword_26798E130;
}

void sub_2167A8438(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OObject::getChildHeader(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 64))(v1);
  }
  else {
    return 0;
  }
}

void sub_2167A8504(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OObject::getChild(Alembic::Abc::v12::OObject *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (int *)((char *)this + 8);
  uint64_t v13 = (char *)this + 8;
  uint64_t v14 = "OObject::getChild( idx)";
  uint64_t v4 = (Alembic::AbcCoreAbstract::v12::ObjectWriter *)*((void *)this + 5);
  if (v4)
  {
    Alembic::AbcCoreAbstract::v12::ObjectWriter::getChild(v4);
    uint64_t v9 = v11;
    uint64_t v10 = v12;
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v5 = *v3;
    v8[0] = 1;
    v8[2] = v5;
    v7[0] = 0;
    v7[2] = 0;
    v6[0] = 0;
    int v6[2] = 0;
    sub_2167A5B3C(a2, &v9, v8, v7, v6);
    if (v10) {
      sub_216784EC4(v10);
    }
    if (v12) {
      sub_216784EC4(v12);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_216779094((void *)(a2 + 16), "");
    *(void *)a2 = &unk_26C7495D0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
  }
}

void sub_2167A8674(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OObject::getChild(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = (int *)(a1 + 8);
  uint64_t v11 = a1 + 8;
  uint64_t v12 = "OObject::getChild( name)";
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 72))(&v9);
    int v5 = *v3;
    v8[0] = 1;
    v8[2] = v5;
    v7[0] = 0;
    v7[2] = 0;
    v6[0] = 0;
    int v6[2] = 0;
    sub_2167A5B3C(a2, &v9, v8, v7, v6);
    if (v10) {
      sub_216784EC4(v10);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 2;
    sub_216779094((void *)(a2 + 16), "");
    *(void *)a2 = &unk_26C7495D0;
    *(void *)(a2 + 40) = 0;
    *(void *)(a2 + 48) = 0;
  }
}

void sub_2167A87D4(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OObject::getProperties(Alembic::Abc::v12::OObject *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v8 = (char *)this + 8;
  uint64_t v9 = "OObject::getProperties()";
  uint64_t v3 = *((void *)this + 5);
  if (v3)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v3 + 40))(&v6);
    v5[0] = 0;
    uint64_t v5[2] = 0;
    v4[0] = 0;
    int v4[2] = 0;
    Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(a2, &v6, 0, v5, v4);
    if (v7) {
      sub_216784EC4(v7);
    }
  }
  else
  {
    *(_DWORD *)a2 = 2;
    sub_216779094((void *)(a2 + 8), "");
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
  }
}

void sub_2167A8908(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OObject::addChildInstance(Alembic::Abc::v12::OObject *this, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a2 + 39) < 0)
  {
    if (!*(void *)(a2 + 24)) {
      goto LABEL_5;
    }
    return 0;
  }
  if (*(unsigned char *)(a2 + 39)) {
    return 0;
  }
LABEL_5:
  if (!*(void *)(a2 + 40) || !*((void *)this + 5)) {
    return 0;
  }
  uint64_t v6 = *(unsigned __int8 *)(a3 + 23);
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a3 + 8);
  }
  if (!v6) {
    return 0;
  }
  Alembic::Abc::v12::OObject::getArchive(this, (uint64_t)&v55);
  Alembic::Abc::v12::OArchive::getName((Alembic::Abc::v12::OArchive *)&v55, (uint64_t)&__dst);
  Alembic::Abc::v12::OObject::getArchive((Alembic::Abc::v12::OObject *)a2, (uint64_t)v60);
  Alembic::Abc::v12::OArchive::getName((Alembic::Abc::v12::OArchive *)v60, (uint64_t)&v61);
  if (v64 >= 0) {
    uint64_t v7 = HIBYTE(v64);
  }
  else {
    uint64_t v7 = *((void *)&__dst + 1);
  }
  uint64_t v8 = HIBYTE(v62);
  int v9 = SHIBYTE(v62);
  if (v62 < 0) {
    uint64_t v8 = *((void *)&v61 + 1);
  }
  if (v7 == v8)
  {
    if (v62 >= 0) {
      uint64_t v10 = (unsigned __int8 *)&v61;
    }
    else {
      uint64_t v10 = (unsigned __int8 *)v61;
    }
    if (v64 < 0)
    {
      BOOL v16 = memcmp((const void *)__dst, v10, *((size_t *)&__dst + 1)) != 0;
    }
    else if (HIBYTE(v64))
    {
      uint64_t v11 = HIBYTE(v64) - 1;
      p_dst = (unsigned __int8 *)&__dst;
      do
      {
        int v14 = *p_dst++;
        int v13 = v14;
        int v15 = *v10++;
        BOOL v16 = v13 != v15;
      }
      while (v13 == v15 && v11-- != 0);
    }
    else
    {
      BOOL v16 = 0;
    }
  }
  else
  {
    BOOL v16 = 1;
  }
  if (v9 < 0) {
    operator delete((void *)v61);
  }
  Alembic::Abc::v12::OArchive::~OArchive((Alembic::Abc::v12::OArchive *)v60);
  if (SHIBYTE(v64) < 0) {
    operator delete((void *)__dst);
  }
  Alembic::Abc::v12::OArchive::~OArchive((Alembic::Abc::v12::OArchive *)&v55);
  if (v16) {
    return 0;
  }
  uint64_t v18 = Alembic::Abc::v12::OObject::getHeader((Alembic::Abc::v12::OObject *)a2) + 48;
  sub_216779094(v60, "isInstance");
  sub_21679F2AC(v18, (const void **)&v60[0].__r_.__value_.__l.__data_, &v55);
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0)
  {
    BOOL v19 = v55.__r_.__value_.__l.__size_ == 1 && *v55.__r_.__value_.__l.__data_ == 49;
    operator delete(v55.__r_.__value_.__l.__data_);
  }
  else
  {
    BOOL v19 = SHIBYTE(v55.__r_.__value_.__r.__words[2]) == 1 && v55.__r_.__value_.__s.__data_[0] == 49;
  }
  if (SHIBYTE(v60[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v60[0].__r_.__value_.__l.__data_);
  }
  if (v19) {
    return 0;
  }
  uint64_t Header = Alembic::Abc::v12::OObject::getHeader((Alembic::Abc::v12::OObject *)a2);
  if (*(char *)(Header + 47) < 0)
  {
    sub_216778F24(&__dst, *(void **)(Header + 24), *(void *)(Header + 32));
  }
  else
  {
    long long __dst = *(_OWORD *)(Header + 24);
    uint64_t v64 = *(void *)(Header + 40);
  }
  uint64_t v23 = Alembic::Abc::v12::OObject::getHeader(this);
  uint64_t v24 = v23;
  if (*(char *)(v23 + 47) >= 0) {
    size_t v25 = *(unsigned __int8 *)(v23 + 47);
  }
  else {
    size_t v25 = *(void *)(v23 + 32);
  }
  uint64_t v26 = &v55;
  sub_2167940B4((uint64_t)&v55, v25 + 1);
  if ((v55.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v26 = (std::string *)v55.__r_.__value_.__r.__words[0];
  }
  if (v25)
  {
    if (*(char *)(v24 + 47) >= 0) {
      uint64_t v27 = (const void *)(v24 + 24);
    }
    else {
      uint64_t v27 = *(const void **)(v24 + 24);
    }
    memmove(v26, v27, v25);
  }
  *(_WORD *)((char *)&v26->__r_.__value_.__l.__data_ + v25) = 47;
  int v28 = *(char *)(a3 + 23);
  if (v28 >= 0) {
    long long v29 = (const std::string::value_type *)a3;
  }
  else {
    long long v29 = *(const std::string::value_type **)a3;
  }
  if (v28 >= 0) {
    std::string::size_type v30 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v30 = *(void *)(a3 + 8);
  }
  int v31 = std::string::append(&v55, v29, v30);
  long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  int64_t v62 = v31->__r_.__value_.__r.__words[2];
  long long v61 = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v55.__r_.__value_.__l.__data_);
  }
  if (v64 >= 0) {
    size_t v33 = HIBYTE(v64);
  }
  else {
    size_t v33 = *((void *)&__dst + 1);
  }
  int64_t v34 = v58;
  sub_2167940B4((uint64_t)v58, v33 + 1);
  if ((v59 & 0x80u) != 0) {
    int64_t v34 = (void **)v58[0];
  }
  if (v33)
  {
    if (v64 >= 0) {
      int v35 = &__dst;
    }
    else {
      int v35 = (long long *)__dst;
    }
    memmove(v34, v35, v33);
  }
  *(_WORD *)((char *)v34 + v33) = 47;
  uint64_t v36 = HIBYTE(v62);
  if (v62 >= 0) {
    uint64_t v37 = (char *)&v61;
  }
  else {
    uint64_t v37 = (char *)v61;
  }
  if ((v59 & 0x80u) == 0) {
    unint64_t v38 = v58;
  }
  else {
    unint64_t v38 = (void **)v58[0];
  }
  if ((v59 & 0x80u) == 0) {
    int64_t v39 = v59;
  }
  else {
    int64_t v39 = (int64_t)v58[1];
  }
  if (v39)
  {
    if (v62 < 0) {
      uint64_t v36 = *((void *)&v61 + 1);
    }
    if (v36 >= v39)
    {
      uint64_t v40 = &v37[v36];
      int v41 = *(char *)v38;
      char v42 = v37;
      do
      {
        uint64_t v43 = v36 - v39;
        if (v43 == -1) {
          break;
        }
        unsigned __int8 v44 = (char *)memchr(v42, v41, v43 + 1);
        if (!v44) {
          break;
        }
        long long v45 = v44;
        if (!memcmp(v44, v38, v39))
        {
          if (v45 == v40 || v45 != v37) {
            break;
          }
          goto LABEL_108;
        }
        char v42 = v45 + 1;
        uint64_t v36 = v40 - (v45 + 1);
      }
      while (v36 >= v39);
    }
    v57[2] = (void *)((char *)this + 8);
    v57[3] = "OObject::addChildInstance()";
    v57[0] = 0;
    v57[1] = 0;
    uint64_t v56 = (uint64_t *)v57;
    sub_216779094(&v55, "isInstance");
    sub_216779094(v60, "1");
    sub_2167A9088(&v56, (long long *)&v55, v60);
    if (SHIBYTE(v60[0].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v60[0].__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v55.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v55.__r_.__value_.__l.__data_);
    }
    sub_2167A90D4((uint64_t)v54, (uint64_t)this);
    LODWORD(v60[0].__r_.__value_.__l.__data_) = 3;
    v60[0].__r_.__value_.__l.__size_ = (std::string::size_type)&v56;
    LODWORD(__p) = 0;
    int v49 = 0;
    int v52 = 0;
    int v53 = 0;
    Alembic::Abc::v12::OObject::OObject((uint64_t)&v55, (uint64_t)v54, (long long *)a3, v60, &__p, &v52);
    Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)v54);
    Alembic::Abc::v12::OObject::getProperties((Alembic::Abc::v12::OObject *)&v55, (uint64_t)v51);
    sub_216779094(&__p, ".instanceSource");
    int v52 = 0;
    int v53 = 0;
    v47[0] = 0;
    v47[2] = 0;
    v46[0] = 0;
    v46[2] = 0;
    sub_2167A9570((uint64_t)v60, v51, (uint64_t)&__p, &v52, v47, v46);
    if (v50 < 0) {
      operator delete(__p);
    }
    Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v51);
    Alembic::Abc::v12::OScalarProperty::set((Alembic::Abc::v12::OScalarProperty *)v60, &__dst);
    Alembic::Abc::v12::OScalarProperty::~OScalarProperty((Alembic::Abc::v12::OScalarProperty *)v60);
    Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&v55);
    sub_2167877AC((uint64_t)&v56, v57[0]);
    uint64_t v20 = 1;
  }
  else
  {
LABEL_108:
    uint64_t v20 = 0;
  }
  if ((char)v59 < 0) {
    operator delete(v58[0]);
  }
  if (SHIBYTE(v62) < 0) {
    operator delete((void *)v61);
  }
  if (SHIBYTE(v64) < 0) {
    operator delete((void *)__dst);
  }
  return v20;
}

void sub_2167A8ECC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,void *a46)
{
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty((Alembic::Abc::v12::OScalarProperty *)(v46 - 192));
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&a35);
  sub_2167877AC((uint64_t)&a45, a46);
  int v49 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v46 - 232, (uint64_t)v49);
  }
  else {
    sub_21679F9F4(v46 - 232, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A8E94);
}

void sub_2167A8FBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (*(char *)(v37 - 193) < 0) {
    operator delete(*(void **)(v37 - 216));
  }
  if (*(char *)(v37 - 121) < 0) {
    operator delete(*(void **)(v37 - 144));
  }
  if (*(char *)(v37 - 89) < 0) {
    operator delete(*(void **)(v37 - 112));
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_2167A9088(uint64_t **a1, long long *a2, const std::string *a3)
{
  uint64_t v6 = a2;
  uint64_t v4 = sub_21677B174(a1, (const void **)a2, (uint64_t)&unk_217409916, &v6);
  return std::string::operator=((std::string *)(v4 + 7), a3);
}

uint64_t sub_2167A90D4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  uint64_t v4 = a1 + 16;
  if (*(char *)(a2 + 39) < 0)
  {
    sub_216778F24((unsigned char *)v4, *(void **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v5 = *(_OWORD *)(a2 + 16);
    *(void *)(v4 + 16) = *(void *)(a2 + 32);
    *(_OWORD *)uint64_t v4 = v5;
  }
  *(void *)a1 = &unk_26C7495D0;
  uint64_t v6 = *(void *)(a2 + 48);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a1 + 48) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void Alembic::Abc::v12::OObject::init(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v7 = *(std::__shared_weak_count **)(a2 + 40);
  uint64_t v15 = *(void *)(a2 + 32);
  BOOL v16 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  LODWORD(v13) = 0;
  LODWORD(v14) = 0;
  *(_DWORD *)(a1 + 8) = sub_2167A92F0((uint64_t)&v15, a3, a4, a5, &v13);
  if (v16) {
    sub_216784EC4(v16);
  }
  uint64_t v13 = a1 + 8;
  int v14 = "OObject::init( OArchive)";
  uint64_t v8 = *(void *)(a2 + 32);
  int v9 = *(std::__shared_weak_count **)(a2 + 40);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(long long *__return_ptr))(*(void *)v8 + 32))(&v12);
  long long v10 = v12;
  long long v12 = 0uLL;
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 48);
  *(_OWORD *)(a1 + 40) = v10;
  if (v11)
  {
    sub_216784EC4(v11);
    if (*((void *)&v12 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v12 + 1));
    }
  }
  if (v9) {
    sub_216784EC4(v9);
  }
}

void sub_2167A9260(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  if (v12) {
    sub_216784EC4(v12);
  }
  uint64_t v15 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v16 = (uint64_t)v15;
    sub_2167A9424(v11);
    sub_21679FA64((uint64_t)&a11, v16);
  }
  else
  {
    sub_2167A9424(v11);
    sub_21679F9F4((uint64_t)&a11, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A924CLL);
}

void sub_2167A92BC(_Unwind_Exception *a1)
{
}

uint64_t sub_2167A92F0(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  v13[0] = 0;
  v13[1] = 0;
  long long v12 = (const void **)v13;
  unsigned int v14 = 2;
  sub_2167898D0(v15, &v12);
  v15[3] = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  uint64_t v18 = 1;
  sub_2167877AC((uint64_t)&v12, v13[0]);
  if (v9) {
    sub_216784EC4(v9);
  }
  sub_2167A030C(a2, (uint64_t)&v14);
  sub_2167A030C(a3, (uint64_t)&v14);
  sub_2167A030C(a4, (uint64_t)&v14);
  sub_2167A030C(a5, (uint64_t)&v14);
  uint64_t v10 = v14;
  if (v16) {
    sub_216784EC4(v16);
  }
  sub_2167877AC((uint64_t)v15, (void *)v15[1]);
  return v10;
}

void sub_2167A93F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
  sub_2167877AC((uint64_t)&a10, a11);
  if (v11) {
    sub_216784EC4(v11);
  }
  _Unwind_Resume(a1);
}

void sub_2167A9424(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 48);
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  if (v2) {
    sub_216784EC4(v2);
  }

  JUMPOUT(0x21D4477E0);
}

uint64_t sub_2167A9470(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_2167A94C0(void *__dst, long long *a2, const void ***a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_216778F24(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)long long __dst = v5;
  }
  sub_216779094(__dst + 3, "");
  sub_2167898D0(__dst + 6, a3);
  return __dst;
}

void sub_2167A953C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167A9570(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  long long v12 = (std::__shared_weak_count *)*((void *)a2 + 5);
  uint64_t v16 = *((void *)a2 + 4);
  int v17 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v13 = *a2;
  v15[0] = 1;
  uint64_t v15[2] = v13;
  sub_2167A964C(a1, &v16, a3, v15, a4, a5, a6);
  if (v17) {
    sub_216784EC4(v17);
  }
  return a1;
}

void sub_2167A962C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_216784EC4(a12);
  }
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty(v12);
  _Unwind_Resume(a1);
}

void sub_2167A964C(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t v24 = 0;
  v25[0] = 0;
  uint64_t v23 = (const void **)&v24;
  int v26 = 2;
  sub_2167898D0((uint64_t *)v27, &v23);
  uint64_t v28 = 0;
  long long v29 = 0;
  int v30 = 0;
  uint64_t v31 = 1;
  sub_2167877AC((uint64_t)&v23, v24);
  sub_2167A030C(a4, (uint64_t)&v26);
  sub_2167A030C(a5, (uint64_t)&v26);
  sub_2167A030C(a6, (uint64_t)&v26);
  sub_2167A030C(a7, (uint64_t)&v26);
  *(_DWORD *)a1 = v26;
  v25[33] = a1;
  v25[34] = "OTypedScalarProperty::init()";
  if (!*a2)
  {
    sub_216778A5C((uint64_t)&v23);
    sub_216779180(v25, (uint64_t)"NULL CompoundPropertyWriterPtr", 30);
    std::stringbuf::str();
    sub_216778E70(v22, (long long *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    BOOL v19 = sub_216779038(exception, (uint64_t)v22);
    __cxa_throw(v19, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_2167898D0((uint64_t *)&v23, v27);
  uint64_t v14 = v28;
  int v13 = v29;
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = *a2;
  if (v14)
  {
    (*(void (**)(void **__return_ptr))(*(void *)v15 + 24))(__p);
    (*(void (**)(_OWORD *__return_ptr))(*(void *)__p[0] + 24))(v22);
    (*(void (**)(void, uint64_t))(**(void **)&v22[0] + 48))(*(void *)&v22[0], v14);
    if (*((void *)&v22[0] + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v22[0] + 1));
    }
    if (__p[1]) {
      sub_216784EC4((std::__shared_weak_count *)__p[1]);
    }
    uint64_t v15 = *a2;
  }
  __p[0] = (void *)0x10000000CLL;
  (*(void (**)(_OWORD *__return_ptr))(*(void *)v15 + 96))(v22);
  long long v16 = v22[0];
  v22[0] = 0uLL;
  int v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v22[0] + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v22[0] + 1));
    }
  }
  if (v13) {
    sub_216784EC4(v13);
  }
  sub_2167877AC((uint64_t)&v23, v24);
  if (v29) {
    sub_216784EC4(v29);
  }
  sub_2167877AC((uint64_t)v27, v27[1]);
}

void sub_2167A9928(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v11 = (uint64_t)v10;
    sub_2167A13A4(v6);
    sub_21679FA64(v7 - 160, v11);
  }
  else
  {
    sub_2167A13A4(v6);
    sub_21679F9F4(v7 - 160, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A9874);
}

void sub_2167A9A04(_Unwind_Exception *a1)
{
  sub_2167A03C4(v1 - 144);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OScalarProperty::OScalarProperty(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v16 = *a2;
  uint64_t v17 = (std::__shared_weak_count *)a2[1];
  v19[0] = v16;
  v19[1] = v17;
  if (v17) {
    atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::Abc::v12::OScalarProperty::init(a1, (uint64_t)v19, a3, a4, a5, a6, a7, a8);
  if (v17) {
    sub_216784EC4(v17);
  }
  return a1;
}

void sub_2167A9B10(_Unwind_Exception *a1)
{
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OScalarProperty::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  v22[0] = 0;
  v22[1] = 0;
  char v21 = (const void **)v22;
  int v23 = 2;
  sub_2167898D0(v24, &v21);
  uint64_t v25 = 0;
  int v26 = 0;
  int v27 = 0;
  uint64_t v28 = 1;
  sub_2167877AC((uint64_t)&v21, v22[0]);
  sub_2167A030C(a5, (uint64_t)&v23);
  sub_2167A030C(a6, (uint64_t)&v23);
  sub_2167A030C(a7, (uint64_t)&v23);
  sub_2167A030C(a8, (uint64_t)&v23);
  *(_DWORD *)a1 = v23;
  char v21 = (const void **)a1;
  v22[0] = "OScalarProperty::init(p, n)";
  uint64_t v15 = v25;
  uint64_t v14 = v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v15)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)a2 + 24))(&v18);
    (*(void (**)(long long *__return_ptr))(*(void *)v18 + 24))(&v20);
    (*(void (**)(void, uint64_t))(*(void *)v20 + 48))(v20, v15);
    if (*((void *)&v20 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v20 + 1));
    }
    if (v19) {
      sub_216784EC4(v19);
    }
  }
  (*(void (**)(long long *__return_ptr))(**(void **)a2 + 96))(&v20);
  long long v16 = v20;
  long long v20 = 0uLL;
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v20 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v20 + 1));
    }
  }
  if (v14) {
    sub_216784EC4(v14);
  }
  if (v26) {
    sub_216784EC4(v26);
  }
  sub_2167877AC((uint64_t)v24, (void *)v24[1]);
}

void sub_2167A9D68(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, char a14)
{
  if (a12) {
    sub_216784EC4(a12);
  }
  if (a10) {
    sub_216784EC4(a10);
  }
  if (v15) {
    sub_216784EC4(v15);
  }
  uint64_t v18 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v19 = (uint64_t)v18;
    sub_2167A13A4(v14);
    sub_21679FA64((uint64_t)&a14, v19);
  }
  else
  {
    sub_2167A13A4(v14);
    sub_21679F9F4((uint64_t)&a14, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A9D30);
}

void sub_2167A9DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_2167A03C4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Alembic::Abc::v12::OScalarProperty::OScalarProperty(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)a2 + 5);
  v18[0] = *((void *)a2 + 4);
  v18[1] = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v15 = *a2;
  v17[0] = 1;
  v17[2] = v15;
  Alembic::Abc::v12::OScalarProperty::init(a1, (uint64_t)v18, a3, a4, v17, a5, a6, a7);
  if (v14) {
    sub_216784EC4(v14);
  }
  return a1;
}

void sub_2167A9F18(_Unwind_Exception *a1)
{
  if (v2) {
    sub_216784EC4(v2);
  }
  sub_2167A0790(v1);
  _Unwind_Resume(a1);
}

void Alembic::Abc::v12::OScalarProperty::~OScalarProperty(Alembic::Abc::v12::OScalarProperty *this)
{
  int v2 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v2) {
    sub_216784EC4(v2);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t Alembic::Abc::v12::OScalarProperty::getNumSamples(Alembic::Abc::v12::OScalarProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 80))(*((void *)this + 4));
}

void sub_2167A9FD8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167A9FC8);
}

void sub_2167AA010(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OScalarProperty::set(Alembic::Abc::v12::OScalarProperty *this, const void *a2)
{
  return (*(uint64_t (**)(void, const void *))(**((void **)this + 4) + 64))(*((void *)this + 4), a2);
}

void sub_2167AA088(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167AA078);
}

void sub_2167AA0BC(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OScalarProperty::setFromPrevious(Alembic::Abc::v12::OScalarProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 72))(*((void *)this + 4));
}

void sub_2167AA134(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167AA124);
}

void sub_2167AA168(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OScalarProperty::setTimeSampling(Alembic::Abc::v12::OScalarProperty *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 88))(*((void *)this + 4));
}

void sub_2167AA1E0(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167AA1D0);
}

void sub_2167AA214(_Unwind_Exception *a1)
{
}

uint64_t Alembic::Abc::v12::OScalarProperty::setTimeSampling(uint64_t a1, void *a2)
{
  uint64_t v12 = a1;
  int v13 = "OScalarProperty::setTimeSampling()";
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 32) + 32))(&v6);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v6 + 24))(&v8);
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v8 + 24))(&v10);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)v10 + 48))(v10, *a2);
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v9) {
    sub_216784EC4(v9);
  }
  if (v7) {
    sub_216784EC4(v7);
  }
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 32) + 88))(*(void *)(a1 + 32), v4);
}

void sub_2167AA370(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  long long v16 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v14 - 32, (uint64_t)v16);
  }
  else {
    sub_21679F9F4(v14 - 32, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167AA360);
}

void sub_2167AA3F8(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::OScalarProperty::getParent(Alembic::Abc::v12::OScalarProperty *this@<X0>, uint64_t a2@<X8>)
{
  int v9 = this;
  uint64_t v10 = "OScalarProperty::getParent()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 4) + 32))(&v7);
  int v4 = *(_DWORD *)this;
  v6[0] = 1;
  int v6[2] = v4;
  v5[0] = 0;
  uint64_t v5[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(a2, &v7, v6, v5);
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167AA4BC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, char a15)
{
  if (a14) {
    sub_216784EC4(a14);
  }
  uint64_t v18 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a15, (uint64_t)v18);
  }
  else {
    sub_21679F9F4((uint64_t)&a15, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v15 = 2;
  sub_216779094((void *)(v15 + 8), "");
  *(void *)(v15 + 32) = 0;
  *(void *)(v15 + 40) = 0;
  JUMPOUT(0x2167AA4A8);
}

void sub_2167AA52C(_Unwind_Exception *a1)
{
}

void Alembic::Abc::v12::SetReference(uint64_t **a1)
{
  sub_216779094(v4, "reference");
  sub_216779094(&__p, "1");
  uint64_t v6 = v4;
  int v2 = sub_21677B174(a1, (const void **)v4, (uint64_t)&unk_217409917, (long long **)&v6);
  std::string::operator=((std::string *)(v2 + 7), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v5 < 0) {
    operator delete(v4[0]);
  }
}

void sub_2167AA5E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL Alembic::Abc::v12::isReference(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  sub_216779094(__p, "reference");
  sub_21679F2AC(v1, (const void **)__p, v6);
  if (v7 < 0)
  {
    BOOL v2 = v6[1] == (void *)1 && *(unsigned char *)v6[0] == 49;
    operator delete(v6[0]);
  }
  else
  {
    BOOL v2 = v7 == 1 && LOBYTE(v6[0]) == 49;
  }
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167AA6C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::Abc::v12::SetSourceName(uint64_t **a1, const std::string *a2)
{
  sub_216779094(__p, "sourceName");
  char v7 = __p;
  int v4 = sub_21677B174(a1, (const void **)__p, (uint64_t)&unk_217409918, (long long **)&v7);
  std::string::operator=((std::string *)(v4 + 7), a2);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_2167AA760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::Abc::v12::GetSourceName(uint64_t a1@<X0>, void *a2@<X8>)
{
  sub_216779094(__p, "sourceName");
  sub_21679F2AC(a1, (const void **)__p, a2);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_2167AA7D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::AbcCoreFactory::v12::IFactory::IFactory(uint64_t this)
{
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(unsigned char *)this = 1;
  *(void *)(this + 8) = 1;
  *(_DWORD *)(this + 16) = 1;
  *(_DWORD *)(this + 40) = 2;
  return this;
}

{
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(unsigned char *)this = 1;
  *(void *)(this + 8) = 1;
  *(_DWORD *)(this + 16) = 1;
  *(_DWORD *)(this + 40) = 2;
  return this;
}

void Alembic::AbcCoreFactory::v12::IFactory::~IFactory(Alembic::AbcCoreFactory::v12::IFactory *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v1) {
    sub_216784EC4(v1);
  }
}

{
  std::__shared_weak_count *v1;

  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v1) {
    sub_216784EC4(v1);
  }
}

void Alembic::AbcCoreFactory::v12::IFactory::getArchive(uint64_t a1@<X0>, long long *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive((uint64_t)&v23, *(void *)(a1 + 8), *(_DWORD *)(a1 + 16) == 1);
  uint64_t v13 = v23;
  char v14 = v24;
  long long v16 = 0;
  uint64_t v17 = 0;
  std::string __p = 0;
  sub_21679AB00(&__p, v25, (uint64_t)v26, (v26 - (unsigned char *)v25) >> 3);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v12 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_2167AB004((uint64_t)&v18, (uint64_t)&v13, a2, 0, (uint64_t)&v11);
  if (v12) {
    sub_216784EC4(v12);
  }
  if (__p)
  {
    long long v16 = __p;
    operator delete(__p);
  }
  if ((SHIBYTE(v20) & 0x80000000) == 0)
  {
    if (!HIBYTE(v20))
    {
      uint64_t v9 = v21;
      if (v21)
      {
        *a3 = 1;
        int v18 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)a4 = v18;
        *(_OWORD *)(a4 + 8) = *(_OWORD *)__src;
        *(void *)(a4 + 24) = v20;
        goto LABEL_14;
      }
    }
LABEL_16:
    *a3 = 3;
    *(_DWORD *)a4 = 2;
    sub_216779094((void *)(a4 + 8), "");
    *(void *)(a4 + 32) = 0;
    *(void *)(a4 + 40) = 0;
    goto LABEL_17;
  }
  if (__src[1] || !v21) {
    goto LABEL_16;
  }
  *a3 = 1;
  int v18 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)a4 = v18;
  sub_216778F24((unsigned char *)(a4 + 8), __src[0], 0);
  uint64_t v9 = v21;
LABEL_14:
  uint64_t v10 = v22;
  *(void *)(a4 + 32) = v9;
  *(void *)(a4 + 40) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
LABEL_17:
  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&v18);
  if (v25)
  {
    int v26 = v25;
    operator delete(v25);
  }
}

void sub_2167AAA30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, char a16)
{
  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&a16);
  int v18 = *(void **)(v16 - 56);
  if (v18)
  {
    *(void *)(v16 - 48) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

void Alembic::AbcCoreFactory::v12::IFactory::getArchive(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  Alembic::AbcCoreFactory::v12::IFactory::getArchive(a1, a2, &v3, a3);
}

void Alembic::AbcCoreFactory::v12::IFactory::getArchive(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  Alembic::AbcCoreFactory::v12::IFactory::getArchive(a1, a2, &v3, a3);
}

void Alembic::AbcCoreFactory::v12::IFactory::getArchive(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  Alembic::AbcCoreLayer::v12::ReadArchive::ReadArchive((Alembic::AbcCoreLayer::v12::ReadArchive *)&v36);
  size_t v33 = 0;
  int64_t v34 = 0;
  unint64_t v35 = 0;
  uint64_t v8 = *(long long **)a2;
  if (*(void *)a2 == *(void *)(a2 + 8)) {
    goto LABEL_30;
  }
  uint64_t v28 = a3;
  int v32 = 0;
  do
  {
    Alembic::AbcCoreFactory::v12::IFactory::getArchive(a1, v8, &v32, (uint64_t)v29);
    uint64_t v10 = v30;
    uint64_t v9 = v31;
    if (v31)
    {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      sub_216784EC4(v9);
      if (!v10) {
        goto LABEL_19;
      }
      uint64_t v10 = v30;
      uint64_t v11 = v31;
      if (v31) {
        atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      if (!v30) {
        goto LABEL_19;
      }
      uint64_t v11 = 0;
    }
    uint64_t v12 = v34;
    if ((unint64_t)v34 >= v35)
    {
      uint64_t v14 = (v34 - v33) >> 4;
      unint64_t v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) >> 60) {
        sub_21677CB10();
      }
      uint64_t v16 = v35 - (void)v33;
      if ((uint64_t)(v35 - (void)v33) >> 3 > v15) {
        unint64_t v15 = v16 >> 3;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v15;
      }
      v37[4] = &v35;
      int v18 = (char *)sub_216787EE0((uint64_t)&v35, v17);
      uint64_t v19 = &v18[16 * v14];
      v37[0] = v18;
      v37[1] = v19;
      v37[3] = &v18[16 * v20];
      *(void *)uint64_t v19 = v10;
      *((void *)v19 + 1) = v11;
      v37[2] = v19 + 16;
      sub_2167AB184((uint64_t *)&v33, v37);
      uint64_t v13 = v34;
      sub_216788028(v37);
    }
    else
    {
      *(void *)int64_t v34 = v10;
      *((void *)v12 + 1) = v11;
      uint64_t v13 = v12 + 16;
    }
    int64_t v34 = v13;
LABEL_19:
    Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)v29);
    uint64_t v8 = (long long *)((char *)v8 + 24);
  }
  while (v8 != *(long long **)(a2 + 8));
  uint64_t v21 = v33;
  if (v34 - v33 == 16)
  {
    _DWORD *v28 = v32;
    uint64_t v23 = *(void *)v21;
    uint64_t v22 = (std::__shared_weak_count *)*((void *)v21 + 1);
    if (v22) {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v24 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)a4 = 2;
    sub_216779094((void *)(a4 + 8), "");
    *(void *)(a4 + 32) = v23;
    *(void *)(a4 + 40) = v22;
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      *(_DWORD *)a4 = v24;
      uint64_t v25 = v22;
      goto LABEL_34;
    }
    *(_DWORD *)a4 = v24;
    goto LABEL_35;
  }
  a3 = v28;
  if (v33 == v34)
  {
LABEL_30:
    *a3 = 3;
    *(_DWORD *)a4 = 2;
    sub_216779094((void *)(a4 + 8), "");
    *(void *)(a4 + 32) = 0;
    *(void *)(a4 + 40) = 0;
    goto LABEL_35;
  }
  Alembic::AbcCoreLayer::v12::ReadArchive::operator()((uint64_t)&v33, v29);
  _DWORD *v28 = 2;
  long long v26 = v29[0];
  if (*((void *)&v29[0] + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v29[0] + 1) + 8), 1uLL, memory_order_relaxed);
  }
  int v27 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)a4 = 2;
  sub_216779094((void *)(a4 + 8), "");
  *(_OWORD *)(a4 + 32) = v26;
  if (*((void *)&v26 + 1))
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v26 + 1) + 8), 1uLL, memory_order_relaxed);
    *(_DWORD *)a4 = v27;
    sub_216784EC4(*((std::__shared_weak_count **)&v26 + 1));
  }
  else
  {
    *(_DWORD *)a4 = v27;
  }
  uint64_t v25 = (std::__shared_weak_count *)*((void *)&v29[0] + 1);
  if (*((void *)&v29[0] + 1)) {
LABEL_34:
  }
    sub_216784EC4(v25);
LABEL_35:
  *(void *)&v29[0] = &v33;
  sub_216787968((void ***)v29);
}

{
  int v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  void *__p[2];
  char v14;
  uint64_t v15;
  char v16;
  void *v17;
  void *v18;
  uint64_t v19;
  int v20;
  void *__src[2];
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  void *v27;
  unsigned char *v28;

  Alembic::AbcCoreOgawa::v12::ReadArchive::ReadArchive((uint64_t)&v25, a2);
  unint64_t v15 = v25;
  uint64_t v16 = v26;
  int v18 = 0;
  uint64_t v19 = 0;
  unint64_t v17 = 0;
  sub_21679AB00(&v17, v27, (uint64_t)v28, (v28 - (unsigned char *)v27) >> 3);
  sub_216779094(__p, "");
  char v7 = *(_DWORD *)(a1 + 40);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v12 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_2167AB004((uint64_t)&v20, (uint64_t)&v15, (long long *)__p, v7, (uint64_t)&v11);
  if (v12) {
    sub_216784EC4(v12);
  }
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if (v17)
  {
    int v18 = v17;
    operator delete(v17);
  }
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (!HIBYTE(v22))
    {
      uint64_t v9 = v23;
      if (v23)
      {
        *a3 = 1;
        *(_DWORD *)a4 = v20;
        *(_OWORD *)(a4 + 8) = *(_OWORD *)__src;
        *(void *)(a4 + 24) = v22;
        goto LABEL_16;
      }
    }
LABEL_18:
    *a3 = 3;
    *(_DWORD *)a4 = 2;
    sub_216779094((void *)(a4 + 8), "");
    *(void *)(a4 + 32) = 0;
    *(void *)(a4 + 40) = 0;
    goto LABEL_19;
  }
  if (__src[1] || !v23) {
    goto LABEL_18;
  }
  *a3 = 1;
  *(_DWORD *)a4 = v20;
  sub_216778F24((unsigned char *)(a4 + 8), __src[0], 0);
  uint64_t v9 = v23;
LABEL_16:
  uint64_t v10 = v24;
  *(void *)(a4 + 32) = v9;
  *(void *)(a4 + 40) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
LABEL_19:
  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&v20);
  if (v27)
  {
    uint64_t v28 = v27;
    operator delete(v27);
  }
}

void sub_2167AAD78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  if (v18) {
    sub_216784EC4(v18);
  }
  if (a12) {
    sub_216784EC4(a12);
  }
  a11 = (void **)&a18;
  sub_216787968(&a11);
  _Unwind_Resume(a1);
}

void sub_2167AAF9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,char a23)
{
  Alembic::Abc::v12::IArchive::~IArchive((Alembic::Abc::v12::IArchive *)&a23);
  uint64_t v25 = *(void **)(v23 - 56);
  if (v25)
  {
    *(void *)(v23 - 48) = v25;
    operator delete(v25);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_2167AB004(uint64_t a1, uint64_t a2, long long *a3, int a4, uint64_t a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)a1 = a4;
  uint64_t v16 = a1;
  unint64_t v17 = "IArchive::IArchive( iFileName)";
  uint64_t v10 = *(std::__shared_weak_count **)(a5 + 8);
  uint64_t v14 = v10;
  if (v10) {
    atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  Alembic::AbcCoreOgawa::v12::ReadArchive::operator()(a2, a3, &v15);
  long long v11 = v15;
  long long v15 = 0uLL;
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v11;
  if (v12)
  {
    sub_216784EC4(v12);
    if (*((void *)&v15 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v15 + 1));
    }
  }
  if (v14) {
    sub_216784EC4(v14);
  }
  return a1;
}

void sub_2167AB0DC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  uint64_t v16 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v17 = (uint64_t)v16;
    sub_2167A13A4(v13);
    sub_21679FA64((uint64_t)&a13, v17);
  }
  else
  {
    sub_2167A13A4(v13);
    sub_21679F9F4((uint64_t)&a13, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167AB0C0);
}

void sub_2167AB13C(_Unwind_Exception *exception_object)
{
  int v4 = *(std::__shared_weak_count **)(v1 + 40);
  if (v4) {
    sub_216784EC4(v4);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167AB184(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167AB1FC((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_2167AB1FC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_2167AB290((uint64_t)v12);
  return v10;
}

uint64_t sub_2167AB290(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_216787FE4(a1);
  }
  return a1;
}

uint64_t sub_2167AB2C8(uint64_t a1, long long **a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  unint64_t v66 = (std::string *)(a1 + 24);
  *(void *)a1 = &unk_26C749618;
  uint64_t v64 = (uint64_t *)(a1 + 48);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 88), 0);
  *(_OWORD *)(a1 + 152) = 0u;
  int v3 = (void **)(a1 + 176);
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  unint64_t v67 = (uint64_t *)(a1 + 152);
  *(_DWORD *)(a1 + 216) = -1;
  int v4 = operator new(0x48uLL);
  v4[7] = 0;
  v4[8] = 0;
  *(_OWORD *)int v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *((_OWORD *)v4 + 2) = 0u;
  v4[6] = v4 + 7;
  sub_2167AB9DC((void *)(a1 + 200), (uint64_t)v4);
  sub_2167ABA24(v64, a2[1] - *a2);
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (v6 != *a2)
  {
    int64_t v63 = (void *)(a1 + 200);
    while (!*((void *)v6-- - 2))
    {
LABEL_79:
      if (v6 == v5) {
        return a1;
      }
    }
    sub_2167ABAB8(v64, v6);
    if (*(char *)(a1 + 47) < 0)
    {
      if (!*(void *)(a1 + 32))
      {
LABEL_9:
        uint64_t v8 = (*(uint64_t (**)(void))(**(void **)v6 + 16))(*(void *)v6);
        int v9 = *(char *)(v8 + 23);
        if (v9 >= 0) {
          uint64_t v10 = (const std::string::value_type *)v8;
        }
        else {
          uint64_t v10 = *(const std::string::value_type **)v8;
        }
        if (v9 >= 0) {
          std::string::size_type v11 = *(unsigned __int8 *)(v8 + 23);
        }
        else {
          std::string::size_type v11 = *(void *)(v8 + 8);
        }
        std::string::append(v66, v10, v11);
        int v12 = (*(uint64_t (**)(void))(**(void **)v6 + 72))(*(void *)v6);
        if (v12)
        {
          uint64_t v13 = 0;
          do
          {
            long long v14 = v3;
            uint64_t v15 = *(void *)(a1 + 160);
            if (v15 == *(void *)(a1 + 152))
            {
              unint64_t v16 = 0;
              uint64_t v20 = *(void *)(a1 + 160);
            }
            else
            {
              unint64_t v16 = 0;
              unsigned int v17 = 1;
              uint64_t v15 = *(void *)(a1 + 152);
              do
              {
                (*(void (**)(std::string *__return_ptr))(**(void **)v6 + 56))(&__str);
                uint64_t v18 = *(void *)(v15 + 16 * v16);
                std::string::size_type v19 = __str.__r_.__value_.__r.__words[0];
                if (__str.__r_.__value_.__l.__size_) {
                  sub_216784EC4((std::__shared_weak_count *)__str.__r_.__value_.__l.__size_);
                }
                uint64_t v15 = *(void *)(a1 + 152);
                uint64_t v20 = *(void *)(a1 + 160);
                if (v18 == v19) {
                  break;
                }
                unint64_t v16 = v17++;
              }
              while (v16 < (v20 - v15) >> 4);
            }
            if (v16 == (v20 - v15) >> 4)
            {
              int v3 = v14;
              (*(void (**)(long long *__return_ptr))(**(void **)v6 + 56))(&v68);
              uint64_t v22 = *(_OWORD **)(a1 + 160);
              unint64_t v21 = *(void *)(a1 + 168);
              if ((unint64_t)v22 >= v21)
              {
                uint64_t v26 = ((uint64_t)v22 - *v67) >> 4;
                unint64_t v27 = v26 + 1;
                if ((unint64_t)(v26 + 1) >> 60) {
                  sub_21677CB10();
                }
                uint64_t v28 = v21 - *v67;
                if (v28 >> 3 > v27) {
                  unint64_t v27 = v28 >> 3;
                }
                if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v29 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v29 = v27;
                }
                uint64_t v71 = a1 + 168;
                uint64_t v30 = (char *)sub_216787EE0(a1 + 168, v29);
                uint64_t v31 = &v30[16 * v26];
                __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
                __str.__r_.__value_.__l.__size_ = (std::string::size_type)v31;
                unint64_t v70 = &v30[16 * v32];
                *(_OWORD *)uint64_t v31 = v68;
                long long v68 = 0uLL;
                __str.__r_.__value_.__r.__words[2] = (std::string::size_type)(v31 + 16);
                sub_216787E68(v67, &__str);
                uint64_t v33 = *(void *)(a1 + 160);
                sub_216788028((void **)&__str.__r_.__value_.__l.__data_);
                int64_t v34 = (std::__shared_weak_count *)*((void *)&v68 + 1);
                *(void *)(a1 + 160) = v33;
                if (v34) {
                  sub_216784EC4(v34);
                }
              }
              else
              {
                *uint64_t v22 = v68;
                *(void *)(a1 + 160) = v22 + 1;
              }
              uint64_t v35 = (*(uint64_t (**)(void, uint64_t))(**(void **)v6 + 64))(*(void *)v6, v13);
              uint64_t v36 = v35;
              unint64_t v38 = *(uint64_t **)(a1 + 184);
              unint64_t v37 = *(void *)(a1 + 192);
              if ((unint64_t)v38 >= v37)
              {
                uint64_t v40 = (uint64_t *)*v14;
                uint64_t v41 = ((char *)v38 - (unsigned char *)*v14) >> 3;
                unint64_t v42 = v41 + 1;
                if ((unint64_t)(v41 + 1) >> 61) {
                  sub_21677CB10();
                }
                uint64_t v43 = v37 - (void)v40;
                if (v43 >> 2 > v42) {
                  unint64_t v42 = v43 >> 2;
                }
                if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v44 = v42;
                }
                if (v44)
                {
                  long long v45 = (char *)sub_21677CB28(a1 + 192, v44);
                  uint64_t v40 = *(uint64_t **)(a1 + 176);
                  unint64_t v38 = *(uint64_t **)(a1 + 184);
                }
                else
                {
                  long long v45 = 0;
                }
                uint64_t v46 = (uint64_t *)&v45[8 * v41];
                *uint64_t v46 = v36;
                int64_t v39 = v46 + 1;
                while (v38 != v40)
                {
                  uint64_t v47 = *--v38;
                  *--uint64_t v46 = v47;
                }
                *(void *)(a1 + 176) = v46;
                *(void *)(a1 + 184) = v39;
                *(void *)(a1 + 192) = &v45[8 * v44];
                if (v40) {
                  operator delete(v40);
                }
              }
              else
              {
                *unint64_t v38 = v35;
                int64_t v39 = v38 + 1;
              }
              *(void *)(a1 + 184) = v39;
            }
            else
            {
              int v3 = v14;
              uint64_t v23 = *v14;
              uint64_t v24 = (*(uint64_t (**)(void, uint64_t))(**(void **)v6 + 64))(*(void *)v6, v13);
              uint64_t v25 = v23[v16];
              if (v25 <= v24) {
                uint64_t v25 = v24;
              }
              *((void *)*v14 + v16) = v25;
            }
            uint64_t v13 = (v13 + 1);
          }
          while (v13 != v12);
        }
        char v48 = (void *)(*(uint64_t (**)(void))(**(void **)v6 + 24))(*(void *)v6);
        int v49 = v48 + 1;
        char v50 = (void *)*v48;
        if ((void *)*v48 != v48 + 1)
        {
          do
          {
            sub_21679F2AC(*v63 + 48, (const void **)v50 + 4, &__str);
            std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = __str.__r_.__value_.__l.__size_;
            }
            if (size) {
              std::string::append(&__str, " , ");
            }
            int v52 = *((char *)v50 + 79);
            if (v52 >= 0) {
              int v53 = (const std::string::value_type *)(v50 + 7);
            }
            else {
              int v53 = (const std::string::value_type *)v50[7];
            }
            if (v52 >= 0) {
              std::string::size_type v54 = *((unsigned __int8 *)v50 + 79);
            }
            else {
              std::string::size_type v54 = v50[8];
            }
            std::string::append(&__str, v53, v54);
            std::string v55 = (uint64_t **)(*v63 + 48);
            uint64_t v72 = (long long *)(v50 + 4);
            uint64_t v56 = sub_21677B174(v55, (const void **)v50 + 4, (uint64_t)&unk_217409984, &v72);
            std::string::operator=((std::string *)(v56 + 7), &__str);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            uint64_t v57 = (void *)v50[1];
            if (v57)
            {
              do
              {
                uint64_t v58 = v57;
                uint64_t v57 = (void *)*v57;
              }
              while (v57);
            }
            else
            {
              do
              {
                uint64_t v58 = (void *)v50[2];
                BOOL v59 = *v58 == (void)v50;
                char v50 = v58;
              }
              while (!v59);
            }
            char v50 = v58;
          }
          while (v58 != v49);
        }
        int v60 = (*(uint64_t (**)(void))(**(void **)v6 + 80))(*(void *)v6);
        int v61 = *(_DWORD *)(a1 + 216);
        if (v61 <= v60) {
          int v61 = v60;
        }
        *(_DWORD *)(a1 + 216) = v61;
        uint64_t v5 = *a2;
        goto LABEL_79;
      }
    }
    else if (!*(unsigned char *)(a1 + 47))
    {
      goto LABEL_9;
    }
    std::string::append(v66, ",");
    goto LABEL_9;
  }
  return a1;
}

void sub_2167AB8D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, pthread_mutex_t *a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  unint64_t v27 = *(std::__shared_weak_count **)(v25 + 80);
  if (v27) {
    std::__shared_weak_count::__release_weak(v27);
  }
  a17 = a11;
  sub_216787968((void ***)&a17);
  if (*(char *)(v25 + 47) < 0) {
    operator delete(*a13);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v25 + 16);
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)v25);
  _Unwind_Resume(a1);
}

void sub_2167AB9DC(void *a1, uint64_t a2)
{
  sub_216787808(&v5, a2);
  int v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v5;
  *(void *)&long long v5 = *a1;
  *((void *)&v5 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_216784EC4(v3);
  }
}

void **sub_2167ABA24(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      sub_21677CB10();
    }
    uint64_t v5 = a1[1] - *a1;
    _DWORD v7[4] = result;
    v7[0] = sub_216787EE0((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 16 * v6;
    sub_2167AB184(a1, v7);
    return sub_216788028(v7);
  }
  return result;
}

void sub_2167ABAA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216788028((void **)va);
  _Unwind_Resume(a1);
}

void **sub_2167ABAB8(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_21677CB10();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    void v18[4] = result;
    long long v14 = (char *)sub_216787EE0((uint64_t)result, v13);
    uint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)uint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    void v18[2] = v15 + 16;
    sub_2167AB184(a1, v18);
    int v9 = (void *)a1[1];
    uint64_t result = sub_216788028(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    int v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_2167ABBC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216788028((void **)va);
  _Unwind_Resume(a1);
}

void sub_2167ABBD8(uint64_t a1)
{
  *(void *)a1 = &unk_26C749618;
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 208);
  if (v2) {
    sub_216784EC4(v2);
  }
  int v3 = *(void **)(a1 + 176);
  if (v3)
  {
    *(void *)(a1 + 184) = v3;
    operator delete(v3);
  }
  unint64_t v6 = (void **)(a1 + 152);
  sub_216787968(&v6);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 88));
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 80);
  if (v4) {
    std::__shared_weak_count::__release_weak(v4);
  }
  unint64_t v6 = (void **)(a1 + 48);
  sub_216787968(&v6);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  Alembic::AbcCoreAbstract::v12::ArchiveReader::~ArchiveReader((Alembic::AbcCoreAbstract::v12::ArchiveReader *)a1);
}

void sub_2167ABC98(uint64_t a1)
{
  sub_2167ABBD8(a1);

  operator delete(v1);
}

uint64_t sub_2167ABCC0(uint64_t a1)
{
  return a1 + 24;
}

uint64_t sub_2167ABCC8(uint64_t a1)
{
  return *(void *)(a1 + 200) + 48;
}

uint64_t sub_2167ABCD4@<X0>(uint64_t a1@<X0>, uint64_t **a2@<X8>)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 88);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 88));
  *a2 = 0;
  a2[1] = 0;
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 80);
  if (v5)
  {
    unint64_t v6 = std::__shared_weak_count::lock(v5);
    a2[1] = (uint64_t *)v6;
    if (v6)
    {
      uint64_t v7 = *(uint64_t **)(a1 + 72);
      *a2 = v7;
      if (v7) {
        return pthread_mutex_unlock(v4);
      }
    }
  }
  else
  {
    unint64_t v6 = 0;
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  unint64_t v31 = 0;
  sub_2167ABFEC(&v29, (uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 4);
  for (uint64_t i = *(void *)(a1 + 48); i != *(void *)(a1 + 56); i += 16)
  {
    (*(void (**)(std::__shared_count *__return_ptr))(**(void **)i + 32))(&v28);
    int v9 = v30;
    if ((unint64_t)v30 >= v31)
    {
      uint64_t v10 = ((uint64_t)v30 - v29) >> 4;
      unint64_t v11 = v10 + 1;
      if ((unint64_t)(v10 + 1) >> 60) {
        sub_21677CB10();
      }
      uint64_t v12 = v31 - v29;
      if ((uint64_t)(v31 - v29) >> 3 > v11) {
        unint64_t v11 = v12 >> 3;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v11;
      }
      uint64_t v36 = &v31;
      long long v14 = (uint64_t *)sub_216787EE0((uint64_t)&v31, v13);
      uint64_t v15 = (std::__shared_weak_count *)&v14[2 * v10];
      uint64_t v32 = v14;
      uint64_t v33 = v15;
      uint64_t v35 = &v14[2 * v16];
      v15->std::__shared_count = v28;
      std::__shared_count v28 = (std::__shared_count)0;
      p_shared_weak_owners = &v15->__shared_weak_owners_;
      sub_2167AC140(&v29, &v32);
      long long v17 = v30;
      sub_216788028((void **)&v32);
      uint64_t v30 = v17;
      if (v28.__shared_owners_) {
        sub_216784EC4((std::__shared_weak_count *)v28.__shared_owners_);
      }
    }
    else
    {
      *uint64_t v30 = v28;
      uint64_t v30 = v9 + 1;
    }
  }
  uint64_t v18 = operator new(0x118uLL);
  sub_216784F38(&v26, (void *)(a1 + 8));
  std::string::size_type v19 = *(std::__shared_weak_count **)(a1 + 208);
  uint64_t v24 = *(void *)(a1 + 200);
  uint64_t v25 = v19;
  if (v19) {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_2167AEE70(v18, &v26, &v29, &v24);
  sub_2167AC284((uint64_t *)&v32, (uint64_t)v18);
  unint64_t v21 = v32;
  uint64_t v20 = v33;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  *a2 = v21;
  a2[1] = (uint64_t *)v20;
  if (v6)
  {
    sub_216784EC4(v6);
    if (v33) {
      sub_216784EC4(v33);
    }
  }
  if (v25) {
    sub_216784EC4(v25);
  }
  if (v27) {
    sub_216784EC4(v27);
  }
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v22 = *(std::__shared_weak_count **)(a1 + 80);
  *(void *)(a1 + 72) = v21;
  *(void *)(a1 + 80) = v20;
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  uint64_t v32 = &v29;
  sub_216787968((void ***)&v32);
  return pthread_mutex_unlock(v4);
}

void sub_2167ABF48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18)
{
  operator delete(v20);
  a13 = &a15;
  sub_216787968((void ***)&a13);
  if (v19) {
    sub_216784EC4(v19);
  }
  pthread_mutex_unlock(v18);
  _Unwind_Resume(a1);
}

void **sub_2167ABFEC(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      sub_21677CB10();
    }
    uint64_t v5 = a1[1] - *a1;
    _DWORD v7[4] = result;
    v7[0] = sub_216787EE0((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 16 * v6;
    sub_2167AC140(a1, v7);
    return sub_216788028(v7);
  }
  return result;
}

void sub_2167AC06C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216788028((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_2167AC080@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  uint64_t v3 = *(void *)(result + 152);
  if (a2 >= (unint64_t)((*(void *)(result + 160) - v3) >> 4))
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    long long v4 = *(_OWORD *)(v3 + 16 * a2);
    *(_OWORD *)a3 = v4;
    if (*((void *)&v4 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v4 + 1) + 8), 1uLL, memory_order_relaxed);
    }
  }
  return result;
}

double sub_2167AC0BC@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_2167AC0F8(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 176);
  if (a2 >= (unint64_t)((*(void *)(a1 + 184) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

void sub_2167AC11C(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t sub_2167AC128(uint64_t a1)
{
  return (*(void *)(a1 + 160) - *(void *)(a1 + 152)) >> 4;
}

uint64_t sub_2167AC138(uint64_t a1)
{
  return *(unsigned int *)(a1 + 216);
}

uint64_t sub_2167AC140(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167AC1B8((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_2167AC1B8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_2167AC24C((uint64_t)v12);
  return v10;
}

uint64_t sub_2167AC24C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_216787FE4(a1);
  }
  return a1;
}

uint64_t *sub_2167AC284(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  long long v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7496D0;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_2167AC2F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323B20(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167AC310(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_2167AC338(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_2167AC368(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C749720)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

unint64_t sub_2167AC3AC(unint64_t a1, uint64_t *a2, long long **a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C749748;
  uint64_t v5 = *a2;
  *(void *)(a1 + 24) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 32) = v6;
  if (v6)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 120) = 0;
  if (!v5)
  {
    sub_216778A5C((uint64_t)&__p);
    sub_216779180(&v16, (uint64_t)"Invalid object in CprImpl(Object)", 33);
    std::stringbuf::str();
    sub_216778E70(v14, &v12);
    if (v13 < 0) {
      operator delete((void *)v12);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v11 = sub_216779038(exception, (uint64_t)v14);
    __cxa_throw(v11, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  long long __p = 0uLL;
  uint64_t v16 = 0;
  uint64_t v7 = operator new(0x50uLL);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
  sub_21678D40C(v7, &__p, (const void ***)(v8 + 48));
  sub_2167AC610((void *)(a1 + 64), (uint64_t)v7);
  sub_2167AC658(a1, a3);
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)__p);
  }
  return a1;
}

void sub_2167AC554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_216779148(&a12);
  sub_216778D38((uint64_t)&__p);
  sub_21678A498(v22, *(char **)(v21 + 136));
  uint64_t v24 = *(void **)(v21 + 104);
  if (v24)
  {
    *(void *)(v21 + 112) = v24;
    operator delete(v24);
  }
  long long __p = (void *)(v22 - 48);
  sub_2167AD7AC((void ***)&__p);
  uint64_t v25 = *(std::__shared_weak_count **)(v21 + 72);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v21 + 48);
  if (v26) {
    sub_216784EC4(v26);
  }
  unint64_t v27 = *(std::__shared_weak_count **)(v21 + 32);
  if (v27) {
    sub_216784EC4(v27);
  }
  std::__shared_count v28 = *(std::__shared_weak_count **)(v21 + 16);
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader((Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *)v21);
  _Unwind_Resume(a1);
}

void sub_2167AC610(void *a1, uint64_t a2)
{
  sub_2167AD820(&v5, a2);
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  long long v4 = v5;
  *(void *)&long long v5 = *a1;
  *((void *)&v5 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3) {
    sub_216784EC4(v3);
  }
}

unint64_t sub_2167AC658(unint64_t result, long long **a2)
{
  uint64_t v2 = *a2;
  if (*a2 != a2[1])
  {
    uint64_t v3 = (void *)result;
    long long v4 = (uint64_t **)(result + 128);
    long long v5 = (void *)(result + 136);
    uint64_t v6 = (uint64_t *)(result + 80);
    uint64_t v47 = result + 120;
    char v48 = (void **)(result + 104);
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)v2 + 64))();
      if (result)
      {
        for (unint64_t i = 0; i < result; ++i)
        {
          uint64_t v8 = (*(uint64_t (**)(void, unint64_t))(**(void **)v2 + 72))(*(void *)v2, i);
          sub_216779094(__p, "prune");
          sub_21679F2AC(v8 + 32, (const void **)__p, &v51);
          if (v53 < 0)
          {
            BOOL v9 = v52 == 1 && *(unsigned __int8 *)v51 == 49;
            operator delete(v51);
          }
          else
          {
            BOOL v9 = v53 == 1 && v51 == 49;
          }
          if (v50 < 0) {
            operator delete(__p[0]);
          }
          sub_216779094(__p, "replace");
          sub_21679F2AC(v8 + 32, (const void **)__p, &v51);
          if (v53 < 0)
          {
            BOOL v10 = v52 == 1 && *(unsigned __int8 *)v51 == 49;
            operator delete(v51);
          }
          else
          {
            BOOL v10 = v53 == 1 && v51 == 49;
          }
          if (v50 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v11 = sub_21678C2D8((uint64_t)v4, (const void **)v8);
          if (v5 == (void *)v11)
          {
            if (!v9)
            {
              uint64_t v21 = v3[18];
              uint64_t v51 = (long long *)v8;
              sub_21678C138(v4, (const void **)v8, (uint64_t)&unk_217409DA6, &v51)[7] = v21;
              sub_2167AD5E8(v6, v21 + 1);
              sub_2167AD690((uint64_t *)(v3[10] + 24 * v21), v2);
              uint64_t v23 = (char *)v3[14];
              unint64_t v22 = v3[15];
              if ((unint64_t)v23 >= v22)
              {
                uint64_t v36 = (char *)*v48;
                uint64_t v37 = (v23 - (unsigned char *)*v48) >> 4;
                unint64_t v38 = v37 + 1;
                if ((unint64_t)(v37 + 1) >> 60) {
                  sub_21677CB10();
                }
                uint64_t v39 = v22 - (void)v36;
                if (v39 >> 3 > v38) {
                  unint64_t v38 = v39 >> 3;
                }
                if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v40 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v40 = v38;
                }
                if (v40)
                {
                  uint64_t v41 = (char *)sub_216787EE0(v47, v40);
                  uint64_t v36 = (char *)v3[13];
                  uint64_t v23 = (char *)v3[14];
                }
                else
                {
                  uint64_t v41 = 0;
                }
                unint64_t v44 = &v41[16 * v37];
                *(void *)unint64_t v44 = 0;
                *((void *)v44 + 1) = i;
                long long v45 = v44;
                if (v23 != v36)
                {
                  do
                  {
                    *((_OWORD *)v45 - 1) = *((_OWORD *)v23 - 1);
                    v45 -= 16;
                    v23 -= 16;
                  }
                  while (v23 != v36);
                  uint64_t v36 = (char *)*v48;
                }
                uint64_t v24 = v44 + 16;
                v3[13] = v45;
                v3[14] = v44 + 16;
                v3[15] = &v41[16 * v40];
                if (v36) {
                  operator delete(v36);
                }
              }
              else
              {
                *(void *)uint64_t v23 = 0;
                *((void *)v23 + 1) = i;
                uint64_t v24 = v23 + 16;
              }
              v3[14] = v24;
            }
          }
          else
          {
            uint64_t v12 = v11;
            if (v9)
            {
              unint64_t v13 = *(void *)(v11 + 56);
              sub_2167ADF14((uint64_t)&v51, v3[10] + 24 * v13 + 24, v3[11], (uint64_t *)(v3[10] + 24 * v13));
              long long v15 = v14;
              uint64_t v16 = (long long *)v3[11];
              if (v16 != v14)
              {
                do
                {
                  uint64_t v16 = (long long *)((char *)v16 - 24);
                  uint64_t v51 = v16;
                  sub_216787968((void ***)&v51);
                }
                while (v16 != v15);
              }
              v3[11] = v15;
              long long v17 = (void *)v3[14];
              uint64_t v18 = v3[13] + 16 * v13;
              for (uint64_t j = (void *)(v18 + 16); j != v17; j += 2)
              {
                uint64_t v20 = j[1];
                *(j - 2) = *j;
                *(j - 1) = v20;
                v18 += 16;
              }
              v3[14] = v18;
              sub_2167ADFC8(v4, v12);
              unint64_t v31 = (void *)v3[16];
              if (v31 != v5)
              {
                do
                {
                  unint64_t v32 = v31[7];
                  if (v32 > v13) {
                    v31[7] = v32 - 1;
                  }
                  uint64_t v33 = (void *)v31[1];
                  if (v33)
                  {
                    do
                    {
                      int64_t v34 = v33;
                      uint64_t v33 = (void *)*v33;
                    }
                    while (v33);
                  }
                  else
                  {
                    do
                    {
                      int64_t v34 = (void *)v31[2];
                      BOOL v35 = *v34 == (void)v31;
                      unint64_t v31 = v34;
                    }
                    while (!v35);
                  }
                  unint64_t v31 = v34;
                }
                while (v34 != v5);
              }
            }
            else if (*(_DWORD *)(v8 + 24) {
                   || (uint64_t v25 = *(void *)(v11 + 56),
            }
                       uint64_t v26 = 24 * v25,
                       unint64_t v27 = (char *)*v48 + 16 * v25,
                       uint64_t v28 = *(void *)(*(void *)(*v6 + v26) + 16 * *v27),
                       *(_DWORD *)((*(uint64_t (**)(uint64_t, void))(*(void *)v28 + 72))(v28, v27[1]) + 24)))
            {
              uint64_t v29 = *(void *)(v12 + 56);
              sub_2167879BC((uint64_t *)(*v6 + 24 * v29));
              sub_2167AD690((uint64_t *)(*v6 + 24 * v29), v2);
              uint64_t v30 = (char *)*v48 + 16 * v29;
              *uint64_t v30 = 0;
              v30[1] = i;
            }
            else
            {
              uint64_t v42 = *(void *)(v12 + 56);
              if (v10) {
                sub_2167879BC((uint64_t *)(*v6 + 24 * v42));
              }
              sub_2167AD690((uint64_t *)(*v6 + 24 * v42), v2);
              if (*(void *)(v8 + 48))
              {
                uint64_t v43 = (char *)*v48 + 16 * v42;
                *uint64_t v43 = ((uint64_t)(*(void *)(*v6 + 24 * v42 + 8) - *(void *)(*v6 + 24 * v42)) >> 4) - 1;
                v43[1] = i;
              }
            }
          }
          uint64_t result = (*(uint64_t (**)(void))(**(void **)v2 + 64))();
        }
      }
      ++v2;
    }
    while (v2 != a2[1]);
  }
  return result;
}

void sub_2167ACB78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_2167ACB9C(unint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C749748;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  uint64_t v4 = *a2;
  *(void *)(a1 + 40) = *a2;
  uint64_t v5 = a2[1];
  *(void *)(a1 + 48) = v5;
  if (v5)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    uint64_t v4 = *(void *)(a1 + 40);
  }
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 56) = a3;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  if (!v4)
  {
    sub_216778A5C((uint64_t)v31);
    sub_216779180(v32, (uint64_t)"Invalid compound in CprImpl(CprImplPtr, size_t)", 47);
    std::stringbuf::str();
    sub_216778E70(&v28, (long long *)__p);
    if (SHIBYTE(v27) < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v24 = sub_216779038(exception, (uint64_t)&v28);
    __cxa_throw(v24, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v7 = *(void *)(v4 + 24);
  uint64_t v6 = *(void *)(v4 + 32);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 32);
  *(void *)(a1 + 24) = v7;
  *(void *)(a1 + 32) = v6;
  if (v8) {
    sub_216784EC4(v8);
  }
  BOOL v9 = (uint64_t *)(*(void *)(*(void *)(a1 + 40) + 80) + 24 * *(void *)(a1 + 56));
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  v30[0] = 0;
  BOOL v10 = v9 + 1;
  sub_2167ACFB4((uint64_t *)&v28, (v9[1] - *v9) >> 4);
  uint64_t v11 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 72))(*(void *)(a1 + 40), *(void *)(a1 + 56));
  if (*(char *)(v11 + 23) < 0)
  {
    sub_216778F24(__p, *(void **)v11, *(void *)(v11 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)v11;
    uint64_t v27 = *(void *)(v11 + 16);
  }
  for (uint64_t i = *v9; i != *v10; i += 16)
  {
    (*(void (**)(long long *__return_ptr))(**(void **)i + 104))(&v25);
    unint64_t v13 = v29;
    if ((unint64_t)v29 >= v30[0])
    {
      uint64_t v14 = v29 - v28;
      unint64_t v15 = v14 + 1;
      if ((unint64_t)(v14 + 1) >> 60) {
        sub_21677CB10();
      }
      uint64_t v16 = v30[0] - (void)v28;
      if ((uint64_t)(v30[0] - (void)v28) >> 3 > v15) {
        unint64_t v15 = v16 >> 3;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v15;
      }
      v32[2] = v30;
      uint64_t v18 = (char *)sub_216787EE0((uint64_t)v30, v17);
      std::string::size_type v19 = &v18[16 * v14];
      v31[0] = v18;
      v31[1] = v19;
      v32[1] = &v18[16 * v20];
      *(_OWORD *)std::string::size_type v19 = v25;
      long long v25 = 0uLL;
      v32[0] = v19 + 16;
      sub_2167AD918((uint64_t *)&v28, v31);
      uint64_t v21 = v29;
      sub_216788028(v31);
      uint64_t v29 = v21;
      if (*((void *)&v25 + 1)) {
        sub_216784EC4(*((std::__shared_weak_count **)&v25 + 1));
      }
    }
    else
    {
      _OWORD *v29 = v25;
      uint64_t v29 = v13 + 1;
    }
  }
  sub_2167AC658(a1, &v28);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  v31[0] = &v28;
  sub_216787968((void ***)v31);
  return a1;
}

void sub_2167ACEC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  sub_216779148((std::exception *)&a17);
  sub_216778D38((uint64_t)&a21);
  sub_21678A498(v22, *(char **)(v21 + 136));
  uint64_t v24 = *(void **)(v21 + 104);
  if (v24)
  {
    *(void *)(v21 + 112) = v24;
    operator delete(v24);
  }
  sub_2167AD7AC((void ***)&a17);
  long long v25 = *(std::__shared_weak_count **)(v21 + 72);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v21 + 48);
  if (v26) {
    sub_216784EC4(v26);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v21 + 32);
  if (v27) {
    sub_216784EC4(v27);
  }
  uint64_t v28 = *(std::__shared_weak_count **)(v21 + 16);
  if (v28) {
    std::__shared_weak_count::__release_weak(v28);
  }
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader((Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *)v21);
  _Unwind_Resume(a1);
}

void **sub_2167ACFB4(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      sub_21677CB10();
    }
    uint64_t v5 = a1[1] - *a1;
    _DWORD v7[4] = result;
    v7[0] = sub_216787EE0((uint64_t)result, a2);
    v7[1] = (char *)v7[0] + v5;
    v7[2] = (char *)v7[0] + v5;
    v7[3] = (char *)v7[0] + 16 * v6;
    sub_2167AD918(a1, v7);
    return sub_216788028(v7);
  }
  return result;
}

void sub_2167AD034(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216788028((void **)va);
  _Unwind_Resume(a1);
}

void sub_2167AD048(uint64_t a1)
{
  *(void *)a1 = &unk_26C749748;
  sub_21678A498(a1 + 128, *(char **)(a1 + 136));
  uint64_t v2 = *(void **)(a1 + 104);
  if (v2)
  {
    *(void *)(a1 + 112) = v2;
    operator delete(v2);
  }
  uint64_t v7 = (void **)(a1 + 80);
  sub_2167AD7AC(&v7);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_216784EC4(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 48);
  if (v4) {
    sub_216784EC4(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5) {
    sub_216784EC4(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  Alembic::AbcCoreAbstract::v12::CompoundPropertyReader::~CompoundPropertyReader((Alembic::AbcCoreAbstract::v12::CompoundPropertyReader *)a1);
}

void sub_2167AD0F0(uint64_t a1)
{
  sub_2167AD048(a1);

  operator delete(v1);
}

uint64_t sub_2167AD118(uint64_t a1)
{
  if (*(void *)(a1 + 64)) {
    return *(void *)(a1 + 64);
  }
  else {
    return (*(uint64_t (**)(void, void))(**(void **)(a1 + 40) + 72))(*(void *)(a1 + 40), *(void *)(a1 + 56));
  }
}

uint64_t sub_2167AD158(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 104))();
}

uint64_t sub_2167AD180@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 48);
  *a2 = *(void *)(result + 40);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

double sub_2167AD19C@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

unint64_t sub_2167AD1D8(uint64_t a1)
{
  return 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 3);
}

uint64_t sub_2167AD1F4(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[10];
  if (0xAAAAAAAAAAAAAAABLL * ((a1[11] - v2) >> 3) <= a2)
  {
    sub_216778A5C((uint64_t)v10);
    sub_216779180(v11, (uint64_t)"Out of range index in CprImpl::getPropertyHeader: ", 50);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v9, &__p);
    if (v8 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v6 = sub_216779038(exception, (uint64_t)v9);
    __cxa_throw(v6, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v3 = *(uint64_t (**)(void))(**(void **)(*(void *)(v2 + 24 * a2) + 16 * *(void *)(a1[13] + 16 * a2)) + 72);

  return v3();
}

void sub_2167AD318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_2167AD340(uint64_t a1, const void **a2)
{
  uint64_t v3 = sub_21678C2D8(a1 + 128, a2);
  if (a1 + 136 == v3) {
    return 0;
  }
  long long v4 = *(uint64_t (**)(void))(**(void **)(*(void *)(*(void *)(a1 + 80) + 24 * *(void *)(v3 + 56))
                                         + 16 * *(void *)(*(void *)(a1 + 104) + 16 * *(void *)(v3 + 56)))
                           + 72);

  return v4();
}

uint64_t sub_2167AD3DC@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  uint64_t result = sub_21678C2D8(a1 + 128, a2);
  if (a1 + 136 == result)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)(*(void *)(*(void *)(a1 + 80) + 24 * *(void *)(result + 56) + 8)
                                           - 16)
                             + 88);
    return v6();
  }
  return result;
}

uint64_t sub_2167AD474@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  uint64_t result = sub_21678C2D8(a1 + 128, a2);
  if (a1 + 136 == result)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    uint64_t v6 = *(uint64_t (**)(void))(**(void **)(*(void *)(*(void *)(a1 + 80) + 24 * *(void *)(result + 56) + 8)
                                           - 16)
                             + 96);
    return v6();
  }
  return result;
}

void sub_2167AD50C(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = sub_21678C2D8(a1 + 128, a2);
  if (a1 + 136 == v5)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    uint64_t v6 = v5;
    uint64_t v7 = operator new(0x98uLL);
    sub_216784F38(&v8, (void *)(a1 + 8));
    sub_2167ACB9C((unint64_t)v7, &v8, *(void *)(v6 + 56));
    sub_2167ADA5C((uint64_t *)&v10, (uint64_t)v7);
    *(_OWORD *)a3 = v10;
    long long v10 = 0uLL;
    if (v9) {
      sub_216784EC4(v9);
    }
  }
}

void sub_2167AD5B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  operator delete(v10);
  _Unwind_Resume(a1);
}

void sub_2167AD5E8(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = (void **)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_2167ADB84(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 3;
      uint64_t v8 = v3;
      sub_216787968(&v8);
    }
    a1[1] = v7;
  }
}

void **sub_2167AD690(uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v10 = ((uint64_t)v7 - *a1) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_21677CB10();
    }
    uint64_t v12 = v5 - *a1;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v11;
    }
    void v18[4] = result;
    uint64_t v14 = (char *)sub_216787EE0((uint64_t)result, v13);
    unint64_t v15 = &v14[16 * v10];
    v18[0] = v14;
    v18[1] = v15;
    v18[3] = &v14[16 * v16];
    long long v17 = *a2;
    *(_OWORD *)unint64_t v15 = *a2;
    if (*((void *)&v17 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    void v18[2] = v15 + 16;
    sub_2167AD918(a1, v18);
    uint64_t v9 = (void *)a1[1];
    uint64_t result = sub_216788028(v18);
  }
  else
  {
    *uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    v7[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = v7 + 2;
    a1[1] = (uint64_t)(v7 + 2);
  }
  a1[1] = (uint64_t)v9;
  return result;
}

void sub_2167AD798(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_216788028((void **)va);
  _Unwind_Resume(a1);
}

void sub_2167AD7AC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        unint64_t v6 = v4;
        sub_216787968(&v6);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_2167AD820(void *a1, uint64_t a2)
{
  *a1 = a2;
  unint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C749810;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_2167AD880(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_21678D6C0((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167AD8A4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

void sub_2167AD8CC(uint64_t a1)
{
}

uint64_t sub_2167AD8D4(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C749860)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_2167AD918(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167AD990((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_2167AD990(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_2167ADA24((uint64_t)v12);
  return v10;
}

uint64_t sub_2167ADA24(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_216787FE4(a1);
  }
  return a1;
}

uint64_t *sub_2167ADA5C(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  unint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C749888;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_2167ADACC(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323BC8(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167ADAE8(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_2167ADB10(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_2167ADB40(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C7498D8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_2167ADB84(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_21677CB10();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)sub_216782ED8(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    long long v15 = v12;
    uint64_t v16 = &v12[24 * v8];
    uint64_t v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    long long v17 = &v16[v14];
    sub_2167ADCEC(a1, &v15);
    sub_2167ADE8C(&v15);
  }
}

void sub_2167ADCD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_2167ADE8C((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_2167ADCEC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167ADD64((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_2167ADD64(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  void v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_2167ADE08((uint64_t)v11);
  return v9;
}

uint64_t sub_2167ADE08(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_2167ADE40(a1);
  }
  return a1;
}

void sub_2167ADE40(uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    sub_216787968(&v3);
    v1 += 3;
  }
}

void **sub_2167ADE8C(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_2167ADEC0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    sub_216787968(&v5);
  }
}

uint64_t sub_2167ADF14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    sub_2167ADF8C(a4);
    *(_OWORD *)a4 = *(_OWORD *)v5;
    a4[2] = *(void *)(v5 + 16);
    *(void *)uint64_t v5 = 0;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    a4 += 3;
    v5 += 24;
  }
  while (v5 != v6);
  return v6;
}

void sub_2167ADF8C(uint64_t *a1)
{
  if (*a1)
  {
    sub_2167879BC(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t *sub_2167ADFC8(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = sub_2167AE00C(a1, (uint64_t *)a2);
  if (*(char *)(a2 + 55) < 0) {
    operator delete(*(void **)(a2 + 32));
  }
  operator delete((void *)a2);
  return v3;
}

uint64_t *sub_2167AE00C(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  uint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_2167AE080(v6, a2);
  return v3;
}

uint64_t *sub_2167AE080(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  uint64_t v6 = (uint64_t **)v3[2];
  uint64_t v7 = *v6;
  if (*v6 == v3)
  {
    *uint64_t v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      uint64_t v7 = 0;
      uint64_t result = (uint64_t *)v2;
    }
    else
    {
      uint64_t v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    int v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *uint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      long long v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *long long v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        uint64_t result = v7;
      }
      uint64_t v7 = *(uint64_t **)(*v7 + 8);
    }
    long long v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      uint64_t v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *uint64_t v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        uint64_t v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        uint64_t v16 = v7;
      }
      else
      {
        long long v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *uint64_t v24 = v23;
      goto LABEL_72;
    }
    uint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    long long v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      long long v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    uint64_t v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      uint64_t result = v7;
    }
    uint64_t v7 = *(uint64_t **)v12;
  }
  uint64_t v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  uint64_t v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    long long v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    uint64_t v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    void v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    uint64_t *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    uint64_t v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t sub_2167AE404(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C749900;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 48) = *a2;
  uint64_t v6 = a2[1];
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 64) = *a4;
  uint64_t v7 = a4[1];
  *(void *)(a1 + 72) = v7;
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 152), 0);
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 256) = a1 + 264;
  *(void *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 248) = 0;
  if (!*(void *)(a1 + 48))
  {
    sub_216778A5C((uint64_t)v14);
    sub_216779180(v15, (uint64_t)"Invalid archive in OrImpl(Archive)", 34);
    std::stringbuf::str();
    sub_216778E70(v13, &__p);
    if (v12 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v10 = sub_216779038(exception, (uint64_t)v13);
    __cxa_throw(v10, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_2167AE664(a1, a3);
  return a1;
}

void sub_2167AE598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, std::exception a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  sub_216779148(&a12);
  sub_216778D38((uint64_t)&a16);
  sub_21678A498(v18, *(char **)(v16 + 264));
  BOOL v21 = *(std::__shared_weak_count **)(v16 + 248);
  if (v21) {
    std::__shared_weak_count::__release_weak(v21);
  }
  sub_216787968(&a16);
  pthread_mutex_destroy(v17);
  sub_2167B0034(&a16);
  a16 = v19 + 3;
  sub_2167AFF20(&a16);
  a16 = v19;
  sub_216787968(&a16);
  uint64_t v22 = *(std::__shared_weak_count **)(v16 + 72);
  if (v22) {
    sub_216784EC4(v22);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(v16 + 56);
  if (v23) {
    sub_216784EC4(v23);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v16 + 32);
  if (v24) {
    sub_216784EC4(v24);
  }
  uint64_t v25 = *(std::__shared_weak_count **)(v16 + 16);
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader((Alembic::AbcCoreAbstract::v12::ObjectReader *)v16);
  _Unwind_Resume(a1);
}

void **sub_2167AE664(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)a2;
  char v53 = (uint64_t *)(a1 + 216);
  uint64_t result = sub_2167ACFB4((uint64_t *)(a1 + 216), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  if (v4 != *(void **)(a2 + 8))
  {
    uint64_t v6 = (uint64_t *)(a1 + 264);
    std::string v55 = (uint64_t *)(a1 + 104);
    uint64_t v56 = (uint64_t **)(a1 + 256);
    std::string::size_type v54 = (uint64_t *)(a1 + 80);
    do
    {
      (*(void (**)(long long *__return_ptr))(*(void *)*v4 + 40))(&v59);
      int v8 = *(_OWORD **)(a1 + 224);
      unint64_t v7 = *(void *)(a1 + 232);
      if ((unint64_t)v8 >= v7)
      {
        uint64_t v9 = ((uint64_t)v8 - *v53) >> 4;
        unint64_t v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 60) {
          sub_21677CB10();
        }
        uint64_t v11 = v7 - *v53;
        if (v11 >> 3 > v10) {
          unint64_t v10 = v11 >> 3;
        }
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v12 = v10;
        }
        *((void *)&v63 + 1) = a1 + 232;
        long long v13 = (char *)sub_216787EE0(a1 + 232, v12);
        uint64_t v14 = &v13[16 * v9];
        __dst[0] = v13;
        __dst[1] = v14;
        *(void *)&long long v63 = &v13[16 * v15];
        *(_OWORD *)uint64_t v14 = v59;
        long long v59 = 0uLL;
        int64_t v62 = v14 + 16;
        sub_2167AD918(v53, __dst);
        uint64_t v16 = *(void *)(a1 + 224);
        sub_216788028(__dst);
        long long v17 = (std::__shared_weak_count *)*((void *)&v59 + 1);
        *(void *)(a1 + 224) = v16;
        if (v17) {
          sub_216784EC4(v17);
        }
      }
      else
      {
        *int v8 = v59;
        *(void *)(a1 + 224) = v8 + 1;
      }
      uint64_t result = (void **)(*(uint64_t (**)(void))(*(void *)*v4 + 48))();
      if (result)
      {
        for (unint64_t i = 0; i < (unint64_t)result; ++i)
        {
          uint64_t v19 = (*(uint64_t (**)(void, unint64_t))(*(void *)*v4 + 56))(*v4, i);
          uint64_t v20 = v19;
          if (*(char *)(v19 + 23) < 0)
          {
            sub_216778F24(__dst, *(void **)v19, *(void *)(v19 + 8));
          }
          else
          {
            long long v21 = *(_OWORD *)v19;
            int64_t v62 = *(_OWORD **)(v19 + 16);
            *(_OWORD *)long long __dst = v21;
          }
          if (*(char *)(v20 + 47) < 0)
          {
            sub_216778F24(&v63, *(void **)(v20 + 24), *(void *)(v20 + 32));
          }
          else
          {
            long long v22 = *(_OWORD *)(v20 + 24);
            uint64_t v64 = *(void *)(v20 + 40);
            long long v63 = v22;
          }
          sub_2167898D0((uint64_t *)v65, (const void ***)(v20 + 48));
          sub_216779094(__p, "prune");
          sub_21679F2AC((uint64_t)v65, (const void **)__p, &v59);
          if (SHIBYTE(v60) < 0)
          {
            BOOL v23 = *((void *)&v59 + 1) == 1 && *(unsigned char *)v59 == 49;
            operator delete((void *)v59);
          }
          else
          {
            BOOL v23 = SHIBYTE(v60) == 1 && v59 == 49;
          }
          if (v58 < 0) {
            operator delete(__p[0]);
          }
          sub_216779094(__p, "replace");
          sub_21679F2AC((uint64_t)v65, (const void **)__p, &v59);
          if (SHIBYTE(v60) < 0)
          {
            BOOL v24 = *((void *)&v59 + 1) == 1 && *(unsigned __int8 *)v59 == 49;
            operator delete((void *)v59);
          }
          else
          {
            BOOL v24 = SHIBYTE(v60) == 1 && v59 == 49;
          }
          if (v58 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v25 = sub_21678C2D8((uint64_t)v56, (const void **)__dst);
          uint64_t v26 = v25;
          if (v6 == (uint64_t *)v25)
          {
            if (!v23)
            {
              uint64_t v31 = *(void *)(a1 + 272);
              *(void *)&long long v59 = __dst;
              sub_21678C138(v56, (const void **)__dst, (uint64_t)&unk_217409E12, (long long **)&v59)[7] = v31;
              unint64_t v32 = operator new(0x48uLL);
              uint64_t v33 = (uint64_t)v32;
              if (SHIBYTE(v62) < 0)
              {
                sub_216778F24(v32, __dst[0], (unint64_t)__dst[1]);
              }
              else
              {
                *(_OWORD *)unint64_t v32 = *(_OWORD *)__dst;
                v32[2] = v62;
              }
              if (SHIBYTE(v64) < 0)
              {
                sub_216778F24((unsigned char *)(v33 + 24), (void *)v63, *((unint64_t *)&v63 + 1));
              }
              else
              {
                *(_OWORD *)(v33 + 24) = v63;
                *(void *)(v33 + 40) = v64;
              }
              sub_2167898D0((uint64_t *)(v33 + 48), v65);
              sub_216787808(__p, v33);
              sub_216793AD0(v54, (long long *)__p);
              sub_2167AFBF8(v55, v31 + 1);
              uint64_t v49 = *v55;
              uint64_t v50 = v4[1];
              *(void *)&long long v59 = *v4;
              *((void *)&v59 + 1) = v50;
              if (v50) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v50 + 8), 1uLL, memory_order_relaxed);
              }
              unint64_t v60 = i;
              sub_2167AFCA0((uint64_t *)(v49 + 24 * v31), (uint64_t)&v59);
              if (*((void *)&v59 + 1)) {
                sub_216784EC4(*((std::__shared_weak_count **)&v59 + 1));
              }
              sub_2167AFDC8((uint64_t *)(a1 + 128), v31 + 1);
              if (__p[1]) {
                sub_216784EC4((std::__shared_weak_count *)__p[1]);
              }
            }
          }
          else
          {
            unint64_t v27 = *(void *)(v25 + 56);
            if (v23)
            {
              sub_2167B0990((uint64_t)&v59, *(void *)(a1 + 104) + 24 * v27 + 24, *(void *)(a1 + 112), (uint64_t *)(*(void *)(a1 + 104) + 24 * v27));
              uint64_t v29 = v28;
              uint64_t v30 = *(void *)(a1 + 112);
              while (v30 != v29)
              {
                v30 -= 24;
                *(void *)&long long v59 = v30;
                sub_2167AFF94((void ***)&v59);
              }
              *(void *)(a1 + 112) = v29;
              sub_2167B0A44((uint64_t)&v59, (long long *)(*(void *)(a1 + 128) + 16 * v27 + 16), *(long long **)(a1 + 136), *(void *)(a1 + 128) + 16 * v27);
              uint64_t v37 = v36;
              for (uint64_t j = *(void *)(a1 + 136); j != v37; j -= 16)
              {
                uint64_t v39 = *(std::__shared_weak_count **)(j - 8);
                if (v39) {
                  std::__shared_weak_count::__release_weak(v39);
                }
              }
              *(void *)(a1 + 136) = v37;
              sub_2167B0AB0((uint64_t)&v59, (long long *)(*(void *)(a1 + 80) + 16 * v27 + 16), *(long long **)(a1 + 88), *(void *)(a1 + 80) + 16 * v27);
              uint64_t v41 = v40;
              for (uint64_t k = *(void *)(a1 + 88); k != v41; k -= 16)
              {
                uint64_t v43 = *(std::__shared_weak_count **)(k - 8);
                if (v43) {
                  sub_216784EC4(v43);
                }
              }
              *(void *)(a1 + 88) = v41;
              sub_2167ADFC8(v56, v26);
              unint64_t v44 = *v56;
              if (*v56 != v6)
              {
                do
                {
                  unint64_t v45 = v44[7];
                  if (v45 > v27) {
                    v44[7] = v45 - 1;
                  }
                  uint64_t v46 = (uint64_t *)v44[1];
                  if (v46)
                  {
                    do
                    {
                      uint64_t v47 = v46;
                      uint64_t v46 = (uint64_t *)*v46;
                    }
                    while (v46);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v47 = (uint64_t *)v44[2];
                      BOOL v48 = *v47 == (void)v44;
                      unint64_t v44 = v47;
                    }
                    while (!v48);
                  }
                  unint64_t v44 = v47;
                }
                while (v47 != v6);
              }
            }
            else
            {
              if (v24)
              {
                sub_2167AFFE8((uint64_t *)(*v55 + 24 * v27));
                *((void *)&v59 + 1) = 0;
                unint64_t v60 = 0;
                *(void *)&long long v59 = (char *)&v59 + 8;
                int64_t v34 = (uint64_t **)(*(void *)(*v54 + 16 * v27) + 48);
                if (v34 == (uint64_t **)&v59)
                {
                  BOOL v35 = 0;
                }
                else
                {
                  sub_216799C1C(v34, (long long *)((char *)&v59 + 8), (long long *)((char *)&v59 + 8));
                  BOOL v35 = (void *)*((void *)&v59 + 1);
                }
                sub_2167877AC((uint64_t)&v59, v35);
              }
              uint64_t v51 = *v55;
              uint64_t v52 = v4[1];
              *(void *)&long long v59 = *v4;
              *((void *)&v59 + 1) = v52;
              if (v52) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
              }
              unint64_t v60 = i;
              sub_2167AFCA0((uint64_t *)(v51 + 24 * v27), (uint64_t)&v59);
              if (*((void *)&v59 + 1)) {
                sub_216784EC4(*((std::__shared_weak_count **)&v59 + 1));
              }
              sub_2167AFE58(*(void *)(*v54 + 16 * v27) + 48, v65);
            }
          }
          sub_2167877AC((uint64_t)v65, v65[1]);
          if (SHIBYTE(v64) < 0) {
            operator delete((void *)v63);
          }
          if (SHIBYTE(v62) < 0) {
            operator delete(__dst[0]);
          }
          uint64_t result = (void **)(*(uint64_t (**)(void))(*(void *)*v4 + 48))();
        }
      }
      v4 += 2;
    }
    while (v4 != *(void **)(a2 + 8));
  }
  return result;
}

void sub_2167AED40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,std::__shared_weak_count *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41)
{
  if (a25) {
    sub_216784EC4(a25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167AEE74(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C749900;
  *(void *)(a1 + 24) = *a2;
  uint64_t v4 = a2[1];
  *(void *)(a1 + 32) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 40) = a3;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(void *)(a1 + 144) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 152), 0);
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 256) = a1 + 264;
  *(void *)(a1 + 272) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(void *)(a1 + 248) = 0;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5)
  {
    sub_216778A5C((uint64_t)v32);
    sub_216779180(v33, (uint64_t)"Invalid object in OrImpl(OrImplPtr, size_t)", 43);
    std::stringbuf::str();
    sub_216778E70(&v29, (long long *)__p);
    if (v28 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v26 = sub_216779038(exception, (uint64_t)&v29);
    __cxa_throw(v26, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v7 = *(void *)(v5 + 48);
  uint64_t v6 = *(void *)(v5 + 56);
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  int v8 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = v7;
  *(void *)(a1 + 56) = v6;
  if (v8) {
    sub_216784EC4(v8);
  }
  uint64_t v9 = *(void *)(a1 + 40);
  long long v10 = *(_OWORD *)(*(void *)(*(void *)(a1 + 24) + 80) + 16 * v9);
  uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 24) + 80) + 16 * v9 + 8);
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v12 = *(std::__shared_weak_count **)(a1 + 72);
  *(_OWORD *)(a1 + 64) = v10;
  if (v12) {
    sub_216784EC4(v12);
  }
  long long v13 = (uint64_t *)(*(void *)(*(void *)(a1 + 24) + 104) + 24 * *(void *)(a1 + 40));
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  v31[0] = 0;
  sub_2167ABFEC(&v29, 0xAAAAAAAAAAAAAAABLL * ((v13[1] - *v13) >> 3));
  for (uint64_t i = *v13; i != v13[1]; i += 24)
  {
    (*(void (**)(void **__return_ptr))(**(void **)i + 80))(__p);
    uint64_t v15 = v30;
    if ((unint64_t)v30 >= v31[0])
    {
      uint64_t v16 = ((uint64_t)v30 - v29) >> 4;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 60) {
        sub_21677CB10();
      }
      uint64_t v18 = v31[0] - v29;
      if ((v31[0] - v29) >> 3 > v17) {
        unint64_t v17 = v18 >> 3;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      v33[2] = v31;
      uint64_t v20 = (char *)sub_216787EE0((uint64_t)v31, v19);
      long long v21 = &v20[16 * v16];
      v32[0] = v20;
      v32[1] = v21;
      v33[1] = &v20[16 * v22];
      *(_OWORD *)long long v21 = *(_OWORD *)__p;
      __p[0] = 0;
      __p[1] = 0;
      v33[0] = v21 + 16;
      sub_2167AC140(&v29, v32);
      BOOL v23 = v30;
      sub_216788028(v32);
      uint64_t v30 = v23;
      if (__p[1]) {
        sub_216784EC4((std::__shared_weak_count *)__p[1]);
      }
    }
    else
    {
      *uint64_t v30 = *(_OWORD *)__p;
      uint64_t v30 = v15 + 1;
    }
  }
  sub_2167AE664(a1, (uint64_t)&v29);
  v32[0] = &v29;
  sub_216787968((void ***)v32);
  return a1;
}

void sub_2167AF1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, pthread_mutex_t *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  sub_216779148((std::exception *)&a15);
  sub_216778D38((uint64_t)&a19);
  sub_21678A498(v20, *(char **)(v19 + 264));
  BOOL v23 = *(std::__shared_weak_count **)(v19 + 248);
  if (v23) {
    std::__shared_weak_count::__release_weak(v23);
  }
  sub_216787968((void ***)&a15);
  pthread_mutex_destroy(a10);
  a15 = a9;
  sub_2167B0034((void ***)&a15);
  a15 = v21 + 24;
  sub_2167AFF20((void ***)&a15);
  a15 = v21;
  sub_216787968((void ***)&a15);
  BOOL v24 = *(std::__shared_weak_count **)(v19 + 72);
  if (v24) {
    sub_216784EC4(v24);
  }
  uint64_t v25 = *(std::__shared_weak_count **)(v19 + 56);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v26 = *(std::__shared_weak_count **)(v19 + 32);
  if (v26) {
    sub_216784EC4(v26);
  }
  unint64_t v27 = *(std::__shared_weak_count **)(v19 + 16);
  if (v27) {
    std::__shared_weak_count::__release_weak(v27);
  }
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader((Alembic::AbcCoreAbstract::v12::ObjectReader *)v19);
  _Unwind_Resume(a1);
}

void sub_2167AF2C0(uint64_t a1)
{
  *(void *)a1 = &unk_26C749900;
  sub_21678A498(a1 + 256, *(char **)(a1 + 264));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 248);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v7 = (void **)(a1 + 216);
  sub_216787968(&v7);
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 152));
  uint64_t v7 = (void **)(a1 + 128);
  sub_2167B0034(&v7);
  uint64_t v7 = (void **)(a1 + 104);
  sub_2167AFF20(&v7);
  uint64_t v7 = (void **)(a1 + 80);
  sub_216787968(&v7);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3) {
    sub_216784EC4(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 56);
  if (v4) {
    sub_216784EC4(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 32);
  if (v5) {
    sub_216784EC4(v5);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 16);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  Alembic::AbcCoreAbstract::v12::ObjectReader::~ObjectReader((Alembic::AbcCoreAbstract::v12::ObjectReader *)a1);
}

void sub_2167AF3A4(uint64_t a1)
{
  sub_2167AF2C0(a1);

  operator delete(v1);
}

uint64_t sub_2167AF3CC(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t sub_2167AF3D4@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 56);
  *a2 = *(void *)(result + 48);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_2167AF3F0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *a2 = *(void *)(result + 24);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_2167AF40C@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 152);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 152));
  *a2 = 0;
  a2[1] = 0;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 248);
  if (v5)
  {
    uint64_t v6 = std::__shared_weak_count::lock(v5);
    a2[1] = (uint64_t)v6;
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 240);
      *a2 = v7;
      if (v7) {
        return pthread_mutex_unlock(v4);
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  int v8 = operator new(0x98uLL);
  sub_216784F38(&v13, (void *)(a1 + 8));
  sub_2167ACB98((unint64_t)v8, &v13, (long long **)(a1 + 216));
  sub_2167ADA5C(&v15, (uint64_t)v8);
  uint64_t v10 = v15;
  uint64_t v9 = v16;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  *a2 = v10;
  a2[1] = (uint64_t)v9;
  if (v6)
  {
    sub_216784EC4(v6);
    if (v16) {
      sub_216784EC4(v16);
    }
  }
  if (v14) {
    sub_216784EC4(v14);
  }
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 248);
  *(void *)(a1 + 240) = v10;
  *(void *)(a1 + 248) = v9;
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
  return pthread_mutex_unlock(v4);
}

void sub_2167AF518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  operator delete(v12);
  if (v11) {
    sub_216784EC4(v11);
  }
  pthread_mutex_unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_2167AF570(uint64_t a1)
{
  return (uint64_t)(*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 4;
}

uint64_t sub_2167AF580(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 80);
  if (a2 >= (*(void *)(a1 + 88) - v2) >> 4)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Out of range index in OrData::getChildHeader: ", 46);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return *(void *)(v2 + 16 * a2);
}

void sub_2167AF64C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_2167AF674(uint64_t a1, const void **a2)
{
  uint64_t v3 = sub_21678C2D8(a1 + 256, a2);
  if (a1 + 264 == v3) {
    return 0;
  }
  else {
    return *(void *)(*(void *)(a1 + 80) + 16 * *(void *)(v3 + 56));
  }
}

uint64_t sub_2167AF6C0@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t result = sub_21678C2D8(a1 + 256, a2);
  if (a1 + 264 == result)
  {
    *a3 = 0;
    a3[1] = 0;
    return result;
  }
  uint64_t v6 = result;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 152));
  uint64_t v7 = (uint64_t *)(*(void *)(a1 + 128) + 16 * *(void *)(v6 + 56));
  *a3 = 0;
  a3[1] = 0;
  uint64_t v8 = (std::__shared_weak_count *)v7[1];
  if (!v8)
  {
    uint64_t v9 = 0;
LABEL_8:
    uint64_t v11 = operator new(0x118uLL);
    sub_216784F38(&v16, (void *)(a1 + 8));
    sub_2167AEE74((uint64_t)v11, &v16, *(void *)(v6 + 56));
    sub_2167AC284(&v18, (uint64_t)v11);
    uint64_t v13 = v18;
    unint64_t v12 = v19;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    *a3 = v13;
    a3[1] = (uint64_t)v12;
    if (v9)
    {
      sub_216784EC4(v9);
      if (v19) {
        sub_216784EC4(v19);
      }
    }
    if (v17) {
      sub_216784EC4(v17);
    }
    uint64_t v14 = (uint64_t *)(*(void *)(a1 + 128) + 16 * *(void *)(v6 + 56));
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v15 = (std::__shared_weak_count *)v14[1];
    uint64_t *v14 = v13;
    v14[1] = (uint64_t)v12;
    if (v15) {
      std::__shared_weak_count::__release_weak(v15);
    }
    return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 152));
  }
  uint64_t v9 = std::__shared_weak_count::lock(v8);
  a3[1] = (uint64_t)v9;
  if (!v9) {
    goto LABEL_8;
  }
  uint64_t v10 = *v7;
  *a3 = *v7;
  if (!v10) {
    goto LABEL_8;
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 152));
}

void sub_2167AF80C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  operator delete(v12);
  if (v11) {
    sub_216784EC4(v11);
  }
  pthread_mutex_unlock(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_2167AF864@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  if (a2 >= (uint64_t)(*(void *)(result + 88) - *(void *)(result + 80)) >> 4)
  {
    *a3 = 0;
    a3[1] = 0;
    return result;
  }
  uint64_t v5 = result;
  uint64_t v6 = (pthread_mutex_t *)(result + 152);
  pthread_mutex_lock((pthread_mutex_t *)(result + 152));
  uint64_t v7 = (uint64_t *)(*(void *)(v5 + 128) + 16 * a2);
  *a3 = 0;
  a3[1] = 0;
  uint64_t v8 = (std::__shared_weak_count *)v7[1];
  if (!v8)
  {
    uint64_t v9 = 0;
LABEL_8:
    uint64_t v11 = operator new(0x118uLL);
    sub_216784F38(&v16, (void *)(v5 + 8));
    sub_2167AEE74((uint64_t)v11, &v16, a2);
    sub_2167AC284(&v18, (uint64_t)v11);
    uint64_t v13 = v18;
    unint64_t v12 = v19;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    *a3 = v13;
    a3[1] = (uint64_t)v12;
    if (v9)
    {
      sub_216784EC4(v9);
      if (v19) {
        sub_216784EC4(v19);
      }
    }
    if (v17) {
      sub_216784EC4(v17);
    }
    uint64_t v14 = (uint64_t *)(*(void *)(v5 + 128) + 16 * a2);
    if (v12) {
      atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v15 = (std::__shared_weak_count *)v14[1];
    uint64_t *v14 = v13;
    v14[1] = (uint64_t)v12;
    if (v15) {
      std::__shared_weak_count::__release_weak(v15);
    }
    return pthread_mutex_unlock(v6);
  }
  uint64_t v9 = std::__shared_weak_count::lock(v8);
  a3[1] = (uint64_t)v9;
  if (!v9) {
    goto LABEL_8;
  }
  uint64_t v10 = *v7;
  *a3 = *v7;
  if (!v10) {
    goto LABEL_8;
  }
  return pthread_mutex_unlock(v6);
}

void sub_2167AF9A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  operator delete(v12);
  if (v11) {
    sub_216784EC4(v11);
  }
  pthread_mutex_unlock(v10);
  _Unwind_Resume(a1);
}

double sub_2167AF9FC@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  sub_216784F38(&v4, (void *)(a1 + 8));
  double result = *(double *)&v4;
  *a2 = v4;
  return result;
}

uint64_t sub_2167AFA38(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  long long v4 = (uint64_t *)(*(void *)(v2 + 104) + 24 * *(void *)(a1 + 40));
  uint64_t v3 = *v4;
  if (v4[1] - *v4 != 24) {
    return 0;
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)v3 + 80))(&v8);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 88))(v8, a2);
  if (v9) {
    sub_216784EC4(v9);
  }
  return v6;
}

void sub_2167AFB00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167AFB18(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    return 0;
  }
  long long v4 = (uint64_t *)(*(void *)(v2 + 104) + 24 * *(void *)(a1 + 40));
  uint64_t v3 = *v4;
  if (v4[1] - *v4 != 24) {
    return 0;
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)v3 + 80))(&v8);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 96))(v8, a2);
  if (v9) {
    sub_216784EC4(v9);
  }
  return v6;
}

void sub_2167AFBE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167AFBF8(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = (void **)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_2167B00D4(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 3;
      uint64_t v8 = v3;
      sub_2167AFF94(&v8);
    }
    a1[1] = v7;
  }
}

void **sub_2167AFCA0(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  double result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = (unint64_t)*(result - 1);
  if (v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_21677CB10();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    uint64_t v13 = (char *)sub_216782ED8((uint64_t)result, v12);
    uint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    void v16[2] = v14 + 24;
    sub_2167B0464(a1, v16);
    uint64_t v8 = a1[1];
    double result = sub_2167B05F4(v16);
  }
  else
  {
    *(_OWORD *)unint64_t v7 = *(_OWORD *)a2;
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(v7 + 16) = *(void *)(a2 + 16);
    uint64_t v8 = v7 + 24;
    a1[1] = v7 + 24;
  }
  a1[1] = v8;
  return result;
}

void sub_2167AFDB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_2167B05F4((void **)va);
  _Unwind_Resume(a1);
}

void sub_2167AFDC8(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 4;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v6 = *a1 + 16 * a2;
      while (v3 != v6)
      {
        unint64_t v7 = *(std::__shared_weak_count **)(v3 - 8);
        if (v7) {
          std::__shared_weak_count::__release_weak(v7);
        }
        v3 -= 16;
      }
      a1[1] = v6;
    }
  }
  else
  {
    unint64_t v5 = a2 - v4;
    sub_2167B067C(a1, v5);
  }
}

uint64_t sub_2167AFE58(uint64_t result, void *a2)
{
  uint64_t v2 = a2 + 1;
  uint64_t v3 = (void *)*a2;
  if ((void *)*a2 != a2 + 1)
  {
    unint64_t v4 = (uint64_t **)result;
    do
    {
      double result = sub_21677B088((uint64_t)v4, (const void **)v3 + 4);
      if (!result)
      {
        unint64_t v9 = (long long *)(v3 + 4);
        unint64_t v5 = sub_21677B174(v4, (const void **)v3 + 4, (uint64_t)&unk_217409E12, &v9);
        double result = (uint64_t)std::string::operator=((std::string *)(v5 + 7), (const std::string *)(v3 + 7));
      }
      uint64_t v6 = (void *)v3[1];
      if (v6)
      {
        do
        {
          unint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          unint64_t v7 = (void *)v3[2];
          BOOL v8 = *v7 == (void)v3;
          uint64_t v3 = v7;
        }
        while (!v8);
      }
      uint64_t v3 = v7;
    }
    while (v7 != v2);
  }
  return result;
}

void sub_2167AFF20(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        sub_2167AFF94(&v6);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_2167AFF94(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_2167AFFE8((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_2167AFFE8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    unint64_t v4 = *(std::__shared_weak_count **)(i - 16);
    if (v4) {
      sub_216784EC4(v4);
    }
  }
  a1[1] = v2;
}

void sub_2167B0034(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_2167B0088((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_2167B0088(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    unint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  a1[1] = v2;
}

void sub_2167B00D4(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_21677CB10();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      unint64_t v12 = (char *)sub_216782ED8(v4, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    uint64_t v16 = &v12[24 * v8];
    uint64_t v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    unint64_t v17 = &v16[v14];
    sub_2167B023C(a1, &v15);
    sub_2167B03DC(&v15);
  }
}

void sub_2167B0228(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_2167B03DC((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_2167B023C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167B02B4((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_2167B02B4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  void v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_2167B0358((uint64_t)v11);
  return v9;
}

uint64_t sub_2167B0358(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_2167B0390(a1);
  }
  return a1;
}

void sub_2167B0390(uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    sub_2167AFF94(&v3);
    v1 += 3;
  }
}

void **sub_2167B03DC(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_2167B0410(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    sub_2167AFF94(&v5);
  }
}

uint64_t sub_2167B0464(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167B04DC((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_2167B04DC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = a7 - 24;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *(void *)(v8 + 16) = a3[2];
      *((void *)&v15 + 1) = v8;
      v8 -= 24;
      v7 -= 24;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_2167B0578((uint64_t)v12);
  return v10;
}

uint64_t sub_2167B0578(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_2167B05B0(a1);
  }
  return a1;
}

void sub_2167B05B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_216784EC4(v3);
    }
    v1 += 24;
  }
}

void **sub_2167B05F4(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_2167B0628(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 24;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 16);
    if (v4)
    {
      sub_216784EC4(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 24;
    }
  }
}

void sub_2167B067C(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - *a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      sub_21677CB10();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - *a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    uint64_t v18 = v4;
    if (v12) {
      char v13 = (char *)sub_216787EE0(v4, v12);
    }
    else {
      char v13 = 0;
    }
    long long v14 = v13;
    long long v15 = &v13[16 * v10];
    unint64_t v17 = &v13[16 * v12];
    bzero(v15, 16 * a2);
    uint64_t v16 = &v15[16 * a2];
    sub_2167B0780(a1, &v14);
    sub_2167B0908(&v14);
  }
}

void sub_2167B076C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_2167B0908((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_2167B0780(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167B07F8((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_2167B07F8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_2167B088C((uint64_t)v12);
  return v10;
}

uint64_t sub_2167B088C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_2167B08C4(a1);
  }
  return a1;
}

void sub_2167B08C4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
    v1 += 16;
  }
}

void **sub_2167B0908(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_2167B093C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_weak(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

uint64_t sub_2167B0990(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    sub_2167B0A08(a4);
    *(_OWORD *)a4 = *(_OWORD *)v5;
    a4[2] = *(void *)(v5 + 16);
    *(void *)uint64_t v5 = 0;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    a4 += 3;
    v5 += 24;
  }
  while (v5 != v6);
  return v6;
}

void sub_2167B0A08(uint64_t *a1)
{
  if (*a1)
  {
    sub_2167AFFE8(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

long long *sub_2167B0A44(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8) {
        std::__shared_weak_count::__release_weak(v8);
      }
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

long long *sub_2167B0AB0(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      long long v7 = *v5;
      *(void *)uint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      uint64_t v8 = *(std::__shared_weak_count **)(a4 + 8);
      *(_OWORD *)a4 = v7;
      if (v8) {
        sub_216784EC4(v8);
      }
      ++v5;
      a4 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

double Alembic::AbcCoreLayer::v12::ReadArchive::operator()@<D0>(uint64_t a1@<X1>, _OWORD *a2@<X8>)
{
  uint64_t v4 = operator new(0xE0uLL);
  sub_2167ABBD4(v4, a1);
  sub_2167B0B94((uint64_t *)&v6, (uint64_t)v4);
  double result = *(double *)&v6;
  *a2 = v6;
  return result;
}

void sub_2167B0B80(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_2167B0B94(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  void *v4 = &unk_26C7499C8;
  v4[1] = 0;
  int v4[2] = 0;
  v4[3] = a2;
  a1[1] = (uint64_t)v4;
  if (a2) {
    uint64_t v5 = (void *)(a2 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  sub_216787B18((uint64_t)a1, v5, a2);
  return a1;
}

void sub_2167B0C04(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_217323C94(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167B0C20(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  operator delete(v1);
}

uint64_t sub_2167B0C48(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_2167B0C78(uint64_t a1, uint64_t a2)
{
  if (sub_21677EC50(a2, (uint64_t)&unk_26C749A18)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void Alembic::AbcCoreLayer::v12::SetPrune(uint64_t **a1, int a2)
{
  if (a2)
  {
    sub_216779094(v5, "prune");
    sub_216779094(&__p, "1");
  }
  else
  {
    sub_216779094(v5, "prune");
    sub_216779094(&__p, "");
  }
  long long v7 = v5;
  uint64_t v3 = sub_21677B174(a1, (const void **)v5, (uint64_t)&unk_217409F42, (long long **)&v7);
  std::string::operator=((std::string *)(v3 + 7), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_2167B0DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::AbcCoreLayer::v12::SetReplace(uint64_t **a1, int a2)
{
  if (a2)
  {
    sub_216779094(v5, "replace");
    sub_216779094(&__p, "1");
  }
  else
  {
    sub_216779094(v5, "replace");
    sub_216779094(&__p, "");
  }
  long long v7 = v5;
  uint64_t v3 = sub_21677B174(a1, (const void **)v5, (uint64_t)&unk_217409F42, (long long **)&v7);
  std::string::operator=((std::string *)(v3 + 7), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_2167B0ED8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::AbcGeom::v12::GetIArchiveBounds(Alembic::Abc::v12::IArchive *a1@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X2>, uint64_t a4@<X8>)
{
  Alembic::Abc::v12::IArchive::getTop(a1, (uint64_t)v9);
  Alembic::Abc::v12::IObject::getProperties((Alembic::Abc::v12::IObject *)v9, (uint64_t)v10);
  sub_216779094(__p, ".childBnds");
  sub_2167B10BC(a4, v10, (uint64_t)__p, a2, a3);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v10);
  Alembic::Abc::v12::IObject::~IObject((Alembic::Abc::v12::IObject *)v9);
}

void sub_2167B0FA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)(v16 - 80));
  Alembic::Abc::v12::IObject::~IObject((Alembic::Abc::v12::IObject *)&a16);
  _Unwind_Resume(a1);
}

void Alembic::AbcGeom::v12::CreateOArchiveBounds(Alembic::Abc::v12::OArchive *a1@<X0>, _DWORD *a2@<X1>, _DWORD *a3@<X2>, _DWORD *a4@<X3>, uint64_t a5@<X8>)
{
  Alembic::Abc::v12::OArchive::getTop(a1, (uint64_t)v11);
  Alembic::Abc::v12::OObject::getProperties((Alembic::Abc::v12::OObject *)v11, (uint64_t)v12);
  sub_216779094(__p, ".childBnds");
  sub_2167B1730(a5, v12, (uint64_t)__p, a2, a3, a4);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v12);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)v11);
}

void sub_2167B1080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)&a22);
  Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_2167B10BC(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v45 + 1) = 0;
  v46[0] = 0;
  *(void *)&long long v45 = (char *)&v45 + 8;
  int v47 = v10;
  sub_2167898D0(v48, (const void ***)&v45);
  v48[3] = 0;
  uint64_t v49 = 0;
  int v50 = 0;
  uint64_t v51 = 1;
  sub_2167877AC((uint64_t)&v45, *((void **)&v45 + 1));
  sub_2167A030C(a4, (uint64_t)&v47);
  sub_2167A030C(a5, (uint64_t)&v47);
  *(_DWORD *)a1 = v47;
  v46[34] = a1;
  v46[35] = "ITypedScalarProperty::ITypedScalarProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v31 = sub_216779180(v46, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v31, (uint64_t)"ITypedScalarProperty ctor", 25);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v33 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v33, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v45);
    int64_t v34 = sub_216779180(v46, (uint64_t)"Nonexistent scalar property: ", 29);
    int v35 = *(char *)(a3 + 23);
    if (v35 >= 0) {
      uint64_t v36 = a3;
    }
    else {
      uint64_t v36 = *(void *)a3;
    }
    if (v35 >= 0) {
      uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v37 = *(void *)(a3 + 8);
    }
    sub_216779180(v34, v36, v37);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    unint64_t v38 = __cxa_allocate_exception(0x20uLL);
    uint64_t v39 = sub_216779038(v38, (uint64_t)__p);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v16 = *(_DWORD *)(v13 + 56) == 11 && *(unsigned char *)(v13 + 60) == 6 && *(_DWORD *)(v13 + 24) == 1;
  if (!v16 || (sub_2167B1640(v13 + 32, v51) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v20 = sub_216779180(v46, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v21 = sub_21677D5B0(v20, (int *)(v14 + 56));
    uint64_t v22 = sub_216779180(v21, (uint64_t)" to expected: ", 14);
    uint64_t v40 = 0x60000000BLL;
    BOOL v23 = sub_21677D5B0(v22, (int *)&v40);
    BOOL v24 = sub_216779180(v23, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v41, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v41, __p);
    if ((v44 & 0x80u) == 0) {
      uint64_t v25 = __p;
    }
    else {
      uint64_t v25 = (void **)__p[0];
    }
    if ((v44 & 0x80u) == 0) {
      uint64_t v26 = v44;
    }
    else {
      uint64_t v26 = (uint64_t)__p[1];
    }
    unint64_t v27 = sub_216779180(v24, (uint64_t)v25, v26);
    char v28 = sub_216779180(v27, (uint64_t)" to expected: ", 14);
    sub_216779180(v28, (uint64_t)"box", 3);
    if ((char)v44 < 0) {
      operator delete(__p[0]);
    }
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    uint64_t v29 = __cxa_allocate_exception(0x20uLL);
    uint64_t v30 = sub_216779038(v29, (uint64_t)__p);
    __cxa_throw(v30, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 88))(&v45, v12, a3);
  long long v17 = v45;
  long long v45 = 0uLL;
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v17;
  if (v18)
  {
    sub_216784EC4(v18);
    if (*((void *)&v45 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v45 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v49) {
    sub_216784EC4(v49);
  }
  sub_2167877AC((uint64_t)v48, (void *)v48[1]);
  return a1;
}

void sub_2167B14F8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B125CLL);
}

void sub_2167B1600()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167B1630);
}

uint64_t sub_2167B1640(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v9);
  if (v10 < 0)
  {
    BOOL v2 = v9[1] == (void *)3 && *(_WORD *)v9[0] == 28514 && *((unsigned char *)v9[0] + 2) == 120;
    operator delete(v9[0]);
  }
  else
  {
    BOOL v2 = v10 == 3 && LOWORD(v9[0]) == 28514 && BYTE2(v9[0]) == 120;
  }
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167B1714(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B1730(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v12 = (std::__shared_weak_count *)*((void *)a2 + 5);
  uint64_t v16 = *((void *)a2 + 4);
  long long v17 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v13 = *a2;
  v15[0] = 1;
  uint64_t v15[2] = v13;
  sub_2167B180C(a1, &v16, a3, v15, a4, a5, a6);
  if (v17) {
    sub_216784EC4(v17);
  }
  return a1;
}

void sub_2167B17EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_216784EC4(a12);
  }
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty(v12);
  _Unwind_Resume(a1);
}

void sub_2167B180C(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t v25 = 0;
  v26[0] = 0;
  uint64_t v24 = (uint64_t *)&v25;
  int v27 = 2;
  sub_2167898D0((uint64_t *)v28, (const void ***)&v24);
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  int v31 = 0;
  uint64_t v32 = 1;
  sub_2167877AC((uint64_t)&v24, v25);
  sub_2167A030C(a4, (uint64_t)&v27);
  sub_2167A030C(a5, (uint64_t)&v27);
  sub_2167A030C(a6, (uint64_t)&v27);
  sub_2167A030C(a7, (uint64_t)&v27);
  *(_DWORD *)a1 = v27;
  uint64_t v26[33] = a1;
  v26[34] = "OTypedScalarProperty::init()";
  if (!*a2)
  {
    sub_216778A5C((uint64_t)&v24);
    sub_216779180(v26, (uint64_t)"NULL CompoundPropertyWriterPtr", 30);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)&__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v20 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v20, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_2167898D0((uint64_t *)&v24, v28);
  sub_216779094(__p, "interpretation");
  sub_216779094(&__str, "box");
  uint64_t v33 = __p;
  int v13 = sub_21677B174(&v24, (const void **)__p, (uint64_t)&unk_217409F43, (long long **)&v33);
  std::string::operator=((std::string *)(v13 + 7), &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  if (v23 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = v29;
  uint64_t v14 = v30;
  if (v30) {
    atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v16 = *a2;
  if (v15)
  {
    (*(void (**)(std::string *__return_ptr))(*(void *)v16 + 24))(&__str);
    (*(void (**)(void **__return_ptr))(*(void *)__str.__r_.__value_.__l.__data_ + 24))(__p);
    (*(void (**)(void *, uint64_t))(*(void *)__p[0] + 48))(__p[0], v15);
    if (__p[1]) {
      sub_216784EC4((std::__shared_weak_count *)__p[1]);
    }
    if (__str.__r_.__value_.__l.__size_) {
      sub_216784EC4((std::__shared_weak_count *)__str.__r_.__value_.__l.__size_);
    }
    uint64_t v16 = *a2;
  }
  __str.__r_.__value_.__r.__words[0] = 0x60000000BLL;
  (*(void (**)(void **__return_ptr))(*(void *)v16 + 96))(__p);
  long long v17 = *(_OWORD *)__p;
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v17;
  if (v18)
  {
    sub_216784EC4(v18);
    if (__p[1]) {
      sub_216784EC4((std::__shared_weak_count *)__p[1]);
    }
  }
  if (v14) {
    sub_216784EC4(v14);
  }
  sub_2167877AC((uint64_t)&v24, v25);
  if (v30) {
    sub_216784EC4(v30);
  }
  sub_2167877AC((uint64_t)v28, v28[1]);
}

void sub_2167B1B58(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a24);
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v25);
    sub_21679FA64(v26 - 176, v30);
  }
  else
  {
    sub_2167A13A4(v25);
    sub_21679F9F4(v26 - 176, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B1AA4);
}

void sub_2167B1C8C()
{
  sub_2167A03C4(v0 - 160);
  JUMPOUT(0x2167B1CBCLL);
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesQuadrics(unsigned int a1)
{
  if (a1 > 4) {
    return 0;
  }
  else {
    return qword_217409F50[a1];
  }
}

BOOL Alembic::AbcGeom::v12::GeometryScopeNumValuesPolygon(unsigned int a1, uint64_t a2)
{
  if (a1 - 2 >= 3) {
    return a1 < 2;
  }
  else {
    return a2;
  }
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesPointsPolygons(uint64_t a1, uint64_t a2)
{
  return a2;
}

BOOL Alembic::AbcGeom::v12::GeometryScopeNumValuesPoints(unsigned int a1, uint64_t a2)
{
  if (a1 - 2 >= 3) {
    return a1 < 2;
  }
  else {
    return a2;
  }
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesSubdivisionMesh(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesBilinearPatch(unsigned int a1)
{
  if (a1 > 4) {
    return 0;
  }
  else {
    return qword_217409F50[a1];
  }
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesBicubicPatch(unsigned int a1)
{
  if (a1 > 4) {
    return 0;
  }
  else {
    return qword_217409F78[a1];
  }
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesBilinearPatchMesh(int a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 1;
  uint64_t v6 = (a4 - a5) * (a2 - a3);
  if (a1 != 1) {
    uint64_t v6 = 0;
  }
  if (a1) {
    uint64_t v5 = v6;
  }
  if ((a1 - 2) >= 3) {
    return v5;
  }
  else {
    return a4 * a2;
  }
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesBicubicPatchMesh(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (a4 - 3) * (a2 - 3);
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesNuPatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return a2 - a3 + 1 + (a2 - a3 + 1) * (a4 - a5);
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesLinearCurves(int a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v4 = 1;
  uint64_t v5 = a4 - (a2 << a3);
  if (a1 != 1) {
    uint64_t v5 = 0;
  }
  if (a1) {
    uint64_t v4 = v5;
  }
  if ((a1 - 2) >= 3) {
    return v4;
  }
  else {
    return a4;
  }
}

uint64_t Alembic::AbcGeom::v12::GeometryScopeNumValuesCubicCurves(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a4 - a2;
}

void Alembic::AbcGeom::v12::SetIsUV(uint64_t **a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    sub_216779094(v5, "notUV");
    sub_216779094(&__p, "1");
    long long v7 = v5;
    uint64_t v3 = sub_21677B174(a1, (const void **)v5, (uint64_t)&unk_217409F48, (long long **)&v7);
    std::string::operator=((std::string *)(v3 + 7), &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v6 < 0) {
      operator delete(v5[0]);
    }
  }
}

void sub_2167B208C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL Alembic::AbcGeom::v12::isUV(uint64_t a1)
{
  uint64_t v2 = a1 + 32;
  int v3 = sub_2167B21C0(a1 + 32);
  int v4 = sub_2167B243C(a1, 0);
  BOOL v5 = 0;
  if (!v4) {
    return v5;
  }
  sub_216779094(v9, "notUV");
  sub_21679F2AC(v2, (const void **)v9, __p);
  if (v12 < 0)
  {
    if (__p[1] != (void *)1) {
      goto LABEL_10;
    }
    char v6 = (void **)__p[0];
  }
  else
  {
    if (v12 != 1) {
      goto LABEL_10;
    }
    char v6 = __p;
  }
  if (*(unsigned char *)v6 == 49)
  {
    BOOL v5 = 0;
    if ((v12 & 0x80000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
LABEL_10:
  BOOL v5 = v3 == 4 || (v3 & 0xFFFFFFFE) == 2;
  if ((v12 & 0x80000000) == 0) {
    goto LABEL_18;
  }
LABEL_17:
  operator delete(__p[0]);
LABEL_18:
  if (v10 < 0) {
    operator delete(v9[0]);
  }
  return v5;
}

void sub_2167B21A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B21C0(uint64_t a1)
{
  sub_216779094(__p, "geoScope");
  sub_21679F2AC(a1, (const void **)__p, &v20);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v2 = v22;
  if ((v22 & 0x80) == 0)
  {
    if (!v22) {
      return v2;
    }
    if (v22 == 3)
    {
      if ((unsigned __int16)v20 == 28515 && BYTE2(v20) == 110) {
        return 0;
      }
      if ((unsigned __int16)v20 == 28277 && BYTE2(v20) == 105)
      {
        uint64_t v13 = 1;
        goto LABEL_68;
      }
      if ((unsigned __int16)v20 != 24950 || BYTE2(v20) != 114) {
        goto LABEL_39;
      }
      return 2;
    }
    return 127;
  }
  uint64_t v6 = v21;
  if (v21 == 3 && *(_WORD *)v20 == 28515 && *((unsigned char *)v20 + 2) == 110)
  {
    uint64_t v13 = 0;
    goto LABEL_68;
  }
  if (!v21)
  {
    uint64_t v13 = 0;
LABEL_69:
    char v8 = v20;
    goto LABEL_70;
  }
  char v8 = v20;
  if (v21 != 3) {
    goto LABEL_32;
  }
  if (*(_WORD *)v20 == 28277 && *((unsigned char *)v20 + 2) == 105)
  {
    uint64_t v13 = 1;
    goto LABEL_69;
  }
  char v8 = v20;
  uint64_t v6 = v21;
LABEL_32:
  if (v6 != 3) {
    goto LABEL_60;
  }
  if (*(_WORD *)v8 == 24950 && v8[2] == 114)
  {
    uint64_t v13 = 2;
    goto LABEL_68;
  }
  if ((v22 & 0x80) != 0)
  {
    char v8 = v20;
    if (v21 == 3)
    {
      if (*(_WORD *)v20 == 29814 && *((unsigned char *)v20 + 2) == 120)
      {
        uint64_t v13 = 3;
        goto LABEL_69;
      }
      char v12 = (unsigned __int16 *)v20;
      goto LABEL_58;
    }
LABEL_60:
    uint64_t v13 = 127;
LABEL_70:
    operator delete(v8);
    return v13;
  }
  if (v22 != 3) {
    return 127;
  }
LABEL_39:
  if ((unsigned __int16)v20 == 29814 && BYTE2(v20) == 120)
  {
    uint64_t v13 = 3;
    goto LABEL_68;
  }
  char v12 = (unsigned __int16 *)&v20;
LABEL_58:
  unsigned int v15 = bswap32(*v12) >> 16;
  if (v15 == 26230)
  {
    int v16 = *((unsigned __int8 *)v12 + 2) - 114;
  }
  else if (v15 < 0x6676)
  {
    int v16 = -1;
  }
  else
  {
    int v16 = 1;
  }
  if (v16) {
    uint64_t v13 = 127;
  }
  else {
    uint64_t v13 = 4;
  }
LABEL_68:
  if ((v22 & 0x80) != 0) {
    goto LABEL_69;
  }
  return v13;
}

void sub_2167B2420(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B243C(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 != 2)
  {
    if (!v3)
    {
      uint64_t v4 = a1 + 32;
      sub_216779094(v19, "podName");
      sub_21679F2AC(v4, (const void **)v19, v21);
      if (v22 < 0)
      {
        if (v21[1] != (void *)9)
        {
          uint64_t v7 = 0;
LABEL_35:
          operator delete(v21[0]);
LABEL_36:
          if (v20 < 0) {
            operator delete(v19[0]);
          }
          return v7;
        }
        BOOL v5 = (void **)v21[0];
      }
      else
      {
        if (v22 != 9)
        {
          uint64_t v7 = 0;
          goto LABEL_36;
        }
        BOOL v5 = v21;
      }
      char v10 = *v5;
      int v11 = *((unsigned __int8 *)v5 + 8);
      if (v10 == (void *)0x5F323374616F6C66 && v11 == 116)
      {
        sub_216779094(v15, "podExtent");
        sub_21679F2AC(v4, (const void **)v15, __p);
        char v13 = v18;
        if (v18 >= 0) {
          uint64_t v14 = __p;
        }
        else {
          uint64_t v14 = (void **)__p[0];
        }
        if (atoi((const char *)v14) == 2)
        {
          uint64_t v7 = sub_2167B2654(v4, a2);
          char v13 = v18;
        }
        else
        {
          uint64_t v7 = 0;
        }
        if (v13 < 0) {
          operator delete(__p[0]);
        }
        if (v16 < 0) {
          operator delete(v15[0]);
        }
        if ((v22 & 0x80) == 0) {
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v7 = 0;
        if ((v22 & 0x80) == 0) {
          goto LABEL_36;
        }
      }
      goto LABEL_35;
    }
    return 0;
  }
  if (*(_DWORD *)(a1 + 56) != 10 || *(unsigned char *)(a1 + 60) != 2) {
    return 0;
  }
  uint64_t v8 = a1 + 32;

  return sub_2167B2654(v8, a2);
}

void sub_2167B25F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (*(char *)(v26 - 33) < 0) {
    operator delete(*(void **)(v26 - 56));
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B2654(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v9);
  if (v10 < 0)
  {
    BOOL v2 = v9[1] == (void *)6 && *(_DWORD *)v9[0] == 1952671094 && *((_WORD *)v9[0] + 2) == 29295;
    operator delete(v9[0]);
  }
  else
  {
    BOOL v2 = v10 == 6 && LODWORD(v9[0]) == 1952671094 && WORD2(v9[0]) == 29295;
  }
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167B2730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

Alembic::AbcGeom::v12::FilmBackXformOp *Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  *(_DWORD *)this = 1;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  uint64_t v3 = 0;
  sub_2167B31F4((void *)this + 4, 2uLL, &v3);
  return this;
}

void sub_2167B27A8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

int *Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(int *a1, int a2, long long *a3)
{
  *a1 = a2;
  if (*((char *)a3 + 23) < 0)
  {
    sub_216778F24((unsigned char *)a1 + 8, *(void **)a3, *((void *)a3 + 1));
    a2 = *a1;
  }
  else
  {
    long long v4 = *a3;
    *((void *)a1 + 3) = *((void *)a3 + 2);
    *(_OWORD *)(a1 + 2) = v4;
  }
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 5) = 0;
  BOOL v5 = (void **)(a1 + 8);
  *((void *)a1 + 6) = 0;
  if (a2 == 2)
  {
    uint64_t v10 = 0;
    sub_2167B31F4(&v11, 9uLL, &v10);
    uint64_t v6 = *v5;
    if (*v5)
    {
      *((void *)a1 + 5) = v6;
      operator delete(v6);
      *BOOL v5 = 0;
      *((void *)a1 + 5) = 0;
      *((void *)a1 + 6) = 0;
    }
    uint64_t v7 = (void *)v11;
    *((_OWORD *)a1 + 2) = v11;
    *((void *)a1 + 6) = v12;
    *uint64_t v7 = 0x3FF0000000000000;
    _DWORD v7[4] = 0x3FF0000000000000;
    v7[8] = 0x3FF0000000000000;
  }
  else
  {
    if (a2 == 1)
    {
      uint64_t v10 = 0;
      sub_2167B31F4(&v11, 2uLL, &v10);
    }
    else
    {
      if (a2) {
        return a1;
      }
      uint64_t v10 = 0x3FF0000000000000;
      sub_2167B31F4(&v11, 2uLL, &v10);
    }
    char v8 = *v5;
    if (*v5)
    {
      *((void *)a1 + 5) = v8;
      operator delete(v8);
      *BOOL v5 = 0;
      *((void *)a1 + 5) = 0;
      *((void *)a1 + 6) = 0;
    }
    *((_OWORD *)a1 + 2) = v11;
    *((void *)a1 + 6) = v12;
  }
  return a1;
}

void sub_2167B28FC(_Unwind_Exception *exception_object)
{
  BOOL v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(uint64_t a1, const std::string *a2)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v3 = (void **)(a1 + 8);
  uint64_t v4 = a1 + 32;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  if (SHIBYTE(a2->__r_.__value_.__r.__words[2]) < 0)
  {
    if (a2->__r_.__value_.__l.__size_)
    {
      int v5 = *(unsigned __int8 *)a2->__r_.__value_.__l.__data_;
      goto LABEL_6;
    }
LABEL_12:
    *(_DWORD *)a1 = 1;
    uint64_t v10 = 0;
    sub_2167B31F4(&v11, 2uLL, &v10);
    goto LABEL_20;
  }
  if (!*((unsigned char *)&a2->__r_.__value_.__s + 23)) {
    goto LABEL_12;
  }
  int v5 = a2->__r_.__value_.__s.__data_[0];
LABEL_6:
  if (v5 == 109)
  {
    *(_DWORD *)a1 = 2;
    std::string::basic_string(&v11, a2, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v10);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v3);
    }
    *(std::string *)uint64_t v3 = v11;
    uint64_t v10 = 0;
    sub_2167B31F4(&v11, 9uLL, &v10);
    uint64_t v6 = *(void **)v4;
    if (*(void *)v4)
    {
      *(void *)(a1 + 40) = v6;
      operator delete(v6);
      *(void *)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
      *(void *)(v4 + 16) = 0;
    }
    uint64_t v7 = (void *)v11.__r_.__value_.__r.__words[0];
    *(std::string *)(a1 + 32) = v11;
    *uint64_t v7 = 0x3FF0000000000000;
    _DWORD v7[4] = 0x3FF0000000000000;
    v7[8] = 0x3FF0000000000000;
    return a1;
  }
  if (v5 == 115)
  {
    *(_DWORD *)a1 = 0;
    std::string::basic_string(&v11, a2, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v10);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v3);
    }
    *(std::string *)uint64_t v3 = v11;
    uint64_t v10 = 0x3FF0000000000000;
    sub_2167B31F4(&v11, 2uLL, &v10);
  }
  else
  {
    *(_DWORD *)a1 = 1;
    std::string::basic_string(&v11, a2, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v10);
    if (*(char *)(a1 + 31) < 0) {
      operator delete(*v3);
    }
    *(std::string *)uint64_t v3 = v11;
    uint64_t v10 = 0;
    sub_2167B31F4(&v11, 2uLL, &v10);
  }
LABEL_20:
  char v8 = *(void **)v4;
  if (*(void *)v4)
  {
    *(void *)(a1 + 40) = v8;
    operator delete(v8);
    *(void *)uint64_t v4 = 0;
    *(void *)(v4 + 8) = 0;
    *(void *)(v4 + 16) = 0;
  }
  *(std::string *)(a1 + 32) = v11;
  return a1;
}

void sub_2167B2B2C(_Unwind_Exception *exception_object)
{
  int v5 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::AbcGeom::v12::FilmBackXformOp::getType(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return *(unsigned int *)this;
}

char *Alembic::AbcGeom::v12::FilmBackXformOp::getHint@<X0>(char *this@<X0>, uint64_t a2@<X8>)
{
  if (this[31] < 0) {
    return (char *)sub_216778F24((unsigned char *)a2, *((void **)this + 1), *((void *)this + 2));
  }
  *(_OWORD *)a2 = *(_OWORD *)(this + 8);
  *(void *)(a2 + 16) = *((void *)this + 3);
  return this;
}

void *Alembic::AbcGeom::v12::FilmBackXformOp::getTypeAndHint@<X0>(Alembic::AbcGeom::v12::FilmBackXformOp *this@<X0>, void *a2@<X8>)
{
  if (*(_DWORD *)this > 2u) {
    return sub_216779094(a2, "");
  }
  else {
    return (void *)std::operator+<char>();
  }
}

uint64_t Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return (uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 3;
}

double Alembic::AbcGeom::v12::FilmBackXformOp::getChannelValue(Alembic::AbcGeom::v12::FilmBackXformOp *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 4);
  double result = 0.0;
  if (a2 <= (*((void *)this + 5) - v2) >> 3) {
    return *(double *)(v2 + 8 * a2);
  }
  return result;
}

uint64_t Alembic::AbcGeom::v12::FilmBackXformOp::setChannelValue(uint64_t this, unint64_t a2, double a3)
{
  uint64_t v3 = *(void *)(this + 32);
  if (a2 < (*(void *)(this + 40) - v3) >> 3) {
    *(double *)(v3 + 8 * a2) = a3;
  }
  return this;
}

BOOL Alembic::AbcGeom::v12::FilmBackXformOp::isTranslateOp(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return *(_DWORD *)this == 1;
}

BOOL Alembic::AbcGeom::v12::FilmBackXformOp::isScaleOp(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return *(_DWORD *)this == 0;
}

BOOL Alembic::AbcGeom::v12::FilmBackXformOp::isMatrixOp(Alembic::AbcGeom::v12::FilmBackXformOp *this)
{
  return *(_DWORD *)this == 2;
}

double Alembic::AbcGeom::v12::FilmBackXformOp::setTranslate(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != 1)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Meaningless to set translate on non-translate op.", 49);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    int v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)uint64_t v2 = *(void *)a2;
  double result = *(double *)(a2 + 8);
  *(double *)(v2 + 8) = result;
  return result;
}

void sub_2167B2D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

double Alembic::AbcGeom::v12::FilmBackXformOp::setScale(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Meaningless to set scale on non-scale op.", 41);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)uint64_t v2 = *(void *)a2;
  double result = *(double *)(a2 + 8);
  *(double *)(v2 + 8) = result;
  return result;
}

void sub_2167B2E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

double Alembic::AbcGeom::v12::FilmBackXformOp::setMatrix(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != 2)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Cannot set non-matrix op from Abc::M33d", 39);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)uint64_t v2 = *(void *)a2;
  *(void *)(v2 + 8) = *(void *)(a2 + 8);
  *(void *)(v2 + 16) = *(void *)(a2 + 16);
  *(void *)(v2 + 24) = *(void *)(a2 + 24);
  *(void *)(v2 + 32) = *(void *)(a2 + 32);
  *(void *)(v2 + 40) = *(void *)(a2 + 40);
  *(void *)(v2 + 48) = *(void *)(a2 + 48);
  *(void *)(v2 + 56) = *(void *)(a2 + 56);
  double result = *(double *)(a2 + 64);
  *(double *)(v2 + 64) = result;
  return result;
}

void sub_2167B2F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

__n128 Alembic::AbcGeom::v12::FilmBackXformOp::getTranslate@<Q0>(Alembic::AbcGeom::v12::FilmBackXformOp *this@<X0>, __n128 *a2@<X8>)
{
  if (*(_DWORD *)this != 1)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Meaningless to get translate vector from non-translate op.", 58);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v2 = (__n128 *)*((void *)this + 4);
  __n128 result = *v2;
  *a2 = *v2;
  return result;
}

void sub_2167B3008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

__n128 Alembic::AbcGeom::v12::FilmBackXformOp::getScale@<Q0>(Alembic::AbcGeom::v12::FilmBackXformOp *this@<X0>, __n128 *a2@<X8>)
{
  if (*(_DWORD *)this)
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Meaningless to get scaling vector from non-scale op.", 52);
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v2 = (__n128 *)*((void *)this + 4);
  __n128 result = *v2;
  *a2 = *v2;
  return result;
}

void sub_2167B30E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

double Alembic::AbcGeom::v12::FilmBackXformOp::getMatrix@<D0>(Alembic::AbcGeom::v12::FilmBackXformOp *this@<X0>, uint64_t a2@<X8>)
{
  if (*(_DWORD *)this != 2)
  {
    sub_216778A5C((uint64_t)v11);
    sub_216779180(v12, (uint64_t)"Can't get matrix from non-matrix op.", 36);
    std::stringbuf::str();
    sub_216778E70(v10, &__p);
    if (v9 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v7 = sub_216779038(exception, (uint64_t)v10);
    __cxa_throw(v7, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v2 = *((void *)this + 4);
  long long v3 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  *(_OWORD *)(a2 + 16) = v3;
  long long v4 = *(_OWORD *)(v2 + 48);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(v2 + 32);
  *(_OWORD *)(a2 + 48) = v4;
  double result = *(double *)(v2 + 64);
  *(double *)(a2 + 64) = result;
  return result;
}

void sub_2167B31CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void *sub_2167B31F4(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_21677CACC(a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_2167B325C(_Unwind_Exception *exception_object)
{
  long long v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

int64x2_t *Alembic::AbcGeom::v12::CameraSample::CameraSample(int64x2_t *this, double a2, double a3, double a4, double a5)
{
  this[8] = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  this[9] = (int64x2_t)xmmword_217409FA0;
  this[10] = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  this[11].i64[1] = 0;
  this[12].i64[0] = 0;
  this[11].i64[0] = 0;
  sub_2167B3334((uint64_t)this);
  double v10 = (a5 - a4) * 0.5;
  double v11 = *(double *)&this->i64[1];
  double v12 = (a2 - a3) * 0.5 * v11 / v10;
  *(double *)this[1].i64 = (v10 + a4) * v11 / (v10 + v10);
  *(double *)&this[1].i64[1] = v12;
  *(double *)this[2].i64 = v11 * (v10 * v12 / v11 + a3) * 0.5;
  *(double *)&this[2].i64[1] = v10;
  return this;
}

void sub_2167B3334(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_217409FB0;
  *(_OWORD *)(a1 + 16) = xmmword_217409FC0;
  *(_OWORD *)(a1 + 32) = xmmword_217409FD0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = xmmword_217409FE0;
  *(_OWORD *)(a1 + 96) = xmmword_217409FF0;
  *(_OWORD *)(a1 + 112) = xmmword_21740A000;
  *(int64x2_t *)(a1 + 128) = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(_OWORD *)(a1 + 144) = xmmword_217409FA0;
  *(int64x2_t *)(a1 + 160) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  uint64_t v3 = *(void *)(a1 + 176);
  for (uint64_t i = *(void *)(a1 + 184); i != v3; sub_2167B3F88(a1 + 192, i))
    i -= 56;
  *(void *)(a1 + 184) = v3;
}

double Alembic::AbcGeom::v12::CameraSample::getCoreValue(Alembic::AbcGeom::v12::CameraSample *this, uint64_t a2)
{
  switch(a2)
  {
    case 0:
      return *(double *)this;
    case 1:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 8);
      break;
    case 2:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 16);
      break;
    case 3:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 24);
      break;
    case 4:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 32);
      break;
    case 5:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 40);
      break;
    case 6:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 48);
      break;
    case 7:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 56);
      break;
    case 8:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 64);
      break;
    case 9:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 72);
      break;
    case 10:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 80);
      break;
    case 11:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 88);
      break;
    case 12:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 96);
      break;
    case 13:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 104);
      break;
    case 14:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 112);
      break;
    case 15:
      this = (Alembic::AbcGeom::v12::CameraSample *)((char *)this + 120);
      break;
    default:
      sub_216778A5C((uint64_t)v8);
      sub_216779180(v9, (uint64_t)"Invalid index specified, must be 0-15 not: ", 43);
      std::ostream::operator<<();
      std::stringbuf::str();
      sub_216778E70(v7, &__p);
      if (v6 < 0) {
        operator delete((void *)__p);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      long long v4 = sub_216779038(exception, (uint64_t)v7);
      __cxa_throw(v4, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return *(double *)this;
}

void sub_2167B3548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

long double Alembic::AbcGeom::v12::CameraSample::getFieldOfView(Alembic::AbcGeom::v12::CameraSample *this)
{
  long double v1 = atan(*((double *)this + 1) * 10.0 / (*(double *)this + *(double *)this));
  return v1 * 57.2957795 + v1 * 57.2957795;
}

double Alembic::AbcGeom::v12::CameraSample::getScreenWindow(Alembic::AbcGeom::v12::CameraSample *this, double *a2, double *a3, double *a4, double *a5)
{
  double v9 = *((double *)this + 5);
  double v10 = (*((double *)this + 2) + *((double *)this + 2)) * v9 / *((double *)this + 1);
  *a4 = -((*((double *)this + 6) + 1.0) * v9);
  *a5 = (*((double *)this + 7) + 1.0) * *((double *)this + 5);
  double v11 = *((double *)this + 1);
  double v12 = *((double *)this + 5) * *((double *)this + 3) / v11;
  double v13 = (*((double *)this + 4) + *((double *)this + 4)) / v11;
  *a3 = -((*((double *)this + 9) + 1.0) * v12);
  double v14 = v12 * (*((double *)this + 8) + 1.0);
  *a2 = v14;
  double v15 = *a4;
  double v16 = *a5;
  double v17 = *a3;
  Alembic::AbcGeom::v12::CameraSample::getFilmBackMatrix(this, &v24);
  double v18 = v32 + v14 * v29 + v15 * v26;
  double v19 = (v31 + v14 * v28 + v15 * v25) / v18;
  double v20 = v32 + v17 * v29 + v16 * v26;
  double v21 = (v30 + v17 * v27 + v16 * v24) / v20;
  double v22 = (v31 + v17 * v28 + v16 * v25) / v20;
  *a4 = v10 + (v30 + v14 * v27 + v15 * v24) / v18;
  *a2 = v13 + v19;
  *a5 = v10 + v21;
  double result = v13 + v22;
  *a3 = v13 + v22;
  return result;
}

void Alembic::AbcGeom::v12::CameraSample::getFilmBackMatrix(Alembic::AbcGeom::v12::CameraSample *this@<X0>, double *a2@<X8>)
{
  *a2 = 1.0;
  a2[1] = 0.0;
  a2[2] = 0.0;
  a2[3] = 0.0;
  a2[4] = 1.0;
  a2[5] = 0.0;
  a2[6] = 0.0;
  a2[7] = 0.0;
  a2[8] = 1.0;
  uint64_t v3 = *((void *)this + 22);
  if (*((void *)this + 23) != v3)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    double v7 = 1.0;
    double v8 = 0.0;
    double v31 = 0.0;
    double v32 = 0.0;
    double v9 = 0.0;
    double v10 = 0.0;
    double v11 = 1.0;
    double v12 = 0.0;
    double v30 = 1.0;
    while (1)
    {
      int v41 = *(_DWORD *)(v3 + v5);
      double v13 = (void **)(v3 + v5 + 8);
      if (*(char *)(v3 + v5 + 31) < 0)
      {
        sub_216778F24(&v42, *v13, *(void *)(v3 + v5 + 16));
      }
      else
      {
        long long v14 = *(_OWORD *)v13;
        uint64_t v43 = *(void *)(v3 + v5 + 24);
        long long v42 = v14;
      }
      long long __p = 0;
      long long v45 = 0;
      uint64_t v46 = 0;
      sub_21677CA50(&__p, *(const void **)(v3 + v5 + 32), *(void *)(v3 + v5 + 40), (uint64_t)(*(void *)(v3 + v5 + 40) - *(void *)(v3 + v5 + 32)) >> 3);
      if (!Alembic::AbcGeom::v12::FilmBackXformOp::isMatrixOp((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41)) {
        break;
      }
      Alembic::AbcGeom::v12::FilmBackXformOp::getMatrix((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41, (uint64_t)&v33);
      double v15 = v33.n128_f64[1];
      double v16 = v33.n128_f64[0];
      double v17 = v34;
      double v18 = v35;
      double v19 = v36;
      double v20 = v37;
      double v22 = v38;
      double v21 = v39;
      double v23 = v40;
LABEL_15:
      double v24 = v7;
      double v7 = v15 * v9 + v16 * v7 + v17 * v31;
      double v25 = v10;
      double v10 = v15 * v11 + v16 * v10 + v17 * v32;
      double v26 = v8;
      double v8 = v15 * v12 + v16 * v8 + v17 * v30;
      double v27 = v9;
      double v9 = v19 * v9 + v18 * v24 + v20 * v31;
      double v28 = v19 * v11 + v18 * v25 + v20 * v32;
      double v29 = v19 * v12 + v18 * v26 + v20 * v30;
      *a2 = v7;
      a2[1] = v10;
      a2[2] = v8;
      a2[3] = v9;
      a2[4] = v28;
      a2[5] = v29;
      double v31 = v21 * v27 + v22 * v24 + v23 * v31;
      double v32 = v21 * v11 + v22 * v25 + v23 * v32;
      a2[6] = v31;
      a2[7] = v32;
      double v30 = v21 * v12 + v22 * v26 + v23 * v30;
      a2[8] = v30;
      if (__p)
      {
        long long v45 = __p;
        operator delete(__p);
      }
      if (SHIBYTE(v43) < 0) {
        operator delete((void *)v42);
      }
      ++v6;
      uint64_t v3 = *((void *)this + 22);
      v5 += 56;
      double v11 = v28;
      double v12 = v29;
      if (v6 >= 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 23) - v3) >> 3)) {
        return;
      }
    }
    if (Alembic::AbcGeom::v12::FilmBackXformOp::isScaleOp((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41))
    {
      Alembic::AbcGeom::v12::FilmBackXformOp::getScale((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41, &v33);
      double v23 = 1.0;
      double v19 = v33.n128_f64[1];
      double v16 = v33.n128_f64[0];
      double v18 = 0.0;
      double v21 = 0.0;
    }
    else
    {
      double v18 = 0.0;
      double v16 = 1.0;
      if (Alembic::AbcGeom::v12::FilmBackXformOp::isTranslateOp((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41))
      {
        Alembic::AbcGeom::v12::FilmBackXformOp::getTranslate((Alembic::AbcGeom::v12::FilmBackXformOp *)&v41, &v33);
        double v21 = v33.n128_f64[1];
        double v22 = v33.n128_f64[0];
        double v19 = 1.0;
        double v23 = 1.0;
LABEL_14:
        double v20 = 0.0;
        double v17 = 0.0;
        double v15 = 0.0;
        goto LABEL_15;
      }
      double v19 = 1.0;
      double v21 = 0.0;
      double v23 = 1.0;
    }
    double v22 = 0.0;
    goto LABEL_14;
  }
}

void sub_2167B3A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

uint64_t Alembic::AbcGeom::v12::CameraSample::addOp(void *a1, uint64_t a2)
{
  unint64_t v4 = a1[24];
  uint64_t v3 = (uint64_t)(a1 + 24);
  unint64_t v5 = *(void *)(v3 - 8);
  if (v5 >= v4)
  {
    uint64_t v6 = sub_2167B3FE0((uint64_t *)(v3 - 16), a2);
  }
  else
  {
    sub_2167B4108(v3, *(void *)(v3 - 8), a2);
    uint64_t v6 = v5 + 56;
    a1[23] = v5 + 56;
  }
  a1[23] = v6;
  return 0x6DB6DB6DB6DB6DB7 * ((v6 - a1[22]) >> 3) - 1;
}

void sub_2167B3AD0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 184) = v2;
  _Unwind_Resume(a1);
}

void *Alembic::AbcGeom::v12::CameraSample::getOp@<X0>(Alembic::AbcGeom::v12::CameraSample *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *((void *)this + 22);
  if (0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 23) - v5) >> 3) <= a2)
  {
    sub_216778A5C((uint64_t)v15);
    sub_216779180(v16, (uint64_t)"Invalid index in CameraSample: ", 31);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v14, &__p);
    if (v13 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    double v11 = sub_216779038(exception, (uint64_t)v14);
    __cxa_throw(v11, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v6 = v5 + 56 * a2;
  *(_DWORD *)a3 = *(_DWORD *)v6;
  double v7 = (void **)(v6 + 8);
  if (*(char *)(v6 + 31) < 0)
  {
    sub_216778F24((unsigned char *)(a3 + 8), *v7, *(void *)(v5 + 56 * a2 + 16));
  }
  else
  {
    long long v8 = *(_OWORD *)v7;
    *(void *)(a3 + 24) = *(void *)(v6 + 24);
    *(_OWORD *)(a3 + 8) = v8;
  }
  *(void *)(a3 + 32) = 0;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = 0;
  return sub_21677CA50((void *)(a3 + 32), *(const void **)(v5 + 56 * a2 + 32), *(void *)(v5 + 56 * a2 + 40), (uint64_t)(*(void *)(v5 + 56 * a2 + 40) - *(void *)(v5 + 56 * a2 + 32)) >> 3);
}

void sub_2167B3C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcGeom::v12::CameraSample::operator[](uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 176);
  if (*a2 >= (unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*(void *)(a1 + 184) - v2) >> 3)))
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Invalid index in CameraSample: ", 31);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return v2 + 56 * *a2;
}

{
  uint64_t v2;
  void *exception;
  void *v5;
  long long __p;
  char v7;
  void v8[4];
  unsigned char v9[16];
  void v10[33];

  uint64_t v2 = *(void *)(a1 + 176);
  if (*a2 >= (unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*(void *)(a1 + 184) - v2) >> 3)))
  {
    sub_216778A5C((uint64_t)v9);
    sub_216779180(v10, (uint64_t)"Invalid index in CameraSample: ", 31);
    std::ostream::operator<<();
    std::stringbuf::str();
    sub_216778E70(v8, &__p);
    if (v7 < 0) {
      operator delete((void *)__p);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    std::exception v5 = sub_216779038(exception, (uint64_t)v8);
    __cxa_throw(v5, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  return v2 + 56 * *a2;
}

void sub_2167B3D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_2167B3E68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  v5.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_2167B3E90(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t Alembic::AbcGeom::v12::CameraSample::getNumOps(Alembic::AbcGeom::v12::CameraSample *this)
{
  return 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)this + 23) - *((void *)this + 22)) >> 3);
}

uint64_t Alembic::AbcGeom::v12::CameraSample::getNumOpChannels(Alembic::AbcGeom::v12::CameraSample *this)
{
  uint64_t v1 = *((void *)this + 22);
  if (*((void *)this + 23) == v1) {
    return 0;
  }
  uint64_t v3 = 0;
  unint64_t v4 = 0;
  uint64_t v5 = 0;
  do
  {
    v5 += Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels((Alembic::AbcGeom::v12::FilmBackXformOp *)(v1 + v3));
    ++v4;
    uint64_t v1 = *((void *)this + 22);
    v3 += 56;
  }
  while (v4 < 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 23) - v1) >> 3));
  return v5;
}

void sub_2167B3F88(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 32);
  if (v3)
  {
    *(void *)(a2 + 40) = v3;
    operator delete(v3);
  }
  if (*(char *)(a2 + 31) < 0)
  {
    unint64_t v4 = *(void **)(a2 + 8);
    operator delete(v4);
  }
}

uint64_t sub_2167B3FE0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x492492492492492) {
    sub_21677CB10();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[2] - *a1) >> 3)) >= 0x249249249249249) {
    unint64_t v6 = 0x492492492492492;
  }
  else {
    unint64_t v6 = v4;
  }
  long long v14 = a1 + 2;
  if (v6) {
    uint64_t v7 = (char *)sub_2167B421C((uint64_t)(a1 + 2), v6);
  }
  else {
    uint64_t v7 = 0;
  }
  double v10 = v7;
  double v11 = &v7[56 * v3];
  char v13 = &v7[56 * v6];
  sub_2167B4108((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  double v12 = v11 + 56;
  sub_2167B41A4(a1, &v10);
  uint64_t v8 = a1[1];
  sub_2167B43B8(&v10);
  return v8;
}

void sub_2167B40F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_2167B43B8((void **)va);
  _Unwind_Resume(a1);
}

void *sub_2167B4108(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  uint64_t v5 = (unsigned char *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_216778F24(v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    *(void *)(a2 + 24) = *(void *)(a3 + 24);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return sub_21677CA50((void *)(a2 + 32), *(const void **)(a3 + 32), *(void *)(a3 + 40), (uint64_t)(*(void *)(a3 + 40) - *(void *)(a3 + 32)) >> 3);
}

void sub_2167B4188(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B41A4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_2167B4268((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_2167B421C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    sub_21677CA1C();
  }
  return operator new(56 * a2);
}

uint64_t sub_2167B4268(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    do
    {
      int v8 = *(_DWORD *)(a3 - 56);
      a3 -= 56;
      *(_DWORD *)(v7 - 56) = v8;
      long long v9 = *(_OWORD *)(a3 + 8);
      *(void *)(v7 - 32) = *(void *)(a3 + 24);
      *(_OWORD *)(v7 - 48) = v9;
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + 24) = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 32);
      *(void *)(v7 - 8) = *(void *)(a3 + 48);
      *(void *)(a3 + 32) = 0;
      *(void *)(a3 + 40) = 0;
      *(void *)(a3 + 48) = 0;
      uint64_t v7 = *((void *)&v15 + 1) - 56;
      *((void *)&v15 + 1) -= 56;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_2167B432C((uint64_t)v12);
  return v10;
}

uint64_t sub_2167B432C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_2167B4364((uint64_t *)a1);
  }
  return a1;
}

void sub_2167B4364(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_2167B3F88(v3, v1);
      v1 += 56;
    }
    while (v1 != v2);
  }
}

void **sub_2167B43B8(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_2167B43EC(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 56;
    sub_2167B3F88(v4, i - 56);
  }
}

void Alembic::AbcGeom::v12::ICameraSchema::init(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 8;
  uint64_t v101 = a1 + 8;
  int v102 = "ICameraSchema::init()";
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 48);
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)&v73.__r_.__value_.__l.__data_ = 0uLL;
  p_p = &v73;
  int v96 = 2;
  sub_2167898D0(v97, (const void ***)&p_p);
  v97[3] = 0;
  unint64_t v98 = 0;
  int v99 = 0;
  uint64_t v100 = 1;
  sub_2167877AC((uint64_t)&p_p, v73.__r_.__value_.__l.__data_);
  sub_2167A030C(a2, (uint64_t)&v96);
  sub_2167A030C(a3, (uint64_t)&v96);
  uint64_t v93 = v8;
  unint64_t v94 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v91 = 0;
  int v92 = 0;
  int v89 = 0;
  int v90 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v95, &v93, &v91, &v89);
  sub_216779094(&__p, ".core");
  int v84 = 1;
  int v85 = v96;
  Alembic::Abc::v12::IScalarProperty::IScalarProperty(&p_p, v95, &__p, &v84);
  *(_DWORD *)(a1 + 56) = p_p;
  std::string::operator=((std::string *)(a1 + 64), &v73);
  long long v9 = v74;
  if (*((void *)&v74 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = *(std::__shared_weak_count **)(a1 + 96);
  *(_OWORD *)(a1 + 88) = v9;
  if (v10) {
    sub_216784EC4(v10);
  }
  Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)&p_p);
  if (v88 < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v95);
  if (v94) {
    sub_216784EC4(v94);
  }
  sub_216779094(&p_p, ".childBnds");
  Propertyuint64_t Header = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v12 = PropertyHeader;
  if (v73.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v12) {
      goto LABEL_27;
    }
  }
  else if (!PropertyHeader)
  {
    goto LABEL_27;
  }
  uint64_t v82 = v8;
  unsigned int v83 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v91 = 0;
  int v92 = 0;
  int v89 = 0;
  int v90 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v95, &v82, &v91, &v89);
  sub_216779094(&__p, ".childBnds");
  sub_2167B10BC((uint64_t)&p_p, v95, (uint64_t)&__p, a2, a3);
  *(_DWORD *)(a1 + 104) = p_p;
  std::string::operator=((std::string *)(a1 + 112), &v73);
  long long v13 = v74;
  if (*((void *)&v74 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  long long v14 = *(std::__shared_weak_count **)(a1 + 144);
  *(_OWORD *)(a1 + 136) = v13;
  if (v14) {
    sub_216784EC4(v14);
  }
  Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)&p_p);
  if (v88 < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v95);
  if (v83) {
    sub_216784EC4(v83);
  }
LABEL_27:
  sub_216779094(&p_p, ".arbGeomParams");
  uint64_t v15 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v16 = v15;
  if (v73.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v16) {
      goto LABEL_41;
    }
  }
  else if (!v15)
  {
    goto LABEL_41;
  }
  uint64_t v80 = v8;
  int64_t v81 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v91 = 0;
  int v92 = 0;
  int v89 = 0;
  int v90 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v95, &v80, &v91, &v89);
  sub_216779094(&__p, ".arbGeomParams");
  int v84 = 1;
  int v85 = v96;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&p_p, v95, &__p, &v84);
  *(_DWORD *)(a1 + 152) = p_p;
  std::string::operator=((std::string *)(a1 + 160), &v73);
  long long v17 = v74;
  if (*((void *)&v74 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  double v18 = *(std::__shared_weak_count **)(a1 + 192);
  *(_OWORD *)(a1 + 184) = v17;
  if (v18) {
    sub_216784EC4(v18);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&p_p);
  if (v88 < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v95);
  if (v81) {
    sub_216784EC4(v81);
  }
LABEL_41:
  sub_216779094(&p_p, ".userProperties");
  uint64_t v19 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v20 = v19;
  if (v73.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v20) {
      goto LABEL_55;
    }
  }
  else if (!v19)
  {
    goto LABEL_55;
  }
  uint64_t v78 = v8;
  unint64_t v79 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v91 = 0;
  int v92 = 0;
  int v89 = 0;
  int v90 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v95, &v78, &v91, &v89);
  sub_216779094(&__p, ".userProperties");
  int v84 = 1;
  int v85 = v96;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&p_p, v95, &__p, &v84);
  *(_DWORD *)(a1 + 200) = p_p;
  std::string::operator=((std::string *)(a1 + 208), &v73);
  long long v21 = v74;
  if (*((void *)&v74 + 1)) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 1uLL, memory_order_relaxed);
  }
  double v22 = *(std::__shared_weak_count **)(a1 + 240);
  *(_OWORD *)(a1 + 232) = v21;
  if (v22) {
    sub_216784EC4(v22);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&p_p);
  if (v88 < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v95);
  if (v79) {
    sub_216784EC4(v79);
  }
LABEL_55:
  sub_216779094(&p_p, ".filmBackOps");
  uint64_t v23 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v24 = v23;
  if (v73.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v24) {
      goto LABEL_104;
    }
  }
  else if (!v23)
  {
    goto LABEL_104;
  }
  int v25 = *(_DWORD *)(v24 + 24);
  if (v25 == 2)
  {
    uint64_t v70 = v8;
    uint64_t v71 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v91 = 0;
    int v92 = 0;
    int v89 = 0;
    int v90 = 0;
    uint64_t v65 = v7;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&p_p, &v70, &v91, &v89);
    sub_216779094(&__p, ".filmBackOps");
    sub_2167B5F84((uint64_t)v95, (int *)&p_p, (uint64_t)&__p, a2, a3);
    if (v88 < 0) {
      operator delete(__p);
    }
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&p_p);
    if (v71) {
      sub_216784EC4(v71);
    }
    uint64_t v64 = v6;
    uint64_t v61 = v8;
    int64_t v62 = a2;
    long long v63 = a3;
    long long __p = 0;
    uint64_t v87 = 0;
    p_p = 0;
    v73.__r_.__value_.__r.__words[0] = 0;
    LODWORD(v73.__r_.__value_.__r.__words[1]) = 2;
    sub_2167B5418((uint64_t)v95, &__p, (uint64_t)&p_p);
    if (__p)
    {
      double v38 = (uint64_t *)*((void *)__p + 2);
      uint64_t v39 = *((void *)__p + 3) - (void)v38;
      if (v39)
      {
        unint64_t v40 = v39 >> 3;
        if (v40 <= 1) {
          unint64_t v40 = 1;
        }
        unint64_t v41 = 1;
        do
        {
          uint64_t v42 = *v38++;
          v41 *= v42;
          --v40;
        }
        while (v40);
      }
      else
      {
        unint64_t v41 = 0;
      }
      uint64_t v43 = (uint64_t *)(a1 + 344);
      sub_2167B536C((uint64_t *)(a1 + 344), v41);
      if (v41)
      {
        uint64_t v44 = 0;
        uint64_t v45 = 0;
        do
        {
          Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(&p_p, *(void *)__p + v45);
          uint64_t v46 = *v43;
          uint64_t v47 = *v43 + v44;
          *(_DWORD *)uint64_t v47 = p_p;
          BOOL v48 = (void **)(v47 + 8);
          if (*(char *)(v47 + 31) < 0) {
            operator delete(*v48);
          }
          long long v49 = *(_OWORD *)&v73.__r_.__value_.__l.__data_;
          *(void *)(v47 + 24) = *((void *)&v73.__r_.__value_.__l + 2);
          *(_OWORD *)BOOL v48 = v49;
          *((unsigned char *)&v73.__r_.__value_.__s + 23) = 0;
          v73.__r_.__value_.__s.__data_[0] = 0;
          uint64_t v52 = *(void **)(v47 + 32);
          uint64_t v51 = (void *)(v47 + 32);
          int v50 = v52;
          if (v52)
          {
            *(void *)(v46 + v44 + 40) = v50;
            operator delete(v50);
            *uint64_t v51 = 0;
            v51[1] = 0;
            void v51[2] = 0;
          }
          *(_OWORD *)uint64_t v51 = v74;
          *(void *)(v46 + v44 + 48) = v75;
          long long v74 = 0uLL;
          uint64_t v75 = 0;
          if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v73.__r_.__value_.__l.__data_);
          }
          v45 += 24;
          v44 += 56;
          --v41;
        }
        while (v41);
      }
    }
    if (v87) {
      sub_216784EC4(v87);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)v95);
  }
  else
  {
    if (v25 != 1) {
      goto LABEL_104;
    }
    uint64_t v76 = v8;
    int64_t v77 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v91 = 0;
    int v92 = 0;
    int v89 = 0;
    int v90 = 0;
    uint64_t v65 = v7;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&p_p, &v76, &v91, &v89);
    sub_216779094(&__p, ".filmBackOps");
    int v84 = 1;
    int v85 = v96;
    Alembic::Abc::v12::IScalarProperty::IScalarProperty(v95, &p_p, &__p, &v84);
    if (v88 < 0) {
      operator delete(__p);
    }
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&p_p);
    if (v77) {
      sub_216784EC4(v77);
    }
    uint64_t v64 = v6;
    unint64_t v26 = *(unsigned __int8 *)(sub_2167B5CBC((uint64_t)v95) + 60);
    sub_216782DE0(&__p, v26);
    p_p = 0;
    v73.__r_.__value_.__r.__words[0] = 0;
    LODWORD(v73.__r_.__value_.__r.__words[1]) = 2;
    Alembic::Abc::v12::IScalarProperty::get((uint64_t)v95, (uint64_t)__p, (uint64_t)&p_p, 0);
    uint64_t v61 = v8;
    int64_t v62 = a2;
    long long v63 = a3;
    double v27 = (uint64_t *)(a1 + 344);
    sub_2167B536C((uint64_t *)(a1 + 344), 0xAAAAAAAAAAAAAAABLL * (((char *)v87 - (unsigned char *)__p) >> 3));
    if (v26)
    {
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      uint64_t v30 = 56 * v26;
      do
      {
        Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(&p_p, (char *)__p + v28);
        uint64_t v31 = *v27;
        uint64_t v32 = *v27 + v29;
        *(_DWORD *)uint64_t v32 = p_p;
        __n128 v33 = (void **)(v32 + 8);
        if (*(char *)(v32 + 31) < 0) {
          operator delete(*v33);
        }
        long long v34 = *(_OWORD *)&v73.__r_.__value_.__l.__data_;
        *(void *)(v32 + 24) = *((void *)&v73.__r_.__value_.__l + 2);
        *(_OWORD *)__n128 v33 = v34;
        *((unsigned char *)&v73.__r_.__value_.__s + 23) = 0;
        v73.__r_.__value_.__s.__data_[0] = 0;
        double v37 = *(void **)(v32 + 32);
        double v36 = (void *)(v32 + 32);
        double v35 = v37;
        if (v37)
        {
          *(void *)(v31 + v29 + 40) = v35;
          operator delete(v35);
          *double v36 = 0;
          v36[1] = 0;
          v36[2] = 0;
        }
        *(_OWORD *)double v36 = v74;
        *(void *)(v31 + v29 + 48) = v75;
        long long v74 = 0uLL;
        uint64_t v75 = 0;
        if (SHIBYTE(v73.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v73.__r_.__value_.__l.__data_);
        }
        v29 += 56;
        v28 += 24;
      }
      while (v30 != v29);
    }
    p_p = &__p;
    sub_216782F20((void ***)&p_p);
    Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)v95);
  }
  uint64_t v6 = v64;
  uint64_t v7 = v65;
  a3 = v63;
  uint64_t v8 = v61;
  a2 = v62;
LABEL_104:
  sub_216779094(&p_p, ".filmBackChannels");
  uint64_t v53 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v54 = v53;
  if (v73.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(p_p);
    if (!v54) {
      goto LABEL_120;
    }
  }
  else if (!v53)
  {
    goto LABEL_120;
  }
  int v55 = *(_DWORD *)(v54 + 24);
  if (v55 == 2)
  {
    uint64_t v66 = v8;
    unint64_t v67 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v91 = 0;
    int v92 = 0;
    int v89 = 0;
    int v90 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v95, &v66, &v91, &v89);
    sub_216779094(&__p, ".filmBackChannels");
    sub_2167B65A8((uint64_t)&p_p, v95, (uint64_t)&__p, a2, a3);
    *(_DWORD *)(a1 + 296) = p_p;
    std::string::operator=((std::string *)(a1 + 304), &v73);
    long long v59 = v74;
    if (*((void *)&v74 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v60 = *(std::__shared_weak_count **)(a1 + 336);
    *(_OWORD *)(a1 + 328) = v59;
    if (v60) {
      sub_216784EC4(v60);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&p_p);
    if (v88 < 0) {
      operator delete(__p);
    }
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v95);
    char v58 = v67;
    if (v67) {
      goto LABEL_119;
    }
  }
  else if (v55 == 1)
  {
    uint64_t v68 = v8;
    int v69 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v91 = 0;
    int v92 = 0;
    int v89 = 0;
    int v90 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v95, &v68, &v91, &v89);
    sub_216779094(&__p, ".filmBackChannels");
    int v84 = 1;
    int v85 = v96;
    Alembic::Abc::v12::IScalarProperty::IScalarProperty(&p_p, v95, &__p, &v84);
    *(_DWORD *)(a1 + 248) = p_p;
    std::string::operator=((std::string *)(a1 + 256), &v73);
    long long v56 = v74;
    if (*((void *)&v74 + 1)) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v74 + 1) + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v57 = *(std::__shared_weak_count **)(a1 + 288);
    *(_OWORD *)(a1 + 280) = v56;
    if (v57) {
      sub_216784EC4(v57);
    }
    Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)&p_p);
    if (v88 < 0) {
      operator delete(__p);
    }
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v95);
    char v58 = v69;
    if (v69) {
LABEL_119:
    }
      sub_216784EC4(v58);
  }
LABEL_120:
  if (v98) {
    sub_216784EC4(v98);
  }
  sub_2167877AC((uint64_t)v97, (void *)v97[1]);
  if (v7) {
    sub_216784EC4(v7);
  }
}

void sub_2167B4F20(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, std::__shared_weak_count *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *__p,std::__shared_weak_count *a43,int a44,__int16 a45,char a46,char a47)
{
  if (a43) {
    sub_216784EC4(a43);
  }
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)(v48 - 216));
  sub_2167A03C4(v48 - 168);
  if (a15) {
    sub_216784EC4(a15);
  }
  uint64_t v51 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v52 = (uint64_t)v51;
    sub_2167B5494(v47);
    sub_21679FA64(v48 - 104, v52);
  }
  else
  {
    sub_2167B5494(v47);
    sub_21679F9F4(v48 - 104, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B4E38);
}

void sub_2167B534C(_Unwind_Exception *a1)
{
}

void sub_2167B536C(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_2167B5DF0(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 56 * a2;
    while (v3 != v7)
    {
      v3 -= 56;
      sub_2167B3F88((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void sub_2167B5418(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  Alembic::Abc::v12::IArrayProperty::get(a1, (uint64_t)&v7, a3);
  uint64_t v5 = v7;
  unint64_t v4 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v6 = (std::__shared_weak_count *)a2[1];
  *a2 = v5;
  a2[1] = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167B547C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167B5494(uint64_t a1)
{
  sub_2167A13A4(a1 + 56);
  sub_2167A13A4(a1 + 104);
  sub_2167A13A4(a1 + 152);
  sub_2167A13A4(a1 + 200);
  uint64_t v3 = *(void *)(a1 + 344);
  for (uint64_t i = *(void *)(a1 + 352); i != v3; sub_2167B3F88(a1 + 360, i))
    i -= 56;
  *(void *)(a1 + 352) = v3;

  sub_2167A13A4(a1 + 8);
}

uint64_t Alembic::AbcGeom::v12::ICameraSchema::isConstant(Alembic::AbcGeom::v12::ICameraSchema *this)
{
  uint64_t result = Alembic::Abc::v12::IScalarProperty::isConstant((Alembic::AbcGeom::v12::ICameraSchema *)((char *)this + 56));
  if (!result) {
    return result;
  }
  if (*((char *)this + 279) < 0)
  {
    if (*((void *)this + 33)) {
      goto LABEL_8;
    }
  }
  else if (*((unsigned char *)this + 279))
  {
    goto LABEL_8;
  }
  if (*((void *)this + 35))
  {
    uint64_t result = Alembic::Abc::v12::IScalarProperty::isConstant((Alembic::AbcGeom::v12::ICameraSchema *)((char *)this + 248));
    if (!result) {
      return result;
    }
  }
LABEL_8:
  if (*((char *)this + 327) < 0)
  {
    if (!*((void *)this + 39)) {
      goto LABEL_12;
    }
    return 1;
  }
  if (*((unsigned char *)this + 327)) {
    return 1;
  }
LABEL_12:
  if (!*((void *)this + 41)) {
    return 1;
  }

  return Alembic::Abc::v12::IArrayProperty::isConstant((Alembic::AbcGeom::v12::ICameraSchema *)((char *)this + 296));
}

void Alembic::AbcGeom::v12::ICameraSchema::get(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1;
  uint64_t v73 = *MEMORY[0x263EF8340];
  uint64_t v63 = a1 + 8;
  uint64_t v64 = "ICameraSchema::get()";
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  unint64_t v6 = (Alembic::Abc::v12::IScalarProperty *)(a1 + 56);
  long long v65 = 0u;
  long long v66 = 0u;
  Alembic::Abc::v12::IScalarProperty::get(a1 + 56, (uint64_t)&v65, a3, 0);
  sub_2167B3334(a2);
  long long v7 = v66;
  *(_OWORD *)a2 = v65;
  *(_OWORD *)(a2 + 16) = v7;
  long long v8 = v68;
  *(_OWORD *)(a2 + 32) = v67;
  *(_OWORD *)(a2 + 48) = v8;
  long long v9 = v70;
  *(_OWORD *)(a2 + 64) = v69;
  *(_OWORD *)(a2 + 80) = v9;
  long long v10 = v72;
  *(_OWORD *)(a2 + 96) = v71;
  *(_OWORD *)(a2 + 112) = v10;
  if (*(char *)(v5 + 279) < 0)
  {
    if (*(void *)(v5 + 264)) {
      goto LABEL_3;
    }
  }
  else if (*(unsigned char *)(v5 + 279))
  {
LABEL_3:
    double v11 = 0;
    goto LABEL_8;
  }
  if (*(void *)(v5 + 280)) {
    double v11 = nullsub_4;
  }
  else {
    double v11 = 0;
  }
LABEL_8:
  uint64_t v44 = v5;
  if (!v11 || !Alembic::Abc::v12::IScalarProperty::getNumSamples((Alembic::Abc::v12::IScalarProperty *)(v5 + 248)))
  {
    if (*(char *)(v5 + 327) < 0)
    {
      if (*(void *)(v5 + 312)) {
        goto LABEL_32;
      }
    }
    else if (*(unsigned char *)(v5 + 327))
    {
LABEL_32:
      uint64_t v28 = 0;
      goto LABEL_37;
    }
    if (*(void *)(v5 + 328)) {
      uint64_t v28 = nullsub_5;
    }
    else {
      uint64_t v28 = 0;
    }
LABEL_37:
    if (v28 && Alembic::Abc::v12::IArrayProperty::getNumSamples((Alembic::Abc::v12::IArrayProperty *)(v5 + 296)))
    {
      Alembic::Abc::v12::IScalarProperty::getTimeSampling(v6, &v60);
      uint64_t NumSamples = Alembic::Abc::v12::IArrayProperty::getNumSamples((Alembic::Abc::v12::IArrayProperty *)(v5 + 296));
      uint64_t Index = (void *)Alembic::Abc::v12::ISampleSelector::getIndex(a3, (double ***)&v60, NumSamples);
      if (v61) {
        sub_216784EC4(v61);
      }
      uint64_t v57 = 0;
      char v58 = 0;
      unint64_t v60 = Index;
      uint64_t v61 = 0;
      int v62 = 2;
      sub_2167B5C40(v5 + 296, &v57, (uint64_t)&v60);
      if (v57)
      {
        uint64_t v32 = *(void *)(v5 + 344);
        uint64_t v31 = *(void *)(v5 + 352);
        unint64_t v60 = 0;
        uint64_t v33 = v31 - v32;
        if (v33)
        {
          uint64_t v34 = 0;
          unint64_t v35 = 0;
          unint64_t v36 = 0x6DB6DB6DB6DB6DB7 * (v33 >> 3);
          do
          {
            uint64_t v37 = *(void *)(v5 + 344);
            double v38 = (int *)(v37 + 56 * v35);
            int v45 = *v38;
            uint64_t v39 = (void **)(v38 + 2);
            if (*((char *)v38 + 31) < 0)
            {
              sub_216778F24(&v46, *v39, *(void *)(v37 + 56 * v35 + 16));
            }
            else
            {
              long long v40 = *(_OWORD *)v39;
              uint64_t v47 = *((void *)v38 + 3);
              long long v46 = v40;
            }
            uint64_t v48 = 0;
            long long v49 = 0;
            uint64_t v50 = 0;
            sub_21677CA50(&v48, *(const void **)(v37 + 56 * v35 + 32), *(void *)(v37 + 56 * v35 + 40), (uint64_t)(*(void *)(v37 + 56 * v35 + 40) - *(void *)(v37 + 56 * v35 + 32)) >> 3);
            Alembic::AbcGeom::v12::CameraSample::addOp((void *)a2, (uint64_t)&v45);
            if (v48)
            {
              long long v49 = v48;
              operator delete(v48);
            }
            if (SHIBYTE(v47) < 0) {
              operator delete((void *)v46);
            }
            unint64_t v41 = (Alembic::AbcGeom::v12::FilmBackXformOp *)Alembic::AbcGeom::v12::CameraSample::operator[](a2, &v60);
            uint64_t NumChannels = Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels(v41);
            if (NumChannels)
            {
              for (unint64_t i = 0; i != NumChannels; ++i)
                Alembic::AbcGeom::v12::FilmBackXformOp::setChannelValue((uint64_t)v41, i, *(double *)(*v57 + 8 * v34 + 8 * i));
              v34 += i;
              uint64_t v5 = v44;
            }
            unint64_t v35 = (unint64_t)v60 + 1;
            unint64_t v60 = (void *)v35;
          }
          while (v35 < v36);
        }
      }
      if (v58) {
        sub_216784EC4(v58);
      }
    }
    return;
  }
  Alembic::Abc::v12::IScalarProperty::getTimeSampling(v6, &v60);
  uint64_t v12 = Alembic::Abc::v12::IScalarProperty::getNumSamples((Alembic::Abc::v12::IScalarProperty *)(v5 + 248));
  uint64_t v13 = Alembic::Abc::v12::ISampleSelector::getIndex(a3, (double ***)&v60, v12);
  if (v61) {
    sub_216784EC4(v61);
  }
  uint64_t v14 = sub_2167B5CBC(v5 + 248);
  sub_21678275C(&v60, *(unsigned __int8 *)(v14 + 60));
  uint64_t v57 = (void *)v13;
  char v58 = 0;
  int v59 = 2;
  Alembic::Abc::v12::IScalarProperty::get(v5 + 248, (uint64_t)v60, (uint64_t)&v57, 0);
  uint64_t v16 = *(void *)(v5 + 344);
  uint64_t v15 = *(void *)(v5 + 352);
  uint64_t v57 = 0;
  uint64_t v17 = v15 - v16;
  if (v17)
  {
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    unint64_t v20 = 0x6DB6DB6DB6DB6DB7 * (v17 >> 3);
    do
    {
      uint64_t v21 = *(void *)(v5 + 344);
      double v22 = (int *)(v21 + 56 * v19);
      int v51 = *v22;
      uint64_t v23 = (void **)(v22 + 2);
      if (*((char *)v22 + 31) < 0)
      {
        sub_216778F24(&v52, *v23, *(void *)(v21 + 56 * v19 + 16));
      }
      else
      {
        long long v24 = *(_OWORD *)v23;
        uint64_t v53 = *((void *)v22 + 3);
        long long v52 = v24;
      }
      long long __p = 0;
      int v55 = 0;
      uint64_t v56 = 0;
      sub_21677CA50(&__p, *(const void **)(v21 + 56 * v19 + 32), *(void *)(v21 + 56 * v19 + 40), (uint64_t)(*(void *)(v21 + 56 * v19 + 40) - *(void *)(v21 + 56 * v19 + 32)) >> 3);
      Alembic::AbcGeom::v12::CameraSample::addOp((void *)a2, (uint64_t)&v51);
      if (__p)
      {
        int v55 = __p;
        operator delete(__p);
      }
      if (SHIBYTE(v53) < 0) {
        operator delete((void *)v52);
      }
      int v25 = (Alembic::AbcGeom::v12::FilmBackXformOp *)Alembic::AbcGeom::v12::CameraSample::operator[](a2, &v57);
      uint64_t v26 = Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels(v25);
      if (v26)
      {
        unint64_t v27 = 0;
        while (v18 + v27 < ((char *)v61 - (unsigned char *)v60) >> 3)
        {
          Alembic::AbcGeom::v12::FilmBackXformOp::setChannelValue((uint64_t)v25, v27, *((double *)v60 + v18 + v27));
          if (v26 == ++v27)
          {
            v18 += v27;
            goto LABEL_27;
          }
        }
        v18 += v27;
      }
LABEL_27:
      unint64_t v19 = (unint64_t)v57 + 1;
      uint64_t v57 = (void *)v19;
      uint64_t v5 = v44;
    }
    while (v19 < v20);
  }
  if (v60)
  {
    uint64_t v61 = (std::__shared_weak_count *)v60;
    operator delete(v60);
  }
}

void sub_2167B5AB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32,uint64_t a33,void *__p,uint64_t a35,uint64_t a36,char a37)
{
  if (a2)
  {
    if (a32) {
      sub_216784EC4(a32);
    }
    uint64_t v39 = __cxa_begin_catch(exception_object);
    if (a2 == 2) {
      sub_21679FA64((uint64_t)&a37, (uint64_t)v39);
    }
    else {
      sub_21679F9F4((uint64_t)&a37, 0);
    }
    __cxa_end_catch();
    JUMPOUT(0x2167B5A7CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167B5C40(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  long long v8 = 0;
  Alembic::Abc::v12::IArrayProperty::get(a1, (uint64_t)&v7, a3);
  uint64_t v5 = v7;
  unint64_t v4 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v6 = (std::__shared_weak_count *)a2[1];
  *a2 = v5;
  a2[1] = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167B5CA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B5CBC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

void sub_2167B5D14(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  long long v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  {
    {
      double v11 = operator new(0x50uLL);
      *double v11 = 0;
      v11[1] = 0;
      void v11[2] = 0;
      *((_DWORD *)v11 + 6) = 1;
      v11[6] = 0;
      v11[5] = 0;
      _DWORD v11[4] = v11 + 5;
      *((_DWORD *)v11 + 14) = 127;
      *((unsigned char *)v11 + 60) = 0;
      _DWORD v11[8] = 0;
      v11[9] = 0;
      Alembic::Abc::v12::IBasePropertyT<std::shared_ptr<Alembic::AbcCoreAbstract::v12::ScalarPropertyReader>>::getHeader(void)const::phd = (uint64_t)v11;
    }
  }
  JUMPOUT(0x2167B5D04);
}

void sub_2167B5DBC(_Unwind_Exception *a1)
{
}

void **sub_2167B5DF0(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = (Alembic::AbcGeom::v12::FilmBackXformOp *)*(result - 1);
  if (0x6DB6DB6DB6DB6DB7 * ((v6 - (uint64_t)v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = (Alembic::AbcGeom::v12::FilmBackXformOp *)((char *)v7 + 56 * a2);
      uint64_t v14 = 56 * a2;
      do
      {
        uint64_t result = (void **)Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp(v7);
        uint64_t v7 = (Alembic::AbcGeom::v12::FilmBackXformOp *)((char *)v7 + 56);
        v14 -= 56;
      }
      while (v14);
      uint64_t v7 = v13;
    }
    a1[1] = (uint64_t)v7;
  }
  else
  {
    uint64_t v8 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x492492492492492) {
      sub_21677CB10();
    }
    unint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x249249249249249) {
      unint64_t v11 = 0x492492492492492;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v21 = result;
    if (v11) {
      uint64_t v12 = (char *)sub_2167B421C((uint64_t)result, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = &v12[56 * v8];
    v18[0] = v12;
    v18[1] = v15;
    unint64_t v19 = v15;
    unint64_t v20 = &v12[56 * v11];
    uint64_t v16 = 56 * a2;
    uint64_t v17 = &v15[56 * a2];
    do
    {
      Alembic::AbcGeom::v12::FilmBackXformOp::FilmBackXformOp((Alembic::AbcGeom::v12::FilmBackXformOp *)v15);
      v15 += 56;
      v16 -= 56;
    }
    while (v16);
    unint64_t v19 = v17;
    sub_2167B41A4(a1, v18);
    return sub_2167B43B8(v18);
  }
  return result;
}

void sub_2167B5F58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_2167B43B8((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_2167B5F84(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v44 + 1) = 0;
  v45[0] = 0;
  *(void *)&long long v44 = (char *)&v44 + 8;
  int v46 = v10;
  sub_2167898D0(v47, (const void ***)&v44);
  v47[3] = 0;
  uint64_t v48 = 0;
  int v49 = 0;
  uint64_t v50 = 1;
  sub_2167877AC((uint64_t)&v44, *((void **)&v44 + 1));
  sub_2167A030C(a4, (uint64_t)&v46);
  sub_2167A030C(a5, (uint64_t)&v46);
  *(_DWORD *)a1 = v46;
  v45[34] = a1;
  v45[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  unint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v30 = sub_216779180(v45, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v30, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v32 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v32, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v33 = sub_216779180(v45, (uint64_t)"Nonexistent array property: ", 28);
    int v34 = *(char *)(a3 + 23);
    if (v34 >= 0) {
      uint64_t v35 = a3;
    }
    else {
      uint64_t v35 = *(void *)a3;
    }
    if (v34 >= 0) {
      uint64_t v36 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v36 = *(void *)(a3 + 8);
    }
    sub_216779180(v33, v35, v36);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v37 = __cxa_allocate_exception(0x20uLL);
    double v38 = sub_216779038(v37, (uint64_t)__p);
    __cxa_throw(v38, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v15 = *(_DWORD *)(v13 + 56) == 12 && *(_DWORD *)(v13 + 24) == 2;
  if (!v15 || (sub_2167B6500(v13 + 32, v50) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v44);
    unint64_t v19 = sub_216779180(v45, (uint64_t)"Incorrect match of header datatype: ", 36);
    unint64_t v20 = sub_21677D5B0(v19, (int *)(v14 + 56));
    uint64_t v21 = sub_216779180(v20, (uint64_t)" to expected: ", 14);
    uint64_t v39 = 0x10000000CLL;
    double v22 = sub_21677D5B0(v21, (int *)&v39);
    uint64_t v23 = sub_216779180(v22, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v40, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v40, __p);
    if ((v43 & 0x80u) == 0) {
      long long v24 = __p;
    }
    else {
      long long v24 = (void **)__p[0];
    }
    if ((v43 & 0x80u) == 0) {
      uint64_t v25 = v43;
    }
    else {
      uint64_t v25 = (uint64_t)__p[1];
    }
    uint64_t v26 = sub_216779180(v23, (uint64_t)v24, v25);
    unint64_t v27 = sub_216779180(v26, (uint64_t)" to expected: ", 14);
    sub_216779180(v27, (uint64_t)"", 0);
    if ((char)v43 < 0) {
      operator delete(__p[0]);
    }
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v28 = __cxa_allocate_exception(0x20uLL);
    uint64_t v29 = sub_216779038(v28, (uint64_t)__p);
    __cxa_throw(v29, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v44, v12, a3);
  long long v16 = v44;
  long long v44 = 0uLL;
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v44 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v44 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v48) {
    sub_216784EC4(v48);
  }
  sub_2167877AC((uint64_t)v47, (void *)v47[1]);
  return a1;
}

void sub_2167B63B8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B611CLL);
}

void sub_2167B64C0()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167B64F0);
}

uint64_t sub_2167B6500(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v7);
  if (v8 < 0)
  {
    BOOL v2 = v7[1] == 0;
    operator delete(v7[0]);
  }
  else
  {
    BOOL v2 = v8 == 0;
  }
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167B658C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B65A8(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v44 + 1) = 0;
  v45[0] = 0;
  *(void *)&long long v44 = (char *)&v44 + 8;
  int v46 = v10;
  sub_2167898D0(v47, (const void ***)&v44);
  v47[3] = 0;
  uint64_t v48 = 0;
  int v49 = 0;
  uint64_t v50 = 1;
  sub_2167877AC((uint64_t)&v44, *((void **)&v44 + 1));
  sub_2167A030C(a4, (uint64_t)&v46);
  sub_2167A030C(a5, (uint64_t)&v46);
  *(_DWORD *)a1 = v46;
  v45[34] = a1;
  v45[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  unint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v30 = sub_216779180(v45, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v30, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v32 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v32, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v33 = sub_216779180(v45, (uint64_t)"Nonexistent array property: ", 28);
    int v34 = *(char *)(a3 + 23);
    if (v34 >= 0) {
      uint64_t v35 = a3;
    }
    else {
      uint64_t v35 = *(void *)a3;
    }
    if (v34 >= 0) {
      uint64_t v36 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v36 = *(void *)(a3 + 8);
    }
    sub_216779180(v33, v35, v36);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v37 = __cxa_allocate_exception(0x20uLL);
    double v38 = sub_216779038(v37, (uint64_t)__p);
    __cxa_throw(v38, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v15 = *(_DWORD *)(v13 + 56) == 11 && *(_DWORD *)(v13 + 24) == 2;
  if (!v15 || (sub_2167B6B24(v13 + 32, v50) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v44);
    unint64_t v19 = sub_216779180(v45, (uint64_t)"Incorrect match of header datatype: ", 36);
    unint64_t v20 = sub_21677D5B0(v19, (int *)(v14 + 56));
    uint64_t v21 = sub_216779180(v20, (uint64_t)" to expected: ", 14);
    uint64_t v39 = 0x10000000BLL;
    double v22 = sub_21677D5B0(v21, (int *)&v39);
    uint64_t v23 = sub_216779180(v22, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v40, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v40, __p);
    if ((v43 & 0x80u) == 0) {
      uint64_t v24 = __p;
    }
    else {
      uint64_t v24 = (void **)__p[0];
    }
    if ((v43 & 0x80u) == 0) {
      uint64_t v25 = v43;
    }
    else {
      uint64_t v25 = (uint64_t)__p[1];
    }
    uint64_t v26 = sub_216779180(v23, (uint64_t)v24, v25);
    unint64_t v27 = sub_216779180(v26, (uint64_t)" to expected: ", 14);
    sub_216779180(v27, (uint64_t)"", 0);
    if ((char)v43 < 0) {
      operator delete(__p[0]);
    }
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v28 = __cxa_allocate_exception(0x20uLL);
    uint64_t v29 = sub_216779038(v28, (uint64_t)__p);
    __cxa_throw(v29, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v44, v12, a3);
  long long v16 = v44;
  long long v44 = 0uLL;
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v44 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v44 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v48) {
    sub_216784EC4(v48);
  }
  sub_2167877AC((uint64_t)v47, (void *)v47[1]);
  return a1;
}

void sub_2167B69DC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B6740);
}

void sub_2167B6AE4()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167B6B14);
}

uint64_t sub_2167B6B24(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v7);
  if (v8 < 0)
  {
    BOOL v2 = v7[1] == 0;
    operator delete(v7[0]);
  }
  else
  {
    BOOL v2 = v8 == 0;
  }
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167B6BB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Alembic::AbcGeom::v12::OCameraSchema::set(Alembic::AbcGeom::v12::OCameraSchema *this, uint64_t **a2)
{
  uint64_t v4 = 0;
  v81[16] = *MEMORY[0x263EF8340];
  uint64_t v5 = (_OWORD *)((char *)this + 472);
  unint64_t v79 = (char *)this + 8;
  uint64_t v80 = "OCameraSchema::set()";
  do
  {
    *(double *)&v81[v4] = Alembic::AbcGeom::v12::CameraSample::getCoreValue((Alembic::AbcGeom::v12::CameraSample *)a2, v4);
    ++v4;
  }
  while (v4 != 16);
  char v6 = (Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 56);
  if (Alembic::Abc::v12::OScalarProperty::getNumSamples((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 56)))
  {
    unint64_t NumOps = Alembic::AbcGeom::v12::CameraSample::getNumOps((Alembic::AbcGeom::v12::CameraSample *)a2);
    if (NumOps != Alembic::AbcGeom::v12::CameraSample::getNumOps((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 344)))
    {
      sub_216778A5C((uint64_t)&v49);
      sub_216779180(&v50, (uint64_t)"Number of Film Back Xform Ops differ expected: ", 47);
      Alembic::AbcGeom::v12::CameraSample::getNumOps((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 344));
      int v46 = (void *)std::ostream::operator<<();
      sub_216779180(v46, (uint64_t)" got: ", 6);
      std::ostream::operator<<();
      std::stringbuf::str();
      sub_216778E70(__p, (long long *)v77);
      if (v78 < 0) {
        operator delete(v77[0]);
      }
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v48 = sub_216779038(exception, (uint64_t)__p);
      __cxa_throw(v48, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    unint64_t NumOpChannels = Alembic::AbcGeom::v12::CameraSample::getNumOpChannels((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 344));
    sub_21678275C(v77, NumOpChannels);
    unint64_t v69 = 0;
    if (NumOps)
    {
      uint64_t v9 = 0;
      do
      {
        int v10 = (Alembic::AbcGeom::v12::FilmBackXformOp *)Alembic::AbcGeom::v12::CameraSample::operator[]((uint64_t)a2, &v69);
        unint64_t v11 = (Alembic::AbcGeom::v12::FilmBackXformOp *)Alembic::AbcGeom::v12::CameraSample::operator[]((uint64_t)this + 344, &v69);
        int Type = Alembic::AbcGeom::v12::FilmBackXformOp::getType(v11);
        if (Type != Alembic::AbcGeom::v12::FilmBackXformOp::getType(v10))
        {
          sub_216778A5C((uint64_t)&v49);
          sub_216779180(&v50, (uint64_t)"Film Back Xform Operation type differs from initial sample at index: ", 69);
          std::ostream::operator<<();
          std::stringbuf::str();
          sub_216778E70(__p, (long long *)v75);
          if (v76 < 0) {
            operator delete(v75[0]);
          }
          long long v44 = __cxa_allocate_exception(0x20uLL);
          int v45 = sub_216779038(v44, (uint64_t)__p);
          __cxa_throw(v45, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
        }
        uint64_t NumChannels = Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels(v10);
        if (NumChannels)
        {
          for (unint64_t i = 0; i != NumChannels; ++i)
          {
            double ChannelValue = Alembic::AbcGeom::v12::FilmBackXformOp::getChannelValue(v10, i);
            *((double *)v77[0] + v9 + i) = ChannelValue;
          }
          v9 += i;
        }
        ++v69;
      }
      while (v69 < NumOps);
    }
    if (*((char *)this + 327) < 0)
    {
      if (*((void *)this + 39)) {
        goto LABEL_15;
      }
    }
    else if (*((unsigned char *)this + 327))
    {
LABEL_15:
      long long v16 = 0;
      goto LABEL_60;
    }
    if (*((void *)this + 41)) {
      long long v16 = nullsub_6;
    }
    else {
      long long v16 = 0;
    }
LABEL_60:
    if (v16)
    {
      Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 296), v77[0]);
LABEL_62:
      if (v77[0])
      {
        v77[1] = v77[0];
        operator delete(v77[0]);
      }
      return Alembic::Abc::v12::OScalarProperty::set(v6, v81);
    }
    if (*((char *)this + 279) < 0)
    {
      if (*((void *)this + 33)) {
        goto LABEL_66;
      }
    }
    else if (*((unsigned char *)this + 279))
    {
LABEL_66:
      double v38 = 0;
      goto LABEL_88;
    }
    if (*((void *)this + 35)) {
      double v38 = nullsub_7;
    }
    else {
      double v38 = 0;
    }
LABEL_88:
    if (v38)
    {
      sub_2167B95A0(&v49, (uint64_t)v77[0], ((char *)v77[1] - (char *)v77[0]) >> 3);
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 248);
      if (v50)
      {
        int v51 = v50;
        operator delete(v50);
      }
    }
    goto LABEL_62;
  }
  long long v17 = *(_OWORD *)a2;
  long long v18 = *((_OWORD *)a2 + 1);
  long long v19 = *((_OWORD *)a2 + 3);
  *(_OWORD *)((char *)this + 376) = *((_OWORD *)a2 + 2);
  *(_OWORD *)((char *)this + 392) = v19;
  *(_OWORD *)((char *)this + 344) = v17;
  *(_OWORD *)((char *)this + 360) = v18;
  long long v20 = *((_OWORD *)a2 + 4);
  long long v21 = *((_OWORD *)a2 + 5);
  long long v22 = *((_OWORD *)a2 + 7);
  *(_OWORD *)((char *)this + 440) = *((_OWORD *)a2 + 6);
  *(_OWORD *)((char *)this + 456) = v22;
  *(_OWORD *)((char *)this + 408) = v20;
  *(_OWORD *)((char *)this + 424) = v21;
  *uint64_t v5 = *((_OWORD *)a2 + 8);
  v5[1] = *((_OWORD *)a2 + 9);
  uint64_t v5[2] = *((_OWORD *)a2 + 10);
  if ((uint64_t **)((char *)this + 344) != a2) {
    sub_2167B854C((uint64_t)this + 520, a2[22], a2[23], 0x6DB6DB6DB6DB6DB7 * (a2[23] - a2[22]));
  }
  unint64_t v23 = Alembic::AbcGeom::v12::CameraSample::getNumOpChannels((Alembic::AbcGeom::v12::CameraSample *)a2);
  uint64_t v24 = (void *)Alembic::AbcGeom::v12::CameraSample::getNumOps((Alembic::AbcGeom::v12::CameraSample *)a2);
  sub_216782DE0(v77, (unint64_t)v24);
  sub_21678275C(v75, v23);
  __p[0] = 0;
  if (!v24) {
    goto LABEL_34;
  }
  uint64_t v25 = 0;
  do
  {
    uint64_t v26 = (Alembic::AbcGeom::v12::FilmBackXformOp *)Alembic::AbcGeom::v12::CameraSample::operator[]((uint64_t)a2, __p);
    Alembic::AbcGeom::v12::FilmBackXformOp::getTypeAndHint(v26, &v49);
    unint64_t v27 = (char *)v77[0] + 24 * (uint64_t)__p[0];
    if (v27[23] < 0) {
      operator delete(*(void **)v27);
    }
    unint64_t v28 = 0;
    long long v29 = v49;
    *((void *)v27 + 2) = v50;
    *(_OWORD *)unint64_t v27 = v29;
    while (v28 < Alembic::AbcGeom::v12::FilmBackXformOp::getNumChannels(v26))
    {
      double v30 = Alembic::AbcGeom::v12::FilmBackXformOp::getChannelValue(v26, v28);
      *((double *)v75[0] + v25 + v28++) = v30;
    }
    ++__p[0];
    v25 += v28;
  }
  while (__p[0] < v24);
  if ((unint64_t)v24 < 0x100)
  {
    int v73 = 12;
    char v74 = (char)v24;
    uint64_t v31 = (std::__shared_weak_count *)*((void *)this + 6);
    uint64_t v71 = *((void *)this + 5);
    long long v72 = v31;
    if (v31) {
      atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(__p, ".filmBackOps");
    LODWORD(v69) = 0;
    int v70 = 0;
    int v67 = 0;
    int v68 = 0;
    int v65 = 0;
    int v66 = 0;
    int v63 = 0;
    int v64 = 0;
    Alembic::Abc::v12::OScalarProperty::OScalarProperty(&v49, &v71, __p, &v73, &v69, &v67, &v65, &v63);
    if (SHIBYTE(v59) < 0) {
      operator delete(__p[0]);
    }
    if (v72) {
      sub_216784EC4(v72);
    }
    Alembic::Abc::v12::OScalarProperty::set((Alembic::Abc::v12::OScalarProperty *)&v49, v77[0]);
    Alembic::Abc::v12::OScalarProperty::~OScalarProperty((Alembic::Abc::v12::OScalarProperty *)&v49);
  }
  else
  {
LABEL_34:
    if (v23 >= 0x100)
    {
      uint64_t v32 = (std::__shared_weak_count *)*((void *)this + 6);
      uint64_t v61 = *((void *)this + 5);
      int v62 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      sub_216779094(__p, ".filmBackOps");
      LODWORD(v69) = 0;
      int v70 = 0;
      int v67 = 0;
      int v68 = 0;
      int v65 = 0;
      int v66 = 0;
      int v63 = 0;
      int v64 = 0;
      sub_2167B8B50((uint64_t)&v49, &v61, (uint64_t)__p, &v69, &v67, &v65, &v63);
      if (SHIBYTE(v59) < 0) {
        operator delete(__p[0]);
      }
      if (v62) {
        sub_216784EC4(v62);
      }
      sub_2167B902C(__p, (uint64_t)v77[0], 0xAAAAAAAAAAAAAAABLL * (((char *)v77[1] - (char *)v77[0]) >> 3));
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v49);
      if (v59)
      {
        unint64_t v60 = v59;
        operator delete(v59);
      }
      Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v49);
      goto LABEL_68;
    }
  }
  if (v23 - 1 <= 0xFE)
  {
    int v73 = 11;
    char v74 = v23;
    uint64_t v33 = (std::__shared_weak_count *)*((void *)this + 6);
    uint64_t v56 = *((void *)this + 5);
    uint64_t v57 = v33;
    if (v33) {
      atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(__p, ".filmBackChannels");
    LODWORD(v69) = 0;
    int v70 = 0;
    int v67 = 0;
    int v68 = 0;
    int v65 = 0;
    int v66 = 0;
    int v63 = 0;
    int v64 = 0;
    Alembic::Abc::v12::OScalarProperty::OScalarProperty(&v49, &v56, __p, &v73, &v69, &v67, &v65, &v63);
    *((_DWORD *)this + 74) = v49;
    std::string::operator=((std::string *)((char *)this + 304), (const std::string *)((char *)&v49 + 8));
    uint64_t v35 = v52;
    uint64_t v34 = v53;
    if (v53) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v53 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v36 = (std::__shared_weak_count *)*((void *)this + 42);
    *((void *)this + 41) = v35;
    *((void *)this + 42) = v34;
    if (v36) {
      sub_216784EC4(v36);
    }
    uint64_t v37 = (Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 296);
    Alembic::Abc::v12::OScalarProperty::~OScalarProperty((Alembic::Abc::v12::OScalarProperty *)&v49);
    if (SHIBYTE(v59) < 0) {
      operator delete(__p[0]);
    }
    if (v57) {
      sub_216784EC4(v57);
    }
    Alembic::Abc::v12::OScalarProperty::set(v37, v75[0]);
    goto LABEL_80;
  }
  if (v23 >= 0x100)
  {
LABEL_68:
    uint64_t v39 = (std::__shared_weak_count *)*((void *)this + 6);
    uint64_t v54 = *((void *)this + 5);
    int v55 = v39;
    if (v39) {
      atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(__p, ".filmBackChannels");
    LODWORD(v69) = 0;
    int v70 = 0;
    int v67 = 0;
    int v68 = 0;
    int v65 = 0;
    int v66 = 0;
    int v63 = 0;
    int v64 = 0;
    sub_2167B90C4((uint64_t)&v49, &v54, (uint64_t)__p, &v69, &v67, &v65, &v63);
    *((_DWORD *)this + 62) = v49;
    std::string::operator=((std::string *)((char *)this + 256), (const std::string *)((char *)&v49 + 8));
    uint64_t v41 = v52;
    uint64_t v40 = v53;
    if (v53) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v53 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v42 = (std::__shared_weak_count *)*((void *)this + 36);
    *((void *)this + 35) = v41;
    *((void *)this + 36) = v40;
    if (v42) {
      sub_216784EC4(v42);
    }
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v49);
    if (SHIBYTE(v59) < 0) {
      operator delete(__p[0]);
    }
    if (v55) {
      sub_216784EC4(v55);
    }
    sub_2167B95A0(&v49, (uint64_t)v75[0], ((char *)v75[1] - (char *)v75[0]) >> 3);
    Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 248);
    if (v50)
    {
      int v51 = v50;
      operator delete(v50);
    }
  }
LABEL_80:
  if (v75[0])
  {
    v75[1] = v75[0];
    operator delete(v75[0]);
  }
  *(void *)&long long v49 = v77;
  sub_216782F20((void ***)&v49);
  return Alembic::Abc::v12::OScalarProperty::set(v6, v81);
}

void sub_2167B7468(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49)
{
  if (a2)
  {
    sub_216779148((std::exception *)&a49);
    sub_216778D38((uint64_t)&a10);
    uint64_t v52 = __cxa_begin_catch(a1);
    if (a2 == 2) {
      sub_21679FA64(v49 - 240, (uint64_t)v52);
    }
    else {
      sub_21679F9F4(v49 - 240, 0);
    }
    __cxa_end_catch();
    JUMPOUT(0x2167B7294);
  }
  _Unwind_Resume(a1);
}

uint64_t Alembic::AbcGeom::v12::OCameraSchema::setFromPrevious(Alembic::AbcGeom::v12::OCameraSchema *this)
{
  uint64_t result = Alembic::Abc::v12::OScalarProperty::setFromPrevious((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 56));
  if (*((char *)this + 327) < 0)
  {
    if (*((void *)this + 39)) {
      goto LABEL_3;
    }
  }
  else if (*((unsigned char *)this + 327))
  {
LABEL_3:
    uint64_t v3 = 0;
    goto LABEL_8;
  }
  if (*((void *)this + 41)) {
    uint64_t v3 = nullsub_6;
  }
  else {
    uint64_t v3 = 0;
  }
LABEL_8:
  if (v3) {
    uint64_t result = Alembic::Abc::v12::OScalarProperty::setFromPrevious((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 296));
  }
  if (*((char *)this + 279) < 0)
  {
    if (*((void *)this + 33)) {
      goto LABEL_12;
    }
LABEL_14:
    if (*((void *)this + 35)) {
      uint64_t v4 = nullsub_7;
    }
    else {
      uint64_t v4 = 0;
    }
    goto LABEL_17;
  }
  if (!*((unsigned char *)this + 279)) {
    goto LABEL_14;
  }
LABEL_12:
  uint64_t v4 = 0;
LABEL_17:
  if (v4) {
    return Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 248));
  }
  return result;
}

void sub_2167B78D8(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B78C8);
}

void sub_2167B790C(_Unwind_Exception *a1)
{
}

uint64_t Alembic::AbcGeom::v12::OCameraSchema::setTimeSampling(Alembic::AbcGeom::v12::OCameraSchema *this)
{
  return Alembic::Abc::v12::OScalarProperty::setTimeSampling((Alembic::AbcGeom::v12::OCameraSchema *)((char *)this + 56));
}

void sub_2167B7968(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B7958);
}

void sub_2167B799C(_Unwind_Exception *a1)
{
}

int *Alembic::AbcGeom::v12::OCameraSchema::setTimeSampling(Alembic::AbcGeom::v12::OCameraSchema *a1, void *a2)
{
  uint64_t result = (int *)((char *)a1 + 8);
  char v6 = result;
  uint64_t v7 = "OCameraSchema::setTimeSampling( TimeSamplingPtr)";
  if (*a2)
  {
    sub_2167B7AC8(result, (uint64_t)v4);
    Alembic::Abc::v12::OObject::getArchive((Alembic::Abc::v12::OObject *)v4, (uint64_t)v5);
    Alembic::Abc::v12::OArchive::addTimeSampling((uint64_t)v5);
    Alembic::Abc::v12::OArchive::~OArchive((Alembic::Abc::v12::OArchive *)v5);
    Alembic::Abc::v12::OObject::~OObject((Alembic::Abc::v12::OObject *)v4);
    return (int *)Alembic::AbcGeom::v12::OCameraSchema::setTimeSampling(a1);
  }
  return result;
}

void sub_2167B7A40(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  long long v19 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v17 - 32, (uint64_t)v19);
  }
  else {
    sub_21679F9F4(v17 - 32, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B7A30);
}

void sub_2167B7AA8(_Unwind_Exception *a1)
{
}

void sub_2167B7AC8(int *a1@<X0>, uint64_t a2@<X8>)
{
  int v10 = a1;
  unint64_t v11 = "OBaseProperty::getObject()";
  (*(void (**)(uint64_t *__return_ptr))(**((void **)a1 + 4) + 24))(&v8);
  int v4 = *a1;
  v7[0] = 1;
  v7[2] = v4;
  v6[0] = 0;
  int v6[2] = 0;
  v5[0] = 0;
  uint64_t v5[2] = 0;
  sub_2167A5B3C(a2, &v8, v7, v6, v5);
  if (v9) {
    sub_216784EC4(v9);
  }
}

void sub_2167B7B78(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16) {
    sub_216784EC4(a16);
  }
  long long v20 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v17 - 48, (uint64_t)v20);
  }
  else {
    sub_21679F9F4(v17 - 48, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)(v16 + 8) = 2;
  sub_216779094((void *)(v16 + 16), "");
  *(void *)uint64_t v16 = &unk_26C7495D0;
  *(void *)(v16 + 40) = 0;
  *(void *)(v16 + 48) = 0;
  JUMPOUT(0x2167B7B64);
}

void sub_2167B7C04(_Unwind_Exception *a1)
{
}

void Alembic::AbcGeom::v12::OCameraSchema::init(Alembic::AbcGeom::v12::OCameraSchema *this, int a2)
{
  unint64_t v23 = (char *)this + 8;
  uint64_t v24 = "OCameraSchema::init()";
  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v16 = v5;
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v16 = 0;
  }
  int v21 = 11;
  char v22 = 16;
  uint64_t v15 = v4;
  sub_216779094(__p, ".core");
  v12[0] = 2;
  void v12[2] = a2;
  v11[0] = 0;
  void v11[2] = 0;
  v10[0] = 0;
  void v10[2] = 0;
  v9[0] = 0;
  int v9[2] = 0;
  Alembic::Abc::v12::OScalarProperty::OScalarProperty(&v17, &v15, __p, &v21, v12, v11, v10, v9);
  *((_DWORD *)this + 14) = v17;
  std::string::operator=((std::string *)((char *)this + 64), &v18);
  uint64_t v7 = v19;
  uint64_t v6 = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 12);
  *((void *)this + 11) = v7;
  *((void *)this + 12) = v6;
  if (v8) {
    sub_216784EC4(v8);
  }
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty((Alembic::Abc::v12::OScalarProperty *)&v17);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if (v16) {
    sub_216784EC4(v16);
  }
  if (v5) {
    sub_216784EC4(v5);
  }
}

void sub_2167B7D64(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,std::__shared_weak_count *a24,char a25)
{
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty((Alembic::Abc::v12::OScalarProperty *)&a25);
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a24) {
    sub_216784EC4(a24);
  }
  if (v25) {
    sub_216784EC4(v25);
  }
  double v30 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v31 = (uint64_t)v30;
    sub_2167B7E1C(v26);
    sub_21679FA64(v27 - 48, v31);
  }
  else
  {
    sub_2167B7E1C(v26);
    sub_21679F9F4(v27 - 48, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B7D50);
}

void sub_2167B7DFC(_Unwind_Exception *a1)
{
}

void sub_2167B7E1C(uint64_t a1)
{
  sub_2167A13A4(a1 + 56);
  sub_2167A13A4(a1 + 104);
  sub_2167A13A4(a1 + 152);
  sub_2167A13A4(a1 + 200);
  sub_2167A13A4(a1 + 248);
  sub_2167A13A4(a1 + 296);

  sub_2167A13A4(a1 + 8);
}

unsigned char *Alembic::AbcGeom::v12::OCameraSchema::getArbGeomParams@<X0>(Alembic::AbcGeom::v12::OCameraSchema *this@<X0>, uint64_t a2@<X8>)
{
  int v21 = (char *)this + 8;
  char v22 = "OCameraSchema::getArbGeomParams()";
  int v4 = *((char *)this + 231);
  if (v4 < 0)
  {
    if (!*((void *)this + 27)) {
      goto LABEL_5;
    }
  }
  else if (!*((unsigned char *)this + 231))
  {
LABEL_5:
    if (*((void *)this + 29)) {
      goto LABEL_17;
    }
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 6);
  uint64_t v15 = *((void *)this + 5);
  uint64_t v16 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216779094(__p, ".arbGeomParams");
  v12[0] = 0;
  void v12[2] = 0;
  v11[0] = 0;
  void v11[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(&v17, &v15, __p, v12, v11);
  *((_DWORD *)this + 50) = v17;
  std::string::operator=((std::string *)((char *)this + 208), &v18);
  uint64_t v7 = v19;
  uint64_t v6 = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 30);
  *((void *)this + 29) = v7;
  *((void *)this + 30) = v6;
  if (v8) {
    sub_216784EC4(v8);
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)&v17);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if (v16) {
    sub_216784EC4(v16);
  }
  LOBYTE(v4) = *((unsigned char *)this + 231);
LABEL_17:
  *(_DWORD *)a2 = *((_DWORD *)this + 50);
  uint64_t result = (unsigned char *)(a2 + 8);
  if ((v4 & 0x80) != 0)
  {
    uint64_t result = sub_216778F24(result, *((void **)this + 26), *((void *)this + 27));
  }
  else
  {
    *(_OWORD *)uint64_t result = *((_OWORD *)this + 13);
    *(void *)(a2 + 24) = *((void *)this + 28);
  }
  uint64_t v10 = *((void *)this + 30);
  *(void *)(a2 + 32) = *((void *)this + 29);
  *(void *)(a2 + 40) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_2167B7FE0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22)
{
  uint64_t v25 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v23 - 48, (uint64_t)v25);
  }
  else {
    sub_21679F9F4(v23 - 48, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v22 = 2;
  sub_216779094((void *)(v22 + 8), "");
  *(void *)(v22 + 32) = 0;
  *(void *)(v22 + 40) = 0;
  JUMPOUT(0x2167B7FCCLL);
}

void sub_2167B8080(_Unwind_Exception *a1)
{
}

unsigned char *Alembic::AbcGeom::v12::OCameraSchema::getUserProperties@<X0>(Alembic::AbcGeom::v12::OCameraSchema *this@<X0>, uint64_t a2@<X8>)
{
  int v21 = (char *)this + 8;
  uint64_t v22 = "OCameraSchema::getUserProperties()";
  int v4 = *((char *)this + 183);
  if (v4 < 0)
  {
    if (!*((void *)this + 21)) {
      goto LABEL_5;
    }
  }
  else if (!*((unsigned char *)this + 183))
  {
LABEL_5:
    if (*((void *)this + 23)) {
      goto LABEL_17;
    }
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 6);
  uint64_t v15 = *((void *)this + 5);
  uint64_t v16 = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216779094(__p, ".userProperties");
  v12[0] = 0;
  void v12[2] = 0;
  v11[0] = 0;
  void v11[2] = 0;
  Alembic::Abc::v12::OCompoundProperty::OCompoundProperty(&v17, &v15, __p, v12, v11);
  *((_DWORD *)this + 38) = v17;
  std::string::operator=((std::string *)((char *)this + 160), &v18);
  uint64_t v7 = v19;
  uint64_t v6 = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 24);
  *((void *)this + 23) = v7;
  *((void *)this + 24) = v6;
  if (v8) {
    sub_216784EC4(v8);
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)&v17);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if (v16) {
    sub_216784EC4(v16);
  }
  LOBYTE(v4) = *((unsigned char *)this + 183);
LABEL_17:
  *(_DWORD *)a2 = *((_DWORD *)this + 38);
  uint64_t result = (unsigned char *)(a2 + 8);
  if ((v4 & 0x80) != 0)
  {
    uint64_t result = sub_216778F24(result, *((void **)this + 20), *((void *)this + 21));
  }
  else
  {
    *(_OWORD *)uint64_t result = *((_OWORD *)this + 10);
    *(void *)(a2 + 24) = *((void *)this + 22);
  }
  uint64_t v10 = *((void *)this + 24);
  *(void *)(a2 + 32) = *((void *)this + 23);
  *(void *)(a2 + 40) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_2167B8200(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22)
{
  uint64_t v25 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v23 - 48, (uint64_t)v25);
  }
  else {
    sub_21679F9F4(v23 - 48, 0);
  }
  __cxa_end_catch();
  *(_DWORD *)uint64_t v22 = 2;
  sub_216779094((void *)(v22 + 8), "");
  *(void *)(v22 + 32) = 0;
  *(void *)(v22 + 40) = 0;
  JUMPOUT(0x2167B81ECLL);
}

void sub_2167B82A0(_Unwind_Exception *a1)
{
}

unsigned char *Alembic::AbcGeom::v12::OCameraSchema::getChildBoundsProperty@<X0>(Alembic::AbcGeom::v12::OCameraSchema *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v28 = (char *)this + 8;
  long long v29 = "OCameraSchema::getChildBoundsProperty()";
  if (*((char *)this + 135) < 0)
  {
    if (!*((void *)this + 15)) {
      goto LABEL_5;
    }
  }
  else if (!*((unsigned char *)this + 135))
  {
LABEL_5:
    if (*((void *)this + 17)) {
      goto LABEL_23;
    }
  }
  uint64_t v4 = *((void *)this + 5);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v23 = v5;
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    uint64_t v23 = 0;
  }
  uint64_t v22 = v4;
  sub_216779094(__p, ".childBnds");
  uint64_t v6 = sub_2167B8A1C((uint64_t)this + 56);
  uint64_t v7 = *(std::__shared_weak_count **)(v6 + 72);
  uint64_t v16 = *(void *)(v6 + 64);
  int v17 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v18 = 4;
  uint64_t v19 = &v16;
  v15[0] = 0;
  uint64_t v15[2] = 0;
  v14[0] = 0;
  void v14[2] = 0;
  v13[0] = 0;
  v13[2] = 0;
  sub_2167B9640((uint64_t)&v24, &v22, (uint64_t)__p, &v18, v15, v14, v13);
  *((_DWORD *)this + 26) = v24;
  std::string::operator=((std::string *)((char *)this + 112), &v25);
  uint64_t v9 = v26;
  uint64_t v8 = v27;
  if (v27) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 18);
  *((void *)this + 17) = v9;
  *((void *)this + 18) = v8;
  if (v10) {
    sub_216784EC4(v10);
  }
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty((Alembic::Abc::v12::OScalarProperty *)&v24);
  if (v17) {
    sub_216784EC4(v17);
  }
  if (v21 < 0) {
    operator delete(__p[0]);
  }
  if (v23) {
    sub_216784EC4(v23);
  }
  if (v5) {
    sub_216784EC4(v5);
  }
LABEL_23:
  *(_DWORD *)a2 = *((_DWORD *)this + 26);
  uint64_t result = (unsigned char *)(a2 + 8);
  if (*((char *)this + 135) < 0)
  {
    uint64_t result = sub_216778F24(result, *((void **)this + 14), *((void *)this + 15));
  }
  else
  {
    *(_OWORD *)uint64_t result = *((_OWORD *)this + 7);
    *(void *)(a2 + 24) = *((void *)this + 16);
  }
  uint64_t v12 = *((void *)this + 18);
  *(void *)(a2 + 32) = *((void *)this + 17);
  *(void *)(a2 + 40) = v12;
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void sub_2167B8490(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,std::__shared_weak_count *a27)
{
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty((Alembic::Abc::v12::OScalarProperty *)(v28 - 112));
  if (a17) {
    sub_216784EC4(a17);
  }
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a27) {
    sub_216784EC4(a27);
  }
  if (v27) {
    sub_216784EC4(v27);
  }
  uint64_t v31 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v28 - 64, (uint64_t)v31);
  }
  else {
    sub_21679F9F4(v28 - 64, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B842CLL);
}

void sub_2167B852C(_Unwind_Exception *a1)
{
}

void sub_2167B854C(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(void **)a1;
  if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    sub_2167B86F0((void **)a1);
    if (a4 > 0x492492492492492) {
      sub_21677CB10();
    }
    unint64_t v10 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)) >= 0x249249249249249) {
      unint64_t v11 = 0x492492492492492;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_2167B8760((void *)a1, v11);
    uint64_t v12 = sub_2167B87B8(v8, (uint64_t)a2, (uint64_t)a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    uint64_t v13 = &a2[(uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3];
    sub_2167B898C((uint64_t)&v17, a2, v13, (uint64_t)v9);
    uint64_t v12 = sub_2167B87B8(v8, (uint64_t)v13, (uint64_t)a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  sub_2167B898C((uint64_t)&v18, a2, a3, (uint64_t)v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 56;
      sub_2167B3F88(v8, v16);
    }
    while (v16 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_2167B86E0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_2167B86E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_2167B86F0(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 56;
        sub_2167B3F88((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *sub_2167B8760(void *a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    sub_21677CB10();
  }
  uint64_t result = (char *)sub_2167B421C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[56 * v4];
  return result;
}

uint64_t sub_2167B87B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  int v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_2167B8864(a1, v4, v6);
      v6 += 56;
      uint64_t v4 = v12 + 56;
      v12 += 56;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  sub_2167B8900((uint64_t)v9);
  return v4;
}

void sub_2167B8850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_2167B8864(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  uint64_t v5 = (unsigned char *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_216778F24(v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(a3 + 8);
    *(void *)(a2 + 24) = *(void *)(a3 + 24);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return sub_21677CA50((void *)(a2 + 32), *(const void **)(a3 + 32), *(void *)(a3 + 40), (uint64_t)(*(void *)(a3 + 40) - *(void *)(a3 + 32)) >> 3);
}

void sub_2167B88E4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B8900(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_2167B8938((uint64_t *)a1);
  }
  return a1;
}

void sub_2167B8938(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 56;
      sub_2167B3F88(v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t *sub_2167B898C(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v5 = a3;
  long long v6 = a2 + 5;
  do
  {
    uint64_t v7 = v6 - 5;
    *(_DWORD *)a4 = *((_DWORD *)v6 - 10);
    std::string::operator=((std::string *)(a4 + 8), (const std::string *)(v6 - 4));
    if ((uint64_t *)a4 != v6 - 5) {
      sub_21677CC7C((char *)(a4 + 32), (char *)*(v6 - 1), *v6, (*v6 - *(v6 - 1)) >> 3);
    }
    a4 += 56;
    v6 += 7;
  }
  while (v7 + 7 != v5);
  return v5;
}

uint64_t sub_2167B8A1C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32));
}

void sub_2167B8A74(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  char v10 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)&a9, (uint64_t)v10);
  }
  else {
    sub_21679F9F4((uint64_t)&a9, 0);
  }
  __cxa_end_catch();
  {
    {
      uint64_t v11 = operator new(0x50uLL);
      *uint64_t v11 = 0;
      v11[1] = 0;
      void v11[2] = 0;
      *((_DWORD *)v11 + 6) = 1;
      v11[6] = 0;
      v11[5] = 0;
      _DWORD v11[4] = v11 + 5;
      *((_DWORD *)v11 + 14) = 127;
      *((unsigned char *)v11 + 60) = 0;
      _DWORD v11[8] = 0;
      v11[9] = 0;
      Alembic::Abc::v12::OBasePropertyT<std::shared_ptr<Alembic::AbcCoreAbstract::v12::ScalarPropertyWriter>>::getHeader(void)const::g_phd = (uint64_t)v11;
    }
  }
  JUMPOUT(0x2167B8A64);
}

void sub_2167B8B1C(_Unwind_Exception *a1)
{
}

uint64_t sub_2167B8B50(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v14 = (std::__shared_weak_count *)a2[1];
  uint64_t v16 = *a2;
  char v17 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_2167B8C28(a1, &v16, a3, a4, a5, a6, a7);
  if (v17) {
    sub_216784EC4(v17);
  }
  return a1;
}

void sub_2167B8C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty(v10);
  _Unwind_Resume(a1);
}

void sub_2167B8C28(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  int v24 = 0;
  v25[0] = 0;
  uint64_t v23 = (const void **)&v24;
  int v26 = 2;
  sub_2167898D0((uint64_t *)v27, &v23);
  uint64_t v28 = 0;
  long long v29 = 0;
  int v30 = 0;
  uint64_t v31 = 1;
  sub_2167877AC((uint64_t)&v23, v24);
  sub_2167A030C(a4, (uint64_t)&v26);
  sub_2167A030C(a5, (uint64_t)&v26);
  sub_2167A030C(a6, (uint64_t)&v26);
  sub_2167A030C(a7, (uint64_t)&v26);
  *(_DWORD *)a1 = v26;
  v25[33] = a1;
  v25[34] = "OTypedArrayProperty::init()";
  if (!*a2)
  {
    sub_216778A5C((uint64_t)&v23);
    sub_216779180(v25, (uint64_t)"NULL CompoundPropertyWriterPtr", 30);
    std::stringbuf::str();
    sub_216778E70(v22, (long long *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v19 = sub_216779038(exception, (uint64_t)v22);
    __cxa_throw(v19, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_2167898D0((uint64_t *)&v23, v27);
  uint64_t v14 = v28;
  uint64_t v13 = v29;
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = *a2;
  if (v14)
  {
    (*(void (**)(void **__return_ptr))(*(void *)v15 + 24))(__p);
    (*(void (**)(_OWORD *__return_ptr))(*(void *)__p[0] + 24))(v22);
    (*(void (**)(void, uint64_t))(**(void **)&v22[0] + 48))(*(void *)&v22[0], v14);
    if (*((void *)&v22[0] + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v22[0] + 1));
    }
    if (__p[1]) {
      sub_216784EC4((std::__shared_weak_count *)__p[1]);
    }
    uint64_t v15 = *a2;
  }
  __p[0] = (void *)0x10000000CLL;
  (*(void (**)(_OWORD *__return_ptr))(*(void *)v15 + 104))(v22);
  long long v16 = v22[0];
  v22[0] = 0uLL;
  char v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v22[0] + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v22[0] + 1));
    }
  }
  if (v13) {
    sub_216784EC4(v13);
  }
  sub_2167877AC((uint64_t)&v23, v24);
  if (v29) {
    sub_216784EC4(v29);
  }
  sub_2167877AC((uint64_t)v27, v27[1]);
}

void sub_2167B8F04(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  char v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v11 = (uint64_t)v10;
    sub_2167A13A4(v6);
    sub_21679FA64(v7 - 160, v11);
  }
  else
  {
    sub_2167A13A4(v6);
    sub_21679F9F4(v7 - 160, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B8E50);
}

void sub_2167B8FE0(_Unwind_Exception *a1)
{
  sub_2167A03C4(v1 - 144);
  _Unwind_Resume(a1);
}

void *sub_2167B902C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a3;
  sub_2167864B4(&__p, 1uLL, &v6);
  *a1 = a2;
  a1[1] = 0x10000000CLL;
  a1[3] = 0;
  a1[4] = 0;
  a1[2] = 0;
  sub_21677EA60(a1 + 2, __p, (uint64_t)v8, (v8 - (unsigned char *)__p) >> 3);
  if (__p)
  {
    uint64_t v8 = __p;
    operator delete(__p);
  }
  return a1;
}

void sub_2167B90A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B90C4(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v14 = (std::__shared_weak_count *)a2[1];
  uint64_t v16 = *a2;
  uint64_t v17 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_2167B919C(a1, &v16, a3, a4, a5, a6, a7);
  if (v17) {
    sub_216784EC4(v17);
  }
  return a1;
}

void sub_2167B917C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty(v10);
  _Unwind_Resume(a1);
}

void sub_2167B919C(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  int v24 = 0;
  v25[0] = 0;
  uint64_t v23 = (const void **)&v24;
  int v26 = 2;
  sub_2167898D0((uint64_t *)v27, &v23);
  uint64_t v28 = 0;
  long long v29 = 0;
  int v30 = 0;
  uint64_t v31 = 1;
  sub_2167877AC((uint64_t)&v23, v24);
  sub_2167A030C(a4, (uint64_t)&v26);
  sub_2167A030C(a5, (uint64_t)&v26);
  sub_2167A030C(a6, (uint64_t)&v26);
  sub_2167A030C(a7, (uint64_t)&v26);
  *(_DWORD *)a1 = v26;
  v25[33] = a1;
  v25[34] = "OTypedArrayProperty::init()";
  if (!*a2)
  {
    sub_216778A5C((uint64_t)&v23);
    sub_216779180(v25, (uint64_t)"NULL CompoundPropertyWriterPtr", 30);
    std::stringbuf::str();
    sub_216778E70(v22, (long long *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v19 = sub_216779038(exception, (uint64_t)v22);
    __cxa_throw(v19, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  sub_2167898D0((uint64_t *)&v23, v27);
  uint64_t v14 = v28;
  uint64_t v13 = v29;
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = *a2;
  if (v14)
  {
    (*(void (**)(void **__return_ptr))(*(void *)v15 + 24))(__p);
    (*(void (**)(_OWORD *__return_ptr))(*(void *)__p[0] + 24))(v22);
    (*(void (**)(void, uint64_t))(**(void **)&v22[0] + 48))(*(void *)&v22[0], v14);
    if (*((void *)&v22[0] + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v22[0] + 1));
    }
    if (__p[1]) {
      sub_216784EC4((std::__shared_weak_count *)__p[1]);
    }
    uint64_t v15 = *a2;
  }
  __p[0] = (void *)0x10000000BLL;
  (*(void (**)(_OWORD *__return_ptr))(*(void *)v15 + 104))(v22);
  long long v16 = v22[0];
  v22[0] = 0uLL;
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v22[0] + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v22[0] + 1));
    }
  }
  if (v13) {
    sub_216784EC4(v13);
  }
  sub_2167877AC((uint64_t)&v23, v24);
  if (v29) {
    sub_216784EC4(v29);
  }
  sub_2167877AC((uint64_t)v27, v27[1]);
}

void sub_2167B9478(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  v12.__vftable = va_arg(va1, std::exception_vtbl *);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  sub_216779148((std::exception *)va);
  sub_216778D38((uint64_t)va1);
  char v10 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v11 = (uint64_t)v10;
    sub_2167A13A4(v6);
    sub_21679FA64(v7 - 160, v11);
  }
  else
  {
    sub_2167A13A4(v6);
    sub_21679F9F4(v7 - 160, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167B93C4);
}

void sub_2167B9554(_Unwind_Exception *a1)
{
  sub_2167A03C4(v1 - 144);
  _Unwind_Resume(a1);
}

void *sub_2167B95A0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a3;
  sub_2167864B4(&__p, 1uLL, &v6);
  *a1 = a2;
  a1[1] = 0x10000000BLL;
  a1[3] = 0;
  a1[4] = 0;
  a1[2] = 0;
  sub_21677EA60(a1 + 2, __p, (uint64_t)v8, (v8 - (unsigned char *)__p) >> 3);
  if (__p)
  {
    uint64_t v8 = __p;
    operator delete(__p);
  }
  return a1;
}

void sub_2167B961C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167B9640(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v14 = (std::__shared_weak_count *)a2[1];
  uint64_t v16 = *a2;
  uint64_t v17 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_2167B180C(a1, &v16, a3, a4, a5, a6, a7);
  if (v17) {
    sub_216784EC4(v17);
  }
  return a1;
}

void sub_2167B96F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  Alembic::Abc::v12::OScalarProperty::~OScalarProperty(v10);
  _Unwind_Resume(a1);
}

void *Alembic::AbcGeom::v12::GetBasisNameFromBasisType@<X0>(int a1@<W0>, void *a2@<X8>)
{
  if ((a1 - 1) > 4) {
    uint64_t v2 = "none";
  }
  else {
    uint64_t v2 = off_2642941F8[a1 - 1];
  }
  return sub_216779094(a2, v2);
}

uint64_t Alembic::AbcGeom::v12::GetStepFromBasisType(int a1)
{
  if ((a1 - 1) > 4) {
    return 1;
  }
  else {
    return dword_21740A018[a1 - 1];
  }
}

uint64_t Alembic::AbcGeom::v12::ICurvesSchema::getTopologyVariance(Alembic::AbcGeom::v12::ICurvesSchema *this)
{
  if (!Alembic::Abc::v12::IArrayProperty::isConstant((Alembic::AbcGeom::v12::ICurvesSchema *)((char *)this + 248))) {
    goto LABEL_11;
  }
  if (*((char *)this + 927) < 0)
  {
    if (!*((void *)this + 114))
    {
LABEL_6:
      if (*((void *)this + 116)
        && !Alembic::Abc::v12::IArrayProperty::isConstant((Alembic::AbcGeom::v12::ICurvesSchema *)((char *)this + 896)))
      {
        goto LABEL_11;
      }
    }
  }
  else if (!*((unsigned char *)this + 927))
  {
    goto LABEL_6;
  }
  if (Alembic::Abc::v12::IArrayProperty::isConstant((Alembic::AbcGeom::v12::ICurvesSchema *)((char *)this + 344))
    && (Alembic::Abc::v12::IScalarProperty::isConstant((Alembic::AbcGeom::v12::ICurvesSchema *)((char *)this + 392)) & 1) != 0)
  {
    return 0;
  }
LABEL_11:
  if (Alembic::Abc::v12::IArrayProperty::isConstant((Alembic::AbcGeom::v12::ICurvesSchema *)((char *)this + 344))
    && (Alembic::Abc::v12::IScalarProperty::isConstant((Alembic::AbcGeom::v12::ICurvesSchema *)((char *)this + 392)) & 1) != 0)
  {
    return 1;
  }
  else
  {
    return 2;
  }
}

void sub_2167B9850(_Unwind_Exception *a1)
{
}

void Alembic::AbcGeom::v12::ICurvesSchema::init(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 8;
  uint64_t v86 = a1 + 8;
  uint64_t v87 = "ICurvesSchema::init()";
  *(_OWORD *)&v57.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v56 = &v57;
  int v81 = 2;
  sub_2167898D0(v82, (const void ***)&v56);
  v82[3] = 0;
  unsigned int v83 = 0;
  int v84 = 0;
  uint64_t v85 = 1;
  sub_2167877AC((uint64_t)&v56, v57.__r_.__value_.__l.__data_);
  sub_2167A030C(a2, (uint64_t)&v81);
  sub_2167A030C(a3, (uint64_t)&v81);
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 48);
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    char v78 = v7;
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  else
  {
    char v78 = 0;
  }
  uint64_t v77 = v8;
  int v75 = 0;
  int v76 = 0;
  int v73 = 0;
  int v74 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v79, &v77, &v75, &v73);
  sub_216779094(__p, "P");
  int v69 = 5;
  int v70 = 1;
  v68[0] = 1;
  v68[2] = v81;
  sub_2167BAD00((uint64_t)&v56, (int *)v79, (uint64_t)__p, &v69, v68);
  *(_DWORD *)(a1 + 248) = v56;
  std::string::operator=((std::string *)(a1 + 256), &v57);
  uint64_t v10 = v58;
  uint64_t v9 = v59;
  if (v59) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = *(std::__shared_weak_count **)(a1 + 288);
  *(void *)(a1 + 280) = v10;
  *(void *)(a1 + 288) = v9;
  if (v11) {
    sub_216784EC4(v11);
  }
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v72 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v79);
  if (v78) {
    sub_216784EC4(v78);
  }
  uint64_t v66 = v8;
  int v67 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v75 = 0;
  int v76 = 0;
  int v73 = 0;
  int v74 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v79, &v66, &v75, &v73);
  sub_216779094(__p, "nVertices");
  sub_2167BB37C((uint64_t)&v56, (int *)v79, (uint64_t)__p, a2, a3);
  *(_DWORD *)(a1 + 344) = v56;
  std::string::operator=((std::string *)(a1 + 352), &v57);
  uint64_t v13 = v58;
  uint64_t v12 = v59;
  if (v59) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 384);
  *(void *)(a1 + 376) = v13;
  *(void *)(a1 + 384) = v12;
  if (v14) {
    sub_216784EC4(v14);
  }
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v72 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v79);
  if (v67) {
    sub_216784EC4(v67);
  }
  uint64_t v64 = v8;
  int v65 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v75 = 0;
  int v76 = 0;
  int v73 = 0;
  int v74 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v79, &v64, &v75, &v73);
  sub_216779094(__p, "curveBasisAndType");
  int v69 = 1;
  int v70 = v81;
  Alembic::Abc::v12::IScalarProperty::IScalarProperty(&v56, v79, __p, &v69);
  *(_DWORD *)(a1 + 392) = v56;
  std::string::operator=((std::string *)(a1 + 400), &v57);
  uint64_t v16 = v58;
  uint64_t v15 = v59;
  if (v59) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 432);
  *(void *)(a1 + 424) = v16;
  *(void *)(a1 + 432) = v15;
  if (v17) {
    sub_216784EC4(v17);
  }
  Alembic::Abc::v12::IScalarProperty::~IScalarProperty((Alembic::Abc::v12::IScalarProperty *)&v56);
  if (v72 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v79);
  if (v65) {
    sub_216784EC4(v65);
  }
  sub_216779094(&v56, "w");
  Propertyuint64_t Header = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v19 = PropertyHeader;
  if (v57.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(v56);
    if (!v19) {
      goto LABEL_46;
    }
  }
  else if (!PropertyHeader)
  {
    goto LABEL_46;
  }
  uint64_t v62 = v8;
  int v63 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v75 = 0;
  int v76 = 0;
  int v73 = 0;
  int v74 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v79, &v62, &v75, &v73);
  sub_216779094(__p, "w");
  sub_2167BB9A0((uint64_t)&v56, (int *)v79, (uint64_t)__p, a2, a3);
  *(_DWORD *)(a1 + 896) = v56;
  std::string::operator=((std::string *)(a1 + 904), &v57);
  uint64_t v21 = v58;
  uint64_t v20 = v59;
  if (v59) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 928) = v21;
  uint64_t v22 = *(std::__shared_weak_count **)(a1 + 936);
  *(void *)(a1 + 936) = v20;
  if (v22) {
    sub_216784EC4(v22);
  }
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v72 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v79);
  if (v63) {
    sub_216784EC4(v63);
  }
LABEL_46:
  sub_216779094(&v56, "uv");
  uint64_t v23 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v24 = v23;
  if (v57.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(v56);
    if (!v24) {
      goto LABEL_56;
    }
  }
  else if (!v23)
  {
    goto LABEL_56;
  }
  uint64_t v54 = v8;
  int v55 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216779094(v79, "uv");
  sub_2167BBFC4((uint64_t)&v56, &v54, (uint64_t)v79, a2, a3);
  sub_2167BA690(a1 + 592, (uint64_t)&v56);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v61);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)v60);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v80 < 0) {
    operator delete(v79[0]);
  }
  if (v55) {
    sub_216784EC4(v55);
  }
LABEL_56:
  sub_216779094(&v56, "N");
  uint64_t v25 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v26 = v25;
  if (v57.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(v56);
    if (!v26) {
      goto LABEL_66;
    }
  }
  else if (!v25)
  {
    goto LABEL_66;
  }
  uint64_t v52 = v8;
  uint64_t v53 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216779094(v79, "N");
  sub_2167BD348((uint64_t)&v56, &v52, (uint64_t)v79, a2, a3);
  sub_2167BA690(a1 + 744, (uint64_t)&v56);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v61);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)v60);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v80 < 0) {
    operator delete(v79[0]);
  }
  if (v53) {
    sub_216784EC4(v53);
  }
LABEL_66:
  sub_216779094(&v56, "width");
  uint64_t v27 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v28 = v27;
  if (v57.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(v56);
    if (!v28) {
      goto LABEL_76;
    }
  }
  else if (!v27)
  {
    goto LABEL_76;
  }
  uint64_t v50 = v8;
  int v51 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216779094(v79, "width");
  sub_2167BE1A0((uint64_t)&v56, &v50, (uint64_t)v79, a2, a3);
  sub_2167BA690(a1 + 440, (uint64_t)&v56);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v61);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)v60);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v80 < 0) {
    operator delete(v79[0]);
  }
  if (v51) {
    sub_216784EC4(v51);
  }
LABEL_76:
  sub_216779094(&v56, ".velocities");
  uint64_t v29 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v30 = v29;
  if (v57.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(v56);
    if (!v30) {
      goto LABEL_90;
    }
  }
  else if (!v29)
  {
    goto LABEL_90;
  }
  uint64_t v48 = v8;
  uint64_t v49 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v75 = 0;
  int v76 = 0;
  int v73 = 0;
  int v74 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v79, &v48, &v75, &v73);
  sub_216779094(__p, ".velocities");
  sub_2167BE97C((uint64_t)&v56, (int *)v79, (uint64_t)__p, a2, a3);
  *(_DWORD *)(a1 + 296) = v56;
  std::string::operator=((std::string *)(a1 + 304), &v57);
  uint64_t v32 = v58;
  uint64_t v31 = v59;
  if (v59) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v33 = *(std::__shared_weak_count **)(a1 + 336);
  *(void *)(a1 + 328) = v32;
  *(void *)(a1 + 336) = v31;
  if (v33) {
    sub_216784EC4(v33);
  }
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v72 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v79);
  if (v49) {
    sub_216784EC4(v49);
  }
LABEL_90:
  sub_216779094(&v56, ".orders");
  uint64_t v34 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v35 = v34;
  if (v57.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(v56);
    if (!v35) {
      goto LABEL_104;
    }
  }
  else if (!v34)
  {
    goto LABEL_104;
  }
  uint64_t v46 = v8;
  uint64_t v47 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v75 = 0;
  int v76 = 0;
  int v73 = 0;
  int v74 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v79, &v46, &v75, &v73);
  sub_216779094(__p, ".orders");
  sub_2167BEFF8((uint64_t)&v56, (int *)v79, (uint64_t)__p, a2, a3);
  *(_DWORD *)(a1 + 944) = v56;
  std::string::operator=((std::string *)(a1 + 952), &v57);
  uint64_t v37 = v58;
  uint64_t v36 = v59;
  if (v59) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 976) = v37;
  double v38 = *(std::__shared_weak_count **)(a1 + 984);
  *(void *)(a1 + 984) = v36;
  if (v38) {
    sub_216784EC4(v38);
  }
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v72 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v79);
  if (v47) {
    sub_216784EC4(v47);
  }
LABEL_104:
  sub_216779094(&v56, ".knots");
  uint64_t v39 = Alembic::Abc::v12::ICompoundProperty::getPropertyHeader(v6);
  uint64_t v40 = v39;
  if (v57.__r_.__value_.__s.__data_[15] < 0)
  {
    operator delete(v56);
    if (!v40) {
      goto LABEL_118;
    }
  }
  else if (!v39)
  {
    goto LABEL_118;
  }
  uint64_t v44 = v8;
  int v45 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v75 = 0;
  int v76 = 0;
  int v73 = 0;
  int v74 = 0;
  Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(v79, &v44, &v75, &v73);
  sub_216779094(__p, ".knots");
  sub_2167BB9A0((uint64_t)&v56, (int *)v79, (uint64_t)__p, a2, a3);
  *(_DWORD *)(a1 + 992) = v56;
  std::string::operator=((std::string *)(a1 + 1000), &v57);
  uint64_t v42 = v58;
  uint64_t v41 = v59;
  if (v59) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 1024) = v42;
  unsigned __int8 v43 = *(std::__shared_weak_count **)(a1 + 1032);
  *(void *)(a1 + 1032) = v41;
  if (v43) {
    sub_216784EC4(v43);
  }
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v56);
  if (v72 < 0) {
    operator delete(__p[0]);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)v79);
  if (v45) {
    sub_216784EC4(v45);
  }
LABEL_118:
  if (v7) {
    sub_216784EC4(v7);
  }
  if (v83) {
    sub_216784EC4(v83);
  }
  sub_2167877AC((uint64_t)v82, (void *)v82[1]);
}

void sub_2167BA23C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&a21);
  if (a58 < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)(v60 - 208));
  if (a10) {
    sub_216784EC4(a10);
  }
  if (v59) {
    sub_216784EC4(v59);
  }
  sub_2167A03C4(v60 - 160);
  int v63 = __cxa_begin_catch(a1);
  uint64_t v64 = *(void (**)(uint64_t))(*(void *)v58 + 16);
  if (a2 == 2)
  {
    uint64_t v65 = (uint64_t)v63;
    v64(v58);
    sub_21679FA64(v60 - 96, v65);
  }
  else
  {
    v64(v58);
    sub_21679F9F4(v60 - 96, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BA21CLL);
}

void sub_2167BA64C(_Unwind_Exception *a1)
{
}

void sub_2167BA66C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,void *a22)
{
}

void sub_2167BA684()
{
}

uint64_t sub_2167BA690(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  std::string::operator=((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v4 = *(void *)(a2 + 40);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 40);
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  std::string::operator=((std::string *)(a1 + 56), (const std::string *)(a2 + 56));
  uint64_t v8 = *(void *)(a2 + 80);
  uint64_t v7 = *(void *)(a2 + 88);
  if (v7) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 88);
  *(void *)(a1 + 80) = v8;
  *(void *)(a1 + 88) = v7;
  if (v9) {
    sub_216784EC4(v9);
  }
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  std::string::operator=((std::string *)(a1 + 104), (const std::string *)(a2 + 104));
  uint64_t v11 = *(void *)(a2 + 128);
  uint64_t v10 = *(void *)(a2 + 136);
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 136);
  *(void *)(a1 + 128) = v11;
  *(void *)(a1 + 136) = v10;
  if (v12) {
    sub_216784EC4(v12);
  }
  *(unsigned char *)(a1 + 144) = *(unsigned char *)(a2 + 144);
  return a1;
}

void sub_2167BA760(uint64_t a1)
{
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)(a1 + 96));
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)(a1 + 48));

  Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)a1);
}

void Alembic::AbcGeom::v12::ICurvesSchema::get(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  uint64_t v16 = a1 + 1;
  uint64_t v17 = "ICurvesSchema::get()";
  if (((*(uint64_t (**)(void))(v6 + 24))() & 1) == 0) {
    return;
  }
  sub_2167BAA94((uint64_t)(a1 + 31), (void *)a2, a3);
  sub_2167BAB10((uint64_t)(a1 + 43), (void *)(a2 + 96), a3);
  Alembic::Abc::v12::IScalarProperty::get((uint64_t)(a1 + 49), (uint64_t)v15, a3, 4);
  int v7 = v15[1];
  int v8 = v15[2];
  *(_DWORD *)(a2 + 144) = v15[0];
  *(_DWORD *)(a2 + 148) = v8;
  *(_DWORD *)(a2 + 152) = v7;
  if (*((char *)a1 + 927) < 0)
  {
    if (a1[114]) {
      goto LABEL_4;
    }
  }
  else if (*((unsigned char *)a1 + 927))
  {
LABEL_4:
    uint64_t v9 = 0;
    goto LABEL_9;
  }
  if (a1[116]) {
    uint64_t v9 = nullsub_5;
  }
  else {
    uint64_t v9 = 0;
  }
LABEL_9:
  if (v9) {
    sub_2167BAB8C((uint64_t)(a1 + 112), (void *)(a2 + 32), a3);
  }
  if (*((char *)a1 + 975) < 0)
  {
    if (a1[120]) {
      goto LABEL_13;
    }
  }
  else if (*((unsigned char *)a1 + 975))
  {
LABEL_13:
    uint64_t v10 = 0;
    goto LABEL_18;
  }
  if (a1[122]) {
    uint64_t v10 = nullsub_5;
  }
  else {
    uint64_t v10 = 0;
  }
LABEL_18:
  if (v10) {
    sub_2167BAC08((uint64_t)(a1 + 118), (void *)(a2 + 112), a3);
  }
  if (*((char *)a1 + 1023) < 0)
  {
    if (a1[126]) {
      goto LABEL_22;
    }
  }
  else if (*((unsigned char *)a1 + 1023))
  {
LABEL_22:
    uint64_t v11 = 0;
    goto LABEL_27;
  }
  if (a1[128]) {
    uint64_t v11 = nullsub_5;
  }
  else {
    uint64_t v11 = 0;
  }
LABEL_27:
  if (v11) {
    sub_2167BAB8C((uint64_t)(a1 + 124), (void *)(a2 + 128), a3);
  }
  if (*((char *)a1 + 87) < 0)
  {
    if (a1[9]) {
      goto LABEL_31;
    }
  }
  else if (*((unsigned char *)a1 + 87))
  {
LABEL_31:
    uint64_t v12 = 0;
    goto LABEL_36;
  }
  if (a1[11]) {
    uint64_t v12 = nullsub_4;
  }
  else {
    uint64_t v12 = 0;
  }
LABEL_36:
  if (v12) {
    Alembic::Abc::v12::IScalarProperty::get((uint64_t)(a1 + 7), a2 + 48, a3, 48);
  }
  if (*((char *)a1 + 327) < 0)
  {
    if (a1[39]) {
      goto LABEL_40;
    }
  }
  else if (*((unsigned char *)a1 + 327))
  {
LABEL_40:
    uint64_t v13 = 0;
    goto LABEL_45;
  }
  if (a1[41]) {
    uint64_t v13 = nullsub_5;
  }
  else {
    uint64_t v13 = 0;
  }
LABEL_45:
  if (v13)
  {
    uint64_t v14 = (Alembic::Abc::v12::IArrayProperty *)(a1 + 37);
    if (Alembic::Abc::v12::IArrayProperty::getNumSamples(v14)) {
      sub_2167BAC84((uint64_t)v14, (void *)(a2 + 16), a3);
    }
  }
}

void sub_2167BAA3C(void *a1, int a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  uint64_t v5 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64((uint64_t)va, (uint64_t)v5);
  }
  else {
    sub_21679F9F4((uint64_t)va, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BAA28);
}

void sub_2167BAA74(_Unwind_Exception *a1)
{
}

void sub_2167BAA94(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  int v8 = 0;
  Alembic::Abc::v12::IArrayProperty::get(a1, (uint64_t)&v7, a3);
  uint64_t v5 = v7;
  uint64_t v4 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  *a2 = v5;
  a2[1] = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167BAAF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167BAB10(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  int v8 = 0;
  Alembic::Abc::v12::IArrayProperty::get(a1, (uint64_t)&v7, a3);
  uint64_t v5 = v7;
  uint64_t v4 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  *a2 = v5;
  a2[1] = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167BAB74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167BAB8C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  int v8 = 0;
  Alembic::Abc::v12::IArrayProperty::get(a1, (uint64_t)&v7, a3);
  uint64_t v5 = v7;
  uint64_t v4 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  *a2 = v5;
  a2[1] = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167BABF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167BAC08(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  int v8 = 0;
  Alembic::Abc::v12::IArrayProperty::get(a1, (uint64_t)&v7, a3);
  uint64_t v5 = v7;
  uint64_t v4 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  *a2 = v5;
  a2[1] = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167BAC6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2167BAC84(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  int v8 = 0;
  Alembic::Abc::v12::IArrayProperty::get(a1, (uint64_t)&v7, a3);
  uint64_t v5 = v7;
  uint64_t v4 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  *a2 = v5;
  a2[1] = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  if (v8) {
    sub_216784EC4(v8);
  }
}

void sub_2167BACE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_216784EC4(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167BAD00(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v45 + 1) = 0;
  v46[0] = 0;
  *(void *)&long long v45 = (char *)&v45 + 8;
  int v47 = v10;
  sub_2167898D0(v48, (const void ***)&v45);
  v48[3] = 0;
  uint64_t v49 = 0;
  int v50 = 0;
  uint64_t v51 = 1;
  sub_2167877AC((uint64_t)&v45, *((void **)&v45 + 1));
  sub_2167A030C(a4, (uint64_t)&v47);
  sub_2167A030C(a5, (uint64_t)&v47);
  *(_DWORD *)a1 = v47;
  v46[34] = a1;
  v46[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v31 = sub_216779180(v46, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v31, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v33 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v33, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v34 = sub_216779180(v46, (uint64_t)"Nonexistent array property: ", 28);
    int v35 = *(char *)(a3 + 23);
    if (v35 >= 0) {
      uint64_t v36 = a3;
    }
    else {
      uint64_t v36 = *(void *)a3;
    }
    if (v35 >= 0) {
      uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v37 = *(void *)(a3 + 8);
    }
    sub_216779180(v34, v36, v37);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    double v38 = __cxa_allocate_exception(0x20uLL);
    uint64_t v39 = sub_216779038(v38, (uint64_t)__p);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v16 = *(_DWORD *)(v13 + 56) == 10 && *(unsigned char *)(v13 + 60) == 3 && *(_DWORD *)(v13 + 24) == 2;
  if (!v16 || (sub_2167BB284(v13 + 32, v51) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v20 = sub_216779180(v46, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v21 = sub_21677D5B0(v20, (int *)(v14 + 56));
    uint64_t v22 = sub_216779180(v21, (uint64_t)" to expected: ", 14);
    uint64_t v40 = 0x30000000ALL;
    uint64_t v23 = sub_21677D5B0(v22, (int *)&v40);
    uint64_t v24 = sub_216779180(v23, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v41, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v41, __p);
    if ((v44 & 0x80u) == 0) {
      uint64_t v25 = __p;
    }
    else {
      uint64_t v25 = (void **)__p[0];
    }
    if ((v44 & 0x80u) == 0) {
      uint64_t v26 = v44;
    }
    else {
      uint64_t v26 = (uint64_t)__p[1];
    }
    uint64_t v27 = sub_216779180(v24, (uint64_t)v25, v26);
    uint64_t v28 = sub_216779180(v27, (uint64_t)" to expected: ", 14);
    sub_216779180(v28, (uint64_t)"point", 5);
    if ((char)v44 < 0) {
      operator delete(__p[0]);
    }
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    uint64_t v29 = __cxa_allocate_exception(0x20uLL);
    uint64_t v30 = sub_216779038(v29, (uint64_t)__p);
    __cxa_throw(v30, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v45, v12, a3);
  long long v17 = v45;
  long long v45 = 0uLL;
  char v18 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v17;
  if (v18)
  {
    sub_216784EC4(v18);
    if (*((void *)&v45 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v45 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v49) {
    sub_216784EC4(v49);
  }
  sub_2167877AC((uint64_t)v48, (void *)v48[1]);
  return a1;
}

void sub_2167BB13C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BAEA0);
}

void sub_2167BB244()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167BB274);
}

uint64_t sub_2167BB284(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v9);
  if (v10 < 0)
  {
    BOOL v2 = v9[1] == (void *)5 && *(_DWORD *)v9[0] == 1852403568 && *((unsigned char *)v9[0] + 4) == 116;
    operator delete(v9[0]);
  }
  else
  {
    BOOL v2 = v10 == 5 && LODWORD(v9[0]) == 1852403568 && BYTE4(v9[0]) == 116;
  }
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167BB360(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167BB37C(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v44 + 1) = 0;
  v45[0] = 0;
  *(void *)&long long v44 = (char *)&v44 + 8;
  int v46 = v10;
  sub_2167898D0(v47, (const void ***)&v44);
  v47[3] = 0;
  uint64_t v48 = 0;
  int v49 = 0;
  uint64_t v50 = 1;
  sub_2167877AC((uint64_t)&v44, *((void **)&v44 + 1));
  sub_2167A030C(a4, (uint64_t)&v46);
  sub_2167A030C(a5, (uint64_t)&v46);
  *(_DWORD *)a1 = v46;
  v45[34] = a1;
  v45[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v30 = sub_216779180(v45, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v30, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v32 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v32, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v33 = sub_216779180(v45, (uint64_t)"Nonexistent array property: ", 28);
    int v34 = *(char *)(a3 + 23);
    if (v34 >= 0) {
      uint64_t v35 = a3;
    }
    else {
      uint64_t v35 = *(void *)a3;
    }
    if (v34 >= 0) {
      uint64_t v36 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v36 = *(void *)(a3 + 8);
    }
    sub_216779180(v33, v35, v36);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v37 = __cxa_allocate_exception(0x20uLL);
    double v38 = sub_216779038(v37, (uint64_t)__p);
    __cxa_throw(v38, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v15 = *(_DWORD *)(v13 + 56) == 6 && *(_DWORD *)(v13 + 24) == 2;
  if (!v15 || (sub_2167BB8F8(v13 + 32, v50) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v19 = sub_216779180(v45, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v20 = sub_21677D5B0(v19, (int *)(v14 + 56));
    uint64_t v21 = sub_216779180(v20, (uint64_t)" to expected: ", 14);
    uint64_t v39 = 0x100000006;
    uint64_t v22 = sub_21677D5B0(v21, (int *)&v39);
    uint64_t v23 = sub_216779180(v22, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v40, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v40, __p);
    if ((v43 & 0x80u) == 0) {
      uint64_t v24 = __p;
    }
    else {
      uint64_t v24 = (void **)__p[0];
    }
    if ((v43 & 0x80u) == 0) {
      uint64_t v25 = v43;
    }
    else {
      uint64_t v25 = (uint64_t)__p[1];
    }
    uint64_t v26 = sub_216779180(v23, (uint64_t)v24, v25);
    uint64_t v27 = sub_216779180(v26, (uint64_t)" to expected: ", 14);
    sub_216779180(v27, (uint64_t)"", 0);
    if ((char)v43 < 0) {
      operator delete(__p[0]);
    }
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v28 = __cxa_allocate_exception(0x20uLL);
    uint64_t v29 = sub_216779038(v28, (uint64_t)__p);
    __cxa_throw(v29, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v44, v12, a3);
  long long v16 = v44;
  long long v44 = 0uLL;
  long long v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v44 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v44 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v48) {
    sub_216784EC4(v48);
  }
  sub_2167877AC((uint64_t)v47, (void *)v47[1]);
  return a1;
}

void sub_2167BB7B0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BB514);
}

void sub_2167BB8B8()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167BB8E8);
}

uint64_t sub_2167BB8F8(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v7);
  if (v8 < 0)
  {
    BOOL v2 = v7[1] == 0;
    operator delete(v7[0]);
  }
  else
  {
    BOOL v2 = v8 == 0;
  }
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167BB984(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167BB9A0(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v44 + 1) = 0;
  v45[0] = 0;
  *(void *)&long long v44 = (char *)&v44 + 8;
  int v46 = v10;
  sub_2167898D0(v47, (const void ***)&v44);
  v47[3] = 0;
  uint64_t v48 = 0;
  int v49 = 0;
  uint64_t v50 = 1;
  sub_2167877AC((uint64_t)&v44, *((void **)&v44 + 1));
  sub_2167A030C(a4, (uint64_t)&v46);
  sub_2167A030C(a5, (uint64_t)&v46);
  *(_DWORD *)a1 = v46;
  v45[34] = a1;
  v45[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v30 = sub_216779180(v45, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v30, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v32 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v32, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v33 = sub_216779180(v45, (uint64_t)"Nonexistent array property: ", 28);
    int v34 = *(char *)(a3 + 23);
    if (v34 >= 0) {
      uint64_t v35 = a3;
    }
    else {
      uint64_t v35 = *(void *)a3;
    }
    if (v34 >= 0) {
      uint64_t v36 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v36 = *(void *)(a3 + 8);
    }
    sub_216779180(v33, v35, v36);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v37 = __cxa_allocate_exception(0x20uLL);
    double v38 = sub_216779038(v37, (uint64_t)__p);
    __cxa_throw(v38, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v15 = *(_DWORD *)(v13 + 56) == 10 && *(_DWORD *)(v13 + 24) == 2;
  if (!v15 || (sub_2167BBF1C(v13 + 32, v50) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v19 = sub_216779180(v45, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v20 = sub_21677D5B0(v19, (int *)(v14 + 56));
    uint64_t v21 = sub_216779180(v20, (uint64_t)" to expected: ", 14);
    uint64_t v39 = 0x10000000ALL;
    uint64_t v22 = sub_21677D5B0(v21, (int *)&v39);
    uint64_t v23 = sub_216779180(v22, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v40, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v40, __p);
    if ((v43 & 0x80u) == 0) {
      uint64_t v24 = __p;
    }
    else {
      uint64_t v24 = (void **)__p[0];
    }
    if ((v43 & 0x80u) == 0) {
      uint64_t v25 = v43;
    }
    else {
      uint64_t v25 = (uint64_t)__p[1];
    }
    uint64_t v26 = sub_216779180(v23, (uint64_t)v24, v25);
    uint64_t v27 = sub_216779180(v26, (uint64_t)" to expected: ", 14);
    sub_216779180(v27, (uint64_t)"", 0);
    if ((char)v43 < 0) {
      operator delete(__p[0]);
    }
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v28 = __cxa_allocate_exception(0x20uLL);
    uint64_t v29 = sub_216779038(v28, (uint64_t)__p);
    __cxa_throw(v29, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v44, v12, a3);
  long long v16 = v44;
  long long v44 = 0uLL;
  long long v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v44 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v44 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v48) {
    sub_216784EC4(v48);
  }
  sub_2167877AC((uint64_t)v47, (void *)v47[1]);
  return a1;
}

void sub_2167BBDD4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BBB38);
}

void sub_2167BBEDC()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167BBF0CLL);
}

uint64_t sub_2167BBF1C(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v7);
  if (v8 < 0)
  {
    BOOL v2 = v7[1] == 0;
    operator delete(v7[0]);
  }
  else
  {
    BOOL v2 = v8 == 0;
  }
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167BBFA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167BBFC4(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  int v10 = (std::string *)(a1 + 8);
  sub_216779094((void *)(a1 + 8), "");
  *(_DWORD *)(a1 + 48) = 2;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_216779094((void *)(a1 + 56), "");
  *(_DWORD *)(a1 + 96) = 2;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  sub_216779094((void *)(a1 + 104), "");
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  uint64_t v11 = (std::__shared_weak_count *)a2[1];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)&v60.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v59 = &v60;
  int v65 = 2;
  sub_2167898D0(v66, (const void ***)&v59);
  v66[3] = 0;
  int v67 = 0;
  int v68 = 0;
  uint64_t v69 = 1;
  sub_2167877AC((uint64_t)&v59, v60.__r_.__value_.__l.__data_);
  if (v11) {
    sub_216784EC4(v11);
  }
  sub_2167A030C(a4, (uint64_t)&v65);
  sub_2167A030C(a5, (uint64_t)&v65);
  *(_DWORD *)a1 = v65;
  uint64_t v63 = a1;
  uint64_t v64 = "ITypedGeomParam::ITypedGeomParam()";
  uint64_t v12 = *a2;
  uint64_t v13 = (std::__shared_weak_count *)a2[1];
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v47 = v13;
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v59);
    uint64_t v32 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v32, (uint64_t)"ITypedGeomParam ctor", 20);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v57);
    if (v58 < 0) {
      operator delete(v57[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    int v34 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v34, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  if (!v14)
  {
    sub_216778A5C((uint64_t)&v59);
    uint64_t v35 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"Nonexistent GeomParam: ", 23);
    int v36 = *(char *)(a3 + 23);
    if (v36 >= 0) {
      uint64_t v37 = a3;
    }
    else {
      uint64_t v37 = *(void *)a3;
    }
    if (v36 >= 0) {
      uint64_t v38 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v38 = *(void *)(a3 + 8);
    }
    sub_216779180(v35, v37, v38);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v57);
    if (v58 < 0) {
      operator delete(v57[0]);
    }
    uint64_t v39 = __cxa_allocate_exception(0x20uLL);
    uint64_t v40 = sub_216779038(v39, (uint64_t)__p);
    __cxa_throw(v40, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  int v15 = *(_DWORD *)(v14 + 24);
  if (v15 == 2)
  {
    uint64_t v27 = (std::__shared_weak_count *)a2[1];
    uint64_t v48 = *a2;
    int v49 = v27;
    if (v27) {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LODWORD(v57[0]) = 0;
    LODWORD(v57[1]) = 0;
    int v51 = 0;
    int v52 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(__p, &v48, v57, &v51);
    sub_2167BCDC4((uint64_t)&v59, (int *)__p, a3, a4, a5);
    *(_DWORD *)a1 = v59;
    std::string::operator=(v10, &v60);
    uint64_t v29 = v61;
    uint64_t v28 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v30 = *(std::__shared_weak_count **)(a1 + 40);
    *(void *)(a1 + 32) = v29;
    *(void *)(a1 + 40) = v28;
    if (v30) {
      sub_216784EC4(v30);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)__p);
    if (v49) {
      sub_216784EC4(v49);
    }
    char v26 = 0;
  }
  else
  {
    if (v15)
    {
      sub_216778A5C((uint64_t)&v59);
      char v41 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"Invalid ITypedGeomParam: ", 25);
      int v42 = *(char *)(a3 + 23);
      if (v42 >= 0) {
        uint64_t v43 = a3;
      }
      else {
        uint64_t v43 = *(void *)a3;
      }
      if (v42 >= 0) {
        uint64_t v44 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v44 = *(void *)(a3 + 8);
      }
      sub_216779180(v41, v43, v44);
      std::stringbuf::str();
      sub_216778E70(__p, (long long *)v57);
      if (v58 < 0) {
        operator delete(v57[0]);
      }
      long long v45 = __cxa_allocate_exception(0x20uLL);
      int v46 = sub_216779038(v45, (uint64_t)__p);
      __cxa_throw(v46, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    long long v16 = (std::__shared_weak_count *)a2[1];
    uint64_t v53 = *a2;
    uint64_t v54 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LODWORD(v57[0]) = 0;
    LODWORD(v57[1]) = 0;
    int v51 = 0;
    int v52 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(__p, &v53, v57, &v51);
    v50[0] = 1;
    _OWORD v50[2] = v65;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&v59, __p, a3, v50);
    *(_DWORD *)(a1 + 96) = v59;
    std::string::operator=((std::string *)(a1 + 104), &v60);
    uint64_t v18 = v61;
    uint64_t v17 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v19 = *(std::__shared_weak_count **)(a1 + 136);
    *(void *)(a1 + 128) = v18;
    *(void *)(a1 + 136) = v17;
    if (v19) {
      sub_216784EC4(v19);
    }
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&v59);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)__p);
    if (v54) {
      sub_216784EC4(v54);
    }
    sub_216779094(__p, ".indices");
    sub_2167BC7A0((uint64_t)&v59, (int *)(a1 + 96), (uint64_t)__p, a4, a5);
    *(_DWORD *)(a1 + 48) = v59;
    std::string::operator=((std::string *)(a1 + 56), &v60);
    uint64_t v21 = v61;
    uint64_t v20 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v22 = *(std::__shared_weak_count **)(a1 + 88);
    *(void *)(a1 + 80) = v21;
    *(void *)(a1 + 88) = v20;
    if (v22) {
      sub_216784EC4(v22);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    if (v56 < 0) {
      operator delete(__p[0]);
    }
    sub_216779094(__p, ".vals");
    sub_2167BCDC4((uint64_t)&v59, (int *)(a1 + 96), (uint64_t)__p, a4, a5);
    *(_DWORD *)a1 = v59;
    std::string::operator=(v10, &v60);
    uint64_t v24 = v61;
    uint64_t v23 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v25 = *(std::__shared_weak_count **)(a1 + 40);
    *(void *)(a1 + 32) = v24;
    *(void *)(a1 + 40) = v23;
    if (v25) {
      sub_216784EC4(v25);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    if (v56 < 0) {
      operator delete(__p[0]);
    }
    char v26 = 1;
  }
  *(unsigned char *)(a1 + 144) = v26;
  if (v47) {
    sub_216784EC4(v47);
  }
  if (v67) {
    sub_216784EC4(v67);
  }
  sub_2167877AC((uint64_t)v66, (void *)v66[1]);
  return a1;
}

void sub_2167BC5C4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a32);
  if (a11) {
    sub_216784EC4(a11);
  }
  uint64_t v35 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v32 - 168, (uint64_t)v35);
  }
  else {
    sub_21679F9F4(v32 - 168, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BC3CCLL);
}

void sub_2167BC720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, Alembic::Abc::v12::IArrayProperty *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30)
{
  sub_2167A03C4(v32 - 152);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty(v31);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty(a9);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_2167BC7A0(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v44 + 1) = 0;
  v45[0] = 0;
  *(void *)&long long v44 = (char *)&v44 + 8;
  int v46 = v10;
  sub_2167898D0(v47, (const void ***)&v44);
  v47[3] = 0;
  uint64_t v48 = 0;
  int v49 = 0;
  uint64_t v50 = 1;
  sub_2167877AC((uint64_t)&v44, *((void **)&v44 + 1));
  sub_2167A030C(a4, (uint64_t)&v46);
  sub_2167A030C(a5, (uint64_t)&v46);
  *(_DWORD *)a1 = v46;
  v45[34] = a1;
  v45[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v30 = sub_216779180(v45, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v30, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v32 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v32, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v33 = sub_216779180(v45, (uint64_t)"Nonexistent array property: ", 28);
    int v34 = *(char *)(a3 + 23);
    if (v34 >= 0) {
      uint64_t v35 = a3;
    }
    else {
      uint64_t v35 = *(void *)a3;
    }
    if (v34 >= 0) {
      uint64_t v36 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v36 = *(void *)(a3 + 8);
    }
    sub_216779180(v33, v35, v36);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v37 = __cxa_allocate_exception(0x20uLL);
    uint64_t v38 = sub_216779038(v37, (uint64_t)__p);
    __cxa_throw(v38, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v15 = *(_DWORD *)(v13 + 56) == 5 && *(_DWORD *)(v13 + 24) == 2;
  if (!v15 || (sub_2167BCD1C(v13 + 32, v50) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v19 = sub_216779180(v45, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v20 = sub_21677D5B0(v19, (int *)(v14 + 56));
    uint64_t v21 = sub_216779180(v20, (uint64_t)" to expected: ", 14);
    uint64_t v39 = 0x100000005;
    uint64_t v22 = sub_21677D5B0(v21, (int *)&v39);
    uint64_t v23 = sub_216779180(v22, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v40, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v40, __p);
    if ((v43 & 0x80u) == 0) {
      uint64_t v24 = __p;
    }
    else {
      uint64_t v24 = (void **)__p[0];
    }
    if ((v43 & 0x80u) == 0) {
      uint64_t v25 = v43;
    }
    else {
      uint64_t v25 = (uint64_t)__p[1];
    }
    char v26 = sub_216779180(v23, (uint64_t)v24, v25);
    uint64_t v27 = sub_216779180(v26, (uint64_t)" to expected: ", 14);
    sub_216779180(v27, (uint64_t)"", 0);
    if ((char)v43 < 0) {
      operator delete(__p[0]);
    }
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v28 = __cxa_allocate_exception(0x20uLL);
    uint64_t v29 = sub_216779038(v28, (uint64_t)__p);
    __cxa_throw(v29, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v44, v12, a3);
  long long v16 = v44;
  long long v44 = 0uLL;
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v44 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v44 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v48) {
    sub_216784EC4(v48);
  }
  sub_2167877AC((uint64_t)v47, (void *)v47[1]);
  return a1;
}

void sub_2167BCBD4(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BC938);
}

void sub_2167BCCDC()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167BCD0CLL);
}

uint64_t sub_2167BCD1C(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v7);
  if (v8 < 0)
  {
    BOOL v2 = v7[1] == 0;
    operator delete(v7[0]);
  }
  else
  {
    BOOL v2 = v8 == 0;
  }
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167BCDA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167BCDC4(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v45 + 1) = 0;
  v46[0] = 0;
  *(void *)&long long v45 = (char *)&v45 + 8;
  int v47 = v10;
  sub_2167898D0(v48, (const void ***)&v45);
  v48[3] = 0;
  int v49 = 0;
  int v50 = 0;
  uint64_t v51 = 1;
  sub_2167877AC((uint64_t)&v45, *((void **)&v45 + 1));
  sub_2167A030C(a4, (uint64_t)&v47);
  sub_2167A030C(a5, (uint64_t)&v47);
  *(_DWORD *)a1 = v47;
  v46[34] = a1;
  v46[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v31 = sub_216779180(v46, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v31, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v33 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v33, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v45);
    int v34 = sub_216779180(v46, (uint64_t)"Nonexistent array property: ", 28);
    int v35 = *(char *)(a3 + 23);
    if (v35 >= 0) {
      uint64_t v36 = a3;
    }
    else {
      uint64_t v36 = *(void *)a3;
    }
    if (v35 >= 0) {
      uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v37 = *(void *)(a3 + 8);
    }
    sub_216779180(v34, v36, v37);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    uint64_t v38 = __cxa_allocate_exception(0x20uLL);
    uint64_t v39 = sub_216779038(v38, (uint64_t)__p);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v16 = *(_DWORD *)(v13 + 56) == 10 && *(unsigned char *)(v13 + 60) == 2 && *(_DWORD *)(v13 + 24) == 2;
  if (!v16 || (sub_2167B2654(v13 + 32, v51) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v20 = sub_216779180(v46, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v21 = sub_21677D5B0(v20, (int *)(v14 + 56));
    uint64_t v22 = sub_216779180(v21, (uint64_t)" to expected: ", 14);
    uint64_t v40 = 0x20000000ALL;
    uint64_t v23 = sub_21677D5B0(v22, (int *)&v40);
    uint64_t v24 = sub_216779180(v23, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v41, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v41, __p);
    if ((v44 & 0x80u) == 0) {
      uint64_t v25 = __p;
    }
    else {
      uint64_t v25 = (void **)__p[0];
    }
    if ((v44 & 0x80u) == 0) {
      uint64_t v26 = v44;
    }
    else {
      uint64_t v26 = (uint64_t)__p[1];
    }
    uint64_t v27 = sub_216779180(v24, (uint64_t)v25, v26);
    uint64_t v28 = sub_216779180(v27, (uint64_t)" to expected: ", 14);
    sub_216779180(v28, (uint64_t)"vector", 6);
    if ((char)v44 < 0) {
      operator delete(__p[0]);
    }
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    uint64_t v29 = __cxa_allocate_exception(0x20uLL);
    uint64_t v30 = sub_216779038(v29, (uint64_t)__p);
    __cxa_throw(v30, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v45, v12, a3);
  long long v17 = v45;
  long long v45 = 0uLL;
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v17;
  if (v18)
  {
    sub_216784EC4(v18);
    if (*((void *)&v45 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v45 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v49) {
    sub_216784EC4(v49);
  }
  sub_2167877AC((uint64_t)v48, (void *)v48[1]);
  return a1;
}

void sub_2167BD200(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BCF64);
}

void sub_2167BD308()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167BD338);
}

uint64_t sub_2167BD348(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  int v10 = (std::string *)(a1 + 8);
  sub_216779094((void *)(a1 + 8), "");
  *(_DWORD *)(a1 + 48) = 2;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_216779094((void *)(a1 + 56), "");
  *(_DWORD *)(a1 + 96) = 2;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  sub_216779094((void *)(a1 + 104), "");
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  uint64_t v11 = (std::__shared_weak_count *)a2[1];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)&v60.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v59 = &v60;
  int v65 = 2;
  sub_2167898D0(v66, (const void ***)&v59);
  v66[3] = 0;
  int v67 = 0;
  int v68 = 0;
  uint64_t v69 = 1;
  sub_2167877AC((uint64_t)&v59, v60.__r_.__value_.__l.__data_);
  if (v11) {
    sub_216784EC4(v11);
  }
  sub_2167A030C(a4, (uint64_t)&v65);
  sub_2167A030C(a5, (uint64_t)&v65);
  *(_DWORD *)a1 = v65;
  uint64_t v63 = a1;
  uint64_t v64 = "ITypedGeomParam::ITypedGeomParam()";
  uint64_t v12 = *a2;
  uint64_t v13 = (std::__shared_weak_count *)a2[1];
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v47 = v13;
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v59);
    uint64_t v32 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v32, (uint64_t)"ITypedGeomParam ctor", 20);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v57);
    if (v58 < 0) {
      operator delete(v57[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    int v34 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v34, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  if (!v14)
  {
    sub_216778A5C((uint64_t)&v59);
    int v35 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"Nonexistent GeomParam: ", 23);
    int v36 = *(char *)(a3 + 23);
    if (v36 >= 0) {
      uint64_t v37 = a3;
    }
    else {
      uint64_t v37 = *(void *)a3;
    }
    if (v36 >= 0) {
      uint64_t v38 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v38 = *(void *)(a3 + 8);
    }
    sub_216779180(v35, v37, v38);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v57);
    if (v58 < 0) {
      operator delete(v57[0]);
    }
    uint64_t v39 = __cxa_allocate_exception(0x20uLL);
    uint64_t v40 = sub_216779038(v39, (uint64_t)__p);
    __cxa_throw(v40, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  int v15 = *(_DWORD *)(v14 + 24);
  if (v15 == 2)
  {
    uint64_t v27 = (std::__shared_weak_count *)a2[1];
    uint64_t v48 = *a2;
    int v49 = v27;
    if (v27) {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LODWORD(v57[0]) = 0;
    LODWORD(v57[1]) = 0;
    int v51 = 0;
    int v52 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(__p, &v48, v57, &v51);
    sub_2167BDB24((uint64_t)&v59, (int *)__p, a3, a4, a5);
    *(_DWORD *)a1 = v59;
    std::string::operator=(v10, &v60);
    uint64_t v29 = v61;
    uint64_t v28 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v30 = *(std::__shared_weak_count **)(a1 + 40);
    *(void *)(a1 + 32) = v29;
    *(void *)(a1 + 40) = v28;
    if (v30) {
      sub_216784EC4(v30);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)__p);
    if (v49) {
      sub_216784EC4(v49);
    }
    char v26 = 0;
  }
  else
  {
    if (v15)
    {
      sub_216778A5C((uint64_t)&v59);
      char v41 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"Invalid ITypedGeomParam: ", 25);
      int v42 = *(char *)(a3 + 23);
      if (v42 >= 0) {
        uint64_t v43 = a3;
      }
      else {
        uint64_t v43 = *(void *)a3;
      }
      if (v42 >= 0) {
        uint64_t v44 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v44 = *(void *)(a3 + 8);
      }
      sub_216779180(v41, v43, v44);
      std::stringbuf::str();
      sub_216778E70(__p, (long long *)v57);
      if (v58 < 0) {
        operator delete(v57[0]);
      }
      long long v45 = __cxa_allocate_exception(0x20uLL);
      int v46 = sub_216779038(v45, (uint64_t)__p);
      __cxa_throw(v46, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    BOOL v16 = (std::__shared_weak_count *)a2[1];
    uint64_t v53 = *a2;
    uint64_t v54 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LODWORD(v57[0]) = 0;
    LODWORD(v57[1]) = 0;
    int v51 = 0;
    int v52 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(__p, &v53, v57, &v51);
    v50[0] = 1;
    _OWORD v50[2] = v65;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&v59, __p, a3, v50);
    *(_DWORD *)(a1 + 96) = v59;
    std::string::operator=((std::string *)(a1 + 104), &v60);
    uint64_t v18 = v61;
    uint64_t v17 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v19 = *(std::__shared_weak_count **)(a1 + 136);
    *(void *)(a1 + 128) = v18;
    *(void *)(a1 + 136) = v17;
    if (v19) {
      sub_216784EC4(v19);
    }
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&v59);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)__p);
    if (v54) {
      sub_216784EC4(v54);
    }
    sub_216779094(__p, ".indices");
    sub_2167BC7A0((uint64_t)&v59, (int *)(a1 + 96), (uint64_t)__p, a4, a5);
    *(_DWORD *)(a1 + 48) = v59;
    std::string::operator=((std::string *)(a1 + 56), &v60);
    uint64_t v21 = v61;
    uint64_t v20 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v22 = *(std::__shared_weak_count **)(a1 + 88);
    *(void *)(a1 + 80) = v21;
    *(void *)(a1 + 88) = v20;
    if (v22) {
      sub_216784EC4(v22);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    if (v56 < 0) {
      operator delete(__p[0]);
    }
    sub_216779094(__p, ".vals");
    sub_2167BDB24((uint64_t)&v59, (int *)(a1 + 96), (uint64_t)__p, a4, a5);
    *(_DWORD *)a1 = v59;
    std::string::operator=(v10, &v60);
    uint64_t v24 = v61;
    uint64_t v23 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v25 = *(std::__shared_weak_count **)(a1 + 40);
    *(void *)(a1 + 32) = v24;
    *(void *)(a1 + 40) = v23;
    if (v25) {
      sub_216784EC4(v25);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    if (v56 < 0) {
      operator delete(__p[0]);
    }
    char v26 = 1;
  }
  *(unsigned char *)(a1 + 144) = v26;
  if (v47) {
    sub_216784EC4(v47);
  }
  if (v67) {
    sub_216784EC4(v67);
  }
  sub_2167877AC((uint64_t)v66, (void *)v66[1]);
  return a1;
}

void sub_2167BD948(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a32);
  if (a11) {
    sub_216784EC4(a11);
  }
  int v35 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v32 - 168, (uint64_t)v35);
  }
  else {
    sub_21679F9F4(v32 - 168, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BD750);
}

void sub_2167BDAA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, Alembic::Abc::v12::IArrayProperty *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30)
{
  sub_2167A03C4(v32 - 152);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty(v31);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty(a9);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_2167BDB24(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v45 + 1) = 0;
  v46[0] = 0;
  *(void *)&long long v45 = (char *)&v45 + 8;
  int v47 = v10;
  sub_2167898D0(v48, (const void ***)&v45);
  v48[3] = 0;
  int v49 = 0;
  int v50 = 0;
  uint64_t v51 = 1;
  sub_2167877AC((uint64_t)&v45, *((void **)&v45 + 1));
  sub_2167A030C(a4, (uint64_t)&v47);
  sub_2167A030C(a5, (uint64_t)&v47);
  *(_DWORD *)a1 = v47;
  v46[34] = a1;
  v46[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v31 = sub_216779180(v46, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v31, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v33 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v33, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v45);
    int v34 = sub_216779180(v46, (uint64_t)"Nonexistent array property: ", 28);
    int v35 = *(char *)(a3 + 23);
    if (v35 >= 0) {
      uint64_t v36 = a3;
    }
    else {
      uint64_t v36 = *(void *)a3;
    }
    if (v35 >= 0) {
      uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v37 = *(void *)(a3 + 8);
    }
    sub_216779180(v34, v36, v37);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    uint64_t v38 = __cxa_allocate_exception(0x20uLL);
    uint64_t v39 = sub_216779038(v38, (uint64_t)__p);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v16 = *(_DWORD *)(v13 + 56) == 10 && *(unsigned char *)(v13 + 60) == 3 && *(_DWORD *)(v13 + 24) == 2;
  if (!v16 || (sub_2167BE0A8(v13 + 32, v51) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v20 = sub_216779180(v46, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v21 = sub_21677D5B0(v20, (int *)(v14 + 56));
    uint64_t v22 = sub_216779180(v21, (uint64_t)" to expected: ", 14);
    uint64_t v40 = 0x30000000ALL;
    uint64_t v23 = sub_21677D5B0(v22, (int *)&v40);
    uint64_t v24 = sub_216779180(v23, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v41, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v41, __p);
    if ((v44 & 0x80u) == 0) {
      uint64_t v25 = __p;
    }
    else {
      uint64_t v25 = (void **)__p[0];
    }
    if ((v44 & 0x80u) == 0) {
      uint64_t v26 = v44;
    }
    else {
      uint64_t v26 = (uint64_t)__p[1];
    }
    uint64_t v27 = sub_216779180(v24, (uint64_t)v25, v26);
    uint64_t v28 = sub_216779180(v27, (uint64_t)" to expected: ", 14);
    sub_216779180(v28, (uint64_t)"normal", 6);
    if ((char)v44 < 0) {
      operator delete(__p[0]);
    }
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    uint64_t v29 = __cxa_allocate_exception(0x20uLL);
    uint64_t v30 = sub_216779038(v29, (uint64_t)__p);
    __cxa_throw(v30, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v45, v12, a3);
  long long v17 = v45;
  long long v45 = 0uLL;
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v17;
  if (v18)
  {
    sub_216784EC4(v18);
    if (*((void *)&v45 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v45 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v49) {
    sub_216784EC4(v49);
  }
  sub_2167877AC((uint64_t)v48, (void *)v48[1]);
  return a1;
}

void sub_2167BDF60(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BDCC4);
}

void sub_2167BE068()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167BE098);
}

uint64_t sub_2167BE0A8(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v9);
  if (v10 < 0)
  {
    BOOL v2 = v9[1] == (void *)6 && *(_DWORD *)v9[0] == 1836216174 && *((_WORD *)v9[0] + 2) == 27745;
    operator delete(v9[0]);
  }
  else
  {
    BOOL v2 = v10 == 6 && LODWORD(v9[0]) == 1836216174 && WORD2(v9[0]) == 27745;
  }
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167BE184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167BE1A0(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  char v10 = (std::string *)(a1 + 8);
  sub_216779094((void *)(a1 + 8), "");
  *(_DWORD *)(a1 + 48) = 2;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_216779094((void *)(a1 + 56), "");
  *(_DWORD *)(a1 + 96) = 2;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  sub_216779094((void *)(a1 + 104), "");
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  uint64_t v11 = (std::__shared_weak_count *)a2[1];
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)&v60.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v59 = &v60;
  int v65 = 2;
  sub_2167898D0(v66, (const void ***)&v59);
  v66[3] = 0;
  int v67 = 0;
  int v68 = 0;
  uint64_t v69 = 1;
  sub_2167877AC((uint64_t)&v59, v60.__r_.__value_.__l.__data_);
  if (v11) {
    sub_216784EC4(v11);
  }
  sub_2167A030C(a4, (uint64_t)&v65);
  sub_2167A030C(a5, (uint64_t)&v65);
  *(_DWORD *)a1 = v65;
  uint64_t v63 = a1;
  uint64_t v64 = "ITypedGeomParam::ITypedGeomParam()";
  uint64_t v12 = *a2;
  uint64_t v13 = (std::__shared_weak_count *)a2[1];
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  int v47 = v13;
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v59);
    uint64_t v32 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v32, (uint64_t)"ITypedGeomParam ctor", 20);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v57);
    if (v58 < 0) {
      operator delete(v57[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    int v34 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v34, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  if (!v14)
  {
    sub_216778A5C((uint64_t)&v59);
    int v35 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"Nonexistent GeomParam: ", 23);
    int v36 = *(char *)(a3 + 23);
    if (v36 >= 0) {
      uint64_t v37 = a3;
    }
    else {
      uint64_t v37 = *(void *)a3;
    }
    if (v36 >= 0) {
      uint64_t v38 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v38 = *(void *)(a3 + 8);
    }
    sub_216779180(v35, v37, v38);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v57);
    if (v58 < 0) {
      operator delete(v57[0]);
    }
    uint64_t v39 = __cxa_allocate_exception(0x20uLL);
    uint64_t v40 = sub_216779038(v39, (uint64_t)__p);
    __cxa_throw(v40, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  int v15 = *(_DWORD *)(v14 + 24);
  if (v15 == 2)
  {
    uint64_t v27 = (std::__shared_weak_count *)a2[1];
    uint64_t v48 = *a2;
    int v49 = v27;
    if (v27) {
      atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LODWORD(v57[0]) = 0;
    LODWORD(v57[1]) = 0;
    int v51 = 0;
    int v52 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(__p, &v48, v57, &v51);
    sub_2167BB9A0((uint64_t)&v59, (int *)__p, a3, a4, a5);
    *(_DWORD *)a1 = v59;
    std::string::operator=(v10, &v60);
    uint64_t v29 = v61;
    uint64_t v28 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v30 = *(std::__shared_weak_count **)(a1 + 40);
    *(void *)(a1 + 32) = v29;
    *(void *)(a1 + 40) = v28;
    if (v30) {
      sub_216784EC4(v30);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)__p);
    if (v49) {
      sub_216784EC4(v49);
    }
    char v26 = 0;
  }
  else
  {
    if (v15)
    {
      sub_216778A5C((uint64_t)&v59);
      char v41 = sub_216779180(&v60.__r_.__value_.__l.__size_, (uint64_t)"Invalid ITypedGeomParam: ", 25);
      int v42 = *(char *)(a3 + 23);
      if (v42 >= 0) {
        uint64_t v43 = a3;
      }
      else {
        uint64_t v43 = *(void *)a3;
      }
      if (v42 >= 0) {
        uint64_t v44 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v44 = *(void *)(a3 + 8);
      }
      sub_216779180(v41, v43, v44);
      std::stringbuf::str();
      sub_216778E70(__p, (long long *)v57);
      if (v58 < 0) {
        operator delete(v57[0]);
      }
      long long v45 = __cxa_allocate_exception(0x20uLL);
      int v46 = sub_216779038(v45, (uint64_t)__p);
      __cxa_throw(v46, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
    }
    BOOL v16 = (std::__shared_weak_count *)a2[1];
    uint64_t v53 = *a2;
    uint64_t v54 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LODWORD(v57[0]) = 0;
    LODWORD(v57[1]) = 0;
    int v51 = 0;
    int v52 = 0;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(__p, &v53, v57, &v51);
    v50[0] = 1;
    _OWORD v50[2] = v65;
    Alembic::Abc::v12::ICompoundProperty::ICompoundProperty(&v59, __p, a3, v50);
    *(_DWORD *)(a1 + 96) = v59;
    std::string::operator=((std::string *)(a1 + 104), &v60);
    uint64_t v18 = v61;
    uint64_t v17 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v19 = *(std::__shared_weak_count **)(a1 + 136);
    *(void *)(a1 + 128) = v18;
    *(void *)(a1 + 136) = v17;
    if (v19) {
      sub_216784EC4(v19);
    }
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)&v59);
    Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty((Alembic::Abc::v12::ICompoundProperty *)__p);
    if (v54) {
      sub_216784EC4(v54);
    }
    sub_216779094(__p, ".indices");
    sub_2167BC7A0((uint64_t)&v59, (int *)(a1 + 96), (uint64_t)__p, a4, a5);
    *(_DWORD *)(a1 + 48) = v59;
    std::string::operator=((std::string *)(a1 + 56), &v60);
    uint64_t v21 = v61;
    uint64_t v20 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v22 = *(std::__shared_weak_count **)(a1 + 88);
    *(void *)(a1 + 80) = v21;
    *(void *)(a1 + 88) = v20;
    if (v22) {
      sub_216784EC4(v22);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    if (v56 < 0) {
      operator delete(__p[0]);
    }
    sub_216779094(__p, ".vals");
    sub_2167BB9A0((uint64_t)&v59, (int *)(a1 + 96), (uint64_t)__p, a4, a5);
    *(_DWORD *)a1 = v59;
    std::string::operator=(v10, &v60);
    uint64_t v24 = v61;
    uint64_t v23 = v62;
    if (v62) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v62 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v25 = *(std::__shared_weak_count **)(a1 + 40);
    *(void *)(a1 + 32) = v24;
    *(void *)(a1 + 40) = v23;
    if (v25) {
      sub_216784EC4(v25);
    }
    Alembic::Abc::v12::IArrayProperty::~IArrayProperty((Alembic::Abc::v12::IArrayProperty *)&v59);
    if (v56 < 0) {
      operator delete(__p[0]);
    }
    char v26 = 1;
  }
  *(unsigned char *)(a1 + 144) = v26;
  if (v47) {
    sub_216784EC4(v47);
  }
  if (v67) {
    sub_216784EC4(v67);
  }
  sub_2167877AC((uint64_t)v66, (void *)v66[1]);
  return a1;
}

void sub_2167BE7A0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a32);
  if (a11) {
    sub_216784EC4(a11);
  }
  int v35 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v32 - 168, (uint64_t)v35);
  }
  else {
    sub_21679F9F4(v32 - 168, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BE5A8);
}

void sub_2167BE8FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, Alembic::Abc::v12::IArrayProperty *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30)
{
  sub_2167A03C4(v32 - 152);
  Alembic::Abc::v12::ICompoundProperty::~ICompoundProperty(v31);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty(a9);
  Alembic::Abc::v12::IArrayProperty::~IArrayProperty(v30);
  _Unwind_Resume(a1);
}

uint64_t sub_2167BE97C(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v45 + 1) = 0;
  v46[0] = 0;
  *(void *)&long long v45 = (char *)&v45 + 8;
  int v47 = v10;
  sub_2167898D0(v48, (const void ***)&v45);
  v48[3] = 0;
  int v49 = 0;
  int v50 = 0;
  uint64_t v51 = 1;
  sub_2167877AC((uint64_t)&v45, *((void **)&v45 + 1));
  sub_2167A030C(a4, (uint64_t)&v47);
  sub_2167A030C(a5, (uint64_t)&v47);
  *(_DWORD *)a1 = v47;
  v46[34] = a1;
  v46[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v31 = sub_216779180(v46, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v31, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v33 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v33, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v45);
    int v34 = sub_216779180(v46, (uint64_t)"Nonexistent array property: ", 28);
    int v35 = *(char *)(a3 + 23);
    if (v35 >= 0) {
      uint64_t v36 = a3;
    }
    else {
      uint64_t v36 = *(void *)a3;
    }
    if (v35 >= 0) {
      uint64_t v37 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v37 = *(void *)(a3 + 8);
    }
    sub_216779180(v34, v36, v37);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    uint64_t v38 = __cxa_allocate_exception(0x20uLL);
    uint64_t v39 = sub_216779038(v38, (uint64_t)__p);
    __cxa_throw(v39, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v16 = *(_DWORD *)(v13 + 56) == 10 && *(unsigned char *)(v13 + 60) == 3 && *(_DWORD *)(v13 + 24) == 2;
  if (!v16 || (sub_2167BEF00(v13 + 32, v51) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v45);
    uint64_t v20 = sub_216779180(v46, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v21 = sub_21677D5B0(v20, (int *)(v14 + 56));
    uint64_t v22 = sub_216779180(v21, (uint64_t)" to expected: ", 14);
    uint64_t v40 = 0x30000000ALL;
    uint64_t v23 = sub_21677D5B0(v22, (int *)&v40);
    uint64_t v24 = sub_216779180(v23, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v41, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v41, __p);
    if ((v44 & 0x80u) == 0) {
      uint64_t v25 = __p;
    }
    else {
      uint64_t v25 = (void **)__p[0];
    }
    if ((v44 & 0x80u) == 0) {
      uint64_t v26 = v44;
    }
    else {
      uint64_t v26 = (uint64_t)__p[1];
    }
    uint64_t v27 = sub_216779180(v24, (uint64_t)v25, v26);
    uint64_t v28 = sub_216779180(v27, (uint64_t)" to expected: ", 14);
    sub_216779180(v28, (uint64_t)"vector", 6);
    if ((char)v44 < 0) {
      operator delete(__p[0]);
    }
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v41);
    if (v42 < 0) {
      operator delete(v41[0]);
    }
    uint64_t v29 = __cxa_allocate_exception(0x20uLL);
    uint64_t v30 = sub_216779038(v29, (uint64_t)__p);
    __cxa_throw(v30, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v45, v12, a3);
  long long v17 = v45;
  long long v45 = 0uLL;
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v17;
  if (v18)
  {
    sub_216784EC4(v18);
    if (*((void *)&v45 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v45 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v49) {
    sub_216784EC4(v49);
  }
  sub_2167877AC((uint64_t)v48, (void *)v48[1]);
  return a1;
}

void sub_2167BEDB8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BEB1CLL);
}

void sub_2167BEEC0()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167BEEF0);
}

uint64_t sub_2167BEF00(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v9);
  if (v10 < 0)
  {
    BOOL v2 = v9[1] == (void *)6 && *(_DWORD *)v9[0] == 1952671094 && *((_WORD *)v9[0] + 2) == 29295;
    operator delete(v9[0]);
  }
  else
  {
    BOOL v2 = v10 == 6 && LODWORD(v9[0]) == 1952671094 && WORD2(v9[0]) == 29295;
  }
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167BEFDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_2167BEFF8(uint64_t a1, int *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *(_DWORD *)a1 = 2;
  sub_216779094((void *)(a1 + 8), "");
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  int v10 = *a2;
  *((void *)&v44 + 1) = 0;
  v45[0] = 0;
  *(void *)&long long v44 = (char *)&v44 + 8;
  int v46 = v10;
  sub_2167898D0(v47, (const void ***)&v44);
  v47[3] = 0;
  uint64_t v48 = 0;
  int v49 = 0;
  uint64_t v50 = 1;
  sub_2167877AC((uint64_t)&v44, *((void **)&v44 + 1));
  sub_2167A030C(a4, (uint64_t)&v46);
  sub_2167A030C(a5, (uint64_t)&v46);
  *(_DWORD *)a1 = v46;
  v45[34] = a1;
  v45[35] = "ITypedArrayProperty::ITypedArrayProperty()";
  uint64_t v12 = *((void *)a2 + 4);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a2 + 5);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v12)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v30 = sub_216779180(v45, (uint64_t)"NULL CompoundPropertyReader passed into ", 40);
    sub_216779180(v30, (uint64_t)"ITypedArrayProperty ctor", 24);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v32 = sub_216779038(exception, (uint64_t)__p);
    __cxa_throw(v32, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 80))(v12, a3);
  uint64_t v14 = v13;
  if (!v13)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v33 = sub_216779180(v45, (uint64_t)"Nonexistent array property: ", 28);
    int v34 = *(char *)(a3 + 23);
    if (v34 >= 0) {
      uint64_t v35 = a3;
    }
    else {
      uint64_t v35 = *(void *)a3;
    }
    if (v34 >= 0) {
      uint64_t v36 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v36 = *(void *)(a3 + 8);
    }
    sub_216779180(v33, v35, v36);
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v37 = __cxa_allocate_exception(0x20uLL);
    uint64_t v38 = sub_216779038(v37, (uint64_t)__p);
    __cxa_throw(v38, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  BOOL v15 = *(_DWORD *)(v13 + 56) == 1 && *(_DWORD *)(v13 + 24) == 2;
  if (!v15 || (sub_2167BF570(v13 + 32, v50) & 1) == 0)
  {
    sub_216778A5C((uint64_t)&v44);
    uint64_t v19 = sub_216779180(v45, (uint64_t)"Incorrect match of header datatype: ", 36);
    uint64_t v20 = sub_21677D5B0(v19, (int *)(v14 + 56));
    uint64_t v21 = sub_216779180(v20, (uint64_t)" to expected: ", 14);
    uint64_t v39 = 0x100000001;
    uint64_t v22 = sub_21677D5B0(v21, (int *)&v39);
    uint64_t v23 = sub_216779180(v22, (uint64_t)",\n...or incorrect match of interpretation: ", 43);
    sub_216779094(v40, "interpretation");
    sub_21679F2AC(v14 + 32, (const void **)v40, __p);
    if ((v43 & 0x80u) == 0) {
      uint64_t v24 = __p;
    }
    else {
      uint64_t v24 = (void **)__p[0];
    }
    if ((v43 & 0x80u) == 0) {
      uint64_t v25 = v43;
    }
    else {
      uint64_t v25 = (uint64_t)__p[1];
    }
    uint64_t v26 = sub_216779180(v23, (uint64_t)v24, v25);
    uint64_t v27 = sub_216779180(v26, (uint64_t)" to expected: ", 14);
    sub_216779180(v27, (uint64_t)"", 0);
    if ((char)v43 < 0) {
      operator delete(__p[0]);
    }
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    std::stringbuf::str();
    sub_216778E70(__p, (long long *)v40);
    if (v41 < 0) {
      operator delete(v40[0]);
    }
    uint64_t v28 = __cxa_allocate_exception(0x20uLL);
    uint64_t v29 = sub_216779038(v28, (uint64_t)__p);
    __cxa_throw(v29, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
  }
  (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v12 + 96))(&v44, v12, a3);
  long long v16 = v44;
  long long v44 = 0uLL;
  long long v17 = *(std::__shared_weak_count **)(a1 + 40);
  *(_OWORD *)(a1 + 32) = v16;
  if (v17)
  {
    sub_216784EC4(v17);
    if (*((void *)&v44 + 1)) {
      sub_216784EC4(*((std::__shared_weak_count **)&v44 + 1));
    }
  }
  if (v11) {
    sub_216784EC4(v11);
  }
  if (v48) {
    sub_216784EC4(v48);
  }
  sub_2167877AC((uint64_t)v47, (void *)v47[1]);
  return a1;
}

void sub_2167BF428(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24)
{
  sub_216779148((std::exception *)&__p);
  sub_216778D38((uint64_t)&a23);
  if (v25) {
    sub_216784EC4(v25);
  }
  uint64_t v29 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v30 = (uint64_t)v29;
    sub_2167A13A4(v24);
    sub_21679FA64(v26 - 144, v30);
  }
  else
  {
    sub_2167A13A4(v24);
    sub_21679F9F4(v26 - 144, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167BF190);
}

void sub_2167BF530()
{
  sub_2167A03C4(v0 - 128);
  JUMPOUT(0x2167BF560);
}

uint64_t sub_2167BF570(uint64_t a1, int a2)
{
  if (a2) {
    return 1;
  }
  sub_216779094(__p, "interpretation");
  sub_21679F2AC(a1, (const void **)__p, v7);
  if (v8 < 0)
  {
    BOOL v2 = v7[1] == 0;
    operator delete(v7[0]);
  }
  else
  {
    BOOL v2 = v8 == 0;
  }
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  return v2;
}

void sub_2167BF5FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::AbcGeom::v12::OCurvesSchema::set(Alembic::AbcGeom::v12::OCurvesSchema *this, uint64_t a2)
{
  if (!*((unsigned char *)this + 344) && !sub_2167C09F8(a2))
  {
    unint64_t v132 = (char *)this + 8;
    double v133 = "OCurvesSchema::set()";
    int v4 = *(_DWORD *)(a2 + 124);
    v129[0] = *(_DWORD *)(a2 + 120);
    v129[1] = v4;
    char v130 = *(unsigned char *)(a2 + 392);
    char v131 = v130;
    uint64_t v5 = (void *)(a2 + 40);
    if (*(_DWORD *)(a2 + 48) == 127 || !*v5 && *(void *)(a2 + 64) == *(void *)(a2 + 56)) {
      char v6 = 0;
    }
    else {
      char v6 = nullsub_10;
    }
    if (!v6) {
      goto LABEL_18;
    }
    if (*((char *)this + 927) < 0)
    {
      if (!*((void *)this + 114)) {
        goto LABEL_16;
      }
    }
    else if (!*((unsigned char *)this + 927))
    {
LABEL_16:
      if (!*((void *)this + 116)) {
        goto LABEL_17;
      }
LABEL_18:
      uint64_t v7 = (void *)(a2 + 216);
      if (*(_DWORD *)(a2 + 224) == 127 || !*v7 && *(void *)(a2 + 240) == *(void *)(a2 + 232)) {
        char v8 = 0;
      }
      else {
        char v8 = nullsub_8;
      }
      if (v8) {
        uint64_t v9 = nullsub_11;
      }
      else {
        uint64_t v9 = 0;
      }
      if (v9 && (sub_2167C5D84((uint64_t)this + 368) & 1) == 0) {
        Alembic::AbcGeom::v12::OCurvesSchema::createUVsProperty(this, a2);
      }
      int v10 = (void *)(a2 + 304);
      if (*(_DWORD *)(a2 + 312) == 127 || !*v10 && *(void *)(a2 + 328) == *(void *)(a2 + 320)) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = nullsub_9;
      }
      if (v11) {
        uint64_t v12 = nullsub_12;
      }
      else {
        uint64_t v12 = 0;
      }
      if (v12 && (sub_2167C5D84((uint64_t)this + 544) & 1) == 0) {
        Alembic::AbcGeom::v12::OCurvesSchema::createNormalsProperty(this, a2);
      }
      uint64_t v13 = (void *)(a2 + 128);
      if (*(_DWORD *)(a2 + 136) == 127 || !*v13 && *(void *)(a2 + 152) == *(void *)(a2 + 144)) {
        uint64_t v14 = 0;
      }
      else {
        uint64_t v14 = nullsub_13;
      }
      if (v14 && (sub_2167C5D84((uint64_t)this + 720) & 1) == 0) {
        Alembic::AbcGeom::v12::OCurvesSchema::createWidthProperty(this, a2);
      }
      BOOL v15 = (void *)(a2 + 400);
      if (*(_DWORD *)(a2 + 408) == 127 || !*v15 && *(void *)(a2 + 424) == *(void *)(a2 + 416)) {
        long long v16 = 0;
      }
      else {
        long long v16 = nullsub_13;
      }
      if (!v16) {
        goto LABEL_60;
      }
      if (*((char *)this + 975) < 0)
      {
        if (!*((void *)this + 120)) {
          goto LABEL_58;
        }
      }
      else if (!*((unsigned char *)this + 975))
      {
LABEL_58:
        if (!*((void *)this + 122)) {
          goto LABEL_59;
        }
LABEL_60:
        long long v17 = (void *)(a2 + 440);
        if (*(_DWORD *)(a2 + 448) == 127 || !*v17 && *(void *)(a2 + 464) == *(void *)(a2 + 456)) {
          uint64_t v18 = 0;
        }
        else {
          uint64_t v18 = nullsub_14;
        }
        if (!v18) {
          goto LABEL_72;
        }
        if (*((char *)this + 1023) < 0)
        {
          if (!*((void *)this + 126)) {
            goto LABEL_70;
          }
        }
        else if (!*((unsigned char *)this + 1023))
        {
LABEL_70:
          if (!*((void *)this + 128)) {
            goto LABEL_71;
          }
LABEL_72:
          uint64_t v19 = (void *)(a2 + 480);
          if (*(_DWORD *)(a2 + 488) == 127 || !*v19 && *(void *)(a2 + 504) == *(void *)(a2 + 496)) {
            uint64_t v20 = 0;
          }
          else {
            uint64_t v20 = nullsub_13;
          }
          if (!v20)
          {
LABEL_84:
            if (*((void *)this + 44))
            {
              int v119 = *((_DWORD *)this + 62);
              if (*((char *)this + 279) < 0)
              {
                sub_216778F24(&v120, *((void **)this + 32), *((void *)this + 33));
              }
              else
              {
                long long v120 = *((_OWORD *)this + 16);
                uint64_t v121 = *((void *)this + 34);
              }
              uint64_t v22 = *((void *)this + 36);
              uint64_t v122 = *((void *)this + 35);
              uint64_t v123 = v22;
              if (v22) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
              }
              uint64_t v23 = *(void *)(a2 + 5);
              *(void *)int v115 = *(void *)a2;
              *(void *)&v115[5] = v23;
              long long __p = 0;
              unint64_t v117 = 0;
              uint64_t v118 = 0;
              sub_21677EA60(&__p, *(const void **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
              if (SHIBYTE(v121) < 0)
              {
                if (*((void *)&v120 + 1)) {
                  goto LABEL_98;
                }
              }
              else if (HIBYTE(v121))
              {
LABEL_98:
                uint64_t v24 = 0;
                goto LABEL_103;
              }
              if (v122) {
                uint64_t v24 = nullsub_7;
              }
              else {
                uint64_t v24 = 0;
              }
LABEL_103:
              if (v24)
              {
                if (*(_DWORD *)&v115[8] == 127 || !*(void *)v115 && v117 == __p) {
                  uint64_t v25 = 0;
                }
                else {
                  uint64_t v25 = nullsub_19;
                }
                if (v25) {
                  Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v119);
                }
                else {
                  Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v119);
                }
              }
              if (__p)
              {
                unint64_t v117 = __p;
                operator delete(__p);
              }
              Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v119);
              int v110 = *((_DWORD *)this + 74);
              if (*((char *)this + 327) < 0)
              {
                sub_216778F24(&v111, *((void **)this + 38), *((void *)this + 39));
              }
              else
              {
                long long v111 = *((_OWORD *)this + 19);
                uint64_t v112 = *((void *)this + 40);
              }
              uint64_t v26 = *((void *)this + 42);
              uint64_t v113 = *((void *)this + 41);
              uint64_t v114 = v26;
              if (v26) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
              }
              uint64_t v27 = *(void *)(a2 + 85);
              *(void *)char v106 = *(void *)(a2 + 80);
              *(void *)&v106[5] = v27;
              unint64_t v107 = 0;
              unint64_t v108 = 0;
              uint64_t v109 = 0;
              sub_21677EA60(&v107, *(const void **)(a2 + 96), *(void *)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3);
              if (SHIBYTE(v112) < 0)
              {
                if (*((void *)&v111 + 1)) {
                  goto LABEL_121;
                }
              }
              else if (HIBYTE(v112))
              {
LABEL_121:
                uint64_t v28 = 0;
                goto LABEL_126;
              }
              if (v113) {
                uint64_t v28 = nullsub_7;
              }
              else {
                uint64_t v28 = 0;
              }
LABEL_126:
              if (v28)
              {
                if (*(_DWORD *)&v106[8] == 127 || !*(void *)v106 && v108 == v107) {
                  uint64_t v29 = 0;
                }
                else {
                  uint64_t v29 = nullsub_20;
                }
                if (v29) {
                  Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v110);
                }
                else {
                  Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v110);
                }
              }
              if (v107)
              {
                unint64_t v108 = v107;
                operator delete(v107);
              }
              Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v110);
              if (*((char *)this + 327) < 0)
              {
                if (*((void *)this + 39)) {
                  goto LABEL_139;
                }
              }
              else if (*((unsigned char *)this + 327))
              {
LABEL_139:
                uint64_t v30 = 0;
LABEL_144:
                uint64_t v31 = (Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 1088);
                if (v30) {
                  Alembic::Abc::v12::OScalarProperty::set(v31, v129);
                }
                else {
                  Alembic::Abc::v12::OScalarProperty::setFromPrevious(v31);
                }
                int v32 = *((char *)this + 927);
                if (v32 < 0)
                {
                  if (*((void *)this + 114)) {
                    goto LABEL_241;
                  }
                }
                else if (*((unsigned char *)this + 927))
                {
                  goto LABEL_241;
                }
                if (*((void *)this + 116)) {
                  uint64_t v33 = nullsub_7;
                }
                else {
                  uint64_t v33 = 0;
                }
                if (!v33)
                {
LABEL_241:
                  if (sub_2167C5D84((uint64_t)this + 368)) {
                    int v47 = nullsub_16;
                  }
                  else {
                    int v47 = 0;
                  }
                  if (v47) {
                    sub_2167C3654((uint64_t)this + 368, a2 + 216);
                  }
                  if (sub_2167C5D84((uint64_t)this + 544)) {
                    uint64_t v48 = nullsub_17;
                  }
                  else {
                    uint64_t v48 = 0;
                  }
                  if (v48) {
                    sub_2167C3A2C((uint64_t)this + 544, a2 + 304);
                  }
                  if (sub_2167C5D84((uint64_t)this + 720)) {
                    int v49 = nullsub_18;
                  }
                  else {
                    int v49 = 0;
                  }
                  if (v49) {
                    sub_2167C3E04((uint64_t)this + 720, a2 + 128);
                  }
                  int v50 = *((char *)this + 975);
                  if (v50 < 0)
                  {
                    if (*((void *)this + 120)) {
                      goto LABEL_288;
                    }
                  }
                  else if (*((unsigned char *)this + 975))
                  {
                    goto LABEL_288;
                  }
                  if (*((void *)this + 122)) {
                    uint64_t v51 = nullsub_7;
                  }
                  else {
                    uint64_t v51 = 0;
                  }
                  if (!v51)
                  {
LABEL_288:
                    int v56 = *((char *)this + 1023);
                    if (v56 < 0)
                    {
                      if (*((void *)this + 126)) {
                        goto LABEL_320;
                      }
                    }
                    else if (*((unsigned char *)this + 1023))
                    {
                      goto LABEL_320;
                    }
                    if (*((void *)this + 128)) {
                      std::string v57 = nullsub_7;
                    }
                    else {
                      std::string v57 = 0;
                    }
                    if (!v57)
                    {
LABEL_320:
                      int v62 = *((char *)this + 1071);
                      if (v62 < 0)
                      {
                        if (*((void *)this + 132)) {
                          goto LABEL_352;
                        }
                      }
                      else if (*((unsigned char *)this + 1071))
                      {
                        goto LABEL_352;
                      }
                      if (*((void *)this + 134)) {
                        uint64_t v63 = nullsub_7;
                      }
                      else {
                        uint64_t v63 = 0;
                      }
                      if (v63)
                      {
                        int v74 = *((_DWORD *)this + 260);
                        if (v62 < 0)
                        {
                          sub_216778F24(&v75, *((void **)this + 131), *((void *)this + 132));
                        }
                        else
                        {
                          long long v75 = *(_OWORD *)((char *)this + 1048);
                          uint64_t v76 = *((void *)this + 133);
                        }
                        uint64_t v64 = *((void *)this + 135);
                        uint64_t v77 = *((void *)this + 134);
                        uint64_t v78 = v64;
                        if (v64) {
                          atomic_fetch_add_explicit((atomic_ullong *volatile)(v64 + 8), 1uLL, memory_order_relaxed);
                        }
                        *(void *)int v70 = *v19;
                        *(void *)&v70[5] = *(void *)(a2 + 485);
                        uint64_t v71 = 0;
                        char v72 = 0;
                        uint64_t v73 = 0;
                        sub_21677EA60(&v71, *(const void **)(a2 + 496), *(void *)(a2 + 504), (uint64_t)(*(void *)(a2 + 504) - *(void *)(a2 + 496)) >> 3);
                        if (SHIBYTE(v76) < 0)
                        {
                          if (*((void *)&v75 + 1)) {
                            goto LABEL_335;
                          }
                        }
                        else if (HIBYTE(v76))
                        {
LABEL_335:
                          int v65 = 0;
LABEL_340:
                          if (v65)
                          {
                            if (*(_DWORD *)&v70[8] == 127 || !*(void *)v70 && v72 == v71) {
                              uint64_t v66 = 0;
                            }
                            else {
                              uint64_t v66 = nullsub_13;
                            }
                            if (v66) {
                              Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v74);
                            }
                            else {
                              Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v74);
                            }
                          }
                          if (v71)
                          {
                            char v72 = v71;
                            operator delete(v71);
                          }
                          Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v74);
                          goto LABEL_352;
                        }
                        if (v77) {
                          int v65 = nullsub_7;
                        }
                        else {
                          int v65 = 0;
                        }
                        goto LABEL_340;
                      }
LABEL_352:
                      if (*(double *)(a2 + 544) <= *(double *)(a2 + 520)
                        || *(double *)(a2 + 552) <= *(double *)(a2 + 528)
                        || *(double *)(a2 + 560) <= *(double *)(a2 + 536))
                      {
                        if (*(_DWORD *)(a2 + 8) == 127
                          || !*(void *)a2 && *(void *)(a2 + 24) == *(void *)(a2 + 16))
                        {
                          int v67 = 0;
                        }
                        else
                        {
                          int v67 = nullsub_19;
                        }
                        if (v67)
                        {
                          sub_2167C354C((void *)a2, (uint64_t)v127);
                          Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 56), v127);
                        }
                        else
                        {
                          Alembic::Abc::v12::OScalarProperty::setFromPrevious((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 56));
                        }
                      }
                      else
                      {
                        Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 56), (const void *)(a2 + 520));
                      }
LABEL_364:
                      ++*((void *)this + 44);
                      return;
                    }
                    int v83 = *((_DWORD *)this + 248);
                    if (v56 < 0)
                    {
                      sub_216778F24(&v84, *((void **)this + 125), *((void *)this + 126));
                    }
                    else
                    {
                      long long v84 = *(_OWORD *)((char *)this + 1000);
                      uint64_t v85 = *((void *)this + 127);
                    }
                    uint64_t v58 = *((void *)this + 129);
                    uint64_t v86 = *((void *)this + 128);
                    uint64_t v87 = v58;
                    if (v58) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v58 + 8), 1uLL, memory_order_relaxed);
                    }
                    uint64_t v59 = *(void *)(a2 + 445);
                    *(void *)unint64_t v79 = *v17;
                    *(void *)&v79[5] = v59;
                    char v80 = 0;
                    int v81 = 0;
                    uint64_t v82 = 0;
                    sub_21677EA60(&v80, *(const void **)(a2 + 456), *(void *)(a2 + 464), (uint64_t)(*(void *)(a2 + 464) - *(void *)(a2 + 456)) >> 3);
                    if (SHIBYTE(v85) < 0)
                    {
                      if (*((void *)&v84 + 1)) {
                        goto LABEL_303;
                      }
                    }
                    else if (HIBYTE(v85))
                    {
LABEL_303:
                      std::string v60 = 0;
LABEL_308:
                      if (v60)
                      {
                        if (*(_DWORD *)&v79[8] == 127 || !*(void *)v79 && v81 == v80) {
                          uint64_t v61 = 0;
                        }
                        else {
                          uint64_t v61 = nullsub_14;
                        }
                        if (v61) {
                          Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v83);
                        }
                        else {
                          Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v83);
                        }
                      }
                      if (v80)
                      {
                        int v81 = v80;
                        operator delete(v80);
                      }
                      Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v83);
                      goto LABEL_320;
                    }
                    if (v86) {
                      std::string v60 = nullsub_7;
                    }
                    else {
                      std::string v60 = 0;
                    }
                    goto LABEL_308;
                  }
                  int v92 = *((_DWORD *)this + 236);
                  if (v50 < 0)
                  {
                    sub_216778F24(&v93, *((void **)this + 119), *((void *)this + 120));
                  }
                  else
                  {
                    long long v93 = *(_OWORD *)((char *)this + 952);
                    uint64_t v94 = *((void *)this + 121);
                  }
                  uint64_t v52 = *((void *)this + 123);
                  uint64_t v95 = *((void *)this + 122);
                  uint64_t v96 = v52;
                  if (v52) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v52 + 8), 1uLL, memory_order_relaxed);
                  }
                  uint64_t v53 = *(void *)(a2 + 405);
                  *(void *)char v88 = *v15;
                  *(void *)&v88[5] = v53;
                  int v89 = 0;
                  int v90 = 0;
                  uint64_t v91 = 0;
                  sub_21677EA60(&v89, *(const void **)(a2 + 416), *(void *)(a2 + 424), (uint64_t)(*(void *)(a2 + 424) - *(void *)(a2 + 416)) >> 3);
                  if (SHIBYTE(v94) < 0)
                  {
                    if (*((void *)&v93 + 1)) {
                      goto LABEL_271;
                    }
                  }
                  else if (HIBYTE(v94))
                  {
LABEL_271:
                    uint64_t v54 = 0;
LABEL_276:
                    if (v54)
                    {
                      if (*(_DWORD *)&v88[8] == 127 || !*(void *)v88 && v90 == v89) {
                        int v55 = 0;
                      }
                      else {
                        int v55 = nullsub_13;
                      }
                      if (v55) {
                        Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v92);
                      }
                      else {
                        Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v92);
                      }
                    }
                    if (v89)
                    {
                      int v90 = v89;
                      operator delete(v89);
                    }
                    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v92);
                    goto LABEL_288;
                  }
                  if (v95) {
                    uint64_t v54 = nullsub_7;
                  }
                  else {
                    uint64_t v54 = 0;
                  }
                  goto LABEL_276;
                }
                int v101 = *((_DWORD *)this + 224);
                if (v32 < 0)
                {
                  sub_216778F24(&v102, *((void **)this + 113), *((void *)this + 114));
                }
                else
                {
                  long long v102 = *(_OWORD *)((char *)this + 904);
                  uint64_t v103 = *((void *)this + 115);
                }
                uint64_t v43 = *((void *)this + 117);
                uint64_t v104 = *((void *)this + 116);
                uint64_t v105 = v43;
                if (v43) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v43 + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t v44 = *(void *)(a2 + 45);
                *(void *)unint64_t v97 = *v5;
                *(void *)&v97[5] = v44;
                unint64_t v98 = 0;
                int v99 = 0;
                uint64_t v100 = 0;
                sub_21677EA60(&v98, *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3);
                if (SHIBYTE(v103) < 0)
                {
                  if (*((void *)&v102 + 1)) {
                    goto LABEL_223;
                  }
                }
                else if (HIBYTE(v103))
                {
LABEL_223:
                  long long v45 = 0;
LABEL_228:
                  if (v45)
                  {
                    if (*(_DWORD *)&v97[8] == 127 || !*(void *)v97 && v99 == v98) {
                      int v46 = 0;
                    }
                    else {
                      int v46 = nullsub_10;
                    }
                    if (v46) {
                      Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v101);
                    }
                    else {
                      Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v101);
                    }
                  }
                  if (v98)
                  {
                    int v99 = v98;
                    operator delete(v98);
                  }
                  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v101);
                  goto LABEL_241;
                }
                if (v104) {
                  long long v45 = nullsub_7;
                }
                else {
                  long long v45 = 0;
                }
                goto LABEL_228;
              }
              if (*((void *)this + 41)) {
                uint64_t v30 = nullsub_7;
              }
              else {
                uint64_t v30 = 0;
              }
              goto LABEL_144;
            }
            if (*(_DWORD *)(a2 + 8) == 127 || !*(void *)a2 && *(void *)(a2 + 24) == *(void *)(a2 + 16))
            {
              sub_216778A5C((uint64_t)v127);
              sub_216779180(v128, (uint64_t)"Sample 0 must have valid data for all mesh components", 53);
              std::stringbuf::str();
              sub_216778E70(v126, &v124);
              if (v125 < 0) {
                operator delete((void *)v124);
              }
              exception = __cxa_allocate_exception(0x20uLL);
              uint64_t v69 = sub_216779038(exception, (uint64_t)v126);
              __cxa_throw(v69, (struct type_info *)&unk_26C7470A0, (void (*)(void *))sub_216778D34);
            }
            Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 248);
            Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 296);
            Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 1088), v129);
            if (*((char *)this + 927) < 0)
            {
              if (*((void *)this + 114)) {
                goto LABEL_92;
              }
            }
            else if (*((unsigned char *)this + 927))
            {
LABEL_92:
              uint64_t v21 = 0;
LABEL_161:
              if (v21) {
                Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 896);
              }
              if (*(double *)(a2 + 544) >= *(double *)(a2 + 520)
                && *(double *)(a2 + 552) >= *(double *)(a2 + 528)
                && *(double *)(a2 + 560) >= *(double *)(a2 + 536))
              {
                Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 56), (const void *)(a2 + 520));
              }
              else
              {
                sub_2167C354C((void *)a2, (uint64_t)v127);
                Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 56), v127);
              }
              if (*(_DWORD *)(a2 + 224) == 127 || !*v7 && *(void *)(a2 + 240) == *(void *)(a2 + 232)) {
                int v34 = 0;
              }
              else {
                int v34 = nullsub_8;
              }
              if (v34) {
                uint64_t v35 = nullsub_11;
              }
              else {
                uint64_t v35 = 0;
              }
              if (v35) {
                sub_2167C3654((uint64_t)this + 368, a2 + 216);
              }
              if (*(_DWORD *)(a2 + 312) == 127 || !*v10 && *(void *)(a2 + 328) == *(void *)(a2 + 320)) {
                uint64_t v36 = 0;
              }
              else {
                uint64_t v36 = nullsub_9;
              }
              if (v36) {
                uint64_t v37 = nullsub_12;
              }
              else {
                uint64_t v37 = 0;
              }
              if (v37) {
                sub_2167C3A2C((uint64_t)this + 544, a2 + 304);
              }
              if (*(_DWORD *)(a2 + 136) == 127 || !*v13 && *(void *)(a2 + 152) == *(void *)(a2 + 144)) {
                uint64_t v38 = 0;
              }
              else {
                uint64_t v38 = nullsub_13;
              }
              if (v38) {
                uint64_t v39 = nullsub_15;
              }
              else {
                uint64_t v39 = 0;
              }
              if (v39) {
                sub_2167C3E04((uint64_t)this + 720, a2 + 128);
              }
              if (*(_DWORD *)(a2 + 408) == 127 || !*v15 && *(void *)(a2 + 424) == *(void *)(a2 + 416)) {
                uint64_t v40 = 0;
              }
              else {
                uint64_t v40 = nullsub_13;
              }
              if (v40) {
                Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 944);
              }
              if (*(_DWORD *)(a2 + 448) == 127 || !*v17 && *(void *)(a2 + 464) == *(void *)(a2 + 456)) {
                char v41 = 0;
              }
              else {
                char v41 = nullsub_14;
              }
              if (v41) {
                Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 992);
              }
              if (*(_DWORD *)(a2 + 488) == 127 || !*v19 && *(void *)(a2 + 504) == *(void *)(a2 + 496)) {
                char v42 = 0;
              }
              else {
                char v42 = nullsub_13;
              }
              if (v42) {
                Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 1040);
              }
              goto LABEL_364;
            }
            if (*((void *)this + 116)) {
              uint64_t v21 = nullsub_7;
            }
            else {
              uint64_t v21 = 0;
            }
            goto LABEL_161;
          }
          if (*((char *)this + 1071) < 0)
          {
            if (!*((void *)this + 132)) {
              goto LABEL_82;
            }
          }
          else if (!*((unsigned char *)this + 1071))
          {
LABEL_82:
            if (*((void *)this + 134)) {
              goto LABEL_84;
            }
          }
          Alembic::AbcGeom::v12::OCurvesSchema::createKnotsProperty(this);
          goto LABEL_84;
        }
LABEL_71:
        Alembic::AbcGeom::v12::OCurvesSchema::createOrdersProperty(this);
        goto LABEL_72;
      }
LABEL_59:
      Alembic::AbcGeom::v12::OCurvesSchema::createPositionWeightsProperty(this);
      goto LABEL_60;
    }
LABEL_17:
    Alembic::AbcGeom::v12::OCurvesSchema::createVelocityProperty(this);
    goto LABEL_18;
  }

  Alembic::AbcGeom::v12::OCurvesSchema::selectiveSet(this, a2);
}

void sub_2167C0858(void *a1, int a2)
{
  sub_216779148((std::exception *)&STACK[0x228]);
  sub_216778D38((uint64_t)&STACK[0x248]);
  uint64_t v5 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v2 - 104, (uint64_t)v5);
  }
  else {
    sub_21679F9F4(v2 - 104, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167C07BCLL);
}

void sub_2167C09D8(_Unwind_Exception *a1)
{
}

BOOL sub_2167C09F8(uint64_t a1)
{
  BOOL result = 0;
  if (!*(void *)a1)
  {
    if (*(_DWORD *)(a1 + 224) == 127 || !*(void *)(a1 + 216) && *(void *)(a1 + 240) == *(void *)(a1 + 232)
       ? 0
       : nullsub_8)
    {
      return 1;
    }
    uint64_t v3 = *(_DWORD *)(a1 + 312) == 127 || !*(void *)(a1 + 304) && *(void *)(a1 + 328) == *(void *)(a1 + 320)
       ? 0
       : nullsub_9;
    if (v3 || *(void *)(a1 + 40)) {
      return 1;
    }
  }
  return result;
}

void Alembic::AbcGeom::v12::OCurvesSchema::selectiveSet(Alembic::AbcGeom::v12::OCurvesSchema *this, uint64_t a2)
{
  uint64_t v118 = (char *)this + 8;
  int v119 = "OCurvesSchema::selectiveSet()";
  int v4 = *(_DWORD *)(a2 + 124);
  v115[0] = *(_DWORD *)(a2 + 120);
  v115[1] = v4;
  char v116 = *(unsigned char *)(a2 + 392);
  char v117 = v116;
  if (*(_DWORD *)(a2 + 8) == 127 || !*(void *)a2 && *(void *)(a2 + 24) == *(void *)(a2 + 16)) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = nullsub_19;
  }
  if (v5)
  {
    if (*((char *)this + 279) < 0)
    {
      if (!*((void *)this + 33)) {
        goto LABEL_11;
      }
    }
    else if (!*((unsigned char *)this + 279))
    {
LABEL_11:
      if (*((void *)this + 35)) {
        goto LABEL_13;
      }
    }
    Alembic::AbcGeom::v12::OCurvesSchema::createPositionProperty(this);
  }
LABEL_13:
  int v6 = *((char *)this + 279);
  if (v6 < 0)
  {
    if (*((void *)this + 33)) {
      goto LABEL_56;
    }
  }
  else if (*((unsigned char *)this + 279))
  {
    goto LABEL_56;
  }
  if (*((void *)this + 35)) {
    uint64_t v7 = nullsub_7;
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7) {
    goto LABEL_56;
  }
  int v110 = *((_DWORD *)this + 62);
  if (v6 < 0)
  {
    sub_216778F24(&v111, *((void **)this + 32), *((void *)this + 33));
  }
  else
  {
    long long v111 = *((_OWORD *)this + 16);
    uint64_t v112 = *((void *)this + 34);
  }
  uint64_t v8 = *((void *)this + 36);
  uint64_t v113 = *((void *)this + 35);
  uint64_t v114 = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *(void *)(a2 + 5);
  *(void *)char v106 = *(void *)a2;
  *(void *)&v106[5] = v9;
  unint64_t v107 = 0;
  unint64_t v108 = 0;
  uint64_t v109 = 0;
  sub_21677EA60(&v107, *(const void **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
  if (SHIBYTE(v112) < 0)
  {
    if (*((void *)&v111 + 1)) {
      goto LABEL_28;
    }
LABEL_30:
    if (v113) {
      int v10 = nullsub_7;
    }
    else {
      int v10 = 0;
    }
    goto LABEL_33;
  }
  if (!HIBYTE(v112)) {
    goto LABEL_30;
  }
LABEL_28:
  int v10 = 0;
LABEL_33:
  if (v10)
  {
    if (*(_DWORD *)&v106[8] == 127 || !*(void *)v106 && v108 == v107) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = nullsub_19;
    }
    if (v11) {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v110);
    }
    else {
      Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v110);
    }
  }
  if (v107)
  {
    unint64_t v108 = v107;
    operator delete(v107);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v110);
  if (*(double *)(a2 + 544) <= *(double *)(a2 + 520)
    || *(double *)(a2 + 552) <= *(double *)(a2 + 528)
    || *(double *)(a2 + 560) <= *(double *)(a2 + 536))
  {
    if (*(_DWORD *)(a2 + 8) == 127 || !*(void *)a2 && *(void *)(a2 + 24) == *(void *)(a2 + 16)) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = nullsub_19;
    }
    if (v12)
    {
      sub_2167C354C((void *)a2, (uint64_t)v105);
      Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 56), v105);
    }
    else
    {
      Alembic::Abc::v12::OScalarProperty::setFromPrevious((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 56));
    }
  }
  else
  {
    Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 56), (const void *)(a2 + 520));
  }
LABEL_56:
  uint64_t v13 = (void *)(a2 + 80);
  if (*(_DWORD *)(a2 + 88) == 127 || !*v13 && *(void *)(a2 + 104) == *(void *)(a2 + 96)) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = nullsub_20;
  }
  if (v14)
  {
    if (*((char *)this + 327) < 0)
    {
      if (!*((void *)this + 39)) {
        goto LABEL_66;
      }
    }
    else if (!*((unsigned char *)this + 327))
    {
LABEL_66:
      if (*((void *)this + 41)) {
        goto LABEL_68;
      }
    }
    Alembic::AbcGeom::v12::OCurvesSchema::createVertexProperties(this);
  }
LABEL_68:
  int v15 = *((char *)this + 327);
  if (v15 < 0)
  {
    if (*((void *)this + 39)) {
      goto LABEL_100;
    }
  }
  else if (*((unsigned char *)this + 327))
  {
    goto LABEL_100;
  }
  if (*((void *)this + 41)) {
    long long v16 = nullsub_7;
  }
  else {
    long long v16 = 0;
  }
  if (!v16) {
    goto LABEL_100;
  }
  int v100 = *((_DWORD *)this + 74);
  if (v15 < 0)
  {
    sub_216778F24(&v101, *((void **)this + 38), *((void *)this + 39));
  }
  else
  {
    long long v101 = *((_OWORD *)this + 19);
    uint64_t v102 = *((void *)this + 40);
  }
  uint64_t v17 = *((void *)this + 42);
  uint64_t v103 = *((void *)this + 41);
  uint64_t v104 = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = *(void *)(a2 + 85);
  *(void *)uint64_t v96 = *v13;
  *(void *)&v96[5] = v18;
  long long __p = 0;
  unint64_t v98 = 0;
  uint64_t v99 = 0;
  sub_21677EA60(&__p, *(const void **)(a2 + 96), *(void *)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3);
  if (SHIBYTE(v102) < 0)
  {
    if (*((void *)&v101 + 1)) {
      goto LABEL_83;
    }
LABEL_85:
    if (v103) {
      uint64_t v19 = nullsub_7;
    }
    else {
      uint64_t v19 = 0;
    }
    goto LABEL_88;
  }
  if (!HIBYTE(v102)) {
    goto LABEL_85;
  }
LABEL_83:
  uint64_t v19 = 0;
LABEL_88:
  if (v19)
  {
    if (*(_DWORD *)&v96[8] == 127 || !*(void *)v96 && v98 == __p) {
      uint64_t v20 = 0;
    }
    else {
      uint64_t v20 = nullsub_20;
    }
    if (v20) {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v100);
    }
    else {
      Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v100);
    }
  }
  if (__p)
  {
    unint64_t v98 = __p;
    operator delete(__p);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v100);
  Alembic::Abc::v12::OScalarProperty::set((Alembic::AbcGeom::v12::OCurvesSchema *)((char *)this + 1088), v115);
LABEL_100:
  uint64_t v21 = (void *)(a2 + 40);
  if (*(_DWORD *)(a2 + 48) == 127 || !*v21 && *(void *)(a2 + 64) == *(void *)(a2 + 56)) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = nullsub_10;
  }
  if (v22)
  {
    if (*((char *)this + 927) < 0)
    {
      if (!*((void *)this + 114)) {
        goto LABEL_110;
      }
    }
    else if (!*((unsigned char *)this + 927))
    {
LABEL_110:
      if (*((void *)this + 116)) {
        goto LABEL_112;
      }
    }
    Alembic::AbcGeom::v12::OCurvesSchema::createVelocityProperty(this);
  }
LABEL_112:
  int v23 = *((char *)this + 927);
  if (v23 < 0)
  {
    if (*((void *)this + 114)) {
      goto LABEL_144;
    }
  }
  else if (*((unsigned char *)this + 927))
  {
    goto LABEL_144;
  }
  if (*((void *)this + 116)) {
    uint64_t v24 = nullsub_7;
  }
  else {
    uint64_t v24 = 0;
  }
  if (!v24) {
    goto LABEL_144;
  }
  int v91 = *((_DWORD *)this + 224);
  if (v23 < 0)
  {
    sub_216778F24(&v92, *((void **)this + 113), *((void *)this + 114));
  }
  else
  {
    long long v92 = *(_OWORD *)((char *)this + 904);
    uint64_t v93 = *((void *)this + 115);
  }
  uint64_t v25 = *((void *)this + 117);
  uint64_t v94 = *((void *)this + 116);
  uint64_t v95 = v25;
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v26 = *(void *)(a2 + 45);
  *(void *)uint64_t v87 = *v21;
  *(void *)&v87[5] = v26;
  char v88 = 0;
  int v89 = 0;
  uint64_t v90 = 0;
  sub_21677EA60(&v88, *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3);
  if (SHIBYTE(v93) < 0)
  {
    if (*((void *)&v92 + 1)) {
      goto LABEL_127;
    }
LABEL_129:
    if (v94) {
      uint64_t v27 = nullsub_7;
    }
    else {
      uint64_t v27 = 0;
    }
    goto LABEL_132;
  }
  if (!HIBYTE(v93)) {
    goto LABEL_129;
  }
LABEL_127:
  uint64_t v27 = 0;
LABEL_132:
  if (v27)
  {
    if (*(_DWORD *)&v87[8] == 127 || !*(void *)v87 && v89 == v88) {
      uint64_t v28 = 0;
    }
    else {
      uint64_t v28 = nullsub_10;
    }
    if (v28) {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v91);
    }
    else {
      Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v91);
    }
  }
  if (v88)
  {
    int v89 = v88;
    operator delete(v88);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v91);
LABEL_144:
  if (*(_DWORD *)(a2 + 224) == 127 || !*(void *)(a2 + 216) && *(void *)(a2 + 240) == *(void *)(a2 + 232)) {
    uint64_t v29 = 0;
  }
  else {
    uint64_t v29 = nullsub_8;
  }
  if (v29) {
    uint64_t v30 = nullsub_11;
  }
  else {
    uint64_t v30 = 0;
  }
  if (v30 && (sub_2167C5D84((uint64_t)this + 368) & 1) == 0) {
    Alembic::AbcGeom::v12::OCurvesSchema::createUVsProperty(this, a2);
  }
  if (sub_2167C5D84((uint64_t)this + 368)) {
    uint64_t v31 = nullsub_16;
  }
  else {
    uint64_t v31 = 0;
  }
  if (v31) {
    sub_2167C3654((uint64_t)this + 368, a2 + 216);
  }
  if (*(_DWORD *)(a2 + 312) == 127 || !*(void *)(a2 + 304) && *(void *)(a2 + 328) == *(void *)(a2 + 320)) {
    int v32 = 0;
  }
  else {
    int v32 = nullsub_9;
  }
  if (v32) {
    uint64_t v33 = nullsub_12;
  }
  else {
    uint64_t v33 = 0;
  }
  if (v33 && (sub_2167C5D84((uint64_t)this + 544) & 1) == 0) {
    Alembic::AbcGeom::v12::OCurvesSchema::createNormalsProperty(this, a2);
  }
  if (sub_2167C5D84((uint64_t)this + 544)) {
    int v34 = nullsub_17;
  }
  else {
    int v34 = 0;
  }
  if (v34) {
    sub_2167C3A2C((uint64_t)this + 544, a2 + 304);
  }
  if (*(_DWORD *)(a2 + 136) == 127 || !*(void *)(a2 + 128) && *(void *)(a2 + 152) == *(void *)(a2 + 144)) {
    uint64_t v35 = 0;
  }
  else {
    uint64_t v35 = nullsub_13;
  }
  if (v35 && (sub_2167C5D84((uint64_t)this + 720) & 1) == 0) {
    Alembic::AbcGeom::v12::OCurvesSchema::createWidthProperty(this, a2);
  }
  if (sub_2167C5D84((uint64_t)this + 720)) {
    uint64_t v36 = nullsub_18;
  }
  else {
    uint64_t v36 = 0;
  }
  if (v36) {
    sub_2167C3E04((uint64_t)this + 720, a2 + 128);
  }
  uint64_t v37 = (void *)(a2 + 400);
  if (*(_DWORD *)(a2 + 408) == 127 || !*v37 && *(void *)(a2 + 424) == *(void *)(a2 + 416)) {
    uint64_t v38 = 0;
  }
  else {
    uint64_t v38 = nullsub_13;
  }
  if (v38)
  {
    if (*((char *)this + 975) < 0)
    {
      if (!*((void *)this + 120)) {
        goto LABEL_199;
      }
    }
    else if (!*((unsigned char *)this + 975))
    {
LABEL_199:
      if (*((void *)this + 122)) {
        goto LABEL_201;
      }
    }
    Alembic::AbcGeom::v12::OCurvesSchema::createPositionWeightsProperty(this);
  }
LABEL_201:
  int v39 = *((char *)this + 975);
  if (v39 < 0)
  {
    if (*((void *)this + 120)) {
      goto LABEL_233;
    }
  }
  else if (*((unsigned char *)this + 975))
  {
    goto LABEL_233;
  }
  if (*((void *)this + 122)) {
    uint64_t v40 = nullsub_7;
  }
  else {
    uint64_t v40 = 0;
  }
  if (!v40) {
    goto LABEL_233;
  }
  int v82 = *((_DWORD *)this + 236);
  if (v39 < 0)
  {
    sub_216778F24(&v83, *((void **)this + 119), *((void *)this + 120));
  }
  else
  {
    long long v83 = *(_OWORD *)((char *)this + 952);
    uint64_t v84 = *((void *)this + 121);
  }
  uint64_t v41 = *((void *)this + 123);
  uint64_t v85 = *((void *)this + 122);
  uint64_t v86 = v41;
  if (v41) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v41 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v42 = *(void *)(a2 + 405);
  *(void *)uint64_t v78 = *v37;
  *(void *)&v78[5] = v42;
  unint64_t v79 = 0;
  char v80 = 0;
  uint64_t v81 = 0;
  sub_21677EA60(&v79, *(const void **)(a2 + 416), *(void *)(a2 + 424), (uint64_t)(*(void *)(a2 + 424) - *(void *)(a2 + 416)) >> 3);
  if (SHIBYTE(v84) < 0)
  {
    if (*((void *)&v83 + 1)) {
      goto LABEL_216;
    }
LABEL_218:
    if (v85) {
      uint64_t v43 = nullsub_7;
    }
    else {
      uint64_t v43 = 0;
    }
    goto LABEL_221;
  }
  if (!HIBYTE(v84)) {
    goto LABEL_218;
  }
LABEL_216:
  uint64_t v43 = 0;
LABEL_221:
  if (v43)
  {
    if (*(_DWORD *)&v78[8] == 127 || !*(void *)v78 && v80 == v79) {
      uint64_t v44 = 0;
    }
    else {
      uint64_t v44 = nullsub_13;
    }
    if (v44) {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v82);
    }
    else {
      Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v82);
    }
  }
  if (v79)
  {
    char v80 = v79;
    operator delete(v79);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v82);
LABEL_233:
  long long v45 = (void *)(a2 + 440);
  if (*(_DWORD *)(a2 + 448) == 127 || !*v45 && *(void *)(a2 + 464) == *(void *)(a2 + 456)) {
    int v46 = 0;
  }
  else {
    int v46 = nullsub_14;
  }
  if (v46)
  {
    if (*((char *)this + 1023) < 0)
    {
      if (!*((void *)this + 126)) {
        goto LABEL_243;
      }
    }
    else if (!*((unsigned char *)this + 1023))
    {
LABEL_243:
      if (*((void *)this + 128)) {
        goto LABEL_245;
      }
    }
    Alembic::AbcGeom::v12::OCurvesSchema::createOrdersProperty(this);
  }
LABEL_245:
  int v47 = *((char *)this + 1023);
  if (v47 < 0)
  {
    if (*((void *)this + 126)) {
      goto LABEL_277;
    }
  }
  else if (*((unsigned char *)this + 1023))
  {
    goto LABEL_277;
  }
  if (*((void *)this + 128)) {
    uint64_t v48 = nullsub_7;
  }
  else {
    uint64_t v48 = 0;
  }
  if (!v48) {
    goto LABEL_277;
  }
  int v73 = *((_DWORD *)this + 248);
  if (v47 < 0)
  {
    sub_216778F24(&v74, *((void **)this + 125), *((void *)this + 126));
  }
  else
  {
    long long v74 = *(_OWORD *)((char *)this + 1000);
    uint64_t v75 = *((void *)this + 127);
  }
  uint64_t v49 = *((void *)this + 129);
  uint64_t v76 = *((void *)this + 128);
  uint64_t v77 = v49;
  if (v49) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v49 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v50 = *(void *)(a2 + 445);
  *(void *)uint64_t v69 = *v45;
  *(void *)&v69[5] = v50;
  int v70 = 0;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  sub_21677EA60(&v70, *(const void **)(a2 + 456), *(void *)(a2 + 464), (uint64_t)(*(void *)(a2 + 464) - *(void *)(a2 + 456)) >> 3);
  if (SHIBYTE(v75) < 0)
  {
    if (*((void *)&v74 + 1)) {
      goto LABEL_260;
    }
LABEL_262:
    if (v76) {
      uint64_t v51 = nullsub_7;
    }
    else {
      uint64_t v51 = 0;
    }
    goto LABEL_265;
  }
  if (!HIBYTE(v75)) {
    goto LABEL_262;
  }
LABEL_260:
  uint64_t v51 = 0;
LABEL_265:
  if (v51)
  {
    if (*(_DWORD *)&v69[8] == 127 || !*(void *)v69 && v71 == v70) {
      uint64_t v52 = 0;
    }
    else {
      uint64_t v52 = nullsub_14;
    }
    if (v52) {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v73);
    }
    else {
      Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v73);
    }
  }
  if (v70)
  {
    uint64_t v71 = v70;
    operator delete(v70);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v73);
LABEL_277:
  uint64_t v53 = (void *)(a2 + 480);
  if (*(_DWORD *)(a2 + 488) == 127 || !*v53 && *(void *)(a2 + 504) == *(void *)(a2 + 496)) {
    uint64_t v54 = 0;
  }
  else {
    uint64_t v54 = nullsub_13;
  }
  if (v54)
  {
    if (*((char *)this + 1071) < 0)
    {
      if (!*((void *)this + 132)) {
        goto LABEL_287;
      }
    }
    else if (!*((unsigned char *)this + 1071))
    {
LABEL_287:
      if (*((void *)this + 134)) {
        goto LABEL_289;
      }
    }
    Alembic::AbcGeom::v12::OCurvesSchema::createKnotsProperty(this);
  }
LABEL_289:
  int v55 = *((char *)this + 1071);
  if (v55 < 0)
  {
    if (*((void *)this + 132)) {
      goto LABEL_321;
    }
  }
  else if (*((unsigned char *)this + 1071))
  {
    goto LABEL_321;
  }
  if (*((void *)this + 134)) {
    int v56 = nullsub_7;
  }
  else {
    int v56 = 0;
  }
  if (v56)
  {
    int v64 = *((_DWORD *)this + 260);
    if (v55 < 0)
    {
      sub_216778F24(&v65, *((void **)this + 131), *((void *)this + 132));
    }
    else
    {
      long long v65 = *(_OWORD *)((char *)this + 1048);
      uint64_t v66 = *((void *)this + 133);
    }
    uint64_t v57 = *((void *)this + 135);
    uint64_t v67 = *((void *)this + 134);
    uint64_t v68 = v57;
    if (v57) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v57 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)std::string v60 = *v53;
    *(void *)&v60[5] = *(void *)(a2 + 485);
    uint64_t v61 = 0;
    int v62 = 0;
    uint64_t v63 = 0;
    sub_21677EA60(&v61, *(const void **)(a2 + 496), *(void *)(a2 + 504), (uint64_t)(*(void *)(a2 + 504) - *(void *)(a2 + 496)) >> 3);
    if (SHIBYTE(v66) < 0)
    {
      if (*((void *)&v65 + 1)) {
        goto LABEL_304;
      }
    }
    else if (HIBYTE(v66))
    {
LABEL_304:
      uint64_t v58 = 0;
LABEL_309:
      if (v58)
      {
        if (*(_DWORD *)&v60[8] == 127 || !*(void *)v60 && v62 == v61) {
          uint64_t v59 = 0;
        }
        else {
          uint64_t v59 = nullsub_13;
        }
        if (v59) {
          Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v64);
        }
        else {
          Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v64);
        }
      }
      if (v61)
      {
        int v62 = v61;
        operator delete(v61);
      }
      Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v64);
      goto LABEL_321;
    }
    if (v67) {
      uint64_t v58 = nullsub_7;
    }
    else {
      uint64_t v58 = 0;
    }
    goto LABEL_309;
  }
LABEL_321:
  ++*((void *)this + 44);
}

void sub_2167C19B8(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57)
{
  uint64_t v59 = __cxa_begin_catch(a1);
  if (a2 == 2) {
    sub_21679FA64(v57 - 64, (uint64_t)v59);
  }
  else {
    sub_21679F9F4(v57 - 64, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167C19A0);
}

void sub_2167C1B04(_Unwind_Exception *a1)
{
}

void Alembic::AbcGeom::v12::OCurvesSchema::calcBasisAndType(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  *a2 = *(_DWORD *)(a3 + 120);
  a2[1] = *(_DWORD *)(a3 + 124);
  char v3 = *(unsigned char *)(a3 + 392);
  a2[2] = v3;
  a2[3] = v3;
}

void Alembic::AbcGeom::v12::OCurvesSchema::createVelocityProperty(Alembic::AbcGeom::v12::OCurvesSchema *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 6);
  uint64_t v15 = *((void *)this + 5);
  long long v16 = v2;
  if (v2) {
    atomic_fetch_add_explicit(&v2->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_216779094(&__p, ".velocities");
  int v3 = *((_DWORD *)this + 90);
  v11[0] = 2;
  void v11[2] = v3;
  v10[0] = 0;
  void v10[2] = 0;
  v9[0] = 0;
  int v9[2] = 0;
  v8[0] = 0;
  v8[2] = 0;
  sub_2167C6BC0((uint64_t)&v17, &v15, (uint64_t)&__p, v11, v10, v9, v8);
  *((_DWORD *)this + 224) = v17;
  std::string::operator=((std::string *)((char *)this + 904), &v18);
  uint64_t v5 = v19;
  uint64_t v4 = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 116) = v5;
  int v6 = (std::__shared_weak_count *)*((void *)this + 117);
  *((void *)this + 117) = v4;
  if (v6) {
    sub_216784EC4(v6);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v17);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p);
  }
  if (v16) {
    sub_216784EC4(v16);
  }
  long long __p = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  sub_2167C6418(&v17, (uint64_t *)&__p);
  if (*((void *)this + 44))
  {
    unint64_t v7 = 0;
    do
    {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 896);
      ++v7;
    }
    while (v7 < *((void *)this + 44));
  }
  if (v18.__r_.__value_.__l.__size_)
  {
    v18.__r_.__value_.__r.__words[2] = v18.__r_.__value_.__l.__size_;
    operator delete((void *)v18.__r_.__value_.__l.__size_);
  }
  if (__p)
  {
    uint64_t v13 = __p;
    operator delete(__p);
  }
}

void sub_2167C1CA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::AbcGeom::v12::OCurvesSchema::createUVsProperty(void *a1, uint64_t a2)
{
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  long long v45 = 0;
  int v46 = 0;
  uint64_t v47 = 0;
  *(void *)&long long v38 = 0;
  *((void *)&v38 + 1) = 0x20000000ALL;
  long long v39 = 0u;
  *(_OWORD *)uint64_t v40 = 0u;
  *(void *)&v40[16] = 0x100000005;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  int v44 = 127;
  if (*(_DWORD *)(a2 + 264) == 127 || !*(void *)(a2 + 256) && *(void *)(a2 + 280) == *(void *)(a2 + 272)) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = nullsub_21;
  }
  if (v4)
  {
    sub_2167C7154(v35, (uint64_t *)&v48);
    sub_2167C71F8(&v31, (uint64_t *)&v45);
    sub_2167C729C((uint64_t)&__dst, (uint64_t *)v35, &v31, *(_DWORD *)(a2 + 296));
    *(void *)&long long v38 = __dst;
    *(void *)((char *)&v38 + 5) = *(void *)((char *)&__dst + 5);
    sub_21677CC7C((char *)&v39, (char *)v23, v24[0], (v24[0] - (uint64_t)v23) >> 3);
    *(void *)&v40[8] = v25;
    *(void *)&v40[13] = *(void *)((char *)&v25 + 5);
    sub_21677CC7C((char *)&v41, (char *)__p, (uint64_t)v27, (v27 - (unsigned char *)__p) >> 3);
    int v44 = v29;
    if (__p)
    {
      uint64_t v27 = __p;
      operator delete(__p);
    }
    if (v23)
    {
      v24[0] = (uint64_t)v23;
      operator delete(v23);
    }
    if (v33)
    {
      int v34 = v33;
      operator delete(v33);
    }
    if (v36)
    {
      uint64_t v37 = v36;
      operator delete(v36);
    }
    uint64_t v5 = (std::__shared_weak_count *)a1[6];
    uint64_t v20 = a1[5];
    uint64_t v21 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(v35, "uv");
    int v6 = v44;
    sub_2167C5248((uint64_t)a1, &v18);
    LODWORD(v31) = 4;
    int v32 = &v18;
    int v16 = 0;
    int v17 = 0;
    int v14 = 0;
    int v15 = 0;
    sub_2167C7350((char *)&__dst, &v20, (uint64_t)v35, 1, v6, 1, &v31, &v16, &v14);
    sub_2167C5310((uint64_t)(a1 + 46), &__dst);
    Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v30);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v28);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)v24);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)__dst);
    }
    if (v19) {
      sub_216784EC4(v19);
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(*(void **)v35);
    }
    unint64_t v7 = v21;
    if (v21) {
LABEL_24:
    }
      sub_216784EC4(v7);
  }
  else
  {
    sub_2167C7154(v35, (uint64_t *)&v48);
    int v9 = *(_DWORD *)(a2 + 296);
    *(void *)&long long __dst = *(void *)v35;
    *(void *)((char *)&__dst + 5) = *(void *)&v35[5];
    int v23 = 0;
    v24[0] = 0;
    v24[1] = 0;
    sub_21677EA60(&v23, v36, (uint64_t)v37, (v37 - v36) >> 3);
    *(void *)&long long v25 = 0;
    *((void *)&v25 + 1) = 0x100000005;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    long long __p = 0;
    int v29 = v9;
    *(void *)&long long v38 = __dst;
    *(void *)((char *)&v38 + 5) = *(void *)((char *)&__dst + 5);
    sub_21677CC7C((char *)&v39, (char *)v23, v24[0], (v24[0] - (uint64_t)v23) >> 3);
    *(void *)&v40[8] = v25;
    *(void *)&v40[13] = *(void *)((char *)&v25 + 5);
    sub_21677CC7C((char *)&v41, (char *)__p, (uint64_t)v27, (v27 - (unsigned char *)__p) >> 3);
    int v44 = v29;
    if (__p)
    {
      uint64_t v27 = __p;
      operator delete(__p);
    }
    if (v23)
    {
      v24[0] = (uint64_t)v23;
      operator delete(v23);
    }
    if (v36)
    {
      uint64_t v37 = v36;
      operator delete(v36);
    }
    int v10 = (std::__shared_weak_count *)a1[6];
    uint64_t v12 = a1[5];
    uint64_t v13 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(v35, "uv");
    int v11 = v44;
    sub_2167C5248((uint64_t)a1, &v18);
    LODWORD(v31) = 4;
    int v32 = &v18;
    int v16 = 0;
    int v17 = 0;
    int v14 = 0;
    int v15 = 0;
    sub_2167C7350((char *)&__dst, &v12, (uint64_t)v35, 0, v11, 1, &v31, &v16, &v14);
    sub_2167C5310((uint64_t)(a1 + 46), &__dst);
    Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v30);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v28);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)v24);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)__dst);
    }
    if (v19) {
      sub_216784EC4(v19);
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(*(void **)v35);
    }
    unint64_t v7 = v13;
    if (v13) {
      goto LABEL_24;
    }
  }
  if (a1[44])
  {
    unint64_t v8 = 0;
    do
    {
      sub_2167C3654((uint64_t)(a1 + 46), (uint64_t)&v38);
      ++v8;
    }
    while (v8 < a1[44]);
  }
  if (v41)
  {
    uint64_t v42 = v41;
    operator delete(v41);
  }
  if ((void)v39)
  {
    *((void *)&v39 + 1) = v39;
    operator delete((void *)v39);
  }
  if (v45)
  {
    int v46 = v45;
    operator delete(v45);
  }
  if (v48)
  {
    uint64_t v49 = v48;
    operator delete(v48);
  }
}

void sub_2167C21BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *__p,uint64_t a45)
{
  sub_2167C5410((uint64_t)&a20);
  if (a17) {
    sub_216784EC4(a17);
  }
  if (*(char *)(v45 - 217) < 0) {
    operator delete(*(void **)(v45 - 240));
  }
  if (a11) {
    sub_216784EC4(a11);
  }
  sub_2167C5204((void *)(v45 - 200));
  uint64_t v47 = *(void **)(v45 - 112);
  if (v47)
  {
    *(void *)(v45 - 104) = v47;
    operator delete(v47);
  }
  uint64_t v48 = *(void **)(v45 - 88);
  if (v48)
  {
    *(void *)(v45 - 80) = v48;
    operator delete(v48);
  }
  _Unwind_Resume(a1);
}

void Alembic::AbcGeom::v12::OCurvesSchema::createNormalsProperty(void *a1, uint64_t a2)
{
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  *(void *)&long long v40 = 0;
  *((void *)&v40 + 1) = 0x30000000ALL;
  long long v41 = 0u;
  *(_OWORD *)uint64_t v42 = 0u;
  *(void *)&v42[16] = 0x100000005;
  uint64_t v43 = 0;
  int v44 = 0;
  uint64_t v45 = 0;
  int v46 = 127;
  if (*(_DWORD *)(a2 + 352) == 127 || !*(void *)(a2 + 344) && *(void *)(a2 + 368) == *(void *)(a2 + 360)) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = nullsub_21;
  }
  if (v4)
  {
    sub_2167C6418(&v33, (uint64_t *)&v50);
    sub_2167C8B1C(v37, &v33);
    sub_2167C71F8(&v29, (uint64_t *)&v47);
    sub_2167C8C94((uint64_t)&__dst, (uint64_t *)v37, &v29, *(_DWORD *)(a2 + 384));
    *(void *)&long long v40 = __dst;
    *(void *)((char *)&v40 + 5) = *(void *)((char *)&__dst + 5);
    sub_21677CC7C((char *)&v41, (char *)v21, v22[0], (v22[0] - (uint64_t)v21) >> 3);
    *(void *)&v42[8] = v23;
    *(void *)&v42[13] = *(void *)((char *)&v23 + 5);
    sub_21677CC7C((char *)&v43, (char *)__p, (uint64_t)v25, (v25 - (unsigned char *)__p) >> 3);
    int v46 = v27;
    if (__p)
    {
      long long v25 = __p;
      operator delete(__p);
    }
    if (v21)
    {
      v22[0] = (uint64_t)v21;
      operator delete(v21);
    }
    if (v31)
    {
      int v32 = v31;
      operator delete(v31);
    }
    if (v38)
    {
      long long v39 = v38;
      operator delete(v38);
    }
    if (v35)
    {
      uint64_t v36 = v35;
      operator delete(v35);
    }
    uint64_t v5 = (std::__shared_weak_count *)a1[6];
    uint64_t v18 = a1[5];
    uint64_t v19 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(v37, "N");
    int v6 = v46;
    sub_2167C5248((uint64_t)a1, &v29);
    LODWORD(v33) = 4;
    int v34 = &v29;
    int v16 = 0;
    int v17 = 0;
    int v14 = 0;
    int v15 = 0;
    sub_2167C8D48((char *)&__dst, &v18, (uint64_t)v37, 1, v6, 1, &v33, &v16, &v14);
    sub_2167C5310((uint64_t)(a1 + 68), &__dst);
    Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v28);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v26);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)v22);
    if (SHIBYTE(v21) < 0) {
      operator delete((void *)__dst);
    }
    if (v30) {
      sub_216784EC4(v30);
    }
    if (SHIBYTE(v38) < 0) {
      operator delete(*(void **)v37);
    }
    unint64_t v7 = v19;
    if (v19) {
LABEL_26:
    }
      sub_216784EC4(v7);
  }
  else
  {
    sub_2167C6418(&v33, (uint64_t *)&v50);
    sub_2167C8B1C(v37, &v33);
    int v9 = *(_DWORD *)(a2 + 384);
    *(void *)&long long __dst = *(void *)v37;
    *(void *)((char *)&__dst + 5) = *(void *)&v37[5];
    uint64_t v21 = 0;
    v22[0] = 0;
    v22[1] = 0;
    sub_21677EA60(&v21, v38, (uint64_t)v39, (v39 - v38) >> 3);
    *(void *)&long long v23 = 0;
    *((void *)&v23 + 1) = 0x100000005;
    long long v25 = 0;
    uint64_t v26 = 0;
    long long __p = 0;
    int v27 = v9;
    *(void *)&long long v40 = __dst;
    *(void *)((char *)&v40 + 5) = *(void *)((char *)&__dst + 5);
    sub_21677CC7C((char *)&v41, (char *)v21, v22[0], (v22[0] - (uint64_t)v21) >> 3);
    *(void *)&v42[8] = v23;
    *(void *)&v42[13] = *(void *)((char *)&v23 + 5);
    sub_21677CC7C((char *)&v43, (char *)__p, (uint64_t)v25, (v25 - (unsigned char *)__p) >> 3);
    int v46 = v27;
    if (__p)
    {
      long long v25 = __p;
      operator delete(__p);
    }
    if (v21)
    {
      v22[0] = (uint64_t)v21;
      operator delete(v21);
    }
    if (v38)
    {
      long long v39 = v38;
      operator delete(v38);
    }
    if (v35)
    {
      uint64_t v36 = v35;
      operator delete(v35);
    }
    int v10 = (std::__shared_weak_count *)a1[6];
    uint64_t v12 = a1[5];
    uint64_t v13 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(v37, "N");
    int v11 = v46;
    sub_2167C5248((uint64_t)a1, &v29);
    LODWORD(v33) = 4;
    int v34 = &v29;
    int v16 = 0;
    int v17 = 0;
    int v14 = 0;
    int v15 = 0;
    sub_2167C8D48((char *)&__dst, &v12, (uint64_t)v37, 0, v11, 1, &v33, &v16, &v14);
    sub_2167C5310((uint64_t)(a1 + 68), &__dst);
    Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v28);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v26);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)v22);
    if (SHIBYTE(v21) < 0) {
      operator delete((void *)__dst);
    }
    if (v30) {
      sub_216784EC4(v30);
    }
    if (SHIBYTE(v38) < 0) {
      operator delete(*(void **)v37);
    }
    unint64_t v7 = v13;
    if (v13) {
      goto LABEL_26;
    }
  }
  if (a1[44])
  {
    unint64_t v8 = 0;
    do
    {
      sub_2167C3A2C((uint64_t)(a1 + 68), (uint64_t)&v40);
      ++v8;
    }
    while (v8 < a1[44]);
  }
  if (v43)
  {
    int v44 = v43;
    operator delete(v43);
  }
  if ((void)v41)
  {
    *((void *)&v41 + 1) = v41;
    operator delete((void *)v41);
  }
  if (v47)
  {
    uint64_t v48 = v47;
    operator delete(v47);
  }
  if (v50)
  {
    uint64_t v51 = v50;
    operator delete(v50);
  }
}

void sub_2167C27C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,std::__shared_weak_count *a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *__p,uint64_t a49)
{
  sub_2167C5410((uint64_t)&a19);
  if (a42) {
    sub_216784EC4(a42);
  }
  if (*(char *)(v49 - 217) < 0) {
    operator delete(*(void **)(v49 - 240));
  }
  if (a12) {
    sub_216784EC4(a12);
  }
  sub_2167C5204((void *)(v49 - 200));
  uint64_t v51 = *(void **)(v49 - 112);
  if (v51)
  {
    *(void *)(v49 - 104) = v51;
    operator delete(v51);
  }
  uint64_t v52 = *(void **)(v49 - 88);
  if (v52)
  {
    *(void *)(v49 - 80) = v52;
    operator delete(v52);
  }
  _Unwind_Resume(a1);
}

void Alembic::AbcGeom::v12::OCurvesSchema::createWidthProperty(void *a1, uint64_t a2)
{
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v45 = 0;
  int v46 = 0;
  uint64_t v47 = 0;
  *(void *)&long long v38 = 0;
  *((void *)&v38 + 1) = 0x10000000ALL;
  long long v39 = 0u;
  *(_OWORD *)long long v40 = 0u;
  *(void *)&v40[16] = 0x100000005;
  long long v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  int v44 = 127;
  if (*(_DWORD *)(a2 + 176) == 127 || !*(void *)(a2 + 168) && *(void *)(a2 + 192) == *(void *)(a2 + 184)) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = nullsub_21;
  }
  if (v4)
  {
    sub_2167CA034(v35, (uint64_t *)&v48);
    sub_2167C71F8(&v31, (uint64_t *)&v45);
    sub_2167CA0D8((uint64_t)&__dst, (uint64_t *)v35, &v31, *(_DWORD *)(a2 + 208));
    *(void *)&long long v38 = __dst;
    *(void *)((char *)&v38 + 5) = *(void *)((char *)&__dst + 5);
    sub_21677CC7C((char *)&v39, (char *)v23, v24[0], (v24[0] - (uint64_t)v23) >> 3);
    *(void *)&v40[8] = v25;
    *(void *)&v40[13] = *(void *)((char *)&v25 + 5);
    sub_21677CC7C((char *)&v41, (char *)__p, (uint64_t)v27, (v27 - (unsigned char *)__p) >> 3);
    int v44 = v29;
    if (__p)
    {
      int v27 = __p;
      operator delete(__p);
    }
    if (v23)
    {
      v24[0] = (uint64_t)v23;
      operator delete(v23);
    }
    if (v33)
    {
      int v34 = v33;
      operator delete(v33);
    }
    if (v36)
    {
      uint64_t v37 = v36;
      operator delete(v36);
    }
    uint64_t v5 = (std::__shared_weak_count *)a1[6];
    uint64_t v20 = a1[5];
    uint64_t v21 = v5;
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(v35, "width");
    int v6 = *(_DWORD *)(a2 + 208);
    sub_2167C5248((uint64_t)a1, &v18);
    LODWORD(v31) = 4;
    int v32 = &v18;
    int v16 = 0;
    int v17 = 0;
    int v14 = 0;
    int v15 = 0;
    sub_2167CA18C((char *)&__dst, &v20, (uint64_t)v35, 1, v6, 1, &v31, &v16, &v14);
    sub_2167C5310((uint64_t)(a1 + 90), &__dst);
    Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v30);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v28);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)v24);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)__dst);
    }
    if (v19) {
      sub_216784EC4(v19);
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(*(void **)v35);
    }
    unint64_t v7 = v21;
    if (v21) {
LABEL_24:
    }
      sub_216784EC4(v7);
  }
  else
  {
    sub_2167CA034(v35, (uint64_t *)&v48);
    int v9 = *(_DWORD *)(a2 + 208);
    *(void *)&long long __dst = *(void *)v35;
    *(void *)((char *)&__dst + 5) = *(void *)&v35[5];
    long long v23 = 0;
    v24[0] = 0;
    v24[1] = 0;
    sub_21677EA60(&v23, v36, (uint64_t)v37, (v37 - v36) >> 3);
    *(void *)&long long v25 = 0;
    *((void *)&v25 + 1) = 0x100000005;
    int v27 = 0;
    uint64_t v28 = 0;
    long long __p = 0;
    int v29 = v9;
    *(void *)&long long v38 = __dst;
    *(void *)((char *)&v38 + 5) = *(void *)((char *)&__dst + 5);
    sub_21677CC7C((char *)&v39, (char *)v23, v24[0], (v24[0] - (uint64_t)v23) >> 3);
    *(void *)&v40[8] = v25;
    *(void *)&v40[13] = *(void *)((char *)&v25 + 5);
    sub_21677CC7C((char *)&v41, (char *)__p, (uint64_t)v27, (v27 - (unsigned char *)__p) >> 3);
    int v44 = v29;
    if (__p)
    {
      int v27 = __p;
      operator delete(__p);
    }
    if (v23)
    {
      v24[0] = (uint64_t)v23;
      operator delete(v23);
    }
    if (v36)
    {
      uint64_t v37 = v36;
      operator delete(v36);
    }
    int v10 = (std::__shared_weak_count *)a1[6];
    uint64_t v12 = a1[5];
    uint64_t v13 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_216779094(v35, "width");
    int v11 = *(_DWORD *)(a2 + 208);
    sub_2167C5248((uint64_t)a1, &v18);
    LODWORD(v31) = 4;
    int v32 = &v18;
    int v16 = 0;
    int v17 = 0;
    int v14 = 0;
    int v15 = 0;
    sub_2167CA18C((char *)&__dst, &v12, (uint64_t)v35, 0, v11, 1, &v31, &v16, &v14);
    sub_2167C5310((uint64_t)(a1 + 90), &__dst);
    Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)v30);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v28);
    Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)v24);
    if (SHIBYTE(v23) < 0) {
      operator delete((void *)__dst);
    }
    if (v19) {
      sub_216784EC4(v19);
    }
    if (SHIBYTE(v36) < 0) {
      operator delete(*(void **)v35);
    }
    unint64_t v7 = v13;
    if (v13) {
      goto LABEL_24;
    }
  }
  if (a1[44])
  {
    unint64_t v8 = 0;
    do
    {
      sub_2167C3E04((uint64_t)(a1 + 90), (uint64_t)&v38);
      ++v8;
    }
    while (v8 < a1[44]);
  }
  if (v41)
  {
    uint64_t v42 = v41;
    operator delete(v41);
  }
  if ((void)v39)
  {
    *((void *)&v39 + 1) = v39;
    operator delete((void *)v39);
  }
  if (v45)
  {
    int v46 = v45;
    operator delete(v45);
  }
  if (v48)
  {
    uint64_t v49 = v48;
    operator delete(v48);
  }
}

void sub_2167C2DB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *__p,uint64_t a45)
{
  sub_2167C5410((uint64_t)&a20);
  if (a17) {
    sub_216784EC4(a17);
  }
  if (*(char *)(v45 - 233) < 0) {
    operator delete(*(void **)(v45 - 256));
  }
  if (a11) {
    sub_216784EC4(a11);
  }
  sub_2167C5204((void *)(v45 - 216));
  uint64_t v47 = *(void **)(v45 - 128);
  if (v47)
  {
    *(void *)(v45 - 120) = v47;
    operator delete(v47);
  }
  uint64_t v48 = *(void **)(v45 - 104);
  if (v48)
  {
    *(void *)(v45 - 96) = v48;
    operator delete(v48);
  }
  _Unwind_Resume(a1);
}

void Alembic::AbcGeom::v12::OCurvesSchema::createPositionWeightsProperty(Alembic::AbcGeom::v12::OCurvesSchema *this)
{
  int v16 = *((_DWORD *)this + 2);
  if (*((char *)this + 39) < 0)
  {
    sub_216778F24(&v17, *((void **)this + 2), *((void *)this + 3));
  }
  else
  {
    long long v17 = *((_OWORD *)this + 1);
    uint64_t v18 = *((void *)this + 4);
  }
  uint64_t v2 = *((void *)this + 6);
  uint64_t v19 = *((void *)this + 5);
  uint64_t v20 = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_216779094(&__p, "w");
  sub_2167C5248((uint64_t)this, &v9);
  int v11 = 4;
  uint64_t v12 = &v9;
  v8[0] = 0;
  v8[2] = 0;
  v7[0] = 0;
  v7[2] = 0;
  sub_2167CB2E8((uint64_t)&v21, &v16, (uint64_t)&__p, &v11, v8, v7);
  *((_DWORD *)this + 236) = v21;
  std::string::operator=((std::string *)((char *)this + 952), &v22);
  uint64_t v4 = v23;
  uint64_t v3 = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 122) = v4;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 123);
  *((void *)this + 123) = v3;
  if (v5) {
    sub_216784EC4(v5);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v21);
  if (v10) {
    sub_216784EC4(v10);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)&v16);
  long long __p = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  sub_2167CA034(&v21, (uint64_t *)&__p);
  if (*((void *)this + 44))
  {
    unint64_t v6 = 0;
    do
    {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 944);
      ++v6;
    }
    while (v6 < *((void *)this + 44));
  }
  if (v22.__r_.__value_.__l.__size_)
  {
    v22.__r_.__value_.__r.__words[2] = v22.__r_.__value_.__l.__size_;
    operator delete((void *)v22.__r_.__value_.__l.__size_);
  }
  if (__p)
  {
    int v14 = __p;
    operator delete(__p);
  }
}

void sub_2167C3084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::AbcGeom::v12::OCurvesSchema::createOrdersProperty(Alembic::AbcGeom::v12::OCurvesSchema *this)
{
  int v16 = *((_DWORD *)this + 2);
  if (*((char *)this + 39) < 0)
  {
    sub_216778F24(&v17, *((void **)this + 2), *((void *)this + 3));
  }
  else
  {
    long long v17 = *((_OWORD *)this + 1);
    uint64_t v18 = *((void *)this + 4);
  }
  uint64_t v2 = *((void *)this + 6);
  uint64_t v19 = *((void *)this + 5);
  uint64_t v20 = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_216779094(&__p, ".orders");
  sub_2167C5248((uint64_t)this, &v9);
  int v11 = 4;
  uint64_t v12 = &v9;
  v8[0] = 0;
  v8[2] = 0;
  v7[0] = 0;
  v7[2] = 0;
  sub_2167CB3C4((uint64_t)&v21, &v16, (uint64_t)&__p, &v11, v8, v7);
  *((_DWORD *)this + 248) = v21;
  std::string::operator=((std::string *)((char *)this + 1000), &v22);
  uint64_t v4 = v23;
  uint64_t v3 = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 128) = v4;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 129);
  *((void *)this + 129) = v3;
  if (v5) {
    sub_216784EC4(v5);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v21);
  if (v10) {
    sub_216784EC4(v10);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)&v16);
  long long __p = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  sub_2167CB8A0(&v21, (uint64_t *)&__p);
  if (*((void *)this + 44))
  {
    unint64_t v6 = 0;
    do
    {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 992);
      ++v6;
    }
    while (v6 < *((void *)this + 44));
  }
  if (v22.__r_.__value_.__l.__size_)
  {
    v22.__r_.__value_.__r.__words[2] = v22.__r_.__value_.__l.__size_;
    operator delete((void *)v22.__r_.__value_.__l.__size_);
  }
  if (__p)
  {
    int v14 = __p;
    operator delete(__p);
  }
}

void sub_2167C32A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Alembic::AbcGeom::v12::OCurvesSchema::createKnotsProperty(Alembic::AbcGeom::v12::OCurvesSchema *this)
{
  int v16 = *((_DWORD *)this + 2);
  if (*((char *)this + 39) < 0)
  {
    sub_216778F24(&v17, *((void **)this + 2), *((void *)this + 3));
  }
  else
  {
    long long v17 = *((_OWORD *)this + 1);
    uint64_t v18 = *((void *)this + 4);
  }
  uint64_t v2 = *((void *)this + 6);
  uint64_t v19 = *((void *)this + 5);
  uint64_t v20 = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  sub_216779094(&__p, ".knots");
  sub_2167C5248((uint64_t)this, &v9);
  int v11 = 4;
  uint64_t v12 = &v9;
  v8[0] = 0;
  v8[2] = 0;
  v7[0] = 0;
  v7[2] = 0;
  sub_2167CB2E8((uint64_t)&v21, &v16, (uint64_t)&__p, &v11, v8, v7);
  *((_DWORD *)this + 260) = v21;
  std::string::operator=((std::string *)((char *)this + 1048), &v22);
  uint64_t v4 = v23;
  uint64_t v3 = v24;
  if (v24) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
  }
  *((void *)this + 134) = v4;
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 135);
  *((void *)this + 135) = v3;
  if (v5) {
    sub_216784EC4(v5);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v21);
  if (v10) {
    sub_216784EC4(v10);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(__p);
  }
  Alembic::Abc::v12::OCompoundProperty::~OCompoundProperty((Alembic::Abc::v12::OCompoundProperty *)&v16);
  long long __p = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  sub_2167CA034(&v21, (uint64_t *)&__p);
  if (*((void *)this + 44))
  {
    unint64_t v6 = 0;
    do
    {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)this + 1040);
      ++v6;
    }
    while (v6 < *((void *)this + 44));
  }
  if (v22.__r_.__value_.__l.__size_)
  {
    v22.__r_.__value_.__r.__words[2] = v22.__r_.__value_.__l.__size_;
    operator delete((void *)v22.__r_.__value_.__l.__size_);
  }
  if (__p)
  {
    int v14 = __p;
    operator delete(__p);
  }
}

void sub_2167C34CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_2167C354C@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  *(int64x2_t *)a2 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(_OWORD *)(a2 + 16) = xmmword_217409FA0;
  *(int64x2_t *)(a2 + 32) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  uint64_t v2 = (uint64_t *)result[2];
  uint64_t v3 = result[3] - (void)v2;
  if (v3)
  {
    unint64_t v4 = v3 >> 3;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    uint64_t v5 = 1;
    do
    {
      uint64_t v6 = v5;
      uint64_t v8 = *v2++;
      uint64_t v7 = v8;
      v5 *= v8;
      --v4;
    }
    while (v4);
    if (v5)
    {
      uint64_t v9 = v6 * v7;
      int v10 = (float *)(*result + 8);
      double v11 = -1.79769313e308;
      double v12 = 1.79769313e308;
      double v13 = 1.79769313e308;
      double v14 = 1.79769313e308;
      double v15 = -1.79769313e308;
      double v16 = -1.79769313e308;
      do
      {
        double v17 = *(v10 - 2);
        if (v14 > v17)
        {
          *(double *)a2 = v17;
          double v14 = v17;
        }
        if (v11 < v17)
        {
          *(double *)(a2 + 24) = v17;
          double v11 = v17;
        }
        double v18 = *(v10 - 1);
        if (v13 > v18)
        {
          *(double *)(a2 + 8) = v18;
          double v13 = v18;
        }
        if (v15 < v18)
        {
          *(double *)(a2 + 32) = v18;
          double v15 = v18;
        }
        double v19 = *v10;
        if (v12 > v19)
        {
          *(double *)(a2 + 16) = v19;
          double v12 = v19;
        }
        if (v16 < v19)
        {
          *(double *)(a2 + 40) = v19;
          double v16 = v19;
        }
        v10 += 3;
        --v9;
      }
      while (v9);
    }
  }
  return result;
}

void sub_2167C3654(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 24;
  uint64_t v30 = a1 + 24;
  uint64_t v31 = "OTypedGeomParam::set()";
  if (!Alembic::Abc::v12::OArrayProperty::getNumSamples((Alembic::Abc::v12::OArrayProperty *)(a1 + 24)))
  {
    Alembic::Abc::v12::OArrayProperty::set(v4);
    if (*(unsigned char *)(a1 + 120)) {
      Alembic::Abc::v12::OArrayProperty::set(a1 + 72);
    }
    return;
  }
  int v25 = *(_DWORD *)(a1 + 24);
  if (*(char *)(a1 + 55) < 0)
  {
    sub_216778F24(&v26, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }
  else
  {
    long long v26 = *(_OWORD *)(a1 + 32);
    uint64_t v27 = *(void *)(a1 + 48);
  }
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v28 = *(void *)(a1 + 56);
  uint64_t v29 = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(void *)(a2 + 5);
  *(void *)uint64_t v21 = *(void *)a2;
  *(void *)&v21[5] = v6;
  long long __p = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  sub_21677EA60(&__p, *(const void **)(a2 + 16), *(void *)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
  if (SHIBYTE(v27) < 0)
  {
    if (*((void *)&v26 + 1)) {
      goto LABEL_11;
    }
  }
  else if (HIBYTE(v27))
  {
LABEL_11:
    uint64_t v7 = 0;
    goto LABEL_16;
  }
  if (v28) {
    uint64_t v7 = nullsub_7;
  }
  else {
    uint64_t v7 = 0;
  }
LABEL_16:
  if (v7)
  {
    if (*(_DWORD *)&v21[8] == 127 || !*(void *)v21 && v23 == __p) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = nullsub_8;
    }
    if (v8) {
      Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v25);
    }
    else {
      Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v25);
    }
  }
  if (__p)
  {
    uint64_t v23 = __p;
    operator delete(__p);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v25);
  if (*(unsigned char *)(a1 + 120))
  {
    int v16 = *(_DWORD *)(a1 + 72);
    if (*(char *)(a1 + 103) < 0)
    {
      sub_216778F24(&v17, *(void **)(a1 + 80), *(void *)(a1 + 88));
    }
    else
    {
      long long v17 = *(_OWORD *)(a1 + 80);
      uint64_t v18 = *(void *)(a1 + 96);
    }
    uint64_t v9 = *(void *)(a1 + 112);
    uint64_t v19 = *(void *)(a1 + 104);
    uint64_t v20 = v9;
    if (v9) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)double v12 = *(void *)(a2 + 40);
    *(void *)&v12[5] = *(void *)(a2 + 45);
    double v13 = 0;
    double v14 = 0;
    uint64_t v15 = 0;
    sub_21677EA60(&v13, *(const void **)(a2 + 56), *(void *)(a2 + 64), (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 3);
    if (SHIBYTE(v18) < 0)
    {
      if (*((void *)&v17 + 1)) {
        goto LABEL_35;
      }
    }
    else if (HIBYTE(v18))
    {
LABEL_35:
      int v10 = 0;
LABEL_40:
      if (v10)
      {
        if (*(_DWORD *)&v12[8] == 127 || !*(void *)v12 && v14 == v13) {
          double v11 = 0;
        }
        else {
          double v11 = nullsub_21;
        }
        if (v11) {
          Alembic::Abc::v12::OArrayProperty::set((uint64_t)&v16);
        }
        else {
          Alembic::Abc::v12::OArrayProperty::setFromPrevious((Alembic::Abc::v12::OArrayProperty *)&v16);
        }
      }
      if (v13)
      {
        double v14 = v13;
        operator delete(v13);
      }
      Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&v16);
      return;
    }
    if (v19) {
      int v10 = nullsub_7;
    }
    else {
      int v10 = 0;
    }
    goto LABEL_40;
  }
}

void sub_2167C3960(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  Alembic::Abc::v12::OArrayProperty::~OArrayProperty((Alembic::Abc::v12::OArrayProperty *)&a14);
  uint64_t v27 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    uint64_t v28 = (uint64_t)v27;
    sub_2167C5E20(v23);
    sub_21679FA64(v24 - 48, v28);
  }
  else
  {
    sub_2167C5E20(v23);
    sub_21679F9F4(v24 - 48, 0);
  }
  __cxa_end_catch();
  JUMPOUT(0x2167C394CLL);
}

void sub_2167C3A0C(_Unwind_Exception *a1)
{
}