uint64_t llvm::mca::InOrderIssueStage::notifyInstructionDispatched(uint64_t result, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;

  v10 = 6;
  v11 = a2;
  v12 = a4;
  v13 = a5;
  v14 = a3;
  v5 = *(void **)(result + 16);
  v6 = (void *)(result + 24);
  if (v5 != (void *)(result + 24))
  {
    do
    {
      result = (*(uint64_t (**)(void, int *))(*(void *)v5[4] + 24))(v5[4], &v10);
      v7 = (void *)v5[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (void *)v5[2];
          v9 = *v8 == (void)v5;
          v5 = v8;
        }
        while (!v9);
      }
      v5 = v8;
    }
    while (v8 != v6);
  }
  return result;
}

uint64_t llvm::mca::InOrderIssueStage::notifyInstructionExecuted(uint64_t result, uint64_t a2)
{
  int v7 = 5;
  uint64_t v8 = a2;
  v2 = *(void **)(result + 16);
  v3 = (void *)(result + 24);
  if (v2 != (void *)(result + 24))
  {
    do
    {
      result = (*(uint64_t (**)(void, int *))(*(void *)v2[4] + 24))(v2[4], &v7);
      v4 = (void *)v2[1];
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = (void *)*v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (void *)v2[2];
          BOOL v6 = *v5 == (void)v2;
          v2 = v5;
        }
        while (!v6);
      }
      v2 = v5;
    }
    while (v5 != v3);
  }
  return result;
}

uint64_t llvm::mca::InOrderIssueStage::notifyInstructionRetired(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v9 = 1;
  uint64_t v10 = a2;
  uint64_t v11 = a3;
  uint64_t v12 = a4;
  v4 = *(void **)(result + 16);
  v5 = (void *)(result + 24);
  if (v4 != (void *)(result + 24))
  {
    do
    {
      result = (*(uint64_t (**)(void, int *))(*(void *)v4[4] + 24))(v4[4], &v9);
      BOOL v6 = (void *)v4[1];
      if (v6)
      {
        do
        {
          int v7 = v6;
          BOOL v6 = (void *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          int v7 = (void *)v4[2];
          BOOL v8 = *v7 == (void)v4;
          v4 = v7;
        }
        while (!v8);
      }
      v4 = v7;
    }
    while (v7 != v5);
  }
  return result;
}

void llvm::mca::InOrderIssueStage::execute(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 8);
  if ((*(unsigned char *)(v6 + 540) & 0xC) != 0) {
    *(_DWORD *)(v6 + 556) = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 416) + 24))(*(void *)(a1 + 416), a2);
  }
  llvm::mca::InOrderIssueStage::tryIssue(a1, a2, a3);
  if (!*a3)
  {
    if (*(void *)(a1 + 520)) {
      llvm::mca::InOrderIssueStage::notifyStallEvent(a1);
    }
    *a3 = 0;
  }
}

void llvm::mca::InOrderIssueStage::tryIssue(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  v39[2] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a2 + 8);
  unsigned int v7 = *(_DWORD *)a2;
  uint64_t v8 = *(void *)v6;
  if (llvm::mca::InOrderIssueStage::canExecute(a1, a2))
  {
    *(_DWORD *)(v6 + 544) = 1;
    *(_DWORD *)(v6 + 552) = -1;
    if (llvm::mca::Instruction::updateDispatched((llvm::mca::Instruction *)v6)) {
      llvm::mca::Instruction::updatePending((llvm::mca::Instruction *)v6);
    }
    int v9 = *(unsigned int **)(a1 + 48);
    uint64_t v10 = v9[6];
    v36 = v39;
    int v38 = 4;
    if (v10 >= 5)
    {
      unsigned int v37 = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    if (v10) {
      bzero(v39, 4 * v10);
    }
    unsigned int v37 = v10;
    uint64_t v11 = *(unsigned int *)(v6 + 312);
    if (v11)
    {
      uint64_t v12 = *(const llvm::MCSubtargetInfo **)(a1 + 40);
      v13 = *(llvm::mca::ReadState **)(v6 + 304);
      uint64_t v14 = 48 * v11;
      do
      {
        llvm::mca::RegisterFile::addRegisterRead((llvm::mca::RegisterFile *)v9, v13, v12);
        v13 = (llvm::mca::ReadState *)((char *)v13 + 48);
        v14 -= 48;
      }
      while (v14);
    }
    uint64_t v15 = *(unsigned int *)(v6 + 24);
    if (v15)
    {
      uint64_t v16 = *(void *)(v6 + 16);
      uint64_t v17 = 136 * v15;
      do
      {
        DWORD2(v34) = 0;
        *(void *)&long long v34 = v7;
        WORD6(v34) = 0;
        v35[0] = v16;
        llvm::mca::RegisterFile::addRegisterWrite((uint64_t *)v9, &v34, v36);
        v16 += 136;
        v17 -= 136;
      }
      while (v17);
    }
    unsigned int v18 = *(_DWORD *)(*(void *)v6 + 284);
    llvm::mca::InOrderIssueStage::notifyInstructionDispatched(a1, a2, v18, (uint64_t)v36, v37);
    *(void *)&long long v34 = v35;
    *((void *)&v34 + 1) = 0x400000000;
    llvm::mca::ResourceManager::issueInstruction(a1 + 56, v8, (uint64_t)&v34);
    llvm::mca::Instruction::execute(v6, v7);
    if ((*(unsigned char *)(v6 + 540) & 0xC) != 0) {
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 416) + 48))(*(void *)(a1 + 416), a2);
    }
    uint64_t v19 = v34;
    uint64_t v20 = DWORD2(v34);
    if (DWORD2(v34))
    {
      uint64_t v21 = *(void *)(a1 + 216);
      uint64_t v22 = 24 * DWORD2(v34);
      v23 = (unint64_t *)v34;
      do
      {
        unint64_t *v23 = *(unsigned int *)(v21 + 4 * (63 - __clz(*v23)));
        v23 += 3;
        v22 -= 24;
      }
      while (v22);
    }
    llvm::mca::InOrderIssueStage::notifyInstructionIssued(a1, a2, v19, v20);
    unsigned int v24 = *(_DWORD *)(a1 + 556);
    int v25 = v18 - v24;
    if (v18 <= v24)
    {
      *(_DWORD *)(a1 + 504) += v18;
      int v26 = v24 - v18;
      if ((*(unsigned char *)(v6 + 540) & 0x40) != 0) {
        int v26 = 0;
      }
    }
    else
    {
      int v26 = 0;
      *(_DWORD *)(a1 + 552) = v25;
      *(_DWORD *)(a1 + 536) = *(_DWORD *)a2;
      *(void *)(a1 + 544) = *(void *)(a2 + 8);
    }
    *(_DWORD *)(a1 + 556) = v26;
    if (*(_DWORD *)(v6 + 544) == 5)
    {
      llvm::mca::RegisterFile::onInstructionExecuted(*(void *)(a1 + 48), v6);
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 416) + 32))(*(void *)(a1 + 416), a2);
      int v32 = 5;
      uint64_t v33 = a2;
      v27 = *(void **)(a1 + 16);
      if (v27 != (void *)(a1 + 24))
      {
        do
        {
          (*(void (**)(void, int *))(*(void *)v27[4] + 24))(v27[4], &v32);
          v28 = (void *)v27[1];
          if (v28)
          {
            do
            {
              v29 = v28;
              v28 = (void *)*v28;
            }
            while (v28);
          }
          else
          {
            do
            {
              v29 = (void *)v27[2];
              BOOL v30 = *v29 == (void)v27;
              v27 = v29;
            }
            while (!v30);
          }
          v27 = v29;
        }
        while (v29 != (void *)(a1 + 24));
      }
      llvm::mca::InOrderIssueStage::retireInstruction(a1, a2);
    }
    else
    {
      unsigned int v31 = *(_DWORD *)(a1 + 432);
      if (v31 >= *(_DWORD *)(a1 + 436)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_OWORD *)(*(void *)(a1 + 424) + 16 * v31) = *(_OWORD *)a2;
      ++*(_DWORD *)(a1 + 432);
      if ((*(char *)(*(void *)(a2 + 8) + 540) & 0x80000000) == 0) {
        *(_DWORD *)(a1 + 560) = *(_DWORD *)(v6 + 548);
      }
    }
    *a3 = 0;
    if ((void *)v34 != v35) {
      free((void *)v34);
    }
    if (v36 != v39) {
      free(v36);
    }
  }
  else
  {
    *(_DWORD *)(a1 + 556) = 0;
    *a3 = 0;
  }
}

uint64_t llvm::mca::InOrderIssueStage::notifyStallEvent(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = this + 512;
  int v3 = *(_DWORD *)(this + 532);
  switch(v3)
  {
    case 5:
      int v23 = 7;
      uint64_t v24 = this + 512;
      uint64_t v12 = *(void **)(this + 16);
      v13 = (void *)(this + 24);
      if (v12 != (void *)(this + 24))
      {
        do
        {
          this = (*(uint64_t (**)(void, int *))(*(void *)v12[4] + 32))(v12[4], &v23);
          uint64_t v14 = (void *)v12[1];
          if (v14)
          {
            do
            {
              uint64_t v15 = v14;
              uint64_t v14 = (void *)*v14;
            }
            while (v14);
          }
          else
          {
            do
            {
              uint64_t v15 = (void *)v12[2];
              BOOL v8 = *v15 == (void)v12;
              uint64_t v12 = v15;
            }
            while (!v8);
          }
          uint64_t v12 = v15;
        }
        while (v15 != v13);
      }
      break;
    case 2:
      int v23 = 3;
      uint64_t v24 = this + 512;
      uint64_t v16 = *(void **)(this + 16);
      uint64_t v17 = (void *)(this + 24);
      if (v16 != (void *)(this + 24))
      {
        do
        {
          this = (*(uint64_t (**)(void, int *))(*(void *)v16[4] + 32))(v16[4], &v23);
          unsigned int v18 = (void *)v16[1];
          if (v18)
          {
            do
            {
              uint64_t v19 = v18;
              unsigned int v18 = (void *)*v18;
            }
            while (v18);
          }
          else
          {
            do
            {
              uint64_t v19 = (void *)v16[2];
              BOOL v8 = *v19 == (void)v16;
              uint64_t v16 = v19;
            }
            while (!v8);
          }
          uint64_t v16 = v19;
        }
        while (v19 != v17);
        uint64_t v20 = *(void **)(v1 + 16);
        int v23 = 1;
        uint64_t v24 = v2;
        long long v25 = xmmword_1CD91D2E0;
        if (v20 != v17)
        {
          do
          {
            this = (*(uint64_t (**)(void, int *))(*(void *)v20[4] + 40))(v20[4], &v23);
            uint64_t v21 = (void *)v20[1];
            if (v21)
            {
              do
              {
                uint64_t v22 = v21;
                uint64_t v21 = (void *)*v21;
              }
              while (v21);
            }
            else
            {
              do
              {
                uint64_t v22 = (void *)v20[2];
                BOOL v8 = *v22 == (void)v20;
                uint64_t v20 = v22;
              }
              while (!v8);
            }
            uint64_t v20 = v22;
          }
          while (v22 != v17);
        }
      }
      break;
    case 1:
      int v23 = 1;
      uint64_t v24 = this + 512;
      v4 = *(void **)(this + 16);
      v5 = (void *)(this + 24);
      if (v4 != (void *)(this + 24))
      {
        do
        {
          this = (*(uint64_t (**)(void, int *))(*(void *)v4[4] + 32))(v4[4], &v23);
          uint64_t v6 = (void *)v4[1];
          if (v6)
          {
            do
            {
              unsigned int v7 = v6;
              uint64_t v6 = (void *)*v6;
            }
            while (v6);
          }
          else
          {
            do
            {
              unsigned int v7 = (void *)v4[2];
              BOOL v8 = *v7 == (void)v4;
              v4 = v7;
            }
            while (!v8);
          }
          v4 = v7;
        }
        while (v7 != v5);
        int v9 = *(void **)(v1 + 16);
        int v23 = 2;
        uint64_t v24 = v2;
        long long v25 = xmmword_1CD91D2E0;
        if (v9 != v5)
        {
          do
          {
            this = (*(uint64_t (**)(void, int *))(*(void *)v9[4] + 40))(v9[4], &v23);
            uint64_t v10 = (void *)v9[1];
            if (v10)
            {
              do
              {
                uint64_t v11 = v10;
                uint64_t v10 = (void *)*v10;
              }
              while (v10);
            }
            else
            {
              do
              {
                uint64_t v11 = (void *)v9[2];
                BOOL v8 = *v11 == (void)v9;
                int v9 = v11;
              }
              while (!v8);
            }
            int v9 = v11;
          }
          while (v11 != v5);
        }
      }
      break;
  }
  return this;
}

void llvm::mca::InOrderIssueStage::retireInstruction(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 8);
  *(_DWORD *)(v4 + 544) = 6;
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 48) + 24);
  if (v5 >= 5) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v5) {
    bzero(v10, 4 * v5);
  }
  unsigned int v9 = v5;
  uint64_t v6 = *(unsigned int *)(v4 + 24);
  if (v6)
  {
    unsigned int v7 = *(uint64_t **)(v4 + 16);
    uint64_t v8 = 136 * v6;
    do
    {
      llvm::mca::RegisterFile::removeRegisterWrite(*(void *)(a1 + 48), v7, v10);
      v7 += 17;
      v8 -= 136;
    }
    while (v8);
  }
  if ((*(unsigned char *)(v4 + 540) & 0xC) != 0) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 416) + 40))(*(void *)(a1 + 416), a2);
  }
  llvm::mca::InOrderIssueStage::notifyInstructionRetired(a1, a2, (uint64_t)v10, v9);
}

void llvm::mca::InOrderIssueStage::updateIssuedInst(llvm::mca::InOrderIssueStage *this)
{
  uint64_t v1 = *((unsigned int *)this + 108);
  if (v1)
  {
    unsigned int v3 = 0;
    uint64_t v4 = (char *)this + 424;
    uint64_t v5 = *((void *)this + 53);
    uint64_t v6 = v5 + 16 * v1;
    do
    {
      uint64_t v7 = *(void *)(v5 + 8);
      llvm::mca::Instruction::cycleEvent(v7);
      if (*(_DWORD *)(v7 + 544) == 5)
      {
        llvm::mca::RegisterFile::onInstructionExecuted(*((void *)this + 6), v7);
        (*(void (**)(void, uint64_t))(**((void **)this + 52) + 32))(*((void *)this + 52), v5);
        llvm::mca::InOrderIssueStage::notifyInstructionExecuted((uint64_t)this, v5);
        uint64_t v8 = v3 + 1;
        llvm::mca::InOrderIssueStage::retireInstruction((uint64_t)this, v5);
        uint64_t v9 = -v8;
        uint64_t v10 = v6 - 16 * v8;
        int v11 = *(_DWORD *)v5;
        uint64_t v12 = *(void *)(v5 + 8);
        *(_DWORD *)uint64_t v5 = *(_DWORD *)v10;
        *(void *)(v5 + 8) = *(void *)(v10 + 8);
        *(_DWORD *)uint64_t v10 = v11;
        *(void *)(v10 + 8) = v12;
        ++v3;
      }
      else
      {
        v5 += 16;
        uint64_t v8 = v3;
        uint64_t v9 = -(uint64_t)v3;
      }
    }
    while (v5 != v6 + 16 * v9);
    if (v3)
    {
      unint64_t v13 = *((unsigned int *)this + 108) - v8;
      sub_1CCC04C5C((uint64_t)v4, v13);
    }
  }
}

uint64_t llvm::mca::InOrderIssueStage::updateCarriedOver(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 544);
  if (v1)
  {
    unsigned int v2 = *(_DWORD *)(this + 552);
    unsigned int v3 = *(_DWORD *)(this + 556);
    if (v2 <= v3)
    {
      unsigned int v4 = v3 - v2;
      if ((*(unsigned char *)(v1 + 540) & 0x40) != 0) {
        unsigned int v5 = 0;
      }
      else {
        unsigned int v5 = v4;
      }
      *(_DWORD *)(this + 556) = v5;
      *(_DWORD *)(this + 536) = 0;
      *(void *)(this + 544) = 0;
      *(_DWORD *)(this + 552) = 0;
    }
    else
    {
      *(_DWORD *)(this + 552) = v2 - v3;
      *(_DWORD *)(this + 556) = 0;
    }
  }
  return this;
}

void llvm::mca::InOrderIssueStage::cycleStart(llvm::mca::InOrderIssueStage *this@<X0>, void *a2@<X8>)
{
  v16[8] = *MEMORY[0x1E4F143B8];
  *((_DWORD *)this + 126) = 0;
  uint64_t v4 = *((void *)this + 6);
  *((_DWORD *)this + 139) = **(_DWORD **)(*((void *)this + 5) + 160);
  uint64_t v5 = *(unsigned int *)(v4 + 24);
  if (v5)
  {
    uint64_t v6 = *(void *)(v4 + 16);
    uint64_t v7 = 20 * v5;
    uint64_t v8 = (_DWORD *)(v6 + 12);
    do
    {
      *uint64_t v8 = 0;
      v8 += 5;
      v7 -= 20;
    }
    while (v7);
  }
  (*(void (**)(void))(**((void **)this + 52) + 56))(*((void *)this + 52));
  v15[0] = v16;
  v15[1] = (void *)0x400000000;
  llvm::mca::ResourceManager::cycleEvent((uint64_t)this + 56, (uint64_t)v15);
  llvm::mca::InOrderIssueStage::updateIssuedInst(this);
  uint64_t v9 = *((void *)this + 68);
  if (v9)
  {
    unsigned int v10 = *((_DWORD *)this + 138);
    unsigned int v11 = *((_DWORD *)this + 139);
    if (v10 <= v11)
    {
      unsigned int v12 = v11 - v10;
      if ((*(unsigned char *)(v9 + 540) & 0x40) != 0) {
        unsigned int v13 = 0;
      }
      else {
        unsigned int v13 = v12;
      }
      *((_DWORD *)this + 139) = v13;
      *((_DWORD *)this + 134) = 0;
      *((void *)this + 68) = 0;
      *((_DWORD *)this + 138) = 0;
    }
    else
    {
      *((_DWORD *)this + 138) = v10 - v11;
      *((_DWORD *)this + 139) = 0;
    }
  }
  if (!*((void *)this + 65)) {
    goto LABEL_14;
  }
  if (*((_DWORD *)this + 132))
  {
LABEL_13:
    llvm::mca::InOrderIssueStage::notifyStallEvent((uint64_t)this);
    *((_DWORD *)this + 139) = 0;
LABEL_14:
    *a2 = 0;
    goto LABEL_15;
  }
  long long v14 = *((_OWORD *)this + 32);
  *((void *)this + 65) = 0;
  *((void *)this + 66) = 0;
  llvm::mca::InOrderIssueStage::tryIssue((uint64_t)this, (uint64_t)&v14, a2);
  if (!*a2)
  {
    if (!*((_DWORD *)this + 132)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_15:
  if (v15[0] != v16) {
    free(v15[0]);
  }
}

uint64_t llvm::mca::InOrderIssueStage::cycleEnd@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  ++*(_DWORD *)(*(void *)(this + 48) + 152);
  if (*(void *)(this + 520))
  {
    int v2 = *(_DWORD *)(this + 528);
    if (v2) {
      *(_DWORD *)(this + 528) = v2 - 1;
    }
  }
  int v3 = *(_DWORD *)(this + 560);
  if (v3) {
    *(_DWORD *)(this + 560) = v3 - 1;
  }
  *a2 = 0;
  return this;
}

uint64_t sub_1CCC04B6C(uint64_t a1)
{
  int v2 = *(void **)(a1 + 424);
  if (v2 != (void *)(a1 + 440)) {
    free(v2);
  }
  sub_1CCBFA434(a1 + 56);
  *(void *)a1 = &unk_1F26320F0;
  sub_1CC1B4328(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1CCC04BD4(uint64_t a1)
{
  int v2 = *(void **)(a1 + 424);
  if (v2 != (void *)(a1 + 440)) {
    free(v2);
  }
  sub_1CCBFA434(a1 + 56);
  *(void *)a1 = &unk_1F26320F0;
  sub_1CC1B4328(a1 + 16, *(void **)(a1 + 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCC04C5C(uint64_t result, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(result + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      if (*(unsigned int *)(result + 12) < a2) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v2 != a2)
      {
        uint64_t v3 = *(void *)result + 16 * a2;
        uint64_t v4 = *(void *)result + 16 * v2;
        do
        {
          *(_DWORD *)uint64_t v4 = 0;
          *(void *)(v4 + 8) = 0;
          v4 += 16;
        }
        while (v4 != v3);
      }
    }
    *(_DWORD *)(result + 8) = a2;
  }
  return result;
}

uint64_t llvm::mca::InstructionTables::execute@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = result;
  uint64_t v5 = **(void **)(a2 + 8);
  *(_DWORD *)(result + 56) = 0;
  unsigned int v6 = *(_DWORD *)(v5 + 144);
  if (v6)
  {
    uint64_t v37 = a2;
    int v38 = a3;
    uint64_t v7 = result + 48;
    uint64_t v8 = *(uint64_t **)(v5 + 136);
    v39 = &v8[3 * v6];
    do
    {
      int v10 = *((_DWORD *)v8 + 2);
      int v9 = *((_DWORD *)v8 + 3);
      v40 = v8;
      uint64_t v11 = (v9 - v10);
      if (v9 != v10)
      {
        uint64_t v12 = *(void *)(v3 + 160);
        uint64_t v13 = *(unsigned int *)(v3 + 168);
        if (v13)
        {
          uint64_t v14 = *v8;
          uint64_t v15 = 8 * v13;
          uint64_t v16 = *(void **)(v3 + 160);
          uint64_t v17 = (void *)(v12 + 8 * v13);
          while (*v16 != v14)
          {
            ++v16;
            v15 -= 8;
            if (!v15)
            {
              uint64_t v16 = v17;
              break;
            }
          }
        }
        else
        {
          uint64_t v16 = *(void **)(v3 + 160);
        }
        uint64_t v18 = (((unint64_t)v16 - v12) >> 3);
        uint64_t v19 = *(void *)(*(void *)(v3 + 40) + 32) + 32 * v18;
        v41 = (void *)(v19 + 24);
        uint64_t v20 = *(unsigned int *)(v19 + 8);
        if (*(void *)(v19 + 24))
        {
          if (v20)
          {
            for (uint64_t i = 0; i != v20; ++i)
            {
              uint64_t v22 = *(unsigned int *)(*v41 + 4 * i);
              uint64_t v23 = v3;
              uint64_t v24 = *(void *)(*(void *)(v3 + 40) + 32) + 32 * v22;
              int v27 = *(_DWORD *)(v24 + 8);
              int v26 = (_DWORD *)(v24 + 8);
              int v25 = v27;
              if (v27)
              {
                int v28 = 0;
                do
                {
                  uint64_t v29 = (*v26 * v20);
                  *(void *)&long long v42 = v22;
                  *((void *)&v42 + 1) = (1 << v28);
                  uint64_t v43 = v11 | (v29 << 32);
                  result = sub_1CCBF9C04(v7, &v42);
                  ++v28;
                }
                while (v25 != v28);
              }
              uint64_t v3 = v23;
            }
          }
        }
        else if (v20)
        {
          int v30 = 0;
          do
          {
            *(void *)&long long v42 = v18;
            *((void *)&v42 + 1) = (1 << v30);
            uint64_t v43 = v11 | (v20 << 32);
            result = sub_1CCBF9C04(v7, &v42);
            ++v30;
          }
          while (v20 != v30);
        }
      }
      uint64_t v8 = v40 + 3;
    }
    while (v40 + 3 != v39);
    uint64_t v31 = *(unsigned int *)(v3 + 56);
    a2 = v37;
    a3 = v38;
  }
  else
  {
    uint64_t v31 = 0;
  }
  uint64_t v32 = *(void *)(v3 + 48);
  LODWORD(v42) = 4;
  *((void *)&v42 + 1) = a2;
  uint64_t v43 = v32;
  uint64_t v44 = v31;
  uint64_t v33 = *(void **)(v3 + 16);
  if (v33 != (void *)(v3 + 24))
  {
    do
    {
      result = (*(uint64_t (**)(void, long long *))(*(void *)v33[4] + 24))(v33[4], &v42);
      long long v34 = (void *)v33[1];
      if (v34)
      {
        do
        {
          v35 = v34;
          long long v34 = (void *)*v34;
        }
        while (v34);
      }
      else
      {
        do
        {
          v35 = (void *)v33[2];
          BOOL v36 = *v35 == (void)v33;
          uint64_t v33 = v35;
        }
        while (!v36);
      }
      uint64_t v33 = v35;
    }
    while (v35 != (void *)(v3 + 24));
  }
  *a3 = 0;
  return result;
}

uint64_t sub_1CCC04F24(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 160);
  if (v2 != (void *)(a1 + 176)) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3 != (void *)(a1 + 64)) {
    free(v3);
  }
  *(void *)a1 = &unk_1F26320F0;
  sub_1CC1B4328(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1CCC04F98(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 160);
  if (v2 != (void *)(a1 + 176)) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3 != (void *)(a1 + 64)) {
    free(v3);
  }
  *(void *)a1 = &unk_1F26320F0;
  sub_1CC1B4328(a1 + 16, *(void **)(a1 + 24));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCC0502C()
{
  return 1;
}

uint64_t sub_1CCC05034()
{
  return 0;
}

void sub_1CCC0503C(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t llvm::mca::MicroOpQueueStage::moveInstructions@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  long long v10 = *(_OWORD *)(*(void *)(this + 40) + 16 * *(unsigned int *)(this + 188));
  if (*((void *)&v10 + 1))
  {
    uint64_t v3 = this;
    do
    {
      this = *(void *)(v3 + 8);
      if (!this) {
        break;
      }
      this = (*(uint64_t (**)(uint64_t, long long *))(*(void *)this + 16))(this, &v10);
      if (!this) {
        break;
      }
      this = (*(uint64_t (**)(void, long long *))(**(void **)(v3 + 8) + 48))(*(void *)(v3 + 8), &v10);
      if (*a2) {
        return this;
      }
      uint64_t v4 = *(unsigned int *)(v3 + 188);
      uint64_t v5 = *(void *)(v3 + 40);
      *(void *)(v5 + 16 * v4 + 8) = 0;
      unsigned int v6 = *(_DWORD *)(v3 + 48);
      unsigned int v7 = *(_DWORD *)(**((void **)&v10 + 1) + 284);
      if (v7 >= v6) {
        unsigned int v7 = *(_DWORD *)(v3 + 48);
      }
      if (v7 <= 1) {
        unsigned int v7 = 1;
      }
      unsigned int v8 = (v7 + v4) % v6;
      *(_DWORD *)(v3 + 188) = v8;
      *(_DWORD *)(v3 + 200) += v7;
      uint64_t v9 = v5 + 16 * v8;
      LODWORD(v10) = *(_DWORD *)v9;
      *((void *)&v10 + 1) = *(void *)(v9 + 8);
    }
    while (*((void *)&v10 + 1));
  }
  *a2 = 0;
  return this;
}

llvm::mca::MicroOpQueueStage *llvm::mca::MicroOpQueueStage::MicroOpQueueStage(llvm::mca::MicroOpQueueStage *this, unint64_t a2, int a3, char a4)
{
  *((void *)this + 4) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *(void *)this = &unk_1F2632060;
  *((void *)this + 5) = (char *)this + 56;
  uint64_t v5 = (char *)this + 40;
  *((void *)this + 6) = 0x800000000;
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 48) = a3;
  *((_DWORD *)this + 49) = 0;
  if (a2 <= 1) {
    a2 = 1;
  }
  else {
    a2 = a2;
  }
  *((unsigned char *)this + 204) = a4;
  sub_1CCC04C5C((uint64_t)v5, a2);
  *((_DWORD *)this + 50) = *((_DWORD *)this + 12);
  return this;
}

{
  char *v5;

  *((void *)this + 4) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *(void *)this = &unk_1F2632060;
  *((void *)this + 5) = (char *)this + 56;
  uint64_t v5 = (char *)this + 40;
  *((void *)this + 6) = 0x800000000;
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 48) = a3;
  *((_DWORD *)this + 49) = 0;
  if (a2 <= 1) {
    a2 = 1;
  }
  else {
    a2 = a2;
  }
  *((unsigned char *)this + 204) = a4;
  sub_1CCC04C5C((uint64_t)v5, a2);
  *((_DWORD *)this + 50) = *((_DWORD *)this + 12);
  return this;
}

uint64_t llvm::mca::MicroOpQueueStage::execute@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v3 = *(unsigned int *)(result + 184);
  uint64_t v4 = *(void *)(result + 40) + 16 * v3;
  *(_DWORD *)uint64_t v4 = *(_DWORD *)a2;
  *(void *)(v4 + 8) = *(void *)(a2 + 8);
  unsigned int v5 = *(_DWORD *)(result + 48);
  unsigned int v6 = *(_DWORD *)(**(void **)(a2 + 8) + 284);
  if (v6 >= v5) {
    unsigned int v6 = *(_DWORD *)(result + 48);
  }
  if (v6 <= 1) {
    unsigned int v6 = 1;
  }
  *(_DWORD *)(result + 184) = (v6 + v3) % v5;
  unsigned int v7 = *(_DWORD *)(result + 200) - v6;
  ++*(_DWORD *)(result + 196);
  *(_DWORD *)(result + 200) = v7;
  *a3 = 0;
  return result;
}

uint64_t llvm::mca::MicroOpQueueStage::cycleStart@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  *(_DWORD *)(this + 196) = 0;
  if (!*(unsigned char *)(this + 204)) {
    return llvm::mca::MicroOpQueueStage::moveInstructions(this, a2);
  }
  *a2 = 0;
  return this;
}

uint64_t llvm::mca::MicroOpQueueStage::cycleEnd@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  if (*(unsigned char *)(this + 204)) {
    return llvm::mca::MicroOpQueueStage::moveInstructions(this, a2);
  }
  *a2 = 0;
  return this;
}

uint64_t sub_1CCC052F4(uint64_t a1)
{
  *(void *)a1 = &unk_1F2632060;
  unint64_t v2 = *(void **)(a1 + 40);
  if (v2 != (void *)(a1 + 56)) {
    free(v2);
  }
  *(void *)a1 = &unk_1F26320F0;
  sub_1CC1B4328(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1CCC05370(uint64_t a1)
{
  *(void *)a1 = &unk_1F2632060;
  unint64_t v2 = *(void **)(a1 + 40);
  if (v2 != (void *)(a1 + 56)) {
    free(v2);
  }
  *(void *)a1 = &unk_1F26320F0;
  sub_1CC1B4328(a1 + 16, *(void **)(a1 + 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCC0540C(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[48];
  if (v2 && a1[49] == v2) {
    return 0;
  }
  unsigned int v4 = a1[12];
  if (*(_DWORD *)(**(void **)(a2 + 8) + 284) < v4) {
    unsigned int v4 = *(_DWORD *)(**(void **)(a2 + 8) + 284);
  }
  if (v4 <= 1) {
    unsigned int v4 = 1;
  }
  return v4 <= a1[50];
}

BOOL sub_1CCC05458(uint64_t a1)
{
  return *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 200);
}

void llvm::mca::RetireStage::cycleStart(llvm::mca::RetireStage *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *((void *)this + 6);
  uint64_t v5 = *(unsigned int *)(v4 + 24);
  if (v5)
  {
    uint64_t v6 = 20 * v5;
    unsigned int v7 = (_DWORD *)(*(void *)(v4 + 16) + 12);
    do
    {
      *unsigned int v7 = 0;
      v7 += 5;
      v6 -= 20;
    }
    while (v6);
  }
  uint64_t v8 = *((void *)this + 5);
  if (*(_DWORD *)(v8 + 20) != *(_DWORD *)(v8 + 16))
  {
    int v9 = *(_DWORD *)(v8 + 24);
    int v10 = v9;
    do
    {
      if (v9 && !v10) {
        break;
      }
      unsigned int v11 = *(_DWORD *)(v8 + 12);
      uint64_t v12 = *(void *)(v8 + 32);
      if (!*(unsigned char *)(v12 + 24 * v11 + 20)) {
        break;
      }
      llvm::mca::RetireStage::notifyInstructionRetired((uint64_t)this, v12 + 24 * v11);
      uint64_t v13 = *((void *)this + 5);
      unsigned int v14 = *(_DWORD *)(v13 + 12);
      uint64_t v15 = *(void *)(v13 + 32);
      uint64_t v16 = *(void *)(v13 + 40);
      uint64_t v17 = v15 + 24 * v14;
      *(_DWORD *)(*(void *)(v17 + 8) + 544) = 6;
      unsigned int v18 = *(_DWORD *)(v17 + 16);
      int v19 = v18 <= 1 ? 1 : *(_DWORD *)(v17 + 16);
      *(_DWORD *)(v13 + 12) = (v19 + v14) % (0xAAAAAAAAAAAAAAABLL * ((v16 - v15) >> 3));
      *(_DWORD *)(v13 + 20) += v18;
      *(_DWORD *)uint64_t v17 = 0;
      *(void *)(v17 + 8) = 0;
      *(_DWORD *)(v17 + 16) = 0;
      *(unsigned char *)(v17 + 20) = 0;
      uint64_t v8 = *((void *)this + 5);
      --v10;
    }
    while (*(_DWORD *)(v8 + 20) != *(_DWORD *)(v8 + 16));
  }
  *a2 = 0;
}

void llvm::mca::RetireStage::notifyInstructionRetired(uint64_t a1, uint64_t a2)
{
  v22[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(unsigned int *)(*(void *)(a1 + 48) + 24);
  int v19 = v22;
  int v21 = 4;
  if (v4 >= 5)
  {
    unsigned int v20 = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v4) {
    bzero(v22, 4 * v4);
  }
  unsigned int v20 = v4;
  uint64_t v5 = *(void *)(a2 + 8);
  if ((*(unsigned char *)(v5 + 540) & 0xC) != 0) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), a2);
  }
  uint64_t v6 = *(unsigned int *)(v5 + 24);
  if (v6)
  {
    unsigned int v7 = *(uint64_t **)(v5 + 16);
    uint64_t v8 = 136 * v6;
    do
    {
      llvm::mca::RegisterFile::removeRegisterWrite(*(void *)(a1 + 48), v7, v19);
      v7 += 17;
      v8 -= 136;
    }
    while (v8);
  }
  int v9 = v19;
  int v15 = 1;
  uint64_t v16 = a2;
  uint64_t v17 = v19;
  uint64_t v18 = v20;
  int v10 = *(void **)(a1 + 16);
  unsigned int v11 = (void *)(a1 + 24);
  if (v10 != v11)
  {
    do
    {
      (*(void (**)(void, int *))(*(void *)v10[4] + 24))(v10[4], &v15);
      uint64_t v12 = (void *)v10[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v10[2];
          BOOL v14 = *v13 == (void)v10;
          int v10 = v13;
        }
        while (!v14);
      }
      int v10 = v13;
    }
    while (v13 != v11);
    int v9 = v19;
  }
  if (v9 != v22) {
    free(v9);
  }
}

uint64_t llvm::mca::RetireStage::cycleEnd@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  return this;
}

uint64_t llvm::mca::RetireStage::execute@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a2 + 8);
  uint64_t result = llvm::mca::RegisterFile::onInstructionExecuted(*(void *)(a1 + 48), v5);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 32) + 24 * *(unsigned int *)(v5 + 552) + 20) = 1;
  *a3 = 0;
  return result;
}

uint64_t sub_1CCC057D8(uint64_t a1)
{
  *(void *)a1 = &unk_1F26320F0;
  sub_1CC1B4328(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_1CCC05820(uint64_t a1)
{
  *(void *)a1 = &unk_1F26320F0;
  sub_1CC1B4328(a1 + 16, *(void **)(a1 + 24));

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CCC05888(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 40) + 20) != *(_DWORD *)(*(void *)(a1 + 40) + 16);
}

void llvm::mca::Stage::~Stage(llvm::mca::Stage *this)
{
  *(void *)this = &unk_1F26320F0;
  sub_1CC1B4328((uint64_t)this + 16, *((void **)this + 3));
}

uint64_t **llvm::mca::Stage::addListener(uint64_t **this, llvm::mca::HWEventListener *a2)
{
  uint64_t v3 = (uint64_t *)a2;
  return sub_1CCC01548(this + 2, (unint64_t *)&v3, &v3);
}

_DWORD *llvm::mca::ResourceCycles::operator+=(_DWORD *result, _DWORD *a2)
{
  unsigned int v2 = result[1];
  unsigned int v3 = a2[1];
  if (v2 == v3)
  {
    *result += *a2;
  }
  else
  {
    LODWORD(v4) = result[1];
    if (v3)
    {
      unint64_t v5 = result[1];
      unint64_t v6 = a2[1];
      do
      {
        unint64_t v4 = v6;
        unint64_t v6 = v5 % v6;
        unint64_t v5 = v4;
      }
      while (v6);
    }
    unsigned int v7 = v3 * v2 / v4;
    *uint64_t result = v7 / v2 * *result + v7 / v3 * *a2;
    result[1] = v7;
  }
  return result;
}

uint64_t llvm::mca::computeProcResourceMasks(uint64_t result, void *a2)
{
  *a2 = 0;
  uint64_t v2 = *(unsigned int *)(result + 48);
  if (v2 >= 2)
  {
    char v3 = 0;
    uint64_t v4 = *(void *)(result + 32);
    uint64_t v5 = v2 - 1;
    unint64_t v6 = a2 + 1;
    unsigned int v7 = (void *)(v4 + 56);
    do
    {
      if (!*v7) {
        *unint64_t v6 = 1 << v3++;
      }
      ++v6;
      v7 += 4;
      --v5;
    }
    while (v5);
    for (uint64_t i = 1; i != v2; ++i)
    {
      uint64_t v9 = v4 + 32 * i;
      int v10 = *(int **)(v9 + 24);
      if (v10)
      {
        uint64_t v11 = 1 << v3;
        a2[i] = 1 << v3;
        uint64_t v12 = *(unsigned int *)(v9 + 8);
        if (v12)
        {
          do
          {
            int v13 = *v10++;
            v11 |= a2[v13];
            a2[i] = v11;
            --v12;
          }
          while (v12);
        }
        ++v3;
      }
    }
  }
  return result;
}

uint64_t llvm::mca::computeBlockRThroughput(uint64_t result, unsigned int a2, unsigned int a3, unsigned int *a4, double a5, double a6, double a7)
{
  double v7 = (double)a3 / (double)a2;
  uint64_t v8 = *(unsigned int *)(result + 48);
  if (v8)
  {
    uint64_t v9 = (_DWORD *)(*(void *)(result + 32) + 8);
    do
    {
      unsigned int v11 = *a4++;
      unsigned int v10 = v11;
      if (v11)
      {
        LODWORD(a7) = *v9;
        a7 = (double)*(unint64_t *)&a7;
        if (v7 < (double)v10 / a7) {
          double v7 = (double)v10 / a7;
        }
      }
      v9 += 8;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t sub_1CCC05A80()
{
  return 0;
}

uint64_t LLVMCreateDisasmCPUFeatures(const char *a1, const char *a2, const char *a3)
{
  v34[0] = 0;
  v34[1] = 0;
  uint64_t v35 = 0;
  size_t v5 = strlen(a1);
  if (v5 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (long long *)operator new(v8 + 1);
    *((void *)&__dst + 1) = v6;
    *(void *)&long long v26 = v9 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_8;
  }
  BYTE7(v26) = v5;
  p_dst = &__dst;
  if (v5) {
LABEL_8:
  }
    memcpy(p_dst, a1, v6);
  *((unsigned char *)p_dst + v6) = 0;
  unsigned int v10 = llvm::TargetRegistry::lookupTarget((std::string::size_type)&__dst, (uint64_t)v34);
  if (SBYTE7(v26) < 0) {
    operator delete((void *)__dst);
  }
  if (v10)
  {
    uint64_t v12 = a1 ? strlen(a1) : 0;
    uint64_t v13 = sub_1CD52142C((uint64_t)v10, (uint64_t)a1, v12);
    if (v13)
    {
      uint64_t v14 = v13;
      LOWORD(__dst) = 4096;
      *(void *)((char *)&__dst + 4) = 2;
      long long v26 = 0u;
      *(_OWORD *)int v27 = 0u;
      long long v28 = 0u;
      *(_OWORD *)uint64_t v29 = 0u;
      *(_OWORD *)__p = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      memset(v33, 0, sizeof(v33));
      if (a1) {
        size_t v15 = strlen(a1);
      }
      else {
        size_t v15 = 0;
      }
      uint64_t v16 = sub_1CD5214A0((uint64_t)v10, v14, (uint64_t)a1, v15, (uint64_t)&__dst);
      if (v16)
      {
        uint64_t v17 = v16;
        uint64_t v18 = (uint64_t (*)(void))v10[8];
        if (v18)
        {
          uint64_t v19 = v18();
          if (v19)
          {
            uint64_t v23 = v19;
            if (a1) {
              size_t v22 = strlen(a1);
            }
            else {
              size_t v22 = 0;
            }
            if (a2) {
              int v21 = (llvm::MCContext *)strlen(a2);
            }
            else {
              int v21 = 0;
            }
            if (a3) {
              size_t v20 = strlen(a3);
            }
            else {
              size_t v20 = 0;
            }
            if (sub_1CD452D6C((uint64_t)v10, (uint64_t)a1, v22, (uint64_t)a2, (uint64_t)v21, (uint64_t)a3, v20)) {
              operator new();
            }
            MEMORY[0x1D25D9CE0](v23, 0x10F0C40CB53E019);
          }
        }
        (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
      }
      BOOL v36 = (void **)v33 + 1;
      sub_1CB8338B8(&v36);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p[1]);
      }
      if (SHIBYTE(__p[0]) < 0) {
        operator delete(v29[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(v27[1]);
      }
      if (SHIBYTE(v27[0]) < 0) {
        operator delete((void *)v26);
      }
      sub_1CD521E44(v14);
    }
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(v34[0]);
  }
  return 0;
}

uint64_t LLVMCreateDisasmCPU(const char *a1, const char *a2)
{
  return LLVMCreateDisasmCPUFeatures(a1, a2, "");
}

uint64_t LLVMCreateDisasm(const char *a1)
{
  return LLVMCreateDisasmCPUFeatures(a1, "", "");
}

uint64_t LLVMDisasmDispose(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    *(void *)(result + 304) = &unk_1F2646B98;
    if (*(_DWORD *)(result + 360) == 1)
    {
      uint64_t v10 = *(void *)(result + 320);
      if (v10) {
        MEMORY[0x1D25D9CB0](v10, 0x1000C8077774924);
      }
    }
    uint64_t v2 = *(void **)(v1 + 152);
    if (v2 != (void *)(v1 + 176)) {
      free(v2);
    }
    if (*(char *)(v1 + 151) < 0) {
      operator delete(*(void **)(v1 + 128));
    }
    uint64_t v3 = *(void *)(v1 + 112);
    *(void *)(v1 + 112) = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = *(void *)(v1 + 104);
    *(void *)(v1 + 104) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    size_t v5 = *(llvm::MCContext **)(v1 + 96);
    *(void *)(v1 + 96) = 0;
    if (v5)
    {
      llvm::MCContext::~MCContext(v5);
      MEMORY[0x1D25D9CE0]();
    }
    uint64_t v6 = *(void *)(v1 + 88);
    *(void *)(v1 + 88) = 0;
    if (v6) {
      MEMORY[0x1D25D9CE0](v6, 0x10F0C40CB53E019);
    }
    uint64_t v7 = *(void *)(v1 + 80);
    *(void *)(v1 + 80) = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    uint64_t v8 = *(void *)(v1 + 72);
    *(void *)(v1 + 72) = 0;
    if (!v8)
    {
      uint64_t v9 = *(void *)(v1 + 64);
      *(void *)(v1 + 64) = 0;
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
      if (*(char *)(v1 + 23) < 0) {
        operator delete(*(void **)v1);
      }
      JUMPOUT(0x1D25D9CE0);
    }
    sub_1CD521E44(v8);
  }
  return result;
}

uint64_t LLVMDisasmInstruction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t v83 = 0;
  v90[0] = 0;
  v90[1] = 0;
  v91 = v93;
  uint64_t v92 = 0x800000000;
  v93[128] = 0;
  uint64_t v8 = *(void *)(a1 + 104);
  uint64_t v9 = *(void *)(a1 + 112);
  v87 = v89;
  long long v88 = xmmword_1CD96DBD0;
  int v75 = 0;
  char v79 = 0;
  uint64_t v80 = 0;
  v82 = &v87;
  int v81 = 0;
  v74 = &unk_1F2646FA8;
  uint64_t v76 = 0;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v10 = 0;
  if ((*(unsigned int (**)(uint64_t, void *, uint64_t *, uint64_t, uint64_t, uint64_t, void **))(*(void *)v8 + 16))(v8, v90, &v83, a2, a3, a4, &v74) < 2)goto LABEL_55; {
  unsigned int v11 = *v82;
  }
  uint64_t v12 = v82[1];
  v84 = v86;
  long long v85 = xmmword_1CD96DBD0;
  int v66 = 0;
  char v70 = 0;
  uint64_t v71 = 0;
  v73 = &v84;
  int v72 = 0;
  v65 = &unk_1F2646FA8;
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  int v53 = 0;
  char v57 = 0;
  uint64_t v58 = 0;
  int v59 = 1;
  unint64_t v55 = 0;
  v56 = 0;
  v54 = 0;
  v52 = &unk_1F2644C68;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  v62 = &v64;
  long long v63 = xmmword_1CDB159A0;
  sub_1CBF2ECF8((uint64_t)&v52, (uint64_t)&v65);
  (*(void (**)(uint64_t, void *, uint64_t, void *, void *, void, void **))(*(void *)v9 + 32))(v9, v90, a4, v11, v12, *(void *)(a1 + 80), &v52);
  if ((*(unsigned char *)(a1 + 120) & 0x10) != 0)
  {
    uint64_t v13 = *(void **)(a1 + 80);
    uint64_t v14 = *(void *)(v13[20] + 40);
    if (v14)
    {
      if ((~*(unsigned __int16 *)(v14
                                 + 24 * *(unsigned __int16 *)(**(void **)(a1 + 88) + 48 * LODWORD(v90[0]) + 6)
                                 + 8) & 0x1FFE) != 0)
      {
        uint64_t v15 = *(unsigned __int16 *)(v14
                                  + 24 * *(unsigned __int16 *)(**(void **)(a1 + 88) + 48 * LODWORD(v90[0]) + 6)
                                  + 16);
        if (*(_WORD *)(v14 + 24 * *(unsigned __int16 *)(**(void **)(a1 + 88) + 48 * LODWORD(v90[0]) + 6) + 16))
        {
          unsigned __int16 v16 = 0;
          uint64_t v17 = (__int16 *)(v13[18]
                          + 4
                          * *(unsigned __int16 *)(v14
                                                + 24
                                                * *(unsigned __int16 *)(**(void **)(a1 + 88)
                                                                      + 48 * LODWORD(v90[0])
                                                                      + 6)
                                                + 14));
          do
          {
            int v19 = *v17;
            v17 += 2;
            unsigned __int16 v18 = v19;
            if ((__int16)v16 <= v19) {
              unsigned __int16 v16 = v18;
            }
            --v15;
          }
          while (v15);
          int v20 = v16;
LABEL_11:
          if (v20 >= 2)
          {
            uint64_t v21 = *(void *)(a1 + 336);
            if ((unint64_t)(*(void *)(a1 + 328) - v21) > 8)
            {
              *(unsigned char *)(v21 + 8) = 32;
              *(void *)uint64_t v21 = *(void *)"Latency: ";
              *(void *)(a1 + 336) += 9;
            }
            else
            {
              llvm::raw_ostream::write((llvm::raw_ostream *)(a1 + 304), "Latency: ", 9uLL);
            }
            sub_1CD098D14((llvm::raw_ostream *)(a1 + 304), v20, 0, 0, 0);
            size_t v22 = *(unsigned char **)(a1 + 336);
            if ((unint64_t)v22 >= *(void *)(a1 + 328))
            {
              llvm::raw_ostream::write((llvm::raw_ostream *)(a1 + 304), 10);
            }
            else
            {
              *(void *)(a1 + 336) = v22 + 1;
              *size_t v22 = 10;
            }
          }
        }
      }
    }
    else
    {
      char v23 = *(unsigned char *)(a1 + 151);
      int v24 = v23;
      size_t v25 = v23 & 0x7F;
      if (v24 >= 0) {
        size_t v26 = v25;
      }
      else {
        size_t v26 = *(void *)(a1 + 136);
      }
      if (v26)
      {
        v41 = v24 >= 0 ? (_DWORD *)(a1 + 128) : *(_DWORD **)(a1 + 128);
        SchedModelForCPU = llvm::MCSubtargetInfo::getSchedModelForCPU(*(void *)(a1 + 80), v41, v26);
        if (v92)
        {
          int v43 = 0;
          int v20 = 0;
          uint64_t v44 = *((void *)SchedModelForCPU + 7);
          uint64_t v45 = v44 + 10 * *(unsigned __int16 *)(**(void **)(a1 + 88) + 48 * LODWORD(v90[0]) + 6);
          v46 = (unsigned __int16 *)(v45 + 6);
          v47 = (unsigned __int16 *)(v45 + 8);
          do
          {
            if (v44 && (unsigned int v48 = v43 + *v46, v48 < *v47)) {
              int v49 = *(_DWORD *)(v13[22] + 4 * v48);
            }
            else {
              int v49 = -1;
            }
            if (v20 <= v49) {
              int v20 = v49;
            }
            ++v43;
          }
          while (v92 != v43);
          goto LABEL_11;
        }
      }
    }
  }
  size_t v27 = *(void *)(a1 + 160);
  if (v27)
  {
    uint64_t v28 = *(void *)(a1 + 64);
    int v30 = *(const void **)(v28 + 48);
    size_t v29 = *(void *)(v28 + 56);
    long long v31 = *(char **)(a1 + 152);
    char v32 = 1;
    do
    {
      if ((v32 & 1) == 0)
      {
        uint64_t v33 = v56;
        if ((unint64_t)v56 >= v55)
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v52, 10);
        }
        else
        {
          ++v56;
          *uint64_t v33 = 10;
        }
      }
      llvm::formatted_raw_ostream::PadToColumn((llvm::formatted_raw_ostream *)&v52, 40);
      long long v34 = memchr(v31, 10, v27);
      if (v34) {
        unint64_t v35 = v34 - v31;
      }
      else {
        unint64_t v35 = -1;
      }
      BOOL v36 = v56;
      if (v29 <= v55 - (unint64_t)v56)
      {
        if (v29)
        {
          memcpy(v56, v30, v29);
          BOOL v36 = &v56[v29];
          v56 += v29;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v52, (const char *)v30, v29);
        BOOL v36 = v56;
      }
      if ((unint64_t)v36 >= v55)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v52, 32);
      }
      else
      {
        v56 = v36 + 1;
        char *v36 = 32;
      }
      if (v27 >= v35) {
        size_t v37 = v35;
      }
      else {
        size_t v37 = v27;
      }
      if (v37 <= v55 - (unint64_t)v56)
      {
        if (v37)
        {
          memcpy(v56, v31, v37);
          v56 += v37;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v52, v31, v37);
      }
      char v32 = 0;
      if (v27 >= v35 + 1) {
        size_t v38 = v35 + 1;
      }
      else {
        size_t v38 = v27;
      }
      v31 += v38;
      v27 -= v38;
    }
    while (v27);
  }
  if (v56 != v54)
  {
    v56 = v54;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v52, v54);
  }
  *(void *)(a1 + 160) = 0;
  if ((unint64_t)v85 >= a6 - 1) {
    size_t v39 = a6 - 1;
  }
  else {
    size_t v39 = v85;
  }
  memcpy(a5, v84, v39);
  *((unsigned char *)a5 + v39) = 0;
  uint64_t v10 = v83;
  sub_1CBF2EF74((llvm::raw_ostream *)&v52);
  v65 = &unk_1F2646B98;
  if (v72 == 1 && v67) {
    MEMORY[0x1D25D9CB0](v67, 0x1000C8077774924);
  }
  if (v84 != v86) {
    free(v84);
  }
LABEL_55:
  v74 = &unk_1F2646B98;
  if (v81 == 1 && v76) {
    MEMORY[0x1D25D9CB0](v76, 0x1000C8077774924);
  }
  if (v87 != v89) {
    free(v87);
  }
  if (v91 != v93) {
    free(v91);
  }
  return v10;
}

BOOL LLVMSetDisasmOptions(void *a1, unint64_t a2)
{
  unint64_t v2 = a2;
  if ((a2 & 1) == 0)
  {
    if ((a2 & 2) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    *(unsigned char *)(a1[14] + 50) = 1;
    a1[15] |= 2uLL;
    v2 &= ~2uLL;
    if ((v2 & 4) == 0) {
      goto LABEL_14;
    }
    goto LABEL_7;
  }
  *(unsigned char *)(a1[14] + 48) = 1;
  a1[15] |= 1uLL;
  unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFFELL;
  if ((a2 & 2) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((v2 & 4) == 0)
  {
LABEL_14:
    if ((v2 & 8) == 0) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_7:
  uint64_t v4 = a1[11];
  uint64_t v6 = a1[8];
  uint64_t v5 = a1[9];
  uint64_t v7 = a1[7];
  BOOL v8 = *(_DWORD *)(v6 + 176) == 0;
  __int16 v16 = 260;
  uint64_t v15 = a1;
  uint64_t v9 = llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)&v15);
  uint64_t v10 = *(void (**)(llvm::Triple *))(v7 + 288);
  if (v10) {
    v10(v9);
  }
  unsigned int v11 = *(uint64_t (**)(void **, BOOL, uint64_t, uint64_t, uint64_t))(v7 + 136);
  if (v11) {
    uint64_t v12 = v11(__p, v8, v6, v4, v5);
  }
  else {
    uint64_t v12 = 0;
  }
  if (v18 < 0)
  {
    operator delete(__p[0]);
    if (!v12) {
      goto LABEL_14;
    }
  }
  else if (!v12)
  {
    goto LABEL_14;
  }
  uint64_t v14 = a1[14];
  a1[14] = v12;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  a1[15] |= 4uLL;
  v2 &= ~4uLL;
  if ((v2 & 8) != 0)
  {
LABEL_15:
    *(void *)(a1[14] + 8) = a1 + 38;
    a1[15] |= 8uLL;
    v2 &= ~8uLL;
  }
LABEL_16:
  if ((v2 & 0x10) != 0)
  {
    a1[15] |= 0x10uLL;
    v2 &= ~0x10uLL;
  }
  return v2 == 0;
}

void llvm::MCDisassembler::~MCDisassembler(llvm::MCDisassembler *this)
{
  *(void *)this = &unk_1F26321D0;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

uint64_t llvm::MCDisassembler::onSymbolStart()
{
  return 0;
}

uint64_t llvm::MCDisassembler::tryAddingSymbolicOperand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)result + 16))(result, a2, *(void *)(a1 + 32), a3, a4, a5, a6, a7);
  }
  return result;
}

uint64_t llvm::MCDisassembler::tryAddingPcLoadReferenceComment(llvm::MCDisassembler *this, uint64_t a2, uint64_t a3)
{
  uint64_t result = *((void *)this + 3);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)result + 24))(result, *((void *)this + 4), a2, a3);
  }
  return result;
}

uint64_t llvm::MCDisassembler::setSymbolizer(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t result = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v3;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

BOOL llvm::XCOFFSymbolInfo::operator<(char *a1, char *a2)
{
  int v2 = a2[12];
  if (a1[12] != v2) {
    return v2 != 0;
  }
  int v4 = a1[1];
  if (a2[1]) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 0;
  }
  BOOL result = v5;
  if (v4) {
    BOOL v7 = a2[1] == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    unint64_t v8 = *a1;
    if (v8 > 0x16) {
      unsigned int v9 = 0;
    }
    else {
      unsigned int v9 = byte_1CFB29040[v8];
    }
    unint64_t v10 = *a2;
    if (v10 > 0x16) {
      unsigned int v11 = 0;
    }
    else {
      unsigned int v11 = byte_1CFB29040[v10];
    }
    return v9 < v11;
  }
  return result;
}

uint64_t llvm::MCExternalSymbolizer::tryAddingSymbolicOperand(uint64_t a1, uint64_t a2, llvm::raw_ostream *a3, unint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8)
{
  long long v15 = 0uLL;
  *(_OWORD *)__sz = 0u;
  *(_OWORD *)__s = 0u;
  long long v103 = 0u;
  long long v105 = a4;
  __int16 v16 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, char **))(a1 + 24);
  if (v16)
  {
    int v17 = v16(*(void *)(a1 + 40), a5, a7, a8, 1, __s);
    long long v15 = 0uLL;
    if (v17) {
      goto LABEL_3;
    }
  }
  uint64_t result = 0;
  *(_OWORD *)__sz = v15;
  long long v105 = v15;
  *(_OWORD *)__s = v15;
  long long v103 = v15;
  char v26 = a6 ^ 1;
  if (a8 != 1) {
    char v26 = 0;
  }
  if ((v26 & 1) == 0)
  {
    size_t v27 = *(uint64_t (**)(void, unint64_t, unint64_t *, uint64_t, char **))(a1 + 32);
    if (v27)
    {
      unint64_t v98 = a6;
      v101 = 0;
      uint64_t v28 = (char *)v27(*(void *)(a1 + 40), a4, &v98, a5, &v101);
      size_t v29 = v28;
      if (v28)
      {
        __s[0] = (char *)1;
        __s[1] = v28;
        int v30 = (unsigned __int8 **)v98;
        if (v98 != 9) {
          goto LABEL_54;
        }
        if (!v101) {
          goto LABEL_3;
        }
        size_t v31 = strlen(v101);
        char v32 = (void *)*((void *)a3 + 4);
        if (v31 <= *((void *)a3 + 3) - (void)v32)
        {
          if (v31)
          {
            memcpy(v32, v101, v31);
            *((void *)a3 + 4) += v31;
          }
        }
        else
        {
          llvm::raw_ostream::write(a3, v101, v31);
        }
      }
      else if (a6)
      {
        *(void *)&long long v105 = a4;
      }
      int v30 = (unsigned __int8 **)v98;
LABEL_54:
      if (v30 == (unsigned __int8 **)5)
      {
        long long v63 = (void *)*((void *)a3 + 4);
        if (*((void *)a3 + 3) - (void)v63 <= 0xDuLL)
        {
          uint64_t v60 = "Objc message: ";
          uint64_t v61 = a3;
          size_t v62 = 14;
          goto LABEL_60;
        }
        qmemcpy(v63, "Objc message: ", 14);
        uint64_t v91 = *((void *)a3 + 4) + 14;
      }
      else
      {
        if (v30 != (unsigned __int8 **)1) {
          goto LABEL_64;
        }
        uint64_t v59 = *((void *)a3 + 4);
        if ((unint64_t)(*((void *)a3 + 3) - v59) <= 0x10)
        {
          uint64_t v60 = "symbol stub for: ";
          uint64_t v61 = a3;
          size_t v62 = 17;
LABEL_60:
          a3 = llvm::raw_ostream::write(v61, v60, v62);
          goto LABEL_61;
        }
        *(unsigned char *)(v59 + 16) = 32;
        *(_OWORD *)uint64_t v59 = *(_OWORD *)"symbol stub for: ";
        uint64_t v91 = *((void *)a3 + 4) + 17;
      }
      *((void *)a3 + 4) = v91;
LABEL_61:
      if (v101)
      {
        size_t v64 = strlen(v101);
        v65 = (void *)*((void *)a3 + 4);
        if (v64 <= *((void *)a3 + 3) - (void)v65)
        {
          if (v64)
          {
            memcpy(v65, v101, v64);
            *((void *)a3 + 4) += v64;
          }
        }
        else
        {
          llvm::raw_ostream::write(a3, v101, v64);
        }
      }
LABEL_64:
      if (!v29 && !a6) {
        return 0;
      }
LABEL_3:
      if (__s[0])
      {
        if (__s[1])
        {
          size_t v18 = strlen(__s[1]);
          int v19 = *(llvm::MCContext **)(a1 + 8);
          __int16 v100 = 261;
          unint64_t v98 = (unint64_t)__s[1];
          size_t v99 = v18;
          uint64_t Symbol = llvm::MCContext::getOrCreateSymbol(v19, (unsigned __int8 ***)&v98);
          uint64_t v21 = *(void *)(a1 + 8);
          *(void *)(v21 + 272) += 24;
          uint64_t v22 = *(void *)(v21 + 192);
          if (((v22 + 7) & 0xFFFFFFFFFFFFFFF8) - v22 + 24 > *(void *)(v21 + 200) - v22)
          {
            unsigned int v73 = *(_DWORD *)(v21 + 216) >> 7;
            if (v73 >= 0x1E) {
              LOBYTE(v73) = 30;
            }
            uint64_t v74 = 4096 << v73;
            unint64_t v23 = (unint64_t)operator new(4096 << v73, (std::align_val_t)8uLL);
            unsigned int v75 = *(_DWORD *)(v21 + 216);
            if (v75 >= *(_DWORD *)(v21 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v21 + 208) + 8 * v75) = v23;
            ++*(_DWORD *)(v21 + 216);
            *(void *)(v21 + 200) = v23 + v74;
          }
          else
          {
            unint64_t v23 = (v22 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v21 + 192) = v23 + 24;
          int v24 = *(unsigned __int8 *)(*(void *)(v21 + 152) + 18) << 16;
          *(unsigned char *)unint64_t v23 = 2;
          *(_DWORD *)(v23 + 1) = v24 | (*(unsigned __int8 *)(v23 + 4) << 24);
          *(void *)(v23 + 8) = 0;
          *(void *)(v23 + 16) = Symbol;
        }
        else
        {
          uint64_t v33 = (int)v103;
          uint64_t v34 = *(void *)(a1 + 8);
          *(void *)(v34 + 272) += 24;
          uint64_t v35 = *(void *)(v34 + 192);
          if (((v35 + 7) & 0xFFFFFFFFFFFFFFF8) - v35 + 24 > *(void *)(v34 + 200) - v35)
          {
            unsigned int v85 = *(_DWORD *)(v34 + 216) >> 7;
            if (v85 >= 0x1E) {
              LOBYTE(v85) = 30;
            }
            uint64_t v86 = 4096 << v85;
            unint64_t v23 = (unint64_t)operator new(4096 << v85, (std::align_val_t)8uLL);
            unsigned int v87 = *(_DWORD *)(v34 + 216);
            if (v87 >= *(_DWORD *)(v34 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v34 + 208) + 8 * v87) = v23;
            ++*(_DWORD *)(v34 + 216);
            *(void *)(v34 + 200) = v23 + v86;
          }
          else
          {
            unint64_t v23 = (v35 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v34 + 192) = v23 + 24;
          *(unsigned char *)unint64_t v23 = 1;
          *(_DWORD *)(v23 + 1) = *(unsigned __int8 *)(v23 + 4) << 24;
          *(void *)(v23 + 8) = 0;
          *(void *)(v23 + 16) = v33;
        }
      }
      else
      {
        unint64_t v23 = 0;
      }
      if (*((void *)&v103 + 1))
      {
        if (__sz[0])
        {
          size_t v36 = strlen((const char *)__sz[0]);
          size_t v37 = *(llvm::MCContext **)(a1 + 8);
          __int16 v100 = 261;
          unint64_t v98 = __sz[0];
          size_t v99 = v36;
          uint64_t v38 = llvm::MCContext::getOrCreateSymbol(v37, (unsigned __int8 ***)&v98);
          uint64_t v39 = *(void *)(a1 + 8);
          *(void *)(v39 + 272) += 24;
          uint64_t v40 = *(void *)(v39 + 192);
          if (((v40 + 7) & 0xFFFFFFFFFFFFFFF8) - v40 + 24 > *(void *)(v39 + 200) - v40)
          {
            unsigned int v76 = *(_DWORD *)(v39 + 216) >> 7;
            if (v76 >= 0x1E) {
              LOBYTE(v76) = 30;
            }
            uint64_t v77 = 4096 << v76;
            unint64_t v41 = (unint64_t)operator new(4096 << v76, (std::align_val_t)8uLL);
            unsigned int v78 = *(_DWORD *)(v39 + 216);
            if (v78 >= *(_DWORD *)(v39 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v39 + 208) + 8 * v78) = v41;
            ++*(_DWORD *)(v39 + 216);
            *(void *)(v39 + 200) = v41 + v77;
          }
          else
          {
            unint64_t v41 = (v40 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v39 + 192) = v41 + 24;
          int v42 = *(unsigned __int8 *)(*(void *)(v39 + 152) + 18) << 16;
          *(unsigned char *)unint64_t v41 = 2;
          *(_DWORD *)(v41 + 1) = v42 | (*(unsigned __int8 *)(v41 + 4) << 24);
          *(void *)(v41 + 8) = 0;
          *(void *)(v41 + 16) = v38;
        }
        else
        {
          uint64_t v43 = SLODWORD(__sz[1]);
          uint64_t v44 = *(void *)(a1 + 8);
          *(void *)(v44 + 272) += 24;
          uint64_t v45 = *(void *)(v44 + 192);
          if (((v45 + 7) & 0xFFFFFFFFFFFFFFF8) - v45 + 24 > *(void *)(v44 + 200) - v45)
          {
            unsigned int v88 = *(_DWORD *)(v44 + 216) >> 7;
            if (v88 >= 0x1E) {
              LOBYTE(v88) = 30;
            }
            uint64_t v89 = 4096 << v88;
            unint64_t v41 = (unint64_t)operator new(4096 << v88, (std::align_val_t)8uLL);
            unsigned int v90 = *(_DWORD *)(v44 + 216);
            if (v90 >= *(_DWORD *)(v44 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v44 + 208) + 8 * v90) = v41;
            ++*(_DWORD *)(v44 + 216);
            *(void *)(v44 + 200) = v41 + v89;
          }
          else
          {
            unint64_t v41 = (v45 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v44 + 192) = v41 + 24;
          *(unsigned char *)unint64_t v41 = 1;
          *(_DWORD *)(v41 + 1) = *(unsigned __int8 *)(v41 + 4) << 24;
          *(void *)(v41 + 8) = 0;
          *(void *)(v41 + 16) = v43;
        }
      }
      else
      {
        unint64_t v41 = 0;
      }
      uint64_t v46 = v105;
      if ((void)v105)
      {
        uint64_t v47 = *(void *)(a1 + 8);
        *(void *)(v47 + 272) += 24;
        uint64_t v48 = *(void *)(v47 + 192);
        if (((v48 + 7) & 0xFFFFFFFFFFFFFFF8) - v48 + 24 > *(void *)(v47 + 200) - v48)
        {
          unsigned int v70 = *(_DWORD *)(v47 + 216) >> 7;
          if (v70 >= 0x1E) {
            LOBYTE(v70) = 30;
          }
          uint64_t v71 = 4096 << v70;
          unint64_t v49 = (unint64_t)operator new(4096 << v70, (std::align_val_t)8uLL);
          unsigned int v72 = *(_DWORD *)(v47 + 216);
          if (v72 >= *(_DWORD *)(v47 + 220)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(v47 + 208) + 8 * v72) = v49;
          ++*(_DWORD *)(v47 + 216);
          *(void *)(v47 + 200) = v49 + v71;
        }
        else
        {
          unint64_t v49 = (v48 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(v47 + 192) = v49 + 24;
        *(unsigned char *)unint64_t v49 = 1;
        *(_DWORD *)(v49 + 1) = *(unsigned __int8 *)(v49 + 4) << 24;
        *(void *)(v49 + 8) = 0;
        *(void *)(v49 + 16) = v46;
        if (v41) {
          goto LABEL_34;
        }
      }
      else
      {
        unint64_t v49 = 0;
        if (v41)
        {
LABEL_34:
          uint64_t v50 = *(void *)(a1 + 8);
          if (v23)
          {
            *(void *)(v50 + 272) += 32;
            uint64_t v51 = *(void *)(v50 + 192);
            if (((v51 + 7) & 0xFFFFFFFFFFFFFFF8) - v51 + 32 > *(void *)(v50 + 200) - v51)
            {
              unsigned int v79 = *(_DWORD *)(v50 + 216) >> 7;
              if (v79 >= 0x1E) {
                LOBYTE(v79) = 30;
              }
              uint64_t v80 = 4096 << v79;
              unint64_t v52 = (unint64_t)operator new(4096 << v79, (std::align_val_t)8uLL);
              unsigned int v81 = *(_DWORD *)(v50 + 216);
              if (v81 >= *(_DWORD *)(v50 + 220)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)(v50 + 208) + 8 * v81) = v52;
              ++*(_DWORD *)(v50 + 216);
              *(void *)(v50 + 200) = v52 + v80;
            }
            else
            {
              unint64_t v52 = (v51 + 7) & 0xFFFFFFFFFFFFFFF8;
            }
            *(void *)(v50 + 192) = v52 + 32;
            *(unsigned char *)unint64_t v52 = 0;
            *(_DWORD *)(v52 + 1) = (*(unsigned __int8 *)(v52 + 4) << 24) | 0x12;
            *(void *)(v52 + 8) = 0;
            *(void *)(v52 + 16) = v23;
            int v53 = (unint64_t *)(v52 + 24);
          }
          else
          {
            unint64_t v52 = sub_1CB906F34((uint64_t *)(v50 + 192), 24, 3);
            *(unsigned char *)unint64_t v52 = 3;
            *(_DWORD *)(v52 + 1) = (*(unsigned __int8 *)(v52 + 4) << 24) | 1;
            *(void *)(v52 + 8) = 0;
            int v53 = (unint64_t *)(v52 + 16);
          }
          *int v53 = v41;
          if (!v49)
          {
            unint64_t v49 = v52;
LABEL_71:
            uint64_t result = (*(uint64_t (**)(void, unint64_t, void))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), v49, DWORD2(v105));
            if (result)
            {
              unsigned int v68 = *(_DWORD *)(a2 + 24);
              if (v68 >= *(_DWORD *)(a2 + 28)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v69 = (void *)(*(void *)(a2 + 16) + 16 * v68);
              *uint64_t v69 = 5;
              v69[1] = result;
              ++*(_DWORD *)(a2 + 24);
              return 1;
            }
            return result;
          }
          uint64_t v57 = *(void *)(a1 + 8);
          *(void *)(v57 + 272) += 32;
          uint64_t v58 = *(void *)(v57 + 192);
          if (((v58 + 7) & 0xFFFFFFFFFFFFFFF8) - v58 + 32 > *(void *)(v57 + 200) - v58)
          {
            unsigned int v82 = *(_DWORD *)(v57 + 216) >> 7;
            if (v82 >= 0x1E) {
              LOBYTE(v82) = 30;
            }
            uint64_t v83 = 4096 << v82;
            unint64_t v23 = (unint64_t)operator new(4096 << v82, (std::align_val_t)8uLL);
            unsigned int v84 = *(_DWORD *)(v57 + 216);
            if (v84 >= *(_DWORD *)(v57 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v57 + 208) + 8 * v84) = v23;
            ++*(_DWORD *)(v57 + 216);
            *(void *)(v57 + 200) = v23 + v83;
          }
          else
          {
            unint64_t v23 = (v58 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v57 + 192) = v23 + 32;
          *(unsigned char *)unint64_t v23 = 0;
          *(_DWORD *)(v23 + 1) = *(unsigned __int8 *)(v23 + 4) << 24;
          *(void *)(v23 + 8) = 0;
          *(void *)(v23 + 16) = v52;
          *(void *)(v23 + 24) = v49;
LABEL_49:
          unint64_t v49 = v23;
          goto LABEL_71;
        }
      }
      if (!v23)
      {
        if (!v49)
        {
          uint64_t v66 = *(void *)(a1 + 8);
          *(void *)(v66 + 272) += 24;
          uint64_t v67 = *(void *)(v66 + 192);
          if (((v67 + 7) & 0xFFFFFFFFFFFFFFF8) - v67 + 24 > *(void *)(v66 + 200) - v67)
          {
            unsigned int v95 = *(_DWORD *)(v66 + 216) >> 7;
            if (v95 >= 0x1E) {
              LOBYTE(v95) = 30;
            }
            uint64_t v96 = 4096 << v95;
            unint64_t v49 = (unint64_t)operator new(4096 << v95, (std::align_val_t)8uLL);
            unsigned int v97 = *(_DWORD *)(v66 + 216);
            if (v97 >= *(_DWORD *)(v66 + 220)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(v66 + 208) + 8 * v97) = v49;
            ++*(_DWORD *)(v66 + 216);
            *(void *)(v66 + 200) = v49 + v96;
          }
          else
          {
            unint64_t v49 = (v67 + 7) & 0xFFFFFFFFFFFFFFF8;
          }
          *(void *)(v66 + 192) = v49 + 24;
          *(unsigned char *)unint64_t v49 = 1;
          *(_DWORD *)(v49 + 1) = *(unsigned __int8 *)(v49 + 4) << 24;
          *(void *)(v49 + 8) = 0;
          *(void *)(v49 + 16) = 0;
        }
        goto LABEL_71;
      }
      if (v49)
      {
        uint64_t v54 = *(void *)(a1 + 8);
        *(void *)(v54 + 272) += 32;
        uint64_t v55 = *(void *)(v54 + 192);
        if (((v55 + 7) & 0xFFFFFFFFFFFFFFF8) - v55 + 32 > *(void *)(v54 + 200) - v55)
        {
          unsigned int v92 = *(_DWORD *)(v54 + 216) >> 7;
          if (v92 >= 0x1E) {
            LOBYTE(v92) = 30;
          }
          uint64_t v93 = 4096 << v92;
          unint64_t v56 = (unint64_t)operator new(4096 << v92, (std::align_val_t)8uLL);
          unsigned int v94 = *(_DWORD *)(v54 + 216);
          if (v94 >= *(_DWORD *)(v54 + 220)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)(v54 + 208) + 8 * v94) = v56;
          ++*(_DWORD *)(v54 + 216);
          *(void *)(v54 + 200) = v56 + v93;
        }
        else
        {
          unint64_t v56 = (v55 + 7) & 0xFFFFFFFFFFFFFFF8;
        }
        *(void *)(v54 + 192) = v56 + 32;
        *(unsigned char *)unint64_t v56 = 0;
        *(_DWORD *)(v56 + 1) = *(unsigned __int8 *)(v56 + 4) << 24;
        *(void *)(v56 + 8) = 0;
        *(void *)(v56 + 16) = v23;
        *(void *)(v56 + 24) = v49;
        unint64_t v49 = v56;
        goto LABEL_71;
      }
      goto LABEL_49;
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MCExternalSymbolizer::tryAddingPcLoadReferenceComment(llvm::raw_ostream *this, llvm::raw_ostream *a2, uint64_t a3, uint64_t a4)
{
  int v4 = (uint64_t (*)(void, uint64_t, uint64_t *, uint64_t, char **))*((void *)this + 4);
  if (v4)
  {
    __s = 0;
    uint64_t v26 = 2;
    this = (llvm::raw_ostream *)v4(*((void *)this + 5), a3, &v26, a4, &__s);
    switch(v26)
    {
      case 2:
        uint64_t v6 = (void *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v6 <= 0x1CuLL)
        {
          BOOL v7 = "literal pool symbol address: ";
          unint64_t v8 = a2;
          size_t v9 = 29;
          goto LABEL_22;
        }
        qmemcpy(v6, "literal pool symbol address: ", 29);
        uint64_t v24 = *((void *)a2 + 4) + 29;
        goto LABEL_45;
      case 3:
        uint64_t v10 = *((void *)a2 + 4);
        if ((unint64_t)(*((void *)a2 + 3) - v10) > 0x12)
        {
          *(_DWORD *)(v10 + 15) = 572537458;
          *(_OWORD *)uint64_t v10 = *(_OWORD *)"literal pool for: \"";
          *((void *)a2 + 4) += 19;
        }
        else
        {
          llvm::raw_ostream::write(a2, "literal pool for: \"", 0x13uLL);
        }
        if (__s) {
          size_t v11 = strlen(__s);
        }
        else {
          size_t v11 = 0;
        }
        this = llvm::raw_ostream::write_escaped(a2, __s, v11, 0);
        goto LABEL_28;
      case 4:
        uint64_t v12 = (void *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v12 > 0x14uLL)
        {
          qmemcpy(v12, "Objc cfstring ref: @\"", 21);
          *((void *)a2 + 4) += 21;
        }
        else
        {
          this = llvm::raw_ostream::write(a2, "Objc cfstring ref: @\"", 0x15uLL);
          a2 = this;
        }
        if (__s)
        {
          unint64_t v13 = strlen(__s);
          this = (llvm::raw_ostream *)*((void *)a2 + 4);
          if (v13 <= *((void *)a2 + 3) - (void)this)
          {
            if (v13)
            {
              this = (llvm::raw_ostream *)memcpy(this, __s, v13);
              *((void *)a2 + 4) += v13;
            }
          }
          else
          {
            this = llvm::raw_ostream::write(a2, __s, v13);
            a2 = this;
          }
        }
LABEL_28:
        uint64_t v22 = (unsigned char *)*((void *)a2 + 4);
        if (*((unsigned char **)a2 + 3) == v22)
        {
          int v20 = "\"";
          int v19 = a2;
          size_t v21 = 1;
          goto LABEL_30;
        }
        *uint64_t v22 = 34;
        uint64_t v23 = *((void *)a2 + 4) + 1;
        goto LABEL_35;
      case 5:
        uint64_t v14 = (void *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v14 <= 0xDuLL)
        {
          BOOL v7 = "Objc message: ";
          unint64_t v8 = a2;
          size_t v9 = 14;
          goto LABEL_22;
        }
        qmemcpy(v14, "Objc message: ", 14);
        uint64_t v24 = *((void *)a2 + 4) + 14;
        goto LABEL_45;
      case 6:
        uint64_t v15 = *((void *)a2 + 4);
        if ((unint64_t)(*((void *)a2 + 3) - v15) <= 0x11)
        {
          BOOL v7 = "Objc message ref: ";
          unint64_t v8 = a2;
          size_t v9 = 18;
          goto LABEL_22;
        }
        *(_WORD *)(v15 + 16) = 8250;
        *(_OWORD *)uint64_t v15 = *(_OWORD *)"Objc message ref: ";
        uint64_t v24 = *((void *)a2 + 4) + 18;
        goto LABEL_45;
      case 7:
        uint64_t v16 = *((void *)a2 + 4);
        if ((unint64_t)(*((void *)a2 + 3) - v16) <= 0x12)
        {
          BOOL v7 = "Objc selector ref: ";
          unint64_t v8 = a2;
          size_t v9 = 19;
          goto LABEL_22;
        }
        *(_DWORD *)(v16 + 15) = 540698213;
        *(_OWORD *)uint64_t v16 = *(_OWORD *)"Objc selector ref: ";
        uint64_t v24 = *((void *)a2 + 4) + 19;
        goto LABEL_45;
      case 8:
        int v17 = (_OWORD *)*((void *)a2 + 4);
        if (*((void *)a2 + 3) - (void)v17 > 0xFuLL)
        {
          *int v17 = *(_OWORD *)"Objc class ref: ";
          uint64_t v24 = *((void *)a2 + 4) + 16;
LABEL_45:
          *((void *)a2 + 4) = v24;
        }
        else
        {
          BOOL v7 = "Objc class ref: ";
          unint64_t v8 = a2;
          size_t v9 = 16;
LABEL_22:
          this = llvm::raw_ostream::write(v8, v7, v9);
          a2 = this;
        }
        if (__s)
        {
          unint64_t v18 = strlen(__s);
          this = (llvm::raw_ostream *)*((void *)a2 + 4);
          if (v18 <= *((void *)a2 + 3) - (void)this)
          {
            if (v18)
            {
              this = (llvm::raw_ostream *)memcpy(this, __s, v18);
              uint64_t v23 = *((void *)a2 + 4) + v18;
LABEL_35:
              *((void *)a2 + 4) = v23;
            }
          }
          else
          {
            int v19 = a2;
            int v20 = __s;
            size_t v21 = v18;
LABEL_30:
            this = llvm::raw_ostream::write(v19, v20, v21);
          }
        }
        break;
      default:
        return this;
    }
  }
  return this;
}

void llvm::createMCSymbolizer()
{
}

void *sub_1CCC07D64(void *a1)
{
  *a1 = &unk_1F2632260;
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1CCC07DD4(void *a1)
{
  *a1 = &unk_1F2632260;
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

void *llvm::MCRelocationInfo::MCRelocationInfo(void *this, llvm::MCContext *a2)
{
  *this = &unk_1F2632238;
  this[1] = a2;
  return this;
}

{
  *this = &unk_1F2632238;
  this[1] = a2;
  return this;
}

void llvm::MCRelocationInfo::~MCRelocationInfo(llvm::MCRelocationInfo *this)
{
}

const llvm::MCExpr *llvm::MCRelocationInfo::createExprForCAPIVariantKind(llvm::MCRelocationInfo *this, const llvm::MCExpr *a2, int a3)
{
  if (a3) {
    return 0;
  }
  else {
    return a2;
  }
}

void llvm::createMCRelocationInfo(llvm *this, const llvm::Triple *a2, llvm::MCContext *a3)
{
}

void llvm::MCSymbolizer::~MCSymbolizer(llvm::MCSymbolizer *this)
{
  *(void *)this = &unk_1F2632260;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

void llvm::initializeObjCARCOpts(llvm *this, llvm::PassRegistry *a2)
{
  llvm::initializeObjCARCAAWrapperPassPass(this, a2);
  llvm::initializeObjCARCAPElimPass(this, v3);
  llvm::initializeObjCARCExpandPass(this, v4);
  llvm::initializeObjCARCContractLegacyPassPass(this, v5);
  llvm::initializeObjCARCOptLegacyPassPass(this, v6);

  llvm::initializePAEvalPass(this, v7);
}

uint64_t llvm::objcarc::BundledRetainClaimRVs::insertAfterInvokes(llvm::objcarc::BundledRetainClaimRVs *this, llvm::Function *a2, llvm::DominatorTree *a3)
{
  uint64_t v3 = (char *)a2 + 72;
  int v4 = (char *)*((void *)a2 + 10);
  if (v4 == (char *)a2 + 72)
  {
    int v8 = 0;
    unsigned __int8 v7 = 0;
  }
  else
  {
    unsigned __int8 v7 = 0;
    int v8 = 0;
    do
    {
      if (v4) {
        size_t v9 = v4 - 24;
      }
      else {
        size_t v9 = 0;
      }
      uint64_t v10 = (char *)*((void *)v9 + 5);
      if (v10 != v9 + 40)
      {
        uint64_t v11 = v10 ? (uint64_t)(v10 - 24) : 0;
        unsigned int v12 = *(unsigned __int8 *)(v11 + 16) - 40;
        uint64_t v13 = v12 >= 0xFFFFFFF5 ? v11 : 0;
        if (v10)
        {
          if (*(unsigned char *)(v13 + 16) == 33
            && v12 >= 0xFFFFFFF5
            && *(unsigned char *)(**(void **)(*(void *)(v13 + 72) + 16) + 8) != 7)
          {
            sub_1CC233A58((char *)v13, 6, (uint64_t *)&v26);
            if ((_BYTE)v29)
            {
              uint64_t v15 = *(llvm::BasicBlock **)(v13 - 96);
              if (!llvm::BasicBlock::getSinglePredecessor(v15))
              {
                uint64_t v26 = a3;
                uint64_t v28 = 0;
                uint64_t v29 = 0;
                uint64_t v27 = 0;
                int v30 = 0;
                int v8 = 1;
                char v31 = 1;
                v25[16] = 257;
                uint64_t v15 = (llvm::BasicBlock *)llvm::SplitCriticalEdge((llvm::Instruction *)v13, 0, (uint64_t)&v26, (llvm::Twine *)v25);
              }
              uint64_t v16 = (void *)((char *)v15 + 40);
              for (uint64_t i = (void *)*((void *)v15 + 6); i != v16; uint64_t i = (void *)i[1])
              {
                unint64_t v18 = i - 3;
                if (!i) {
                  unint64_t v18 = 0;
                }
                if (*((unsigned char *)v18 + 16) != 83)
                {
                  unsigned int v19 = *((unsigned __int8 *)i - 8) - 38;
                  BOOL v20 = v19 > 0x38;
                  uint64_t v21 = (1 << v19) & 0x100060000000001;
                  if (v20 || v21 == 0) {
                    uint64_t v16 = i;
                  }
                  else {
                    uint64_t v16 = (void *)i[1];
                  }
                  break;
                }
              }
              if (v16) {
                uint64_t v23 = (uint64_t **)(v16 - 3);
              }
              else {
                uint64_t v23 = 0;
              }
              uint64_t v26 = 0;
              uint64_t v27 = 0;
              LODWORD(v28) = 0;
              llvm::objcarc::BundledRetainClaimRVs::insertRVCallWithColors((uint64_t)this, v23, (char *)v13, (uint64_t)&v26);
              sub_1CC0CADD4((uint64_t *)&v26);
              unsigned __int8 v7 = 1;
            }
          }
        }
      }
      int v4 = (char *)*((void *)v4 + 1);
    }
    while (v4 != v3);
  }
  return v7 | (v8 << 8);
}

void llvm::initializeObjCARCOptLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCEF2F8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CCC0824C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCEF2F8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CCC0824C(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CCC082EC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCEF2F0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F2632298;
  *(unsigned char *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 204) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 212) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 220) = 0;
  *(void *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 232) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCEF2F8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCC0824C;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCEF2F8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

BOOL sub_1CCC083DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v849[16] = *MEMORY[0x1E4F143B8];
  if (!llvm::objcarc::EnableARCOpts) {
    return 0;
  }
  uint64_t v7 = a1;
  *(_WORD *)a1 = 0;
  v802[0] = 0;
  v802[1] = 0;
  int v803 = 0;
  uint64_t v804 = a1 + 64;
  __int16 v805 = 0;
  *(void *)(a1 + 192) = v802;
  __int16 v8 = llvm::objcarc::BundledRetainClaimRVs::insertAfterInvokes((llvm::objcarc::BundledRetainClaimRVs *)v802, (llvm::Function *)a2, 0);
  *(unsigned char *)v7 |= v8 & 1;
  char v10 = HIBYTE(v8) & 1 | *(unsigned char *)(v7 + 1);
  *(void *)(v7 + 8) = a3;
  v774 = (uint64_t *)(v7 + 8);
  *(unsigned char *)(v7 + 1) = v10;
  *(_DWORD *)(v7 + 204) = 0;
  long long v824 = 0uLL;
  LODWORD(v825) = 0;
  if ((*(unsigned char *)(a2 + 18) & 8) != 0)
  {
    int v11 = *(_DWORD *)(a2 + 20);
    unsigned int v12 = (v11 & 0x40000000) != 0 ? *(llvm::Value ***)(a2 - 8) : (llvm::Value **)(a2 - 32 * (v11 & 0x7FFFFFF));
    unsigned int v13 = llvm::classifyEHPersonality(*v12, v9);
    if (v13 - 7 < 4 || v13 == 12)
    {
      llvm::colorEHFunclets((llvm *)a2, (uint64_t)v833);
      sub_1CD4B08AC((uint64_t *)&v824, (uint64_t *)v833);
      sub_1CC0CADD4((uint64_t *)v833);
    }
  }
  uint64_t v14 = (void *)(a2 + 72);
  uint64_t v766 = a2;
  uint64_t v15 = *(void **)(a2 + 80);
  v793 = v14;
  uint64_t v782 = v7;
  if (v15 != v14)
  {
    while (1)
    {
      uint64_t v16 = v15 - 3;
      if (!v15) {
        uint64_t v16 = 0;
      }
      int v17 = (void *)v16[6];
      if (v17 != v16 + 5) {
        break;
      }
      uint64_t v15 = (void *)v15[1];
      if (v15 == v793) {
        goto LABEL_115;
      }
    }
    unint64_t v18 = 0;
    while (1)
    {
      v794 = v18;
      unsigned int v19 = v17;
      int v17 = (void *)v17[1];
      BOOL v20 = v15 - 3;
      if (!v15) {
        BOOL v20 = 0;
      }
      if (v17 == v20 + 5)
      {
        uint64_t v21 = (void *)v15[1];
        uint64_t v15 = v793;
        if (v21 != v793)
        {
          while (1)
          {
            uint64_t v22 = v21 - 3;
            if (!v21) {
              uint64_t v22 = 0;
            }
            int v17 = (void *)v22[6];
            if (v17 != v22 + 5) {
              break;
            }
            uint64_t v21 = (void *)v21[1];
            if (v21 == v793)
            {
              uint64_t v15 = v793;
              goto LABEL_28;
            }
          }
          uint64_t v15 = v21;
        }
      }
LABEL_28:
      if (v19) {
        uint64_t v23 = (uint64_t)(v19 - 3);
      }
      else {
        uint64_t v23 = 0;
      }
      int v24 = *(unsigned __int8 *)(v23 + 16);
      if (v24 == 84) {
        uint64_t v25 = v23;
      }
      else {
        uint64_t v25 = 0;
      }
      if (v19)
      {
        if (v24 == 84 && *(unsigned char *)(**(void **)(*(void *)(v25 + 72) + 16) + 8) != 7)
        {
          sub_1CC233A58((char *)v25, 6, (uint64_t *)v833);
          if (v833[24])
          {
            if (v17) {
              uint64_t v26 = (uint64_t **)(v17 - 3);
            }
            else {
              uint64_t v26 = 0;
            }
            llvm::objcarc::BundledRetainClaimRVs::insertRVCall(*(llvm::objcarc::BundledRetainClaimRVs **)(v7 + 192), v26, (llvm::CallBase *)v25);
            *(unsigned char *)uint64_t v7 = 1;
          }
        }
      }
      unsigned int v27 = sub_1CD4B36C8(v23, v9);
      unsigned int v28 = v27;
      unint64_t v18 = v794;
      if (v27 > 0x18) {
        goto LABEL_66;
      }
      if (((1 << v27) & 0x1A00000) == 0) {
        break;
      }
      if (!v794) {
        goto LABEL_112;
      }
      int v30 = *(unsigned __int8 *)(v23 + 16);
      if ((v30 - 29) >= 0xB)
      {
        unsigned int v31 = v30 - 33;
        if (v31 > 0x33) {
          goto LABEL_112;
        }
        if (((1 << v31) & 0x8000000000041) == 0) {
          goto LABEL_112;
        }
        uint64_t v32 = *(v19 - 7);
        if (v32)
        {
          if (!*(unsigned char *)(v32 + 16) && *(void *)(v32 + 24) == v19[6] && *(_DWORD *)(v32 + 36)) {
            goto LABEL_112;
          }
        }
      }
      uint64_t v33 = v7;
      uint64_t v34 = v794;
      int v35 = 6;
      size_t v36 = 0;
LABEL_111:
      sub_1CCC0DD80(v33, (const llvm::Function *)&v824, v34, v35, v36);
      unint64_t v18 = 0;
LABEL_112:
      if (v15 == v793)
      {
        if (v18) {
          sub_1CCC0DD80(v7, (const llvm::Function *)&v824, v18, 6, 0);
        }
        goto LABEL_115;
      }
    }
    if (((1 << v27) & 6) != 0)
    {
      v786 = (llvm::ValueAsMetadata *)v23;
      if (!v794)
      {
        uint64_t v29 = 0;
        goto LABEL_110;
      }
      if (!v19) {
        goto LABEL_63;
      }
      if (*(unsigned char *)(v23 + 16) != 84) {
        goto LABEL_63;
      }
      size_t v37 = *(uint64_t **)(v7 + 192);
      *(void *)v833 = v23;
      v845 = 0;
      unsigned int v38 = v28;
      char v39 = sub_1CD3C8538(v37, v833, &v845);
      unsigned int v28 = v38;
      uint64_t v40 = 0;
      uint64_t v29 = 0;
      if ((v39 & 1) == 0)
      {
LABEL_63:
        unsigned int v783 = v28;
        uint64_t v29 = sub_1CD4B3548(*((llvm::Value **)v786 - 4 * (*((_DWORD *)v786 + 5) & 0x7FFFFFF)));
        unint64_t v41 = sub_1CD4B3548((llvm::Value *)v794[-4 * (*((_DWORD *)v794 + 5) & 0x7FFFFFF)]);
        if (v29 == v41) {
          goto LABEL_64;
        }
        uint64_t v40 = v41;
        if (!v29 || *((unsigned char *)v29 + 16) != 83) {
          goto LABEL_108;
        }
        v790 = v41;
        *(void *)v833 = &v833[16];
        *(void *)&v833[8] = 0x400000000;
        if (*(void *)(*((void *)v29 + 5) + 40) != *((void *)v29 + 5) + 40)
        {
          uint64_t v44 = *(void *)(*((void *)v29 + 5) + 48);
          uint64_t v45 = v44 - 24;
          uint64_t v46 = v44 ? v44 - 24 : 0;
          if (v44 && *(unsigned char *)(v46 + 16) == 83)
          {
            do
            {
              if ((llvm::Value *)v45 != v29)
              {
                int v47 = *((_DWORD *)v29 + 5);
                uint64_t v48 = v47 & 0x7FFFFFF;
                if ((v47 & 0x7FFFFFF) != 0)
                {
                  uint64_t v49 = 0;
                  uint64_t v50 = 0;
                  while (1)
                  {
                    int v51 = *((_DWORD *)v29 + 5);
                    unint64_t v52 = (v51 & 0x40000000) != 0
                        ? (llvm::Value *)*((void *)v29 - 1)
                        : (llvm::Value *)((char *)v29 - 32 * (v51 & 0x7FFFFFF));
                    uint64_t v53 = *((void *)v52 + 4 * *((unsigned int *)v29 + 15) + v50);
                    uint64_t v54 = llvm::Value::stripPointerCasts(*(llvm::Value **)((char *)v52 + v49));
                    uint64_t v55 = (llvm::Value *)sub_1CBF73380(v45, v53);
                    if (v54 != llvm::Value::stripPointerCasts(v55)) {
                      break;
                    }
                    ++v50;
                    v49 += 32;
                    if (v48 == v50) {
                      goto LABEL_87;
                    }
                  }
                }
                else
                {
                  LODWORD(v50) = 0;
                }
                if (v50 == v48)
                {
LABEL_87:
                  if (*(unsigned int *)&v833[8] >= (unint64_t)*(unsigned int *)&v833[12]) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(*(void *)v833 + 8 * *(unsigned int *)&v833[8]) = v45;
                  ++*(_DWORD *)&v833[8];
                }
              }
              uint64_t v56 = *(void *)(v45 + 32);
              uint64_t v45 = v56 - 24;
              if (v56) {
                uint64_t v57 = v56 - 24;
              }
              else {
                uint64_t v57 = 0;
              }
            }
            while (v56 && *(unsigned char *)(v57 + 16) == 83);
            uint64_t v58 = *(unsigned int *)&v833[8];
            if (*(_DWORD *)&v833[8])
            {
              uint64_t v60 = 8 * *(unsigned int *)&v833[8];
              uint64_t v59 = *(llvm::Value ***)v833;
              uint64_t v7 = v782;
              while (*v59 != v790)
              {
                ++v59;
                v60 -= 8;
                if (!v60)
                {
                  uint64_t v59 = (llvm::Value **)(*(void *)v833 + 8 * *(unsigned int *)&v833[8]);
                  break;
                }
              }
            }
            else
            {
              uint64_t v58 = 0;
              uint64_t v59 = *(llvm::Value ***)v833;
              uint64_t v7 = v782;
            }
            uint64_t v61 = ((uint64_t)v59 - *(void *)v833) >> 3;
            if (*(unsigned char **)v833 != &v833[16]) {
              free(*(void **)v833);
            }
            BOOL v132 = v61 == v58;
            unint64_t v18 = v794;
            uint64_t v40 = v790;
            if (!v132)
            {
LABEL_64:
              llvm::Value::doRAUW((llvm::ValueAsMetadata *)v18, (llvm::Value *)v18[-4 * (*((_DWORD *)v18 + 5) & 0x7FFFFFF)], (llvm::Value *)1);
              *(unsigned char *)uint64_t v7 = 1;
              int v42 = (llvm::ValueAsMetadata *)v18;
              uint64_t v43 = (llvm::Value *)v18[-4 * (*((_DWORD *)v18 + 5) & 0x7FFFFFF)];
              if (!*((void *)v42 + 1)) {
                llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
              }
              llvm::Value::doRAUW(v42, v43, (llvm::Value *)1);
              llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
            }
LABEL_108:
            unsigned int v28 = v783;
            goto LABEL_109;
          }
        }
        uint64_t v7 = v782;
        unsigned int v28 = v783;
        uint64_t v40 = v41;
      }
    }
    else
    {
      if (v27 == 6)
      {
        if (v794) {
          sub_1CCC0DD80(v7, (const llvm::Function *)&v824, v794, 6, 0);
        }
        unint64_t v18 = (uint64_t **)(v19 - 3);
        goto LABEL_112;
      }
LABEL_66:
      v786 = (llvm::ValueAsMetadata *)v23;
      uint64_t v40 = 0;
      uint64_t v29 = 0;
      if (!v794)
      {
LABEL_110:
        uint64_t v33 = v7;
        uint64_t v34 = (uint64_t **)v786;
        int v35 = v28;
        size_t v36 = v29;
        goto LABEL_111;
      }
    }
LABEL_109:
    size_t v62 = v18;
    unsigned int v63 = v28;
    sub_1CCC0DD80(v7, (const llvm::Function *)&v824, v62, 6, v40);
    unsigned int v28 = v63;
    goto LABEL_110;
  }
LABEL_115:
  sub_1CC0CADD4((uint64_t *)&v824);
  if ((*(_DWORD *)(v7 + 204) & 0x7F000) != 0)
  {
    v65 = *(void **)(v766 + 80);
    if (v65 != v793)
    {
      uint64_t v66 = v65 - 3;
      if (!v65) {
        uint64_t v66 = 0;
      }
      uint64_t v67 = (uint64_t *)v66[6];
      if (v67 == v66 + 5)
      {
        unsigned int v68 = *(void **)(v766 + 80);
        do
        {
          unsigned int v68 = (void *)v68[1];
          if (v68 == v793) {
            goto LABEL_194;
          }
          uint64_t v69 = v68 - 3;
          if (!v68) {
            uint64_t v69 = 0;
          }
          uint64_t v67 = (uint64_t *)v69[6];
        }
        while (v67 == v69 + 5);
      }
      else
      {
        unsigned int v68 = *(void **)(v766 + 80);
      }
      do
      {
        unsigned int v70 = v67;
        uint64_t v67 = (uint64_t *)v67[1];
        uint64_t v71 = v68 - 3;
        if (!v68) {
          uint64_t v71 = 0;
        }
        if (v67 == v71 + 5)
        {
          unsigned int v72 = (void *)v68[1];
          unsigned int v68 = v793;
          if (v72 != v793)
          {
            while (1)
            {
              unsigned int v73 = v72 - 3;
              if (!v72) {
                unsigned int v73 = 0;
              }
              uint64_t v67 = (uint64_t *)v73[6];
              if (v67 != v73 + 5) {
                break;
              }
              unsigned int v72 = (void *)v72[1];
              if (v72 == v793)
              {
                unsigned int v68 = v793;
                goto LABEL_137;
              }
            }
            unsigned int v68 = v72;
          }
        }
LABEL_137:
        if (v70) {
          uint64_t v74 = (uint64_t)(v70 - 3);
        }
        else {
          uint64_t v74 = 0;
        }
        int v75 = sub_1CD4B36C8(v74, v64);
        int v76 = v75;
        if (v75 == 15)
        {
          uint64_t v77 = v68;
          unsigned int v78 = v67;
          if (!*(void *)(v74 + 8)) {
            llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
          }
LABEL_148:
          while (1)
          {
            if (v77 != v793)
            {
              uint64_t v80 = v77 - 3;
              if (!v77) {
                uint64_t v80 = 0;
              }
              unsigned int v81 = (uint64_t *)v80[6];
              if (v78 != v81) {
                break;
              }
            }
            uint64_t v77 = (void *)*v77;
            unsigned int v79 = v77 - 3;
            if (!v77) {
              unsigned int v79 = 0;
            }
            unsigned int v78 = v79 + 5;
          }
          for (uint64_t i = (uint64_t *)*v78; ; uint64_t i = (uint64_t *)*i)
          {
            if (i == v81) {
              goto LABEL_182;
            }
            uint64_t v83 = *i ? (llvm::objcarc *)(*i - 24) : 0;
            unsigned int ARCInstKind = llvm::objcarc::GetARCInstKind(v83, v64);
            if (ARCInstKind > 0x18) {
              goto LABEL_182;
            }
            int v85 = 1 << ARCInstKind;
            if (((1 << ARCInstKind) & 0x1900080) == 0)
            {
              if ((v85 & 0x6000) != 0)
              {
                uint64_t v89 = *((void *)v83 - 4 * (*((_DWORD *)v83 + 5) & 0x7FFFFFF));
                uint64_t v90 = *v774;
                *(void *)v833 = *(void *)(v74 - 32 * (*(_DWORD *)(v74 + 20) & 0x7FFFFFF));
                *(void *)&v833[8] = -1;
                *(_OWORD *)&v833[16] = 0u;
                *(_OWORD *)v834 = 0u;
                *(void *)&long long v824 = v89;
                *((void *)&v824 + 1) = -1;
                long long v825 = 0u;
                long long v826 = 0u;
                int v91 = llvm::AAResults::alias(v90, (uint64_t)v833, (uint64_t)&v824);
                if ((v91 - 1) < 2) {
                  goto LABEL_182;
                }
                if (v91 == 3)
                {
                  *(unsigned char *)uint64_t v782 = 1;
                  if (v76 == 12)
                  {
                    uint64_t v92 = *(void *)(v782 + 88);
                    if (v92
                      || (uint64_t v93 = *(uint64_t ***)(v782 + 64),
                          llvm::Intrinsic::getType(*v93, 222, 0, 0),
                          Type = (llvm::PointerType *)llvm::Intrinsic::getType(*v93, 222, 0, 0),
                          llvm::Module::getOrInsertFunction((uint64_t)v93, "llvm.objc.retain", (const char *)0x10, Type, 0), unsigned int v95 = 0, v96 = 0, (*(void *)(v782 + 88) = v92) != 0))
                    {
                      uint64_t v96 = *(uint64_t ***)(v92 + 24);
                      unsigned int v95 = (uint64_t **)v92;
                    }
                    v791 = v95;
                    v795 = v96;
                    *(void *)&long long v824 = v83;
                    LOWORD(v834[0]) = 257;
                    unsigned int v97 = (char *)operator new(0x90uLL);
                    unint64_t v98 = v795;
                    size_t v99 = v97;
                    __int16 v100 = (llvm::Value *)(v97 + 64);
                    *((_DWORD *)v97 + 21) = *((_DWORD *)v97 + 21) & 0x38000000 | 2;
                    *(void *)unsigned int v97 = 0;
                    *((void *)v97 + 1) = 0;
                    *((void *)v97 + 2) = 0;
                    *((void *)v97 + 3) = v97 + 64;
                    *((void *)v97 + 4) = 0;
                    *((void *)v97 + 5) = 0;
                    *((void *)v97 + 6) = 0;
                    *((void *)v97 + 7) = v97 + 64;
                    *((void *)v97 + 8) = *v795[2];
                    *((void *)v97 + 9) = 0;
                    v97[80] = 84;
                    v97[81] = 0;
                    *((_WORD *)v97 + 41) = 0;
                    *((_DWORD *)v97 + 21) = 2;
                    *(_OWORD *)(v97 + 88) = 0u;
                    v101 = v97 + 88;
                    *((_DWORD *)v97 + 30) = 0;
                    *(_OWORD *)(v97 + 104) = 0u;
                    if (v70)
                    {
                      uint64_t v114 = v70[2];
                      *((void *)v97 + 13) = v114;
                      *(_WORD *)(v114 + 18) &= ~0x8000u;
                      if ((v97[87] & 0x10) != 0)
                      {
                        uint64_t v118 = *(void *)(v114 + 56);
                        if (v118)
                        {
                          v119 = *(llvm::ValueSymbolTable **)(v118 + 104);
                          if (v119)
                          {
                            llvm::ValueSymbolTable::reinsertValue(v119, v100);
                            unint64_t v98 = v795;
                          }
                        }
                      }
                      uint64_t v115 = *v70;
                      *((void *)v99 + 11) = *v70;
                      *((void *)v99 + 12) = v70;
                      *(void *)(v115 + 8) = v101;
                      *unsigned int v70 = (uint64_t)v101;
                    }
                    *((void *)v99 + 16) = 0;
                    llvm::CallInst::init((uint64_t ***)v100, v98, v791, (uint64_t *)&v824, 1, 0, 0, (const char **)v833);
                    *((_WORD *)v99 + 41) = *((_WORD *)v99 + 41) & 0xFFFC | 1;
                  }
                  v102 = (llvm::Value *)((void *)v83 - 4 * (*((_DWORD *)v83 + 5) & 0x7FFFFFF))[4];
                  long long v103 = (llvm::ValueAsMetadata *)v74;
LABEL_181:
                  llvm::Value::doRAUW(v103, v102, (llvm::Value *)1);
                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                }
              }
              else
              {
                if ((v85 & 0x9000) == 0) {
                  goto LABEL_182;
                }
                uint64_t v86 = *((void *)v83 - 4 * (*((_DWORD *)v83 + 5) & 0x7FFFFFF));
                uint64_t v87 = *v774;
                *(void *)v833 = *(void *)(v74 - 32 * (*(_DWORD *)(v74 + 20) & 0x7FFFFFF));
                *(void *)&v833[8] = -1;
                *(_OWORD *)&v833[16] = 0u;
                *(_OWORD *)v834 = 0u;
                *(void *)&long long v824 = v86;
                *((void *)&v824 + 1) = -1;
                long long v825 = 0u;
                long long v826 = 0u;
                int v88 = llvm::AAResults::alias(v87, (uint64_t)v833, (uint64_t)&v824);
                if ((v88 - 1) < 2) {
                  goto LABEL_182;
                }
                if (v88 == 3)
                {
                  *(unsigned char *)uint64_t v782 = 1;
                  if (v76 == 12)
                  {
                    uint64_t v104 = *(void *)(v782 + 88);
                    if (v104
                      || (long long v105 = *(uint64_t ***)(v782 + 64),
                          llvm::Intrinsic::getType(*v105, 222, 0, 0),
                          v106 = (llvm::PointerType *)llvm::Intrinsic::getType(*v105, 222, 0, 0),
                          llvm::Module::getOrInsertFunction((uint64_t)v105, "llvm.objc.retain", (const char *)0x10, v106, 0), v107 = 0, v108 = 0, (*(void *)(v782 + 88) = v104) != 0))
                    {
                      v108 = *(uint64_t ***)(v104 + 24);
                      v107 = (uint64_t **)v104;
                    }
                    v792 = v107;
                    v796 = v108;
                    *(void *)&long long v824 = v83;
                    LOWORD(v834[0]) = 257;
                    v109 = (char *)operator new(0x90uLL);
                    v110 = v796;
                    v111 = v109;
                    v112 = (llvm::Value *)(v109 + 64);
                    *((_DWORD *)v109 + 21) = *((_DWORD *)v109 + 21) & 0x38000000 | 2;
                    *(void *)v109 = 0;
                    *((void *)v109 + 1) = 0;
                    *((void *)v109 + 2) = 0;
                    *((void *)v109 + 3) = v109 + 64;
                    *((void *)v109 + 4) = 0;
                    *((void *)v109 + 5) = 0;
                    *((void *)v109 + 6) = 0;
                    *((void *)v109 + 7) = v109 + 64;
                    *((void *)v109 + 8) = *v796[2];
                    *((void *)v109 + 9) = 0;
                    v109[80] = 84;
                    v109[81] = 0;
                    *((_WORD *)v109 + 41) = 0;
                    *((_DWORD *)v109 + 21) = 2;
                    *(_OWORD *)(v109 + 88) = 0u;
                    v113 = v109 + 88;
                    *((_DWORD *)v109 + 30) = 0;
                    *(_OWORD *)(v109 + 104) = 0u;
                    if (v70)
                    {
                      uint64_t v116 = v70[2];
                      *((void *)v109 + 13) = v116;
                      *(_WORD *)(v116 + 18) &= ~0x8000u;
                      if ((v109[87] & 0x10) != 0)
                      {
                        uint64_t v120 = *(void *)(v116 + 56);
                        if (v120)
                        {
                          v121 = *(llvm::ValueSymbolTable **)(v120 + 104);
                          if (v121)
                          {
                            llvm::ValueSymbolTable::reinsertValue(v121, v112);
                            v110 = v796;
                          }
                        }
                      }
                      uint64_t v117 = *v70;
                      *((void *)v111 + 11) = *v70;
                      *((void *)v111 + 12) = v70;
                      *(void *)(v117 + 8) = v113;
                      *unsigned int v70 = (uint64_t)v113;
                    }
                    *((void *)v111 + 16) = 0;
                    llvm::CallInst::init((uint64_t ***)v112, v110, v792, (uint64_t *)&v824, 1, 0, 0, (const char **)v833);
                    *((_WORD *)v111 + 41) = *((_WORD *)v111 + 41) & 0xFFFC | 1;
                  }
                  long long v103 = (llvm::ValueAsMetadata *)v74;
                  v102 = v83;
                  goto LABEL_181;
                }
              }
            }
          }
        }
        uint64_t v77 = v68;
        unsigned int v78 = v67;
        if (v75 == 12) {
          goto LABEL_148;
        }
LABEL_182:
        ;
      }
      while (v68 != v793);
      v65 = *(void **)(v766 + 80);
      uint64_t v7 = v782;
LABEL_194:
      while (v65 != v793)
      {
        v122 = v65 - 3;
        if (!v65) {
          v122 = 0;
        }
        v123 = (void *)v122[6];
        if (v123 != v122 + 5)
        {
          do
          {
            v124 = v123;
            v123 = (void *)v123[1];
            v125 = v65 - 3;
            if (!v65) {
              v125 = 0;
            }
            if (v123 == v125 + 5)
            {
              v126 = (void *)v65[1];
              v65 = v793;
              if (v126 != v793)
              {
                while (1)
                {
                  v127 = v126 - 3;
                  if (!v126) {
                    v127 = 0;
                  }
                  v123 = (void *)v127[6];
                  if (v123 != v127 + 5) {
                    break;
                  }
                  v126 = (void *)v126[1];
                  if (v126 == v793)
                  {
                    v65 = v793;
                    goto LABEL_209;
                  }
                }
                v65 = v126;
              }
            }
LABEL_209:
            if (v124) {
              uint64_t v128 = (uint64_t)(v124 - 3);
            }
            else {
              uint64_t v128 = 0;
            }
            if (sub_1CD4B36C8(v128, v64) == 18)
            {
              uint64_t v129 = *(void *)(v128 - 32 * (*(_DWORD *)(v128 + 20) & 0x7FFFFFF));
              if (v129)
              {
                if (*(unsigned char *)(v129 + 16) == 59)
                {
                  uint64_t v130 = *(void *)(v129 + 8);
                  if (v130)
                  {
                    do
                    {
                      unsigned int v131 = sub_1CD4B36C8(*(void *)(v130 + 24), v64);
                      BOOL v132 = v131 > 0x12 || ((1 << v131) & 0x46000) == 0;
                      if (v132) {
                        goto LABEL_227;
                      }
                      uint64_t v130 = *(void *)(v130 + 8);
                    }
                    while (v130);
                    uint64_t v133 = *(void *)(v129 + 8);
                    *(unsigned char *)uint64_t v7 = 1;
                    if (v133)
                    {
                      v134 = *(llvm::ValueAsMetadata **)(v133 + 24);
                      if (sub_1CD4B36C8((uint64_t)v134, v64) - 13 <= 1) {
                        llvm::Value::doRAUW(v134, ((llvm::Value **)v134 - 4 * (*((_DWORD *)v134 + 5) & 0x7FFFFFF))[4], (llvm::Value *)1);
                      }
                      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                    }
                  }
                  else
                  {
                    *(unsigned char *)uint64_t v7 = 1;
                  }
                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                }
              }
            }
LABEL_227:
            ;
          }
          while (v65 != v793);
          break;
        }
        v65 = (void *)v65[1];
      }
    }
  }
  int v135 = *(_DWORD *)(v7 + 204);
  if ((v135 & 0xB) != 0 && (*(_DWORD *)(v7 + 204) & 0x10) != 0)
  {
    uint64_t v763 = v7 + 160;
    while (1)
    {
      v813[0] = 0;
      v813[1] = 0;
      unsigned int v814 = 0;
      v808[0] = 0;
      v808[1] = 0;
      int v809 = 0;
      v811 = 0;
      uint64_t v812 = 0;
      v810 = 0;
      v806[0] = 0;
      v806[1] = 0;
      unsigned int v807 = 0;
      v821 = v823;
      uint64_t v822 = 0x1000000000;
      v818 = v820;
      uint64_t v819 = 0x1000000000;
      if (!*(unsigned char *)(v7 + 188))
      {
        int MDKindID = llvm::LLVMContext::getMDKindID(**(uint64_t ***)(v7 + 160), "clang.arc.no_objc_arc_exceptions", 0x20uLL);
        int v138 = *(unsigned __int8 *)(v7 + 188);
        *(_DWORD *)(v7 + 184) = MDKindID;
        if (!v138) {
          *(unsigned char *)(v7 + 188) = 1;
        }
      }
      v845 = (llvm::Value *)v849;
      v846 = v849;
      uint64_t v847 = 16;
      int v848 = 0;
      v840 = v844;
      v841 = v844;
      uint64_t v842 = 16;
      int v843 = 0;
      *(void *)v833 = &v833[16];
      *(void *)&v833[8] = 0x1000000000;
      uint64_t v139 = *(void *)(v766 + 80);
      if (v139) {
        uint64_t v140 = v139 - 24;
      }
      else {
        uint64_t v140 = 0;
      }
      uint64_t v817 = v140;
      v141 = sub_1CCC0F8D0((uint64_t)v806, &v817);
      uint64_t v142 = 0;
      *(_DWORD *)v141 = 1;
      uint64_t v143 = *(void *)(v140 + 40);
      if (v143 != v140 + 40)
      {
        uint64_t v142 = v143 - 24;
        if (!v143) {
          uint64_t v142 = 0;
        }
        if (*(unsigned __int8 *)(v142 + 16) - 29 >= 0xB) {
          uint64_t v142 = 0;
        }
      }
      *(void *)&long long v824 = v140;
      *((void *)&v824 + 1) = v142;
      LODWORD(v825) = 0;
      if (*(_DWORD *)&v833[8] >= *(_DWORD *)&v833[12])
      {
        if (*(void *)v833 > (unint64_t)&v824
          || *(void *)v833 + 24 * (unint64_t)*(unsigned int *)&v833[8] <= (unint64_t)&v824)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v144 = *(void *)v833 + 24 * *(unsigned int *)&v833[8];
      long long v145 = v824;
      *(void *)(v144 + 16) = v825;
      *(_OWORD *)uint64_t v144 = v145;
      ++*(_DWORD *)&v833[8];
      v146 = (char *)v846;
      uint64_t v147 = HIDWORD(v847);
      if (v846 == v845)
      {
        if (HIDWORD(v847))
        {
          v148 = 0;
          uint64_t v149 = 8 * HIDWORD(v847);
          v150 = (uint64_t *)v846;
          do
          {
            if (*v150 == v140) {
              goto LABEL_277;
            }
            if (*v150 == -2) {
              v148 = v150;
            }
            ++v150;
            v149 -= 8;
          }
          while (v149);
          if (v148)
          {
            uint64_t *v148 = v140;
            --v848;
            goto LABEL_277;
          }
        }
        unsigned int v151 = v847;
        if (HIDWORD(v847) < v847)
        {
          ++HIDWORD(v847);
          *((void *)v846 + v147) = v140;
          goto LABEL_277;
        }
      }
      else
      {
        unsigned int v151 = v847;
      }
      if (3 * v151 <= 4 * (HIDWORD(v847) - v848))
      {
        if (v151 >= 0x40) {
          v151 *= 2;
        }
        else {
          unsigned int v151 = 128;
        }
      }
      else if (v151 - HIDWORD(v847) >= v151 >> 3)
      {
        goto LABEL_258;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v845, v151);
      unsigned int v151 = v847;
      v146 = (char *)v846;
LABEL_258:
      unsigned int v152 = v151 - 1;
      unsigned int v153 = (v151 - 1) & ((v140 >> 4) ^ (v140 >> 9));
      v154 = &v146[8 * v153];
      uint64_t v155 = *(void *)v154;
      if (*(void *)v154 == -1)
      {
        v156 = 0;
LABEL_270:
        if (v156) {
          v160 = v156;
        }
        else {
          v160 = (uint64_t *)v154;
        }
        if (*v160 != v140)
        {
          if (*v160 == -2) {
            --v848;
          }
          else {
            ++HIDWORD(v847);
          }
          uint64_t *v160 = v140;
        }
      }
      else
      {
        v156 = 0;
        int v157 = 1;
        while (v155 != v140)
        {
          if (v156) {
            BOOL v158 = 0;
          }
          else {
            BOOL v158 = v155 == -2;
          }
          if (v158) {
            v156 = (uint64_t *)v154;
          }
          unsigned int v159 = v153 + v157++;
          unsigned int v153 = v159 & v152;
          v154 = &v146[8 * (v159 & v152)];
          uint64_t v155 = *(void *)v154;
          if (*(void *)v154 == -1) {
            goto LABEL_270;
          }
        }
      }
LABEL_277:
      v161 = (char *)v841;
      uint64_t v162 = HIDWORD(v842);
      if (v841 == v840)
      {
        if (HIDWORD(v842))
        {
          v163 = 0;
          uint64_t v164 = 8 * HIDWORD(v842);
          v165 = (uint64_t *)v841;
          do
          {
            if (*v165 == v140) {
              goto LABEL_326;
            }
            if (*v165 == -2) {
              v163 = v165;
            }
            ++v165;
            v164 -= 8;
          }
          while (v164);
          if (v163)
          {
            uint64_t *v163 = v140;
LABEL_325:
            --v843;
            goto LABEL_326;
          }
        }
        unsigned int v166 = v842;
        if (HIDWORD(v842) < v842)
        {
          ++HIDWORD(v842);
          *((void *)v841 + v162) = v140;
          goto LABEL_326;
        }
      }
      else
      {
        unsigned int v166 = v842;
      }
      if (3 * v166 <= 4 * (HIDWORD(v842) - v843))
      {
        if (v166 >= 0x40) {
          v166 *= 2;
        }
        else {
          unsigned int v166 = 128;
        }
LABEL_323:
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v840, v166);
        unsigned int v166 = v842;
        v161 = (char *)v841;
        goto LABEL_290;
      }
      if (v166 - HIDWORD(v842) < v166 >> 3) {
        goto LABEL_323;
      }
LABEL_290:
      unsigned int v167 = v166 - 1;
      unsigned int v168 = (v166 - 1) & ((v140 >> 4) ^ (v140 >> 9));
      v169 = &v161[8 * v168];
      uint64_t v170 = *(void *)v169;
      if (*(void *)v169 == -1)
      {
        v171 = 0;
      }
      else
      {
        v171 = 0;
        int v172 = 1;
        do
        {
          if (v170 == v140) {
            goto LABEL_326;
          }
          if (v171) {
            BOOL v173 = 0;
          }
          else {
            BOOL v173 = v170 == -2;
          }
          if (v173) {
            v171 = (uint64_t *)v169;
          }
          unsigned int v174 = v168 + v172++;
          unsigned int v168 = v174 & v167;
          v169 = &v161[8 * (v174 & v167)];
          uint64_t v170 = *(void *)v169;
        }
        while (*(void *)v169 != -1);
      }
      if (v171) {
        v175 = v171;
      }
      else {
        v175 = (uint64_t *)v169;
      }
      if (*v175 != v140)
      {
        if (*v175 == -2) {
          --v843;
        }
        else {
          ++HIDWORD(v842);
        }
        uint64_t *v175 = v140;
      }
      do
      {
LABEL_326:
        uint64_t v176 = *(void *)v833 + 24 * *(unsigned int *)&v833[8];
        uint64_t v177 = *(void *)(v176 - 24);
        uint64_t v816 = v177;
        uint64_t v178 = *(void *)(v177 + 40);
        if (v178 == v177 + 40)
        {
LABEL_335:
          int v250 = 0;
        }
        else
        {
          if (v178) {
            uint64_t v179 = v178 - 24;
          }
          else {
            uint64_t v179 = 0;
          }
          if (*(unsigned char *)(v179 + 16) != 30)
          {
            int v250 = 0;
            switch(*(unsigned char *)(v179 + 16))
            {
              case 0x1D:
              case 0x22:
              case 0x23:
                goto LABEL_336;
              case 0x1E:
LABEL_1505:
                __break(1u);
                goto LABEL_1506;
              case 0x1F:
                int v250 = (*(_DWORD *)(v179 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_336;
              case 0x20:
              case 0x26:
                int v250 = (*(_DWORD *)(v179 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_336;
              case 0x21:
                int v250 = 2;
                goto LABEL_336;
              case 0x24:
                int v250 = *(_WORD *)(v179 + 18) & 1;
                goto LABEL_336;
              case 0x25:
                int v250 = 1;
                goto LABEL_336;
              case 0x27:
                int v250 = *(_DWORD *)(v179 + 80) + 1;
                goto LABEL_336;
              default:
                goto LABEL_335;
            }
          }
          if ((*(_DWORD *)(v179 + 20) & 0x7FFFFFF) == 3) {
            int v250 = 2;
          }
          else {
            int v250 = 1;
          }
        }
LABEL_336:
        while (*(_DWORD *)(v176 - 8) != v250)
        {
          v180 = *(llvm::Instruction **)(v176 - 16);
          unsigned int v181 = *(_DWORD *)(v176 - 8);
          *(_DWORD *)(v176 - 8) = v181 + 1;
          uint64_t Successor = llvm::Instruction::getSuccessor(v180, v181);
          uint64_t v183 = Successor;
          uint64_t v815 = Successor;
          v184 = (char *)v846;
          uint64_t v185 = HIDWORD(v847);
          if (v846 == v845)
          {
            if (HIDWORD(v847))
            {
              v186 = 0;
              uint64_t v187 = 8 * HIDWORD(v847);
              v188 = (uint64_t *)v846;
              while (*v188 != Successor)
              {
                if (*v188 == -2) {
                  v186 = v188;
                }
                ++v188;
                v187 -= 8;
                if (!v187)
                {
                  if (!v186) {
                    goto LABEL_345;
                  }
                  uint64_t *v186 = Successor;
                  --v848;
                  goto LABEL_429;
                }
              }
              goto LABEL_366;
            }
LABEL_345:
            unsigned int v189 = v847;
            if (HIDWORD(v847) < v847)
            {
              ++HIDWORD(v847);
              *((void *)v846 + v185) = Successor;
              goto LABEL_429;
            }
          }
          else
          {
            unsigned int v189 = v847;
          }
          if (3 * v189 <= 4 * (HIDWORD(v847) - v848))
          {
            if (v189 >= 0x40) {
              v189 *= 2;
            }
            else {
              unsigned int v189 = 128;
            }
          }
          else if (v189 - HIDWORD(v847) >= v189 >> 3)
          {
            goto LABEL_350;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v845, v189);
          unsigned int v189 = v847;
          v184 = (char *)v846;
LABEL_350:
          unsigned int v190 = v189 - 1;
          unsigned int v191 = (v189 - 1) & ((v183 >> 4) ^ (v183 >> 9));
          v192 = &v184[8 * v191];
          uint64_t v193 = *(void *)v192;
          if (*(void *)v192 == -1)
          {
            v194 = 0;
LABEL_362:
            if (v194) {
              v198 = v194;
            }
            else {
              v198 = (uint64_t *)v192;
            }
            if (*v198 != v183)
            {
              if (*v198 == -2) {
                --v848;
              }
              else {
                ++HIDWORD(v847);
              }
              uint64_t *v198 = v183;
LABEL_429:
              uint64_t v225 = *(void *)(v183 + 40);
              if (v225 == v183 + 40)
              {
                uint64_t v226 = 0;
              }
              else
              {
                if (v225) {
                  uint64_t v226 = v225 - 24;
                }
                else {
                  uint64_t v226 = 0;
                }
                if (*(unsigned __int8 *)(v226 + 16) - 29 >= 0xB) {
                  uint64_t v226 = 0;
                }
              }
              *(void *)&long long v824 = v183;
              *((void *)&v824 + 1) = v226;
              LODWORD(v825) = 0;
              if (*(_DWORD *)&v833[8] >= *(_DWORD *)&v833[12])
              {
                if (*(void *)v833 > (unint64_t)&v824
                  || *(void *)v833 + 24 * (unint64_t)*(unsigned int *)&v833[8] <= (unint64_t)&v824)
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v227 = *(void *)v833 + 24 * *(unsigned int *)&v833[8];
              long long v228 = v824;
              *(void *)(v227 + 16) = v825;
              *(_OWORD *)uint64_t v227 = v228;
              ++*(_DWORD *)&v833[8];
              v229 = sub_1CCC0F8D0((uint64_t)v806, &v816);
              unint64_t v230 = *((unsigned int *)v229 + 36);
              if (v230 >= *((unsigned int *)v229 + 37)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(v229[17] + 8 * v230) = v183;
              ++*((_DWORD *)v229 + 36);
              v231 = sub_1CCC0F8D0((uint64_t)v806, &v815);
              unint64_t v232 = *((unsigned int *)v231 + 28);
              if (v232 >= *((unsigned int *)v231 + 29)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(v231[13] + 8 * v232) = v177;
              ++*((_DWORD *)v231 + 28);
              v233 = (char *)v841;
              uint64_t v234 = HIDWORD(v842);
              if (v841 == v840)
              {
                if (HIDWORD(v842))
                {
                  v235 = 0;
                  uint64_t v236 = 8 * HIDWORD(v842);
                  v237 = (uint64_t *)v841;
                  while (*v237 != v183)
                  {
                    if (*v237 == -2) {
                      v235 = v237;
                    }
                    ++v237;
                    v236 -= 8;
                    if (!v236)
                    {
                      if (!v235) {
                        goto LABEL_448;
                      }
                      uint64_t *v235 = v183;
                      goto LABEL_325;
                    }
                  }
                  goto LABEL_326;
                }
LABEL_448:
                unsigned int v238 = v842;
                if (HIDWORD(v842) < v842)
                {
                  ++HIDWORD(v842);
                  *((void *)v841 + v234) = v183;
                  goto LABEL_326;
                }
              }
              else
              {
                unsigned int v238 = v842;
              }
              if (3 * v238 <= 4 * (HIDWORD(v842) - v843))
              {
                if (v238 >= 0x40) {
                  v238 *= 2;
                }
                else {
                  unsigned int v238 = 128;
                }
              }
              else if (v238 - HIDWORD(v842) >= v238 >> 3)
              {
                goto LABEL_453;
              }
              llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v840, v238);
              unsigned int v238 = v842;
              v233 = (char *)v841;
LABEL_453:
              unsigned int v239 = v238 - 1;
              unsigned int v240 = (v238 - 1) & ((v183 >> 4) ^ (v183 >> 9));
              v241 = &v233[8 * v240];
              uint64_t v242 = *(void *)v241;
              if (*(void *)v241 == -1)
              {
                v243 = 0;
LABEL_476:
                if (v243) {
                  v248 = v243;
                }
                else {
                  v248 = (uint64_t *)v241;
                }
                if (*v248 != v183)
                {
                  if (*v248 == -2) {
                    --v843;
                  }
                  else {
                    ++HIDWORD(v842);
                  }
                  uint64_t *v248 = v183;
                }
              }
              else
              {
                v243 = 0;
                int v244 = 1;
                while (v242 != v183)
                {
                  if (v243) {
                    BOOL v245 = 0;
                  }
                  else {
                    BOOL v245 = v242 == -2;
                  }
                  if (v245) {
                    v243 = (uint64_t *)v241;
                  }
                  unsigned int v246 = v240 + v244++;
                  unsigned int v240 = v246 & v239;
                  v241 = &v233[8 * (v246 & v239)];
                  uint64_t v242 = *(void *)v241;
                  if (*(void *)v241 == -1) {
                    goto LABEL_476;
                  }
                }
              }
              goto LABEL_326;
            }
          }
          else
          {
            v194 = 0;
            int v195 = 1;
            while (v193 != v183)
            {
              if (v194) {
                BOOL v196 = 0;
              }
              else {
                BOOL v196 = v193 == -2;
              }
              if (v196) {
                v194 = (uint64_t *)v192;
              }
              unsigned int v197 = v191 + v195++;
              unsigned int v191 = v197 & v190;
              v192 = &v184[8 * (v197 & v190)];
              uint64_t v193 = *(void *)v192;
              if (*(void *)v192 == -1) {
                goto LABEL_362;
              }
            }
          }
LABEL_366:
          v199 = v840;
          if (v841 == v840)
          {
            unsigned int v200 = HIDWORD(v842);
            v201 = (char *)v841 + 8 * HIDWORD(v842);
            if (HIDWORD(v842))
            {
              uint64_t v202 = 0;
              while (*(void *)((char *)v841 + v202) != v183)
              {
                v202 += 8;
                if (8 * HIDWORD(v842) == v202) {
                  goto LABEL_385;
                }
              }
              v201 = (char *)v841 + v202;
            }
LABEL_385:
            v199 = v841;
          }
          else
          {
            int v203 = v842 - 1;
            unsigned int v204 = (v842 - 1) & ((v183 >> 4) ^ (v183 >> 9));
            v201 = (char *)v841 + 8 * v204;
            uint64_t v205 = *(void *)v201;
            if (*(void *)v201 == -1)
            {
              v206 = 0;
LABEL_395:
              if (v206) {
                v201 = v206;
              }
              unsigned int v200 = HIDWORD(v842);
              if (*(void *)v201 != v183) {
                v201 = (char *)v841 + 8 * v842;
              }
            }
            else
            {
              v206 = 0;
              int v207 = 1;
              while (v205 != v183)
              {
                if (v206) {
                  BOOL v208 = 0;
                }
                else {
                  BOOL v208 = v205 == -2;
                }
                if (v208) {
                  v206 = v201;
                }
                unsigned int v209 = v204 + v207++;
                unsigned int v204 = v209 & v203;
                v201 = (char *)v841 + 8 * (v209 & v203);
                uint64_t v205 = *(void *)v201;
                if (*(void *)v201 == -1) {
                  goto LABEL_395;
                }
              }
              unsigned int v200 = HIDWORD(v842);
            }
          }
          if (v841 == v199) {
            unsigned int v210 = v200;
          }
          else {
            unsigned int v210 = v842;
          }
          if (v201 == (char *)v841 + 8 * v210)
          {
            v211 = sub_1CCC0F8D0((uint64_t)v806, &v816);
            unint64_t v212 = *((unsigned int *)v211 + 36);
            if (v212 >= *((unsigned int *)v211 + 37)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(v211[17] + 8 * v212) = v183;
            ++*((_DWORD *)v211 + 36);
            v213 = sub_1CCC0F8D0((uint64_t)v806, &v815);
            unint64_t v214 = *((unsigned int *)v213 + 28);
            if (v214 >= *((unsigned int *)v213 + 29)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(v213[13] + 8 * v214) = v177;
            ++*((_DWORD *)v213 + 28);
          }
          uint64_t v176 = *(void *)v833 + 24 * *(unsigned int *)&v833[8];
        }
        v215 = v840;
        if (v841 == v840)
        {
          unsigned int v216 = HIDWORD(v842);
          v217 = (char *)v841 + 8 * HIDWORD(v842);
          if (HIDWORD(v842))
          {
            uint64_t v218 = 0;
            while (*(void *)((char *)v841 + v218) != v177)
            {
              v218 += 8;
              if (8 * HIDWORD(v842) == v218) {
                goto LABEL_465;
              }
            }
            v217 = (char *)v841 + v218;
          }
LABEL_465:
          v215 = v841;
        }
        else
        {
          int v219 = v842 - 1;
          unsigned int v220 = (v842 - 1) & ((v177 >> 4) ^ (v177 >> 9));
          v217 = (char *)v841 + 8 * v220;
          uint64_t v221 = *(void *)v217;
          if (*(void *)v217 == -1)
          {
            v249 = 0;
LABEL_483:
            if (v249) {
              v217 = v249;
            }
            unsigned int v216 = HIDWORD(v842);
            if (*(void *)v217 != v177) {
              v217 = (char *)v841 + 8 * v842;
            }
          }
          else
          {
            v249 = 0;
            int v222 = 1;
            while (v221 != v177)
            {
              if (v249) {
                BOOL v223 = 0;
              }
              else {
                BOOL v223 = v221 == -2;
              }
              if (v223) {
                v249 = v217;
              }
              unsigned int v224 = v220 + v222++;
              unsigned int v220 = v224 & v219;
              v217 = (char *)v841 + 8 * (v224 & v219);
              uint64_t v221 = *(void *)v217;
              if (*(void *)v217 == -1) {
                goto LABEL_483;
              }
            }
            unsigned int v216 = HIDWORD(v842);
          }
        }
        if (v841 == v215) {
          unsigned int v247 = v216;
        }
        else {
          unsigned int v247 = v842;
        }
        if (v217 != (char *)v841 + 8 * v247)
        {
          *(void *)v217 = -2;
          ++v843;
          uint64_t v177 = v816;
        }
        if (v822 >= (unint64_t)HIDWORD(v822)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v821 + v822) = v177;
        LODWORD(v822) = v822 + 1;
        --*(_DWORD *)&v833[8];
      }
      while (*(_DWORD *)&v833[8]);
      if (v846 == v845) {
        goto LABEL_510;
      }
      if (v847 < 0x21 || 4 * (HIDWORD(v847) - v848) >= v847)
      {
        memset(v846, 255, 8 * v847);
LABEL_510:
        int v848 = 0;
        HIDWORD(v847) = 0;
      }
      else
      {
        llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v845);
      }
      *(void *)&long long v824 = &v825;
      *((void *)&v824 + 1) = 0x1000000000;
      v251 = *(void **)(v766 + 80);
      if (v251 == v793) {
        goto LABEL_610;
      }
      while (2)
      {
        if (v251) {
          uint64_t v252 = (uint64_t)(v251 - 3);
        }
        else {
          uint64_t v252 = 0;
        }
        uint64_t v816 = v252;
        v253 = sub_1CCC0F8D0((uint64_t)v806, &v816);
        if (!*((_DWORD *)v253 + 36))
        {
          *((_DWORD *)v253 + 1) = 1;
          uint64_t v254 = v253[13];
          if (DWORD2(v824) >= (unint64_t)HIDWORD(v824)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v255 = (uint64_t *)(v824 + 16 * DWORD2(v824));
          uint64_t *v255 = v252;
          v255[1] = v254;
          ++DWORD2(v824);
          v256 = (char *)v846;
          uint64_t v257 = HIDWORD(v847);
          if (v846 != v845)
          {
            unsigned int v261 = v847;
            goto LABEL_530;
          }
          if (HIDWORD(v847))
          {
            v258 = 0;
            uint64_t v259 = 8 * HIDWORD(v847);
            v260 = (uint64_t *)v846;
            do
            {
              if (*v260 == v252) {
                goto LABEL_551;
              }
              if (*v260 == -2) {
                v258 = v260;
              }
              ++v260;
              v259 -= 8;
            }
            while (v259);
            if (v258)
            {
              uint64_t *v258 = v252;
              --v848;
              goto LABEL_551;
            }
          }
          unsigned int v261 = v847;
          if (HIDWORD(v847) < v847)
          {
            ++HIDWORD(v847);
            *((void *)v846 + v257) = v252;
            goto LABEL_551;
          }
LABEL_530:
          if (3 * v261 <= 4 * (HIDWORD(v847) - v848))
          {
            if (v261 >= 0x40) {
              v261 *= 2;
            }
            else {
              unsigned int v261 = 128;
            }
          }
          else if (v261 - HIDWORD(v847) >= v261 >> 3)
          {
LABEL_532:
            unsigned int v262 = v261 - 1;
            unsigned int v263 = (v261 - 1) & ((v252 >> 4) ^ (v252 >> 9));
            v264 = &v256[8 * v263];
            uint64_t v265 = *(void *)v264;
            if (*(void *)v264 == -1)
            {
              v266 = 0;
LABEL_544:
              if (v266) {
                v270 = v266;
              }
              else {
                v270 = (uint64_t *)v264;
              }
              if (*v270 != v252)
              {
                if (*v270 == -2) {
                  --v848;
                }
                else {
                  ++HIDWORD(v847);
                }
                uint64_t *v270 = v252;
              }
            }
            else
            {
              v266 = 0;
              int v267 = 1;
              while (v265 != v252)
              {
                if (v266) {
                  BOOL v268 = 0;
                }
                else {
                  BOOL v268 = v265 == -2;
                }
                if (v268) {
                  v266 = (uint64_t *)v264;
                }
                unsigned int v269 = v263 + v267++;
                unsigned int v263 = v269 & v262;
                v264 = &v256[8 * (v269 & v262)];
                uint64_t v265 = *(void *)v264;
                if (*(void *)v264 == -1) {
                  goto LABEL_544;
                }
              }
            }
LABEL_551:
            unsigned int v271 = DWORD2(v824);
            if (!DWORD2(v824)) {
              goto LABEL_516;
            }
            while (2)
            {
              while (1)
              {
                v272 = sub_1CCC0F8D0((uint64_t)v806, (uint64_t *)(v824 + 16 * v271 - 16));
                uint64_t v273 = v272[13] + 8 * *((unsigned int *)v272 + 28);
                int v274 = DWORD2(v824);
                uint64_t v275 = v824 + 16 * DWORD2(v824);
                v276 = (void *)(v275 - 8);
                v277 = *(uint64_t **)(v275 - 8);
                if (v277 != (uint64_t *)v273) {
                  break;
                }
LABEL_596:
                uint64_t v296 = *(void *)(v275 - 16);
                DWORD2(v824) = v274 - 1;
                if (v819 >= (unint64_t)HIDWORD(v819)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v818 + v819) = v296;
                LODWORD(v819) = v819 + 1;
                unsigned int v271 = DWORD2(v824);
                if (!DWORD2(v824)) {
                  goto LABEL_516;
                }
              }
              v278 = (llvm::Value *)v846;
              v279 = v845;
LABEL_554:
              void *v276 = v277 + 1;
              uint64_t v280 = *v277;
              uint64_t v816 = *v277;
              uint64_t v281 = HIDWORD(v847);
              if (v278 == v279)
              {
                if (HIDWORD(v847))
                {
                  uint64_t v282 = 0;
                  v283 = 0;
                  do
                  {
                    uint64_t v284 = *(void *)((char *)v278 + v282);
                    if (v284 == v280) {
                      goto LABEL_582;
                    }
                    if (v284 == -2) {
                      v283 = (uint64_t *)((char *)v278 + v282);
                    }
                    v282 += 8;
                  }
                  while (8 * HIDWORD(v847) != v282);
                  if (v283)
                  {
                    uint64_t *v283 = v280;
                    --v848;
                    goto LABEL_592;
                  }
                }
                unsigned int v285 = v847;
                if (HIDWORD(v847) < v847)
                {
                  ++HIDWORD(v847);
                  *((void *)v278 + v281) = v280;
                  goto LABEL_592;
                }
              }
              else
              {
                unsigned int v285 = v847;
              }
              if (3 * v285 <= 4 * (HIDWORD(v847) - v848))
              {
                if (v285 >= 0x40) {
                  v285 *= 2;
                }
                else {
                  unsigned int v285 = 128;
                }
              }
              else if (v285 - HIDWORD(v847) >= v285 >> 3)
              {
                goto LABEL_567;
              }
              llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v845, v285);
              unsigned int v285 = v847;
              v278 = (llvm::Value *)v846;
LABEL_567:
              unsigned int v286 = v285 - 1;
              unsigned int v287 = (v285 - 1) & ((v280 >> 4) ^ (v280 >> 9));
              v288 = (uint64_t *)((char *)v278 + 8 * v287);
              uint64_t v289 = *v288;
              if (*v288 == -1)
              {
                v290 = 0;
LABEL_579:
                if (v290) {
                  v288 = v290;
                }
                if (*v288 != v280)
                {
                  if (*v288 == -2) {
                    --v848;
                  }
                  else {
                    ++HIDWORD(v847);
                  }
                  uint64_t *v288 = v280;
LABEL_592:
                  uint64_t v294 = sub_1CCC0F8D0((uint64_t)v806, &v816)[13];
                  if (DWORD2(v824) >= (unint64_t)HIDWORD(v824)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  v295 = (uint64_t *)(v824 + 16 * DWORD2(v824));
                  uint64_t *v295 = v280;
                  v295[1] = v294;
                  unsigned int v271 = ++DWORD2(v824);
                  continue;
                }
              }
              else
              {
                v290 = 0;
                int v291 = 1;
                while (v289 != v280)
                {
                  if (v290) {
                    BOOL v292 = 0;
                  }
                  else {
                    BOOL v292 = v289 == -2;
                  }
                  if (v292) {
                    v290 = v288;
                  }
                  unsigned int v293 = v287 + v291++;
                  unsigned int v287 = v293 & v286;
                  v288 = (uint64_t *)((char *)v278 + 8 * (v293 & v286));
                  uint64_t v289 = *v288;
                  if (*v288 == -1) {
                    goto LABEL_579;
                  }
                }
              }
              break;
            }
LABEL_582:
            v279 = v845;
            uint64_t v275 = v824 + 16 * DWORD2(v824);
            v276 = (void *)(v275 - 8);
            v277 = *(uint64_t **)(v275 - 8);
            if (v277 == (uint64_t *)v273)
            {
              int v274 = DWORD2(v824);
              goto LABEL_596;
            }
            goto LABEL_554;
          }
          llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v845, v261);
          unsigned int v261 = v847;
          v256 = (char *)v846;
          goto LABEL_532;
        }
LABEL_516:
        v251 = (void *)v251[1];
        if (v251 != v793) {
          continue;
        }
        break;
      }
      if ((long long *)v824 != &v825) {
        free((void *)v824);
      }
LABEL_610:
      if (*(unsigned char **)v833 != &v833[16]) {
        free(*(void **)v833);
      }
      if (v841 != v840) {
        free(v841);
      }
      if (v846 != v845) {
        free(v846);
      }
      int v297 = 0;
      v298 = (char *)v818;
      v299 = (char *)v818 + 8 * v819;
      v797 = (char *)v818;
      while (2)
      {
        int v780 = v297;
        if (v299 != v298)
        {
          uint64_t v301 = *((void *)v299 - 1);
          v299 -= 8;
          uint64_t v300 = v301;
          *(void *)&long long v824 = v301;
          v302 = sub_1CCC0F8D0((uint64_t)v806, (uint64_t *)&v824);
          uint64_t v303 = (uint64_t)v302;
          uint64_t v304 = *((unsigned int *)v302 + 36);
          if (!v304) {
            goto LABEL_619;
          }
          v316 = (uint64_t *)v302[17];
          uint64_t v317 = *v316;
          *(void *)v833 = 0;
          uint64_t v318 = v806[0];
          unsigned int v319 = v807;
          uint64_t v320 = sub_1CCC0F984(v806[0], v807, v317, v833) ? *(void *)v833 : v318 + 176 * v319;
          sub_1CD6C0634(v303 + 56, v320 + 64);
          *(_DWORD *)(v303 + 4) = *(_DWORD *)(v320 + 12);
          if (v304 == 1)
          {
LABEL_619:
            v305 = (void *)(v300 + 40);
            v306 = *(void **)(v300 + 48);
            if ((void *)(v300 + 40) != v306)
            {
              int v307 = 0;
              while (1)
              {
                v308 = (void *)*v305;
                if (*v305) {
                  v309 = (llvm::objcarc *)(*v305 - 24);
                }
                else {
                  v309 = 0;
                }
                if (*((unsigned char *)v309 + 16) != 33)
                {
                  BOOL v310 = sub_1CCC0FE34(v7, v309, v300, (uint64_t)v808, v303);
                  if (dword_1EBCEF2B0 < -252645135
                                       * ((*(void *)(v303 + 88) - *(void *)(v303 + 80)) >> 3))
                  {
                    char v764 = 0;
                    *(unsigned char *)(v7 + 200) = 1;
                    goto LABEL_703;
                  }
                  v307 |= v310;
                  v308 = (void *)*v305;
                }
                v305 = v308;
                if (v308 == v306) {
                  goto LABEL_630;
                }
              }
            }
            int v307 = 0;
LABEL_630:
            uint64_t v311 = *(unsigned int *)(v303 + 112);
            if (v311)
            {
              uint64_t v312 = *(void *)(v303 + 104);
              uint64_t v313 = 8 * v311;
              do
              {
                uint64_t v314 = *(void *)(*(void *)v312 + 40);
                if (v314) {
                  v315 = (llvm::objcarc *)(v314 - 24);
                }
                else {
                  v315 = 0;
                }
                if (v314 && *((unsigned char *)v315 + 16) == 33) {
                  v307 |= sub_1CCC0FE34(v7, v315, v300, (uint64_t)v808, v303);
                }
                v312 += 8;
                v313 -= 8;
              }
              while (v313);
            }
            int v297 = v780 | v307;
            if (*(unsigned char *)(v7 + 200))
            {
              char v764 = 0;
              goto LABEL_703;
            }
            continue;
          }
          v321 = &v316[v304];
          v322 = v316 + 1;
          while (2)
          {
            uint64_t v323 = *v322;
            *(void *)v833 = 0;
            uint64_t v324 = v806[0];
            unsigned int v325 = v807;
            if (sub_1CCC0F984(v806[0], v807, v323, v833)) {
              uint64_t v326 = *(void *)v833;
            }
            else {
              uint64_t v326 = v324 + 176 * v325;
            }
            int v327 = *(_DWORD *)(v303 + 4);
            if (v327 == -1)
            {
LABEL_693:
              if (++v322 == v321)
              {
                uint64_t v300 = v824;
                uint64_t v7 = v782;
                v298 = v797;
                goto LABEL_619;
              }
              continue;
            }
            break;
          }
          unsigned int v328 = *(_DWORD *)(v326 + 12) + v327;
          *(_DWORD *)(v303 + 4) = v328;
          if (v328 == -1)
          {
            sub_1CD3C7F68((_DWORD *)(v303 + 56));
            uint64_t v352 = *(void *)(v303 + 80);
            uint64_t v351 = *(void *)(v303 + 88);
            if (v351 != v352)
            {
              do
              {
                uint64_t v353 = v351 - 136;
                sub_1CD6C05EC((void *)(v351 - 120));
                uint64_t v351 = v353;
              }
              while (v353 != v352);
LABEL_700:
              uint64_t v351 = v352;
            }
          }
          else
          {
            if (v328 >= *(_DWORD *)(v326 + 12))
            {
              uint64_t v330 = *(void *)(v326 + 88);
              uint64_t v329 = *(void *)(v326 + 96);
              while (v330 != v329)
              {
                uint64_t v331 = sub_1CD6C0750(v303 + 56, (uint64_t *)v330);
                if (v332)
                {
                  char v333 = 0;
                  __b[0] = 0;
                  long long v839 = 0u;
                  long long v838 = 0u;
                  long long v835 = 0u;
                  memset(v833, 0, 24);
                  *(void *)&v833[24] = (char *)&v835 + 8;
                  v834[0] = (char *)&v835 + 8;
                  v834[1] = (void *)2;
                  __b[1] = (char *)&v838 + 8;
                  v837[0] = (char *)&v838 + 8;
                  v837[1] = (void *)2;
                }
                else
                {
                  __int16 v334 = *(_WORD *)(v330 + 8);
                  v833[2] = *(unsigned char *)(v330 + 10);
                  *(_WORD *)v833 = v334;
                  *(_OWORD *)&v833[8] = *(_OWORD *)(v330 + 16);
                  v335 = (char *)&v835 + 8;
                  *(void *)&v833[24] = (char *)&v835 + 8;
                  v336 = *(const void **)(v330 + 40);
                  if (v336 == *(const void **)(v330 + 32))
                  {
                    v834[0] = (char *)&v835 + 8;
                    v337 = v336;
                  }
                  else
                  {
                    uint64_t v347 = *(unsigned int *)(v330 + 48);
                    v335 = (char *)malloc_type_malloc(8 * v347, 0x4065EBACuLL);
                    if (!v335)
                    {
                      if (v347) {
                        goto LABEL_1506;
                      }
                      v335 = (char *)malloc_type_malloc(1uLL, 0x4065EBACuLL);
                      if (!v335) {
                        goto LABEL_1506;
                      }
                    }
                    v834[0] = v335;
                    v337 = *(const void **)(v330 + 32);
                    v336 = *(const void **)(v330 + 40);
                  }
                  unsigned int v338 = *(_DWORD *)(v330 + 48);
                  LODWORD(v834[1]) = v338;
                  int v339 = *(_DWORD *)(v330 + 52);
                  if (v336 == v337) {
                    unsigned int v340 = *(_DWORD *)(v330 + 52);
                  }
                  else {
                    unsigned int v340 = v338;
                  }
                  if (v340)
                  {
                    memmove(v335, v336, 8 * v340);
                    int v339 = *(_DWORD *)(v330 + 52);
                  }
                  HIDWORD(v834[1]) = v339;
                  LODWORD(v835) = *(_DWORD *)(v330 + 56);
                  v341 = (char *)&v838 + 8;
                  __b[1] = (char *)&v838 + 8;
                  v342 = *(const void **)(v330 + 88);
                  if (v342 == *(const void **)(v330 + 80))
                  {
                    v837[0] = (char *)&v838 + 8;
                    v343 = v342;
                  }
                  else
                  {
                    uint64_t v348 = *(unsigned int *)(v330 + 96);
                    v341 = (char *)malloc_type_malloc(8 * v348, 0x4065EBACuLL);
                    if (!v341)
                    {
                      if (v348) {
                        goto LABEL_1506;
                      }
                      v341 = (char *)malloc_type_malloc(1uLL, 0x4065EBACuLL);
                      if (!v341) {
                        goto LABEL_1506;
                      }
                    }
                    v837[0] = v341;
                    v343 = *(const void **)(v330 + 80);
                    v342 = *(const void **)(v330 + 88);
                  }
                  unsigned int v344 = *(_DWORD *)(v330 + 96);
                  LODWORD(v837[1]) = v344;
                  int v345 = *(_DWORD *)(v330 + 100);
                  if (v342 == v343) {
                    unsigned int v346 = *(_DWORD *)(v330 + 100);
                  }
                  else {
                    unsigned int v346 = v344;
                  }
                  if (v346)
                  {
                    memmove(v341, v342, 8 * v346);
                    int v345 = *(_DWORD *)(v330 + 100);
                  }
                  HIDWORD(v837[1]) = v345;
                  LODWORD(v838) = *(_DWORD *)(v330 + 104);
                  char v333 = *(unsigned char *)(v330 + 128);
                }
                BYTE8(v839) = v333;
                llvm::objcarc::PtrState::Merge((llvm::objcarc::PtrState *)(v331 + 8), (const llvm::objcarc::PtrState *)v833, 0);
                if (v837[0] != __b[1]) {
                  free(v837[0]);
                }
                if (v834[0] != *(void **)&v833[24]) {
                  free(v834[0]);
                }
                v330 += 136;
              }
              v349 = *(uint64_t **)(v303 + 80);
              for (j = *(uint64_t **)(v303 + 88); v349 != j; v349 += 17)
              {
                if (*(void *)(v326 + 96) == sub_1CD6C0800(v326 + 64, *v349))
                {
                  __b[0] = 0;
                  long long v839 = 0u;
                  long long v838 = 0u;
                  long long v835 = 0u;
                  memset(v833, 0, 24);
                  *(void *)&v833[24] = (char *)&v835 + 8;
                  v834[0] = (char *)&v835 + 8;
                  v834[1] = (void *)2;
                  __b[1] = (char *)&v838 + 8;
                  v837[0] = (char *)&v838 + 8;
                  v837[1] = (void *)2;
                  llvm::objcarc::PtrState::Merge((llvm::objcarc::PtrState *)(v349 + 1), (const llvm::objcarc::PtrState *)v833, 0);
                  if (v837[0] != __b[1]) {
                    free(v837[0]);
                  }
                  if (v834[0] != *(void **)&v833[24]) {
                    free(v834[0]);
                  }
                }
              }
              goto LABEL_693;
            }
            *(_DWORD *)(v303 + 4) = -1;
            sub_1CD3C7F68((_DWORD *)(v303 + 56));
            uint64_t v352 = *(void *)(v303 + 80);
            uint64_t v351 = *(void *)(v303 + 88);
            if (v351 != v352)
            {
              do
              {
                uint64_t v354 = v351 - 136;
                sub_1CD6C05EC((void *)(v351 - 120));
                uint64_t v351 = v354;
              }
              while (v354 != v352);
              goto LABEL_700;
            }
          }
          *(void *)(v303 + 88) = v351;
          goto LABEL_693;
        }
        break;
      }
      long long v824 = 0uLL;
      LODWORD(v825) = 0;
      v609 = v810;
      v610 = v811;
      if (v810 != v811)
      {
        while (1)
        {
          uint64_t v611 = *v609;
          int v612 = *(_DWORD *)(*v609 + 20);
          if ((v612 & 0x40000000) != 0) {
            v613 = *(llvm::Value ***)(v611 - 8);
          }
          else {
            v613 = (llvm::Value **)(v611 - 32 * (v612 & 0x7FFFFFF));
          }
          v614 = sub_1CD4B3548(*v613);
          v615 = v614;
          uint64_t v616 = v609[10];
          uint64_t v617 = 88;
          if (v616 == v609[9]) {
            uint64_t v617 = 92;
          }
          uint64_t v618 = *(unsigned int *)((char *)v609 + v617);
          if (v618)
          {
            uint64_t v619 = 8 * v618;
            v620 = (unint64_t *)v609[10];
            while (*v620 >= 0xFFFFFFFFFFFFFFFELL)
            {
              ++v620;
              v619 -= 8;
              if (!v619) {
                goto LABEL_1279;
              }
            }
          }
          else
          {
            v620 = (unint64_t *)v609[10];
          }
          v621 = (unint64_t *)(v616 + 8 * v618);
          if (v620 != v621) {
            break;
          }
LABEL_1279:
          v609 += 16;
          if (v609 == v610) {
            goto LABEL_1280;
          }
        }
        unsigned int v622 = (v614 >> 4) ^ (v614 >> 9);
        while (2)
        {
          *(void *)v833 = 0;
          *(void *)v833 = *v620;
          v623 = sub_1CD4D60C0((uint64_t)&v824, (uint64_t *)v833);
          uint64_t v624 = v623[2];
          uint64_t v625 = *((unsigned int *)v623 + 7);
          if (v624 == v623[1])
          {
            if (v625)
            {
              v626 = 0;
              uint64_t v627 = 8 * v625;
              v628 = (llvm::Value **)v623[2];
              do
              {
                if (*v628 == v615) {
                  goto LABEL_1269;
                }
                if (*v628 == (llvm::Value *)-2) {
                  v626 = v628;
                }
                ++v628;
                v627 -= 8;
              }
              while (v627);
              if (v626)
              {
                *v626 = v615;
                --*((_DWORD *)v623 + 8);
LABEL_1269:
                v639 = v620 + 1;
                do
                {
                  if (v639 == v621) {
                    goto LABEL_1279;
                  }
                  unint64_t v640 = *v639++;
                }
                while (v640 > 0xFFFFFFFFFFFFFFFDLL);
                v620 = v639 - 1;
                continue;
              }
            }
            unsigned int v629 = *((_DWORD *)v623 + 6);
            if (v625 < v629)
            {
              *((_DWORD *)v623 + 7) = v625 + 1;
              *(void *)(v624 + 8 * v625) = v615;
              goto LABEL_1269;
            }
          }
          else
          {
            unsigned int v629 = *((_DWORD *)v623 + 6);
          }
          break;
        }
        if (3 * v629 <= 4 * ((int)v625 - *((_DWORD *)v623 + 8)))
        {
          if (v629 >= 0x40) {
            v629 *= 2;
          }
          else {
            unsigned int v629 = 128;
          }
        }
        else if (v629 - v625 >= v629 >> 3)
        {
          goto LABEL_1250;
        }
        llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v623 + 1), v629);
        unsigned int v629 = *((_DWORD *)v623 + 6);
        uint64_t v624 = v623[2];
LABEL_1250:
        unsigned int v630 = v629 - 1;
        unsigned int v631 = (v629 - 1) & v622;
        v632 = (llvm::Value **)(v624 + 8 * v631);
        v633 = *v632;
        if (*v632 == (llvm::Value *)-1)
        {
          v634 = 0;
LABEL_1262:
          if (v634) {
            v638 = v634;
          }
          else {
            v638 = v632;
          }
          if (*v638 != v615)
          {
            if (*v638 == (llvm::Value *)-2) {
              --*((_DWORD *)v623 + 8);
            }
            else {
              ++*((_DWORD *)v623 + 7);
            }
            *v638 = v615;
          }
        }
        else
        {
          v634 = 0;
          int v635 = 1;
          while (v633 != v615)
          {
            if (v634) {
              BOOL v636 = 0;
            }
            else {
              BOOL v636 = v633 == (llvm::Value *)-2;
            }
            if (v636) {
              v634 = v632;
            }
            unsigned int v637 = v631 + v635++;
            unsigned int v631 = v637 & v630;
            v632 = (llvm::Value **)(v624 + 8 * (v637 & v630));
            v633 = *v632;
            if (*v632 == (llvm::Value *)-1) {
              goto LABEL_1262;
            }
          }
        }
        goto LABEL_1269;
      }
LABEL_1280:
      int v641 = 0;
      v771 = (char *)v821;
      v642 = (char *)v821 + 8 * v822;
      while (2)
      {
        if (v642 != v771)
        {
          int v776 = v641;
          v643 = (llvm::Value *)*((void *)v642 - 1);
          v773 = v642 - 8;
          v845 = v643;
          v644 = sub_1CCC0F8D0((uint64_t)v806, (uint64_t *)&v845);
          v645 = v644;
          uint64_t v646 = *((unsigned int *)v644 + 28);
          if (v646)
          {
            v696 = (uint64_t *)v644[13];
            uint64_t v697 = *v696;
            *(void *)v833 = 0;
            uint64_t v698 = v806[0];
            unsigned int v699 = v807;
            uint64_t v700 = sub_1CCC0F984(v806[0], v807, v697, v833) ? *(void *)v833 : v698 + 176 * v699;
            sub_1CD6C0634((uint64_t)(v645 + 1), v700 + 16);
            *(_DWORD *)v645 = *(_DWORD *)(v700 + 8);
            if (v646 != 1)
            {
              v701 = &v696[v646];
              v702 = v696 + 1;
              while (2)
              {
                uint64_t v703 = *v702;
                *(void *)v833 = 0;
                uint64_t v704 = v806[0];
                unsigned int v705 = v807;
                if (sub_1CCC0F984(v806[0], v807, v703, v833)) {
                  uint64_t v706 = *(void *)v833;
                }
                else {
                  uint64_t v706 = v704 + 176 * v705;
                }
                if (*(_DWORD *)v645 == -1) {
                  goto LABEL_1435;
                }
                unsigned int v707 = *(_DWORD *)(v706 + 8) + *(_DWORD *)v645;
                *(_DWORD *)v645 = v707;
                if (v707 == -1)
                {
                  sub_1CD3C7F68((_DWORD *)v645 + 2);
                  uint64_t v731 = v645[4];
                  uint64_t v730 = v645[5];
                  if (v730 != v731)
                  {
                    do
                    {
                      uint64_t v732 = v730 - 136;
                      sub_1CD6C05EC((void *)(v730 - 120));
                      uint64_t v730 = v732;
                    }
                    while (v732 != v731);
LABEL_1442:
                    uint64_t v730 = v731;
                  }
                }
                else
                {
                  if (v707 >= *(_DWORD *)(v706 + 8))
                  {
                    uint64_t v708 = *(void *)(v706 + 40);
                    uint64_t v709 = *(void *)(v706 + 48);
                    while (v708 != v709)
                    {
                      uint64_t v710 = sub_1CD6C0750((uint64_t)(v645 + 1), (uint64_t *)v708);
                      if (v711)
                      {
                        char v712 = 0;
                        __b[0] = 0;
                        long long v839 = 0u;
                        long long v838 = 0u;
                        long long v835 = 0u;
                        memset(v833, 0, 24);
                        *(void *)&v833[24] = (char *)&v835 + 8;
                        v834[0] = (char *)&v835 + 8;
                        v834[1] = (void *)2;
                        __b[1] = (char *)&v838 + 8;
                        v837[0] = (char *)&v838 + 8;
                        v837[1] = (void *)2;
                      }
                      else
                      {
                        __int16 v713 = *(_WORD *)(v708 + 8);
                        v833[2] = *(unsigned char *)(v708 + 10);
                        *(_WORD *)v833 = v713;
                        *(_OWORD *)&v833[8] = *(_OWORD *)(v708 + 16);
                        v714 = (char *)&v835 + 8;
                        *(void *)&v833[24] = (char *)&v835 + 8;
                        v715 = *(const void **)(v708 + 40);
                        if (v715 == *(const void **)(v708 + 32))
                        {
                          v834[0] = (char *)&v835 + 8;
                          v716 = v715;
                        }
                        else
                        {
                          uint64_t v726 = *(unsigned int *)(v708 + 48);
                          v714 = (char *)malloc_type_malloc(8 * v726, 0x4065EBACuLL);
                          if (!v714
                            && (v726 || (v714 = (char *)malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0))
                          {
LABEL_1506:
                            llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
                          }
                          v834[0] = v714;
                          v716 = *(const void **)(v708 + 32);
                          v715 = *(const void **)(v708 + 40);
                        }
                        unsigned int v717 = *(_DWORD *)(v708 + 48);
                        LODWORD(v834[1]) = v717;
                        int v718 = *(_DWORD *)(v708 + 52);
                        if (v715 == v716) {
                          unsigned int v719 = *(_DWORD *)(v708 + 52);
                        }
                        else {
                          unsigned int v719 = v717;
                        }
                        if (v719)
                        {
                          memmove(v714, v715, 8 * v719);
                          int v718 = *(_DWORD *)(v708 + 52);
                        }
                        HIDWORD(v834[1]) = v718;
                        LODWORD(v835) = *(_DWORD *)(v708 + 56);
                        v720 = (char *)&v838 + 8;
                        __b[1] = (char *)&v838 + 8;
                        v721 = *(const void **)(v708 + 88);
                        if (v721 == *(const void **)(v708 + 80))
                        {
                          v837[0] = (char *)&v838 + 8;
                          v722 = v721;
                        }
                        else
                        {
                          uint64_t v727 = *(unsigned int *)(v708 + 96);
                          v720 = (char *)malloc_type_malloc(8 * v727, 0x4065EBACuLL);
                          if (!v720)
                          {
                            if (v727) {
                              goto LABEL_1506;
                            }
                            v720 = (char *)malloc_type_malloc(1uLL, 0x4065EBACuLL);
                            if (!v720) {
                              goto LABEL_1506;
                            }
                          }
                          v837[0] = v720;
                          v722 = *(const void **)(v708 + 80);
                          v721 = *(const void **)(v708 + 88);
                        }
                        unsigned int v723 = *(_DWORD *)(v708 + 96);
                        LODWORD(v837[1]) = v723;
                        int v724 = *(_DWORD *)(v708 + 100);
                        if (v721 == v722) {
                          unsigned int v725 = *(_DWORD *)(v708 + 100);
                        }
                        else {
                          unsigned int v725 = v723;
                        }
                        if (v725)
                        {
                          memmove(v720, v721, 8 * v725);
                          int v724 = *(_DWORD *)(v708 + 100);
                        }
                        HIDWORD(v837[1]) = v724;
                        LODWORD(v838) = *(_DWORD *)(v708 + 104);
                        char v712 = *(unsigned char *)(v708 + 128);
                      }
                      BYTE8(v839) = v712;
                      llvm::objcarc::PtrState::Merge((llvm::objcarc::PtrState *)(v710 + 8), (const llvm::objcarc::PtrState *)v833, 1);
                      if (v837[0] != __b[1]) {
                        free(v837[0]);
                      }
                      if (v834[0] != *(void **)&v833[24]) {
                        free(v834[0]);
                      }
                      v708 += 136;
                    }
                    v728 = (uint64_t *)v645[4];
                    for (k = (uint64_t *)v645[5]; v728 != k; v728 += 17)
                    {
                      if (*(void *)(v706 + 48) == sub_1CD6C0800(v706 + 16, *v728))
                      {
                        __b[0] = 0;
                        long long v839 = 0u;
                        long long v838 = 0u;
                        long long v835 = 0u;
                        memset(v833, 0, 24);
                        *(void *)&v833[24] = (char *)&v835 + 8;
                        v834[0] = (char *)&v835 + 8;
                        v834[1] = (void *)2;
                        __b[1] = (char *)&v838 + 8;
                        v837[0] = (char *)&v838 + 8;
                        v837[1] = (void *)2;
                        llvm::objcarc::PtrState::Merge((llvm::objcarc::PtrState *)(v728 + 1), (const llvm::objcarc::PtrState *)v833, 1);
                        if (v837[0] != __b[1]) {
                          free(v837[0]);
                        }
                        if (v834[0] != *(void **)&v833[24]) {
                          free(v834[0]);
                        }
                      }
                    }
                    goto LABEL_1435;
                  }
                  *(_DWORD *)v645 = -1;
                  sub_1CD3C7F68((_DWORD *)v645 + 2);
                  uint64_t v731 = v645[4];
                  uint64_t v730 = v645[5];
                  if (v730 != v731)
                  {
                    do
                    {
                      uint64_t v733 = v730 - 136;
                      sub_1CD6C05EC((void *)(v730 - 120));
                      uint64_t v730 = v733;
                    }
                    while (v733 != v731);
                    goto LABEL_1442;
                  }
                }
                v645[5] = v730;
LABEL_1435:
                if (++v702 == v701)
                {
                  v643 = v845;
                  break;
                }
                continue;
              }
            }
          }
          if (!llvm::BasicBlock::hasNPredecessors(v643, *((_DWORD *)v645 + 28)))
          {
            uint64_t v677 = v645[4];
            uint64_t v678 = v645[5];
            while (v677 != v678)
            {
              *(unsigned char *)(v677 + 128) = 1;
              v677 += 136;
            }
          }
          v648 = (char *)*((void *)v643 + 6);
          v800 = (char *)v643 + 40;
          if (v648 == (char *)v643 + 40)
          {
            int v779 = 0;
            v670 = (uint64_t *)v645[4];
            v671 = (uint64_t *)v645[5];
          }
          else
          {
            int v649 = 0;
            v788 = (llvm::ValueAsMetadata *)(v645 + 1);
            while (2)
            {
              int v778 = v649;
              if (v648) {
                v650 = (llvm::objcarc *)(v648 - 24);
              }
              else {
                v650 = 0;
              }
              int v651 = llvm::objcarc::GetARCInstKind(v650, v647);
              *(void *)v833 = 0;
              unsigned int v652 = v825;
              if (sub_1CD4A7E9C(v824, v825, (uint64_t)v650, v833)) {
                BOOL v653 = *(void *)v833 == (void)v824 + 56 * v652;
              }
              else {
                BOOL v653 = 1;
              }
              if (!v653)
              {
                uint64_t v654 = *(void *)(*(void *)v833 + 16);
                uint64_t v655 = 24;
                if (v654 == *(void *)(*(void *)v833 + 8)) {
                  uint64_t v655 = 28;
                }
                uint64_t v656 = *(unsigned int *)(*(void *)v833 + v655);
                if (v656)
                {
                  uint64_t v657 = 8 * v656;
                  v658 = *(unint64_t **)(*(void *)v833 + 16);
                  while (*v658 >= 0xFFFFFFFFFFFFFFFELL)
                  {
                    ++v658;
                    v657 -= 8;
                    if (!v657) {
                      goto LABEL_1310;
                    }
                  }
                }
                else
                {
                  v658 = *(unint64_t **)(*(void *)v833 + 16);
                }
                v659 = (unint64_t *)(v654 + 8 * v656);
                if (v658 != v659)
                {
                  unint64_t v660 = *v658;
                  while (1)
                  {
                    *(void *)v833 = v660;
                    uint64_t v661 = sub_1CD6C09D8((uint64_t)v788, (uint64_t *)v833);
                    if (*(unsigned char *)(v661 + 2) == 1) {
                      *(unsigned char *)(v661 + 120) = 1;
                    }
                    v662 = v658 + 1;
                    do
                    {
                      if (v662 == v659) {
                        goto LABEL_1310;
                      }
                      unint64_t v663 = *v662++;
                      unint64_t v660 = v663;
                    }
                    while (v663 > 0xFFFFFFFFFFFFFFFDLL);
                    v658 = v662 - 1;
                  }
                }
              }
LABEL_1310:
              BOOL inited = 0;
              v665 = 0;
              switch(v651)
              {
                case 0:
                case 1:
                  v665 = sub_1CD4B3548(*((llvm::Value **)v650 - 4 * (*((_DWORD *)v650 + 5) & 0x7FFFFFF)));
                  *(void *)v833 = v665;
                  uint64_t v666 = sub_1CD6C09D8((uint64_t)v788, (uint64_t *)v833);
                  BOOL inited = llvm::objcarc::TopDownPtrState::InitTopDown(v666, v651, (uint64_t)v650);
                  goto LABEL_1313;
                case 2:
                case 3:
                case 5:
                case 6:
                  goto LABEL_1313;
                case 4:
                  v665 = sub_1CD4B3548(*((llvm::Value **)v650 - 4 * (*((_DWORD *)v650 + 5) & 0x7FFFFFF)));
                  *(void *)v833 = v665;
                  uint64_t v672 = sub_1CD6C09D8((uint64_t)v788, (uint64_t *)v833);
                  if (llvm::objcarc::TopDownPtrState::MatchWithRelease(v672, v763, v650))
                  {
                    *(void *)v833 = v650;
                    v676 = sub_1CD6C0BE0((uint64_t)v813, (uint64_t *)v833);
                    sub_1CD6C06F8((uint64_t)(v676 + 1), v672 + 8);
                    llvm::objcarc::PtrState::ResetSequenceProgress(v672, 0);
                  }
                  BOOL inited = 0;
                  goto LABEL_1313;
                case 7:
                  goto LABEL_1320;
                case 8:
                  sub_1CD3C7F68(v788);
                  uint64_t v674 = v645[4];
                  uint64_t v673 = v645[5];
                  if (v673 != v674)
                  {
                    do
                    {
                      uint64_t v675 = v673 - 136;
                      sub_1CD6C05EC((void *)(v673 - 120));
                      uint64_t v673 = v675;
                    }
                    while (v675 != v674);
                  }
                  BOOL inited = 0;
                  v645[5] = v674;
                  goto LABEL_1320;
                default:
                  if (v651 != 24)
                  {
LABEL_1313:
                    uint64_t v667 = v645[4];
                    for (uint64_t m = v645[5]; v667 != m; v667 += 136)
                    {
                      v669 = *(const llvm::Value **)v667;
                      if (*(llvm::Value **)v667 != v665
                        && (llvm::objcarc::TopDownPtrState::HandlePotentialAlterRefCount(v667 + 8, (uint64_t)v650, *(const llvm::Value **)v667, v774, v651, *(uint64_t **)(v782 + 192)) & 1) == 0&& *(unsigned char *)(v667 + 10) == 2&& llvm::objcarc::CanUse((uint64_t)v650, v669, (const llvm::Value **)v774, v651))
                      {
                        *(unsigned char *)(v667 + 10) = 3;
                      }
                    }
                  }
LABEL_1320:
                  v670 = (uint64_t *)v645[4];
                  v671 = (uint64_t *)v645[5];
                  if (dword_1EBCEF2B0 < -252645135
                                       * ((unint64_t)((char *)v671 - (char *)v670) >> 3))
                  {
                    char v764 = 0;
                    uint64_t v7 = v782;
                    *(unsigned char *)(v782 + 200) = 1;
                    goto LABEL_1445;
                  }
                  int v649 = v778 | inited;
                  v648 = (char *)*((void *)v648 + 1);
                  if (v648 != v800) {
                    continue;
                  }
                  int v779 = v778 | inited;
                  break;
              }
              break;
            }
          }
          uint64_t v7 = v782;
          if (v670 == v671) {
            goto LABEL_1381;
          }
          v785 = v671;
          v789 = (llvm::Value *)((char *)v845 + 40);
LABEL_1335:
          if (!*((unsigned char *)v670 + 10)) {
            goto LABEL_1370;
          }
          uint64_t v679 = *(void *)v789;
          if (*(llvm::ValueAsMetadata **)v789 == v789) {
            goto LABEL_1370;
          }
          if (v679) {
            uint64_t v680 = v679 - 24;
          }
          else {
            uint64_t v680 = 0;
          }
          uint64_t v681 = *v670;
          if (*(unsigned char *)(v680 + 16) != 30)
          {
            int v695 = 2;
            switch(*(unsigned char *)(v680 + 16))
            {
              case 0x1E:
                goto LABEL_1505;
              case 0x1F:
                int v695 = (*(_DWORD *)(v680 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_1374;
              case 0x20:
              case 0x26:
                int v695 = (*(_DWORD *)(v680 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_1374;
              case 0x21:
                goto LABEL_1345;
              case 0x24:
                int v695 = *(_WORD *)(v680 + 18) & 1;
                goto LABEL_1374;
              case 0x25:
                int v695 = 1;
                goto LABEL_1345;
              case 0x27:
                int v695 = *(_DWORD *)(v680 + 80) + 1;
LABEL_1374:
                if (!v695) {
                  goto LABEL_1370;
                }
                goto LABEL_1345;
              default:
                goto LABEL_1370;
            }
          }
          if ((*(_DWORD *)(v680 + 20) & 0x7FFFFFF) == 3) {
            int v695 = 2;
          }
          else {
            int v695 = 1;
          }
LABEL_1345:
          int v682 = 0;
          char v683 = 0;
          unsigned int v684 = 0;
          uint64_t v801 = (uint64_t)(v670 + 1);
          int v685 = 1;
LABEL_1346:
          uint64_t v686 = llvm::Instruction::getSuccessor((llvm::Instruction *)v680, v684);
          *(void *)v833 = 0;
          uint64_t v687 = v806[0];
          unsigned int v688 = v807;
          int v689 = sub_1CCC0F984(v806[0], v807, v686, v833);
          uint64_t v690 = *(void *)v833;
          if (!v689) {
            uint64_t v690 = v687 + 176 * v688;
          }
          *(void *)v833 = v681;
          uint64_t v691 = sub_1CD6C09D8(v690 + 64, (uint64_t *)v833);
          int v692 = *(unsigned __int8 *)(v691 + 2);
          if (!*(unsigned char *)(v691 + 2)) {
            goto LABEL_1362;
          }
          int v693 = *(unsigned __int8 *)(v691 + 8);
          int v694 = *((unsigned __int8 *)v670 + 10);
          if (v694 == 2)
          {
            if ((v692 - 3) >= 3)
            {
              if (v692 != 2) {
                goto LABEL_1363;
              }
              goto LABEL_1361;
            }
          }
          else
          {
            if (v694 != 3) {
              goto LABEL_1363;
            }
            if ((v692 - 4) >= 2)
            {
              if (v692 != 3)
              {
                if (v692 != 2) {
                  goto LABEL_1363;
                }
                if (*((unsigned __int8 *)v670 + 16) | v693)
                {
                  *((unsigned char *)v670 + 128) = 1;
                  goto LABEL_1363;
                }
LABEL_1362:
                llvm::objcarc::PtrState::ResetSequenceProgress(v801, 0);
LABEL_1363:
                if (v695 == ++v684)
                {
                  if (v682 && !v685)
                  {
                    llvm::objcarc::PtrState::ResetSequenceProgress(v801, 0);
                    uint64_t v7 = v782;
                    v671 = v785;
                  }
                  else
                  {
                    uint64_t v7 = v782;
                    v671 = v785;
                    if (v683) {
                      *((unsigned char *)v670 + 128) = 1;
                    }
                  }
LABEL_1370:
                  v670 += 17;
                  if (v670 == v671)
                  {
LABEL_1381:
                    int v641 = v776 | v779;
                    v642 = v773;
                    if (*(unsigned char *)(v7 + 200))
                    {
                      char v764 = 0;
                      goto LABEL_1445;
                    }
                    continue;
                  }
                  goto LABEL_1335;
                }
                goto LABEL_1346;
              }
LABEL_1361:
              int v682 = 1;
              goto LABEL_1363;
            }
          }
          if (*((unsigned __int8 *)v670 + 16) | v693) {
            char v683 = 1;
          }
          else {
            int v685 = 0;
          }
          goto LABEL_1363;
        }
        break;
      }
      char v764 = v641 & v780;
LABEL_1445:
      uint64_t v734 = v824;
      sub_1CD6C0F9C(v824, v825);
      MEMORY[0x1D25D9CD0](v734, 8);
LABEL_703:
      if (v818 != v820) {
        free(v818);
      }
      if (v821 != v823) {
        free(v821);
      }
      if (*(unsigned char *)(v7 + 200))
      {
        char v357 = 0;
        goto LABEL_1207;
      }
      v845 = (llvm::Value *)&v847;
      v846 = (void *)0x800000000;
      v355 = v810;
      v356 = v811;
      if (v810 == v811)
      {
        BOOL v765 = 0;
        goto LABEL_1204;
      }
      BOOL v765 = 0;
      v767 = v811;
      while (2)
      {
        uint64_t v358 = *v355;
        if (!*v355) {
          goto LABEL_713;
        }
        v769 = v355;
        v359 = sub_1CD4B3548(*(llvm::Value **)(v358 - 32 * (*(_DWORD *)(v358 + 20) & 0x7FFFFFF)));
        unsigned int v360 = *((unsigned __int8 *)v359 + 16);
        BOOL v362 = v360 < 0x15 || v360 == 59;
        char v775 = v362;
        v768 = v359;
        if (v359 && v360 == 60)
        {
          v539 = sub_1CD4B3548(*((llvm::Value **)v359 - 4));
          if (v539 && *((unsigned char *)v539 + 16) == 3) {
            v775 |= *((unsigned char *)v539 + 80);
          }
        }
        int v770 = 0;
        int v772 = 0;
        int v787 = 0;
        BOOL v363 = 0;
        *(_WORD *)v833 = 0;
        *(void *)&v833[8] = 0;
        *(void *)&v833[16] = &v835;
        *(void *)&v833[24] = &v835;
        v834[0] = (void *)2;
        LODWORD(v834[1]) = 0;
        __b[0] = &v838;
        __b[1] = &v838;
        v837[0] = (void *)2;
        LODWORD(v837[1]) = 0;
        LOBYTE(v839) = 0;
        LOWORD(v824) = 0;
        *((void *)&v824 + 1) = 0;
        *(void *)&long long v825 = v827;
        *((void *)&v825 + 1) = v827;
        *(void *)&long long v826 = 2;
        DWORD2(v826) = 0;
        v828 = v832;
        v829 = v832;
        uint64_t v830 = 2;
        int v831 = 0;
        v832[16] = 0;
        v840 = &v842;
        uint64_t v842 = v358;
        char v784 = 1;
        int v364 = 1;
        int v365 = 1;
        v841 = (void *)0x400000001;
        while (2)
        {
          v821 = v823;
          uint64_t v822 = 0x400000000;
          if (!v841)
          {
            LODWORD(v841) = 0;
            int v445 = 2;
            goto LABEL_1057;
          }
          v366 = (uint64_t *)v840;
          v367 = (uint64_t *)((char *)v840 + 8 * v841);
          while (2)
          {
            uint64_t v368 = *v366;
            uint64_t v369 = sub_1CD6C1000((uint64_t)v808, *v366);
            int v365 = v365 & (*(unsigned char *)(v369 + 8) != 0);
            BOOL v363 = (*(unsigned __int8 *)(v369 + 120) | v363) != 0;
            uint64_t v370 = *(void *)(v369 + 32);
            uint64_t v371 = 44;
            if (v370 != *(void *)(v369 + 24)) {
              uint64_t v371 = 40;
            }
            uint64_t v372 = *(unsigned int *)(v369 + v371);
            if (v372)
            {
              uint64_t v373 = 8 * v372;
              v374 = *(unint64_t **)(v369 + 32);
              while (*v374 >= 0xFFFFFFFFFFFFFFFELL)
              {
                ++v374;
                v373 -= 8;
                if (!v373) {
                  goto LABEL_888;
                }
              }
              int v798 = v365;
            }
            else
            {
              int v798 = v365;
              v374 = *(unint64_t **)(v369 + 32);
            }
            v375 = (unint64_t *)(v370 + 8 * v372);
            if (v374 != v375)
            {
              unsigned int v376 = v814;
              if (v814)
              {
                v781 = v367;
                unint64_t v377 = *v374;
                while (2)
                {
                  unsigned int v378 = (v377 >> 4) ^ (v377 >> 9);
                  uint64_t v379 = v378 & (v376 - 1);
                  uint64_t v380 = v813[0] + (v379 << 7);
                  uint64_t v381 = *(void *)v380;
                  if (v377 != *(void *)v380)
                  {
                    int v446 = 1;
                    while (v381 != -4096)
                    {
                      int v447 = v379 + v446++;
                      uint64_t v379 = v447 & (v376 - 1);
                      uint64_t v381 = *(void *)(v813[0] + ((unint64_t)v379 << 7));
                      if (v377 == v381)
                      {
                        uint64_t v380 = v813[0] + (v379 << 7);
                        goto LABEL_739;
                      }
                    }
                    break;
                  }
LABEL_739:
                  if (v379 != v376)
                  {
                    uint64_t v383 = *(void *)(v380 + 24);
                    uint64_t v382 = *(void *)(v380 + 32);
                    if (v382 == v383)
                    {
                      uint64_t v384 = *(unsigned int *)(v380 + 44);
                      v385 = (void *)(v382 + 8 * v384);
                      if (v384)
                      {
                        uint64_t v386 = 0;
                        uint64_t v387 = 8 * v384;
                        while (*(void *)(v382 + v386) != v368)
                        {
                          v386 += 8;
                          if (v387 == v386) {
                            goto LABEL_758;
                          }
                        }
                        v385 = (void *)(v382 + v386);
                      }
LABEL_758:
                      uint64_t v383 = *(void *)(v380 + 32);
                    }
                    else
                    {
                      uint64_t v388 = *(unsigned int *)(v380 + 40);
                      int v389 = v388 - 1;
                      unsigned int v390 = (v388 - 1) & ((v368 >> 4) ^ (v368 >> 9));
                      v385 = (void *)(v382 + 8 * v390);
                      uint64_t v391 = *v385;
                      if (*v385 == -1)
                      {
                        v392 = 0;
LABEL_871:
                        if (v392) {
                          v385 = v392;
                        }
                        if (*v385 != v368) {
                          v385 = (void *)(v382 + 8 * v388);
                        }
                      }
                      else
                      {
                        v392 = 0;
                        int v393 = 1;
                        while (v391 != v368)
                        {
                          if (v392) {
                            BOOL v394 = 0;
                          }
                          else {
                            BOOL v394 = v391 == -2;
                          }
                          if (v394) {
                            v392 = v385;
                          }
                          unsigned int v395 = v390 + v393++;
                          unsigned int v390 = v395 & v389;
                          v385 = (void *)(v382 + 8 * (v395 & v389));
                          uint64_t v391 = *v385;
                          if (*v385 == -1) {
                            goto LABEL_871;
                          }
                        }
                      }
                    }
                    BOOL v132 = v382 == v383;
                    uint64_t v396 = 44;
                    if (!v132) {
                      uint64_t v396 = 40;
                    }
                    if (v385 != (void *)(v382 + 8 * *(unsigned int *)(v380 + v396)))
                    {
                      uint64_t v397 = *((void *)&v825 + 1);
                      uint64_t v398 = DWORD1(v826);
                      if (*((void *)&v825 + 1) == (void)v825)
                      {
                        if (DWORD1(v826))
                        {
                          v399 = 0;
                          uint64_t v400 = 8 * DWORD1(v826);
                          v401 = (unint64_t *)*((void *)&v825 + 1);
                          while (*v401 != v377)
                          {
                            if (*v401 == -2) {
                              v399 = v401;
                            }
                            ++v401;
                            v400 -= 8;
                            if (!v400)
                            {
                              if (!v399) {
                                goto LABEL_770;
                              }
                              unint64_t *v399 = v377;
                              --DWORD2(v826);
                              goto LABEL_794;
                            }
                          }
                          goto LABEL_865;
                        }
LABEL_770:
                        unsigned int v402 = v826;
                        if (DWORD1(v826) < v826)
                        {
                          ++DWORD1(v826);
                          *(void *)(*((void *)&v825 + 1) + 8 * v398) = v377;
                          goto LABEL_794;
                        }
                      }
                      else
                      {
                        unsigned int v402 = v826;
                      }
                      if (3 * v402 <= 4 * (DWORD1(v826) - DWORD2(v826)))
                      {
                        if (v402 >= 0x40) {
                          v402 *= 2;
                        }
                        else {
                          unsigned int v402 = 128;
                        }
                      }
                      else if (v402 - DWORD1(v826) >= v402 >> 3)
                      {
                        goto LABEL_775;
                      }
                      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v825, v402);
                      unsigned int v402 = v826;
                      uint64_t v397 = *((void *)&v825 + 1);
LABEL_775:
                      unsigned int v403 = v402 - 1;
                      unsigned int v404 = (v402 - 1) & v378;
                      v405 = (unint64_t *)(v397 + 8 * v404);
                      unint64_t v406 = *v405;
                      if (*v405 != -1)
                      {
                        v407 = 0;
                        int v408 = 1;
                        while (v406 != v377)
                        {
                          if (v407) {
                            BOOL v409 = 0;
                          }
                          else {
                            BOOL v409 = v406 == -2;
                          }
                          if (v409) {
                            v407 = v405;
                          }
                          unsigned int v410 = v404 + v408++;
                          unsigned int v404 = v410 & v403;
                          v405 = (unint64_t *)(v397 + 8 * (v410 & v403));
                          unint64_t v406 = *v405;
                          if (*v405 == -1) {
                            goto LABEL_787;
                          }
                        }
                        goto LABEL_865;
                      }
                      v407 = 0;
LABEL_787:
                      if (v407) {
                        v411 = v407;
                      }
                      else {
                        v411 = v405;
                      }
                      if (*v411 == v377) {
                        goto LABEL_865;
                      }
                      if (*v411 == -2) {
                        --DWORD2(v826);
                      }
                      else {
                        ++DWORD1(v826);
                      }
                      unint64_t *v411 = v377;
LABEL_794:
                      v818 = *(void **)(v377 + 40);
                      v412 = (unsigned int *)sub_1CCC0F8D0((uint64_t)v806, (uint64_t *)&v818);
                      if (*v412 != -1)
                      {
                        unsigned int v413 = v412[1];
                        if (v413 != -1)
                        {
                          unint64_t v414 = *v412 * (unint64_t)v413;
                          if ((v414 & 0xFFFFFFFF00000000) == 0 && v414 != -1)
                          {
                            if (v784)
                            {
                              *((void *)&v824 + 1) = *(void *)(v380 + 16);
                              char v415 = *(unsigned char *)(v380 + 9);
                              goto LABEL_804;
                            }
                            if (*((void *)&v824 + 1) != *(void *)(v380 + 16)) {
                              *((void *)&v824 + 1) = 0;
                            }
                            if (BYTE1(v824) != *(unsigned __int8 *)(v380 + 9))
                            {
                              char v415 = 0;
LABEL_804:
                              BYTE1(v824) = v415;
                            }
                            v787 -= v414;
                            if ((v775 & 1) == 0)
                            {
                              uint64_t v416 = *(void *)(v380 + 80);
                              uint64_t v417 = 88;
                              if (v416 == *(void *)(v380 + 72)) {
                                uint64_t v417 = 92;
                              }
                              uint64_t v418 = *(unsigned int *)(v380 + v417);
                              if (v418)
                              {
                                uint64_t v419 = 8 * v418;
                                v420 = *(unint64_t **)(v380 + 80);
                                while (*v420 >= 0xFFFFFFFFFFFFFFFELL)
                                {
                                  ++v420;
                                  v419 -= 8;
                                  if (!v419) {
                                    goto LABEL_863;
                                  }
                                }
                              }
                              else
                              {
                                v420 = *(unint64_t **)(v380 + 80);
                              }
                              v421 = (unint64_t *)(v416 + 8 * v418);
                              if (v420 != v421)
                              {
                                unint64_t v422 = *v420;
LABEL_816:
                                v423 = (char *)v829;
                                uint64_t v424 = HIDWORD(v830);
                                if (v829 == v828)
                                {
                                  if (HIDWORD(v830))
                                  {
                                    v425 = 0;
                                    uint64_t v426 = 8 * HIDWORD(v830);
                                    v427 = (unint64_t *)v829;
                                    while (*v427 != v422)
                                    {
                                      if (*v427 == -2) {
                                        v425 = v427;
                                      }
                                      ++v427;
                                      v426 -= 8;
                                      if (!v426)
                                      {
                                        if (!v425) {
                                          goto LABEL_824;
                                        }
                                        unint64_t *v425 = v422;
                                        --v831;
                                        goto LABEL_848;
                                      }
                                    }
                                    goto LABEL_853;
                                  }
LABEL_824:
                                  unsigned int v428 = v830;
                                  if (HIDWORD(v830) < v830)
                                  {
                                    ++HIDWORD(v830);
                                    *((void *)v829 + v424) = v422;
                                    goto LABEL_848;
                                  }
                                }
                                else
                                {
                                  unsigned int v428 = v830;
                                }
                                if (3 * v428 <= 4 * (HIDWORD(v830) - v831))
                                {
                                  if (v428 >= 0x40) {
                                    v428 *= 2;
                                  }
                                  else {
                                    unsigned int v428 = 128;
                                  }
                                }
                                else if (v428 - HIDWORD(v830) >= v428 >> 3)
                                {
                                  goto LABEL_829;
                                }
                                llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v828, v428);
                                unsigned int v428 = v830;
                                v423 = (char *)v829;
LABEL_829:
                                unsigned int v429 = v428 - 1;
                                unsigned int v430 = (v428 - 1) & ((v422 >> 4) ^ (v422 >> 9));
                                v431 = &v423[8 * v430];
                                uint64_t v432 = *(void *)v431;
                                if (*(void *)v431 != -1)
                                {
                                  v433 = 0;
                                  int v434 = 1;
                                  while (v432 != v422)
                                  {
                                    if (v433) {
                                      BOOL v435 = 0;
                                    }
                                    else {
                                      BOOL v435 = v432 == -2;
                                    }
                                    if (v435) {
                                      v433 = (unint64_t *)v431;
                                    }
                                    unsigned int v436 = v430 + v434++;
                                    unsigned int v430 = v436 & v429;
                                    v431 = &v423[8 * (v436 & v429)];
                                    uint64_t v432 = *(void *)v431;
                                    if (*(void *)v431 == -1) {
                                      goto LABEL_841;
                                    }
                                  }
                                  goto LABEL_853;
                                }
                                v433 = 0;
LABEL_841:
                                if (v433) {
                                  v437 = v433;
                                }
                                else {
                                  v437 = (unint64_t *)v431;
                                }
                                if (*v437 != v422)
                                {
                                  if (*v437 == -2) {
                                    --v831;
                                  }
                                  else {
                                    ++HIDWORD(v830);
                                  }
                                  unint64_t *v437 = v422;
LABEL_848:
                                  v818 = *(void **)(v422 + 40);
                                  v438 = (unsigned int *)sub_1CCC0F8D0((uint64_t)v806, (uint64_t *)&v818);
                                  if (*v438 == -1)
                                  {
                                    char v784 = 0;
                                    goto LABEL_1055;
                                  }
                                  unsigned int v439 = v438[1];
                                  if (v439 != -1)
                                  {
                                    unint64_t v440 = *v438 * (unint64_t)v439;
                                    if ((v440 & 0xFFFFFFFF00000000) == 0 && v440 != -1)
                                    {
                                      v772 -= v440;
                                      goto LABEL_853;
                                    }
                                  }
                                  char v784 = 0;
                                  break;
                                }
LABEL_853:
                                v441 = v420 + 1;
                                while (v441 != v421)
                                {
                                  unint64_t v442 = *v441++;
                                  unint64_t v422 = v442;
                                  if (v442 <= 0xFFFFFFFFFFFFFFFDLL)
                                  {
                                    v420 = v441 - 1;
                                    goto LABEL_816;
                                  }
                                }
                              }
                            }
LABEL_863:
                            if (v822 >= (unint64_t)HIDWORD(v822)) {
                              llvm::SmallVectorBase<unsigned int>::grow_pod();
                            }
                            char v784 = 0;
                            *((void *)v821 + v822) = v377;
                            LODWORD(v822) = v822 + 1;
LABEL_865:
                            v443 = v374 + 1;
                            do
                            {
                              if (v443 == v375)
                              {
                                int v365 = v798;
                                v367 = v781;
                                goto LABEL_888;
                              }
                              unint64_t v444 = *v443++;
                              unint64_t v377 = v444;
                            }
                            while (v444 > 0xFFFFFFFFFFFFFFFDLL);
                            unsigned int v376 = v814;
                            v374 = v443 - 1;
                            int v445 = 1;
                            if (v814) {
                              continue;
                            }
                            goto LABEL_1056;
                          }
                        }
                      }
                    }
                  }
                  break;
                }
              }
              int v445 = 1;
              goto LABEL_1056;
            }
            int v365 = v798;
LABEL_888:
            if (++v366 != v367) {
              continue;
            }
            break;
          }
          LODWORD(v841) = 0;
          if (!v822)
          {
            int v445 = 2;
            goto LABEL_1057;
          }
          v448 = (uint64_t *)v821;
          v449 = (char *)v821 + 8 * v822;
          int v798 = v365;
          while (1)
          {
            uint64_t v450 = *v448;
            if (v814)
            {
              unsigned int v451 = v814 - 1;
              uint64_t v452 = v813[0]
                   + ((unint64_t)(((v450 >> 4) ^ (v450 >> 9)) & (v814 - 1)) << 7);
              uint64_t v453 = *(void *)v452;
              if (v450 != *(void *)v452)
              {
                int v454 = 1;
                LODWORD(v455) = ((v450 >> 4) ^ (v450 >> 9)) & v451;
                while (v453 != -4096)
                {
                  int v456 = v455 + v454++;
                  uint64_t v455 = v456 & v451;
                  uint64_t v453 = *(void *)(v813[0] + ((unint64_t)v455 << 7));
                  if (v450 == v453)
                  {
                    uint64_t v452 = v813[0] + (v455 << 7);
                    goto LABEL_898;
                  }
                }
                uint64_t v452 = v813[0] + ((unint64_t)v814 << 7);
              }
            }
            else
            {
              uint64_t v452 = v813[0];
            }
LABEL_898:
            int v364 = v364 & (*(unsigned char *)(v452 + 8) != 0);
            BOOL v363 = (*(unsigned __int8 *)(v452 + 120) | v363) != 0;
            uint64_t v457 = *(void *)(v452 + 32);
            uint64_t v458 = v457 == *(void *)(v452 + 24) ? 44 : 40;
            uint64_t v459 = *(unsigned int *)(v452 + v458);
            if (v459)
            {
              uint64_t v460 = 8 * v459;
              v461 = *(uint64_t **)(v452 + 32);
              while ((unint64_t)*v461 >= 0xFFFFFFFFFFFFFFFELL)
              {
                ++v461;
                v460 -= 8;
                if (!v460) {
                  goto LABEL_908;
                }
              }
            }
            else
            {
              v461 = *(uint64_t **)(v452 + 32);
            }
            v462 = (uint64_t *)(v457 + 8 * v459);
            if (v461 != v462) {
              break;
            }
LABEL_908:
            if (++v448 == (uint64_t *)v449)
            {
              int v445 = 2 * (v841 == 0);
              goto LABEL_1057;
            }
          }
          uint64_t v463 = *v461;
          uint64_t v464 = sub_1CD6C1000((uint64_t)v808, *v461);
          if (v811 == (void *)v464) {
            goto LABEL_1055;
          }
          uint64_t v465 = v464;
          unsigned int v466 = (v450 >> 4) ^ (v450 >> 9);
          while (2)
          {
            uint64_t v468 = *(void *)(v465 + 24);
            uint64_t v467 = *(void *)(v465 + 32);
            if (v467 == v468)
            {
              uint64_t v469 = *(unsigned int *)(v465 + 44);
              v470 = (void *)(v467 + 8 * v469);
              if (v469)
              {
                uint64_t v471 = 0;
                uint64_t v472 = 8 * v469;
                while (*(void *)(v467 + v471) != v450)
                {
                  v471 += 8;
                  if (v472 == v471) {
                    goto LABEL_930;
                  }
                }
                v470 = (void *)(v467 + v471);
LABEL_930:
                uint64_t v468 = *(void *)(v465 + 32);
              }
              else
              {
                uint64_t v468 = *(void *)(v465 + 32);
              }
            }
            else
            {
              uint64_t v473 = *(unsigned int *)(v465 + 40);
              int v474 = v473 - 1;
              unsigned int v475 = (v473 - 1) & v466;
              v470 = (void *)(v467 + 8 * v475);
              uint64_t v476 = *v470;
              v477 = 0;
              if (*v470 == -1)
              {
LABEL_932:
                if (v477) {
                  v470 = v477;
                }
                if (*v470 != v450) {
                  v470 = (void *)(v467 + 8 * v473);
                }
              }
              else
              {
                int v478 = 1;
                while (v476 != v450)
                {
                  if (v477) {
                    BOOL v479 = 0;
                  }
                  else {
                    BOOL v479 = v476 == -2;
                  }
                  if (v479) {
                    v477 = v470;
                  }
                  unsigned int v480 = v475 + v478++;
                  unsigned int v475 = v480 & v474;
                  v470 = (void *)(v467 + 8 * (v480 & v474));
                  uint64_t v476 = *v470;
                  if (*v470 == -1) {
                    goto LABEL_932;
                  }
                }
              }
            }
            uint64_t v481 = v467 == v468 ? 44 : 40;
            if (v470 == (void *)(v467 + 8 * *(unsigned int *)(v465 + v481))) {
              goto LABEL_1055;
            }
            uint64_t v482 = *(void *)&v833[24];
            uint64_t v483 = HIDWORD(v834[0]);
            if (*(void *)&v833[24] == *(void *)&v833[16])
            {
              if (HIDWORD(v834[0]))
              {
                v484 = 0;
                uint64_t v485 = 8 * HIDWORD(v834[0]);
                v486 = *(uint64_t **)&v833[24];
                while (*v486 != v463)
                {
                  if (*v486 == -2) {
                    v484 = v486;
                  }
                  ++v486;
                  v485 -= 8;
                  if (!v485)
                  {
                    if (!v484) {
                      goto LABEL_948;
                    }
                    uint64_t *v484 = v463;
                    --LODWORD(v834[1]);
                    goto LABEL_972;
                  }
                }
                goto LABEL_1036;
              }
LABEL_948:
              unsigned int v487 = v834[0];
              if (HIDWORD(v834[0]) < LODWORD(v834[0]))
              {
                ++HIDWORD(v834[0]);
                *(void *)(*(void *)&v833[24] + 8 * v483) = v463;
                goto LABEL_972;
              }
            }
            else
            {
              unsigned int v487 = v834[0];
            }
            if (3 * v487 <= 4 * (HIDWORD(v834[0]) - LODWORD(v834[1])))
            {
              if (v487 >= 0x40) {
                v487 *= 2;
              }
              else {
                unsigned int v487 = 128;
              }
            }
            else if (v487 - HIDWORD(v834[0]) >= v487 >> 3)
            {
              goto LABEL_953;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v833[16], v487);
            unsigned int v487 = v834[0];
            uint64_t v482 = *(void *)&v833[24];
LABEL_953:
            unsigned int v488 = v487 - 1;
            unsigned int v489 = (v487 - 1) & ((v463 >> 4) ^ (v463 >> 9));
            v490 = (uint64_t *)(v482 + 8 * v489);
            uint64_t v491 = *v490;
            if (*v490 != -1)
            {
              v492 = 0;
              int v493 = 1;
              while (v491 != v463)
              {
                if (v492) {
                  BOOL v494 = 0;
                }
                else {
                  BOOL v494 = v491 == -2;
                }
                if (v494) {
                  v492 = v490;
                }
                unsigned int v495 = v489 + v493++;
                unsigned int v489 = v495 & v488;
                v490 = (uint64_t *)(v482 + 8 * (v495 & v488));
                uint64_t v491 = *v490;
                if (*v490 == -1) {
                  goto LABEL_965;
                }
              }
              goto LABEL_1036;
            }
            v492 = 0;
LABEL_965:
            if (v492) {
              v496 = v492;
            }
            else {
              v496 = v490;
            }
            if (*v496 == v463)
            {
LABEL_1036:
              v527 = (unint64_t *)(v461 + 1);
              do
              {
                if (v527 == (unint64_t *)v462)
                {
                  int v365 = v798;
                  goto LABEL_908;
                }
                unint64_t v528 = *v527++;
                uint64_t v463 = v528;
              }
              while (v528 > 0xFFFFFFFFFFFFFFFDLL);
              uint64_t v465 = sub_1CD6C1000((uint64_t)v808, v463);
              v461 = (uint64_t *)(v527 - 1);
              int v445 = 1;
              unsigned int v466 = (v450 >> 4) ^ (v450 >> 9);
              if (v811 != (void *)v465) {
                continue;
              }
              goto LABEL_1056;
            }
            break;
          }
          if (*v496 == -2) {
            --LODWORD(v834[1]);
          }
          else {
            ++HIDWORD(v834[0]);
          }
          uint64_t *v496 = v463;
LABEL_972:
          v818 = *(void **)(v463 + 40);
          v497 = (unsigned int *)sub_1CCC0F8D0((uint64_t)v806, (uint64_t *)&v818);
          if (*v497 == -1) {
            goto LABEL_1055;
          }
          unsigned int v498 = v497[1];
          if (v498 == -1) {
            goto LABEL_1055;
          }
          unint64_t v499 = *v497 * (unint64_t)v498;
          if ((v499 & 0xFFFFFFFF00000000) != 0 || v499 == -1) {
            goto LABEL_1055;
          }
          v787 += v499;
          if (v775) {
            goto LABEL_1034;
          }
          uint64_t v500 = *(void *)(v465 + 80);
          uint64_t v501 = 88;
          if (v500 == *(void *)(v465 + 72)) {
            uint64_t v501 = 92;
          }
          uint64_t v502 = *(unsigned int *)(v465 + v501);
          if (v502)
          {
            uint64_t v503 = 8 * v502;
            v504 = *(unint64_t **)(v465 + 80);
            while (*v504 >= 0xFFFFFFFFFFFFFFFELL)
            {
              ++v504;
              v503 -= 8;
              if (!v503) {
                goto LABEL_1034;
              }
            }
          }
          else
          {
            v504 = *(unint64_t **)(v465 + 80);
          }
          v505 = (unint64_t *)(v500 + 8 * v502);
          if (v504 == v505) {
            goto LABEL_1034;
          }
          unint64_t v506 = *v504;
          v777 = (unint64_t *)(v500 + 8 * v502);
LABEL_987:
          v507 = (char *)__b[1];
          uint64_t v508 = HIDWORD(v837[0]);
          if (__b[1] != __b[0])
          {
            unsigned int v512 = v837[0];
LABEL_998:
            if (3 * v512 <= 4 * (HIDWORD(v837[0]) - LODWORD(v837[1])))
            {
              if (v512 >= 0x40) {
                v512 *= 2;
              }
              else {
                unsigned int v512 = 128;
              }
            }
            else if (v512 - HIDWORD(v837[0]) >= v512 >> 3)
            {
LABEL_1000:
              unsigned int v513 = v512 - 1;
              unsigned int v514 = (v512 - 1) & ((v506 >> 4) ^ (v506 >> 9));
              v515 = &v507[8 * v514];
              uint64_t v516 = *(void *)v515;
              if (*(void *)v515 != -1)
              {
                v517 = 0;
                int v518 = 1;
                while (v516 != v506)
                {
                  if (v517) {
                    BOOL v519 = 0;
                  }
                  else {
                    BOOL v519 = v516 == -2;
                  }
                  if (v519) {
                    v517 = (unint64_t *)v515;
                  }
                  unsigned int v520 = v514 + v518++;
                  unsigned int v514 = v520 & v513;
                  v515 = &v507[8 * (v520 & v513)];
                  uint64_t v516 = *(void *)v515;
                  if (*(void *)v515 == -1) {
                    goto LABEL_1012;
                  }
                }
                goto LABEL_1024;
              }
              v517 = 0;
LABEL_1012:
              if (v517) {
                v521 = v517;
              }
              else {
                v521 = (unint64_t *)v515;
              }
              if (*v521 != v506)
              {
                if (*v521 == -2) {
                  --LODWORD(v837[1]);
                }
                else {
                  ++HIDWORD(v837[0]);
                }
                unint64_t *v521 = v506;
                goto LABEL_1019;
              }
LABEL_1024:
              v525 = v504 + 1;
              while (v525 != v505)
              {
                unint64_t v526 = *v525++;
                unint64_t v506 = v526;
                if (v526 <= 0xFFFFFFFFFFFFFFFDLL)
                {
                  v504 = v525 - 1;
                  goto LABEL_987;
                }
              }
LABEL_1034:
              if (v841 >= (unint64_t)HIDWORD(v841)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v840 + v841) = v463;
              LODWORD(v841) = v841 + 1;
              goto LABEL_1036;
            }
            llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)__b, v512);
            v505 = v777;
            unsigned int v512 = v837[0];
            v507 = (char *)__b[1];
            goto LABEL_1000;
          }
          if (HIDWORD(v837[0]))
          {
            v509 = 0;
            uint64_t v510 = 8 * HIDWORD(v837[0]);
            v511 = (unint64_t *)__b[1];
            while (*v511 != v506)
            {
              if (*v511 == -2) {
                v509 = v511;
              }
              ++v511;
              v510 -= 8;
              if (!v510)
              {
                if (!v509) {
                  goto LABEL_995;
                }
                unint64_t *v509 = v506;
                --LODWORD(v837[1]);
                goto LABEL_1019;
              }
            }
            goto LABEL_1024;
          }
LABEL_995:
          unsigned int v512 = v837[0];
          if (HIDWORD(v837[0]) >= LODWORD(v837[0])) {
            goto LABEL_998;
          }
          ++HIDWORD(v837[0]);
          *((void *)__b[1] + v508) = v506;
LABEL_1019:
          v818 = *(void **)(v506 + 40);
          v522 = (unsigned int *)sub_1CCC0F8D0((uint64_t)v806, (uint64_t *)&v818);
          if (*v522 != -1)
          {
            unsigned int v523 = v522[1];
            if (v523 != -1)
            {
              unint64_t v524 = *v522 * (unint64_t)v523;
              if ((v524 & 0xFFFFFFFF00000000) == 0 && v524 != -1)
              {
                v770 += v524;
                v772 += v524;
                v505 = v777;
                goto LABEL_1024;
              }
            }
          }
LABEL_1055:
          int v445 = 1;
LABEL_1056:
          int v365 = v798;
LABEL_1057:
          if (v821 != v823) {
            free(v821);
          }
          if (!v445) {
            continue;
          }
          break;
        }
        if (v840 != &v842) {
          free(v840);
        }
        if (v445 == 2)
        {
          if (v365 & v364)
          {
            uint64_t v7 = v782;
            if (__b[1] == __b[0]) {
              goto LABEL_1065;
            }
            if (LODWORD(v837[0]) >= 0x21
              && (4 * (HIDWORD(v837[0]) - LODWORD(v837[1]))) < LODWORD(v837[0]))
            {
              llvm::SmallPtrSetImplBase::shrink_and_clear(__b);
            }
            else
            {
              memset(__b[1], 255, 8 * LODWORD(v837[0]));
LABEL_1065:
              LODWORD(v837[1]) = 0;
              HIDWORD(v837[0]) = 0;
            }
            if (v829 == v828)
            {
LABEL_1067:
              int v529 = 0;
              int v831 = 0;
              HIDWORD(v830) = 0;
            }
            else
            {
              if (v830 < 0x21 || 4 * (HIDWORD(v830) - v831) >= v830)
              {
                memset(v829, 255, 8 * v830);
                goto LABEL_1067;
              }
              llvm::SmallPtrSetImplBase::shrink_and_clear((void **)&v828);
              int v529 = 0;
            }
LABEL_1068:
            if (!v787)
            {
              *(unsigned char *)uint64_t v7 = 1;
              BOOL v765 = v529 == 0;
              v530 = *(llvm::Type **)v768;
              unint64_t v531 = llvm::PointerType::get((llvm::PointerType *)(***(void ***)v768 + 1912), 0);
              v532 = (llvm::Type *)v531;
              if (v829 == v828) {
                v533 = (uint64_t *)((char *)&v830 + 4);
              }
              else {
                v533 = &v830;
              }
              uint64_t v534 = *(unsigned int *)v533;
              v799 = (llvm::Type *)v531;
              if (v534)
              {
                uint64_t v535 = 8 * v534;
                v536 = (unint64_t *)v829;
                while (*v536 >= 0xFFFFFFFFFFFFFFFELL)
                {
                  ++v536;
                  v535 -= 8;
                  if (!v535) {
                    goto LABEL_1122;
                  }
                }
              }
              else
              {
                v536 = (unint64_t *)v829;
              }
              v541 = (unint64_t *)((char *)v829 + 8 * v534);
              if (v536 != v541)
              {
                v542 = (llvm::Instruction *)*v536;
LABEL_1106:
                v821 = 0;
                v543 = v768;
                if (v530 != v532)
                {
                  v544 = operator new(0x60uLL);
                  v544[13] = v544[13] & 0x38000000 | 1;
                  *(void *)v544 = 0;
                  *((void *)v544 + 1) = 0;
                  *((void *)v544 + 2) = 0;
                  *((void *)v544 + 3) = v544 + 8;
                  v844[0] = 257;
                  v543 = llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v544 + 8), v768, v532, (const char **)&v840, v542);
                }
                v821 = v543;
                uint64_t v545 = *(void *)(v7 + 88);
                if (v545
                  || (v546 = *(uint64_t ***)(v7 + 64),
                      llvm::Intrinsic::getType(*v546, 222, 0, 0),
                      v547 = (llvm::PointerType *)llvm::Intrinsic::getType(*v546, 222, 0, 0),
                      llvm::Module::getOrInsertFunction((uint64_t)v546, "llvm.objc.retain", (const char *)0x10, v547, 0), uint64_t v545 = v548, (*(void *)(v7 + 88) = v548) != 0))
                {
                  v549 = *(uint64_t ***)(v545 + 24);
                }
                else
                {
                  v549 = 0;
                }
                v844[0] = 257;
                v550 = (char *)operator new(0x90uLL);
                v551 = v550;
                v552 = (llvm::Value *)(v550 + 64);
                *((_DWORD *)v550 + 21) = *((_DWORD *)v550 + 21) & 0x38000000 | 2;
                *(void *)v550 = 0;
                *((void *)v550 + 1) = 0;
                *((void *)v550 + 2) = 0;
                *((void *)v550 + 3) = v550 + 64;
                *((void *)v550 + 4) = 0;
                *((void *)v550 + 5) = 0;
                *((void *)v550 + 6) = 0;
                *((void *)v550 + 7) = v550 + 64;
                *((void *)v550 + 8) = *v549[2];
                *((void *)v550 + 9) = 0;
                v550[80] = 84;
                v550[81] = 0;
                *((_WORD *)v550 + 41) = 0;
                *((_DWORD *)v550 + 21) = 2;
                *(_OWORD *)(v550 + 88) = 0u;
                v553 = v550 + 88;
                *((_DWORD *)v550 + 30) = 0;
                *(_OWORD *)(v550 + 104) = 0u;
                if (v542)
                {
                  uint64_t v557 = *((void *)v542 + 5);
                  *((void *)v550 + 13) = v557;
                  *(_WORD *)(v557 + 18) &= ~0x8000u;
                  if ((v550[87] & 0x10) != 0)
                  {
                    uint64_t v559 = *(void *)(v557 + 56);
                    if (v559)
                    {
                      v560 = *(llvm::ValueSymbolTable **)(v559 + 104);
                      if (v560) {
                        llvm::ValueSymbolTable::reinsertValue(v560, v552);
                      }
                    }
                  }
                  uint64_t v558 = *((void *)v542 + 3);
                  v551[11] = v558;
                  v551[12] = (char *)v542 + 24;
                  *(void *)(v558 + 8) = v553;
                  *((void *)v542 + 3) = v553;
                }
                v551[16] = 0;
                v554 = v551 + 16;
                llvm::CallInst::init((uint64_t ***)v552, v549, (uint64_t **)v545, (uint64_t *)&v821, 1, 0, 0, (const char **)&v840);
                uint64_t *v554 = llvm::AttributeList::addAttributeAtIndex(v554, *(uint64_t **)*(v554 - 8), -1, 37);
                *((_WORD *)v554 - 23) = *((_WORD *)v554 - 23) & 0xFFFC | 1;
                v555 = v536 + 1;
                v532 = v799;
                while (v555 != v541)
                {
                  unint64_t v556 = *v555++;
                  v542 = (llvm::Instruction *)v556;
                  if (v556 <= 0xFFFFFFFFFFFFFFFDLL)
                  {
                    v536 = v555 - 1;
                    goto LABEL_1106;
                  }
                }
              }
LABEL_1122:
              if (__b[1] == __b[0]) {
                v561 = (void **)((char *)v837 + 4);
              }
              else {
                v561 = v837;
              }
              uint64_t v562 = *(unsigned int *)v561;
              if (v562)
              {
                uint64_t v563 = 8 * v562;
                v564 = (unint64_t *)__b[1];
                while (*v564 >= 0xFFFFFFFFFFFFFFFELL)
                {
                  ++v564;
                  v563 -= 8;
                  if (!v563) {
                    goto LABEL_1157;
                  }
                }
              }
              else
              {
                v564 = (unint64_t *)__b[1];
              }
              v565 = (unint64_t *)((char *)__b[1] + 8 * v562);
              if (v564 != v565)
              {
                v566 = (llvm::Instruction *)*v564;
LABEL_1133:
                v821 = 0;
                v567 = v768;
                if (v530 != v532)
                {
                  v568 = operator new(0x60uLL);
                  v568[13] = v568[13] & 0x38000000 | 1;
                  *(void *)v568 = 0;
                  *((void *)v568 + 1) = 0;
                  *((void *)v568 + 2) = 0;
                  *((void *)v568 + 3) = v568 + 8;
                  v844[0] = 257;
                  v567 = llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v568 + 8), v768, v532, (const char **)&v840, v566);
                }
                v821 = v567;
                uint64_t v569 = *(void *)(v7 + 80);
                if (v569
                  || (v570 = *(uint64_t ***)(v7 + 64),
                      llvm::Intrinsic::getType(*v570, 221, 0, 0),
                      v571 = (llvm::PointerType *)llvm::Intrinsic::getType(*v570, 221, 0, 0),
                      llvm::Module::getOrInsertFunction((uint64_t)v570, "llvm.objc.release", (const char *)0x11, v571, 0), uint64_t v569 = v572, (*(void *)(v7 + 80) = v572) != 0))
                {
                  v573 = *(uint64_t ***)(v569 + 24);
                }
                else
                {
                  v573 = 0;
                }
                v844[0] = 257;
                v574 = (char *)operator new(0x90uLL);
                v575 = v574;
                v576 = (llvm::Value *)(v574 + 64);
                *((_DWORD *)v574 + 21) = *((_DWORD *)v574 + 21) & 0x38000000 | 2;
                *(void *)v574 = 0;
                *((void *)v574 + 1) = 0;
                *((void *)v574 + 2) = 0;
                *((void *)v574 + 3) = v574 + 64;
                *((void *)v574 + 4) = 0;
                *((void *)v574 + 5) = 0;
                *((void *)v574 + 6) = 0;
                *((void *)v574 + 7) = v574 + 64;
                *((void *)v574 + 8) = *v573[2];
                *((void *)v574 + 9) = 0;
                v574[80] = 84;
                v574[81] = 0;
                *((_WORD *)v574 + 41) = 0;
                *((_DWORD *)v574 + 21) = 2;
                *(_OWORD *)(v574 + 88) = 0u;
                v577 = v574 + 88;
                *((_DWORD *)v574 + 30) = 0;
                *(_OWORD *)(v574 + 104) = 0u;
                if (v566)
                {
                  uint64_t v583 = *((void *)v566 + 5);
                  *((void *)v574 + 13) = v583;
                  *(_WORD *)(v583 + 18) &= ~0x8000u;
                  if ((v574[87] & 0x10) != 0)
                  {
                    uint64_t v585 = *(void *)(v583 + 56);
                    if (v585)
                    {
                      v586 = *(llvm::ValueSymbolTable **)(v585 + 104);
                      if (v586) {
                        llvm::ValueSymbolTable::reinsertValue(v586, v576);
                      }
                    }
                  }
                  uint64_t v584 = *((void *)v566 + 3);
                  *((void *)v575 + 11) = v584;
                  *((void *)v575 + 12) = (char *)v566 + 24;
                  *(void *)(v584 + 8) = v577;
                  *((void *)v566 + 3) = v577;
                }
                *((void *)v575 + 16) = 0;
                llvm::CallInst::init((uint64_t ***)v576, v573, (uint64_t **)v569, (uint64_t *)&v821, 1, 0, 0, (const char **)&v840);
                v578 = (llvm::MDNode *)*((void *)&v824 + 1);
                v532 = v799;
                if (*((void *)&v824 + 1))
                {
                  if (*(unsigned char *)(v7 + 172))
                  {
                    int v579 = *(_DWORD *)(v7 + 168);
                  }
                  else
                  {
                    int v579 = llvm::LLVMContext::getMDKindID(**(uint64_t ***)(v7 + 160), "clang.imprecise_release", 0x17uLL);
                    int v580 = *(unsigned __int8 *)(v7 + 172);
                    *(_DWORD *)(v7 + 168) = v579;
                    if (!v580) {
                      *(unsigned char *)(v7 + 172) = 1;
                    }
                  }
                  llvm::Instruction::setMetadata(v576, v579, v578);
                }
                *((void *)v575 + 16) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)v575 + 16, **(uint64_t ***)v576, -1, 37);
                if (BYTE1(v824)) {
                  *((_WORD *)v575 + 41) = *((_WORD *)v575 + 41) & 0xFFFC | 1;
                }
                v581 = v564 + 1;
                while (v581 != v565)
                {
                  unint64_t v582 = *v581++;
                  v566 = (llvm::Instruction *)v582;
                  if (v582 <= 0xFFFFFFFFFFFFFFFDLL)
                  {
                    v564 = v581 - 1;
                    goto LABEL_1133;
                  }
                }
              }
LABEL_1157:
              if (*(void *)&v833[24] == *(void *)&v833[16]) {
                v587 = (void **)((char *)v834 + 4);
              }
              else {
                v587 = v834;
              }
              uint64_t v588 = *(unsigned int *)v587;
              if (v588)
              {
                uint64_t v589 = 8 * v588;
                v590 = *(uint64_t **)&v833[24];
                while ((unint64_t)*v590 >= 0xFFFFFFFFFFFFFFFELL)
                {
                  ++v590;
                  v589 -= 8;
                  if (!v589) {
                    goto LABEL_1174;
                  }
                }
              }
              else
              {
                v590 = *(uint64_t **)&v833[24];
              }
              uint64_t v591 = *(void *)&v833[24] + 8 * v588;
              if (v590 != (uint64_t *)v591)
              {
                uint64_t v592 = *v590;
LABEL_1168:
                sub_1CD6C1070((uint64_t)v808, v592);
                if (v846 >= (unint64_t)HIDWORD(v846)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v845 + v846) = v592;
                LODWORD(v846) = v846 + 1;
                v593 = (unint64_t *)(v590 + 1);
                while (v593 != (unint64_t *)v591)
                {
                  unint64_t v594 = *v593++;
                  uint64_t v592 = v594;
                  if (v594 <= 0xFFFFFFFFFFFFFFFDLL)
                  {
                    v590 = (uint64_t *)(v593 - 1);
                    goto LABEL_1168;
                  }
                }
              }
LABEL_1174:
              if (*((void *)&v825 + 1) == (void)v825) {
                v595 = (unsigned int *)&v826 + 1;
              }
              else {
                v595 = (unsigned int *)&v826;
              }
              uint64_t v596 = *v595;
              if (v596)
              {
                uint64_t v597 = 8 * v596;
                v598 = (uint64_t *)*((void *)&v825 + 1);
                while ((unint64_t)*v598 >= 0xFFFFFFFFFFFFFFFELL)
                {
                  ++v598;
                  v597 -= 8;
                  if (!v597) {
                    goto LABEL_1079;
                  }
                }
              }
              else
              {
                v598 = (uint64_t *)*((void *)&v825 + 1);
              }
              uint64_t v599 = *((void *)&v825 + 1) + 8 * v596;
              if (v598 != (uint64_t *)v599)
              {
                uint64_t v600 = *v598;
LABEL_1185:
                sub_1CD6C10F8((uint64_t)v813, v600);
                if (v846 >= (unint64_t)HIDWORD(v846)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v845 + v846) = v600;
                LODWORD(v846) = v846 + 1;
                v601 = (unint64_t *)(v598 + 1);
                while (v601 != (unint64_t *)v599)
                {
                  unint64_t v602 = *v601++;
                  uint64_t v600 = v602;
                  if (v602 <= 0xFFFFFFFFFFFFFFFDLL)
                  {
                    v598 = (uint64_t *)(v601 - 1);
                    goto LABEL_1185;
                  }
                }
              }
            }
          }
          else
          {
            uint64_t v7 = v782;
            if (!v772)
            {
              BOOL v538 = HIDWORD(v837[0]) == LODWORD(v837[1]) && HIDWORD(v830) == v831;
              if (!v363)
              {
                int v529 = v770;
                goto LABEL_1068;
              }
              int v529 = v770;
              if (v538) {
                goto LABEL_1068;
              }
            }
          }
        }
        else
        {
          uint64_t v7 = v782;
        }
LABEL_1079:
        if (v829 != v828) {
          free(v829);
        }
        if (*((void *)&v825 + 1) != (void)v825) {
          free(*((void **)&v825 + 1));
        }
        if (__b[1] != __b[0]) {
          free(__b[1]);
        }
        if (*(void *)&v833[24] != *(void *)&v833[16]) {
          free(*(void **)&v833[24]);
        }
        v355 = v769;
        v356 = v767;
LABEL_713:
        v355 += 16;
        if (v355 != v356) {
          continue;
        }
        break;
      }
      if (v846)
      {
        uint64_t v603 = *((void *)v845 + v846 - 1);
        LODWORD(v846) = v846 - 1;
        if (*(void *)(v603 + 8))
        {
          llvm::Value::doRAUW((llvm::ValueAsMetadata *)v603, *(llvm::Value **)(v603 - 32 * (*(_DWORD *)(v603 + 20) & 0x7FFFFFF)), (llvm::Value *)1);
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
      }
LABEL_1204:
      if (v845 != (llvm::Value *)&v847) {
        free(v845);
      }
      char v357 = v765 & v764;
LABEL_1207:
      uint64_t v604 = v806[0];
      if (v807)
      {
        uint64_t v605 = 176 * v807;
        uint64_t v606 = v806[0] + 160;
        do
        {
          if ((*(void *)(v606 - 160) | 0x1000) != 0xFFFFFFFFFFFFF000)
          {
            v607 = *(void **)(v606 - 16);
            if ((void *)v606 != v607) {
              free(v607);
            }
            v608 = *(void **)(v606 - 48);
            if ((void *)(v606 - 32) != v608) {
              free(v608);
            }
            sub_1CD6C05A4(v606 - 96);
            sub_1CD6C05A4(v606 - 144);
          }
          v606 += 176;
          v605 -= 176;
        }
        while (v605);
        uint64_t v604 = v806[0];
      }
      MEMORY[0x1D25D9CD0](v604, 8);
      sub_1CD6C1168((uint64_t)v808);
      sub_1CD6C11B0(v813);
      if ((v357 & 1) == 0)
      {
        int v135 = *(_DWORD *)(v7 + 204);
        break;
      }
    }
  }
  if ((v135 & 0x60) != 0 && *(unsigned char *)(**(void **)(*(void *)(v766 + 24) + 16) + 8) == 15)
  {
    for (n = *(void **)(v766 + 80); n != v793; n = (void *)n[1])
    {
      if (n) {
        uint64_t v736 = (uint64_t)(n - 3);
      }
      else {
        uint64_t v736 = 0;
      }
      uint64_t v737 = *(void *)(v736 + 40);
      if (v737) {
        uint64_t v738 = v737 - 24;
      }
      else {
        uint64_t v738 = 0;
      }
      if (v737) {
        BOOL v739 = *(unsigned char *)(v738 + 16) == 29;
      }
      else {
        BOOL v739 = 0;
      }
      if (v739)
      {
        v740 = sub_1CD4B3548(*(llvm::Value **)(v738 - 32 * (*(_DWORD *)(v738 + 20) & 0x7FFFFFF)));
        *(void *)v833 = v834;
        *(void *)&v833[8] = v834;
        *(void *)&v833[16] = 4;
        *(_DWORD *)&v833[24] = 0;
        uint64_t SingleDependency = llvm::objcarc::findSingleDependency(0, v740, v736, v738, v774);
        uint64_t v743 = SingleDependency;
        if (SingleDependency)
        {
          if (*(unsigned char *)(SingleDependency + 16) == 84 && sub_1CD4B36C8(SingleDependency, v742) - 5 <= 1)
          {
            if (sub_1CD4B3548(*(llvm::Value **)(v743 - 32 * (*(_DWORD *)(v743 + 20) & 0x7FFFFFF))) != v740) {
              uint64_t v743 = 0;
            }
          }
          else
          {
            uint64_t v743 = 0;
          }
        }
        if (*(void *)&v833[8] != *(void *)v833) {
          free(*(void **)&v833[8]);
        }
        if (v743)
        {
          uint64_t v744 = llvm::objcarc::findSingleDependency(2, v740, *(void *)(v743 + 40), v743, v774);
          if (v744)
          {
            uint64_t v746 = v744;
            if (*(unsigned char *)(v744 + 16) == 84
              && sub_1CD4B36C8(v744, v745) <= 1
              && sub_1CD4B3548(*(llvm::Value **)(v746 - 32 * (*(_DWORD *)(v746 + 20) & 0x7FFFFFF))) == v740)
            {
              uint64_t v747 = llvm::objcarc::findSingleDependency(2, v740, *(void *)(v746 + 40), v746, v774);
              if (v747)
              {
                int v749 = *(unsigned __int8 *)(v747 + 16);
                BOOL v750 = v749 == 84;
                v751 = v749 == 84 ? (llvm::Value *)v747 : 0;
                BOOL v752 = v750 && v751 == v740;
                if (v752
                  && sub_1CD4B36C8((uint64_t)v740, v748) - 21 <= 1
                  && ((*((_WORD *)v740 + 9) & 3u) - 1 < 2
                   || sub_1CD4B36C8(v746, v753) != 1
                   || sub_1CD4B36C8(v743, v754) != 6))
                {
                  *(unsigned char *)uint64_t v7 = 1;
                  uint64_t v755 = *(void *)(v7 + 192);
                  *(void *)&long long v824 = v746;
                  *(void *)v833 = 0;
                  if (!sub_1CD3C8538((uint64_t *)v755, &v824, v833)
                    || (uint64_t v757 = *(void *)v833, *(void *)v833 == *(void *)v755 + 16 * *(unsigned int *)(v755 + 16)))
                  {
                    if (*(void *)(v746 + 8))
                    {
                      llvm::Value::doRAUW((llvm::ValueAsMetadata *)v746, *(llvm::Value **)(v746 - 32 * (*(_DWORD *)(v746 + 20) & 0x7FFFFFF)), (llvm::Value *)1);
                      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                    }
                    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                  }
                  v758 = *(llvm::CallBase **)(*(void *)v833 + 8);
                  for (iuint64_t i = *((void *)v758 + 1); ii; iuint64_t i = *(void *)(ii + 8))
                  {
                    uint64_t v760 = *(void *)(ii + 24);
                    if (v760)
                    {
                      if (*(unsigned char *)(v760 + 16) == 84)
                      {
                        uint64_t v761 = *(void *)(v760 - 32);
                        if (v761)
                        {
                          if (!*(unsigned char *)(v761 + 16)
                            && *(void *)(v761 + 24) == *(void *)(v760 + 72)
                            && *(_DWORD *)(v761 + 36) == 213)
                          {
                            llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                          }
                        }
                      }
                    }
                  }
                  v762 = llvm::CallBase::removeOperandBundle(v758, (llvm::CallBase *)6, v758, v756);
                  llvm::Instruction::copyMetadata((uint64_t)v762, *(void *)(v757 + 8), 0, 0);
                  llvm::Value::doRAUW(*(llvm::ValueAsMetadata **)(v757 + 8), (llvm::Value *)v762, (llvm::Value *)1);
                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                }
              }
            }
          }
        }
      }
    }
  }
  BOOL v3 = *(unsigned char *)v7 != 0;
  llvm::objcarc::BundledRetainClaimRVs::~BundledRetainClaimRVs(v802);
  return v3;
}

void sub_1CCC0DB10()
{
}

void sub_1CCC0DB4C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2632298;
  sub_1CD6C121C((uint64_t)a1 + 40);

  llvm::Pass::~Pass(a1);
}

void sub_1CCC0DBA0(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F2632298;
  sub_1CD6C121C((uint64_t)a1 + 40);
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCC0DC08(uint64_t a1, uint64_t a2)
{
  if (llvm::objcarc::EnableARCOpts)
  {
    *(void *)(a1 + 208) = 0;
    *(void *)(a1 + 216) = 0;
    *(void *)(a1 + 192) = a2;
    *(void *)(a1 + 200) = 0;
    *(void *)(a1 + 96) = a2;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0u;
    *(_OWORD *)(a1 + 168) = 0u;
    *(void *)(a1 + 184) = 0;
  }
  return 0;
}

void sub_1CCC0DC48(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::objcarc::ObjCARCAAWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)&llvm::AAResultsWrapperPass::ID);
}

llvm::ValueHandleBase *sub_1CCC0DC98(uint64_t a1)
{
  sub_1CD553F7C((_DWORD *)(a1 + 48));

  return sub_1CD6C03F0((llvm::ValueHandleBase *)(a1 + 72));
}

BOOL sub_1CCC0DCD4(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_4:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::AAResultsWrapperPass::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_4;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = a1 + 32;
  uint64_t v8 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::AAResultsWrapperPass::ID)+ 32);

  return sub_1CCC083DC(v7, a2, v8);
}

void sub_1CCC0DD80(uint64_t a1, const llvm::Function *a2, uint64_t **a3, int a4, llvm::Value *a5)
{
  uint64_t v8 = a2;
  uint64_t v224 = *MEMORY[0x1E4F143B8];
  unsigned int v210 = &v214;
  v211 = &v214;
  uint64_t v212 = 1;
  int v213 = 0;
  if (a3)
  {
    if (*((unsigned char *)a3 + 16) == 84)
    {
      size_t v37 = *(uint64_t **)(a1 + 192);
      v217 = a3;
      uint64_t v221 = 0;
      if (sub_1CD3C8538(v37, &v217, &v221))
      {
LABEL_69:
        *(_DWORD *)(a1 + 204) |= 1 << a4;
        goto LABEL_70;
      }
    }
  }
  if (((1 << a4) & 0x1FFF380) == 0)
  {
    int v10 = *((_DWORD *)a3 + 5);
    int v11 = (v10 & 0x40000000) != 0 ? (llvm::Value **)*(a3 - 1) : (llvm::Value **)&a3[-4 * (v10 & 0x7FFFFFF)];
    if (sub_1CCC0F3CC(*v11, (uint64_t)&v210))
    {
      if (*((unsigned char *)*a3 + 8) != 7)
      {
        int v12 = *((_DWORD *)a3 + 5);
        if ((v12 & 0x40000000) != 0) {
          unsigned int v13 = (llvm::Value **)*(a3 - 1);
        }
        else {
          unsigned int v13 = (llvm::Value **)&a3[-4 * (v12 & 0x7FFFFFF)];
        }
        llvm::Value::doRAUW((llvm::ValueAsMetadata *)a3, *v13, (llvm::Value *)1);
      }
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
  }
  switch(a4)
  {
    case 1:
      uint64_t v58 = sub_1CD4B3548((llvm::Value *)a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)]);
      unsigned int v59 = *((unsigned __int8 *)v58 + 16);
      if (v59 < 0x1C) {
        goto LABEL_281;
      }
      if (v59 - 33 > 0x33 || ((1 << (v59 - 33)) & 0x8000000000041) == 0) {
        goto LABEL_281;
      }
      uint64_t v61 = a3[5];
      if (*((uint64_t **)v58 + 5) == v61)
      {
        for (uint64_t i = (uint64_t *)((char *)v58 + 32); ; uint64_t i = (uint64_t *)(v187 + 8))
        {
          uint64_t v187 = *i;
          uint64_t v188 = *i - 24;
          v65 = v187 ? (unsigned __int8 *)v188 : 0;
          int v189 = v65[16];
          if (v189 != 77
            && (v189 != 62 || !llvm::GetElementPtrInst::hasAllZeroIndices((llvm::GetElementPtrInst *)v65)))
          {
            break;
          }
        }
      }
      else
      {
        if (v59 != 33 || *((uint64_t **)v58 - 12) != v61) {
          goto LABEL_281;
        }
        for (j = v61 + 6; ; j = (uint64_t *)(v63 + 8))
        {
          uint64_t v63 = *j;
          uint64_t v64 = *j - 24;
          v65 = v63 ? (unsigned __int8 *)v64 : 0;
          int v66 = v65[16];
          if (v66 != 77
            && (v66 != 62 || !llvm::GetElementPtrInst::hasAllZeroIndices((llvm::GetElementPtrInst *)v65)))
          {
            break;
          }
        }
      }
      if (v65 == (unsigned __int8 *)a3) {
        goto LABEL_284;
      }
LABEL_281:
      *(unsigned char *)a1 = 1;
      uint64_t v190 = *(void *)(a1 + 88);
      if (!v190)
      {
        unsigned int v191 = *(uint64_t ***)(a1 + 64);
        llvm::Intrinsic::getType(*v191, 222, 0, 0);
        Type = (llvm::PointerType *)llvm::Intrinsic::getType(*v191, 222, 0, 0);
        llvm::Module::getOrInsertFunction((uint64_t)v191, "llvm.objc.retain", (const char *)0x10, Type, 0);
        *(void *)(a1 + 88) = v190;
      }
      sub_1CC1DDE04((uint64_t)a3, v190);
LABEL_284:
      a4 = 1;
      goto LABEL_75;
    case 6:
      uint64_t v57 = sub_1CD4B3548((llvm::Value *)a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)]);
      if (*((unsigned __int8 *)v57 + 16) - 11 < 0xA)
      {
        a4 = 6;
        goto LABEL_19;
      }
      uint64_t v86 = v57;
      v217 = v219;
      v219[0] = v57;
      uint64_t v218 = 0x200000001;
      if (*((unsigned char *)v57 + 16) != 83 || *(void *)(*((void *)v57 + 5) + 40) == *((void *)v57 + 5) + 40)
      {
        unsigned int v90 = 1;
        goto LABEL_286;
      }
      uint64_t v87 = *(void *)(*((void *)v57 + 5) + 48);
      uint64_t v88 = v87 - 24;
      if (v87) {
        uint64_t v89 = v87 - 24;
      }
      else {
        uint64_t v89 = 0;
      }
      unsigned int v90 = 1;
      if (!v87 || *(unsigned char *)(v89 + 16) != 83) {
        goto LABEL_286;
      }
      BOOL v208 = v8;
      break;
    case 9:
      goto LABEL_67;
    case 12:
    case 13:
    case 14:
    case 15:
    case 18:
      unsigned int v14 = *((unsigned __int8 *)a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)] + 16);
      BOOL v15 = v14 > 0x13;
      int v16 = (1 << v14) & 0x81800;
      goto LABEL_13;
    case 16:
    case 17:
      uint64_t v22 = &a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)];
      unsigned int v23 = *((unsigned __int8 *)*v22 + 16);
      if (v23 <= 0x13 && ((1 << v23) & 0x81800) != 0) {
        goto LABEL_37;
      }
      unsigned int v38 = *((unsigned __int8 *)v22[4] + 16);
      BOOL v15 = v38 > 0x13;
      int v16 = (1 << v38) & 0x81800;
LABEL_13:
      if (v15 || v16 == 0) {
        goto LABEL_18;
      }
LABEL_37:
      *(unsigned char *)a1 = 1;
      uint64_t v25 = operator new(0x80uLL);
      unsigned int v27 = (llvm::StoreInst *)(v25 + 16);
      v25[21] = v25[21] & 0x38000000 | 2;
      *(void *)uint64_t v25 = 0;
      *((void *)v25 + 1) = 0;
      *((void *)v25 + 2) = 0;
      *((void *)v25 + 3) = v25 + 16;
      *((void *)v25 + 4) = 0;
      *((void *)v25 + 5) = 0;
      *((void *)v25 + 6) = 0;
      *((void *)v25 + 7) = v25 + 16;
      uint64_t v28 = **a3;
      uint64_t v29 = *(void *)v28;
      int v30 = *(llvm::Type ***)(*(void *)v28 + 1560);
      if (!v30)
      {
        uint64_t v83 = *(llvm::ConstantInt **)(v29 + 1888);
        unsigned int v84 = *(_DWORD *)(v29 + 1896);
        LODWORD(v218) = v84 >> 8;
        if (v84 >> 8 > 0x40) {
          llvm::APInt::initSlowCase((llvm::APInt *)&v217);
        }
        if (v84 <= 0xFF) {
          char v85 = 0;
        }
        else {
          char v85 = 0xFFFFFFFFFFFFFFFFLL >> -BYTE1(v84);
        }
        v217 = (void *)(v85 & 1);
        int v30 = (llvm::Type **)llvm::ConstantInt::get(v83, (llvm::LLVMContext *)&v217, v26);
        if (v218 >= 0x41 && v217) {
          MEMORY[0x1D25D9CB0](v217, 0x1000C8000313F17);
        }
        *(void *)(v29 + 1560) = v30;
        uint64_t v29 = *(void *)**a3;
      }
      unsigned int v31 = (llvm::UndefValue *)llvm::PointerType::get((llvm::PointerType *)(v29 + 1888), 0);
      uint64_t v33 = llvm::UndefValue::get(v31, v32);
      llvm::StoreInst::StoreInst(v27, v30, v33, 0, (llvm::Instruction *)a3);
      int v35 = llvm::UndefValue::get((llvm::UndefValue *)*a3, v34);
      size_t v36 = (llvm::ValueAsMetadata *)a3;
      goto LABEL_39;
    default:
      goto LABEL_18;
  }
  do
  {
    if ((llvm::Value *)v88 != v86)
    {
      int v91 = *((_DWORD *)v86 + 5);
      uint64_t v92 = v91 & 0x7FFFFFF;
      if ((v91 & 0x7FFFFFF) != 0)
      {
        uint64_t v93 = 0;
        uint64_t v94 = 0;
        while (1)
        {
          int v95 = *((_DWORD *)v86 + 5);
          uint64_t v96 = (v95 & 0x40000000) != 0
              ? (llvm::Value *)*((void *)v86 - 1)
              : (llvm::Value *)((char *)v86 - 32 * (v95 & 0x7FFFFFF));
          uint64_t v97 = *((void *)v96 + 4 * *((unsigned int *)v86 + 15) + v94);
          unint64_t v98 = llvm::Value::stripPointerCasts(*(llvm::Value **)((char *)v96 + v93));
          size_t v99 = (llvm::Value *)sub_1CBF73380(v88, v97);
          if (v98 != llvm::Value::stripPointerCasts(v99)) {
            break;
          }
          ++v94;
          v93 += 32;
          if (v92 == v94) {
            goto LABEL_144;
          }
        }
      }
      else
      {
        LODWORD(v94) = 0;
      }
      if (v94 == v92)
      {
LABEL_144:
        if (v218 >= (unint64_t)HIDWORD(v218)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v217 + v218) = v88;
        LODWORD(v218) = v218 + 1;
      }
    }
    uint64_t v100 = *(void *)(v88 + 32);
    uint64_t v88 = v100 - 24;
    if (v100) {
      uint64_t v101 = v100 - 24;
    }
    else {
      uint64_t v101 = 0;
    }
  }
  while (v100 && *(unsigned char *)(v101 + 16) == 83);
  unsigned int v90 = v218;
  uint64_t v8 = v208;
LABEL_286:
  while (1)
  {
    uint64_t v193 = *((void *)v217 + --v90);
    LODWORD(v218) = v90;
    uint64_t v194 = *(void *)(v193 + 8);
    if (v194) {
      break;
    }
LABEL_295:
    if (!v90)
    {
      *(unsigned char *)a1 = 1;
      uint64_t v196 = *(void *)(a1 + 104);
      if (!v196)
      {
        unsigned int v197 = *(uint64_t ***)(a1 + 64);
        llvm::Intrinsic::getType(*v197, 208, 0, 0);
        v198 = (llvm::PointerType *)llvm::Intrinsic::getType(*v197, 208, 0, 0);
        llvm::Module::getOrInsertFunction((uint64_t)v197, "llvm.objc.autorelease", (const char *)0x15, v198, 0);
        *(void *)(a1 + 104) = v196;
      }
      sub_1CC1DDE04((uint64_t)a3, v196);
      *((_WORD *)a3 + 9) &= 0xFFFCu;
      a4 = 5;
      goto LABEL_300;
    }
  }
  while (1)
  {
    uint64_t v195 = *(void *)(v194 + 24);
    if (*(unsigned char *)(v195 + 16) == 29 || sub_1CD4B36C8(*(void *)(v194 + 24), a2) == 1) {
      break;
    }
    if (*(unsigned char *)(v195 + 16) == 77)
    {
      if (v218 >= (unint64_t)HIDWORD(v218)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v217 + v218) = v195;
      LODWORD(v218) = v218 + 1;
    }
    uint64_t v194 = *(void *)(v194 + 8);
    if (!v194)
    {
      unsigned int v90 = v218;
      goto LABEL_295;
    }
  }
  a4 = 6;
LABEL_300:
  if (v217 != v219) {
    free(v217);
  }
LABEL_18:
  if ((a4 - 5) > 1) {
    goto LABEL_58;
  }
LABEL_19:
  if (a3[1]) {
    goto LABEL_58;
  }
  uint64_t v18 = (uint64_t)a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)];
  int v19 = *(unsigned __int8 *)(v18 + 16);
  if ((v19 - 11) < 0xA) {
    goto LABEL_58;
  }
  while (1)
  {
    uint64_t v20 = *(void *)(v18 + 8);
    if (!v20 || *(void *)(v20 + 8)) {
      break;
    }
    if (v19 == 62)
    {
      if ((llvm::GetElementPtrInst::hasAllZeroIndices((llvm::GetElementPtrInst *)v18) & 1) == 0)
      {
LABEL_30:
        if (((1 << sub_1CD4B36C8(v18, a2)) & 0x267) == 0)
        {
          if (!sub_1CCC0F60C(v18)) {
            goto LABEL_58;
          }
LABEL_52:
          *(unsigned char *)a1 = 1;
          uint64_t v41 = **a3;
          uint64_t v42 = *(void *)(a1 + 80);
          if (v42
            || (uint64_t v43 = *(uint64_t ***)(a1 + 64),
                llvm::Intrinsic::getType(*v43, 221, 0, 0),
                uint64_t v44 = (llvm::PointerType *)llvm::Intrinsic::getType(*v43, 221, 0, 0),
                llvm::Module::getOrInsertFunction((uint64_t)v43, "llvm.objc.release", (const char *)0x11, v44, 0),
                uint64_t v42 = v45,
                (*(void *)(a1 + 80) = v45) != 0))
          {
            uint64_t v46 = *(uint64_t ***)(v42 + 24);
          }
          else
          {
            uint64_t v46 = 0;
          }
          uint64_t v221 = (char *)a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)];
          __int16 v220 = 257;
          int v47 = (char *)operator new(0x90uLL);
          uint64_t v48 = (llvm::Value *)(v47 + 64);
          *((_DWORD *)v47 + 21) = *((_DWORD *)v47 + 21) & 0x38000000 | 2;
          *(void *)int v47 = 0;
          *((void *)v47 + 1) = 0;
          *((void *)v47 + 2) = 0;
          *((void *)v47 + 3) = v47 + 64;
          *((void *)v47 + 4) = 0;
          *((void *)v47 + 5) = 0;
          *((void *)v47 + 6) = 0;
          *((void *)v47 + 7) = v47 + 64;
          *((void *)v47 + 8) = *v46[2];
          *((void *)v47 + 9) = 0;
          v47[80] = 84;
          v47[81] = 0;
          *((_WORD *)v47 + 41) = 0;
          *((_DWORD *)v47 + 21) = 2;
          *(_OWORD *)(v47 + 88) = 0u;
          uint64_t v49 = v47 + 88;
          *(_OWORD *)(v47 + 104) = 0u;
          *((_DWORD *)v47 + 30) = 0;
          uint64_t v50 = a3[5];
          int v51 = (uint64_t *)(a3 + 3);
          *((void *)v47 + 13) = v50;
          *((_WORD *)v50 + 9) &= ~0x8000u;
          if ((v47[87] & 0x10) != 0)
          {
            uint64_t v201 = v50[7];
            if (v201)
            {
              uint64_t v202 = *(llvm::ValueSymbolTable **)(v201 + 104);
              if (v202) {
                llvm::ValueSymbolTable::reinsertValue(v202, v48);
              }
            }
          }
          uint64_t v52 = *v51;
          *((void *)v47 + 11) = *v51;
          *((void *)v47 + 12) = v51;
          *(void *)(v52 + 8) = v49;
          *int v51 = (uint64_t)v49;
          *((void *)v47 + 16) = 0;
          llvm::CallInst::init((uint64_t ***)v48, v46, (uint64_t **)v42, (uint64_t *)&v221, 1, 0, 0, (const char **)&v217);
          if (*(unsigned char *)(a1 + 172))
          {
            int MDKindID = *(_DWORD *)(a1 + 168);
          }
          else
          {
            int MDKindID = llvm::LLVMContext::getMDKindID(**(uint64_t ***)(a1 + 160), "clang.imprecise_release", 0x17uLL);
            int v184 = *(unsigned __int8 *)(a1 + 172);
            *(_DWORD *)(a1 + 168) = MDKindID;
            if (!v184) {
              *(unsigned char *)(a1 + 172) = 1;
            }
          }
          Impl = llvm::MDTuple::getImpl(v41, 0, 0, 0, 1);
          llvm::Instruction::setMetadata(v48, MDKindID, Impl);
          if (a3[1])
          {
            llvm::Value::doRAUW((llvm::ValueAsMetadata *)a3, (llvm::Value *)a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)], (llvm::Value *)1);
            llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
          }
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
      }
      uint64_t v21 = -(uint64_t)(*(_DWORD *)(v18 + 20) & 0x7FFFFFF);
      goto LABEL_28;
    }
    if (v19 != 77) {
      goto LABEL_30;
    }
    uint64_t v21 = -1;
LABEL_28:
    uint64_t v18 = *(void *)(v18 + 32 * v21);
    int v19 = *(unsigned __int8 *)(v18 + 16);
    if ((v19 - 11) < 0xA) {
      goto LABEL_58;
    }
  }
  if (sub_1CCC0F60C(v18))
  {
    uint64_t v39 = *(void *)(v18 + 8);
    if (!v39) {
      goto LABEL_52;
    }
    do
    {
      uint64_t v40 = *(llvm::Value **)(v39 + 24);
      if (*((void *)v40 + 1) || sub_1CD4B3548(v40) != (llvm::Value *)v18) {
        goto LABEL_58;
      }
      uint64_t v39 = *(void *)(v39 + 8);
    }
    while (v39);
    if (v18) {
      goto LABEL_52;
    }
  }
LABEL_58:
  if ((a4 - 7) >= 0x12 && ((1 << a4) & 0x47) != 0)
  {
LABEL_75:
    int v55 = *((unsigned __int16 *)a3 + 9);
    if ((~v55 & 3) != 0)
    {
      *(unsigned char *)a1 = 1;
      *((_WORD *)a3 + 9) = v55 & 0xFFFC | 1;
    }
  }
  if (((1 << a4) & 0x1FFFE08) == 0)
  {
    if (((1 << a4) & 0x1D7) == 0)
    {
      *((_WORD *)a3 + 9) &= 0xFFFCu;
      a4 = 5;
    }
    *(unsigned char *)a1 = 1;
    a3[8] = (uint64_t *)llvm::AttributeList::addAttributeAtIndex((uint64_t *)a3 + 8, (uint64_t *)**a3, -1, 37);
  }
  if (!a5) {
    a5 = sub_1CD4B3548((llvm::Value *)a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)]);
  }
  unsigned int v54 = *((unsigned __int8 *)a5 + 16);
  if (v54 <= 0x13 && ((1 << v54) & 0x81800) != 0)
  {
LABEL_67:
    *(unsigned char *)a1 = 1;
    if (!a3[1]) {
      llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
    size_t v36 = (llvm::ValueAsMetadata *)a3;
    int v35 = (llvm::UndefValue *)a3[-4 * (*((_DWORD *)a3 + 5) & 0x7FFFFFF)];
LABEL_39:
    llvm::Value::doRAUW(v36, v35, (llvm::Value *)1);
    llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
  }
  *(_DWORD *)(a1 + 204) |= 1 << a4;
  if (a4 != 4) {
    goto LABEL_155;
  }
  if (*(unsigned char *)(a1 + 172))
  {
    int v56 = *(_DWORD *)(a1 + 168);
  }
  else
  {
    int v56 = llvm::LLVMContext::getMDKindID(**(uint64_t ***)(a1 + 160), "clang.imprecise_release", 0x17uLL);
    int v67 = *(unsigned __int8 *)(a1 + 172);
    *(_DWORD *)(a1 + 168) = v56;
    if (!v67) {
      *(unsigned char *)(a1 + 172) = 1;
    }
  }
  unsigned int v68 = a3[6];
  if (v68 || (*((unsigned char *)a3 + 23) & 0x20) != 0)
  {
    if (!v56) {
      goto LABEL_154;
    }
    if ((*((unsigned char *)a3 + 23) & 0x20) != 0)
    {
      uint64_t v69 = *(void *)**a3;
      v217 = a3;
      int v70 = *(_DWORD *)(v69 + 2496);
      if (!v70)
      {
        v199 = 0;
        goto LABEL_306;
      }
      uint64_t v71 = *(void *)(v69 + 2480);
      int v72 = v70 - 1;
      unsigned int v73 = v72 & ((a3 >> 4) ^ (a3 >> 9));
      uint64_t v74 = (uint64_t ***)(v71 + 40 * v73);
      int v75 = *v74;
      if (*v74 != a3)
      {
        int v76 = 0;
        int v77 = 1;
        while (v75 != (uint64_t **)-4096)
        {
          if (v76) {
            BOOL v78 = 0;
          }
          else {
            BOOL v78 = v75 == (uint64_t **)-8192;
          }
          if (v78) {
            int v76 = v74;
          }
          unsigned int v79 = v73 + v77++;
          unsigned int v73 = v79 & v72;
          uint64_t v74 = (uint64_t ***)(v71 + 40 * v73);
          int v75 = *v74;
          if (*v74 == a3) {
            goto LABEL_114;
          }
        }
        if (v76) {
          v199 = v76;
        }
        else {
          v199 = v74;
        }
LABEL_306:
        uint64_t v74 = (uint64_t ***)sub_1CC609054(v69 + 2480, (uint64_t)&v217, (uint64_t *)&v217, v199);
        unsigned int v200 = (uint64_t **)v217;
        v74[3] = 0;
        v74[4] = 0;
        void *v74 = v200;
        v74[1] = (uint64_t **)(v74 + 3);
        v74[2] = (uint64_t **)0x100000000;
      }
LABEL_114:
      uint64_t v80 = *((unsigned int *)v74 + 4);
      if (v80)
      {
        unsigned int v81 = v74[1] + 1;
        uint64_t v82 = 16 * v80;
        while (*((_DWORD *)v81 - 2) != v56)
        {
          v81 += 2;
          v82 -= 16;
          if (!v82) {
            goto LABEL_70;
          }
        }
        unsigned int v68 = (uint64_t *)*v81;
LABEL_154:
        if (v68)
        {
LABEL_155:
          v217 = v219;
          HIDWORD(v218) = 4;
          v219[0] = a3;
          v219[1] = a5;
          unsigned int v209 = v8;
          unsigned int v102 = 1;
          do
          {
            long long v103 = (char *)v217 + 16 * v102;
            uint64_t v104 = *((void *)v103 - 2);
            uint64_t v105 = *((void *)v103 - 1);
            LODWORD(v218) = v102 - 1;
            if (v105)
            {
              if (*(unsigned char *)(v105 + 16) == 83)
              {
                uint64_t v106 = *(_DWORD *)(v105 + 20) & 0x7FFFFFF;
                if (v106)
                {
                  uint64_t v107 = 0;
                  uint64_t v108 = 0;
                  char v109 = 0;
                  uint64_t v110 = 32 * v106;
                  do
                  {
                    int v111 = *(_DWORD *)(v105 + 20);
                    if ((v111 & 0x40000000) != 0) {
                      uint64_t v112 = *(void *)(v105 - 8);
                    }
                    else {
                      uint64_t v112 = v105 - 32 * (v111 & 0x7FFFFFF);
                    }
                    unsigned int v113 = *((unsigned __int8 *)sub_1CD4B3548(*(llvm::Value **)(v112 + v108)) + 16);
                    BOOL v15 = v113 > 0x13;
                    int v114 = (1 << v113) & 0x81800;
                    if (v15 || v114 == 0)
                    {
                      int v116 = *(_DWORD *)(v105 + 20);
                      if ((v116 & 0x40000000) != 0) {
                        uint64_t v117 = *(void *)(v105 - 8);
                      }
                      else {
                        uint64_t v117 = v105 - 32 * (v116 & 0x7FFFFFF);
                      }
                      uint64_t v118 = *(void *)(v117 + 32 * *(unsigned int *)(v105 + 60) + v107);
                      uint64_t v119 = *(void *)(v118 + 40);
                      if (v119 == v118 + 40)
                      {
                        uint64_t v120 = 0;
                      }
                      else
                      {
                        if (v119) {
                          uint64_t v120 = v119 - 24;
                        }
                        else {
                          uint64_t v120 = 0;
                        }
                        if (*(unsigned __int8 *)(v120 + 16) - 29 >= 0xB) {
                          uint64_t v120 = 0;
                        }
                      }
                      if (*(unsigned char *)(v120 + 16) != 30)
                      {
                        switch(*(unsigned char *)(v120 + 16))
                        {
                          case 0x1E:
                            __break(1u);
                            JUMPOUT(0x1CCC0F33CLL);
                          case 0x1F:
                            int v121 = (*(_DWORD *)(v120 + 20) >> 1) & 0x3FFFFFF;
                            goto LABEL_186;
                          case 0x20:
                          case 0x26:
                            int v121 = (*(_DWORD *)(v120 + 20) & 0x7FFFFFF) - 1;
                            goto LABEL_186;
                          case 0x24:
                            int v121 = *(_WORD *)(v120 + 18) & 1;
                            goto LABEL_186;
                          case 0x25:
                            goto LABEL_168;
                          case 0x27:
                            int v121 = *(_DWORD *)(v120 + 80) + 1;
LABEL_186:
                            if (v121 != 1) {
                              goto LABEL_261;
                            }
                            goto LABEL_168;
                          default:
                            goto LABEL_261;
                        }
                      }
                      if ((*(_DWORD *)(v120 + 20) & 0x7FFFFFF) == 3) {
                        goto LABEL_261;
                      }
                    }
                    else
                    {
                      char v109 = 1;
                    }
LABEL_168:
                    v108 += 32;
                    v107 += 8;
                  }
                  while (v110 != v108);
                  if (v109)
                  {
                    int v122 = 0;
                    uint64_t SingleDependency = 0;
                    switch(a4)
                    {
                      case 0:
                      case 3:
                        goto LABEL_195;
                      case 1:
                      case 2:
                      case 6:
                        goto LABEL_261;
                      case 4:
                        goto LABEL_194;
                      case 5:
                        int v122 = 1;
LABEL_194:
                        uint64_t SingleDependency = llvm::objcarc::findSingleDependency(v122, (llvm::objcarc *)v105, *(void *)(v104 + 40), v104, (uint64_t *)(a1 + 8));
LABEL_195:
                        if (SingleDependency != v105) {
                          goto LABEL_261;
                        }
                        *(unsigned char *)a1 = 1;
                        v124 = *(llvm::Value **)(v104 - 32 * (*(_DWORD *)(v104 + 20) & 0x7FFFFFF));
                        int v125 = *(_DWORD *)(v105 + 20);
                        uint64_t v126 = v125 & 0x7FFFFFF;
                        if ((v125 & 0x7FFFFFF) == 0) {
                          goto LABEL_259;
                        }
                        uint64_t v127 = 0;
                        v206 = *(llvm::Type **)v124;
                        uint64_t v203 = v104 - 8;
                        break;
                      default:
                        goto LABEL_69;
                    }
                    while (1)
                    {
                      int v128 = *(_DWORD *)(v105 + 20);
                      if ((v128 & 0x40000000) != 0) {
                        uint64_t v129 = *(void *)(v105 - 8);
                      }
                      else {
                        uint64_t v129 = v105 - 32 * (v128 & 0x7FFFFFF);
                      }
                      uint64_t v130 = sub_1CD4B3548(*(llvm::Value **)(v129 + 32 * v127));
                      unsigned int v131 = *((unsigned __int8 *)v130 + 16);
                      BOOL v15 = v131 > 0x13;
                      int v132 = (1 << v131) & 0x81800;
                      if (v15 || v132 == 0)
                      {
                        int v134 = *(_DWORD *)(v105 + 20);
                        uint64_t v204 = v126;
                        uint64_t v205 = v130;
                        if ((v134 & 0x40000000) != 0) {
                          uint64_t v135 = *(void *)(v105 - 8);
                        }
                        else {
                          uint64_t v135 = v105 - 32 * (v134 & 0x7FFFFFF);
                        }
                        v136 = *(llvm::Value **)(v135 + 32 * v127);
                        uint64_t v137 = *(void *)(*(void *)(v135 + 32 * *(unsigned int *)(v105 + 60) + 8 * v127) + 40);
                        if (v137) {
                          int v138 = (uint64_t *)(v137 - 24);
                        }
                        else {
                          int v138 = 0;
                        }
                        int v207 = (llvm::Instruction *)v138;
                        uint64_t v139 = v138[5];
                        uint64_t v221 = (char *)v223;
                        uint64_t v222 = 0x100000000;
                        int v140 = *(_DWORD *)(v104 + 20);
                        if (v140 < 0)
                        {
                          unint64_t v175 = *(void *)(v203 - 32 * (v140 & 0x7FFFFFF));
                          if ((v175 & 0xFFFFFFFF0) != 0)
                          {
                            uint64_t v176 = (v175 >> 4);
                            uint64_t v177 = v104;
                            do
                            {
                              uint64_t v178 = *(_DWORD *)(v104 + 20) & 0x7FFFFFF;
                              uint64_t v179 = (unsigned int *)(v177 - (*(void *)(v203 - 32 * v178) + 32 * v178));
                              uint64_t v180 = *v179;
                              uint64_t v181 = v104 - 32 * v178 + 32 * v180;
                              uint64_t v182 = v179[1] - v180;
                              uint64_t v183 = *((void *)v179 - 1);
                              v215[0] = v181;
                              v215[1] = v182;
                              v215[2] = v183;
                              if (*(_DWORD *)(v183 + 8) != 1) {
                                sub_1CD5C74F0((uint64_t)&v221, (uint64_t)v215);
                              }
                              v177 += 16;
                              --v176;
                            }
                            while (v176);
                          }
                        }
                        if (*((_DWORD *)v209 + 2))
                        {
                          v215[0] = v139;
                          uint64_t v216 = 0;
                          int v162 = sub_1CD3C8538((uint64_t *)v209, v215, &v216);
                          uint64_t v163 = v216;
                          if (!v162) {
                            uint64_t v163 = *(void *)v209 + 16 * *((unsigned int *)v209 + 4);
                          }
                          v215[0] = 0;
                          uint64_t v164 = *(void *)(v163 + 8);
                          unint64_t v165 = v164 & 0xFFFFFFFFFFFFFFF8;
                          if ((v164 & 4) != 0) {
                            unint64_t v165 = **(void **)v165;
                          }
                          unint64_t v166 = v165 + 40;
                          for (uint64_t k = *(void *)(v165 + 48); k != v166; uint64_t k = *(void *)(k + 8))
                          {
                            uint64_t v168 = k - 24;
                            if (k) {
                              uint64_t v169 = k - 24;
                            }
                            else {
                              uint64_t v169 = 0;
                            }
                            if (*(unsigned char *)(v169 + 16) != 83) {
                              goto LABEL_248;
                            }
                          }
                          uint64_t v168 = 0;
LABEL_248:
                          v215[0] = v168;
                          unsigned int v172 = *(unsigned __int8 *)(v168 + 16) - 38;
                          BOOL v15 = v172 > 0x38;
                          uint64_t v173 = (1 << v172) & 0x100060000000001;
                          if (!v15 && v173 != 0) {
                            sub_1CD697EF8((uint64_t *)&v221, "funclet", v215);
                          }
                        }
                        uint64_t v141 = llvm::CallInst::Create(v104, (uint64_t)v221, v222, 0);
                        uint64_t v142 = v221;
                        if (v222)
                        {
                          uint64_t v143 = 48 * v222;
                          uint64_t v144 = v221 - 48;
                          do
                          {
                            sub_1CD4AF9B4((uint64_t)&v144[v143]);
                            v143 -= 48;
                          }
                          while (v143);
                          uint64_t v142 = v221;
                        }
                        if (v142 != (char *)v223) {
                          free(v142);
                        }
                        long long v145 = v136;
                        if (*(llvm::Type **)v136 != v206)
                        {
                          v146 = operator new(0x60uLL);
                          v146[13] = v146[13] & 0x38000000 | 1;
                          uint64_t v147 = (llvm::Value *)(v146 + 8);
                          *(void *)v146 = 0;
                          *((void *)v146 + 1) = 0;
                          *((void *)v146 + 2) = 0;
                          *((void *)v146 + 3) = v146 + 8;
                          v223[8] = 257;
                          llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v146 + 8), v136, v206, (const char **)&v221, v207);
                          long long v145 = v147;
                        }
                        uint64_t v126 = v204;
                        uint64_t v148 = *(_DWORD *)(v141 + 20) & 0x7FFFFFF;
                        uint64_t v149 = -v148;
                        v150 = (llvm::Value **)(v141 - 32 * v148);
                        if (*v150)
                        {
                          uint64_t v151 = v141 + 32 * v149;
                          unsigned int v153 = *(void **)(v151 + 16);
                          unsigned int v152 = (void *)(v151 + 16);
                          *unsigned int v153 = *(v152 - 1);
                          uint64_t v154 = *(v152 - 1);
                          if (v154) {
                            *(void *)(v154 + 16) = *v152;
                          }
                        }
                        uint64_t *v150 = v145;
                        uint64_t v157 = *((void *)v145 + 1);
                        v156 = (llvm::Value ***)((char *)v145 + 8);
                        uint64_t v155 = v157;
                        uint64_t v158 = v141 + 32 * v149;
                        *(void *)(v158 + 8) = v157;
                        if (v157) {
                          *(void *)(v155 + 16) = v158 + 8;
                        }
                        *(void *)(v158 + 16) = v156;
                        uint64_t *v156 = v150;
                        uint64_t v159 = *((void *)v207 + 5);
                        *(void *)(v141 + 40) = v159;
                        *(_WORD *)(v159 + 18) &= ~0x8000u;
                        if ((*(unsigned char *)(v141 + 23) & 0x10) != 0)
                        {
                          uint64_t v170 = *(void *)(v159 + 56);
                          if (v170)
                          {
                            v171 = *(llvm::ValueSymbolTable **)(v170 + 104);
                            if (v171) {
                              llvm::ValueSymbolTable::reinsertValue(v171, (llvm::Value *)v141);
                            }
                          }
                        }
                        uint64_t v160 = *((void *)v207 + 3);
                        *(void *)(v141 + 24) = v160;
                        *(void *)(v141 + 32) = (char *)v207 + 24;
                        *(void *)(v160 + 8) = v141 + 24;
                        *((void *)v207 + 3) = v141 + 24;
                        if (v218 >= (unint64_t)HIDWORD(v218)) {
                          llvm::SmallVectorBase<unsigned int>::grow_pod();
                        }
                        v161 = (uint64_t *)((char *)v217 + 16 * v218);
                        uint64_t *v161 = v141;
                        v161[1] = (uint64_t)v205;
                        LODWORD(v218) = v218 + 1;
                      }
                      if (++v127 == v126)
                      {
                        v124 = *(llvm::Value **)(v104 - 32 * (*(_DWORD *)(v104 + 20) & 0x7FFFFFF));
LABEL_259:
                        if (*(void *)(v104 + 8))
                        {
                          llvm::Value::doRAUW((llvm::ValueAsMetadata *)v104, v124, (llvm::Value *)1);
                          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                        }
                        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                      }
                    }
                  }
                }
              }
            }
LABEL_261:
            unsigned int v102 = v218;
          }
          while (v218);
          if (v217 != v219) {
            free(v217);
          }
        }
      }
    }
  }
LABEL_70:
  if (v211 != v210) {
    free(v211);
  }
}

uint64_t sub_1CCC0F3CC(llvm::Value *a1, uint64_t a2)
{
  BOOL v3 = llvm::Value::stripPointerCasts(a1);
  int v4 = *((unsigned __int8 *)v3 + 16);
  if ((v4 - 11) < 2 || v4 == 19) {
    return 1;
  }
  uint64_t v7 = v3;
  if (v4 != 3) {
    goto LABEL_11;
  }
  uint64_t v8 = *((void *)v3 + 9);
  if (!v8) {
    return 0;
  }
  v30[0] = "objc_arc_inert";
  v30[1] = 14;
  uint64_t v31 = 0;
  if (sub_1CC5122C8((uint64_t *)(v8 + 24), (uint64_t)v30, &v31)) {
    return 1;
  }
  int v4 = *((unsigned __int8 *)v7 + 16);
LABEL_11:
  if (v4 != 83) {
    return 0;
  }
  uint64_t v9 = *(void *)(a2 + 8);
  uint64_t v10 = *(unsigned int *)(a2 + 20);
  if (v9 == *(void *)a2)
  {
    if (v10)
    {
      int v11 = 0;
      uint64_t v12 = 8 * v10;
      unsigned int v13 = *(llvm::Value ***)(a2 + 8);
      while (*v13 != v7)
      {
        if (*v13 == (llvm::Value *)-2) {
          int v11 = v13;
        }
        ++v13;
        v12 -= 8;
        if (!v12)
        {
          if (!v11) {
            goto LABEL_20;
          }
          *int v11 = v7;
          --*(_DWORD *)(a2 + 24);
          goto LABEL_45;
        }
      }
      return 1;
    }
LABEL_20:
    unsigned int v14 = *(_DWORD *)(a2 + 16);
    if (v10 < v14)
    {
      *(_DWORD *)(a2 + 20) = v10 + 1;
      *(void *)(v9 + 8 * v10) = v7;
      goto LABEL_45;
    }
  }
  else
  {
    unsigned int v14 = *(_DWORD *)(a2 + 16);
  }
  if (3 * v14 <= 4 * ((int)v10 - *(_DWORD *)(a2 + 24)))
  {
    if (v14 >= 0x40) {
      v14 *= 2;
    }
    else {
      unsigned int v14 = 128;
    }
    goto LABEL_61;
  }
  if (v14 - v10 < v14 >> 3)
  {
LABEL_61:
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)a2, v14);
    unsigned int v14 = *(_DWORD *)(a2 + 16);
    uint64_t v9 = *(void *)(a2 + 8);
  }
  unsigned int v15 = v14 - 1;
  unsigned int v16 = (v14 - 1) & ((v7 >> 4) ^ (v7 >> 9));
  int v17 = (llvm::Value **)(v9 + 8 * v16);
  uint64_t v18 = *v17;
  if (*v17 != (llvm::Value *)-1)
  {
    int v19 = 0;
    int v20 = 1;
    while (v18 != v7)
    {
      if (v19) {
        BOOL v21 = 0;
      }
      else {
        BOOL v21 = v18 == (llvm::Value *)-2;
      }
      if (v21) {
        int v19 = v17;
      }
      unsigned int v22 = v16 + v20++;
      unsigned int v16 = v22 & v15;
      int v17 = (llvm::Value **)(v9 + 8 * (v22 & v15));
      uint64_t v18 = *v17;
      if (*v17 == (llvm::Value *)-1) {
        goto LABEL_38;
      }
    }
    return 1;
  }
  int v19 = 0;
LABEL_38:
  if (v19) {
    unsigned int v23 = v19;
  }
  else {
    unsigned int v23 = v17;
  }
  if (*v23 == v7) {
    return 1;
  }
  if (*v23 == (llvm::Value *)-2) {
    --*(_DWORD *)(a2 + 24);
  }
  else {
    ++*(_DWORD *)(a2 + 20);
  }
  unint64_t *v23 = v7;
LABEL_45:
  int v24 = *((_DWORD *)v7 + 5);
  if ((v24 & 0x40000000) != 0)
  {
    uint64_t v26 = (uint64_t *)*((void *)v7 - 1);
    uint64_t v25 = v24 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v25 = v24 & 0x7FFFFFF;
    uint64_t v26 = (uint64_t *)((char *)v7 - 32 * v25);
  }
  if (!v25) {
    return 1;
  }
  uint64_t v27 = 32 * v25 - 32;
  do
  {
    uint64_t v28 = *v26;
    v26 += 4;
    uint64_t result = sub_1CCC0F3CC(v28, a2);
    if (result) {
      BOOL v29 = v27 == 0;
    }
    else {
      BOOL v29 = 1;
    }
    v27 -= 32;
  }
  while (!v29);
  return result;
}

BOOL sub_1CCC0F60C(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int8 *)(a1 + 16);
  if (v1 - 21 <= 0x3F && ((1 << (v1 - 21)) & 0x8000000000001001) != 0) {
    return 1;
  }
  BOOL result = 1;
  if (v1 >= 0x15 && v1 != 59)
  {
    if (v1 != 60) {
      return 0;
    }
    uint64_t v5 = sub_1CD4B3548(*(llvm::Value **)(a1 - 32));
    if (!v5 || *((unsigned char *)v5 + 16) != 3) {
      return 0;
    }
    if (*((unsigned char *)v5 + 80)) {
      return 1;
    }
    unsigned int v6 = v5 >> 4;
    if ((*((unsigned char *)v5 + 23) & 0x10) == 0)
    {
LABEL_30:
      long long v21 = 0uLL;
      if ((*((unsigned char *)v5 + 34) & 0x40) == 0)
      {
LABEL_34:
        long long v35 = v21;
        return llvm::StringRef::find((uint64_t *)&v35, "__message_refs", 0xEuLL, 0) != -1
            || llvm::StringRef::find((uint64_t *)&v35, "__objc_classrefs", 0x10uLL, 0) != -1
            || llvm::StringRef::find((uint64_t *)&v35, "__objc_superrefs", 0x10uLL, 0) != -1
            || llvm::StringRef::find((uint64_t *)&v35, "__objc_methname", 0xFuLL, 0) != -1
            || llvm::StringRef::find((uint64_t *)&v35, "__cstring", 9uLL, 0) != -1;
      }
      uint64_t v22 = ***(void ***)v5;
      size_t v36 = v5;
      int v23 = *(_DWORD *)(v22 + 2520);
      if (v23)
      {
        uint64_t v24 = *(void *)(v22 + 2504);
        int v25 = v23 - 1;
        unsigned int v26 = v25 & (v6 ^ (v5 >> 9));
        uint64_t v27 = (void *)(v24 + 24 * v26);
        uint64_t v28 = (llvm::Value *)*v27;
        if ((llvm::Value *)*v27 == v5)
        {
LABEL_33:
          long long v21 = *(_OWORD *)(v27 + 1);
          goto LABEL_34;
        }
        BOOL v29 = 0;
        int v30 = 1;
        while (v28 != (llvm::Value *)-4096)
        {
          if (v29) {
            BOOL v31 = 0;
          }
          else {
            BOOL v31 = v28 == (llvm::Value *)-8192;
          }
          if (v31) {
            BOOL v29 = v27;
          }
          unsigned int v32 = v26 + v30++;
          unsigned int v26 = v32 & v25;
          uint64_t v27 = (void *)(v24 + 24 * (v32 & v25));
          uint64_t v28 = (llvm::Value *)*v27;
          if ((llvm::Value *)*v27 == v5) {
            goto LABEL_33;
          }
        }
        if (v29) {
          uint64_t v33 = v29;
        }
        else {
          uint64_t v33 = v27;
        }
      }
      else
      {
        uint64_t v33 = 0;
      }
      uint64_t v27 = sub_1CC5BF31C(v22 + 2504, (uint64_t)&v36, (uint64_t *)&v36, v33);
      uint64_t v34 = (uint64_t)v36;
      v27[1] = 0;
      v27[2] = 0;
      void *v27 = v34;
      goto LABEL_33;
    }
    uint64_t v7 = ***(void ***)v5;
    uint64_t v8 = *(void *)(v7 + 152);
    uint64_t v9 = *(unsigned int *)(v7 + 168);
    if (v9)
    {
      LODWORD(v10) = (v9 - 1) & (v6 ^ (v5 >> 9));
      int v11 = (llvm::Value **)(v8 + 16 * v10);
      uint64_t v12 = *v11;
      if (*v11 == v5)
      {
LABEL_22:
        unsigned int v15 = v11[1];
        if (*(void *)v15 >= 0x16uLL)
        {
          uint64_t v16 = *((void *)v15 + 2);
          uint64_t v17 = *((void *)v15 + 3);
          uint64_t v18 = *(void *)((char *)v15 + 30);
          BOOL v19 = v16 == 0x5F636A626F5F6C01 && v17 == 0x5F646E655367736DLL;
          if (v19 && v18 == 0x5F70757869665F64) {
            return 1;
          }
        }
        goto LABEL_30;
      }
      int v13 = 1;
      while (v12 != (llvm::Value *)-4096)
      {
        int v14 = v10 + v13++;
        uint64_t v10 = v14 & (v9 - 1);
        uint64_t v12 = *(llvm::Value **)(v8 + 16 * v10);
        if (v12 == v5)
        {
          int v11 = (llvm::Value **)(v8 + 16 * v10);
          goto LABEL_22;
        }
      }
    }
    int v11 = (llvm::Value **)(v8 + 16 * v9);
    goto LABEL_22;
  }
  return result;
}

void *sub_1CCC0F8D0(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CCC0F984(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CCC0FA1C(a1, a2, v7);
    void *v5 = *a2;
    *(_OWORD *)(v5 + 13) = 0u;
    *(_OWORD *)(v5 + 15) = 0u;
    *(_OWORD *)(v5 + 17) = 0u;
    *(_OWORD *)(v5 + 19) = 0u;
    v5[21] = 0;
    *(_OWORD *)(v5 + 11) = 0u;
    *(_OWORD *)(v5 + 9) = 0u;
    *(_OWORD *)(v5 + 7) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 3) = 0u;
    *(_OWORD *)(v5 + 1) = 0u;
    v5[14] = v5 + 16;
    *((_DWORD *)v5 + 31) = 2;
    v5[18] = v5 + 20;
    *((_DWORD *)v5 + 39) = 2;
  }
  return v5 + 1;
}

uint64_t sub_1CCC0F984(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    unsigned int v6 = (void *)(a1 + 176 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        unsigned int v6 = (void *)(a1 + 176 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_5;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        unsigned int v6 = v10;
      }
    }
  }
  else
  {
    unsigned int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_5:
  *a4 = v6;
  return v8;
}

void *sub_1CCC0FA1C(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v34 = a3;
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    int v7 = 2 * v6;
  }
  else
  {
    int v7 = *(_DWORD *)(a1 + 16);
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
  }
  uint64_t v9 = *(void *)a1;
  unint64_t v10 = (v7 - 1) | ((unint64_t)(v7 - 1) >> 1);
  unint64_t v11 = v10 | (v10 >> 2) | ((v10 | (v10 >> 2)) >> 4);
  int v12 = ((v11 | (v11 >> 8)) >> 16) | v11 | (v11 >> 8);
  if ((v12 + 1) > 0x40) {
    unsigned int v13 = v12 + 1;
  }
  else {
    unsigned int v13 = 64;
  }
  *(_DWORD *)(a1 + 16) = v13;
  int v14 = operator new(176 * v13, (std::align_val_t)8uLL);
  *(void *)a1 = v14;
  if (v9)
  {
    *(void *)(a1 + 8) = 0;
    unsigned int v15 = *(_DWORD *)(a1 + 16);
    if (v15)
    {
      uint64_t v16 = 176 * v15;
      do
      {
        *int v14 = -4096;
        v14 += 22;
        v16 -= 176;
      }
      while (v16);
    }
    if (v6)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 176 * v6;
      do
      {
        uint64_t v19 = v9 + v17;
        uint64_t v20 = *(void *)(v9 + v17);
        if ((v20 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          long long v35 = 0;
          sub_1CCC0F984(*(void *)a1, *(_DWORD *)(a1 + 16), v20, &v35);
          long long v21 = v35;
          uint64_t *v35 = v20;
          v21[1] = *(void *)(v19 + 8);
          sub_1CD46AEB4((uint64_t)(v21 + 2), v19 + 16);
          sub_1CD46AEB4((uint64_t)(v21 + 8), v19 + 64);
          v21[14] = (uint64_t)(v21 + 16);
          v21[15] = 0x200000000;
          unsigned int v22 = *(_DWORD *)(v19 + 120);
          if (v22 && (uint64_t *)v19 != v21)
          {
            int v23 = *(const void **)(v9 + v17 + 112);
            uint64_t v24 = v9 + v17 + 128;
            if ((const void *)v24 == v23)
            {
              if (v22 >= 3) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v21 + 16, v23, 8 * *(unsigned int *)(v19 + 120));
              *((_DWORD *)v21 + 30) = v22;
            }
            else
            {
              v21[14] = (uint64_t)v23;
              *((_DWORD *)v21 + 30) = v22;
              *((_DWORD *)v21 + 31) = *(_DWORD *)(v9 + v17 + 124);
              *(void *)(v9 + v17 + 112) = v24;
              *(_DWORD *)(v9 + v17 + 124) = 0;
            }
            *(_DWORD *)(v19 + 120) = 0;
          }
          v21[18] = (uint64_t)(v21 + 20);
          v21[19] = 0x200000000;
          uint64_t v25 = v9 + v17;
          unsigned int v26 = *(_DWORD *)(v9 + v17 + 152);
          if (v26 && (uint64_t *)v19 != v21)
          {
            uint64_t v27 = *(const void **)(v25 + 144);
            uint64_t v28 = v9 + v17;
            uint64_t v29 = v9 + v17 + 160;
            if ((const void *)v29 == v27)
            {
              if (v26 >= 3) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              memcpy(v21 + 20, v27, 8 * *(unsigned int *)(v9 + v17 + 152));
              *((_DWORD *)v21 + 38) = v26;
            }
            else
            {
              v21[18] = (uint64_t)v27;
              *((_DWORD *)v21 + 38) = v26;
              *((_DWORD *)v21 + 39) = *(_DWORD *)(v28 + 156);
              *(void *)(v25 + 144) = v29;
              *(_DWORD *)(v28 + 156) = 0;
            }
            *(_DWORD *)(v25 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
          }
          ++*(_DWORD *)(a1 + 8);
          int v30 = *(void **)(v25 + 144);
          if ((void *)(v25 + 160) != v30) {
            free(v30);
          }
          BOOL v31 = *(void **)(v9 + v17 + 112);
          if ((void *)(v9 + v17 + 128) != v31) {
            free(v31);
          }
          sub_1CD6C05A4(v19 + 64);
          sub_1CD6C05A4(v19 + 16);
        }
        v17 += 176;
      }
      while (v18 != v17);
    }
    MEMORY[0x1D25D9CD0](v9, 8);
    int v14 = *(void **)a1;
    unsigned int v32 = *(_DWORD *)(a1 + 16);
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    unsigned int v32 = *(_DWORD *)(a1 + 16);
    if (v32)
    {
      uint64_t v33 = 0;
      do
      {
        v14[v33] = -4096;
        v33 += 22;
      }
      while (22 * v32 != v33);
    }
  }
  sub_1CCC0F984((uint64_t)v14, v32, *a2, &v34);
  int v5 = *(_DWORD *)(a1 + 8);
  a3 = v34;
LABEL_3:
  *(_DWORD *)(a1 + 8) = v5 + 1;
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void sub_1CCC0FDAC(void ***a1)
{
  unsigned int v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unsigned int v6 = v4 - 136;
        sub_1CD6C05EC((void *)v4 - 15);
        int v4 = v6;
      }
      while (v6 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

BOOL sub_1CCC0FE34(uint64_t a1, llvm::objcarc *this, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int ARCInstKind = llvm::objcarc::GetARCInstKind(this, this);
  int v11 = ARCInstKind;
  BOOL inited = 0;
  unsigned int v13 = 0;
  switch(ARCInstKind)
  {
    case 0:
    case 1:
      unsigned int v13 = sub_1CD4B3548(*((llvm::Value **)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF)));
      uint64_t v25 = v13;
      int v14 = (llvm::objcarc::BottomUpPtrState *)sub_1CD6C09D8(a5 + 56, (uint64_t *)&v25);
      if (llvm::objcarc::BottomUpPtrState::MatchWithRetain(v14))
      {
        if (v11 != 1)
        {
          uint64_t v25 = this;
          uint64_t v24 = sub_1CD6C0884(a4, (uint64_t *)&v25);
          sub_1CD6C06F8(v24, (uint64_t)v14 + 8);
        }
        llvm::objcarc::PtrState::ResetSequenceProgress((uint64_t)v14, 0);
      }
      BOOL inited = 0;
      goto LABEL_5;
    case 2:
    case 3:
    case 5:
    case 6:
      goto LABEL_5;
    case 4:
      unsigned int v13 = sub_1CD4B3548(*((llvm::Value **)this - 4 * (*((_DWORD *)this + 5) & 0x7FFFFFF)));
      uint64_t v25 = v13;
      uint64_t v19 = sub_1CD6C09D8(a5 + 56, (uint64_t *)&v25);
      BOOL inited = llvm::objcarc::BottomUpPtrState::InitBottomUp(v19, a1 + 160, this);
      goto LABEL_5;
    case 7:
      return inited;
    case 8:
      sub_1CD3C7F68((_DWORD *)(a5 + 56));
      uint64_t v21 = *(void *)(a5 + 80);
      uint64_t v20 = *(void *)(a5 + 88);
      if (v20 != v21)
      {
        do
        {
          uint64_t v22 = v20 - 136;
          sub_1CD6C05EC((void *)(v20 - 120));
          uint64_t v20 = v22;
        }
        while (v22 != v21);
      }
      BOOL inited = 0;
      *(void *)(a5 + 88) = v21;
      return inited;
    default:
      if (ARCInstKind != 24)
      {
LABEL_5:
        unsigned int v15 = *(const llvm::Value ***)(a5 + 80);
        uint64_t v16 = *(const llvm::Value ***)(a5 + 88);
        if (v15 != v16)
        {
          uint64_t v17 = (const llvm::Value **)(a1 + 8);
          do
          {
            uint64_t v18 = *v15;
            if (*v15 != v13
              && (llvm::objcarc::BottomUpPtrState::HandlePotentialAlterRefCount((uint64_t)(v15 + 1), (uint64_t)this, *v15, (uint64_t *)v17, v11) & 1) == 0)
            {
              llvm::objcarc::BottomUpPtrState::HandlePotentialUse((llvm::Value *)(v15 + 1), a3, (uint64_t)this, v18, v17, v11);
            }
            v15 += 17;
          }
          while (v15 != v16);
        }
      }
      return inited;
  }
}

uint64_t sub_1CCC10048(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  int v7 = (void *)result;
  uint64_t v8 = *(char **)result;
  if (0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(result + 16) - *(void *)result) >> 3) < a4)
  {
    sub_1CD6C068C((void **)result);
    if (a4 > 0x1E1E1E1E1E1E1E1) {
      goto LABEL_23;
    }
    unint64_t v19 = 0xE1E1E1E1E1E1E1E2 * ((uint64_t)(v7[2] - *v7) >> 3);
    if (v19 <= a4) {
      unint64_t v19 = a4;
    }
    unint64_t v20 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v7[2] - *v7) >> 3) >= 0xF0F0F0F0F0F0F0 ? 0x1E1E1E1E1E1E1E1 : v19;
    if (v20 > 0x1E1E1E1E1E1E1E1) {
LABEL_23:
    }
      abort();
    uint64_t v21 = 17 * v20;
    uint64_t v22 = (char *)operator new(136 * v20);
    *int v7 = v22;
    v7[1] = v22;
    v7[2] = &v22[8 * v21];
    BOOL result = sub_1CCC1022C(a2, a3, (uint64_t)v22);
    v7[1] = result;
  }
  else
  {
    uint64_t v9 = *(char **)(result + 8);
    if (0xF0F0F0F0F0F0F0F1 * ((v9 - v8) >> 3) >= a4)
    {
      if (a2 != a3)
      {
        BOOL result = (uint64_t)(v8 + 16);
        uint64_t v15 = a2 + 16;
        do
        {
          *(void *)(result - 16) = *(void *)(v15 - 16);
          __int16 v16 = *(_WORD *)(v15 - 8);
          *(unsigned char *)(result - 6) = *(unsigned char *)(v15 - 6);
          *(_WORD *)(result - 8) = v16;
          v8 += 136;
          BOOL result = sub_1CD6C06F8(result, v15) + 136;
          uint64_t v17 = v15 + 120;
          v15 += 136;
        }
        while (v17 != a3);
        uint64_t v9 = (char *)v7[1];
      }
      if (v9 != v8)
      {
        do
        {
          uint64_t v18 = v9 - 136;
          BOOL result = (uint64_t)sub_1CD6C05EC((void *)v9 - 15);
          uint64_t v9 = v18;
        }
        while (v18 != v8);
      }
      v7[1] = v8;
    }
    else
    {
      uint64_t v10 = a2 + 8 * ((v9 - v8) >> 3);
      if (v9 != v8)
      {
        uint64_t v11 = (uint64_t)(v8 + 16);
        uint64_t v12 = a2 + 16;
        do
        {
          *(void *)(v11 - 16) = *(void *)(v12 - 16);
          __int16 v13 = *(_WORD *)(v12 - 8);
          *(unsigned char *)(v11 - 6) = *(unsigned char *)(v12 - 6);
          *(_WORD *)(v11 - 8) = v13;
          uint64_t v11 = sub_1CD6C06F8(v11, v12) + 136;
          uint64_t v14 = v12 + 120;
          v12 += 136;
        }
        while (v14 != v10);
        uint64_t v8 = (char *)v7[1];
      }
      BOOL result = sub_1CCC1022C(v10, a3, (uint64_t)v8);
      v7[1] = result;
    }
  }
  return result;
}

uint64_t sub_1CCC1022C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      uint64_t v8 = a1 + v6;
      *(void *)uint64_t v7 = *(void *)(a1 + v6);
      __int16 v9 = *(_WORD *)(a1 + v6 + 8);
      *(unsigned char *)(v7 + 10) = *(unsigned char *)(a1 + v6 + 10);
      *(_WORD *)(v7 + 8) = v9;
      *(_OWORD *)(v7 + 16) = *(_OWORD *)(a1 + v6 + 16);
      uint64_t v10 = (void *)(a3 + v6 + 64);
      *(void *)(v7 + 32) = v10;
      uint64_t v11 = *(const void **)(a1 + v6 + 40);
      if (v11 == *(const void **)(a1 + v6 + 32))
      {
        *(void *)(v7 + 40) = v10;
      }
      else
      {
        uint64_t v26 = *(unsigned int *)(v8 + 48);
        uint64_t v10 = malloc_type_malloc(8 * v26, 0x4065EBACuLL);
        if (!v10 && (v26 || (uint64_t v10 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) == 0)) {
LABEL_28:
        }
          llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
        *(void *)(a3 + v6 + 40) = v10;
        uint64_t v11 = *(const void **)(v8 + 32);
      }
      uint64_t v12 = a1 + v6;
      uint64_t v13 = a3 + v6;
      *(_DWORD *)(a3 + v6 + 48) = *(_DWORD *)(a1 + v6 + 48);
      uint64_t v14 = *(const void **)(v8 + 40);
      int v15 = *(_DWORD *)(a1 + v6 + 52);
      if (v14 == v11) {
        unsigned int v16 = *(_DWORD *)(a1 + v6 + 52);
      }
      else {
        unsigned int v16 = *(_DWORD *)(a1 + v6 + 48);
      }
      if (v16)
      {
        memmove(v10, v14, 8 * v16);
        int v15 = *(_DWORD *)(v12 + 52);
      }
      int v17 = *(_DWORD *)(v12 + 56);
      *(_DWORD *)(v13 + 52) = v15;
      *(_DWORD *)(v13 + 56) = v17;
      uint64_t v18 = (void *)(v13 + 112);
      *(void *)(v13 + 80) = v13 + 112;
      unint64_t v19 = *(const void **)(v12 + 88);
      if (v19 == *(const void **)(v12 + 80))
      {
        *(void *)(a3 + v6 + 88) = v18;
      }
      else
      {
        uint64_t v27 = *(unsigned int *)(a1 + v6 + 96);
        uint64_t v18 = malloc_type_malloc(8 * v27, 0x4065EBACuLL);
        if (!v18)
        {
          if (v27) {
            goto LABEL_28;
          }
          uint64_t v18 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
          if (!v18) {
            goto LABEL_28;
          }
        }
        *(void *)(a3 + v6 + 88) = v18;
        unint64_t v19 = *(const void **)(v12 + 80);
      }
      uint64_t v20 = a1 + v6;
      uint64_t v21 = a3 + v6;
      *(_DWORD *)(a3 + v6 + 96) = *(_DWORD *)(a1 + v6 + 96);
      uint64_t v22 = *(const void **)(v12 + 88);
      int v23 = *(_DWORD *)(a1 + v6 + 100);
      if (v22 == v19) {
        unsigned int v24 = *(_DWORD *)(a1 + v6 + 100);
      }
      else {
        unsigned int v24 = *(_DWORD *)(a1 + v6 + 96);
      }
      if (v24)
      {
        memmove(v18, v22, 8 * v24);
        int v23 = *(_DWORD *)(v20 + 100);
      }
      int v25 = *(_DWORD *)(v20 + 104);
      *(_DWORD *)(v21 + 100) = v23;
      *(_DWORD *)(v21 + 104) = v25;
      *(unsigned char *)(v21 + 128) = *(unsigned char *)(v20 + 128);
      v6 += 136;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void sub_1CCC10400(uint64_t *a1, uint64_t a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = a1[2];
  if (v5 < v4)
  {
    *(void *)unint64_t v5 = *(void *)a2;
    __int16 v6 = *(_WORD *)(a2 + 8);
    *(unsigned char *)(v5 + 10) = *(unsigned char *)(a2 + 10);
    *(_WORD *)(v5 + 8) = v6;
    *(_OWORD *)(v5 + 16) = *(_OWORD *)(a2 + 16);
    uint64_t v7 = (void *)(v5 + 64);
    *(void *)(v5 + 32) = v5 + 64;
    uint64_t v8 = *(const void **)(a2 + 40);
    if (v8 == *(const void **)(a2 + 32))
    {
      *(void *)(v5 + 40) = v7;
    }
    else
    {
      uint64_t v47 = *(unsigned int *)(a2 + 48);
      uint64_t v7 = malloc_type_malloc(8 * v47, 0x4065EBACuLL);
      if (!v7)
      {
        if (v47) {
          goto LABEL_67;
        }
        uint64_t v7 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
        if (!v7) {
          goto LABEL_67;
        }
      }
      *(void *)(v5 + 40) = v7;
      uint64_t v8 = *(const void **)(a2 + 32);
    }
    *(_DWORD *)(v5 + 48) = *(_DWORD *)(a2 + 48);
    __int16 v9 = *(const void **)(a2 + 40);
    int v10 = *(_DWORD *)(a2 + 52);
    if (v9 == v8) {
      unsigned int v11 = *(_DWORD *)(a2 + 52);
    }
    else {
      unsigned int v11 = *(_DWORD *)(a2 + 48);
    }
    if (v11)
    {
      memmove(v7, v9, 8 * v11);
      int v10 = *(_DWORD *)(a2 + 52);
    }
    int v12 = *(_DWORD *)(a2 + 56);
    *(_DWORD *)(v5 + 52) = v10;
    *(_DWORD *)(v5 + 56) = v12;
    uint64_t v13 = (void *)(v5 + 112);
    *(void *)(v5 + 80) = v5 + 112;
    uint64_t v14 = *(const void **)(a2 + 88);
    if (v14 == *(const void **)(a2 + 80))
    {
      *(void *)(v5 + 88) = v13;
LABEL_11:
      *(_DWORD *)(v5 + 96) = *(_DWORD *)(a2 + 96);
      int v15 = *(const void **)(a2 + 88);
      int v16 = *(_DWORD *)(a2 + 100);
      if (v15 == v14) {
        unsigned int v17 = *(_DWORD *)(a2 + 100);
      }
      else {
        unsigned int v17 = *(_DWORD *)(a2 + 96);
      }
      if (v17)
      {
        memmove(v13, v15, 8 * v17);
        int v16 = *(_DWORD *)(a2 + 100);
      }
      int v18 = *(_DWORD *)(a2 + 104);
      *(_DWORD *)(v5 + 100) = v16;
      *(_DWORD *)(v5 + 104) = v18;
      *(unsigned char *)(v5 + 128) = *(unsigned char *)(a2 + 128);
      uint64_t v19 = v5 + 136;
      goto LABEL_45;
    }
    uint64_t v48 = *(unsigned int *)(a2 + 96);
    uint64_t v13 = malloc_type_malloc(8 * v48, 0x4065EBACuLL);
    if (v13 || !v48 && (uint64_t v13 = malloc_type_malloc(1uLL, 0x4065EBACuLL)) != 0)
    {
      *(void *)(v5 + 88) = v13;
      uint64_t v14 = *(const void **)(a2 + 80);
      goto LABEL_11;
    }
LABEL_67:
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  unint64_t v20 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v5 - *a1) >> 3);
  if (v20 + 1 > 0x1E1E1E1E1E1E1E1) {
    abort();
  }
  unint64_t v21 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v4 - *a1) >> 3);
  uint64_t v22 = 2 * v21;
  if (2 * v21 <= v20 + 1) {
    uint64_t v22 = v20 + 1;
  }
  if (v21 >= 0xF0F0F0F0F0F0F0) {
    unint64_t v23 = 0x1E1E1E1E1E1E1E1;
  }
  else {
    unint64_t v23 = v22;
  }
  if (v23)
  {
    if (v23 > 0x1E1E1E1E1E1E1E1) {
      sub_1CB833614();
    }
    unsigned int v24 = operator new(136 * v23);
  }
  else
  {
    unsigned int v24 = 0;
  }
  uint64_t v25 = (uint64_t)&v24[136 * v20];
  *(void *)uint64_t v25 = *(void *)a2;
  *(_WORD *)(v25 + 8) = *(_WORD *)(a2 + 8);
  *(unsigned char *)(v25 + 10) = *(unsigned char *)(a2 + 10);
  *(_OWORD *)(v25 + 16) = *(_OWORD *)(a2 + 16);
  uint64_t v26 = (void *)(v25 + 64);
  *(void *)(v25 + 32) = v25 + 64;
  uint64_t v27 = *(const void **)(a2 + 40);
  if (v27 == *(const void **)(a2 + 32))
  {
    *(void *)(v25 + 40) = v26;
    uint64_t v28 = v27;
  }
  else
  {
    uint64_t v49 = *(unsigned int *)(a2 + 48);
    uint64_t v26 = malloc_type_malloc(8 * v49, 0x4065EBACuLL);
    if (!v26)
    {
      if (v49) {
        goto LABEL_67;
      }
      uint64_t v26 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v26) {
        goto LABEL_67;
      }
    }
    *(void *)(v25 + 40) = v26;
    uint64_t v28 = *(const void **)(a2 + 32);
    uint64_t v27 = *(const void **)(a2 + 40);
  }
  unsigned int v30 = *(_DWORD *)(a2 + 48);
  unsigned int v29 = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(v25 + 48) = v30;
  if (v27 == v28) {
    unsigned int v31 = v29;
  }
  else {
    unsigned int v31 = v30;
  }
  if (v31)
  {
    memmove(v26, v27, 8 * v31);
    unsigned int v29 = *(_DWORD *)(a2 + 52);
  }
  int v32 = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(v25 + 52) = v29;
  *(_DWORD *)(v25 + 56) = v32;
  uint64_t v33 = &v24[136 * v20];
  uint64_t v34 = v33 + 112;
  *((void *)v33 + 10) = v33 + 112;
  long long v35 = v33 + 80;
  size_t v36 = *(const void **)(a2 + 88);
  if (v36 == *(const void **)(a2 + 80))
  {
    *((void *)v35 + 1) = v34;
    size_t v37 = v36;
  }
  else
  {
    uint64_t v50 = *(unsigned int *)(a2 + 96);
    uint64_t v34 = malloc_type_malloc(8 * v50, 0x4065EBACuLL);
    if (!v34)
    {
      if (v50) {
        goto LABEL_67;
      }
      uint64_t v34 = malloc_type_malloc(1uLL, 0x4065EBACuLL);
      if (!v34) {
        goto LABEL_67;
      }
    }
    *((void *)v35 + 1) = v34;
    size_t v37 = *(const void **)(a2 + 80);
    size_t v36 = *(const void **)(a2 + 88);
  }
  unsigned int v38 = &v24[136 * v23];
  unsigned int v40 = *(_DWORD *)(a2 + 96);
  unsigned int v39 = *(_DWORD *)(a2 + 100);
  *((_DWORD *)v35 + 4) = v40;
  if (v36 == v37) {
    unsigned int v41 = v39;
  }
  else {
    unsigned int v41 = v40;
  }
  if (v41)
  {
    memmove(v34, v36, 8 * v41);
    unsigned int v39 = *(_DWORD *)(a2 + 100);
  }
  int v42 = *(_DWORD *)(a2 + 104);
  *((_DWORD *)v35 + 5) = v39;
  *((_DWORD *)v35 + 6) = v42;
  v24[136 * v20 + 128] = *(unsigned char *)(a2 + 128);
  uint64_t v19 = v25 + 136;
  uint64_t v43 = sub_1CCC107C4(a1[1], a1[1], *a1, *a1, v25, v25);
  uint64_t v45 = (char *)*a1;
  uint64_t v44 = (char *)a1[1];
  *a1 = v43;
  a1[1] = v25 + 136;
  a1[2] = (uint64_t)v38;
  if (v44 != v45)
  {
    do
    {
      uint64_t v46 = v44 - 136;
      sub_1CD6C05EC((void *)v44 - 15);
      uint64_t v44 = v46;
    }
    while (v46 != v45);
  }
  if (v45) {
    operator delete(v45);
  }
LABEL_45:
  a1[1] = v19;
}

uint64_t sub_1CCC107C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2 != a4)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = a6 + v9;
      uint64_t v11 = a2 + v9;
      *(void *)(v10 - 136) = *(void *)(a2 + v9 - 136);
      __int16 v12 = *(_WORD *)(a2 + v9 - 128);
      *(unsigned char *)(v10 - 126) = *(unsigned char *)(a2 + v9 - 126);
      *(_WORD *)(v10 - 128) = v12;
      *(_OWORD *)(v10 - 120) = *(_OWORD *)(a2 + v9 - 120);
      uint64_t v13 = (void *)(a6 + v9 - 72);
      *(void *)(v10 - 104) = v13;
      uint64_t v15 = *(void *)(a2 + v9 - 104);
      uint64_t v14 = *(void *)(a2 + v9 - 96);
      if (v14 == v15)
      {
        *(void *)(v10 - 96) = v13;
        uint64_t v16 = *(unsigned int *)(v11 - 84);
        if (v16) {
          memmove(v13, *(const void **)(v11 - 96), 8 * v16);
        }
      }
      else
      {
        *(void *)(v10 - 96) = v14;
        *(void *)(v11 - 96) = v15;
      }
      uint64_t v17 = a2 + v9;
      uint64_t v18 = a6 + v9;
      *(void *)(v18 - 88) = *(void *)(a2 + v9 - 88);
      *(_DWORD *)(v18 - 80) = *(_DWORD *)(a2 + v9 - 80);
      *(void *)(v17 - 88) = 2;
      *(_DWORD *)(v17 - 80) = 0;
      uint64_t v19 = (void *)(a6 + v9 - 24);
      *(void *)(v18 - 56) = v19;
      uint64_t v21 = *(void *)(a2 + v9 - 56);
      uint64_t v20 = *(void *)(a2 + v9 - 48);
      if (v20 == v21)
      {
        *(void *)(v18 - 48) = v19;
        uint64_t v22 = *(unsigned int *)(v17 - 36);
        if (v22) {
          memmove(v19, *(const void **)(v17 - 48), 8 * v22);
        }
      }
      else
      {
        *(void *)(v18 - 48) = v20;
        *(void *)(v17 - 48) = v21;
      }
      uint64_t v23 = a2 + v9;
      uint64_t v24 = a6 + v9;
      *(void *)(v24 - 40) = *(void *)(a2 + v9 - 40);
      *(_DWORD *)(v24 - 32) = *(_DWORD *)(a2 + v9 - 32);
      *(void *)(v23 - 40) = 2;
      *(_DWORD *)(v23 - 32) = 0;
      *(unsigned char *)(v24 - 8) = *(unsigned char *)(a2 + v9 - 8);
      v9 -= 136;
    }
    while (a2 + v9 != a4);
    a6 += v9;
  }
  return a6;
}

void sub_1CCC1090C(uint64_t *a1, uint64_t a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = a1[2];
  if (v5 >= v4)
  {
    uint64_t v16 = *a1;
    unint64_t v17 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v5 - *a1) >> 3);
    unint64_t v18 = v17 + 1;
    if (v17 + 1 > 0x1E1E1E1E1E1E1E1) {
      abort();
    }
    unint64_t v19 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(v4 - v16) >> 3);
    if (2 * v19 > v18) {
      unint64_t v18 = 2 * v19;
    }
    if (v19 >= 0xF0F0F0F0F0F0F0) {
      unint64_t v20 = 0x1E1E1E1E1E1E1E1;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20 > 0x1E1E1E1E1E1E1E1) {
      sub_1CB833614();
    }
    uint64_t v21 = 17 * v20;
    uint64_t v22 = operator new(136 * v20);
    uint64_t v23 = (uint64_t)&v22[136 * v17];
    *(void *)uint64_t v23 = *(void *)a2;
    *(_WORD *)(v23 + 8) = *(_WORD *)(a2 + 8);
    *(unsigned char *)(v23 + 10) = *(unsigned char *)(a2 + 10);
    *(_OWORD *)(v23 + 16) = *(_OWORD *)(a2 + 16);
    uint64_t v24 = (void *)(v23 + 64);
    *(void *)(v23 + 32) = v23 + 64;
    uint64_t v26 = *(const void **)(a2 + 32);
    uint64_t v25 = *(const void **)(a2 + 40);
    if (v25 == v26)
    {
      *(void *)(v23 + 40) = v24;
      uint64_t v27 = *(unsigned int *)(a2 + 52);
      if (v27) {
        memmove(v24, v25, 8 * v27);
      }
    }
    else
    {
      *(void *)(v23 + 40) = v25;
      *(void *)(a2 + 40) = v26;
      LODWORD(v27) = *(_DWORD *)(a2 + 52);
    }
    uint64_t v28 = &v22[8 * v21];
    *(_DWORD *)(v23 + 48) = *(_DWORD *)(a2 + 48);
    *(_DWORD *)(v23 + 52) = v27;
    *(_DWORD *)(v23 + 56) = *(_DWORD *)(a2 + 56);
    *(void *)(a2 + 48) = 2;
    *(_DWORD *)(a2 + 56) = 0;
    unsigned int v29 = &v22[136 * v17];
    unsigned int v30 = v29 + 112;
    *((void *)v29 + 10) = v29 + 112;
    unsigned int v31 = v29 + 80;
    uint64_t v33 = *(const void **)(a2 + 80);
    int v32 = *(const void **)(a2 + 88);
    if (v32 == v33)
    {
      *((void *)v31 + 1) = v30;
      uint64_t v34 = *(unsigned int *)(a2 + 100);
      if (v34) {
        memmove(v30, v32, 8 * v34);
      }
    }
    else
    {
      *((void *)v31 + 1) = v32;
      *(void *)(a2 + 88) = v33;
      LODWORD(v34) = *(_DWORD *)(a2 + 100);
    }
    *((_DWORD *)v31 + 4) = *(_DWORD *)(a2 + 96);
    *((_DWORD *)v31 + 5) = v34;
    *((_DWORD *)v31 + 6) = *(_DWORD *)(a2 + 104);
    *(void *)(a2 + 96) = 2;
    *(_DWORD *)(a2 + 104) = 0;
    v22[136 * v17 + 128] = *(unsigned char *)(a2 + 128);
    uint64_t v15 = v23 + 136;
    uint64_t v35 = sub_1CCC107C4(v5, v5, v16, v16, v23, v23);
    size_t v37 = (char *)*a1;
    size_t v36 = (char *)a1[1];
    *a1 = v35;
    a1[1] = v23 + 136;
    a1[2] = (uint64_t)v28;
    if (v36 != v37)
    {
      do
      {
        unsigned int v38 = v36 - 136;
        sub_1CD6C05EC((void *)v36 - 15);
        size_t v36 = v38;
      }
      while (v38 != v37);
    }
    if (v37) {
      operator delete(v37);
    }
  }
  else
  {
    *(void *)unint64_t v5 = *(void *)a2;
    __int16 v6 = *(_WORD *)(a2 + 8);
    *(unsigned char *)(v5 + 10) = *(unsigned char *)(a2 + 10);
    *(_WORD *)(v5 + 8) = v6;
    *(_OWORD *)(v5 + 16) = *(_OWORD *)(a2 + 16);
    uint64_t v7 = (void *)(v5 + 64);
    *(void *)(v5 + 32) = v5 + 64;
    uint64_t v9 = *(void *)(a2 + 32);
    uint64_t v8 = *(void *)(a2 + 40);
    if (v8 == v9)
    {
      *(void *)(v5 + 40) = v7;
      uint64_t v10 = *(unsigned int *)(a2 + 52);
      if (v10) {
        memmove(v7, *(const void **)(a2 + 40), 8 * v10);
      }
    }
    else
    {
      *(void *)(v5 + 40) = v8;
      *(void *)(a2 + 40) = v9;
    }
    *(void *)(v5 + 48) = *(void *)(a2 + 48);
    *(_DWORD *)(v5 + 56) = *(_DWORD *)(a2 + 56);
    *(void *)(a2 + 48) = 2;
    *(_DWORD *)(a2 + 56) = 0;
    uint64_t v11 = (void *)(v5 + 112);
    *(void *)(v5 + 80) = v5 + 112;
    uint64_t v13 = *(void *)(a2 + 80);
    uint64_t v12 = *(void *)(a2 + 88);
    if (v12 == v13)
    {
      *(void *)(v5 + 88) = v11;
      uint64_t v14 = *(unsigned int *)(a2 + 100);
      if (v14) {
        memmove(v11, *(const void **)(a2 + 88), 8 * v14);
      }
    }
    else
    {
      *(void *)(v5 + 88) = v12;
      *(void *)(a2 + 88) = v13;
    }
    *(void *)(v5 + 96) = *(void *)(a2 + 96);
    *(_DWORD *)(v5 + 104) = *(_DWORD *)(a2 + 104);
    *(void *)(a2 + 96) = 2;
    *(_DWORD *)(a2 + 104) = 0;
    *(unsigned char *)(v5 + 128) = *(unsigned char *)(a2 + 128);
    uint64_t v15 = v5 + 136;
  }
  a1[1] = v15;
}

void sub_1CCC10BFC(void **a1, uint64_t a2)
{
  unint64_t v5 = (char *)a1[1];
  unint64_t v4 = (char *)a1[2];
  if (v5 >= v4)
  {
    uint64_t v15 = (char *)*a1;
    uint64_t v16 = (v5 - (unsigned char *)*a1) >> 7;
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 57) {
      abort();
    }
    uint64_t v18 = v4 - v15;
    if (v18 >> 6 > v17) {
      unint64_t v17 = v18 >> 6;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFF80) {
      unint64_t v19 = 0x1FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v19 = v17;
    }
    if (v19 >> 57) {
      sub_1CB833614();
    }
    unint64_t v20 = operator new(v19 << 7);
    uint64_t v21 = &v20[128 * v16];
    *(void *)uint64_t v21 = *(void *)a2;
    *(_OWORD *)(v21 + 8) = *(_OWORD *)(a2 + 8);
    uint64_t v22 = v21 + 56;
    *((void *)v21 + 3) = v21 + 56;
    uint64_t v24 = *(const void **)(a2 + 24);
    uint64_t v23 = *(const void **)(a2 + 32);
    if (v23 == v24)
    {
      *((void *)v21 + 4) = v22;
      uint64_t v25 = *(unsigned int *)(a2 + 44);
      if (v25) {
        memmove(v22, v23, 8 * v25);
      }
    }
    else
    {
      *((void *)v21 + 4) = v23;
      *(void *)(a2 + 32) = v24;
      LODWORD(v25) = *(_DWORD *)(a2 + 44);
    }
    *((_DWORD *)v21 + 10) = *(_DWORD *)(a2 + 40);
    *((_DWORD *)v21 + 11) = v25;
    *((_DWORD *)v21 + 12) = *(_DWORD *)(a2 + 48);
    *(void *)(a2 + 40) = 2;
    *(_DWORD *)(a2 + 48) = 0;
    uint64_t v26 = &v20[128 * v16];
    uint64_t v27 = v26 + 104;
    *((void *)v26 + 9) = v26 + 104;
    uint64_t v28 = v26 + 72;
    unsigned int v30 = *(const void **)(a2 + 72);
    unsigned int v29 = *(const void **)(a2 + 80);
    if (v29 == v30)
    {
      *((void *)v28 + 1) = v27;
      uint64_t v31 = *(unsigned int *)(a2 + 92);
      if (v31) {
        memmove(v27, v29, 8 * v31);
      }
    }
    else
    {
      *((void *)v28 + 1) = v29;
      *(void *)(a2 + 80) = v30;
      LODWORD(v31) = *(_DWORD *)(a2 + 92);
    }
    int v32 = &v20[128 * v19];
    *((_DWORD *)v28 + 4) = *(_DWORD *)(a2 + 88);
    *((_DWORD *)v28 + 5) = v31;
    *((_DWORD *)v28 + 6) = *(_DWORD *)(a2 + 96);
    *(void *)(a2 + 88) = 2;
    *(_DWORD *)(a2 + 96) = 0;
    v20[128 * v16 + 120] = *(unsigned char *)(a2 + 120);
    uint64_t v14 = v21 + 128;
    if (v5 != v15)
    {
      uint64_t v33 = 0;
      do
      {
        uint64_t v34 = &v21[v33];
        uint64_t v35 = &v5[v33];
        *((void *)v34 - 16) = *(void *)&v5[v33 - 128];
        *(_OWORD *)(v34 - 120) = *(_OWORD *)&v5[v33 - 120];
        size_t v36 = &v21[v33 - 72];
        *((void *)v34 - 13) = v36;
        unsigned int v38 = *(const void **)&v5[v33 - 104];
        size_t v37 = *(const void **)&v5[v33 - 96];
        if (v37 == v38)
        {
          *((void *)v34 - 12) = v36;
          uint64_t v39 = *((unsigned int *)v35 - 21);
          if (v39) {
            memmove(v36, v37, 8 * v39);
          }
        }
        else
        {
          *((void *)v34 - 12) = v37;
          *((void *)v35 - 12) = v38;
          LODWORD(v39) = *((_DWORD *)v35 - 21);
        }
        unsigned int v40 = &v5[v33];
        unsigned int v41 = &v21[v33];
        *((_DWORD *)v41 - 22) = *(_DWORD *)&v5[v33 - 88];
        *((_DWORD *)v41 - 21) = v39;
        *((_DWORD *)v41 - 20) = *(_DWORD *)&v5[v33 - 80];
        *((void *)v40 - 11) = 2;
        *((_DWORD *)v40 - 20) = 0;
        int v42 = &v21[v33 - 24];
        *((void *)v41 - 7) = v42;
        uint64_t v44 = *(const void **)&v5[v33 - 56];
        uint64_t v43 = *(const void **)&v5[v33 - 48];
        if (v43 == v44)
        {
          *((void *)v41 - 6) = v42;
          uint64_t v45 = *((unsigned int *)v40 - 9);
          if (v45) {
            memmove(v42, v43, 8 * v45);
          }
        }
        else
        {
          *((void *)v41 - 6) = v43;
          *((void *)v40 - 6) = v44;
          LODWORD(v45) = *((_DWORD *)v40 - 9);
        }
        uint64_t v46 = &v5[v33];
        uint64_t v47 = &v21[v33];
        *((_DWORD *)v47 - 10) = *(_DWORD *)&v5[v33 - 40];
        *((_DWORD *)v47 - 9) = v45;
        *((_DWORD *)v47 - 8) = *(_DWORD *)&v5[v33 - 32];
        *((void *)v46 - 5) = 2;
        *((_DWORD *)v46 - 8) = 0;
        *(v47 - 8) = v5[v33 - 8];
        v33 -= 128;
      }
      while (&v5[v33] != v15);
      v21 += v33;
    }
    uint64_t v49 = (char *)*a1;
    uint64_t v48 = (char *)a1[1];
    *a1 = v21;
    a1[1] = v14;
    a1[2] = v32;
    if (v48 != v49)
    {
      do
      {
        uint64_t v50 = v48 - 128;
        sub_1CD6C05EC((void *)v48 - 15);
        uint64_t v48 = v50;
      }
      while (v50 != v49);
    }
    if (v49) {
      operator delete(v49);
    }
  }
  else
  {
    *(void *)unint64_t v5 = *(void *)a2;
    *(_OWORD *)(v5 + 8) = *(_OWORD *)(a2 + 8);
    __int16 v6 = v5 + 56;
    *((void *)v5 + 3) = v5 + 56;
    uint64_t v8 = *(void *)(a2 + 24);
    uint64_t v7 = *(void *)(a2 + 32);
    if (v7 == v8)
    {
      *((void *)v5 + 4) = v6;
      uint64_t v9 = *(unsigned int *)(a2 + 44);
      if (v9) {
        memmove(v6, *(const void **)(a2 + 32), 8 * v9);
      }
    }
    else
    {
      *((void *)v5 + 4) = v7;
      *(void *)(a2 + 32) = v8;
    }
    *((void *)v5 + 5) = *(void *)(a2 + 40);
    *((_DWORD *)v5 + 12) = *(_DWORD *)(a2 + 48);
    *(void *)(a2 + 40) = 2;
    *(_DWORD *)(a2 + 48) = 0;
    uint64_t v10 = v5 + 104;
    *((void *)v5 + 9) = v5 + 104;
    uint64_t v12 = *(void *)(a2 + 72);
    uint64_t v11 = *(void *)(a2 + 80);
    if (v11 == v12)
    {
      *((void *)v5 + 10) = v10;
      uint64_t v13 = *(unsigned int *)(a2 + 92);
      if (v13) {
        memmove(v10, *(const void **)(a2 + 80), 8 * v13);
      }
    }
    else
    {
      *((void *)v5 + 10) = v11;
      *(void *)(a2 + 80) = v12;
    }
    *((void *)v5 + 11) = *(void *)(a2 + 88);
    *((_DWORD *)v5 + 24) = *(_DWORD *)(a2 + 96);
    *(void *)(a2 + 88) = 2;
    *(_DWORD *)(a2 + 96) = 0;
    v5[120] = *(unsigned char *)(a2 + 120);
    uint64_t v14 = v5 + 128;
  }
  a1[1] = v14;
}

void sub_1CCC10F78(void ***a1)
{
  unsigned int v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        __int16 v6 = v4 - 128;
        sub_1CD6C05EC((void *)v4 - 15);
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1CCC11000()
{
  int v4 = 1;
  *(void *)&long long v3 = "Maximum number of ptr states the optimizer keeps track of";
  *((void *)&v3 + 1) = 57;
  int v1 = 4095;
  uint64_t v2 = &v1;
  sub_1CD413D64((uint64_t)&unk_1EBCEF230, "arc-opt-max-ptr-states", &v4, &v3, &v2);
  return __cxa_atexit((void (*)(void *))sub_1CB8598A4, &unk_1EBCEF230, &dword_1CB82C000);
}

void llvm::initializeObjCARCExpandPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCEF308, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CCC11100;
    v4[1] = &v2;
    long long v3 = v4;
    std::__call_once(&qword_1EBCEF308, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CCC11100()
{
}

uint64_t sub_1CCC1119C(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCEF300;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F2632338;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCEF308, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCC11100;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCEF308, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCC1124C(uint64_t a1)
{
  if (llvm::objcarc::EnableARCOpts && sub_1CD6C1340(*(void *)(a1 + 40)))
  {
    uint64_t v5 = a1 + 72;
    for (uint64_t i = *(void *)(a1 + 80); i != v5; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v7 = i - 24;
      if (!i) {
        uint64_t v7 = 0;
      }
      uint64_t v8 = *(void *)(v7 + 48);
      if (v8 != v7 + 40)
      {
        char v1 = 0;
        while (1)
        {
          if (v8) {
            uint64_t v9 = (llvm::ValueAsMetadata *)(v8 - 24);
          }
          else {
            uint64_t v9 = 0;
          }
          unsigned int v10 = sub_1CD4B36C8((uint64_t)v9, v4);
          if (v10 <= 0xB && ((1 << v10) & 0xC63) != 0)
          {
            char v1 = 1;
            llvm::Value::doRAUW(v9, *((llvm::Value **)v9 - 4 * (*((_DWORD *)v9 + 5) & 0x7FFFFFF)), (llvm::Value *)1);
          }
          uint64_t v8 = *(void *)(v8 + 8);
          uint64_t v12 = i - 24;
          if (!i) {
            uint64_t v12 = 0;
          }
          if (v8 == v12 + 40) {
            break;
          }
LABEL_27:
          if (i == v5) {
            return v1 & 1;
          }
        }
        while (1)
        {
          uint64_t i = *(void *)(i + 8);
          if (i == v5) {
            return v1 & 1;
          }
          uint64_t v13 = i - 24;
          if (!i) {
            uint64_t v13 = 0;
          }
          uint64_t v8 = *(void *)(v13 + 48);
          if (v8 != v13 + 40) {
            goto LABEL_27;
          }
        }
      }
    }
  }
  char v1 = 0;
  return v1 & 1;
}

void sub_1CCC11380()
{
}

void sub_1CCC113C0(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCC113F8(llvm::PassRegistry *a1, uint64_t a2)
{
  v3[0] = &unk_1F2617E40;
  v3[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v3);
}

uint64_t sub_1CCC11444(uint64_t a1, uint64_t a2)
{
  return sub_1CCC1124C(a2);
}

void llvm::initializeObjCARCAPElimPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCEF318, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CCC114BC;
    v4[1] = &v2;
    long long v3 = v4;
    std::__call_once(&qword_1EBCEF318, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CCC114BC()
{
}

uint64_t sub_1CCC11558(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCEF310;
  *(_DWORD *)(a1 + 24) = 4;
  *(void *)a1 = &unk_1F26323D8;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCEF318, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCC114BC;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCEF318, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CCC11608(uint64_t a1)
{
  if (llvm::objcarc::EnableARCOpts && sub_1CD6C1340(a1))
  {
    long long v3 = *(uint64_t **)(a1 + 112);
    unsigned int v4 = *((_DWORD *)v3 + 8);
    uint64_t v5 = v4 <= 1 ? 1 : v4;
    size_t v6 = v4 <= 0x10 ? v5 : 17;
    uint64_t v7 = *((unsigned int *)v3 + 2);
    if (v7)
    {
      uint64_t v8 = 0;
      int v9 = 0;
      do
        int v9 = 33 * v9 + aLlvmGlobalCtor[v8++];
      while (v6 != v8);
      uint64_t v10 = *v3;
      uint64_t v11 = *v3 + 8 * v7 + 8;
      int v12 = 1;
      int v13 = v9;
      while (1)
      {
        uint64_t v14 = v13 & (v7 - 1);
        uint64_t v15 = *(void **)(v10 + 8 * v14);
        if (v15 != (void *)-8)
        {
          if (!v15) {
            return 0;
          }
          if (*(_DWORD *)(v11 + 4 * v14) == v9
            && v6 == *v15
            && !memcmp("llvm.global_ctors", (char *)v15 + *((unsigned int *)v3 + 5), v6))
          {
            break;
          }
        }
        int v13 = v12 + v14;
        ++v12;
      }
      if (v14 != -1 && (int)v14 != v7)
      {
        uint64_t v17 = *(void *)(*(void *)(v10 + 8 * (int)v14) + 8);
        if (v17)
        {
          if (*(unsigned char *)(v17 + 16) == 3 && (*(_DWORD *)(v17 + 32) & 0xFu) - 7 >= 2)
          {
            uint64_t v18 = *(void *)(v17 - 32);
            uint64_t v19 = *(_DWORD *)(v18 + 20) & 0x7FFFFFF;
            if (v19)
            {
              uint64_t v20 = v18 - 32 * v19;
              do
              {
                uint64_t v21 = *(void *)(*(void *)v20 - 32 * (*(_DWORD *)(*(void *)v20 + 20) & 0x7FFFFFF) + 32);
                if (v21) {
                  BOOL v22 = *(unsigned char *)(v21 + 16) == 0;
                }
                else {
                  BOOL v22 = 0;
                }
                if (v22)
                {
                  uint64_t v23 = v21 + 72;
                  if (*(void *)(v21 + 72) != v21 + 72 || (*(unsigned char *)(v21 + 34) & 0x80) != 0)
                  {
                    uint64_t v24 = *(void *)(v21 + 80);
                    if (*(void *)(v24 + 8) == v23)
                    {
                      uint64_t v25 = *(void *)(v24 + 24);
                      uint64_t v26 = v24 + 16;
                      if (v25 != v24 + 16)
                      {
                        uint64_t v27 = 0;
                        do
                        {
                          uint64_t v28 = v25 - 24;
                          BOOL v22 = v25 == 0;
                          uint64_t v25 = *(void *)(v25 + 8);
                          if (v22) {
                            uint64_t v29 = 0;
                          }
                          else {
                            uint64_t v29 = v28;
                          }
                          int v30 = sub_1CD4B36C8(v29, v16);
                          switch(v30)
                          {
                            case 21:
                              if (sub_1CCC119E0(v29, 0)) {
                                uint64_t v27 = 0;
                              }
                              break;
                            case 8:
                              if (v27)
                              {
                                if (*(void *)(v29 - 32 * (*(_DWORD *)(v29 + 20) & 0x7FFFFFF)) == v27) {
                                  llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
                                }
                                uint64_t v27 = 0;
                              }
                              break;
                            case 7:
                              uint64_t v27 = v29;
                              break;
                          }
                        }
                        while (v25 != v26);
                      }
                    }
                  }
                }
                v20 += 32;
              }
              while (v20 != v18);
            }
          }
        }
      }
    }
  }
  return 0;
}

void sub_1CCC118D0()
{
}

void sub_1CCC11910(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCC11948(llvm::PassRegistry *a1, uint64_t a2)
{
  v3[0] = &unk_1F2617E40;
  v3[1] = a2 + 112;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(a1);
  llvm::PassRegistry::enumerateWith(PassRegistry, (uint64_t)v3);
}

uint64_t sub_1CCC11994(llvm::ModulePass *a1, llvm::LLVMContextImpl ***a2)
{
  if (llvm::ModulePass::skipModule(a1, a2)) {
    return 0;
  }

  return sub_1CCC11608((uint64_t)a2);
}

uint64_t sub_1CCC119E0(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(void *)(a1 - 32);
  if (v3)
  {
    if (!*(unsigned char *)(v3 + 16))
    {
      uint64_t v2 = *(void *)(a1 + 72);
      if (*(void *)(v3 + 24) == v2)
      {
        uint64_t v6 = v3 + 72;
        int v7 = *(_DWORD *)(v3 + 32);
        if (*(void *)(v3 + 72) == v3 + 72 && (v7 & 0x800000) == 0) {
          goto LABEL_12;
        }
        char v9 = v7 & 0xF;
        LODWORD(v2) = 1;
        int v4 = 0;
        if (((1 << v9) & 0x7D5) == 0) {
          return (v4 | v2) & 1;
        }
        if (llvm::GlobalValue::isInterposable(*(llvm::GlobalValue **)(a1 - 32)))
        {
LABEL_12:
          int v4 = 0;
          LODWORD(v2) = 1;
          return (v4 | v2) & 1;
        }
        uint64_t v11 = *(void *)(v3 + 80);
        if (v11 == v6)
        {
          int v4 = 0;
          LODWORD(v2) = 0;
          return (v4 | v2) & 1;
        }
LABEL_14:
        uint64_t v12 = v11 - 24;
        if (!v11) {
          uint64_t v12 = 0;
        }
        uint64_t v13 = v12 + 40;
        for (uint64_t i = *(void *)(v12 + 48); ; uint64_t i = *(void *)(i + 8))
        {
          if (i == v13)
          {
            int v4 = 0;
            LODWORD(v2) = 0;
            uint64_t v11 = *(void *)(v11 + 8);
            if (v11 == v6) {
              return (v4 | v2) & 1;
            }
            goto LABEL_14;
          }
          if (i) {
            uint64_t v15 = i - 24;
          }
          else {
            uint64_t v15 = 0;
          }
          unsigned int v16 = *(unsigned __int8 *)(v15 + 16) - 33;
          BOOL v19 = v16 > 0x33;
          uint64_t v17 = (1 << v16) & 0x8000000000041;
          BOOL v19 = v19 || v17 == 0 || a2 > 2;
          if (!v19)
          {
            uint64_t v20 = *(void *)(i + 40);
            if (!v20 || (*(unsigned char *)(v20 + 17) & 0x30) == 0)
            {
              int v21 = *(_DWORD *)(i - 4);
              if (v21 < 0
                && (uint64_t v22 = i - 24 - 32 * (v21 & 0x7FFFFFF), v25 = *(void *)(v22 - 8), v23 = v22 - 8, (v24 = v25) != 0))
              {
                uint64_t v26 = -v24;
                while (1)
                {
                  unsigned int v27 = *(_DWORD *)(*(void *)(v23 + v26) + 8);
                  BOOL v19 = v27 > 7;
                  int v28 = (1 << v27) & 0x83;
                  if (v19 || v28 == 0) {
                    break;
                  }
                  v26 += 16;
                  if (!v26) {
                    goto LABEL_31;
                  }
                }
              }
              else
              {
LABEL_31:
                if ((llvm::CallBase::hasFnAttrOnCalledFunction(i - 24, 45) & 1) != 0
                  || (llvm::CallBase::hasFnAttrOnCalledFunction(i - 24, 44) & 1) != 0)
                {
                  continue;
                }
              }
              if (sub_1CCC119E0(i - 24, a2 + 1)) {
                goto LABEL_12;
              }
            }
          }
        }
      }
    }
  }
  int v4 = 1;
  return (v4 | v2) & 1;
}

void llvm::initializeObjCARCContractLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCEF3E8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CCC11C28;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCEF3E8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CCC11C28(llvm *a1, llvm::PassRegistry *a2)
{
}

uint64_t sub_1CCC11CD0(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = &unk_1EBCEF3E0;
  *(_DWORD *)(a1 + 24) = 2;
  *(void *)a1 = &unk_1F2632478;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)a1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCEF3E8, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CCC11C28;
    v5[1] = &PassRegistry;
    int v4 = v5;
    std::__call_once(&qword_1EBCEF3E8, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CCC11D80(uint64_t a1, llvm::Module *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 80) = a2;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0u;
  *(void *)(a1 + 168) = 0;
  if (dword_1EBCEF3A0)
  {
    BOOL v4 = dword_1EBCEF3A0 == 1;
  }
  else
  {
    __int16 v14 = 260;
    uint64_t v13 = (char *)a2 + 216;
    llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)&v13);
    if ((v18 - 3) > 2)
    {
      BOOL v4 = 0;
    }
    else
    {
      unsigned int OSVersion = llvm::Triple::getOSVersion((llvm::Triple *)&__p);
      BOOL v4 = 0;
      switch(v19)
      {
        case 28:
          goto LABEL_8;
        case 29:
          BOOL v6 = OSVersion > 8;
          goto LABEL_10;
        case 30:
          BOOL v6 = OSVersion > 6;
          goto LABEL_10;
        case 31:
        case 32:
          break;
        case 33:
          BOOL v4 = 1;
          break;
        default:
          if (v19 != 7) {
            break;
          }
LABEL_8:
          BOOL v6 = OSVersion > 0xF;
LABEL_10:
          BOOL v4 = v6;
          break;
      }
    }
    if ((v17[7] & 0x80000000) != 0) {
      operator delete(__p);
    }
  }
  *(unsigned char *)(a1 + 184) = v4;
  __p = v17;
  uint64_t v16 = 0x800000000;
  llvm::Module::getModuleFlagsMetadata(a2, (uint64_t)&__p);
  int v7 = __p;
  if (v16)
  {
    uint64_t v8 = (unsigned char **)((char *)__p + 16);
    uint64_t v9 = 24 * v16;
    while (1)
    {
      uint64_t v10 = (void *)*((void *)*(v8 - 1) + 1);
      if (*v10 == 45 && !memcmp("clang.arc.retainAutoreleasedReturnValueMarker", v10 + 3, 0x2DuLL)) {
        break;
      }
      v8 += 3;
      v9 -= 24;
      if (!v9) {
        goto LABEL_23;
      }
    }
    uint64_t v11 = *v8;
  }
  else
  {
LABEL_23:
    uint64_t v11 = 0;
  }
  if (v7 == v17)
  {
    if (v11) {
      goto LABEL_26;
    }
LABEL_30:
    uint64_t v12 = 0;
    goto LABEL_31;
  }
  free(v7);
  if (!v11) {
    goto LABEL_30;
  }
LABEL_26:
  if (*v11) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v11;
  }
LABEL_31:
  *(void *)(a1 + 192) = v12;
}

BOOL sub_1CCC11FA4(uint64_t a1, uint64_t a2, uint64_t a3, llvm::DominatorTree *a4)
{
  uint64_t v226 = *MEMORY[0x1E4F143B8];
  if (!llvm::objcarc::EnableARCOpts) {
    return 0;
  }
  uint64_t v7 = a1;
  *(_WORD *)a1 = 0;
  *(void *)(a1 + 24) = a3;
  v199 = (uint64_t *)(a1 + 24);
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  uint64_t v8 = a1 + 80;
  char v9 = *(unsigned char *)(a1 + 184);
  v204[0] = 0;
  v204[1] = 0;
  int v205 = 0;
  uint64_t v206 = a1 + 80;
  char v207 = 1;
  char v208 = v9;
  *(void *)(a1 + 176) = v204;
  __int16 v10 = llvm::objcarc::BundledRetainClaimRVs::insertAfterInvokes((llvm::objcarc::BundledRetainClaimRVs *)v204, (llvm::Function *)a2, a4);
  *(unsigned char *)v7 |= v10 & 1;
  *(unsigned char *)(v7 + 1) |= HIBYTE(v10) & 1;
  v202[0] = 0;
  v202[1] = 0;
  int v203 = 0;
  if ((*(unsigned char *)(a2 + 18) & 8) != 0)
  {
    int v12 = *(_DWORD *)(a2 + 20);
    uint64_t v13 = (v12 & 0x40000000) != 0 ? *(llvm::Value ***)(a2 - 8) : (llvm::Value **)(a2 - 32 * (v12 & 0x7FFFFFF));
    unsigned int v14 = llvm::classifyEHPersonality(*v13, v11);
    if (v14 - 7 < 4 || v14 == 12)
    {
      llvm::colorEHFunclets((llvm *)a2, (uint64_t)&v215);
      sub_1CD4B08AC(v202, (uint64_t *)&v215);
      sub_1CC0CADD4((uint64_t *)&v215);
    }
  }
  if (*(_DWORD *)(*(void *)(a2 + 24) + 8) <= 0xFFu) {
    int v200 = llvm::Function::callsFunctionThatReturnsTwice((llvm::Function *)a2) ^ 1;
  }
  else {
    int v200 = 0;
  }
  uint64_t v15 = (void *)(a2 + 72);
  for (uint64_t i = *(void **)(a2 + 80); ; uint64_t i = (void *)i[1])
  {
    if (i == v15) {
      goto LABEL_382;
    }
    uint64_t v17 = i - 3;
    if (!i) {
      uint64_t v17 = 0;
    }
    int v18 = (void *)v17[6];
    if (v18 != v17 + 5) {
      break;
    }
  }
  uint64_t v195 = (llvm::SmallPtrSetImplBase *)(v7 + 200);
  uint64_t v196 = v8;
  uint64_t v201 = v7;
  while (2)
  {
    int v19 = (void *)v18[1];
    uint64_t v20 = i - 3;
    if (!i) {
      uint64_t v20 = 0;
    }
    if (v19 == v20 + 5)
    {
      int v21 = (void *)i[1];
      uint64_t i = v15;
      if (v21 != v15)
      {
        while (1)
        {
          uint64_t v22 = v21 - 3;
          if (!v21) {
            uint64_t v22 = 0;
          }
          int v19 = (void *)v22[6];
          if (v19 != v22 + 5) {
            break;
          }
          int v21 = (void *)v21[1];
          if (v21 == v15)
          {
            uint64_t i = v15;
            goto LABEL_31;
          }
        }
        uint64_t i = v21;
      }
    }
LABEL_31:
    if (v18) {
      uint64_t v23 = (uint64_t)(v18 - 3);
    }
    else {
      uint64_t v23 = 0;
    }
    int v24 = *(unsigned __int8 *)(v23 + 16);
    if (v24 == 84) {
      uint64_t v25 = v23;
    }
    else {
      uint64_t v25 = 0;
    }
    if (v18)
    {
      if (v24 == 84 && *(unsigned char *)(**(void **)(*(void *)(v25 + 72) + 16) + 8) != 7)
      {
        sub_1CC233A58((char *)v25, 6, (uint64_t *)&v215);
        if (v217[8])
        {
          if (v19) {
            uint64_t v26 = (uint64_t **)(v19 - 3);
          }
          else {
            uint64_t v26 = 0;
          }
          llvm::objcarc::BundledRetainClaimRVs::insertRVCallWithColors(*(void *)(v7 + 176), v26, (char *)v25, (uint64_t)v202);
          while (1)
          {
            if (i != v15)
            {
              unsigned int v27 = i - 3;
              if (!i) {
                unsigned int v27 = 0;
              }
              if (v19 != (void *)v27[6]) {
                break;
              }
            }
            uint64_t i = (void *)*i;
            int v28 = i - 3;
            if (!i) {
              int v28 = 0;
            }
            int v19 = v28 + 5;
          }
          int v19 = (void *)*v19;
          *(unsigned char *)uint64_t v7 = 1;
        }
      }
    }
    int v29 = sub_1CD4B36C8(v23, v11);
    switch(v29)
    {
      case 0:
        uint64_t v71 = sub_1CD4B3548(*(llvm::Value **)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF)));
        unsigned int v72 = *((unsigned __int8 *)v71 + 16);
        if (v72 < 0x1C) {
          goto LABEL_180;
        }
        unsigned int v73 = v72 - 33;
        BOOL v45 = v73 > 0x33;
        uint64_t v74 = (1 << v73) & 0x8000000000041;
        BOOL v75 = v45 || v74 == 0;
        if (v75 || *((void *)v71 + 5) != *(void *)(v23 + 40)) {
          goto LABEL_180;
        }
        for (j = (uint64_t *)((char *)v71 + 32); ; j = (uint64_t *)(v77 + 8))
        {
          uint64_t v77 = *j;
          uint64_t v78 = *j - 24;
          unsigned int v79 = v77 ? (unsigned __int8 *)v78 : 0;
          int v80 = v79[16];
          if (v80 != 77
            && (v80 != 62 || !llvm::GetElementPtrInst::hasAllZeroIndices((llvm::GetElementPtrInst *)v79)))
          {
            break;
          }
        }
        if (v79 != (unsigned __int8 *)v23) {
          goto LABEL_180;
        }
        *(unsigned char *)uint64_t v7 = 1;
        uint64_t v85 = *(void *)(v7 + 136);
        if (!v85)
        {
          uint64_t v86 = *(uint64_t ***)(v7 + 80);
          llvm::Intrinsic::getType(*v86, 226, 0, 0);
          Type = (llvm::PointerType *)llvm::Intrinsic::getType(*v86, 226, 0, 0);
          llvm::Module::getOrInsertFunction((uint64_t)v86, "llvm.objc.retainAutoreleasedReturnValue", (const char *)0x27, Type, 0);
          *(void *)(v7 + 136) = v85;
        }
        sub_1CC1DDE04(v23, v85);
        if (!v18) {
          goto LABEL_57;
        }
LABEL_55:
        if (*(unsigned char *)(v23 + 16) == 84)
        {
          int v30 = *(uint64_t **)(v7 + 176);
          v215 = (void *)v23;
          v211[0] = 0;
          if (sub_1CD3C8538(v30, &v215, v211)) {
            goto LABEL_254;
          }
        }
LABEL_57:
        if (!*(void *)(v7 + 192)) {
          goto LABEL_180;
        }
        uint64_t v31 = (void *)(v23 + 24);
        int v32 = *(llvm::BasicBlock **)(v23 + 40);
        uint64_t v33 = (void *)*((void *)v32 + 6);
        while (v31 != v33)
        {
          uint64_t v31 = (void *)*v31;
          if (v31) {
            uint64_t v34 = (unsigned __int8 *)(v31 - 3);
          }
          else {
            uint64_t v34 = 0;
          }
          int v35 = v34[16];
          if (v35 == 62)
          {
            if ((llvm::GetElementPtrInst::hasAllZeroIndices((llvm::GetElementPtrInst *)v34) & 1) == 0)
            {
LABEL_67:
              uint64_t v7 = v201;
              goto LABEL_173;
            }
          }
          else if (v35 != 77)
          {
            goto LABEL_67;
          }
        }
        uint64_t SinglePredecessor = llvm::BasicBlock::getSinglePredecessor(v32);
        uint64_t v7 = v201;
        if (!SinglePredecessor) {
          goto LABEL_180;
        }
        uint64_t v83 = *(void *)(SinglePredecessor + 40);
        if (v83 == SinglePredecessor + 40)
        {
          uint64_t v84 = 0;
        }
        else
        {
          if (v83) {
            uint64_t v84 = v83 - 24;
          }
          else {
            uint64_t v84 = 0;
          }
          if (*(unsigned __int8 *)(v84 + 16) - 29 >= 0xB) {
            uint64_t v84 = 0;
          }
        }
        uint64_t v31 = (void *)(v84 + 24);
LABEL_173:
        if (v31) {
          uint64_t v88 = (llvm::Value *)(v31 - 3);
        }
        else {
          uint64_t v88 = 0;
        }
        uint64_t v89 = sub_1CD4B3548(v88);
        if (v89 == sub_1CD4B3548(*(llvm::Value **)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF))))
        {
          *(unsigned char *)uint64_t v7 = 1;
          unsigned int v90 = (llvm::PointerType *)llvm::FunctionType::get((uint64_t **)(***(void ***)v23 + 1576), 0, 0, 0);
          uint64_t v91 = llvm::InlineAsm::get(v90, *(void *)(*(void *)(v7 + 192) + 8) + 24, **(void **)(*(void *)(v7 + 192) + 8), (uint64_t)"", 0, 1, 0, 0, 0);
          uint64_t v92 = 0;
          if (v91) {
            uint64_t v92 = *(uint64_t ***)(v91 + 72);
          }
          __int16 v218 = 257;
          llvm::objcarc::createCallInstWithColors(v92, (uint64_t **)v91, 0, 0, (const char **)&v215, v23, (uint64_t)v202);
        }
LABEL_180:
        v211[0] = (llvm::Value *)v23;
        v211[1] = (llvm::Value *)v7;
        uint64_t v93 = *(void *)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF));
        uint64_t v94 = v93;
        while (2)
        {
          sub_1CCC13978((llvm::BitCastInst *)v211, v94);
          int v95 = *(unsigned __int8 *)(v94 + 16);
          if (v94 && v95 == 77) {
            goto LABEL_192;
          }
          if (v95 == 62) {
            goto LABEL_186;
          }
          if (v95 != 5) {
            goto LABEL_190;
          }
          if (*(_WORD *)(v94 + 18) != 34) {
            goto LABEL_232;
          }
LABEL_186:
          if (sub_1CC543B10(v94))
          {
            int v96 = *(_DWORD *)(v94 + 20);
            if ((v96 & 0x40000000) != 0) {
              uint64_t v97 = *(uint64_t **)(v94 - 8);
            }
            else {
              uint64_t v97 = (uint64_t *)(v94 - 32 * (v96 & 0x7FFFFFF));
            }
            goto LABEL_193;
          }
          int v95 = *(unsigned __int8 *)(v94 + 16);
LABEL_190:
          if (v95 != 1) {
            goto LABEL_196;
          }
          if (!llvm::GlobalValue::isInterposable((llvm::GlobalValue *)v94))
          {
LABEL_192:
            uint64_t v97 = (uint64_t *)(v94 - 32);
LABEL_193:
            uint64_t v94 = *v97;
            continue;
          }
          break;
        }
        int v95 = *(unsigned __int8 *)(v94 + 16);
LABEL_196:
        if (v94)
        {
          if (v95 == 83)
          {
            v215 = v217;
            uint64_t v216 = 0x100000000;
            if (*(void *)(*(void *)(v94 + 40) + 40) != *(void *)(v94 + 40) + 40)
            {
              uint64_t v98 = *(void *)(*(void *)(v94 + 40) + 48);
              uint64_t v99 = v98 - 24;
              uint64_t v100 = v98 ? v98 - 24 : 0;
              if (v98 && *(unsigned char *)(v100 + 16) == 83)
              {
                uint64_t v198 = v93;
                do
                {
                  if (v99 != v94)
                  {
                    int v101 = *(_DWORD *)(v94 + 20);
                    uint64_t v102 = v101 & 0x7FFFFFF;
                    if ((v101 & 0x7FFFFFF) != 0)
                    {
                      uint64_t v103 = 0;
                      uint64_t v104 = 0;
                      while (1)
                      {
                        int v105 = *(_DWORD *)(v94 + 20);
                        uint64_t v106 = (v105 & 0x40000000) != 0 ? *(void *)(v94 - 8) : v94 - 32 * (v105 & 0x7FFFFFF);
                        uint64_t v107 = *(void *)(v106 + 32 * *(unsigned int *)(v94 + 60) + 8 * v104);
                        uint64_t v108 = llvm::Value::stripPointerCasts(*(llvm::Value **)(v106 + v103));
                        char v109 = (llvm::Value *)sub_1CBF73380(v99, v107);
                        if (v108 != llvm::Value::stripPointerCasts(v109)) {
                          break;
                        }
                        ++v104;
                        v103 += 32;
                        if (v102 == v104) {
                          goto LABEL_216;
                        }
                      }
                    }
                    else
                    {
                      LODWORD(v104) = 0;
                    }
                    if (v104 == v102)
                    {
LABEL_216:
                      if (v216 >= (unint64_t)HIDWORD(v216)) {
                        llvm::SmallVectorBase<unsigned int>::grow_pod();
                      }
                      *((void *)v215 + v216) = v99;
                      LODWORD(v216) = v216 + 1;
                    }
                  }
                  uint64_t v110 = *(void *)(v99 + 32);
                  uint64_t v99 = v110 - 24;
                  if (v110) {
                    uint64_t v111 = v110 - 24;
                  }
                  else {
                    uint64_t v111 = 0;
                  }
                }
                while (v110 && *(unsigned char *)(v111 + 16) == 83);
                uint64_t v112 = (uint64_t *)v215;
                if (v216)
                {
                  uint64_t v113 = 8 * v216;
                  uint64_t v93 = v198;
                  do
                  {
                    uint64_t v114 = *v112++;
                    sub_1CCC13978((llvm::BitCastInst *)v211, v114);
                    v113 -= 8;
                  }
                  while (v113);
                  uint64_t v112 = (uint64_t *)v215;
                }
                else
                {
                  uint64_t v93 = v198;
                }
                if (v112 != (uint64_t *)v217) {
                  free(v112);
                }
              }
            }
          }
        }
LABEL_232:
        v215 = v217;
        uint64_t v216 = 0x200000000;
        uint64_t v115 = *(void *)(v93 + 8);
        if (v115)
        {
          unsigned int v116 = 0;
          do
          {
            uint64_t v117 = *(void *)(v115 + 24);
            if (v117 && *(unsigned char *)(v117 + 16) == 77)
            {
              if (v116 >= HIDWORD(v216)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v215 + v116) = v117;
              unsigned int v116 = v216 + 1;
              LODWORD(v216) = v216 + 1;
            }
            uint64_t v115 = *(void *)(v115 + 8);
          }
          while (v115);
          while (v116)
          {
            uint64_t v118 = *((void *)v215 + v116 - 1);
            unsigned int v119 = v116 - 1;
            LODWORD(v216) = v119;
            for (uint64_t k = *(void *)(v118 + 8); k; uint64_t k = *(void *)(k + 8))
            {
              uint64_t v121 = *(void *)(k + 24);
              if (v121 && *(unsigned char *)(v121 + 16) == 77)
              {
                if (v119 >= HIDWORD(v216)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v215 + v119) = v121;
                unsigned int v119 = v216 + 1;
                LODWORD(v216) = v216 + 1;
              }
            }
            sub_1CCC13978((llvm::BitCastInst *)v211, v118);
            unsigned int v116 = v216;
          }
        }
        if (v215 != v217) {
          free(v215);
        }
LABEL_253:
        uint64_t v7 = v201;
LABEL_254:
        int v18 = v19;
        if (i != v15) {
          continue;
        }
LABEL_382:
        if ((_BYTE)v200)
        {
          uint64_t v181 = *(char **)(v7 + 200);
          uint64_t v180 = *(char **)(v7 + 208);
          uint64_t v182 = 216;
          if (v180 == v181) {
            uint64_t v182 = 220;
          }
          uint64_t v183 = *(unsigned int *)(v7 + v182);
          int v184 = *(unint64_t **)(v7 + 208);
          if (v183)
          {
            uint64_t v185 = 0;
            while (*(void *)&v180[v185] >= 0xFFFFFFFFFFFFFFFELL)
            {
              v185 += 8;
              if (8 * v183 == v185) {
                goto LABEL_398;
              }
            }
            int v184 = (unint64_t *)&v180[v185];
          }
          v186 = (unint64_t *)&v180[8 * v183];
          if (v184 != v186)
          {
            unint64_t v187 = *v184;
LABEL_393:
            *(_WORD *)(v187 + 18) = *(_WORD *)(v187 + 18) & 0xFFFC | 1;
            uint64_t v188 = v184 + 1;
            while (v188 != v186)
            {
              unint64_t v189 = *v188++;
              unint64_t v187 = v189;
              if (v189 <= 0xFFFFFFFFFFFFFFFDLL)
              {
                int v184 = v188 - 1;
                goto LABEL_393;
              }
            }
          }
        }
        else
        {
          uint64_t v181 = *(char **)(v7 + 200);
          uint64_t v180 = *(char **)(v7 + 208);
        }
LABEL_398:
        if (v180 == v181)
        {
LABEL_399:
          *(_DWORD *)(v7 + 220) = 0;
          *(_DWORD *)(v7 + 224) = 0;
        }
        else
        {
          uint64_t v190 = *(unsigned int *)(v7 + 216);
          if (v190 < 0x21 || 4 * (*(_DWORD *)(v7 + 220) - *(_DWORD *)(v7 + 224)) >= v190)
          {
            memset(v180, 255, 8 * v190);
            goto LABEL_399;
          }
          llvm::SmallPtrSetImplBase::shrink_and_clear((void **)(v7 + 200));
        }
        BOOL v4 = *(unsigned char *)v7 != 0;
        sub_1CC0CADD4(v202);
        llvm::objcarc::BundledRetainClaimRVs::~BundledRetainClaimRVs(v204);
        return v4;
      case 1:
      case 2:
        if (v18) {
          goto LABEL_55;
        }
        goto LABEL_57;
      case 4:
        uint64_t v49 = sub_1CD4B3548(*(llvm::Value **)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF)));
        if (!v49) {
          goto LABEL_254;
        }
        uint64_t v50 = v49;
        if (*((unsigned char *)v49 + 16) != 60) {
          goto LABEL_254;
        }
        if ((*((_WORD *)v49 + 9) & 0x381) != 0) {
          goto LABEL_254;
        }
        uint64_t v51 = *(void *)(v23 + 40);
        if (*((void *)v49 + 5) != v51) {
          goto LABEL_254;
        }
        uint64_t v193 = *(llvm::Instruction **)(v7 + 8);
        uint64_t v52 = (llvm::Value *)*((void *)v49 - 4);
        uint64_t v53 = sub_1CB83544C(*(void *)(*(void *)(v51 + 56) + 40) + 272, *(void *)v49);
        unint64_t v55 = v54 == 1 ? -2 : (unint64_t)(v53 + 7) >> 3;
        llvm::Instruction::getAAMetadata((uint64_t ***)v50, v210);
        *(void *)&long long v209 = v52;
        *((void *)&v209 + 1) = v55;
        v192 = llvm::Value::stripPointerCasts(v52);
        uint64_t v56 = *((void *)v50 + 4);
        unsigned int v197 = v50;
        uint64_t v57 = *((void *)v50 + 5) + 40;
        if (v56 == v57) {
          goto LABEL_254;
        }
        char v58 = 0;
        unsigned int v59 = 0;
        break;
      case 5:
      case 6:
        size_t v36 = sub_1CD4B3548(*(llvm::Value **)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF)));
        if (v29 == 6) {
          int v37 = 4;
        }
        else {
          int v37 = 3;
        }
        uint64_t SingleDependency = llvm::objcarc::findSingleDependency(v37, v36, *(void *)(v23 + 40), v23, v199);
        if (!SingleDependency) {
          goto LABEL_180;
        }
        uint64_t v40 = SingleDependency;
        if (*(unsigned char *)(SingleDependency + 16) != 84
          || sub_1CD4B36C8(SingleDependency, v39)
          || sub_1CD4B3548(*(llvm::Value **)(v40 - 32 * (*(_DWORD *)(v40 + 20) & 0x7FFFFFF))) != v36)
        {
          goto LABEL_180;
        }
        *(unsigned char *)uint64_t v7 = 1;
        if (v29 == 6) {
          int v41 = 10;
        }
        else {
          int v41 = 9;
        }
        uint64_t v42 = sub_1CD6C17D0(v196, v41);
        sub_1CC1DDE04(v40, v42);
        uint64_t v43 = *(llvm::Type ***)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF));
        if (!*(void *)(v23 + 8)) {
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
        goto LABEL_85;
      case 10:
      case 11:
        goto LABEL_180;
      case 14:
        unsigned int v44 = *(unsigned __int8 *)(*(void *)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF) + 32) + 16);
        BOOL v45 = v44 > 0x13;
        int v46 = (1 << v44) & 0x81800;
        BOOL v47 = v45 || v46 == 0;
        if (v47) {
          goto LABEL_254;
        }
        uint64_t v43 = (llvm::Type **)llvm::ConstantPointerNull::get(*(llvm::ConstantPointerNull **)v23, v11);
        *(unsigned char *)uint64_t v7 = 1;
        uint64_t v48 = operator new(0x80uLL);
        v48[21] = v48[21] & 0x38000000 | 2;
        *(void *)uint64_t v48 = 0;
        *((void *)v48 + 1) = 0;
        *((void *)v48 + 2) = 0;
        *((void *)v48 + 3) = v48 + 16;
        *((void *)v48 + 4) = 0;
        *((void *)v48 + 5) = 0;
        *((void *)v48 + 6) = 0;
        *((void *)v48 + 7) = v48 + 16;
        llvm::StoreInst::StoreInst((llvm::StoreInst *)(v48 + 16), v43, *(llvm::Value **)(v23 - 32 * (*(_DWORD *)(v23 + 20) & 0x7FFFFFF)), 0, (llvm::Instruction *)v23);
LABEL_85:
        llvm::Value::doRAUW((llvm::ValueAsMetadata *)v23, (llvm::Value *)v43, (llvm::Value *)1);
        goto LABEL_158;
      case 20:
        goto LABEL_157;
      case 23:
        int v70 = v200;
        if (*(unsigned char *)(v23 + 16) == 59) {
          int v70 = 0;
        }
        int v200 = v70;
        goto LABEL_254;
      default:
        if (!v18) {
          goto LABEL_254;
        }
        if (*(unsigned char *)(v23 + 16) != 84) {
          goto LABEL_254;
        }
        uint64_t v81 = *(void *)(v23 - 32);
        if (!v81
          || *(unsigned char *)(v81 + 16)
          || *(void *)(v81 + 24) != *(void *)(v23 + 72)
          || *(_DWORD *)(v81 + 36) != 213)
        {
          goto LABEL_254;
        }
LABEL_157:
        *(unsigned char *)uint64_t v7 = 1;
LABEL_158:
        llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
    }
    break;
  }
  while (1)
  {
    if (v59 && (v58 & 1) != 0)
    {
      char v58 = 1;
LABEL_257:
      if (((v59 != 0) & v58) != 0) {
        int v122 = (llvm::Instruction *)v59;
      }
      else {
        int v122 = 0;
      }
      if (((v59 != 0) & v58) != 1) {
        goto LABEL_253;
      }
      uint64_t v194 = v122;
      v123 = sub_1CD4B3548((llvm::Value *)*(v59 - 8));
      v124 = v59 + 3;
      int v125 = *(void **)(v59[5] + 48);
      uint64_t v7 = v201;
      if (v59 + 3 != v125)
      {
        do
        {
          if (v124) {
            uint64_t v126 = (llvm::objcarc *)(v124 - 3);
          }
          else {
            uint64_t v126 = 0;
          }
          if (!sub_1CD4B36C8((uint64_t)v126, v11)) {
            goto LABEL_271;
          }
          int ARCInstKind = llvm::objcarc::GetARCInstKind(v126, v11);
          if (llvm::objcarc::CanDecrementRefCount(ARCInstKind))
          {
            char CanAlterRefCount = llvm::objcarc::CanAlterRefCount((uint64_t)v126, v123, v199, ARCInstKind);
            if (v126 != (llvm::objcarc *)v23 && (CanAlterRefCount & 1) != 0) {
              goto LABEL_254;
            }
          }
          v124 = (void *)*v124;
        }
        while (v124 != v125);
        v124 = v125;
      }
LABEL_271:
      if (v124) {
        uint64_t v129 = (uint64_t)(v124 - 3);
      }
      else {
        uint64_t v129 = 0;
      }
      if (sub_1CD4B36C8(v129, v11)
        || sub_1CD4B3548(*(llvm::Value **)(v129 - 32 * (*(_DWORD *)(v129 + 20) & 0x7FFFFFF))) != v123)
      {
        goto LABEL_254;
      }
      *(unsigned char *)uint64_t v201 = 1;
      uint64_t v130 = (llvm::PointerType *)llvm::PointerType::get((llvm::PointerType *)(***(void ***)v23 + 1912), 0);
      unint64_t v131 = llvm::PointerType::get(v130, 0);
      v211[0] = 0;
      v211[1] = 0;
      v211[0] = *((llvm::Value **)v197 - 4);
      v211[1] = v123;
      if (*(void *)v211[0] != v131)
      {
        int v132 = (llvm::Type *)v131;
        uint64_t v133 = operator new(0x60uLL);
        int v134 = v130;
        uint64_t v135 = (llvm::Value *)(v133 + 8);
        v133[13] = v133[13] & 0x38000000 | 1;
        *(void *)uint64_t v133 = 0;
        *((void *)v133 + 1) = 0;
        *((void *)v133 + 2) = 0;
        *((void *)v133 + 3) = v133 + 8;
        __int16 v218 = 257;
        llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v133 + 8), v211[0], v132, (const char **)&v215, v194);
        v211[0] = v135;
        uint64_t v130 = v134;
        v123 = v211[1];
      }
      BOOL v47 = *(void *)v123 == (void)v130;
      v136 = v194;
      if (!v47)
      {
        uint64_t v137 = operator new(0x60uLL);
        int v138 = (llvm::Value *)(v137 + 8);
        v137[13] = v137[13] & 0x38000000 | 1;
        *(void *)uint64_t v137 = 0;
        *((void *)v137 + 1) = 0;
        *((void *)v137 + 2) = 0;
        *((void *)v137 + 3) = v137 + 8;
        __int16 v218 = 257;
        llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v137 + 8), v211[1], v130, (const char **)&v215, v194);
        v211[1] = v138;
      }
      uint64_t v139 = *(void *)(v201 + 128);
      if (v139
        || (int v140 = *(uint64_t ***)(v201 + 80),
            llvm::Intrinsic::getType(*v140, 229, 0, 0),
            uint64_t v141 = (llvm::PointerType *)llvm::Intrinsic::getType(*v140, 229, 0, 0),
            llvm::Module::getOrInsertFunction((uint64_t)v140, "llvm.objc.storeStrong", (const char *)0x15, v141, 0),
            (*(void *)(v201 + 128) = v139) != 0))
      {
        uint64_t v142 = *(uint64_t ***)(v139 + 24);
      }
      else
      {
        uint64_t v142 = 0;
      }
      __int16 v218 = 257;
      uint64_t v143 = llvm::objcarc::createCallInstWithColors(v142, (uint64_t **)v139, (uint64_t *)v211, 2, (const char **)&v215, (uint64_t)v194, (uint64_t)v202);
      *(void *)(v143 + 64) = llvm::AttributeList::addAttributeAtIndex((uint64_t *)(v143 + 64), **(uint64_t ***)v143, -1, 37);
      uint64_t v144 = (unsigned __int8 *)*((void *)v194 + 6);
      *(void *)&long long v209 = v144;
      if (v144) {
        llvm::MetadataTracking::track((uint64_t)&v209, v144, 2);
      }
      long long v145 = (unsigned __int8 **)(v143 + 48);
      if (&v209 == (long long *)(v143 + 48))
      {
        if (!(void)v209) {
          goto LABEL_290;
        }
        int v176 = *(unsigned __int8 *)v209;
        if ((v176 - 4) > 0x1E)
        {
          if ((v176 - 3) >= 0xFFFFFFFE) {
            uint64_t v179 = v209;
          }
          else {
            uint64_t v179 = 0;
          }
          if ((v176 - 3) < 0xFFFFFFFE)
          {
            uint64_t v7 = v201;
            v136 = v194;
            if (v176 == 3) {
              *(void *)(v209 + 8) = 0;
            }
            goto LABEL_290;
          }
          unint64_t v178 = v179 + 8;
        }
        else
        {
          uint64_t v7 = v201;
          v136 = v194;
          if ((*(unsigned char *)(v209 + 1) & 0x7F) != 2 && !*(_DWORD *)(v209 + 12)) {
            goto LABEL_290;
          }
          uint64_t v177 = *(void *)(v209 + 16);
          if ((v177 & 4) == 0) {
            goto LABEL_290;
          }
          unint64_t v178 = v177 & 0xFFFFFFFFFFFFFFF8;
          if (!v178) {
            goto LABEL_290;
          }
        }
        v215 = &v209;
        sub_1CC5FA668(v178 + 16, &v215);
        uint64_t v7 = v201;
        v136 = v194;
        goto LABEL_290;
      }
      v146 = *v145;
      if (!*v145) {
        goto LABEL_288;
      }
      int v167 = *v146;
      if ((v167 - 4) <= 0x1E)
      {
        uint64_t v7 = v201;
        v136 = v194;
        if ((v146[1] & 0x7F) != 2 && !*((_DWORD *)v146 + 3)) {
          goto LABEL_288;
        }
        uint64_t v168 = *((void *)v146 + 2);
        if ((v168 & 4) == 0) {
          goto LABEL_288;
        }
        unint64_t v169 = v168 & 0xFFFFFFFFFFFFFFF8;
        if (!v169) {
          goto LABEL_288;
        }
        goto LABEL_359;
      }
      if ((v167 - 3) >= 0xFFFFFFFE) {
        unint64_t v175 = *v145;
      }
      else {
        unint64_t v175 = 0;
      }
      if ((v167 - 3) >= 0xFFFFFFFE)
      {
        unint64_t v169 = (unint64_t)(v175 + 8);
LABEL_359:
        v215 = (void *)(v143 + 48);
        sub_1CC5FA668(v169 + 16, &v215);
        uint64_t v7 = v201;
        v136 = v194;
        goto LABEL_288;
      }
      uint64_t v7 = v201;
      v136 = v194;
      if (v167 == 3) {
        *((void *)v146 + 1) = 0;
      }
LABEL_288:
      uint64_t v147 = (unsigned __int8 *)v209;
      *long long v145 = (unsigned __int8 *)v209;
      if (v147)
      {
        llvm::MetadataTracking::retrack((uint64_t)&v209, v147, v143 + 48);
        *(void *)&long long v209 = 0;
      }
LABEL_290:
      uint64_t v148 = *(void *)(v7 + 208);
      uint64_t v149 = *(unsigned int *)(v7 + 220);
      if (v148 != *(void *)(v7 + 200))
      {
        unsigned int v153 = *(_DWORD *)(v7 + 216);
        goto LABEL_301;
      }
      if (!v149) {
        goto LABEL_298;
      }
      v150 = 0;
      uint64_t v151 = 8 * v149;
      unsigned int v152 = *(uint64_t **)(v7 + 208);
      do
      {
        if (*v152 == v143) {
          goto LABEL_322;
        }
        if (*v152 == -2) {
          v150 = v152;
        }
        ++v152;
        v151 -= 8;
      }
      while (v151);
      if (!v150)
      {
LABEL_298:
        unsigned int v153 = *(_DWORD *)(v7 + 216);
        if (v149 < v153)
        {
          *(_DWORD *)(v7 + 220) = v149 + 1;
          *(void *)(v148 + 8 * v149) = v143;
          goto LABEL_322;
        }
LABEL_301:
        if (3 * v153 <= 4 * ((int)v149 - *(_DWORD *)(v7 + 224)))
        {
          if (v153 >= 0x40) {
            v153 *= 2;
          }
          else {
            unsigned int v153 = 128;
          }
        }
        else if (v153 - v149 >= v153 >> 3)
        {
LABEL_303:
          unsigned int v154 = v153 - 1;
          unsigned int v155 = (v153 - 1) & ((v143 >> 4) ^ (v143 >> 9));
          v156 = (uint64_t *)(v148 + 8 * v155);
          uint64_t v157 = *v156;
          if (*v156 == -1)
          {
            uint64_t v158 = 0;
LABEL_315:
            if (v158) {
              int v162 = v158;
            }
            else {
              int v162 = v156;
            }
            if (*v162 != v143)
            {
              if (*v162 == -2) {
                --*(_DWORD *)(v7 + 224);
              }
              else {
                ++*(_DWORD *)(v7 + 220);
              }
              *int v162 = v143;
              v136 = v194;
            }
          }
          else
          {
            uint64_t v158 = 0;
            int v159 = 1;
            while (v157 != v143)
            {
              if (v158) {
                BOOL v160 = 0;
              }
              else {
                BOOL v160 = v157 == -2;
              }
              if (v160) {
                uint64_t v158 = v156;
              }
              unsigned int v161 = v155 + v159++;
              unsigned int v155 = v161 & v154;
              v156 = (uint64_t *)(v148 + 8 * (v161 & v154));
              uint64_t v157 = *v156;
              if (*v156 == -1) {
                goto LABEL_315;
              }
            }
          }
LABEL_322:
          BOOL v163 = v124 == 0;
          if (v19) {
            BOOL v163 = v19 - 3 == (void *)v129;
          }
          if (v163)
          {
            int v19 = (void *)v19[1];
            uint64_t v164 = i - 3;
            if (!i) {
              uint64_t v164 = 0;
            }
            if (v19 == v164 + 5)
            {
              unint64_t v165 = (void *)i[1];
              uint64_t i = v15;
              if (v165 != v15)
              {
                while (1)
                {
                  unint64_t v166 = v165 - 3;
                  if (!v165) {
                    unint64_t v166 = 0;
                  }
                  int v19 = (void *)v166[6];
                  if (v19 != v166 + 5) {
                    break;
                  }
                  unint64_t v165 = (void *)v165[1];
                  if (v165 == v15)
                  {
                    uint64_t i = v15;
                    goto LABEL_341;
                  }
                }
                uint64_t i = v165;
              }
            }
          }
LABEL_341:
          uint64_t v170 = (llvm::Instruction *)(v19 - 3);
          if (!v19) {
            uint64_t v170 = 0;
          }
          if (v170 == v136)
          {
            v171 = (void *)v19[1];
            unsigned int v172 = i - 3;
            if (!i) {
              unsigned int v172 = 0;
            }
            if (v171 == v172 + 5)
            {
              for (uint64_t m = (void *)i[1]; m != v15; uint64_t m = (void *)m[1])
              {
                unsigned int v174 = m - 3;
                if (!m) {
                  unsigned int v174 = 0;
                }
                if ((void *)v174[6] != v174 + 5) {
                  break;
                }
              }
            }
          }
          llvm::SymbolTableListTraits<llvm::Instruction>::removeNodeFromList();
        }
        llvm::SmallPtrSetImplBase::Grow(v195, v153);
        unsigned int v153 = *(_DWORD *)(v7 + 216);
        uint64_t v148 = *(void *)(v7 + 208);
        goto LABEL_303;
      }
      uint64_t *v150 = v143;
      --*(_DWORD *)(v7 + 224);
      goto LABEL_322;
    }
    if (v56) {
      uint64_t v60 = (unsigned __int8 *)(v56 - 24);
    }
    else {
      uint64_t v60 = 0;
    }
    if (v60 == (unsigned __int8 *)v23)
    {
      char v58 = 1;
    }
    else
    {
      unsigned int v61 = sub_1CD4B36C8((uint64_t)v60, v11);
      if (v59)
      {
        if (llvm::objcarc::CanUse((uint64_t)v60, v197, (const llvm::Value **)v199, v61)) {
          goto LABEL_253;
        }
      }
      else
      {
        if (v61 >= 2)
        {
          unsigned int v59 = (void *)(v56 - 24);
          *(_OWORD *)v211 = v209;
          long long v212 = v210[0];
          long long v213 = v210[1];
          char v214 = 1;
          v215 = (void *)1;
          uint64_t v62 = 8;
          do
          {
            uint64_t v63 = (char *)&v215 + v62;
            *(_OWORD *)uint64_t v63 = xmmword_1CFAC3060;
            *((_OWORD *)v63 + 1) = xmmword_1CFAC3060;
            v62 += 40;
          }
          while (v63 + 40 != (char *)v219);
          v219[0] = &v223;
          v219[1] = 0;
          __int16 v220 = v222;
          uint64_t v221 = 0x400000000;
          BOOL v223 = &unk_1F2600DB8;
          uint64_t v64 = 504;
          uint64_t v224 = 1;
          do
          {
            *(void **)((char *)&v215 + v64) = (void *)-4096;
            v64 += 16;
          }
          while (v64 != 632);
          char ModRefInfo = llvm::AAResults::getModRefInfo((uint64_t)v193, (llvm::Instruction *)v60, (long long *)v211, (uint64_t)&v215);
          if ((v224 & 1) == 0) {
            MEMORY[0x1D25D9CD0](v225, 8);
          }
          if (v220 != v222) {
            free(v220);
          }
          if (v215)
          {
            if ((ModRefInfo & 2) != 0) {
              goto LABEL_120;
            }
          }
          else
          {
            MEMORY[0x1D25D9CD0](v216, 8);
            if ((ModRefInfo & 2) != 0)
            {
LABEL_120:
              int v66 = v60[16];
              if (v66 == 61) {
                int v67 = v60;
              }
              else {
                int v67 = 0;
              }
              if (!v56 || v66 != 61) {
                goto LABEL_253;
              }
              int v68 = v67[16];
              if (v68 == 60 || v68 == 61)
              {
                __int16 v69 = *((_WORD *)v67 + 9);
                if (v69 & 0x380) != 0 || (v69) {
                  goto LABEL_253;
                }
              }
              else if (v68 - 63) < 3 || (*((_WORD *)v67 + 9))
              {
                goto LABEL_253;
              }
              if (llvm::Value::stripPointerCasts(*((llvm::Value **)v67 - 4)) != v192) {
                goto LABEL_253;
              }
              goto LABEL_102;
            }
          }
        }
        unsigned int v59 = 0;
      }
    }
LABEL_102:
    uint64_t v56 = *(void *)(v56 + 8);
    if (v56 == v57) {
      goto LABEL_257;
    }
  }
}

void sub_1CCC13714()
{
}

void sub_1CCC13754(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCC1378C(uint64_t a1, uint64_t a2)
{
  sub_1CB843600(a2, a2, (uint64_t)&llvm::AAResultsWrapperPass::ID);

  sub_1CB843600(a2, a2, (uint64_t)&llvm::DominatorTreeWrapperPass::ID);
}

BOOL sub_1CCC137DC(uint64_t a1, uint64_t a2)
{
  v17[1] = 0;
  v17[2] = 0;
  int v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  int v21 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  memset(v27, 0, sizeof(v27));
  int v28 = v32;
  int v29 = v32;
  uint64_t v30 = 8;
  int v31 = 0;
  sub_1CCC11D80((uint64_t)v16, *(llvm::Module **)(a2 + 40));
  uint64_t v4 = 0;
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t v6 = *v5;
  uint64_t v7 = v5[1];
  if (v6 != v7)
  {
    while (*(_UNKNOWN **)v6 != &llvm::AAResultsWrapperPass::ID)
    {
      v6 += 16;
      if (v6 == v7)
      {
        uint64_t v4 = 0;
        goto LABEL_6;
      }
    }
    uint64_t v4 = *(void *)(v6 + 8);
  }
LABEL_6:
  uint64_t v8 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 96))(v4, &llvm::AAResultsWrapperPass::ID)+ 32);
  char v9 = *(uint64_t **)(a1 + 8);
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_9:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::DominatorTreeWrapperPass::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_9;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::DominatorTreeWrapperPass::ID);
  BOOL v14 = sub_1CCC11FA4((uint64_t)v16, a2, v8, (llvm::DominatorTree *)(v13 + 32));
  if (v29 != v28) {
    free(v29);
  }
  sub_1CD6C121C((uint64_t)v17);
  return v14;
}

llvm::BitCastInst *sub_1CCC13978(llvm::BitCastInst *result, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a2 + 16);
  if (v2 <= 0x1B && v2 != 21) {
    return result;
  }
  uint64_t v4 = *(llvm::Type ****)(a2 + 8);
  if (!v4) {
    return result;
  }
  uint64_t v5 = (const llvm::Value **)result;
  uint64_t v6 = *((void *)result + 1);
  do
  {
    uint64_t v7 = v4[1];
    uint64_t v8 = v4[3];
    int v9 = *((_DWORD *)v8 + 5);
    if ((v9 & 0x40000000) != 0) {
      uint64_t v10 = (llvm::Type **)*(v8 - 1);
    }
    else {
      uint64_t v10 = &v8[-4 * (v9 & 0x7FFFFFF)];
    }
    BOOL result = (llvm::BitCastInst *)llvm::DominatorTree::isReachableFromEntry(*(llvm::DominatorTree **)(v6 + 16), (const llvm::Use *)v4);
    if (!result) {
      goto LABEL_68;
    }
    BOOL result = (llvm::BitCastInst *)llvm::DominatorTree::dominates(*(llvm::DominatorTree **)(v6 + 16), *v5, (const llvm::Use *)v4);
    if (!result) {
      goto LABEL_68;
    }
    *(unsigned char *)uint64_t v6 = 1;
    uint64_t v11 = *v5;
    uint64_t v12 = **v4;
    uint64_t v13 = v4[3];
    if (!v13 || *((unsigned char *)v13 + 16) != 83)
    {
      if (*(llvm::Type **)v11 == v12) {
        goto LABEL_71;
      }
      uint64_t v16 = operator new(0x60uLL);
      uint64_t v17 = (const llvm::Value *)(v16 + 8);
      v16[13] = v16[13] & 0x38000000 | 1;
      *(void *)uint64_t v16 = 0;
      *((void *)v16 + 1) = 0;
      *((void *)v16 + 2) = 0;
      *((void *)v16 + 3) = v16 + 8;
      __int16 v51 = 257;
      BOOL result = llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v16 + 8), v11, v12, v50, (llvm::Instruction *)v4[3]);
      uint64_t v11 = v17;
      if (*v4)
      {
LABEL_71:
        *void v4[2] = (llvm::Type *)v4[1];
        int v18 = v4[1];
        if (v18) {
          v18[2] = (llvm::Type *)v4[2];
        }
      }
      void *v4 = (llvm::Type **)v11;
      int v21 = (llvm::Type **)*((void *)v11 + 1);
      uint64_t v20 = (llvm::Type ****)((char *)v11 + 8);
      uint64_t v19 = v21;
      v4[1] = v21;
      if (v21) {
        v19[2] = (llvm::Type *)(v4 + 1);
      }
      void v4[2] = (llvm::Type **)v20;
      *uint64_t v20 = v4;
      goto LABEL_68;
    }
    int v14 = *((_DWORD *)v13 + 5);
    if ((v14 & 0x40000000) != 0) {
      uint64_t v15 = (llvm::Type **)*(v13 - 1);
    }
    else {
      uint64_t v15 = &v13[-4 * (v14 & 0x7FFFFFF)];
    }
    long long v22 = *(&v15[4 * *((unsigned int *)v13 + 15)] + ((unint64_t)((char *)v4 - (char *)v10) >> 5));
    if (*(llvm::Type **)v11 == v12) {
      goto LABEL_45;
    }
    for (uint64_t i = v22; ; uint64_t i = (llvm::Type *)**((void **)v30[1] + 1))
    {
      for (uint64_t j = *((void *)i + 6); ; uint64_t j = *(void *)(j + 8))
      {
        uint64_t v25 = j - 24;
        if (!j) {
          uint64_t v25 = 0;
        }
        if (*(unsigned char *)(v25 + 16) != 83) {
          break;
        }
      }
      if (*(unsigned char *)(j - 8) != 38) {
        break;
      }
      uint64_t v26 = *(void *)(v6 + 16);
      uint64_t v27 = *(void *)(v26 + 24);
      uint64_t v28 = *(unsigned int *)(v26 + 40);
      if (v28)
      {
        LODWORD(v29) = (v28 - 1) & ((i >> 4) ^ (i >> 9));
        uint64_t v30 = (llvm::Type **)(v27 + 16 * v29);
        int v31 = *v30;
        if (i == *v30) {
          continue;
        }
        int v32 = 1;
        while (v31 != (llvm::Type *)-4096)
        {
          int v33 = v29 + v32++;
          uint64_t v29 = v33 & (v28 - 1);
          int v31 = *(llvm::Type **)(v27 + 16 * v29);
          if (i == v31)
          {
            uint64_t v30 = (llvm::Type **)(v27 + 16 * v29);
            goto LABEL_40;
          }
        }
      }
      uint64_t v30 = (llvm::Type **)(v27 + 16 * v28);
LABEL_40:
      ;
    }
    uint64_t v34 = operator new(0x60uLL);
    int v35 = (const llvm::Value *)(v34 + 8);
    v34[13] = v34[13] & 0x38000000 | 1;
    *(void *)uint64_t v34 = 0;
    *((void *)v34 + 1) = 0;
    *((void *)v34 + 2) = 0;
    *((void *)v34 + 3) = v34 + 8;
    __int16 v51 = 257;
    uint64_t v36 = *((void *)i + 5);
    if (v36) {
      int v37 = (llvm::Instruction *)(v36 - 24);
    }
    else {
      int v37 = 0;
    }
    BOOL result = llvm::BitCastInst::BitCastInst((llvm::BitCastInst *)(v34 + 8), v11, v12, v50, v37);
    int v14 = *((_DWORD *)v13 + 5);
    uint64_t v11 = v35;
LABEL_45:
    unsigned int v38 = v14 & 0x7FFFFFF;
    if ((v14 & 0x7FFFFFF) != 0)
    {
      unint64_t v39 = 0;
      uint64_t v40 = (const llvm::Value *)((char *)v11 + 8);
      uint64_t v41 = 32 * v38;
      uint64_t v42 = 4 * *((unsigned int *)v13 + 15);
      do
      {
        int v43 = *((_DWORD *)v13 + 5);
        if ((v43 & 0x40000000) != 0) {
          unsigned int v44 = (llvm::Type **)*(v13 - 1);
        }
        else {
          unsigned int v44 = &v13[-4 * (v43 & 0x7FFFFFF)];
        }
        if (v44[v42] == v22)
        {
          if (v7)
          {
            BOOL v45 = (v43 & 0x40000000) != 0 ? *(v13 - 1) : (llvm::Type *)&v13[-4 * (v43 & 0x7FFFFFF)];
            if ((llvm::Type **)((char *)v45 + v39) == v7) {
              uint64_t v7 = (llvm::Type **)v7[1];
            }
          }
          if ((v43 & 0x40000000) != 0) {
            int v46 = (llvm::Type **)*(v13 - 1);
          }
          else {
            int v46 = &v13[-4 * (v43 & 0x7FFFFFF)];
          }
          BOOL v47 = &v46[v39 / 8];
          if (v46[v39 / 8])
          {
            *(void *)v47[2] = v47[1];
            uint64_t v49 = v47[1];
            if (v49) {
              *((void *)v49 + 2) = v47[2];
            }
          }
          char *v47 = v11;
          uint64_t v48 = (llvm::Type *)*((void *)v11 + 1);
          v47[1] = v48;
          if (v48) {
            *((void *)v48 + 2) = v47 + 1;
          }
          v46[v39 / 8 + 2] = v40;
          *(void *)uint64_t v40 = v47;
        }
        v39 += 32;
        ++v42;
      }
      while (v41 != v39);
    }
LABEL_68:
    uint64_t v4 = (llvm::Type ***)v7;
  }
  while (v7);
  return result;
}

uint64_t sub_1CCC13CFC()
{
  *(void *)&long long v1 = "Enable generation of calls to objc_claimAutoreleasedReturnValue";
  *((void *)&v1 + 1) = 63;
  sub_1CD6C183C(&v1);

  return __cxa_atexit((void (*)(void *))sub_1CC243CA8, &qword_1EBCEF320, &dword_1CB82C000);
}

uint64_t llvm::objcarc::CanAlterRefCount(uint64_t a1, const llvm::Value *a2, uint64_t *a3, int a4)
{
  if (a4 - 5) < 0x13 && ((0x48003u >> (a4 - 5))) {
    return 0;
  }
  char ModRefBehavior = llvm::AAResults::getModRefBehavior(*a3, a1);
  if ((ModRefBehavior & 2) == 0) {
    return 0;
  }
  if ((ModRefBehavior & 0x30) == 0)
  {
    int v10 = *(_DWORD *)(a1 + 20);
    uint64_t v11 = v10 & 0x7FFFFFF;
    uint64_t v12 = (llvm::objcarc **)(a1 - 32 * v11);
    int v13 = *(unsigned __int8 *)(a1 + 16);
    if (v13 == 84)
    {
      uint64_t v14 = 0;
    }
    else if (v13 == 39)
    {
      uint64_t v14 = (*(_DWORD *)(a1 + 80) + 1);
    }
    else
    {
      uint64_t v14 = 2;
    }
    if (v10 < 0 && (uint64_t v18 = (uint64_t)*(v12 - 1), (v18 & 0xFFFFFFFF0) != 0)) {
      uint64_t v15 = (*((_DWORD *)v12 - 3) - *(_DWORD *)((char *)v12 - v18));
    }
    else {
      uint64_t v15 = 0;
    }
    if (v12 == (llvm::objcarc **)(a1 - 32 * v14 - 32 * v15 - 32)) {
      return 0;
    }
    uint64_t v16 = 32 * v11 - 32 * v14 - 32 * v15 - 32;
    while (1)
    {
      uint64_t v17 = *v12;
      if (llvm::objcarc::IsPotentialRetainableObjPtr(*v12, (const llvm::Value *)*a3, v8)
        && llvm::objcarc::ProvenanceAnalysis::related((llvm::objcarc::ProvenanceAnalysis *)a3, a2, v17))
      {
        break;
      }
      uint64_t result = 0;
      v12 += 4;
      v16 -= 32;
      if (!v16) {
        return result;
      }
    }
  }
  return 1;
}

BOOL llvm::objcarc::CanUse(uint64_t a1, const llvm::Value *a2, const llvm::Value **a3, int a4)
{
  if (a4 == 22) {
    return 0;
  }
  int v7 = *(unsigned __int8 *)(a1 + 16);
  if (a1 && v7 == 81)
  {
    if (!llvm::objcarc::IsPotentialRetainableObjPtr(*(llvm::objcarc **)(a1 - 32), *a3, (llvm::AAResults *)a3)) {
      return 0;
    }
    goto LABEL_26;
  }
  if ((v7 - 33) <= 0x33 && ((1 << (v7 - 33)) & 0x8000000000041) != 0)
  {
    int v9 = *(_DWORD *)(a1 + 20);
    uint64_t v10 = v9 & 0x7FFFFFF;
    uint64_t v11 = (llvm::objcarc **)(a1 - 32 * v10);
    if (v7 == 84)
    {
      uint64_t v12 = 0;
    }
    else if (v7 == 39)
    {
      uint64_t v12 = (*(_DWORD *)(a1 + 80) + 1);
    }
    else
    {
      uint64_t v12 = 2;
    }
    if (v9 < 0 && (uint64_t v24 = (uint64_t)*(v11 - 1), (v24 & 0xFFFFFFFF0) != 0)) {
      uint64_t v13 = (*((_DWORD *)v11 - 3) - *(_DWORD *)((char *)v11 - v24));
    }
    else {
      uint64_t v13 = 0;
    }
    if (v11 != (llvm::objcarc **)(a1 - 32 * v12 - 32 * v13 - 32))
    {
      uint64_t v14 = 32 * v10 - 32 * v12 - 32 * v13 - 32;
      while (1)
      {
        uint64_t v15 = *v11;
        if (llvm::objcarc::IsPotentialRetainableObjPtr(*v11, *a3, (llvm::AAResults *)a3)
          && llvm::objcarc::ProvenanceAnalysis::related((llvm::objcarc::ProvenanceAnalysis *)a3, a2, v15))
        {
          break;
        }
        BOOL result = 0;
        v11 += 4;
        v14 -= 32;
        if (!v14) {
          return result;
        }
      }
      return 1;
    }
    return 0;
  }
  if (!a1 || v7 != 61)
  {
LABEL_26:
    int v19 = *(_DWORD *)(a1 + 20);
    if ((v19 & 0x40000000) != 0)
    {
      int v21 = *(llvm::objcarc ***)(a1 - 8);
      uint64_t v20 = v19 & 0x7FFFFFF;
      if (v20)
      {
LABEL_28:
        uint64_t v22 = 32 * v20;
        while (1)
        {
          long long v23 = *v21;
          if (llvm::objcarc::IsPotentialRetainableObjPtr(*v21, *a3, (llvm::AAResults *)a3)
            && llvm::objcarc::ProvenanceAnalysis::related((llvm::objcarc::ProvenanceAnalysis *)a3, a2, v23))
          {
            break;
          }
          BOOL result = 0;
          v21 += 4;
          v22 -= 32;
          if (!v22) {
            return result;
          }
        }
        return 1;
      }
    }
    else
    {
      uint64_t v20 = v19 & 0x7FFFFFF;
      int v21 = (llvm::objcarc **)(a1 - 32 * v20);
      if (v20) {
        goto LABEL_28;
      }
    }
    return 0;
  }
  uint64_t v17 = sub_1CD4B35A0(*(llvm **)(a1 - 32));
  BOOL result = llvm::objcarc::IsPotentialRetainableObjPtr(v17, *a3, v18);
  if (result)
  {
    return llvm::objcarc::ProvenanceAnalysis::related((llvm::objcarc::ProvenanceAnalysis *)a3, v17, a2);
  }
  return result;
}

uint64_t llvm::objcarc::findSingleDependency(int a1, llvm::objcarc *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  v109[8] = *MEMORY[0x1E4F143B8];
  uint64_t v97 = v101;
  uint64_t v98 = v101;
  uint64_t v99 = 4;
  int v100 = 0;
  uint64_t v102 = v106;
  uint64_t v103 = v106;
  uint64_t v104 = 4;
  int v105 = 0;
  uint64_t v107 = v109;
  v109[0] = a3;
  v109[1] = a4 + 24;
  unsigned int v9 = 1;
  uint64_t v108 = 0x400000001;
  do
  {
    uint64_t v10 = (char *)v107 + 16 * v9;
    uint64_t v11 = *((void *)v10 - 2);
    uint64_t v12 = (void *)*((void *)v10 - 1);
    LODWORD(v108) = v9 - 1;
    uint64_t v13 = *(void **)(v11 + 48);
    if (v13 == v12)
    {
LABEL_8:
      uint64_t v15 = *(void *)(v11 + 8);
      if (!v15) {
        goto LABEL_192;
      }
      while (1)
      {
        uint64_t v16 = *(void *)(v15 + 24);
        unsigned int v17 = *(unsigned __int8 *)(v16 + 16);
        BOOL v18 = v16 && v17 >= 0x1C;
        if (v18 && v17 - 29 <= 0xA) {
          break;
        }
        uint64_t v15 = *(void *)(v15 + 8);
        if (!v15) {
          goto LABEL_192;
        }
      }
LABEL_19:
      uint64_t v20 = *(void *)(v16 + 40);
      int v21 = v103;
      uint64_t v22 = HIDWORD(v104);
      if (v103 == v102)
      {
        if (HIDWORD(v104))
        {
          long long v23 = 0;
          uint64_t v24 = 8 * HIDWORD(v104);
          uint64_t v25 = v103;
          do
          {
            if (*v25 == v20) {
              goto LABEL_53;
            }
            if (*v25 == -2) {
              long long v23 = v25;
            }
            ++v25;
            v24 -= 8;
          }
          while (v24);
          if (v23)
          {
            void *v23 = v20;
            --v105;
            goto LABEL_51;
          }
        }
        unsigned int v26 = v104;
        if (HIDWORD(v104) < v104)
        {
          ++HIDWORD(v104);
          *(void *)&v103[8 * v22] = v20;
LABEL_51:
          if (v108 >= (unint64_t)HIDWORD(v108)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v36 = (char *)v107 + 16 * v108;
          void *v36 = v20;
          v36[1] = v20 + 40;
          LODWORD(v108) = v108 + 1;
          goto LABEL_53;
        }
      }
      else
      {
        unsigned int v26 = v104;
      }
      if (3 * v26 <= 4 * (HIDWORD(v104) - v105))
      {
        if (v26 >= 0x40) {
          v26 *= 2;
        }
        else {
          unsigned int v26 = 128;
        }
      }
      else if (v26 - HIDWORD(v104) >= v26 >> 3)
      {
LABEL_32:
        unsigned int v27 = v26 - 1;
        unsigned int v28 = (v26 - 1) & ((v20 >> 4) ^ (v20 >> 9));
        uint64_t v29 = &v21[8 * v28];
        uint64_t v30 = *(void *)v29;
        if (*(void *)v29 == -1)
        {
          int v31 = 0;
        }
        else
        {
          int v31 = 0;
          int v32 = 1;
          do
          {
            if (v30 == v20) {
              goto LABEL_53;
            }
            if (v31) {
              BOOL v33 = 0;
            }
            else {
              BOOL v33 = v30 == -2;
            }
            if (v33) {
              int v31 = v29;
            }
            unsigned int v34 = v28 + v32++;
            unsigned int v28 = v34 & v27;
            uint64_t v29 = &v21[8 * (v34 & v27)];
            uint64_t v30 = *(void *)v29;
          }
          while (*(void *)v29 != -1);
        }
        if (v31) {
          int v35 = v31;
        }
        else {
          int v35 = v29;
        }
        if (*(void *)v35 != v20)
        {
          if (*(void *)v35 == -2) {
            --v105;
          }
          else {
            ++HIDWORD(v104);
          }
          *(void *)int v35 = v20;
          goto LABEL_51;
        }
LABEL_53:
        while (1)
        {
          uint64_t v15 = *(void *)(v15 + 8);
          if (!v15) {
            goto LABEL_101;
          }
          uint64_t v16 = *(void *)(v15 + 24);
          unsigned int v37 = *(unsigned __int8 *)(v16 + 16);
          if (v16) {
            BOOL v38 = v37 >= 0x1C;
          }
          else {
            BOOL v38 = 0;
          }
          if (v38 && v37 - 29 < 0xB) {
            goto LABEL_19;
          }
        }
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v102, v26);
      unsigned int v26 = v104;
      int v21 = v103;
      goto LABEL_32;
    }
    while (1)
    {
      uint64_t v12 = (void *)*v12;
      uint64_t v14 = v12 ? (llvm::objcarc *)(v12 - 3) : 0;
      if (llvm::objcarc::Depends(a1, v14, a2, a5)) {
        break;
      }
      if (v12 == v13) {
        goto LABEL_8;
      }
    }
    uint64_t v40 = v98;
    uint64_t v41 = HIDWORD(v99);
    if (v98 != v97)
    {
      unsigned int v45 = v99;
      goto LABEL_80;
    }
    if (!HIDWORD(v99))
    {
LABEL_77:
      unsigned int v45 = v99;
      if (HIDWORD(v99) < v99)
      {
        ++HIDWORD(v99);
        *(void *)&v98[8 * v41] = v14;
        goto LABEL_101;
      }
LABEL_80:
      if (3 * v45 <= 4 * (HIDWORD(v99) - v100))
      {
        if (v45 >= 0x40) {
          v45 *= 2;
        }
        else {
          unsigned int v45 = 128;
        }
      }
      else if (v45 - HIDWORD(v99) >= v45 >> 3)
      {
        goto LABEL_82;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v97, v45);
      unsigned int v45 = v99;
      uint64_t v40 = v98;
LABEL_82:
      unsigned int v46 = v45 - 1;
      unsigned int v47 = (v45 - 1) & ((v14 >> 4) ^ (v14 >> 9));
      uint64_t v48 = (llvm::objcarc **)&v40[8 * v47];
      uint64_t v49 = *v48;
      if (*v48 == (llvm::objcarc *)-1)
      {
        uint64_t v50 = 0;
LABEL_94:
        if (v50) {
          int v54 = v50;
        }
        else {
          int v54 = v48;
        }
        if (*v54 != v14)
        {
          if (*v54 == (llvm::objcarc *)-2) {
            --v100;
          }
          else {
            ++HIDWORD(v99);
          }
          llvm::Value *v54 = v14;
        }
      }
      else
      {
        uint64_t v50 = 0;
        int v51 = 1;
        while (v49 != v14)
        {
          if (v50) {
            BOOL v52 = 0;
          }
          else {
            BOOL v52 = v49 == (llvm::objcarc *)-2;
          }
          if (v52) {
            uint64_t v50 = v48;
          }
          unsigned int v53 = v47 + v51++;
          unsigned int v47 = v53 & v46;
          uint64_t v48 = (llvm::objcarc **)&v40[8 * (v53 & v46)];
          uint64_t v49 = *v48;
          if (*v48 == (llvm::objcarc *)-1) {
            goto LABEL_94;
          }
        }
      }
      goto LABEL_101;
    }
    uint64_t v42 = 0;
    uint64_t v43 = 8 * HIDWORD(v99);
    unsigned int v44 = (llvm::objcarc **)v98;
    while (*v44 != v14)
    {
      if (*v44 == (llvm::objcarc *)-2) {
        uint64_t v42 = v44;
      }
      ++v44;
      v43 -= 8;
      if (!v43)
      {
        if (!v42) {
          goto LABEL_77;
        }
        *uint64_t v42 = v14;
        --v100;
        break;
      }
    }
LABEL_101:
    unsigned int v9 = v108;
  }
  while (v108);
  if (HIDWORD(v99) - v100 != 1) {
    goto LABEL_192;
  }
  unint64_t v55 = v98;
  uint64_t v56 = v98 == v97 ? HIDWORD(v99) : v99;
  uint64_t v57 = 8 * v56;
  char v58 = (uint64_t *)v98;
  if (v56)
  {
    uint64_t v59 = 8 * v56;
    uint64_t v60 = (uint64_t *)v98;
    while (1)
    {
      uint64_t v61 = *v60;
      if ((unint64_t)*v60 < 0xFFFFFFFFFFFFFFFELL) {
        break;
      }
      ++v60;
      v59 -= 8;
      if (!v59)
      {
        char v58 = (uint64_t *)&v98[8 * v56];
        goto LABEL_118;
      }
    }
  }
  else
  {
LABEL_118:
    uint64_t v61 = *v58;
  }
  if (v61)
  {
    if (v56)
    {
      while (*(void *)v55 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v55 += 8;
        v57 -= 8;
        if (!v57)
        {
          unint64_t v55 = &v98[8 * v56];
          break;
        }
      }
    }
    uint64_t v62 = *(void *)(*(void *)v55 + 40);
    if (v103 == v102) {
      uint64_t v63 = (uint64_t *)((char *)&v104 + 4);
    }
    else {
      uint64_t v63 = &v104;
    }
    uint64_t v64 = *(unsigned int *)v63;
    if (v64)
    {
      uint64_t v65 = 8 * v64;
      int v66 = (unint64_t *)v103;
      char v67 = 1;
      while (*v66 >= 0xFFFFFFFFFFFFFFFELL)
      {
        ++v66;
        v65 -= 8;
        if (!v65) {
          goto LABEL_193;
        }
      }
    }
    else
    {
      int v66 = (unint64_t *)v103;
    }
    int v68 = &v103[8 * v64];
    char v67 = 1;
    if (v66 != (unint64_t *)v68)
    {
      unint64_t v69 = *v66;
LABEL_135:
      if (v69 != a3)
      {
        uint64_t v70 = *(void *)(v69 + 40);
        if (v70 != v69 + 40)
        {
          if (v70) {
            uint64_t v71 = v70 - 24;
          }
          else {
            uint64_t v71 = 0;
          }
          if (*(unsigned char *)(v71 + 16) != 30)
          {
            int v86 = 2;
            switch(*(unsigned char *)(v71 + 16))
            {
              case 0x1E:
                __break(1u);
                JUMPOUT(0x1CCC148B0);
              case 0x1F:
                int v86 = (*(_DWORD *)(v71 + 20) >> 1) & 0x3FFFFFF;
                goto LABEL_186;
              case 0x20:
              case 0x26:
                int v86 = (*(_DWORD *)(v71 + 20) & 0x7FFFFFF) - 1;
                goto LABEL_186;
              case 0x21:
                goto LABEL_145;
              case 0x24:
                int v86 = *(_WORD *)(v71 + 18) & 1;
                goto LABEL_186;
              case 0x25:
                int v86 = 1;
                goto LABEL_145;
              case 0x27:
                int v86 = *(_DWORD *)(v71 + 80) + 1;
LABEL_186:
                if (!v86) {
                  goto LABEL_181;
                }
                goto LABEL_145;
              default:
                goto LABEL_181;
            }
          }
          if ((*(_DWORD *)(v71 + 20) & 0x7FFFFFF) == 3) {
            int v86 = 2;
          }
          else {
            int v86 = 1;
          }
LABEL_145:
          unsigned int v72 = 0;
          do
          {
            uint64_t Successor = llvm::Instruction::getSuccessor((llvm::Instruction *)v71, v72);
            if (Successor == v62) {
              goto LABEL_192;
            }
            if (Successor != a3)
            {
              uint64_t v74 = v102;
              if (v103 == v102)
              {
                int v75 = HIDWORD(v104);
                int v76 = &v103[8 * HIDWORD(v104)];
                if (HIDWORD(v104))
                {
                  uint64_t v77 = 0;
                  while (*(void *)&v103[v77] != Successor)
                  {
                    v77 += 8;
                    if (8 * HIDWORD(v104) == v77) {
                      goto LABEL_167;
                    }
                  }
                  int v76 = &v103[v77];
                }
LABEL_167:
                uint64_t v74 = v103;
              }
              else
              {
                int v78 = v104 - 1;
                unsigned int v79 = (v104 - 1) & ((Successor >> 4) ^ (Successor >> 9));
                int v76 = &v103[8 * v79];
                uint64_t v80 = *(void *)v76;
                if (*(void *)v76 == -1)
                {
                  uint64_t v81 = 0;
LABEL_175:
                  if (v81) {
                    int v76 = v81;
                  }
                  int v75 = HIDWORD(v104);
                  if (*(void *)v76 != Successor) {
                    int v76 = &v103[8 * v104];
                  }
                }
                else
                {
                  uint64_t v81 = 0;
                  int v82 = 1;
                  while (v80 != Successor)
                  {
                    if (v81) {
                      BOOL v83 = 0;
                    }
                    else {
                      BOOL v83 = v80 == -2;
                    }
                    if (v83) {
                      uint64_t v81 = v76;
                    }
                    unsigned int v84 = v79 + v82++;
                    unsigned int v79 = v84 & v78;
                    int v76 = &v103[8 * (v84 & v78)];
                    uint64_t v80 = *(void *)v76;
                    if (*(void *)v76 == -1) {
                      goto LABEL_175;
                    }
                  }
                  int v75 = HIDWORD(v104);
                }
              }
              int v85 = v103 == v74 ? v75 : v104;
              if (v76 == &v103[8 * v85]) {
                goto LABEL_192;
              }
            }
          }
          while (v86 != ++v72);
        }
      }
LABEL_181:
      uint64_t v87 = v66 + 1;
      while (v87 != (unint64_t *)v68)
      {
        unint64_t v88 = *v87++;
        unint64_t v69 = v88;
        if (v88 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          int v66 = v87 - 1;
          goto LABEL_135;
        }
      }
      char v67 = 1;
    }
  }
  else
  {
LABEL_192:
    char v67 = 0;
  }
LABEL_193:
  if (v107 != v109) {
    free(v107);
  }
  if (v103 != v102) {
    free(v103);
  }
  if (v67)
  {
    unsigned int v90 = v97;
    uint64_t v89 = v98;
    if (HIDWORD(v99) - v100 == 1)
    {
      if (v98 == v97) {
        uint64_t v91 = HIDWORD(v99);
      }
      else {
        uint64_t v91 = v99;
      }
      uint64_t v92 = (uint64_t *)v98;
      if (v91)
      {
        uint64_t v93 = 8 * v91;
        uint64_t v92 = (uint64_t *)v98;
        uint64_t v94 = (uint64_t *)&v98[8 * v91];
        while ((unint64_t)*v92 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v92;
          v93 -= 8;
          if (!v93)
          {
            uint64_t v92 = v94;
            break;
          }
        }
      }
      uint64_t v95 = *v92;
    }
    else
    {
      uint64_t v95 = 0;
    }
  }
  else
  {
    uint64_t v95 = 0;
    unsigned int v90 = v97;
    uint64_t v89 = v98;
  }
  if (v89 != v90) {
    free(v89);
  }
  return v95;
}

uint64_t llvm::objcarc::ProvenanceAnalysis::relatedPHI(llvm::objcarc::ProvenanceAnalysis *this, const llvm::PHINode *a2, const llvm::Value *a3)
{
  if (!a3 || *((unsigned char *)a3 + 16) != 83) {
    goto LABEL_63;
  }
  if (*((void *)a3 + 5) == *((void *)a2 + 5))
  {
    uint64_t v9 = *((_DWORD *)a2 + 5) & 0x7FFFFFF;
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = 32 * v9 - 32;
      do
      {
        int v13 = *((_DWORD *)a2 + 5);
        if ((v13 & 0x40000000) != 0) {
          uint64_t v14 = (char *)*((void *)a2 - 1);
        }
        else {
          uint64_t v14 = (char *)a2 - 32 * (v13 & 0x7FFFFFF);
        }
        uint64_t v15 = *(const llvm::Value **)&v14[v11];
        uint64_t v16 = (const llvm::Value *)sub_1CBF73380((uint64_t)a3, *(void *)&v14[32 * *((unsigned int *)a2 + 15) + v10]);
        uint64_t v17 = llvm::objcarc::ProvenanceAnalysis::related(this, v15, v16);
        if (v17) {
          break;
        }
        v10 += 8;
        BOOL v32 = v12 == v11;
        v11 += 32;
      }
      while (!v32);
      return v17;
    }
    return 0;
  }
  uint64_t v56 = v60;
  uint64_t v57 = v60;
  uint64_t v58 = 4;
  int v59 = 0;
  int v6 = *((_DWORD *)a3 + 5);
  if ((v6 & 0x40000000) != 0)
  {
    uint64_t v8 = (const llvm::Value **)*((void *)a3 - 1);
    uint64_t v7 = v6 & 0x7FFFFFF;
    if (!v7) {
      return 0;
    }
  }
  else
  {
    uint64_t v7 = v6 & 0x7FFFFFF;
    uint64_t v8 = (const llvm::Value **)((char *)a3 - 32 * v7);
    if (!v7) {
      return 0;
    }
  }
  BOOL v18 = &v8[4 * v7];
  while (1)
  {
    int v19 = *v8;
    uint64_t v20 = v57;
    uint64_t v21 = HIDWORD(v58);
    if (v57 == v56)
    {
      if (HIDWORD(v58))
      {
        uint64_t v22 = 0;
        uint64_t v23 = 8 * HIDWORD(v58);
        uint64_t v24 = (const llvm::Value **)v57;
        do
        {
          if (*v24 == v19) {
            goto LABEL_51;
          }
          if (*v24 == (const llvm::Value *)-2) {
            uint64_t v22 = v24;
          }
          ++v24;
          v23 -= 8;
        }
        while (v23);
        if (v22)
        {
          *uint64_t v22 = v19;
          --v59;
          goto LABEL_50;
        }
      }
      unsigned int v25 = v58;
      if (HIDWORD(v58) < v58)
      {
        ++HIDWORD(v58);
        *(void *)&v57[8 * v21] = v19;
        goto LABEL_50;
      }
    }
    else
    {
      unsigned int v25 = v58;
    }
    if (3 * v25 <= 4 * (HIDWORD(v58) - v59))
    {
      if (v25 >= 0x40) {
        v25 *= 2;
      }
      else {
        unsigned int v25 = 128;
      }
LABEL_58:
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v56, v25);
      unsigned int v25 = v58;
      uint64_t v20 = v57;
      goto LABEL_31;
    }
    if (v25 - HIDWORD(v58) < v25 >> 3) {
      goto LABEL_58;
    }
LABEL_31:
    unsigned int v26 = v25 - 1;
    unsigned int v27 = (v25 - 1) & ((v19 >> 4) ^ (v19 >> 9));
    unsigned int v28 = &v20[8 * v27];
    uint64_t v29 = *(const llvm::Value **)v28;
    if (*(void *)v28 != -1)
    {
      uint64_t v30 = 0;
      int v31 = 1;
      while (v29 != v19)
      {
        if (v30) {
          BOOL v32 = 0;
        }
        else {
          BOOL v32 = v29 == (const llvm::Value *)-2;
        }
        if (v32) {
          uint64_t v30 = (const llvm::Value **)v28;
        }
        unsigned int v33 = v27 + v31++;
        unsigned int v27 = v33 & v26;
        unsigned int v28 = &v20[8 * (v33 & v26)];
        uint64_t v29 = *(const llvm::Value **)v28;
        if (*(void *)v28 == -1) {
          goto LABEL_43;
        }
      }
      goto LABEL_51;
    }
    uint64_t v30 = 0;
LABEL_43:
    if (v30) {
      unsigned int v34 = v30;
    }
    else {
      unsigned int v34 = (const llvm::Value **)v28;
    }
    if (*v34 == v19) {
      goto LABEL_51;
    }
    if (*v34 == (const llvm::Value *)-2) {
      --v59;
    }
    else {
      ++HIDWORD(v58);
    }
    *unsigned int v34 = v19;
LABEL_50:
    if (llvm::objcarc::ProvenanceAnalysis::related(this, v19, a2)) {
      break;
    }
LABEL_51:
    v8 += 4;
    if (v8 == v18)
    {
      if (v57 != v56) {
        free(v57);
      }
      return 0;
    }
  }
  if (v57 != v56) {
    free(v57);
  }
LABEL_63:
  uint64_t v56 = v60;
  uint64_t v57 = v60;
  uint64_t v58 = 4;
  int v59 = 0;
  int v35 = *((_DWORD *)a2 + 5);
  if ((v35 & 0x40000000) == 0)
  {
    uint64_t v36 = v35 & 0x7FFFFFF;
    unsigned int v37 = (const llvm::Value **)((char *)a2 - 32 * v36);
    if (v36) {
      goto LABEL_65;
    }
    return 0;
  }
  unsigned int v37 = (const llvm::Value **)*((void *)a2 - 1);
  uint64_t v36 = v35 & 0x7FFFFFF;
  if (!v36) {
    return 0;
  }
LABEL_65:
  BOOL v38 = &v37[4 * v36];
  while (2)
  {
    unint64_t v39 = *v37;
    uint64_t v40 = v57;
    uint64_t v41 = HIDWORD(v58);
    if (v57 == v56)
    {
      if (HIDWORD(v58))
      {
        uint64_t v42 = 0;
        uint64_t v43 = 8 * HIDWORD(v58);
        unsigned int v44 = (const llvm::Value **)v57;
        while (*v44 != v39)
        {
          if (*v44 == (const llvm::Value *)-2) {
            uint64_t v42 = v44;
          }
          ++v44;
          v43 -= 8;
          if (!v43)
          {
            if (!v42) {
              goto LABEL_74;
            }
            *uint64_t v42 = v39;
            --v59;
            goto LABEL_98;
          }
        }
        goto LABEL_99;
      }
LABEL_74:
      unsigned int v45 = v58;
      if (HIDWORD(v58) < v58)
      {
        ++HIDWORD(v58);
        *(void *)&v57[8 * v41] = v39;
        goto LABEL_98;
      }
    }
    else
    {
      unsigned int v45 = v58;
    }
    if (3 * v45 <= 4 * (HIDWORD(v58) - v59))
    {
      if (v45 >= 0x40) {
        v45 *= 2;
      }
      else {
        unsigned int v45 = 128;
      }
      goto LABEL_106;
    }
    if (v45 - HIDWORD(v58) < v45 >> 3)
    {
LABEL_106:
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v56, v45);
      unsigned int v45 = v58;
      uint64_t v40 = v57;
    }
    unsigned int v46 = v45 - 1;
    unsigned int v47 = (v45 - 1) & ((v39 >> 4) ^ (v39 >> 9));
    uint64_t v48 = &v40[8 * v47];
    uint64_t v49 = *(const llvm::Value **)v48;
    if (*(void *)v48 != -1)
    {
      uint64_t v50 = 0;
      int v51 = 1;
      while (v49 != v39)
      {
        if (v50) {
          BOOL v52 = 0;
        }
        else {
          BOOL v52 = v49 == (const llvm::Value *)-2;
        }
        if (v52) {
          uint64_t v50 = (const llvm::Value **)v48;
        }
        unsigned int v53 = v47 + v51++;
        unsigned int v47 = v53 & v46;
        uint64_t v48 = &v40[8 * (v53 & v46)];
        uint64_t v49 = *(const llvm::Value **)v48;
        if (*(void *)v48 == -1) {
          goto LABEL_91;
        }
      }
      goto LABEL_99;
    }
    uint64_t v50 = 0;
LABEL_91:
    if (v50) {
      int v54 = v50;
    }
    else {
      int v54 = (const llvm::Value **)v48;
    }
    if (*v54 == v39)
    {
LABEL_99:
      v37 += 4;
      if (v37 == v38)
      {
        uint64_t v17 = 0;
        goto LABEL_110;
      }
      continue;
    }
    break;
  }
  if (*v54 == (const llvm::Value *)-2) {
    --v59;
  }
  else {
    ++HIDWORD(v58);
  }
  llvm::Value *v54 = v39;
LABEL_98:
  if ((llvm::objcarc::ProvenanceAnalysis::related(this, v39, a3) & 1) == 0) {
    goto LABEL_99;
  }
  uint64_t v17 = 1;
LABEL_110:
  if (v57 != v56) {
    free(v57);
  }
  return v17;
}

uint64_t sub_1CCC14D98(uint64_t a1)
{
  v33[8] = *MEMORY[0x1E4F143B8];
  unsigned int v25 = (char *)v29;
  unsigned int v26 = (char *)v29;
  int v28 = 0;
  uint64_t v30 = v33;
  unsigned int v32 = 8;
  v33[0] = a1;
  uint64_t v27 = 0x100000008;
  v29[0] = a1;
  unsigned int v1 = 1;
  while (1)
  {
    uint64_t v2 = *((void *)v30 + --v1);
    unsigned int v31 = v1;
    uint64_t v3 = *(void *)(v2 + 8);
    if (v3) {
      break;
    }
LABEL_54:
    if (!v1)
    {
      uint64_t v23 = 0;
      goto LABEL_57;
    }
  }
  while (1)
  {
    uint64_t v4 = *(void *)(v3 + 24);
    int v5 = *(unsigned __int8 *)(v4 + 16);
    if (v5 != 84) {
      break;
    }
LABEL_44:
    uint64_t v3 = *(void *)(v3 + 8);
    if (!v3)
    {
      unsigned int v1 = v31;
      goto LABEL_54;
    }
  }
  if (v5 != 61)
  {
    if (*(unsigned char *)(v2 + 16) == 75) {
      goto LABEL_56;
    }
    uint64_t v8 = v26;
    uint64_t v9 = HIDWORD(v27);
    if (v26 == v25)
    {
      if (HIDWORD(v27))
      {
        uint64_t v10 = 0;
        uint64_t v11 = 8 * HIDWORD(v27);
        uint64_t v12 = v26;
        while (*(void *)v12 != v4)
        {
          if (*(void *)v12 == -2) {
            uint64_t v10 = v12;
          }
          v12 += 8;
          v11 -= 8;
          if (!v11)
          {
            if (!v10) {
              goto LABEL_18;
            }
            *(void *)uint64_t v10 = v4;
            --v28;
            goto LABEL_42;
          }
        }
        goto LABEL_44;
      }
LABEL_18:
      unsigned int v13 = v27;
      if (HIDWORD(v27) < v27)
      {
        ++HIDWORD(v27);
        *(void *)&v26[8 * v9] = v4;
LABEL_42:
        if (v31 >= (unint64_t)v32) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v30 + v31++) = v4;
        goto LABEL_44;
      }
    }
    else
    {
      unsigned int v13 = v27;
    }
    if (3 * v13 <= 4 * (HIDWORD(v27) - v28))
    {
      if (v13 >= 0x40) {
        v13 *= 2;
      }
      else {
        unsigned int v13 = 128;
      }
    }
    else if (v13 - HIDWORD(v27) >= v13 >> 3)
    {
LABEL_23:
      unsigned int v14 = v13 - 1;
      unsigned int v15 = (v13 - 1) & ((v4 >> 4) ^ (v4 >> 9));
      uint64_t v16 = &v8[8 * v15];
      uint64_t v17 = *(void *)v16;
      if (*(void *)v16 != -1)
      {
        BOOL v18 = 0;
        int v19 = 1;
        while (v17 != v4)
        {
          if (v18) {
            BOOL v20 = 0;
          }
          else {
            BOOL v20 = v17 == -2;
          }
          if (v20) {
            BOOL v18 = v16;
          }
          unsigned int v21 = v15 + v19++;
          unsigned int v15 = v21 & v14;
          uint64_t v16 = &v8[8 * (v21 & v14)];
          uint64_t v17 = *(void *)v16;
          if (*(void *)v16 == -1) {
            goto LABEL_35;
          }
        }
        goto LABEL_44;
      }
      BOOL v18 = 0;
LABEL_35:
      if (v18) {
        uint64_t v22 = v18;
      }
      else {
        uint64_t v22 = v16;
      }
      if (*(void *)v22 == v4) {
        goto LABEL_44;
      }
      if (*(void *)v22 == -2) {
        --v28;
      }
      else {
        ++HIDWORD(v27);
      }
      *(void *)uint64_t v22 = v4;
      goto LABEL_42;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)&v25, v13);
    unsigned int v13 = v27;
    uint64_t v8 = v26;
    goto LABEL_23;
  }
  int v6 = *(_DWORD *)(v4 + 20);
  if ((v6 & 0x40000000) != 0) {
    uint64_t v7 = *(void *)(v4 - 8);
  }
  else {
    uint64_t v7 = v4 - 32 * (v6 & 0x7FFFFFF);
  }
  if (((v3 - v7) & 0x1FFFFFFFE0) != 0) {
    goto LABEL_44;
  }
LABEL_56:
  uint64_t v23 = 1;
LABEL_57:
  if (v30 != v33) {
    free(v30);
  }
  if (v26 != v25) {
    free(v26);
  }
  return v23;
}

unint64_t *sub_1CCC15080(unint64_t *result, void *a2)
{
  *BOOL result = 4;
  result[1] = 0;
  unint64_t v2 = a2[2];
  result[2] = v2;
  if (v2 != -8192 && v2 != -4096 && v2 != 0)
  {
    unint64_t v4 = *a2 & 0xFFFFFFFFFFFFFFF8;
    result[1] = *(void *)v4;
    *(void *)unint64_t v4 = result;
    *BOOL result = v4 | 4;
    int v5 = (unint64_t *)result[1];
    if (v5) {
      unint64_t *v5 = *v5 & 7 | (unint64_t)(result + 1);
    }
  }
  result[3] = 6;
  int v6 = result + 3;
  result[4] = 0;
  unint64_t v7 = (unint64_t)(result + 4);
  unint64_t v8 = a2[5];
  result[5] = v8;
  if (v8 != -8192 && v8 != -4096 && v8 != 0)
  {
    unint64_t v10 = a2[3] & 0xFFFFFFFFFFFFFFF8;
    *(void *)unint64_t v7 = *(void *)v10;
    *(void *)unint64_t v10 = v6;
    *int v6 = v10 | 6;
    if (*(void *)v7) {
      **(void **)unint64_t v7 = **(void **)v7 & 7 | v7;
    }
  }
  return result;
}

void llvm::initializePAEvalPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EA61DEC0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CCC151BC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EA61DEC0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CCC151BC(llvm *a1, llvm::PassRegistry *a2)
{
}

void sub_1CCC15264(llvm::Pass *a1)
{
  llvm::Pass::~Pass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCC1529C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1CCC152AC(uint64_t a1, llvm::Function *this)
{
  v72[0] = 0;
  v72[1] = 0;
  int v73 = 0;
  int v75 = 0;
  uint64_t v76 = 0;
  __p = 0;
  if (*((unsigned char *)this + 18))
  {
    llvm::Function::BuildLazyArguments(this);
    uint64_t v4 = *((void *)this + 11);
    if (*((_WORD *)this + 9))
    {
      llvm::Function::BuildLazyArguments(this);
      uint64_t v5 = *((void *)this + 11);
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v4 = *((void *)this + 11);
  }
  uint64_t v5 = v4;
LABEL_4:
  uint64_t v6 = v5 + 40 * *((void *)this + 12);
  while (v4 != v6)
  {
    v67[0] = v4;
    if ((*(unsigned char *)(v4 + 23) & 0x10) != 0) {
      sub_1CBF5F714(v72, v67);
    }
    v4 += 40;
  }
  unint64_t v7 = (char *)this + 72;
  for (uint64_t i = *((void *)this + 10); ; uint64_t i = *(void *)(i + 8))
  {
    if ((char *)i == v7) {
      goto LABEL_36;
    }
    uint64_t v9 = i - 24;
    if (!i) {
      uint64_t v9 = 0;
    }
    uint64_t v10 = *(void *)(v9 + 48);
    if (v10 != v9 + 40) {
      break;
    }
  }
  while (1)
  {
    if (v10) {
      uint64_t v11 = v10 - 24;
    }
    else {
      uint64_t v11 = 0;
    }
    v67[0] = v11;
    int v12 = *(_DWORD *)(v11 + 20);
    if ((v12 & 0x10000000) != 0)
    {
      sub_1CBF5F714(v72, v67);
      int v12 = *(_DWORD *)(v11 + 20);
    }
    if ((v12 & 0x40000000) != 0)
    {
      unsigned int v14 = *(void **)(v11 - 8);
      uint64_t v13 = v12 & 0x7FFFFFF;
      if (!v13) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v13 = v12 & 0x7FFFFFF;
      unsigned int v14 = (void *)(v11 - 32 * v13);
      if (!v13) {
        goto LABEL_28;
      }
    }
    uint64_t v15 = 32 * v13;
    do
    {
      v67[0] = *v14;
      if ((*(unsigned char *)(v67[0] + 23) & 0x10) != 0) {
        sub_1CBF5F714(v72, v67);
      }
      v14 += 4;
      v15 -= 32;
    }
    while (v15);
LABEL_28:
    uint64_t v10 = *(void *)(v10 + 8);
    uint64_t v16 = i - 24;
    if (!i) {
      uint64_t v16 = 0;
    }
    if (v10 == v16 + 40) {
      break;
    }
LABEL_35:
    if ((char *)i == v7) {
      goto LABEL_36;
    }
  }
  while (1)
  {
    uint64_t i = *(void *)(i + 8);
    if ((char *)i == v7) {
      break;
    }
    uint64_t v17 = i - 24;
    if (!i) {
      uint64_t v17 = 0;
    }
    uint64_t v10 = *(void *)(v17 + 48);
    if (v10 != v17 + 40) {
      goto LABEL_35;
    }
  }
LABEL_36:
  uint64_t v18 = 0;
  v67[1] = 0;
  v67[2] = 0;
  int v68 = 0;
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  int v71 = 0;
  int v19 = *(uint64_t **)(a1 + 8);
  uint64_t v20 = *v19;
  uint64_t v21 = v19[1];
  if (v20 != v21)
  {
    while (*(_UNKNOWN **)v20 != &llvm::AAResultsWrapperPass::ID)
    {
      v20 += 16;
      if (v20 == v21)
      {
        uint64_t v18 = 0;
        goto LABEL_41;
      }
    }
    uint64_t v18 = *(void *)(v20 + 8);
  }
LABEL_41:
  uint64_t v22 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v18 + 96))(v18, &llvm::AAResultsWrapperPass::ID);
  uint64_t v24 = (const llvm::Value **)__p;
  uint64_t v23 = v75;
  int v66 = v75;
  v67[0] = *(void *)(v22 + 32);
  while (2)
  {
    if (v24 != v23)
    {
      unsigned int v25 = *v24;
      if ((*((unsigned char *)*v24 + 23) & 0x10) != 0)
      {
        uint64_t v26 = ***(void ***)v25;
        uint64_t v27 = *(void *)(v26 + 152);
        uint64_t v28 = *(unsigned int *)(v26 + 168);
        if (!v28) {
          goto LABEL_50;
        }
        LODWORD(v29) = (v28 - 1) & ((v25 >> 4) ^ (v25 >> 9));
        uint64_t v30 = (const llvm::Value **)(v27 + 16 * v29);
        unsigned int v31 = *v30;
        if (*v30 != v25)
        {
          int v32 = 1;
          while (v31 != (const llvm::Value *)-4096)
          {
            int v33 = v29 + v32++;
            uint64_t v29 = v33 & (v28 - 1);
            unsigned int v31 = *(const llvm::Value **)(v27 + 16 * v29);
            if (v31 == v25)
            {
              uint64_t v30 = (const llvm::Value **)(v27 + 16 * v29);
              goto LABEL_51;
            }
          }
LABEL_50:
          uint64_t v30 = (const llvm::Value **)(v27 + 16 * v28);
        }
LABEL_51:
        unsigned int v34 = v30[1];
        size_t v37 = *(void *)v34;
        uint64_t v36 = (char *)v34 + 16;
        size_t v35 = v37;
        if (v37)
        {
          if (*v36 == 1)
          {
            uint64_t v36 = (char *)v30[1] + 17;
            size_t v38 = v35 - 1;
          }
          else
          {
            size_t v38 = v35;
          }
        }
        else
        {
          size_t v38 = 0;
        }
      }
      else
      {
        size_t v38 = 0;
        uint64_t v36 = &byte_1CFBCE98E;
      }
      unint64_t v39 = (const llvm::Value **)__p;
      uint64_t v40 = v75;
LABEL_57:
      if (v39 == v40)
      {
        ++v24;
        uint64_t v23 = v66;
        continue;
      }
      uint64_t v41 = *v39;
      if ((*((unsigned char *)*v39 + 23) & 0x10) != 0)
      {
        uint64_t v42 = ***(void ***)v41;
        uint64_t v43 = *(void *)(v42 + 152);
        uint64_t v44 = *(unsigned int *)(v42 + 168);
        if (!v44) {
          goto LABEL_65;
        }
        LODWORD(v45) = (v44 - 1) & ((v41 >> 4) ^ (v41 >> 9));
        unsigned int v46 = (const llvm::Value **)(v43 + 16 * v45);
        unsigned int v47 = *v46;
        if (*v46 != v41)
        {
          int v48 = 1;
          while (v47 != (const llvm::Value *)-4096)
          {
            int v49 = v45 + v48++;
            uint64_t v45 = v49 & (v44 - 1);
            unsigned int v47 = *(const llvm::Value **)(v43 + 16 * v45);
            if (v47 == v41)
            {
              unsigned int v46 = (const llvm::Value **)(v43 + 16 * v45);
              goto LABEL_66;
            }
          }
LABEL_65:
          unsigned int v46 = (const llvm::Value **)(v43 + 16 * v44);
        }
LABEL_66:
        uint64_t v50 = v46[1];
        size_t v53 = *(void *)v50;
        BOOL v52 = (char *)v50 + 16;
        size_t v51 = v53;
        if (v53 && *v52 == 1)
        {
          BOOL v52 = (char *)v46[1] + 17;
          --v51;
        }
      }
      else
      {
        size_t v51 = 0;
        BOOL v52 = &byte_1CFBCE98E;
      }
      if (v51 >= v38) {
        size_t v54 = v38;
      }
      else {
        size_t v54 = v51;
      }
      if (v54 && (uint64_t v22 = memcmp(v36, v52, v54), v22))
      {
        if ((v22 & 0x80000000) != 0)
        {
LABEL_78:
          unint64_t v55 = (llvm::raw_ostream *)llvm::errs((llvm *)v22);
          uint64_t v56 = (unsigned char *)*((void *)v55 + 4);
          if (v38 <= *((void *)v55 + 3) - (void)v56)
          {
            if (v38)
            {
              memcpy(v56, v36, v38);
              uint64_t v56 = (unsigned char *)(*((void *)v55 + 4) + v38);
              *((void *)v55 + 4) = v56;
            }
          }
          else
          {
            llvm::raw_ostream::write(v55, v36, v38);
            uint64_t v56 = (unsigned char *)*((void *)v55 + 4);
          }
          if (*((void *)v55 + 3) - (void)v56 > 4uLL)
          {
            v56[4] = 32;
            *(_DWORD *)uint64_t v56 = 1684955424;
            uint64_t v57 = (void *)(*((void *)v55 + 4) + 5);
            *((void *)v55 + 4) = v57;
          }
          else
          {
            llvm::raw_ostream::write(v55, " and ", 5uLL);
            uint64_t v57 = (void *)*((void *)v55 + 4);
          }
          if (v51 <= *((void *)v55 + 3) - (void)v57)
          {
            if (v51)
            {
              memcpy(v57, v52, v51);
              *((void *)v55 + 4) += v51;
            }
          }
          else
          {
            llvm::raw_ostream::write(v55, v52, v51);
          }
          BOOL v58 = llvm::objcarc::ProvenanceAnalysis::related((llvm::objcarc::ProvenanceAnalysis *)v67, v25, v41);
          BOOL v59 = v58;
          uint64_t v22 = (uint64_t)llvm::errs((llvm *)v58);
          uint64_t v60 = *(_WORD **)(v22 + 32);
          unint64_t v61 = *(void *)(v22 + 24) - (void)v60;
          if (v59)
          {
            if (v61 <= 0xD)
            {
              uint64_t v62 = " are related.\n";
              size_t v63 = 14;
              goto LABEL_93;
            }
            qmemcpy(v60, " are related.\n", 14);
            uint64_t v64 = *(void *)(v22 + 32) + 14;
LABEL_98:
            *(void *)(v22 + 32) = v64;
          }
          else
          {
            if (v61 > 0x11)
            {
              v60[8] = 2606;
              *(_OWORD *)uint64_t v60 = *(_OWORD *)" are not related.\n";
              uint64_t v64 = *(void *)(v22 + 32) + 18;
              goto LABEL_98;
            }
            uint64_t v62 = " are not related.\n";
            size_t v63 = 18;
LABEL_93:
            uint64_t v22 = (uint64_t)llvm::raw_ostream::write((llvm::raw_ostream *)v22, v62, v63);
          }
        }
      }
      else if (v38 < v51)
      {
        goto LABEL_78;
      }
      ++v39;
      goto LABEL_57;
    }
    break;
  }
  sub_1CD6C121C((uint64_t)v67);
  if (__p)
  {
    int v75 = (const llvm::Value **)__p;
    operator delete(__p);
  }
  MEMORY[0x1D25D9CD0](v72[0], 8);
  return 0;
}

void sub_1CCC15848()
{
}

void *llvm::objcarc::RRInfo::clear(llvm::objcarc::RRInfo *this)
{
  *(_WORD *)this = 0;
  *((void *)this + 1) = 0;
  unint64_t v2 = (void **)((char *)this + 16);
  uint64_t v3 = (void *)*((void *)this + 2);
  uint64_t v4 = (void *)*((void *)this + 3);
  if (v4 == v3) {
    goto LABEL_2;
  }
  uint64_t v6 = *((unsigned int *)this + 8);
  if (v6 < 0x21 || 4 * (*((_DWORD *)this + 9) - *((_DWORD *)this + 10)) >= v6)
  {
    memset(v4, 255, 8 * v6);
LABEL_2:
    *((_DWORD *)this + 9) = 0;
    *((_DWORD *)this + 10) = 0;
    goto LABEL_3;
  }
  llvm::SmallPtrSetImplBase::shrink_and_clear(v2);
LABEL_3:
  BOOL result = (void *)*((void *)this + 9);
  if (result != *((void **)this + 8))
  {
    uint64_t v8 = *((unsigned int *)this + 20);
    if (v8 >= 0x21 && 4 * (*((_DWORD *)this + 21) - *((_DWORD *)this + 22)) < v8)
    {
      BOOL result = llvm::SmallPtrSetImplBase::shrink_and_clear((void **)this + 8);
      goto LABEL_5;
    }
    BOOL result = memset(result, 255, 8 * v8);
  }
  *((_DWORD *)this + 21) = 0;
  *((_DWORD *)this + 22) = 0;
LABEL_5:
  *((unsigned char *)this + 112) = 0;
  return result;
}

unsigned char *llvm::objcarc::PtrState::SetKnownPositiveRefCount(unsigned char *this)
{
  *this = 1;
  return this;
}

unsigned char *llvm::objcarc::PtrState::ClearKnownPositiveRefCount(unsigned char *this)
{
  *this = 0;
  return this;
}

uint64_t llvm::objcarc::PtrState::SetSeq(uint64_t result, char a2)
{
  *(unsigned char *)(result + 2) = a2;
  return result;
}

uint64_t llvm::objcarc::PtrState::Merge(llvm::objcarc::PtrState *this, const llvm::objcarc::PtrState *a2, int a3)
{
  int v4 = *((unsigned __int8 *)this + 2);
  int v5 = *((unsigned __int8 *)a2 + 2);
  if (v4 != v5)
  {
    if (*((unsigned char *)this + 2)) {
      BOOL v6 = v5 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6) {
      goto LABEL_30;
    }
    if (v4 >= v5) {
      int v7 = *((unsigned __int8 *)a2 + 2);
    }
    else {
      int v7 = *((unsigned __int8 *)this + 2);
    }
    if (v4 <= v5) {
      int v8 = *((unsigned __int8 *)a2 + 2);
    }
    else {
      int v8 = *((unsigned __int8 *)this + 2);
    }
    if (a3)
    {
      BOOL v9 = (v7 - 1) <= 1 && (v8 & 0xFE) == 2;
      LOBYTE(v7) = v8;
      if (!v9)
      {
LABEL_30:
        *((unsigned char *)this + 2) = 0;
        *(unsigned char *)this &= *(unsigned char *)a2;
LABEL_31:
        int v12 = (void **)((char *)this + 24);
        uint64_t v13 = (void *)*((void *)this + 3);
        *((unsigned char *)this + 1) = 0;
        goto LABEL_36;
      }
    }
    else if ((v7 & 0xFE) != 2 || (v8 - 3) >= 3)
    {
      if (v7 != 4 || v8 != 5) {
        goto LABEL_30;
      }
      LOBYTE(v7) = 4;
    }
    *((unsigned char *)this + 2) = v7;
    *(unsigned char *)this &= *(unsigned char *)a2;
    goto LABEL_34;
  }
  *(unsigned char *)this &= *(unsigned char *)a2;
  if (!v4) {
    goto LABEL_31;
  }
LABEL_34:
  if (*((unsigned __int8 *)this + 1) | *((unsigned __int8 *)a2 + 1))
  {
    int v12 = (void **)((char *)this + 24);
    uint64_t v13 = (void *)*((void *)this + 3);
    *(_WORD *)((char *)this + 1) = 0;
LABEL_36:
    *((_WORD *)v12 - 8) = 0;
    *(v12 - 1) = 0;
    if (v12[1] != v13)
    {
      uint64_t v15 = *((unsigned int *)this + 10);
      if (v15 >= 0x21 && 4 * (*((_DWORD *)this + 11) - *((_DWORD *)this + 12)) < v15)
      {
        llvm::SmallPtrSetImplBase::shrink_and_clear(v12);
LABEL_38:
        uint64_t result = *((void *)this + 10);
        if (result != *((void *)this + 9))
        {
          uint64_t v16 = *((unsigned int *)this + 22);
          if (v16 >= 0x21 && 4 * (*((_DWORD *)this + 23) - *((_DWORD *)this + 24)) < v16)
          {
            uint64_t result = (uint64_t)llvm::SmallPtrSetImplBase::shrink_and_clear((void **)this + 9);
            goto LABEL_40;
          }
          uint64_t result = (uint64_t)memset((void *)result, 255, 8 * v16);
        }
        *((_DWORD *)this + 23) = 0;
        *((_DWORD *)this + 24) = 0;
LABEL_40:
        *((unsigned char *)this + 120) = 0;
        return result;
      }
      memset(v12[1], 255, 8 * v15);
    }
    *((_DWORD *)this + 11) = 0;
    *((_DWORD *)this + 12) = 0;
    goto LABEL_38;
  }
  uint64_t result = llvm::objcarc::RRInfo::Merge((llvm::objcarc::PtrState *)((char *)this + 8), (const llvm::objcarc::PtrState *)((char *)a2 + 8));
  *((unsigned char *)this + 1) = result;
  return result;
}

char *sub_1CCC15D0C(void **a1, char a2)
{
  uint64_t v3 = *a1;
  *((unsigned char *)*a1 + 2) = a2;
  uint64_t v4 = *a1[1];
  if (*(unsigned char *)(v4 + 16) == 33)
  {
    uint64_t v5 = *a1[2];
    BOOL v6 = (uint64_t *)(v5 + 40);
    for (uint64_t i = *(void *)(v5 + 48); ; uint64_t i = *(void *)(i + 8))
    {
      if ((uint64_t *)i == v6) {
        goto LABEL_15;
      }
      uint64_t v8 = i - 24;
      if (!i) {
        uint64_t v8 = 0;
      }
      if (*(unsigned char *)(v8 + 16) != 83) {
        break;
      }
    }
    unsigned int v9 = *(unsigned __int8 *)(i - 8) - 38;
    BOOL v10 = v9 > 0x38;
    uint64_t v11 = (1 << v9) & 0x100060000000001;
    if (!v10 && v11 != 0) {
      uint64_t i = *(void *)(i + 8);
    }
    if (v6 == (uint64_t *)i) {
LABEL_15:
    }
      uint64_t i = *v6;
    uint64_t v13 = i - 24;
    if (!i) {
      uint64_t v13 = 0;
    }
    if (*(unsigned char *)(v13 + 16) == 38) {
      v3[120] = 1;
    }
  }
  else
  {
    uint64_t i = *(void *)(v4 + 32);
    uint64_t v5 = *a1[2];
  }
  if (i != v5 + 40) {
    uint64_t i = llvm::skipDebugIntrinsics(i);
  }
  if (i) {
    uint64_t v14 = i - 24;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *((void *)v3 + 10);
  uint64_t v16 = *((unsigned int *)v3 + 23);
  if (v15 != *((void *)v3 + 9))
  {
    unsigned int v20 = *((_DWORD *)v3 + 22);
    goto LABEL_36;
  }
  if (!v16)
  {
LABEL_33:
    unsigned int v20 = *((_DWORD *)v3 + 22);
    if (v16 < v20)
    {
      *((_DWORD *)v3 + 23) = v16 + 1;
      *(void *)(v15 + 8 * v16) = v14;
      goto LABEL_57;
    }
LABEL_36:
    if (3 * v20 <= 4 * ((int)v16 - *((_DWORD *)v3 + 24)))
    {
      if (v20 >= 0x40) {
        v20 *= 2;
      }
      else {
        unsigned int v20 = 128;
      }
    }
    else if (v20 - v16 >= v20 >> 3)
    {
      goto LABEL_38;
    }
    llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(v3 + 72), v20);
    unsigned int v20 = *((_DWORD *)v3 + 22);
    uint64_t v15 = *((void *)v3 + 10);
LABEL_38:
    unsigned int v21 = v20 - 1;
    unsigned int v22 = (v20 - 1) & ((v14 >> 4) ^ (v14 >> 9));
    uint64_t v23 = (uint64_t *)(v15 + 8 * v22);
    uint64_t v24 = *v23;
    if (*v23 == -1)
    {
      unsigned int v25 = 0;
LABEL_50:
      if (v25) {
        uint64_t v29 = v25;
      }
      else {
        uint64_t v29 = v23;
      }
      if (*v29 != v14)
      {
        if (*v29 == -2) {
          --*((_DWORD *)v3 + 24);
        }
        else {
          ++*((_DWORD *)v3 + 23);
        }
        uint64_t *v29 = v14;
      }
    }
    else
    {
      unsigned int v25 = 0;
      int v26 = 1;
      while (v24 != v14)
      {
        if (v25) {
          BOOL v27 = 0;
        }
        else {
          BOOL v27 = v24 == -2;
        }
        if (v27) {
          unsigned int v25 = v23;
        }
        unsigned int v28 = v22 + v26++;
        unsigned int v22 = v28 & v21;
        uint64_t v23 = (uint64_t *)(v15 + 8 * (v28 & v21));
        uint64_t v24 = *v23;
        if (*v23 == -1) {
          goto LABEL_50;
        }
      }
    }
    goto LABEL_57;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 8 * v16;
  int v19 = (uint64_t *)*((void *)v3 + 10);
  while (*v19 != v14)
  {
    if (*v19 == -2) {
      uint64_t v17 = v19;
    }
    ++v19;
    v18 -= 8;
    if (!v18)
    {
      if (!v17) {
        goto LABEL_33;
      }
      *uint64_t v17 = v14;
      --*((_DWORD *)v3 + 24);
      break;
    }
  }
LABEL_57:
  uint64_t result = (char *)*a1[1];
  unsigned int v31 = result[16] - 33;
  BOOL v10 = v31 > 0x33;
  uint64_t v32 = (1 << v31) & 0x8000000000041;
  BOOL v33 = v10 || v32 == 0;
  if (!v33 && *(unsigned char *)(**(void **)(*((void *)result + 9) + 16) + 8) != 7)
  {
    uint64_t result = sub_1CC233A58(result, 6, v34);
    if (v35) {
      v3[120] = 1;
    }
  }
  return result;
}

uint64_t llvm::objcarc::TopDownPtrState::HandlePotentialAlterRefCount(uint64_t a1, uint64_t a2, const llvm::Value *a3, uint64_t *a4, int a5, uint64_t *a6)
{
  uint64_t result = llvm::objcarc::CanDecrementRefCount(a5);
  if (result) {
    uint64_t result = llvm::objcarc::CanAlterRefCount(a2, a3, a4, a5);
  }
  if (a5 == 20 || result)
  {
    uint64_t result = 0;
    *(unsigned char *)a1 = 0;
    if (*(unsigned char *)(a1 + 2) == 1)
    {
      uint64_t v13 = *(void *)(a1 + 72);
      *(unsigned char *)(a1 + 2) = 2;
      uint64_t v14 = *(void *)(a1 + 80);
      uint64_t v15 = *(unsigned int *)(a1 + 92);
      if (v14 == v13)
      {
        if (v15)
        {
          uint64_t v16 = 0;
          uint64_t v17 = 8 * v15;
          uint64_t v18 = *(uint64_t **)(a1 + 80);
          while (*v18 != a2)
          {
            if (*v18 == -2) {
              uint64_t v16 = v18;
            }
            ++v18;
            v17 -= 8;
            if (!v17)
            {
              if (!v16) {
                goto LABEL_14;
              }
              *uint64_t v16 = a2;
              --*(_DWORD *)(a1 + 96);
              goto LABEL_38;
            }
          }
          goto LABEL_38;
        }
LABEL_14:
        unsigned int v19 = *(_DWORD *)(a1 + 88);
        if (v15 < v19)
        {
          *(_DWORD *)(a1 + 92) = v15 + 1;
          *(void *)(v14 + 8 * v15) = a2;
LABEL_38:
          uint64_t result = 1;
          if (a2 && *(unsigned char *)(a2 + 16) == 84)
          {
            uint64_t v30 = 0;
            uint64_t v31 = a2;
            int v29 = sub_1CD3C8538(a6, &v31, &v30);
            uint64_t result = 1;
            if (v29) {
              *(unsigned char *)(a1 + 120) = 1;
            }
          }
          return result;
        }
      }
      else
      {
        unsigned int v19 = *(_DWORD *)(a1 + 88);
      }
      if (3 * v19 <= 4 * ((int)v15 - *(_DWORD *)(a1 + 96)))
      {
        if (v19 >= 0x40) {
          v19 *= 2;
        }
        else {
          unsigned int v19 = 128;
        }
      }
      else if (v19 - v15 >= v19 >> 3)
      {
        goto LABEL_19;
      }
      llvm::SmallPtrSetImplBase::Grow((llvm::SmallPtrSetImplBase *)(a1 + 72), v19);
      unsigned int v19 = *(_DWORD *)(a1 + 88);
      uint64_t v14 = *(void *)(a1 + 80);
LABEL_19:
      unsigned int v20 = v19 - 1;
      unsigned int v21 = (v19 - 1) & ((a2 >> 4) ^ (a2 >> 9));
      unsigned int v22 = (uint64_t *)(v14 + 8 * v21);
      uint64_t v23 = *v22;
      if (*v22 == -1)
      {
        uint64_t v24 = 0;
LABEL_31:
        if (v24) {
          unsigned int v28 = v24;
        }
        else {
          unsigned int v28 = v22;
        }
        if (*v28 != a2)
        {
          if (*v28 == -2) {
            --*(_DWORD *)(a1 + 96);
          }
          else {
            ++*(_DWORD *)(a1 + 92);
          }
          uint64_t *v28 = a2;
        }
      }
      else
      {
        uint64_t v24 = 0;
        int v25 = 1;
        while (v23 != a2)
        {
          if (v24) {
            BOOL v26 = 0;
          }
          else {
            BOOL v26 = v23 == -2;
          }
          if (v26) {
            uint64_t v24 = v22;
          }
          unsigned int v27 = v21 + v25++;
          unsigned int v21 = v27 & v20;
          unsigned int v22 = (uint64_t *)(v14 + 8 * (v27 & v20));
          uint64_t v23 = *v22;
          if (*v22 == -1) {
            goto LABEL_31;
          }
        }
      }
      goto LABEL_38;
    }
  }
  return result;
}

void *llvm::object::CommonArchiveMemberHeader<llvm::object::UnixArMemHdrType>::CommonArchiveMemberHeader(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = &unk_1F26325B8;
  result[1] = a2;
  result[2] = a3;
  return result;
}

void *llvm::object::CommonArchiveMemberHeader<llvm::object::BigArMemHdrType>::CommonArchiveMemberHeader(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = &unk_1F2632638;
  result[1] = a2;
  result[2] = a3;
  return result;
}

void sub_1CCC16254(int a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  (*(void (**)(void *__return_ptr, void *, uint64_t))(*a2 + 64))(v19, a2, a4);
  if (v20)
  {
    uint64_t v8 = (void *)v19[0];
    v19[0] = 0;
    int v12 = v8;
    sub_1CD4515D0(&v12);
    if (v12) {
      (*(void (**)(void *))(*v12 + 8))(v12);
    }
    uint64_t v11 = a3 - *(void *)(a2[1] + 16);
    __int16 v16 = 773;
    uint64_t v13 = "remaining size of archive too small for next archive member header ";
    uint64_t v14 = 67;
    uint64_t v15 = "at offset ";
    v9[0] = &v13;
    v9[2] = &v11;
    __int16 v10 = 3074;
    int v7 = (llvm::Twine *)v9;
  }
  else
  {
    __int16 v16 = 773;
    uint64_t v13 = "remaining size of archive too small for next archive member header ";
    uint64_t v14 = 67;
    uint64_t v15 = "for ";
    v17[0] = &v13;
    v17[2] = v19[0];
    void v17[3] = v19[1];
    __int16 v18 = 1282;
    int v7 = (llvm::Twine *)v17;
  }
  sub_1CCC16404(a1, v7);
}

void sub_1CCC16404(int a1, llvm::Twine *this)
{
  llvm::Twine::str(this, &v6);
  unint64_t v2 = std::string::insert(&v6, 0, "truncated or malformed archive (");
  std::string::size_type v3 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  uint64_t v4 = std::string::append(&v9, ")");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  std::string::size_type v8 = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
  operator new();
}

uint64_t *getArchiveMemberOctField@<X0>(uint64_t *result@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  int v7 = result;
  if (!a3)
  {
LABEL_13:
    uint64_t v34 = (*(uint64_t (**)(uint64_t))(*(void *)a4 + 80))(a4);
    int v16 = *((unsigned __int8 *)v7 + 32);
    if (*((unsigned char *)v7 + 32))
    {
      if (v16 == 1)
      {
        uint64_t v17 = "characters in ";
        v23[0] = "characters in ";
        __int16 v24 = 259;
        char v18 = 3;
      }
      else
      {
        uint64_t v21 = (uint64_t *)*v7;
        uint64_t v22 = v7[1];
        char v18 = 2;
        if (*((unsigned char *)v7 + 33) != 1)
        {
          LOBYTE(v16) = 2;
          uint64_t v21 = v7;
        }
        v23[0] = "characters in ";
        v23[2] = v21;
        v23[3] = v22;
        LOBYTE(v24) = 3;
        HIBYTE(v24) = v16;
        uint64_t v17 = (const char *)v23;
      }
      v25[0] = v17;
      v25[2] = " field in archive member header are not all octal numbers: '";
      LOBYTE(v26) = v18;
      HIBYTE(v26) = 3;
      v27[0] = v25;
      v27[2] = a2;
      v27[3] = a3;
      __int16 v28 = 1282;
      v29[0] = v27;
      v29[2] = "' for the archive member header at offset ";
      __int16 v30 = 770;
      char v20 = 12;
      char v19 = 2;
      v31[0] = v29;
      v31[2] = &v34;
    }
    else
    {
      char v19 = 0;
      __int16 v24 = 256;
      __int16 v26 = 256;
      __int16 v28 = 256;
      __int16 v30 = 256;
      char v20 = 1;
    }
    char v32 = v19;
    char v33 = v20;
    sub_1CCC16404(a5, (llvm::Twine *)v31);
  }
  unint64_t v9 = 0;
  __int16 v10 = a2;
  uint64_t v11 = a3;
  do
  {
    int v12 = *v10;
    if ((v12 - 48) >= 0xA)
    {
      if ((v12 - 97) >= 0x1A)
      {
        if ((v12 - 65) > 0x19) {
          goto LABEL_13;
        }
        int v13 = -55;
      }
      else
      {
        int v13 = -87;
      }
    }
    else
    {
      int v13 = -48;
    }
    unsigned int v14 = v13 + v12;
    if (v14 > 7) {
      goto LABEL_13;
    }
    unint64_t v15 = 8 * v9 + v14;
    if (v9 > v15 >> 3) {
      goto LABEL_13;
    }
    ++v10;
    unint64_t v9 = v15;
    --v11;
  }
  while (v11);
  *(unsigned char *)(a5 + 8) &= ~1u;
  *(void *)a5 = v15;
  return result;
}

uint64_t *llvm::object::AbstractArchiveMemberHeader::getAccessMode@<X0>(llvm::object::AbstractArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = "AccessMode";
  __int16 v10 = 259;
  uint64_t v4 = (unsigned __int8 *)(*(uint64_t (**)(llvm::object::AbstractArchiveMemberHeader *))(*(void *)this + 32))(this);
  uint64_t result = getArchiveMemberOctField((uint64_t *)&v9, v4, v5, (uint64_t)this, (uint64_t)&v11);
  if (v12)
  {
    uint64_t v8 = v11;
    *(unsigned char *)(a2 + 8) |= 1u;
    *(void *)a2 = v8;
  }
  else
  {
    int v7 = v11;
    *(unsigned char *)(a2 + 8) &= ~1u;
    *(_DWORD *)a2 = v7;
  }
  return result;
}

uint64_t llvm::object::AbstractArchiveMemberHeader::getLastModified@<X0>(llvm::object::AbstractArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = "LastModified";
  __int16 v10 = 259;
  uint64_t v4 = (unsigned __int8 *)(*(uint64_t (**)(llvm::object::AbstractArchiveMemberHeader *))(*(void *)this + 40))(this);
  uint64_t result = getArchiveMemberDecField((uint64_t *)&v9, v4, v5, (uint64_t)this, (uint64_t)&__t);
  if (v12)
  {
    time_t v7 = __t;
    char v8 = *(unsigned char *)(a2 + 8) | 1;
  }
  else
  {
    uint64_t result = std::chrono::system_clock::from_time_t(__t).__d_.__rep_;
    time_t v7 = result / 1000000;
    char v8 = *(unsigned char *)(a2 + 8) & 0xFE;
  }
  *(unsigned char *)(a2 + 8) = v8;
  *(void *)a2 = v7;
  return result;
}

unsigned __int8 *llvm::object::AbstractArchiveMemberHeader::getUID@<X0>(llvm::object::AbstractArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (unsigned __int8 *)(*(uint64_t (**)(llvm::object::AbstractArchiveMemberHeader *))(*(void *)this + 48))(this);
  if (v5)
  {
    time_t v7 = "UID";
    __int16 v8 = 259;
    uint64_t result = (unsigned __int8 *)getArchiveMemberDecField((uint64_t *)&v7, result, v5, (uint64_t)this, (uint64_t)&v9);
    char v6 = v10;
    *(unsigned char *)(a2 + 8) = *(unsigned char *)(a2 + 8) & 0xFE | v10 & 1;
    if (v6) {
      *(void *)a2 = v9;
    }
    else {
      *(_DWORD *)a2 = v9;
    }
  }
  else
  {
    *(unsigned char *)(a2 + 8) &= ~1u;
    *(_DWORD *)a2 = 0;
  }
  return result;
}

unsigned __int8 *llvm::object::AbstractArchiveMemberHeader::getGID@<X0>(llvm::object::AbstractArchiveMemberHeader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t result = (unsigned __int8 *)(*(uint64_t (**)(llvm::object::AbstractArchiveMemberHeader *))(*(void *)this + 56))(this);
  if (v5)
  {
    time_t v7 = "GID";
    __int16 v8 = 259;
    uint64_t result = (unsigned __int8 *)getArchiveMemberDecField((uint64_t *)&v7, result, v5, (uint64_t)this, (uint64_t)&v9);
    char v6 = v10;
    *(unsigned char *)(a2 + 8) = *(unsigned char *)(a2 + 8) & 0xFE | v10 & 1;
    if (v6) {
      *(void *)a2 = v9;
    }
    else {
      *(_DWORD *)a2 = v9;
    }
  }
  else
  {
    *(unsigned char *)(a2 + 8) &= ~1u;
    *(_DWORD *)a2 = 0;
  }
  return result;
}

uint64_t llvm::object::Archive::Child::isThinMember(llvm::object::Archive::Child *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 96))();
}

uint64_t llvm::object::Archive::Child::getRawSize(llvm::object::Archive::Child *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 72))();
}

uint64_t llvm::object::Archive::Child::getSize@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  if ((*(unsigned char *)(*(void *)this + 98) & 8) != 0) {
    return (*(uint64_t (**)(void))(**(void **)(this + 8) + 72))();
  }
  uint64_t v2 = *(void *)(this + 24) - *(unsigned __int16 *)(this + 32);
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(void *)a2 = v2;
  return this;
}

uint64_t llvm::object::Archive::Child::getChildOffset(llvm::object::Archive::Child *this)
{
  return *((void *)this + 2) - *(void *)(*(void *)this + 16);
}

void llvm::object::Archive::Child::getAsBinary(llvm::object::Archive::Child *this@<X0>, llvm::LLVMContext *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  llvm::object::Archive::Child::getMemoryBufferRef(this, (uint64_t)v9);
  if (v10)
  {
    uint64_t v5 = *(void *)&v9[0];
LABEL_6:
    *(unsigned char *)(a3 + 8) |= 1u;
    goto LABEL_7;
  }
  v6[0] = v9[0];
  v6[1] = v9[1];
  llvm::object::createBinary((uint64_t)v6, (uint64_t)a2, 1, (uint64_t)&v7);
  if (v8)
  {
    uint64_t v5 = v7;
    goto LABEL_6;
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  uint64_t v5 = v7;
LABEL_7:
  *(void *)a3 = v5;
}

uint64_t llvm::object::Archive::getArchiveMagicLen(llvm::object::Archive *this)
{
  return 8;
}

__n128 llvm::object::Archive::setFirstRegular(__n128 *this, __n128 *a2)
{
  __n128 result = a2[1];
  this[5] = result;
  this[6].n128_u16[0] = a2[2].n128_u16[0];
  return result;
}

BOOL llvm::object::Archive::isEmpty(llvm::object::Archive *this)
{
  return *((void *)this + 3) == 8;
}

uint64_t llvm::object::Archive::Symbol::getName(llvm::object::Archive::Symbol *this)
{
  uint64_t v1 = *(void *)(*(void *)this + 48);
  uint64_t v2 = v1 + *((unsigned int *)this + 3);
  if (v1) {
    strlen((const char *)(v1 + *((unsigned int *)this + 3)));
  }
  return v2;
}

llvm::object::Archive *llvm::object::Archive::symbol_end(llvm::object::Archive *this)
{
  return this;
}

char *sub_1CCC16D34(char **a1, void *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  uint64_t v21 = a1 + 2;
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    char v8 = (char *)operator new(8 * v7);
  }
  else
  {
    char v8 = 0;
  }
  uint64_t v9 = &v8[8 * v2];
  char v10 = &v8[8 * v7];
  *(void *)uint64_t v9 = *a2;
  uint64_t v11 = v9 + 8;
  *a2 = 0;
  v19.i64[1] = (uint64_t)(v9 + 8);
  char v20 = v10;
  uint64_t v13 = *a1;
  char v12 = a1[1];
  if (v12 == *a1)
  {
    int64x2_t v15 = vdupq_n_s64((unint64_t)v12);
  }
  else
  {
    do
    {
      uint64_t v14 = *((void *)v12 - 1);
      v12 -= 8;
      *(void *)char v12 = 0;
      *((void *)v9 - 1) = v14;
      v9 -= 8;
    }
    while (v12 != v13);
    int64x2_t v15 = *(int64x2_t *)a1;
    uint64_t v11 = (char *)v19.i64[1];
    char v10 = v20;
  }
  *a1 = v9;
  a1[1] = v11;
  int64x2_t v19 = v15;
  int v16 = a1[2];
  a1[2] = v10;
  char v20 = v16;
  uint64_t v18 = v15.i64[0];
  sub_1CCB8F094((uint64_t)&v18);
  return v11;
}

void sub_1CCC16E40()
{
}

uint64_t llvm::NewArchiveMember::NewArchiveMember(uint64_t a1, _OWORD *a2)
{
  long long v4 = a2[1];
  v6[0] = *a2;
  v6[1] = v4;
  llvm::MemoryBuffer::getMemBuffer((uint64_t *)v6, (void *)a1);
  *(_OWORD *)(a1 + 8) = a2[1];
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 420;
  return a1;
}

{
  long long v4;
  _OWORD v6[2];

  long long v4 = a2[1];
  v6[0] = *a2;
  v6[1] = v4;
  llvm::MemoryBuffer::getMemBuffer((uint64_t *)v6, (void *)a1);
  *(_OWORD *)(a1 + 8) = a2[1];
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 420;
  return a1;
}

void llvm::NewArchiveMember::getOldMember(llvm::object::AbstractArchiveMemberHeader **this@<X0>, const llvm::object::Archive::Child *a2@<X1>, uint64_t a3@<X8>)
{
  char v3 = (char)a2;
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  llvm::object::Archive::Child::getMemoryBufferRef((llvm::object::Archive::Child *)this, (uint64_t)v26);
  if (v27)
  {
    uint64_t v6 = *(void *)&v26[0];
    *(unsigned char *)(a3 + 48) |= 1u;
    *(void *)a3 = v6;
    return;
  }
  v17[0] = v26[0];
  v17[1] = v26[1];
  llvm::MemoryBuffer::getMemBuffer((uint64_t *)v17, &v24);
  uint64_t v7 = v24;
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 16))(v24);
  uint64_t v10 = v9;
  if (v3)
  {
    uint64_t v11 = 0;
    int v12 = 0;
    int v13 = 0;
    int v14 = 420;
LABEL_6:
    *(unsigned char *)(a3 + 48) &= ~1u;
    *(void *)a3 = v7;
    *(void *)(a3 + 8) = v8;
    *(void *)(a3 + 16) = v10;
    *(void *)(a3 + 24) = v11;
    *(_DWORD *)(a3 + 32) = v12;
    *(_DWORD *)(a3 + 36) = v13;
    *(_DWORD *)(a3 + 40) = v14;
    return;
  }
  llvm::object::AbstractArchiveMemberHeader::getLastModified(this[1], (uint64_t)&v24);
  if (v25)
  {
    uint64_t v15 = v24;
  }
  else
  {
    uint64_t v11 = v24;
    llvm::object::AbstractArchiveMemberHeader::getUID(this[1], (uint64_t)&v22);
    if (v23)
    {
      uint64_t v15 = v22;
    }
    else
    {
      int v12 = v22;
      llvm::object::AbstractArchiveMemberHeader::getGID(this[1], (uint64_t)&v20);
      if (v21)
      {
        uint64_t v15 = v20;
      }
      else
      {
        int v13 = v20;
        llvm::object::AbstractArchiveMemberHeader::getAccessMode(this[1], (uint64_t)&v18);
        if ((v19 & 1) == 0)
        {
          int v14 = v18;
          goto LABEL_6;
        }
        uint64_t v15 = v18;
      }
    }
  }
  *(unsigned char *)(a3 + 48) |= 1u;
  *(void *)a3 = v15;
  int v16 = *(void (**)(uint64_t))(*(void *)v7 + 8);

  v16(v7);
}

uint64_t llvm::NewArchiveMember::getFile@<X0>(uint64_t a1@<X0>, __darwin_ino64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)time_t __t = 0u;
  memset(v30, 0, sizeof(v30));
  int v31 = 0xFFFF;
  LOWORD(v32.st_atimespec.tv_sec) = 261;
  *(void *)&v32.st_dev = a1;
  v32.st_ino = a2;
  uint64_t result = (uint64_t)llvm::sys::fs::openNativeFileForRead((unsigned __int8 *)&v32, 0, 0, (uint64_t)&v35);
  if (v36)
  {
    uint64_t v13 = v35;
    *(unsigned char *)(a4 + 48) |= 1u;
    goto LABEL_5;
  }
  uint64_t v9 = (llvm::sys::Process *)v35;
  int v10 = fstat(v35, &v32);
  uint64_t v11 = (llvm *)sub_1CD0E6A50(v10, &v32.st_dev, (uint64_t)__t);
  if (v11)
  {
    uint64_t result = llvm::errorCodeToError(v11, v12, &v28);
    *(unsigned char *)(a4 + 48) |= 1u;
    uint64_t v13 = v28;
LABEL_5:
    *(void *)a4 = v13;
    return result;
  }
  if (*(_DWORD *)&v30[24] == 3)
  {
    *(void *)&v38.__val_ = std::generic_category();
    uint64_t result = llvm::errorCodeToError((llvm *)0x15, v38, &v27);
    *(unsigned char *)(a4 + 48) |= 1u;
    uint64_t v13 = v27;
    goto LABEL_5;
  }
  LOWORD(v32.st_atimespec.tv_sec) = 261;
  *(void *)&v32.st_dev = a1;
  v32.st_ino = a2;
  sub_1CD097170(*(llvm::WritableMemoryBuffer **)&v30[16], (int)v9, (const void ***)&v32, *(llvm::WritableMemoryBuffer **)&v30[16], 0, 0, 0, (uint64_t)v33);
  if (v34)
  {
    *(llvm **)&v14.__val_ = v33[1];
    uint64_t result = llvm::errorCodeToError(v33[0], v14, &v26);
    *(unsigned char *)(a4 + 48) |= 1u;
    uint64_t v13 = v26;
    goto LABEL_5;
  }
  uint64_t v15 = (llvm *)llvm::sys::Process::SafelyCloseFileDescriptor(v9);
  if (v15)
  {
    llvm::errorCodeToError(v15, v16, &v25);
    *(unsigned char *)(a4 + 48) |= 1u;
    *(void *)a4 = v25;
    uint64_t result = (uint64_t)v33[0];
    if (v33[0]) {
      return (*(uint64_t (**)(llvm *))(*(void *)v33[0] + 8))(v33[0]);
    }
  }
  else
  {
    uint64_t v17 = v33[0];
    uint64_t result = (*(uint64_t (**)(llvm *))(*(void *)v33[0] + 16))(v33[0]);
    uint64_t v18 = result;
    uint64_t v20 = v19;
    if (a3)
    {
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      int v23 = 420;
    }
    else
    {
      uint64_t v24 = *(unsigned int *)&v30[4];
      uint64_t result = std::chrono::system_clock::from_time_t(__t[1]).__d_.__rep_;
      uint64_t v21 = (v24 + 1000 * result) / 1000000000;
      uint64_t v22 = *(void *)&v30[8];
      int v23 = v31;
    }
    *(unsigned char *)(a4 + 48) &= ~1u;
    *(void *)a4 = v17;
    *(void *)(a4 + 8) = v18;
    *(void *)(a4 + 16) = v20;
    *(void *)(a4 + 24) = v21;
    *(void *)(a4 + 32) = v22;
    *(_DWORD *)(a4 + 40) = v23;
  }
  return result;
}

void llvm::computeArchiveRelativePath(void *a1@<X0>, size_t a2@<X1>, void *a3@<X2>, size_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  sub_1CCC178B0((uint64_t)&v64, a3, a4);
  sub_1CCC178B0((uint64_t)&v60, a1, a2);
  if (v67 & 1) != 0 || (v63)
  {
    uint64_t v20 = (llvm *)*__error();
    *(void *)&v69.__val_ = std::generic_category();
    llvm::errorCodeToError(v20, v69, &v51);
    *(unsigned char *)(a5 + 24) |= 1u;
    *(void *)a5 = v51;
    goto LABEL_20;
  }
  uint64_t v8 = v60;
  unint64_t v9 = v61;
  unint64_t v10 = sub_1CD0E3AC0((unsigned __int8 *)v60, v61, 0);
  uint64_t v11 = 0;
  if (v9 >= v10) {
    size_t v12 = v10;
  }
  else {
    size_t v12 = v9;
  }
  if (v10 == -1) {
    size_t v13 = 0;
  }
  else {
    size_t v13 = v12;
  }
  if (v10 == -1) {
    std::error_code v14 = 0;
  }
  else {
    std::error_code v14 = v8;
  }
  uint64_t v57 = v59;
  long long v58 = xmmword_1CFAC3020;
  if (v13 >= 0x81) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v13)
  {
    memcpy(v57, v14, v13);
    uint64_t v11 = v58;
  }
  *(void *)&long long v58 = v11 + v13;
  uint64_t v15 = llvm::sys::path::root_name((unint64_t)v64, v65, 0);
  size_t v17 = v16;
  uint64_t v18 = llvm::sys::path::root_name((unint64_t)v57, v58, 0);
  if (v17 == v19 && (!v17 || !memcmp(v15, v18, v17)))
  {
    llvm::sys::path::begin((unint64_t)v57, v58, 0, (uint64_t)v47);
    uint64_t v21 = v57;
    uint64_t v22 = v58;
    llvm::sys::path::begin((unint64_t)v64, v65, 0, (uint64_t)&v52);
    *(_OWORD *)&v55[16] = v47[1];
    long long v56 = v47[2];
    *(_OWORD *)unint64_t v55 = v47[0];
    if (*(void **)&v47[0] != v21 || (void)v56 != v22)
    {
      do
      {
        if (*(void **)&v55[24] != __s2[1]
          || *(void *)&v55[24] && memcmp(*(const void **)&v55[16], __s2[0], *(size_t *)&v55[24]))
        {
          break;
        }
        llvm::sys::path::const_iterator::operator++((uint64_t *)v55);
        llvm::sys::path::const_iterator::operator++((uint64_t *)&v52);
      }
      while (*(void **)v55 != v21 || (void)v56 != v22);
    }
    v47[3] = *(_OWORD *)v55;
    v47[4] = *(_OWORD *)&v55[16];
    v47[5] = v56;
    long long v48 = v52;
    long long v49 = *(_OWORD *)__s2;
    long long v50 = v54;
    *(_OWORD *)__s2 = *(_OWORD *)&v55[16];
    long long v54 = v56;
    long long v52 = *(_OWORD *)v55;
    long long v44 = v48;
    long long v45 = v49;
    long long v46 = v50;
    *(void *)unint64_t v55 = &v55[24];
    *(_OWORD *)&v55[8] = xmmword_1CFAC3020;
    uint64_t v24 = v57;
    uint64_t v25 = v58;
    while ((void *)v52 != v24 || (void)v54 != v25)
    {
      *(void *)&long long __dst = "..";
      __int16 v43 = 259;
      __int16 v40 = 257;
      __int16 v38 = 257;
      __int16 v36 = 257;
      llvm::sys::path::append(v55, (llvm::Twine *)1, (const char **)&__dst, v39, (uint64_t)v37, (uint64_t)v35);
      llvm::sys::path::const_iterator::operator++((uint64_t *)&v52);
    }
    uint64_t v27 = v64;
    unint64_t v28 = v65;
    while ((std::string::value_type *)v44 != v27 || (void)v46 != v28)
    {
      __int16 v43 = 261;
      long long __dst = v45;
      __int16 v40 = 257;
      __int16 v38 = 257;
      __int16 v36 = 257;
      llvm::sys::path::append(v55, (llvm::Twine *)1, (const char **)&__dst, v39, (uint64_t)v37, (uint64_t)v35);
      llvm::sys::path::const_iterator::operator++((uint64_t *)&v44);
    }
    size_t v30 = *(void *)&v55[8];
    if (*(void *)&v55[8] >= 0x7FFFFFFFFFFFFFF8uLL) {
      abort();
    }
    int v31 = *(const void **)v55;
    if (*(void *)&v55[8] >= 0x17uLL)
    {
      uint64_t v33 = (*(void *)&v55[8] & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((*(void *)&v55[8] | 7) != 0x17) {
        uint64_t v33 = *(void *)&v55[8] | 7;
      }
      uint64_t v34 = v33 + 1;
      p_dst = (long long *)operator new(v33 + 1);
      *((void *)&__dst + 1) = v30;
      unint64_t v42 = v34 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v42) = v55[8];
      p_dst = &__dst;
      if (!*(void *)&v55[8])
      {
LABEL_59:
        *((unsigned char *)p_dst + v30) = 0;
        *(unsigned char *)(a5 + 24) &= ~1u;
        *(_OWORD *)a5 = __dst;
        *(void *)(a5 + 16) = v42;
        if (*(unsigned char **)v55 != &v55[24]) {
          free(*(void **)v55);
        }
        goto LABEL_61;
      }
    }
    memmove(p_dst, v31, v30);
    goto LABEL_59;
  }
  std::string::__init((std::string *)v55, v64, v65);
  *(unsigned char *)(a5 + 24) &= ~1u;
  *(_OWORD *)a5 = *(_OWORD *)v55;
  *(void *)(a5 + 16) = *(void *)&v55[16];
LABEL_61:
  if (v57 != v59) {
    free(v57);
  }
LABEL_20:
  if ((v63 & 1) == 0 && v60 != &v62) {
    free(v60);
  }
  if ((v67 & 1) == 0 && v64 != (std::string::value_type *)&v66) {
    free(v64);
  }
}

void sub_1CCC178B0(uint64_t a1, void *__src, size_t __n)
{
  v10[16] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = v10;
  long long v9 = xmmword_1CFAC3020;
  if (__n >= 0x81) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v5 = 0;
  if (__n)
  {
    memcpy(v8, __src, __n);
    uint64_t v5 = v9;
  }
  *(void *)&long long v9 = v5 + __n;
  unint64_t absolute = llvm::sys::fs::make_absolute((uint64_t)&v8);
  if (absolute)
  {
    *(unsigned char *)(a1 + 152) |= 1u;
    *(void *)a1 = absolute;
    *(void *)(a1 + 8) = v7;
  }
  else
  {
    llvm::sys::path::remove_dots((unsigned __int8 **)&v8, 1, 0);
    *(unsigned char *)(a1 + 152) &= ~1u;
    *(void *)a1 = a1 + 24;
    *(_OWORD *)(a1 + 8) = xmmword_1CFAC3020;
    if ((void)v9) {
      sub_1CC1B8518(a1, (uint64_t)&v8);
    }
  }
  if (v8 != v10) {
    free(v8);
  }
}

uint64_t *llvm::writeArchive@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, size_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unsigned int a6@<W5>, int a7@<W6>, int a8@<W7>, char **a9@<X8>, uint64_t *a10)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  __int16 v30 = 773;
  v29[0] = a1;
  v29[1] = a2;
  v29[2] = ".temp-archive-%%%%%%%.a";
  llvm::sys::fs::TempFile::create((uint64_t)v29, 438, 0, (uint64_t)v31);
  if (v33)
  {
    uint64_t v19 = v31[0];
    v31[0] = 0;
    *a9 = (char *)v19;
  }
  else
  {
    llvm::raw_fd_ostream::raw_fd_ostream((uint64_t)v29, v32, 0, 0, 0);
    sub_1CCC17C28(v24, (llvm::raw_ostream *)v29, a3, a4, a5, a6, a7, a8);
    uint64_t v22 = (char *)v24[0];
    if (v24[0])
    {
      llvm::sys::fs::TempFile::discard((llvm::sys::fs::TempFile *)v31, &v28);
      if (v28)
      {
        uint64_t v26 = v28;
        uint64_t v27 = v22;
        unint64_t v28 = 0;
        sub_1CD5E5368(&v27, &v26, a9);
        if (v26) {
          (*(void (**)(char *))(*(void *)v26 + 8))(v26);
        }
        if (v27) {
          (*(void (**)(char *))(*(void *)v27 + 8))(v27);
        }
        if (v28) {
          (*(void (**)(char *))(*(void *)v28 + 8))(v28);
        }
      }
      else
      {
        *a9 = v22;
      }
    }
    else
    {
      uint64_t v23 = *a10;
      *a10 = 0;
      if (v23) {
        (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
      }
      __int16 v25 = 261;
      v24[0] = a1;
      v24[1] = a2;
      llvm::sys::fs::TempFile::keep((llvm::sys::fs::TempFile *)v31, (const llvm::Twine *)v24, v21, a9);
    }
    llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)v29);
  }
  return sub_1CCC1A4A0(v31);
}

void sub_1CCC17C28(void *a1, llvm::raw_ostream *a2, size_t a3, uint64_t a4, int a5, unsigned int a6, int a7, int a8)
{
  unsigned int v8 = a6;
  uint64_t v305 = *MEMORY[0x1E4F143B8];
  size_t v282 = 0;
  uint64_t v283 = 0;
  uint64_t v280 = &p_p;
  p_p = &__p;
  int v273 = 0;
  char v277 = 0;
  uint64_t v278 = 0;
  int v279 = 0;
  uint64_t v271 = 0;
  v272 = &unk_1F2646FA8;
  uint64_t v274 = 0;
  uint64_t v275 = 0;
  uint64_t v276 = 0;
  unsigned int v269 = &v272;
  v270 = 0;
  int v261 = 0;
  char v265 = 0;
  uint64_t v266 = 0;
  BOOL v268 = &v269;
  int v267 = 0;
  v260 = (uint64_t (**)(void **))&unk_1F2646FA8;
  uint64_t v262 = 0;
  uint64_t v263 = 0;
  long long __dst = 0;
  *(void *)uint64_t v301 = 0;
  *(void *)&v301[8] = 0;
  *(void *)&v301[16] = 0x1000000000;
  unsigned int v234 = a6 - 3;
  char v223 = a7;
  if (a6 - 3 < 2) {
    int v11 = a7;
  }
  else {
    int v11 = 0;
  }
  v287[0] = 0;
  v287[1] = 0;
  unsigned int v286 = v287;
  int v233 = v11;
  if (v11 != 1)
  {
LABEL_15:
    if (!a4) {
      goto LABEL_16;
    }
    int v249 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    size_t v23 = a3;
    size_t v232 = a3 + 48 * a4;
    while (1)
    {
      unsigned int v246 = v20;
      __p = 0;
      long long v285 = 0uLL;
      int v290 = 0;
      char v294 = 0;
      uint64_t v295 = 0;
      uint64_t v289 = &unk_1F2646F30;
      int v297 = (std::string *)&__p;
      int v296 = 0;
      unint64_t v292 = 0;
      unsigned int v293 = 0;
      int v291 = 0;
      uint64_t v24 = *(const char **)(*(void *)v23 + 8);
      __int16 v25 = (void *)(*(void *)(*(void *)v23 + 16) - (void)v24);
      (*(void (**)(void))(**(void **)v23 + 16))();
      uint64_t v26 = "";
      if (!a8) {
        uint64_t v26 = v24;
      }
      __src = v26;
      if (a8) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = v25;
      }
      v255 = v27;
      if (v234 >= 2) {
        unsigned int v28 = 0;
      }
      else {
        unsigned int v28 = ((v27 + 7) & 0xFFFFFFF8) - v27;
      }
      if (v233)
      {
        v302.__r_.__value_.__r.__words[0] = v23 + 8;
        uint64_t v64 = sub_1CD6C6E68((uint64_t)&v286, v23 + 8, &v302);
        time_t v65 = *((unsigned int *)v64 + 12);
        *((_DWORD *)v64 + 12) = v65 + 1;
        std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v29 = std::chrono::system_clock::from_time_t(v65).__d_.__rep_ / 1000000;
      }
      else
      {
        std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v29 = *(void *)(v23 + 24);
      }
      size_t __n = v23;
      if ((unint64_t)v25 + v28 >= 0x2540BE400)
      {
        uint64_t v66 = *(const void **)(v23 + 8);
        if (!v66)
        {
          memset(&v300, 0, sizeof(v300));
          goto LABEL_129;
        }
        std::string::size_type v77 = *(void *)(v23 + 16);
        if (v77 < 0x7FFFFFFFFFFFFFF8)
        {
          if (v77 >= 0x17)
          {
            uint64_t v97 = (v77 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v77 | 7) != 0x17) {
              uint64_t v97 = v77 | 7;
            }
            uint64_t v98 = v97 + 1;
            int v78 = operator new(v97 + 1);
            v300.__r_.__value_.__l.__size_ = v77;
            v300.__r_.__value_.__r.__words[2] = v98 | 0x8000000000000000;
            v300.__r_.__value_.__r.__words[0] = (std::string::size_type)v78;
          }
          else
          {
            *((unsigned char *)&v300.__r_.__value_.__s + 23) = *(void *)(v23 + 16);
            int v78 = &v300;
            if (!v77) {
              goto LABEL_128;
            }
          }
          memmove(v78, v66, v77);
LABEL_128:
          *((unsigned char *)v78 + v77) = 0;
LABEL_129:
          uint64_t v99 = std::string::insert(&v300, 0, "File ");
          std::string::size_type v100 = v99->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v302.__r_.__value_.__l.__data_ = *(_OWORD *)&v99->__r_.__value_.__l.__data_;
          v302.__r_.__value_.__r.__words[2] = v100;
          v99->__r_.__value_.__l.__size_ = 0;
          v99->__r_.__value_.__r.__words[2] = 0;
          v99->__r_.__value_.__r.__words[0] = 0;
          int v101 = std::string::append(&v302, " exceeds size limit");
          std::string::size_type v102 = v101->__r_.__value_.__r.__words[2];
          long long v298 = *(_OWORD *)&v101->__r_.__value_.__l.__data_;
          std::string::size_type v299 = v102;
          v101->__r_.__value_.__l.__size_ = 0;
          v101->__r_.__value_.__r.__words[2] = 0;
          v101->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(v302.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v302.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v300.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v300.__r_.__value_.__l.__data_);
          }
          operator new();
        }
LABEL_245:
        abort();
      }
      v256 = (void **)v21;
      *(void *)&long long v298 = v29;
      __int16 v30 = *(void **)(v23 + 8);
      size_t v31 = *(void *)(v23 + 16);
      if (a6 < 2) {
        break;
      }
      sub_1CCC19C80((llvm::raw_ostream *)&v289, v249, v30, v31, (uint64_t *)&v298, *(_DWORD *)(v23 + 32), *(_DWORD *)(v23 + 36), *(_DWORD *)(v23 + 40), (uint64_t)v25 + v28);
LABEL_96:
      int64_t v79 = v293 - v291;
      if (v293 != v291)
      {
        unsigned int v293 = v291;
        llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v289, v291);
      }
      if (a5) {
        llvm::LLVMContext::LLVMContext((llvm::LLVMContext *)v288);
      }
      int v80 = (int)v255;
      uint64_t v81 = (void *)(((v28 + v255 + 1) & 0xFFFFFFFE) - v255);
      char v82 = HIBYTE(v285);
      BOOL v83 = __p;
      if (v285 >= 0) {
        int v84 = HIBYTE(v285) & 0x7F;
      }
      else {
        int v84 = v285;
      }
      v302.__r_.__value_.__r.__words[0] = v285;
      *(std::string::size_type *)((char *)v302.__r_.__value_.__r.__words + 7) = *(void *)((char *)&v285 + 7);
      long long v285 = 0uLL;
      __p = 0;
      if (v256 >= (void **)v246)
      {
        unint64_t v87 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v256 - (char *)v22) >> 4) + 1;
        if (v87 > 0x333333333333333) {
          goto LABEL_245;
        }
        if (0x999999999999999ALL * ((v246 - (char *)v22) >> 4) > v87) {
          unint64_t v87 = 0x999999999999999ALL * ((v246 - (char *)v22) >> 4);
        }
        if (0xCCCCCCCCCCCCCCCDLL * ((v246 - (char *)v22) >> 4) >= 0x199999999999999) {
          unint64_t v87 = 0x333333333333333;
        }
        if (v87 > 0x333333333333333) {
          goto LABEL_246;
        }
        uint64_t v238 = 5 * v87;
        unint64_t v88 = (char *)operator new(80 * v87);
        uint64_t v89 = &v88[16 * (((char *)v256 - (char *)v22) >> 4)];
        *(void *)uint64_t v89 = 0;
        *((void *)v89 + 1) = 0;
        *((void *)v89 + 2) = 0;
        *((void *)v89 + 3) = v83;
        *((void *)v89 + 4) = v302.__r_.__value_.__r.__words[0];
        *(void *)(v89 + 39) = *(std::string::size_type *)((char *)v302.__r_.__value_.__r.__words + 7);
        v89[47] = v82;
        v302.__r_.__value_.__r.__words[0] = 0;
        *(std::string::size_type *)((char *)v302.__r_.__value_.__r.__words + 7) = 0;
        int v80 = (int)v255;
        *((void *)v89 + 6) = __src;
        *((void *)v89 + 7) = v255;
        *((void *)v89 + 8) = asc_1EA6167B1;
        *((void *)v89 + 9) = v81;
        unsigned int v90 = v256;
        uint64_t v91 = v89;
        if (v256 != v22)
        {
          do
          {
            *((void *)v91 - 10) = 0;
            *((void *)v91 - 9) = 0;
            v91 -= 80;
            *((void *)v91 + 2) = 0;
            long long v92 = *((_OWORD *)v90 - 5);
            v90 -= 10;
            *(_OWORD *)uint64_t v91 = v92;
            *((void *)v91 + 2) = v90[2];
            *unsigned int v90 = 0;
            v90[1] = 0;
            void v90[2] = 0;
            long long v93 = *(_OWORD *)(v90 + 3);
            *((void *)v91 + 5) = v90[5];
            *(_OWORD *)(v91 + 24) = v93;
            v90[4] = 0;
            v90[5] = 0;
            v90[3] = 0;
            long long v94 = *((_OWORD *)v90 + 4);
            *((_OWORD *)v91 + 3) = *((_OWORD *)v90 + 3);
            *((_OWORD *)v91 + 4) = v94;
          }
          while (v90 != v22);
          uint64_t v95 = v256;
          do
          {
            if (*((char *)v95 - 33) < 0) {
              operator delete(*(v95 - 7));
            }
            int v96 = *(v95 - 10);
            if (v96)
            {
              *(v95 - 9) = v96;
              operator delete(v96);
            }
            v95 -= 10;
          }
          while (v95 != v22);
          int v80 = (int)v255;
        }
        int v86 = &v88[16 * v238];
        int v85 = v89 + 80;
        if (v22)
        {
          operator delete(v22);
          int v80 = (int)v255;
        }
        uint64_t v22 = (void **)v91;
      }
      else
      {
        char *v256 = 0;
        v256[1] = 0;
        v256[2] = 0;
        v256[3] = v83;
        v256[4] = (void *)v302.__r_.__value_.__r.__words[0];
        *(void **)((char *)v256 + 39) = *(void **)((char *)v302.__r_.__value_.__r.__words + 7);
        *((unsigned char *)v256 + 47) = v82;
        v256[6] = (void *)__src;
        v256[7] = v255;
        int v85 = (char *)(v256 + 10);
        int v86 = v246;
        v256[8] = asc_1EA6167B1;
        v256[9] = v81;
      }
      v249 += v80 + v81 + v84;
      uint64_t v289 = &unk_1F2646B98;
      if (v296 == 1 && v291) {
        MEMORY[0x1D25D9CB0](v291, 0x1000C8077774924, v79);
      }
      if (SHIBYTE(v285) < 0) {
        operator delete(__p);
      }
      size_t v23 = __n + 48;
      uint64_t v20 = v86;
      uint64_t v21 = v85;
      if (__n + 48 == v232)
      {
        uint64_t v18 = (void **)v85;
        unint64_t v245 = (unint64_t)v86;
        uint64_t v225 = v22;
        uint64_t v19 = a1;
        unsigned int v8 = a6;
        goto LABEL_145;
      }
    }
    std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v230 = v29;
    unint64_t v229 = (unint64_t)v25 + v28;
    if ((a8 & 1) == 0 && v31 <= 0xF && (!v31 || (int v32 = memchr(v30, 47, v31)) == 0 || v32 - (unsigned char *)v30 == -1))
    {
      unsigned int v34 = *(_DWORD *)(v23 + 32);
      unsigned int v35 = *(_DWORD *)(v23 + 36);
      unsigned int v36 = *(_DWORD *)(v23 + 40);
      v302.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
      v302.__r_.__value_.__l.__size_ = v31;
      v302.__r_.__value_.__r.__words[2] = (std::string::size_type)"/";
      __int16 v304 = 773;
      sub_1CCC1A0F0((llvm::raw_ostream *)&v289, (uint64_t)&v302);
      unsigned int v37 = v34;
      unsigned int v38 = v35;
      uint64_t v39 = v230;
      unsigned int v40 = v36;
      unint64_t v41 = (unint64_t)v25 + v28;
LABEL_95:
      sub_1CCC19E84((llvm::raw_ostream *)&v289, v39, v37, v38, v40, v41);
      goto LABEL_96;
    }
    char v33 = v293;
    if ((unint64_t)v293 >= v292)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v289, 47);
    }
    else
    {
      ++v293;
      *char v33 = 47;
    }
    if (a8)
    {
      uint64_t v42 = v260[10]((void **)&v260);
      __int16 v43 = __dst;
      long long v44 = *(const void **)(v23 + 8);
      unint64_t v45 = *(void *)(v23 + 16);
      uint64_t v46 = v262;
      if (v45 <= v263 - (uint64_t)__dst)
      {
        if (v45)
        {
          memcpy(__dst, v44, *(void *)(v23 + 16));
          unsigned int v47 = (char *)__dst + v45;
          long long __dst = (char *)__dst + v45;
        }
        else
        {
          unsigned int v47 = __dst;
        }
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v260, (const char *)v44, *(void *)(v23 + 16));
        unsigned int v47 = __dst;
      }
      unint64_t v76 = (unint64_t)v43 + v42 - v46;
      if ((unint64_t)(v263 - (void)v47) > 1)
      {
        _WORD *v47 = 2607;
        long long __dst = (char *)__dst + 2;
      }
      else
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v260, "/\n", 2uLL);
      }
      goto LABEL_94;
    }
    size_t v48 = *(void *)(v23 + 16);
    __s1 = *(unsigned __int8 **)(v23 + 8);
    unsigned int v49 = *(_DWORD *)&v301[8];
    if (!*(_DWORD *)&v301[8])
    {
      *(void *)&v301[12] = 0;
      uint64_t v103 = malloc_type_calloc(0x11uLL, 0xCuLL, 0x6D9A4F0CuLL);
      if (!v103) {
        llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
      }
      v103[16] = 2;
      *(void *)uint64_t v301 = v103;
      unsigned int v49 = 16;
      *(_DWORD *)&v301[8] = 16;
    }
    unsigned int v237 = v28;
    int v50 = 0;
    if (v48)
    {
      size_t v51 = v48;
      long long v52 = __s1;
      do
      {
        int v53 = *v52++;
        int v50 = 33 * v50 + v53;
        --v51;
      }
      while (v51);
    }
    unsigned int v54 = v49 - 1;
    uint64_t v55 = *(void *)v301;
    uint64_t v56 = *(void *)v301 + 8 * v49 + 8;
    uint64_t v226 = *(unsigned int *)&v301[20];
    int v57 = -1;
    int v58 = 1;
    int v59 = v50;
    while (1)
    {
      uint64_t v60 = v59 & v54;
      unint64_t v61 = *(void **)(v55 + 8 * v60);
      if (!v61) {
        break;
      }
      if (v61 == (void *)-8)
      {
        if (v57 == -1) {
          int v57 = v59 & v54;
        }
      }
      else if (*(_DWORD *)(v56 + 4 * v60) == v50 && v48 == *v61 && (!v48 || !memcmp(__s1, (char *)v61 + v226, v48)))
      {
        goto LABEL_62;
      }
      int v59 = v58 + v60;
      ++v58;
    }
    uint64_t v62 = v57;
    if (v57 == -1)
    {
      uint64_t v62 = v60;
      uint64_t v60 = v60;
    }
    else
    {
      uint64_t v60 = v57;
    }
    *(_DWORD *)(v56 + 4 * v62) = v50;
    unint64_t v61 = *(void **)(v55 + 8 * v60);
LABEL_62:
    uint64_t i = v55 + 8 * v60;
    if (v61 == (void *)-8)
    {
      --*(_DWORD *)&v301[16];
      size_t v23 = __n;
    }
    else
    {
      size_t v23 = __n;
      if (v61)
      {
LABEL_86:
        unint64_t v76 = *(void *)(*(void *)i + 8);
        unsigned int v28 = v237;
LABEL_94:
        sub_1CCC19DA8((llvm::raw_ostream *)&v289, v76, 15);
        unsigned int v37 = *(_DWORD *)(v23 + 32);
        unsigned int v38 = *(_DWORD *)(v23 + 36);
        unsigned int v40 = *(_DWORD *)(v23 + 40);
        uint64_t v39 = v230;
        unint64_t v41 = v229;
        goto LABEL_95;
      }
    }
    char v67 = operator new(v48 + 17, (std::align_val_t)8uLL);
    uint64_t v68 = v67;
    std::error_code v69 = (char *)(v67 + 2);
    if (v48) {
      memcpy(v67 + 2, __s1, v48);
    }
    v69[v48] = 0;
    *uint64_t v68 = v48;
    v68[1] = 0;
    *(void *)uint64_t i = v68;
    ++*(_DWORD *)&v301[12];
    unsigned int v70 = llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)v301, v60);
    for (uint64_t i = *(void *)v301 + 8 * v70; ; i += 8)
    {
      BOOL v71 = !*(void *)i || *(void *)i == -8;
      if (!v71) {
        break;
      }
    }
    uint64_t v72 = v260[10]((void **)&v260);
    int v73 = __dst;
    *(void *)(*(void *)i + 8) = (char *)__dst + v72 - v262;
    uint64_t v74 = *(const void **)(v23 + 8);
    unint64_t v75 = *(void *)(v23 + 16);
    if (v75 <= v263 - (uint64_t)v73)
    {
      if (v75)
      {
        memcpy(v73, v74, *(void *)(v23 + 16));
        int v73 = (char *)__dst + v75;
        long long __dst = (char *)__dst + v75;
      }
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v260, (const char *)v74, *(void *)(v23 + 16));
      int v73 = __dst;
    }
    if ((unint64_t)(v263 - (void)v73) > 1)
    {
      *int v73 = 2607;
      long long __dst = (char *)__dst + 2;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v260, "/\n", 2uLL);
    }
    goto LABEL_86;
  }
  if (a4)
  {
    uint64_t v12 = 48 * a4;
    size_t v13 = (_OWORD *)(a3 + 8);
    do
    {
      uint64_t v289 = v13;
      std::error_code v14 = sub_1CD6C6E68((uint64_t)&v286, (uint64_t)v13, &v289);
      ++*((_DWORD *)v14 + 12);
      v13 += 3;
      v12 -= 48;
    }
    while (v12);
    uint64_t v15 = v286;
    unsigned int v8 = a6;
    if (v286 != v287)
    {
      do
      {
        *((_DWORD *)v15 + 12) = *((_DWORD *)v15 + 12) > 1u;
        size_t v16 = v15[1];
        if (v16)
        {
          do
          {
            size_t v17 = (void **)v16;
            size_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            size_t v17 = (void **)v15[2];
            BOOL v71 = *v17 == v15;
            uint64_t v15 = v17;
          }
          while (!v71);
        }
        uint64_t v15 = v17;
      }
      while (v17 != v287);
    }
    goto LABEL_15;
  }
LABEL_16:
  uint64_t v18 = 0;
  unint64_t v245 = 0;
  uint64_t v225 = 0;
  uint64_t v19 = a1;
LABEL_145:
  sub_1CD40B1BC(v287[0]);
  sub_1CD4AFD10((uint64_t)v301);
  uint64_t v104 = v225;
  *uint64_t v19 = 0;
  uint64_t v106 = v270;
  if (v270)
  {
    unint64_t v107 = (unint64_t)v18;
    uint64_t v108 = v269;
    unsigned int v109 = ((v270 + 1) & 0xFFFFFFFE) - v270;
    memset(&v302, 0, sizeof(v302));
    int v290 = 0;
    char v294 = 0;
    uint64_t v295 = 0;
    int v297 = &v302;
    int v296 = 0;
    uint64_t v289 = &unk_1F2646F30;
    int v291 = 0;
    unsigned int v293 = 0;
    unint64_t v292 = 0;
    int v110 = off_1F2646F80((uint64_t)&v289);
    int v111 = (int)v293;
    int v112 = (int)v291;
    if (v292 - (unint64_t)v293 > 1)
    {
      *(_WORD *)unsigned int v293 = 12079;
      v293 += 2;
    }
    else
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v289, "//", 2uLL);
    }
    int v113 = (*((uint64_t (**)(_OWORD **))v289 + 10))(&v289);
    llvm::raw_ostream::indent((llvm::raw_ostream *)&v289, v110 + v111 - (v113 + v112 + v293) + v291 + 48);
    sub_1CCC1A1D0((llvm::raw_ostream *)&v289, v109 + v106, 10);
    if (v292 - (unint64_t)v293 > 1)
    {
      *(_WORD *)unsigned int v293 = 2656;
      uint64_t v114 = v293 + 2;
      v293 += 2;
    }
    else
    {
      uint64_t v114 = v293;
    }
    unsigned int v8 = a6;
    int64_t v115 = v114 - v291;
    if (v114 != v291)
    {
      unsigned int v293 = v291;
      llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v289, v291);
    }
    *(void *)uint64_t v301 = v302.__r_.__value_.__l.__size_;
    std::string::size_type v116 = v302.__r_.__value_.__r.__words[0];
    *(void *)&v301[7] = *(std::string::size_type *)((char *)&v302.__r_.__value_.__r.__words[1] + 7);
    char v117 = HIBYTE(v302.__r_.__value_.__r.__words[2]);
    memset(&v302, 0, sizeof(v302));
    BOOL v118 = v109 != 0;
    if (v109) {
      unsigned int v119 = "\n";
    }
    else {
      unsigned int v119 = "";
    }
    uint64_t v289 = &unk_1F2646B98;
    if (v296 == 1 && v291)
    {
      std::string::size_type v258 = v116;
      MEMORY[0x1D25D9CB0](v291, 0x1000C8077774924, v115);
      std::string::size_type v116 = v258;
      unint64_t v120 = v107;
      if (SHIBYTE(v302.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v302.__r_.__value_.__l.__data_);
        std::string::size_type v116 = v258;
      }
    }
    else
    {
      unint64_t v120 = v107;
    }
    if (v120 < v245)
    {
      if (v225 == (void **)v120)
      {
        *(void *)unint64_t v120 = 0;
        *(void *)(v120 + 8) = 0;
        *(void *)(v120 + 16) = 0;
        *(void *)(v120 + 24) = v116;
        *(void *)(v120 + 32) = *(void *)v301;
        *(void *)(v120 + 39) = *(void *)&v301[7];
        *(unsigned char *)(v120 + 47) = v117;
        *(void *)(v120 + 48) = v108;
        *(void *)(v120 + 56) = v106;
        v123 = (char *)(v120 + 80);
        uint64_t v137 = (void *)v120;
        *(void *)(v120 + 64) = v119;
        *(void *)(v120 + 72) = v118;
        v136 = a2;
      }
      else
      {
        char __srca = v117;
        unsigned int v247 = v119;
        uint64_t v121 = (char *)(v225 + 10);
        unint64_t v122 = v120 - 80;
        v123 = (char *)v120;
        if (v120 >= 0x50)
        {
          unint64_t v124 = v120 - 80;
          v123 = (char *)v120;
          do
          {
            *(void *)v123 = 0;
            *((void *)v123 + 1) = 0;
            *((void *)v123 + 2) = 0;
            *(_OWORD *)v123 = *(_OWORD *)v124;
            *((void *)v123 + 2) = *(void *)(v124 + 16);
            *(void *)unint64_t v124 = 0;
            *(void *)(v124 + 8) = 0;
            *(void *)(v124 + 16) = 0;
            long long v125 = *(_OWORD *)(v124 + 24);
            *((void *)v123 + 5) = *(void *)(v124 + 40);
            *(_OWORD *)(v123 + 24) = v125;
            *(void *)(v124 + 32) = 0;
            *(void *)(v124 + 40) = 0;
            *(void *)(v124 + 24) = 0;
            long long v126 = *(_OWORD *)(v124 + 64);
            *((_OWORD *)v123 + 3) = *(_OWORD *)(v124 + 48);
            *((_OWORD *)v123 + 4) = v126;
            v123 += 80;
            v124 += 80;
          }
          while (v124 < v120);
        }
        std::string::size_type v257 = v116;
        BOOL v250 = v118;
        size_t __na = (size_t)v108;
        if ((char *)v120 != v121)
        {
          uint64_t v127 = 0;
          uint64_t v128 = -16 * ((uint64_t)(v120 - (void)v121) >> 4);
          do
          {
            uint64_t v129 = v122 + v127;
            uint64_t v130 = v120 + v127;
            sub_1CD46D2D8(v130 - 80, (__n128 *)(v122 + v127 - 80));
            unint64_t v131 = (void **)(v130 - 56);
            if (*(char *)(v130 - 33) < 0) {
              operator delete(*v131);
            }
            long long v132 = *(_OWORD *)(v129 - 56);
            *(void *)(v130 - 40) = *(void *)(v129 - 40);
            *(_OWORD *)unint64_t v131 = v132;
            *(unsigned char *)(v129 - 33) = 0;
            *(unsigned char *)(v129 - 56) = 0;
            long long v133 = *(_OWORD *)(v129 - 16);
            *(_OWORD *)(v130 - 32) = *(_OWORD *)(v129 - 32);
            *(_OWORD *)(v130 - 16) = v133;
            v127 -= 80;
            unint64_t v120 = v107;
          }
          while (v128 != v127);
        }
        int v134 = *v225;
        if (*v225)
        {
          v225[1] = v134;
          operator delete(v134);
        }
        *uint64_t v225 = 0;
        v225[1] = 0;
        v225[2] = 0;
        unsigned int v8 = a6;
        if (*((char *)v225 + 47) < 0) {
          operator delete(v225[3]);
        }
        uint64_t v135 = *(void **)v301;
        v225[3] = (void *)v257;
        v225[4] = v135;
        *(void **)((char *)v225 + 39) = *(void **)&v301[7];
        *((unsigned char *)v225 + 47) = __srca;
        v225[6] = (void *)__na;
        v225[7] = v106;
        v225[8] = (void *)v247;
        v225[9] = (void *)v250;
        v136 = a2;
        uint64_t v137 = v225;
      }
      goto LABEL_203;
    }
    unint64_t v138 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v120 - (void)v225) >> 4) + 1;
    if (v138 > 0x333333333333333) {
      goto LABEL_245;
    }
    if (0x999999999999999ALL * ((uint64_t)(v245 - (void)v225) >> 4) > v138) {
      unint64_t v138 = 0x999999999999999ALL * ((uint64_t)(v245 - (void)v225) >> 4);
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v245 - (void)v225) >> 4) >= 0x199999999999999) {
      unint64_t v138 = 0x333333333333333;
    }
    if (v138)
    {
      if (v138 > 0x333333333333333) {
LABEL_246:
      }
        sub_1CB833614();
      std::string::size_type v139 = v116;
      size_t v140 = 80 * v138;
    }
    else
    {
      std::string::size_type v139 = v116;
      size_t v140 = 80;
    }
    uint64_t v137 = operator new(v140);
    *uint64_t v137 = 0;
    v137[1] = 0;
    v137[2] = 0;
    v137[3] = v139;
    v137[4] = *(void *)v301;
    *(void *)((char *)v137 + 39) = *(void *)&v301[7];
    *((unsigned char *)v137 + 47) = v117;
    *(void *)uint64_t v301 = 0;
    *(void *)&v301[7] = 0;
    v137[6] = v108;
    v137[7] = v106;
    v123 = (char *)(v137 + 10);
    v137[8] = v119;
    v137[9] = v118;
    if (v225 == (void **)v120)
    {
      v136 = a2;
      if (!v225) {
        goto LABEL_203;
      }
    }
    else
    {
      uint64_t v141 = v137;
      uint64_t v142 = 0;
      do
      {
        uint64_t v143 = &v123[v142 * 8];
        uint64_t v144 = &v225[v142];
        *(void *)uint64_t v143 = 0;
        *((void *)v143 + 1) = 0;
        *((void *)v143 + 2) = 0;
        *(void *)uint64_t v143 = v225[v142];
        *((void *)v143 + 1) = v225[v142 + 1];
        *((void *)v143 + 2) = v225[v142 + 2];
        *uint64_t v144 = 0;
        v144[1] = 0;
        v144[2] = 0;
        long long v145 = *(_OWORD *)&v225[v142 + 3];
        *((void *)v143 + 5) = v225[v142 + 5];
        *(_OWORD *)(v143 + 24) = v145;
        v144[4] = 0;
        v144[5] = 0;
        v144[3] = 0;
        long long v146 = *(_OWORD *)&v225[v142 + 8];
        *((_OWORD *)v143 + 3) = *(_OWORD *)&v225[v142 + 6];
        *((_OWORD *)v143 + 4) = v146;
        v142 += 10;
      }
      while (v144 + 10 != (void **)v120);
      v123 += v142 * 8;
      v136 = a2;
      do
      {
        if (*(char *)(v120 - 33) < 0) {
          operator delete(*(void **)(v120 - 56));
        }
        uint64_t v147 = *(void **)(v120 - 80);
        if (v147)
        {
          *(void *)(v120 - 72) = v147;
          operator delete(v147);
        }
        v120 -= 80;
      }
      while ((void **)v120 != v225);
      uint64_t v137 = v141;
      if (!v225) {
        goto LABEL_203;
      }
    }
    uint64_t v148 = v137;
    operator delete(v225);
    uint64_t v137 = v148;
LABEL_203:
    uint64_t v104 = (void **)v137;
    uint64_t v18 = (void **)v123;
    goto LABEL_204;
  }
  v136 = a2;
LABEL_204:
  if (!a5) {
    goto LABEL_266;
  }
  if (v104 == v18)
  {
    uint64_t v149 = 0;
    uint64_t v153 = 8;
  }
  else
  {
    uint64_t v149 = 0;
    uint64_t v150 = 8;
    uint64_t v151 = v104;
    do
    {
      if (*((char *)v151 + 47) < 0) {
        unsigned int v152 = v151[4];
      }
      else {
        unsigned int v152 = (void *)*((unsigned __int8 *)v151 + 47);
      }
      uint64_t v153 = v150;
      v150 += (uint64_t)v151[9] + (void)v152 + (unint64_t)v151[7];
      unsigned int v155 = *v151;
      unsigned int v154 = v151[1];
      v151 += 10;
      v149 += (v154 - v155) >> 2;
    }
    while (v151 != v18);
  }
  v156 = v18;
  char v157 = 2;
  if (v8 > 1) {
    char v157 = 3;
  }
  uint64_t v158 = v149 << v157;
  uint64_t v159 = 4;
  if (v8 > 1) {
    uint64_t v159 = 8;
  }
  *(_OWORD *)&v302.__r_.__value_.__r.__words[1] = 0uLL;
  size_t v160 = v158 + v159 + v282;
  if (v8 <= 1) {
    int v161 = -2;
  }
  else {
    int v161 = -8;
  }
  v302.__r_.__value_.__r.__words[0] = (std::string::size_type)&v303;
  int v290 = 0;
  char v294 = 0;
  uint64_t v295 = 0;
  int v297 = &v302;
  int v162 = v160 + 7;
  if (v8 <= 1) {
    int v162 = v160 + 1;
  }
  int v296 = 0;
  uint64_t v289 = &unk_1F2646FA8;
  int v291 = 0;
  unsigned int v163 = v8;
  unint64_t v164 = (v162 & v161) - v160 + v160;
  unsigned int v293 = 0;
  unint64_t v292 = 0;
  sub_1CCC1A2AC((llvm::raw_ostream *)&v289, v163, v223, v164);
  std::string::size_type size = v302.__r_.__value_.__l.__size_;
  uint64_t v289 = &unk_1F2646B98;
  if (v296 == 1 && v291) {
    MEMORY[0x1D25D9CB0](v291, 0x1000C8077774924);
  }
  if ((uint64_t *)v302.__r_.__value_.__l.__data_ != &v303) {
    free(v302.__r_.__value_.__l.__data_);
  }
  unint64_t v166 = v164 + v153 + size;
  int v167 = getenv("SYM64_THRESHOLD");
  if (!v167)
  {
    unint64_t v176 = 0x100000000;
    unsigned int v8 = a6;
    goto LABEL_261;
  }
  uint64_t v168 = v167;
  size_t v169 = strlen(v167);
  if (!v169)
  {
    unint64_t v175 = 0;
    BOOL v177 = 0;
    BOOL v178 = 1;
    unsigned int v8 = a6;
    goto LABEL_258;
  }
  unint64_t v170 = 0;
  size_t v171 = v169;
  while (1)
  {
    int v172 = *v168;
    if ((v172 - 48) < 0xA)
    {
      int v173 = -48;
      goto LABEL_230;
    }
    if ((v172 - 97) >= 0x1A) {
      break;
    }
    int v173 = -87;
LABEL_238:
    v136 = a2;
    uint64_t v18 = v156;
LABEL_230:
    unsigned int v174 = v173 + v172;
    if (v174 > 9)
    {
      unint64_t v175 = v170;
      goto LABEL_256;
    }
    unint64_t v175 = 10 * v170 + v174;
    if (v170 > v175 / 0xA)
    {
      BOOL v177 = 1;
      BOOL v178 = 1;
      goto LABEL_257;
    }
    ++v168;
    unint64_t v170 = v175;
    if (!--v171) {
      goto LABEL_256;
    }
  }
  if ((v172 - 65) <= 0x19)
  {
    int v173 = -55;
    goto LABEL_238;
  }
  unint64_t v175 = v170;
  v136 = a2;
  uint64_t v18 = v156;
LABEL_256:
  BOOL v178 = v169 == v171;
  BOOL v177 = v171 != 0;
LABEL_257:
  unsigned int v8 = a6;
LABEL_258:
  BOOL v71 = !v177 && !v178;
  unint64_t v176 = 0x100000000;
  if (v71) {
    unint64_t v176 = v175;
  }
LABEL_261:
  if (v8 == 3) {
    int v179 = 4;
  }
  else {
    int v179 = 1;
  }
  if (v166 >= v176) {
    unsigned int v8 = v179;
  }
LABEL_266:
  uint64_t v180 = (uint64_t *)*((void *)v136 + 4);
  unint64_t v181 = *((void *)v136 + 3) - (void)v180;
  if (a8)
  {
    if (v181 <= 7)
    {
      uint64_t v182 = "!<thin>\n";
      goto LABEL_271;
    }
    uint64_t v222 = 0x6E6968743C21;
LABEL_338:
    uint64_t *v180 = v222 & 0xFFFFFFFFFFFFLL | 0xA3E000000000000;
    *((void *)v136 + 4) += 8;
  }
  else
  {
    if (v181 > 7)
    {
      uint64_t v222 = 0x686372613C21;
      goto LABEL_338;
    }
    uint64_t v182 = "!<arch>\n";
LABEL_271:
    llvm::raw_ostream::write(v136, v182, 8uLL);
  }
  uint64_t v183 = a2;
  if (a5 && (v8 - 3 < 2 || v282))
  {
    __srcb = p_p;
    uint64_t v184 = ((char *)v18 - (char *)v104) / 80;
    unsigned int v185 = 0;
    if (v18 != v104)
    {
      uint64_t v186 = 80 * v184;
      unint64_t v187 = v104 + 1;
      do
      {
        v185 += (*v187 - *(v187 - 1)) >> 2;
        v187 += 10;
        v186 -= 80;
      }
      while (v186);
    }
    uint64_t v188 = (unsigned int **)&v104[10 * v184];
    uint64_t v259 = v18;
    if (((1 << v8) & 0x6D) != 0)
    {
      char v189 = 2;
      if (v8 >= 2)
      {
        unsigned int v190 = v8;
        uint64_t v191 = 4;
        goto LABEL_283;
      }
LABEL_284:
      unsigned int v190 = v8;
      char v244 = v189;
      unint64_t v248 = v185;
      int v193 = 0;
      uint64_t v191 = 0;
      uint64_t v192 = (v185 + 1) << v189;
      uint64_t v194 = 2;
    }
    else
    {
      char v189 = 3;
      if (v8 <= 1) {
        goto LABEL_284;
      }
      unsigned int v190 = v8;
      uint64_t v191 = 8;
LABEL_283:
      char v244 = v189;
      unint64_t v248 = v185;
      uint64_t v192 = v191 + 2 * ((unint64_t)v185 << v189);
      int v193 = 1;
      uint64_t v194 = 8;
    }
    uint64_t v195 = v191 + v282 + v192;
    uint64_t v236 = (v194 + v195 - 1) & -v194;
    int v239 = v191 + v282 + v192;
    int v251 = v236 - v195;
    size_t __nb = v282;
    unint64_t v196 = v195 + (v236 - v195);
    sub_1CCC1A2AC(a2, v190, v223, v196);
    uint64_t v197 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a2 + 80))(a2);
    uint64_t v198 = *((void *)a2 + 4);
    uint64_t v199 = *((void *)a2 + 2);
    if (v193) {
      unint64_t v200 = (unint64_t)(2 * v185) << v244;
    }
    else {
      unint64_t v200 = v248;
    }
    sub_1CCC1A438(a2, v190, v200);
    if (v259 != v104)
    {
      unint64_t v201 = v197 + v196 + v198 - v199;
      uint64_t v202 = (unsigned int **)v104;
      do
      {
        int v203 = *v202;
        uint64_t v204 = v202[1];
        while (v203 != v204)
        {
          if (v193) {
            sub_1CCC1A438(a2, v190, *v203);
          }
          sub_1CCC1A438(a2, v190, v201);
          ++v203;
        }
        if (*((char *)v202 + 47) < 0) {
          int v205 = v202[4];
        }
        else {
          int v205 = (unsigned int *)*((unsigned __int8 *)v202 + 47);
        }
        v201 += (unint64_t)v202[9] + (void)v205 + (unint64_t)v202[7];
        v202 += 10;
      }
      while (v202 != v188);
    }
    if (v193) {
      sub_1CCC1A438(a2, v190, __nb);
    }
    uint64_t v206 = (void *)*((void *)a2 + 4);
    uint64_t v18 = v259;
    if (__nb <= *((void *)a2 + 3) - (void)v206)
    {
      if (__nb)
      {
        memcpy(v206, __srcb, __nb);
        *((void *)a2 + 4) += __nb;
      }
    }
    else
    {
      llvm::raw_ostream::write(a2, (const char *)__srcb, __nb);
    }
    uint64_t v183 = a2;
    if (v251)
    {
      int v207 = v239 - v236;
      do
        uint64_t v183 = llvm::raw_ostream::write(v183, 0);
      while (!__CFADD__(v207++, 1));
    }
  }
  long long v209 = v183;
  if (v104 != v18)
  {
    unsigned int v210 = v104;
    do
    {
      char v211 = *((unsigned char *)v210 + 47);
      int v212 = v211;
      if (v211 >= 0) {
        long long v213 = (const char *)(v210 + 3);
      }
      else {
        long long v213 = (const char *)v210[3];
      }
      size_t v214 = v211 & 0x7F;
      if (v212 >= 0) {
        size_t v215 = v214;
      }
      else {
        size_t v215 = (size_t)v210[4];
      }
      llvm::raw_ostream::write(v209, v213, v215);
      uint64_t v216 = v210[6];
      unint64_t v217 = (unint64_t)v210[7];
      __int16 v218 = (void *)*((void *)v209 + 4);
      if (v217 <= *((void *)v209 + 3) - (void)v218)
      {
        if (v217)
        {
          memcpy(v218, v216, (size_t)v210[7]);
          __int16 v218 = (void *)(*((void *)v209 + 4) + v217);
          *((void *)v209 + 4) = v218;
        }
      }
      else
      {
        llvm::raw_ostream::write(v209, (const char *)v216, (size_t)v210[7]);
        __int16 v218 = (void *)*((void *)v209 + 4);
      }
      int v219 = v210[8];
      unint64_t v220 = (unint64_t)v210[9];
      if (v220 <= *((void *)v209 + 3) - (void)v218)
      {
        if (v220)
        {
          memcpy(v218, v219, (size_t)v210[9]);
          *((void *)v209 + 4) += v220;
        }
      }
      else
      {
        llvm::raw_ostream::write(v209, (const char *)v219, (size_t)v210[9]);
      }
      v210 += 10;
    }
    while (v210 != v18);
  }
  uint64_t v221 = (const char *)*((void *)v209 + 2);
  if (*((const char **)v209 + 4) != v221)
  {
    *((void *)v209 + 4) = v221;
    llvm::raw_ostream::flush_tied_then_write(v209, v221);
  }
  *a1 = 0;
  if (v104)
  {
    while (v18 != v104)
    {
      if (*((char *)v18 - 33) < 0) {
        operator delete(*(v18 - 7));
      }
      int v105 = *(v18 - 10);
      if (v105)
      {
        *(v18 - 9) = v105;
        operator delete(v105);
      }
      v18 -= 10;
    }
    operator delete(v104);
  }
  v260 = (uint64_t (**)(void **))&unk_1F2646B98;
  if (v267 == 1 && v262) {
    MEMORY[0x1D25D9CB0](v262, 0x1000C8077774924);
  }
  if (v269 != &v272) {
    free(v269);
  }
  v272 = &unk_1F2646B98;
  if (v279 == 1 && v274) {
    MEMORY[0x1D25D9CB0](v274, 0x1000C8077774924);
  }
  if (p_p != &__p) {
    free(p_p);
  }
}

void llvm::writeArchiveToBuffer(size_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, unsigned int a4@<W3>, int a5@<W4>, int a6@<W5>, uint64_t a7@<X8>)
{
  v19[1] = 0;
  void v19[2] = 0;
  v19[0] = &v20;
  int v11 = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  uint64_t v18 = v19;
  int v17 = 0;
  unint64_t v10 = &unk_1F2646FA8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  sub_1CCC17C28(&v9, (llvm::raw_ostream *)&v10, a1, a2, a3, a4, a5, a6);
  uint64_t v8 = v9;
  if (!v9) {
    operator new();
  }
  *(unsigned char *)(a7 + 8) |= 1u;
  *(void *)a7 = v8;
  unint64_t v10 = &unk_1F2646B98;
  if (v17 == 1 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8077774924);
  }
  if (v19[0] != &v20) {
    free(v19[0]);
  }
}

void *sub_1CCC19C80(llvm::raw_ostream *a1, int a2, const void *a3, size_t a4, uint64_t *a5, unsigned int a6, unsigned int a7, unsigned int a8, uint64_t a9)
{
  int v15 = a2 + a4 + 67;
  int v16 = (v15 & 0xFFFFFFF8) - (a2 + a4) - 60;
  uint64_t v17 = (v15 & 0xFFFFFFF8) - a2 - 60;
  v23[0] = "#1/";
  v23[2] = v17;
  __int16 v24 = 2051;
  sub_1CCC1A0F0(a1, (uint64_t)v23);
  sub_1CCC19E84(a1, *a5, a6, a7, a8, v17 + a9);
  uint64_t result = (void *)*((void *)a1 + 4);
  if (a4 <= *((void *)a1 + 3) - (void)result)
  {
    if (a4)
    {
      uint64_t result = memcpy(result, a3, a4);
      *((void *)a1 + 4) += a4;
    }
  }
  else
  {
    uint64_t result = llvm::raw_ostream::write(a1, (const char *)a3, a4);
  }
  if (v16)
  {
    int v19 = a4 + a2 - (v15 & 0xFFFFFFF8) + 60;
    do
      uint64_t result = llvm::raw_ostream::write(a1, 0);
    while (!__CFADD__(v19++, 1));
  }
  return result;
}

llvm::raw_ostream *sub_1CCC19DA8(llvm::raw_ostream *a1, unint64_t a2, int a3)
{
  int v6 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1);
  int v7 = *((_DWORD *)a1 + 8);
  int v8 = *((_DWORD *)a1 + 4);
  sub_1CD098D14(a1, a2, 0, 0, 0);
  unsigned int v9 = v6
     + v7
     - ((*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1)
      + v8
      + *((_DWORD *)a1 + 8))
     + *((_DWORD *)a1 + 4)
     + a3;

  return llvm::raw_ostream::indent(a1, v9);
}

llvm::raw_ostream *sub_1CCC19E84(llvm::raw_ostream *a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, unint64_t a6)
{
  __t.__d_.__rep_ = 1000000 * a2;
  time_t v11 = std::chrono::system_clock::to_time_t(&__t);
  int v12 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1);
  uint64_t v13 = *((void *)a1 + 4);
  uint64_t v14 = *((void *)a1 + 2);
  if (v11 < 0)
  {
    unint64_t v16 = -v11;
    int v15 = a1;
    int v17 = 1;
  }
  else
  {
    int v15 = a1;
    unint64_t v16 = v11;
    int v17 = 0;
  }
  sub_1CD098D14(v15, v16, 0, 0, v17);
  int v18 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1);
  int v19 = llvm::raw_ostream::indent(a1, v12 + (int)v13 - (v18 + (int)v14 + *((_DWORD *)a1 + 8)) + *((_DWORD *)a1 + 4) + 12);
  sub_1CCC1A1D0(v19, a3 % 0xF4240, 6);
  sub_1CCC1A1D0(a1, a4 % 0xF4240, 6);
  v28[0] = &unk_1F25FED10;
  v28[1] = "%o";
  v28[2] = a5;
  int v20 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1);
  int v21 = *((_DWORD *)a1 + 8);
  int v22 = *((_DWORD *)a1 + 4);
  size_t v23 = llvm::raw_ostream::operator<<(a1, (uint64_t)v28);
  int v24 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(v23);
  __int16 v25 = llvm::raw_ostream::indent(a1, v20 + v21 - (v24 + v22 + *((_DWORD *)a1 + 8)) + *((_DWORD *)a1 + 4) + 8);
  uint64_t result = sub_1CCC19DA8(v25, a6, 10);
  uint64_t v27 = (_WORD *)*((void *)a1 + 4);
  if (*((void *)a1 + 3) - (void)v27 <= 1uLL) {
  _WORD *v27 = 2656;
  }
  *((void *)a1 + 4) += 2;
  return result;
}

llvm::raw_ostream *sub_1CCC1A0F0(llvm::raw_ostream *a1, uint64_t a2)
{
  long long v4 = (llvm::raw_ostream *)(*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1);
  int v5 = (int)v4;
  int v6 = *((_DWORD *)a1 + 8);
  int v7 = *((_DWORD *)a1 + 4);
  int v8 = llvm::Twine::printOneChild(v4, a1, *(void *)a2, *(void *)(a2 + 8), *(unsigned char *)(a2 + 32));
  llvm::Twine::printOneChild(v8, a1, *(void *)(a2 + 16), *(void *)(a2 + 24), *(unsigned char *)(a2 + 33));
  unsigned int v9 = v5
     + v6
     - ((*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1)
      + v7
      + *((_DWORD *)a1 + 8))
     + *((_DWORD *)a1 + 4)
     + 16;

  return llvm::raw_ostream::indent(a1, v9);
}

llvm::raw_ostream *sub_1CCC1A1D0(llvm::raw_ostream *a1, unsigned int a2, int a3)
{
  int v6 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1);
  int v7 = *((_DWORD *)a1 + 8);
  int v8 = *((_DWORD *)a1 + 4);
  sub_1CD098D14(a1, a2, 0, 0, 0);
  unsigned int v9 = v6
     + v7
     - ((*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1)
      + v8
      + *((_DWORD *)a1 + 8))
     + *((_DWORD *)a1 + 4)
     + a3;

  return llvm::raw_ostream::indent(a1, v9);
}

llvm::raw_ostream *sub_1CCC1A2AC(llvm::raw_ostream *a1, unsigned int a2, char a3, unint64_t a4)
{
  if (a2 < 2)
  {
    std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v11 = 0;
    if (a2) {
      uint64_t v12 = 6;
    }
    else {
      uint64_t v12 = 0;
    }
    if ((a3 & 1) == 0) {
      std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v11 = std::chrono::system_clock::now().__d_.__rep_ / 1000000;
    }
    uint64_t v13 = "/SYM64";
    if (!a2) {
      uint64_t v13 = "";
    }
    v16[0] = (uint64_t)v13;
    v16[1] = v12;
    v16[2] = (uint64_t)"/";
    __int16 v17 = 773;
    sub_1CCC1A0F0(a1, (uint64_t)v16);
    return sub_1CCC19E84(a1, v11, 0, 0, 0, a4);
  }
  else
  {
    uint64_t v8 = (*(uint64_t (**)(llvm::raw_ostream *))(*(void *)a1 + 80))(a1)
       + *((void *)a1 + 4)
       - *((void *)a1 + 2);
    if (a2 == 4) {
      size_t v9 = 12;
    }
    else {
      size_t v9 = 9;
    }
    if (a3) {
      std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v10 = 0;
    }
    else {
      std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v10 = std::chrono::system_clock::now().__d_.__rep_ / 1000000;
    }
    v16[0] = v10;
    if (a2 == 4) {
      int v15 = "__.SYMDEF_64";
    }
    else {
      int v15 = "__.SYMDEF";
    }
    return (llvm::raw_ostream *)sub_1CCC19C80(a1, v8, v15, v9, v16, 0, 0, 0, a4);
  }
}

llvm::raw_ostream *sub_1CCC1A438(llvm::raw_ostream *a1, unsigned int a2, unint64_t a3)
{
  if (((1 << a2) & 0x6D) != 0)
  {
    unsigned int v3 = bswap32(a3);
    if (a2 > 1) {
      unsigned int v3 = a3;
    }
    unsigned int v9 = v3;
    long long v4 = (const char *)&v9;
    size_t v5 = 4;
  }
  else
  {
    unint64_t v6 = bswap64(a3);
    if (a2 > 1) {
      unint64_t v6 = a3;
    }
    unint64_t v8 = v6;
    long long v4 = (const char *)&v8;
    size_t v5 = 8;
  }
  return llvm::raw_ostream::write(a1, v4, v5);
}

uint64_t *sub_1CCC1A4A0(uint64_t *a1)
{
  if (a1[5])
  {
    uint64_t v2 = *a1;
    *a1 = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  else if (*((char *)a1 + 31) < 0)
  {
    operator delete((void *)a1[1]);
  }
  return a1;
}

__n128 llvm::object::Binary::Binary(uint64_t a1, int a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F2632828;
  *(_DWORD *)(a1 + 8) = a2;
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
  *(_OWORD *)(a1 + 32) = v4;
  return result;
}

{
  __n128 result;
  long long v4;

  *(void *)a1 = &unk_1F2632828;
  *(_DWORD *)(a1 + 8) = a2;
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a3;
  *(_OWORD *)(a1 + 32) = v4;
  return result;
}

uint64_t llvm::object::Binary::getData(llvm::object::Binary *this)
{
  return *((void *)this + 2);
}

void llvm::object::createBinary(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (llvm::object *)llvm::identify_magic(*(unsigned __int8 **)a1, *(void *)(a1 + 8));
  if ((v8 - 3) >= 0x14)
  {
    switch((int)v8)
    {
      case 1:
      case 27:
      case 28:
      case 29:
      case 31:
      case 32:
      case 33:
      case 37:
        goto LABEL_2;
      case 2:
        long long v10 = *(_OWORD *)(a1 + 16);
        v17[0] = *(_OWORD *)a1;
        v17[1] = v10;
        llvm::object::Archive::create((uint64_t)v17);
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
        __break(1u);
        goto LABEL_7;
      case 23:
      case 24:
LABEL_7:
        long long v11 = *(_OWORD *)(a1 + 16);
        v15[2] = *(_OWORD *)a1;
        v15[3] = v11;
        llvm::object::MachOUniversalBinary::create();
      case 25:
        long long v12 = *(_OWORD *)(a1 + 16);
        v14[0] = *(_OWORD *)a1;
        v14[1] = v12;
        llvm::object::MinidumpFile::create(v14);
      case 30:
        long long v13 = *(_OWORD *)(a1 + 16);
        v15[0] = *(_OWORD *)a1;
        v15[1] = v13;
        llvm::object::WindowsResource::createWindowsResource(v15);
      case 35:
        llvm::object::TapiUniversal::create();
      default:
        *(void *)&v21.__val_ = llvm::object::object_category(v8);
        llvm::errorCodeToError((llvm *)2, v21, (void *)a4);
        *(unsigned char *)(a4 + 8) |= 1u;
        break;
    }
  }
  else
  {
LABEL_2:
    long long v9 = *(_OWORD *)(a1 + 16);
    v16[0] = *(_OWORD *)a1;
    v16[1] = v9;
    llvm::object::SymbolicFile::createSymbolicFile((uint64_t)v16, v8, a2, a3, (uint64_t)&v18);
    *(unsigned char *)(a4 + 8) = *(unsigned char *)(a4 + 8) & 0xFE | v19 & 1;
    *(void *)a4 = v18;
  }
}

void llvm::object::createBinary(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  __int16 v21 = 261;
  uint64_t v19 = a1;
  uint64_t v20 = a2;
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)&v19, 0, 0, (uint64_t)&v22);
  char cat = (char)v23.__cat_;
  if ((uint64_t)v23.__cat_)
  {
    long long v10 = v22;
    if (v22)
    {
      *(void *)&v8.__val_ = *(void *)&v23.__val_;
      llvm::errorCodeToError(v22, v8, &v18);
      *(unsigned char *)(a5 + 16) |= 1u;
      uint64_t v11 = v18;
LABEL_7:
      *(void *)a5 = v11;
      return;
    }
  }
  else
  {
    std::system_category();
    long long v10 = v22;
  }
  uint64_t v12 = *((void *)v10 + 1);
  uint64_t v13 = *((void *)v10 + 2) - v12;
  uint64_t v14 = (*(uint64_t (**)(llvm *))(*(void *)v10 + 16))(v10);
  v17[0] = v12;
  v17[1] = v13;
  _OWORD v17[2] = v14;
  void v17[3] = v15;
  llvm::object::createBinary((uint64_t)v17, a3, a4, (uint64_t)&v19);
  uint64_t v11 = v19;
  char v16 = *(unsigned char *)(a5 + 16);
  if ((v20 & 1) == 0)
  {
    *(unsigned char *)(a5 + 16) = v16 & 0xFE;
    *(void *)(a5 + 8) = v10;
    goto LABEL_7;
  }
  *(unsigned char *)(a5 + 16) = v16 | 1;
  *(void *)a5 = v11;
  if ((cat & 1) == 0) {
    (*(void (**)(llvm *))(*(void *)v10 + 8))(v10);
  }
}

void llvm::object::writeImportLibrary(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, long long *a5@<X4>, uint64_t a6@<X5>, int a7@<W6>, int a8@<W7>, char **a9@<X8>)
{
  uint64_t v341 = *MEMORY[0x1E4F143B8];
  v294[0] = 0;
  v294[1] = 0;
  v295[0] = 0;
  int v327 = 0;
  uint64_t v326 = 0;
  uint64_t v324 = a1;
  uint64_t v325 = a2;
  uint64_t v328 = a2;
  v329[0] = 0;
  llvm::sys::path::reverse_iterator::operator++((uint64_t)&v324);
  uint64_t v12 = v326;
  uint64_t v13 = (char *)v327;
  int v272 = a7;
  LODWORD(v324) = a7;
  uint64_t v326 = 0;
  uint64_t v325 = 0;
  int v327 = v329;
  uint64_t v328 = 0x400000000;
  uint64_t v330 = v332;
  uint64_t v331 = 0;
  v332[0] = 0;
  v332[1] = 1;
  __src = v12;
  size_t __n = (size_t)v13;
  if (v13 >= v13 - 4) {
    v13 -= 4;
  }
  v335 = v12;
  v336 = v13;
  WORD4(v316) = 1283;
  *(void *)__p = "__IMPORT_DESCRIPTOR_";
  *(void *)&__p[16] = v12;
  *(void *)&long long v316 = v13;
  llvm::Twine::str((llvm::Twine *)__p, &v337);
  WORD4(v283) = 1283;
  *(void *)long long __dst = "\x7F";
  *(void *)&__dst[16] = v335;
  *(void *)&long long v283 = v336;
  *(void *)__p = __dst;
  *(void *)&__p[16] = "_NULL_THUNK_DATA";
  WORD4(v316) = 770;
  llvm::Twine::str((llvm::Twine *)__p, &v339);
  int v291 = 0;
  unint64_t v292 = 0;
  uint64_t v293 = 0;
  __int16 v14 = v324;
  int v15 = __n + 151;
  if ((int)v324 > 34403) {
    __int16 v16 = 0;
  }
  else {
    __int16 v16 = 256;
  }
  sub_1CD674784((unint64_t *)&v291, 0x14uLL);
  __int16 v17 = v291;
  *(_WORD *)int v291 = v14;
  v17[1] = 2;
  *((_DWORD *)v17 + 1) = 0;
  *((_DWORD *)v17 + 2) = v15;
  *((_DWORD *)v17 + 3) = 7;
  unsigned char v17[8] = 0;
  v17[9] = v16;
  int v18 = __n + 1;
  uint64_t v19 = (char *)v291;
  int64_t v20 = v292 - (unsigned char *)v291;
  if ((unint64_t)(v292 - (unsigned char *)v291) > 0xFFFFFFFFFFFFFFAFLL)
  {
    v292 += 80;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v291, 0x50uLL);
    uint64_t v19 = (char *)v291;
  }
  int v21 = -1070596032;
  int v22 = &v19[v20];
  *(void *)int v22 = 0x322461746164692ELL;
  *(_OWORD *)(v22 + 8) = xmmword_1CFB29100;
  *((void *)v22 + 3) = 120;
  *((void *)v22 + 4) = 0xC030004000000003;
  *((void *)v22 + 5) = 0x362461746164692ELL;
  *((void *)v22 + 6) = 0;
  *((_DWORD *)v22 + 14) = v18;
  *((_DWORD *)v22 + 15) = 150;
  *((void *)v22 + 8) = 0;
  *((_DWORD *)v22 + 18) = 0;
  *((_DWORD *)v22 + 19) = -1071644608;
  std::error_code v23 = (char *)v291;
  int64_t v24 = v292 - (unsigned char *)v291;
  if ((unint64_t)(v292 - (unsigned char *)v291) > 0xFFFFFFFFFFFFFFEBLL)
  {
    v292 += 20;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v291, 0x14uLL);
    std::error_code v23 = (char *)v291;
  }
  __int16 v25 = &v23[v24];
  *(void *)__int16 v25 = 0;
  *((void *)v25 + 1) = 0;
  *((_DWORD *)v25 + 4) = 0;
  if ((int)v324 > 34403)
  {
    if (v324 == 34404)
    {
      __int16 v26 = 3;
      goto LABEL_18;
    }
  }
  else if (v324 == 332)
  {
    __int16 v26 = 7;
    goto LABEL_18;
  }
  __int16 v26 = 2;
LABEL_18:
  uint64_t v27 = (char *)v291;
  int64_t v28 = v292 - (unsigned char *)v291;
  if ((unint64_t)(v292 - (unsigned char *)v291) > 0xFFFFFFFFFFFFFFE1)
  {
    v292 += 30;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v291, 0x1EuLL);
    uint64_t v27 = (char *)v291;
  }
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v29 = &v27[v28];
  *(void *)std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v29 = 0x20000000CLL;
  *((_WORD *)v29 + 4) = v26;
  *(void *)(v29 + 10) = 0x300000000;
  *((_WORD *)v29 + 9) = v26;
  *(void *)(v29 + 20) = 0x400000010;
  *((_WORD *)v29 + 14) = v26;
  __int16 v30 = (char *)v291;
  int64_t v31 = v292 - (unsigned char *)v291;
  size_t v32 = __n;
  size_t v33 = __n + 1 + v292 - (unsigned char *)v291;
  if (v292 - (unsigned char *)v291 >= v33)
  {
    if (v292 - (unsigned char *)v291 > v33) {
      v292 += __n + 1;
    }
  }
  else
  {
    sub_1CD674784((unint64_t *)&v291, __n + 1);
    __int16 v30 = (char *)v291;
    size_t v32 = __n;
  }
  memcpy(&v30[v31], __src, v32);
  *((unsigned char *)v291 + __n + v31) = 0;
  if (v338 >= 0) {
    int v34 = SHIBYTE(v338) & 0x7F;
  }
  else {
    int v34 = DWORD2(v337);
  }
  int v35 = v34 + 5;
  if (byte_1EBCEF407 >= 0) {
    int v36 = byte_1EBCEF407 & 0x7F;
  }
  else {
    int v36 = DWORD2(xmmword_1EBCEF3F0);
  }
  int v37 = v35 + v36 + 1;
  unsigned int v38 = (char *)v291;
  int64_t v39 = v292 - (unsigned char *)v291;
  if ((unint64_t)(v292 - (unsigned char *)v291) > 0xFFFFFFFFFFFFFF81)
  {
    v292 += 126;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v291, 0x7EuLL);
    unsigned int v38 = (char *)v291;
  }
  unsigned int v40 = &v38[v39];
  *(void *)unsigned int v40 = 0x400000000;
  *((void *)v40 + 1) = 0x100000000;
  *((void *)v40 + 2) = 0x61746164692E0002;
  *((_WORD *)v40 + 12) = 12836;
  *(void *)(v40 + 26) = 0x100000000;
  *(void *)(v40 + 34) = 0x61746164692E0068;
  *((_WORD *)v40 + 21) = 13860;
  *(void *)(v40 + 44) = 0x200000000;
  *(void *)(v40 + 52) = 0x61746164692E0003;
  *((_WORD *)v40 + 30) = 13348;
  *(void *)(v40 + 62) = 0;
  *(void *)(v40 + 70) = 0x61746164692E0068;
  *((_WORD *)v40 + 39) = 13604;
  *((void *)v40 + 10) = 0;
  v40[88] = 104;
  *(_DWORD *)(v40 + 89) = 0;
  v40[93] = 0;
  *(_DWORD *)(v40 + 94) = v35;
  *(void *)(v40 + 98) = 0;
  v40[106] = 2;
  *(_DWORD *)(v40 + 107) = 0;
  v40[111] = 0;
  *((_DWORD *)v40 + 28) = v37;
  *(void *)(v40 + 116) = 0;
  *((_WORD *)v40 + 62) = 2;
  if (SHIBYTE(v338) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, (const void *)v337, *((unint64_t *)&v337 + 1));
  }
  else
  {
    *(_OWORD *)__p = v337;
    *(void *)&__p[16] = v338;
  }
  if (byte_1EBCEF407 < 0)
  {
    sub_1CB8BDF7C((uint64_t)&v316, (const void *)xmmword_1EBCEF3F0, *((unint64_t *)&xmmword_1EBCEF3F0 + 1));
  }
  else
  {
    long long v316 = xmmword_1EBCEF3F0;
    uint64_t v317 = unk_1EBCEF400;
  }
  if (SHIBYTE(v340) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v318, (const void *)v339, *((unint64_t *)&v339 + 1));
  }
  else
  {
    *(_OWORD *)uint64_t v318 = v339;
    uint64_t v319 = v340;
  }
  sub_1CCC1CA74((char *)&v291, (uint64_t)__p, 3);
  for (uint64_t i = 0; i != -9; i -= 3)
  {
    if (*((char *)&v319 + i * 8 + 7) < 0) {
      operator delete(v318[i]);
    }
  }
  uint64_t v42 = __src;
  size_t v43 = __n;
  *(void *)long long __dst = v291;
  *(void *)&__dst[8] = v292 - (unsigned char *)v291;
  *(void *)&__dst[16] = __src;
  *(void *)&long long v283 = __n;
  llvm::MemoryBuffer::getMemBuffer((uint64_t *)__dst, __p);
  *(void *)&__p[8] = v42;
  *(void *)&__p[16] = v43;
  long long v316 = 0uLL;
  LODWORD(v317) = 420;
  long long v44 = (char *)v294[1];
  uint64_t v45 = v295[0];
  if (v294[1] >= (void *)v295[0])
  {
    uint64_t v47 = a6;
    size_t v48 = (char *)v294[0];
    unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * (((char *)v294[1] - (char *)v294[0]) >> 4);
    unint64_t v50 = v49 + 1;
    if (v49 + 1 > 0x555555555555555) {
      goto LABEL_404;
    }
    if (0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) > v50) {
      unint64_t v50 = 0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v51 = 0x555555555555555;
    }
    else {
      unint64_t v51 = v50;
    }
    *((void *)&v283 + 1) = v295;
    if (v51)
    {
      if (v51 > 0x555555555555555) {
        goto LABEL_405;
      }
      long long v52 = (char *)operator new(48 * v51);
    }
    else
    {
      long long v52 = 0;
    }
    int v53 = &v52[48 * v49];
    long long v54 = v316;
    *(_OWORD *)(v53 + 8) = *(_OWORD *)&__p[8];
    uint64_t v55 = &v52[48 * v51];
    uint64_t v56 = *(void *)__p;
    *(void *)__p = 0;
    *(void *)int v53 = v56;
    *(_OWORD *)(v53 + 24) = v54;
    *((_DWORD *)v53 + 10) = v317;
    int v57 = v53 + 48;
    *(void *)&__dst[16] = v53 + 48;
    *(void *)&long long v283 = v55;
    if (v44 == v48)
    {
      uint64_t v58 = 0;
      int64x2_t v59 = vdupq_n_s64((unint64_t)v44);
      a6 = v47;
    }
    else
    {
      a6 = v47;
      do
      {
        uint64_t v60 = *((void *)v44 - 6);
        v44 -= 48;
        *(void *)long long v44 = 0;
        *((void *)v53 - 6) = v60;
        v53 -= 48;
        long long v61 = *(_OWORD *)(v44 + 8);
        long long v62 = *(_OWORD *)(v44 + 24);
        *((_DWORD *)v53 + 10) = *((_DWORD *)v44 + 10);
        *(_OWORD *)(v53 + 24) = v62;
        *(_OWORD *)(v53 + 8) = v61;
      }
      while (v44 != v48);
      int64x2_t v59 = *(int64x2_t *)v294;
      int v57 = *(void **)&__dst[16];
      uint64_t v55 = (char *)v283;
      uint64_t v45 = v295[0];
      uint64_t v58 = *(void *)__p;
    }
    v294[0] = v53;
    v294[1] = v57;
    *(int64x2_t *)&__dst[8] = v59;
    v295[0] = v55;
    *(void *)&long long v283 = v45;
    *(void *)long long __dst = v59.i64[0];
    sub_1CCC1CB58((uint64_t)__dst);
    v294[1] = v57;
    if (v58) {
      (*(void (**)(uint64_t))(*(void *)v58 + 8))(v58);
    }
  }
  else
  {
    uint64_t v46 = *(void *)__p;
    *(void *)__p = 0;
    *(void *)v294[1] = v46;
    *(_OWORD *)(v44 + 8) = *(_OWORD *)&__p[8];
    *(_OWORD *)(v44 + 24) = v316;
    *((_DWORD *)v44 + 10) = v317;
    v294[1] = v44 + 48;
  }
  v288 = 0;
  uint64_t v289 = 0;
  uint64_t v290 = 0;
  __int16 v63 = v324;
  if ((int)v324 > 34403) {
    __int16 v64 = 0;
  }
  else {
    __int16 v64 = 256;
  }
  sub_1CD674784((unint64_t *)&v288, 0x14uLL);
  time_t v65 = (char *)v288;
  *(_WORD *)v288 = v63;
  *((_WORD *)v65 + 1) = 1;
  *(void *)(v65 + 4) = 0x5000000000;
  *((_DWORD *)v65 + 3) = 1;
  *((_WORD *)v65 + 8) = 0;
  *((_WORD *)v65 + 9) = v64;
  uint64_t v66 = (char *)v288;
  int64_t v67 = v289 - (unsigned char *)v288;
  if ((unint64_t)(v289 - (unsigned char *)v288) > 0xFFFFFFFFFFFFFFD7)
  {
    v289 += 40;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v288, 0x28uLL);
    uint64_t v66 = (char *)v288;
  }
  uint64_t v68 = &v66[v67];
  *(void *)uint64_t v68 = 0x332461746164692ELL;
  *(_OWORD *)(v68 + 8) = xmmword_1CFB29110;
  *((void *)v68 + 3) = 0;
  *((_DWORD *)v68 + 8) = 0;
  *((_DWORD *)v68 + 9) = -1070596032;
  std::error_code v69 = (char *)v288;
  int64_t v70 = v289 - (unsigned char *)v288;
  if ((unint64_t)(v289 - (unsigned char *)v288) > 0xFFFFFFFFFFFFFFEBLL)
  {
    v289 += 20;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v288, 0x14uLL);
    std::error_code v69 = (char *)v288;
  }
  BOOL v71 = &v69[v70];
  *(void *)BOOL v71 = 0;
  *((void *)v71 + 1) = 0;
  *((_DWORD *)v71 + 4) = 0;
  uint64_t v72 = (char *)v288;
  int64_t v73 = v289 - (unsigned char *)v288;
  if ((unint64_t)(v289 - (unsigned char *)v288) > 0xFFFFFFFFFFFFFFEDLL)
  {
    v289 += 18;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v288, 0x12uLL);
    uint64_t v72 = (char *)v288;
  }
  uint64_t v74 = &v72[v73];
  *(void *)uint64_t v74 = 0x400000000;
  *((void *)v74 + 1) = 0x100000000;
  *((_WORD *)v74 + 8) = 2;
  if (byte_1EBCEF407 < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, (const void *)xmmword_1EBCEF3F0, *((unint64_t *)&xmmword_1EBCEF3F0 + 1));
  }
  else
  {
    *(_OWORD *)__p = xmmword_1EBCEF3F0;
    *(void *)&__p[16] = unk_1EBCEF400;
  }
  sub_1CCC1CA74((char *)&v288, (uint64_t)__p, 1);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  unint64_t v75 = __src;
  size_t v76 = __n;
  *(void *)long long __dst = v288;
  *(void *)&__dst[8] = v289 - (unsigned char *)v288;
  *(void *)&__dst[16] = __src;
  *(void *)&long long v283 = __n;
  llvm::MemoryBuffer::getMemBuffer((uint64_t *)__dst, __p);
  *(void *)&__p[8] = v75;
  *(void *)&__p[16] = v76;
  long long v316 = 0uLL;
  LODWORD(v317) = 420;
  std::string::size_type v77 = (char *)v294[1];
  uint64_t v78 = v295[0];
  if (v294[1] >= (void *)v295[0])
  {
    int v80 = (char *)v294[0];
    unint64_t v81 = 0xAAAAAAAAAAAAAAABLL * (((char *)v294[1] - (char *)v294[0]) >> 4);
    unint64_t v82 = v81 + 1;
    if (v81 + 1 > 0x555555555555555) {
      goto LABEL_404;
    }
    if (0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) > v82) {
      unint64_t v82 = 0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v83 = 0x555555555555555;
    }
    else {
      unint64_t v83 = v82;
    }
    *((void *)&v283 + 1) = v295;
    if (v83)
    {
      if (v83 > 0x555555555555555) {
        goto LABEL_405;
      }
      int v84 = (char *)operator new(48 * v83);
    }
    else
    {
      int v84 = 0;
    }
    int v85 = &v84[48 * v81];
    long long v86 = v316;
    *(_OWORD *)(v85 + 8) = *(_OWORD *)&__p[8];
    unint64_t v87 = &v84[48 * v83];
    uint64_t v88 = *(void *)__p;
    *(void *)__p = 0;
    *(void *)int v85 = v88;
    *(_OWORD *)(v85 + 24) = v86;
    *((_DWORD *)v85 + 10) = v317;
    uint64_t v89 = v85 + 48;
    *(void *)&__dst[16] = v85 + 48;
    *(void *)&long long v283 = v87;
    if (v77 == v80)
    {
      uint64_t v90 = 0;
      int64x2_t v91 = vdupq_n_s64((unint64_t)v77);
    }
    else
    {
      do
      {
        uint64_t v92 = *((void *)v77 - 6);
        v77 -= 48;
        *(void *)std::string::size_type v77 = 0;
        *((void *)v85 - 6) = v92;
        v85 -= 48;
        long long v93 = *(_OWORD *)(v77 + 8);
        long long v94 = *(_OWORD *)(v77 + 24);
        *((_DWORD *)v85 + 10) = *((_DWORD *)v77 + 10);
        *(_OWORD *)(v85 + 24) = v94;
        *(_OWORD *)(v85 + 8) = v93;
      }
      while (v77 != v80);
      int64x2_t v91 = *(int64x2_t *)v294;
      uint64_t v89 = *(void **)&__dst[16];
      unint64_t v87 = (char *)v283;
      uint64_t v78 = v295[0];
      uint64_t v90 = *(void *)__p;
    }
    v294[0] = v85;
    v294[1] = v89;
    *(int64x2_t *)&__dst[8] = v91;
    v295[0] = v87;
    *(void *)&long long v283 = v78;
    *(void *)long long __dst = v91.i64[0];
    sub_1CCC1CB58((uint64_t)__dst);
    v294[1] = v89;
    if (v90) {
      (*(void (**)(uint64_t))(*(void *)v90 + 8))(v90);
    }
  }
  else
  {
    uint64_t v79 = *(void *)__p;
    *(void *)__p = 0;
    *(void *)v294[1] = v79;
    *(_OWORD *)(v77 + 8) = *(_OWORD *)&__p[8];
    *(_OWORD *)(v77 + 24) = v316;
    *((_DWORD *)v77 + 10) = v317;
    v294[1] = v77 + 48;
  }
  long long v285 = 0;
  unsigned int v286 = 0;
  uint64_t v287 = 0;
  __int16 v95 = v324;
  if ((int)v324 > 34403) {
    int v96 = 8;
  }
  else {
    int v96 = 4;
  }
  if ((int)v324 > 34403) {
    __int16 v97 = 0;
  }
  else {
    __int16 v97 = 256;
  }
  sub_1CD674784((unint64_t *)&v285, 0x14uLL);
  uint64_t v98 = v285;
  *(_WORD *)long long v285 = v95;
  v98[1] = 2;
  *((_DWORD *)v98 + 1) = 0;
  *((_DWORD *)v98 + 2) = v96 + 100 + v96;
  *((_DWORD *)v98 + 3) = 1;
  v98[8] = 0;
  v98[9] = v97;
  if ((int)v324 > 34403) {
    int v99 = -1069547456;
  }
  else {
    int v99 = -1070596032;
  }
  if ((int)v324 > 34403) {
    int v21 = -1069547456;
  }
  std::string::size_type v100 = (char *)v285;
  int64_t v101 = v286 - (unsigned char *)v285;
  if ((unint64_t)(v286 - (unsigned char *)v285) > 0xFFFFFFFFFFFFFFAFLL)
  {
    v286 += 80;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v285, 0x50uLL);
    std::string::size_type v100 = (char *)v285;
  }
  std::string::size_type v102 = &v100[v101];
  *(void *)std::string::size_type v102 = 0x352461746164692ELL;
  *((void *)v102 + 1) = 0;
  *((_DWORD *)v102 + 4) = v96;
  *((_DWORD *)v102 + 5) = 100;
  *((void *)v102 + 3) = 0;
  *((_DWORD *)v102 + 8) = 0;
  *((_DWORD *)v102 + 9) = v99;
  *((void *)v102 + 5) = 0x342461746164692ELL;
  *((void *)v102 + 6) = 0;
  *((_DWORD *)v102 + 14) = v96;
  *((_DWORD *)v102 + 15) = v96 + 100;
  *((void *)v102 + 8) = 0;
  *((_DWORD *)v102 + 18) = 0;
  *((_DWORD *)v102 + 19) = v21;
  uint64_t v103 = (char *)v285;
  int64_t v104 = v286 - (unsigned char *)v285;
  if ((unint64_t)(v286 - (unsigned char *)v285) > 0xFFFFFFFFFFFFFFFBLL)
  {
    v286 += 4;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v285, 4uLL);
    uint64_t v103 = (char *)v285;
  }
  *(_DWORD *)&v103[v104] = 0;
  if ((int)v324 > 34403)
  {
    int v105 = (char *)v285;
    int64_t v106 = v286 - (unsigned char *)v285;
    if ((unint64_t)(v286 - (unsigned char *)v285) > 0xFFFFFFFFFFFFFFFBLL)
    {
      v286 += 4;
    }
    else
    {
      sub_1CD674784((unint64_t *)&v285, 4uLL);
      int v105 = (char *)v285;
    }
    *(_DWORD *)&v105[v106] = 0;
  }
  unint64_t v107 = (char *)v285;
  int64_t v108 = v286 - (unsigned char *)v285;
  if ((unint64_t)(v286 - (unsigned char *)v285) > 0xFFFFFFFFFFFFFFFBLL)
  {
    v286 += 4;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v285, 4uLL);
    unint64_t v107 = (char *)v285;
  }
  *(_DWORD *)&v107[v108] = 0;
  if ((int)v324 > 34403)
  {
    unsigned int v109 = (char *)v285;
    int64_t v110 = v286 - (unsigned char *)v285;
    if ((unint64_t)(v286 - (unsigned char *)v285) > 0xFFFFFFFFFFFFFFFBLL)
    {
      v286 += 4;
    }
    else
    {
      sub_1CD674784((unint64_t *)&v285, 4uLL);
      unsigned int v109 = (char *)v285;
    }
    *(_DWORD *)&v109[v110] = 0;
  }
  int v111 = (char *)v285;
  int64_t v112 = v286 - (unsigned char *)v285;
  if ((unint64_t)(v286 - (unsigned char *)v285) > 0xFFFFFFFFFFFFFFEDLL)
  {
    v286 += 18;
  }
  else
  {
    sub_1CD674784((unint64_t *)&v285, 0x12uLL);
    int v111 = (char *)v285;
  }
  int v113 = &v111[v112];
  *(void *)int v113 = 0x400000000;
  *((void *)v113 + 1) = 0x100000000;
  *((_WORD *)v113 + 8) = 2;
  if (SHIBYTE(v340) < 0)
  {
    sub_1CB8BDF7C((uint64_t)__p, (const void *)v339, *((unint64_t *)&v339 + 1));
  }
  else
  {
    *(_OWORD *)__p = v339;
    *(void *)&__p[16] = v340;
  }
  sub_1CCC1CA74((char *)&v285, (uint64_t)__p, 1);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v114 = __src;
  size_t v115 = __n;
  *(void *)long long __dst = v285;
  *(void *)&__dst[8] = v286 - (unsigned char *)v285;
  *(void *)&__dst[16] = __src;
  *(void *)&long long v283 = __n;
  llvm::MemoryBuffer::getMemBuffer((uint64_t *)__dst, __p);
  *(void *)&__p[8] = v114;
  *(void *)&__p[16] = v115;
  long long v316 = 0uLL;
  LODWORD(v317) = 420;
  std::string::size_type v116 = (char *)v294[1];
  uint64_t v117 = v295[0];
  if (v294[1] < (void *)v295[0])
  {
    uint64_t v118 = *(void *)__p;
    *(void *)__p = 0;
    *(void *)v294[1] = v118;
    *(_OWORD *)(v116 + 8) = *(_OWORD *)&__p[8];
    *(_OWORD *)(v116 + 24) = v316;
    *((_DWORD *)v116 + 10) = v317;
    v294[1] = v116 + 48;
    goto LABEL_157;
  }
  unsigned int v119 = (char *)v294[0];
  unint64_t v120 = 0xAAAAAAAAAAAAAAABLL * (((char *)v294[1] - (char *)v294[0]) >> 4);
  unint64_t v121 = v120 + 1;
  if (v120 + 1 > 0x555555555555555) {
LABEL_404:
  }
    abort();
  if (0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) > v121) {
    unint64_t v121 = 0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v122 = 0x555555555555555;
  }
  else {
    unint64_t v122 = v121;
  }
  *((void *)&v283 + 1) = v295;
  if (v122)
  {
    if (v122 <= 0x555555555555555)
    {
      v123 = (char *)operator new(48 * v122);
      goto LABEL_151;
    }
LABEL_405:
    sub_1CB833614();
  }
  v123 = 0;
LABEL_151:
  unint64_t v124 = &v123[48 * v120];
  long long v125 = v316;
  *(_OWORD *)(v124 + 8) = *(_OWORD *)&__p[8];
  long long v126 = &v123[48 * v122];
  uint64_t v127 = *(void *)__p;
  *(void *)__p = 0;
  *(void *)unint64_t v124 = v127;
  *(_OWORD *)(v124 + 24) = v125;
  *((_DWORD *)v124 + 10) = v317;
  uint64_t v128 = v124 + 48;
  *(void *)&__dst[16] = v124 + 48;
  *(void *)&long long v283 = v126;
  if (v116 == v119)
  {
    uint64_t v133 = 0;
    int64x2_t v132 = vdupq_n_s64((unint64_t)v116);
  }
  else
  {
    do
    {
      uint64_t v129 = *((void *)v116 - 6);
      v116 -= 48;
      *(void *)std::string::size_type v116 = 0;
      *((void *)v124 - 6) = v129;
      v124 -= 48;
      long long v130 = *(_OWORD *)(v116 + 8);
      long long v131 = *(_OWORD *)(v116 + 24);
      *((_DWORD *)v124 + 10) = *((_DWORD *)v116 + 10);
      *(_OWORD *)(v124 + 24) = v131;
      *(_OWORD *)(v124 + 8) = v130;
    }
    while (v116 != v119);
    int64x2_t v132 = *(int64x2_t *)v294;
    uint64_t v128 = *(void **)&__dst[16];
    long long v126 = (char *)v283;
    uint64_t v117 = v295[0];
    uint64_t v133 = *(void *)__p;
  }
  v294[0] = v124;
  v294[1] = v128;
  *(int64x2_t *)&__dst[8] = v132;
  v295[0] = v126;
  *(void *)&long long v283 = v117;
  *(void *)long long __dst = v132.i64[0];
  sub_1CCC1CB58((uint64_t)__dst);
  v294[1] = v128;
  if (v133) {
    (*(void (**)(uint64_t))(*(void *)v133 + 8))(v133);
  }
LABEL_157:
  if (a6)
  {
    int v134 = (long long *)((char *)a5 + 104 * a6);
    uint64_t v276 = v134;
    do
    {
      if (*((char *)a5 + 23) < 0)
      {
        sub_1CB8BDF7C((uint64_t)__p, *(const void **)a5, *((void *)a5 + 1));
      }
      else
      {
        long long v135 = *a5;
        *(void *)&__p[16] = *((void *)a5 + 2);
        *(_OWORD *)__p = v135;
      }
      if (*((char *)a5 + 47) < 0)
      {
        sub_1CB8BDF7C((uint64_t)&v316, *((const void **)a5 + 3), *((void *)a5 + 4));
      }
      else
      {
        long long v136 = *(long long *)((char *)a5 + 24);
        uint64_t v317 = *((void *)a5 + 5);
        long long v316 = v136;
      }
      if (*((char *)a5 + 71) < 0)
      {
        sub_1CB8BDF7C((uint64_t)v318, *((const void **)a5 + 6), *((void *)a5 + 7));
      }
      else
      {
        long long v137 = a5[3];
        uint64_t v319 = *((void *)a5 + 8);
        *(_OWORD *)uint64_t v318 = v137;
      }
      if (*((char *)a5 + 95) < 0)
      {
        sub_1CB8BDF7C((uint64_t)&v320, *((const void **)a5 + 9), *((void *)a5 + 10));
      }
      else
      {
        long long v138 = *(long long *)((char *)a5 + 72);
        uint64_t v321 = *((void *)a5 + 11);
        long long v320 = v138;
      }
      int v139 = *((_DWORD *)a5 + 24);
      __int16 v323 = *((_WORD *)a5 + 50);
      int v322 = v139;
      if ((_BYTE)v323)
      {
        int v140 = 3;
        goto LABEL_173;
      }
      if (HIBYTE(v323)) {
        char v141 = 2;
      }
      else {
        char v141 = HIBYTE(v322);
      }
      char v142 = HIBYTE(v319);
      uint64_t v143 = v318[1];
      if (v319 >= 0) {
        uint64_t v144 = (void *)(HIBYTE(v319) & 0x7F);
      }
      else {
        uint64_t v144 = v318[1];
      }
      BOOL v145 = v144 == 0;
      uint64_t v146 = 48;
      if (v145)
      {
        uint64_t v146 = 0;
        uint64_t v147 = (void **)__p;
      }
      else
      {
        uint64_t v147 = v318;
      }
      char v148 = __p[23];
      if (v145) {
        char v142 = __p[23];
      }
      int v149 = v142;
      uint64_t v150 = *(void ***)&__p[v146];
      size_t v151 = *(void *)&__p[8];
      if (v145) {
        uint64_t v143 = *(void **)&__p[8];
      }
      if (v142 >= 0) {
        unsigned int v152 = v147;
      }
      else {
        unsigned int v152 = v150;
      }
      size_t v153 = v142 & 0x7F;
      if (v149 >= 0) {
        size_t v154 = v153;
      }
      else {
        size_t v154 = (size_t)v143;
      }
      unsigned __int8 v279 = v141;
      if (BYTE2(v322))
      {
        __int16 v155 = 0;
        goto LABEL_206;
      }
      if (__p[23] >= 0) {
        uint64_t v168 = __p;
      }
      else {
        uint64_t v168 = *(unsigned char **)__p;
      }
      if (__p[23] >= 0) {
        size_t v169 = __p[23] & 0x7F;
      }
      else {
        size_t v169 = *(void *)&__p[8];
      }
      if (v169)
      {
        if (*v168 == 95)
        {
          unint64_t v170 = v152;
          size_t v171 = memchr(v168, 64, v169);
          unsigned int v152 = v170;
          if (v171)
          {
            if (v171 - v168 != -1 && !a8)
            {
              __int16 v155 = 4;
              goto LABEL_206;
            }
          }
        }
        if (v154 != v169)
        {
          __int16 v155 = 12;
          goto LABEL_206;
        }
        uint64_t v191 = v152;
        if (memcmp(v152, v168, v154))
        {
          __int16 v155 = 12;
          unsigned int v152 = v191;
          goto LABEL_206;
        }
        unsigned int v152 = v191;
        if (v272 == 332 && *(unsigned char *)v191 == 95)
        {
          __int16 v155 = 8;
          goto LABEL_206;
        }
      }
      else if (v154)
      {
        __int16 v155 = 12;
        goto LABEL_206;
      }
      __int16 v155 = 4;
LABEL_206:
      int v156 = SHIBYTE(v317);
      if (v317 >= 0) {
        size_t v157 = HIBYTE(v317) & 0x7F;
      }
      else {
        size_t v157 = *((void *)&v316 + 1);
      }
      __int16 v278 = v155;
      if (!v157)
      {
        if (v154 >= 0x7FFFFFFFFFFFFFF8) {
          goto LABEL_404;
        }
        if (v154 >= 0x17)
        {
          uint64_t v186 = (v154 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v154 | 7) != 0x17) {
            uint64_t v186 = v154 | 7;
          }
          uint64_t v187 = v186 + 1;
          uint64_t v188 = v152;
          char v189 = operator new(v186 + 1);
          unsigned int v152 = v188;
          int v172 = v189;
          *(void *)&__dst[8] = v154;
          *(void *)&__dst[16] = v187 | 0x8000000000000000;
          *(void *)long long __dst = v189;
        }
        else
        {
          __dst[23] = v154;
          int v172 = __dst;
          if (!v154)
          {
LABEL_274:
            v172[v154] = 0;
            v314 &= ~1u;
            *(_OWORD *)uint64_t v312 = *(_OWORD *)__dst;
            uint64_t v313 = *(long long **)&__dst[16];
            if (v314) {
              goto LABEL_275;
            }
            goto LABEL_253;
          }
        }
        memmove(v172, v152, v154);
        goto LABEL_274;
      }
      uint64_t v158 = *(unsigned char **)__p;
      uint64_t v159 = v316;
      if (v148 >= 0) {
        size_t v160 = __p;
      }
      else {
        size_t v160 = *(char **)__p;
      }
      if (v148 >= 0) {
        size_t v161 = v148 & 0x7F;
      }
      else {
        size_t v161 = v151;
      }
      int v162 = &v316;
      if (v317 < 0) {
        int v162 = (long long *)v316;
      }
      uint64_t v280 = v162;
      uint64_t v163 = (uint64_t)v152;
      v307[0] = (uint64_t)v152;
      v307[1] = v154;
      unint64_t v164 = llvm::StringRef::find(v307, v160, v161, 0);
      if (v164 == -1)
      {
        uint64_t v173 = v163;
        if (!v161) {
          goto LABEL_250;
        }
        unsigned int v174 = v280;
        if (*v160 != 95 || *(unsigned char *)v280 != 95) {
          goto LABEL_251;
        }
        unint64_t v175 = __p;
        if (v148 < 0) {
          unint64_t v175 = v158;
        }
        size_t v160 = v175 + 1;
        --v161;
        unint64_t v176 = (char *)&v316 + 1;
        if (v156 < 0) {
          unint64_t v176 = (char *)(v159 + 1);
        }
        uint64_t v280 = (long long *)v176;
        --v157;
        unint64_t v164 = llvm::StringRef::find(v307, v160, v161, 0);
        if (v164 == -1)
        {
          uint64_t v173 = v163;
LABEL_250:
          unsigned int v174 = v280;
LABEL_251:
          __int16 v297 = 773;
          v296[0] = v173;
          v296[1] = v154;
          v296[2] = ": replacing '";
          v298[0] = v296;
          v298[2] = v160;
          v298[3] = v161;
          __int16 v299 = 1282;
          v300[0] = v298;
          v300[2] = "' with '";
          __int16 v301 = 770;
          *(void *)&long long v302 = v300;
          uint64_t v303 = v174;
          size_t v304 = v157;
          __int16 v305 = 1282;
          v308 = &v302;
          v309.i64[1] = (uint64_t)"' failed";
          LOWORD(v311) = 770;
          llvm::Twine::str((llvm::Twine *)&v308, &v306);
          operator new();
        }
      }
      int v134 = v276;
      if (v154 >= v164) {
        unint64_t v165 = v164;
      }
      else {
        unint64_t v165 = v154;
      }
      v308 = (long long *)v163;
      v309.i64[0] = v165;
      v309.i64[1] = (uint64_t)v280;
      size_t v310 = v157;
      LOWORD(v311) = 1285;
      size_t v166 = v161 + v164;
      if (v154 < v161 + v164) {
        size_t v166 = v154;
      }
      *(void *)long long __dst = &v308;
      *(void *)&__dst[16] = v163 + v166;
      *(void *)&long long v283 = v154 - v166;
      WORD4(v283) = 1282;
      llvm::Twine::str((llvm::Twine *)__dst, &v302);
      char v167 = v314 & 0xFE;
      v314 &= ~1u;
      *(_OWORD *)uint64_t v312 = v302;
      uint64_t v313 = v303;
      if (v167)
      {
LABEL_275:
        size_t v190 = v312[0];
        v312[0] = 0;
        *a9 = (char *)v190;
        int v140 = 1;
        goto LABEL_335;
      }
LABEL_253:
      if (v321 >= 0) {
        uint64_t v177 = HIBYTE(v321) & 0x7F;
      }
      else {
        uint64_t v177 = *((void *)&v320 + 1);
      }
      size_t v178 = v312[1];
      int v179 = SHIBYTE(v313);
      if (!v177)
      {
        size_t v180 = HIBYTE(v313) & 0x7F;
LABEL_346:
        if (v179 >= 0) {
          unsigned int v234 = v312;
        }
        else {
          unsigned int v234 = (size_t *)v312[0];
        }
        if (v179 >= 0) {
          size_t v235 = v180;
        }
        else {
          size_t v235 = v178;
        }
        int v236 = (unsigned __int16)v322;
        int v237 = __n + v235;
        size_t v238 = __n + v235 + 22;
        uint64_t v239 = sub_1CB906F34(&v325, v238, 0);
        bzero((void *)v239, v238);
        *(_WORD *)(v239 + 2) = -1;
        *(_WORD *)(v239 + 6) = v324;
        *(_DWORD *)(v239 + 12) = v237 + 2;
        if (v236) {
          *(_WORD *)(v239 + 16) = v236;
        }
        *(_WORD *)(v239 + 18) = v278 | v279;
        memcpy((void *)(v239 + 20), v234, v235);
        memcpy((void *)(v235 + v239 + 20 + 1), __src, __n);
        unsigned int v240 = __src;
        size_t v241 = __n;
        v308 = (long long *)v239;
        v309.i64[0] = v238;
        v309.i64[1] = (uint64_t)__src;
        size_t v310 = __n;
        llvm::MemoryBuffer::getMemBuffer((uint64_t *)&v308, __dst);
        *(void *)&__dst[8] = v240;
        *(void *)&__dst[16] = v241;
        long long v283 = 0uLL;
        int v284 = 420;
        uint64_t v242 = (char *)v294[1];
        size_t v243 = v295[0];
        if (v294[1] >= (void *)v295[0])
        {
          unint64_t v245 = (char *)v294[0];
          unint64_t v246 = 0xAAAAAAAAAAAAAAABLL * (((char *)v294[1] - (char *)v294[0]) >> 4);
          unint64_t v247 = v246 + 1;
          if (v246 + 1 > 0x555555555555555) {
            goto LABEL_404;
          }
          if (0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) > v247) {
            unint64_t v247 = 0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v248 = 0x555555555555555;
          }
          else {
            unint64_t v248 = v247;
          }
          uint64_t v311 = v295;
          if (v248)
          {
            if (v248 > 0x555555555555555) {
              goto LABEL_405;
            }
            int v249 = (char *)operator new(48 * v248);
          }
          else
          {
            int v249 = 0;
          }
          BOOL v250 = &v249[48 * v246];
          long long v251 = v283;
          *(_OWORD *)(v250 + 8) = *(_OWORD *)&__dst[8];
          uint64_t v252 = &v249[48 * v248];
          uint64_t v253 = *(void *)__dst;
          *(void *)long long __dst = 0;
          *(void *)BOOL v250 = v253;
          *(_OWORD *)(v250 + 24) = v251;
          *((_DWORD *)v250 + 10) = v284;
          uint64_t v254 = v250 + 48;
          size_t v310 = (size_t)v252;
          v309.i64[1] = (uint64_t)(v250 + 48);
          if (v242 == v245)
          {
            uint64_t v259 = 0;
            int64x2_t v258 = vdupq_n_s64((unint64_t)v242);
          }
          else
          {
            do
            {
              uint64_t v255 = *((void *)v242 - 6);
              v242 -= 48;
              *(void *)uint64_t v242 = 0;
              *((void *)v250 - 6) = v255;
              v250 -= 48;
              long long v256 = *(_OWORD *)(v242 + 8);
              long long v257 = *(_OWORD *)(v242 + 24);
              *((_DWORD *)v250 + 10) = *((_DWORD *)v242 + 10);
              *(_OWORD *)(v250 + 24) = v257;
              *(_OWORD *)(v250 + 8) = v256;
            }
            while (v242 != v245);
            int64x2_t v258 = *(int64x2_t *)v294;
            uint64_t v254 = (void *)v309.i64[1];
            uint64_t v252 = (char *)v310;
            size_t v243 = v295[0];
            uint64_t v259 = *(void *)__dst;
          }
          v294[0] = v250;
          v294[1] = v254;
          int64x2_t v309 = v258;
          v295[0] = v252;
          size_t v310 = v243;
          v308 = (long long *)v258.i64[0];
          sub_1CCC1CB58((uint64_t)&v308);
          v294[1] = v254;
          if (v259) {
            (*(void (**)(uint64_t))(*(void *)v259 + 8))(v259);
          }
        }
        else
        {
          uint64_t v244 = *(void *)__dst;
          *(void *)long long __dst = 0;
          *(void *)v294[1] = v244;
          *(_OWORD *)(v242 + 8) = *(_OWORD *)&__dst[8];
          *(_OWORD *)(v242 + 24) = v283;
          *((_DWORD *)v242 + 10) = v284;
          v294[1] = v242 + 48;
        }
        int v140 = 0;
        goto LABEL_335;
      }
      size_t v180 = HIBYTE(v313) & 0x7F;
      if (SHIBYTE(v313) >= 0) {
        uint64_t v181 = HIBYTE(v313) & 0x7F;
      }
      else {
        uint64_t v181 = v312[1];
      }
      if (v321 >= 0) {
        uint64_t v182 = &v320;
      }
      else {
        uint64_t v182 = (long long *)v320;
      }
      if (v181 == v177)
      {
        if ((HIBYTE(v313) & 0x80) != 0)
        {
          if (!memcmp((const void *)v312[0], v182, v312[1])) {
            goto LABEL_346;
          }
        }
        else
        {
          if ((HIBYTE(v313) & 0x7F) == 0)
          {
            size_t v180 = 0;
            goto LABEL_346;
          }
          uint64_t v183 = v312;
          uint64_t v184 = (unsigned __int8 *)v182;
          uint64_t v185 = HIBYTE(v313) & 0x7F;
          while (*(unsigned __int8 *)v183 == *v184)
          {
            uint64_t v183 = (size_t *)((char *)v183 + 1);
            ++v184;
            if (!--v185) {
              goto LABEL_346;
            }
          }
        }
      }
      if (v179 >= 0) {
        uint64_t v192 = v312;
      }
      else {
        uint64_t v192 = (size_t *)v312[0];
      }
      sub_1CCC1C7B0((uint64_t)__dst, &v324, (uint64_t)v182, v177, (uint64_t)v192, v181, 0);
      int v193 = (char *)v294[1];
      size_t v194 = v295[0];
      if (v294[1] >= (void *)v295[0])
      {
        unint64_t v196 = (char *)v294[0];
        unint64_t v197 = 0xAAAAAAAAAAAAAAABLL * (((char *)v294[1] - (char *)v294[0]) >> 4);
        unint64_t v198 = v197 + 1;
        if (v197 + 1 > 0x555555555555555) {
          goto LABEL_404;
        }
        if (0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) > v198) {
          unint64_t v198 = 0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v199 = 0x555555555555555;
        }
        else {
          unint64_t v199 = v198;
        }
        uint64_t v311 = v295;
        if (v199)
        {
          if (v199 > 0x555555555555555) {
            goto LABEL_405;
          }
          unint64_t v200 = (char *)operator new(48 * v199);
        }
        else
        {
          unint64_t v200 = 0;
        }
        unint64_t v201 = &v200[48 * v197];
        long long v202 = v283;
        *(_OWORD *)(v201 + 8) = *(_OWORD *)&__dst[8];
        int v203 = &v200[48 * v199];
        uint64_t v204 = *(void *)__dst;
        *(void *)long long __dst = 0;
        *(void *)unint64_t v201 = v204;
        *(_OWORD *)(v201 + 24) = v202;
        *((_DWORD *)v201 + 10) = v284;
        int v205 = v201 + 48;
        size_t v310 = (size_t)v203;
        v309.i64[1] = (uint64_t)(v201 + 48);
        if (v193 == v196)
        {
          uint64_t v210 = 0;
          int64x2_t v209 = vdupq_n_s64((unint64_t)v193);
        }
        else
        {
          do
          {
            uint64_t v206 = *((void *)v193 - 6);
            v193 -= 48;
            *(void *)int v193 = 0;
            *((void *)v201 - 6) = v206;
            v201 -= 48;
            long long v207 = *(_OWORD *)(v193 + 8);
            long long v208 = *(_OWORD *)(v193 + 24);
            *((_DWORD *)v201 + 10) = *((_DWORD *)v193 + 10);
            *(_OWORD *)(v201 + 24) = v208;
            *(_OWORD *)(v201 + 8) = v207;
          }
          while (v193 != v196);
          int64x2_t v209 = *(int64x2_t *)v294;
          int v205 = (void *)v309.i64[1];
          int v203 = (char *)v310;
          size_t v194 = v295[0];
          uint64_t v210 = *(void *)__dst;
        }
        v294[0] = v201;
        v294[1] = v205;
        int64x2_t v309 = v209;
        v295[0] = v203;
        size_t v310 = v194;
        v308 = (long long *)v209.i64[0];
        sub_1CCC1CB58((uint64_t)&v308);
        v294[1] = v205;
        if (v210) {
          (*(void (**)(uint64_t))(*(void *)v210 + 8))(v210);
        }
      }
      else
      {
        uint64_t v195 = *(void *)__dst;
        *(void *)long long __dst = 0;
        *(void *)v294[1] = v195;
        *(_OWORD *)(v193 + 8) = *(_OWORD *)&__dst[8];
        *(_OWORD *)(v193 + 24) = v283;
        *((_DWORD *)v193 + 10) = v284;
        v294[1] = v193 + 48;
      }
      if (v321 >= 0) {
        char v211 = &v320;
      }
      else {
        char v211 = (long long *)v320;
      }
      if (v321 >= 0) {
        uint64_t v212 = HIBYTE(v321) & 0x7F;
      }
      else {
        uint64_t v212 = *((void *)&v320 + 1);
      }
      if (SHIBYTE(v313) >= 0) {
        long long v213 = v312;
      }
      else {
        long long v213 = (size_t *)v312[0];
      }
      if (SHIBYTE(v313) >= 0) {
        uint64_t v214 = HIBYTE(v313) & 0x7F;
      }
      else {
        uint64_t v214 = v312[1];
      }
      sub_1CCC1C7B0((uint64_t)__dst, &v324, (uint64_t)v211, v212, (uint64_t)v213, v214, 1);
      size_t v215 = (char *)v294[1];
      size_t v216 = v295[0];
      if (v294[1] >= (void *)v295[0])
      {
        __int16 v218 = (char *)v294[0];
        unint64_t v219 = 0xAAAAAAAAAAAAAAABLL * (((char *)v294[1] - (char *)v294[0]) >> 4);
        unint64_t v220 = v219 + 1;
        if (v219 + 1 > 0x555555555555555) {
          goto LABEL_404;
        }
        if (0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) > v220) {
          unint64_t v220 = 0x5555555555555556 * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v295[0] - (unint64_t)v294[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v221 = 0x555555555555555;
        }
        else {
          unint64_t v221 = v220;
        }
        uint64_t v311 = v295;
        if (v221)
        {
          if (v221 > 0x555555555555555) {
            goto LABEL_405;
          }
          uint64_t v222 = (char *)operator new(48 * v221);
        }
        else
        {
          uint64_t v222 = 0;
        }
        char v223 = &v222[48 * v219];
        long long v224 = v283;
        *(_OWORD *)(v223 + 8) = *(_OWORD *)&__dst[8];
        uint64_t v225 = &v222[48 * v221];
        uint64_t v226 = *(void *)__dst;
        *(void *)long long __dst = 0;
        *(void *)char v223 = v226;
        *(_OWORD *)(v223 + 24) = v224;
        *((_DWORD *)v223 + 10) = v284;
        uint64_t v227 = v223 + 48;
        size_t v310 = (size_t)v225;
        v309.i64[1] = (uint64_t)(v223 + 48);
        if (v215 == v218)
        {
          uint64_t v232 = 0;
          int64x2_t v231 = vdupq_n_s64((unint64_t)v215);
        }
        else
        {
          do
          {
            uint64_t v228 = *((void *)v215 - 6);
            v215 -= 48;
            *(void *)size_t v215 = 0;
            *((void *)v223 - 6) = v228;
            v223 -= 48;
            long long v229 = *(_OWORD *)(v215 + 8);
            long long v230 = *(_OWORD *)(v215 + 24);
            *((_DWORD *)v223 + 10) = *((_DWORD *)v215 + 10);
            *(_OWORD *)(v223 + 24) = v230;
            *(_OWORD *)(v223 + 8) = v229;
          }
          while (v215 != v218);
          int64x2_t v231 = *(int64x2_t *)v294;
          uint64_t v227 = (void *)v309.i64[1];
          uint64_t v225 = (char *)v310;
          size_t v216 = v295[0];
          uint64_t v232 = *(void *)__dst;
        }
        v294[0] = v223;
        v294[1] = v227;
        int64x2_t v309 = v231;
        v295[0] = v225;
        size_t v310 = v216;
        v308 = (long long *)v231.i64[0];
        sub_1CCC1CB58((uint64_t)&v308);
        v294[1] = v227;
        if (v232) {
          (*(void (**)(uint64_t))(*(void *)v232 + 8))(v232);
        }
      }
      else
      {
        uint64_t v217 = *(void *)__dst;
        *(void *)long long __dst = 0;
        *(void *)v294[1] = v217;
        *(_OWORD *)(v215 + 8) = *(_OWORD *)&__dst[8];
        *(_OWORD *)(v215 + 24) = v283;
        *((_DWORD *)v215 + 10) = v284;
        v294[1] = v215 + 48;
      }
      int v140 = 3;
LABEL_335:
      if (v314)
      {
        size_t v233 = v312[0];
        v312[0] = 0;
        if (v233) {
          (*(void (**)(size_t))(*(void *)v233 + 8))(v233);
        }
      }
      else if (SHIBYTE(v313) < 0)
      {
        operator delete((void *)v312[0]);
      }
LABEL_173:
      if (SHIBYTE(v321) < 0) {
        operator delete((void *)v320);
      }
      if (SHIBYTE(v319) < 0) {
        operator delete(v318[0]);
      }
      if (SHIBYTE(v317) < 0) {
        operator delete((void *)v316);
      }
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      if (v140 != 3 && v140) {
        goto LABEL_375;
      }
      a5 = (long long *)((char *)a5 + 104);
    }
    while (a5 != v134);
  }
  uint64_t v281 = 0;
  llvm::writeArchive(a3, a4, (size_t)v294[0], 0xAAAAAAAAAAAAAAABLL * (((char *)v294[1] - (char *)v294[0]) >> 4), 1, 0, 1, 0, a9, &v281);
  uint64_t v260 = v281;
  uint64_t v281 = 0;
  if (v260) {
    (*(void (**)(uint64_t))(*(void *)v260 + 8))(v260);
  }
LABEL_375:
  if (v285)
  {
    unsigned int v286 = (char *)v285;
    operator delete(v285);
  }
  if (v288)
  {
    uint64_t v289 = (char *)v288;
    operator delete(v288);
  }
  if (v291)
  {
    unint64_t v292 = (char *)v291;
    operator delete(v291);
  }
  if (SHIBYTE(v340) < 0) {
    operator delete((void *)v339);
  }
  if (SHIBYTE(v338) < 0) {
    operator delete((void *)v337);
  }
  if (v328)
  {
    int v261 = (uint64_t *)v327;
    uint64_t v262 = 8 * v328;
    do
    {
      uint64_t v263 = *v261++;
      MEMORY[0x1D25D9CD0](v263, 8);
      v262 -= 8;
    }
    while (v262);
  }
  v264 = (uint64_t *)v330;
  if (v331)
  {
    uint64_t v270 = 16 * v331;
    do
    {
      uint64_t v271 = *v264;
      v264 += 2;
      MEMORY[0x1D25D9CD0](v271, 8);
      v270 -= 16;
    }
    while (v270);
    v264 = (uint64_t *)v330;
  }
  if (v264 != v332) {
    free(v264);
  }
  if (v327 != v329) {
    free(v327);
  }
  char v265 = v294[0];
  if (v294[0])
  {
    uint64_t v266 = v294[1];
    int v267 = v294[0];
    if (v294[1] != v294[0])
    {
      do
      {
        uint64_t v269 = *(v266 - 6);
        v266 -= 6;
        uint64_t v268 = v269;
        void *v266 = 0;
        if (v269) {
          (*(void (**)(uint64_t))(*(void *)v268 + 8))(v268);
        }
      }
      while (v266 != v265);
      int v267 = v294[0];
    }
    v294[1] = v265;
    operator delete(v267);
  }
}

void sub_1CCC1C7B0(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  v36[3] = *MEMORY[0x1E4F143B8];
  __p = 0;
  size_t v33 = 0;
  uint64_t v34 = 0;
  int v14 = *(_DWORD *)a2;
  sub_1CD674784((unint64_t *)&__p, 0x14uLL);
  int v15 = (char *)__p;
  *(_WORD *)__p = v14;
  *((_WORD *)v15 + 1) = 1;
  *(void *)(v15 + 4) = 0x3C00000000;
  *(void *)(v15 + 12) = 5;
  __int16 v16 = (char *)__p;
  int64_t v17 = v33 - (unsigned char *)__p;
  if ((unint64_t)(v33 - (unsigned char *)__p) > 0xFFFFFFFFFFFFFFD7)
  {
    v33 += 40;
  }
  else
  {
    sub_1CD674784((unint64_t *)&__p, 0x28uLL);
    __int16 v16 = (char *)__p;
  }
  int v18 = &v16[v17];
  *(void *)int v18 = 0x657674636572642ELL;
  *((void *)v18 + 1) = 0;
  *((void *)v18 + 2) = 0;
  *((void *)v18 + 3) = 0;
  *((void *)v18 + 4) = 0xA0000000000;
  if (a7) {
    uint64_t v19 = 6;
  }
  else {
    uint64_t v19 = 0;
  }
  int64_t v20 = (char *)__p;
  int64_t v21 = v33 - (unsigned char *)__p;
  if ((unint64_t)(v33 - (unsigned char *)__p) > 0xFFFFFFFFFFFFFFA5)
  {
    v33 += 90;
  }
  else
  {
    sub_1CD674784((unint64_t *)&__p, 0x5AuLL);
    int64_t v20 = (char *)__p;
  }
  int v22 = &v20[v21];
  *(void *)int v22 = 0x64692E706D6F6340;
  *((void *)v22 + 1) = 0xFFFF00000000;
  *((void *)v22 + 2) = 0x2E74616566400003;
  *((_WORD *)v22 + 12) = 12336;
  *(void *)(v22 + 26) = 0xFFFF00000000;
  v22[34] = 3;
  *(_DWORD *)(v22 + 35) = 0;
  v22[39] = 0;
  *((_DWORD *)v22 + 10) = 4;
  *(void *)(v22 + 44) = 0;
  v22[52] = 2;
  *(_DWORD *)(v22 + 53) = 0;
  v22[57] = 0;
  *(_DWORD *)(v22 + 58) = a4 + v19 + 5;
  *(void *)(v22 + 62) = 0;
  *(_DWORD *)(v22 + 70) = 131433;
  *((_WORD *)v22 + 37) = 0;
  v22[76] = 3;
  *(void *)(v22 + 82) = 0;
  *(void *)(v22 + 77) = 0;
  if (a7) {
    std::error_code v23 = "__imp_";
  }
  else {
    std::error_code v23 = "";
  }
  v30[0] = v23;
  v30[1] = v19;
  void v30[2] = a3;
  v30[3] = a4;
  __int16 v31 = 1285;
  llvm::Twine::str((llvm::Twine *)v30, v35);
  v28[0] = v23;
  v28[1] = v19;
  v28[2] = a5;
  void v28[3] = a6;
  __int16 v29 = 1285;
  llvm::Twine::str((llvm::Twine *)v28, v36);
  sub_1CCC1CA74((char *)&__p, (uint64_t)v35, 2);
  for (uint64_t i = 0; i != -6; i -= 3)
  {
    if (SHIBYTE(v36[i + 2]) < 0) {
      operator delete((void *)v35[i + 3]);
    }
  }
  __int16 v25 = (void *)sub_1CB906F34(a2 + 1, v33 - (unsigned char *)__p, 0);
  memcpy(v25, __p, v33 - (unsigned char *)__p);
  uint64_t v27 = a2[13];
  uint64_t v26 = a2[14];
  v35[0] = (uint64_t)v25;
  v35[1] = v33 - (unsigned char *)__p;
  v35[2] = v27;
  v36[0] = v26;
  llvm::MemoryBuffer::getMemBuffer(v35, (void *)a1);
  *(void *)(a1 + 8) = v27;
  *(void *)(a1 + 16) = v26;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 420;
  if (__p)
  {
    size_t v33 = (char *)__p;
    operator delete(__p);
  }
}

char *sub_1CCC1CA74(char *result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)result;
  unint64_t v4 = *((void *)result + 1);
  unint64_t v5 = v4 - *(void *)result;
  if (a3)
  {
    int v7 = (unint64_t *)result;
    unint64_t v8 = v5 + 4;
    uint64_t v9 = 24 * a3;
    do
    {
      if (*(char *)(a2 + 23) < 0) {
        uint64_t v10 = *(void *)(a2 + 8);
      }
      else {
        uint64_t v10 = *(unsigned __int8 *)(a2 + 23);
      }
      unint64_t v11 = v10 + v8 + 1;
      unint64_t v12 = *v7;
      unint64_t v13 = v7[1] - *v7;
      if (v11 > v13)
      {
        sub_1CD674784(v7, v11 - v13);
        unint64_t v12 = *v7;
      }
      else if (v11 < v13)
      {
        v7[1] = v12 + v11;
      }
      int v14 = (const char *)a2;
      if (*(char *)(a2 + 23) < 0) {
        int v14 = *(const char **)a2;
      }
      __n128 result = strcpy((char *)(v12 + v8), v14);
      if (*(char *)(a2 + 23) < 0) {
        uint64_t v15 = *(void *)(a2 + 8);
      }
      else {
        uint64_t v15 = *(unsigned __int8 *)(a2 + 23);
      }
      v8 += v15 + 1;
      a2 += 24;
      v9 -= 24;
    }
    while (v9);
    unint64_t v3 = *v7;
    unint64_t v4 = v7[1];
  }
  *(_DWORD *)(v3 + v5) = v4 - v3 - v5;
  return result;
}

uint64_t sub_1CCC1CB58(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    uint64_t v4 = *(void *)(i - 48);
    *(void *)(i - 48) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CCC1CBD4()
{
  *(void *)&xmmword_1EBCEF3F0 = operator new(0x20uLL);
  *(long long *)((char *)&xmmword_1EBCEF3F0 + 8) = xmmword_1CD91A410;
  strcpy((char *)xmmword_1EBCEF3F0, "__NULL_IMPORT_DESCRIPTOR");
  v0 = (void (*)(void *))MEMORY[0x1E4FBA210];

  return __cxa_atexit(v0, &xmmword_1EBCEF3F0, &dword_1CB82C000);
}

void llvm::object::parseCOFFModuleDefinition(long long *a1@<X0>, int a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  long long v191 = *a1;
  *(_DWORD *)uint64_t v192 = 0;
  *(void *)&v192[8] = "";
  *(_OWORD *)&v192[16] = 0u;
  long long v193 = 0u;
  int v194 = a2;
  *(_OWORD *)uint64_t v195 = 0u;
  memset(v196, 0, sizeof(v196));
  *(_OWORD *)__p = 0u;
  memset(v198, 0, sizeof(v198));
  char v199 = a3;
  while (2)
  {
    if (*(void *)&v192[24] == (void)v193)
    {
      sub_1CCC1E804((uint64_t)__str, &v191);
      *(std::string *)uint64_t v192 = __str[0];
    }
    else
    {
      long long v4 = *(_OWORD *)(v193 - 24);
      *(void *)&v192[16] = *(void *)(v193 - 8);
      *(_OWORD *)uint64_t v192 = v4;
      *(void *)&long long v193 = v193 - 24;
    }
    int v5 = *(_DWORD *)v192;
    switch(*(_DWORD *)v192)
    {
      case 1:
        goto LABEL_359;
      case 9:
LABEL_8:
        if (*(void *)&v192[24] == (void)v193)
        {
          sub_1CCC1E804((uint64_t)__str, &v191);
          *(std::string *)uint64_t v192 = __str[0];
        }
        else
        {
          long long v7 = *(_OWORD *)(v193 - 24);
          *(void *)&v192[16] = *(void *)(v193 - 8);
          *(_OWORD *)uint64_t v192 = v7;
          *(void *)&long long v193 = v193 - 24;
        }
        if (*(_DWORD *)v192 == 2)
        {
          memset(v206, 0, 38);
          long long v205 = 0u;
          memset(__str, 0, sizeof(__str));
          std::string::size_type v8 = *(void *)&v192[16];
          if (*(void *)&v192[16] > 0x7FFFFFFFFFFFFFF7uLL) {
            goto LABEL_408;
          }
          uint64_t v9 = *(const void **)&v192[8];
          if (*(void *)&v192[16] >= 0x17uLL)
          {
            uint64_t v11 = (*(void *)&v192[16] & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((*(void *)&v192[16] | 7) != 0x17) {
              uint64_t v11 = *(void *)&v192[16] | 7;
            }
            uint64_t v12 = v11 + 1;
            p_dst = (std::string *)operator new(v11 + 1);
            __dst.__r_.__value_.__l.__size_ = v8;
            __dst.__r_.__value_.__r.__words[2] = v12 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          }
          else
          {
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v192[16];
            p_dst = &__dst;
            if (!*(void *)&v192[16])
            {
LABEL_20:
              p_dst->__r_.__value_.__s.__data_[v8] = 0;
              if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__str[0].__r_.__value_.__l.__data_);
              }
              __str[0] = __dst;
              if (*(void *)&v192[24] == (void)v193)
              {
                sub_1CCC1E804((uint64_t)&__dst, &v191);
                *(std::string *)uint64_t v192 = __dst;
              }
              else
              {
                long long v13 = *(_OWORD *)(v193 - 24);
                *(void *)&v192[16] = *(void *)(v193 - 8);
                *(_OWORD *)uint64_t v192 = v13;
                *(void *)&long long v193 = v193 - 24;
              }
              if (*(_DWORD *)v192 == 4)
              {
                if (*(void *)&v192[24] == (void)v193)
                {
                  sub_1CCC1E804((uint64_t)&__dst, &v191);
                  *(std::string *)uint64_t v192 = __dst;
                }
                else
                {
                  long long v14 = *(_OWORD *)(v193 - 24);
                  *(void *)&v192[16] = *(void *)(v193 - 8);
                  *(_OWORD *)uint64_t v192 = v14;
                  *(void *)&long long v193 = v193 - 24;
                }
                if (*(_DWORD *)v192 != 2)
                {
                  __int16 v203 = 1283;
                  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)"identifier expected, but got ";
                  __dst.__r_.__value_.__r.__words[2] = *(void *)&v192[8];
                  uint64_t v202 = *(void *)&v192[16];
                  operator new();
                }
                std::string::operator=(&__str[1], __str);
                std::string::size_type v23 = *(void *)&v192[16];
                if (*(void *)&v192[16] > 0x7FFFFFFFFFFFFFF7uLL) {
                  goto LABEL_408;
                }
                int64_t v24 = *(const void **)&v192[8];
                if (*(void *)&v192[16] >= 0x17uLL)
                {
                  uint64_t v26 = (*(void *)&v192[16] & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((*(void *)&v192[16] | 7) != 0x17) {
                    uint64_t v26 = *(void *)&v192[16] | 7;
                  }
                  uint64_t v27 = v26 + 1;
                  __int16 v25 = (std::string *)operator new(v26 + 1);
                  __dst.__r_.__value_.__l.__size_ = v23;
                  __dst.__r_.__value_.__r.__words[2] = v27 | 0x8000000000000000;
                  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
                }
                else
                {
                  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v192[16];
                  __int16 v25 = &__dst;
                  if (!*(void *)&v192[16])
                  {
LABEL_50:
                    v25->__r_.__value_.__s.__data_[v23] = 0;
                    if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__str[0].__r_.__value_.__l.__data_);
                    }
                    __str[0] = __dst;
                    goto LABEL_60;
                  }
                }
                memmove(v25, v24, v23);
                goto LABEL_50;
              }
              uint64_t v15 = (_OWORD *)v193;
              if ((unint64_t)v193 >= *((void *)&v193 + 1))
              {
                int v18 = *(_OWORD **)&v192[24];
                unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v193 - *(void *)&v192[24]) >> 3);
                unint64_t v20 = v19 + 1;
                if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  goto LABEL_408;
                }
                if (0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) > v20) {
                  unint64_t v20 = 0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) >= 0x555555555555555) {
                  unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v21 = v20;
                }
                if (v21)
                {
                  if (v21 > 0xAAAAAAAAAAAAAAALL) {
                    goto LABEL_409;
                  }
                  int v22 = (char *)operator new(24 * v21);
                }
                else
                {
                  int v22 = 0;
                }
                int64_t v28 = &v22[24 * v19];
                *(_OWORD *)int64_t v28 = *(_OWORD *)v192;
                *((void *)v28 + 2) = *(void *)&v192[16];
                __int16 v29 = v28;
                if (v15 != v18)
                {
                  do
                  {
                    long long v30 = *(_OWORD *)((char *)v15 - 24);
                    *((void *)v29 - 1) = *((void *)v15 - 1);
                    *(_OWORD *)(v29 - 24) = v30;
                    v29 -= 24;
                    uint64_t v15 = (_OWORD *)((char *)v15 - 24);
                  }
                  while (v15 != v18);
                  uint64_t v15 = *(_OWORD **)&v192[24];
                }
                int64_t v17 = v28 + 24;
                *(void *)&v192[24] = v29;
                *(void *)&long long v193 = v28 + 24;
                *((void *)&v193 + 1) = &v22[24 * v21];
                if (v15) {
                  operator delete(v15);
                }
              }
              else
              {
                long long v16 = *(_OWORD *)v192;
                *(void *)(v193 + 16) = *(void *)&v192[16];
                *uint64_t v15 = v16;
                int64_t v17 = (char *)v15 + 24;
              }
              *(void *)&long long v193 = v17;
LABEL_60:
              if (v194 == 332)
              {
                if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  __int16 v31 = __str;
                }
                else {
                  __int16 v31 = (std::string *)__str[0].__r_.__value_.__r.__words[0];
                }
                if ((__str[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type size = *((unsigned char *)&__str[0].__r_.__value_.__s + 23) & 0x7F;
                }
                else {
                  std::string::size_type size = __str[0].__r_.__value_.__l.__size_;
                }
                if ((sub_1CCC1EC4C((unsigned __int8 *)v31, size, v199) & 1) == 0)
                {
                  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 1;
                  LOWORD(__dst.__r_.__value_.__l.__data_) = 95;
                  size_t v33 = std::string::append(&__dst, (const std::string::value_type *)v31, size);
                  std::string::operator=(__str, v33);
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                    operator delete(__dst.__r_.__value_.__l.__data_);
                  }
                }
                if ((__str[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v34 = *((unsigned char *)&__str[1].__r_.__value_.__s + 23) & 0x7F;
                }
                else {
                  std::string::size_type v34 = __str[1].__r_.__value_.__l.__size_;
                }
                if (v34)
                {
                  int v35 = (__str[1].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                      ? &__str[1]
                      : (std::string *)__str[1].__r_.__value_.__r.__words[0];
                  if ((sub_1CCC1EC4C((unsigned __int8 *)v35, v34, v199) & 1) == 0)
                  {
                    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 1;
                    LOWORD(__dst.__r_.__value_.__l.__data_) = 95;
                    int v36 = std::string::append(&__dst, (const std::string::value_type *)v35, v34);
                    int v37 = &__str[1];
LABEL_79:
                    std::string::operator=(v37, v36);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    }
                  }
                }
              }
              while (2)
              {
                if (*(void *)&v192[24] == (void)v193)
                {
                  sub_1CCC1E804((uint64_t)&__dst, &v191);
                  *(std::string *)uint64_t v192 = __dst;
                }
                else
                {
                  long long v38 = *(_OWORD *)(v193 - 24);
                  *(void *)&v192[16] = *(void *)(v193 - 8);
                  *(_OWORD *)uint64_t v192 = v38;
                  *(void *)&long long v193 = v193 - 24;
                }
                switch(*(_DWORD *)v192)
                {
                  case 5:
                    if (*(void *)&v192[24] == (void)v193)
                    {
                      sub_1CCC1E804((uint64_t)&__dst, &v191);
                      *(std::string *)uint64_t v192 = __dst;
                    }
                    else
                    {
                      long long v39 = *(_OWORD *)(v193 - 24);
                      *(void *)&v192[16] = *(void *)(v193 - 8);
                      *(_OWORD *)uint64_t v192 = v39;
                      *(void *)&long long v193 = v193 - 24;
                    }
                    std::string::size_type v50 = *(void *)&v192[16];
                    if (*(void *)&v192[16] > 0x7FFFFFFFFFFFFFF7uLL) {
                      goto LABEL_408;
                    }
                    unint64_t v51 = *(const void **)&v192[8];
                    if (*(void *)&v192[16] >= 0x17uLL)
                    {
                      uint64_t v53 = (*(void *)&v192[16] & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((*(void *)&v192[16] | 7) != 0x17) {
                        uint64_t v53 = *(void *)&v192[16] | 7;
                      }
                      uint64_t v54 = v53 + 1;
                      long long v52 = (std::string *)operator new(v53 + 1);
                      __dst.__r_.__value_.__l.__size_ = v50;
                      __dst.__r_.__value_.__r.__words[2] = v54 | 0x8000000000000000;
                      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v52;
                    }
                    else
                    {
                      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v192[16];
                      long long v52 = &__dst;
                      if (!*(void *)&v192[16]) {
                        goto LABEL_119;
                      }
                    }
                    memmove(v52, v51, v50);
LABEL_119:
                    v52->__r_.__value_.__s.__data_[v50] = 0;
                    if (SHIBYTE(v206[1]) < 0) {
                      operator delete(*((void **)&v206[0] + 1));
                    }
                    *(std::string *)((char *)v206 + 8) = __dst;
                    if (v194 != 332) {
                      continue;
                    }
                    uint64_t v55 = v206[1] >= 0 ? (unsigned __int8 *)v206 + 8 : (unsigned __int8 *)*((void *)&v206[0] + 1);
                    size_t v56 = v206[1] >= 0 ? HIBYTE(v206[1]) & 0x7F : *(void *)&v206[1];
                    if (sub_1CCC1EC4C(v55, v56, v199)) {
                      continue;
                    }
                    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 1;
                    LOWORD(__dst.__r_.__value_.__l.__data_) = 95;
                    int v36 = std::string::append(&__dst, (const std::string::value_type *)v55, v56);
                    int v37 = (std::string *)((char *)v206 + 8);
                    goto LABEL_79;
                  case 6:
                  case 9:
                  case 0xA:
                  case 0xB:
                  case 0xC:
                  case 0xD:
                    goto LABEL_168;
                  case 7:
                    BYTE5(v206[2]) = 1;
                    continue;
                  case 8:
                    BYTE3(v206[2]) = 1;
                    continue;
                  case 0xE:
                    BYTE4(v206[2]) = 1;
                    continue;
                  default:
                    if (*(_DWORD *)v192 != 2 || **(unsigned char **)&v192[8] != 64)
                    {
LABEL_168:
                      unint64_t v75 = (void *)v193;
                      if ((unint64_t)v193 < *((void *)&v193 + 1)) {
                        goto LABEL_179;
                      }
                      size_t v76 = *(void **)&v192[24];
                      unint64_t v77 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v193 - *(void *)&v192[24]) >> 3);
                      unint64_t v78 = v77 + 1;
                      if (v77 + 1 <= 0xAAAAAAAAAAAAAAALL)
                      {
                        if (0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) > v78) {
                          unint64_t v78 = 0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3);
                        }
                        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) >= 0x555555555555555) {
                          unint64_t v79 = 0xAAAAAAAAAAAAAAALL;
                        }
                        else {
                          unint64_t v79 = v78;
                        }
                        if (v79)
                        {
                          if (v79 > 0xAAAAAAAAAAAAAAALL) {
                            goto LABEL_409;
                          }
                          int v80 = (char *)operator new(24 * v79);
                        }
                        else
                        {
                          int v80 = 0;
                        }
                        long long v86 = &v80[24 * v77];
                        *(_OWORD *)long long v86 = *(_OWORD *)v192;
                        *((void *)v86 + 2) = *(void *)&v192[16];
                        unint64_t v87 = v86;
                        if (v75 != v76)
                        {
                          do
                          {
                            long long v88 = *(_OWORD *)(v75 - 3);
                            *((void *)v87 - 1) = *(v75 - 1);
                            *(_OWORD *)(v87 - 24) = v88;
                            v87 -= 24;
                            v75 -= 3;
                          }
                          while (v75 != v76);
                          goto LABEL_196;
                        }
LABEL_197:
                        unint64_t v82 = v86 + 24;
                        *(void *)&v192[24] = v87;
                        *(void *)&long long v193 = v86 + 24;
                        *((void *)&v193 + 1) = &v80[24 * v79];
                        if (v75) {
                          operator delete(v75);
                        }
                        goto LABEL_199;
                      }
LABEL_408:
                      abort();
                    }
                    if (*(void *)&v192[16] == 1)
                    {
                      if (*(void *)&v192[24] == (void)v193)
                      {
                        sub_1CCC1E804((uint64_t)&__dst, &v191);
                        *(std::string *)uint64_t v192 = __dst;
                      }
                      else
                      {
                        long long v40 = *(_OWORD *)(v193 - 24);
                        *(void *)&v192[16] = *(void *)(v193 - 8);
                        *(_OWORD *)uint64_t v192 = v40;
                        *(void *)&long long v193 = v193 - 24;
                      }
                      uint64_t v57 = *(void *)&v192[16];
                      if (!*(void *)&v192[16]) {
                        goto LABEL_145;
                      }
                      unint64_t v58 = 0;
                      int64x2_t v59 = *(unsigned __int8 **)&v192[8];
                      do
                      {
                        int v60 = *v59;
                        if ((v60 - 48) >= 0xA)
                        {
                          if ((v60 - 97) >= 0x1A)
                          {
                            if ((v60 - 65) > 0x19) {
                              goto LABEL_145;
                            }
                            int v61 = -55;
                          }
                          else
                          {
                            int v61 = -87;
                          }
                        }
                        else
                        {
                          int v61 = -48;
                        }
                        unsigned int v62 = v61 + v60;
                        if (v62 > 9) {
                          goto LABEL_145;
                        }
                        unint64_t v48 = 10 * v58 + v62;
                        if (v58 > v48 / 0xA) {
                          goto LABEL_145;
                        }
                        ++v59;
                        unint64_t v58 = v48;
                        --v57;
                      }
                      while (v57);
                      if (v48 >= 0x10000)
                      {
LABEL_145:
                        if (*(void *)&v192[24] == (void)v193)
                        {
                          sub_1CCC1E804((uint64_t)&__dst, &v191);
                          *(std::string *)uint64_t v192 = __dst;
                        }
                        else
                        {
                          long long v63 = *(_OWORD *)(v193 - 24);
                          *(void *)&v192[16] = *(void *)(v193 - 8);
                          *(_OWORD *)uint64_t v192 = v63;
                          *(void *)&long long v193 = v193 - 24;
                        }
                        if (*(_DWORD *)v192 == 13)
                        {
                          BYTE2(v206[2]) = 1;
                        }
                        else
                        {
                          __int16 v64 = (_OWORD *)v193;
                          if ((unint64_t)v193 >= *((void *)&v193 + 1))
                          {
                            int64_t v67 = *(_OWORD **)&v192[24];
                            unint64_t v68 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v193 - *(void *)&v192[24]) >> 3);
                            unint64_t v69 = v68 + 1;
                            if (v68 + 1 > 0xAAAAAAAAAAAAAAALL) {
                              goto LABEL_408;
                            }
                            if (0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) > v69) {
                              unint64_t v69 = 0x5555555555555556
                            }
                                  * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3);
                            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) >= 0x555555555555555) {
                              unint64_t v70 = 0xAAAAAAAAAAAAAAALL;
                            }
                            else {
                              unint64_t v70 = v69;
                            }
                            if (v70)
                            {
                              if (v70 > 0xAAAAAAAAAAAAAAALL) {
                                goto LABEL_409;
                              }
                              BOOL v71 = (char *)operator new(24 * v70);
                            }
                            else
                            {
                              BOOL v71 = 0;
                            }
                            uint64_t v72 = &v71[24 * v68];
                            *(_OWORD *)uint64_t v72 = *(_OWORD *)v192;
                            *((void *)v72 + 2) = *(void *)&v192[16];
                            int64_t v73 = v72;
                            if (v64 != v67)
                            {
                              do
                              {
                                long long v74 = *(_OWORD *)((char *)v64 - 24);
                                *((void *)v73 - 1) = *((void *)v64 - 1);
                                *(_OWORD *)(v73 - 24) = v74;
                                v73 -= 24;
                                __int16 v64 = (_OWORD *)((char *)v64 - 24);
                              }
                              while (v64 != v67);
                              __int16 v64 = *(_OWORD **)&v192[24];
                            }
                            uint64_t v66 = v72 + 24;
                            *(void *)&v192[24] = v73;
                            *(void *)&long long v193 = v72 + 24;
                            *((void *)&v193 + 1) = &v71[24 * v70];
                            if (v64) {
                              operator delete(v64);
                            }
                          }
                          else
                          {
                            long long v65 = *(_OWORD *)v192;
                            *(void *)(v193 + 16) = *(void *)&v192[16];
                            *__int16 v64 = v65;
                            uint64_t v66 = (char *)v64 + 24;
                          }
                          *(void *)&long long v193 = v66;
                        }
                        continue;
                      }
                    }
                    else
                    {
                      uint64_t v41 = *(void *)&v192[16] != 0;
                      if (*(void *)&v192[16] == v41) {
                        goto LABEL_178;
                      }
                      unint64_t v42 = 0;
                      size_t v43 = (unsigned __int8 *)(*(void *)&v192[8] + v41);
                      uint64_t v44 = v41 - *(void *)&v192[16];
                      do
                      {
                        int v45 = *v43;
                        if ((v45 - 48) >= 0xA)
                        {
                          if ((v45 - 97) >= 0x1A)
                          {
                            if ((v45 - 65) > 0x19) {
                              goto LABEL_178;
                            }
                            int v46 = -55;
                          }
                          else
                          {
                            int v46 = -87;
                          }
                        }
                        else
                        {
                          int v46 = -48;
                        }
                        unsigned int v47 = v46 + v45;
                        if (v47 > 9) {
                          goto LABEL_178;
                        }
                        unint64_t v48 = 10 * v42 + v47;
                        if (v42 > v48 / 0xA) {
                          goto LABEL_178;
                        }
                        ++v43;
                        unint64_t v42 = v48;
                      }
                      while (!__CFADD__(v44++, 1));
                      if (v48 >= 0x10000)
                      {
LABEL_178:
                        unint64_t v75 = (void *)v193;
                        if ((unint64_t)v193 < *((void *)&v193 + 1))
                        {
LABEL_179:
                          long long v81 = *(_OWORD *)v192;
                          v75[2] = *(void *)&v192[16];
                          *(_OWORD *)unint64_t v75 = v81;
                          unint64_t v82 = v75 + 3;
LABEL_199:
                          *(void *)&long long v193 = v82;
                          uint64_t v90 = (char *)v195[1];
                          if (v195[1] >= v196[0])
                          {
                            uint64_t v92 = sub_1CCC1ED20(v195, (uint64_t)__str);
                          }
                          else
                          {
                            if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0)
                            {
                              sub_1CB8BDF7C((uint64_t)v195[1], __str[0].__r_.__value_.__l.__data_, __str[0].__r_.__value_.__l.__size_);
                            }
                            else
                            {
                              long long v91 = *(_OWORD *)&__str[0].__r_.__value_.__l.__data_;
                              *((void *)v195[1] + 2) = *((void *)&__str[0].__r_.__value_.__l + 2);
                              *(_OWORD *)uint64_t v90 = v91;
                            }
                            long long v93 = v90 + 24;
                            if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0)
                            {
                              sub_1CB8BDF7C((uint64_t)v93, __str[1].__r_.__value_.__l.__data_, __str[1].__r_.__value_.__l.__size_);
                            }
                            else
                            {
                              long long v94 = *(_OWORD *)&__str[1].__r_.__value_.__l.__data_;
                              *((void *)v90 + 5) = *((void *)&__str[1].__r_.__value_.__l + 2);
                              *long long v93 = v94;
                            }
                            __int16 v95 = v90 + 48;
                            if (SBYTE7(v206[0]) < 0)
                            {
                              sub_1CB8BDF7C((uint64_t)v95, (const void *)v205, *((unint64_t *)&v205 + 1));
                            }
                            else
                            {
                              long long v96 = v205;
                              *((void *)v90 + 8) = *(void *)&v206[0];
                              *__int16 v95 = v96;
                            }
                            __int16 v97 = v90 + 72;
                            if (SHIBYTE(v206[1]) < 0)
                            {
                              sub_1CB8BDF7C((uint64_t)v97, *((const void **)&v206[0] + 1), *(unint64_t *)&v206[1]);
                            }
                            else
                            {
                              long long v98 = *(_OWORD *)((char *)v206 + 8);
                              *((void *)v90 + 11) = *((void *)&v206[1] + 1);
                              *__int16 v97 = v98;
                            }
                            int v99 = v206[2];
                            *((_WORD *)v90 + 50) = WORD2(v206[2]);
                            *((_DWORD *)v90 + 24) = v99;
                            uint64_t v92 = v90 + 104;
                          }
                          v195[1] = v92;
                          uint64_t v200 = 0;
                          if (SHIBYTE(v206[1]) < 0) {
                            operator delete(*((void **)&v206[0] + 1));
                          }
                          if (SBYTE7(v206[0]) < 0) {
                            operator delete((void *)v205);
                          }
                          if (SHIBYTE(__str[1].__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(__str[1].__r_.__value_.__l.__data_);
                          }
                          if (SHIBYTE(__str[0].__r_.__value_.__r.__words[2]) < 0) {
                            operator delete(__str[0].__r_.__value_.__l.__data_);
                          }
                          goto LABEL_8;
                        }
                        unint64_t v83 = *(void **)&v192[24];
                        unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v193 - *(void *)&v192[24]) >> 3);
                        unint64_t v85 = v84 + 1;
                        if (v84 + 1 <= 0xAAAAAAAAAAAAAAALL)
                        {
                          if (0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) > v85) {
                            unint64_t v85 = 0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3);
                          }
                          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) >= 0x555555555555555) {
                            unint64_t v79 = 0xAAAAAAAAAAAAAAALL;
                          }
                          else {
                            unint64_t v79 = v85;
                          }
                          if (v79)
                          {
                            if (v79 <= 0xAAAAAAAAAAAAAAALL)
                            {
                              int v80 = (char *)operator new(24 * v79);
                              goto LABEL_194;
                            }
LABEL_409:
                            sub_1CB833614();
                          }
                          int v80 = 0;
LABEL_194:
                          long long v86 = &v80[24 * v84];
                          *(_OWORD *)long long v86 = *(_OWORD *)v192;
                          *((void *)v86 + 2) = *(void *)&v192[16];
                          unint64_t v87 = v86;
                          if (v75 != v83)
                          {
                            do
                            {
                              long long v89 = *(_OWORD *)(v75 - 3);
                              *((void *)v87 - 1) = *(v75 - 1);
                              *(_OWORD *)(v87 - 24) = v89;
                              v87 -= 24;
                              v75 -= 3;
                            }
                            while (v75 != v83);
LABEL_196:
                            unint64_t v75 = *(void **)&v192[24];
                          }
                          goto LABEL_197;
                        }
                        goto LABEL_408;
                      }
                    }
                    LOWORD(v206[2]) = v48;
                    goto LABEL_145;
                }
              }
            }
          }
          memmove(p_dst, v9, v8);
          goto LABEL_20;
        }
        unsigned int v109 = (_OWORD *)v193;
        if ((unint64_t)v193 >= *((void *)&v193 + 1))
        {
          char v142 = *(_OWORD **)&v192[24];
          unint64_t v143 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v193 - *(void *)&v192[24]) >> 3);
          unint64_t v144 = v143 + 1;
          if (v143 + 1 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_408;
          }
          if (0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) > v144) {
            unint64_t v144 = 0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) >= 0x555555555555555) {
            unint64_t v145 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v145 = v144;
          }
          if (v145)
          {
            if (v145 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_409;
            }
            uint64_t v146 = (char *)operator new(24 * v145);
          }
          else
          {
            uint64_t v146 = 0;
          }
          __int16 v155 = &v146[24 * v143];
          *(_OWORD *)__int16 v155 = *(_OWORD *)v192;
          *((void *)v155 + 2) = *(void *)&v192[16];
          int v156 = v155;
          if (v109 != v142)
          {
            do
            {
              long long v157 = *(_OWORD *)((char *)v109 - 24);
              *((void *)v156 - 1) = *((void *)v109 - 1);
              *(_OWORD *)(v156 - 24) = v157;
              v156 -= 24;
              unsigned int v109 = (_OWORD *)((char *)v109 - 24);
            }
            while (v109 != v142);
            unsigned int v109 = *(_OWORD **)&v192[24];
          }
          int v111 = v155 + 24;
          *(void *)&v192[24] = v156;
          *(void *)&long long v193 = v155 + 24;
          *((void *)&v193 + 1) = &v146[24 * v145];
          if (v109) {
            operator delete(v109);
          }
        }
        else
        {
          long long v110 = *(_OWORD *)v192;
          *(void *)(v193 + 16) = *(void *)&v192[16];
          _OWORD *v109 = v110;
          int v111 = (char *)v109 + 24;
        }
        *(void *)&long long v193 = v111;
        goto LABEL_352;
      case 0xA:
        std::string::size_type v100 = &v198[4];
        int64_t v101 = &v198[5];
        goto LABEL_227;
      case 0xB:
      case 0xC:
        memset(&__dst, 0, sizeof(__dst));
        if (*(void *)&v192[24] == (void)v193)
        {
          sub_1CCC1E804((uint64_t)__str, &v191);
          *(std::string *)uint64_t v192 = __str[0];
        }
        else
        {
          long long v6 = *(_OWORD *)(v193 - 24);
          *(void *)&v192[16] = *(void *)(v193 - 8);
          *(_OWORD *)uint64_t v192 = v6;
          *(void *)&long long v193 = v193 - 24;
        }
        if (*(_DWORD *)v192 != 2)
        {
          MEMORY[0x1D25D9630](&__dst, "");
          int64_t v106 = (_OWORD *)v193;
          if ((unint64_t)v193 >= *((void *)&v193 + 1))
          {
            int64_t v112 = *(_OWORD **)&v192[24];
            unint64_t v113 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v193 - *(void *)&v192[24]) >> 3);
            unint64_t v114 = v113 + 1;
            if (v113 + 1 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_408;
            }
            if (0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) > v114) {
              unint64_t v114 = 0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) >= 0x555555555555555) {
              unint64_t v115 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v115 = v114;
            }
            if (v115)
            {
              if (v115 > 0xAAAAAAAAAAAAAAALL) {
                goto LABEL_409;
              }
              std::string::size_type v116 = (char *)operator new(24 * v115);
            }
            else
            {
              std::string::size_type v116 = 0;
            }
            unsigned int v152 = &v116[24 * v113];
            *(_OWORD *)unsigned int v152 = *(_OWORD *)v192;
            *((void *)v152 + 2) = *(void *)&v192[16];
            size_t v153 = v152;
            if (v106 != v112)
            {
              do
              {
                long long v154 = *(_OWORD *)((char *)v106 - 24);
                *((void *)v153 - 1) = *((void *)v106 - 1);
                *(_OWORD *)(v153 - 24) = v154;
                v153 -= 24;
                int64_t v106 = (_OWORD *)((char *)v106 - 24);
              }
              while (v106 != v112);
              int64_t v106 = *(_OWORD **)&v192[24];
            }
            int64_t v108 = v152 + 24;
            *(void *)&v192[24] = v153;
            *(void *)&long long v193 = v152 + 24;
            *((void *)&v193 + 1) = &v116[24 * v115];
            if (v106) {
              operator delete(v106);
            }
          }
          else
          {
            long long v107 = *(_OWORD *)v192;
            *(void *)(v193 + 16) = *(void *)&v192[16];
            _OWORD *v106 = v107;
            int64_t v108 = (char *)v106 + 24;
          }
          *(void *)&long long v193 = v108;
LABEL_345:
          std::string::operator=((std::string *)__p, &__dst);
          size_t v161 = (void *)HIBYTE(v196[3]);
          if (SHIBYTE(v196[3]) < 0) {
            size_t v161 = v196[2];
          }
          if (!v161)
          {
            std::string::operator=((std::string *)&v196[1], &__dst);
            LOWORD(__str[1].__r_.__value_.__r.__words[1]) = 260;
            __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&__dst;
            if (!llvm::sys::path::has_extension((llvm::sys::path *)__str, 0))
            {
              if (v5 == 11) {
                uint64_t v163 = ".dll";
              }
              else {
                uint64_t v163 = ".exe";
              }
              std::string::append((std::string *)&v196[1], v163);
            }
          }
          uint64_t v200 = 0;
          goto LABEL_349;
        }
        std::string::size_type v103 = *(void *)&v192[16];
        if (*(void *)&v192[16] > 0x7FFFFFFFFFFFFFF7uLL) {
          goto LABEL_408;
        }
        int64_t v104 = *(const void **)&v192[8];
        if (*(void *)&v192[16] >= 0x17uLL)
        {
          uint64_t v117 = (*(void *)&v192[16] & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((*(void *)&v192[16] | 7) != 0x17) {
            uint64_t v117 = *(void *)&v192[16] | 7;
          }
          uint64_t v118 = v117 + 1;
          int v105 = (std::string *)operator new(v117 + 1);
          __str[0].__r_.__value_.__l.__size_ = v103;
          __str[0].__r_.__value_.__r.__words[2] = v118 | 0x8000000000000000;
          __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v105;
        }
        else
        {
          *((unsigned char *)&__str[0].__r_.__value_.__s + 23) = v192[16];
          int v105 = __str;
          if (!*(void *)&v192[16]) {
            goto LABEL_251;
          }
        }
        memmove(v105, v104, v103);
LABEL_251:
        v105->__r_.__value_.__s.__data_[v103] = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        std::string __dst = __str[0];
        if (*(void *)&v192[24] == (void)v193)
        {
          sub_1CCC1E804((uint64_t)__str, &v191);
          *(std::string *)uint64_t v192 = __str[0];
        }
        else
        {
          long long v119 = *(_OWORD *)(v193 - 24);
          *(void *)&v192[16] = *(void *)(v193 - 8);
          *(_OWORD *)uint64_t v192 = v119;
          *(void *)&long long v193 = v193 - 24;
        }
        if (*(_DWORD *)v192 != 6)
        {
          uint64_t v128 = (_OWORD *)v193;
          if ((unint64_t)v193 >= *((void *)&v193 + 1))
          {
            uint64_t v147 = *(_OWORD **)&v192[24];
            unint64_t v148 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v193 - *(void *)&v192[24]) >> 3);
            unint64_t v149 = v148 + 1;
            if (v148 + 1 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_408;
            }
            if (0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) > v149) {
              unint64_t v149 = 0x5555555555555556 * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v193 + 1) - *(void *)&v192[24]) >> 3) >= 0x555555555555555) {
              unint64_t v150 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v150 = v149;
            }
            if (v150)
            {
              if (v150 > 0xAAAAAAAAAAAAAAALL) {
                goto LABEL_409;
              }
              size_t v151 = (char *)operator new(24 * v150);
            }
            else
            {
              size_t v151 = 0;
            }
            uint64_t v158 = &v151[24 * v148];
            *(_OWORD *)uint64_t v158 = *(_OWORD *)v192;
            *((void *)v158 + 2) = *(void *)&v192[16];
            uint64_t v159 = v158;
            if (v128 != v147)
            {
              do
              {
                long long v160 = *(_OWORD *)((char *)v128 - 24);
                *((void *)v159 - 1) = *((void *)v128 - 1);
                *(_OWORD *)(v159 - 24) = v160;
                v159 -= 24;
                uint64_t v128 = (_OWORD *)((char *)v128 - 24);
              }
              while (v128 != v147);
              uint64_t v128 = *(_OWORD **)&v192[24];
            }
            long long v130 = v158 + 24;
            *(void *)&v192[24] = v159;
            *(void *)&long long v193 = v158 + 24;
            *((void *)&v193 + 1) = &v151[24 * v150];
            if (v128) {
              operator delete(v128);
            }
          }
          else
          {
            long long v129 = *(_OWORD *)v192;
            *(void *)(v193 + 16) = *(void *)&v192[16];
            *uint64_t v128 = v129;
            long long v130 = (char *)v128 + 24;
          }
          *(void *)&long long v193 = v130;
          v198[1] = 0;
          goto LABEL_345;
        }
        if (*(void *)&v192[24] == (void)v193)
        {
          sub_1CCC1E804((uint64_t)__str, &v191);
          *(std::string *)uint64_t v192 = __str[0];
        }
        else
        {
          long long v127 = *(_OWORD *)(v193 - 24);
          *(void *)&v192[16] = *(void *)(v193 - 8);
          *(_OWORD *)uint64_t v192 = v127;
          *(void *)&long long v193 = v193 - 24;
        }
        if (*(_DWORD *)v192 != 4)
        {
          LOWORD(__str[1].__r_.__value_.__r.__words[1]) = 261;
          __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)"'=' expected";
          __str[0].__r_.__value_.__l.__size_ = 12;
          operator new();
        }
        uint64_t v200 = 0;
        sub_1CCC1EFE8((unint64_t)&v200, (uint64_t)&v191, &v198[1]);
        if (!v200) {
          goto LABEL_345;
        }
LABEL_349:
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
LABEL_351:
        uint64_t v162 = v200;
        if (v200)
        {
          *(unsigned char *)(a4 + 128) |= 1u;
          *(void *)a4 = v162;
          goto LABEL_386;
        }
LABEL_352:
        if (*(_DWORD *)v192 != 1) {
          continue;
        }
LABEL_359:
        *(unsigned char *)(a4 + 128) &= ~1u;
        *(void *)(a4 + 8) = 0;
        *(void *)(a4 + 16) = 0;
        *(void *)a4 = 0;
        unint64_t v164 = (char *)v195[0];
        unint64_t v165 = (char *)v195[1];
        int64_t v166 = (char *)v195[1] - (char *)v195[0];
        if (v195[1] != v195[0])
        {
          unint64_t v167 = 0x4EC4EC4EC4EC4EC5 * (v166 >> 3);
          if (v167 >= 0x276276276276277) {
            goto LABEL_408;
          }
          uint64_t v168 = (char *)operator new(v166);
          uint64_t v169 = 0;
          *(void *)a4 = v168;
          *(void *)(a4 + 8) = v168;
          *(void *)(a4 + 16) = &v168[104 * v167];
          do
          {
            unint64_t v170 = &v164[v169];
            uint64_t v171 = (uint64_t)&v168[v169];
            if (v164[v169 + 23] < 0)
            {
              sub_1CB8BDF7C(v171, *(const void **)v170, *((void *)v170 + 1));
            }
            else
            {
              long long v172 = *(_OWORD *)v170;
              *(void *)(v171 + 16) = *((void *)v170 + 2);
              *(_OWORD *)uint64_t v171 = v172;
            }
            uint64_t v173 = &v168[v169 + 24];
            unsigned int v174 = (const void **)&v164[v169 + 24];
            if (v164[v169 + 47] < 0)
            {
              sub_1CB8BDF7C((uint64_t)v173, *v174, *(void *)&v164[v169 + 32]);
            }
            else
            {
              long long v175 = *(_OWORD *)v174;
              *(void *)&v168[v169 + 40] = *(void *)&v164[v169 + 40];
              *(_OWORD *)uint64_t v173 = v175;
            }
            unint64_t v176 = &v168[v169 + 48];
            uint64_t v177 = (const void **)&v164[v169 + 48];
            if (v164[v169 + 71] < 0)
            {
              sub_1CB8BDF7C((uint64_t)v176, *v177, *(void *)&v164[v169 + 56]);
            }
            else
            {
              long long v178 = *(_OWORD *)v177;
              *(void *)&v168[v169 + 64] = *(void *)&v164[v169 + 64];
              *(_OWORD *)unint64_t v176 = v178;
            }
            int v179 = &v168[v169 + 72];
            size_t v180 = (const void **)&v164[v169 + 72];
            if (v164[v169 + 95] < 0)
            {
              sub_1CB8BDF7C((uint64_t)v179, *v180, *(void *)&v164[v169 + 80]);
            }
            else
            {
              long long v181 = *(_OWORD *)v180;
              *(void *)&v168[v169 + 88] = *(void *)&v164[v169 + 88];
              *(_OWORD *)int v179 = v181;
            }
            uint64_t v182 = &v168[v169];
            int v183 = *(_DWORD *)&v164[v169 + 96];
            *((_WORD *)v182 + 50) = *(_WORD *)&v164[v169 + 100];
            *((_DWORD *)v182 + 24) = v183;
            v169 += 104;
          }
          while (&v164[v169] != v165);
          *(void *)(a4 + 8) = &v168[v169];
        }
        uint64_t v184 = (_OWORD *)(a4 + 24);
        if (SHIBYTE(v196[3]) < 0)
        {
          sub_1CB8BDF7C((uint64_t)v184, v196[1], (unint64_t)v196[2]);
        }
        else
        {
          _OWORD *v184 = *(_OWORD *)&v196[1];
          *(void **)(a4 + 40) = v196[3];
        }
        uint64_t v185 = (_OWORD *)(a4 + 48);
        if (SHIBYTE(v198[0]) < 0)
        {
          sub_1CB8BDF7C((uint64_t)v185, __p[0], (unint64_t)__p[1]);
        }
        else
        {
          *uint64_t v185 = *(_OWORD *)__p;
          *(void *)(a4 + 64) = v198[0];
        }
        long long v186 = *(_OWORD *)&v198[3];
        *(_OWORD *)(a4 + 72) = *(_OWORD *)&v198[1];
        *(_OWORD *)(a4 + 88) = v186;
        *(_OWORD *)(a4 + 104) = *(_OWORD *)&v198[5];
        *(void *)(a4 + 120) = v198[7];
LABEL_386:
        if (SHIBYTE(v198[0]) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v196[3]) < 0) {
          operator delete(v196[1]);
        }
        uint64_t v187 = (void **)v195[0];
        if (v195[0])
        {
          uint64_t v188 = (void **)v195[1];
          char v189 = v195[0];
          if (v195[1] != v195[0])
          {
            do
            {
              if (*((char *)v188 - 9) < 0) {
                operator delete(*(v188 - 4));
              }
              if (*((char *)v188 - 33) < 0) {
                operator delete(*(v188 - 7));
              }
              if (*((char *)v188 - 57) < 0) {
                operator delete(*(v188 - 10));
              }
              if (*((char *)v188 - 81) < 0) {
                operator delete(*(v188 - 13));
              }
              v188 -= 13;
            }
            while (v188 != v187);
            char v189 = v195[0];
          }
          v195[1] = v187;
          operator delete(v189);
        }
        if (*(void *)&v192[24])
        {
          *(void *)&long long v193 = *(void *)&v192[24];
          operator delete(*(void **)&v192[24]);
        }
        return;
      case 0xF:
        std::string::size_type v100 = &v198[2];
        int64_t v101 = &v198[3];
LABEL_227:
        sub_1CCC1E634(&v200, (uint64_t)&v191, v100, v101);
        goto LABEL_351;
      case 0x10:
        if (*(void *)&v192[24] == (void)v193)
        {
          sub_1CCC1E804((uint64_t)__str, &v191);
          *(std::string *)uint64_t v192 = __str[0];
        }
        else
        {
          long long v102 = *(_OWORD *)(v193 - 24);
          *(void *)&v192[16] = *(void *)(v193 - 8);
          *(_OWORD *)uint64_t v192 = v102;
          *(void *)&long long v193 = v193 - 24;
        }
        if (*(_DWORD *)v192 != 2)
        {
          LOWORD(__str[1].__r_.__value_.__r.__words[1]) = 1283;
          __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)"identifier expected, but got ";
          *(_OWORD *)&__str[0].__r_.__value_.__r.__words[2] = *(_OWORD *)&v192[8];
LABEL_379:
          operator new();
        }
        __str[0].__r_.__value_.__s.__data_[0] = 46;
        unint64_t v120 = llvm::StringRef::find((uint64_t *)&v192[8], (char *)__str, 1uLL, 0);
        if (v120 == -1)
        {
          long long v125 = 0;
          unint64_t v126 = 0;
          std::string::size_type v122 = *(void *)&v192[8];
          std::string::size_type v121 = *(void *)&v192[16];
          unint64_t v123 = *(void *)&v192[16];
          if (!*(void *)&v192[16]) {
            goto LABEL_378;
          }
        }
        else
        {
          std::string::size_type v122 = *(void *)&v192[8];
          std::string::size_type v121 = *(void *)&v192[16];
          if (*(void *)&v192[16] >= v120) {
            unint64_t v123 = v120;
          }
          else {
            unint64_t v123 = *(void *)&v192[16];
          }
          if (*(void *)&v192[16] >= v120 + 1) {
            unint64_t v124 = v120 + 1;
          }
          else {
            unint64_t v124 = *(void *)&v192[16];
          }
          long long v125 = (unsigned __int8 *)(*(void *)&v192[8] + v124);
          unint64_t v126 = *(void *)&v192[16] - v124;
          if (!v123) {
            goto LABEL_378;
          }
        }
        uint64_t v131 = 0;
        unint64_t v132 = 0;
        do
        {
          int v133 = *(unsigned __int8 *)(v122 + v131);
          if ((v133 - 48) >= 0xA)
          {
            if ((v133 - 97) >= 0x1A)
            {
              if ((v133 - 65) > 0x19) {
                goto LABEL_378;
              }
              int v134 = -55;
            }
            else
            {
              int v134 = -87;
            }
          }
          else
          {
            int v134 = -48;
          }
          unsigned int v135 = v134 + v133;
          if (v135 > 9) {
            goto LABEL_378;
          }
          unint64_t v136 = 10 * v132 + v135;
          if (v132 > v136 / 0xA) {
            goto LABEL_378;
          }
          ++v131;
          unint64_t v132 = v136;
        }
        while (v123 != v131);
        if (HIDWORD(v136))
        {
LABEL_378:
          LOWORD(__str[1].__r_.__value_.__r.__words[1]) = 1283;
          __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)"integer expected, but got ";
          __str[0].__r_.__value_.__r.__words[2] = v122;
          __str[1].__r_.__value_.__r.__words[0] = v121;
          goto LABEL_379;
        }
        LODWORD(v198[6]) = v136;
        if (v126)
        {
          unint64_t v137 = 0;
          do
          {
            int v138 = *v125;
            if ((v138 - 48) >= 0xA)
            {
              if ((v138 - 97) >= 0x1A)
              {
                if ((v138 - 65) > 0x19) {
                  goto LABEL_378;
                }
                int v139 = -55;
              }
              else
              {
                int v139 = -87;
              }
            }
            else
            {
              int v139 = -48;
            }
            unsigned int v140 = v139 + v138;
            if (v140 > 9) {
              goto LABEL_378;
            }
            unint64_t v141 = 10 * v137 + v140;
            if (v137 > v141 / 0xA) {
              goto LABEL_378;
            }
            ++v125;
            unint64_t v137 = v141;
            --v126;
          }
          while (v126);
          if (HIDWORD(v141)) {
            goto LABEL_378;
          }
        }
        else
        {
          LODWORD(v141) = 0;
        }
        HIDWORD(v198[6]) = v141;
        goto LABEL_352;
      default:
        LOWORD(__str[1].__r_.__value_.__r.__words[1]) = 1283;
        __str[0].__r_.__value_.__r.__words[0] = (std::string::size_type)"unknown directive: ";
        *(_OWORD *)&__str[0].__r_.__value_.__r.__words[2] = *(_OWORD *)&v192[8];
        goto LABEL_379;
    }
  }
}

void sub_1CCC1E634(void *a1, uint64_t a2, unint64_t *a3, unint64_t *a4)
{
  sub_1CCC1EFE8((unint64_t)a1, a2, a3);
  if (!*a1)
  {
    uint64_t v7 = *(void *)(a2 + 48);
    if (*(void *)(a2 + 40) == v7)
    {
      sub_1CCC1E804((uint64_t)&v21, (void *)a2);
      *(_OWORD *)(a2 + 16) = v21;
      *(void *)(a2 + 32) = v22;
    }
    else
    {
      long long v8 = *(_OWORD *)(v7 - 24);
      *(void *)(a2 + 32) = *(void *)(v7 - 8);
      *(_OWORD *)(a2 + 16) = v8;
      *(void *)(a2 + 48) = v7 - 24;
    }
    uint64_t v9 = (_OWORD *)(a2 + 16);
    if (*(_DWORD *)(a2 + 16) == 3)
    {
      sub_1CCC1EFE8((unint64_t)a1, a2, a4);
      if (*a1) {
        return;
      }
    }
    else
    {
      uint64_t v11 = *(void **)(a2 + 48);
      unint64_t v10 = *(void *)(a2 + 56);
      if ((unint64_t)v11 >= v10)
      {
        long long v14 = *(void **)(a2 + 40);
        unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (v11 - v14) + 1;
        if (v15 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)v14) >> 3);
        if (2 * v16 > v15) {
          unint64_t v15 = 2 * v16;
        }
        if (v16 >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          if (v17 > 0xAAAAAAAAAAAAAAALL) {
            sub_1CB833614();
          }
          int v18 = (char *)operator new(24 * v17);
        }
        else
        {
          int v18 = 0;
        }
        unint64_t v19 = &v18[8 * (v11 - v14)];
        *(_OWORD *)unint64_t v19 = *v9;
        *((void *)v19 + 2) = *(void *)(a2 + 32);
        long long v13 = v19 + 24;
        if (v11 != v14)
        {
          do
          {
            long long v20 = *(_OWORD *)(v11 - 3);
            *((void *)v19 - 1) = *(v11 - 1);
            *(_OWORD *)(v19 - 24) = v20;
            v19 -= 24;
            v11 -= 3;
          }
          while (v11 != v14);
          uint64_t v11 = *(void **)(a2 + 40);
        }
        *(void *)(a2 + 40) = v19;
        *(void *)(a2 + 48) = v13;
        *(void *)(a2 + 56) = &v18[24 * v17];
        if (v11) {
          operator delete(v11);
        }
      }
      else
      {
        long long v12 = *v9;
        v11[2] = *(void *)(a2 + 32);
        *(_OWORD *)uint64_t v11 = v12;
        long long v13 = v11 + 3;
      }
      *(void *)(a2 + 48) = v13;
    }
    *a1 = 0;
  }
}

unint64_t sub_1CCC1E804(uint64_t a1, void *a2)
{
  unint64_t result = sub_1CD5A69D0(a2, " \t\n\v\f\r", 6);
  *a2 = result;
  a2[1] = v5;
  long long v6 = "";
  if (v5)
  {
    uint64_t v7 = (char *)result;
    size_t v8 = v5;
    while (1)
    {
      uint64_t v9 = *v7;
      if ((int)v9 <= 58) {
        break;
      }
      if (v9 != 59)
      {
        if (v9 == 61)
        {
          *a2 = v7 + 1;
          a2[1] = v8 - 1;
          if (v8 != 1 && v7[1] == 61)
          {
            *a2 = v7 + 2;
            a2[1] = v8 - 2;
            long long v6 = "==";
            LODWORD(v19) = 5;
            uint64_t v9 = 2;
            goto LABEL_83;
          }
          long long v6 = "=";
          LODWORD(v19) = 4;
          goto LABEL_48;
        }
LABEL_39:
        unint64_t result = llvm::StringRef::find_first_of(a2, "=,;\r\n \t\v", 8, 0);
        if (v8 >= result) {
          uint64_t v9 = result;
        }
        else {
          uint64_t v9 = v8;
        }
        switch(v9)
        {
          case 4:
            uint64_t v19 = 0x100000006;
            if (*(_DWORD *)v7 != 1163084098)
            {
              if (*(_DWORD *)v7 == 1096040772)
              {
                uint64_t v19 = 0x100000008;
              }
              else
              {
                if (*(_DWORD *)v7 != 1162690894) {
                  goto LABEL_77;
                }
                uint64_t v19 = 0x10000000CLL;
              }
            }
            break;
          case 6:
            if (*(_DWORD *)v7 != 1095651150 || *((_WORD *)v7 + 2) != 17741) {
              goto LABEL_77;
            }
            uint64_t v19 = 0x10000000DLL;
            break;
          case 7:
            if (*(_DWORD *)v7 == 1330665541 && *(_DWORD *)(v7 + 3) == 1398035023)
            {
              uint64_t v19 = 0x100000009;
            }
            else if (*(_DWORD *)v7 == 1380075852 && *(_DWORD *)(v7 + 3) == 1498562898)
            {
              uint64_t v19 = 0x10000000BLL;
            }
            else if (*(_DWORD *)v7 == 1447645776 && *(_DWORD *)(v7 + 3) == 1163149654)
            {
              uint64_t v19 = 0x10000000ELL;
            }
            else
            {
              uint64_t v19 = 0x100000010;
              if (*(_DWORD *)v7 ^ 0x53524556 | *(_DWORD *)(v7 + 3) ^ 0x4E4F4953) {
                uint64_t v19 = 0;
              }
            }
            break;
          case 8:
            if (*(void *)v7 == 0x544E4154534E4F43)
            {
              uint64_t v19 = 0x100000007;
            }
            else
            {
              if (*(void *)v7 != 0x455A495350414548) {
                goto LABEL_77;
              }
              uint64_t v19 = 0x10000000ALL;
            }
            break;
          case 9:
            if (*(void *)v7 != 0x5A49534B43415453 || v7[8] != 69) {
              goto LABEL_77;
            }
            uint64_t v19 = 0x10000000FLL;
            break;
          default:
LABEL_77:
            uint64_t v19 = 0;
            break;
        }
        if ((v19 & 0x300000000) == 0) {
          LODWORD(v19) = 2;
        }
        int64_t v28 = &v7[v9];
        size_t v29 = v8 - v9;
        if (result == -1)
        {
          size_t v29 = 0;
          int64_t v28 = "";
        }
        *a2 = v28;
        a2[1] = v29;
        long long v6 = v7;
        goto LABEL_83;
      }
      unint64_t v10 = memchr(v7, 10, v8);
      size_t v11 = v10 - v7;
      if (v10) {
        BOOL v12 = v11 == -1;
      }
      else {
        BOOL v12 = 1;
      }
      int v13 = v12;
      if (v8 < v11) {
        size_t v11 = v8;
      }
      long long v14 = &v7[v11];
      size_t v15 = v8 - v11;
      BOOL v16 = v13 == 0;
      if (v13) {
        unint64_t v17 = "";
      }
      else {
        unint64_t v17 = v14;
      }
      if (!v16) {
        size_t v15 = 0;
      }
      *a2 = v17;
      a2[1] = v15;
      unint64_t result = sub_1CD5A69D0(a2, " \t\n\v\f\r", 6);
      uint64_t v7 = (char *)result;
      size_t v8 = v18;
      uint64_t v9 = 0;
      *a2 = result;
      a2[1] = v18;
      LODWORD(v19) = 1;
      if (!v18) {
        goto LABEL_83;
      }
    }
    if (!*v7) {
      goto LABEL_25;
    }
    if (v9 != 34)
    {
      if (v9 == 44)
      {
        *a2 = v7 + 1;
        a2[1] = v8 - 1;
        long long v6 = ",";
        LODWORD(v19) = 3;
LABEL_48:
        uint64_t v9 = 1;
        goto LABEL_83;
      }
      goto LABEL_39;
    }
    long long v6 = v7 + 1;
    unint64_t v20 = v8 - 1;
    v30[0] = (uint64_t)v6;
    v30[1] = v8 - 1;
    char v31 = 34;
    unint64_t result = llvm::StringRef::find(v30, &v31, 1uLL, 0);
    if (v8 - 1 >= result) {
      uint64_t v9 = result;
    }
    else {
      uint64_t v9 = v8 - 1;
    }
    if (v20 >= result + 1) {
      unint64_t v21 = result + 1;
    }
    else {
      unint64_t v21 = v8 - 1;
    }
    uint64_t v22 = &v6[v21];
    uint64_t v19 = v20 - v21;
    if (result == -1)
    {
      uint64_t v9 = v8 - 1;
      uint64_t v22 = 0;
      uint64_t v19 = 0;
    }
    *a2 = v22;
    a2[1] = v19;
    LODWORD(v19) = 2;
  }
  else
  {
    uint64_t v9 = 0;
LABEL_25:
    LODWORD(v19) = 1;
  }
LABEL_83:
  *(_DWORD *)a1 = v19;
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = v9;
  return result;
}

uint64_t sub_1CCC1EC4C(unsigned __int8 *a1, size_t a2, char a3)
{
  v12[0] = (uint64_t)a1;
  v12[1] = a2;
  if (a2)
  {
    int v5 = *a1;
    if (v5 == 64 || llvm::StringRef::find(v12, "@@", 2uLL, 0) != -1) {
      return 1;
    }
    uint64_t result = v5 == 63;
    if (v5 != 63 && (a3 & 1) == 0)
    {
      size_t v11 = memchr(a1, 64, a2);
      if (v11)
      {
        uint64_t v10 = v11 - a1;
        return v10 != -1;
      }
LABEL_8:
      uint64_t v10 = -1;
      return v10 != -1;
    }
  }
  else
  {
    uint64_t v8 = llvm::StringRef::find(v12, "@@", 2uLL, 0);
    BOOL v9 = v8 == -1;
    uint64_t result = v8 != -1;
    if (v9 && (a3 & 1) == 0) {
      goto LABEL_8;
    }
  }
  return result;
}

char *sub_1CCC1ED20(void **a1, uint64_t a2)
{
  uint64_t v2 = 0x4EC4EC4EC4EC4EC5 * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x276276276276276) {
    abort();
  }
  if (0x9D89D89D89D89D8ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x9D89D89D89D89D8ALL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3)) >= 0x13B13B13B13B13BLL) {
    unint64_t v6 = 0x276276276276276;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x276276276276276) {
      sub_1CB833614();
    }
    uint64_t v7 = operator new(104 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = (char *)&v7[13 * v2];
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)&v7[13 * v2], *(const void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
    *((void *)v8 + 2) = *(void *)(a2 + 16);
  }
  BOOL v9 = &v7[13 * v2 + 3];
  if (*(char *)(a2 + 47) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v9, *(const void **)(a2 + 24), *(void *)(a2 + 32));
  }
  else
  {
    *BOOL v9 = *(_OWORD *)(a2 + 24);
    v7[13 * v2 + 5] = *(void *)(a2 + 40);
  }
  uint64_t v10 = &v7[13 * v2 + 6];
  if (*(char *)(a2 + 71) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v10, *(const void **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    *uint64_t v10 = *(_OWORD *)(a2 + 48);
    v7[13 * v2 + 8] = *(void *)(a2 + 64);
  }
  size_t v11 = &v7[13 * v2 + 9];
  if (*(char *)(a2 + 95) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v11, *(const void **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    *size_t v11 = *(_OWORD *)(a2 + 72);
    v7[13 * v2 + 11] = *(void *)(a2 + 88);
  }
  BOOL v12 = (char *)&v7[13 * v6];
  int v13 = (char *)&v7[13 * v2];
  *((_DWORD *)v13 + 24) = *(_DWORD *)(a2 + 96);
  *((_WORD *)v13 + 50) = *(_WORD *)(a2 + 100);
  long long v14 = v8 + 104;
  size_t v15 = (void **)*a1;
  BOOL v16 = (void **)a1[1];
  if (v16 == *a1)
  {
    *a1 = v8;
    a1[1] = v14;
    a1[2] = v12;
  }
  else
  {
    do
    {
      long long v17 = *(_OWORD *)(v16 - 13);
      *((void *)v8 - 11) = *(v16 - 11);
      *(_OWORD *)(v8 - 104) = v17;
      *(v16 - 12) = 0;
      *(v16 - 11) = 0;
      *(v16 - 13) = 0;
      long long v18 = *((_OWORD *)v16 - 5);
      *((void *)v8 - 8) = *(v16 - 8);
      *((_OWORD *)v8 - 5) = v18;
      *(v16 - 9) = 0;
      *(v16 - 8) = 0;
      *(v16 - 10) = 0;
      long long v19 = *(_OWORD *)(v16 - 7);
      *((void *)v8 - 5) = *(v16 - 5);
      *(_OWORD *)(v8 - 56) = v19;
      *(v16 - 6) = 0;
      *(v16 - 5) = 0;
      *(v16 - 7) = 0;
      long long v20 = *((_OWORD *)v16 - 2);
      *((void *)v8 - 2) = *(v16 - 2);
      *((_OWORD *)v8 - 2) = v20;
      *(v16 - 4) = 0;
      *(v16 - 3) = 0;
      *(v16 - 2) = 0;
      int v21 = *((_DWORD *)v16 - 2);
      *((_WORD *)v8 - 2) = *((_WORD *)v16 - 2);
      *((_DWORD *)v8 - 2) = v21;
      v8 -= 104;
      v16 -= 13;
    }
    while (v16 != v15);
    BOOL v16 = (void **)*a1;
    uint64_t v22 = (void **)a1[1];
    *a1 = v8;
    a1[1] = v14;
    a1[2] = v12;
    while (v22 != v16)
    {
      if (*((char *)v22 - 9) < 0) {
        operator delete(*(v22 - 4));
      }
      if (*((char *)v22 - 33) < 0) {
        operator delete(*(v22 - 7));
      }
      if (*((char *)v22 - 57) < 0) {
        operator delete(*(v22 - 10));
      }
      if (*((char *)v22 - 81) < 0) {
        operator delete(*(v22 - 13));
      }
      v22 -= 13;
    }
  }
  if (v16) {
    operator delete(v16);
  }
  return v14;
}

unint64_t sub_1CCC1EFE8(unint64_t result, uint64_t a2, unint64_t *a3)
{
  int v5 = (void *)result;
  uint64_t v6 = *(void *)(a2 + 48);
  if (*(void *)(a2 + 40) == v6)
  {
    uint64_t result = sub_1CCC1E804((uint64_t)&v15, (void *)a2);
    *(_OWORD *)(a2 + 16) = v15;
    *(void *)(a2 + 32) = v16;
  }
  else
  {
    long long v7 = *(_OWORD *)(v6 - 24);
    *(void *)(a2 + 32) = *(void *)(v6 - 8);
    *(_OWORD *)(a2 + 16) = v7;
    *(void *)(a2 + 48) = v6 - 24;
  }
  if (*(_DWORD *)(a2 + 16) != 2 || (uint64_t v8 = *(void *)(a2 + 32)) == 0)
  {
LABEL_17:
    *(void *)&long long v15 = "integer expected";
    __int16 v17 = 259;
    operator new();
  }
  unint64_t v9 = 0;
  uint64_t v10 = *(unsigned __int8 **)(a2 + 24);
  do
  {
    int v11 = *v10;
    if ((v11 - 48) >= 0xA)
    {
      if ((v11 - 97) >= 0x1A)
      {
        if ((v11 - 65) > 0x19) {
          goto LABEL_17;
        }
        int v12 = -55;
      }
      else
      {
        int v12 = -87;
      }
    }
    else
    {
      int v12 = -48;
    }
    unsigned int v13 = v12 + v11;
    if (v13 > 9) {
      goto LABEL_17;
    }
    unint64_t v14 = 10 * v9 + v13;
    if (v9 > v14 / 0xA) {
      goto LABEL_17;
    }
    ++v10;
    unint64_t v9 = v14;
    --v8;
  }
  while (v8);
  *a3 = v14;
  void *v5 = 0;
  return result;
}

uint64_t llvm::object::COFFObjectFile::toSec(uint64_t a1, uint64_t a2)
{
  return a2;
}

llvm::object::COFFObjectFile *llvm::object::COFFObjectFile::getSymbolName@<X0>(llvm::object::COFFObjectFile *a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = *((void *)a1 + 12);
  BOOL v4 = v3 == 0;
  if (v3) {
    int v5 = 0;
  }
  else {
    int v5 = a2;
  }
  if (v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = a2;
  }
  if (v6) {
    long long v7 = v6;
  }
  else {
    long long v7 = v5;
  }
  return llvm::object::COFFObjectFile::getSymbolName(v7, a1, a3);
}

llvm::object::COFFObjectFile *llvm::object::COFFObjectFile::getSymbolName@<X0>(llvm::object::COFFObjectFile *a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  if (!a2) {
    a2 = a3;
  }
  return llvm::object::COFFObjectFile::getSymbolName(a2, a1, a4);
}

uint64_t llvm::object::COFFObjectFile::getCOFFSymbol(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 96)) {
    return *(void *)a2;
  }
  else {
    return 0;
  }
}

{
  if (*(void *)(a1 + 96)) {
    return *(void *)a2;
  }
  else {
    return 0;
  }
}

uint64_t llvm::object::COFFObjectFile::getSymbolValueImpl(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  BOOL v3 = v2 == 0;
  if (v2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v3) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v4) {
    uint64_t v4 = v5;
  }
  return *(unsigned int *)(v4 + 8);
}

uint64_t llvm::object::COFFObjectFile::getSymbolAlignment(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  BOOL v3 = v2 == 0;
  if (v2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v3) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v4) {
    uint64_t v4 = v5;
  }
  uint64_t v6 = *(unsigned int *)(v4 + 8);
  if (v6)
  {
    unint64_t v7 = (v6 - 1) | ((unint64_t)(v6 - 1) >> 1) | (((v6 - 1) | ((unint64_t)(v6 - 1) >> 1)) >> 2);
    unint64_t v8 = v7 | (v7 >> 4) | ((v7 | (v7 >> 4)) >> 8);
    unint64_t v9 = (v8 | (v8 >> 16)) + 1;
  }
  else
  {
    unint64_t v9 = 0;
  }
  if (v9 >= 0x20) {
    return 32;
  }
  else {
    return v9;
  }
}

uint64_t llvm::object::COFFObjectFile::getSymbolAddress@<X0>(llvm::object *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v22[2] = *MEMORY[0x1E4F143B8];
  llvm::object::ObjectFile::getSymbolValue((uint64_t)a1, a2, (uint64_t)v22);
  uint64_t v6 = *((void *)a1 + 12);
  if (v6) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v6) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = a2;
  }
  if (v7)
  {
    unsigned int v10 = *(unsigned __int16 *)(v7 + 12);
    if (v10 >> 8 <= 0xFE) {
      int v9 = *(unsigned __int16 *)(v7 + 12);
    }
    else {
      int v9 = (__int16)v10;
    }
  }
  else
  {
    int v9 = *(_DWORD *)(v8 + 12);
  }
  uint64_t v11 = v22[0];
  uint64_t result = sub_1CD6C6F8C(v7, v8);
  if (result) {
    goto LABEL_32;
  }
  unsigned int v13 = (unsigned char *)(v7 + 16);
  if (!v7) {
    unsigned int v13 = (unsigned char *)(v8 + 18);
  }
  if (*v13 == 2)
  {
    if (v7)
    {
      if (HIBYTE(*(unsigned __int16 *)(v7 + 12)) > 0xFEu || *(_WORD *)(v7 + 12)) {
        goto LABEL_19;
      }
    }
    else if (*(_DWORD *)(v8 + 12))
    {
      goto LABEL_19;
    }
    long long v18 = (_DWORD *)(v7 + 8);
    if (!v7) {
      long long v18 = (_DWORD *)(v8 + 8);
    }
    if (*v18) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v9 < 1;
    }
    if (!v19) {
      goto LABEL_20;
    }
LABEL_32:
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v11;
    return result;
  }
LABEL_19:
  if (v9 <= 0) {
    goto LABEL_32;
  }
LABEL_20:
  uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getSection(a1, v9, (uint64_t)&v20);
  uint64_t v14 = v20;
  if (v21)
  {
    char v17 = *(unsigned char *)(a3 + 8) | 1;
  }
  else
  {
    uint64_t v15 = *((void *)a1 + 8);
    if (v15)
    {
      uint64_t v16 = *(unsigned int *)(v15 + 28);
    }
    else
    {
      uint64_t v16 = *((void *)a1 + 9);
      if (v16) {
        uint64_t v16 = *(void *)(v16 + 24);
      }
    }
    uint64_t v14 = v11 + *(unsigned int *)(v20 + 12) + v16;
    char v17 = *(unsigned char *)(a3 + 8) & 0xFE;
  }
  *(unsigned char *)(a3 + 8) = v17;
  *(void *)a3 = v14;
  return result;
}

llvm::object *llvm::object::COFFObjectFile::getSection@<X0>(llvm::object *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2 <= 0)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v4 = *((void *)this + 6);
    if (v4)
    {
      unsigned int v5 = *(unsigned __int16 *)(v4 + 2);
      if (v5 == 0xFFFF) {
        unsigned int v5 = 0;
      }
    }
    else
    {
      unsigned int v5 = *(_DWORD *)(*((void *)this + 7) + 44);
    }
    if (v5 < a2)
    {
      llvm::object::object_category(this);
      sub_1CD06481C();
    }
    uint64_t v6 = *((void *)this + 11) + 40 * (a2 - 1);
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = v6;
  return this;
}

uint64_t llvm::object::COFFObjectFile::getImageBase(llvm::object::COFFObjectFile *this)
{
  uint64_t v1 = *((void *)this + 8);
  if (v1) {
    return *(unsigned int *)(v1 + 28);
  }
  uint64_t v3 = *((void *)this + 9);
  if (v3) {
    return *(void *)(v3 + 24);
  }
  else {
    return 0;
  }
}

uint64_t llvm::object::COFFObjectFile::getSymbolType@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(result + 96);
  if (v4) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = a2;
  }
  if (v5)
  {
    unsigned int v7 = *(unsigned __int16 *)(v5 + 12);
    if (v7 >> 8 <= 0xFE) {
      int v8 = *(unsigned __int16 *)(v5 + 12);
    }
    else {
      int v8 = (__int16)v7;
    }
  }
  else
  {
    int v8 = *(_DWORD *)(v6 + 12);
  }
  int v9 = (_WORD *)(v5 + 14);
  if (!v5) {
    int v9 = (_WORD *)(v6 + 16);
  }
  if ((*v9 & 0xF0) == 0x20)
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    int v10 = 5;
    goto LABEL_16;
  }
  uint64_t result = sub_1CD6C6F8C(v5, v6);
  if (result)
  {
    int v10 = 0;
    *(unsigned char *)(a3 + 8) &= ~1u;
    goto LABEL_16;
  }
  uint64_t v11 = (unsigned __int8 *)(v5 + 16);
  if (!v5) {
    uint64_t v11 = (unsigned __int8 *)(v6 + 18);
  }
  int v12 = *v11;
  if (v12 == 103)
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    int v10 = 4;
    goto LABEL_16;
  }
  if (v12 == 2)
  {
    if (v5)
    {
      unsigned int v13 = *(unsigned __int16 *)(v5 + 12);
      if (v13 >> 8 > 0xFE) {
        goto LABEL_29;
      }
    }
    else
    {
      unsigned int v13 = *(_DWORD *)(v6 + 12);
    }
    if (!v13)
    {
      uint64_t v14 = (_DWORD *)(v5 + 8);
      if (!v5) {
        uint64_t v14 = (_DWORD *)(v6 + 8);
      }
      if (*v14)
      {
        *(unsigned char *)(a3 + 8) &= ~1u;
        int v10 = 2;
        goto LABEL_16;
      }
    }
  }
LABEL_29:
  if (v8 == -2 || (uint64_t result = sub_1CD6C6FE4(v5, v6), result))
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    int v10 = 3;
  }
  else
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    if (v8 < 1) {
      int v10 = 1;
    }
    else {
      int v10 = 2;
    }
  }
LABEL_16:
  *(_DWORD *)a3 = v10;
  return result;
}

uint64_t llvm::object::COFFObjectFile::getSymbolFlags@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = a2;
  }
  unsigned int v7 = (unsigned __int8 *)(v5 + 16);
  if (!v5) {
    unsigned int v7 = (unsigned __int8 *)(v6 + 18);
  }
  int v8 = *v7;
  int v9 = (unsigned __int8 *)(v5 + 17);
  if (!v5) {
    int v9 = (unsigned __int8 *)(v6 + 19);
  }
  if (v8 == 105 || v8 == 2) {
    int v11 = 2;
  }
  else {
    int v11 = 0;
  }
  int v12 = *v9;
  if (v8 == 105 && v12 != 0)
  {
    uint64_t v14 = v5 + 18;
    if (!v5) {
      uint64_t v14 = v6 + 20;
    }
    if (*(_DWORD *)(v14 + 4) == 3) {
      int v15 = 4;
    }
    else {
      int v15 = 5;
    }
    v11 |= v15;
  }
  if (!v5)
  {
    int v16 = *(_DWORD *)(v6 + 12);
    int v17 = *(unsigned __int8 *)(v6 + 18);
    uint64_t result = sub_1CD6C6FE4(0, v6);
    if (v8 == 2)
    {
      unsigned int v19 = *(_DWORD *)(v6 + 12);
      goto LABEL_35;
    }
LABEL_40:
    BOOL v20 = 0;
    goto LABEL_41;
  }
  if (*(__int16 *)(v5 + 12) >= 0xFFFFFF00) {
    int v16 = *(__int16 *)(v5 + 12);
  }
  else {
    int v16 = *(unsigned __int16 *)(v5 + 12);
  }
  int v17 = *(unsigned __int8 *)(v5 + 16);
  uint64_t result = sub_1CD6C6FE4(v5, v6);
  if (v8 != 2) {
    goto LABEL_40;
  }
  unsigned int v19 = *(unsigned __int16 *)(v5 + 12);
  if (v19 >> 8 > 0xFE) {
    goto LABEL_40;
  }
LABEL_35:
  if (v19)
  {
    BOOL v20 = 0;
    if (v5) {
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v26 = (_DWORD *)(v5 + 8);
    if (!v5) {
      uint64_t v26 = (_DWORD *)(v6 + 8);
    }
    BOOL v20 = *v26 != 0;
    if (v5)
    {
LABEL_37:
      if (HIBYTE(*(unsigned __int16 *)(v5 + 12)) <= 0xFEu && !*(_WORD *)(v5 + 12)) {
        goto LABEL_58;
      }
LABEL_41:
      BOOL v21 = 0;
      goto LABEL_42;
    }
  }
  if (*(_DWORD *)(v6 + 12)) {
    goto LABEL_41;
  }
LABEL_58:
  uint64_t v27 = (_DWORD *)(v5 + 8);
  if (!v5) {
    uint64_t v27 = (_DWORD *)(v6 + 8);
  }
  BOOL v21 = *v27 == 0;
LABEL_42:
  if (v17 == 103) {
    int v22 = 1;
  }
  else {
    int v22 = result;
  }
  int v23 = v11 | 8;
  if (v16 != -1) {
    int v23 = v11;
  }
  if (v22) {
    int v24 = v23 | 0x80;
  }
  else {
    int v24 = v23;
  }
  if (v20) {
    int v25 = v24 | 0x10;
  }
  else {
    int v25 = v24;
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = v25 | v21;
  return result;
}

uint64_t llvm::object::COFFObjectFile::getCommonSymbolSizeImpl(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  BOOL v3 = v2 == 0;
  if (v2) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v3) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!v4) {
    uint64_t v4 = v5;
  }
  return *(unsigned int *)(v4 + 8);
}

llvm::object *llvm::object::COFFObjectFile::getSymbolSection@<X0>(llvm::object::COFFObjectFile *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    BOOL v6 = a2 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v5) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = a2;
    }
    int v8 = *(_DWORD *)(v7 + 12);
    if (v8 <= 0) {
      goto LABEL_13;
    }
  }
  else
  {
    int v8 = *(unsigned __int16 *)(a2 + 12);
    if ((unsigned __int16)(v8 + 256) < 0x101u)
    {
LABEL_13:
      uint64_t result = (llvm::object *)(*(uint64_t (**)(llvm::object::COFFObjectFile *))(*(void *)this + 352))(this);
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)a3 = result;
      *(void *)(a3 + 8) = v11;
      return result;
    }
  }
  uint64_t result = llvm::object::COFFObjectFile::getSection(this, v8, (uint64_t)&v12);
  uint64_t v10 = v12;
  if (v13)
  {
    *(unsigned char *)(a3 + 16) |= 1u;
  }
  else
  {
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)(a3 + 8) = this;
  }
  *(void *)a3 = v10;
  return result;
}

uint64_t llvm::object::COFFObjectFile::getSymbolSectionID(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 96);
  if (v2) {
    BOOL v3 = a2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    if (v2) {
      uint64_t v4 = 0;
    }
    else {
      uint64_t v4 = a2;
    }
    return *(unsigned int *)(v4 + 12);
  }
  else
  {
    unsigned int v6 = *(unsigned __int16 *)(a2 + 12);
    if (v6 >> 8 <= 0xFE) {
      return *(unsigned __int16 *)(a2 + 12);
    }
    else {
      return (__int16)v6;
    }
  }
}

unint64_t llvm::object::COFFObjectFile::getSectionName@<X0>(llvm::object::COFFObjectFile *this@<X0>, char *__s@<X1>, uint64_t a3@<X8>)
{
  if (!__s[7])
  {
    unint64_t result = strlen(__s);
    if (result && *__s == 47)
    {
      if (result < 2) {
        goto LABEL_45;
      }
      goto LABEL_3;
    }
LABEL_19:
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(void *)a3 = __s;
    *(void *)(a3 + 8) = result;
    return result;
  }
  unint64_t result = 8;
  if (*__s != 47) {
    goto LABEL_19;
  }
LABEL_3:
  if (*(_WORD *)__s == 12079)
  {
    unint64_t v15 = result - 2;
    if (result - 2 <= 6)
    {
      if (result == 2)
      {
        LODWORD(v16) = 0;
        goto LABEL_46;
      }
      unint64_t v16 = 0;
      int v17 = __s + 2;
      do
      {
        uint64_t v18 = *v17;
        if ((v18 - 65) > 0x19)
        {
          if ((v18 - 97) > 0x19)
          {
            if ((v18 - 48) > 9)
            {
              if (v18 == 43)
              {
                uint64_t v19 = 62;
              }
              else
              {
                if (v18 != 47) {
                  goto LABEL_35;
                }
                uint64_t v19 = 63;
              }
            }
            else
            {
              uint64_t v19 = v18 + 4;
            }
          }
          else
          {
            uint64_t v19 = v18 - 71;
          }
        }
        else
        {
          uint64_t v19 = v18 - 65;
        }
        unint64_t v16 = v19 + (v16 << 6);
        ++v17;
        --v15;
      }
      while (v15);
      if (!HIDWORD(v16)) {
        goto LABEL_46;
      }
    }
LABEL_35:
    llvm::object::object_category((llvm::object *)result);
    sub_1CD06481C();
  }
  unint64_t v7 = 0;
  int v8 = __s + 1;
  unint64_t v9 = result - 1;
  while (1)
  {
    int v11 = *v8++;
    int v10 = v11;
    if ((v11 - 48) < 0xA)
    {
      int v12 = -48;
      goto LABEL_7;
    }
    if ((v10 - 97) < 0x1A)
    {
      int v12 = -87;
      goto LABEL_7;
    }
    if ((v10 - 65) > 0x19) {
      break;
    }
    int v12 = -55;
LABEL_7:
    unsigned int v13 = v12 + v10;
    if (v13 > 9) {
      break;
    }
    unint64_t v14 = 10 * v7 + v13;
    if (v7 > v14 / 0xA) {
      goto LABEL_45;
    }
    unint64_t v7 = v14;
    if (!--v9) {
      goto LABEL_38;
    }
  }
  unint64_t v14 = v7;
LABEL_38:
  BOOL v20 = v9 != 0;
  int v21 = 0;
  if (v14 < 0x100000000) {
    int v21 = v14;
  }
  if (v20) {
    LODWORD(v16) = 0;
  }
  else {
    LODWORD(v16) = v21;
  }
  if (HIDWORD(v14) || v20)
  {
LABEL_45:
    llvm::object::object_category((llvm::object *)result);
    sub_1CD06481C();
  }
LABEL_46:

  return llvm::object::COFFObjectFile::getString(this, v16, a3);
}

uint64_t llvm::object::COFFObjectFile::getSectionSize(void *a1, uint64_t a2)
{
  if ((a1[8] || a1[9]) && a1[2])
  {
    unsigned int v2 = *(_DWORD *)(a2 + 16);
    if (v2 >= *(_DWORD *)(a2 + 8)) {
      return *(unsigned int *)(a2 + 8);
    }
  }
  else
  {
    return *(unsigned int *)(a2 + 16);
  }
  return v2;
}

{
  unsigned int v2;

  if ((a1[8] || a1[9]) && a1[2])
  {
    unsigned int v2 = *(_DWORD *)(a2 + 16);
    if (v2 >= *(_DWORD *)(a2 + 8)) {
      return *(unsigned int *)(a2 + 8);
    }
  }
  else
  {
    return *(unsigned int *)(a2 + 16);
  }
  return v2;
}

BOOL llvm::object::COFFObjectFile::isDebugSection(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  (*(void (**)(void *__return_ptr))(*(void *)a1 + 136))(v6);
  if (v7)
  {
    uint64_t v5 = (void *)v6[0];
    v6[0] = 0;
    sub_1CD4515D0(&v5);
    if (v5) {
      (*(void (**)(void *))(*v5 + 8))(v5);
    }
  }
  else if (v6[1] >= 6uLL)
  {
    BOOL v1 = *(_DWORD *)v6[0] == 1650811950 && *(_WORD *)(v6[0] + 4) == 26485;
    goto LABEL_10;
  }
  BOOL v1 = 0;
LABEL_10:
  if (v7)
  {
    uint64_t v3 = v6[0];
    v6[0] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  return v1;
}

uint64_t llvm::object::COFFObjectFile::getSectionID(uint64_t a1, uint64_t a2)
{
  return ((a2 - *(void *)(a1 + 88)) / 0x28uLL) + 1;
}

unint64_t sub_1CCC1FD74(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  long long v6 = a2[1];
  v15[0] = *a2;
  v15[1] = v6;
  unsigned int v7 = sub_1CCC1FE88(a1, v15, a3);
  if (!v7) {
    return 0;
  }
  BOOL v8 = (*(unsigned char *)(a1 + 39) & 1) != 0 && *(__int16 *)(a1 + 32) == -1;
  unint64_t v9 = a3 + *(unsigned int *)(a1 + 24) + 10 * v8;
  long long v10 = a2[1];
  v13[0] = *a2;
  v13[1] = v10;
  sub_1CCC207AC((llvm::object *)v13, v9, 10 * v7, &v14);
  if (v14)
  {
    int v12 = v14;
    unint64_t v14 = 0;
    sub_1CD4515D0(&v12);
    if (v12) {
      (*(void (**)(void *))(*v12 + 8))(v12);
    }
    if (v14) {
      (*(void (**)(void *))(*v14 + 8))(v14);
    }
    return 0;
  }
  return v9;
}

uint64_t sub_1CCC1FE88(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  if ((*(unsigned char *)(a1 + 39) & 1) == 0) {
    return *(unsigned __int16 *)(a1 + 32);
  }
  uint64_t result = *(unsigned __int16 *)(a1 + 32);
  if (result == 0xFFFF)
  {
    long long v5 = a2[1];
    v9[0] = *a2;
    v9[1] = v5;
    long long v6 = (_DWORD *)(a3 + *(unsigned int *)(a1 + 24));
    sub_1CCC207AC((llvm::object *)v9, (unint64_t)v6, 0xAuLL, &v8);
    if (v8)
    {
      unsigned int v7 = v8;
      BOOL v8 = 0;
      sub_1CD4515D0(&v7);
      if (v7) {
        (*(void (**)(void *))(*v7 + 8))(v7);
      }
      if (v8) {
        (*(void (**)(void *))(*v8 + 8))(v8);
      }
      return 0;
    }
    else
    {
      return (*v6 - 1);
    }
  }
  return result;
}

llvm::object *llvm::object::COFFObjectFile::initSymbolTablePtr@<X0>(llvm::object::COFFObjectFile *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *((void *)this + 6);
  if (!v4)
  {
    BOOL v8 = (void *)((char *)this + 56);
    uint64_t v7 = *((void *)this + 7);
    if (!v7) {
      goto LABEL_35;
    }
    unint64_t v9 = (void *)((char *)this + 104);
    long long v36 = *((_OWORD *)this + 1);
    long long v37 = *((_OWORD *)this + 2);
    uint64_t v10 = *((void *)this + 2);
    unint64_t v11 = *((void *)this + 12);
LABEL_6:
    uint64_t v12 = 0;
    unsigned int v13 = (unsigned int *)(v7 + 48);
    int v14 = 1;
    goto LABEL_7;
  }
  int v5 = *(unsigned __int16 *)(v4 + 2);
  if (v5 == 0xFFFF) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = *(_DWORD *)(v4 + 8);
  }
  uint64_t v18 = (long long *)((char *)this + 16);
  unint64_t v11 = *((void *)this + 2) + v6;
  if ((*((void *)this + 12) || *((void *)this + 13)) && v5 != 0xFFFF) {
    unsigned int v19 = *(_DWORD *)(v4 + 12);
  }
  else {
    unsigned int v19 = 0;
  }
  long long v20 = *((_OWORD *)this + 2);
  long long v38 = *v18;
  long long v39 = v20;
  uint64_t result = sub_1CCC207AC((llvm::object *)&v38, v11, 18 * v19, a2);
  if (*a2) {
    return result;
  }
  *((void *)this + 12) = v11;
  *a2 = 0;
  BOOL v8 = (void *)((char *)this + 56);
  uint64_t v7 = *((void *)this + 7);
  uint64_t v12 = *((void *)this + 6);
  if (!v7)
  {
LABEL_31:
    if (v12)
    {
      if (*(__int16 *)(v12 + 2) == -1)
      {
        int v24 = 0;
        int v26 = 0;
        goto LABEL_37;
      }
      int v24 = 0;
      int v25 = (int *)(v12 + 8);
LABEL_36:
      int v26 = *v25;
LABEL_37:
      if (*((void *)this + 12) || *((void *)this + 13))
      {
        if (v24)
        {
          uint64_t v27 = (int *)(*v8 + 52);
LABEL_43:
          int v28 = *v27;
          goto LABEL_45;
        }
        if (*(__int16 *)(v12 + 2) != -1)
        {
          uint64_t v27 = (int *)(v12 + 12);
          goto LABEL_43;
        }
      }
      int v28 = 0;
LABEL_45:
      if (v24) {
        int v29 = 20;
      }
      else {
        int v29 = 18;
      }
      long long v30 = *((_OWORD *)this + 2);
      char v31 = (unsigned int *)(*((void *)this + 2) + (v26 + v28 * v29));
      long long v38 = *((_OWORD *)this + 1);
      long long v39 = v30;
      uint64_t result = sub_1CCC207AC((llvm::object *)&v38, (unint64_t)v31, 4uLL, a2);
      if (!*a2)
      {
        *a2 = 0;
        unint64_t v32 = *v31;
        *((_DWORD *)this + 30) = v32;
        long long v33 = *((_OWORD *)this + 2);
        long long v38 = *((_OWORD *)this + 1);
        long long v39 = v33;
        uint64_t result = sub_1CCC207AC((llvm::object *)&v38, (unint64_t)v31, v32, a2);
        if (!*a2)
        {
          *((void *)this + 14) = v31;
          *a2 = 0;
          unsigned int v34 = *((_DWORD *)this + 30);
          if (v34 > 3)
          {
            if (v34 != 4)
            {
              if (*((unsigned char *)v31 + v34 - 1))
              {
                atomic_ullong v35 = llvm::object::object_category(result);
                *(void *)&long long v38 = 3;
                *((void *)&v38 + 1) = v35;
                long long v40 = "string table missing null terminator";
                sub_1CD06481C();
              }
            }
          }
          else
          {
            *((_DWORD *)this + 30) = 4;
          }
          *a2 = 0;
        }
      }
      return result;
    }
    uint64_t v7 = *v8;
LABEL_35:
    uint64_t v12 = 0;
    int v25 = (int *)(v7 + 48);
    int v24 = 1;
    goto LABEL_36;
  }
  unint64_t v9 = (void *)((char *)this + 104);
  long long v36 = *v18;
  long long v37 = *((_OWORD *)this + 2);
  uint64_t v10 = *((void *)this + 2);
  if (!v12) {
    goto LABEL_6;
  }
  if (*(__int16 *)(v12 + 2) == -1)
  {
    int v14 = 0;
    unsigned int v15 = 0;
    goto LABEL_8;
  }
  int v14 = 0;
  unsigned int v13 = (unsigned int *)(v12 + 8);
LABEL_7:
  unsigned int v15 = *v13;
LABEL_8:
  uint64_t v16 = v10 + v15;
  if (v11 || *v9)
  {
    if (v14)
    {
      int v17 = (unsigned int *)(v7 + 52);
LABEL_25:
      unsigned int v22 = *v17;
      goto LABEL_27;
    }
    if (*(__int16 *)(v12 + 2) != -1)
    {
      int v17 = (unsigned int *)(v12 + 12);
      goto LABEL_25;
    }
  }
  unsigned int v22 = 0;
LABEL_27:
  unsigned int v23 = 18;
  if (v14) {
    unsigned int v23 = 20;
  }
  long long v38 = v36;
  long long v39 = v37;
  uint64_t result = sub_1CCC207AC((llvm::object *)&v38, v10 + v15, v22 * (unint64_t)v23, a2);
  if (!*a2)
  {
    *((void *)this + 13) = v16;
    *a2 = 0;
    uint64_t v12 = *((void *)this + 6);
    goto LABEL_31;
  }
  return result;
}

llvm::object *llvm::object::COFFObjectFile::getVaPtr@<X0>(llvm::object::COFFObjectFile *this@<X0>, unint64_t *a2@<X2>, int a3@<W1>, void *a4@<X8>)
{
  uint64_t v4 = *((void *)this + 8);
  if (v4)
  {
    LODWORD(v4) = *(_DWORD *)(v4 + 28);
  }
  else
  {
    uint64_t v4 = *((void *)this + 9);
    if (v4) {
      uint64_t v4 = *(void *)(v4 + 24);
    }
  }
  return llvm::object::COFFObjectFile::getRvaPtr(this, a2, 0, a3 - (int)v4, a4);
}

llvm::object *llvm::object::COFFObjectFile::getRvaPtr@<X0>(llvm::object::COFFObjectFile *this@<X0>, unint64_t *a2@<X2>, const char *a3@<X3>, unsigned int a4@<W1>, void *a5@<X8>)
{
  unsigned int v28 = a4;
  uint64_t v27 = a3;
  uint64_t v10 = (llvm::object *)(*(uint64_t (**)(llvm::object::COFFObjectFile *))(*(void *)this + 344))(this);
  uint64_t v12 = v11;
  uint64_t result = (llvm::object *)(*(uint64_t (**)(llvm::object::COFFObjectFile *))(*(void *)this + 352))(this);
  int v25 = v10;
  uint64_t v26 = v12;
  if (v12 == v14 && v10 == result)
  {
LABEL_15:
    atomic_ullong v24 = llvm::object::object_category(result);
    if (!a3) {
      sub_1CD5E50F0(3, v24, (uint64_t)"RVA 0x%x not found", &v28);
    }
    sub_1CD5E5228(3, v24, (uint64_t)"RVA 0x%x for %s not found", (int *)&v28, (uint64_t *)&v27);
  }
  uint64_t v16 = result;
  uint64_t v17 = v14;
  while (1)
  {
    unsigned int v18 = *((_DWORD *)v10 + 3);
    unsigned int v19 = *((_DWORD *)v10 + 2) + v18;
    BOOL v20 = a4 >= v18;
    uint64_t v21 = a4 - v18;
    if (v20 && v19 > a4) {
      break;
    }
    uint64_t result = (llvm::object *)(*(uint64_t (**)(uint64_t, llvm::object **))(*(void *)v12 + 128))(v12, &v25);
    uint64_t v10 = v25;
    uint64_t v12 = v26;
    if (v26 == v17 && v25 == v16) {
      goto LABEL_15;
    }
  }
  *a2 = *((void *)this + 2) + *((unsigned int *)v10 + 5) + v21;
  *a5 = 0;
  return result;
}

uint64_t llvm::object::COFFObjectFile::getCOFFSection(uint64_t a1, uint64_t a2)
{
  return *(void *)a2;
}

llvm::object *llvm::object::COFFObjectFile::getRvaAndSizeAsBytes@<X0>(void *a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, void *a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  unsigned int v30 = a2;
  uint64_t v29 = a5;
  uint64_t v12 = (llvm::object *)(*(uint64_t (**)(void *))(*a1 + 344))(a1);
  uint64_t v14 = v13;
  uint64_t result = (llvm::object *)(*(uint64_t (**)(void *))(*a1 + 352))(a1);
  uint64_t v27 = v12;
  uint64_t v28 = v14;
  if (v14 == v16 && v12 == result)
  {
LABEL_16:
    atomic_ullong v26 = llvm::object::object_category(result);
    if (!a5) {
      sub_1CD5E50F0(3, v26, (uint64_t)"RVA 0x%x not found", &v30);
    }
    sub_1CD5E5228(3, v26, (uint64_t)"RVA 0x%x for %s not found", (int *)&v30, &v29);
  }
  unsigned int v18 = result;
  uint64_t v19 = v16;
  while (1)
  {
    unsigned int v20 = *((_DWORD *)v12 + 3);
    BOOL v21 = a2 >= v20;
    unsigned int v22 = a2 - v20;
    if (v21)
    {
      unsigned int v23 = *((_DWORD *)v12 + 2);
      BOOL v21 = v23 >= v22;
      unsigned int v24 = v23 - v22;
      if (v24 != 0 && v21 && v24 >= a3) {
        break;
      }
    }
    uint64_t result = (llvm::object *)(*(uint64_t (**)(uint64_t, llvm::object **))(*(void *)v14 + 128))(v14, &v27);
    uint64_t v12 = v27;
    uint64_t v14 = v28;
    if (v28 == v19 && v27 == v18) {
      goto LABEL_16;
    }
  }
  *a4 = a1[2] + v22 + *((unsigned int *)v12 + 5);
  a4[1] = a3;
  *a6 = 0;
  return result;
}

uint64_t llvm::object::COFFObjectFile::getHintName@<X0>(llvm::object::COFFObjectFile *this@<X0>, unsigned __int16 *a2@<X2>, llvm::StringRef *a3@<X3>, unsigned int a4@<W1>, void *a5@<X8>)
{
  __s = 0;
  uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this, (unint64_t *)&__s, 0, a4, a5);
  if (!*a5)
  {
    unint64_t v9 = __s + 2;
    *a2 = *(_WORD *)__s;
    uint64_t result = strlen(v9);
    *(void *)a3 = v9;
    *((void *)a3 + 1) = result;
    *a5 = 0;
  }
  return result;
}

llvm::object *llvm::object::COFFObjectFile::getDebugPDBInfo@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X3>, void *a5@<X8>)
{
  uint64_t v14 = 0;
  unint64_t v15 = 0;
  uint64_t result = llvm::object::COFFObjectFile::getRvaAndSizeAsBytes(a1, *(_DWORD *)(a2 + 20), *(_DWORD *)(a2 + 16), &v14, (uint64_t)"PDB info", a5);
  if (!*a5)
  {
    unint64_t v9 = v15 - 24;
    if (v15 <= 0x18)
    {
      atomic_ullong v10 = llvm::object::object_category(result);
      v17[0] = 3;
      v17[1] = v10;
      uint64_t v16 = "PDB info too small";
      sub_1CD06481C();
    }
    uint64_t v11 = v14;
    *a3 = v14;
    uint64_t v12 = v11 + 24;
    *a4 = v11 + 24;
    a4[1] = v9;
    LOBYTE(v17[0]) = 0;
    uint64_t result = (llvm::object *)llvm::StringRef::find(a4, (char *)v17, 1uLL, 0);
    if (v9 >= (unint64_t)result) {
      uint64_t v13 = result;
    }
    else {
      uint64_t v13 = (llvm::object *)v9;
    }
    if (result == (llvm::object *)-1) {
      uint64_t v13 = (llvm::object *)v9;
    }
    *a4 = v12;
    a4[1] = (uint64_t)v13;
    *a5 = 0;
  }
  return result;
}

llvm::object *llvm::object::COFFObjectFile::getDebugPDBInfo@<X0>(llvm::object *result@<X0>, void *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  int v5 = (_DWORD *)*((void *)result + 22);
  uint64_t v4 = (_DWORD *)*((void *)result + 23);
  if (v5 == v4)
  {
LABEL_5:
    *a2 = 0;
    *a3 = 0;
    a3[1] = 0;
    *a4 = 0;
  }
  else
  {
    unsigned int v6 = v5 + 3;
    while (*v6 != 2)
    {
      uint64_t v7 = v6 + 4;
      v6 += 7;
      if (v7 == v4) {
        goto LABEL_5;
      }
    }
    return llvm::object::COFFObjectFile::getDebugPDBInfo(result, (uint64_t)(v6 - 3), a2, a3, a4);
  }
  return result;
}

uint64_t llvm::object::COFFObjectFile::getDataDirectory(llvm::object::COFFObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 10);
  if (v2
    && ((uint64_t v3 = *((void *)this + 8)) == 0
      ? (uint64_t v4 = (unsigned int *)(*((void *)this + 9) + 108))
      : (uint64_t v4 = (unsigned int *)(v3 + 92)),
        *v4 > a2))
  {
    return v2 + 8 * a2;
  }
  else
  {
    return 0;
  }
}

llvm::object *sub_1CCC207AC@<X0>(llvm::object *result@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  unint64_t v5 = a3 + a2;
  if (__CFADD__(a3, a2)
    || v5 < a3
    || (*(void *)result <= a2 ? (BOOL v6 = v5 > *(void *)result + *((void *)result + 1)) : (BOOL v6 = 1), v6))
  {
    *(void *)&v7.__val_ = llvm::object::object_category(result);
    return (llvm::object *)llvm::errorCodeToError((llvm *)4, v7, a4);
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

llvm::object *llvm::object::COFFObjectFile::initialize@<X0>(llvm::object::COFFObjectFile *this@<X0>, void *a2@<X8>)
{
  uint64_t result = (llvm::object *)std::system_category();
  unint64_t v5 = *((void *)this + 3);
  if (v5 <= 0x13)
  {
    *(void *)&v11.__val_ = llvm::object::object_category(result);
    return (llvm::object *)llvm::errorCodeToError((llvm *)4, v11, a2);
  }
  BOOL v6 = (void *)((char *)this + 16);
  if (v5 <= 0x43)
  {
    llvm::object::object_category(result);
    int v12 = 0;
    uint64_t v13 = 0;
    std::error_code v7 = (unsigned char *)*v6;
  }
  else
  {
    std::error_code v7 = (unsigned char *)*v6;
    if (*(unsigned char *)*v6 == 77 && v7[1] == 90)
    {
      uint64_t v8 = *((unsigned int *)v7 + 15);
      if (*(_DWORD *)&v7[v8] != 17744)
      {
LABEL_6:
        atomic_ullong v9 = llvm::object::object_category(result);
        *(void *)&long long v41 = 3;
        *((void *)&v41 + 1) = v9;
        atomic_ullong v10 = "incorrect PE magic";
        goto LABEL_60;
      }
      uint64_t v13 = v8 + 4;
      int v12 = 1;
    }
    else
    {
      int v12 = 0;
      uint64_t v13 = 0;
    }
  }
  long long v14 = *((_OWORD *)this + 2);
  long long v41 = *(_OWORD *)v6;
  long long v42 = v14;
  unint64_t v15 = &v7[v13];
  uint64_t result = sub_1CCC207AC((llvm::object *)&v41, (unint64_t)&v7[v13], 0x14uLL, a2);
  if (!*a2)
  {
    *((void *)this + 6) = v15;
    *a2 = 0;
    if ((v12 & 1) == 0)
    {
      if (*v15) {
        goto LABEL_29;
      }
      if ((__int16)v15[1] == -1)
      {
        if (*((void *)this + 3) <= 0x37uLL)
        {
          llvm::object::object_category(result);
        }
        else
        {
          long long v16 = *((_OWORD *)this + 2);
          long long v41 = *(_OWORD *)v6;
          long long v42 = v16;
          unint64_t v17 = *((void *)this + 2) + v13;
          uint64_t result = sub_1CCC207AC((llvm::object *)&v41, v17, 0x38uLL, a2);
          if (*a2) {
            return result;
          }
          *((void *)this + 7) = v17;
          *a2 = 0;
          if (*(unsigned __int16 *)(v17 + 4) >= 2u
            && *(void *)(v17 + 12) == 0x4BA9BAEED1BAA1C7
            && *(void *)(v17 + 20) == 0xB8DCA46AF6FA20AFLL)
          {
            *((void *)this + 6) = 0;
            v13 += 56;
            goto LABEL_45;
          }
          *((void *)this + 7) = 0;
        }
      }
      unint64_t v15 = (_WORD *)*((void *)this + 6);
    }
    if (!v15)
    {
      uint64_t v21 = 0;
      if (!v12) {
        goto LABEL_31;
      }
      goto LABEL_37;
    }
LABEL_29:
    uint64_t v19 = std::system_category();
    uint64_t v21 = *((void *)this + 6);
    if (*(__int16 *)(v21 + 2) == -1)
    {
      *(void *)&v20.__val_ = v19;
      return (llvm::object *)llvm::errorCodeToError(0, v20, a2);
    }
    v13 += 20;
    if (!v12)
    {
LABEL_31:
      if (v21)
      {
LABEL_32:
        uint64_t v22 = v13 + *(unsigned __int16 *)(v21 + 16);
        long long v23 = *((_OWORD *)this + 2);
        long long v39 = *(_OWORD *)v6;
        long long v40 = v23;
        unint64_t v24 = *v6 + v22;
        unsigned int v25 = *(unsigned __int16 *)(v21 + 2);
        if (v25 == 0xFFFF) {
          unsigned int v25 = 0;
        }
LABEL_46:
        long long v41 = v39;
        long long v42 = v40;
        uint64_t result = sub_1CCC207AC((llvm::object *)&v41, v24, 40 * v25, a2);
        if (*a2) {
          return result;
        }
        *((void *)this + 11) = v24;
        *a2 = 0;
        uint64_t v34 = *((void *)this + 6);
        if (v34)
        {
          if (*(__int16 *)(v34 + 2) == -1) {
            goto LABEL_52;
          }
          atomic_ullong v35 = (_DWORD *)(v34 + 8);
        }
        else
        {
          atomic_ullong v35 = (_DWORD *)(*((void *)this + 7) + 48);
        }
        if (*v35)
        {
          llvm::object::COFFObjectFile::initSymbolTablePtr(this, &v41);
          if ((void)v41)
          {
            long long v38 = (void *)v41;
            *(void *)&long long v41 = 0;
            sub_1CD4515D0(&v38);
            if (v38) {
              (*(void (**)(void *))(*v38 + 8))(v38);
            }
            *((void *)this + 12) = 0;
            *((void *)this + 13) = 0;
            *((_DWORD *)this + 30) = 0;
            *((void *)this + 14) = 0;
            if ((void)v41) {
              (*(void (**)(void))(*(void *)v41 + 8))(v41);
            }
          }
          goto LABEL_66;
        }
LABEL_52:
        if (*((void *)this + 12) || *((void *)this + 13))
        {
          if (!v34)
          {
            long long v36 = (_DWORD *)(*((void *)this + 7) + 52);
LABEL_58:
            if (*v36)
            {
              atomic_ullong v37 = llvm::object::object_category(result);
              *(void *)&long long v41 = 3;
              *((void *)&v41 + 1) = v37;
              atomic_ullong v10 = "symbol table missing";
LABEL_60:
              size_t v43 = v10;
              sub_1CD06481C();
            }
            goto LABEL_66;
          }
          if (*(__int16 *)(v34 + 2) != -1)
          {
            long long v36 = (_DWORD *)(v34 + 12);
            goto LABEL_58;
          }
        }
LABEL_66:
        uint64_t result = llvm::object::COFFObjectFile::initImportTablePtr(this, a2);
        if (!*a2)
        {
          uint64_t result = llvm::object::COFFObjectFile::initDelayImportTablePtr(this, a2);
          if (!*a2)
          {
            uint64_t result = llvm::object::COFFObjectFile::initExportTablePtr(this, a2);
            if (!*a2)
            {
              uint64_t result = llvm::object::COFFObjectFile::initBaseRelocPtr(this, a2);
              if (!*a2)
              {
                uint64_t result = llvm::object::COFFObjectFile::initDebugDirectoryPtr(this, a2);
                if (!*a2)
                {
                  uint64_t result = llvm::object::COFFObjectFile::initTLSDirectoryPtr(this, a2);
                  if (!*a2)
                  {
                    uint64_t result = llvm::object::COFFObjectFile::initLoadConfigPtr(this, a2);
                    if (!*a2) {
                      *a2 = 0;
                    }
                  }
                }
              }
            }
          }
        }
        return result;
      }
      goto LABEL_44;
    }
LABEL_37:
    long long v26 = *((_OWORD *)this + 2);
    long long v41 = *(_OWORD *)v6;
    long long v42 = v26;
    uint64_t v27 = (unsigned __int16 *)(*v6 + v13);
    uint64_t result = sub_1CCC207AC((llvm::object *)&v41, (unint64_t)v27, 0x60uLL, a2);
    if (*a2) {
      return result;
    }
    *a2 = 0;
    int v28 = *v27;
    if (v28 == 267)
    {
      *((void *)this + 8) = v27;
      unint64_t v29 = *((void *)this + 2) + v13 + 96;
      unsigned int v30 = (unsigned int *)(v27 + 46);
    }
    else
    {
      if (v28 != 523) {
        goto LABEL_6;
      }
      *((void *)this + 9) = v27;
      unint64_t v29 = *((void *)this + 2) + v13 + 112;
      unsigned int v30 = (unsigned int *)(v27 + 54);
    }
    unint64_t v31 = 8 * *v30;
    long long v32 = *((_OWORD *)this + 2);
    long long v41 = *(_OWORD *)v6;
    long long v42 = v32;
    uint64_t result = sub_1CCC207AC((llvm::object *)&v41, v29, v31, a2);
    if (*a2) {
      return result;
    }
    *((void *)this + 10) = v29;
    *a2 = 0;
    uint64_t v21 = *((void *)this + 6);
    if (v21) {
      goto LABEL_32;
    }
LABEL_44:
    unint64_t v17 = *((void *)this + 7);
LABEL_45:
    long long v33 = *((_OWORD *)this + 2);
    long long v39 = *(_OWORD *)v6;
    long long v40 = v33;
    unint64_t v24 = *v6 + v13;
    unsigned int v25 = *(_DWORD *)(v17 + 44);
    goto LABEL_46;
  }
  return result;
}

uint64_t llvm::object::COFFObjectFile::import_directory_begin@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(_DWORD **)(this + 128);
  if (!v2) {
    goto LABEL_9;
  }
  if (!*v2 && !v2[1] && !v2[2] && !v2[3] && !v2[4])
  {
    uint64_t v2 = 0;
LABEL_9:
    int v3 = -1;
    goto LABEL_10;
  }
  int v3 = 0;
LABEL_10:
  *(void *)a2 = v2;
  *(_DWORD *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::import_directory_end@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 8) = -1;
  *(void *)(a2 + 16) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::delay_import_directory_begin@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = *(void *)(this + 136);
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::delay_import_directory_end@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  int v2 = *(_DWORD *)(this + 144);
  *(void *)a2 = *(void *)(this + 136);
  *(_DWORD *)(a2 + 8) = v2;
  *(void *)(a2 + 16) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::export_directory_begin@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = *(void *)(this + 152);
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::export_directory_end@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 152);
  if (v2) {
    int v3 = *(_DWORD *)(v2 + 20);
  }
  else {
    int v3 = 0;
  }
  *(void *)a2 = v2;
  *(_DWORD *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::section_end(llvm::object::COFFObjectFile *this)
{
  uint64_t v1 = *((void *)this + 6);
  if (v1)
  {
    int v2 = *(unsigned __int16 *)(v1 + 2);
    if (v2 == 0xFFFF) {
      int v2 = 0;
    }
  }
  else
  {
    int v2 = *(_DWORD *)(*((void *)this + 7) + 44);
  }
  return *((void *)this + 11) + 40 * v2;
}

uint64_t llvm::object::COFFObjectFile::base_reloc_begin(llvm::object::COFFObjectFile *this)
{
  return *((void *)this + 20);
}

uint64_t llvm::object::COFFObjectFile::base_reloc_end(llvm::object::COFFObjectFile *this)
{
  return *((void *)this + 21);
}

uint64_t llvm::object::COFFObjectFile::import_directories@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  int v2 = *(_DWORD **)(this + 128);
  if (!v2) {
    goto LABEL_9;
  }
  if (!*v2 && !v2[1] && !v2[2] && !v2[3] && !v2[4])
  {
    int v2 = 0;
LABEL_9:
    int v3 = -1;
    goto LABEL_10;
  }
  int v3 = 0;
LABEL_10:
  *(void *)a2 = v2;
  *(_DWORD *)(a2 + 8) = v3;
  *(void *)(a2 + 16) = this;
  *(void *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 32) = -1;
  *(void *)(a2 + 40) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::delay_import_directories@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 136);
  int v3 = *(_DWORD *)(this + 144);
  *(void *)a2 = v2;
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = this;
  *(void *)(a2 + 24) = v2;
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 40) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::export_directories@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 152);
  if (v2) {
    int v3 = *(_DWORD *)(v2 + 20);
  }
  else {
    int v3 = 0;
  }
  *(void *)a2 = v2;
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = this;
  *(void *)(a2 + 24) = v2;
  *(_DWORD *)(a2 + 32) = v3;
  *(void *)(a2 + 40) = this;
  return this;
}

uint64_t llvm::object::COFFObjectFile::base_relocs@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 168);
  *a2 = *(void *)(this + 160);
  a2[1] = 0;
  a2[2] = v2;
  a2[3] = 0;
  return this;
}

uint64_t llvm::object::COFFObjectFile::getSymbolAuxData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 18;
  if (!*(void *)(a1 + 48)) {
    uint64_t v3 = 20;
  }
  uint64_t v4 = (unsigned __int8 *)(a2 + 17);
  if (!a2) {
    uint64_t v4 = (unsigned __int8 *)(a3 + 19);
  }
  int v5 = *v4;
  if (a2) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = a3;
  }
  uint64_t v7 = v6 + v3;
  if (v5) {
    return v7;
  }
  else {
    return 0;
  }
}

unint64_t llvm::object::COFFObjectFile::getSymbolIndex(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[12];
  if (!v3) {
    uint64_t v3 = a1[13];
  }
  if (a2) {
    a3 = a2;
  }
  unint64_t v5 = a3 - v3;
  unint64_t v6 = 18;
  if (!a1[6]) {
    unint64_t v6 = 20;
  }
  return v5 / v6;
}

uint64_t llvm::object::COFFObjectFile::toRel(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t llvm::object::COFFObjectFile::getCOFFRelocation(uint64_t a1, uint64_t a2)
{
  return *(void *)a2;
}

unint64_t llvm::object::COFFObjectFile::getRelocations(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a1 + 32);
  v9[0] = *(_OWORD *)(a1 + 16);
  v9[1] = v4;
  unint64_t v5 = sub_1CCC1FD74(a2, v9, *(void *)(a1 + 16));
  long long v6 = *(_OWORD *)(a1 + 32);
  v8[0] = *(_OWORD *)(a1 + 16);
  v8[1] = v6;
  sub_1CCC1FE88(a2, v8, *(void *)(a1 + 16));
  return v5;
}

BOOL llvm::object::ImportDirectoryEntryRef::operator==(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2 && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

uint64_t *llvm::object::ImportDirectoryEntryRef::moveNext(uint64_t *this)
{
  unsigned int v1 = *((_DWORD *)this + 2) + 1;
  *((_DWORD *)this + 2) = v1;
  uint64_t v2 = *this;
  if (!*(_DWORD *)(*this + 20 * v1)
    && !*(_DWORD *)(v2 + 20 * v1 + 4)
    && !*(_DWORD *)(v2 + 20 * v1 + 8)
    && !*(_DWORD *)(v2 + 20 * v1 + 12)
    && !*(_DWORD *)(v2 + 20 * v1 + 16))
  {
    *((_DWORD *)this + 2) = -1;
    *this = 0;
  }
  return this;
}

llvm::object *llvm::object::ImportDirectoryEntryRef::getImportTableEntry@<X0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  long long v8 = *(_OWORD *)(v5 + 32);
  unint64_t v6 = *(void *)a1 + 20 * *(unsigned int *)(a1 + 8);
  v9[0] = *(_OWORD *)(v5 + 16);
  v9[1] = v8;
  uint64_t result = sub_1CCC207AC((llvm::object *)v9, v6, 0x14uLL, a3);
  if (!*a3)
  {
    *a2 = v6;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::object::ImportDirectoryEntryRef::imported_symbol_begin@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  return sub_1CCC2112C(a2, *((_DWORD *)*this + 5 * *((unsigned int *)this + 2) + 4), this[2]);
}

uint64_t sub_1CCC2112C(uint64_t a1, unsigned int a2, llvm::object::COFFObjectFile *this)
{
  unint64_t v10 = 0;
  llvm::object::COFFObjectFile::getRvaPtr(this, &v10, 0, a2, &v9);
  unint64_t v5 = v10;
  uint64_t result = (*(uint64_t (**)(llvm::object::COFFObjectFile *))(*(void *)this + 360))(this);
  if (result == 4) {
    unint64_t v7 = v5;
  }
  else {
    unint64_t v7 = 0;
  }
  if (result == 4) {
    unint64_t v8 = 0;
  }
  else {
    unint64_t v8 = v5;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v8;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = this;
  return result;
}

uint64_t llvm::object::ImportDirectoryEntryRef::imported_symbol_end@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  return sub_1CCC211F0(a2, *((_DWORD *)*this + 5 * *((unsigned int *)this + 2) + 4), this[2]);
}

uint64_t sub_1CCC211F0(uint64_t a1, unsigned int a2, llvm::object::COFFObjectFile *this)
{
  unint64_t v16 = 0;
  llvm::object::COFFObjectFile::getRvaPtr(this, &v16, 0, a2, &v15);
  int v5 = (*(uint64_t (**)(llvm::object::COFFObjectFile *))(*(void *)this + 360))(this);
  unint64_t v6 = v16;
  if (v5 == 4)
  {
    if (*(_DWORD *)v16)
    {
      int v7 = 0;
      unint64_t v8 = (_DWORD *)(v16 + 4);
      do
        ++v7;
      while (*v8++);
      goto LABEL_11;
    }
  }
  else if (*(void *)v16)
  {
    int v7 = 0;
    unint64_t v10 = (void *)(v16 + 8);
    do
      ++v7;
    while (*v10++);
    goto LABEL_11;
  }
  int v7 = 0;
LABEL_11:
  uint64_t result = (*(uint64_t (**)(llvm::object::COFFObjectFile *))(*(void *)this + 360))(this);
  if (result == 4) {
    unint64_t v13 = v6;
  }
  else {
    unint64_t v13 = 0;
  }
  if (result == 4) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = v6;
  }
  *(void *)a1 = v13;
  *(void *)(a1 + 8) = v14;
  *(_DWORD *)(a1 + 16) = v7;
  *(void *)(a1 + 24) = this;
  return result;
}

uint64_t llvm::object::ImportDirectoryEntryRef::imported_symbols@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  sub_1CCC2112C(a2, *((_DWORD *)*this + 5 * *((unsigned int *)this + 2) + 4), this[2]);
  unsigned int v4 = *((_DWORD *)*this + 5 * *((unsigned int *)this + 2) + 4);
  int v5 = this[2];

  return sub_1CCC211F0(a2 + 32, v4, v5);
}

uint64_t llvm::object::ImportDirectoryEntryRef::lookup_table_begin@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  return sub_1CCC2112C(a2, *((_DWORD *)*this + 5 * *((unsigned int *)this + 2)), this[2]);
}

uint64_t llvm::object::ImportDirectoryEntryRef::lookup_table_end@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  return sub_1CCC211F0(a2, *((_DWORD *)*this + 5 * *((unsigned int *)this + 2)), this[2]);
}

uint64_t llvm::object::ImportDirectoryEntryRef::lookup_table_symbols@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  sub_1CCC2112C(a2, *((_DWORD *)*this + 5 * *((unsigned int *)this + 2)), this[2]);
  unsigned int v4 = *((_DWORD *)*this + 5 * *((unsigned int *)this + 2));
  int v5 = this[2];

  return sub_1CCC211F0(a2 + 32, v4, v5);
}

uint64_t llvm::object::ImportDirectoryEntryRef::getName@<X0>(llvm::object::COFFObjectFile **this@<X0>, llvm::StringRef *a2@<X1>, void *a3@<X8>)
{
  __s = 0;
  uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this[2], (unint64_t *)&__s, "import directory name", *((_DWORD *)*this + 5 * *((unsigned int *)this + 2) + 3), a3);
  if (!*a3)
  {
    if (__s) {
      uint64_t result = strlen(__s);
    }
    else {
      uint64_t result = 0;
    }
    *(void *)a2 = __s;
    *((void *)a2 + 1) = result;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::object::ImportDirectoryEntryRef::getImportLookupTableRVA@<X0>(uint64_t this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  *a2 = *(_DWORD *)(*(void *)this + 20 * *(unsigned int *)(this + 8));
  *a3 = 0;
  return this;
}

uint64_t llvm::object::ImportDirectoryEntryRef::getImportAddressTableRVA@<X0>(uint64_t this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  *a2 = *(_DWORD *)(*(void *)this + 20 * *(unsigned int *)(this + 8) + 16);
  *a3 = 0;
  return this;
}

BOOL llvm::object::DelayImportDirectoryEntryRef::operator==(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2 && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

uint64_t llvm::object::DelayImportDirectoryEntryRef::moveNext(uint64_t this)
{
  return this;
}

uint64_t llvm::object::DelayImportDirectoryEntryRef::imported_symbol_begin@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  return sub_1CCC2112C(a2, *((_DWORD *)*this + 8 * *((unsigned int *)this + 2) + 4), this[2]);
}

uint64_t llvm::object::DelayImportDirectoryEntryRef::imported_symbol_end@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  return sub_1CCC211F0(a2, *((_DWORD *)*this + 8 * *((unsigned int *)this + 2) + 4), this[2]);
}

uint64_t llvm::object::DelayImportDirectoryEntryRef::imported_symbols@<X0>(llvm::object::COFFObjectFile **this@<X0>, uint64_t a2@<X8>)
{
  sub_1CCC2112C(a2, *((_DWORD *)*this + 8 * *((unsigned int *)this + 2) + 4), this[2]);
  unsigned int v4 = *((_DWORD *)*this + 8 * *((unsigned int *)this + 2) + 4);
  int v5 = this[2];

  return sub_1CCC211F0(a2 + 32, v4, v5);
}

uint64_t llvm::object::DelayImportDirectoryEntryRef::getName@<X0>(llvm::object::COFFObjectFile **this@<X0>, llvm::StringRef *a2@<X1>, void *a3@<X8>)
{
  __s = 0;
  uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this[2], (unint64_t *)&__s, "delay import directory name", *((_DWORD *)*this + 8 * *((unsigned int *)this + 2) + 1), a3);
  if (!*a3)
  {
    if (__s) {
      uint64_t result = strlen(__s);
    }
    else {
      uint64_t result = 0;
    }
    *(void *)a2 = __s;
    *((void *)a2 + 1) = result;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::object::DelayImportDirectoryEntryRef::getDelayImportTable@<X0>(uint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  *a2 = *(void *)result + 32 * *(unsigned int *)(result + 8);
  *a3 = 0;
  return result;
}

llvm::object *llvm::object::DelayImportDirectoryEntryRef::getImportAddress@<X0>(llvm::object::DelayImportDirectoryEntryRef *this@<X0>, unint64_t *a2@<X2>, int a3@<W1>, void *a4@<X8>)
{
  int v7 = *(_DWORD *)(*(void *)this + 32 * *((unsigned int *)this + 2) + 12);
  unint64_t v8 = (llvm::object::COFFObjectFile *)*((void *)this + 2);
  if (*((void *)v8 + 9)) {
    char v9 = 3;
  }
  else {
    char v9 = 2;
  }
  unint64_t v12 = 0;
  uint64_t result = llvm::object::COFFObjectFile::getRvaPtr(v8, &v12, "import address", (a3 << v9) + v7, a4);
  if (!*a4)
  {
    if (*(void *)(*((void *)this + 2) + 72)) {
      unint64_t v11 = *(void *)v12;
    }
    else {
      unint64_t v11 = *(unsigned int *)v12;
    }
    *a2 = v11;
    *a4 = 0;
  }
  return result;
}

BOOL llvm::object::ExportDirectoryEntryRef::operator==(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2 && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

uint64_t llvm::object::ExportDirectoryEntryRef::moveNext(uint64_t this)
{
  return this;
}

uint64_t llvm::object::ExportDirectoryEntryRef::getDllName@<X0>(llvm::object::COFFObjectFile **this@<X0>, llvm::StringRef *a2@<X1>, void *a3@<X8>)
{
  __s = 0;
  uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this[2], (unint64_t *)&__s, "dll name", *((_DWORD *)*this + 3), a3);
  if (!*a3)
  {
    if (__s) {
      uint64_t result = strlen(__s);
    }
    else {
      uint64_t result = 0;
    }
    *(void *)a2 = __s;
    *((void *)a2 + 1) = result;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::object::ExportDirectoryEntryRef::getOrdinalBase@<X0>(uint64_t this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  *a2 = *(_DWORD *)(*(void *)this + 16);
  *a3 = 0;
  return this;
}

_DWORD *llvm::object::ExportDirectoryEntryRef::getOrdinal@<X0>(_DWORD *this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  *a2 = this[2] + *(_DWORD *)(*(void *)this + 16);
  *a3 = 0;
  return this;
}

llvm::object *llvm::object::ExportDirectoryEntryRef::getExportRVA@<X0>(llvm::object::COFFObjectFile **this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  unint64_t v7 = 0;
  uint64_t result = llvm::object::COFFObjectFile::getRvaPtr(this[2], &v7, "export address", *((_DWORD *)*this + 7), a3);
  if (!*a3)
  {
    *a2 = *(_DWORD *)(v7 + 4 * *((unsigned int *)this + 2));
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::object::ExportDirectoryEntryRef::getSymbolName@<X0>(llvm::object::COFFObjectFile **this@<X0>, llvm::StringRef *a2@<X1>, void *a3@<X8>)
{
  __s = 0;
  uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this[2], (unint64_t *)&__s, "export ordinal table", *((_DWORD *)*this + 9), a3);
  if (*a3) {
    return result;
  }
  uint64_t v7 = *((unsigned int *)*this + 6);
  if (!v7)
  {
    uint64_t result = 0;
    unint64_t v11 = (char *)&unk_1CFBFB355;
LABEL_8:
    *(void *)a2 = v11;
    *((void *)a2 + 1) = result;
    *a3 = 0;
    return result;
  }
  uint64_t v8 = 0;
  char v9 = __s;
  unint64_t v10 = &__s[2 * v7];
  unint64_t v11 = (char *)&unk_1CFBFB355;
  while (*((_DWORD *)this + 2) != *(unsigned __int16 *)v9)
  {
    v9 += 2;
    v8 += 4;
    if (v9 >= v10) {
      goto LABEL_6;
    }
  }
  uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this[2], (unint64_t *)&__s, "export table entry", *((_DWORD *)*this + 8), a3);
  if (!*a3)
  {
    uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this[2], (unint64_t *)&__s, "export symbol name", *(_DWORD *)&__s[v8], a3);
    if (!*a3)
    {
      unint64_t v11 = __s;
      if (!__s)
      {
LABEL_6:
        uint64_t result = 0;
        goto LABEL_8;
      }
      uint64_t result = strlen(__s);
      goto LABEL_8;
    }
  }
  return result;
}

llvm::object *llvm::object::ExportDirectoryEntryRef::isForwarder@<X0>(llvm::object::ExportDirectoryEntryRef *this@<X0>, BOOL *a2@<X1>, void *a3@<X8>)
{
  int v5 = (llvm::object *)*((void *)this + 2);
  unint64_t v6 = (unsigned int *)*((void *)v5 + 10);
  if (!v6
    || ((uint64_t v8 = *((void *)v5 + 8)) == 0 ? (v9 = (_DWORD *)(*((void *)v5 + 9) + 108)) : (v9 = (_DWORD *)(v8 + 92)),
        !*v9))
  {
    v14[0] = 3;
    v14[1] = llvm::object::object_category(v5);
    sub_1CD06481C();
  }
  v14[0] = 0;
  uint64_t result = llvm::object::COFFObjectFile::getRvaPtr(v5, v14, "export address", *(_DWORD *)(*(void *)this + 28), a3);
  if (!*a3)
  {
    unsigned int v11 = *(_DWORD *)(v14[0] + 4 * *((unsigned int *)this + 2));
    BOOL v13 = *v6 <= v11 && v11 < v6[1] + *v6;
    *a2 = v13;
    *a3 = 0;
  }
  return result;
}

uint64_t llvm::object::ExportDirectoryEntryRef::getForwardTo@<X0>(llvm::object::COFFObjectFile **this@<X0>, llvm::StringRef *a2@<X1>, void *a3@<X8>)
{
  __s = 0;
  uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this[2], (unint64_t *)&__s, "export address", *((_DWORD *)*this + 7), a3);
  if (!*a3)
  {
    unsigned int v7 = *(_DWORD *)&__s[4 * *((unsigned int *)this + 2)];
    *a3 = 0;
    __s = 0;
    uint64_t result = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(this[2], (unint64_t *)&__s, "export forward target", v7, a3);
    if (!*a3)
    {
      if (__s) {
        uint64_t result = strlen(__s);
      }
      else {
        uint64_t result = 0;
      }
      *(void *)a2 = __s;
      *((void *)a2 + 1) = result;
      *a3 = 0;
    }
  }
  return result;
}

BOOL llvm::object::ImportedSymbolRef::operator==(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2
      && *(void *)(a1 + 8) == *(void *)(a2 + 8)
      && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16);
}

uint64_t llvm::object::ImportedSymbolRef::moveNext(uint64_t this)
{
  return this;
}

uint64_t llvm::object::ImportedSymbolRef::getSymbolName@<X0>(uint64_t this@<X0>, llvm::StringRef *a2@<X1>, void *a3@<X8>)
{
  if (*(void *)this)
  {
    LODWORD(v5) = *(_DWORD *)(*(void *)this + 4 * *(unsigned int *)(this + 16));
    if ((v5 & 0x80000000) != 0) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v5 = *(void *)(*(void *)(this + 8) + 8 * *(unsigned int *)(this + 16));
    if (v5 < 0) {
      goto LABEL_10;
    }
  }
  unint64_t v6 = 0;
  this = (uint64_t)llvm::object::COFFObjectFile::getRvaPtr(*(llvm::object::COFFObjectFile **)(this + 24), &v6, "import symbol name", v5, a3);
  if (*a3) {
    return this;
  }
  if (v6 == -2) {
    this = 0;
  }
  else {
    this = strlen((const char *)(v6 + 2));
  }
  *(void *)a2 = v6 + 2;
  *((void *)a2 + 1) = this;
LABEL_10:
  *a3 = 0;
  return this;
}

uint64_t llvm::object::ImportedSymbolRef::isOrdinal@<X0>(uint64_t this@<X0>, BOOL *a2@<X1>, void *a3@<X8>)
{
  if (*(void *)this) {
    LODWORD(v3) = *(_DWORD *)(*(void *)this + 4 * *(unsigned int *)(this + 16)) >> 31;
  }
  else {
    BOOL v3 = *(void *)(*(void *)(this + 8) + 8 * *(unsigned int *)(this + 16)) >> 63;
  }
  *a2 = v3;
  *a3 = 0;
  return this;
}

uint64_t llvm::object::ImportedSymbolRef::getHintNameRVA@<X0>(uint64_t this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  if (*(void *)this) {
    LODWORD(v3) = *(_DWORD *)(*(void *)this + 4 * *(unsigned int *)(this + 16));
  }
  else {
    uint64_t v3 = *(void *)(*(void *)(this + 8) + 8 * *(unsigned int *)(this + 16));
  }
  *a2 = v3;
  *a3 = 0;
  return this;
}

llvm::object *llvm::object::ImportedSymbolRef::getOrdinal@<X0>(llvm::object *this@<X0>, unsigned __int16 *a2@<X1>, void *a3@<X8>)
{
  if (!*(void *)this)
  {
    uint64_t v5 = *(void *)(*((void *)this + 1) + 8 * *((unsigned int *)this + 4));
    if ((v5 & 0x8000000000000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    *a2 = v5;
    goto LABEL_7;
  }
  LODWORD(v5) = *(_DWORD *)(*(void *)this + 4 * *((unsigned int *)this + 4));
  if ((v5 & 0x80000000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  unint64_t v6 = 0;
  this = llvm::object::COFFObjectFile::getRvaPtr(*((llvm::object::COFFObjectFile **)this + 3), &v6, "import symbol ordinal", v5, a3);
  if (*a3) {
    return this;
  }
  *a2 = *(_WORD *)v6;
LABEL_7:
  *a3 = 0;
  return this;
}

BOOL llvm::object::BaseRelocRef::operator==(uint64_t a1, uint64_t a2)
{
  return *(void *)a1 == *(void *)a2 && *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

_DWORD *llvm::object::BaseRelocRef::moveNext(_DWORD *this)
{
  int v1 = this[2];
  unsigned int v2 = 2 * v1 + 10;
  if (v2 == *(_DWORD *)(*(void *)this + 4))
  {
    int v3 = 0;
    *(void *)this += v2;
  }
  else
  {
    int v3 = v1 + 1;
  }
  this[2] = v3;
  return this;
}

uint64_t llvm::object::BaseRelocRef::getType@<X0>(uint64_t this@<X0>, unsigned __int8 *a2@<X1>, void *a3@<X8>)
{
  *a2 = *(unsigned __int16 *)(*(void *)this + 2 * *(unsigned int *)(this + 8) + 8) >> 12;
  *a3 = 0;
  return this;
}

uint64_t llvm::object::BaseRelocRef::getRVA@<X0>(uint64_t this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  *a2 = **(_DWORD **)this + (*(_WORD *)(*(void *)this + 2 * *(unsigned int *)(this + 8) + 8) & 0xFFF);
  *a3 = 0;
  return this;
}

void *llvm::object::ResourceSectionRef::getDirStringAtOffset@<X0>(llvm::object::ResourceSectionRef *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v10 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef(v11, this);
  v11[6] = a2;
  unsigned __int16 v9 = 0;
  sub_1CD6C7F64((uint64_t)&v10, &v9, &v8);
  uint64_t v5 = v8;
  if ((void)v8 || (long long v8 = 0uLL, sub_1CCC21EB0((uint64_t)&v10, &v8, v9, &v7), (v5 = v7) != 0))
  {
    *(unsigned char *)(a3 + 16) |= 1u;
    *(void *)a3 = v5;
  }
  else
  {
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(_OWORD *)a3 = v8;
  }
  return sub_1CCC22DBC(&v10);
}

uint64_t sub_1CCC21EB0@<X0>(uint64_t a1@<X0>, void *a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  if (!a3)
  {
    uint64_t result = 0;
    *a2 = 0;
    a2[1] = 0;
LABEL_3:
    *a4 = 0;
    return result;
  }
  if ((a3 & 0x80000000) != 0) {
    operator new();
  }
  uint64_t result = llvm::BinaryStreamReader::readBytes(a1, 2 * a3, a4);
  if (!*a4)
  {
    uint64_t result = 0;
    *a2 = 0;
    a2[1] = a3;
    goto LABEL_3;
  }
  return result;
}

void *llvm::object::ResourceSectionRef::getEntryNameString@<X0>(llvm::object::ResourceSectionRef *a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  return llvm::object::ResourceSectionRef::getDirStringAtOffset(a1, *a2 & 0x7FFFFFFF, a3);
}

void *llvm::object::ResourceSectionRef::getTableAtOffset@<X0>(llvm::object::ResourceSectionRef *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int16 v9 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef(v10, this);
  v10[6] = a2;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  llvm::BinaryStreamReader::readBytes((uint64_t)&v9, 0x10u, &v8);
  uint64_t v5 = v8;
  if (v8)
  {
    char v6 = *(unsigned char *)(a3 + 8) | 1;
  }
  else
  {
    uint64_t v5 = v11;
    char v6 = *(unsigned char *)(a3 + 8) & 0xFE;
  }
  *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = v6;
  *(void *)a3 = v5;
  return sub_1CCC22DBC(&v9);
}

void *llvm::object::ResourceSectionRef::getTableEntryAtOffset@<X0>(llvm::object::ResourceSectionRef *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int16 v9 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef(v10, this);
  v10[6] = a2;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  llvm::BinaryStreamReader::readBytes((uint64_t)&v9, 8u, &v8);
  uint64_t v5 = v8;
  if (v8)
  {
    char v6 = *(unsigned char *)(a3 + 8) | 1;
  }
  else
  {
    uint64_t v5 = v11;
    char v6 = *(unsigned char *)(a3 + 8) & 0xFE;
  }
  *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = v6;
  *(void *)a3 = v5;
  return sub_1CCC22DBC(&v9);
}

void *llvm::object::ResourceSectionRef::getDataEntryAtOffset@<X0>(llvm::object::ResourceSectionRef *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned __int16 v9 = &unk_1F2632A58;
  llvm::BinaryStreamRef::BinaryStreamRef(v10, this);
  v10[6] = a2;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  llvm::BinaryStreamReader::readBytes((uint64_t)&v9, 0x10u, &v8);
  uint64_t v5 = v8;
  if (v8)
  {
    char v6 = *(unsigned char *)(a3 + 8) | 1;
  }
  else
  {
    uint64_t v5 = v11;
    char v6 = *(unsigned char *)(a3 + 8) & 0xFE;
  }
  *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = v6;
  *(void *)a3 = v5;
  return sub_1CCC22DBC(&v9);
}

void *llvm::object::ResourceSectionRef::getEntrySubDir@<X0>(llvm::object::ResourceSectionRef *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return llvm::object::ResourceSectionRef::getTableAtOffset(a1, *(_DWORD *)(a2 + 4) & 0x7FFFFFFF, a3);
}

void *llvm::object::ResourceSectionRef::getEntryData@<X0>(llvm::object::ResourceSectionRef *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  return llvm::object::ResourceSectionRef::getDataEntryAtOffset(a1, *(_DWORD *)(a2 + 4) & 0x7FFFFFFF, a3);
}

void *llvm::object::ResourceSectionRef::getBaseTable@<X0>(llvm::object::ResourceSectionRef *this@<X0>, uint64_t a2@<X8>)
{
  return llvm::object::ResourceSectionRef::getTableAtOffset(this, 0, a2);
}

void *llvm::object::ResourceSectionRef::getTableEntry@<X0>(llvm::object *a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  if (*(unsigned __int16 *)(a2 + 14) + *(unsigned __int16 *)(a2 + 12) <= a3)
  {
    llvm::object::object_category(a1);
    sub_1CD06481C();
  }
  unsigned int v4 = a2 + 8 * a3 - *((_DWORD *)a1 + 4) + 16;

  return llvm::object::ResourceSectionRef::getTableEntryAtOffset(a1, v4, a4);
}

void *llvm::object::ResourceSectionRef::load@<X0>(llvm::object::ResourceSectionRef *this@<X0>, const llvm::object::COFFObjectFile *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(const llvm::object::COFFObjectFile *))(*(void *)a2 + 344))(a2);
  uint64_t v8 = v7;
  unsigned __int16 v9 = (llvm::object *)(*(uint64_t (**)(const llvm::object::COFFObjectFile *))(*(void *)a2 + 352))(a2);
  *(void *)&long long v18 = v6;
  *((void *)&v18 + 1) = v8;
  if (v8 == v10 && v6 == (void)v9)
  {
LABEL_21:
    atomic_ullong v17 = llvm::object::object_category(v9);
    uint64_t v19 = 3;
    atomic_ullong v20 = v17;
    *(void *)&long long v18 = "no resource section found";
    sub_1CD06481C();
  }
  uint64_t v12 = v9;
  uint64_t v13 = v10;
  while (1)
  {
    uint64_t result = (*(void *(**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v8 + 136))(&v19, v8, v6);
    if (v21)
    {
      *a3 = v19;
      return result;
    }
    if (v20 == 8)
    {
      if (*(void *)v19 == 0x313024637273722ELL) {
        break;
      }
      goto LABEL_16;
    }
    if (v20 == 5 && *(_DWORD *)v19 == 1920168494 && *(unsigned char *)(v19 + 4) == 99) {
      break;
    }
LABEL_16:
    unsigned __int16 v9 = (llvm::object *)(*(uint64_t (**)(void, long long *))(**((void **)&v18 + 1) + 128))(*((void *)&v18 + 1), &v18);
    uint64_t v8 = *((void *)&v18 + 1);
    uint64_t v6 = v18;
    if (*((void *)&v18 + 1) == v13 && (void)v18 == (void)v12) {
      goto LABEL_21;
    }
  }
  uint64_t result = llvm::object::ResourceSectionRef::load((uint64_t)this, (uint64_t)a2, &v18, a3);
  if (v21)
  {
    uint64_t result = (void *)v19;
    uint64_t v19 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ResourceSectionRef::load@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X2>, void *a4@<X8>)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 4++*(_DWORD *)(this + 8) = a2;
  *(_OWORD *)(a1 + 32) = *a3;
  uint64_t result = (*(void *(**)(unsigned char *__return_ptr))(**(void **)(a1 + 40) + 168))(v38);
  uint64_t v7 = *(void *)v38;
  if ((v38[16] & 1) == 0)
  {
    uint64_t v8 = *(void *)&v38[8];
    *(_DWORD *)&v38[8] = 1;
    *(void *)&v38[16] = *(void *)v38;
    *(void *)(a1 + 24) = v8;
    *(_OWORD *)(a1 + ++*(_DWORD *)(this + 8) = *(_OWORD *)&v38[8];
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(void *)(a1 + 48);
    long long v11 = *(_OWORD *)(v10 + 32);
    *(_OWORD *)long long v38 = *(_OWORD *)(v10 + 16);
    *(_OWORD *)&v38[16] = v11;
    unint64_t v12 = sub_1CCC1FD74(v9, v38, *(void *)(v10 + 16));
    long long v13 = *(_OWORD *)(v10 + 32);
    v37[0] = *(_OWORD *)(v10 + 16);
    v37[1] = v13;
    unsigned int v14 = sub_1CCC1FE88(v9, v37, *(void *)(v10 + 16));
    uint64_t v15 = v14;
    unint64_t v16 = *(unsigned char **)(a1 + 56);
    if (v14 > (unint64_t)((uint64_t)(*(void *)(a1 + 72) - (void)v16) >> 3))
    {
      atomic_ullong v17 = *(unsigned char **)(a1 + 64);
      long long v18 = (char *)operator new(8 * v14);
      uint64_t v19 = &v18[(v17 - v16) & 0xFFFFFFFFFFFFFFF8];
      atomic_ullong v20 = v19;
      if (v17 != v16)
      {
        atomic_ullong v20 = &v18[(v17 - v16) & 0xFFFFFFFFFFFFFFF8];
        do
        {
          uint64_t v21 = *((void *)v17 - 1);
          v17 -= 8;
          *((void *)v20 - 1) = v21;
          v20 -= 8;
        }
        while (v17 != v16);
      }
      *(void *)(a1 + 56) = v20;
      *(void *)(a1 + 64) = v19;
      *(void *)(a1 + 72) = &v18[8 * v15];
      if (v16) {
        operator delete(v16);
      }
    }
    uint64_t v22 = *(unsigned int ***)(a1 + 64);
    if (v15)
    {
      unint64_t v23 = v12 + 10 * v15;
      do
      {
        unint64_t v24 = *(void *)(a1 + 72);
        if ((unint64_t)v22 >= v24)
        {
          long long v26 = *(void **)(a1 + 56);
          uint64_t v27 = v22 - (unsigned int **)v26;
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 61) {
            abort();
          }
          uint64_t v29 = v24 - (void)v26;
          if (v29 >> 2 > v28) {
            unint64_t v28 = v29 >> 2;
          }
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v28;
          }
          if (v30)
          {
            if (v30 >> 61) {
              sub_1CB833614();
            }
            unint64_t v31 = (char *)operator new(8 * v30);
          }
          else
          {
            unint64_t v31 = 0;
          }
          long long v32 = (unint64_t *)&v31[8 * v27];
          *long long v32 = v12;
          unsigned int v25 = (unsigned int **)(v32 + 1);
          if (v22 != v26)
          {
            do
            {
              unint64_t v33 = (unint64_t)*--v22;
              *--long long v32 = v33;
            }
            while (v22 != v26);
            uint64_t v22 = *(unsigned int ***)(a1 + 56);
          }
          *(void *)(a1 + 56) = v32;
          *(void *)(a1 + 64) = v25;
          *(void *)(a1 + 72) = &v31[8 * v30];
          if (v22) {
            operator delete(v22);
          }
        }
        else
        {
          *uint64_t v22 = (unsigned int *)v12;
          unsigned int v25 = v22 + 1;
        }
        *(void *)(a1 + 64) = v25;
        v12 += 10;
        uint64_t v22 = v25;
      }
      while (v12 != v23);
    }
    else
    {
      unsigned int v25 = *(unsigned int ***)(a1 + 64);
    }
    unint64_t v34 = *(void *)(a1 + 56);
    unint64_t v35 = 126 - 2 * __clz((uint64_t)((uint64_t)v25 - v34) >> 3);
    if (v25 == (unsigned int **)v34) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v35;
    }
    uint64_t result = (void *)sub_1CCC22E7C(v34, v25, v36, 1);
    uint64_t v7 = 0;
  }
  *a4 = v7;
  return result;
}

llvm::object *llvm::object::ResourceSectionRef::getContents@<X0>(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(llvm::object **)(a1 + 48);
  if (!v5)
  {
    uint64_t v75 = 3;
    unint64_t v76 = llvm::object::object_category(0);
    int64_t v73 = "no object provided";
    sub_1CD06481C();
  }
  uint64_t v7 = *(uint64_t **)(a1 + 56);
  uint64_t v8 = *(uint64_t **)(a1 + 64);
  if (v8 == v7) {
    goto LABEL_9;
  }
  unsigned int v9 = a2 - *(_DWORD *)(a1 + 16);
  unint64_t v10 = v8 - v7;
  while (1)
  {
    unint64_t v11 = v10 >> 1;
    unint64_t v12 = &v7[v10 >> 1];
    unsigned int v13 = *(_DWORD *)*v12;
    if (v13 >= v9) {
      break;
    }
    uint64_t v7 = v12 + 1;
    unint64_t v11 = v10 + ~v11;
LABEL_8:
    unint64_t v10 = v11;
    if (!v11) {
      goto LABEL_9;
    }
  }
  if (v13 > v9)
  {
    uint64_t v8 = &v7[v10 >> 1];
    goto LABEL_8;
  }
  if (v10 >= 2)
  {
    do
    {
      unint64_t v18 = v11 >> 1;
      uint64_t v19 = &v7[v11 >> 1];
      uint64_t v21 = (unsigned int *)*v19;
      atomic_ullong v20 = v19 + 1;
      v11 += ~(v11 >> 1);
      if (*v21 < v9) {
        uint64_t v7 = v20;
      }
      else {
        unint64_t v11 = v18;
      }
    }
    while (v11);
  }
  uint64_t v22 = v12 + 1;
  if (v8 != v12 + 1)
  {
    unint64_t v23 = v8 - (v12 + 1);
    uint64_t v8 = v22;
    do
    {
      unint64_t v24 = v23 >> 1;
      unsigned int v25 = (unsigned int **)&v8[v23 >> 1];
      uint64_t v27 = *v25;
      long long v26 = (uint64_t *)(v25 + 1);
      v23 += ~(v23 >> 1);
      if (*v27 > v9) {
        unint64_t v23 = v24;
      }
      else {
        uint64_t v8 = v26;
      }
    }
    while (v23);
  }
  if (v7 == v8)
  {
LABEL_9:
    unsigned int v14 = (llvm::object *)(*(uint64_t (**)(llvm::object *))(*(void *)v5 + 424))(v5);
    if (v14)
    {
      uint64_t v75 = 3;
      unint64_t v76 = llvm::object::object_category(v14);
      int64_t v73 = "no relocation found for DataRVA";
      sub_1CD06481C();
    }
    uint64_t v15 = *(void **)(a1 + 48);
    uint64_t v16 = v15[8];
    if (v16)
    {
      uint64_t v17 = *(unsigned int *)(v16 + 28);
    }
    else
    {
      uint64_t v32 = v15[9];
      if (v32) {
        uint64_t v17 = *(void *)(v32 + 24);
      }
      else {
        uint64_t v17 = 0;
      }
    }
    uint64_t v34 = *a2;
    unint64_t v35 = (char *)(*(uint64_t (**)(void *))(*v15 + 344))(v15);
    uint64_t v37 = v36;
    long long v38 = (llvm::object *)(*(uint64_t (**)(void *))(*v15 + 352))(v15);
    int64_t v73 = v35;
    uint64_t v74 = v37;
    if (v37 == v39 && v35 == (char *)v38)
    {
LABEL_50:
      atomic_ullong v47 = llvm::object::object_category(v38);
      uint64_t v75 = 3;
      unint64_t v76 = v47;
      int64_t v73 = "address not found in image";
      sub_1CD06481C();
    }
    long long v41 = (char *)v38;
    uint64_t v42 = v39;
    unint64_t v43 = v17 + v34;
    while (1)
    {
      if (v43 >= (*(uint64_t (**)(uint64_t, char *))(*(void *)v37 + 144))(v37, v35))
      {
        unint64_t v44 = v43 + a2[1];
        uint64_t v45 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v74 + 144))(v74, v73);
        if (v44 <= (*(uint64_t (**)(uint64_t, char *))(*(void *)v74 + 160))(v74, v73) + v45) {
          break;
        }
      }
      long long v38 = (llvm::object *)(*(uint64_t (**)(uint64_t, char **))(*(void *)v74 + 128))(v74, &v73);
      unint64_t v35 = v73;
      uint64_t v37 = v74;
      if (v74 == v42 && v73 == v41) {
        goto LABEL_50;
      }
    }
    uint64_t v48 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v74 + 144))(v74, v73);
    uint64_t result = (llvm::object *)(*(void *(**)(uint64_t *__return_ptr))(*(void *)v74 + 168))(&v75);
    std::string::size_type v50 = (char *)v75;
    if ((v77 & 1) == 0)
    {
      unint64_t v51 = v76;
      unint64_t v52 = v43 - v48;
      unint64_t v53 = v43 - v48 + a2[1];
      if (v76 < v43 - v48) {
        unint64_t v52 = v76;
      }
      if (v52 > v53) {
        unint64_t v53 = v52;
      }
      if (v76 >= v53) {
        unint64_t v51 = v53;
      }
      std::string::size_type v50 = (char *)(v75 + v52);
      *(unsigned char *)(a3 + 16) &= ~1u;
      *(void *)(a3 + ++*(_DWORD *)(this + 8) = v51 - v52;
      goto LABEL_51;
    }
LABEL_82:
    *(unsigned char *)(a3 + 16) |= 1u;
LABEL_51:
    *(void *)a3 = v50;
    return result;
  }
  unint64_t v28 = (unsigned __int16 *)*((void *)v5 + 6);
  uint64_t v29 = v28;
  if (!v28) {
    uint64_t v29 = (unsigned __int16 *)(*((void *)v5 + 7) + 6);
  }
  uint64_t v30 = *v7;
  int v31 = *v29;
  if (v31 > 34403)
  {
    if (v31 == 43620) {
      goto LABEL_60;
    }
    if (v31 != 34404) {
      goto LABEL_69;
    }
    int v33 = 3;
  }
  else if (v31 == 332)
  {
    int v33 = 7;
  }
  else
  {
    if (v31 != 452)
    {
LABEL_69:
      uint64_t v75 = 3;
      unint64_t v76 = llvm::object::object_category(v5);
      int64_t v73 = "unsupported architecture";
      sub_1CD06481C();
    }
LABEL_60:
    int v33 = 2;
  }
  if (v33 != *(unsigned __int16 *)(v30 + 8))
  {
    uint64_t v75 = 3;
    unint64_t v76 = llvm::object::object_category(v5);
    int64_t v73 = "unexpected relocation type";
    sub_1CD06481C();
  }
  unsigned int v54 = *(_DWORD *)(v30 + 4);
  uint64_t v55 = *((void *)v5 + 12);
  if (!v55 && !*((void *)v5 + 13)) {
    goto LABEL_76;
  }
  if (v28)
  {
    if ((__int16)v28[1] != -1)
    {
      size_t v56 = (unsigned int *)(v28 + 6);
      goto LABEL_71;
    }
    goto LABEL_76;
  }
  size_t v56 = (unsigned int *)(*((void *)v5 + 7) + 52);
LABEL_71:
  if (*v56 <= v54)
  {
LABEL_76:
    int v61 = &v75;
LABEL_77:
    *(void *)&v79.__val_ = llvm::object::object_category(v5);
    uint64_t result = (llvm::object *)llvm::errorCodeToError((llvm *)3, v79, v61);
    std::string::size_type v50 = (char *)*v61;
    goto LABEL_82;
  }
  if (!v55)
  {
    uint64_t v62 = *((void *)v5 + 13);
    if (v62)
    {
      uint64_t v57 = 0;
      uint64_t v59 = v62 + 20 * v54;
      int v60 = *(_DWORD *)(v59 + 12);
      goto LABEL_80;
    }
    int v61 = (uint64_t *)&v73;
    goto LABEL_77;
  }
  uint64_t v57 = v55 + 18 * v54;
  unsigned int v58 = *(unsigned __int16 *)(v57 + 12);
  uint64_t v59 = 0;
  if (v58 >> 8 <= 0xFE) {
    int v60 = *(unsigned __int16 *)(v57 + 12);
  }
  else {
    int v60 = (__int16)v58;
  }
LABEL_80:
  uint64_t result = llvm::object::COFFObjectFile::getSection(v5, v60, (uint64_t)&v73);
  if (v74)
  {
    std::string::size_type v50 = v73;
    goto LABEL_82;
  }
  int v63 = *a2;
  if (v55) {
    uint64_t v64 = v57;
  }
  else {
    uint64_t v64 = v59;
  }
  int v65 = *(_DWORD *)(v64 + 8);
  unint64_t v70 = 0;
  unint64_t v71 = 0;
  uint64_t result = llvm::object::COFFObjectFile::getSectionContents(*(llvm::object **)(a1 + 48), v73, &v70, &v75);
  std::string::size_type v50 = (char *)v75;
  if (v75) {
    goto LABEL_82;
  }
  uint64_t v66 = (v65 + v63);
  uint64_t v67 = a2[1];
  if (v67 + v66 > v71)
  {
    atomic_ullong v68 = llvm::object::object_category(result);
    uint64_t v75 = 3;
    unint64_t v76 = v68;
    uint64_t v72 = "data outside of section";
    sub_1CD06481C();
  }
  uint64_t v69 = v70 + v66;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v69;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v67;
  return result;
}

void *sub_1CCC22DBC(void *a1)
{
  *a1 = &unk_1F2632A58;
  unsigned int v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void sub_1CCC22E44(void *a1)
{
  sub_1CCC22DBC(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CCC22E7C(unint64_t result, unsigned int **a2, uint64_t a3, char a4)
{
  unsigned int v9 = (unsigned int **)result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unsigned int v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          uint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                long long v41 = *(a2 - 1);
                uint64_t v42 = *v10;
                if (*v41 < **v10)
                {
                  *unint64_t v10 = v41;
                  *(a2 - 1) = v42;
                }
                break;
              case 3:
                uint64_t result = (unint64_t)sub_1CCC235CC(v10, v10 + 1, a2 - 1);
                break;
              case 4:
                uint64_t result = (unint64_t)sub_1CCC23870(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5:
                unint64_t v43 = v10 + 1;
                unint64_t v44 = v10 + 2;
                uint64_t v45 = v10 + 3;
                uint64_t result = (unint64_t)sub_1CCC23870(v10, v10 + 1, v10 + 2, v10 + 3);
                int v46 = *(a2 - 1);
                atomic_ullong v47 = v10[3];
                if (*v46 < *v47)
                {
                  *uint64_t v45 = v46;
                  *(a2 - 1) = v47;
                  uint64_t v48 = *v45;
                  unint64_t v49 = *v44;
                  if (**v45 < **v44)
                  {
                    *unint64_t v44 = v48;
                    *uint64_t v45 = v49;
                    std::string::size_type v50 = *v43;
                    if (*v48 < **v43)
                    {
                      v10[1] = v48;
                      v10[2] = v50;
                      unint64_t v51 = *v10;
                      if (*v48 < **v10)
                      {
                        *unint64_t v10 = v48;
                        v10[1] = v51;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            unint64_t v52 = v10 + 1;
            BOOL v54 = v10 == a2 || v52 == a2;
            if (a4)
            {
              if (!v54)
              {
                uint64_t v55 = 8;
                size_t v56 = v10;
                do
                {
                  unsigned int v58 = *v56;
                  uint64_t v57 = v56[1];
                  size_t v56 = v52;
                  if (*v57 < *v58)
                  {
                    uint64_t v59 = v55;
                    do
                    {
                      *(unsigned int **)((char *)v10 + v59) = v58;
                      uint64_t v60 = v59 - 8;
                      if (v59 == 8)
                      {
                        int v61 = v10;
                        goto LABEL_83;
                      }
                      unsigned int v58 = *(unsigned int **)((char *)v10 + v59 - 16);
                      v59 -= 8;
                    }
                    while (*v57 < *v58);
                    int v61 = (unsigned int **)((char *)v10 + v60);
LABEL_83:
                    *int v61 = v57;
                  }
                  unint64_t v52 = v56 + 1;
                  v55 += 8;
                }
                while (v56 + 1 != a2);
              }
            }
            else if (!v54)
            {
              do
              {
                uint64_t v92 = *v9;
                long long v91 = v9[1];
                unsigned int v9 = v52;
                if (*v91 < *v92)
                {
                  do
                  {
                    std::string *v52 = v92;
                    uint64_t v92 = *(v52 - 2);
                    --v52;
                  }
                  while (*v91 < *v92);
                  std::string *v52 = v91;
                }
                unint64_t v52 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v62 = (unint64_t)(v12 - 2) >> 1;
              int64_t v63 = v62;
              do
              {
                int64_t v64 = v63;
                if (v62 >= v63)
                {
                  uint64_t v65 = (2 * v63) | 1;
                  uint64_t v66 = &v10[v65];
                  uint64_t v67 = *v66;
                  if (2 * v64 + 2 < v12)
                  {
                    unsigned int v68 = *v67;
                    uint64_t result = *v66[1];
                    if (*v67 <= result) {
                      unsigned int v68 = *v66[1];
                    }
                    if (*v67 < result)
                    {
                      uint64_t v67 = v66[1];
                      ++v66;
                      uint64_t v65 = 2 * v64 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v68 = *v67;
                  }
                  uint64_t v69 = &v10[v64];
                  unint64_t v70 = *v69;
                  if (v68 >= **v69)
                  {
                    do
                    {
                      unint64_t v71 = v66;
                      *uint64_t v69 = v67;
                      if (v62 < v65) {
                        break;
                      }
                      uint64_t v72 = (2 * v65) | 1;
                      uint64_t v66 = &v10[v72];
                      uint64_t v65 = 2 * v65 + 2;
                      uint64_t v67 = *v66;
                      if (v65 < v12)
                      {
                        unsigned int v74 = *v67;
                        unsigned int v73 = *v66[1];
                        if (*v67 <= v73) {
                          unsigned int v74 = *v66[1];
                        }
                        if (*v67 >= v73)
                        {
                          uint64_t v65 = v72;
                        }
                        else
                        {
                          uint64_t v67 = v66[1];
                          ++v66;
                        }
                      }
                      else
                      {
                        unsigned int v74 = *v67;
                        uint64_t v65 = v72;
                      }
                      uint64_t result = *v70;
                      uint64_t v69 = v71;
                    }
                    while (v74 >= result);
                    *unint64_t v71 = v70;
                  }
                }
                int64_t v63 = v64 - 1;
              }
              while (v64);
              do
              {
                uint64_t v75 = 0;
                unint64_t v76 = *v10;
                char v77 = v10;
                do
                {
                  uint64_t v78 = &v77[v75];
                  long long v81 = v78[1];
                  std::error_code v79 = v78 + 1;
                  int v80 = v81;
                  uint64_t v82 = (2 * v75) | 1;
                  uint64_t v83 = 2 * v75 + 2;
                  if (v83 < v12)
                  {
                    uint64_t result = *v80;
                    if (result < *v79[1])
                    {
                      int v80 = v79[1];
                      ++v79;
                      uint64_t v82 = v83;
                    }
                  }
                  *char v77 = v80;
                  char v77 = v79;
                  uint64_t v75 = v82;
                }
                while (v82 <= (uint64_t)((unint64_t)(v12 - 2) >> 1));
                if (v79 == --a2)
                {
                  *std::error_code v79 = v76;
                }
                else
                {
                  *std::error_code v79 = *a2;
                  *a2 = v76;
                  uint64_t v84 = (char *)v79 - (char *)v10 + 8;
                  if (v84 >= 9)
                  {
                    unint64_t v85 = (((unint64_t)v84 >> 3) - 2) >> 1;
                    long long v86 = &v10[v85];
                    unint64_t v87 = *v86;
                    long long v88 = *v79;
                    if (**v86 < **v79)
                    {
                      do
                      {
                        long long v89 = v86;
                        *std::error_code v79 = v87;
                        if (!v85) {
                          break;
                        }
                        unint64_t v85 = (v85 - 1) >> 1;
                        long long v86 = &v10[v85];
                        unint64_t v87 = *v86;
                        std::error_code v79 = v89;
                      }
                      while (**v86 < *v88);
                      *long long v89 = v88;
                    }
                  }
                }
              }
              while (v12-- > 2);
            }
            return result;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          unsigned int v14 = &v10[(unint64_t)v12 >> 1];
          if ((unint64_t)v11 >= 0x401)
          {
            sub_1CCC235CC(v9, &v9[(unint64_t)v12 >> 1], a2 - 1);
            sub_1CCC235CC(v9 + 1, v14 - 1, a2 - 2);
            sub_1CCC235CC(v9 + 2, &v9[v13 + 1], a2 - 3);
            uint64_t result = (unint64_t)sub_1CCC235CC(v14 - 1, v14, &v9[v13 + 1]);
            uint64_t v15 = *v9;
            *unsigned int v9 = *v14;
            *unsigned int v14 = v15;
          }
          else
          {
            uint64_t result = (unint64_t)sub_1CCC235CC(&v9[(unint64_t)v12 >> 1], v9, a2 - 1);
          }
          --a3;
          uint64_t v16 = *v9;
          unsigned int v17 = **v9;
          if ((a4 & 1) != 0 || **(v9 - 1) < v17) {
            break;
          }
          if (v17 >= **(a2 - 1))
          {
            uint64_t v32 = v9 + 1;
            do
            {
              unint64_t v10 = v32;
              if (v32 >= a2) {
                break;
              }
              ++v32;
            }
            while (v17 >= **v10);
          }
          else
          {
            unint64_t v10 = v9;
            do
            {
              int v31 = v10[1];
              ++v10;
            }
            while (v17 >= *v31);
          }
          int v33 = a2;
          if (v10 < a2)
          {
            int v33 = a2;
            do
              uint64_t v34 = *--v33;
            while (v17 < *v34);
          }
          if (v10 < v33)
          {
            unint64_t v35 = *v10;
            uint64_t v36 = *v33;
            do
            {
              *unint64_t v10 = v36;
              *int v33 = v35;
              unsigned int v37 = *v16;
              do
              {
                long long v38 = v10[1];
                ++v10;
                unint64_t v35 = v38;
              }
              while (v37 >= *v38);
              do
              {
                uint64_t v39 = *--v33;
                uint64_t v36 = v39;
              }
              while (v37 < *v39);
            }
            while (v10 < v33);
          }
          long long v40 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            *unsigned int v9 = *v40;
          }
          a4 = 0;
          const char *v40 = v16;
        }
        uint64_t v18 = 0;
        do
          uint64_t v19 = v9[++v18];
        while (*v19 < v17);
        atomic_ullong v20 = &v9[v18];
        uint64_t v21 = a2;
        if (v18 == 1)
        {
          do
          {
            if (v20 >= v21) {
              break;
            }
            unint64_t v23 = *--v21;
          }
          while (*v23 >= v17);
        }
        else
        {
          do
            uint64_t v22 = *--v21;
          while (*v22 >= v17);
        }
        if (v20 >= v21)
        {
          unint64_t v10 = &v9[v18];
        }
        else
        {
          unint64_t v24 = *v21;
          unint64_t v10 = v20;
          unsigned int v25 = v21;
          do
          {
            *unint64_t v10 = v24;
            *unsigned int v25 = v19;
            unsigned int v26 = *v16;
            do
            {
              uint64_t v27 = v10[1];
              ++v10;
              uint64_t v19 = v27;
            }
            while (*v27 < v26);
            do
            {
              unint64_t v28 = *--v25;
              unint64_t v24 = v28;
            }
            while (*v28 >= v26);
          }
          while (v10 < v25);
        }
        uint64_t v29 = v10 - 1;
        if (v10 - 1 != v9) {
          *unsigned int v9 = *v29;
        }
        unsigned __int16 *v29 = v16;
        if (v20 >= v21) {
          break;
        }
LABEL_32:
        uint64_t result = sub_1CCC22E7C(v9, v10 - 1, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v30 = sub_1CCC23658(v9, v10 - 1);
      uint64_t result = sub_1CCC23658(v10, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_32;
      }
    }
    a2 = v10 - 1;
    if (!v30) {
      continue;
    }
    return result;
  }
}

unsigned int **sub_1CCC235CC(unsigned int **result, unsigned int **a2, unsigned int **a3)
{
  int v3 = *a2;
  BOOL v4 = *result;
  unsigned int v5 = **a2;
  uint64_t v6 = *a3;
  unsigned int v7 = **a3;
  if (v5 >= **result)
  {
    if (v7 < v5)
    {
      *a2 = v6;
      *a3 = v3;
      uint64_t v8 = *result;
      if (**a2 < **result)
      {
        *uint64_t result = *a2;
        *a2 = v8;
      }
    }
  }
  else
  {
    if (v7 >= v5)
    {
      *uint64_t result = v3;
      *a2 = v4;
      if (**a3 >= *v4) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *uint64_t result = v6;
    }
    *a3 = v4;
  }
  return result;
}

BOOL sub_1CCC23658(unsigned int **a1, unsigned int **a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      unsigned int v7 = *a1;
      if (*v6 < **a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      sub_1CCC235CC(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_1CCC23870(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      unsigned int v17 = a1 + 1;
      uint64_t v18 = a1 + 2;
      uint64_t v19 = a1 + 3;
      sub_1CCC23870(a1, a1 + 1, a1 + 2, a1 + 3);
      atomic_ullong v20 = *(a2 - 1);
      uint64_t v21 = a1[3];
      if (*v20 < *v21)
      {
        *uint64_t v19 = v20;
        *(a2 - 1) = v21;
        uint64_t v22 = *v19;
        unint64_t v23 = *v18;
        if (**v19 < **v18)
        {
          *uint64_t v18 = v22;
          *uint64_t v19 = v23;
          unint64_t v24 = *v17;
          if (*v22 < **v17)
          {
            a1[1] = v22;
            a1[2] = v24;
            unsigned int v25 = *a1;
            if (*v22 < **a1)
            {
              *a1 = v22;
              a1[1] = v25;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v8 = a1 + 2;
      sub_1CCC235CC(a1, a1 + 1, a1 + 2);
      unsigned int v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    unint64_t v13 = *v8;
    if (**v9 < **v8)
    {
      uint64_t v14 = v11;
      while (1)
      {
        *(unsigned int **)((char *)a1 + v14) = v13;
        uint64_t v15 = v14 - 8;
        if (v14 == 8) {
          break;
        }
        unint64_t v13 = *(unsigned int **)((char *)a1 + v14 - 16);
        v14 -= 8;
        if (*v12 >= *v13)
        {
          uint64_t v16 = (unsigned int **)((char *)a1 + v15);
          goto LABEL_13;
        }
      }
      uint64_t v16 = a1;
LABEL_13:
      *uint64_t v16 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    uint64_t v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

unsigned int **sub_1CCC23870(unsigned int **a1, unsigned int **a2, unsigned int **a3, unsigned int **a4)
{
  BOOL result = sub_1CCC235CC(a1, a2, a3);
  unsigned int v9 = *a3;
  if (**a4 < **a3)
  {
    *a3 = *a4;
    *a4 = v9;
    int v10 = *a2;
    if (**a3 < **a2)
    {
      *a2 = *a3;
      *a3 = v10;
      uint64_t v11 = *a1;
      if (**a2 < **a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

void llvm::object::Decompressor::create()
{
  v0 = "zlib is not available";
  __int16 v1 = 259;
  operator new();
}

void *llvm::object::Decompressor::Decompressor(void *result, uint64_t a2, uint64_t a3)
{
  *BOOL result = a2;
  result[1] = a3;
  result[2] = 0;
  return result;
}

{
  *BOOL result = a2;
  result[1] = a3;
  result[2] = 0;
  return result;
}

BOOL llvm::object::Decompressor::isGnuStyle(_DWORD *a1, unint64_t a2)
{
  if (a2 < 7) {
    return 0;
  }
  return *a1 == 1701083694 && *(_DWORD *)((char *)a1 + 3) == 1735746149;
}

void *llvm::object::Decompressor::consumeCompressedGnuHeader@<X0>(void *this@<X0>, void *a2@<X8>)
{
  unint64_t v3 = this[1];
  unint64_t v4 = v3 - 4;
  if (v3 < 4 || (unsigned int v5 = (_DWORD *)*this, *(_DWORD *)*this != 1112099930))
  {
    uint64_t v6 = "corrupted compressed section header";
    goto LABEL_4;
  }
  *this = v5 + 1;
  this[1] = v4;
  if (v4 <= 7)
  {
    uint64_t v6 = "corrupted uncompressed section size";
LABEL_4:
    uint64_t v8 = v6;
    __int16 v9 = 259;
    operator new();
  }
  unint64_t v7 = bswap64(*(void *)(v5 + 1));
  *this = v5 + 3;
  this[1] = v3 - 12;
  this[2] = v7;
  *a2 = 0;
  return this;
}

unint64_t llvm::object::Decompressor::consumeCompressedZLibHeader@<X0>(llvm::object::Decompressor *this@<X0>, int a2@<W1>, char a3@<W2>, void *a4@<X8>)
{
  if (a2) {
    unint64_t v5 = 24;
  }
  else {
    unint64_t v5 = 12;
  }
  unint64_t v6 = *((void *)this + 1);
  if (v6 < v5)
  {
    unint64_t v7 = "corrupted compressed section header";
    goto LABEL_6;
  }
  v15[0] = *(void *)this;
  v15[1] = v6;
  char v16 = a3;
  char v17 = 0;
  unint64_t v14 = 0;
  if (sub_1CD8337FC((uint64_t)v15, &v14, 0) != 1)
  {
    unint64_t v7 = "unsupported compression type";
LABEL_6:
    uint64_t v18 = v7;
    __int16 v19 = 259;
    operator new();
  }
  if (a2)
  {
    v14 += 4;
    int v10 = 8;
  }
  else
  {
    int v10 = 4;
  }
  unint64_t result = llvm::DataExtractor::getUnsigned(v15, &v14, v10, 0);
  unint64_t v12 = *((void *)this + 1);
  if (v12 >= v5) {
    unint64_t v13 = v5;
  }
  else {
    unint64_t v13 = *((void *)this + 1);
  }
  *(void *)this += v13;
  *((void *)this + 1) = v12 - v13;
  *((void *)this + 2) = result;
  *a4 = 0;
  return result;
}

uint64_t llvm::object::Decompressor::isCompressed(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), *(void *)a1)) {
    return 1;
  }
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 8) + 136))(v7);
  if (v8)
  {
    unint64_t v6 = (void *)v7[0];
    v7[0] = 0;
    sub_1CD4515D0(&v6);
    if (v6) {
      (*(void (**)(void *))(*v6 + 8))(v6);
    }
  }
  else if (v7[1] >= 7uLL)
  {
    BOOL v2 = *(_DWORD *)v7[0] == 1701083694 && *(_DWORD *)(v7[0] + 3) == 1735746149;
    goto LABEL_12;
  }
  BOOL v2 = 0;
LABEL_12:
  if (v8)
  {
    uint64_t v4 = v7[0];
    v7[0] = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  return v2;
}

BOOL llvm::object::Decompressor::isCompressedELFSection(__int16 a1, _DWORD *a2, unint64_t a3)
{
  if ((a1 & 0x800) != 0) {
    return 1;
  }
  if (a3 < 7) {
    return 0;
  }
  return *a2 == 1701083694 && *(_DWORD *)((char *)a2 + 3) == 1735746149;
}

uint64_t llvm::object::getELFRelativeRelocationType(llvm::object *this)
{
  int v1 = (int)this;
  uint64_t result = 8;
  if (v1 > 61)
  {
    if (v1 > 194)
    {
      if (v1 > 250)
      {
        if (v1 == 251) {
          return 17;
        }
        if (v1 == 252) {
          return 9;
        }
        return 0;
      }
      if (v1 != 195)
      {
        if (v1 == 243) {
          return 3;
        }
        return 0;
      }
    }
    else
    {
      if (v1 > 163)
      {
        if (v1 == 164) {
          return 35;
        }
        if (v1 == 183) {
          return 1027;
        }
        return 0;
      }
      if (v1 == 62) {
        return result;
      }
      if (v1 != 93) {
        return 0;
      }
    }
    return 56;
  }
  if (v1 > 20)
  {
    if (v1 > 39)
    {
      if (v1 == 40) {
        return 23;
      }
      if (v1 != 43) {
        return 0;
      }
    }
    else if (v1 != 21)
    {
      if (v1 == 22) {
        return 12;
      }
      return 0;
    }
    return 22;
  }
  if (v1 <= 5)
  {
    if (v1 != 2)
    {
      if (v1 == 3) {
        return result;
      }
      return 0;
    }
    return 22;
  }
  if (v1 != 6)
  {
    if (v1 != 18) {
      return 0;
    }
    return 22;
  }
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::base(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::end(void *a1)
{
  return *a1 + a1[1];
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getBufSize(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::ELFFile(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getHeader(uint64_t a1)
{
  return *(void *)a1;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getVersionDefinitions(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getLinkAsStrtab(a1, a2, (uint64_t)v75);
  if (v76)
  {
    uint64_t v6 = v75[0];
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
    return;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionContents(a1, a2, (uint64_t)v73);
  if (v74)
  {
    sub_1CCC255A8(&v66, a1, a2);
    unint64_t v28 = std::string::insert(&v66, 0, "cannot read content of ");
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v67.__r_.__value_.__r.__words[2] = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    BOOL v30 = std::string::append(&v67, ": ");
    uint64_t v31 = 0;
    std::string::size_type v32 = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v32;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    if (v74)
    {
      uint64_t v31 = v73[0];
      v73[0] = 0;
    }
    uint64_t v64 = v31;
    sub_1CD4FB504(&v64, &v65);
    if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v33 = &v65;
    }
    else {
      int v33 = (std::string *)v65.__r_.__value_.__r.__words[0];
    }
    if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v65.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v65.__r_.__value_.__l.__size_;
    }
    unint64_t v35 = std::string::append(&__p, (const std::string::value_type *)v33, size);
    std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)unint64_t v70 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    *(void *)&v70[16] = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    LOWORD(v69) = 260;
    v68[0] = v70;
    operator new();
  }
  unint64_t v7 = (unsigned __int16 *)v73[0];
  unint64_t v62 = v73[0] + v73[1];
  uint64_t v63 = v73[0];
  v68[0] = &v62;
  v68[1] = a1;
  v68[2] = a2;
  v68[3] = &v63;
  uint64_t v69 = v75;
  memset(&v67, 0, sizeof(v67));
  if (!*(_DWORD *)(a2 + 28))
  {
    std::string::size_type v22 = 0;
    char v8 = *(unsigned char *)(a3 + 24);
    long long v21 = 0uLL;
    goto LABEL_34;
  }
  char v8 = *(unsigned char *)(a3 + 24);
  unsigned int v9 = 1;
  while (1)
  {
    if ((unint64_t)(v7 + 10) > v62)
    {
      sub_1CCC255A8(&v59, a1, a2);
      unsigned int v37 = std::string::insert(&v59, 0, "invalid ");
      std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v65.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      v65.__r_.__value_.__r.__words[2] = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      uint64_t v39 = std::string::append(&v65, ": version definition ");
      std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v66;
      __p.__r_.__value_.__r.__words[2] = v9;
      __int16 v61 = 2052;
      long long v41 = " goes past the end of the section";
      goto LABEL_49;
    }
    if ((v7 & 3) != 0)
    {
      sub_1CCC255A8(&v65, a1, a2);
      uint64_t v42 = std::string::insert(&v65, 0, "invalid ");
      std::string::size_type v43 = v42->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v43;
      v42->__r_.__value_.__l.__size_ = 0;
      v42->__r_.__value_.__r.__words[2] = 0;
      v42->__r_.__value_.__r.__words[0] = 0;
      unint64_t v44 = std::string::append(&v66, ": found a misaligned version definition entry at offset 0x");
      std::string::size_type v45 = v44->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v45;
      v44->__r_.__value_.__l.__size_ = 0;
      v44->__r_.__value_.__r.__words[2] = 0;
      v44->__r_.__value_.__r.__words[0] = 0;
      v59.__r_.__value_.__r.__words[0] = (std::string::size_type)v7 - v63;
      uint64_t v27 = &v59;
LABEL_36:
      *(void *)unint64_t v70 = &__p;
      *(void *)&v70[16] = v27;
      __int16 v72 = 3588;
      operator new();
    }
    std::string::size_type v10 = *v7;
    if (v10 != 1)
    {
      sub_1CCC255A8(&v59, a1, a2);
      int v46 = std::string::insert(&v59, 0, "unable to dump ");
      std::string::size_type v47 = v46->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v65.__r_.__value_.__l.__data_ = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
      v65.__r_.__value_.__r.__words[2] = v47;
      v46->__r_.__value_.__l.__size_ = 0;
      v46->__r_.__value_.__r.__words[2] = 0;
      v46->__r_.__value_.__r.__words[0] = 0;
      uint64_t v48 = std::string::append(&v65, ": version ");
      std::string::size_type v49 = v48->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v49;
      v48->__r_.__value_.__l.__size_ = 0;
      v48->__r_.__value_.__r.__words[2] = 0;
      v48->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v66;
      __p.__r_.__value_.__r.__words[2] = v10;
      __int16 v61 = 2052;
      long long v41 = " is not yet supported";
LABEL_49:
      *(void *)unint64_t v70 = &__p;
      *(void *)&v70[16] = v41;
      __int16 v72 = 770;
      operator new();
    }
    uint64_t v11 = sub_1CCC25678((uint64_t)&v67, v67.__r_.__value_.__l.__size_);
    *(_DWORD *)uint64_t v11 = v7 - v63;
    *((_DWORD *)v11 + 1) = *v7;
    *((_DWORD *)v11 + 2) = v7[1];
    *((_DWORD *)v11 + 3) = v7[2];
    *((_DWORD *)v11 + 4) = v7[3];
    *((_DWORD *)v11 + 5) = *((_DWORD *)v7 + 2);
    v59.__r_.__value_.__r.__words[0] = (std::string::size_type)v7 + *((unsigned int *)v7 + 3);
    if (v7[3]) {
      break;
    }
LABEL_31:
    unint64_t v7 = (unsigned __int16 *)((char *)v7 + *((unsigned int *)v7 + 4));
    if (++v9 > *(_DWORD *)(a2 + 28))
    {
      long long v21 = *(_OWORD *)&v67.__r_.__value_.__l.__data_;
      std::string::size_type v22 = v67.__r_.__value_.__r.__words[2];
LABEL_34:
      *(unsigned char *)(a3 + 24) = v8 & 0xFE;
      *(_OWORD *)a3 = v21;
      *(void *)(a3 + ++*(_DWORD *)(this + 16) = v22;
      goto LABEL_58;
    }
  }
  unint64_t v12 = v11;
  int v13 = 0;
  size_t v56 = (unint64_t *)(v11 + 3);
  uint64_t v57 = (std::string *)((char *)v11 + 24);
  while (1)
  {
    if ((v59.__r_.__value_.__s.__data_[0] & 3) != 0)
    {
      sub_1CCC255A8(&v65, a1, a2);
      unint64_t v23 = std::string::insert(&v65, 0, "invalid ");
      std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      unsigned int v25 = std::string::append(&v66, ": found a misaligned auxiliary entry at offset 0x");
      std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      std::string::size_type v58 = v59.__r_.__value_.__r.__words[0] - v63;
      uint64_t v27 = (std::string *)&v58;
      goto LABEL_36;
    }
    sub_1CCC258BC((uint64_t)v68, (unsigned int **)&v59, v9, (uint64_t)v70);
    char v14 = v72;
    if (v72)
    {
      uint64_t v18 = *(void *)v70;
      *(void *)unint64_t v70 = 0;
      v8 |= 1u;
      *(unsigned char *)(a3 + 24) = v8;
      *(void *)a3 = v18;
    }
    else if (v13)
    {
      unint64_t v15 = *((void *)v12 + 7);
      if (v15 >= *((void *)v12 + 8))
      {
        __int16 v19 = sub_1CCC3F408(v56, (uint64_t)v70);
      }
      else
      {
        *(_DWORD *)unint64_t v15 = *(_DWORD *)v70;
        char v16 = (_OWORD *)(v15 + 8);
        if (SHIBYTE(v71) < 0)
        {
          sub_1CB8BDF7C((uint64_t)v16, *(const void **)&v70[8], *(unint64_t *)&v70[16]);
        }
        else
        {
          long long v17 = *(_OWORD *)&v70[8];
          *(void *)(v15 + 24) = v71;
          *char v16 = v17;
        }
        __int16 v19 = (char *)(v15 + 32);
      }
      *((void *)v12 + 7) = v19;
    }
    else
    {
      std::string::operator=(v57, (const std::string *)&v70[8]);
    }
    if (v72)
    {
      uint64_t v20 = *(void *)v70;
      *(void *)unint64_t v70 = 0;
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
      }
    }
    else if (SHIBYTE(v71) < 0)
    {
      operator delete(*(void **)&v70[8]);
    }
    if (v14) {
      break;
    }
    if (++v13 >= v7[3]) {
      goto LABEL_31;
    }
  }
  std::string::size_type v50 = v67.__r_.__value_.__r.__words[0];
  if (v67.__r_.__value_.__r.__words[0])
  {
    unint64_t v51 = (void *)v67.__r_.__value_.__r.__words[0];
    if (v67.__r_.__value_.__l.__size_ != v67.__r_.__value_.__r.__words[0])
    {
      std::string::size_type v52 = v67.__r_.__value_.__l.__size_ - 24;
      do
      {
        *(void *)unint64_t v70 = v52;
        sub_1CC1CB288((void ***)v70);
        if (*(char *)(v52 - 1) < 0) {
          operator delete(*(void **)(v52 - 24));
        }
        std::string::size_type v53 = v52 - 48;
        v52 -= 72;
      }
      while (v53 != v50);
      unint64_t v51 = (void *)v67.__r_.__value_.__r.__words[0];
    }
    v67.__r_.__value_.__l.__size_ = v50;
    operator delete(v51);
  }
LABEL_58:
  if (v74)
  {
    uint64_t v54 = v73[0];
    v73[0] = 0;
    if (v54) {
      (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
    }
  }
  if (v76)
  {
    uint64_t v55 = v75[0];
    v75[0] = 0;
    if (v55) {
      (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
    }
  }
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getLinkAsStrtab(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSection(a1, *(_DWORD *)(a2 + 24), (uint64_t)&v36);
  if (v37)
  {
    sub_1CCC255A8(&v29, a1, a2);
    uint64_t v6 = std::string::insert(&v29, 0, "invalid section linked to ");
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    char v8 = std::string::append(&v30, ": ");
    uint64_t v9 = 0;
    std::string::size_type v10 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v10;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if (v37)
    {
      uint64_t v9 = v36;
      uint64_t v36 = 0;
    }
    uint64_t v27 = v9;
    sub_1CD4FB504(&v27, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    int v13 = std::string::append(&v31, (const std::string::value_type *)p_p, size);
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    long long v34 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    std::string::size_type v35 = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    std::string::size_type v32 = (std::string *)&v34;
    operator new();
  }
  std::string::size_type v32 = (std::string *)sub_1CCC27114;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getStringTable(a1, v36, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v32, (uint64_t)&v34);
  if (v35)
  {
    sub_1CCC255A8(&__p, a1, a2);
    char v16 = std::string::insert(&__p, 0, "invalid string table linked to ");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    uint64_t v18 = std::string::append(&v29, ": ");
    uint64_t v19 = 0;
    std::string::size_type v20 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v20;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if (v35)
    {
      uint64_t v19 = v34;
      *(void *)&long long v34 = 0;
    }
    uint64_t v25 = v19;
    sub_1CD4FB504(&v25, &v26);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v21 = &v26;
    }
    else {
      long long v21 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v22 = *((unsigned char *)&v26.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type v22 = v26.__r_.__value_.__l.__size_;
    }
    unint64_t v23 = std::string::append(&v30, (const std::string::value_type *)v21, v22);
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    std::string::size_type v32 = &v31;
    operator new();
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(_OWORD *)a3 = v34;
  if (v37)
  {
    uint64_t v15 = v36;
    uint64_t v36 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
}

void sub_1CCC255A8(void *a1, void *a2, uint64_t a3)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections(a2, (uint64_t)v13);
  uint64_t v6 = -858993459 * ((unint64_t)(a3 - v13[0]) >> 3);
  ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)*(unsigned __int16 *)(*a2 + 18), *(_DWORD *)(a3 + 4));
  __int16 v10 = 773;
  v9[0] = ELFSectionTypeName;
  v9[1] = v8;
  _OWORD v9[2] = " section with index ";
  v11[0] = v9;
  v11[2] = v6;
  __int16 v12 = 2050;
  llvm::Twine::str((llvm::Twine *)v11, a1);
}

long long *sub_1CCC25678(uint64_t a1, uint64_t a2)
{
  BOOL v2 = (long long *)a2;
  unint64_t v5 = *(long long **)a1;
  unint64_t v4 = *(void *)(a1 + 8);
  unint64_t v6 = 0x8E38E38E38E38E39 * ((a2 - *(void *)a1) >> 3);
  unint64_t v7 = *(void *)(a1 + 16);
  if (v4 >= v7)
  {
    unint64_t v12 = 0x8E38E38E38E38E39 * ((uint64_t)(v4 - (void)v5) >> 3) + 1;
    if (v12 > 0x38E38E38E38E38ELL) {
      abort();
    }
    unint64_t v13 = 0x8E38E38E38E38E39 * ((uint64_t)(v7 - (void)v5) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x1C71C71C71C71C7) {
      unint64_t v14 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v14 = v12;
    }
    *(void *)&v20[1] = a1 + 16;
    if (v14)
    {
      if (v14 > 0x38E38E38E38E38ELL) {
        sub_1CB833614();
      }
      uint64_t v15 = (char *)operator new(72 * v14);
    }
    else
    {
      uint64_t v15 = 0;
    }
    __p[0] = v15;
    __p[1] = &v15[72 * v6];
    *(void **)&v20[0] = __p[1];
    *((void *)&v20[0] + 1) = &v15[72 * v14];
    sub_1CCC3EFF8((long long **)__p);
    BOOL v2 = sub_1CCC3F26C((long long **)a1, __p, v2);
    char v16 = __p[1];
    while (1)
    {
      uint64_t v17 = *(void *)&v20[0];
      if (*(void **)&v20[0] == v16) {
        break;
      }
      *(void *)&v20[0] -= 72;
      std::string::size_type v24 = (void **)(v17 - 24);
      sub_1CC1CB288(&v24);
      if (*(char *)(v17 - 25) < 0) {
        operator delete(*(void **)(v17 - 48));
      }
    }
    uint64_t v11 = __p[0];
    if (__p[0]) {
      goto LABEL_23;
    }
  }
  else if (a2 == v4)
  {
    *(void *)(a2 + 64) = 0;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 4++*(_DWORD *)(this + 8) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + ++*(_DWORD *)(this + 16) = 0u;
    *(void *)(a1 + ++*(_DWORD *)(this + 8) = a2 + 72;
  }
  else
  {
    *(_OWORD *)std::string __p = 0u;
    memset(v20, 0, sizeof(v20));
    long long v21 = 0u;
    uint64_t v22 = 0;
    uint64_t v23 = a1 + 16;
    sub_1CCC3EEA8(a1, a2, v4, a2 + 72);
    *(void *)BOOL v2 = 0;
    *((void *)v2 + 1) = 0;
    *((void *)v2 + 2) = 0;
    uint64_t v8 = (void **)v5 + 9 * v6 + 3;
    if (*((char *)v2 + 47) < 0) {
      operator delete(*v8);
    }
    long long v9 = *(_OWORD *)((char *)v20 + 8);
    *((void *)v5 + 9 * v6 + 5) = *((void *)&v20[1] + 1);
    *(_OWORD *)uint64_t v8 = v9;
    HIBYTE(v20[1]) = 0;
    BYTE8(v20[0]) = 0;
    __int16 v10 = (void **)v5 + 9 * v6;
    sub_1CCC3F398(v10 + 6);
    v10[6] = 0;
    void v10[7] = 0;
    v10[8] = 0;
    long long v21 = 0uLL;
    uint64_t v22 = 0;
    std::string::size_type v24 = (void **)&v21;
    sub_1CC1CB288(&v24);
    if (SHIBYTE(v20[1]) < 0)
    {
      uint64_t v11 = (void *)*((void *)&v20[0] + 1);
LABEL_23:
      operator delete(v11);
    }
  }
  return v2;
}

void sub_1CCC258BC(uint64_t a1@<X0>, unsigned int **a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a2;
  if ((unint64_t)(*a2 + 2) > **(void **)a1)
  {
    sub_1CCC255A8(&v24, *(void **)(a1 + 8), *(void *)(a1 + 16));
    unint64_t v7 = std::string::insert(&v24, 0, "invalid ");
    std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    long long v9 = std::string::append(&v32, ": version definition ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    *(void *)&__p[16] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    v26[0] = __p;
    unint64_t v27 = a3;
    __int16 v28 = 2052;
    std::string __dst = v26;
    *((void *)&v30 + 1) = " refers to an auxiliary entry that goes past the end of the section";
    __int16 v31 = 770;
    operator new();
  }
  uint64_t v11 = (unsigned int *)((char *)v5 + v5[1]);
  *a2 = v11;
  unint64_t v12 = *(uint64_t **)(a1 + 32);
  int v13 = **(_DWORD **)(a1 + 24);
  unint64_t v14 = *v5;
  unint64_t v15 = v12[1];
  size_t v16 = v15 - v14;
  if (v15 >= v14)
  {
    if (v16 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v19 = *v12;
    if (v16 >= 0x17)
    {
      uint64_t v21 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v21 = v16 | 7;
      }
      uint64_t v22 = v21 + 1;
      p_dst = (void **)operator new(v21 + 1);
      *(void *)&long long v30 = v16;
      *((void *)&v30 + 1) = v22 | 0x8000000000000000;
      std::string __dst = p_dst;
    }
    else
    {
      HIBYTE(v30) = v15 - v14;
      p_dst = &__dst;
      if (v15 == v14) {
        goto LABEL_13;
      }
    }
    memmove(p_dst, (const void *)(v19 + v14), v16);
LABEL_13:
    *((unsigned char *)p_dst + v++*(_DWORD *)(this + 16) = 0;
    uint64_t v17 = __dst;
    v32.__r_.__value_.__r.__words[0] = v30;
    *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7) = *(void *)((char *)&v30 + 7);
    char v18 = HIBYTE(v30);
    goto LABEL_14;
  }
  v26[0] = "<invalid vda_name: ";
  unint64_t v27 = v14;
  __int16 v28 = 2051;
  std::string __dst = v26;
  *((void *)&v30 + 1) = ">";
  __int16 v31 = 770;
  llvm::Twine::str((llvm::Twine *)&__dst, __p);
  uint64_t v17 = *(void **)__p;
  v32.__r_.__value_.__r.__words[0] = *(void *)&__p[8];
  *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7) = *(void *)&__p[15];
  char v18 = __p[23];
LABEL_14:
  *(unsigned char *)(a4 + 32) &= ~1u;
  *(_DWORD *)a4 = v11 - v13;
  std::string::size_type v23 = v32.__r_.__value_.__r.__words[0];
  *(void *)(a4 + ++*(_DWORD *)(this + 8) = v17;
  *(void *)(a4 + ++*(_DWORD *)(this + 16) = v23;
  *(void *)(a4 + 23) = *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7);
  *(unsigned char *)(a4 + 31) = v18;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getVersionDependencies(void *a1@<X0>, uint64_t a2@<X1>, void (*a3)(unsigned __int16 **__return_ptr, uint64_t, long long *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = a2;
  std::string::size_type v8 = a1;
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getLinkAsStrtab(a1, a2, (uint64_t)v95);
  if (v96)
  {
    uint64_t v39 = v95[0];
    v95[0] = 0;
    uint64_t v88 = v39;
    sub_1CD4FB504(&v88, &__p);
    __int16 v91 = 260;
    *(void *)&long long __dst = &__p;
    a3(&v92, a4, &__dst);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v88) {
      (*(void (**)(uint64_t))(*(void *)v88 + 8))(v88);
    }
    std::string::size_type v40 = v92;
    if (v92)
    {
      *(unsigned char *)(a5 + 24) |= 1u;
      *(void *)a5 = v40;
      goto LABEL_67;
    }
    uint64_t v80 = 0;
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v10 = v95[1];
    uint64_t v80 = v95[0];
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionContents(v8, v7, (uint64_t)&v92);
  if (v94)
  {
    sub_1CCC255A8(&v85, v8, v7);
    std::string::size_type v49 = std::string::insert(&v85, 0, "cannot read content of ");
    std::string::size_type v50 = v49->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
    v86.__r_.__value_.__r.__words[2] = v50;
    v49->__r_.__value_.__l.__size_ = 0;
    v49->__r_.__value_.__r.__words[2] = 0;
    v49->__r_.__value_.__r.__words[0] = 0;
    unint64_t v51 = std::string::append(&v86, ": ");
    uint64_t v52 = 0;
    std::string::size_type v53 = v51->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    v87.__r_.__value_.__r.__words[2] = v53;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    if (v94)
    {
      uint64_t v52 = (uint64_t)v92;
      uint64_t v92 = 0;
    }
    uint64_t v83 = v52;
    sub_1CD4FB504(&v83, &v84);
    if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v54 = &v84;
    }
    else {
      uint64_t v54 = (std::string *)v84.__r_.__value_.__r.__words[0];
    }
    if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v84.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v84.__r_.__value_.__l.__size_;
    }
    size_t v56 = std::string::append(&v87, (const std::string::value_type *)v54, size);
    std::string::size_type v57 = v56->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v57;
    v56->__r_.__value_.__l.__size_ = 0;
    v56->__r_.__value_.__r.__words[2] = 0;
    v56->__r_.__value_.__r.__words[0] = 0;
    __int16 v91 = 260;
    *(void *)&long long __dst = &__p;
    operator new();
  }
  uint64_t v11 = (char *)v92;
  long long v12 = 0uLL;
  memset(&v87, 0, sizeof(v87));
  if (*(_DWORD *)(v7 + 28))
  {
    unint64_t v13 = (unint64_t)v92 + v93;
    unsigned int v14 = 1;
    unint64_t v15 = (char *)v92;
    uint64_t v75 = v7;
    uint64_t v76 = a5;
    char v74 = v8;
    unint64_t v78 = (unint64_t)v92 + v93;
    unint64_t v79 = v10;
    while ((unint64_t)(v15 + 20) <= v13)
    {
      if ((v15 & 3) != 0)
      {
        sub_1CCC255A8(&v85, v8, v7);
        uint64_t v63 = std::string::insert(&v85, 0, "invalid ");
        std::string::size_type v64 = v63->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
        v86.__r_.__value_.__r.__words[2] = v64;
        v63->__r_.__value_.__l.__size_ = 0;
        v63->__r_.__value_.__r.__words[2] = 0;
        v63->__r_.__value_.__r.__words[0] = 0;
        std::string v65 = std::string::append(&v86, ": found a misaligned version dependency entry at offset 0x");
        std::string::size_type v66 = v65->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v66;
        v65->__r_.__value_.__l.__size_ = 0;
        v65->__r_.__value_.__r.__words[2] = 0;
        v65->__r_.__value_.__r.__words[0] = 0;
        v84.__r_.__value_.__r.__words[0] = v15 - v11;
        *(void *)&long long __dst = &__p;
        uint64_t v90 = (const char *)&v84;
        __int16 v91 = 3588;
        operator new();
      }
      std::string::size_type v16 = *(unsigned __int16 *)v15;
      if (v16 != 1)
      {
        sub_1CCC255A8(&v84, v8, v7);
        std::string v67 = std::string::insert(&v84, 0, "unable to dump ");
        std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v85.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
        v85.__r_.__value_.__r.__words[2] = v68;
        v67->__r_.__value_.__l.__size_ = 0;
        v67->__r_.__value_.__r.__words[2] = 0;
        v67->__r_.__value_.__r.__words[0] = 0;
        uint64_t v69 = std::string::append(&v85, ": version ");
        std::string::size_type v70 = v69->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
        v86.__r_.__value_.__r.__words[2] = v70;
        v69->__r_.__value_.__l.__size_ = 0;
        v69->__r_.__value_.__r.__words[2] = 0;
        v69->__r_.__value_.__r.__words[0] = 0;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
        __p.__r_.__value_.__r.__words[2] = v16;
        __int16 v82 = 2052;
        unint64_t v62 = " is not yet supported";
LABEL_63:
        *(void *)&long long __dst = &__p;
        uint64_t v90 = v62;
        __int16 v91 = 770;
        operator new();
      }
      unsigned int v77 = v14;
      uint64_t v17 = sub_1CCC26774((uint64_t)&v87, (_OWORD *)v87.__r_.__value_.__l.__size_);
      *(_DWORD *)uint64_t v17 = *(unsigned __int16 *)v15;
      *(_DWORD *)(v17 + 4) = *((unsigned __int16 *)v15 + 1);
      *(_DWORD *)(v17 + ++*(_DWORD *)(this + 8) = v15 - v11;
      unint64_t v18 = *((unsigned int *)v15 + 1);
      unint64_t v19 = v10 - v18;
      if (v10 <= v18)
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"<corrupt vn_file: ";
        unint64_t v73 = v73 & 0xFFFFFFFF00000000 | v18;
        __p.__r_.__value_.__r.__words[2] = v73;
        __int16 v82 = 2051;
        *(void *)&long long __dst = &__p;
        uint64_t v90 = ">";
        __int16 v91 = 770;
        llvm::Twine::str((llvm::Twine *)&__dst, &v86);
        uint64_t v21 = v17 + 16;
        if (*(char *)(v17 + 39) < 0) {
          operator delete(*(void **)v21);
        }
        uint64_t v22 = (const char *)v86.__r_.__value_.__r.__words[2];
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v86.__r_.__value_.__l.__data_;
      }
      else
      {
        if (v19 > 0x7FFFFFFFFFFFFFF7) {
LABEL_71:
        }
          abort();
        if (v19 >= 0x17)
        {
          uint64_t v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v23 = v19 | 7;
          }
          uint64_t v24 = v23 + 1;
          p_dst = (long long *)operator new(v23 + 1);
          *((void *)&__dst + 1) = v10 - v18;
          uint64_t v90 = (const char *)(v24 | 0x8000000000000000);
          *(void *)&long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v90) = v10 - v18;
          p_dst = &__dst;
        }
        memmove(p_dst, (const void *)(v80 + v18), v10 - v18);
        *((unsigned char *)p_dst + v19) = 0;
        uint64_t v21 = v17 + 16;
        if (*(char *)(v17 + 39) < 0) {
          operator delete(*(void **)v21);
        }
        *(_OWORD *)uint64_t v21 = __dst;
        uint64_t v22 = v90;
      }
      *(void *)(v21 + ++*(_DWORD *)(this + 16) = v22;
      unint64_t v25 = v78;
      if (*((_WORD *)v15 + 1))
      {
        unsigned int v26 = 0;
        unint64_t v27 = &v15[*((unsigned int *)v15 + 2)];
        do
        {
          if ((v27 & 3) != 0)
          {
            sub_1CCC255A8(&v85, v74, v75);
            long long v41 = std::string::insert(&v85, 0, "invalid ");
            std::string::size_type v42 = v41->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
            v86.__r_.__value_.__r.__words[2] = v42;
            v41->__r_.__value_.__l.__size_ = 0;
            v41->__r_.__value_.__r.__words[2] = 0;
            v41->__r_.__value_.__r.__words[0] = 0;
            std::string::size_type v43 = std::string::append(&v86, ": found a misaligned auxiliary entry at offset 0x");
            std::string::size_type v44 = v43->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v44;
            v43->__r_.__value_.__l.__size_ = 0;
            v43->__r_.__value_.__r.__words[2] = 0;
            v43->__r_.__value_.__r.__words[0] = 0;
            v84.__r_.__value_.__r.__words[0] = v27 - v11;
            *(void *)&long long __dst = &__p;
            uint64_t v90 = (const char *)&v84;
            __int16 v91 = 3588;
            operator new();
          }
          if ((unint64_t)(v27 + 16) > v25)
          {
            sub_1CCC255A8(&v84, v74, v75);
            std::string::size_type v45 = std::string::insert(&v84, 0, "invalid ");
            std::string::size_type v46 = v45->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v85.__r_.__value_.__l.__data_ = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
            v85.__r_.__value_.__r.__words[2] = v46;
            v45->__r_.__value_.__l.__size_ = 0;
            v45->__r_.__value_.__r.__words[2] = 0;
            v45->__r_.__value_.__r.__words[0] = 0;
            std::string::size_type v47 = std::string::append(&v85, ": version dependency ");
            std::string::size_type v48 = v47->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
            v86.__r_.__value_.__r.__words[2] = v48;
            v47->__r_.__value_.__l.__size_ = 0;
            v47->__r_.__value_.__r.__words[2] = 0;
            v47->__r_.__value_.__r.__words[0] = 0;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
            __p.__r_.__value_.__r.__words[2] = v77;
            __int16 v82 = 2052;
            *(void *)&long long __dst = &__p;
            uint64_t v90 = " refers to an auxiliary entry that goes past the end of the section";
            __int16 v91 = 770;
            operator new();
          }
          __int16 v28 = (_DWORD *)sub_1CCC26958((char **)(v17 + 40), *(void *)(v17 + 48));
          std::string v29 = v28;
          _DWORD *v28 = *(_DWORD *)v27;
          v28[1] = *((unsigned __int16 *)v27 + 2);
          v28[2] = *((unsigned __int16 *)v27 + 3);
          void v28[3] = v27 - v11;
          unint64_t v30 = *((unsigned int *)v27 + 2);
          size_t v31 = v10 - v30;
          if (v10 <= v30)
          {
            MEMORY[0x1D25D9630](v28 + 4, "<corrupt>");
          }
          else
          {
            if (v31 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_71;
            }
            if (v31 >= 0x17)
            {
              uint64_t v33 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v31 | 7) != 0x17) {
                uint64_t v33 = v31 | 7;
              }
              long long v34 = v11;
              uint64_t v35 = v33 + 1;
              std::string v32 = (long long *)operator new(v33 + 1);
              unint64_t v36 = v35 | 0x8000000000000000;
              uint64_t v11 = v34;
              unint64_t v25 = v78;
              *((void *)&__dst + 1) = v31;
              uint64_t v90 = (const char *)v36;
              *(void *)&long long __dst = v32;
            }
            else
            {
              HIBYTE(v90) = v10 - v30;
              std::string v32 = &__dst;
            }
            memmove(v32, (const void *)(v80 + v30), v31);
            *((unsigned char *)v32 + v31) = 0;
            char v37 = (void **)(v29 + 4);
            if (*((char *)v29 + 39) < 0) {
              operator delete(*v37);
            }
            *(_OWORD *)char v37 = __dst;
            *((void *)v29 + 4) = v90;
            unint64_t v10 = v79;
          }
          v27 += *((unsigned int *)v27 + 3);
          ++v26;
        }
        while (v26 < *((unsigned __int16 *)v15 + 1));
      }
      v15 += *((unsigned int *)v15 + 3);
      unsigned int v14 = v77 + 1;
      std::string::size_type v8 = v74;
      uint64_t v7 = v75;
      unint64_t v13 = v25;
      a5 = v76;
      if (v77 + 1 > *(_DWORD *)(v75 + 28))
      {
        long long v12 = *(_OWORD *)&v87.__r_.__value_.__l.__data_;
        std::string::size_type v38 = v87.__r_.__value_.__r.__words[2];
        goto LABEL_47;
      }
    }
    sub_1CCC255A8(&v84, v8, v7);
    std::string::size_type v58 = std::string::insert(&v84, 0, "invalid ");
    std::string::size_type v59 = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v85.__r_.__value_.__l.__data_ = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v85.__r_.__value_.__r.__words[2] = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    uint64_t v60 = std::string::append(&v85, ": version dependency ");
    std::string::size_type v61 = v60->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
    v86.__r_.__value_.__r.__words[2] = v61;
    v60->__r_.__value_.__l.__size_ = 0;
    v60->__r_.__value_.__r.__words[2] = 0;
    v60->__r_.__value_.__r.__words[0] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
    __p.__r_.__value_.__r.__words[2] = v14;
    __int16 v82 = 2052;
    unint64_t v62 = " goes past the end of the section";
    goto LABEL_63;
  }
  std::string::size_type v38 = 0;
LABEL_47:
  *(unsigned char *)(a5 + 24) &= ~1u;
  *(_OWORD *)a5 = v12;
  *(void *)(a5 + ++*(_DWORD *)(this + 16) = v38;
  if (v94)
  {
    uint64_t v71 = v92;
    uint64_t v92 = 0;
    if (v71) {
      (*(void (**)(unsigned __int16 *))(*(void *)v71 + 8))(v71);
    }
  }
LABEL_67:
  if (v96)
  {
    uint64_t v72 = v95[0];
    v95[0] = 0;
    if (v72) {
      (*(void (**)(uint64_t))(*(void *)v72 + 8))(v72);
    }
  }
}

uint64_t sub_1CCC26774(uint64_t a1, _OWORD *a2)
{
  uint64_t v2 = (uint64_t)a2;
  unint64_t v5 = *(uint64_t **)a1;
  unint64_t v4 = *(void *)(a1 + 8);
  uint64_t v6 = ((uint64_t)a2 - *(void *)a1) >> 6;
  unint64_t v7 = *(void *)(a1 + 16);
  if (v4 >= v7)
  {
    unint64_t v12 = ((uint64_t)(v4 - (void)v5) >> 6) + 1;
    if (v12 >> 58) {
      abort();
    }
    uint64_t v13 = v7 - (void)v5;
    if (v13 >> 5 > v12) {
      unint64_t v12 = v13 >> 5;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v14 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v12;
    }
    *(void *)&long long v21 = a1 + 16;
    if (v14)
    {
      if (v14 >> 58) {
        sub_1CB833614();
      }
      unint64_t v15 = (char *)operator new(v14 << 6);
    }
    else
    {
      unint64_t v15 = 0;
    }
    __p[0] = v15;
    __p[1] = &v15[64 * v6];
    *(void **)&long long v20 = __p[1];
    *((void *)&v20 + 1) = &v15[64 * v14];
    sub_1CCC3F79C((uint64_t **)__p);
    uint64_t v2 = sub_1CCC3F9B4((uint64_t **)a1, __p, (uint64_t *)v2);
    std::string::size_type v16 = __p[1];
    while (1)
    {
      uint64_t v17 = v20;
      if ((void *)v20 == v16) {
        break;
      }
      *(void *)&long long v20 = v20 - 64;
      uint64_t v24 = (void **)(v17 - 24);
      sub_1CCC3F5D8(&v24);
      if (*(char *)(v17 - 25) < 0) {
        operator delete(*(void **)(v17 - 48));
      }
    }
    uint64_t v11 = __p[0];
    if (__p[0]) {
      goto LABEL_23;
    }
  }
  else if (a2 == (_OWORD *)v4)
  {
    a2[2] = 0u;
    a2[3] = 0u;
    *a2 = 0u;
    a2[1] = 0u;
    *(void *)(a1 + ++*(_DWORD *)(this + 8) = a2 + 4;
  }
  else
  {
    uint64_t v23 = a1 + 16;
    *(_OWORD *)std::string __p = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    sub_1CCC3F664(a1, (uint64_t)a2, v4, (uint64_t)(a2 + 4));
    *(_DWORD *)(v2 + ++*(_DWORD *)(this + 8) = 0;
    *(void *)uint64_t v2 = 0;
    std::string::size_type v8 = &v5[8 * v6];
    long long v9 = (void **)(v8 + 2);
    if (*(char *)(v2 + 39) < 0) {
      operator delete(*v9);
    }
    long long v10 = v20;
    v8[4] = v21;
    *(_OWORD *)long long v9 = v10;
    BYTE7(v21) = 0;
    LOBYTE(v20) = 0;
    sub_1CCC3FAD0((void **)v8 + 5);
    v8[5] = 0;
    v8[6] = 0;
    v8[7] = 0;
    *((void *)&v21 + 1) = 0;
    long long v22 = 0uLL;
    uint64_t v24 = (void **)&v21 + 1;
    sub_1CCC3F5D8(&v24);
    if (SBYTE7(v21) < 0)
    {
      uint64_t v11 = (void *)v20;
LABEL_23:
      operator delete(v11);
    }
  }
  return v2;
}

uint64_t sub_1CCC26958(char **a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v5 = *a1;
  unint64_t v4 = (unint64_t)a1[1];
  unint64_t v6 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - (uint64_t)*a1) >> 3);
  unint64_t v7 = (unint64_t)a1[2];
  if (v4 >= v7)
  {
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - (void)v5) >> 3) + 1;
    if (v12 > 0x666666666666666) {
      abort();
    }
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - (void)v5) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x333333333333333) {
      unint64_t v14 = 0x666666666666666;
    }
    else {
      unint64_t v14 = v12;
    }
    std::string v32 = a1 + 2;
    if (v14)
    {
      if (v14 > 0x666666666666666) {
        sub_1CB833614();
      }
      unint64_t v15 = (char *)operator new(40 * v14);
    }
    else
    {
      unint64_t v15 = 0;
    }
    __int16 v28 = v15;
    std::string v29 = &v15[40 * v6];
    unint64_t v30 = v29;
    size_t v31 = &v15[40 * v14];
    sub_1CCC3FB40(&v28);
    std::string::size_type v16 = v29;
    uint64_t v17 = *a1;
    unint64_t v18 = v29;
    if ((char *)v2 != *a1)
    {
      uint64_t v19 = v2;
      long long v20 = v29;
      do
      {
        unint64_t v18 = v20 - 40;
        *(_OWORD *)(v20 - 40) = *(_OWORD *)(v19 - 40);
        long long v21 = *(_OWORD *)(v19 - 24);
        *((void *)v20 - 1) = *(void *)(v19 - 8);
        *(_OWORD *)(v20 - 24) = v21;
        *(void *)(v19 - ++*(_DWORD *)(this + 16) = 0;
        *(void *)(v19 - ++*(_DWORD *)(this + 8) = 0;
        *(void *)(v19 - 24) = 0;
        v19 -= 40;
        v20 -= 40;
      }
      while ((char *)v19 != v17);
    }
    std::string v29 = v18;
    long long v22 = a1[1];
    uint64_t v23 = v30;
    if ((char *)v2 != v22)
    {
      do
      {
        *(_OWORD *)uint64_t v23 = *(_OWORD *)v2;
        long long v24 = *(_OWORD *)(v2 + 16);
        *((void *)v23 + 4) = *(void *)(v2 + 32);
        *((_OWORD *)v23 + 1) = v24;
        *(void *)(v2 + 24) = 0;
        *(void *)(v2 + 32) = 0;
        *(void *)(v2 + ++*(_DWORD *)(this + 16) = 0;
        v23 += 40;
        v2 += 40;
      }
      while ((char *)v2 != v22);
      unint64_t v18 = v29;
      uint64_t v2 = (uint64_t)a1[1];
    }
    unint64_t v25 = *a1;
    *a1 = v18;
    a1[1] = v23;
    unsigned int v26 = a1[2];
    a1[2] = v31;
    unint64_t v30 = (char *)v2;
    size_t v31 = v26;
    __int16 v28 = v25;
    std::string v29 = v25;
    sub_1CCC3FD5C((uint64_t)&v28);
    return (uint64_t)v16;
  }
  else if (a2 == v4)
  {
    *(void *)(a2 + 32) = 0;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + ++*(_DWORD *)(this + 16) = 0u;
    a1[1] = (char *)(a2 + 40);
  }
  else
  {
    std::string::size_type v8 = a1[1];
    if (v4 - 40 < v4)
    {
      unint64_t v9 = v4 - 40;
      std::string::size_type v8 = a1[1];
      do
      {
        *(_OWORD *)std::string::size_type v8 = *(_OWORD *)v9;
        long long v10 = *(_OWORD *)(v9 + 16);
        *((void *)v8 + 4) = *(void *)(v9 + 32);
        *((_OWORD *)v8 + 1) = v10;
        *(void *)(v9 + 24) = 0;
        *(void *)(v9 + 32) = 0;
        *(void *)(v9 + ++*(_DWORD *)(this + 16) = 0;
        v8 += 40;
        v9 += 40;
      }
      while (v9 < v4);
    }
    a1[1] = v8;
    sub_1CCC3FCC0(a2, v4 - 40, v4);
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + ++*(_DWORD *)(this + 8) = 0;
    uint64_t v11 = (void **)&v5[40 * v6 + 16];
    if (*(char *)(v2 + 39) < 0) {
      operator delete(*v11);
    }
    *uint64_t v11 = 0;
    *(void *)&v5[40 * v6 + 24] = 0;
    *(void *)&v5[40 * v6 + 32] = 0;
  }
  return v2;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSymbolVersionByIndex(__int16 a1@<W1>, unsigned char *a2@<X2>, uint64_t a3@<X3>, __int16 a4@<W4>, uint64_t a5@<X8>)
{
  uint64_t v6 = a1 & 0x7FFF;
  uint64_t v14 = v6;
  if (v6 <= 1)
  {
    *a2 = 0;
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = "";
    *(void *)(a5 + ++*(_DWORD *)(this + 8) = 0;
    return;
  }
  if (*(_DWORD *)(a3 + 8) <= v6 || (size_t v7 = *(void *)a3 + 40 * (a1 & 0x7FFF), !*(unsigned char *)(v7 + 32)))
  {
    v9[0] = "SHT_GNU_versym section refers to a version index ";
    _OWORD v9[2] = &v14;
    __int16 v10 = 2563;
    uint64_t v11 = v9;
    unint64_t v12 = " which is missing";
    __int16 v13 = 770;
    operator new();
  }
  char v8 = *(unsigned char *)(v7 + 24);
  if (v8) {
    char v8 = ((a4 & 0xFF00) == 0 || !(_BYTE)a4) && (a1 & 0x8000) == 0;
  }
  *a2 = v8;
  if ((*(char *)(v7 + 23) & 0x80000000) == 0)
  {
    *(unsigned char *)(a5 + 16) &= ~1u;
    *(void *)a5 = v7;
LABEL_14:
    size_t v7 = strlen((const char *)v7);
    goto LABEL_15;
  }
  size_t v7 = *(void *)v7;
  *(unsigned char *)(a5 + 16) &= ~1u;
  *(void *)a5 = v7;
  if (v7) {
    goto LABEL_14;
  }
LABEL_15:
  *(void *)(a5 + ++*(_DWORD *)(this + 8) = v7;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getStringTableForSymtab@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections(a1, (uint64_t)&v5);
  if ((v6 & 1) == 0) {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getStringTableForSymtab();
  }
  uint64_t v4 = v5;
  *(unsigned char *)(a2 + 16) |= 1u;
  *(void *)a2 = v4;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *(unsigned int *)(*result + 32);
  if (v4)
  {
    uint64_t v5 = (uint64_t *)*(unsigned __int16 *)(v3 + 46);
    if (v5 != (uint64_t *)40)
    {
      unint64_t v12 = "invalid e_shentsize in ELF header: ";
      __int16 v13 = v5;
      __int16 v8 = 2307;
      goto LABEL_11;
    }
    unint64_t v6 = result[1];
    if (v4 > 0xFFFFFFD7 || v4 + 40 > v6)
    {
      uint64_t v11 = *(unsigned int *)(*result + 32);
      unint64_t v12 = "section header table goes past the end of the file: e_shoff = 0x";
      __int16 v13 = &v11;
      __int16 v8 = 3587;
      goto LABEL_11;
    }
    uint64_t v9 = v3 + v4;
    unsigned int v10 = *(unsigned __int16 *)(v3 + 48);
    if (!v10) {
      unsigned int v10 = *(_DWORD *)(v9 + 20);
    }
    if (v4 + 40 * (unint64_t)v10 > v6)
    {
      unint64_t v12 = "section table goes past the end of file";
      __int16 v8 = 259;
LABEL_11:
      __int16 v14 = v8;
      operator new();
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = v9;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = v10;
  }
  else
  {
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = 0;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getStringTableForSymtab(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6 != 2 && v6 != 11)
  {
    unint64_t v12 = "invalid sh_type for symbol table, expected SHT_SYMTAB or SHT_DYNSYM";
    __int16 v14 = 259;
    operator new();
  }
  sub_1CD6CA180(a3, a4, *(_DWORD *)(a2 + 24), (uint64_t)&v12);
  uint64_t v9 = v12;
  if (v13)
  {
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v9;
  }
  else
  {
    uint64_t v11 = sub_1CCC27114;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getStringTable(a1, (uint64_t)v12, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v11, a5);
    if (v13)
    {
      unsigned int v10 = v12;
      unint64_t v12 = 0;
      if (v10) {
        (*(void (**)(const char *))(*(void *)v10 + 8))(v10);
      }
    }
  }
}

void sub_1CCC27114()
{
}

llvm::object *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getDynSymtabSize@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t result = (llvm::object *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections(a1, (uint64_t)&v20);
  unint64_t v4 = (unint64_t)v20;
  if (v22)
  {
    long long v20 = 0;
    char v7 = *(unsigned char *)(a2 + 8) | 1;
  }
  else
  {
    if (!v21) {
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::dynamicEntries();
    }
    uint64_t v5 = v20 + 9;
    uint64_t v6 = 40 * v21;
    while (*(v5 - 8) != 11)
    {
      v5 += 10;
      v6 -= 40;
      if (!v6)
      {
        *(unsigned char *)(a2 + 8) &= ~1u;
        *(void *)a2 = 0;
        goto LABEL_12;
      }
    }
    unsigned int v8 = *(v5 - 4);
    unint64_t v4 = v8 / *v5;
    if (v8 % *v5)
    {
      atomic_ullong v9 = llvm::object::object_category(result);
      uint64_t v10 = *(v5 - 4);
      v12[0] = "SHT_DYNSYM section has sh_size (";
      uint64_t v12[2] = v10;
      __int16 v13 = 2051;
      v14[0] = v12;
      unint64_t v14[2] = ") % sh_entsize (";
      __int16 v15 = 770;
      uint64_t v11 = *v5;
      v16[0] = v14;
      _OWORD v16[2] = v11;
      __int16 v17 = 2050;
      v18[0] = v16;
      v18[2] = ") that is not 0";
      __int16 v19 = 770;
      sub_1CD4FF4BC(3, v9, (llvm::Twine *)v18);
    }
    char v7 = *(unsigned char *)(a2 + 8) & 0xFE;
  }
  *(unsigned char *)(a2 + ++*(_DWORD *)(this + 8) = v7;
  *(void *)a2 = v4;
LABEL_12:
  if (v22)
  {
    uint64_t result = (llvm::object *)v20;
    long long v20 = 0;
    if (result) {
      return (llvm::object *)(*(uint64_t (**)(llvm::object *))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::dynamicEntries()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::program_headers();
}

{
  while (1)
    ;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::toMappedAddr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::program_headers();
}

const char *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getRelocationTypeName(uint64_t a1, unsigned int a2)
{
  return llvm::object::getELFRelocationTypeName((llvm::object *)*(unsigned __int16 *)(*(void *)a1 + 18), a2);
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::isMipsELF64(uint64_t a1)
{
  return *(_WORD *)(*(void *)a1 + 18) == 8 && *(unsigned char *)(*(void *)a1 + 4) == 2;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getRelativeRelocationType(uint64_t a1)
{
  return llvm::object::getELFRelativeRelocationType((llvm::object *)*(unsigned __int16 *)(*(void *)a1 + 18));
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getDynamicTagAsString(int a1@<W1>, int64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (a1 > 163)
  {
    switch(a1)
    {
      case 164:
        switch(a2)
        {
          case 1879048194:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1414287455;
            unint64_t v4 = "HEXAGON_PLT";
            goto LABEL_46;
          case 1879048193:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1380275807;
            unint64_t v4 = "HEXAGON_VER";
            goto LABEL_46;
          case 1879048192:
            unsigned int v8 = "HEXAGON_SYMSZ";
LABEL_23:
            *(unsigned char *)(a3 + 23) = 13;
            *(void *)a3 = *(void *)v8;
            *(void *)(a3 + 5) = *(void *)(v8 + 5);
            *(unsigned char *)(a3 + 13) = 0;
            return;
        }
        break;
      case 243:
        if (a2 == 1879048193)
        {
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "RISCV_VARIANT_CC";
LABEL_26:
          *(_OWORD *)a3 = *(_OWORD *)v6;
          *(unsigned char *)(a3 + ++*(_DWORD *)(this + 16) = 0;
          return;
        }
        break;
      case 183:
        switch(a2)
        {
          case 1879048197:
            *(unsigned char *)(a3 + 23) = 19;
            *(_DWORD *)(a3 + 15) = 1396920415;
            uint64_t v11 = "AARCH64_VARIANT_PCS";
LABEL_41:
            *(_OWORD *)a3 = *(_OWORD *)v11;
            *(unsigned char *)(a3 + 19) = 0;
            return;
          case 1879048195:
            uint64_t v5 = "AARCH64_PAC_PLT";
            goto LABEL_43;
          case 1879048193:
            uint64_t v5 = "AARCH64_BTI_PLT";
            goto LABEL_43;
        }
        break;
    }
  }
  else
  {
    if (a1 == 8)
    {
      switch(a2)
      {
        case 1879048193:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_RLD_VERSION";
          goto LABEL_26;
        case 1879048194:
          uint64_t v5 = "MIPS_TIME_STAMP";
          goto LABEL_43;
        case 1879048195:
          std::string::size_type v16 = "MIPS_ICHECKSUM";
          goto LABEL_159;
        case 1879048196:
          unsigned int v8 = "MIPS_IVERSION";
          goto LABEL_23;
        case 1879048197:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 21319;
          __int16 v14 = "MIPS_FLAGS";
          goto LABEL_172;
        case 1879048198:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 83;
          long long v24 = "MIPS_BASE_ADDRESS";
          goto LABEL_165;
        case 1879048199:
          *(unsigned char *)(a3 + 23) = 9;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 77;
          unint64_t v12 = "MIPS_MSYM";
          goto LABEL_126;
        case 1879048200:
          unsigned int v8 = "MIPS_CONFLICT";
          goto LABEL_23;
        case 1879048201:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1414744396;
          __int16 v15 = "MIPS_LIBLIST";
          goto LABEL_157;
        case 1879048202:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_LOCAL_GOTNO";
          goto LABEL_26;
        case 1879048203:
          uint64_t v5 = "MIPS_CONFLICTNO";
          goto LABEL_43;
        case 1879048208:
          std::string::size_type v16 = "MIPS_LIBLISTNO";
          goto LABEL_159;
        case 1879048209:
          unsigned int v8 = "MIPS_SYMTABNO";
          goto LABEL_23;
        case 1879048210:
          uint64_t v5 = "MIPS_UNREFEXTNO";
          goto LABEL_43;
        case 1879048211:
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1297699668;
          unint64_t v4 = "MIPS_GOTSYM";
          goto LABEL_46;
        case 1879048212:
          unsigned int v8 = "MIPS_HIPAGENO";
          goto LABEL_23;
        case 1879048214:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1346456927;
          __int16 v15 = "MIPS_RLD_MAP";
          goto LABEL_157;
        case 1879048215:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_DELTA_CLASS";
          goto LABEL_26;
        case 1879048216:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1330536275;
          uint64_t v11 = "MIPS_DELTA_CLASS_NO";
          goto LABEL_41;
        case 1879048217:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1162038849;
          uint64_t v11 = "MIPS_DELTA_INSTANCE";
          goto LABEL_41;
        case 1879048218:
          unint64_t v25 = "MIPS_DELTA_INSTANCE_NO";
          goto LABEL_147;
        case 1879048219:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_DELTA_RELOC";
          goto LABEL_26;
        case 1879048220:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1330536259;
          uint64_t v11 = "MIPS_DELTA_RELOC_NO";
          goto LABEL_41;
        case 1879048221:
          std::string::size_type v16 = "MIPS_DELTA_SYM";
          goto LABEL_159;
        case 1879048222:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 79;
          long long v24 = "MIPS_DELTA_SYM_NO";
          goto LABEL_165;
        case 1879048224:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1297699667;
          uint64_t v11 = "MIPS_DELTA_CLASSSYM";
          goto LABEL_41;
        case 1879048225:
          unint64_t v25 = "MIPS_DELTA_CLASSSYM_NO";
LABEL_147:
          *(_OWORD *)a3 = *(_OWORD *)v25;
          *(void *)(a3 + 14) = *(void *)(v25 + 14);
          *(_WORD *)(a3 + 22) = 5632;
          return;
        case 1879048226:
          std::string::size_type v16 = "MIPS_CXX_FLAGS";
          goto LABEL_159;
        case 1879048227:
          uint64_t v5 = "MIPS_PIXIE_INIT";
          goto LABEL_43;
        case 1879048228:
          uint64_t v5 = "MIPS_SYMBOL_LIB";
          goto LABEL_43;
        case 1879048229:
          unsigned int v26 = "MIPS_LOCALPAGE_GOTIDX";
          goto LABEL_155;
        case 1879048230:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 88;
          long long v24 = "MIPS_LOCAL_GOTIDX";
          goto LABEL_165;
        case 1879048231:
          *(unsigned char *)(a3 + 23) = 18;
          strcpy((char *)a3, "MIPS_HIDDEN_GOTIDX");
          return;
        case 1879048232:
          unsigned int v26 = "MIPS_PROTECTED_GOTIDX";
LABEL_155:
          *(unsigned char *)(a3 + 23) = 21;
          *(_OWORD *)a3 = *(_OWORD *)v26;
          *(void *)(a3 + 13) = *(void *)(v26 + 13);
          *(unsigned char *)(a3 + 21) = 0;
          return;
        case 1879048233:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1397641033;
          __int16 v15 = "MIPS_OPTIONS";
          goto LABEL_157;
        case 1879048234:
          std::string::size_type v16 = "MIPS_INTERFACE";
          goto LABEL_159;
        case 1879048235:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 78;
          long long v24 = "MIPS_DYNSTR_ALIGN";
          goto LABEL_165;
        case 1879048236:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1163544915;
          uint64_t v11 = "MIPS_INTERFACE_SIZE";
          goto LABEL_41;
        case 1879048237:
          unint64_t v27 = (char *)operator new(0x20uLL);
          *(void *)a3 = v27;
          *(_OWORD *)(a3 + ++*(_DWORD *)(this + 8) = xmmword_1CD96DBE0;
          strcpy(v27, "MIPS_RLD_TEXT_RESOLVE_ADDR");
          return;
        case 1879048238:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_PERF_SUFFIX";
          goto LABEL_26;
        case 1879048239:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 69;
          long long v24 = "MIPS_COMPACT_SIZE";
LABEL_165:
          *(_OWORD *)a3 = *(_OWORD *)v24;
          return;
        case 1879048240:
          unsigned int v8 = "MIPS_GP_VALUE";
          goto LABEL_23;
        case 1879048241:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_AUX_DYNAMIC";
          goto LABEL_26;
        case 1879048242:
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414481748;
          unint64_t v4 = "MIPS_PLTGOT";
          goto LABEL_46;
        case 1879048244:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 21580;
          __int16 v14 = "MIPS_RWPLT";
          goto LABEL_172;
        case 1879048245:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_RLD_MAP_REL";
          goto LABEL_26;
        case 1879048246:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 18515;
          __int16 v14 = "MIPS_XHASH";
LABEL_172:
          *(void *)a3 = *(void *)v14;
          *(unsigned char *)(a3 + 10) = 0;
          break;
        default:
          goto LABEL_27;
      }
      return;
    }
    if (a1 == 20)
    {
      if (a2 == 1879048193)
      {
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1598246992;
        int v7 = 1414549343;
      }
      else
      {
        if (a2 != 1879048192) {
          goto LABEL_27;
        }
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1598246992;
        int v7 = 1414481759;
      }
LABEL_116:
      *(_DWORD *)(a3 + 3) = v7;
      *(unsigned char *)(a3 + 7) = 0;
      return;
    }
    if (a1 == 21 && a2 == 1879048192)
    {
      *(unsigned char *)(a3 + 23) = 11;
      *(_DWORD *)(a3 + 7) = 1263421772;
      unint64_t v4 = "PPC64_GLINK";
LABEL_46:
      *(void *)a3 = *(void *)v4;
      *(unsigned char *)(a3 + 11) = 0;
      return;
    }
  }
LABEL_27:
  if (a2 <= 1879039999)
  {
    switch(a2)
    {
      case 0:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1280070990;
        goto LABEL_113;
      case 1:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1145390414;
        __int16 v10 = 17477;
        goto LABEL_111;
      case 2:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x5A534C4552544C50;
        goto LABEL_98;
      case 3:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1196706896;
        __int16 v10 = 21583;
        goto LABEL_111;
      case 4:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1213415752;
        goto LABEL_113;
      case 5:
        *(unsigned char *)(a3 + 23) = 6;
        int v17 = 1414681683;
        goto LABEL_76;
      case 6:
        *(unsigned char *)(a3 + 23) = 6;
        int v17 = 1414355283;
LABEL_76:
        *(_DWORD *)a3 = v17;
        __int16 v10 = 16961;
        goto LABEL_111;
      case 7:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1095517522;
        goto LABEL_113;
      case 8:
        *(unsigned char *)(a3 + 23) = 6;
        int v18 = 1095517522;
        goto LABEL_110;
      case 9:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1095517522;
        unsigned __int16 v19 = 17729;
        goto LABEL_115;
      case 10:
        *(unsigned char *)(a3 + 23) = 5;
        int v20 = 1397904467;
        goto LABEL_89;
      case 11:
        *(unsigned char *)(a3 + 23) = 6;
        int v21 = 1162697043;
        goto LABEL_91;
      case 12:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1414090313;
        goto LABEL_113;
      case 13:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1229867334;
        goto LABEL_113;
      case 14:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1095651155;
        __int16 v10 = 17741;
        goto LABEL_111;
      case 15:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1413566546;
        __int16 v22 = 72;
        goto LABEL_105;
      case 16:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x43494C4F424D5953;
        goto LABEL_98;
      case 17:
        *(unsigned char *)(a3 + 23) = 3;
        *(_DWORD *)a3 = 4998482;
        return;
      case 18:
        *(unsigned char *)(a3 + 23) = 5;
        int v20 = 1397507410;
LABEL_89:
        *(_DWORD *)a3 = v20;
        __int16 v22 = 90;
        goto LABEL_105;
      case 19:
        *(unsigned char *)(a3 + 23) = 6;
        int v21 = 1162626386;
LABEL_91:
        *(_DWORD *)a3 = v21;
        __int16 v10 = 21582;
        goto LABEL_111;
      case 20:
        *(unsigned char *)(a3 + 23) = 6;
        int v23 = 1381256272;
        goto LABEL_96;
      case 21:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1430406468;
        __int16 v22 = 71;
        goto LABEL_105;
      case 22:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1415071060;
        int v7 = 1279611476;
        goto LABEL_116;
      case 23:
        *(unsigned char *)(a3 + 23) = 6;
        int v23 = 1380994378;
LABEL_96:
        *(_DWORD *)a3 = v23;
        __int16 v10 = 19525;
        goto LABEL_111;
      case 24:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x574F4E5F444E4942;
        goto LABEL_98;
      case 25:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 22849;
        __int16 v14 = "INIT_ARRAY";
        goto LABEL_172;
      case 26:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 22849;
        __int16 v14 = "FINI_ARRAY";
        goto LABEL_172;
      case 27:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1515411777;
        __int16 v15 = "INIT_ARRAYSZ";
        goto LABEL_157;
      case 28:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1515411777;
        __int16 v15 = "FINI_ARRAYSZ";
        goto LABEL_157;
      case 29:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1347310930;
        int v7 = 1213481296;
        goto LABEL_116;
      case 30:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1195461702;
        __int16 v22 = 83;
LABEL_105:
        *(_WORD *)(a3 + 4) = v22;
        return;
      case 31:
        goto LABEL_174;
      case 32:
        unsigned int v8 = "PREINIT_ARRAY";
        goto LABEL_23;
      case 33:
        uint64_t v5 = "PREINIT_ARRAYSZ";
        goto LABEL_43;
      case 34:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1480871496;
        __int16 v15 = "SYMTAB_SHNDX";
        goto LABEL_157;
      case 35:
        *(unsigned char *)(a3 + 23) = 6;
        int v18 = 1380730194;
LABEL_110:
        *(_DWORD *)a3 = v18;
        __int16 v10 = 23123;
        goto LABEL_111;
      case 36:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1380730194;
        goto LABEL_113;
      case 37:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1380730194;
        unsigned __int16 v19 = 17746;
LABEL_115:
        int v7 = v19 | 0x544E0000;
        goto LABEL_116;
      default:
        switch(a2)
        {
          case 1610612751:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1279611487;
            unint64_t v4 = "ANDROID_REL";
            goto LABEL_46;
          case 1610612752:
            unsigned int v8 = "ANDROID_RELSZ";
            goto LABEL_23;
          case 1610612753:
            *(unsigned char *)(a3 + 23) = 12;
            *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1095517522;
            __int16 v15 = "ANDROID_RELA";
            goto LABEL_157;
          case 1610612754:
            std::string::size_type v16 = "ANDROID_RELASZ";
            goto LABEL_159;
          default:
            goto LABEL_174;
        }
    }
  }
  if (a2 <= 1879048175)
  {
    if (a2 > 1879047924)
    {
      if (a2 != 1879047925)
      {
        if (a2 == 1879047926)
        {
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414287455;
          unint64_t v4 = "TLSDESC_PLT";
          goto LABEL_46;
        }
        if (a2 == 1879047927)
        {
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414481759;
          unint64_t v4 = "TLSDESC_GOT";
          goto LABEL_46;
        }
        goto LABEL_174;
      }
      *(unsigned char *)(a3 + 23) = 8;
      uint64_t v13 = 0x485341485F554E47;
LABEL_98:
      *(void *)a3 = v13;
      *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = 0;
      return;
    }
    if (a2 == 1879040000)
    {
      *(unsigned char *)(a3 + 23) = 12;
      *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1380730194;
      __int16 v15 = "ANDROID_RELR";
LABEL_157:
      *(void *)a3 = *(void *)v15;
      *(unsigned char *)(a3 + 12) = 0;
      return;
    }
    if (a2 == 1879040001)
    {
      std::string::size_type v16 = "ANDROID_RELRSZ";
LABEL_159:
      *(unsigned char *)(a3 + 23) = 14;
      *(void *)a3 = *(void *)v16;
      *(void *)(a3 + 6) = *(void *)(v16 + 6);
      *(unsigned char *)(a3 + 14) = 0;
      return;
    }
    if (a2 != 1879040003) {
      goto LABEL_174;
    }
    uint64_t v5 = "ANDROID_RELRENT";
LABEL_43:
    *(unsigned char *)(a3 + 23) = 15;
    *(void *)a3 = *(void *)v5;
    *(void *)(a3 + 7) = *(void *)(v5 + 7);
    *(unsigned char *)(a3 + 15) = 0;
    return;
  }
  if (a2 <= 2147483644)
  {
    switch(a2)
    {
      case 1879048176:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1397900630;
        __int16 v10 = 19801;
        goto LABEL_111;
      case 1879048185:
        *(unsigned char *)(a3 + 23) = 9;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 84;
        unint64_t v12 = "RELACOUNT";
        goto LABEL_126;
      case 1879048186:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x544E554F434C4552;
        goto LABEL_98;
      case 1879048187:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1195461702;
        int v7 = 828330823;
        goto LABEL_116;
      case 1879048188:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1146242390;
        __int16 v10 = 17989;
        goto LABEL_111;
      case 1879048189:
        *(unsigned char *)(a3 + 23) = 9;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 77;
        unint64_t v12 = "VERDEFNUM";
        goto LABEL_126;
      case 1879048190:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1314014550;
        int v7 = 1145390414;
        goto LABEL_116;
      case 1879048191:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 19797;
        __int16 v14 = "VERNEEDNUM";
        goto LABEL_172;
      default:
        goto LABEL_174;
    }
  }
  if (a2 != 2147483645)
  {
    if (a2 == 2147483646)
    {
      *(unsigned char *)(a3 + 23) = 4;
      int v9 = 1145394005;
LABEL_113:
      *(_DWORD *)a3 = v9;
      *(unsigned char *)(a3 + 4) = 0;
      return;
    }
    if (a2 == 0x7FFFFFFF)
    {
      *(unsigned char *)(a3 + 23) = 6;
      *(_DWORD *)a3 = 1414285638;
      __int16 v10 = 21061;
LABEL_111:
      *(_WORD *)(a3 + 4) = v10;
      *(unsigned char *)(a3 + 6) = 0;
      return;
    }
LABEL_174:
    sub_1CD5E9F58(a2, 1, 0, &v30);
    __int16 v28 = std::string::insert(&v30, 0, "<unknown:>0x");
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)a3 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    *(void *)(a3 + ++*(_DWORD *)(this + 16) = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    return;
  }
  *(unsigned char *)(a3 + 23) = 9;
  *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 89;
  unint64_t v12 = "AUXILIARY";
LABEL_126:
  *(void *)a3 = *(void *)v12;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getDynamicTagAsString()
{
}

{
  while (1)
    ;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getRelocationSymbol@<X0>(void *result@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v4 = *(_DWORD *)(a2 + 4);
  if (v4 > 0xFF) {
    return sub_1CD6CAE48(result, a3, v4 >> 8, a4);
  }
  *(unsigned char *)(a4 + 8) &= ~1u;
  *(void *)a4 = 0;
  return result;
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::isMips64EL(uint64_t *a1)
{
  uint64_t v1 = *a1;
  return *(_WORD *)(*a1 + 18) == 8 && *(unsigned char *)(v1 + 4) == 2 && *(unsigned char *)(v1 + 5) == 1;
}

char **llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::loadVersionMap@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  std::string::size_type v42 = &v44;
  uint64_t v43 = 0;
  __p[0] = 0;
  __p[1] = 0;
  char v40 = 0;
  unint64_t v39 = 0;
  char v41 = 1;
  sub_1CCC297E0((uint64_t)&v42, (unint64_t)__p);
  if (v41 && SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  char v40 = 0;
  unint64_t v39 = 0;
  char v41 = 1;
  sub_1CCC297E0((uint64_t)&v42, (unint64_t)__p);
  if (v41 && SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  if (a3)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getVersionDefinitions(a1, a3, (uint64_t)&v44);
    unsigned int v8 = v44;
    if (v46)
    {
      std::string::size_type v44 = 0;
      *(unsigned char *)(a4 + 16) |= 1u;
      *(void *)a4 = v8;
      sub_1CCC3FEAC((uint64_t)&v44);
      return sub_1CCC3FDC0((char **)&v42);
    }
    uint64_t v35 = a1;
    int v9 = v45;
    if (v44 != v45)
    {
      __int16 v10 = v44 + 3;
      do
      {
        unsigned int v11 = *((_DWORD *)v10 - 3) & 0x7FFF;
        char v12 = *((unsigned char *)v10 + 23);
        BOOL v13 = v12 < 0;
        if (v12 >= 0) {
          __int16 v14 = v10;
        }
        else {
          __int16 v14 = *v10;
        }
        size_t v15 = v12 & 0x7F;
        if (v13) {
          size_t v16 = (size_t)v10[1];
        }
        else {
          size_t v16 = v15;
        }
        if (v43 <= v11) {
          sub_1CCC3EBD0((uint64_t)&v42, v11 + 1);
        }
        if (v16 > 0x7FFFFFFFFFFFFFF7) {
LABEL_68:
        }
          abort();
        if (v16 >= 0x17)
        {
          uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v16 | 7) != 0x17) {
            uint64_t v18 = v16 | 7;
          }
          uint64_t v19 = v18 + 1;
          int v17 = operator new(v18 + 1);
          __p[1] = (void *)v16;
          unint64_t v39 = v19 | 0x8000000000000000;
          __p[0] = v17;
        }
        else
        {
          HIBYTE(v39) = v16;
          int v17 = __p;
          if (!v16) {
            goto LABEL_27;
          }
        }
        memmove(v17, v14, v16);
LABEL_27:
        *((unsigned char *)v17 + v++*(_DWORD *)(this + 16) = 0;
        int v20 = (char *)&v42[5 * v11];
        int v21 = v20 + 32;
        if (v20[32])
        {
          if (v20[23] < 0) {
            operator delete(*(void **)v20);
          }
          *(_OWORD *)int v20 = *(_OWORD *)__p;
          *((void *)v20 + 2) = v39;
          int v21 = v20 + 24;
        }
        else
        {
          *(_OWORD *)int v20 = *(_OWORD *)__p;
          *((void *)v20 + 2) = v39;
          v20[24] = 1;
        }
        *int v21 = 1;
        __int16 v22 = v10 + 6;
        v10 += 9;
      }
      while (v22 != v9);
    }
    sub_1CCC3FEAC((uint64_t)&v44);
    a1 = v35;
  }
  if (a2)
  {
    __p[0] = sub_1CCC27114;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getVersionDependencies(a1, a2, (void (*)(unsigned __int16 **__return_ptr, uint64_t, long long *))sub_1CD6D6140, (uint64_t)__p, (uint64_t)&v44);
    int v23 = v44;
    if ((v46 & 1) == 0)
    {
      uint64_t v36 = a4;
      char v37 = v45;
      if (v44 == v45) {
        goto LABEL_62;
      }
      while (1)
      {
        long long v24 = (char *)v23[5];
        unint64_t v25 = (char *)v23[6];
        while (v24 != v25)
        {
          unsigned int v26 = *((_DWORD *)v24 + 2) & 0x7FFF;
          char v27 = v24[39];
          if (v27 >= 0) {
            __int16 v28 = v24 + 16;
          }
          else {
            __int16 v28 = (const void *)*((void *)v24 + 2);
          }
          if (v27 >= 0) {
            size_t v29 = v27 & 0x7F;
          }
          else {
            size_t v29 = *((void *)v24 + 3);
          }
          if (v43 <= v26) {
            sub_1CCC3EBD0((uint64_t)&v42, v26 + 1);
          }
          if (v29 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_68;
          }
          if (v29 >= 0x17)
          {
            uint64_t v31 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v29 | 7) != 0x17) {
              uint64_t v31 = v29 | 7;
            }
            uint64_t v32 = v31 + 1;
            std::string v30 = operator new(v31 + 1);
            __p[1] = (void *)v29;
            unint64_t v39 = v32 | 0x8000000000000000;
            __p[0] = v30;
LABEL_54:
            memmove(v30, v28, v29);
            goto LABEL_55;
          }
          HIBYTE(v39) = v29;
          std::string v30 = __p;
          if (v29) {
            goto LABEL_54;
          }
LABEL_55:
          *((unsigned char *)v30 + v29) = 0;
          uint64_t v33 = (char *)&v42[5 * v26];
          if (v33[32])
          {
            if (v33[23] < 0) {
              operator delete(*(void **)v33);
            }
            *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
            *((void *)v33 + 2) = v39;
            v33[24] = 0;
          }
          else
          {
            *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
            *((void *)v33 + 2) = v39;
            v33[24] = 0;
            v33[32] = 1;
          }
          v24 += 40;
        }
        v23 += 8;
        if (v23 == v37)
        {
LABEL_62:
          sub_1CCC3FF24((uint64_t)&v44);
          a4 = v36;
          goto LABEL_63;
        }
      }
    }
    std::string::size_type v44 = 0;
    *(unsigned char *)(a4 + 16) |= 1u;
    *(void *)a4 = v23;
    sub_1CCC3FF24((uint64_t)&v44);
  }
  else
  {
LABEL_63:
    *(unsigned char *)(a4 + 16) &= ~1u;
    *(void *)a4 = a4 + 16;
    *(void *)(a4 + ++*(_DWORD *)(this + 8) = 0;
    if (v43) {
      sub_1CCC3FF9C(a4, (uint64_t)&v42);
    }
  }
  return sub_1CCC3FDC0((char **)&v42);
}

unint64_t sub_1CCC297E0(uint64_t a1, unint64_t a2)
{
  unint64_t result = sub_1CCC3FE40(a1, a2, 1);
  uint64_t v4 = *(void *)a1 + 40 * *(unsigned int *)(a1 + 8);
  *(unsigned char *)uint64_t v4 = 0;
  *(unsigned char *)(v4 + 32) = 0;
  if (*(unsigned char *)(result + 32))
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(v4 + ++*(_DWORD *)(this + 16) = *(void *)(result + 16);
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(result + ++*(_DWORD *)(this + 8) = 0;
    *(void *)(result + ++*(_DWORD *)(this + 16) = 0;
    *(void *)unint64_t result = 0;
    *(unsigned char *)(v4 + 24) = *(unsigned char *)(result + 24);
    *(unsigned char *)(v4 + 32) = 1;
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::isLE(uint64_t a1)
{
  return *(unsigned char *)(*(void *)a1 + 5) == 1;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::program_headers@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *(unsigned __int16 *)(*result + 44);
  if (*(_WORD *)(*result + 44))
  {
    uint64_t v5 = *(unsigned __int16 *)(v3 + 42);
    if (v5 != 32)
    {
      int v23 = "invalid e_phentsize: ";
      uint64_t v24 = v5;
      __int16 v6 = 2307;
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v5 = *(unsigned __int16 *)(v3 + 42);
  }
  uint64_t v7 = *(unsigned int *)(v3 + 28);
  unint64_t v8 = result[1];
  if (v7 + v5 * (unint64_t)*(unsigned __int16 *)(*result + 44) > v8)
  {
    uint64_t v9 = *(unsigned int *)(v3 + 28);
    unint64_t v10 = v8;
    v11[0] = "program headers are longer than binary of size ";
    v11[2] = &v10;
    __int16 v12 = 2563;
    v13[0] = v11;
    _OWORD v13[2] = ": e_phoff = 0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    v17[0] = v15;
    v17[2] = ", e_phnuuint64_t m = ";
    __int16 v18 = 770;
    v19[0] = v17;
    void v19[2] = v4;
    __int16 v6 = 2306;
    __int16 v20 = 2306;
    v21[0] = v19;
    v21[2] = ", e_phentstd::string::size_type size = ";
    __int16 v22 = 770;
    int v23 = (const char *)v21;
    uint64_t v24 = v5;
LABEL_7:
    __int16 v25 = v6;
    operator new();
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  *(void *)a2 = v3 + v7;
  *(void *)(a2 + ++*(_DWORD *)(this + 8) = v4;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::symbols@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    return sub_1CD6CB19C(result, a2, a3);
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = 0;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = 0;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::decode_relrs(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, unint64_t **a4@<X8>)
{
  uint64_t v5 = (llvm::object *)*(unsigned __int16 *)(*(void *)a1 + 18);
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  if (a3)
  {
    __int16 v6 = a2;
    uint64_t v33 = &a2[a3];
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = (unint64_t)llvm::object::getELFRelativeRelocationType(v5) << 32;
    do
    {
      uint64_t v10 = *v6;
      if (v10)
      {
        unsigned int v13 = v8;
        if (v10 >= 2)
        {
          do
          {
            if ((v10 & 2) != 0)
            {
              unint64_t v14 = (unint64_t)a4[2];
              if ((unint64_t)v7 >= v14)
              {
                __int16 v16 = *a4;
                uint64_t v17 = v7 - *a4;
                unint64_t v18 = v17 + 1;
                if ((unint64_t)(v17 + 1) >> 61) {
                  goto LABEL_46;
                }
                uint64_t v19 = v14 - (void)v16;
                if (v19 >> 2 > v18) {
                  unint64_t v18 = v19 >> 2;
                }
                if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v20 = v18;
                }
                if (v20)
                {
                  if (v20 >> 61) {
                    goto LABEL_47;
                  }
                  int v21 = (char *)operator new(8 * v20);
                }
                else
                {
                  int v21 = 0;
                }
                __int16 v22 = (unint64_t *)&v21[8 * v17];
                *__int16 v22 = v9 | v13;
                size_t v15 = v22 + 1;
                if (v7 != v16)
                {
                  do
                  {
                    unint64_t v23 = *--v7;
                    *--__int16 v22 = v23;
                  }
                  while (v7 != v16);
                  uint64_t v7 = *a4;
                }
                *a4 = v22;
                a4[1] = v15;
                a4[2] = (unint64_t *)&v21[8 * v20];
                if (v7) {
                  operator delete(v7);
                }
              }
              else
              {
                *uint64_t v7 = v9 | v13;
                size_t v15 = v7 + 1;
              }
              a4[1] = v15;
              uint64_t v7 = v15;
            }
            v13 += 4;
            BOOL v24 = v10 >= 4;
            LODWORD(v10) = v10 >> 1;
          }
          while (v24);
        }
        v8 += 124;
      }
      else
      {
        unint64_t v11 = (unint64_t)a4[2];
        if ((unint64_t)v7 >= v11)
        {
          __int16 v25 = *a4;
          uint64_t v26 = v7 - *a4;
          unint64_t v27 = v26 + 1;
          if ((unint64_t)(v26 + 1) >> 61) {
LABEL_46:
          }
            abort();
          uint64_t v28 = v11 - (void)v25;
          if (v28 >> 2 > v27) {
            unint64_t v27 = v28 >> 2;
          }
          if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v29 = v27;
          }
          if (v29)
          {
            if (v29 >> 61) {
LABEL_47:
            }
              sub_1CB833614();
            std::string v30 = (char *)operator new(8 * v29);
          }
          else
          {
            std::string v30 = 0;
          }
          uint64_t v31 = (unint64_t *)&v30[8 * v26];
          *uint64_t v31 = v9 | v10;
          __int16 v12 = v31 + 1;
          if (v7 != v25)
          {
            do
            {
              unint64_t v32 = *--v7;
              *--uint64_t v31 = v32;
            }
            while (v7 != v25);
            uint64_t v7 = *a4;
          }
          *a4 = v31;
          a4[1] = v12;
          a4[2] = (unint64_t *)&v30[8 * v29];
          if (v7) {
            operator delete(v7);
          }
        }
        else
        {
          *uint64_t v7 = v9 | v10;
          __int16 v12 = v7 + 1;
        }
        a4[1] = v12;
        unsigned int v8 = v10 + 4;
        uint64_t v7 = v12;
      }
      ++v6;
    }
    while (v6 != v33);
  }
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::android_relas@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionContents(a1, a2, (uint64_t)&v48);
  __int16 v6 = v48;
  if (v50)
  {
    std::string::size_type v48 = 0;
LABEL_12:
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
    goto LABEL_14;
  }
  if (v49 < 4 || *v48 != 65 || v48[1] != 80 || v48[2] != 83 || v48[3] != 50)
  {
    char v46 = "invalid packed relocation header";
    __int16 v47 = 259;
    operator new();
  }
  BOOL v7 = *(unsigned char *)(*a1 + 5) == 1;
  v43[0] = v48;
  v43[1] = v49;
  BOOL v44 = v7;
  char v45 = 4;
  unsigned int v8 = &v42;
  uint64_t v41 = 4;
  uint64_t v42 = 0;
  unint64_t SLEB128 = llvm::DataExtractor::getSLEB128(v43, &v41, &v42);
  uint64_t result = llvm::DataExtractor::getSLEB128(v43, &v41, &v42);
  __int16 v6 = (unsigned char *)v42;
  if (v42) {
    goto LABEL_12;
  }
  int v10 = result;
  uint64_t v35 = a3;
  if (SLEB128)
  {
    if (SLEB128 > 0x1555555555555555) {
LABEL_72:
    }
      abort();
    unint64_t v11 = (char *)operator new(12 * SLEB128);
    __int16 v12 = &v11[12 * SLEB128];
  }
  else
  {
    unint64_t v11 = 0;
    __int16 v12 = 0;
  }
  uint64_t v13 = 0;
  unint64_t v14 = v11;
  do
  {
    if (!SLEB128)
    {
      *(unsigned char *)(v35 + 24) &= ~1u;
      *(void *)uint64_t v35 = v11;
      *(void *)(v35 + ++*(_DWORD *)(this + 8) = v14;
      *(void *)(v35 + ++*(_DWORD *)(this + 16) = v12;
      goto LABEL_70;
    }
    unint64_t v15 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    uint64_t v16 = v42;
    if (v42) {
      break;
    }
    unint64_t v17 = v15;
    BOOL v18 = SLEB128 >= v15;
    SLEB128 -= v15;
    if (!v18)
    {
      char v46 = "relocation group unexpectedly large";
      __int16 v47 = 259;
      operator new();
    }
    uint64_t v40 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    if ((v40 & 2) != 0) {
      int v39 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    }
    else {
      int v39 = 0;
    }
    if (v40) {
      int v38 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    }
    else {
      int v38 = 0;
    }
    uint64_t v37 = v40 & 0xC;
    if (v37 == 12) {
      v13 += llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    }
    v13 &= v40 << 60 >> 63;
    uint64_t v16 = v42;
    BOOL v19 = v42 == 0;
    if (!v42 && v17)
    {
      unint64_t v36 = SLEB128;
      uint64_t v20 = 0;
      do
      {
        int v21 = v39;
        if ((v40 & 2) == 0) {
          int v21 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
        }
        int v22 = v38;
        if ((v40 & 1) == 0) {
          int v22 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
        }
        if (v37 == 8) {
          v13 += llvm::DataExtractor::getSLEB128(v43, &v41, v8);
        }
        v10 += v21;
        if (v14 >= v12)
        {
          unint64_t v23 = v12;
          BOOL v24 = v8;
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v11) >> 2) + 1;
          if (v25 > 0x1555555555555555) {
            goto LABEL_72;
          }
          unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v11) >> 2);
          if (2 * v26 > v25) {
            unint64_t v25 = 2 * v26;
          }
          if (v26 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v27 = 0x1555555555555555;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27)
          {
            if (v27 > 0x1555555555555555) {
              sub_1CB833614();
            }
            uint64_t v28 = (char *)operator new(12 * v27);
          }
          else
          {
            uint64_t v28 = 0;
          }
          unint64_t v29 = &v28[4 * ((v14 - v11) >> 2)];
          *(_DWORD *)unint64_t v29 = v10;
          *((_DWORD *)v29 + 1) = v22;
          *((_DWORD *)v29 + 2) = v13;
          std::string v30 = v29;
          while (v14 != v11)
          {
            uint64_t v31 = *(void *)(v14 - 12);
            v14 -= 12;
            int v32 = *((_DWORD *)v14 + 2);
            *(void *)(v30 - 12) = v31;
            v30 -= 12;
            *((_DWORD *)v30 + 2) = v32;
          }
          uint64_t v33 = &v28[12 * v27];
          unint64_t v14 = v29 + 12;
          if (v11) {
            operator delete(v11);
          }
          unint64_t v11 = v30;
          unsigned int v8 = v24;
          __int16 v12 = v33;
        }
        else
        {
          *(_DWORD *)unint64_t v14 = v10;
          *((_DWORD *)v14 + 1) = v22;
          *((_DWORD *)v14 + 2) = v13;
          v14 += 12;
        }
        ++v20;
        uint64_t v16 = v42;
        BOOL v19 = v42 == 0;
        if (v42) {
          BOOL v34 = 1;
        }
        else {
          BOOL v34 = v20 == v17;
        }
      }
      while (!v34);
      unint64_t SLEB128 = v36;
    }
  }
  while (v19);
  uint64_t v42 = 0;
  *(unsigned char *)(v35 + 24) |= 1u;
  *(void *)uint64_t v35 = v16;
  if (v11) {
    operator delete(v11);
  }
LABEL_70:
  uint64_t result = v42;
  if (v42) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v42 + 8))(v42);
  }
LABEL_14:
  if (v50)
  {
    uint64_t result = (uint64_t)v48;
    std::string::size_type v48 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::notes_begin@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void **a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = *(unsigned int *)(a2 + 4);
  uint64_t v7 = *(unsigned int *)(a2 + 16);
  if (a1[1] < (unint64_t)(v7 + v6))
  {
    uint64_t v9 = *(unsigned int *)(a2 + 16);
    uint64_t v10 = v6;
    v11[0] = "invalid offset (0x";
    v11[2] = &v10;
    __int16 v12 = 3587;
    v13[0] = v11;
    _OWORD v13[2] = ") or size (0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    unint64_t v17 = v15;
    BOOL v18 = ")";
    __int16 v19 = 770;
    operator new();
  }
  uint64_t result = sub_1CCC40C58(a4, *a1 + v6, v7, a3);
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

{
  uint64_t v6;
  uint64_t v7;
  void *result;
  uint64_t v9;
  uint64_t v10;
  void v11[4];
  __int16 v12;
  void v13[4];
  __int16 v14;
  void v15[4];
  __int16 v16;
  void *v17;
  const char *v18;
  __int16 v19;

  uint64_t v7 = *(unsigned int *)(a2 + 16);
  uint64_t v6 = *(unsigned int *)(a2 + 20);
  if (a1[1] < (unint64_t)(v6 + v7))
  {
    uint64_t v9 = *(unsigned int *)(a2 + 20);
    uint64_t v10 = v7;
    v11[0] = "invalid offset (0x";
    v11[2] = &v10;
    __int16 v12 = 3587;
    v13[0] = v11;
    _OWORD v13[2] = ") or size (0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    unint64_t v17 = v15;
    BOOL v18 = ")";
    __int16 v19 = 770;
    operator new();
  }
  uint64_t result = sub_1CCC40C58(a4, *a1 + v7, v6, a3);
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::notes_end(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::notes()
{
}

{
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::notes_begin();
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSymbol@<X0>(void *a1@<X0>, unsigned int *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    unint64_t v26 = 0;
    unint64_t v27 = 0;
    uint64_t v8 = a3;
    char v28 = 0;
    goto LABEL_3;
  }
  uint64_t result = sub_1CD6CB19C(a1, a2, (uint64_t)&v26);
  char v14 = v28;
  if (v28)
  {
    unint64_t v15 = v26;
    unint64_t v26 = 0;
    char v16 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    uint64_t v8 = a3;
    if (v27 <= a3)
    {
LABEL_3:
      sub_1CD6C9BF8(a1, (uint64_t)a2, (char *)&v17);
      uint64_t v9 = std::string::insert(&v17, 0, "unable to get symbol from section ");
      std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v10;
      v9->__r_.__value_.__l.__size_ = 0;
      v9->__r_.__value_.__r.__words[2] = 0;
      v9->__r_.__value_.__r.__words[0] = 0;
      unint64_t v11 = std::string::append(&v18, ": invalid symbol index (");
      std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      std::string::size_type v20 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      v21[0] = __p;
      v21[2] = v8;
      __int16 v22 = 2052;
      unint64_t v23 = v21;
      BOOL v24 = ")";
      __int16 v25 = 770;
      operator new();
    }
    unint64_t v15 = &v26[2 * a3];
    char v16 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v16;
  *(void *)a4 = v15;
  if (v14)
  {
    uint64_t result = v26;
    unint64_t v26 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSegmentContents@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(unsigned int *)(a2 + 4);
  uint64_t v5 = *(unsigned int *)(a2 + 16);
  if (__CFADD__(v4, v5)) {
    sub_1CCC2AAA0();
  }
  if (result[1] < (unint64_t)(v5 + v4)) {
    sub_1CCC2AAA0();
  }
  uint64_t v6 = *result + v4;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v6;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v5;
  return result;
}

void sub_1CCC2AAA0()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::program_headers();
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::decodeBBAddrMap(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::getSectionContents(a1, a2, (uint64_t)&v65);
  if (v67)
  {
    uint64_t v33 = v65;
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v33;
  }
  else
  {
    BOOL v5 = *(unsigned char *)(*a1 + 5) == 1;
    v46[0] = v65;
    v46[1] = v66;
    BOOL v47 = v5;
    unsigned __int8 v48 = 4;
    long long v44 = 0uLL;
    uint64_t v45 = 0;
    unsigned long long v43 = 0uLL;
    uint64_t v35 = v66;
    if (v66)
    {
      do
      {
        unsigned int Unsigned = llvm::DataExtractor::getUnsigned(v46, (unint64_t *)&v43, v48, (void *)&v43 + 1);
        uint64_t v64 = v43;
        unint64_t ULEB128 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
        unsigned int v38 = ULEB128;
        if (HIDWORD(ULEB128))
        {
          v49[0] = "ULEB128 value at offset 0x";
          char v50 = &v64;
          __int16 v51 = 3587;
          v52[0] = v49;
          std::string::size_type v53 = " exceeds UINT32_MAX (0x";
          __int16 v54 = 770;
          v55[0] = v52;
          p_unint64_t ULEB128 = &ULEB128;
          __int16 v57 = 3586;
          unint64_t v58 = (unint64_t)v55;
          uint64_t v60 = ")";
          __int16 v62 = 770;
          operator new();
        }
        unsigned int v6 = 0;
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        while (!*((void *)&v43 + 1) && v6 < v38)
        {
          uint64_t v64 = v43;
          unint64_t v11 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v11;
          unsigned int v39 = v6;
          if (HIDWORD(v11))
          {
            v49[0] = "ULEB128 value at offset 0x";
            char v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            std::string::size_type v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            unint64_t v58 = (unint64_t)v55;
            uint64_t v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v12 = v11;
          uint64_t v64 = v43;
          unint64_t v13 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v13;
          if (HIDWORD(v13))
          {
            v49[0] = "ULEB128 value at offset 0x";
            char v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            std::string::size_type v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            unint64_t v58 = (unint64_t)v55;
            uint64_t v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v14 = v13;
          uint64_t v64 = v43;
          unint64_t v15 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v15;
          if (HIDWORD(v15))
          {
            v49[0] = "ULEB128 value at offset 0x";
            char v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            std::string::size_type v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            unint64_t v58 = (unint64_t)v55;
            uint64_t v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v16 = v14;
          unsigned int v17 = (v15 >> 1) & 1;
          char v18 = v15 & 1;
          unsigned int v19 = (v15 >> 2) & 1;
          unsigned int v20 = (v15 >> 3) & 1;
          if (v8 >= v7)
          {
            unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 2) + 1;
            if (v23 > 0x1555555555555555) {
              abort();
            }
            if (0x5555555555555556 * ((v7 - v9) >> 2) > v23) {
              unint64_t v23 = 0x5555555555555556 * ((v7 - v9) >> 2);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v7 - v9) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
              unint64_t v24 = 0x1555555555555555;
            }
            else {
              unint64_t v24 = v23;
            }
            if (v24)
            {
              if (v24 > 0x1555555555555555) {
                sub_1CB833614();
              }
              unsigned int v25 = (v15 >> 3) & 1;
              int v26 = v16;
              unint64_t v37 = v24;
              unint64_t v27 = (char *)operator new(12 * v24);
              unint64_t v24 = v37;
              int v16 = v26;
              LOBYTE(v20) = v25;
            }
            else
            {
              unint64_t v27 = 0;
            }
            char v28 = &v27[4 * ((v8 - v9) >> 2)];
            *(_DWORD *)char v28 = v12;
            *((_DWORD *)v28 + 1) = v16;
            v28[8] = v18;
            v28[9] = v17;
            v28[10] = v19;
            v28[11] = v20;
            if (v8 == v9)
            {
              uint64_t v9 = &v27[4 * ((v8 - v9) >> 2)];
              unsigned int v22 = v39;
            }
            else
            {
              uint64_t v29 = &v27[4 * ((v8 - v9) >> 2)];
              unsigned int v22 = v39;
              do
              {
                uint64_t v30 = *(void *)(v8 - 12);
                v8 -= 12;
                int v31 = *((_DWORD *)v8 + 2);
                *(void *)(v29 - 12) = v30;
                v29 -= 12;
                *((_DWORD *)v29 + 2) = v31;
              }
              while (v8 != v9);
              uint64_t v8 = v9;
              uint64_t v9 = v29;
            }
            uint64_t v7 = &v27[12 * v24];
            int v21 = v28 + 12;
            if (v8) {
              operator delete(v8);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v8 = v12;
            *((_DWORD *)v8 + 1) = v16;
            v8[8] = v18;
            v8[9] = (v15 & 2) != 0;
            v8[10] = (v15 & 4) != 0;
            int v21 = v8 + 12;
            v8[11] = (v15 & 8) != 0;
            unsigned int v22 = v39;
          }
          unsigned int v6 = v22 + 1;
          uint64_t v8 = v21;
        }
        unint64_t v58 = Unsigned;
        uint64_t v60 = 0;
        uint64_t v61 = 0;
        std::string::size_type v59 = 0;
        sub_1CCC40DEC(&v59, v9, (uint64_t)v8, 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 2));
        sub_1CCC2B418((void **)&v44, (uint64_t)&v58);
        if (v59) {
          operator delete(v59);
        }
        if (v9) {
          operator delete(v9);
        }
        int v32 = (char *)*((void *)&v43 + 1);
      }
      while (v43 < (unint64_t)v35);
    }
    else
    {
      int v32 = 0;
    }
    if (v32)
    {
      uint64_t v40 = 0;
      uint64_t v41 = v32;
      *((void *)&v43 + 1) = 0;
      sub_1CD5E5368(&v41, &v40, &v42);
      *(unsigned char *)(a3 + 24) |= 1u;
      *(void *)a3 = v42;
      uint64_t v42 = 0;
      if (v40) {
        (*(void (**)(char *))(*(void *)v40 + 8))(v40);
      }
      if (v41) {
        (*(void (**)(char *))(*(void *)v41 + 8))(v41);
      }
    }
    else
    {
      *(unsigned char *)(a3 + 24) &= ~1u;
      *(_OWORD *)a3 = v44;
      *(void *)(a3 + ++*(_DWORD *)(this + 16) = v45;
      long long v44 = 0uLL;
      uint64_t v45 = 0;
    }
    if (*((void *)&v43 + 1)) {
      (*(void (**)(void))(**((void **)&v43 + 1) + 8))(*((void *)&v43 + 1));
    }
    unint64_t v58 = (unint64_t)&v44;
    sub_1CC4CDFC0((void ***)&v58);
    if (v67)
    {
      uint64_t v34 = v65;
      uint64_t v65 = 0;
      if (v34) {
        (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
      }
    }
  }
}

void sub_1CCC2B418(void **a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  unint64_t v5 = (unint64_t)a1[2];
  if ((unint64_t)v4 >= v5)
  {
    uint64_t v7 = ((char *)v4 - (unsigned char *)*a1) >> 5;
    unint64_t v8 = v7 + 1;
    if ((unint64_t)(v7 + 1) >> 59) {
      abort();
    }
    uint64_t v9 = v5 - (void)*a1;
    if (v9 >> 4 > v8) {
      unint64_t v8 = v9 >> 4;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10 >> 59) {
      sub_1CB833614();
    }
    unint64_t v11 = (char *)operator new(32 * v10);
    int v12 = &v11[32 * v7];
    unint64_t v13 = &v11[32 * v10];
    *(void *)int v12 = *(void *)a2;
    *(_OWORD *)(v12 + ++*(_DWORD *)(this + 8) = *(_OWORD *)(a2 + 8);
    *((void *)v12 + 3) = *(void *)(a2 + 24);
    unsigned int v6 = v12 + 32;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
    *(void *)(a2 + ++*(_DWORD *)(this + 16) = 0;
    *(void *)(a2 + 24) = 0;
    int v14 = (char *)*a1;
    unint64_t v15 = (char *)a1[1];
    if (v15 == *a1)
    {
      *a1 = v12;
      a1[1] = v6;
      a1[2] = v13;
    }
    else
    {
      uint64_t v16 = 0;
      do
      {
        unsigned int v17 = &v12[v16];
        char v18 = &v15[v16];
        *((void *)v17 - 4) = *(void *)&v15[v16 - 32];
        *((void *)v17 - 3) = 0;
        *((void *)v17 - 2) = 0;
        *((void *)v17 - 1) = 0;
        *(_OWORD *)(v17 - 24) = *(_OWORD *)&v15[v16 - 24];
        *((void *)v17 - 1) = *(void *)&v15[v16 - 8];
        *((void *)v18 - 3) = 0;
        *((void *)v18 - 2) = 0;
        *((void *)v18 - 1) = 0;
        v16 -= 32;
      }
      while (&v15[v16] != v14);
      unint64_t v15 = (char *)*a1;
      unsigned int v19 = (char *)a1[1];
      *a1 = &v12[v16];
      a1[1] = v6;
      a1[2] = v13;
      while (v19 != v15)
      {
        unsigned int v20 = (void *)*((void *)v19 - 3);
        if (v20)
        {
          *((void *)v19 - 2) = v20;
          operator delete(v20);
        }
        v19 -= 32;
      }
    }
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    void *v4 = *(void *)a2;
    v4[1] = 0;
    void v4[2] = 0;
    v4[3] = 0;
    *(_OWORD *)(v4 + 1) = *(_OWORD *)(a2 + 8);
    v4[3] = *(void *)(a2 + 24);
    unsigned int v6 = v4 + 4;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
    *(void *)(a2 + ++*(_DWORD *)(this + 16) = 0;
    *(void *)(a2 + 24) = 0;
  }
  a1[1] = v6;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::base(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::end(void *a1)
{
  return *a1 + a1[1];
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getBufSize(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::ELFFile(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getHeader(uint64_t a1)
{
  return *(void *)a1;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getVersionDefinitions(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getLinkAsStrtab(a1, a2, (uint64_t)v76);
  if (v77)
  {
    uint64_t v6 = v76[0];
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
    return;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionContents(a1, a2, (uint64_t)v74);
  if (v75)
  {
    sub_1CCC2C378(&v67, a1, a2);
    char v28 = std::string::insert(&v67, 0, "cannot read content of ");
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v68.__r_.__value_.__l.__data_ = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v68.__r_.__value_.__r.__words[2] = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    uint64_t v30 = std::string::append(&v68, ": ");
    uint64_t v31 = 0;
    std::string::size_type v32 = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v32;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    if (v75)
    {
      uint64_t v31 = v74[0];
      v74[0] = 0;
    }
    uint64_t v65 = v31;
    sub_1CD4FB504(&v65, &v66);
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v33 = &v66;
    }
    else {
      uint64_t v33 = (std::string *)v66.__r_.__value_.__r.__words[0];
    }
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v66.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v66.__r_.__value_.__l.__size_;
    }
    uint64_t v35 = std::string::append(&__p, (const std::string::value_type *)v33, size);
    std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v71 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    *(void *)&v71[16] = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    LOWORD(v70) = 260;
    v69[0] = v71;
    operator new();
  }
  uint64_t v7 = (unsigned __int16 *)v74[0];
  unint64_t v63 = v74[0] + v74[1];
  uint64_t v64 = v74[0];
  v69[0] = &v63;
  v69[1] = a1;
  v69[2] = a2;
  v69[3] = &v64;
  std::string::size_type v70 = v76;
  memset(&v68, 0, sizeof(v68));
  if (!*(_DWORD *)(a2 + 28))
  {
    std::string::size_type v22 = 0;
    char v8 = *(unsigned char *)(a3 + 24);
    long long v21 = 0uLL;
    goto LABEL_34;
  }
  char v8 = *(unsigned char *)(a3 + 24);
  unsigned int v9 = 1;
  while (1)
  {
    if ((unint64_t)(v7 + 10) > v63)
    {
      sub_1CCC2C378(&v60, a1, a2);
      unint64_t v37 = std::string::insert(&v60, 0, "invalid ");
      std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      unsigned int v39 = std::string::append(&v66, ": version definition ");
      std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v67;
      __p.__r_.__value_.__r.__words[2] = v9;
      __int16 v62 = 2052;
      uint64_t v41 = " goes past the end of the section";
      goto LABEL_49;
    }
    if ((v7 & 3) != 0)
    {
      sub_1CCC2C378(&v66, a1, a2);
      uint64_t v42 = std::string::insert(&v66, 0, "invalid ");
      std::string::size_type v43 = v42->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v43;
      v42->__r_.__value_.__l.__size_ = 0;
      v42->__r_.__value_.__r.__words[2] = 0;
      v42->__r_.__value_.__r.__words[0] = 0;
      long long v44 = std::string::append(&v67, ": found a misaligned version definition entry at offset 0x");
      std::string::size_type v45 = v44->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v45;
      v44->__r_.__value_.__l.__size_ = 0;
      v44->__r_.__value_.__r.__words[2] = 0;
      v44->__r_.__value_.__r.__words[0] = 0;
      v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v7 - v64;
      unint64_t v27 = &v60;
LABEL_36:
      *(void *)uint64_t v71 = &__p;
      *(void *)&v71[16] = v27;
      __int16 v73 = 3588;
      operator new();
    }
    unsigned int v10 = *v7;
    if (v10 != 256)
    {
      std::string::size_type v46 = __rev16(v10);
      sub_1CCC2C378(&v60, a1, a2);
      BOOL v47 = std::string::insert(&v60, 0, "unable to dump ");
      std::string::size_type v48 = v47->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v48;
      v47->__r_.__value_.__l.__size_ = 0;
      v47->__r_.__value_.__r.__words[2] = 0;
      v47->__r_.__value_.__r.__words[0] = 0;
      unint64_t v49 = std::string::append(&v66, ": version ");
      std::string::size_type v50 = v49->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v50;
      v49->__r_.__value_.__l.__size_ = 0;
      v49->__r_.__value_.__r.__words[2] = 0;
      v49->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v67;
      __p.__r_.__value_.__r.__words[2] = v46;
      __int16 v62 = 2052;
      uint64_t v41 = " is not yet supported";
LABEL_49:
      *(void *)uint64_t v71 = &__p;
      *(void *)&v71[16] = v41;
      __int16 v73 = 770;
      operator new();
    }
    unint64_t v11 = sub_1CCC25678((uint64_t)&v68, v68.__r_.__value_.__l.__size_);
    *(_DWORD *)unint64_t v11 = v7 - v64;
    *((_DWORD *)v11 + 1) = bswap32(*v7) >> 16;
    *((_DWORD *)v11 + 2) = bswap32(v7[1]) >> 16;
    *((_DWORD *)v11 + 3) = bswap32(v7[2]) >> 16;
    *((_DWORD *)v11 + 4) = bswap32(v7[3]) >> 16;
    *((_DWORD *)v11 + 5) = bswap32(*((_DWORD *)v7 + 2));
    v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v7 + bswap32(*((_DWORD *)v7 + 3));
    if (v7[3]) {
      break;
    }
LABEL_31:
    uint64_t v7 = (unsigned __int16 *)((char *)v7 + bswap32(*((_DWORD *)v7 + 4)));
    if (++v9 > bswap32(*(_DWORD *)(a2 + 28)))
    {
      long long v21 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
      std::string::size_type v22 = v68.__r_.__value_.__r.__words[2];
LABEL_34:
      *(unsigned char *)(a3 + 24) = v8 & 0xFE;
      *(_OWORD *)a3 = v21;
      *(void *)(a3 + ++*(_DWORD *)(this + 16) = v22;
      goto LABEL_58;
    }
  }
  int v12 = v11;
  int v13 = 0;
  __int16 v57 = (unint64_t *)(v11 + 3);
  unint64_t v58 = (std::string *)((char *)v11 + 24);
  while (1)
  {
    if ((v60.__r_.__value_.__s.__data_[0] & 3) != 0)
    {
      sub_1CCC2C378(&v66, a1, a2);
      unint64_t v23 = std::string::insert(&v66, 0, "invalid ");
      std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      unsigned int v25 = std::string::append(&v67, ": found a misaligned auxiliary entry at offset 0x");
      std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      std::string::size_type v59 = v60.__r_.__value_.__r.__words[0] - v64;
      unint64_t v27 = (std::string *)&v59;
      goto LABEL_36;
    }
    sub_1CCC2C454((uint64_t)v69, (unsigned int **)&v60, v9, (uint64_t)v71);
    char v14 = v73;
    if (v73)
    {
      uint64_t v18 = *(void *)v71;
      *(void *)uint64_t v71 = 0;
      v8 |= 1u;
      *(unsigned char *)(a3 + 24) = v8;
      *(void *)a3 = v18;
    }
    else if (v13)
    {
      unint64_t v15 = *((void *)v12 + 7);
      if (v15 >= *((void *)v12 + 8))
      {
        unsigned int v19 = sub_1CCC3F408(v57, (uint64_t)v71);
      }
      else
      {
        *(_DWORD *)unint64_t v15 = *(_DWORD *)v71;
        uint64_t v16 = (_OWORD *)(v15 + 8);
        if (SHIBYTE(v72) < 0)
        {
          sub_1CB8BDF7C((uint64_t)v16, *(const void **)&v71[8], *(unint64_t *)&v71[16]);
        }
        else
        {
          long long v17 = *(_OWORD *)&v71[8];
          *(void *)(v15 + 24) = v72;
          *uint64_t v16 = v17;
        }
        unsigned int v19 = (char *)(v15 + 32);
      }
      *((void *)v12 + 7) = v19;
    }
    else
    {
      std::string::operator=(v58, (const std::string *)&v71[8]);
    }
    if (v73)
    {
      uint64_t v20 = *(void *)v71;
      *(void *)uint64_t v71 = 0;
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
      }
    }
    else if (SHIBYTE(v72) < 0)
    {
      operator delete(*(void **)&v71[8]);
    }
    if (v14) {
      break;
    }
    if (++v13 >= bswap32(v7[3]) >> 16) {
      goto LABEL_31;
    }
  }
  std::string::size_type v51 = v68.__r_.__value_.__r.__words[0];
  if (v68.__r_.__value_.__r.__words[0])
  {
    uint64_t v52 = (void *)v68.__r_.__value_.__r.__words[0];
    if (v68.__r_.__value_.__l.__size_ != v68.__r_.__value_.__r.__words[0])
    {
      std::string::size_type v53 = v68.__r_.__value_.__l.__size_ - 24;
      do
      {
        *(void *)uint64_t v71 = v53;
        sub_1CC1CB288((void ***)v71);
        if (*(char *)(v53 - 1) < 0) {
          operator delete(*(void **)(v53 - 24));
        }
        std::string::size_type v54 = v53 - 48;
        v53 -= 72;
      }
      while (v54 != v51);
      uint64_t v52 = (void *)v68.__r_.__value_.__r.__words[0];
    }
    v68.__r_.__value_.__l.__size_ = v51;
    operator delete(v52);
  }
LABEL_58:
  if (v75)
  {
    uint64_t v55 = v74[0];
    v74[0] = 0;
    if (v55) {
      (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
    }
  }
  if (v77)
  {
    uint64_t v56 = v76[0];
    v76[0] = 0;
    if (v56) {
      (*(void (**)(uint64_t))(*(void *)v56 + 8))(v56);
    }
  }
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getLinkAsStrtab(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSection(a1, bswap32(*(_DWORD *)(a2 + 24)), (uint64_t)&v36);
  if (v37)
  {
    sub_1CCC2C378(&v29, a1, a2);
    uint64_t v6 = std::string::insert(&v29, 0, "invalid section linked to ");
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    char v8 = std::string::append(&v30, ": ");
    uint64_t v9 = 0;
    std::string::size_type v10 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v10;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if (v37)
    {
      uint64_t v9 = v36;
      uint64_t v36 = 0;
    }
    uint64_t v27 = v9;
    sub_1CD4FB504(&v27, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    int v13 = std::string::append(&v31, (const std::string::value_type *)p_p, size);
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    long long v34 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    std::string::size_type v35 = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    std::string::size_type v32 = (std::string *)&v34;
    operator new();
  }
  std::string::size_type v32 = (std::string *)sub_1CCC27114;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getStringTable(a1, v36, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v32, (uint64_t)&v34);
  if (v35)
  {
    sub_1CCC2C378(&__p, a1, a2);
    uint64_t v16 = std::string::insert(&__p, 0, "invalid string table linked to ");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    uint64_t v18 = std::string::append(&v29, ": ");
    uint64_t v19 = 0;
    std::string::size_type v20 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v20;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if (v35)
    {
      uint64_t v19 = v34;
      *(void *)&long long v34 = 0;
    }
    uint64_t v25 = v19;
    sub_1CD4FB504(&v25, &v26);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v21 = &v26;
    }
    else {
      long long v21 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v22 = *((unsigned char *)&v26.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type v22 = v26.__r_.__value_.__l.__size_;
    }
    unint64_t v23 = std::string::append(&v30, (const std::string::value_type *)v21, v22);
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    std::string::size_type v32 = &v31;
    operator new();
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(_OWORD *)a3 = v34;
  if (v37)
  {
    uint64_t v15 = v36;
    uint64_t v36 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
}

void sub_1CCC2C378(void *a1, void *a2, uint64_t a3)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections(a2, (uint64_t)v13);
  uint64_t v6 = -858993459 * ((unint64_t)(a3 - v13[0]) >> 3);
  ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*a2 + 18)) >> 16), bswap32(*(_DWORD *)(a3 + 4)));
  __int16 v10 = 773;
  v9[0] = ELFSectionTypeName;
  v9[1] = v8;
  _OWORD v9[2] = " section with index ";
  v11[0] = v9;
  v11[2] = v6;
  __int16 v12 = 2050;
  llvm::Twine::str((llvm::Twine *)v11, a1);
}

void sub_1CCC2C454(uint64_t a1@<X0>, unsigned int **a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a2;
  if ((unint64_t)(*a2 + 2) > **(void **)a1)
  {
    sub_1CCC2C378(&v24, *(void **)(a1 + 8), *(void *)(a1 + 16));
    std::string::size_type v7 = std::string::insert(&v24, 0, "invalid ");
    std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    uint64_t v9 = std::string::append(&v32, ": version definition ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    *(void *)&__p[16] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    v26[0] = __p;
    unint64_t v27 = a3;
    __int16 v28 = 2052;
    long long __dst = v26;
    *((void *)&v30 + 1) = " refers to an auxiliary entry that goes past the end of the section";
    __int16 v31 = 770;
    operator new();
  }
  unint64_t v11 = (unsigned int *)((char *)v5 + bswap32(v5[1]));
  *a2 = v11;
  __int16 v12 = *(uint64_t **)(a1 + 32);
  int v13 = **(_DWORD **)(a1 + 24);
  unint64_t v14 = bswap32(*v5);
  unint64_t v15 = v12[1];
  size_t v16 = v15 - v14;
  if (v15 >= v14)
  {
    if (v16 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v19 = *v12;
    if (v16 >= 0x17)
    {
      uint64_t v21 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v21 = v16 | 7;
      }
      uint64_t v22 = v21 + 1;
      p_dst = (void **)operator new(v21 + 1);
      *(void *)&long long v30 = v16;
      *((void *)&v30 + 1) = v22 | 0x8000000000000000;
      long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v30) = v15 - v14;
      p_dst = &__dst;
      if (v15 == v14) {
        goto LABEL_13;
      }
    }
    memmove(p_dst, (const void *)(v19 + v14), v16);
LABEL_13:
    *((unsigned char *)p_dst + v++*(_DWORD *)(this + 16) = 0;
    std::string::size_type v17 = __dst;
    v32.__r_.__value_.__r.__words[0] = v30;
    *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7) = *(void *)((char *)&v30 + 7);
    char v18 = HIBYTE(v30);
    goto LABEL_14;
  }
  v26[0] = "<invalid vda_name: ";
  unint64_t v27 = v14;
  __int16 v28 = 2051;
  long long __dst = v26;
  *((void *)&v30 + 1) = ">";
  __int16 v31 = 770;
  llvm::Twine::str((llvm::Twine *)&__dst, __p);
  std::string::size_type v17 = *(void **)__p;
  v32.__r_.__value_.__r.__words[0] = *(void *)&__p[8];
  *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7) = *(void *)&__p[15];
  char v18 = __p[23];
LABEL_14:
  *(unsigned char *)(a4 + 32) &= ~1u;
  *(_DWORD *)a4 = v11 - v13;
  std::string::size_type v23 = v32.__r_.__value_.__r.__words[0];
  *(void *)(a4 + ++*(_DWORD *)(this + 8) = v17;
  *(void *)(a4 + ++*(_DWORD *)(this + 16) = v23;
  *(void *)(a4 + 23) = *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7);
  *(unsigned char *)(a4 + 31) = v18;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getVersionDependencies(void *a1@<X0>, uint64_t a2@<X1>, void (*a3)(void *__return_ptr, uint64_t, long long *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = a2;
  std::string::size_type v8 = a1;
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getLinkAsStrtab(a1, a2, (uint64_t)v96);
  if (v97)
  {
    uint64_t v38 = v96[0];
    v96[0] = 0;
    uint64_t v90 = v38;
    sub_1CD4FB504(&v90, &__p);
    __int16 v93 = 260;
    *(void *)&long long __dst = &__p;
    a3(v94, a4, &__dst);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v90) {
      (*(void (**)(uint64_t))(*(void *)v90 + 8))(v90);
    }
    uint64_t v39 = v94[0];
    if (v94[0])
    {
      *(unsigned char *)(a5 + 24) |= 1u;
      *(void *)a5 = v39;
      goto LABEL_67;
    }
    uint64_t v80 = 0;
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v10 = v96[1];
    uint64_t v80 = v96[0];
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionContents(v8, v7, (uint64_t)v94);
  if (v95)
  {
    sub_1CCC2C378(&v87, v8, v7);
    std::string::size_type v48 = std::string::insert(&v87, 0, "cannot read content of ");
    std::string::size_type v49 = v48->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
    v88.__r_.__value_.__r.__words[2] = v49;
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v50 = std::string::append(&v88, ": ");
    uint64_t v51 = 0;
    std::string::size_type v52 = v50->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v89.__r_.__value_.__l.__data_ = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v89.__r_.__value_.__r.__words[2] = v52;
    v50->__r_.__value_.__l.__size_ = 0;
    v50->__r_.__value_.__r.__words[2] = 0;
    v50->__r_.__value_.__r.__words[0] = 0;
    if (v95)
    {
      uint64_t v51 = v94[0];
      v94[0] = 0;
    }
    uint64_t v85 = v51;
    sub_1CD4FB504(&v85, &v86);
    if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v53 = &v86;
    }
    else {
      std::string::size_type v53 = (std::string *)v86.__r_.__value_.__r.__words[0];
    }
    if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v86.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v86.__r_.__value_.__l.__size_;
    }
    uint64_t v55 = std::string::append(&v89, (const std::string::value_type *)v53, size);
    std::string::size_type v56 = v55->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v56;
    v55->__r_.__value_.__l.__size_ = 0;
    v55->__r_.__value_.__r.__words[2] = 0;
    v55->__r_.__value_.__r.__words[0] = 0;
    __int16 v93 = 260;
    *(void *)&long long __dst = &__p;
    operator new();
  }
  uint64_t v11 = v94[0];
  long long v12 = 0uLL;
  memset(&v89, 0, sizeof(v89));
  if (*(_DWORD *)(v7 + 28))
  {
    unint64_t v13 = v94[0] + v94[1];
    unsigned int v14 = 1;
    unint64_t v15 = (unsigned __int16 *)v94[0];
    uint64_t v75 = v7;
    uint64_t v76 = a5;
    char v74 = v8;
    unint64_t v79 = v10;
    while ((unint64_t)(v15 + 10) <= v13)
    {
      if ((v15 & 3) != 0)
      {
        sub_1CCC2C378(&v87, v8, v7);
        __int16 v62 = std::string::insert(&v87, 0, "invalid ");
        std::string::size_type v63 = v62->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
        v88.__r_.__value_.__r.__words[2] = v63;
        v62->__r_.__value_.__l.__size_ = 0;
        v62->__r_.__value_.__r.__words[2] = 0;
        v62->__r_.__value_.__r.__words[0] = 0;
        uint64_t v64 = std::string::append(&v88, ": found a misaligned version dependency entry at offset 0x");
        std::string::size_type v65 = v64->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v65;
        v64->__r_.__value_.__l.__size_ = 0;
        v64->__r_.__value_.__r.__words[2] = 0;
        v64->__r_.__value_.__r.__words[0] = 0;
        v86.__r_.__value_.__r.__words[0] = (std::string::size_type)v15 - v11;
        *(void *)&long long __dst = &__p;
        uint64_t v92 = (const char *)&v86;
        __int16 v93 = 3588;
        operator new();
      }
      unsigned int v16 = *v15;
      if (v16 != 256)
      {
        std::string::size_type v66 = __rev16(v16);
        sub_1CCC2C378(&v86, v8, v7);
        std::string v67 = std::string::insert(&v86, 0, "unable to dump ");
        std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
        v87.__r_.__value_.__r.__words[2] = v68;
        v67->__r_.__value_.__l.__size_ = 0;
        v67->__r_.__value_.__r.__words[2] = 0;
        v67->__r_.__value_.__r.__words[0] = 0;
        uint64_t v69 = std::string::append(&v87, ": version ");
        std::string::size_type v70 = v69->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
        v88.__r_.__value_.__r.__words[2] = v70;
        v69->__r_.__value_.__l.__size_ = 0;
        v69->__r_.__value_.__r.__words[2] = 0;
        v69->__r_.__value_.__r.__words[0] = 0;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
        __p.__r_.__value_.__r.__words[2] = v66;
        __int16 v84 = 2052;
        uint64_t v61 = " is not yet supported";
LABEL_63:
        *(void *)&long long __dst = &__p;
        uint64_t v92 = v61;
        __int16 v93 = 770;
        operator new();
      }
      unsigned int v77 = v14;
      uint64_t v17 = sub_1CCC26774((uint64_t)&v89, (_OWORD *)v89.__r_.__value_.__l.__size_);
      *(_DWORD *)uint64_t v17 = bswap32(*v15) >> 16;
      *(_DWORD *)(v17 + 4) = bswap32(v15[1]) >> 16;
      *(_DWORD *)(v17 + ++*(_DWORD *)(this + 8) = v15 - v11;
      unint64_t v18 = bswap32(*((_DWORD *)v15 + 1));
      unint64_t v19 = v10 - v18;
      if (v10 <= v18)
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"<corrupt vn_file: ";
        unint64_t v73 = v73 & 0xFFFFFFFF00000000 | v18;
        __p.__r_.__value_.__r.__words[2] = v73;
        __int16 v84 = 2051;
        *(void *)&long long __dst = &__p;
        uint64_t v92 = ">";
        __int16 v93 = 770;
        llvm::Twine::str((llvm::Twine *)&__dst, &v88);
        uint64_t v21 = v17 + 16;
        uint64_t v22 = v17;
        if (*(char *)(v17 + 39) < 0) {
          operator delete(*(void **)v21);
        }
        std::string::size_type v23 = (const char *)v88.__r_.__value_.__r.__words[2];
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v88.__r_.__value_.__l.__data_;
      }
      else
      {
        if (v19 > 0x7FFFFFFFFFFFFFF7) {
LABEL_71:
        }
          abort();
        if (v19 >= 0x17)
        {
          uint64_t v24 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v24 = v19 | 7;
          }
          uint64_t v81 = v24 + 1;
          p_dst = (long long *)operator new(v24 + 1);
          *((void *)&__dst + 1) = v10 - v18;
          uint64_t v92 = (const char *)(v81 | 0x8000000000000000);
          *(void *)&long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v92) = v10 - v18;
          p_dst = &__dst;
        }
        memmove(p_dst, (const void *)(v80 + v18), v10 - v18);
        *((unsigned char *)p_dst + v19) = 0;
        uint64_t v22 = v17;
        uint64_t v21 = v17 + 16;
        if (*(char *)(v17 + 39) < 0) {
          operator delete(*(void **)v21);
        }
        *(_OWORD *)uint64_t v21 = __dst;
        std::string::size_type v23 = v92;
      }
      *(void *)(v21 + ++*(_DWORD *)(this + 16) = v23;
      if (v15[1])
      {
        unsigned int v25 = 0;
        std::string v26 = (char *)v15 + bswap32(*((_DWORD *)v15 + 2));
        __int16 v82 = (char **)(v22 + 40);
        uint64_t v78 = v22;
        do
        {
          if ((v26 & 3) != 0)
          {
            sub_1CCC2C378(&v87, v74, v75);
            std::string::size_type v40 = std::string::insert(&v87, 0, "invalid ");
            std::string::size_type v41 = v40->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
            v88.__r_.__value_.__r.__words[2] = v41;
            v40->__r_.__value_.__l.__size_ = 0;
            v40->__r_.__value_.__r.__words[2] = 0;
            v40->__r_.__value_.__r.__words[0] = 0;
            uint64_t v42 = std::string::append(&v88, ": found a misaligned auxiliary entry at offset 0x");
            std::string::size_type v43 = v42->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v43;
            v42->__r_.__value_.__l.__size_ = 0;
            v42->__r_.__value_.__r.__words[2] = 0;
            v42->__r_.__value_.__r.__words[0] = 0;
            v86.__r_.__value_.__r.__words[0] = (std::string::size_type)&v26[-v11];
            *(void *)&long long __dst = &__p;
            uint64_t v92 = (const char *)&v86;
            __int16 v93 = 3588;
            operator new();
          }
          if ((unint64_t)(v26 + 16) > v13)
          {
            sub_1CCC2C378(&v86, v74, v75);
            long long v44 = std::string::insert(&v86, 0, "invalid ");
            std::string::size_type v45 = v44->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
            v87.__r_.__value_.__r.__words[2] = v45;
            v44->__r_.__value_.__l.__size_ = 0;
            v44->__r_.__value_.__r.__words[2] = 0;
            v44->__r_.__value_.__r.__words[0] = 0;
            std::string::size_type v46 = std::string::append(&v87, ": version dependency ");
            std::string::size_type v47 = v46->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
            v88.__r_.__value_.__r.__words[2] = v47;
            v46->__r_.__value_.__l.__size_ = 0;
            v46->__r_.__value_.__r.__words[2] = 0;
            v46->__r_.__value_.__r.__words[0] = 0;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
            __p.__r_.__value_.__r.__words[2] = v77;
            __int16 v84 = 2052;
            *(void *)&long long __dst = &__p;
            uint64_t v92 = " refers to an auxiliary entry that goes past the end of the section";
            __int16 v93 = 770;
            operator new();
          }
          unint64_t v27 = (_DWORD *)sub_1CCC26958(v82, *(void *)(v22 + 48));
          __int16 v28 = v27;
          _DWORD *v27 = bswap32(*(_DWORD *)v26);
          v27[1] = bswap32(*((unsigned __int16 *)v26 + 2)) >> 16;
          v27[2] = bswap32(*((unsigned __int16 *)v26 + 3)) >> 16;
          v27[3] = v26 - v11;
          unint64_t v29 = bswap32(*((_DWORD *)v26 + 2));
          size_t v30 = v10 - v29;
          if (v10 <= v29)
          {
            MEMORY[0x1D25D9630](v27 + 4, "<corrupt>");
          }
          else
          {
            if (v30 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_71;
            }
            if (v30 >= 0x17)
            {
              uint64_t v32 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v30 | 7) != 0x17) {
                uint64_t v32 = v30 | 7;
              }
              uint64_t v33 = v11;
              uint64_t v34 = v32 + 1;
              __int16 v31 = (long long *)operator new(v32 + 1);
              unint64_t v35 = v34 | 0x8000000000000000;
              uint64_t v11 = v33;
              uint64_t v22 = v78;
              *((void *)&__dst + 1) = v30;
              uint64_t v92 = (const char *)v35;
              *(void *)&long long __dst = v31;
            }
            else
            {
              HIBYTE(v92) = v10 - v29;
              __int16 v31 = &__dst;
            }
            memmove(v31, (const void *)(v80 + v29), v30);
            *((unsigned char *)v31 + v30) = 0;
            uint64_t v36 = (void **)(v28 + 4);
            if (*((char *)v28 + 39) < 0) {
              operator delete(*v36);
            }
            *(_OWORD *)uint64_t v36 = __dst;
            *((void *)v28 + 4) = v92;
            unint64_t v10 = v79;
          }
          v26 += bswap32(*((_DWORD *)v26 + 3));
          ++v25;
        }
        while (v25 < bswap32(v15[1]) >> 16);
      }
      unint64_t v15 = (unsigned __int16 *)((char *)v15 + bswap32(*((_DWORD *)v15 + 3)));
      unsigned int v14 = v77 + 1;
      uint64_t v7 = v75;
      a5 = v76;
      std::string::size_type v8 = v74;
      if (v77 + 1 > bswap32(*(_DWORD *)(v75 + 28)))
      {
        long long v12 = *(_OWORD *)&v89.__r_.__value_.__l.__data_;
        std::string::size_type v37 = v89.__r_.__value_.__r.__words[2];
        goto LABEL_47;
      }
    }
    sub_1CCC2C378(&v86, v8, v7);
    __int16 v57 = std::string::insert(&v86, 0, "invalid ");
    std::string::size_type v58 = v57->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
    v87.__r_.__value_.__r.__words[2] = v58;
    v57->__r_.__value_.__l.__size_ = 0;
    v57->__r_.__value_.__r.__words[2] = 0;
    v57->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v59 = std::string::append(&v87, ": version dependency ");
    std::string::size_type v60 = v59->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
    v88.__r_.__value_.__r.__words[2] = v60;
    v59->__r_.__value_.__l.__size_ = 0;
    v59->__r_.__value_.__r.__words[2] = 0;
    v59->__r_.__value_.__r.__words[0] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
    __p.__r_.__value_.__r.__words[2] = v14;
    __int16 v84 = 2052;
    uint64_t v61 = " goes past the end of the section";
    goto LABEL_63;
  }
  std::string::size_type v37 = 0;
LABEL_47:
  *(unsigned char *)(a5 + 24) &= ~1u;
  *(_OWORD *)a5 = v12;
  *(void *)(a5 + ++*(_DWORD *)(this + 16) = v37;
  if (v95)
  {
    uint64_t v71 = v94[0];
    v94[0] = 0;
    if (v71) {
      (*(void (**)(uint64_t))(*(void *)v71 + 8))(v71);
    }
  }
LABEL_67:
  if (v97)
  {
    uint64_t v72 = v96[0];
    v96[0] = 0;
    if (v72) {
      (*(void (**)(uint64_t))(*(void *)v72 + 8))(v72);
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getStringTableForSymtab@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections(a1, (uint64_t)&v5);
  if ((v6 & 1) == 0) {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getStringTableForSymtab();
  }
  uint64_t v4 = v5;
  *(unsigned char *)(a2 + 16) |= 1u;
  *(void *)a2 = v4;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  unsigned int v4 = *(_DWORD *)(*result + 32);
  if (v4)
  {
    unsigned int v5 = *(unsigned __int16 *)(v3 + 46);
    if (v5 != 10240)
    {
      unsigned int v14 = "invalid e_shentsize in ELF header: ";
      unint64_t v15 = (uint64_t *)__rev16(v5);
      __int16 v9 = 2307;
      goto LABEL_11;
    }
    uint64_t v6 = bswap32(v4);
    unint64_t v7 = result[1];
    if (v6 > 0xFFFFFFD7 || v6 + 40 > v7)
    {
      uint64_t v13 = v6;
      unsigned int v14 = "section header table goes past the end of the file: e_shoff = 0x";
      unint64_t v15 = &v13;
      __int16 v9 = 3587;
      goto LABEL_11;
    }
    uint64_t v10 = v3 + v6;
    unsigned int v11 = *(unsigned __int16 *)(v3 + 48);
    if (v11) {
      unsigned int v12 = __rev16(v11);
    }
    else {
      unsigned int v12 = bswap32(*(_DWORD *)(v10 + 20));
    }
    if (v6 + 40 * (unint64_t)v12 > v7)
    {
      unsigned int v14 = "section table goes past the end of file";
      __int16 v9 = 259;
LABEL_11:
      __int16 v16 = v9;
      operator new();
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = v10;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = v12;
  }
  else
  {
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = 0;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getStringTableForSymtab(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6 != 0x2000000 && v6 != 184549376)
  {
    unsigned int v12 = "invalid sh_type for symbol table, expected SHT_SYMTAB or SHT_DYNSYM";
    __int16 v14 = 259;
    operator new();
  }
  sub_1CD6CA180(a3, a4, bswap32(*(_DWORD *)(a2 + 24)), (uint64_t)&v12);
  __int16 v9 = v12;
  if (v13)
  {
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v9;
  }
  else
  {
    unsigned int v11 = sub_1CCC27114;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getStringTable(a1, (uint64_t)v12, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v11, a5);
    if (v13)
    {
      uint64_t v10 = v12;
      unsigned int v12 = 0;
      if (v10) {
        (*(void (**)(const char *))(*(void *)v10 + 8))(v10);
      }
    }
  }
}

llvm::object *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getDynSymtabSize@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t result = (llvm::object *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections(a1, (uint64_t)&v21);
  unsigned int v4 = v21;
  if (v23)
  {
    uint64_t v21 = 0;
    char v7 = *(unsigned char *)(a2 + 8) | 1;
  }
  else
  {
    if (!v22) {
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::dynamicEntries();
    }
    unsigned int v5 = v21 + 9;
    uint64_t v6 = 40 * v22;
    while (*(v5 - 8) != 184549376)
    {
      v5 += 10;
      v6 -= 40;
      if (!v6)
      {
        *(unsigned char *)(a2 + 8) &= ~1u;
        *(void *)a2 = 0;
        goto LABEL_12;
      }
    }
    unsigned int v8 = bswap32(*(v5 - 4));
    unsigned int v9 = bswap32(*v5);
    unsigned int v4 = (unsigned int *)(v8 / v9);
    if (v8 % v9)
    {
      atomic_ullong v10 = llvm::object::object_category(result);
      uint64_t v11 = bswap32(*(v5 - 4));
      v13[0] = "SHT_DYNSYM section has sh_size (";
      _OWORD v13[2] = v11;
      __int16 v14 = 2051;
      v15[0] = v13;
      void v15[2] = ") % sh_entsize (";
      __int16 v16 = 770;
      uint64_t v12 = bswap32(*v5);
      v17[0] = v15;
      void v17[2] = v12;
      __int16 v18 = 2050;
      v19[0] = v17;
      void v19[2] = ") that is not 0";
      __int16 v20 = 770;
      sub_1CD4FF4BC(3, v10, (llvm::Twine *)v19);
    }
    char v7 = *(unsigned char *)(a2 + 8) & 0xFE;
  }
  *(unsigned char *)(a2 + ++*(_DWORD *)(this + 8) = v7;
  *(void *)a2 = v4;
LABEL_12:
  if (v23)
  {
    uint64_t result = (llvm::object *)v21;
    uint64_t v21 = 0;
    if (result) {
      return (llvm::object *)(*(uint64_t (**)(llvm::object *))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::dynamicEntries()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::program_headers();
}

{
  while (1)
    ;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::toMappedAddr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::program_headers();
}

const char *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getRelocationTypeName(uint64_t a1, unsigned int a2)
{
  return llvm::object::getELFRelocationTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*(void *)a1 + 18)) >> 16), a2);
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::isMipsELF64(uint64_t a1)
{
  return *(_WORD *)(*(void *)a1 + 18) == 2048 && *(unsigned char *)(*(void *)a1 + 4) == 2;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getRelativeRelocationType(uint64_t a1)
{
  return llvm::object::getELFRelativeRelocationType((llvm::object *)(bswap32(*(unsigned __int16 *)(*(void *)a1 + 18)) >> 16));
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getDynamicTagAsString(int a1@<W1>, int64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (a1 > 163)
  {
    switch(a1)
    {
      case 164:
        switch(a2)
        {
          case 1879048194:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1414287455;
            unsigned int v4 = "HEXAGON_PLT";
            goto LABEL_46;
          case 1879048193:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1380275807;
            unsigned int v4 = "HEXAGON_VER";
            goto LABEL_46;
          case 1879048192:
            unsigned int v8 = "HEXAGON_SYMSZ";
LABEL_23:
            *(unsigned char *)(a3 + 23) = 13;
            *(void *)a3 = *(void *)v8;
            *(void *)(a3 + 5) = *(void *)(v8 + 5);
            *(unsigned char *)(a3 + 13) = 0;
            return;
        }
        break;
      case 243:
        if (a2 == 1879048193)
        {
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "RISCV_VARIANT_CC";
LABEL_26:
          *(_OWORD *)a3 = *(_OWORD *)v6;
          *(unsigned char *)(a3 + ++*(_DWORD *)(this + 16) = 0;
          return;
        }
        break;
      case 183:
        switch(a2)
        {
          case 1879048197:
            *(unsigned char *)(a3 + 23) = 19;
            *(_DWORD *)(a3 + 15) = 1396920415;
            uint64_t v11 = "AARCH64_VARIANT_PCS";
LABEL_41:
            *(_OWORD *)a3 = *(_OWORD *)v11;
            *(unsigned char *)(a3 + 19) = 0;
            return;
          case 1879048195:
            unsigned int v5 = "AARCH64_PAC_PLT";
            goto LABEL_43;
          case 1879048193:
            unsigned int v5 = "AARCH64_BTI_PLT";
            goto LABEL_43;
        }
        break;
    }
  }
  else
  {
    if (a1 == 8)
    {
      switch(a2)
      {
        case 1879048193:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_RLD_VERSION";
          goto LABEL_26;
        case 1879048194:
          unsigned int v5 = "MIPS_TIME_STAMP";
          goto LABEL_43;
        case 1879048195:
          __int16 v16 = "MIPS_ICHECKSUM";
          goto LABEL_159;
        case 1879048196:
          unsigned int v8 = "MIPS_IVERSION";
          goto LABEL_23;
        case 1879048197:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 21319;
          __int16 v14 = "MIPS_FLAGS";
          goto LABEL_172;
        case 1879048198:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 83;
          uint64_t v24 = "MIPS_BASE_ADDRESS";
          goto LABEL_165;
        case 1879048199:
          *(unsigned char *)(a3 + 23) = 9;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 77;
          uint64_t v12 = "MIPS_MSYM";
          goto LABEL_126;
        case 1879048200:
          unsigned int v8 = "MIPS_CONFLICT";
          goto LABEL_23;
        case 1879048201:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1414744396;
          uint64_t v15 = "MIPS_LIBLIST";
          goto LABEL_157;
        case 1879048202:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_LOCAL_GOTNO";
          goto LABEL_26;
        case 1879048203:
          unsigned int v5 = "MIPS_CONFLICTNO";
          goto LABEL_43;
        case 1879048208:
          __int16 v16 = "MIPS_LIBLISTNO";
          goto LABEL_159;
        case 1879048209:
          unsigned int v8 = "MIPS_SYMTABNO";
          goto LABEL_23;
        case 1879048210:
          unsigned int v5 = "MIPS_UNREFEXTNO";
          goto LABEL_43;
        case 1879048211:
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1297699668;
          unsigned int v4 = "MIPS_GOTSYM";
          goto LABEL_46;
        case 1879048212:
          unsigned int v8 = "MIPS_HIPAGENO";
          goto LABEL_23;
        case 1879048214:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1346456927;
          uint64_t v15 = "MIPS_RLD_MAP";
          goto LABEL_157;
        case 1879048215:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_DELTA_CLASS";
          goto LABEL_26;
        case 1879048216:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1330536275;
          uint64_t v11 = "MIPS_DELTA_CLASS_NO";
          goto LABEL_41;
        case 1879048217:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1162038849;
          uint64_t v11 = "MIPS_DELTA_INSTANCE";
          goto LABEL_41;
        case 1879048218:
          unsigned int v25 = "MIPS_DELTA_INSTANCE_NO";
          goto LABEL_147;
        case 1879048219:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_DELTA_RELOC";
          goto LABEL_26;
        case 1879048220:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1330536259;
          uint64_t v11 = "MIPS_DELTA_RELOC_NO";
          goto LABEL_41;
        case 1879048221:
          __int16 v16 = "MIPS_DELTA_SYM";
          goto LABEL_159;
        case 1879048222:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 79;
          uint64_t v24 = "MIPS_DELTA_SYM_NO";
          goto LABEL_165;
        case 1879048224:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1297699667;
          uint64_t v11 = "MIPS_DELTA_CLASSSYM";
          goto LABEL_41;
        case 1879048225:
          unsigned int v25 = "MIPS_DELTA_CLASSSYM_NO";
LABEL_147:
          *(_OWORD *)a3 = *(_OWORD *)v25;
          *(void *)(a3 + 14) = *(void *)(v25 + 14);
          *(_WORD *)(a3 + 22) = 5632;
          return;
        case 1879048226:
          __int16 v16 = "MIPS_CXX_FLAGS";
          goto LABEL_159;
        case 1879048227:
          unsigned int v5 = "MIPS_PIXIE_INIT";
          goto LABEL_43;
        case 1879048228:
          unsigned int v5 = "MIPS_SYMBOL_LIB";
          goto LABEL_43;
        case 1879048229:
          std::string v26 = "MIPS_LOCALPAGE_GOTIDX";
          goto LABEL_155;
        case 1879048230:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 88;
          uint64_t v24 = "MIPS_LOCAL_GOTIDX";
          goto LABEL_165;
        case 1879048231:
          *(unsigned char *)(a3 + 23) = 18;
          strcpy((char *)a3, "MIPS_HIDDEN_GOTIDX");
          return;
        case 1879048232:
          std::string v26 = "MIPS_PROTECTED_GOTIDX";
LABEL_155:
          *(unsigned char *)(a3 + 23) = 21;
          *(_OWORD *)a3 = *(_OWORD *)v26;
          *(void *)(a3 + 13) = *(void *)(v26 + 13);
          *(unsigned char *)(a3 + 21) = 0;
          return;
        case 1879048233:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1397641033;
          uint64_t v15 = "MIPS_OPTIONS";
          goto LABEL_157;
        case 1879048234:
          __int16 v16 = "MIPS_INTERFACE";
          goto LABEL_159;
        case 1879048235:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 78;
          uint64_t v24 = "MIPS_DYNSTR_ALIGN";
          goto LABEL_165;
        case 1879048236:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1163544915;
          uint64_t v11 = "MIPS_INTERFACE_SIZE";
          goto LABEL_41;
        case 1879048237:
          unint64_t v27 = (char *)operator new(0x20uLL);
          *(void *)a3 = v27;
          *(_OWORD *)(a3 + ++*(_DWORD *)(this + 8) = xmmword_1CD96DBE0;
          strcpy(v27, "MIPS_RLD_TEXT_RESOLVE_ADDR");
          return;
        case 1879048238:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_PERF_SUFFIX";
          goto LABEL_26;
        case 1879048239:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 69;
          uint64_t v24 = "MIPS_COMPACT_SIZE";
LABEL_165:
          *(_OWORD *)a3 = *(_OWORD *)v24;
          return;
        case 1879048240:
          unsigned int v8 = "MIPS_GP_VALUE";
          goto LABEL_23;
        case 1879048241:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_AUX_DYNAMIC";
          goto LABEL_26;
        case 1879048242:
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414481748;
          unsigned int v4 = "MIPS_PLTGOT";
          goto LABEL_46;
        case 1879048244:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 21580;
          __int16 v14 = "MIPS_RWPLT";
          goto LABEL_172;
        case 1879048245:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_RLD_MAP_REL";
          goto LABEL_26;
        case 1879048246:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 18515;
          __int16 v14 = "MIPS_XHASH";
LABEL_172:
          *(void *)a3 = *(void *)v14;
          *(unsigned char *)(a3 + 10) = 0;
          break;
        default:
          goto LABEL_27;
      }
      return;
    }
    if (a1 == 20)
    {
      if (a2 == 1879048193)
      {
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1598246992;
        int v7 = 1414549343;
      }
      else
      {
        if (a2 != 1879048192) {
          goto LABEL_27;
        }
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1598246992;
        int v7 = 1414481759;
      }
LABEL_116:
      *(_DWORD *)(a3 + 3) = v7;
      *(unsigned char *)(a3 + 7) = 0;
      return;
    }
    if (a1 == 21 && a2 == 1879048192)
    {
      *(unsigned char *)(a3 + 23) = 11;
      *(_DWORD *)(a3 + 7) = 1263421772;
      unsigned int v4 = "PPC64_GLINK";
LABEL_46:
      *(void *)a3 = *(void *)v4;
      *(unsigned char *)(a3 + 11) = 0;
      return;
    }
  }
LABEL_27:
  if (a2 <= 1879039999)
  {
    switch(a2)
    {
      case 0:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1280070990;
        goto LABEL_113;
      case 1:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1145390414;
        __int16 v10 = 17477;
        goto LABEL_111;
      case 2:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x5A534C4552544C50;
        goto LABEL_98;
      case 3:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1196706896;
        __int16 v10 = 21583;
        goto LABEL_111;
      case 4:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1213415752;
        goto LABEL_113;
      case 5:
        *(unsigned char *)(a3 + 23) = 6;
        int v17 = 1414681683;
        goto LABEL_76;
      case 6:
        *(unsigned char *)(a3 + 23) = 6;
        int v17 = 1414355283;
LABEL_76:
        *(_DWORD *)a3 = v17;
        __int16 v10 = 16961;
        goto LABEL_111;
      case 7:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1095517522;
        goto LABEL_113;
      case 8:
        *(unsigned char *)(a3 + 23) = 6;
        int v18 = 1095517522;
        goto LABEL_110;
      case 9:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1095517522;
        unsigned __int16 v19 = 17729;
        goto LABEL_115;
      case 10:
        *(unsigned char *)(a3 + 23) = 5;
        int v20 = 1397904467;
        goto LABEL_89;
      case 11:
        *(unsigned char *)(a3 + 23) = 6;
        int v21 = 1162697043;
        goto LABEL_91;
      case 12:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1414090313;
        goto LABEL_113;
      case 13:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1229867334;
        goto LABEL_113;
      case 14:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1095651155;
        __int16 v10 = 17741;
        goto LABEL_111;
      case 15:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1413566546;
        __int16 v22 = 72;
        goto LABEL_105;
      case 16:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x43494C4F424D5953;
        goto LABEL_98;
      case 17:
        *(unsigned char *)(a3 + 23) = 3;
        *(_DWORD *)a3 = 4998482;
        return;
      case 18:
        *(unsigned char *)(a3 + 23) = 5;
        int v20 = 1397507410;
LABEL_89:
        *(_DWORD *)a3 = v20;
        __int16 v22 = 90;
        goto LABEL_105;
      case 19:
        *(unsigned char *)(a3 + 23) = 6;
        int v21 = 1162626386;
LABEL_91:
        *(_DWORD *)a3 = v21;
        __int16 v10 = 21582;
        goto LABEL_111;
      case 20:
        *(unsigned char *)(a3 + 23) = 6;
        int v23 = 1381256272;
        goto LABEL_96;
      case 21:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1430406468;
        __int16 v22 = 71;
        goto LABEL_105;
      case 22:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1415071060;
        int v7 = 1279611476;
        goto LABEL_116;
      case 23:
        *(unsigned char *)(a3 + 23) = 6;
        int v23 = 1380994378;
LABEL_96:
        *(_DWORD *)a3 = v23;
        __int16 v10 = 19525;
        goto LABEL_111;
      case 24:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x574F4E5F444E4942;
        goto LABEL_98;
      case 25:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 22849;
        __int16 v14 = "INIT_ARRAY";
        goto LABEL_172;
      case 26:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 22849;
        __int16 v14 = "FINI_ARRAY";
        goto LABEL_172;
      case 27:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1515411777;
        uint64_t v15 = "INIT_ARRAYSZ";
        goto LABEL_157;
      case 28:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1515411777;
        uint64_t v15 = "FINI_ARRAYSZ";
        goto LABEL_157;
      case 29:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1347310930;
        int v7 = 1213481296;
        goto LABEL_116;
      case 30:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1195461702;
        __int16 v22 = 83;
LABEL_105:
        *(_WORD *)(a3 + 4) = v22;
        return;
      case 31:
        goto LABEL_174;
      case 32:
        unsigned int v8 = "PREINIT_ARRAY";
        goto LABEL_23;
      case 33:
        unsigned int v5 = "PREINIT_ARRAYSZ";
        goto LABEL_43;
      case 34:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1480871496;
        uint64_t v15 = "SYMTAB_SHNDX";
        goto LABEL_157;
      case 35:
        *(unsigned char *)(a3 + 23) = 6;
        int v18 = 1380730194;
LABEL_110:
        *(_DWORD *)a3 = v18;
        __int16 v10 = 23123;
        goto LABEL_111;
      case 36:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1380730194;
        goto LABEL_113;
      case 37:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1380730194;
        unsigned __int16 v19 = 17746;
LABEL_115:
        int v7 = v19 | 0x544E0000;
        goto LABEL_116;
      default:
        switch(a2)
        {
          case 1610612751:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1279611487;
            unsigned int v4 = "ANDROID_REL";
            goto LABEL_46;
          case 1610612752:
            unsigned int v8 = "ANDROID_RELSZ";
            goto LABEL_23;
          case 1610612753:
            *(unsigned char *)(a3 + 23) = 12;
            *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1095517522;
            uint64_t v15 = "ANDROID_RELA";
            goto LABEL_157;
          case 1610612754:
            __int16 v16 = "ANDROID_RELASZ";
            goto LABEL_159;
          default:
            goto LABEL_174;
        }
    }
  }
  if (a2 <= 1879048175)
  {
    if (a2 > 1879047924)
    {
      if (a2 != 1879047925)
      {
        if (a2 == 1879047926)
        {
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414287455;
          unsigned int v4 = "TLSDESC_PLT";
          goto LABEL_46;
        }
        if (a2 == 1879047927)
        {
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414481759;
          unsigned int v4 = "TLSDESC_GOT";
          goto LABEL_46;
        }
        goto LABEL_174;
      }
      *(unsigned char *)(a3 + 23) = 8;
      uint64_t v13 = 0x485341485F554E47;
LABEL_98:
      *(void *)a3 = v13;
      *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = 0;
      return;
    }
    if (a2 == 1879040000)
    {
      *(unsigned char *)(a3 + 23) = 12;
      *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1380730194;
      uint64_t v15 = "ANDROID_RELR";
LABEL_157:
      *(void *)a3 = *(void *)v15;
      *(unsigned char *)(a3 + 12) = 0;
      return;
    }
    if (a2 == 1879040001)
    {
      __int16 v16 = "ANDROID_RELRSZ";
LABEL_159:
      *(unsigned char *)(a3 + 23) = 14;
      *(void *)a3 = *(void *)v16;
      *(void *)(a3 + 6) = *(void *)(v16 + 6);
      *(unsigned char *)(a3 + 14) = 0;
      return;
    }
    if (a2 != 1879040003) {
      goto LABEL_174;
    }
    unsigned int v5 = "ANDROID_RELRENT";
LABEL_43:
    *(unsigned char *)(a3 + 23) = 15;
    *(void *)a3 = *(void *)v5;
    *(void *)(a3 + 7) = *(void *)(v5 + 7);
    *(unsigned char *)(a3 + 15) = 0;
    return;
  }
  if (a2 <= 2147483644)
  {
    switch(a2)
    {
      case 1879048176:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1397900630;
        __int16 v10 = 19801;
        goto LABEL_111;
      case 1879048185:
        *(unsigned char *)(a3 + 23) = 9;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 84;
        uint64_t v12 = "RELACOUNT";
        goto LABEL_126;
      case 1879048186:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x544E554F434C4552;
        goto LABEL_98;
      case 1879048187:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1195461702;
        int v7 = 828330823;
        goto LABEL_116;
      case 1879048188:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1146242390;
        __int16 v10 = 17989;
        goto LABEL_111;
      case 1879048189:
        *(unsigned char *)(a3 + 23) = 9;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 77;
        uint64_t v12 = "VERDEFNUM";
        goto LABEL_126;
      case 1879048190:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1314014550;
        int v7 = 1145390414;
        goto LABEL_116;
      case 1879048191:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 19797;
        __int16 v14 = "VERNEEDNUM";
        goto LABEL_172;
      default:
        goto LABEL_174;
    }
  }
  if (a2 != 2147483645)
  {
    if (a2 == 2147483646)
    {
      *(unsigned char *)(a3 + 23) = 4;
      int v9 = 1145394005;
LABEL_113:
      *(_DWORD *)a3 = v9;
      *(unsigned char *)(a3 + 4) = 0;
      return;
    }
    if (a2 == 0x7FFFFFFF)
    {
      *(unsigned char *)(a3 + 23) = 6;
      *(_DWORD *)a3 = 1414285638;
      __int16 v10 = 21061;
LABEL_111:
      *(_WORD *)(a3 + 4) = v10;
      *(unsigned char *)(a3 + 6) = 0;
      return;
    }
LABEL_174:
    sub_1CD5E9F58(a2, 1, 0, &v30);
    __int16 v28 = std::string::insert(&v30, 0, "<unknown:>0x");
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)a3 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    *(void *)(a3 + ++*(_DWORD *)(this + 16) = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    return;
  }
  *(unsigned char *)(a3 + 23) = 9;
  *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 89;
  uint64_t v12 = "AUXILIARY";
LABEL_126:
  *(void *)a3 = *(void *)v12;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getDynamicTagAsString()
{
}

{
  while (1)
    ;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getRelocationSymbol@<X0>(void *result@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v4 = bswap32(*(_DWORD *)(a2 + 4));
  if (v4 > 0xFF) {
    return sub_1CD6CE4A0(result, a3, v4 >> 8, a4);
  }
  *(unsigned char *)(a4 + 8) &= ~1u;
  *(void *)a4 = 0;
  return result;
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::isMips64EL(uint64_t *a1)
{
  uint64_t v1 = *a1;
  return *(_WORD *)(*a1 + 18) == 2048 && *(unsigned char *)(v1 + 4) == 2 && *(unsigned char *)(v1 + 5) == 1;
}

char **llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::loadVersionMap@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v42 = &v44;
  uint64_t v43 = 0;
  __p[0] = 0;
  __p[1] = 0;
  char v40 = 0;
  unint64_t v39 = 0;
  char v41 = 1;
  sub_1CCC297E0((uint64_t)&v42, (unint64_t)__p);
  if (v41 && SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  char v40 = 0;
  unint64_t v39 = 0;
  char v41 = 1;
  sub_1CCC297E0((uint64_t)&v42, (unint64_t)__p);
  if (v41 && SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  if (a3)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getVersionDefinitions(a1, a3, (uint64_t)&v44);
    unsigned int v8 = v44;
    if (v46)
    {
      long long v44 = 0;
      *(unsigned char *)(a4 + 16) |= 1u;
      *(void *)a4 = v8;
      sub_1CCC3FEAC((uint64_t)&v44);
      return sub_1CCC3FDC0((char **)&v42);
    }
    unint64_t v35 = a1;
    int v9 = v45;
    if (v44 != v45)
    {
      __int16 v10 = v44 + 3;
      do
      {
        unsigned int v11 = *((_DWORD *)v10 - 3) & 0x7FFF;
        char v12 = *((unsigned char *)v10 + 23);
        BOOL v13 = v12 < 0;
        if (v12 >= 0) {
          __int16 v14 = v10;
        }
        else {
          __int16 v14 = *v10;
        }
        size_t v15 = v12 & 0x7F;
        if (v13) {
          size_t v16 = (size_t)v10[1];
        }
        else {
          size_t v16 = v15;
        }
        if (v43 <= v11) {
          sub_1CCC3EBD0((uint64_t)&v42, v11 + 1);
        }
        if (v16 > 0x7FFFFFFFFFFFFFF7) {
LABEL_68:
        }
          abort();
        if (v16 >= 0x17)
        {
          uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v16 | 7) != 0x17) {
            uint64_t v18 = v16 | 7;
          }
          uint64_t v19 = v18 + 1;
          int v17 = operator new(v18 + 1);
          __p[1] = (void *)v16;
          unint64_t v39 = v19 | 0x8000000000000000;
          __p[0] = v17;
        }
        else
        {
          HIBYTE(v39) = v16;
          int v17 = __p;
          if (!v16) {
            goto LABEL_27;
          }
        }
        memmove(v17, v14, v16);
LABEL_27:
        *((unsigned char *)v17 + v++*(_DWORD *)(this + 16) = 0;
        int v20 = (char *)&v42[5 * v11];
        int v21 = v20 + 32;
        if (v20[32])
        {
          if (v20[23] < 0) {
            operator delete(*(void **)v20);
          }
          *(_OWORD *)int v20 = *(_OWORD *)__p;
          *((void *)v20 + 2) = v39;
          int v21 = v20 + 24;
        }
        else
        {
          *(_OWORD *)int v20 = *(_OWORD *)__p;
          *((void *)v20 + 2) = v39;
          v20[24] = 1;
        }
        *int v21 = 1;
        __int16 v22 = v10 + 6;
        v10 += 9;
      }
      while (v22 != v9);
    }
    sub_1CCC3FEAC((uint64_t)&v44);
    a1 = v35;
  }
  if (a2)
  {
    __p[0] = sub_1CCC27114;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getVersionDependencies(a1, a2, (void (*)(void *__return_ptr, uint64_t, long long *))sub_1CD6D6140, (uint64_t)__p, (uint64_t)&v44);
    int v23 = v44;
    if ((v46 & 1) == 0)
    {
      uint64_t v36 = a4;
      std::string::size_type v37 = v45;
      if (v44 == v45) {
        goto LABEL_62;
      }
      while (1)
      {
        uint64_t v24 = (char *)v23[5];
        unsigned int v25 = (char *)v23[6];
        while (v24 != v25)
        {
          unsigned int v26 = *((_DWORD *)v24 + 2) & 0x7FFF;
          char v27 = v24[39];
          if (v27 >= 0) {
            __int16 v28 = v24 + 16;
          }
          else {
            __int16 v28 = (const void *)*((void *)v24 + 2);
          }
          if (v27 >= 0) {
            size_t v29 = v27 & 0x7F;
          }
          else {
            size_t v29 = *((void *)v24 + 3);
          }
          if (v43 <= v26) {
            sub_1CCC3EBD0((uint64_t)&v42, v26 + 1);
          }
          if (v29 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_68;
          }
          if (v29 >= 0x17)
          {
            uint64_t v31 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v29 | 7) != 0x17) {
              uint64_t v31 = v29 | 7;
            }
            uint64_t v32 = v31 + 1;
            std::string v30 = operator new(v31 + 1);
            __p[1] = (void *)v29;
            unint64_t v39 = v32 | 0x8000000000000000;
            __p[0] = v30;
LABEL_54:
            memmove(v30, v28, v29);
            goto LABEL_55;
          }
          HIBYTE(v39) = v29;
          std::string v30 = __p;
          if (v29) {
            goto LABEL_54;
          }
LABEL_55:
          *((unsigned char *)v30 + v29) = 0;
          uint64_t v33 = (char *)&v42[5 * v26];
          if (v33[32])
          {
            if (v33[23] < 0) {
              operator delete(*(void **)v33);
            }
            *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
            *((void *)v33 + 2) = v39;
            v33[24] = 0;
          }
          else
          {
            *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
            *((void *)v33 + 2) = v39;
            v33[24] = 0;
            v33[32] = 1;
          }
          v24 += 40;
        }
        v23 += 8;
        if (v23 == v37)
        {
LABEL_62:
          sub_1CCC3FF24((uint64_t)&v44);
          a4 = v36;
          goto LABEL_63;
        }
      }
    }
    long long v44 = 0;
    *(unsigned char *)(a4 + 16) |= 1u;
    *(void *)a4 = v23;
    sub_1CCC3FF24((uint64_t)&v44);
  }
  else
  {
LABEL_63:
    *(unsigned char *)(a4 + 16) &= ~1u;
    *(void *)a4 = a4 + 16;
    *(void *)(a4 + ++*(_DWORD *)(this + 8) = 0;
    if (v43) {
      sub_1CCC3FF9C(a4, (uint64_t)&v42);
    }
  }
  return sub_1CCC3FDC0((char **)&v42);
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::isLE(uint64_t a1)
{
  return *(unsigned char *)(*(void *)a1 + 5) == 1;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::program_headers@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  if (*(_WORD *)(*result + 44))
  {
    unsigned int v4 = *(unsigned __int16 *)(v3 + 42);
    if (v4 != 0x2000)
    {
      uint64_t v24 = "invalid e_phentsize: ";
      uint64_t v25 = __rev16(v4);
      __int16 v26 = 2307;
LABEL_8:
      operator new();
    }
    unsigned int v5 = 0x2000;
  }
  else
  {
    unsigned int v5 = *(unsigned __int16 *)(v3 + 42);
  }
  uint64_t v6 = __rev16(*(unsigned __int16 *)(*result + 44));
  uint64_t v7 = __rev16(v5);
  uint64_t v8 = bswap32(*(_DWORD *)(v3 + 28));
  unint64_t v9 = result[1];
  if (v8 + v7 * (unint64_t)v6 > v9)
  {
    uint64_t v10 = v8;
    unint64_t v11 = v9;
    v12[0] = "program headers are longer than binary of size ";
    uint64_t v12[2] = &v11;
    __int16 v13 = 2563;
    v14[0] = v12;
    unint64_t v14[2] = ": e_phoff = 0x";
    __int16 v15 = 770;
    v16[0] = v14;
    _OWORD v16[2] = &v10;
    __int16 v17 = 3586;
    v18[0] = v16;
    v18[2] = ", e_phnuuint64_t m = ";
    __int16 v19 = 770;
    v20[0] = v18;
    _OWORD v20[2] = v6;
    __int16 v21 = 2306;
    v22[0] = v20;
    v22[2] = ", e_phentstd::string::size_type size = ";
    __int16 v23 = 770;
    uint64_t v24 = (const char *)v22;
    uint64_t v25 = v7;
    __int16 v26 = 2306;
    goto LABEL_8;
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  *(void *)a2 = v3 + v8;
  *(void *)(a2 + ++*(_DWORD *)(this + 8) = v6;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::symbols@<X0>(void *result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    return sub_1CD6CE6A4(result, a2, a3);
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = 0;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = 0;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::decode_relrs(uint64_t a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, uint64_t **a4@<X8>)
{
  unsigned int v5 = *(unsigned __int16 *)(*(void *)a1 + 18);
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  if (a3)
  {
    uint64_t v6 = a2;
    unint64_t v35 = &a2[a3];
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    uint64_t v9 = llvm::object::getELFRelativeRelocationType((llvm::object *)__rev16(v5)) << 56;
    do
    {
      uint64_t v10 = *v6;
      unsigned int v11 = bswap32(v10);
      if (v11)
      {
        unsigned int v34 = v8;
        if (v11 >= 2)
        {
          do
          {
            if ((v11 & 2) != 0)
            {
              uint64_t v14 = bswap32(v8);
              unint64_t v15 = (unint64_t)a4[2];
              if ((unint64_t)v7 >= v15)
              {
                __int16 v17 = *a4;
                uint64_t v18 = v7 - *a4;
                unint64_t v19 = v18 + 1;
                if ((unint64_t)(v18 + 1) >> 61) {
                  goto LABEL_46;
                }
                uint64_t v20 = v15 - (void)v17;
                if (v20 >> 2 > v19) {
                  unint64_t v19 = v20 >> 2;
                }
                if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v21 = v19;
                }
                if (v21)
                {
                  if (v21 >> 61) {
                    goto LABEL_47;
                  }
                  __int16 v22 = (char *)operator new(8 * v21);
                }
                else
                {
                  __int16 v22 = 0;
                }
                __int16 v23 = (uint64_t *)&v22[8 * v18];
                uint64_t *v23 = v9 | v14;
                size_t v16 = v23 + 1;
                if (v7 != v17)
                {
                  do
                  {
                    uint64_t v24 = *--v7;
                    *--__int16 v23 = v24;
                  }
                  while (v7 != v17);
                  uint64_t v7 = *a4;
                }
                *a4 = v23;
                a4[1] = v16;
                a4[2] = (uint64_t *)&v22[8 * v21];
                if (v7) {
                  operator delete(v7);
                }
              }
              else
              {
                *uint64_t v7 = v9 | v14;
                size_t v16 = v7 + 1;
              }
              a4[1] = v16;
              uint64_t v7 = v16;
            }
            v8 += 4;
            BOOL v25 = v11 >= 4;
            v11 >>= 1;
          }
          while (v25);
        }
        unsigned int v8 = v34 + 124;
      }
      else
      {
        unint64_t v12 = (unint64_t)a4[2];
        if ((unint64_t)v7 >= v12)
        {
          __int16 v26 = *a4;
          uint64_t v27 = v7 - *a4;
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 61) {
LABEL_46:
          }
            abort();
          uint64_t v29 = v12 - (void)v26;
          if (v29 >> 2 > v28) {
            unint64_t v28 = v29 >> 2;
          }
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v28;
          }
          if (v30)
          {
            if (v30 >> 61) {
LABEL_47:
            }
              sub_1CB833614();
            uint64_t v31 = (char *)operator new(8 * v30);
          }
          else
          {
            uint64_t v31 = 0;
          }
          uint64_t v32 = (uint64_t *)&v31[8 * v27];
          *uint64_t v32 = v9 | v10;
          __int16 v13 = v32 + 1;
          if (v7 != v26)
          {
            do
            {
              uint64_t v33 = *--v7;
              *--uint64_t v32 = v33;
            }
            while (v7 != v26);
            uint64_t v7 = *a4;
          }
          *a4 = v32;
          a4[1] = v13;
          a4[2] = (uint64_t *)&v31[8 * v30];
          if (v7) {
            operator delete(v7);
          }
        }
        else
        {
          *uint64_t v7 = v9 | v10;
          __int16 v13 = v7 + 1;
        }
        a4[1] = v13;
        uint64_t v7 = v13;
        unsigned int v8 = v11 + 4;
      }
      ++v6;
    }
    while (v6 != v35);
  }
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::android_relas@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionContents(a1, a2, (uint64_t)&v52);
  uint64_t v6 = v52;
  if (v54)
  {
    std::string::size_type v52 = 0;
LABEL_12:
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
    goto LABEL_14;
  }
  if (v53 < 4 || *v52 != 65 || v52[1] != 80 || v52[2] != 83 || v52[3] != 50)
  {
    std::string::size_type v50 = "invalid packed relocation header";
    __int16 v51 = 259;
    operator new();
  }
  BOOL v7 = *(unsigned char *)(*a1 + 5) == 1;
  v47[0] = v52;
  v47[1] = v53;
  BOOL v48 = v7;
  char v49 = 4;
  unsigned int v8 = &v46;
  uint64_t v45 = 4;
  uint64_t v46 = 0;
  unint64_t SLEB128 = llvm::DataExtractor::getSLEB128(v47, &v45, &v46);
  uint64_t result = llvm::DataExtractor::getSLEB128(v47, &v45, &v46);
  uint64_t v6 = (unsigned char *)v46;
  if (v46) {
    goto LABEL_12;
  }
  uint64_t v10 = result;
  uint64_t v37 = a3;
  if (SLEB128)
  {
    if (SLEB128 > 0x1555555555555555) {
LABEL_74:
    }
      abort();
    unsigned int v11 = (unsigned int *)operator new(12 * SLEB128);
    unint64_t v12 = &v11[3 * SLEB128];
  }
  else
  {
    unsigned int v11 = 0;
    unint64_t v12 = 0;
  }
  uint64_t v13 = 0;
  uint64_t v14 = v11;
  do
  {
    if (!SLEB128)
    {
      *(unsigned char *)(v37 + 24) &= ~1u;
      *(void *)uint64_t v37 = v11;
      *(void *)(v37 + ++*(_DWORD *)(this + 8) = v14;
      *(void *)(v37 + ++*(_DWORD *)(this + 16) = v12;
      goto LABEL_72;
    }
    unint64_t v15 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    uint64_t v16 = v46;
    if (v46) {
      break;
    }
    unint64_t v17 = v15;
    BOOL v18 = SLEB128 >= v15;
    SLEB128 -= v15;
    if (!v18)
    {
      std::string::size_type v50 = "relocation group unexpectedly large";
      __int16 v51 = 259;
      operator new();
    }
    uint64_t v44 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    if ((v44 & 2) != 0) {
      uint64_t v43 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    }
    else {
      uint64_t v43 = 0;
    }
    if (v44) {
      unsigned int v42 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    }
    else {
      unsigned int v42 = 0;
    }
    uint64_t v41 = v44 & 0xC;
    if (v41 == 12) {
      v13 += llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    }
    v13 &= v44 << 60 >> 63;
    uint64_t v16 = v46;
    BOOL v19 = v46 == 0;
    if (!v46 && v17)
    {
      unint64_t v38 = SLEB128;
      uint64_t v20 = 0;
      unint64_t v40 = v17;
      do
      {
        uint64_t v21 = v43;
        if ((v44 & 2) == 0) {
          uint64_t v21 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
        }
        unsigned int v22 = v42;
        if ((v44 & 1) == 0) {
          unsigned int v22 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
        }
        if (v41 == 8) {
          v13 += llvm::DataExtractor::getSLEB128(v47, &v45, v8);
        }
        v10 += v21;
        unsigned int v23 = bswap32(v10);
        unsigned int v24 = bswap32(v22);
        unsigned int v25 = bswap32(v13);
        if (v14 >= v12)
        {
          uint64_t v39 = v13;
          uint64_t v27 = v10;
          unint64_t v28 = v8;
          unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (v14 - v11) + 1;
          if (v29 > 0x1555555555555555) {
            goto LABEL_74;
          }
          if (0x5555555555555556 * (v12 - v11) > v29) {
            unint64_t v29 = 0x5555555555555556 * (v12 - v11);
          }
          if (0xAAAAAAAAAAAAAAABLL * (v12 - v11) >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v30 = 0x1555555555555555;
          }
          else {
            unint64_t v30 = v29;
          }
          if (v30)
          {
            if (v30 > 0x1555555555555555) {
              sub_1CB833614();
            }
            uint64_t v31 = (char *)operator new(12 * v30);
          }
          else
          {
            uint64_t v31 = 0;
          }
          uint64_t v32 = (unsigned int *)&v31[4 * (v14 - v11)];
          *uint64_t v32 = v23;
          v32[1] = v24;
          v32[2] = v25;
          uint64_t v33 = v32;
          if (v14 == v11)
          {
            unint64_t v26 = v40;
          }
          else
          {
            unint64_t v26 = v40;
            do
            {
              uint64_t v34 = *(void *)(v14 - 3);
              v14 -= 3;
              unsigned int v35 = v14[2];
              *(void *)(v33 - 3) = v34;
              v33 -= 3;
              _OWORD v33[2] = v35;
            }
            while (v14 != v11);
          }
          unint64_t v12 = (unsigned int *)&v31[12 * v30];
          uint64_t v14 = v32 + 3;
          if (v11) {
            operator delete(v11);
          }
          unsigned int v11 = v33;
          unsigned int v8 = v28;
          uint64_t v10 = v27;
          uint64_t v13 = v39;
        }
        else
        {
          *uint64_t v14 = v23;
          v14[1] = v24;
          unint64_t v14[2] = v25;
          v14 += 3;
          unint64_t v26 = v40;
        }
        ++v20;
        uint64_t v16 = v46;
        BOOL v19 = v46 == 0;
        if (v46) {
          BOOL v36 = 1;
        }
        else {
          BOOL v36 = v20 == v26;
        }
      }
      while (!v36);
      unint64_t SLEB128 = v38;
    }
  }
  while (v19);
  uint64_t v46 = 0;
  *(unsigned char *)(v37 + 24) |= 1u;
  *(void *)uint64_t v37 = v16;
  if (v11) {
    operator delete(v11);
  }
LABEL_72:
  uint64_t result = v46;
  if (v46) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 8))(v46);
  }
LABEL_14:
  if (v54)
  {
    uint64_t result = (uint64_t)v52;
    std::string::size_type v52 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::notes_begin@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void **a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = bswap32(*(_DWORD *)(a2 + 4));
  uint64_t v7 = bswap32(*(_DWORD *)(a2 + 16));
  if (a1[1] < (unint64_t)(v7 + v6))
  {
    uint64_t v9 = v7;
    uint64_t v10 = v6;
    v11[0] = "invalid offset (0x";
    v11[2] = &v10;
    __int16 v12 = 3587;
    v13[0] = v11;
    _OWORD v13[2] = ") or size (0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    unint64_t v17 = v15;
    BOOL v18 = ")";
    __int16 v19 = 770;
    operator new();
  }
  uint64_t result = sub_1CCC417D8(a4, *a1 + v6, v7, a3);
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

{
  uint64_t v6;
  uint64_t v7;
  void *result;
  uint64_t v9;
  uint64_t v10;
  void v11[4];
  __int16 v12;
  void v13[4];
  __int16 v14;
  void v15[4];
  __int16 v16;
  void *v17;
  const char *v18;
  __int16 v19;

  uint64_t v6 = bswap32(*(_DWORD *)(a2 + 16));
  uint64_t v7 = bswap32(*(_DWORD *)(a2 + 20));
  if (a1[1] < (unint64_t)(v7 + v6))
  {
    uint64_t v9 = v7;
    uint64_t v10 = v6;
    v11[0] = "invalid offset (0x";
    v11[2] = &v10;
    __int16 v12 = 3587;
    v13[0] = v11;
    _OWORD v13[2] = ") or size (0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    unint64_t v17 = v15;
    BOOL v18 = ")";
    __int16 v19 = 770;
    operator new();
  }
  uint64_t result = sub_1CCC417D8(a4, *a1 + v6, v7, a3);
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::notes_end(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::notes()
{
}

{
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::notes_begin();
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSymbol@<X0>(void *a1@<X0>, unsigned int *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    unint64_t v26 = 0;
    unint64_t v27 = 0;
    uint64_t v8 = a3;
    char v28 = 0;
    goto LABEL_3;
  }
  uint64_t result = sub_1CD6CE6A4(a1, a2, (uint64_t)&v26);
  char v14 = v28;
  if (v28)
  {
    unint64_t v15 = v26;
    unint64_t v26 = 0;
    char v16 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    uint64_t v8 = a3;
    if (v27 <= a3)
    {
LABEL_3:
      sub_1CD6CD2F0(a1, (uint64_t)a2, (char *)&v17);
      uint64_t v9 = std::string::insert(&v17, 0, "unable to get symbol from section ");
      std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v10;
      v9->__r_.__value_.__l.__size_ = 0;
      v9->__r_.__value_.__r.__words[2] = 0;
      v9->__r_.__value_.__r.__words[0] = 0;
      unsigned int v11 = std::string::append(&v18, ": invalid symbol index (");
      std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      std::string::size_type v20 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      v21[0] = __p;
      v21[2] = v8;
      __int16 v22 = 2052;
      unsigned int v23 = v21;
      unsigned int v24 = ")";
      __int16 v25 = 770;
      operator new();
    }
    unint64_t v15 = &v26[2 * a3];
    char v16 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v16;
  *(void *)a4 = v15;
  if (v14)
  {
    uint64_t result = v26;
    unint64_t v26 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSegmentContents@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v4 = bswap32(*(_DWORD *)(a2 + 4));
  uint64_t v5 = bswap32(*(_DWORD *)(a2 + 16));
  if (__CFADD__(v4, v5)) {
    sub_1CCC310D4();
  }
  if (result[1] < (unint64_t)(v5 + v4)) {
    sub_1CCC310D4();
  }
  uint64_t v6 = *result + v4;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v6;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v5;
  return result;
}

void sub_1CCC310D4()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::program_headers();
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::decodeBBAddrMap(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::getSectionContents(a1, a2, (uint64_t)&v65);
  if (v67)
  {
    uint64_t v33 = v65;
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v33;
  }
  else
  {
    BOOL v5 = *(unsigned char *)(*a1 + 5) == 1;
    v46[0] = v65;
    v46[1] = v66;
    BOOL v47 = v5;
    unsigned __int8 v48 = 4;
    long long v44 = 0uLL;
    uint64_t v45 = 0;
    unsigned long long v43 = 0uLL;
    uint64_t v35 = v66;
    if (v66)
    {
      do
      {
        unsigned int Unsigned = llvm::DataExtractor::getUnsigned(v46, (unint64_t *)&v43, v48, (void *)&v43 + 1);
        uint64_t v64 = v43;
        unint64_t ULEB128 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
        unsigned int v38 = ULEB128;
        if (HIDWORD(ULEB128))
        {
          v49[0] = "ULEB128 value at offset 0x";
          std::string::size_type v50 = &v64;
          __int16 v51 = 3587;
          v52[0] = v49;
          unint64_t v53 = " exceeds UINT32_MAX (0x";
          __int16 v54 = 770;
          v55[0] = v52;
          p_unint64_t ULEB128 = &ULEB128;
          __int16 v57 = 3586;
          unint64_t v58 = (unint64_t)v55;
          std::string::size_type v60 = ")";
          __int16 v62 = 770;
          operator new();
        }
        unsigned int v6 = 0;
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        while (!*((void *)&v43 + 1) && v6 < v38)
        {
          uint64_t v64 = v43;
          unint64_t v11 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v11;
          unsigned int v39 = v6;
          if (HIDWORD(v11))
          {
            v49[0] = "ULEB128 value at offset 0x";
            std::string::size_type v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            unint64_t v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            unint64_t v58 = (unint64_t)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v12 = v11;
          uint64_t v64 = v43;
          unint64_t v13 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v13;
          if (HIDWORD(v13))
          {
            v49[0] = "ULEB128 value at offset 0x";
            std::string::size_type v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            unint64_t v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            unint64_t v58 = (unint64_t)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v14 = v13;
          uint64_t v64 = v43;
          unint64_t v15 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v15;
          if (HIDWORD(v15))
          {
            v49[0] = "ULEB128 value at offset 0x";
            std::string::size_type v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            unint64_t v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            unint64_t v58 = (unint64_t)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v16 = v14;
          unsigned int v17 = (v15 >> 1) & 1;
          char v18 = v15 & 1;
          unsigned int v19 = (v15 >> 2) & 1;
          unsigned int v20 = (v15 >> 3) & 1;
          if (v8 >= v7)
          {
            unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 2) + 1;
            if (v23 > 0x1555555555555555) {
              abort();
            }
            if (0x5555555555555556 * ((v7 - v9) >> 2) > v23) {
              unint64_t v23 = 0x5555555555555556 * ((v7 - v9) >> 2);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v7 - v9) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
              unint64_t v24 = 0x1555555555555555;
            }
            else {
              unint64_t v24 = v23;
            }
            if (v24)
            {
              if (v24 > 0x1555555555555555) {
                sub_1CB833614();
              }
              unsigned int v25 = (v15 >> 3) & 1;
              int v26 = v16;
              unint64_t v37 = v24;
              unint64_t v27 = (char *)operator new(12 * v24);
              unint64_t v24 = v37;
              int v16 = v26;
              LOBYTE(v20) = v25;
            }
            else
            {
              unint64_t v27 = 0;
            }
            char v28 = &v27[4 * ((v8 - v9) >> 2)];
            *(_DWORD *)char v28 = v12;
            *((_DWORD *)v28 + 1) = v16;
            v28[8] = v18;
            v28[9] = v17;
            v28[10] = v19;
            v28[11] = v20;
            if (v8 == v9)
            {
              uint64_t v9 = &v27[4 * ((v8 - v9) >> 2)];
              unsigned int v22 = v39;
            }
            else
            {
              uint64_t v29 = &v27[4 * ((v8 - v9) >> 2)];
              unsigned int v22 = v39;
              do
              {
                uint64_t v30 = *(void *)(v8 - 12);
                v8 -= 12;
                int v31 = *((_DWORD *)v8 + 2);
                *(void *)(v29 - 12) = v30;
                v29 -= 12;
                *((_DWORD *)v29 + 2) = v31;
              }
              while (v8 != v9);
              uint64_t v8 = v9;
              uint64_t v9 = v29;
            }
            uint64_t v7 = &v27[12 * v24];
            uint64_t v21 = v28 + 12;
            if (v8) {
              operator delete(v8);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v8 = v12;
            *((_DWORD *)v8 + 1) = v16;
            v8[8] = v18;
            v8[9] = (v15 & 2) != 0;
            v8[10] = (v15 & 4) != 0;
            uint64_t v21 = v8 + 12;
            v8[11] = (v15 & 8) != 0;
            unsigned int v22 = v39;
          }
          unsigned int v6 = v22 + 1;
          uint64_t v8 = v21;
        }
        unint64_t v58 = Unsigned;
        std::string::size_type v60 = 0;
        uint64_t v61 = 0;
        std::string::size_type v59 = 0;
        sub_1CCC40DEC(&v59, v9, (uint64_t)v8, 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 2));
        sub_1CCC2B418((void **)&v44, (uint64_t)&v58);
        if (v59) {
          operator delete(v59);
        }
        if (v9) {
          operator delete(v9);
        }
        uint64_t v32 = (char *)*((void *)&v43 + 1);
      }
      while (v43 < (unint64_t)v35);
    }
    else
    {
      uint64_t v32 = 0;
    }
    if (v32)
    {
      unint64_t v40 = 0;
      uint64_t v41 = v32;
      *((void *)&v43 + 1) = 0;
      sub_1CD5E5368(&v41, &v40, &v42);
      *(unsigned char *)(a3 + 24) |= 1u;
      *(void *)a3 = v42;
      unsigned int v42 = 0;
      if (v40) {
        (*(void (**)(char *))(*(void *)v40 + 8))(v40);
      }
      if (v41) {
        (*(void (**)(char *))(*(void *)v41 + 8))(v41);
      }
    }
    else
    {
      *(unsigned char *)(a3 + 24) &= ~1u;
      *(_OWORD *)a3 = v44;
      *(void *)(a3 + ++*(_DWORD *)(this + 16) = v45;
      long long v44 = 0uLL;
      uint64_t v45 = 0;
    }
    if (*((void *)&v43 + 1)) {
      (*(void (**)(void))(**((void **)&v43 + 1) + 8))(*((void *)&v43 + 1));
    }
    unint64_t v58 = (unint64_t)&v44;
    sub_1CC4CDFC0((void ***)&v58);
    if (v67)
    {
      uint64_t v34 = v65;
      uint64_t v65 = 0;
      if (v34) {
        (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
      }
    }
  }
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::base(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::end(void *a1)
{
  return *a1 + a1[1];
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getBufSize(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::ELFFile(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getHeader(uint64_t a1)
{
  return *(void *)a1;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getVersionDefinitions(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getLinkAsStrtab(a1, a2, (uint64_t)v75);
  if (v76)
  {
    uint64_t v6 = v75[0];
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
    return;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionContents(a1, a2, (uint64_t)v73);
  if (v74)
  {
    sub_1CCC327FC(&v66, a1, a2);
    char v28 = std::string::insert(&v66, 0, "cannot read content of ");
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v67.__r_.__value_.__r.__words[2] = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    uint64_t v30 = std::string::append(&v67, ": ");
    uint64_t v31 = 0;
    std::string::size_type v32 = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v32;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    if (v74)
    {
      uint64_t v31 = v73[0];
      v73[0] = 0;
    }
    uint64_t v64 = v31;
    sub_1CD4FB504(&v64, &v65);
    if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v33 = &v65;
    }
    else {
      uint64_t v33 = (std::string *)v65.__r_.__value_.__r.__words[0];
    }
    if ((v65.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v65.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v65.__r_.__value_.__l.__size_;
    }
    uint64_t v35 = std::string::append(&__p, (const std::string::value_type *)v33, size);
    std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string::size_type v70 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    *(void *)&v70[16] = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    LOWORD(v69) = 260;
    v68[0] = v70;
    operator new();
  }
  uint64_t v7 = (unsigned __int16 *)v73[0];
  unint64_t v62 = v73[0] + v73[1];
  uint64_t v63 = v73[0];
  v68[0] = &v62;
  v68[1] = a1;
  v68[2] = a2;
  v68[3] = &v63;
  uint64_t v69 = v75;
  memset(&v67, 0, sizeof(v67));
  if (!*(_DWORD *)(a2 + 44))
  {
    std::string::size_type v22 = 0;
    char v8 = *(unsigned char *)(a3 + 24);
    long long v21 = 0uLL;
    goto LABEL_34;
  }
  char v8 = *(unsigned char *)(a3 + 24);
  unsigned int v9 = 1;
  while (1)
  {
    if ((unint64_t)(v7 + 10) > v62)
    {
      sub_1CCC327FC(&v59, a1, a2);
      unint64_t v37 = std::string::insert(&v59, 0, "invalid ");
      std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v65.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      v65.__r_.__value_.__r.__words[2] = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      unsigned int v39 = std::string::append(&v65, ": version definition ");
      std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v66;
      __p.__r_.__value_.__r.__words[2] = v9;
      __int16 v61 = 2052;
      uint64_t v41 = " goes past the end of the section";
      goto LABEL_49;
    }
    if ((v7 & 3) != 0)
    {
      sub_1CCC327FC(&v65, a1, a2);
      unsigned int v42 = std::string::insert(&v65, 0, "invalid ");
      std::string::size_type v43 = v42->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v43;
      v42->__r_.__value_.__l.__size_ = 0;
      v42->__r_.__value_.__r.__words[2] = 0;
      v42->__r_.__value_.__r.__words[0] = 0;
      long long v44 = std::string::append(&v66, ": found a misaligned version definition entry at offset 0x");
      std::string::size_type v45 = v44->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v45;
      v44->__r_.__value_.__l.__size_ = 0;
      v44->__r_.__value_.__r.__words[2] = 0;
      v44->__r_.__value_.__r.__words[0] = 0;
      v59.__r_.__value_.__r.__words[0] = (std::string::size_type)v7 - v63;
      unint64_t v27 = &v59;
LABEL_36:
      *(void *)std::string::size_type v70 = &__p;
      *(void *)&v70[16] = v27;
      __int16 v72 = 3588;
      operator new();
    }
    std::string::size_type v10 = *v7;
    if (v10 != 1)
    {
      sub_1CCC327FC(&v59, a1, a2);
      uint64_t v46 = std::string::insert(&v59, 0, "unable to dump ");
      std::string::size_type v47 = v46->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v65.__r_.__value_.__l.__data_ = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
      v65.__r_.__value_.__r.__words[2] = v47;
      v46->__r_.__value_.__l.__size_ = 0;
      v46->__r_.__value_.__r.__words[2] = 0;
      v46->__r_.__value_.__r.__words[0] = 0;
      unsigned __int8 v48 = std::string::append(&v65, ": version ");
      std::string::size_type v49 = v48->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v49;
      v48->__r_.__value_.__l.__size_ = 0;
      v48->__r_.__value_.__r.__words[2] = 0;
      v48->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v66;
      __p.__r_.__value_.__r.__words[2] = v10;
      __int16 v61 = 2052;
      uint64_t v41 = " is not yet supported";
LABEL_49:
      *(void *)std::string::size_type v70 = &__p;
      *(void *)&v70[16] = v41;
      __int16 v72 = 770;
      operator new();
    }
    unint64_t v11 = sub_1CCC25678((uint64_t)&v67, v67.__r_.__value_.__l.__size_);
    *(_DWORD *)unint64_t v11 = v7 - v63;
    *((_DWORD *)v11 + 1) = *v7;
    *((_DWORD *)v11 + 2) = v7[1];
    *((_DWORD *)v11 + 3) = v7[2];
    *((_DWORD *)v11 + 4) = v7[3];
    *((_DWORD *)v11 + 5) = *((_DWORD *)v7 + 2);
    v59.__r_.__value_.__r.__words[0] = (std::string::size_type)v7 + *((unsigned int *)v7 + 3);
    if (v7[3]) {
      break;
    }
LABEL_31:
    uint64_t v7 = (unsigned __int16 *)((char *)v7 + *((unsigned int *)v7 + 4));
    if (++v9 > *(_DWORD *)(a2 + 44))
    {
      long long v21 = *(_OWORD *)&v67.__r_.__value_.__l.__data_;
      std::string::size_type v22 = v67.__r_.__value_.__r.__words[2];
LABEL_34:
      *(unsigned char *)(a3 + 24) = v8 & 0xFE;
      *(_OWORD *)a3 = v21;
      *(void *)(a3 + ++*(_DWORD *)(this + 16) = v22;
      goto LABEL_58;
    }
  }
  int v12 = v11;
  int v13 = 0;
  std::string::size_type v56 = (unint64_t *)(v11 + 3);
  __int16 v57 = (std::string *)((char *)v11 + 24);
  while (1)
  {
    if ((v59.__r_.__value_.__s.__data_[0] & 3) != 0)
    {
      sub_1CCC327FC(&v65, a1, a2);
      unint64_t v23 = std::string::insert(&v65, 0, "invalid ");
      std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      unsigned int v25 = std::string::append(&v66, ": found a misaligned auxiliary entry at offset 0x");
      std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      std::string::size_type v58 = v59.__r_.__value_.__r.__words[0] - v63;
      unint64_t v27 = (std::string *)&v58;
      goto LABEL_36;
    }
    sub_1CCC328C0((uint64_t)v68, (unsigned int **)&v59, v9, (uint64_t)v70);
    char v14 = v72;
    if (v72)
    {
      uint64_t v18 = *(void *)v70;
      *(void *)std::string::size_type v70 = 0;
      v8 |= 1u;
      *(unsigned char *)(a3 + 24) = v8;
      *(void *)a3 = v18;
    }
    else if (v13)
    {
      unint64_t v15 = *((void *)v12 + 7);
      if (v15 >= *((void *)v12 + 8))
      {
        unsigned int v19 = sub_1CCC3F408(v56, (uint64_t)v70);
      }
      else
      {
        *(_DWORD *)unint64_t v15 = *(_DWORD *)v70;
        int v16 = (_OWORD *)(v15 + 8);
        if (SHIBYTE(v71) < 0)
        {
          sub_1CB8BDF7C((uint64_t)v16, *(const void **)&v70[8], *(unint64_t *)&v70[16]);
        }
        else
        {
          long long v17 = *(_OWORD *)&v70[8];
          *(void *)(v15 + 24) = v71;
          *int v16 = v17;
        }
        unsigned int v19 = (char *)(v15 + 32);
      }
      *((void *)v12 + 7) = v19;
    }
    else
    {
      std::string::operator=(v57, (const std::string *)&v70[8]);
    }
    if (v72)
    {
      uint64_t v20 = *(void *)v70;
      *(void *)std::string::size_type v70 = 0;
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
      }
    }
    else if (SHIBYTE(v71) < 0)
    {
      operator delete(*(void **)&v70[8]);
    }
    if (v14) {
      break;
    }
    if (++v13 >= v7[3]) {
      goto LABEL_31;
    }
  }
  std::string::size_type v50 = v67.__r_.__value_.__r.__words[0];
  if (v67.__r_.__value_.__r.__words[0])
  {
    __int16 v51 = (void *)v67.__r_.__value_.__r.__words[0];
    if (v67.__r_.__value_.__l.__size_ != v67.__r_.__value_.__r.__words[0])
    {
      std::string::size_type v52 = v67.__r_.__value_.__l.__size_ - 24;
      do
      {
        *(void *)std::string::size_type v70 = v52;
        sub_1CC1CB288((void ***)v70);
        if (*(char *)(v52 - 1) < 0) {
          operator delete(*(void **)(v52 - 24));
        }
        std::string::size_type v53 = v52 - 48;
        v52 -= 72;
      }
      while (v53 != v50);
      __int16 v51 = (void *)v67.__r_.__value_.__r.__words[0];
    }
    v67.__r_.__value_.__l.__size_ = v50;
    operator delete(v51);
  }
LABEL_58:
  if (v74)
  {
    uint64_t v54 = v73[0];
    v73[0] = 0;
    if (v54) {
      (*(void (**)(uint64_t))(*(void *)v54 + 8))(v54);
    }
  }
  if (v76)
  {
    uint64_t v55 = v75[0];
    v75[0] = 0;
    if (v55) {
      (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
    }
  }
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getLinkAsStrtab(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSection(a1, *(_DWORD *)(a2 + 40), (uint64_t)&v36);
  if (v37)
  {
    sub_1CCC327FC(&v29, a1, a2);
    uint64_t v6 = std::string::insert(&v29, 0, "invalid section linked to ");
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    char v8 = std::string::append(&v30, ": ");
    uint64_t v9 = 0;
    std::string::size_type v10 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v10;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if (v37)
    {
      uint64_t v9 = v36;
      uint64_t v36 = 0;
    }
    uint64_t v27 = v9;
    sub_1CD4FB504(&v27, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    int v13 = std::string::append(&v31, (const std::string::value_type *)p_p, size);
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    long long v34 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    std::string::size_type v35 = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    std::string::size_type v32 = (std::string *)&v34;
    operator new();
  }
  std::string::size_type v32 = (std::string *)sub_1CCC27114;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getStringTable(a1, v36, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v32, (uint64_t)&v34);
  if (v35)
  {
    sub_1CCC327FC(&__p, a1, a2);
    int v16 = std::string::insert(&__p, 0, "invalid string table linked to ");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    uint64_t v18 = std::string::append(&v29, ": ");
    uint64_t v19 = 0;
    std::string::size_type v20 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v20;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if (v35)
    {
      uint64_t v19 = v34;
      *(void *)&long long v34 = 0;
    }
    uint64_t v25 = v19;
    sub_1CD4FB504(&v25, &v26);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v21 = &v26;
    }
    else {
      long long v21 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v22 = *((unsigned char *)&v26.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type v22 = v26.__r_.__value_.__l.__size_;
    }
    unint64_t v23 = std::string::append(&v30, (const std::string::value_type *)v21, v22);
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    std::string::size_type v32 = &v31;
    operator new();
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(_OWORD *)a3 = v34;
  if (v37)
  {
    uint64_t v15 = v36;
    uint64_t v36 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
}

void sub_1CCC327FC(void *a1, void *a2, uint64_t a3)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections(a2, (uint64_t)v13);
  unint64_t v6 = a3 - v13[0];
  ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)*(unsigned __int16 *)(*a2 + 18), *(_DWORD *)(a3 + 4));
  __int16 v10 = 773;
  v9[0] = ELFSectionTypeName;
  v9[1] = v8;
  _OWORD v9[2] = " section with index ";
  v11[0] = v9;
  v11[2] = (v6 >> 6);
  __int16 v12 = 2050;
  llvm::Twine::str((llvm::Twine *)v11, a1);
}

void sub_1CCC328C0(uint64_t a1@<X0>, unsigned int **a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  BOOL v5 = *a2;
  if ((unint64_t)(*a2 + 2) > **(void **)a1)
  {
    sub_1CCC327FC(&v24, *(void **)(a1 + 8), *(void *)(a1 + 16));
    std::string::size_type v7 = std::string::insert(&v24, 0, "invalid ");
    std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    uint64_t v9 = std::string::append(&v32, ": version definition ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    *(void *)&__p[16] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    v26[0] = __p;
    unint64_t v27 = a3;
    __int16 v28 = 2052;
    long long __dst = v26;
    *((void *)&v30 + 1) = " refers to an auxiliary entry that goes past the end of the section";
    __int16 v31 = 770;
    operator new();
  }
  unint64_t v11 = (unsigned int *)((char *)v5 + v5[1]);
  *a2 = v11;
  __int16 v12 = *(uint64_t **)(a1 + 32);
  int v13 = **(_DWORD **)(a1 + 24);
  unint64_t v14 = *v5;
  unint64_t v15 = v12[1];
  size_t v16 = v15 - v14;
  if (v15 >= v14)
  {
    if (v16 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v19 = *v12;
    if (v16 >= 0x17)
    {
      uint64_t v21 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v21 = v16 | 7;
      }
      uint64_t v22 = v21 + 1;
      p_dst = (void **)operator new(v21 + 1);
      *(void *)&long long v30 = v16;
      *((void *)&v30 + 1) = v22 | 0x8000000000000000;
      long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v30) = v15 - v14;
      p_dst = &__dst;
      if (v15 == v14) {
        goto LABEL_13;
      }
    }
    memmove(p_dst, (const void *)(v19 + v14), v16);
LABEL_13:
    *((unsigned char *)p_dst + v++*(_DWORD *)(this + 16) = 0;
    std::string::size_type v17 = __dst;
    v32.__r_.__value_.__r.__words[0] = v30;
    *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7) = *(void *)((char *)&v30 + 7);
    char v18 = HIBYTE(v30);
    goto LABEL_14;
  }
  v26[0] = "<invalid vda_name: ";
  unint64_t v27 = v14;
  __int16 v28 = 2051;
  long long __dst = v26;
  *((void *)&v30 + 1) = ">";
  __int16 v31 = 770;
  llvm::Twine::str((llvm::Twine *)&__dst, __p);
  std::string::size_type v17 = *(void **)__p;
  v32.__r_.__value_.__r.__words[0] = *(void *)&__p[8];
  *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7) = *(void *)&__p[15];
  char v18 = __p[23];
LABEL_14:
  *(unsigned char *)(a4 + 32) &= ~1u;
  *(_DWORD *)a4 = v11 - v13;
  std::string::size_type v23 = v32.__r_.__value_.__r.__words[0];
  *(void *)(a4 + ++*(_DWORD *)(this + 8) = v17;
  *(void *)(a4 + ++*(_DWORD *)(this + 16) = v23;
  *(void *)(a4 + 23) = *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7);
  *(unsigned char *)(a4 + 31) = v18;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getVersionDependencies(void *a1@<X0>, uint64_t a2@<X1>, void (*a3)(unsigned __int16 **__return_ptr, uint64_t, long long *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = a2;
  std::string::size_type v8 = a1;
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getLinkAsStrtab(a1, a2, (uint64_t)v95);
  if (v96)
  {
    uint64_t v39 = v95[0];
    v95[0] = 0;
    uint64_t v88 = v39;
    sub_1CD4FB504(&v88, &__p);
    __int16 v91 = 260;
    *(void *)&long long __dst = &__p;
    a3(&v92, a4, &__dst);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v88) {
      (*(void (**)(uint64_t))(*(void *)v88 + 8))(v88);
    }
    std::string::size_type v40 = v92;
    if (v92)
    {
      *(unsigned char *)(a5 + 24) |= 1u;
      *(void *)a5 = v40;
      goto LABEL_67;
    }
    uint64_t v80 = 0;
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v10 = v95[1];
    uint64_t v80 = v95[0];
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionContents(v8, v7, (uint64_t)&v92);
  if (v94)
  {
    sub_1CCC327FC(&v85, v8, v7);
    std::string::size_type v49 = std::string::insert(&v85, 0, "cannot read content of ");
    std::string::size_type v50 = v49->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
    v86.__r_.__value_.__r.__words[2] = v50;
    v49->__r_.__value_.__l.__size_ = 0;
    v49->__r_.__value_.__r.__words[2] = 0;
    v49->__r_.__value_.__r.__words[0] = 0;
    __int16 v51 = std::string::append(&v86, ": ");
    uint64_t v52 = 0;
    std::string::size_type v53 = v51->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    v87.__r_.__value_.__r.__words[2] = v53;
    v51->__r_.__value_.__l.__size_ = 0;
    v51->__r_.__value_.__r.__words[2] = 0;
    v51->__r_.__value_.__r.__words[0] = 0;
    if (v94)
    {
      uint64_t v52 = (uint64_t)v92;
      uint64_t v92 = 0;
    }
    uint64_t v83 = v52;
    sub_1CD4FB504(&v83, &v84);
    if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v54 = &v84;
    }
    else {
      uint64_t v54 = (std::string *)v84.__r_.__value_.__r.__words[0];
    }
    if ((v84.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v84.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v84.__r_.__value_.__l.__size_;
    }
    std::string::size_type v56 = std::string::append(&v87, (const std::string::value_type *)v54, size);
    std::string::size_type v57 = v56->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v57;
    v56->__r_.__value_.__l.__size_ = 0;
    v56->__r_.__value_.__r.__words[2] = 0;
    v56->__r_.__value_.__r.__words[0] = 0;
    __int16 v91 = 260;
    *(void *)&long long __dst = &__p;
    operator new();
  }
  unint64_t v11 = (char *)v92;
  long long v12 = 0uLL;
  memset(&v87, 0, sizeof(v87));
  if (*(_DWORD *)(v7 + 44))
  {
    unint64_t v13 = (unint64_t)v92 + v93;
    unsigned int v14 = 1;
    unint64_t v15 = (char *)v92;
    uint64_t v75 = v7;
    uint64_t v76 = a5;
    char v74 = v8;
    unint64_t v78 = (unint64_t)v92 + v93;
    unint64_t v79 = v10;
    while ((unint64_t)(v15 + 20) <= v13)
    {
      if ((v15 & 3) != 0)
      {
        sub_1CCC327FC(&v85, v8, v7);
        uint64_t v63 = std::string::insert(&v85, 0, "invalid ");
        std::string::size_type v64 = v63->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
        v86.__r_.__value_.__r.__words[2] = v64;
        v63->__r_.__value_.__l.__size_ = 0;
        v63->__r_.__value_.__r.__words[2] = 0;
        v63->__r_.__value_.__r.__words[0] = 0;
        std::string v65 = std::string::append(&v86, ": found a misaligned version dependency entry at offset 0x");
        std::string::size_type v66 = v65->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v66;
        v65->__r_.__value_.__l.__size_ = 0;
        v65->__r_.__value_.__r.__words[2] = 0;
        v65->__r_.__value_.__r.__words[0] = 0;
        v84.__r_.__value_.__r.__words[0] = v15 - v11;
        *(void *)&long long __dst = &__p;
        uint64_t v90 = (const char *)&v84;
        __int16 v91 = 3588;
        operator new();
      }
      std::string::size_type v16 = *(unsigned __int16 *)v15;
      if (v16 != 1)
      {
        sub_1CCC327FC(&v84, v8, v7);
        std::string v67 = std::string::insert(&v84, 0, "unable to dump ");
        std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v85.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
        v85.__r_.__value_.__r.__words[2] = v68;
        v67->__r_.__value_.__l.__size_ = 0;
        v67->__r_.__value_.__r.__words[2] = 0;
        v67->__r_.__value_.__r.__words[0] = 0;
        uint64_t v69 = std::string::append(&v85, ": version ");
        std::string::size_type v70 = v69->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
        v86.__r_.__value_.__r.__words[2] = v70;
        v69->__r_.__value_.__l.__size_ = 0;
        v69->__r_.__value_.__r.__words[2] = 0;
        v69->__r_.__value_.__r.__words[0] = 0;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
        __p.__r_.__value_.__r.__words[2] = v16;
        __int16 v82 = 2052;
        unint64_t v62 = " is not yet supported";
LABEL_63:
        *(void *)&long long __dst = &__p;
        uint64_t v90 = v62;
        __int16 v91 = 770;
        operator new();
      }
      unsigned int v77 = v14;
      uint64_t v17 = sub_1CCC26774((uint64_t)&v87, (_OWORD *)v87.__r_.__value_.__l.__size_);
      *(_DWORD *)uint64_t v17 = *(unsigned __int16 *)v15;
      *(_DWORD *)(v17 + 4) = *((unsigned __int16 *)v15 + 1);
      *(_DWORD *)(v17 + ++*(_DWORD *)(this + 8) = v15 - v11;
      unint64_t v18 = *((unsigned int *)v15 + 1);
      unint64_t v19 = v10 - v18;
      if (v10 <= v18)
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"<corrupt vn_file: ";
        unint64_t v73 = v73 & 0xFFFFFFFF00000000 | v18;
        __p.__r_.__value_.__r.__words[2] = v73;
        __int16 v82 = 2051;
        *(void *)&long long __dst = &__p;
        uint64_t v90 = ">";
        __int16 v91 = 770;
        llvm::Twine::str((llvm::Twine *)&__dst, &v86);
        uint64_t v21 = v17 + 16;
        if (*(char *)(v17 + 39) < 0) {
          operator delete(*(void **)v21);
        }
        uint64_t v22 = (const char *)v86.__r_.__value_.__r.__words[2];
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v86.__r_.__value_.__l.__data_;
      }
      else
      {
        if (v19 > 0x7FFFFFFFFFFFFFF7) {
LABEL_71:
        }
          abort();
        if (v19 >= 0x17)
        {
          uint64_t v23 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v23 = v19 | 7;
          }
          uint64_t v24 = v23 + 1;
          p_dst = (long long *)operator new(v23 + 1);
          *((void *)&__dst + 1) = v10 - v18;
          uint64_t v90 = (const char *)(v24 | 0x8000000000000000);
          *(void *)&long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v90) = v10 - v18;
          p_dst = &__dst;
        }
        memmove(p_dst, (const void *)(v80 + v18), v10 - v18);
        *((unsigned char *)p_dst + v19) = 0;
        uint64_t v21 = v17 + 16;
        if (*(char *)(v17 + 39) < 0) {
          operator delete(*(void **)v21);
        }
        *(_OWORD *)uint64_t v21 = __dst;
        uint64_t v22 = v90;
      }
      *(void *)(v21 + ++*(_DWORD *)(this + 16) = v22;
      unint64_t v25 = v78;
      if (*((_WORD *)v15 + 1))
      {
        unsigned int v26 = 0;
        unint64_t v27 = &v15[*((unsigned int *)v15 + 2)];
        do
        {
          if ((v27 & 3) != 0)
          {
            sub_1CCC327FC(&v85, v74, v75);
            uint64_t v41 = std::string::insert(&v85, 0, "invalid ");
            std::string::size_type v42 = v41->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
            v86.__r_.__value_.__r.__words[2] = v42;
            v41->__r_.__value_.__l.__size_ = 0;
            v41->__r_.__value_.__r.__words[2] = 0;
            v41->__r_.__value_.__r.__words[0] = 0;
            std::string::size_type v43 = std::string::append(&v86, ": found a misaligned auxiliary entry at offset 0x");
            std::string::size_type v44 = v43->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v44;
            v43->__r_.__value_.__l.__size_ = 0;
            v43->__r_.__value_.__r.__words[2] = 0;
            v43->__r_.__value_.__r.__words[0] = 0;
            v84.__r_.__value_.__r.__words[0] = v27 - v11;
            *(void *)&long long __dst = &__p;
            uint64_t v90 = (const char *)&v84;
            __int16 v91 = 3588;
            operator new();
          }
          if ((unint64_t)(v27 + 16) > v25)
          {
            sub_1CCC327FC(&v84, v74, v75);
            std::string::size_type v45 = std::string::insert(&v84, 0, "invalid ");
            std::string::size_type v46 = v45->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v85.__r_.__value_.__l.__data_ = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
            v85.__r_.__value_.__r.__words[2] = v46;
            v45->__r_.__value_.__l.__size_ = 0;
            v45->__r_.__value_.__r.__words[2] = 0;
            v45->__r_.__value_.__r.__words[0] = 0;
            std::string::size_type v47 = std::string::append(&v85, ": version dependency ");
            std::string::size_type v48 = v47->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
            v86.__r_.__value_.__r.__words[2] = v48;
            v47->__r_.__value_.__l.__size_ = 0;
            v47->__r_.__value_.__r.__words[2] = 0;
            v47->__r_.__value_.__r.__words[0] = 0;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
            __p.__r_.__value_.__r.__words[2] = v77;
            __int16 v82 = 2052;
            *(void *)&long long __dst = &__p;
            uint64_t v90 = " refers to an auxiliary entry that goes past the end of the section";
            __int16 v91 = 770;
            operator new();
          }
          __int16 v28 = (_DWORD *)sub_1CCC26958((char **)(v17 + 40), *(void *)(v17 + 48));
          std::string v29 = v28;
          _DWORD *v28 = *(_DWORD *)v27;
          v28[1] = *((unsigned __int16 *)v27 + 2);
          v28[2] = *((unsigned __int16 *)v27 + 3);
          void v28[3] = v27 - v11;
          unint64_t v30 = *((unsigned int *)v27 + 2);
          size_t v31 = v10 - v30;
          if (v10 <= v30)
          {
            MEMORY[0x1D25D9630](v28 + 4, "<corrupt>");
          }
          else
          {
            if (v31 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_71;
            }
            if (v31 >= 0x17)
            {
              uint64_t v33 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v31 | 7) != 0x17) {
                uint64_t v33 = v31 | 7;
              }
              long long v34 = v11;
              uint64_t v35 = v33 + 1;
              std::string v32 = (long long *)operator new(v33 + 1);
              unint64_t v36 = v35 | 0x8000000000000000;
              unint64_t v11 = v34;
              unint64_t v25 = v78;
              *((void *)&__dst + 1) = v31;
              uint64_t v90 = (const char *)v36;
              *(void *)&long long __dst = v32;
            }
            else
            {
              HIBYTE(v90) = v10 - v30;
              std::string v32 = &__dst;
            }
            memmove(v32, (const void *)(v80 + v30), v31);
            *((unsigned char *)v32 + v31) = 0;
            char v37 = (void **)(v29 + 4);
            if (*((char *)v29 + 39) < 0) {
              operator delete(*v37);
            }
            *(_OWORD *)char v37 = __dst;
            *((void *)v29 + 4) = v90;
            unint64_t v10 = v79;
          }
          v27 += *((unsigned int *)v27 + 3);
          ++v26;
        }
        while (v26 < *((unsigned __int16 *)v15 + 1));
      }
      v15 += *((unsigned int *)v15 + 3);
      unsigned int v14 = v77 + 1;
      std::string::size_type v8 = v74;
      uint64_t v7 = v75;
      unint64_t v13 = v25;
      a5 = v76;
      if (v77 + 1 > *(_DWORD *)(v75 + 44))
      {
        long long v12 = *(_OWORD *)&v87.__r_.__value_.__l.__data_;
        std::string::size_type v38 = v87.__r_.__value_.__r.__words[2];
        goto LABEL_47;
      }
    }
    sub_1CCC327FC(&v84, v8, v7);
    std::string::size_type v58 = std::string::insert(&v84, 0, "invalid ");
    std::string::size_type v59 = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v85.__r_.__value_.__l.__data_ = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v85.__r_.__value_.__r.__words[2] = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v60 = std::string::append(&v85, ": version dependency ");
    std::string::size_type v61 = v60->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
    v86.__r_.__value_.__r.__words[2] = v61;
    v60->__r_.__value_.__l.__size_ = 0;
    v60->__r_.__value_.__r.__words[2] = 0;
    v60->__r_.__value_.__r.__words[0] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v86;
    __p.__r_.__value_.__r.__words[2] = v14;
    __int16 v82 = 2052;
    unint64_t v62 = " goes past the end of the section";
    goto LABEL_63;
  }
  std::string::size_type v38 = 0;
LABEL_47:
  *(unsigned char *)(a5 + 24) &= ~1u;
  *(_OWORD *)a5 = v12;
  *(void *)(a5 + ++*(_DWORD *)(this + 16) = v38;
  if (v94)
  {
    uint64_t v71 = v92;
    uint64_t v92 = 0;
    if (v71) {
      (*(void (**)(unsigned __int16 *))(*(void *)v71 + 8))(v71);
    }
  }
LABEL_67:
  if (v96)
  {
    uint64_t v72 = v95[0];
    v95[0] = 0;
    if (v72) {
      (*(void (**)(uint64_t))(*(void *)v72 + 8))(v72);
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getStringTableForSymtab@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections(a1, (uint64_t)&v5);
  if ((v6 & 1) == 0) {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getStringTableForSymtab();
  }
  uint64_t v4 = v5;
  *(unsigned char *)(a2 + 16) |= 1u;
  *(void *)a2 = v4;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getStringTableForSymtab(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6 != 2 && v6 != 11)
  {
    long long v12 = "invalid sh_type for symbol table, expected SHT_SYMTAB or SHT_DYNSYM";
    __int16 v14 = 259;
    operator new();
  }
  sub_1CD6D1030(a3, a4, *(_DWORD *)(a2 + 40), (uint64_t)&v12);
  uint64_t v9 = v12;
  if (v13)
  {
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v9;
  }
  else
  {
    unint64_t v11 = sub_1CCC27114;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getStringTable(a1, (uint64_t)v12, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v11, a5);
    if (v13)
    {
      unint64_t v10 = v12;
      long long v12 = 0;
      if (v10) {
        (*(void (**)(const char *))(*(void *)v10 + 8))(v10);
      }
    }
  }
}

llvm::object *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getDynSymtabSize@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t result = (llvm::object *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections(a1, (uint64_t)&v20);
  unint64_t v4 = (unint64_t)v20;
  if (v22)
  {
    std::string::size_type v20 = 0;
    char v7 = *(unsigned char *)(a2 + 8) | 1;
  }
  else
  {
    if (!v21) {
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::dynamicEntries();
    }
    uint64_t v5 = v20 + 4;
    uint64_t v6 = v21 << 6;
    while (*((_DWORD *)v5 - 7) != 11)
    {
      v5 += 8;
      v6 -= 64;
      if (!v6)
      {
        *(unsigned char *)(a2 + 8) &= ~1u;
        *(void *)a2 = 0;
        goto LABEL_12;
      }
    }
    unint64_t v8 = v5[3];
    unint64_t v4 = *v5 / v8;
    if (*v5 % v8)
    {
      atomic_ullong v9 = llvm::object::object_category(result);
      uint64_t v11 = *v5;
      v12[0] = "SHT_DYNSYM section has sh_size (";
      uint64_t v12[2] = &v11;
      __int16 v13 = 3075;
      v14[0] = v12;
      unint64_t v14[2] = ") % sh_entsize (";
      __int16 v15 = 770;
      uint64_t v10 = v5[3];
      v16[0] = v14;
      _OWORD v16[2] = &v10;
      __int16 v17 = 3074;
      v18[0] = v16;
      v18[2] = ") that is not 0";
      __int16 v19 = 770;
      sub_1CD4FF4BC(3, v9, (llvm::Twine *)v18);
    }
    char v7 = *(unsigned char *)(a2 + 8) & 0xFE;
  }
  *(unsigned char *)(a2 + ++*(_DWORD *)(this + 8) = v7;
  *(void *)a2 = v4;
LABEL_12:
  if (v22)
  {
    uint64_t result = (llvm::object *)v20;
    std::string::size_type v20 = 0;
    if (result) {
      return (llvm::object *)(*(uint64_t (**)(llvm::object *))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::dynamicEntries()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::program_headers();
}

{
  while (1)
    ;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::toMappedAddr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::program_headers();
}

const char *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getRelocationTypeName(uint64_t a1, unsigned int a2)
{
  return llvm::object::getELFRelocationTypeName((llvm::object *)*(unsigned __int16 *)(*(void *)a1 + 18), a2);
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::isMipsELF64(uint64_t a1)
{
  return *(_WORD *)(*(void *)a1 + 18) == 8 && *(unsigned char *)(*(void *)a1 + 4) == 2;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getRelativeRelocationType(uint64_t a1)
{
  return llvm::object::getELFRelativeRelocationType((llvm::object *)*(unsigned __int16 *)(*(void *)a1 + 18));
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getDynamicTagAsString(int a1@<W1>, int64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (a1 > 163)
  {
    switch(a1)
    {
      case 164:
        switch(a2)
        {
          case 1879048194:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1414287455;
            unint64_t v4 = "HEXAGON_PLT";
            goto LABEL_46;
          case 1879048193:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1380275807;
            unint64_t v4 = "HEXAGON_VER";
            goto LABEL_46;
          case 1879048192:
            unint64_t v8 = "HEXAGON_SYMSZ";
LABEL_23:
            *(unsigned char *)(a3 + 23) = 13;
            *(void *)a3 = *(void *)v8;
            *(void *)(a3 + 5) = *(void *)(v8 + 5);
            *(unsigned char *)(a3 + 13) = 0;
            return;
        }
        break;
      case 243:
        if (a2 == 1879048193)
        {
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "RISCV_VARIANT_CC";
LABEL_26:
          *(_OWORD *)a3 = *(_OWORD *)v6;
          *(unsigned char *)(a3 + ++*(_DWORD *)(this + 16) = 0;
          return;
        }
        break;
      case 183:
        switch(a2)
        {
          case 1879048197:
            *(unsigned char *)(a3 + 23) = 19;
            *(_DWORD *)(a3 + 15) = 1396920415;
            uint64_t v11 = "AARCH64_VARIANT_PCS";
LABEL_41:
            *(_OWORD *)a3 = *(_OWORD *)v11;
            *(unsigned char *)(a3 + 19) = 0;
            return;
          case 1879048195:
            uint64_t v5 = "AARCH64_PAC_PLT";
            goto LABEL_43;
          case 1879048193:
            uint64_t v5 = "AARCH64_BTI_PLT";
            goto LABEL_43;
        }
        break;
    }
  }
  else
  {
    if (a1 == 8)
    {
      switch(a2)
      {
        case 1879048193:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_RLD_VERSION";
          goto LABEL_26;
        case 1879048194:
          uint64_t v5 = "MIPS_TIME_STAMP";
          goto LABEL_43;
        case 1879048195:
          std::string::size_type v16 = "MIPS_ICHECKSUM";
          goto LABEL_159;
        case 1879048196:
          unint64_t v8 = "MIPS_IVERSION";
          goto LABEL_23;
        case 1879048197:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 21319;
          __int16 v14 = "MIPS_FLAGS";
          goto LABEL_172;
        case 1879048198:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 83;
          uint64_t v24 = "MIPS_BASE_ADDRESS";
          goto LABEL_165;
        case 1879048199:
          *(unsigned char *)(a3 + 23) = 9;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 77;
          long long v12 = "MIPS_MSYM";
          goto LABEL_126;
        case 1879048200:
          unint64_t v8 = "MIPS_CONFLICT";
          goto LABEL_23;
        case 1879048201:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1414744396;
          __int16 v15 = "MIPS_LIBLIST";
          goto LABEL_157;
        case 1879048202:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_LOCAL_GOTNO";
          goto LABEL_26;
        case 1879048203:
          uint64_t v5 = "MIPS_CONFLICTNO";
          goto LABEL_43;
        case 1879048208:
          std::string::size_type v16 = "MIPS_LIBLISTNO";
          goto LABEL_159;
        case 1879048209:
          unint64_t v8 = "MIPS_SYMTABNO";
          goto LABEL_23;
        case 1879048210:
          uint64_t v5 = "MIPS_UNREFEXTNO";
          goto LABEL_43;
        case 1879048211:
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1297699668;
          unint64_t v4 = "MIPS_GOTSYM";
          goto LABEL_46;
        case 1879048212:
          unint64_t v8 = "MIPS_HIPAGENO";
          goto LABEL_23;
        case 1879048214:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1346456927;
          __int16 v15 = "MIPS_RLD_MAP";
          goto LABEL_157;
        case 1879048215:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_DELTA_CLASS";
          goto LABEL_26;
        case 1879048216:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1330536275;
          uint64_t v11 = "MIPS_DELTA_CLASS_NO";
          goto LABEL_41;
        case 1879048217:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1162038849;
          uint64_t v11 = "MIPS_DELTA_INSTANCE";
          goto LABEL_41;
        case 1879048218:
          unint64_t v25 = "MIPS_DELTA_INSTANCE_NO";
          goto LABEL_147;
        case 1879048219:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_DELTA_RELOC";
          goto LABEL_26;
        case 1879048220:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1330536259;
          uint64_t v11 = "MIPS_DELTA_RELOC_NO";
          goto LABEL_41;
        case 1879048221:
          std::string::size_type v16 = "MIPS_DELTA_SYM";
          goto LABEL_159;
        case 1879048222:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 79;
          uint64_t v24 = "MIPS_DELTA_SYM_NO";
          goto LABEL_165;
        case 1879048224:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1297699667;
          uint64_t v11 = "MIPS_DELTA_CLASSSYM";
          goto LABEL_41;
        case 1879048225:
          unint64_t v25 = "MIPS_DELTA_CLASSSYM_NO";
LABEL_147:
          *(_OWORD *)a3 = *(_OWORD *)v25;
          *(void *)(a3 + 14) = *(void *)(v25 + 14);
          *(_WORD *)(a3 + 22) = 5632;
          return;
        case 1879048226:
          std::string::size_type v16 = "MIPS_CXX_FLAGS";
          goto LABEL_159;
        case 1879048227:
          uint64_t v5 = "MIPS_PIXIE_INIT";
          goto LABEL_43;
        case 1879048228:
          uint64_t v5 = "MIPS_SYMBOL_LIB";
          goto LABEL_43;
        case 1879048229:
          unsigned int v26 = "MIPS_LOCALPAGE_GOTIDX";
          goto LABEL_155;
        case 1879048230:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 88;
          uint64_t v24 = "MIPS_LOCAL_GOTIDX";
          goto LABEL_165;
        case 1879048231:
          *(unsigned char *)(a3 + 23) = 18;
          strcpy((char *)a3, "MIPS_HIDDEN_GOTIDX");
          return;
        case 1879048232:
          unsigned int v26 = "MIPS_PROTECTED_GOTIDX";
LABEL_155:
          *(unsigned char *)(a3 + 23) = 21;
          *(_OWORD *)a3 = *(_OWORD *)v26;
          *(void *)(a3 + 13) = *(void *)(v26 + 13);
          *(unsigned char *)(a3 + 21) = 0;
          return;
        case 1879048233:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1397641033;
          __int16 v15 = "MIPS_OPTIONS";
          goto LABEL_157;
        case 1879048234:
          std::string::size_type v16 = "MIPS_INTERFACE";
          goto LABEL_159;
        case 1879048235:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 78;
          uint64_t v24 = "MIPS_DYNSTR_ALIGN";
          goto LABEL_165;
        case 1879048236:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1163544915;
          uint64_t v11 = "MIPS_INTERFACE_SIZE";
          goto LABEL_41;
        case 1879048237:
          unint64_t v27 = (char *)operator new(0x20uLL);
          *(void *)a3 = v27;
          *(_OWORD *)(a3 + ++*(_DWORD *)(this + 8) = xmmword_1CD96DBE0;
          strcpy(v27, "MIPS_RLD_TEXT_RESOLVE_ADDR");
          return;
        case 1879048238:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_PERF_SUFFIX";
          goto LABEL_26;
        case 1879048239:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 69;
          uint64_t v24 = "MIPS_COMPACT_SIZE";
LABEL_165:
          *(_OWORD *)a3 = *(_OWORD *)v24;
          return;
        case 1879048240:
          unint64_t v8 = "MIPS_GP_VALUE";
          goto LABEL_23;
        case 1879048241:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_AUX_DYNAMIC";
          goto LABEL_26;
        case 1879048242:
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414481748;
          unint64_t v4 = "MIPS_PLTGOT";
          goto LABEL_46;
        case 1879048244:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 21580;
          __int16 v14 = "MIPS_RWPLT";
          goto LABEL_172;
        case 1879048245:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_RLD_MAP_REL";
          goto LABEL_26;
        case 1879048246:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 18515;
          __int16 v14 = "MIPS_XHASH";
LABEL_172:
          *(void *)a3 = *(void *)v14;
          *(unsigned char *)(a3 + 10) = 0;
          break;
        default:
          goto LABEL_27;
      }
      return;
    }
    if (a1 == 20)
    {
      if (a2 == 1879048193)
      {
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1598246992;
        int v7 = 1414549343;
      }
      else
      {
        if (a2 != 1879048192) {
          goto LABEL_27;
        }
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1598246992;
        int v7 = 1414481759;
      }
LABEL_116:
      *(_DWORD *)(a3 + 3) = v7;
      *(unsigned char *)(a3 + 7) = 0;
      return;
    }
    if (a1 == 21 && a2 == 1879048192)
    {
      *(unsigned char *)(a3 + 23) = 11;
      *(_DWORD *)(a3 + 7) = 1263421772;
      unint64_t v4 = "PPC64_GLINK";
LABEL_46:
      *(void *)a3 = *(void *)v4;
      *(unsigned char *)(a3 + 11) = 0;
      return;
    }
  }
LABEL_27:
  if (a2 <= 1879039999)
  {
    switch(a2)
    {
      case 0:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1280070990;
        goto LABEL_113;
      case 1:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1145390414;
        __int16 v10 = 17477;
        goto LABEL_111;
      case 2:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x5A534C4552544C50;
        goto LABEL_98;
      case 3:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1196706896;
        __int16 v10 = 21583;
        goto LABEL_111;
      case 4:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1213415752;
        goto LABEL_113;
      case 5:
        *(unsigned char *)(a3 + 23) = 6;
        int v17 = 1414681683;
        goto LABEL_76;
      case 6:
        *(unsigned char *)(a3 + 23) = 6;
        int v17 = 1414355283;
LABEL_76:
        *(_DWORD *)a3 = v17;
        __int16 v10 = 16961;
        goto LABEL_111;
      case 7:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1095517522;
        goto LABEL_113;
      case 8:
        *(unsigned char *)(a3 + 23) = 6;
        int v18 = 1095517522;
        goto LABEL_110;
      case 9:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1095517522;
        unsigned __int16 v19 = 17729;
        goto LABEL_115;
      case 10:
        *(unsigned char *)(a3 + 23) = 5;
        int v20 = 1397904467;
        goto LABEL_89;
      case 11:
        *(unsigned char *)(a3 + 23) = 6;
        int v21 = 1162697043;
        goto LABEL_91;
      case 12:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1414090313;
        goto LABEL_113;
      case 13:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1229867334;
        goto LABEL_113;
      case 14:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1095651155;
        __int16 v10 = 17741;
        goto LABEL_111;
      case 15:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1413566546;
        __int16 v22 = 72;
        goto LABEL_105;
      case 16:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x43494C4F424D5953;
        goto LABEL_98;
      case 17:
        *(unsigned char *)(a3 + 23) = 3;
        *(_DWORD *)a3 = 4998482;
        return;
      case 18:
        *(unsigned char *)(a3 + 23) = 5;
        int v20 = 1397507410;
LABEL_89:
        *(_DWORD *)a3 = v20;
        __int16 v22 = 90;
        goto LABEL_105;
      case 19:
        *(unsigned char *)(a3 + 23) = 6;
        int v21 = 1162626386;
LABEL_91:
        *(_DWORD *)a3 = v21;
        __int16 v10 = 21582;
        goto LABEL_111;
      case 20:
        *(unsigned char *)(a3 + 23) = 6;
        int v23 = 1381256272;
        goto LABEL_96;
      case 21:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1430406468;
        __int16 v22 = 71;
        goto LABEL_105;
      case 22:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1415071060;
        int v7 = 1279611476;
        goto LABEL_116;
      case 23:
        *(unsigned char *)(a3 + 23) = 6;
        int v23 = 1380994378;
LABEL_96:
        *(_DWORD *)a3 = v23;
        __int16 v10 = 19525;
        goto LABEL_111;
      case 24:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x574F4E5F444E4942;
        goto LABEL_98;
      case 25:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 22849;
        __int16 v14 = "INIT_ARRAY";
        goto LABEL_172;
      case 26:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 22849;
        __int16 v14 = "FINI_ARRAY";
        goto LABEL_172;
      case 27:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1515411777;
        __int16 v15 = "INIT_ARRAYSZ";
        goto LABEL_157;
      case 28:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1515411777;
        __int16 v15 = "FINI_ARRAYSZ";
        goto LABEL_157;
      case 29:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1347310930;
        int v7 = 1213481296;
        goto LABEL_116;
      case 30:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1195461702;
        __int16 v22 = 83;
LABEL_105:
        *(_WORD *)(a3 + 4) = v22;
        return;
      case 31:
        goto LABEL_174;
      case 32:
        unint64_t v8 = "PREINIT_ARRAY";
        goto LABEL_23;
      case 33:
        uint64_t v5 = "PREINIT_ARRAYSZ";
        goto LABEL_43;
      case 34:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1480871496;
        __int16 v15 = "SYMTAB_SHNDX";
        goto LABEL_157;
      case 35:
        *(unsigned char *)(a3 + 23) = 6;
        int v18 = 1380730194;
LABEL_110:
        *(_DWORD *)a3 = v18;
        __int16 v10 = 23123;
        goto LABEL_111;
      case 36:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1380730194;
        goto LABEL_113;
      case 37:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1380730194;
        unsigned __int16 v19 = 17746;
LABEL_115:
        int v7 = v19 | 0x544E0000;
        goto LABEL_116;
      default:
        switch(a2)
        {
          case 1610612751:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1279611487;
            unint64_t v4 = "ANDROID_REL";
            goto LABEL_46;
          case 1610612752:
            unint64_t v8 = "ANDROID_RELSZ";
            goto LABEL_23;
          case 1610612753:
            *(unsigned char *)(a3 + 23) = 12;
            *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1095517522;
            __int16 v15 = "ANDROID_RELA";
            goto LABEL_157;
          case 1610612754:
            std::string::size_type v16 = "ANDROID_RELASZ";
            goto LABEL_159;
          default:
            goto LABEL_174;
        }
    }
  }
  if (a2 <= 1879048175)
  {
    if (a2 > 1879047924)
    {
      if (a2 != 1879047925)
      {
        if (a2 == 1879047926)
        {
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414287455;
          unint64_t v4 = "TLSDESC_PLT";
          goto LABEL_46;
        }
        if (a2 == 1879047927)
        {
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414481759;
          unint64_t v4 = "TLSDESC_GOT";
          goto LABEL_46;
        }
        goto LABEL_174;
      }
      *(unsigned char *)(a3 + 23) = 8;
      uint64_t v13 = 0x485341485F554E47;
LABEL_98:
      *(void *)a3 = v13;
      *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = 0;
      return;
    }
    if (a2 == 1879040000)
    {
      *(unsigned char *)(a3 + 23) = 12;
      *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1380730194;
      __int16 v15 = "ANDROID_RELR";
LABEL_157:
      *(void *)a3 = *(void *)v15;
      *(unsigned char *)(a3 + 12) = 0;
      return;
    }
    if (a2 == 1879040001)
    {
      std::string::size_type v16 = "ANDROID_RELRSZ";
LABEL_159:
      *(unsigned char *)(a3 + 23) = 14;
      *(void *)a3 = *(void *)v16;
      *(void *)(a3 + 6) = *(void *)(v16 + 6);
      *(unsigned char *)(a3 + 14) = 0;
      return;
    }
    if (a2 != 1879040003) {
      goto LABEL_174;
    }
    uint64_t v5 = "ANDROID_RELRENT";
LABEL_43:
    *(unsigned char *)(a3 + 23) = 15;
    *(void *)a3 = *(void *)v5;
    *(void *)(a3 + 7) = *(void *)(v5 + 7);
    *(unsigned char *)(a3 + 15) = 0;
    return;
  }
  if (a2 <= 2147483644)
  {
    switch(a2)
    {
      case 1879048176:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1397900630;
        __int16 v10 = 19801;
        goto LABEL_111;
      case 1879048185:
        *(unsigned char *)(a3 + 23) = 9;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 84;
        long long v12 = "RELACOUNT";
        goto LABEL_126;
      case 1879048186:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x544E554F434C4552;
        goto LABEL_98;
      case 1879048187:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1195461702;
        int v7 = 828330823;
        goto LABEL_116;
      case 1879048188:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1146242390;
        __int16 v10 = 17989;
        goto LABEL_111;
      case 1879048189:
        *(unsigned char *)(a3 + 23) = 9;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 77;
        long long v12 = "VERDEFNUM";
        goto LABEL_126;
      case 1879048190:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1314014550;
        int v7 = 1145390414;
        goto LABEL_116;
      case 1879048191:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 19797;
        __int16 v14 = "VERNEEDNUM";
        goto LABEL_172;
      default:
        goto LABEL_174;
    }
  }
  if (a2 != 2147483645)
  {
    if (a2 == 2147483646)
    {
      *(unsigned char *)(a3 + 23) = 4;
      int v9 = 1145394005;
LABEL_113:
      *(_DWORD *)a3 = v9;
      *(unsigned char *)(a3 + 4) = 0;
      return;
    }
    if (a2 == 0x7FFFFFFF)
    {
      *(unsigned char *)(a3 + 23) = 6;
      *(_DWORD *)a3 = 1414285638;
      __int16 v10 = 21061;
LABEL_111:
      *(_WORD *)(a3 + 4) = v10;
      *(unsigned char *)(a3 + 6) = 0;
      return;
    }
LABEL_174:
    sub_1CD5E9F58(a2, 1, 0, &v30);
    __int16 v28 = std::string::insert(&v30, 0, "<unknown:>0x");
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)a3 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    *(void *)(a3 + ++*(_DWORD *)(this + 16) = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    return;
  }
  *(unsigned char *)(a3 + 23) = 9;
  *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 89;
  long long v12 = "AUXILIARY";
LABEL_126:
  *(void *)a3 = *(void *)v12;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getDynamicTagAsString()
{
}

{
  while (1)
    ;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getRelocationSymbol@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *result;
  if (*(_WORD *)(*result + 18) == 8 && *(unsigned char *)(v4 + 4) == 2)
  {
    if (*(unsigned char *)(v4 + 5) == 1) {
      unint64_t v5 = *(void *)(a2 + 8) << 32;
    }
    else {
      unint64_t v5 = *(void *)(a2 + 8);
    }
  }
  else
  {
    unint64_t v5 = *(void *)(a2 + 8);
  }
  unint64_t v6 = HIDWORD(v5);
  if (v6) {
    return sub_1CD6D1BF4(result, a3, v6, a4);
  }
  *(unsigned char *)(a4 + 8) &= ~1u;
  *(void *)a4 = 0;
  return result;
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::isMips64EL(uint64_t *a1)
{
  uint64_t v1 = *a1;
  return *(_WORD *)(*a1 + 18) == 8 && *(unsigned char *)(v1 + 4) == 2 && *(unsigned char *)(v1 + 5) == 1;
}

char **llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::loadVersionMap@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  std::string::size_type v42 = &v44;
  uint64_t v43 = 0;
  __p[0] = 0;
  __p[1] = 0;
  char v40 = 0;
  unint64_t v39 = 0;
  char v41 = 1;
  sub_1CCC297E0((uint64_t)&v42, (unint64_t)__p);
  if (v41 && SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  char v40 = 0;
  unint64_t v39 = 0;
  char v41 = 1;
  sub_1CCC297E0((uint64_t)&v42, (unint64_t)__p);
  if (v41 && SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  if (a3)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getVersionDefinitions(a1, a3, (uint64_t)&v44);
    unint64_t v8 = v44;
    if (v46)
    {
      std::string::size_type v44 = 0;
      *(unsigned char *)(a4 + 16) |= 1u;
      *(void *)a4 = v8;
      sub_1CCC3FEAC((uint64_t)&v44);
      return sub_1CCC3FDC0((char **)&v42);
    }
    uint64_t v35 = a1;
    int v9 = v45;
    if (v44 != v45)
    {
      __int16 v10 = v44 + 3;
      do
      {
        unsigned int v11 = *((_DWORD *)v10 - 3) & 0x7FFF;
        char v12 = *((unsigned char *)v10 + 23);
        BOOL v13 = v12 < 0;
        if (v12 >= 0) {
          __int16 v14 = v10;
        }
        else {
          __int16 v14 = *v10;
        }
        size_t v15 = v12 & 0x7F;
        if (v13) {
          size_t v16 = (size_t)v10[1];
        }
        else {
          size_t v16 = v15;
        }
        if (v43 <= v11) {
          sub_1CCC3EBD0((uint64_t)&v42, v11 + 1);
        }
        if (v16 > 0x7FFFFFFFFFFFFFF7) {
LABEL_68:
        }
          abort();
        if (v16 >= 0x17)
        {
          uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v16 | 7) != 0x17) {
            uint64_t v18 = v16 | 7;
          }
          uint64_t v19 = v18 + 1;
          int v17 = operator new(v18 + 1);
          __p[1] = (void *)v16;
          unint64_t v39 = v19 | 0x8000000000000000;
          __p[0] = v17;
        }
        else
        {
          HIBYTE(v39) = v16;
          int v17 = __p;
          if (!v16) {
            goto LABEL_27;
          }
        }
        memmove(v17, v14, v16);
LABEL_27:
        *((unsigned char *)v17 + v++*(_DWORD *)(this + 16) = 0;
        int v20 = (char *)&v42[5 * v11];
        int v21 = v20 + 32;
        if (v20[32])
        {
          if (v20[23] < 0) {
            operator delete(*(void **)v20);
          }
          *(_OWORD *)int v20 = *(_OWORD *)__p;
          *((void *)v20 + 2) = v39;
          int v21 = v20 + 24;
        }
        else
        {
          *(_OWORD *)int v20 = *(_OWORD *)__p;
          *((void *)v20 + 2) = v39;
          v20[24] = 1;
        }
        *int v21 = 1;
        __int16 v22 = v10 + 6;
        v10 += 9;
      }
      while (v22 != v9);
    }
    sub_1CCC3FEAC((uint64_t)&v44);
    a1 = v35;
  }
  if (a2)
  {
    __p[0] = sub_1CCC27114;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getVersionDependencies(a1, a2, (void (*)(unsigned __int16 **__return_ptr, uint64_t, long long *))sub_1CD6D6140, (uint64_t)__p, (uint64_t)&v44);
    int v23 = v44;
    if ((v46 & 1) == 0)
    {
      uint64_t v36 = a4;
      char v37 = v45;
      if (v44 == v45) {
        goto LABEL_62;
      }
      while (1)
      {
        uint64_t v24 = (char *)v23[5];
        unint64_t v25 = (char *)v23[6];
        while (v24 != v25)
        {
          unsigned int v26 = *((_DWORD *)v24 + 2) & 0x7FFF;
          char v27 = v24[39];
          if (v27 >= 0) {
            __int16 v28 = v24 + 16;
          }
          else {
            __int16 v28 = (const void *)*((void *)v24 + 2);
          }
          if (v27 >= 0) {
            size_t v29 = v27 & 0x7F;
          }
          else {
            size_t v29 = *((void *)v24 + 3);
          }
          if (v43 <= v26) {
            sub_1CCC3EBD0((uint64_t)&v42, v26 + 1);
          }
          if (v29 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_68;
          }
          if (v29 >= 0x17)
          {
            uint64_t v31 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v29 | 7) != 0x17) {
              uint64_t v31 = v29 | 7;
            }
            uint64_t v32 = v31 + 1;
            std::string v30 = operator new(v31 + 1);
            __p[1] = (void *)v29;
            unint64_t v39 = v32 | 0x8000000000000000;
            __p[0] = v30;
LABEL_54:
            memmove(v30, v28, v29);
            goto LABEL_55;
          }
          HIBYTE(v39) = v29;
          std::string v30 = __p;
          if (v29) {
            goto LABEL_54;
          }
LABEL_55:
          *((unsigned char *)v30 + v29) = 0;
          uint64_t v33 = (char *)&v42[5 * v26];
          if (v33[32])
          {
            if (v33[23] < 0) {
              operator delete(*(void **)v33);
            }
            *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
            *((void *)v33 + 2) = v39;
            v33[24] = 0;
          }
          else
          {
            *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
            *((void *)v33 + 2) = v39;
            v33[24] = 0;
            v33[32] = 1;
          }
          v24 += 40;
        }
        v23 += 8;
        if (v23 == v37)
        {
LABEL_62:
          sub_1CCC3FF24((uint64_t)&v44);
          a4 = v36;
          goto LABEL_63;
        }
      }
    }
    std::string::size_type v44 = 0;
    *(unsigned char *)(a4 + 16) |= 1u;
    *(void *)a4 = v23;
    sub_1CCC3FF24((uint64_t)&v44);
  }
  else
  {
LABEL_63:
    *(unsigned char *)(a4 + 16) &= ~1u;
    *(void *)a4 = a4 + 16;
    *(void *)(a4 + ++*(_DWORD *)(this + 8) = 0;
    if (v43) {
      sub_1CCC3FF9C(a4, (uint64_t)&v42);
    }
  }
  return sub_1CCC3FDC0((char **)&v42);
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::isLE(uint64_t a1)
{
  return *(unsigned char *)(*(void *)a1 + 5) == 1;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::program_headers@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  uint64_t v4 = *(unsigned __int16 *)(*result + 56);
  if (*(_WORD *)(*result + 56))
  {
    uint64_t v5 = *(unsigned __int16 *)(v3 + 54);
    if (v5 != 56)
    {
      unsigned int v26 = "invalid e_phentsize: ";
      uint64_t v27 = v5;
      __int16 v6 = 2307;
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v5 = *(unsigned __int16 *)(v3 + 54);
  }
  unint64_t v7 = v5 * (unint64_t)*(unsigned __int16 *)(*result + 56);
  uint64_t v8 = *(void *)(v3 + 32);
  unint64_t v9 = result[1];
  BOOL v10 = __CFADD__(v8, v7);
  unint64_t v11 = v8 + v7;
  if (v10 || v11 > v9)
  {
    uint64_t v12 = *(void *)(v3 + 32);
    unint64_t v13 = v9;
    v14[0] = "program headers are longer than binary of size ";
    unint64_t v14[2] = &v13;
    __int16 v15 = 2563;
    v16[0] = v14;
    _OWORD v16[2] = ": e_phoff = 0x";
    __int16 v17 = 770;
    v18[0] = v16;
    v18[2] = &v12;
    __int16 v19 = 3586;
    v20[0] = v18;
    v20[2] = ", e_phnuuint64_t m = ";
    __int16 v21 = 770;
    v22[0] = v20;
    v22[2] = v4;
    __int16 v6 = 2306;
    __int16 v23 = 2306;
    v24[0] = v22;
    v24[2] = ", e_phentstd::string::size_type size = ";
    __int16 v25 = 770;
    unsigned int v26 = (const char *)v24;
    uint64_t v27 = v5;
LABEL_9:
    __int16 v28 = v6;
    operator new();
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  *(void *)a2 = v3 + v8;
  *(void *)(a2 + ++*(_DWORD *)(this + 8) = v4;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::symbols@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    return llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relas(result, a2, a3);
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = 0;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = 0;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relrs@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = result;
  if (a2[7] != 8)
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v29);
    unint64_t v9 = std::string::insert(&v29, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    unint64_t v11 = std::string::append(&v31, " has invalid sh_entsize: expected ");
    uint64_t v12 = (uint64_t *)v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    uint64_t v35 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    v33.__r_.__value_.__r.__words[0] = 8;
    v39[0] = __p;
    char v40 = &v33;
    __int16 v41 = 2564;
    v42[0] = v39;
    uint64_t v43 = (std::string *)", but got ";
    __int16 v44 = 770;
    v28.__r_.__value_.__r.__words[0] = a2[7];
    std::string::size_type v45 = v42;
    char v46 = &v28;
    __int16 v47 = 3074;
    operator new();
  }
  uint64_t v6 = a2[3];
  unint64_t v7 = a2[4];
  unint64_t v37 = v7;
  uint64_t v38 = v6;
  if ((v7 & 7) != 0)
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v33);
    unint64_t v13 = std::string::insert(&v33, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    __int16 v15 = std::string::append(&v29, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __p[0] = &v31;
    uint64_t v35 = (uint64_t *)&v37;
    __int16 v36 = 3076;
    v39[0] = __p;
    char v40 = (std::string *)") which is not a multiple of its sh_entsize (";
    __int16 v41 = 770;
    v28.__r_.__value_.__r.__words[0] = a2[7];
    v42[0] = v39;
    uint64_t v43 = &v28;
    __int16 v44 = 3074;
    __int16 v17 = ")";
    goto LABEL_9;
  }
  if (__CFADD__(v6, v7))
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v33);
    uint64_t v18 = std::string::insert(&v33, 0, "section ");
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    int v20 = std::string::append(&v29, " has a sh_offset (0x");
    std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    __p[0] = &v31;
    uint64_t v35 = &v38;
    __int16 v36 = 3588;
    v39[0] = __p;
    char v40 = (std::string *)") + sh_size (0x";
    __int16 v41 = 770;
    v42[0] = v39;
    uint64_t v43 = (std::string *)&v37;
    __int16 v44 = 3586;
    __int16 v17 = ") that cannot be represented";
LABEL_9:
    std::string::size_type v45 = v42;
    char v46 = (std::string *)v17;
    __int16 v47 = 770;
    operator new();
  }
  if (v7 + v6 > result[1])
  {
    sub_1CD6D0838(result, (uint64_t)a2, (char *)&v27);
    __int16 v22 = std::string::insert(&v27, 0, "section ");
    std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v28.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v28.__r_.__value_.__r.__words[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    uint64_t v24 = std::string::append(&v28, " has a sh_offset (0x");
    std::string::size_type v25 = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&v33;
    v29.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38;
    __int16 v30 = 3588;
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
    v31.__r_.__value_.__r.__words[2] = (std::string::size_type)") + sh_size (0x";
    __int16 v32 = 770;
    __p[0] = &v31;
    uint64_t v35 = (uint64_t *)&v37;
    __int16 v36 = 3586;
    v39[0] = __p;
    char v40 = (std::string *)") that is greater than the file size (0x";
    __int16 v41 = 770;
    uint64_t v26 = v4[1];
    v42[0] = v39;
    uint64_t v43 = (std::string *)&v26;
    __int16 v44 = 3586;
    std::string::size_type v45 = v42;
    char v46 = (std::string *)")";
    __int16 v47 = 770;
    operator new();
  }
  uint64_t v8 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v7 >> 3;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::decode_relrs(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, unint64_t **a4@<X8>)
{
  unsigned int ELFRelativeRelocationType = llvm::object::getELFRelativeRelocationType((llvm::object *)*(unsigned __int16 *)(*(void *)a1 + 18));
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  if (a3)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    unint64_t v10 = ELFRelativeRelocationType;
    unint64_t v11 = &a2[a3];
    uint64_t v35 = v11;
    do
    {
      unint64_t v12 = *a2;
      if (*a2)
      {
        unint64_t v15 = v9;
        if (v12 >= 2)
        {
          do
          {
            if ((v12 & 2) != 0)
            {
              unint64_t v16 = (unint64_t)a4[2];
              if ((unint64_t)v8 >= v16)
              {
                uint64_t v18 = *a4;
                uint64_t v19 = ((char *)v8 - (char *)*a4) >> 4;
                unint64_t v20 = v19 + 1;
                if ((unint64_t)(v19 + 1) >> 60) {
                  goto LABEL_46;
                }
                uint64_t v21 = v16 - (void)v18;
                if (v21 >> 3 > v20) {
                  unint64_t v20 = v21 >> 3;
                }
                if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v22 = v20;
                }
                if (v22)
                {
                  if (v22 >> 60) {
                    goto LABEL_47;
                  }
                  std::string::size_type v23 = (char *)operator new(16 * v22);
                }
                else
                {
                  std::string::size_type v23 = 0;
                }
                uint64_t v24 = &v23[16 * v19];
                *(void *)uint64_t v24 = v15;
                *((void *)v24 + 1) = v10;
                std::string::size_type v25 = v24;
                if (v8 != v18)
                {
                  do
                  {
                    *((_OWORD *)v25 - 1) = *((_OWORD *)v8 - 1);
                    v25 -= 16;
                    v8 -= 2;
                  }
                  while (v8 != v18);
                  uint64_t v8 = *a4;
                }
                __int16 v17 = (unint64_t *)(v24 + 16);
                *a4 = (unint64_t *)v25;
                a4[1] = (unint64_t *)(v24 + 16);
                a4[2] = (unint64_t *)&v23[16 * v22];
                if (v8) {
                  operator delete(v8);
                }
              }
              else
              {
                *uint64_t v8 = v15;
                v8[1] = v10;
                __int16 v17 = v8 + 2;
              }
              a4[1] = v17;
              uint64_t v8 = v17;
            }
            v15 += 8;
            BOOL v26 = v12 >= 4;
            v12 >>= 1;
          }
          while (v26);
        }
        v9 += 504;
        unint64_t v11 = v35;
      }
      else
      {
        unint64_t v13 = (unint64_t)a4[2];
        if ((unint64_t)v8 >= v13)
        {
          std::string v27 = *a4;
          uint64_t v28 = ((char *)v8 - (char *)*a4) >> 4;
          unint64_t v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) >> 60) {
LABEL_46:
          }
            abort();
          uint64_t v30 = v13 - (void)v27;
          if (v30 >> 3 > v29) {
            unint64_t v29 = v30 >> 3;
          }
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v31 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v29;
          }
          if (v31)
          {
            if (v31 >> 60) {
LABEL_47:
            }
              sub_1CB833614();
            __int16 v32 = (char *)operator new(16 * v31);
          }
          else
          {
            __int16 v32 = 0;
          }
          std::string v33 = (unint64_t *)&v32[16 * v28];
          *std::string v33 = v12;
          v33[1] = v10;
          long long v34 = v33;
          if (v8 != v27)
          {
            do
            {
              *((_OWORD *)v34 - 1) = *((_OWORD *)v8 - 1);
              v34 -= 2;
              v8 -= 2;
            }
            while (v8 != v27);
            uint64_t v8 = *a4;
          }
          std::string::size_type v14 = v33 + 2;
          *a4 = v34;
          a4[1] = v33 + 2;
          a4[2] = (unint64_t *)&v32[16 * v31];
          if (v8) {
            operator delete(v8);
          }
        }
        else
        {
          *uint64_t v8 = v12;
          v8[1] = v10;
          std::string::size_type v14 = v8 + 2;
        }
        a4[1] = v14;
        unint64_t v9 = v12 + 8;
        uint64_t v8 = v14;
      }
      ++a2;
    }
    while (a2 != v11);
  }
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::android_relas@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionContents(a1, a2, (uint64_t)&v48);
  uint64_t v6 = v48;
  if (v50)
  {
    std::string::size_type v48 = 0;
LABEL_12:
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
    goto LABEL_14;
  }
  if (v49 < 4 || *v48 != 65 || v48[1] != 80 || v48[2] != 83 || v48[3] != 50)
  {
    char v46 = "invalid packed relocation header";
    __int16 v47 = 259;
    operator new();
  }
  BOOL v7 = *(unsigned char *)(*a1 + 5) == 1;
  v43[0] = v48;
  v43[1] = v49;
  BOOL v44 = v7;
  char v45 = 8;
  uint64_t v8 = &v42;
  uint64_t v41 = 4;
  uint64_t v42 = 0;
  unint64_t SLEB128 = llvm::DataExtractor::getSLEB128(v43, &v41, &v42);
  uint64_t result = llvm::DataExtractor::getSLEB128(v43, &v41, &v42);
  uint64_t v6 = (unsigned char *)v42;
  if (v42) {
    goto LABEL_12;
  }
  uint64_t v10 = result;
  uint64_t v35 = a3;
  if (SLEB128)
  {
    if (SLEB128 > 0xAAAAAAAAAAAAAAALL) {
LABEL_74:
    }
      abort();
    unint64_t v11 = (char *)operator new(24 * SLEB128);
    unint64_t v12 = &v11[24 * SLEB128];
  }
  else
  {
    unint64_t v11 = 0;
    unint64_t v12 = 0;
  }
  uint64_t v13 = 0;
  std::string::size_type v14 = v11;
  do
  {
    if (!SLEB128)
    {
      *(unsigned char *)(v35 + 24) &= ~1u;
      *(void *)uint64_t v35 = v11;
      *(void *)(v35 + ++*(_DWORD *)(this + 8) = v14;
      *(void *)(v35 + ++*(_DWORD *)(this + 16) = v12;
      goto LABEL_72;
    }
    unint64_t v15 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    uint64_t v16 = v42;
    if (v42) {
      break;
    }
    unint64_t v17 = v15;
    BOOL v18 = SLEB128 >= v15;
    SLEB128 -= v15;
    if (!v18)
    {
      char v46 = "relocation group unexpectedly large";
      __int16 v47 = 259;
      operator new();
    }
    uint64_t v40 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    if ((v40 & 2) != 0) {
      uint64_t v39 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    }
    else {
      uint64_t v39 = 0;
    }
    if (v40) {
      uint64_t v38 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    }
    else {
      uint64_t v38 = 0;
    }
    uint64_t v37 = v40 & 0xC;
    if (v37 == 12) {
      v13 += llvm::DataExtractor::getSLEB128(v43, &v41, v8);
    }
    v13 &= v40 << 60 >> 63;
    uint64_t v16 = v42;
    BOOL v19 = v42 == 0;
    if (!v42 && v17)
    {
      unint64_t v36 = SLEB128;
      uint64_t v20 = 0;
      do
      {
        uint64_t v21 = v39;
        if ((v40 & 2) == 0) {
          uint64_t v21 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
        }
        uint64_t v22 = v38;
        if ((v40 & 1) == 0) {
          uint64_t v22 = llvm::DataExtractor::getSLEB128(v43, &v41, v8);
        }
        if (v37 == 8) {
          v13 += llvm::DataExtractor::getSLEB128(v43, &v41, v8);
        }
        v10 += v21;
        if (v14 >= v12)
        {
          std::string::size_type v23 = v12;
          uint64_t v24 = v8;
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v11) >> 3) + 1;
          if (v25 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_74;
          }
          unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((v23 - v11) >> 3);
          if (2 * v26 > v25) {
            unint64_t v25 = 2 * v26;
          }
          if (v26 >= 0x555555555555555) {
            unint64_t v27 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27)
          {
            if (v27 > 0xAAAAAAAAAAAAAAALL) {
              sub_1CB833614();
            }
            uint64_t v28 = (char *)operator new(24 * v27);
          }
          else
          {
            uint64_t v28 = 0;
          }
          unint64_t v29 = (uint64_t *)&v28[8 * ((v14 - v11) >> 3)];
          uint64_t *v29 = v10;
          v29[1] = v22;
          v29[2] = v13;
          if (v14 == v11)
          {
            __int16 v32 = &v28[8 * ((v14 - v11) >> 3)];
          }
          else
          {
            uint64_t v30 = &v28[8 * ((v14 - v11) >> 3)];
            do
            {
              long long v31 = *(_OWORD *)(v14 - 24);
              __int16 v32 = v30 - 24;
              *((void *)v30 - 1) = *((void *)v14 - 1);
              *(_OWORD *)(v30 - 24) = v31;
              v14 -= 24;
              v30 -= 24;
            }
            while (v14 != v11);
          }
          std::string v33 = &v28[24 * v27];
          std::string::size_type v14 = (char *)(v29 + 3);
          if (v11) {
            operator delete(v11);
          }
          unint64_t v11 = v32;
          uint64_t v8 = v24;
          unint64_t v12 = v33;
        }
        else
        {
          *(void *)std::string::size_type v14 = v10;
          *((void *)v14 + 1) = v22;
          *((void *)v14 + 2) = v13;
          v14 += 24;
        }
        ++v20;
        uint64_t v16 = v42;
        BOOL v19 = v42 == 0;
        if (v42) {
          BOOL v34 = 1;
        }
        else {
          BOOL v34 = v20 == v17;
        }
      }
      while (!v34);
      unint64_t SLEB128 = v36;
    }
  }
  while (v19);
  uint64_t v42 = 0;
  *(unsigned char *)(v35 + 24) |= 1u;
  *(void *)uint64_t v35 = v16;
  if (v11) {
    operator delete(v11);
  }
LABEL_72:
  uint64_t result = v42;
  if (v42) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v42 + 8))(v42);
  }
LABEL_14:
  if (v50)
  {
    uint64_t result = (uint64_t)v48;
    std::string::size_type v48 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::notes_begin@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void **a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(void *)(a2 + 32);
  if ((unint64_t)(v7 + v6) > a1[1])
  {
    uint64_t v9 = *(void *)(a2 + 32);
    uint64_t v10 = v6;
    v11[0] = "invalid offset (0x";
    v11[2] = &v10;
    __int16 v12 = 3587;
    v13[0] = v11;
    _OWORD v13[2] = ") or size (0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    unint64_t v17 = v15;
    BOOL v18 = ")";
    __int16 v19 = 770;
    operator new();
  }
  uint64_t result = sub_1CCC40C58(a4, *a1 + v6, v7, a3);
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

{
  uint64_t v6;
  uint64_t v7;
  void *result;
  uint64_t v9;
  uint64_t v10;
  void v11[4];
  __int16 v12;
  void v13[4];
  __int16 v14;
  void v15[4];
  __int16 v16;
  void *v17;
  const char *v18;
  __int16 v19;

  uint64_t v7 = *(void *)(a2 + 24);
  uint64_t v6 = *(void *)(a2 + 32);
  if ((unint64_t)(v6 + v7) > a1[1])
  {
    uint64_t v9 = *(void *)(a2 + 32);
    uint64_t v10 = v7;
    v11[0] = "invalid offset (0x";
    v11[2] = &v10;
    __int16 v12 = 3587;
    v13[0] = v11;
    _OWORD v13[2] = ") or size (0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    unint64_t v17 = v15;
    BOOL v18 = ")";
    __int16 v19 = 770;
    operator new();
  }
  uint64_t result = sub_1CCC40C58(a4, *a1 + v7, v6, a3);
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::notes_end(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::notes()
{
}

{
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::notes_begin();
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSymbol@<X0>(void *a1@<X0>, void *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    unint64_t v26 = 0;
    unint64_t v27 = 0;
    uint64_t v8 = a3;
    char v28 = 0;
    goto LABEL_3;
  }
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relas(a1, a2, (uint64_t)&v26);
  char v14 = v28;
  if (v28)
  {
    unint64_t v15 = v26;
    unint64_t v26 = 0;
    char v16 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    uint64_t v8 = a3;
    if (v27 <= a3)
    {
LABEL_3:
      sub_1CD6D0838(a1, (uint64_t)a2, (char *)&v17);
      uint64_t v9 = std::string::insert(&v17, 0, "unable to get symbol from section ");
      std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v10;
      v9->__r_.__value_.__l.__size_ = 0;
      v9->__r_.__value_.__r.__words[2] = 0;
      v9->__r_.__value_.__r.__words[0] = 0;
      unint64_t v11 = std::string::append(&v18, ": invalid symbol index (");
      std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      std::string::size_type v20 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      v21[0] = __p;
      v21[2] = v8;
      __int16 v22 = 2052;
      std::string::size_type v23 = v21;
      uint64_t v24 = ")";
      __int16 v25 = 770;
      operator new();
    }
    unint64_t v15 = &v26[3 * a3];
    char v16 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v16;
  *(void *)a4 = v15;
  if (v14)
  {
    uint64_t result = v26;
    unint64_t v26 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSegmentContents@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v7 = v5;
  uint64_t v8 = v4;
  if (__CFADD__(v4, v5)) {
    sub_1CCC378A0();
  }
  if ((unint64_t)(v5 + v4) > result[1]) {
    sub_1CCC378A0();
  }
  uint64_t v6 = *result + v4;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v6;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v5;
  return result;
}

void sub_1CCC378A0()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::program_headers();
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::decodeBBAddrMap(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSectionContents(a1, a2, (uint64_t)&v65);
  if (v67)
  {
    uint64_t v33 = v65;
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v33;
  }
  else
  {
    BOOL v5 = *(unsigned char *)(*a1 + 5) == 1;
    v46[0] = v65;
    v46[1] = v66;
    BOOL v47 = v5;
    unsigned __int8 v48 = 8;
    long long v44 = 0uLL;
    uint64_t v45 = 0;
    unsigned long long v43 = 0uLL;
    uint64_t v35 = v66;
    if (v66)
    {
      do
      {
        unsigned int Unsigned = (void **)llvm::DataExtractor::getUnsigned(v46, (unint64_t *)&v43, v48, (void *)&v43 + 1);
        uint64_t v64 = v43;
        unint64_t ULEB128 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
        unsigned int v38 = ULEB128;
        if (HIDWORD(ULEB128))
        {
          v49[0] = "ULEB128 value at offset 0x";
          char v50 = &v64;
          __int16 v51 = 3587;
          v52[0] = v49;
          std::string::size_type v53 = " exceeds UINT32_MAX (0x";
          __int16 v54 = 770;
          v55[0] = v52;
          p_unint64_t ULEB128 = &ULEB128;
          __int16 v57 = 3586;
          std::string::size_type v58 = (void **)v55;
          std::string::size_type v60 = ")";
          __int16 v62 = 770;
          operator new();
        }
        unsigned int v6 = 0;
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        uint64_t v9 = 0;
        while (!*((void *)&v43 + 1) && v6 < v38)
        {
          uint64_t v64 = v43;
          unint64_t v11 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v11;
          unsigned int v39 = v6;
          if (HIDWORD(v11))
          {
            v49[0] = "ULEB128 value at offset 0x";
            char v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            std::string::size_type v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            std::string::size_type v58 = (void **)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v12 = v11;
          uint64_t v64 = v43;
          unint64_t v13 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v13;
          if (HIDWORD(v13))
          {
            v49[0] = "ULEB128 value at offset 0x";
            char v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            std::string::size_type v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            std::string::size_type v58 = (void **)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v14 = v13;
          uint64_t v64 = v43;
          unint64_t v15 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v15;
          if (HIDWORD(v15))
          {
            v49[0] = "ULEB128 value at offset 0x";
            char v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            std::string::size_type v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            std::string::size_type v58 = (void **)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v16 = v14;
          unsigned int v17 = (v15 >> 1) & 1;
          char v18 = v15 & 1;
          unsigned int v19 = (v15 >> 2) & 1;
          unsigned int v20 = (v15 >> 3) & 1;
          if (v8 >= v7)
          {
            unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 2) + 1;
            if (v23 > 0x1555555555555555) {
              abort();
            }
            if (0x5555555555555556 * ((v7 - v9) >> 2) > v23) {
              unint64_t v23 = 0x5555555555555556 * ((v7 - v9) >> 2);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v7 - v9) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
              unint64_t v24 = 0x1555555555555555;
            }
            else {
              unint64_t v24 = v23;
            }
            if (v24)
            {
              if (v24 > 0x1555555555555555) {
                sub_1CB833614();
              }
              unsigned int v25 = (v15 >> 3) & 1;
              int v26 = v16;
              unint64_t v37 = v24;
              unint64_t v27 = (char *)operator new(12 * v24);
              unint64_t v24 = v37;
              int v16 = v26;
              LOBYTE(v20) = v25;
            }
            else
            {
              unint64_t v27 = 0;
            }
            char v28 = &v27[4 * ((v8 - v9) >> 2)];
            *(_DWORD *)char v28 = v12;
            *((_DWORD *)v28 + 1) = v16;
            v28[8] = v18;
            v28[9] = v17;
            v28[10] = v19;
            v28[11] = v20;
            if (v8 == v9)
            {
              uint64_t v9 = &v27[4 * ((v8 - v9) >> 2)];
              unsigned int v22 = v39;
            }
            else
            {
              uint64_t v29 = &v27[4 * ((v8 - v9) >> 2)];
              unsigned int v22 = v39;
              do
              {
                uint64_t v30 = *(void *)(v8 - 12);
                v8 -= 12;
                int v31 = *((_DWORD *)v8 + 2);
                *(void *)(v29 - 12) = v30;
                v29 -= 12;
                *((_DWORD *)v29 + 2) = v31;
              }
              while (v8 != v9);
              uint64_t v8 = v9;
              uint64_t v9 = v29;
            }
            uint64_t v7 = &v27[12 * v24];
            uint64_t v21 = v28 + 12;
            if (v8) {
              operator delete(v8);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v8 = v12;
            *((_DWORD *)v8 + 1) = v16;
            v8[8] = v18;
            v8[9] = (v15 & 2) != 0;
            v8[10] = (v15 & 4) != 0;
            uint64_t v21 = v8 + 12;
            v8[11] = (v15 & 8) != 0;
            unsigned int v22 = v39;
          }
          unsigned int v6 = v22 + 1;
          uint64_t v8 = v21;
        }
        std::string::size_type v58 = Unsigned;
        std::string::size_type v60 = 0;
        uint64_t v61 = 0;
        std::string::size_type v59 = 0;
        sub_1CCC40DEC(&v59, v9, (uint64_t)v8, 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 2));
        sub_1CCC2B418((void **)&v44, (uint64_t)&v58);
        if (v59) {
          operator delete(v59);
        }
        if (v9) {
          operator delete(v9);
        }
        __int16 v32 = (char *)*((void *)&v43 + 1);
      }
      while (v43 < (unint64_t)v35);
    }
    else
    {
      __int16 v32 = 0;
    }
    if (v32)
    {
      uint64_t v40 = 0;
      uint64_t v41 = v32;
      *((void *)&v43 + 1) = 0;
      sub_1CD5E5368(&v41, &v40, &v42);
      *(unsigned char *)(a3 + 24) |= 1u;
      *(void *)a3 = v42;
      uint64_t v42 = 0;
      if (v40) {
        (*(void (**)(char *))(*(void *)v40 + 8))(v40);
      }
      if (v41) {
        (*(void (**)(char *))(*(void *)v41 + 8))(v41);
      }
    }
    else
    {
      *(unsigned char *)(a3 + 24) &= ~1u;
      *(_OWORD *)a3 = v44;
      *(void *)(a3 + ++*(_DWORD *)(this + 16) = v45;
      long long v44 = 0uLL;
      uint64_t v45 = 0;
    }
    if (*((void *)&v43 + 1)) {
      (*(void (**)(void))(**((void **)&v43 + 1) + 8))(*((void *)&v43 + 1));
    }
    std::string::size_type v58 = (void **)&v44;
    sub_1CC4CDFC0(&v58);
    if (v67)
    {
      uint64_t v34 = v65;
      uint64_t v65 = 0;
      if (v34) {
        (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
      }
    }
  }
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::base(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::end(void *a1)
{
  return *a1 + a1[1];
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getBufSize(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::ELFFile(void *result, uint64_t a2, uint64_t a3)
{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

{
  *uint64_t result = a2;
  result[1] = a3;
  return result;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getHeader(uint64_t a1)
{
  return *(void *)a1;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getVersionDefinitions(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getLinkAsStrtab(a1, a2, (uint64_t)v76);
  if (v77)
  {
    uint64_t v6 = v76[0];
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
    return;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionContents(a1, a2, (uint64_t)v74);
  if (v75)
  {
    sub_1CCC39014(&v67, a1, a2);
    char v28 = std::string::insert(&v67, 0, "cannot read content of ");
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v68.__r_.__value_.__l.__data_ = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v68.__r_.__value_.__r.__words[2] = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    uint64_t v30 = std::string::append(&v68, ": ");
    uint64_t v31 = 0;
    std::string::size_type v32 = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v32;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    if (v75)
    {
      uint64_t v31 = v74[0];
      v74[0] = 0;
    }
    uint64_t v65 = v31;
    sub_1CD4FB504(&v65, &v66);
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v33 = &v66;
    }
    else {
      uint64_t v33 = (std::string *)v66.__r_.__value_.__r.__words[0];
    }
    if ((v66.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v66.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v66.__r_.__value_.__l.__size_;
    }
    uint64_t v35 = std::string::append(&__p, (const std::string::value_type *)v33, size);
    std::string::size_type v36 = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)uint64_t v71 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    *(void *)&v71[16] = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    LOWORD(v70) = 260;
    v69[0] = v71;
    operator new();
  }
  uint64_t v7 = (unsigned __int16 *)v74[0];
  unint64_t v63 = v74[0] + v74[1];
  uint64_t v64 = v74[0];
  v69[0] = &v63;
  v69[1] = a1;
  v69[2] = a2;
  v69[3] = &v64;
  std::string::size_type v70 = v76;
  memset(&v68, 0, sizeof(v68));
  if (!*(_DWORD *)(a2 + 44))
  {
    std::string::size_type v22 = 0;
    char v8 = *(unsigned char *)(a3 + 24);
    long long v21 = 0uLL;
    goto LABEL_34;
  }
  char v8 = *(unsigned char *)(a3 + 24);
  unsigned int v9 = 1;
  while (1)
  {
    if ((unint64_t)(v7 + 10) > v63)
    {
      sub_1CCC39014(&v60, a1, a2);
      unint64_t v37 = std::string::insert(&v60, 0, "invalid ");
      std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v38;
      v37->__r_.__value_.__l.__size_ = 0;
      v37->__r_.__value_.__r.__words[2] = 0;
      v37->__r_.__value_.__r.__words[0] = 0;
      unsigned int v39 = std::string::append(&v66, ": version definition ");
      std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v67;
      __p.__r_.__value_.__r.__words[2] = v9;
      __int16 v62 = 2052;
      uint64_t v41 = " goes past the end of the section";
      goto LABEL_49;
    }
    if ((v7 & 3) != 0)
    {
      sub_1CCC39014(&v66, a1, a2);
      uint64_t v42 = std::string::insert(&v66, 0, "invalid ");
      std::string::size_type v43 = v42->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v43;
      v42->__r_.__value_.__l.__size_ = 0;
      v42->__r_.__value_.__r.__words[2] = 0;
      v42->__r_.__value_.__r.__words[0] = 0;
      long long v44 = std::string::append(&v67, ": found a misaligned version definition entry at offset 0x");
      std::string::size_type v45 = v44->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v45;
      v44->__r_.__value_.__l.__size_ = 0;
      v44->__r_.__value_.__r.__words[2] = 0;
      v44->__r_.__value_.__r.__words[0] = 0;
      v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v7 - v64;
      unint64_t v27 = &v60;
LABEL_36:
      *(void *)uint64_t v71 = &__p;
      *(void *)&v71[16] = v27;
      __int16 v73 = 3588;
      operator new();
    }
    unsigned int v10 = *v7;
    if (v10 != 256)
    {
      std::string::size_type v46 = __rev16(v10);
      sub_1CCC39014(&v60, a1, a2);
      BOOL v47 = std::string::insert(&v60, 0, "unable to dump ");
      std::string::size_type v48 = v47->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v66.__r_.__value_.__l.__data_ = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
      v66.__r_.__value_.__r.__words[2] = v48;
      v47->__r_.__value_.__l.__size_ = 0;
      v47->__r_.__value_.__r.__words[2] = 0;
      v47->__r_.__value_.__r.__words[0] = 0;
      unint64_t v49 = std::string::append(&v66, ": version ");
      std::string::size_type v50 = v49->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v50;
      v49->__r_.__value_.__l.__size_ = 0;
      v49->__r_.__value_.__r.__words[2] = 0;
      v49->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v67;
      __p.__r_.__value_.__r.__words[2] = v46;
      __int16 v62 = 2052;
      uint64_t v41 = " is not yet supported";
LABEL_49:
      *(void *)uint64_t v71 = &__p;
      *(void *)&v71[16] = v41;
      __int16 v73 = 770;
      operator new();
    }
    unint64_t v11 = sub_1CCC25678((uint64_t)&v68, v68.__r_.__value_.__l.__size_);
    *(_DWORD *)unint64_t v11 = v7 - v64;
    *((_DWORD *)v11 + 1) = bswap32(*v7) >> 16;
    *((_DWORD *)v11 + 2) = bswap32(v7[1]) >> 16;
    *((_DWORD *)v11 + 3) = bswap32(v7[2]) >> 16;
    *((_DWORD *)v11 + 4) = bswap32(v7[3]) >> 16;
    *((_DWORD *)v11 + 5) = bswap32(*((_DWORD *)v7 + 2));
    v60.__r_.__value_.__r.__words[0] = (std::string::size_type)v7 + bswap32(*((_DWORD *)v7 + 3));
    if (v7[3]) {
      break;
    }
LABEL_31:
    uint64_t v7 = (unsigned __int16 *)((char *)v7 + bswap32(*((_DWORD *)v7 + 4)));
    if (++v9 > bswap32(*(_DWORD *)(a2 + 44)))
    {
      long long v21 = *(_OWORD *)&v68.__r_.__value_.__l.__data_;
      std::string::size_type v22 = v68.__r_.__value_.__r.__words[2];
LABEL_34:
      *(unsigned char *)(a3 + 24) = v8 & 0xFE;
      *(_OWORD *)a3 = v21;
      *(void *)(a3 + ++*(_DWORD *)(this + 16) = v22;
      goto LABEL_58;
    }
  }
  int v12 = v11;
  int v13 = 0;
  __int16 v57 = (unint64_t *)(v11 + 3);
  std::string::size_type v58 = (std::string *)((char *)v11 + 24);
  while (1)
  {
    if ((v60.__r_.__value_.__s.__data_[0] & 3) != 0)
    {
      sub_1CCC39014(&v66, a1, a2);
      unint64_t v23 = std::string::insert(&v66, 0, "invalid ");
      std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v67.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      v67.__r_.__value_.__r.__words[2] = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      unsigned int v25 = std::string::append(&v67, ": found a misaligned auxiliary entry at offset 0x");
      std::string::size_type v26 = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      std::string::size_type v59 = v60.__r_.__value_.__r.__words[0] - v64;
      unint64_t v27 = (std::string *)&v59;
      goto LABEL_36;
    }
    sub_1CCC390E4((uint64_t)v69, (unsigned int **)&v60, v9, (uint64_t)v71);
    char v14 = v73;
    if (v73)
    {
      uint64_t v18 = *(void *)v71;
      *(void *)uint64_t v71 = 0;
      v8 |= 1u;
      *(unsigned char *)(a3 + 24) = v8;
      *(void *)a3 = v18;
    }
    else if (v13)
    {
      unint64_t v15 = *((void *)v12 + 7);
      if (v15 >= *((void *)v12 + 8))
      {
        unsigned int v19 = sub_1CCC3F408(v57, (uint64_t)v71);
      }
      else
      {
        *(_DWORD *)unint64_t v15 = *(_DWORD *)v71;
        int v16 = (_OWORD *)(v15 + 8);
        if (SHIBYTE(v72) < 0)
        {
          sub_1CB8BDF7C((uint64_t)v16, *(const void **)&v71[8], *(unint64_t *)&v71[16]);
        }
        else
        {
          long long v17 = *(_OWORD *)&v71[8];
          *(void *)(v15 + 24) = v72;
          *int v16 = v17;
        }
        unsigned int v19 = (char *)(v15 + 32);
      }
      *((void *)v12 + 7) = v19;
    }
    else
    {
      std::string::operator=(v58, (const std::string *)&v71[8]);
    }
    if (v73)
    {
      uint64_t v20 = *(void *)v71;
      *(void *)uint64_t v71 = 0;
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
      }
    }
    else if (SHIBYTE(v72) < 0)
    {
      operator delete(*(void **)&v71[8]);
    }
    if (v14) {
      break;
    }
    if (++v13 >= bswap32(v7[3]) >> 16) {
      goto LABEL_31;
    }
  }
  std::string::size_type v51 = v68.__r_.__value_.__r.__words[0];
  if (v68.__r_.__value_.__r.__words[0])
  {
    uint64_t v52 = (void *)v68.__r_.__value_.__r.__words[0];
    if (v68.__r_.__value_.__l.__size_ != v68.__r_.__value_.__r.__words[0])
    {
      std::string::size_type v53 = v68.__r_.__value_.__l.__size_ - 24;
      do
      {
        *(void *)uint64_t v71 = v53;
        sub_1CC1CB288((void ***)v71);
        if (*(char *)(v53 - 1) < 0) {
          operator delete(*(void **)(v53 - 24));
        }
        std::string::size_type v54 = v53 - 48;
        v53 -= 72;
      }
      while (v54 != v51);
      uint64_t v52 = (void *)v68.__r_.__value_.__r.__words[0];
    }
    v68.__r_.__value_.__l.__size_ = v51;
    operator delete(v52);
  }
LABEL_58:
  if (v75)
  {
    uint64_t v55 = v74[0];
    v74[0] = 0;
    if (v55) {
      (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
    }
  }
  if (v77)
  {
    uint64_t v56 = v76[0];
    v76[0] = 0;
    if (v56) {
      (*(void (**)(uint64_t))(*(void *)v56 + 8))(v56);
    }
  }
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getLinkAsStrtab(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSection(a1, bswap32(*(_DWORD *)(a2 + 40)), (uint64_t)&v36);
  if (v37)
  {
    sub_1CCC39014(&v29, a1, a2);
    uint64_t v6 = std::string::insert(&v29, 0, "invalid section linked to ");
    std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    char v8 = std::string::append(&v30, ": ");
    uint64_t v9 = 0;
    std::string::size_type v10 = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v10;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    if (v37)
    {
      uint64_t v9 = v36;
      uint64_t v36 = 0;
    }
    uint64_t v27 = v9;
    sub_1CD4FB504(&v27, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    int v13 = std::string::append(&v31, (const std::string::value_type *)p_p, size);
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    long long v34 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    std::string::size_type v35 = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    std::string::size_type v32 = (std::string *)&v34;
    operator new();
  }
  std::string::size_type v32 = (std::string *)sub_1CCC27114;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getStringTable(a1, v36, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v32, (uint64_t)&v34);
  if (v35)
  {
    sub_1CCC39014(&__p, a1, a2);
    int v16 = std::string::insert(&__p, 0, "invalid string table linked to ");
    std::string::size_type v17 = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    uint64_t v18 = std::string::append(&v29, ": ");
    uint64_t v19 = 0;
    std::string::size_type v20 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v20;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    if (v35)
    {
      uint64_t v19 = v34;
      *(void *)&long long v34 = 0;
    }
    uint64_t v25 = v19;
    sub_1CD4FB504(&v25, &v26);
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      long long v21 = &v26;
    }
    else {
      long long v21 = (std::string *)v26.__r_.__value_.__r.__words[0];
    }
    if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v22 = *((unsigned char *)&v26.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type v22 = v26.__r_.__value_.__l.__size_;
    }
    unint64_t v23 = std::string::append(&v30, (const std::string::value_type *)v21, v22);
    std::string::size_type v24 = v23->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v24;
    v23->__r_.__value_.__l.__size_ = 0;
    v23->__r_.__value_.__r.__words[2] = 0;
    v23->__r_.__value_.__r.__words[0] = 0;
    __int16 v33 = 260;
    std::string::size_type v32 = &v31;
    operator new();
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(_OWORD *)a3 = v34;
  if (v37)
  {
    uint64_t v15 = v36;
    uint64_t v36 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
}

void sub_1CCC39014(void *a1, void *a2, uint64_t a3)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections(a2, (uint64_t)v13);
  unint64_t v6 = a3 - v13[0];
  ELFSectionTypeName = llvm::object::getELFSectionTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*a2 + 18)) >> 16), bswap32(*(_DWORD *)(a3 + 4)));
  __int16 v10 = 773;
  v9[0] = ELFSectionTypeName;
  v9[1] = v8;
  _OWORD v9[2] = " section with index ";
  v11[0] = v9;
  v11[2] = (v6 >> 6);
  __int16 v12 = 2050;
  llvm::Twine::str((llvm::Twine *)v11, a1);
}

void sub_1CCC390E4(uint64_t a1@<X0>, unsigned int **a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  BOOL v5 = *a2;
  if ((unint64_t)(*a2 + 2) > **(void **)a1)
  {
    sub_1CCC39014(&v24, *(void **)(a1 + 8), *(void *)(a1 + 16));
    std::string::size_type v7 = std::string::insert(&v24, 0, "invalid ");
    std::string::size_type v8 = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    uint64_t v9 = std::string::append(&v32, ": version definition ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    *(void *)&__p[16] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    v26[0] = __p;
    unint64_t v27 = a3;
    __int16 v28 = 2052;
    long long __dst = v26;
    *((void *)&v30 + 1) = " refers to an auxiliary entry that goes past the end of the section";
    __int16 v31 = 770;
    operator new();
  }
  unint64_t v11 = (unsigned int *)((char *)v5 + bswap32(v5[1]));
  *a2 = v11;
  __int16 v12 = *(uint64_t **)(a1 + 32);
  int v13 = **(_DWORD **)(a1 + 24);
  unint64_t v14 = bswap32(*v5);
  unint64_t v15 = v12[1];
  size_t v16 = v15 - v14;
  if (v15 >= v14)
  {
    if (v16 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    uint64_t v19 = *v12;
    if (v16 >= 0x17)
    {
      uint64_t v21 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v21 = v16 | 7;
      }
      uint64_t v22 = v21 + 1;
      p_dst = (void **)operator new(v21 + 1);
      *(void *)&long long v30 = v16;
      *((void *)&v30 + 1) = v22 | 0x8000000000000000;
      long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v30) = v15 - v14;
      p_dst = &__dst;
      if (v15 == v14) {
        goto LABEL_13;
      }
    }
    memmove(p_dst, (const void *)(v19 + v14), v16);
LABEL_13:
    *((unsigned char *)p_dst + v++*(_DWORD *)(this + 16) = 0;
    std::string::size_type v17 = __dst;
    v32.__r_.__value_.__r.__words[0] = v30;
    *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7) = *(void *)((char *)&v30 + 7);
    char v18 = HIBYTE(v30);
    goto LABEL_14;
  }
  v26[0] = "<invalid vda_name: ";
  unint64_t v27 = v14;
  __int16 v28 = 2051;
  long long __dst = v26;
  *((void *)&v30 + 1) = ">";
  __int16 v31 = 770;
  llvm::Twine::str((llvm::Twine *)&__dst, __p);
  std::string::size_type v17 = *(void **)__p;
  v32.__r_.__value_.__r.__words[0] = *(void *)&__p[8];
  *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7) = *(void *)&__p[15];
  char v18 = __p[23];
LABEL_14:
  *(unsigned char *)(a4 + 32) &= ~1u;
  *(_DWORD *)a4 = v11 - v13;
  std::string::size_type v23 = v32.__r_.__value_.__r.__words[0];
  *(void *)(a4 + ++*(_DWORD *)(this + 8) = v17;
  *(void *)(a4 + ++*(_DWORD *)(this + 16) = v23;
  *(void *)(a4 + 23) = *(std::string::size_type *)((char *)v32.__r_.__value_.__r.__words + 7);
  *(unsigned char *)(a4 + 31) = v18;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getVersionDependencies(void *a1@<X0>, uint64_t a2@<X1>, void (*a3)(void *__return_ptr, uint64_t, long long *)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = a2;
  std::string::size_type v8 = a1;
  uint64_t v98 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getLinkAsStrtab(a1, a2, (uint64_t)v96);
  if (v97)
  {
    uint64_t v38 = v96[0];
    v96[0] = 0;
    uint64_t v90 = v38;
    sub_1CD4FB504(&v90, &__p);
    __int16 v93 = 260;
    *(void *)&long long __dst = &__p;
    a3(v94, a4, &__dst);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v90) {
      (*(void (**)(uint64_t))(*(void *)v90 + 8))(v90);
    }
    uint64_t v39 = v94[0];
    if (v94[0])
    {
      *(unsigned char *)(a5 + 24) |= 1u;
      *(void *)a5 = v39;
      goto LABEL_67;
    }
    uint64_t v80 = 0;
    unint64_t v10 = 0;
  }
  else
  {
    unint64_t v10 = v96[1];
    uint64_t v80 = v96[0];
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionContents(v8, v7, (uint64_t)v94);
  if (v95)
  {
    sub_1CCC39014(&v87, v8, v7);
    std::string::size_type v48 = std::string::insert(&v87, 0, "cannot read content of ");
    std::string::size_type v49 = v48->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
    v88.__r_.__value_.__r.__words[2] = v49;
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v50 = std::string::append(&v88, ": ");
    uint64_t v51 = 0;
    std::string::size_type v52 = v50->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v89.__r_.__value_.__l.__data_ = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v89.__r_.__value_.__r.__words[2] = v52;
    v50->__r_.__value_.__l.__size_ = 0;
    v50->__r_.__value_.__r.__words[2] = 0;
    v50->__r_.__value_.__r.__words[0] = 0;
    if (v95)
    {
      uint64_t v51 = v94[0];
      v94[0] = 0;
    }
    uint64_t v85 = v51;
    sub_1CD4FB504(&v85, &v86);
    if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v53 = &v86;
    }
    else {
      std::string::size_type v53 = (std::string *)v86.__r_.__value_.__r.__words[0];
    }
    if ((v86.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = *((unsigned char *)&v86.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      std::string::size_type size = v86.__r_.__value_.__l.__size_;
    }
    uint64_t v55 = std::string::append(&v89, (const std::string::value_type *)v53, size);
    std::string::size_type v56 = v55->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v56;
    v55->__r_.__value_.__l.__size_ = 0;
    v55->__r_.__value_.__r.__words[2] = 0;
    v55->__r_.__value_.__r.__words[0] = 0;
    __int16 v93 = 260;
    *(void *)&long long __dst = &__p;
    operator new();
  }
  uint64_t v11 = v94[0];
  long long v12 = 0uLL;
  memset(&v89, 0, sizeof(v89));
  if (*(_DWORD *)(v7 + 44))
  {
    unint64_t v13 = v94[0] + v94[1];
    unsigned int v14 = 1;
    unint64_t v15 = (unsigned __int16 *)v94[0];
    uint64_t v75 = v7;
    uint64_t v76 = a5;
    char v74 = v8;
    unint64_t v79 = v10;
    while ((unint64_t)(v15 + 10) <= v13)
    {
      if ((v15 & 3) != 0)
      {
        sub_1CCC39014(&v87, v8, v7);
        __int16 v62 = std::string::insert(&v87, 0, "invalid ");
        std::string::size_type v63 = v62->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
        v88.__r_.__value_.__r.__words[2] = v63;
        v62->__r_.__value_.__l.__size_ = 0;
        v62->__r_.__value_.__r.__words[2] = 0;
        v62->__r_.__value_.__r.__words[0] = 0;
        uint64_t v64 = std::string::append(&v88, ": found a misaligned version dependency entry at offset 0x");
        std::string::size_type v65 = v64->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v65;
        v64->__r_.__value_.__l.__size_ = 0;
        v64->__r_.__value_.__r.__words[2] = 0;
        v64->__r_.__value_.__r.__words[0] = 0;
        v86.__r_.__value_.__r.__words[0] = (std::string::size_type)v15 - v11;
        *(void *)&long long __dst = &__p;
        uint64_t v92 = (const char *)&v86;
        __int16 v93 = 3588;
        operator new();
      }
      unsigned int v16 = *v15;
      if (v16 != 256)
      {
        std::string::size_type v66 = __rev16(v16);
        sub_1CCC39014(&v86, v8, v7);
        std::string v67 = std::string::insert(&v86, 0, "unable to dump ");
        std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
        v87.__r_.__value_.__r.__words[2] = v68;
        v67->__r_.__value_.__l.__size_ = 0;
        v67->__r_.__value_.__r.__words[2] = 0;
        v67->__r_.__value_.__r.__words[0] = 0;
        uint64_t v69 = std::string::append(&v87, ": version ");
        std::string::size_type v70 = v69->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
        v88.__r_.__value_.__r.__words[2] = v70;
        v69->__r_.__value_.__l.__size_ = 0;
        v69->__r_.__value_.__r.__words[2] = 0;
        v69->__r_.__value_.__r.__words[0] = 0;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
        __p.__r_.__value_.__r.__words[2] = v66;
        __int16 v84 = 2052;
        uint64_t v61 = " is not yet supported";
LABEL_63:
        *(void *)&long long __dst = &__p;
        uint64_t v92 = v61;
        __int16 v93 = 770;
        operator new();
      }
      unsigned int v77 = v14;
      uint64_t v17 = sub_1CCC26774((uint64_t)&v89, (_OWORD *)v89.__r_.__value_.__l.__size_);
      *(_DWORD *)uint64_t v17 = bswap32(*v15) >> 16;
      *(_DWORD *)(v17 + 4) = bswap32(v15[1]) >> 16;
      *(_DWORD *)(v17 + ++*(_DWORD *)(this + 8) = v15 - v11;
      unint64_t v18 = bswap32(*((_DWORD *)v15 + 1));
      unint64_t v19 = v10 - v18;
      if (v10 <= v18)
      {
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"<corrupt vn_file: ";
        unint64_t v73 = v73 & 0xFFFFFFFF00000000 | v18;
        __p.__r_.__value_.__r.__words[2] = v73;
        __int16 v84 = 2051;
        *(void *)&long long __dst = &__p;
        uint64_t v92 = ">";
        __int16 v93 = 770;
        llvm::Twine::str((llvm::Twine *)&__dst, &v88);
        uint64_t v21 = v17 + 16;
        uint64_t v22 = v17;
        if (*(char *)(v17 + 39) < 0) {
          operator delete(*(void **)v21);
        }
        std::string::size_type v23 = (const char *)v88.__r_.__value_.__r.__words[2];
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v88.__r_.__value_.__l.__data_;
      }
      else
      {
        if (v19 > 0x7FFFFFFFFFFFFFF7) {
LABEL_71:
        }
          abort();
        if (v19 >= 0x17)
        {
          uint64_t v24 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v19 | 7) != 0x17) {
            uint64_t v24 = v19 | 7;
          }
          uint64_t v81 = v24 + 1;
          p_dst = (long long *)operator new(v24 + 1);
          *((void *)&__dst + 1) = v10 - v18;
          uint64_t v92 = (const char *)(v81 | 0x8000000000000000);
          *(void *)&long long __dst = p_dst;
        }
        else
        {
          HIBYTE(v92) = v10 - v18;
          p_dst = &__dst;
        }
        memmove(p_dst, (const void *)(v80 + v18), v10 - v18);
        *((unsigned char *)p_dst + v19) = 0;
        uint64_t v22 = v17;
        uint64_t v21 = v17 + 16;
        if (*(char *)(v17 + 39) < 0) {
          operator delete(*(void **)v21);
        }
        *(_OWORD *)uint64_t v21 = __dst;
        std::string::size_type v23 = v92;
      }
      *(void *)(v21 + ++*(_DWORD *)(this + 16) = v23;
      if (v15[1])
      {
        unsigned int v25 = 0;
        std::string v26 = (char *)v15 + bswap32(*((_DWORD *)v15 + 2));
        __int16 v82 = (char **)(v22 + 40);
        uint64_t v78 = v22;
        do
        {
          if ((v26 & 3) != 0)
          {
            sub_1CCC39014(&v87, v74, v75);
            std::string::size_type v40 = std::string::insert(&v87, 0, "invalid ");
            std::string::size_type v41 = v40->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
            v88.__r_.__value_.__r.__words[2] = v41;
            v40->__r_.__value_.__l.__size_ = 0;
            v40->__r_.__value_.__r.__words[2] = 0;
            v40->__r_.__value_.__r.__words[0] = 0;
            uint64_t v42 = std::string::append(&v88, ": found a misaligned auxiliary entry at offset 0x");
            std::string::size_type v43 = v42->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v43;
            v42->__r_.__value_.__l.__size_ = 0;
            v42->__r_.__value_.__r.__words[2] = 0;
            v42->__r_.__value_.__r.__words[0] = 0;
            v86.__r_.__value_.__r.__words[0] = (std::string::size_type)&v26[-v11];
            *(void *)&long long __dst = &__p;
            uint64_t v92 = (const char *)&v86;
            __int16 v93 = 3588;
            operator new();
          }
          if ((unint64_t)(v26 + 16) > v13)
          {
            sub_1CCC39014(&v86, v74, v75);
            long long v44 = std::string::insert(&v86, 0, "invalid ");
            std::string::size_type v45 = v44->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
            v87.__r_.__value_.__r.__words[2] = v45;
            v44->__r_.__value_.__l.__size_ = 0;
            v44->__r_.__value_.__r.__words[2] = 0;
            v44->__r_.__value_.__r.__words[0] = 0;
            std::string::size_type v46 = std::string::append(&v87, ": version dependency ");
            std::string::size_type v47 = v46->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
            v88.__r_.__value_.__r.__words[2] = v47;
            v46->__r_.__value_.__l.__size_ = 0;
            v46->__r_.__value_.__r.__words[2] = 0;
            v46->__r_.__value_.__r.__words[0] = 0;
            __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
            __p.__r_.__value_.__r.__words[2] = v77;
            __int16 v84 = 2052;
            *(void *)&long long __dst = &__p;
            uint64_t v92 = " refers to an auxiliary entry that goes past the end of the section";
            __int16 v93 = 770;
            operator new();
          }
          unint64_t v27 = (_DWORD *)sub_1CCC26958(v82, *(void *)(v22 + 48));
          __int16 v28 = v27;
          _DWORD *v27 = bswap32(*(_DWORD *)v26);
          v27[1] = bswap32(*((unsigned __int16 *)v26 + 2)) >> 16;
          v27[2] = bswap32(*((unsigned __int16 *)v26 + 3)) >> 16;
          v27[3] = v26 - v11;
          unint64_t v29 = bswap32(*((_DWORD *)v26 + 2));
          size_t v30 = v10 - v29;
          if (v10 <= v29)
          {
            MEMORY[0x1D25D9630](v27 + 4, "<corrupt>");
          }
          else
          {
            if (v30 > 0x7FFFFFFFFFFFFFF7) {
              goto LABEL_71;
            }
            if (v30 >= 0x17)
            {
              uint64_t v32 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v30 | 7) != 0x17) {
                uint64_t v32 = v30 | 7;
              }
              uint64_t v33 = v11;
              uint64_t v34 = v32 + 1;
              __int16 v31 = (long long *)operator new(v32 + 1);
              unint64_t v35 = v34 | 0x8000000000000000;
              uint64_t v11 = v33;
              uint64_t v22 = v78;
              *((void *)&__dst + 1) = v30;
              uint64_t v92 = (const char *)v35;
              *(void *)&long long __dst = v31;
            }
            else
            {
              HIBYTE(v92) = v10 - v29;
              __int16 v31 = &__dst;
            }
            memmove(v31, (const void *)(v80 + v29), v30);
            *((unsigned char *)v31 + v30) = 0;
            uint64_t v36 = (void **)(v28 + 4);
            if (*((char *)v28 + 39) < 0) {
              operator delete(*v36);
            }
            *(_OWORD *)uint64_t v36 = __dst;
            *((void *)v28 + 4) = v92;
            unint64_t v10 = v79;
          }
          v26 += bswap32(*((_DWORD *)v26 + 3));
          ++v25;
        }
        while (v25 < bswap32(v15[1]) >> 16);
      }
      unint64_t v15 = (unsigned __int16 *)((char *)v15 + bswap32(*((_DWORD *)v15 + 3)));
      unsigned int v14 = v77 + 1;
      uint64_t v7 = v75;
      a5 = v76;
      std::string::size_type v8 = v74;
      if (v77 + 1 > bswap32(*(_DWORD *)(v75 + 44)))
      {
        long long v12 = *(_OWORD *)&v89.__r_.__value_.__l.__data_;
        std::string::size_type v37 = v89.__r_.__value_.__r.__words[2];
        goto LABEL_47;
      }
    }
    sub_1CCC39014(&v86, v8, v7);
    __int16 v57 = std::string::insert(&v86, 0, "invalid ");
    std::string::size_type v58 = v57->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
    v87.__r_.__value_.__r.__words[2] = v58;
    v57->__r_.__value_.__l.__size_ = 0;
    v57->__r_.__value_.__r.__words[2] = 0;
    v57->__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v59 = std::string::append(&v87, ": version dependency ");
    std::string::size_type v60 = v59->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
    v88.__r_.__value_.__r.__words[2] = v60;
    v59->__r_.__value_.__l.__size_ = 0;
    v59->__r_.__value_.__r.__words[2] = 0;
    v59->__r_.__value_.__r.__words[0] = 0;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
    __p.__r_.__value_.__r.__words[2] = v14;
    __int16 v84 = 2052;
    uint64_t v61 = " goes past the end of the section";
    goto LABEL_63;
  }
  std::string::size_type v37 = 0;
LABEL_47:
  *(unsigned char *)(a5 + 24) &= ~1u;
  *(_OWORD *)a5 = v12;
  *(void *)(a5 + ++*(_DWORD *)(this + 16) = v37;
  if (v95)
  {
    uint64_t v71 = v94[0];
    v94[0] = 0;
    if (v71) {
      (*(void (**)(uint64_t))(*(void *)v71 + 8))(v71);
    }
  }
LABEL_67:
  if (v97)
  {
    uint64_t v72 = v96[0];
    v96[0] = 0;
    if (v72) {
      (*(void (**)(uint64_t))(*(void *)v72 + 8))(v72);
    }
  }
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getStringTableForSymtab@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections(a1, (uint64_t)&v5);
  if ((v6 & 1) == 0) {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getStringTableForSymtab();
  }
  uint64_t v4 = v5;
  *(unsigned char *)(a2 + 16) |= 1u;
  *(void *)a2 = v4;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getStringTableForSymtab(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a2 + 4);
  if (v6 != 0x2000000 && v6 != 184549376)
  {
    long long v12 = "invalid sh_type for symbol table, expected SHT_SYMTAB or SHT_DYNSYM";
    __int16 v14 = 259;
    operator new();
  }
  sub_1CD6D1030(a3, a4, bswap32(*(_DWORD *)(a2 + 40)), (uint64_t)&v12);
  uint64_t v9 = v12;
  if (v13)
  {
    *(unsigned char *)(a5 + 16) |= 1u;
    *(void *)a5 = v9;
  }
  else
  {
    uint64_t v11 = sub_1CCC27114;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getStringTable(a1, (uint64_t)v12, (void (*)(uint64_t *__return_ptr, uint64_t, void *))sub_1CD6D6140, (uint64_t)&v11, a5);
    if (v13)
    {
      unint64_t v10 = v12;
      long long v12 = 0;
      if (v10) {
        (*(void (**)(const char *))(*(void *)v10 + 8))(v10);
      }
    }
  }
}

llvm::object *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getDynSymtabSize@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t result = (llvm::object *)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections(a1, (uint64_t)&v21);
  unint64_t v4 = (unint64_t)v21;
  if (v23)
  {
    uint64_t v21 = 0;
    char v7 = *(unsigned char *)(a2 + 8) | 1;
  }
  else
  {
    if (!v22) {
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::dynamicEntries();
    }
    uint64_t v5 = v21 + 4;
    uint64_t v6 = v22 << 6;
    while (*((_DWORD *)v5 - 7) != 184549376)
    {
      v5 += 8;
      v6 -= 64;
      if (!v6)
      {
        *(unsigned char *)(a2 + 8) &= ~1u;
        *(void *)a2 = 0;
        goto LABEL_12;
      }
    }
    unint64_t v8 = bswap64(*v5);
    unint64_t v9 = bswap64(v5[3]);
    unint64_t v4 = v8 / v9;
    if (v8 % v9)
    {
      atomic_ullong v10 = llvm::object::object_category(result);
      unint64_t v12 = bswap64(*v5);
      v13[0] = "SHT_DYNSYM section has sh_size (";
      _OWORD v13[2] = &v12;
      __int16 v14 = 3075;
      v15[0] = v13;
      void v15[2] = ") % sh_entsize (";
      __int16 v16 = 770;
      unint64_t v11 = bswap64(v5[3]);
      v17[0] = v15;
      void v17[2] = &v11;
      __int16 v18 = 3074;
      v19[0] = v17;
      void v19[2] = ") that is not 0";
      __int16 v20 = 770;
      sub_1CD4FF4BC(3, v10, (llvm::Twine *)v19);
    }
    char v7 = *(unsigned char *)(a2 + 8) & 0xFE;
  }
  *(unsigned char *)(a2 + ++*(_DWORD *)(this + 8) = v7;
  *(void *)a2 = v4;
LABEL_12:
  if (v23)
  {
    uint64_t result = (llvm::object *)v21;
    uint64_t v21 = 0;
    if (result) {
      return (llvm::object *)(*(uint64_t (**)(llvm::object *))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::dynamicEntries()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::program_headers();
}

{
  while (1)
    ;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::toMappedAddr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::program_headers();
}

const char *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getRelocationTypeName(uint64_t a1, unsigned int a2)
{
  return llvm::object::getELFRelocationTypeName((llvm::object *)(bswap32(*(unsigned __int16 *)(*(void *)a1 + 18)) >> 16), a2);
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::isMipsELF64(uint64_t a1)
{
  return *(_WORD *)(*(void *)a1 + 18) == 2048 && *(unsigned char *)(*(void *)a1 + 4) == 2;
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getRelativeRelocationType(uint64_t a1)
{
  return llvm::object::getELFRelativeRelocationType((llvm::object *)(bswap32(*(unsigned __int16 *)(*(void *)a1 + 18)) >> 16));
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getDynamicTagAsString(int a1@<W1>, int64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (a1 > 163)
  {
    switch(a1)
    {
      case 164:
        switch(a2)
        {
          case 1879048194:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1414287455;
            unint64_t v4 = "HEXAGON_PLT";
            goto LABEL_46;
          case 1879048193:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1380275807;
            unint64_t v4 = "HEXAGON_VER";
            goto LABEL_46;
          case 1879048192:
            unint64_t v8 = "HEXAGON_SYMSZ";
LABEL_23:
            *(unsigned char *)(a3 + 23) = 13;
            *(void *)a3 = *(void *)v8;
            *(void *)(a3 + 5) = *(void *)(v8 + 5);
            *(unsigned char *)(a3 + 13) = 0;
            return;
        }
        break;
      case 243:
        if (a2 == 1879048193)
        {
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "RISCV_VARIANT_CC";
LABEL_26:
          *(_OWORD *)a3 = *(_OWORD *)v6;
          *(unsigned char *)(a3 + ++*(_DWORD *)(this + 16) = 0;
          return;
        }
        break;
      case 183:
        switch(a2)
        {
          case 1879048197:
            *(unsigned char *)(a3 + 23) = 19;
            *(_DWORD *)(a3 + 15) = 1396920415;
            unint64_t v11 = "AARCH64_VARIANT_PCS";
LABEL_41:
            *(_OWORD *)a3 = *(_OWORD *)v11;
            *(unsigned char *)(a3 + 19) = 0;
            return;
          case 1879048195:
            uint64_t v5 = "AARCH64_PAC_PLT";
            goto LABEL_43;
          case 1879048193:
            uint64_t v5 = "AARCH64_BTI_PLT";
            goto LABEL_43;
        }
        break;
    }
  }
  else
  {
    if (a1 == 8)
    {
      switch(a2)
      {
        case 1879048193:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_RLD_VERSION";
          goto LABEL_26;
        case 1879048194:
          uint64_t v5 = "MIPS_TIME_STAMP";
          goto LABEL_43;
        case 1879048195:
          __int16 v16 = "MIPS_ICHECKSUM";
          goto LABEL_159;
        case 1879048196:
          unint64_t v8 = "MIPS_IVERSION";
          goto LABEL_23;
        case 1879048197:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 21319;
          __int16 v14 = "MIPS_FLAGS";
          goto LABEL_172;
        case 1879048198:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 83;
          uint64_t v24 = "MIPS_BASE_ADDRESS";
          goto LABEL_165;
        case 1879048199:
          *(unsigned char *)(a3 + 23) = 9;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 77;
          unint64_t v12 = "MIPS_MSYM";
          goto LABEL_126;
        case 1879048200:
          unint64_t v8 = "MIPS_CONFLICT";
          goto LABEL_23;
        case 1879048201:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1414744396;
          uint64_t v15 = "MIPS_LIBLIST";
          goto LABEL_157;
        case 1879048202:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_LOCAL_GOTNO";
          goto LABEL_26;
        case 1879048203:
          uint64_t v5 = "MIPS_CONFLICTNO";
          goto LABEL_43;
        case 1879048208:
          __int16 v16 = "MIPS_LIBLISTNO";
          goto LABEL_159;
        case 1879048209:
          unint64_t v8 = "MIPS_SYMTABNO";
          goto LABEL_23;
        case 1879048210:
          uint64_t v5 = "MIPS_UNREFEXTNO";
          goto LABEL_43;
        case 1879048211:
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1297699668;
          unint64_t v4 = "MIPS_GOTSYM";
          goto LABEL_46;
        case 1879048212:
          unint64_t v8 = "MIPS_HIPAGENO";
          goto LABEL_23;
        case 1879048214:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1346456927;
          uint64_t v15 = "MIPS_RLD_MAP";
          goto LABEL_157;
        case 1879048215:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_DELTA_CLASS";
          goto LABEL_26;
        case 1879048216:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1330536275;
          unint64_t v11 = "MIPS_DELTA_CLASS_NO";
          goto LABEL_41;
        case 1879048217:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1162038849;
          unint64_t v11 = "MIPS_DELTA_INSTANCE";
          goto LABEL_41;
        case 1879048218:
          unsigned int v25 = "MIPS_DELTA_INSTANCE_NO";
          goto LABEL_147;
        case 1879048219:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_DELTA_RELOC";
          goto LABEL_26;
        case 1879048220:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1330536259;
          unint64_t v11 = "MIPS_DELTA_RELOC_NO";
          goto LABEL_41;
        case 1879048221:
          __int16 v16 = "MIPS_DELTA_SYM";
          goto LABEL_159;
        case 1879048222:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 79;
          uint64_t v24 = "MIPS_DELTA_SYM_NO";
          goto LABEL_165;
        case 1879048224:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1297699667;
          unint64_t v11 = "MIPS_DELTA_CLASSSYM";
          goto LABEL_41;
        case 1879048225:
          unsigned int v25 = "MIPS_DELTA_CLASSSYM_NO";
LABEL_147:
          *(_OWORD *)a3 = *(_OWORD *)v25;
          *(void *)(a3 + 14) = *(void *)(v25 + 14);
          *(_WORD *)(a3 + 22) = 5632;
          return;
        case 1879048226:
          __int16 v16 = "MIPS_CXX_FLAGS";
          goto LABEL_159;
        case 1879048227:
          uint64_t v5 = "MIPS_PIXIE_INIT";
          goto LABEL_43;
        case 1879048228:
          uint64_t v5 = "MIPS_SYMBOL_LIB";
          goto LABEL_43;
        case 1879048229:
          std::string v26 = "MIPS_LOCALPAGE_GOTIDX";
          goto LABEL_155;
        case 1879048230:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 88;
          uint64_t v24 = "MIPS_LOCAL_GOTIDX";
          goto LABEL_165;
        case 1879048231:
          *(unsigned char *)(a3 + 23) = 18;
          strcpy((char *)a3, "MIPS_HIDDEN_GOTIDX");
          return;
        case 1879048232:
          std::string v26 = "MIPS_PROTECTED_GOTIDX";
LABEL_155:
          *(unsigned char *)(a3 + 23) = 21;
          *(_OWORD *)a3 = *(_OWORD *)v26;
          *(void *)(a3 + 13) = *(void *)(v26 + 13);
          *(unsigned char *)(a3 + 21) = 0;
          return;
        case 1879048233:
          *(unsigned char *)(a3 + 23) = 12;
          *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1397641033;
          uint64_t v15 = "MIPS_OPTIONS";
          goto LABEL_157;
        case 1879048234:
          __int16 v16 = "MIPS_INTERFACE";
          goto LABEL_159;
        case 1879048235:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 78;
          uint64_t v24 = "MIPS_DYNSTR_ALIGN";
          goto LABEL_165;
        case 1879048236:
          *(unsigned char *)(a3 + 23) = 19;
          *(_DWORD *)(a3 + 15) = 1163544915;
          unint64_t v11 = "MIPS_INTERFACE_SIZE";
          goto LABEL_41;
        case 1879048237:
          unint64_t v27 = (char *)operator new(0x20uLL);
          *(void *)a3 = v27;
          *(_OWORD *)(a3 + ++*(_DWORD *)(this + 8) = xmmword_1CD96DBE0;
          strcpy(v27, "MIPS_RLD_TEXT_RESOLVE_ADDR");
          return;
        case 1879048238:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_PERF_SUFFIX";
          goto LABEL_26;
        case 1879048239:
          *(unsigned char *)(a3 + 23) = 17;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 16) = 69;
          uint64_t v24 = "MIPS_COMPACT_SIZE";
LABEL_165:
          *(_OWORD *)a3 = *(_OWORD *)v24;
          return;
        case 1879048240:
          unint64_t v8 = "MIPS_GP_VALUE";
          goto LABEL_23;
        case 1879048241:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_AUX_DYNAMIC";
          goto LABEL_26;
        case 1879048242:
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414481748;
          unint64_t v4 = "MIPS_PLTGOT";
          goto LABEL_46;
        case 1879048244:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 21580;
          __int16 v14 = "MIPS_RWPLT";
          goto LABEL_172;
        case 1879048245:
          *(unsigned char *)(a3 + 23) = 16;
          uint64_t v6 = "MIPS_RLD_MAP_REL";
          goto LABEL_26;
        case 1879048246:
          *(unsigned char *)(a3 + 23) = 10;
          *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 18515;
          __int16 v14 = "MIPS_XHASH";
LABEL_172:
          *(void *)a3 = *(void *)v14;
          *(unsigned char *)(a3 + 10) = 0;
          break;
        default:
          goto LABEL_27;
      }
      return;
    }
    if (a1 == 20)
    {
      if (a2 == 1879048193)
      {
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1598246992;
        int v7 = 1414549343;
      }
      else
      {
        if (a2 != 1879048192) {
          goto LABEL_27;
        }
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1598246992;
        int v7 = 1414481759;
      }
LABEL_116:
      *(_DWORD *)(a3 + 3) = v7;
      *(unsigned char *)(a3 + 7) = 0;
      return;
    }
    if (a1 == 21 && a2 == 1879048192)
    {
      *(unsigned char *)(a3 + 23) = 11;
      *(_DWORD *)(a3 + 7) = 1263421772;
      unint64_t v4 = "PPC64_GLINK";
LABEL_46:
      *(void *)a3 = *(void *)v4;
      *(unsigned char *)(a3 + 11) = 0;
      return;
    }
  }
LABEL_27:
  if (a2 <= 1879039999)
  {
    switch(a2)
    {
      case 0:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1280070990;
        goto LABEL_113;
      case 1:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1145390414;
        __int16 v10 = 17477;
        goto LABEL_111;
      case 2:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x5A534C4552544C50;
        goto LABEL_98;
      case 3:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1196706896;
        __int16 v10 = 21583;
        goto LABEL_111;
      case 4:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1213415752;
        goto LABEL_113;
      case 5:
        *(unsigned char *)(a3 + 23) = 6;
        int v17 = 1414681683;
        goto LABEL_76;
      case 6:
        *(unsigned char *)(a3 + 23) = 6;
        int v17 = 1414355283;
LABEL_76:
        *(_DWORD *)a3 = v17;
        __int16 v10 = 16961;
        goto LABEL_111;
      case 7:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1095517522;
        goto LABEL_113;
      case 8:
        *(unsigned char *)(a3 + 23) = 6;
        int v18 = 1095517522;
        goto LABEL_110;
      case 9:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1095517522;
        unsigned __int16 v19 = 17729;
        goto LABEL_115;
      case 10:
        *(unsigned char *)(a3 + 23) = 5;
        int v20 = 1397904467;
        goto LABEL_89;
      case 11:
        *(unsigned char *)(a3 + 23) = 6;
        int v21 = 1162697043;
        goto LABEL_91;
      case 12:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1414090313;
        goto LABEL_113;
      case 13:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1229867334;
        goto LABEL_113;
      case 14:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1095651155;
        __int16 v10 = 17741;
        goto LABEL_111;
      case 15:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1413566546;
        __int16 v22 = 72;
        goto LABEL_105;
      case 16:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x43494C4F424D5953;
        goto LABEL_98;
      case 17:
        *(unsigned char *)(a3 + 23) = 3;
        *(_DWORD *)a3 = 4998482;
        return;
      case 18:
        *(unsigned char *)(a3 + 23) = 5;
        int v20 = 1397507410;
LABEL_89:
        *(_DWORD *)a3 = v20;
        __int16 v22 = 90;
        goto LABEL_105;
      case 19:
        *(unsigned char *)(a3 + 23) = 6;
        int v21 = 1162626386;
LABEL_91:
        *(_DWORD *)a3 = v21;
        __int16 v10 = 21582;
        goto LABEL_111;
      case 20:
        *(unsigned char *)(a3 + 23) = 6;
        int v23 = 1381256272;
        goto LABEL_96;
      case 21:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1430406468;
        __int16 v22 = 71;
        goto LABEL_105;
      case 22:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1415071060;
        int v7 = 1279611476;
        goto LABEL_116;
      case 23:
        *(unsigned char *)(a3 + 23) = 6;
        int v23 = 1380994378;
LABEL_96:
        *(_DWORD *)a3 = v23;
        __int16 v10 = 19525;
        goto LABEL_111;
      case 24:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x574F4E5F444E4942;
        goto LABEL_98;
      case 25:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 22849;
        __int16 v14 = "INIT_ARRAY";
        goto LABEL_172;
      case 26:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 22849;
        __int16 v14 = "FINI_ARRAY";
        goto LABEL_172;
      case 27:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1515411777;
        uint64_t v15 = "INIT_ARRAYSZ";
        goto LABEL_157;
      case 28:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1515411777;
        uint64_t v15 = "FINI_ARRAYSZ";
        goto LABEL_157;
      case 29:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1347310930;
        int v7 = 1213481296;
        goto LABEL_116;
      case 30:
        *(unsigned char *)(a3 + 23) = 5;
        *(_DWORD *)a3 = 1195461702;
        __int16 v22 = 83;
LABEL_105:
        *(_WORD *)(a3 + 4) = v22;
        return;
      case 31:
        goto LABEL_174;
      case 32:
        unint64_t v8 = "PREINIT_ARRAY";
        goto LABEL_23;
      case 33:
        uint64_t v5 = "PREINIT_ARRAYSZ";
        goto LABEL_43;
      case 34:
        *(unsigned char *)(a3 + 23) = 12;
        *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1480871496;
        uint64_t v15 = "SYMTAB_SHNDX";
        goto LABEL_157;
      case 35:
        *(unsigned char *)(a3 + 23) = 6;
        int v18 = 1380730194;
LABEL_110:
        *(_DWORD *)a3 = v18;
        __int16 v10 = 23123;
        goto LABEL_111;
      case 36:
        *(unsigned char *)(a3 + 23) = 4;
        int v9 = 1380730194;
        goto LABEL_113;
      case 37:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1380730194;
        unsigned __int16 v19 = 17746;
LABEL_115:
        int v7 = v19 | 0x544E0000;
        goto LABEL_116;
      default:
        switch(a2)
        {
          case 1610612751:
            *(unsigned char *)(a3 + 23) = 11;
            *(_DWORD *)(a3 + 7) = 1279611487;
            unint64_t v4 = "ANDROID_REL";
            goto LABEL_46;
          case 1610612752:
            unint64_t v8 = "ANDROID_RELSZ";
            goto LABEL_23;
          case 1610612753:
            *(unsigned char *)(a3 + 23) = 12;
            *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1095517522;
            uint64_t v15 = "ANDROID_RELA";
            goto LABEL_157;
          case 1610612754:
            __int16 v16 = "ANDROID_RELASZ";
            goto LABEL_159;
          default:
            goto LABEL_174;
        }
    }
  }
  if (a2 <= 1879048175)
  {
    if (a2 > 1879047924)
    {
      if (a2 != 1879047925)
      {
        if (a2 == 1879047926)
        {
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414287455;
          unint64_t v4 = "TLSDESC_PLT";
          goto LABEL_46;
        }
        if (a2 == 1879047927)
        {
          *(unsigned char *)(a3 + 23) = 11;
          *(_DWORD *)(a3 + 7) = 1414481759;
          unint64_t v4 = "TLSDESC_GOT";
          goto LABEL_46;
        }
        goto LABEL_174;
      }
      *(unsigned char *)(a3 + 23) = 8;
      uint64_t v13 = 0x485341485F554E47;
LABEL_98:
      *(void *)a3 = v13;
      *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = 0;
      return;
    }
    if (a2 == 1879040000)
    {
      *(unsigned char *)(a3 + 23) = 12;
      *(_DWORD *)(a3 + ++*(_DWORD *)(this + 8) = 1380730194;
      uint64_t v15 = "ANDROID_RELR";
LABEL_157:
      *(void *)a3 = *(void *)v15;
      *(unsigned char *)(a3 + 12) = 0;
      return;
    }
    if (a2 == 1879040001)
    {
      __int16 v16 = "ANDROID_RELRSZ";
LABEL_159:
      *(unsigned char *)(a3 + 23) = 14;
      *(void *)a3 = *(void *)v16;
      *(void *)(a3 + 6) = *(void *)(v16 + 6);
      *(unsigned char *)(a3 + 14) = 0;
      return;
    }
    if (a2 != 1879040003) {
      goto LABEL_174;
    }
    uint64_t v5 = "ANDROID_RELRENT";
LABEL_43:
    *(unsigned char *)(a3 + 23) = 15;
    *(void *)a3 = *(void *)v5;
    *(void *)(a3 + 7) = *(void *)(v5 + 7);
    *(unsigned char *)(a3 + 15) = 0;
    return;
  }
  if (a2 <= 2147483644)
  {
    switch(a2)
    {
      case 1879048176:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1397900630;
        __int16 v10 = 19801;
        goto LABEL_111;
      case 1879048185:
        *(unsigned char *)(a3 + 23) = 9;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 84;
        unint64_t v12 = "RELACOUNT";
        goto LABEL_126;
      case 1879048186:
        *(unsigned char *)(a3 + 23) = 8;
        uint64_t v13 = 0x544E554F434C4552;
        goto LABEL_98;
      case 1879048187:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1195461702;
        int v7 = 828330823;
        goto LABEL_116;
      case 1879048188:
        *(unsigned char *)(a3 + 23) = 6;
        *(_DWORD *)a3 = 1146242390;
        __int16 v10 = 17989;
        goto LABEL_111;
      case 1879048189:
        *(unsigned char *)(a3 + 23) = 9;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 77;
        unint64_t v12 = "VERDEFNUM";
        goto LABEL_126;
      case 1879048190:
        *(unsigned char *)(a3 + 23) = 7;
        *(_DWORD *)a3 = 1314014550;
        int v7 = 1145390414;
        goto LABEL_116;
      case 1879048191:
        *(unsigned char *)(a3 + 23) = 10;
        *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 19797;
        __int16 v14 = "VERNEEDNUM";
        goto LABEL_172;
      default:
        goto LABEL_174;
    }
  }
  if (a2 != 2147483645)
  {
    if (a2 == 2147483646)
    {
      *(unsigned char *)(a3 + 23) = 4;
      int v9 = 1145394005;
LABEL_113:
      *(_DWORD *)a3 = v9;
      *(unsigned char *)(a3 + 4) = 0;
      return;
    }
    if (a2 == 0x7FFFFFFF)
    {
      *(unsigned char *)(a3 + 23) = 6;
      *(_DWORD *)a3 = 1414285638;
      __int16 v10 = 21061;
LABEL_111:
      *(_WORD *)(a3 + 4) = v10;
      *(unsigned char *)(a3 + 6) = 0;
      return;
    }
LABEL_174:
    sub_1CD5E9F58(a2, 1, 0, &v30);
    __int16 v28 = std::string::insert(&v30, 0, "<unknown:>0x");
    std::string::size_type v29 = v28->__r_.__value_.__r.__words[2];
    *(_OWORD *)a3 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    *(void *)(a3 + ++*(_DWORD *)(this + 16) = v29;
    v28->__r_.__value_.__l.__size_ = 0;
    v28->__r_.__value_.__r.__words[2] = 0;
    v28->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
    return;
  }
  *(unsigned char *)(a3 + 23) = 9;
  *(_WORD *)(a3 + ++*(_DWORD *)(this + 8) = 89;
  unint64_t v12 = "AUXILIARY";
LABEL_126:
  *(void *)a3 = *(void *)v12;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getDynamicTagAsString()
{
}

{
  while (1)
    ;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getRelocationSymbol@<X0>(void *result@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v4 = *result;
  if (*(_WORD *)(*result + 18) == 2048 && *(unsigned char *)(v4 + 4) == 2)
  {
    unint64_t v5 = bswap64(*(void *)(a2 + 8));
    if (*(unsigned char *)(v4 + 5) == 1) {
      unint64_t v6 = v5 << 32;
    }
    else {
      unint64_t v6 = v5;
    }
  }
  else
  {
    unint64_t v6 = bswap64(*(void *)(a2 + 8));
  }
  unint64_t v7 = HIDWORD(v6);
  if (v7) {
    return sub_1CD6D4A70(result, a3, v7, a4);
  }
  *(unsigned char *)(a4 + 8) &= ~1u;
  *(void *)a4 = 0;
  return result;
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::isMips64EL(uint64_t *a1)
{
  uint64_t v1 = *a1;
  return *(_WORD *)(*a1 + 18) == 2048 && *(unsigned char *)(v1 + 4) == 2 && *(unsigned char *)(v1 + 5) == 1;
}

char **llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::loadVersionMap@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v42 = &v44;
  uint64_t v43 = 0;
  __p[0] = 0;
  __p[1] = 0;
  char v40 = 0;
  unint64_t v39 = 0;
  char v41 = 1;
  sub_1CCC297E0((uint64_t)&v42, (unint64_t)__p);
  if (v41 && SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  char v40 = 0;
  unint64_t v39 = 0;
  char v41 = 1;
  sub_1CCC297E0((uint64_t)&v42, (unint64_t)__p);
  if (v41 && SHIBYTE(v39) < 0) {
    operator delete(__p[0]);
  }
  if (a3)
  {
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getVersionDefinitions(a1, a3, (uint64_t)&v44);
    unint64_t v8 = v44;
    if (v46)
    {
      long long v44 = 0;
      *(unsigned char *)(a4 + 16) |= 1u;
      *(void *)a4 = v8;
      sub_1CCC3FEAC((uint64_t)&v44);
      return sub_1CCC3FDC0((char **)&v42);
    }
    unint64_t v35 = a1;
    int v9 = v45;
    if (v44 != v45)
    {
      __int16 v10 = v44 + 3;
      do
      {
        unsigned int v11 = *((_DWORD *)v10 - 3) & 0x7FFF;
        char v12 = *((unsigned char *)v10 + 23);
        BOOL v13 = v12 < 0;
        if (v12 >= 0) {
          __int16 v14 = v10;
        }
        else {
          __int16 v14 = *v10;
        }
        size_t v15 = v12 & 0x7F;
        if (v13) {
          size_t v16 = (size_t)v10[1];
        }
        else {
          size_t v16 = v15;
        }
        if (v43 <= v11) {
          sub_1CCC3EBD0((uint64_t)&v42, v11 + 1);
        }
        if (v16 > 0x7FFFFFFFFFFFFFF7) {
LABEL_68:
        }
          abort();
        if (v16 >= 0x17)
        {
          uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v16 | 7) != 0x17) {
            uint64_t v18 = v16 | 7;
          }
          uint64_t v19 = v18 + 1;
          int v17 = operator new(v18 + 1);
          __p[1] = (void *)v16;
          unint64_t v39 = v19 | 0x8000000000000000;
          __p[0] = v17;
        }
        else
        {
          HIBYTE(v39) = v16;
          int v17 = __p;
          if (!v16) {
            goto LABEL_27;
          }
        }
        memmove(v17, v14, v16);
LABEL_27:
        *((unsigned char *)v17 + v++*(_DWORD *)(this + 16) = 0;
        int v20 = (char *)&v42[5 * v11];
        int v21 = v20 + 32;
        if (v20[32])
        {
          if (v20[23] < 0) {
            operator delete(*(void **)v20);
          }
          *(_OWORD *)int v20 = *(_OWORD *)__p;
          *((void *)v20 + 2) = v39;
          int v21 = v20 + 24;
        }
        else
        {
          *(_OWORD *)int v20 = *(_OWORD *)__p;
          *((void *)v20 + 2) = v39;
          v20[24] = 1;
        }
        *int v21 = 1;
        __int16 v22 = v10 + 6;
        v10 += 9;
      }
      while (v22 != v9);
    }
    sub_1CCC3FEAC((uint64_t)&v44);
    a1 = v35;
  }
  if (a2)
  {
    __p[0] = sub_1CCC27114;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getVersionDependencies(a1, a2, (void (*)(void *__return_ptr, uint64_t, long long *))sub_1CD6D6140, (uint64_t)__p, (uint64_t)&v44);
    int v23 = v44;
    if ((v46 & 1) == 0)
    {
      uint64_t v36 = a4;
      std::string::size_type v37 = v45;
      if (v44 == v45) {
        goto LABEL_62;
      }
      while (1)
      {
        uint64_t v24 = (char *)v23[5];
        unsigned int v25 = (char *)v23[6];
        while (v24 != v25)
        {
          unsigned int v26 = *((_DWORD *)v24 + 2) & 0x7FFF;
          char v27 = v24[39];
          if (v27 >= 0) {
            __int16 v28 = v24 + 16;
          }
          else {
            __int16 v28 = (const void *)*((void *)v24 + 2);
          }
          if (v27 >= 0) {
            size_t v29 = v27 & 0x7F;
          }
          else {
            size_t v29 = *((void *)v24 + 3);
          }
          if (v43 <= v26) {
            sub_1CCC3EBD0((uint64_t)&v42, v26 + 1);
          }
          if (v29 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_68;
          }
          if (v29 >= 0x17)
          {
            uint64_t v31 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v29 | 7) != 0x17) {
              uint64_t v31 = v29 | 7;
            }
            uint64_t v32 = v31 + 1;
            std::string v30 = operator new(v31 + 1);
            __p[1] = (void *)v29;
            unint64_t v39 = v32 | 0x8000000000000000;
            __p[0] = v30;
LABEL_54:
            memmove(v30, v28, v29);
            goto LABEL_55;
          }
          HIBYTE(v39) = v29;
          std::string v30 = __p;
          if (v29) {
            goto LABEL_54;
          }
LABEL_55:
          *((unsigned char *)v30 + v29) = 0;
          uint64_t v33 = (char *)&v42[5 * v26];
          if (v33[32])
          {
            if (v33[23] < 0) {
              operator delete(*(void **)v33);
            }
            *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
            *((void *)v33 + 2) = v39;
            v33[24] = 0;
          }
          else
          {
            *(_OWORD *)uint64_t v33 = *(_OWORD *)__p;
            *((void *)v33 + 2) = v39;
            v33[24] = 0;
            v33[32] = 1;
          }
          v24 += 40;
        }
        v23 += 8;
        if (v23 == v37)
        {
LABEL_62:
          sub_1CCC3FF24((uint64_t)&v44);
          a4 = v36;
          goto LABEL_63;
        }
      }
    }
    long long v44 = 0;
    *(unsigned char *)(a4 + 16) |= 1u;
    *(void *)a4 = v23;
    sub_1CCC3FF24((uint64_t)&v44);
  }
  else
  {
LABEL_63:
    *(unsigned char *)(a4 + 16) &= ~1u;
    *(void *)a4 = a4 + 16;
    *(void *)(a4 + ++*(_DWORD *)(this + 8) = 0;
    if (v43) {
      sub_1CCC3FF9C(a4, (uint64_t)&v42);
    }
  }
  return sub_1CCC3FDC0((char **)&v42);
}

BOOL llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::isLE(uint64_t a1)
{
  return *(unsigned char *)(*(void *)a1 + 5) == 1;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::program_headers@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *result;
  if (*(_WORD *)(*result + 56))
  {
    unsigned int v4 = *(unsigned __int16 *)(v3 + 54);
    unsigned int v5 = 14336;
    if (v4 != 14336)
    {
      char v27 = "invalid e_phentsize: ";
      uint64_t v28 = __rev16(v4);
      __int16 v29 = 2307;
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v5 = *(unsigned __int16 *)(v3 + 54);
  }
  uint64_t v6 = __rev16(*(unsigned __int16 *)(*result + 56));
  uint64_t v7 = __rev16(v5);
  unint64_t v8 = v7 * (unint64_t)v6;
  unint64_t v9 = bswap64(*(void *)(v3 + 32));
  unint64_t v10 = result[1];
  BOOL v11 = __CFADD__(v9, v8);
  unint64_t v12 = v9 + v8;
  if (v11 || v12 > v10)
  {
    unint64_t v13 = v9;
    unint64_t v14 = v10;
    v15[0] = "program headers are longer than binary of size ";
    void v15[2] = &v14;
    __int16 v16 = 2563;
    v17[0] = v15;
    void v17[2] = ": e_phoff = 0x";
    __int16 v18 = 770;
    v19[0] = v17;
    void v19[2] = &v13;
    __int16 v20 = 3586;
    v21[0] = v19;
    v21[2] = ", e_phnuuint64_t m = ";
    __int16 v22 = 770;
    v23[0] = v21;
    v23[2] = v6;
    __int16 v24 = 2306;
    v25[0] = v23;
    v25[2] = ", e_phentstd::string::size_type size = ";
    __int16 v26 = 770;
    char v27 = (const char *)v25;
    uint64_t v28 = v7;
    __int16 v29 = 2306;
LABEL_9:
    operator new();
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  *(void *)a2 = v3 + v9;
  *(void *)(a2 + ++*(_DWORD *)(this + 8) = v6;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::symbols@<X0>(void *result@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    return llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::relas(result, a2, a3);
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = 0;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = 0;
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::relrs@<X0>(void *result@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v4 = result;
  if (a2[7] != 0x800000000000000)
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v29);
    unint64_t v9 = std::string::insert(&v29, 0, "section ");
    std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    BOOL v11 = std::string::append(&v31, " has invalid sh_entsize: expected ");
    unint64_t v12 = (unint64_t *)v11->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    unint64_t v35 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    v33.__r_.__value_.__r.__words[0] = 8;
    v39[0] = __p;
    char v40 = &v33;
    __int16 v41 = 2564;
    v42[0] = v39;
    uint64_t v43 = (std::string *)", but got ";
    __int16 v44 = 770;
    v28.__r_.__value_.__r.__words[0] = bswap64(a2[7]);
    std::string::size_type v45 = v42;
    char v46 = &v28;
    __int16 v47 = 3074;
    operator new();
  }
  unint64_t v6 = bswap64(a2[3]);
  unint64_t v7 = bswap64(a2[4]);
  unint64_t v37 = v7;
  unint64_t v38 = v6;
  if ((v7 & 7) != 0)
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v33);
    unint64_t v13 = std::string::insert(&v33, 0, "section ");
    std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    size_t v15 = std::string::append(&v29, " has an invalid sh_size (");
    std::string::size_type v16 = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    __p[0] = &v31;
    unint64_t v35 = &v37;
    __int16 v36 = 3076;
    v39[0] = __p;
    char v40 = (std::string *)") which is not a multiple of its sh_entsize (";
    __int16 v41 = 770;
    v28.__r_.__value_.__r.__words[0] = bswap64(a2[7]);
    v42[0] = v39;
    uint64_t v43 = &v28;
    __int16 v44 = 3074;
    int v17 = ")";
    goto LABEL_9;
  }
  if (__CFADD__(v6, v7))
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v33);
    __int16 v18 = std::string::insert(&v33, 0, "section ");
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v19;
    v18->__r_.__value_.__l.__size_ = 0;
    v18->__r_.__value_.__r.__words[2] = 0;
    v18->__r_.__value_.__r.__words[0] = 0;
    __int16 v20 = std::string::append(&v29, " has a sh_offset (0x");
    std::string::size_type v21 = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v31.__r_.__value_.__l.__data_ = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v31.__r_.__value_.__r.__words[2] = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    __p[0] = &v31;
    unint64_t v35 = &v38;
    __int16 v36 = 3588;
    v39[0] = __p;
    char v40 = (std::string *)") + sh_size (0x";
    __int16 v41 = 770;
    v42[0] = v39;
    uint64_t v43 = (std::string *)&v37;
    __int16 v44 = 3586;
    int v17 = ") that cannot be represented";
LABEL_9:
    std::string::size_type v45 = v42;
    char v46 = (std::string *)v17;
    __int16 v47 = 770;
    operator new();
  }
  if (v7 + v6 > result[1])
  {
    sub_1CD6D3754(result, (uint64_t)a2, (char *)&v27);
    __int16 v22 = std::string::insert(&v27, 0, "section ");
    std::string::size_type v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v28.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v28.__r_.__value_.__r.__words[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    __int16 v24 = std::string::append(&v28, " has a sh_offset (0x");
    std::string::size_type v25 = v24->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v33.__r_.__value_.__l.__data_ = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v33.__r_.__value_.__r.__words[2] = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    v29.__r_.__value_.__r.__words[0] = (std::string::size_type)&v33;
    v29.__r_.__value_.__r.__words[2] = (std::string::size_type)&v38;
    __int16 v30 = 3588;
    v31.__r_.__value_.__r.__words[0] = (std::string::size_type)&v29;
    v31.__r_.__value_.__r.__words[2] = (std::string::size_type)") + sh_size (0x";
    __int16 v32 = 770;
    __p[0] = &v31;
    unint64_t v35 = &v37;
    __int16 v36 = 3586;
    v39[0] = __p;
    char v40 = (std::string *)") that is greater than the file size (0x";
    __int16 v41 = 770;
    uint64_t v26 = v4[1];
    v42[0] = v39;
    uint64_t v43 = (std::string *)&v26;
    __int16 v44 = 3586;
    std::string::size_type v45 = v42;
    char v46 = (std::string *)")";
    __int16 v47 = 770;
    operator new();
  }
  unint64_t v8 = *result + v6;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v7 >> 3;
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::decode_relrs(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X2>, unint64_t **a4@<X8>)
{
  unsigned int ELFRelativeRelocationType = llvm::object::getELFRelativeRelocationType((llvm::object *)(bswap32(*(unsigned __int16 *)(*(void *)a1 + 18)) >> 16));
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  if (a3)
  {
    unint64_t v8 = 0;
    unint64_t v9 = bswap64(ELFRelativeRelocationType);
    unint64_t v35 = &a2[a3];
    unint64_t v36 = 0;
    do
    {
      unint64_t v10 = *a2;
      unint64_t v11 = bswap64(*a2);
      if (v11)
      {
        unint64_t v14 = v36;
        if (v11 >= 2)
        {
          do
          {
            if ((v11 & 2) != 0)
            {
              unint64_t v15 = bswap64(v14);
              unint64_t v16 = (unint64_t)a4[2];
              if ((unint64_t)v8 >= v16)
              {
                __int16 v18 = *a4;
                uint64_t v19 = ((char *)v8 - (char *)*a4) >> 4;
                unint64_t v20 = v19 + 1;
                if ((unint64_t)(v19 + 1) >> 60) {
                  goto LABEL_46;
                }
                uint64_t v21 = v16 - (void)v18;
                if (v21 >> 3 > v20) {
                  unint64_t v20 = v21 >> 3;
                }
                if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v22 = v20;
                }
                if (v22)
                {
                  if (v22 >> 60) {
                    goto LABEL_47;
                  }
                  std::string::size_type v23 = (char *)operator new(16 * v22);
                }
                else
                {
                  std::string::size_type v23 = 0;
                }
                __int16 v24 = (unint64_t *)&v23[16 * v19];
                *__int16 v24 = v15;
                v24[1] = v9;
                std::string::size_type v25 = v24;
                if (v8 != v18)
                {
                  do
                  {
                    *((_OWORD *)v25 - 1) = *((_OWORD *)v8 - 1);
                    v25 -= 2;
                    v8 -= 2;
                  }
                  while (v8 != v18);
                  unint64_t v8 = *a4;
                }
                int v17 = v24 + 2;
                *a4 = v25;
                a4[1] = v24 + 2;
                a4[2] = (unint64_t *)&v23[16 * v22];
                if (v8) {
                  operator delete(v8);
                }
              }
              else
              {
                *unint64_t v8 = v15;
                v8[1] = v9;
                int v17 = v8 + 2;
              }
              a4[1] = v17;
              unint64_t v8 = v17;
            }
            v14 += 8;
            BOOL v26 = v11 >= 4;
            v11 >>= 1;
          }
          while (v26);
        }
        v36 += 504;
      }
      else
      {
        unint64_t v12 = (unint64_t)a4[2];
        if ((unint64_t)v8 >= v12)
        {
          std::string v27 = *a4;
          uint64_t v28 = ((char *)v8 - (char *)*a4) >> 4;
          unint64_t v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) >> 60) {
LABEL_46:
          }
            abort();
          uint64_t v30 = v12 - (void)v27;
          if (v30 >> 3 > v29) {
            unint64_t v29 = v30 >> 3;
          }
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v31 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v29;
          }
          if (v31)
          {
            if (v31 >> 60) {
LABEL_47:
            }
              sub_1CB833614();
            __int16 v32 = (char *)operator new(16 * v31);
          }
          else
          {
            __int16 v32 = 0;
          }
          std::string v33 = (unint64_t *)&v32[16 * v28];
          *std::string v33 = v10;
          v33[1] = v9;
          uint64_t v34 = v33;
          if (v8 != v27)
          {
            do
            {
              *((_OWORD *)v34 - 1) = *((_OWORD *)v8 - 1);
              v34 -= 2;
              v8 -= 2;
            }
            while (v8 != v27);
            unint64_t v8 = *a4;
          }
          unint64_t v13 = v33 + 2;
          *a4 = v34;
          a4[1] = v33 + 2;
          a4[2] = (unint64_t *)&v32[16 * v31];
          if (v8) {
            operator delete(v8);
          }
        }
        else
        {
          *unint64_t v8 = v10;
          v8[1] = v9;
          unint64_t v13 = v8 + 2;
        }
        a4[1] = v13;
        unint64_t v36 = v11 + 8;
        unint64_t v8 = v13;
      }
      ++a2;
    }
    while (a2 != v35);
  }
}

uint64_t llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::android_relas@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionContents(a1, a2, (uint64_t)&v52);
  unint64_t v6 = v52;
  if (v54)
  {
    std::string::size_type v52 = 0;
LABEL_12:
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v6;
    goto LABEL_14;
  }
  if (v53 < 4 || *v52 != 65 || v52[1] != 80 || v52[2] != 83 || v52[3] != 50)
  {
    std::string::size_type v50 = "invalid packed relocation header";
    __int16 v51 = 259;
    operator new();
  }
  BOOL v7 = *(unsigned char *)(*a1 + 5) == 1;
  v47[0] = v52;
  v47[1] = v53;
  BOOL v48 = v7;
  char v49 = 8;
  unint64_t v8 = &v46;
  uint64_t v45 = 4;
  uint64_t v46 = 0;
  unint64_t SLEB128 = llvm::DataExtractor::getSLEB128(v47, &v45, &v46);
  uint64_t result = llvm::DataExtractor::getSLEB128(v47, &v45, &v46);
  unint64_t v6 = (unsigned char *)v46;
  if (v46) {
    goto LABEL_12;
  }
  unint64_t v10 = result;
  uint64_t v37 = a3;
  if (SLEB128)
  {
    if (SLEB128 > 0xAAAAAAAAAAAAAAALL) {
LABEL_74:
    }
      abort();
    unint64_t v11 = (unint64_t *)operator new(24 * SLEB128);
    unint64_t v12 = &v11[3 * SLEB128];
  }
  else
  {
    unint64_t v11 = 0;
    unint64_t v12 = 0;
  }
  unint64_t v13 = 0;
  unint64_t v14 = v11;
  do
  {
    if (!SLEB128)
    {
      *(unsigned char *)(v37 + 24) &= ~1u;
      *(void *)uint64_t v37 = v11;
      *(void *)(v37 + ++*(_DWORD *)(this + 8) = v14;
      *(void *)(v37 + ++*(_DWORD *)(this + 16) = v12;
      goto LABEL_72;
    }
    unint64_t v15 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    uint64_t v16 = v46;
    if (v46) {
      break;
    }
    unint64_t v17 = v15;
    BOOL v18 = SLEB128 >= v15;
    SLEB128 -= v15;
    if (!v18)
    {
      std::string::size_type v50 = "relocation group unexpectedly large";
      __int16 v51 = 259;
      operator new();
    }
    uint64_t v44 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    if ((v44 & 2) != 0) {
      uint64_t v43 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    }
    else {
      uint64_t v43 = 0;
    }
    if (v44) {
      uint64_t v42 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    }
    else {
      uint64_t v42 = 0;
    }
    uint64_t v41 = v44 & 0xC;
    if (v41 == 12) {
      v13 += llvm::DataExtractor::getSLEB128(v47, &v45, v8);
    }
    v13 &= v44 << 60 >> 63;
    uint64_t v16 = v46;
    BOOL v19 = v46 == 0;
    if (!v46 && v17)
    {
      unint64_t v38 = SLEB128;
      uint64_t v20 = 0;
      unint64_t v40 = v17;
      do
      {
        uint64_t v21 = v43;
        if ((v44 & 2) == 0) {
          uint64_t v21 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
        }
        unint64_t v22 = v42;
        if ((v44 & 1) == 0) {
          unint64_t v22 = llvm::DataExtractor::getSLEB128(v47, &v45, v8);
        }
        if (v41 == 8) {
          v13 += llvm::DataExtractor::getSLEB128(v47, &v45, v8);
        }
        v10 += v21;
        unint64_t v23 = bswap64(v10);
        unint64_t v24 = bswap64(v22);
        unint64_t v25 = bswap64(v13);
        if (v14 >= v12)
        {
          unint64_t v39 = v13;
          unint64_t v27 = v10;
          uint64_t v28 = v8;
          unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (v14 - v11) + 1;
          if (v29 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_74;
          }
          if (0x5555555555555556 * (v12 - v11) > v29) {
            unint64_t v29 = 0x5555555555555556 * (v12 - v11);
          }
          if (0xAAAAAAAAAAAAAAABLL * (v12 - v11) >= 0x555555555555555) {
            unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v30 = v29;
          }
          if (v30)
          {
            if (v30 > 0xAAAAAAAAAAAAAAALL) {
              sub_1CB833614();
            }
            unint64_t v31 = (char *)operator new(24 * v30);
          }
          else
          {
            unint64_t v31 = 0;
          }
          __int16 v32 = (unint64_t *)&v31[8 * (v14 - v11)];
          *__int16 v32 = v23;
          v32[1] = v24;
          v32[2] = v25;
          if (v14 == v11)
          {
            unint64_t v35 = &v31[8 * (v14 - v11)];
            unint64_t v26 = v40;
          }
          else
          {
            std::string v33 = &v31[8 * (v14 - v11)];
            unint64_t v26 = v40;
            do
            {
              long long v34 = *(_OWORD *)(v14 - 3);
              unint64_t v35 = v33 - 24;
              *((void *)v33 - 1) = *(v14 - 1);
              *(_OWORD *)(v33 - 24) = v34;
              v14 -= 3;
              v33 -= 24;
            }
            while (v14 != v11);
          }
          unint64_t v12 = (unint64_t *)&v31[24 * v30];
          unint64_t v14 = v32 + 3;
          if (v11) {
            operator delete(v11);
          }
          unint64_t v11 = (unint64_t *)v35;
          unint64_t v8 = v28;
          unint64_t v10 = v27;
          unint64_t v13 = v39;
        }
        else
        {
          *unint64_t v14 = v23;
          v14[1] = v24;
          unint64_t v14[2] = v25;
          v14 += 3;
          unint64_t v26 = v40;
        }
        ++v20;
        uint64_t v16 = v46;
        BOOL v19 = v46 == 0;
        if (v46) {
          BOOL v36 = 1;
        }
        else {
          BOOL v36 = v20 == v26;
        }
      }
      while (!v36);
      unint64_t SLEB128 = v38;
    }
  }
  while (v19);
  uint64_t v46 = 0;
  *(unsigned char *)(v37 + 24) |= 1u;
  *(void *)uint64_t v37 = v16;
  if (v11) {
    operator delete(v11);
  }
LABEL_72:
  uint64_t result = v46;
  if (v46) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 8))(v46);
  }
LABEL_14:
  if (v54)
  {
    uint64_t result = (uint64_t)v52;
    std::string::size_type v52 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::notes_begin@<X0>(void *a1@<X0>, uint64_t a2@<X1>, void **a3@<X2>, void *a4@<X8>)
{
  unint64_t v6 = bswap64(*(void *)(a2 + 8));
  uint64_t v7 = bswap64(*(void *)(a2 + 32));
  if (v7 + v6 > a1[1])
  {
    uint64_t v9 = v7;
    unint64_t v10 = v6;
    v11[0] = "invalid offset (0x";
    v11[2] = &v10;
    __int16 v12 = 3587;
    v13[0] = v11;
    _OWORD v13[2] = ") or size (0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    unint64_t v17 = v15;
    BOOL v18 = ")";
    __int16 v19 = 770;
    operator new();
  }
  uint64_t result = sub_1CCC417D8(a4, *a1 + v6, v7, a3);
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

{
  unint64_t v6;
  uint64_t v7;
  void *result;
  uint64_t v9;
  unint64_t v10;
  void v11[4];
  __int16 v12;
  void v13[4];
  __int16 v14;
  void v15[4];
  __int16 v16;
  void *v17;
  const char *v18;
  __int16 v19;

  unint64_t v6 = bswap64(*(void *)(a2 + 24));
  uint64_t v7 = bswap64(*(void *)(a2 + 32));
  if (v7 + v6 > a1[1])
  {
    uint64_t v9 = v7;
    unint64_t v10 = v6;
    v11[0] = "invalid offset (0x";
    v11[2] = &v10;
    __int16 v12 = 3587;
    v13[0] = v11;
    _OWORD v13[2] = ") or size (0x";
    __int16 v14 = 770;
    v15[0] = v13;
    void v15[2] = &v9;
    __int16 v16 = 3586;
    unint64_t v17 = v15;
    BOOL v18 = ")";
    __int16 v19 = 770;
    operator new();
  }
  uint64_t result = sub_1CCC417D8(a4, *a1 + v6, v7, a3);
  if (!*a3) {
    *a3 = 0;
  }
  return result;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::notes_end(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::notes()
{
}

{
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::notes_begin();
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSymbol@<X0>(void *a1@<X0>, unint64_t *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    unint64_t v26 = 0;
    unint64_t v27 = 0;
    uint64_t v8 = a3;
    char v28 = 0;
    goto LABEL_3;
  }
  uint64_t result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::relas(a1, a2, (uint64_t)&v26);
  char v14 = v28;
  if (v28)
  {
    unint64_t v15 = v26;
    unint64_t v26 = 0;
    char v16 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    uint64_t v8 = a3;
    if (v27 <= a3)
    {
LABEL_3:
      sub_1CD6D3754(a1, (uint64_t)a2, (char *)&v17);
      uint64_t v9 = std::string::insert(&v17, 0, "unable to get symbol from section ");
      std::string::size_type v10 = v9->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v18.__r_.__value_.__l.__data_ = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
      v18.__r_.__value_.__r.__words[2] = v10;
      v9->__r_.__value_.__l.__size_ = 0;
      v9->__r_.__value_.__r.__words[2] = 0;
      v9->__r_.__value_.__r.__words[0] = 0;
      unint64_t v11 = std::string::append(&v18, ": invalid symbol index (");
      std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      std::string::size_type v20 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      v21[0] = __p;
      v21[2] = v8;
      __int16 v22 = 2052;
      unint64_t v23 = v21;
      unint64_t v24 = ")";
      __int16 v25 = 770;
      operator new();
    }
    unint64_t v15 = &v26[3 * a3];
    char v16 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v16;
  *(void *)a4 = v15;
  if (v14)
  {
    uint64_t result = v26;
    unint64_t v26 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

void *llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSegmentContents@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = bswap64(*(void *)(a2 + 8));
  unint64_t v5 = bswap64(*(void *)(a2 + 32));
  unint64_t v7 = v5;
  unint64_t v8 = v4;
  if (__CFADD__(v4, v5)) {
    sub_1CCC3E248();
  }
  if (v5 + v4 > result[1]) {
    sub_1CCC3E248();
  }
  unint64_t v6 = *result + v4;
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v6;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v5;
  return result;
}

void sub_1CCC3E248()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::program_headers();
}

void llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::decodeBBAddrMap(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::getSectionContents(a1, a2, (uint64_t)&v65);
  if (v67)
  {
    uint64_t v33 = v65;
    *(unsigned char *)(a3 + 24) |= 1u;
    *(void *)a3 = v33;
  }
  else
  {
    BOOL v5 = *(unsigned char *)(*a1 + 5) == 1;
    v46[0] = v65;
    v46[1] = v66;
    BOOL v47 = v5;
    unsigned __int8 v48 = 8;
    long long v44 = 0uLL;
    uint64_t v45 = 0;
    unsigned long long v43 = 0uLL;
    uint64_t v35 = v66;
    if (v66)
    {
      do
      {
        unsigned int Unsigned = (void **)llvm::DataExtractor::getUnsigned(v46, (unint64_t *)&v43, v48, (void *)&v43 + 1);
        uint64_t v64 = v43;
        unint64_t ULEB128 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
        unsigned int v38 = ULEB128;
        if (HIDWORD(ULEB128))
        {
          v49[0] = "ULEB128 value at offset 0x";
          std::string::size_type v50 = &v64;
          __int16 v51 = 3587;
          v52[0] = v49;
          unint64_t v53 = " exceeds UINT32_MAX (0x";
          __int16 v54 = 770;
          v55[0] = v52;
          p_unint64_t ULEB128 = &ULEB128;
          __int16 v57 = 3586;
          std::string::size_type v58 = (void **)v55;
          std::string::size_type v60 = ")";
          __int16 v62 = 770;
          operator new();
        }
        unsigned int v6 = 0;
        unint64_t v7 = 0;
        unint64_t v8 = 0;
        uint64_t v9 = 0;
        while (!*((void *)&v43 + 1) && v6 < v38)
        {
          uint64_t v64 = v43;
          unint64_t v11 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v11;
          unsigned int v39 = v6;
          if (HIDWORD(v11))
          {
            v49[0] = "ULEB128 value at offset 0x";
            std::string::size_type v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            unint64_t v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            std::string::size_type v58 = (void **)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v12 = v11;
          uint64_t v64 = v43;
          unint64_t v13 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v13;
          if (HIDWORD(v13))
          {
            v49[0] = "ULEB128 value at offset 0x";
            std::string::size_type v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            unint64_t v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            std::string::size_type v58 = (void **)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v14 = v13;
          uint64_t v64 = v43;
          unint64_t v15 = llvm::DataExtractor::getULEB128(v46, (uint64_t *)&v43, (void *)&v43 + 1);
          unint64_t ULEB128 = v15;
          if (HIDWORD(v15))
          {
            v49[0] = "ULEB128 value at offset 0x";
            std::string::size_type v50 = &v64;
            __int16 v51 = 3587;
            v52[0] = v49;
            unint64_t v53 = " exceeds UINT32_MAX (0x";
            __int16 v54 = 770;
            v55[0] = v52;
            p_unint64_t ULEB128 = &ULEB128;
            __int16 v57 = 3586;
            std::string::size_type v58 = (void **)v55;
            std::string::size_type v60 = ")";
            __int16 v62 = 770;
            operator new();
          }
          int v16 = v14;
          unsigned int v17 = (v15 >> 1) & 1;
          char v18 = v15 & 1;
          unsigned int v19 = (v15 >> 2) & 1;
          unsigned int v20 = (v15 >> 3) & 1;
          if (v8 >= v7)
          {
            unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 2) + 1;
            if (v23 > 0x1555555555555555) {
              abort();
            }
            if (0x5555555555555556 * ((v7 - v9) >> 2) > v23) {
              unint64_t v23 = 0x5555555555555556 * ((v7 - v9) >> 2);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v7 - v9) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
              unint64_t v24 = 0x1555555555555555;
            }
            else {
              unint64_t v24 = v23;
            }
            if (v24)
            {
              if (v24 > 0x1555555555555555) {
                sub_1CB833614();
              }
              unsigned int v25 = (v15 >> 3) & 1;
              int v26 = v16;
              unint64_t v37 = v24;
              unint64_t v27 = (char *)operator new(12 * v24);
              unint64_t v24 = v37;
              int v16 = v26;
              LOBYTE(v20) = v25;
            }
            else
            {
              unint64_t v27 = 0;
            }
            char v28 = &v27[4 * ((v8 - v9) >> 2)];
            *(_DWORD *)char v28 = v12;
            *((_DWORD *)v28 + 1) = v16;
            v28[8] = v18;
            v28[9] = v17;
            v28[10] = v19;
            v28[11] = v20;
            if (v8 == v9)
            {
              uint64_t v9 = &v27[4 * ((v8 - v9) >> 2)];
              unsigned int v22 = v39;
            }
            else
            {
              uint64_t v29 = &v27[4 * ((v8 - v9) >> 2)];
              unsigned int v22 = v39;
              do
              {
                uint64_t v30 = *(void *)(v8 - 12);
                v8 -= 12;
                int v31 = *((_DWORD *)v8 + 2);
                *(void *)(v29 - 12) = v30;
                v29 -= 12;
                *((_DWORD *)v29 + 2) = v31;
              }
              while (v8 != v9);
              unint64_t v8 = v9;
              uint64_t v9 = v29;
            }
            unint64_t v7 = &v27[12 * v24];
            uint64_t v21 = v28 + 12;
            if (v8) {
              operator delete(v8);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v8 = v12;
            *((_DWORD *)v8 + 1) = v16;
            v8[8] = v18;
            v8[9] = (v15 & 2) != 0;
            v8[10] = (v15 & 4) != 0;
            uint64_t v21 = v8 + 12;
            v8[11] = (v15 & 8) != 0;
            unsigned int v22 = v39;
          }
          unsigned int v6 = v22 + 1;
          unint64_t v8 = v21;
        }
        std::string::size_type v58 = Unsigned;
        std::string::size_type v60 = 0;
        uint64_t v61 = 0;
        std::string::size_type v59 = 0;
        sub_1CCC40DEC(&v59, v9, (uint64_t)v8, 0xAAAAAAAAAAAAAAABLL * ((v8 - v9) >> 2));
        sub_1CCC2B418((void **)&v44, (uint64_t)&v58);
        if (v59) {
          operator delete(v59);
        }
        if (v9) {
          operator delete(v9);
        }
        __int16 v32 = (char *)*((void *)&v43 + 1);
      }
      while (v43 < (unint64_t)v35);
    }
    else
    {
      __int16 v32 = 0;
    }
    if (v32)
    {
      unint64_t v40 = 0;
      uint64_t v41 = v32;
      *((void *)&v43 + 1) = 0;
      sub_1CD5E5368(&v41, &v40, &v42);
      *(unsigned char *)(a3 + 24) |= 1u;
      *(void *)a3 = v42;
      uint64_t v42 = 0;
      if (v40) {
        (*(void (**)(char *))(*(void *)v40 + 8))(v40);
      }
      if (v41) {
        (*(void (**)(char *))(*(void *)v41 + 8))(v41);
      }
    }
    else
    {
      *(unsigned char *)(a3 + 24) &= ~1u;
      *(_OWORD *)a3 = v44;
      *(void *)(a3 + ++*(_DWORD *)(this + 16) = v45;
      long long v44 = 0uLL;
      uint64_t v45 = 0;
    }
    if (*((void *)&v43 + 1)) {
      (*(void (**)(void))(**((void **)&v43 + 1) + 8))(*((void *)&v43 + 1));
    }
    std::string::size_type v58 = (void **)&v44;
    sub_1CC4CDFC0(&v58);
    if (v67)
    {
      uint64_t v34 = v65;
      uint64_t v65 = 0;
      if (v34) {
        (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
      }
    }
  }
}

void sub_1CCC3EBD0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2)
      {
        sub_1CCC3ECB4(a1, a2);
        unint64_t v2 = *(unsigned int *)(a1 + 8);
      }
      if (v2 != a2) {
        bzero((void *)(*(void *)a1 + 40 * v2), 40 * ((-40 * v2 + 40 * a2 - 40) / 0x28) + 40);
      }
    }
    else
    {
      uint64_t v5 = 5 * v2;
      unsigned int v6 = (char *)(*(void *)a1 + 8 * v5 - 17);
      uint64_t v7 = 40 * a2 - 8 * v5;
      do
      {
        if (v6[9])
        {
          if (*v6 < 0) {
            operator delete(*(void **)(v6 - 23));
          }
          v6[9] = 0;
        }
        v6 -= 40;
        v7 += 40;
      }
      while (v7);
    }
    *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = a2;
  }
}

void sub_1CCC3ECB4(uint64_t a1, unint64_t a2)
{
  if (HIDWORD(a2)) {
    sub_1CD0A88F0(a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  if (v3 == -1) {
    sub_1CD0A89A8(0xFFFFFFFFuLL);
  }
  unint64_t v4 = (2 * v3) | 1;
  if (v4 <= a2) {
    unint64_t v4 = a2;
  }
  if (v4 >= 0xFFFFFFFF) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v5 = v4;
  }
  unsigned int v6 = malloc_type_malloc(40 * v5, 0x4065EBACuLL);
  if (!v6) {
    llvm::report_bad_alloc_error((llvm *)"Allocation failed", (const char *)1);
  }
  uint64_t v7 = v6;
  sub_1CCC3ED70((long long **)a1, (uint64_t)v6);
  if (*(void *)a1 != a1 + 16) {
    free(*(void **)a1);
  }
  *(void *)a1 = v7;
  *(_DWORD *)(a1 + 12) = v5;
}

void sub_1CCC3ED70(long long **a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    unint64_t v4 = (unsigned char *)(a2 + 32);
    uint64_t v5 = 40 * v2;
    do
    {
      *(v4 - 32) = 0;
      unsigned char *v4 = 0;
      if (*((unsigned char *)v3 + 32))
      {
        long long v6 = *v3;
        *((void *)v4 - 2) = *((void *)v3 + 2);
        *((_OWORD *)v4 - 2) = v6;
        *((void *)v3 + 1) = 0;
        *((void *)v3 + 2) = 0;
        *(void *)uint64_t v3 = 0;
        *(v4 - ++*(_DWORD *)(this + 8) = *((unsigned char *)v3 + 24);
        unsigned char *v4 = 1;
      }
      uint64_t v3 = (long long *)((char *)v3 + 40);
      v4 += 40;
      v5 -= 40;
    }
    while (v5);
    uint64_t v7 = *((unsigned int *)a1 + 2);
    if (v7)
    {
      unint64_t v8 = *a1;
      uint64_t v9 = 40 * v7;
      do
      {
        uint64_t v10 = (uint64_t)v8 + v9;
        if (*((unsigned char *)v8 + v9 - 8))
        {
          if (*(char *)(v10 - 17) < 0) {
            operator delete(*(void **)(v10 - 40));
          }
          *(unsigned char *)(v10 - ++*(_DWORD *)(this + 8) = 0;
        }
        v9 -= 40;
      }
      while (v9);
    }
  }
}

void sub_1CCC3EE34(uint64_t a1, void **a2)
{
  unint64_t v4 = *(void ***)(a1 + 8);
  if (v4 != a2)
  {
    uint64_t v5 = v4 - 3;
    do
    {
      uint64_t v7 = v5;
      sub_1CC1CB288(&v7);
      if (*((char *)v5 - 1) < 0) {
        operator delete(*(v5 - 3));
      }
      long long v6 = v5 - 6;
      v5 -= 9;
    }
    while (v6 != a2);
  }
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = a2;
}

__n128 sub_1CCC3EEA8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = a2 + v4 - a4;
  if (v5 >= a3)
  {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  else
  {
    long long v6 = (long long *)(a2 + v4 - a4);
    uint64_t v7 = *(void *)(a1 + 8);
    do
    {
      long long v8 = *v6;
      *(void *)(v7 + ++*(_DWORD *)(this + 16) = *((void *)v6 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      long long v9 = *(long long *)((char *)v6 + 24);
      *(void *)(v7 + 40) = *((void *)v6 + 5);
      *(_OWORD *)(v7 + 24) = v9;
      *((void *)v6 + 4) = 0;
      *((void *)v6 + 5) = 0;
      *((void *)v6 + 3) = 0;
      *(void *)(v7 + 4++*(_DWORD *)(this + 8) = 0;
      *(void *)(v7 + 56) = 0;
      *(void *)(v7 + 64) = 0;
      __n128 result = (__n128)v6[3];
      *(__n128 *)(v7 + 4++*(_DWORD *)(this + 8) = result;
      *(void *)(v7 + 64) = *((void *)v6 + 8);
      v7 += 72;
      *((void *)v6 + 6) = 0;
      *((void *)v6 + 7) = 0;
      *((void *)v6 + ++*(_DWORD *)(this + 8) = 0;
      long long v6 = (long long *)((char *)v6 + 72);
    }
    while ((unint64_t)v6 < a3);
  }
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = v7;
  if (v4 != a4)
  {
    uint64_t v11 = 0;
    uint64_t v12 = -8 * ((v4 - a4) >> 3);
    do
    {
      uint64_t v13 = v5 + v11;
      uint64_t v14 = v4 + v11;
      long long v15 = *(_OWORD *)(v5 + v11 - 72);
      *(void *)(v14 - 56) = *(void *)(v5 + v11 - 56);
      *(_OWORD *)(v14 - 72) = v15;
      int v16 = (void **)(v4 + v11 - 48);
      if (*(char *)(v4 + v11 - 25) < 0) {
        operator delete(*v16);
      }
      long long v17 = *(_OWORD *)(v13 - 48);
      *(void *)(v4 + v11 - 32) = *(void *)(v13 - 32);
      *(_OWORD *)int v16 = v17;
      *(unsigned char *)(v13 - 25) = 0;
      *(unsigned char *)(v13 - 4++*(_DWORD *)(this + 8) = 0;
      sub_1CCC3F398((void **)(v14 - 24));
      __n128 result = *(__n128 *)(v13 - 24);
      *(__n128 *)(v14 - 24) = result;
      *(void *)(v14 - ++*(_DWORD *)(this + 8) = *(void *)(v13 - 8);
      *(void *)(v13 - 24) = 0;
      *(void *)(v13 - ++*(_DWORD *)(this + 16) = 0;
      *(void *)(v13 - ++*(_DWORD *)(this + 8) = 0;
      v11 -= 72;
    }
    while (v12 != v11);
  }
  return result;
}

double sub_1CCC3EFF8(long long **a1)
{
  uint64_t v2 = a1[2];
  if (v2 != a1[3]) {
    goto LABEL_29;
  }
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  if (v4 > *a1)
  {
    int64_t v5 = 0x8E38E38E38E38E39 * (((char *)v4 - (char *)*a1) >> 3);
    if (v5 >= -1) {
      uint64_t v6 = v5 + 1;
    }
    else {
      uint64_t v6 = v5 + 2;
    }
    uint64_t v7 = -(v6 >> 1);
    if (v4 == v2)
    {
      uint64_t v13 = (long long *)((char *)v4 - 72 * (v6 >> 1));
    }
    else
    {
      uint64_t v8 = -72 * (v6 >> 1);
      do
      {
        uint64_t v9 = (uint64_t)v4 + v8;
        long long v10 = *v4;
        *(void *)(v9 + ++*(_DWORD *)(this + 16) = *((void *)v4 + 2);
        *(_OWORD *)uint64_t v9 = v10;
        uint64_t v11 = (void **)((char *)v4 + v8 + 24);
        if (*((char *)v4 + v8 + 47) < 0) {
          operator delete(*v11);
        }
        long long v12 = *(long long *)((char *)v4 + 24);
        *(void *)((char *)v4 + v8 + 40) = *((void *)v4 + 5);
        *(_OWORD *)uint64_t v11 = v12;
        *((unsigned char *)v4 + 47) = 0;
        *((unsigned char *)v4 + 24) = 0;
        sub_1CCC3F398((void **)(v9 + 48));
        *(_OWORD *)(v9 + 4++*(_DWORD *)(this + 8) = v4[3];
        *(void *)(v9 + 64) = *((void *)v4 + 8);
        *((void *)v4 + 6) = 0;
        *((void *)v4 + 7) = 0;
        *((void *)v4 + ++*(_DWORD *)(this + 8) = 0;
        uint64_t v4 = (long long *)((char *)v4 + 72);
      }
      while (v4 != v2);
      uint64_t v2 = a1[1];
      uint64_t v13 = (long long *)((char *)v4 + 72 * v7);
    }
    a1[1] = (long long *)((char *)v2 + 72 * v7);
    a1[2] = v13;
    goto LABEL_29;
  }
  unint64_t v14 = 0x1C71C71C71C71C72 * (((char *)v2 - (char *)v3) >> 3);
  if (v2 == v3) {
    unint64_t v14 = 1;
  }
  if (v14 >= 0x38E38E38E38E38FLL) {
    sub_1CB833614();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 9 * v14;
  long long v17 = (char *)operator new(72 * v14);
  char v18 = &v17[72 * v15];
  unsigned int v19 = &v17[8 * v16];
  if (v2 == v4)
  {
    *a1 = (long long *)v17;
    a1[1] = (long long *)v18;
    a1[2] = (long long *)v18;
    a1[3] = (long long *)v19;
    if (!v3) {
      goto LABEL_29;
    }
LABEL_28:
    operator delete(v3);
    goto LABEL_29;
  }
  unsigned int v20 = &v18[(char *)v2 - (char *)v4];
  uint64_t v21 = 72 * v15;
  do
  {
    unsigned int v22 = &v17[v21];
    long long v23 = *v4;
    *((void *)v22 + 2) = *((void *)v4 + 2);
    *(_OWORD *)unsigned int v22 = v23;
    long long v24 = *(long long *)((char *)v4 + 24);
    *((void *)v22 + 5) = *((void *)v4 + 5);
    *(_OWORD *)(v22 + 24) = v24;
    *((void *)v4 + 4) = 0;
    *((void *)v4 + 5) = 0;
    *((void *)v4 + 3) = 0;
    *((_OWORD *)v22 + 3) = v4[3];
    *((void *)v22 + ++*(_DWORD *)(this + 8) = *((void *)v4 + 8);
    *((void *)v4 + 6) = 0;
    *((void *)v4 + 7) = 0;
    *((void *)v4 + ++*(_DWORD *)(this + 8) = 0;
    v21 += 72;
    uint64_t v4 = (long long *)((char *)v4 + 72);
  }
  while (v22 + 72 != v20);
  uint64_t v3 = *a1;
  unsigned int v25 = (void **)a1[1];
  int v26 = (void **)a1[2];
  *a1 = (long long *)v17;
  a1[1] = (long long *)v18;
  a1[2] = (long long *)v20;
  a1[3] = (long long *)v19;
  if (v26 != v25)
  {
    unint64_t v27 = v26 - 3;
    do
    {
      int v31 = v27;
      sub_1CC1CB288(&v31);
      if (*((char *)v27 - 1) < 0) {
        operator delete(*(v27 - 3));
      }
      char v28 = v27 - 6;
      v27 -= 9;
    }
    while (v28 != v25);
  }
  if (v3) {
    goto LABEL_28;
  }
LABEL_29:
  uint64_t v29 = a1[2];
  *((void *)v29 + ++*(_DWORD *)(this + 8) = 0;
  double result = 0.0;
  v29[2] = 0u;
  v29[3] = 0u;
  long long *v29 = 0u;
  v29[1] = 0u;
  a1[2] = (long long *)((char *)a1[2] + 72);
  return result;
}

long long *sub_1CCC3F26C(long long **a1, void *a2, long long *a3)
{
  double result = (long long *)a2[1];
  int64_t v5 = *a1;
  uint64_t v6 = result;
  if (*a1 != a3)
  {
    uint64_t v7 = a3;
    uint64_t v8 = a2[1];
    do
    {
      uint64_t v6 = (long long *)(v8 - 72);
      long long v9 = *(long long *)((char *)v7 - 72);
      *(void *)(v8 - 56) = *((void *)v7 - 7);
      *(_OWORD *)(v8 - 72) = v9;
      long long v10 = *(v7 - 3);
      *(void *)(v8 - 32) = *((void *)v7 - 4);
      *(_OWORD *)(v8 - 4++*(_DWORD *)(this + 8) = v10;
      *((void *)v7 - 5) = 0;
      *((void *)v7 - 4) = 0;
      *((void *)v7 - 6) = 0;
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - ++*(_DWORD *)(this + 16) = 0;
      *(void *)(v8 - ++*(_DWORD *)(this + 8) = 0;
      *(_OWORD *)(v8 - 24) = *(long long *)((char *)v7 - 24);
      *(void *)(v8 - ++*(_DWORD *)(this + 8) = *((void *)v7 - 1);
      *((void *)v7 - 3) = 0;
      *((void *)v7 - 2) = 0;
      *((void *)v7 - 1) = 0;
      uint64_t v7 = (long long *)((char *)v7 - 72);
      v8 -= 72;
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  uint64_t v11 = a1[1];
  uint64_t v12 = a2[2];
  if (v11 != a3)
  {
    do
    {
      long long v13 = *a3;
      *(void *)(v12 + ++*(_DWORD *)(this + 16) = *((void *)a3 + 2);
      *(_OWORD *)uint64_t v12 = v13;
      long long v14 = *(long long *)((char *)a3 + 24);
      *(void *)(v12 + 40) = *((void *)a3 + 5);
      *(_OWORD *)(v12 + 24) = v14;
      *((void *)a3 + 4) = 0;
      *((void *)a3 + 5) = 0;
      *((void *)a3 + 3) = 0;
      *(void *)(v12 + 4++*(_DWORD *)(this + 8) = 0;
      *(void *)(v12 + 56) = 0;
      *(void *)(v12 + 64) = 0;
      *(_OWORD *)(v12 + 4++*(_DWORD *)(this + 8) = a3[3];
      *(void *)(v12 + 64) = *((void *)a3 + 8);
      v12 += 72;
      *((void *)a3 + 6) = 0;
      *((void *)a3 + 7) = 0;
      *((void *)a3 + ++*(_DWORD *)(this + 8) = 0;
      a3 = (long long *)((char *)a3 + 72);
    }
    while (a3 != v11);
    uint64_t v6 = (long long *)a2[1];
  }
  a2[2] = v12;
  unint64_t v15 = *a1;
  *a1 = v6;
  a2[1] = v15;
  uint64_t v16 = a1[1];
  a1[1] = (long long *)a2[2];
  a2[2] = v16;
  long long v17 = a1[2];
  a1[2] = (long long *)a2[3];
  a2[3] = v17;
  *a2 = a2[1];
  return result;
}

void sub_1CCC3F398(void **a1)
{
  uint64_t v1 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 4;
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *sub_1CCC3F408(unint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  unint64_t v2 = a1[1];
  uint64_t v4 = (uint64_t)(v2 - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    abort();
  }
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  unsigned int v22 = a1 + 2;
  if (v9)
  {
    if (v9 >> 59) {
      sub_1CB833614();
    }
    long long v10 = (char *)operator new(32 * v9);
  }
  else
  {
    long long v10 = 0;
  }
  uint64_t v11 = &v10[32 * v4];
  *(_DWORD *)uint64_t v11 = *(_DWORD *)a2;
  uint64_t v12 = v11 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v12, *(const void **)(a2 + 8), *(void *)(a2 + 16));
    unint64_t v3 = *a1;
    unint64_t v2 = a1[1];
  }
  else
  {
    *uint64_t v12 = *(_OWORD *)(a2 + 8);
    *((void *)v11 + 3) = *(void *)(a2 + 24);
  }
  if (v2 == v3)
  {
    int64x2_t v16 = vdupq_n_s64(v3);
    unint64_t v13 = (unint64_t)v11;
  }
  else
  {
    unint64_t v13 = (unint64_t)v11;
    do
    {
      int v14 = *(_DWORD *)(v2 - 32);
      v2 -= 32;
      *(_DWORD *)(v13 - 32) = v14;
      v13 -= 32;
      long long v15 = *(_OWORD *)(v2 + 8);
      *(void *)(v13 + 24) = *(void *)(v2 + 24);
      *(_OWORD *)(v13 + ++*(_DWORD *)(this + 8) = v15;
      *(void *)(v2 + ++*(_DWORD *)(this + 16) = 0;
      *(void *)(v2 + 24) = 0;
      *(void *)(v2 + ++*(_DWORD *)(this + 8) = 0;
    }
    while (v2 != v3);
    int64x2_t v16 = *(int64x2_t *)a1;
  }
  *a1 = v13;
  a1[1] = (unint64_t)(v11 + 32);
  int64x2_t v20 = v16;
  unint64_t v17 = a1[2];
  a1[2] = (unint64_t)&v10[32 * v9];
  unint64_t v21 = v17;
  uint64_t v19 = v16.i64[0];
  sub_1CD4FF274((uint64_t)&v19);
  return v11 + 32;
}

void sub_1CCC3F564(uint64_t a1, void **a2)
{
  uint64_t v4 = *(void ***)(a1 + 8);
  if (v4 != a2)
  {
    unint64_t v5 = v4 - 3;
    do
    {
      uint64_t v7 = v5;
      sub_1CCC3F5D8(&v7);
      if (*((char *)v5 - 1) < 0) {
        operator delete(*(v5 - 3));
      }
      uint64_t v6 = v5 - 5;
      v5 -= 8;
    }
    while (v6 != a2);
  }
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = a2;
}

void sub_1CCC3F5D8(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0) {
          operator delete(*(v4 - 3));
        }
        v4 -= 5;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

__n128 sub_1CCC3F664(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = a2 + v4 - a4;
  if (v5 >= a3)
  {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  else
  {
    uint64_t v6 = (uint64_t *)(a2 + v4 - a4);
    uint64_t v7 = *(void *)(a1 + 8);
    do
    {
      uint64_t v8 = *v6;
      *(_DWORD *)(v7 + ++*(_DWORD *)(this + 8) = *((_DWORD *)v6 + 2);
      *(void *)uint64_t v7 = v8;
      long long v9 = *((_OWORD *)v6 + 1);
      *(void *)(v7 + 32) = v6[4];
      *(_OWORD *)(v7 + ++*(_DWORD *)(this + 16) = v9;
      v6[3] = 0;
      v6[4] = 0;
      void v6[2] = 0;
      *(void *)(v7 + 40) = 0;
      *(void *)(v7 + 4++*(_DWORD *)(this + 8) = 0;
      *(void *)(v7 + 56) = 0;
      __n128 result = *(__n128 *)(v6 + 5);
      *(__n128 *)(v7 + 40) = result;
      *(void *)(v7 + 56) = v6[7];
      v7 += 64;
      v6[5] = 0;
      v6[6] = 0;
      v6[7] = 0;
      v6 += 8;
    }
    while ((unint64_t)v6 < a3);
  }
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = v7;
  if (v4 != a4)
  {
    uint64_t v11 = 0;
    uint64_t v12 = -64 * ((v4 - a4) >> 6);
    do
    {
      uint64_t v13 = v5 + v11;
      uint64_t v14 = v4 + v11;
      uint64_t v15 = *(void *)(v5 + v11 - 64);
      *(_DWORD *)(v14 - 56) = *(_DWORD *)(v5 + v11 - 56);
      *(void *)(v14 - 64) = v15;
      int64x2_t v16 = (void **)(v4 + v11 - 48);
      if (*(char *)(v4 + v11 - 25) < 0) {
        operator delete(*v16);
      }
      long long v17 = *(_OWORD *)(v13 - 48);
      *(void *)(v4 + v11 - 32) = *(void *)(v13 - 32);
      *(_OWORD *)int64x2_t v16 = v17;
      *(unsigned char *)(v13 - 25) = 0;
      *(unsigned char *)(v13 - 4++*(_DWORD *)(this + 8) = 0;
      sub_1CCC3FAD0((void **)(v14 - 24));
      __n128 result = *(__n128 *)(v13 - 24);
      *(__n128 *)(v14 - 24) = result;
      *(void *)(v14 - ++*(_DWORD *)(this + 8) = *(void *)(v13 - 8);
      *(void *)(v13 - 24) = 0;
      *(void *)(v13 - ++*(_DWORD *)(this + 16) = 0;
      *(void *)(v13 - ++*(_DWORD *)(this + 8) = 0;
      v11 -= 64;
    }
    while (v12 != v11);
  }
  return result;
}

double sub_1CCC3F79C(uint64_t **a1)
{
  unint64_t v2 = a1[2];
  if (v2 != a1[3]) {
    goto LABEL_30;
  }
  unint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  if (v4 > *a1)
  {
    uint64_t v5 = ((char *)v4 - (char *)*a1) >> 6;
    if (v5 >= -1) {
      uint64_t v6 = v5 + 1;
    }
    else {
      uint64_t v6 = v5 + 2;
    }
    uint64_t v7 = -(v6 >> 1);
    if (v4 == v2)
    {
      uint64_t v13 = &v4[-8 * (v6 >> 1)];
    }
    else
    {
      uint64_t v8 = -8 * (v6 >> 1);
      do
      {
        long long v9 = &v4[v8];
        uint64_t v10 = *v4;
        *((_DWORD *)v9 + 2) = *((_DWORD *)v4 + 2);
        *long long v9 = v10;
        uint64_t v11 = (void **)&v4[v8 + 2];
        if (SHIBYTE(v4[v8 + 4]) < 0) {
          operator delete(*v11);
        }
        long long v12 = *((_OWORD *)v4 + 1);
        v4[v8 + 4] = v4[4];
        *(_OWORD *)uint64_t v11 = v12;
        *((unsigned char *)v4 + 39) = 0;
        *((unsigned char *)v4 + ++*(_DWORD *)(this + 16) = 0;
        sub_1CCC3FAD0((void **)v9 + 5);
        *(_OWORD *)(v9 + 5) = *(_OWORD *)(v4 + 5);
        v9[7] = v4[7];
        v4[5] = 0;
        v4[6] = 0;
        v4[7] = 0;
        v4 += 8;
      }
      while (v4 != v2);
      unint64_t v2 = a1[1];
      uint64_t v13 = &v4[8 * v7];
    }
    a1[1] = &v2[8 * v7];
    a1[2] = v13;
    goto LABEL_30;
  }
  if (v2 == v3) {
    unint64_t v14 = 1;
  }
  else {
    unint64_t v14 = ((char *)v2 - (char *)v3) >> 5;
  }
  if (v14 >> 58) {
    sub_1CB833614();
  }
  uint64_t v15 = (char *)operator new(v14 << 6);
  int64x2_t v16 = &v15[64 * (v14 >> 2)];
  long long v17 = &v15[64 * v14];
  if (v2 == v4)
  {
    *a1 = (uint64_t *)v15;
    a1[1] = (uint64_t *)v16;
    a1[2] = (uint64_t *)v16;
    a1[3] = (uint64_t *)v17;
    if (!v3) {
      goto LABEL_30;
    }
LABEL_29:
    operator delete(v3);
    goto LABEL_30;
  }
  char v18 = &v16[(char *)v2 - (char *)v4];
  unint64_t v19 = v14 >> 2 << 6;
  do
  {
    int64x2_t v20 = &v15[v19];
    uint64_t v21 = *v4;
    *((_DWORD *)v20 + 2) = *((_DWORD *)v4 + 2);
    *(void *)int64x2_t v20 = v21;
    long long v22 = *((_OWORD *)v4 + 1);
    *((void *)v20 + 4) = v4[4];
    *((_OWORD *)v20 + 1) = v22;
    v4[3] = 0;
    v4[4] = 0;
    void v4[2] = 0;
    *(_OWORD *)(v20 + 40) = *(_OWORD *)(v4 + 5);
    *((void *)v20 + 7) = v4[7];
    v4[5] = 0;
    v4[6] = 0;
    v4[7] = 0;
    v19 += 64;
    v4 += 8;
  }
  while (v20 + 64 != v18);
  unint64_t v3 = *a1;
  long long v23 = (void **)a1[1];
  long long v24 = (void **)a1[2];
  *a1 = (uint64_t *)v15;
  a1[1] = (uint64_t *)v16;
  a1[2] = (uint64_t *)v18;
  a1[3] = (uint64_t *)v17;
  if (v24 != v23)
  {
    unsigned int v25 = v24 - 3;
    do
    {
      uint64_t v29 = v25;
      sub_1CCC3F5D8(&v29);
      if (*((char *)v25 - 1) < 0) {
        operator delete(*(v25 - 3));
      }
      int v26 = v25 - 5;
      v25 -= 8;
    }
    while (v26 != v23);
  }
  if (v3) {
    goto LABEL_29;
  }
LABEL_30:
  unint64_t v27 = a1[2];
  double result = 0.0;
  *((_OWORD *)v27 + 2) = 0u;
  *((_OWORD *)v27 + 3) = 0u;
  *(_OWORD *)unint64_t v27 = 0u;
  *((_OWORD *)v27 + 1) = 0u;
  a1[2] += 8;
  return result;
}

uint64_t sub_1CCC3F9B4(uint64_t **a1, void *a2, uint64_t *a3)
{
  uint64_t result = a2[1];
  uint64_t v5 = *a1;
  uint64_t v6 = result;
  if (*a1 != a3)
  {
    uint64_t v7 = a3;
    uint64_t v6 = a2[1];
    do
    {
      uint64_t v8 = *(v7 - 8);
      v7 -= 8;
      int v9 = *((_DWORD *)v7 + 2);
      *(void *)(v6 - 64) = v8;
      v6 -= 64;
      *(_DWORD *)(v6 + ++*(_DWORD *)(this + 8) = v9;
      long long v10 = *((_OWORD *)v7 + 1);
      *(void *)(v6 + 32) = v7[4];
      *(_OWORD *)(v6 + ++*(_DWORD *)(this + 16) = v10;
      v7[3] = 0;
      v7[4] = 0;
      void v7[2] = 0;
      *(void *)(v6 + 40) = 0;
      *(void *)(v6 + 4++*(_DWORD *)(this + 8) = 0;
      *(void *)(v6 + 56) = 0;
      *(_OWORD *)(v6 + 40) = *(_OWORD *)(v7 + 5);
      *(void *)(v6 + 56) = v7[7];
      v7[5] = 0;
      v7[6] = 0;
      v7[7] = 0;
    }
    while (v7 != v5);
  }
  a2[1] = v6;
  uint64_t v11 = a1[1];
  uint64_t v12 = a2[2];
  if (v11 != a3)
  {
    do
    {
      uint64_t v13 = *a3;
      *(_DWORD *)(v12 + ++*(_DWORD *)(this + 8) = *((_DWORD *)a3 + 2);
      *(void *)uint64_t v12 = v13;
      long long v14 = *((_OWORD *)a3 + 1);
      *(void *)(v12 + 32) = a3[4];
      *(_OWORD *)(v12 + ++*(_DWORD *)(this + 16) = v14;
      a3[3] = 0;
      a3[4] = 0;
      a3[2] = 0;
      *(void *)(v12 + 40) = 0;
      *(void *)(v12 + 4++*(_DWORD *)(this + 8) = 0;
      *(void *)(v12 + 56) = 0;
      *(_OWORD *)(v12 + 40) = *(_OWORD *)(a3 + 5);
      *(void *)(v12 + 56) = a3[7];
      v12 += 64;
      a3[5] = 0;
      a3[6] = 0;
      a3[7] = 0;
      a3 += 8;
    }
    while (a3 != v11);
    uint64_t v6 = a2[1];
  }
  a2[2] = v12;
  uint64_t v15 = *a1;
  *a1 = (uint64_t *)v6;
  a2[1] = v15;
  int64x2_t v16 = a1[1];
  a1[1] = (uint64_t *)a2[2];
  a2[2] = v16;
  long long v17 = a1[2];
  a1[2] = (uint64_t *)a2[3];
  a2[3] = v17;
  *a2 = a2[1];
  return result;
}

void sub_1CCC3FAD0(void **a1)
{
  uint64_t v1 = (void **)*a1;
  if (*a1)
  {
    unint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*(v3 - 3));
        }
        v3 -= 5;
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

double sub_1CCC3FB40(void *a1)
{
  unint64_t v2 = a1[2];
  if (v2 == a1[3])
  {
    uint64_t v4 = *a1;
    unint64_t v3 = a1[1];
    if (v3 <= *a1)
    {
      unint64_t v9 = 0x999999999999999ALL * ((uint64_t)(v2 - v4) >> 3);
      if (v2 == v4) {
        unint64_t v9 = 1;
      }
      uint64_t v22 = a1[4];
      if (v9 >= 0x666666666666667) {
        sub_1CB833614();
      }
      unint64_t v10 = v9 >> 2;
      uint64_t v11 = 5 * v9;
      uint64_t v12 = (char *)operator new(40 * v9);
      uint64_t v13 = &v12[40 * v10];
      if (v2 == v3)
      {
        int64x2_t v17 = vdupq_n_s64(v2);
        long long v14 = &v12[40 * v10];
      }
      else
      {
        long long v14 = &v13[v2 - v3];
        uint64_t v15 = &v12[40 * v10];
        do
        {
          *(_OWORD *)uint64_t v15 = *(_OWORD *)v3;
          long long v16 = *(_OWORD *)(v3 + 16);
          *((void *)v15 + 4) = *(void *)(v3 + 32);
          *((_OWORD *)v15 + 1) = v16;
          *(void *)(v3 + 24) = 0;
          *(void *)(v3 + 32) = 0;
          *(void *)(v3 + ++*(_DWORD *)(this + 16) = 0;
          v15 += 40;
          v3 += 40;
        }
        while (v15 != v14);
        uint64_t v4 = *a1;
        int64x2_t v17 = *(int64x2_t *)(a1 + 1);
        unint64_t v2 = a1[3];
      }
      uint64_t v19 = v4;
      *a1 = v12;
      a1[1] = v13;
      int64x2_t v20 = v17;
      a1[2] = v14;
      a1[3] = &v12[8 * v11];
      unint64_t v21 = v2;
      sub_1CCC3FD5C((uint64_t)&v19);
      unint64_t v2 = a1[2];
    }
    else
    {
      int64_t v5 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v3 - *a1) >> 3);
      if (v5 >= -1) {
        uint64_t v6 = v5 + 1;
      }
      else {
        uint64_t v6 = v5 + 2;
      }
      uint64_t v7 = -5 * (v6 >> 1);
      sub_1CC1924A0(a1[1], v2, v3 - 40 * (v6 >> 1));
      unint64_t v2 = v8;
      a1[1] += 8 * v7;
      a1[2] = v8;
    }
  }
  *(void *)(v2 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)unint64_t v2 = 0u;
  *(_OWORD *)(v2 + ++*(_DWORD *)(this + 16) = 0u;
  a1[2] += 40;
  return result;
}

uint64_t sub_1CCC3FCC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a1)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a2 + v6;
      *(_OWORD *)(a3 + v6 - 40) = *(_OWORD *)(a2 + v6 - 40);
      uint64_t v8 = a3 + v6 - 24;
      if (*(char *)(a3 + v6 - 1) < 0) {
        operator delete(*(void **)v8);
      }
      v6 -= 40;
      long long v9 = *(_OWORD *)(v7 - 24);
      *(void *)(v8 + ++*(_DWORD *)(this + 16) = *(void *)(v7 - 8);
      *(_OWORD *)uint64_t v8 = v9;
      *(unsigned char *)(v7 - 1) = 0;
      *(unsigned char *)(v7 - 24) = 0;
    }
    while (a2 + v6 != a1);
  }
  return a2;
}

uint64_t sub_1CCC3FD5C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 40;
      *(void *)(a1 + ++*(_DWORD *)(this + 16) = v2 - 40;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char **sub_1CCC3FDC0(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 40 * v3;
    do
    {
      int64_t v5 = (void **)&v2[v4];
      if (v2[v4 - 8])
      {
        if (*((char *)v5 - 17) < 0) {
          operator delete(*(v5 - 5));
        }
        *((unsigned char *)v5 - ++*(_DWORD *)(this + 8) = 0;
      }
      v4 -= 40;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

unint64_t sub_1CCC3FE40(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = v4 + a3;
  if (v4 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v7 = *(void *)a1 + 40 * v4;
    if (*(void *)a1 <= a2 && v7 > a2)
    {
      unint64_t v9 = a2 - *(void *)a1;
      sub_1CCC3ECB4(a1, v5);
      return *(void *)a1 + v9;
    }
    else
    {
      sub_1CCC3ECB4(a1, v5);
    }
  }
  return a2;
}

uint64_t sub_1CCC3FEAC(uint64_t a1)
{
  uint64_t v2 = *(void ***)a1;
  if (*(unsigned char *)(a1 + 24))
  {
    *(void *)a1 = 0;
    if (v2) {
      (*((void (**)(void **))*v2 + 1))(v2);
    }
  }
  else if (v2)
  {
    sub_1CCC3EE34(a1, v2);
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CCC3FF24(uint64_t a1)
{
  uint64_t v2 = *(void ***)a1;
  if (*(unsigned char *)(a1 + 24))
  {
    *(void *)a1 = 0;
    if (v2) {
      (*((void (**)(void **))*v2 + 1))(v2);
    }
  }
  else if (v2)
  {
    sub_1CCC3F564(a1, v2);
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CCC3FF9C(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 != a2 + 16)
    {
      sub_1CCC40214((char **)a1, (char **)a2);
      return a1;
    }
    unint64_t v5 = *(unsigned int *)(a2 + 8);
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    if (v6 >= v5)
    {
      unint64_t v10 = *(char **)a1;
      if (v5)
      {
        uint64_t v11 = 40 * v5;
        do
        {
          sub_1CCC402B4((uint64_t)v10, (long long *)v4);
          v4 += 40;
          v10 += 40;
          v11 -= 40;
        }
        while (v11);
        LODWORD(v6) = *(_DWORD *)(a1 + 8);
        uint64_t v12 = *(char **)a1;
      }
      else
      {
        uint64_t v12 = *(char **)a1;
      }
      for (uint64_t i = &v12[40 * v6]; i != v10; i -= 40)
      {
        if (*(i - 8))
        {
          if (*(i - 17) < 0) {
            operator delete(*((void **)i - 5));
          }
          *(i - ++*(_DWORD *)(this + 8) = 0;
        }
      }
      *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = v5;
      uint64_t v25 = *(unsigned int *)(a2 + 8);
      if (v25)
      {
        int v26 = *(char **)a2;
        uint64_t v27 = 40 * v25;
        do
        {
          char v28 = &v26[v27];
          if (v26[v27 - 8])
          {
            if (*(v28 - 17) < 0) {
              operator delete(*((void **)v28 - 5));
            }
            *(v28 - ++*(_DWORD *)(this + 8) = 0;
          }
          v27 -= 40;
        }
        while (v27);
      }
      goto LABEL_52;
    }
    if (*(_DWORD *)(a1 + 12) >= v5)
    {
      if (v6)
      {
        uint64_t v13 = *(char **)a1;
        uint64_t v14 = 40 * v6;
        do
        {
          sub_1CCC402B4((uint64_t)v13, (long long *)v4);
          v4 += 40;
          v13 += 40;
          v14 -= 40;
        }
        while (v14);
        goto LABEL_23;
      }
    }
    else
    {
      if (v6)
      {
        unint64_t v7 = *(char **)a1;
        uint64_t v8 = 40 * v6;
        do
        {
          unint64_t v9 = &v7[v8];
          if (v7[v8 - 8])
          {
            if (*(v9 - 17) < 0) {
              operator delete(*((void **)v9 - 5));
            }
            *(v9 - ++*(_DWORD *)(this + 8) = 0;
          }
          v8 -= 40;
        }
        while (v8);
      }
      *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = 0;
      sub_1CCC3ECB4(a1, v5);
    }
    uint64_t v6 = 0;
LABEL_23:
    uint64_t v15 = *(char **)a2;
    uint64_t v16 = *(unsigned int *)(a2 + 8);
    if (v6 != v16)
    {
      int64x2_t v17 = &v15[40 * v6];
      char v18 = (unsigned char *)(*(void *)a1 + 40 * v6 + 32);
      uint64_t v19 = 40 * v16 - 40 * v6;
      do
      {
        *(v18 - 32) = 0;
        *char v18 = 0;
        if (v17[32])
        {
          long long v20 = *(_OWORD *)v17;
          *((void *)v18 - 2) = *((void *)v17 + 2);
          *((_OWORD *)v18 - 2) = v20;
          *((void *)v17 + 1) = 0;
          *((void *)v17 + 2) = 0;
          *(void *)int64x2_t v17 = 0;
          *(v18 - ++*(_DWORD *)(this + 8) = v17[24];
          *char v18 = 1;
        }
        v17 += 40;
        v18 += 40;
        v19 -= 40;
      }
      while (v19);
      uint64_t v15 = *(char **)a2;
    }
    *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = v5;
    uint64_t v21 = *(unsigned int *)(a2 + 8);
    if (v21)
    {
      uint64_t v22 = 40 * v21;
      do
      {
        long long v23 = &v15[v22];
        if (v15[v22 - 8])
        {
          if (*(v23 - 17) < 0) {
            operator delete(*((void **)v23 - 5));
          }
          *(v23 - ++*(_DWORD *)(this + 8) = 0;
        }
        v22 -= 40;
      }
      while (v22);
    }
LABEL_52:
    *(_DWORD *)(a2 + ++*(_DWORD *)(this + 8) = 0;
  }
  return a1;
}

double sub_1CCC40214(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 40 * v5;
    do
    {
      unint64_t v7 = (void **)&v4[v6];
      if (v4[v6 - 8])
      {
        if (*((char *)v7 - 17) < 0) {
          operator delete(*(v7 - 5));
        }
        *((unsigned char *)v7 - ++*(_DWORD *)(this + 8) = 0;
      }
      v6 -= 40;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

uint64_t sub_1CCC402B4(uint64_t a1, long long *a2)
{
  if (*((unsigned char *)a2 + 32))
  {
    if (*(unsigned char *)(a1 + 32))
    {
      if (*(char *)(a1 + 23) < 0) {
        operator delete(*(void **)a1);
      }
      long long v4 = *a2;
      *(void *)(a1 + ++*(_DWORD *)(this + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v4;
      *((unsigned char *)a2 + 23) = 0;
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a1 + 24) = *((unsigned char *)a2 + 24);
    }
    else
    {
      long long v5 = *a2;
      *(void *)(a1 + ++*(_DWORD *)(this + 16) = *((void *)a2 + 2);
      *(_OWORD *)a1 = v5;
      *((void *)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
      *(void *)a2 = 0;
      *(unsigned char *)(a1 + 24) = *((unsigned char *)a2 + 24);
      *(unsigned char *)(a1 + 32) = 1;
    }
  }
  else if (*(unsigned char *)(a1 + 32))
  {
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
    *(unsigned char *)(a1 + 32) = 0;
  }
  return a1;
}

char *sub_1CCC40364(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    uint64_t v6 = result;
    if (a3 == 2)
    {
      uint64_t v7 = *((void *)a2 - 1);
      uint64_t v8 = *(void *)result;
      if (*(_DWORD *)(v7 + 8) < *(_DWORD *)(*(void *)result + 8))
      {
        *(void *)double result = v7;
        *((void *)a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v19 = (char *)a4;
      unint64_t v20 = a3 >> 1;
      uint64_t v21 = &result[8 * (a3 >> 1)];
      unint64_t v22 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CCC405B0((uint64_t)result, v21, v22, a4);
        long long v23 = (uint64_t *)&v19[8 * v20];
        double result = (char *)sub_1CCC405B0((uint64_t)&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        long long v24 = &v19[8 * a3];
        uint64_t v25 = v23;
        while (v25 != (uint64_t *)v24)
        {
          int v26 = v25;
          uint64_t v27 = *v25;
          uint64_t v28 = *(void *)v19;
          unsigned int v29 = *(_DWORD *)(v27 + 8);
          unsigned int v30 = *(_DWORD *)(*(void *)v19 + 8);
          if (v29 < v30) {
            uint64_t v28 = v27;
          }
          v19 += 8 * (v29 >= v30);
          uint64_t v25 = &v26[v29 < v30];
          *(void *)uint64_t v6 = v28;
          v6 += 8;
          if (v19 == (char *)v23)
          {
            if (v25 != (uint64_t *)v24)
            {
              uint64_t v31 = 0;
              if (v29 < v30) {
                char v32 = 1;
              }
              else {
                char v32 = 2;
              }
              uint64_t v33 = &v26[v32 & 1];
              do
              {
                *(void *)&v6[v31 * 8] = v33[v31];
                ++v31;
              }
              while (&v33[v31] != (uint64_t *)v24);
            }
            return result;
          }
        }
        if (v19 != (char *)v23)
        {
          uint64_t v34 = 0;
          do
          {
            *(void *)&v6[v34] = *(void *)&v19[v34];
            v34 += 8;
          }
          while (&v19[v34] != (char *)v23);
        }
      }
      else
      {
        sub_1CCC40364(result, v21, v22, a4, a5);
        sub_1CCC40364(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);
        return sub_1CCC407B0(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }
    else if (result != a2)
    {
      unint64_t v10 = result + 8;
      if (result + 8 != a2)
      {
        uint64_t v11 = 8;
        uint64_t v12 = result;
        do
        {
          uint64_t v14 = *(void *)v12;
          uint64_t v13 = *((void *)v12 + 1);
          uint64_t v12 = v10;
          if (*(_DWORD *)(v13 + 8) < *(_DWORD *)(v14 + 8))
          {
            uint64_t v15 = v11;
            while (1)
            {
              *(void *)&result[v15] = v14;
              uint64_t v16 = v15 - 8;
              if (v15 == 8) {
                break;
              }
              uint64_t v14 = *(void *)&result[v15 - 16];
              v15 -= 8;
              if (*(_DWORD *)(v13 + 8) >= *(_DWORD *)(v14 + 8))
              {
                int64x2_t v17 = &result[v16];
                goto LABEL_15;
              }
            }
            int64x2_t v17 = result;
LABEL_15:
            *(void *)int64x2_t v17 = v13;
          }
          unint64_t v10 = v12 + 8;
          v11 += 8;
        }
        while (v12 + 8 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1CCC405B0(uint64_t result, void *a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    long long v4 = a4;
    uint64_t v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      uint64_t *v4 = *(void *)v6;
      return result;
    }
    if (a3 == 2)
    {
      uint64_t v8 = *(a2 - 1);
      unsigned int v9 = *(_DWORD *)(v8 + 8);
      unsigned int v10 = *(_DWORD *)(*(void *)result + 8);
      if (v9 >= v10) {
        uint64_t v8 = *(void *)result;
      }
      *a4 = v8;
      long long v4 = a4 + 1;
      if (v9 >= v10) {
        uint64_t v6 = (uint64_t)(a2 - 1);
      }
      goto LABEL_8;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v20 = result + 8 * (a3 >> 1);
      sub_1CCC40364(result, v20, a3 >> 1, a4, a3 >> 1);
      double result = sub_1CCC40364(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      uint64_t v21 = (void *)(v6 + 8 * (a3 >> 1));
      while (v21 != a2)
      {
        unint64_t v22 = v21;
        uint64_t v23 = *v21;
        uint64_t v24 = *(void *)v6;
        unsigned int v25 = *(_DWORD *)(v23 + 8);
        unsigned int v26 = *(_DWORD *)(*(void *)v6 + 8);
        if (v25 < v26) {
          uint64_t v24 = v23;
        }
        uint64_t v21 = &v22[v25 < v26];
        v6 += 8 * (v25 >= v26);
        *v4++ = v24;
        if (v6 == v20)
        {
          if (v21 != a2)
          {
            uint64_t v27 = 0;
            uint64_t v28 = &v22[v25 < v26];
            do
            {
              v4[v27] = v28[v27];
              ++v27;
            }
            while (&v28[v27] != a2);
          }
          return result;
        }
      }
      if (v6 != v20)
      {
        uint64_t v29 = 0;
        do
        {
          v4[v29] = *(void *)(v6 + v29 * 8);
          ++v29;
        }
        while (v6 + v29 * 8 != v20);
      }
    }
    else if ((void *)result != a2)
    {
      uint64_t v11 = result + 8;
      *a4 = *(void *)result;
      if ((void *)(result + 8) != a2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = a4;
        uint64_t v14 = a4;
        do
        {
          uint64_t v16 = *v14++;
          uint64_t v15 = v16;
          if (*(_DWORD *)(*(void *)v11 + 8) >= *(_DWORD *)(v16 + 8))
          {
            *uint64_t v14 = *(void *)v11;
          }
          else
          {
            v13[1] = v15;
            int64x2_t v17 = a4;
            if (v13 != a4)
            {
              uint64_t v18 = v12;
              while (1)
              {
                int64x2_t v17 = (uint64_t *)((char *)a4 + v18);
                uint64_t v19 = *(uint64_t *)((char *)a4 + v18 - 8);
                if (*(_DWORD *)(*(void *)v11 + 8) >= *(_DWORD *)(v19 + 8)) {
                  break;
                }
                *int64x2_t v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  int64x2_t v17 = a4;
                  break;
                }
              }
            }
            *int64x2_t v17 = *(void *)v11;
          }
          v11 += 8;
          v12 += 8;
          uint64_t v13 = v14;
        }
        while ((void *)v11 != a2);
      }
    }
  }
  return result;
}

char *sub_1CCC407B0(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    uint64_t v11 = result;
    while (a4 > a7 && v8 > a7)
    {
      if (!a4) {
        return result;
      }
      while (1)
      {
        uint64_t v12 = *(void *)v11;
        if (*(_DWORD *)(*(void *)a2 + 8) < *(_DWORD *)(*(void *)v11 + 8)) {
          break;
        }
        v11 += 8;
        if (!--a4) {
          return result;
        }
      }
      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *(void *)uint64_t v11 = *(void *)a2;
          *(void *)a2 = v12;
          return result;
        }
        if (a4 >= 0) {
          uint64_t v23 = a4;
        }
        else {
          uint64_t v23 = a4 + 1;
        }
        uint64_t v22 = v23 >> 1;
        uint64_t v16 = &v11[8 * (v23 >> 1)];
        uint64_t v15 = a3;
        if (a3 != a2)
        {
          unint64_t v24 = (a3 - a2) >> 3;
          uint64_t v15 = a2;
          do
          {
            unint64_t v25 = v24 >> 1;
            unsigned int v26 = &v15[8 * (v24 >> 1)];
            uint64_t v28 = *(void *)v26;
            uint64_t v27 = v26 + 8;
            v24 += ~(v24 >> 1);
            if (*(_DWORD *)(v28 + 8) < *(_DWORD *)(*(void *)v16 + 8)) {
              uint64_t v15 = v27;
            }
            else {
              unint64_t v24 = v25;
            }
          }
          while (v24);
        }
        uint64_t v14 = (v15 - a2) >> 3;
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v13 = v8;
        }
        else {
          uint64_t v13 = v8 + 1;
        }
        uint64_t v14 = v13 >> 1;
        uint64_t v15 = &a2[8 * (v13 >> 1)];
        uint64_t v16 = a2;
        if (v11 != a2)
        {
          unint64_t v17 = (a2 - v11) >> 3;
          uint64_t v16 = v11;
          do
          {
            unint64_t v18 = v17 >> 1;
            uint64_t v19 = &v16[8 * (v17 >> 1)];
            uint64_t v21 = *(void *)v19;
            unint64_t v20 = v19 + 8;
            v17 += ~(v17 >> 1);
            if (*(_DWORD *)(*(void *)v15 + 8) < *(_DWORD *)(v21 + 8)) {
              unint64_t v17 = v18;
            }
            else {
              uint64_t v16 = v20;
            }
          }
          while (v17);
        }
        uint64_t v22 = (v16 - v11) >> 3;
      }
      uint64_t v29 = v15;
      if (v16 != a2)
      {
        uint64_t v29 = v16;
        if (a2 != v15)
        {
          if (v16 + 8 == a2)
          {
            uint64_t v69 = *(void *)v16;
            uint64_t v71 = a3;
            uint64_t v36 = v15 - a2;
            unint64_t v73 = a6;
            memmove(v16, a2, v15 - a2);
            a3 = v71;
            a6 = v73;
            uint64_t v29 = &v16[v36];
            *(void *)uint64_t v29 = v69;
          }
          else if (a2 + 8 == v15)
          {
            uint64_t v37 = *((void *)v15 - 1);
            uint64_t v29 = v16 + 8;
            if (v15 - 8 != v16)
            {
              uint64_t v72 = a3;
              char v74 = a6;
              uint64_t v70 = *((void *)v15 - 1);
              memmove(v16 + 8, v16, v15 - 8 - v16);
              uint64_t v37 = v70;
              a3 = v72;
              a6 = v74;
            }
            *(void *)uint64_t v16 = v37;
          }
          else
          {
            uint64_t v30 = (a2 - v16) >> 3;
            if (v30 == (v15 - a2) >> 3)
            {
              uint64_t v31 = 0;
              do
              {
                uint64_t v32 = *(void *)&v16[v31];
                *(void *)&v16[v31] = *(void *)&a2[v31];
                uint64_t v33 = (uint64_t)&v16[v31 + 8];
                *(void *)&a2[v31] = v32;
                uint64_t v34 = (uint64_t)&a2[v31 + 8];
                v31 += 8;
              }
              while ((char *)v33 != a2 && v34 != (void)v15);
              uint64_t v29 = a2;
            }
            else
            {
              uint64_t v38 = (v15 - a2) >> 3;
              uint64_t v39 = (a2 - v16) >> 3;
              do
              {
                uint64_t v40 = v39;
                uint64_t v39 = v38;
                uint64_t v38 = v40 % v38;
              }
              while (v38);
              if (v39)
              {
                uint64_t v41 = &v16[8 * v39];
                do
                {
                  uint64_t v43 = *((void *)v41 - 1);
                  v41 -= 8;
                  uint64_t v42 = v43;
                  long long v44 = &v41[8 * v30];
                  uint64_t v45 = v41;
                  do
                  {
                    uint64_t v46 = v45;
                    uint64_t v45 = v44;
                    *(void *)uint64_t v46 = *(void *)v44;
                    BOOL v47 = __OFSUB__(v30, (v15 - v44) >> 3);
                    uint64_t v49 = v30 - ((v15 - v44) >> 3);
                    char v48 = (v49 < 0) ^ v47;
                    long long v44 = &v16[8 * v49];
                    if (v48) {
                      long long v44 = &v45[8 * v30];
                    }
                  }
                  while (v44 != v41);
                  *(void *)uint64_t v45 = v42;
                }
                while (v41 != v16);
              }
              uint64_t v29 = &v16[8 * ((v15 - a2) >> 3)];
            }
          }
        }
      }
      a4 -= v22;
      v8 -= v14;
      if (v22 + v14 >= a4 + v8)
      {
        uint64_t v54 = v8;
        uint64_t v55 = a6;
        double result = (char *)sub_1CCC407B0(v29, v15, a3, a4, v54, a6, a7);
        a6 = v55;
        uint64_t v15 = v16;
        uint64_t v8 = v14;
        a4 = v22;
        a3 = v29;
      }
      else
      {
        std::string::size_type v50 = v11;
        __int16 v51 = v16;
        std::string::size_type v52 = a6;
        unint64_t v53 = a3;
        double result = (char *)sub_1CCC407B0(v50, v51, v29, v22, v14, a6, a7);
        a3 = v53;
        a6 = v52;
        uint64_t v11 = v29;
      }
      a2 = v15;
      if (!v8) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (v11 != a2)
      {
        uint64_t v60 = 0;
        do
        {
          *(void *)&a6[v60] = *(void *)&v11[v60];
          v60 += 8;
        }
        while (&v11[v60] != a2);
        if (v60)
        {
          uint64_t v61 = a6;
          while (a2 != a3)
          {
            uint64_t v62 = *(void *)a2;
            unsigned int v63 = *(_DWORD *)(*(void *)a2 + 8);
            unsigned int v64 = *(_DWORD *)(*(void *)v61 + 8);
            BOOL v65 = v63 >= v64;
            BOOL v66 = v63 < v64;
            unsigned int v67 = v65;
            if (v65) {
              uint64_t v62 = *(void *)v61;
            }
            v61 += 8 * v67;
            a2 += 8 * v66;
            *(void *)uint64_t v11 = v62;
            v11 += 8;
            if (&a6[v60] == v61) {
              return result;
            }
          }
          return (char *)memmove(v11, v61, a6 - v61 + v60);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v56 = 0;
      do
      {
        *(void *)&a6[v56] = *(void *)&a2[v56];
        v56 += 8;
      }
      while (&a2[v56] != a3);
      if (v56)
      {
        __int16 v57 = &a6[v56];
        std::string::size_type v58 = a3 - 8;
        while (a2 != v11)
        {
          uint64_t v59 = *((void *)v57 - 1);
          if (*(_DWORD *)(v59 + 8) >= *(_DWORD *)(*((void *)a2 - 1) + 8))
          {
            v57 -= 8;
          }
          else
          {
            uint64_t v59 = *((void *)a2 - 1);
            a2 -= 8;
          }
          *(void *)std::string::size_type v58 = v59;
          v58 -= 8;
          if (v57 == a6) {
            return result;
          }
        }
        if (v57 != a6)
        {
          uint64_t v68 = 0;
          do
          {
            *(void *)&v58[v68] = *(void *)&v57[v68 - 8];
            v68 -= 8;
          }
          while (&v57[v68] != a6);
        }
      }
    }
  }
  return result;
}

void *sub_1CCC40C58(void *a1, uint64_t a2, uint64_t a3, void **a4)
{
  *a1 = 0;
  a1[1] = a3;
  a1[2] = a4;
  uint64_t v7 = *a4;
  *a4 = 0;
  sub_1CD4515D0(&v7);
  if (v7) {
    (*(void (**)(void *))(*v7 + 8))(v7);
  }
  sub_1CCC40CE0((uint64_t)a1, a2, 0);
  return a1;
}

uint64_t sub_1CCC40CE0(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(result + 8) - a3;
  *(void *)(result + ++*(_DWORD *)(this + 8) = v3;
  if (v3)
  {
    if (v3 <= 0xB
      || (*(void *)double result = a2 + a3,
          ((*(unsigned int *)(a2 + a3) + 3) & 0x1FFFFFFFCLL)
        + ((*(unsigned int *)(a2 + a3 + 4) + 3) & 0x1FFFFFFFCuLL)
        + 12 > v3))
    {
      *(void *)double result = 0;
      operator new();
    }
    **(void **)(result + ++*(_DWORD *)(this + 16) = 0;
  }
  else
  {
    **(void **)(result + ++*(_DWORD *)(this + 16) = 0;
    *(void *)double result = 0;
  }
  return result;
}

void *sub_1CCC40DEC(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x1555555555555556) {
      abort();
    }
    uint64_t v6 = result;
    uint64_t v7 = 3 * a4;
    double result = operator new(12 * a4);
    uint64_t v8 = result;
    *uint64_t v6 = result;
    v6[1] = result;
    void v6[2] = (char *)result + 4 * v7;
    size_t v9 = a3 - (void)a2;
    if (v9) {
      double result = memcpy(result, a2, v9);
    }
    v6[1] = (char *)v8 + v9;
  }
  return result;
}

char *sub_1CCC40E7C(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    uint64_t v6 = result;
    if (a3 == 2)
    {
      uint64_t v7 = *((void *)a2 - 1);
      uint64_t v8 = *(void *)result;
      if (bswap32(*(_DWORD *)(v7 + 8)) < bswap32(*(_DWORD *)(*(void *)result + 8)))
      {
        *(void *)double result = v7;
        *((void *)a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      unint64_t v18 = (char *)a4;
      unint64_t v19 = a3 >> 1;
      unint64_t v20 = &result[8 * (a3 >> 1)];
      unint64_t v21 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CCC410E8((uint64_t)result, v20, v21, a4);
        uint64_t v22 = (uint64_t *)&v18[8 * v19];
        double result = (char *)sub_1CCC410E8((uint64_t)&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v22);
        uint64_t v23 = &v18[8 * a3];
        unint64_t v24 = v22;
        while (v24 != (uint64_t *)v23)
        {
          unint64_t v25 = v24;
          uint64_t v26 = *v24;
          uint64_t v27 = *(void *)v18;
          unsigned int v28 = bswap32(*(_DWORD *)(v26 + 8));
          unsigned int v29 = bswap32(*(_DWORD *)(*(void *)v18 + 8));
          if (v28 < v29) {
            uint64_t v27 = v26;
          }
          v18 += 8 * (v28 >= v29);
          unint64_t v24 = &v25[v28 < v29];
          *(void *)uint64_t v6 = v27;
          v6 += 8;
          if (v18 == (char *)v22)
          {
            if (v24 != (uint64_t *)v23)
            {
              uint64_t v30 = 0;
              if (v28 < v29) {
                char v31 = 1;
              }
              else {
                char v31 = 2;
              }
              uint64_t v32 = &v25[v31 & 1];
              do
              {
                *(void *)&v6[v30 * 8] = v32[v30];
                ++v30;
              }
              while (&v32[v30] != (uint64_t *)v23);
            }
            return result;
          }
        }
        if (v18 != (char *)v22)
        {
          uint64_t v33 = 0;
          do
          {
            *(void *)&v6[v33] = *(void *)&v18[v33];
            v33 += 8;
          }
          while (&v18[v33] != (char *)v22);
        }
      }
      else
      {
        sub_1CCC40E7C(result, v20, v21, a4, a5);
        sub_1CCC40E7C(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v18, a5);
        return sub_1CCC41308(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v18, a5);
      }
    }
    else if (result != a2)
    {
      unsigned int v10 = result + 8;
      if (result + 8 != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = result;
        do
        {
          uint64_t v14 = *(void *)v12;
          uint64_t v13 = *((void *)v12 + 1);
          uint64_t v12 = v10;
          if (bswap32(*(_DWORD *)(v13 + 8)) < bswap32(*(_DWORD *)(v14 + 8)))
          {
            uint64_t v15 = v11;
            while (1)
            {
              *(void *)&result[v15 + 8] = v14;
              if (!v15) {
                break;
              }
              uint64_t v14 = *(void *)&result[v15 - 8];
              v15 -= 8;
              if (bswap32(*(_DWORD *)(v13 + 8)) >= bswap32(*(_DWORD *)(v14 + 8)))
              {
                uint64_t v16 = &result[v15 + 8];
                goto LABEL_15;
              }
            }
            uint64_t v16 = result;
LABEL_15:
            *(void *)uint64_t v16 = v13;
          }
          unsigned int v10 = v12 + 8;
          v11 += 8;
        }
        while (v12 + 8 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1CCC410E8(uint64_t result, void *a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    long long v4 = a4;
    uint64_t v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      uint64_t *v4 = *(void *)v6;
      return result;
    }
    if (a3 == 2)
    {
      uint64_t v8 = *(a2 - 1);
      unsigned int v9 = bswap32(*(_DWORD *)(v8 + 8));
      unsigned int v10 = bswap32(*(_DWORD *)(*(void *)result + 8));
      if (v9 >= v10) {
        uint64_t v8 = *(void *)result;
      }
      *a4 = v8;
      long long v4 = a4 + 1;
      if (v9 >= v10) {
        uint64_t v6 = (uint64_t)(a2 - 1);
      }
      goto LABEL_8;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v20 = result + 8 * (a3 >> 1);
      sub_1CCC40E7C(result, v20, a3 >> 1, a4, a3 >> 1);
      double result = sub_1CCC40E7C(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      unint64_t v21 = (void *)(v6 + 8 * (a3 >> 1));
      while (v21 != a2)
      {
        uint64_t v22 = v21;
        uint64_t v23 = *v21;
        uint64_t v24 = *(void *)v6;
        unsigned int v25 = bswap32(*(_DWORD *)(v23 + 8));
        unsigned int v26 = bswap32(*(_DWORD *)(*(void *)v6 + 8));
        if (v25 < v26) {
          uint64_t v24 = v23;
        }
        unint64_t v21 = &v22[v25 < v26];
        v6 += 8 * (v25 >= v26);
        *v4++ = v24;
        if (v6 == v20)
        {
          if (v21 != a2)
          {
            uint64_t v27 = 0;
            unsigned int v28 = &v22[v25 < v26];
            do
            {
              v4[v27] = v28[v27];
              ++v27;
            }
            while (&v28[v27] != a2);
          }
          return result;
        }
      }
      if (v6 != v20)
      {
        uint64_t v29 = 0;
        do
        {
          v4[v29] = *(void *)(v6 + v29 * 8);
          ++v29;
        }
        while (v6 + v29 * 8 != v20);
      }
    }
    else if ((void *)result != a2)
    {
      uint64_t v11 = result + 8;
      *a4 = *(void *)result;
      if ((void *)(result + 8) != a2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = a4;
        uint64_t v14 = a4;
        do
        {
          uint64_t v16 = *v14++;
          uint64_t v15 = v16;
          if (bswap32(*(_DWORD *)(*(void *)v11 + 8)) >= bswap32(*(_DWORD *)(v16 + 8)))
          {
            *uint64_t v14 = *(void *)v11;
          }
          else
          {
            v13[1] = v15;
            unint64_t v17 = a4;
            if (v13 != a4)
            {
              uint64_t v18 = v12;
              while (1)
              {
                unint64_t v17 = (uint64_t *)((char *)a4 + v18);
                uint64_t v19 = *(uint64_t *)((char *)a4 + v18 - 8);
                if (bswap32(*(_DWORD *)(*(void *)v11 + 8)) >= bswap32(*(_DWORD *)(v19 + 8))) {
                  break;
                }
                *unint64_t v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  unint64_t v17 = a4;
                  break;
                }
              }
            }
            *unint64_t v17 = *(void *)v11;
          }
          v11 += 8;
          v12 += 8;
          uint64_t v13 = v14;
        }
        while ((void *)v11 != a2);
      }
    }
  }
  return result;
}

char *sub_1CCC41308(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    uint64_t v11 = result;
    while (a4 > a7 && v8 > a7)
    {
      if (!a4) {
        return result;
      }
      unsigned int v12 = bswap32(*(_DWORD *)(*(void *)a2 + 8));
      while (1)
      {
        uint64_t v13 = *(void *)v11;
        if (v12 < bswap32(*(_DWORD *)(*(void *)v11 + 8))) {
          break;
        }
        v11 += 8;
        if (!--a4) {
          return result;
        }
      }
      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *(void *)uint64_t v11 = *(void *)a2;
          *(void *)a2 = v13;
          return result;
        }
        if (a4 >= 0) {
          uint64_t v25 = a4;
        }
        else {
          uint64_t v25 = a4 + 1;
        }
        uint64_t v24 = v25 >> 1;
        unint64_t v17 = &v11[8 * (v25 >> 1)];
        uint64_t v16 = a3;
        if (a3 != a2)
        {
          unint64_t v26 = (a3 - a2) >> 3;
          unsigned int v27 = bswap32(*(_DWORD *)(*(void *)v17 + 8));
          uint64_t v16 = a2;
          do
          {
            unint64_t v28 = v26 >> 1;
            uint64_t v29 = &v16[8 * (v26 >> 1)];
            uint64_t v31 = *(void *)v29;
            uint64_t v30 = v29 + 8;
            v26 += ~(v26 >> 1);
            if (bswap32(*(_DWORD *)(v31 + 8)) < v27) {
              uint64_t v16 = v30;
            }
            else {
              unint64_t v26 = v28;
            }
          }
          while (v26);
        }
        uint64_t v15 = (v16 - a2) >> 3;
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v14 = v8;
        }
        else {
          uint64_t v14 = v8 + 1;
        }
        uint64_t v15 = v14 >> 1;
        uint64_t v16 = &a2[8 * (v14 >> 1)];
        unint64_t v17 = a2;
        if (v11 != a2)
        {
          unint64_t v18 = (a2 - v11) >> 3;
          unsigned int v19 = bswap32(*(_DWORD *)(*(void *)v16 + 8));
          unint64_t v17 = v11;
          do
          {
            unint64_t v20 = v18 >> 1;
            unint64_t v21 = &v17[8 * (v18 >> 1)];
            uint64_t v23 = *(void *)v21;
            uint64_t v22 = v21 + 8;
            v18 += ~(v18 >> 1);
            if (v19 < bswap32(*(_DWORD *)(v23 + 8))) {
              unint64_t v18 = v20;
            }
            else {
              unint64_t v17 = v22;
            }
          }
          while (v18);
        }
        uint64_t v24 = (v17 - v11) >> 3;
      }
      uint64_t v32 = v16;
      if (v17 != a2)
      {
        uint64_t v32 = v17;
        if (a2 != v16)
        {
          if (v17 + 8 == a2)
          {
            uint64_t v72 = *(void *)v17;
            char v74 = a3;
            uint64_t v39 = v16 - a2;
            uint64_t v76 = a6;
            memmove(v17, a2, v16 - a2);
            a3 = v74;
            a6 = v76;
            uint64_t v32 = &v17[v39];
            *(void *)uint64_t v32 = v72;
          }
          else if (a2 + 8 == v16)
          {
            uint64_t v40 = *((void *)v16 - 1);
            uint64_t v32 = v17 + 8;
            if (v16 - 8 != v17)
            {
              uint64_t v75 = a3;
              unsigned int v77 = a6;
              uint64_t v73 = *((void *)v16 - 1);
              memmove(v17 + 8, v17, v16 - 8 - v17);
              uint64_t v40 = v73;
              a3 = v75;
              a6 = v77;
            }
            *(void *)unint64_t v17 = v40;
          }
          else
          {
            uint64_t v33 = (a2 - v17) >> 3;
            if (v33 == (v16 - a2) >> 3)
            {
              uint64_t v34 = 0;
              do
              {
                uint64_t v35 = *(void *)&v17[v34];
                *(void *)&v17[v34] = *(void *)&a2[v34];
                uint64_t v36 = (uint64_t)&v17[v34 + 8];
                *(void *)&a2[v34] = v35;
                uint64_t v37 = (uint64_t)&a2[v34 + 8];
                v34 += 8;
              }
              while ((char *)v36 != a2 && v37 != (void)v16);
              uint64_t v32 = a2;
            }
            else
            {
              uint64_t v41 = (v16 - a2) >> 3;
              uint64_t v42 = (a2 - v17) >> 3;
              do
              {
                uint64_t v43 = v42;
                uint64_t v42 = v41;
                uint64_t v41 = v43 % v41;
              }
              while (v41);
              if (v42)
              {
                long long v44 = &v17[8 * v42];
                do
                {
                  uint64_t v46 = *((void *)v44 - 1);
                  v44 -= 8;
                  uint64_t v45 = v46;
                  BOOL v47 = &v44[8 * v33];
                  char v48 = v44;
                  do
                  {
                    uint64_t v49 = v48;
                    char v48 = v47;
                    *(void *)uint64_t v49 = *(void *)v47;
                    BOOL v50 = __OFSUB__(v33, (v16 - v47) >> 3);
                    uint64_t v52 = v33 - ((v16 - v47) >> 3);
                    char v51 = (v52 < 0) ^ v50;
                    BOOL v47 = &v17[8 * v52];
                    if (v51) {
                      BOOL v47 = &v48[8 * v33];
                    }
                  }
                  while (v47 != v44);
                  *(void *)char v48 = v45;
                }
                while (v44 != v17);
              }
              uint64_t v32 = &v17[8 * ((v16 - a2) >> 3)];
            }
          }
        }
      }
      a4 -= v24;
      v8 -= v15;
      if (v24 + v15 >= a4 + v8)
      {
        uint64_t v57 = v8;
        std::string::size_type v58 = a6;
        double result = (char *)sub_1CCC41308(v32, v16, a3, a4, v57, a6, a7);
        a6 = v58;
        uint64_t v16 = v17;
        uint64_t v8 = v15;
        a4 = v24;
        a3 = v32;
      }
      else
      {
        unint64_t v53 = v11;
        uint64_t v54 = v17;
        uint64_t v55 = a6;
        uint64_t v56 = a3;
        double result = (char *)sub_1CCC41308(v53, v54, v32, v24, v15, a6, a7);
        a3 = v56;
        a6 = v55;
        uint64_t v11 = v32;
      }
      a2 = v16;
      if (!v8) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (v11 != a2)
      {
        uint64_t v63 = 0;
        do
        {
          *(void *)&a6[v63] = *(void *)&v11[v63];
          v63 += 8;
        }
        while (&v11[v63] != a2);
        if (v63)
        {
          unsigned int v64 = a6;
          while (a2 != a3)
          {
            uint64_t v65 = *(void *)a2;
            unsigned int v66 = bswap32(*(_DWORD *)(*(void *)a2 + 8));
            unsigned int v67 = bswap32(*(_DWORD *)(*(void *)v64 + 8));
            BOOL v68 = v66 >= v67;
            BOOL v69 = v66 < v67;
            unsigned int v70 = v68;
            if (v68) {
              uint64_t v65 = *(void *)v64;
            }
            v64 += 8 * v70;
            a2 += 8 * v69;
            *(void *)uint64_t v11 = v65;
            v11 += 8;
            if (&a6[v63] == v64) {
              return result;
            }
          }
          return (char *)memmove(v11, v64, a6 - v64 + v63);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v59 = 0;
      do
      {
        *(void *)&a6[v59] = *(void *)&a2[v59];
        v59 += 8;
      }
      while (&a2[v59] != a3);
      if (v59)
      {
        uint64_t v60 = &a6[v59];
        uint64_t v61 = a3 - 8;
        while (a2 != v11)
        {
          uint64_t v62 = *((void *)v60 - 1);
          if (bswap32(*(_DWORD *)(v62 + 8)) >= bswap32(*(_DWORD *)(*((void *)a2 - 1) + 8)))
          {
            v60 -= 8;
          }
          else
          {
            uint64_t v62 = *((void *)a2 - 1);
            a2 -= 8;
          }
          *(void *)uint64_t v61 = v62;
          v61 -= 8;
          if (v60 == a6) {
            return result;
          }
        }
        if (v60 != a6)
        {
          uint64_t v71 = 0;
          do
          {
            *(void *)&v61[v71] = *(void *)&v60[v71 - 8];
            v71 -= 8;
          }
          while (&v60[v71] != a6);
        }
      }
    }
  }
  return result;
}

void *sub_1CCC417D8(void *a1, uint64_t a2, uint64_t a3, void **a4)
{
  *a1 = 0;
  a1[1] = a3;
  a1[2] = a4;
  uint64_t v7 = *a4;
  *a4 = 0;
  sub_1CD4515D0(&v7);
  if (v7) {
    (*(void (**)(void *))(*v7 + 8))(v7);
  }
  sub_1CCC41860((uint64_t)a1, a2, 0);
  return a1;
}

uint64_t sub_1CCC41860(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(result + 8) - a3;
  *(void *)(result + ++*(_DWORD *)(this + 8) = v3;
  if (v3)
  {
    if (v3 <= 0xB
      || (*(void *)double result = a2 + a3,
          vaddvq_s64((int64x2_t)vandq_s8((int8x16_t)vaddw_u32((uint64x2_t)vdupq_n_s64(3uLL), (uint32x2_t)vrev32_s8(*(int8x8_t *)(a2 + a3))), (int8x16_t)vdupq_n_s64(0x1FFFFFFFCuLL)))+ 12 > v3))
    {
      *(void *)double result = 0;
      operator new();
    }
    **(void **)(result + ++*(_DWORD *)(this + 16) = 0;
  }
  else
  {
    **(void **)(result + ++*(_DWORD *)(this + 16) = 0;
    *(void *)double result = 0;
  }
  return result;
}

char *sub_1CCC4197C(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    uint64_t v6 = result;
    if (a3 == 2)
    {
      uint64_t v7 = *((void *)a2 - 1);
      uint64_t v8 = *(void *)result;
      if (*(void *)(v7 + 16) < *(void *)(*(void *)result + 16))
      {
        *(void *)double result = v7;
        *((void *)a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      unsigned int v19 = (char *)a4;
      unint64_t v20 = a3 >> 1;
      unint64_t v21 = &result[8 * (a3 >> 1)];
      unint64_t v22 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CCC41BC8((uint64_t)result, v21, v22, a4);
        uint64_t v23 = (uint64_t *)&v19[8 * v20];
        double result = (char *)sub_1CCC41BC8((uint64_t)&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v23);
        uint64_t v24 = &v19[8 * a3];
        uint64_t v25 = v23;
        while (v25 != (uint64_t *)v24)
        {
          unint64_t v26 = v25;
          uint64_t v27 = *v25;
          uint64_t v28 = *(void *)v19;
          unint64_t v29 = *(void *)(v27 + 16);
          unint64_t v30 = *(void *)(*(void *)v19 + 16);
          if (v29 < v30) {
            uint64_t v28 = v27;
          }
          v19 += 8 * (v29 >= v30);
          uint64_t v25 = &v26[v29 < v30];
          *(void *)uint64_t v6 = v28;
          v6 += 8;
          if (v19 == (char *)v23)
          {
            if (v25 != (uint64_t *)v24)
            {
              uint64_t v31 = 0;
              if (v29 < v30) {
                char v32 = 1;
              }
              else {
                char v32 = 2;
              }
              uint64_t v33 = &v26[v32 & 1];
              do
              {
                *(void *)&v6[v31 * 8] = v33[v31];
                ++v31;
              }
              while (&v33[v31] != (uint64_t *)v24);
            }
            return result;
          }
        }
        if (v19 != (char *)v23)
        {
          uint64_t v34 = 0;
          do
          {
            *(void *)&v6[v34] = *(void *)&v19[v34];
            v34 += 8;
          }
          while (&v19[v34] != (char *)v23);
        }
      }
      else
      {
        sub_1CCC4197C(result, v21, v22, a4, a5);
        sub_1CCC4197C(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v19, a5);
        return sub_1CCC41DC8(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v19, a5);
      }
    }
    else if (result != a2)
    {
      unsigned int v10 = result + 8;
      if (result + 8 != a2)
      {
        uint64_t v11 = 8;
        unsigned int v12 = result;
        do
        {
          uint64_t v14 = *(void *)v12;
          uint64_t v13 = *((void *)v12 + 1);
          unsigned int v12 = v10;
          if (*(void *)(v13 + 16) < *(void *)(v14 + 16))
          {
            uint64_t v15 = v11;
            while (1)
            {
              *(void *)&result[v15] = v14;
              uint64_t v16 = v15 - 8;
              if (v15 == 8) {
                break;
              }
              uint64_t v14 = *(void *)&result[v15 - 16];
              v15 -= 8;
              if (*(void *)(v13 + 16) >= *(void *)(v14 + 16))
              {
                unint64_t v17 = &result[v16];
                goto LABEL_15;
              }
            }
            unint64_t v17 = result;
LABEL_15:
            *(void *)unint64_t v17 = v13;
          }
          unsigned int v10 = v12 + 8;
          v11 += 8;
        }
        while (v12 + 8 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1CCC41BC8(uint64_t result, void *a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    long long v4 = a4;
    uint64_t v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      uint64_t *v4 = *(void *)v6;
      return result;
    }
    if (a3 == 2)
    {
      uint64_t v8 = *(a2 - 1);
      unint64_t v9 = *(void *)(v8 + 16);
      unint64_t v10 = *(void *)(*(void *)result + 16);
      if (v9 >= v10) {
        uint64_t v8 = *(void *)result;
      }
      *a4 = v8;
      long long v4 = a4 + 1;
      if (v9 >= v10) {
        uint64_t v6 = (uint64_t)(a2 - 1);
      }
      goto LABEL_8;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v20 = result + 8 * (a3 >> 1);
      sub_1CCC4197C(result, v20, a3 >> 1, a4, a3 >> 1);
      double result = sub_1CCC4197C(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      unint64_t v21 = (void *)(v6 + 8 * (a3 >> 1));
      while (v21 != a2)
      {
        unint64_t v22 = v21;
        uint64_t v23 = *v21;
        uint64_t v24 = *(void *)v6;
        unint64_t v25 = *(void *)(v23 + 16);
        unint64_t v26 = *(void *)(*(void *)v6 + 16);
        if (v25 < v26) {
          uint64_t v24 = v23;
        }
        unint64_t v21 = &v22[v25 < v26];
        v6 += 8 * (v25 >= v26);
        *v4++ = v24;
        if (v6 == v20)
        {
          if (v21 != a2)
          {
            uint64_t v27 = 0;
            uint64_t v28 = &v22[v25 < v26];
            do
            {
              v4[v27] = v28[v27];
              ++v27;
            }
            while (&v28[v27] != a2);
          }
          return result;
        }
      }
      if (v6 != v20)
      {
        uint64_t v29 = 0;
        do
        {
          v4[v29] = *(void *)(v6 + v29 * 8);
          ++v29;
        }
        while (v6 + v29 * 8 != v20);
      }
    }
    else if ((void *)result != a2)
    {
      uint64_t v11 = result + 8;
      *a4 = *(void *)result;
      if ((void *)(result + 8) != a2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = a4;
        uint64_t v14 = a4;
        do
        {
          uint64_t v16 = *v14++;
          uint64_t v15 = v16;
          if (*(void *)(*(void *)v11 + 16) >= *(void *)(v16 + 16))
          {
            *uint64_t v14 = *(void *)v11;
          }
          else
          {
            v13[1] = v15;
            unint64_t v17 = a4;
            if (v13 != a4)
            {
              uint64_t v18 = v12;
              while (1)
              {
                unint64_t v17 = (uint64_t *)((char *)a4 + v18);
                uint64_t v19 = *(uint64_t *)((char *)a4 + v18 - 8);
                if (*(void *)(*(void *)v11 + 16) >= *(void *)(v19 + 16)) {
                  break;
                }
                *unint64_t v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  unint64_t v17 = a4;
                  break;
                }
              }
            }
            *unint64_t v17 = *(void *)v11;
          }
          v11 += 8;
          v12 += 8;
          uint64_t v13 = v14;
        }
        while ((void *)v11 != a2);
      }
    }
  }
  return result;
}

char *sub_1CCC41DC8(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    uint64_t v11 = result;
    while (a4 > a7 && v8 > a7)
    {
      if (!a4) {
        return result;
      }
      while (1)
      {
        uint64_t v12 = *(void *)v11;
        if (*(void *)(*(void *)a2 + 16) < *(void *)(*(void *)v11 + 16)) {
          break;
        }
        v11 += 8;
        if (!--a4) {
          return result;
        }
      }
      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *(void *)uint64_t v11 = *(void *)a2;
          *(void *)a2 = v12;
          return result;
        }
        if (a4 >= 0) {
          uint64_t v23 = a4;
        }
        else {
          uint64_t v23 = a4 + 1;
        }
        uint64_t v22 = v23 >> 1;
        uint64_t v16 = &v11[8 * (v23 >> 1)];
        uint64_t v15 = a3;
        if (a3 != a2)
        {
          unint64_t v24 = (a3 - a2) >> 3;
          uint64_t v15 = a2;
          do
          {
            unint64_t v25 = v24 >> 1;
            unint64_t v26 = &v15[8 * (v24 >> 1)];
            uint64_t v28 = *(void *)v26;
            uint64_t v27 = v26 + 8;
            v24 += ~(v24 >> 1);
            if (*(void *)(v28 + 16) < *(void *)(*(void *)v16 + 16)) {
              uint64_t v15 = v27;
            }
            else {
              unint64_t v24 = v25;
            }
          }
          while (v24);
        }
        uint64_t v14 = (v15 - a2) >> 3;
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v13 = v8;
        }
        else {
          uint64_t v13 = v8 + 1;
        }
        uint64_t v14 = v13 >> 1;
        uint64_t v15 = &a2[8 * (v13 >> 1)];
        uint64_t v16 = a2;
        if (v11 != a2)
        {
          unint64_t v17 = (a2 - v11) >> 3;
          uint64_t v16 = v11;
          do
          {
            unint64_t v18 = v17 >> 1;
            uint64_t v19 = &v16[8 * (v17 >> 1)];
            uint64_t v21 = *(void *)v19;
            unint64_t v20 = v19 + 8;
            v17 += ~(v17 >> 1);
            if (*(void *)(*(void *)v15 + 16) < *(void *)(v21 + 16)) {
              unint64_t v17 = v18;
            }
            else {
              uint64_t v16 = v20;
            }
          }
          while (v17);
        }
        uint64_t v22 = (v16 - v11) >> 3;
      }
      uint64_t v29 = v15;
      if (v16 != a2)
      {
        uint64_t v29 = v16;
        if (a2 != v15)
        {
          if (v16 + 8 == a2)
          {
            uint64_t v69 = *(void *)v16;
            uint64_t v71 = a3;
            uint64_t v36 = v15 - a2;
            uint64_t v73 = a6;
            memmove(v16, a2, v15 - a2);
            a3 = v71;
            a6 = v73;
            uint64_t v29 = &v16[v36];
            *(void *)uint64_t v29 = v69;
          }
          else if (a2 + 8 == v15)
          {
            uint64_t v37 = *((void *)v15 - 1);
            uint64_t v29 = v16 + 8;
            if (v15 - 8 != v16)
            {
              uint64_t v72 = a3;
              char v74 = a6;
              uint64_t v70 = *((void *)v15 - 1);
              memmove(v16 + 8, v16, v15 - 8 - v16);
              uint64_t v37 = v70;
              a3 = v72;
              a6 = v74;
            }
            *(void *)uint64_t v16 = v37;
          }
          else
          {
            uint64_t v30 = (a2 - v16) >> 3;
            if (v30 == (v15 - a2) >> 3)
            {
              uint64_t v31 = 0;
              do
              {
                uint64_t v32 = *(void *)&v16[v31];
                *(void *)&v16[v31] = *(void *)&a2[v31];
                uint64_t v33 = (uint64_t)&v16[v31 + 8];
                *(void *)&a2[v31] = v32;
                uint64_t v34 = (uint64_t)&a2[v31 + 8];
                v31 += 8;
              }
              while ((char *)v33 != a2 && v34 != (void)v15);
              uint64_t v29 = a2;
            }
            else
            {
              uint64_t v38 = (v15 - a2) >> 3;
              uint64_t v39 = (a2 - v16) >> 3;
              do
              {
                uint64_t v40 = v39;
                uint64_t v39 = v38;
                uint64_t v38 = v40 % v38;
              }
              while (v38);
              if (v39)
              {
                uint64_t v41 = &v16[8 * v39];
                do
                {
                  uint64_t v43 = *((void *)v41 - 1);
                  v41 -= 8;
                  uint64_t v42 = v43;
                  long long v44 = &v41[8 * v30];
                  uint64_t v45 = v41;
                  do
                  {
                    uint64_t v46 = v45;
                    uint64_t v45 = v44;
                    *(void *)uint64_t v46 = *(void *)v44;
                    BOOL v47 = __OFSUB__(v30, (v15 - v44) >> 3);
                    uint64_t v49 = v30 - ((v15 - v44) >> 3);
                    char v48 = (v49 < 0) ^ v47;
                    long long v44 = &v16[8 * v49];
                    if (v48) {
                      long long v44 = &v45[8 * v30];
                    }
                  }
                  while (v44 != v41);
                  *(void *)uint64_t v45 = v42;
                }
                while (v41 != v16);
              }
              uint64_t v29 = &v16[8 * ((v15 - a2) >> 3)];
            }
          }
        }
      }
      a4 -= v22;
      v8 -= v14;
      if (v22 + v14 >= a4 + v8)
      {
        uint64_t v54 = v8;
        uint64_t v55 = a6;
        double result = (char *)sub_1CCC41DC8(v29, v15, a3, a4, v54, a6, a7);
        a6 = v55;
        uint64_t v15 = v16;
        uint64_t v8 = v14;
        a4 = v22;
        a3 = v29;
      }
      else
      {
        BOOL v50 = v11;
        char v51 = v16;
        uint64_t v52 = a6;
        unint64_t v53 = a3;
        double result = (char *)sub_1CCC41DC8(v50, v51, v29, v22, v14, a6, a7);
        a3 = v53;
        a6 = v52;
        uint64_t v11 = v29;
      }
      a2 = v15;
      if (!v8) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (v11 != a2)
      {
        uint64_t v60 = 0;
        do
        {
          *(void *)&a6[v60] = *(void *)&v11[v60];
          v60 += 8;
        }
        while (&v11[v60] != a2);
        if (v60)
        {
          uint64_t v61 = a6;
          while (a2 != a3)
          {
            uint64_t v62 = *(void *)a2;
            unint64_t v63 = *(void *)(*(void *)a2 + 16);
            unint64_t v64 = *(void *)(*(void *)v61 + 16);
            BOOL v65 = v63 >= v64;
            BOOL v66 = v63 < v64;
            unsigned int v67 = v65;
            if (v65) {
              uint64_t v62 = *(void *)v61;
            }
            v61 += 8 * v67;
            a2 += 8 * v66;
            *(void *)uint64_t v11 = v62;
            v11 += 8;
            if (&a6[v60] == v61) {
              return result;
            }
          }
          return (char *)memmove(v11, v61, a6 - v61 + v60);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v56 = 0;
      do
      {
        *(void *)&a6[v56] = *(void *)&a2[v56];
        v56 += 8;
      }
      while (&a2[v56] != a3);
      if (v56)
      {
        uint64_t v57 = &a6[v56];
        std::string::size_type v58 = a3 - 8;
        while (a2 != v11)
        {
          uint64_t v59 = *((void *)v57 - 1);
          if (*(void *)(v59 + 16) >= *(void *)(*((void *)a2 - 1) + 16))
          {
            v57 -= 8;
          }
          else
          {
            uint64_t v59 = *((void *)a2 - 1);
            a2 -= 8;
          }
          *(void *)std::string::size_type v58 = v59;
          v58 -= 8;
          if (v57 == a6) {
            return result;
          }
        }
        if (v57 != a6)
        {
          uint64_t v68 = 0;
          do
          {
            *(void *)&v58[v68] = *(void *)&v57[v68 - 8];
            v68 -= 8;
          }
          while (&v57[v68] != a6);
        }
      }
    }
  }
  return result;
}

char *sub_1CCC42270(char *result, char *a2, unint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a3 >= 2)
  {
    uint64_t v6 = result;
    if (a3 == 2)
    {
      uint64_t v7 = *((void *)a2 - 1);
      uint64_t v8 = *(void *)result;
      if (bswap64(*(void *)(v7 + 16)) < bswap64(*(void *)(*(void *)result + 16)))
      {
        *(void *)double result = v7;
        *((void *)a2 - 1) = v8;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      unint64_t v18 = (char *)a4;
      unint64_t v19 = a3 >> 1;
      unint64_t v20 = &result[8 * (a3 >> 1)];
      unint64_t v21 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CCC424DC((uint64_t)result, v20, v21, a4);
        uint64_t v22 = (uint64_t *)&v18[8 * v19];
        double result = (char *)sub_1CCC424DC((uint64_t)&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v22);
        uint64_t v23 = &v18[8 * a3];
        unint64_t v24 = v22;
        while (v24 != (uint64_t *)v23)
        {
          unint64_t v25 = v24;
          uint64_t v26 = *v24;
          uint64_t v27 = *(void *)v18;
          unint64_t v28 = bswap64(*(void *)(v26 + 16));
          unint64_t v29 = bswap64(*(void *)(*(void *)v18 + 16));
          if (v28 < v29) {
            uint64_t v27 = v26;
          }
          v18 += 8 * (v28 >= v29);
          unint64_t v24 = &v25[v28 < v29];
          *(void *)uint64_t v6 = v27;
          v6 += 8;
          if (v18 == (char *)v22)
          {
            if (v24 != (uint64_t *)v23)
            {
              uint64_t v30 = 0;
              if (v28 < v29) {
                char v31 = 1;
              }
              else {
                char v31 = 2;
              }
              uint64_t v32 = &v25[v31 & 1];
              do
              {
                *(void *)&v6[v30 * 8] = v32[v30];
                ++v30;
              }
              while (&v32[v30] != (uint64_t *)v23);
            }
            return result;
          }
        }
        if (v18 != (char *)v22)
        {
          uint64_t v33 = 0;
          do
          {
            *(void *)&v6[v33] = *(void *)&v18[v33];
            v33 += 8;
          }
          while (&v18[v33] != (char *)v22);
        }
      }
      else
      {
        sub_1CCC42270(result, v20, v21, a4, a5);
        sub_1CCC42270(&v6[8 * (a3 >> 1)], a2, a3 - (a3 >> 1), v18, a5);
        return sub_1CCC426FC(v6, &v6[8 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), v18, a5);
      }
    }
    else if (result != a2)
    {
      unint64_t v10 = result + 8;
      if (result + 8 != a2)
      {
        uint64_t v11 = 0;
        uint64_t v12 = result;
        do
        {
          uint64_t v14 = *(void *)v12;
          uint64_t v13 = *((void *)v12 + 1);
          uint64_t v12 = v10;
          if (bswap64(*(void *)(v13 + 16)) < bswap64(*(void *)(v14 + 16)))
          {
            uint64_t v15 = v11;
            while (1)
            {
              *(void *)&result[v15 + 8] = v14;
              if (!v15) {
                break;
              }
              uint64_t v14 = *(void *)&result[v15 - 8];
              v15 -= 8;
              if (bswap64(*(void *)(v13 + 16)) >= bswap64(*(void *)(v14 + 16)))
              {
                uint64_t v16 = &result[v15 + 8];
                goto LABEL_15;
              }
            }
            uint64_t v16 = result;
LABEL_15:
            *(void *)uint64_t v16 = v13;
          }
          unint64_t v10 = v12 + 8;
          v11 += 8;
        }
        while (v12 + 8 != a2);
      }
    }
  }
  return result;
}

uint64_t sub_1CCC424DC(uint64_t result, void *a2, unint64_t a3, uint64_t *a4)
{
  if (a3)
  {
    long long v4 = a4;
    uint64_t v6 = result;
    if (a3 == 1)
    {
LABEL_8:
      uint64_t *v4 = *(void *)v6;
      return result;
    }
    if (a3 == 2)
    {
      uint64_t v8 = *(a2 - 1);
      unint64_t v9 = bswap64(*(void *)(v8 + 16));
      unint64_t v10 = bswap64(*(void *)(*(void *)result + 16));
      if (v9 >= v10) {
        uint64_t v8 = *(void *)result;
      }
      *a4 = v8;
      long long v4 = a4 + 1;
      if (v9 >= v10) {
        uint64_t v6 = (uint64_t)(a2 - 1);
      }
      goto LABEL_8;
    }
    if ((uint64_t)a3 > 8)
    {
      unint64_t v20 = result + 8 * (a3 >> 1);
      sub_1CCC42270(result, v20, a3 >> 1, a4, a3 >> 1);
      double result = sub_1CCC42270(v6 + 8 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
      unint64_t v21 = (void *)(v6 + 8 * (a3 >> 1));
      while (v21 != a2)
      {
        uint64_t v22 = v21;
        uint64_t v23 = *v21;
        uint64_t v24 = *(void *)v6;
        unint64_t v25 = bswap64(*(void *)(v23 + 16));
        unint64_t v26 = bswap64(*(void *)(*(void *)v6 + 16));
        if (v25 < v26) {
          uint64_t v24 = v23;
        }
        unint64_t v21 = &v22[v25 < v26];
        v6 += 8 * (v25 >= v26);
        *v4++ = v24;
        if (v6 == v20)
        {
          if (v21 != a2)
          {
            uint64_t v27 = 0;
            unint64_t v28 = &v22[v25 < v26];
            do
            {
              v4[v27] = v28[v27];
              ++v27;
            }
            while (&v28[v27] != a2);
          }
          return result;
        }
      }
      if (v6 != v20)
      {
        uint64_t v29 = 0;
        do
        {
          v4[v29] = *(void *)(v6 + v29 * 8);
          ++v29;
        }
        while (v6 + v29 * 8 != v20);
      }
    }
    else if ((void *)result != a2)
    {
      uint64_t v11 = result + 8;
      *a4 = *(void *)result;
      if ((void *)(result + 8) != a2)
      {
        uint64_t v12 = 0;
        uint64_t v13 = a4;
        uint64_t v14 = a4;
        do
        {
          uint64_t v16 = *v14++;
          uint64_t v15 = v16;
          if (bswap64(*(void *)(*(void *)v11 + 16)) >= bswap64(*(void *)(v16 + 16)))
          {
            *uint64_t v14 = *(void *)v11;
          }
          else
          {
            v13[1] = v15;
            unint64_t v17 = a4;
            if (v13 != a4)
            {
              uint64_t v18 = v12;
              while (1)
              {
                unint64_t v17 = (uint64_t *)((char *)a4 + v18);
                uint64_t v19 = *(uint64_t *)((char *)a4 + v18 - 8);
                if (bswap64(*(void *)(*(void *)v11 + 16)) >= bswap64(*(void *)(v19 + 16))) {
                  break;
                }
                *unint64_t v17 = v19;
                v18 -= 8;
                if (!v18)
                {
                  unint64_t v17 = a4;
                  break;
                }
              }
            }
            *unint64_t v17 = *(void *)v11;
          }
          v11 += 8;
          v12 += 8;
          uint64_t v13 = v14;
        }
        while ((void *)v11 != a2);
      }
    }
  }
  return result;
}

char *sub_1CCC426FC(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v8 = a5;
    uint64_t v11 = result;
    while (a4 > a7 && v8 > a7)
    {
      if (!a4) {
        return result;
      }
      unint64_t v12 = bswap64(*(void *)(*(void *)a2 + 16));
      while (1)
      {
        uint64_t v13 = *(void *)v11;
        if (v12 < bswap64(*(void *)(*(void *)v11 + 16))) {
          break;
        }
        v11 += 8;
        if (!--a4) {
          return result;
        }
      }
      if (a4 >= v8)
      {
        if (a4 == 1)
        {
          *(void *)uint64_t v11 = *(void *)a2;
          *(void *)a2 = v13;
          return result;
        }
        if (a4 >= 0) {
          uint64_t v25 = a4;
        }
        else {
          uint64_t v25 = a4 + 1;
        }
        uint64_t v24 = v25 >> 1;
        unint64_t v17 = &v11[8 * (v25 >> 1)];
        uint64_t v16 = a3;
        if (a3 != a2)
        {
          unint64_t v26 = (a3 - a2) >> 3;
          unint64_t v27 = bswap64(*(void *)(*(void *)v17 + 16));
          uint64_t v16 = a2;
          do
          {
            unint64_t v28 = v26 >> 1;
            uint64_t v29 = &v16[8 * (v26 >> 1)];
            uint64_t v31 = *(void *)v29;
            uint64_t v30 = v29 + 8;
            v26 += ~(v26 >> 1);
            if (bswap64(*(void *)(v31 + 16)) < v27) {
              uint64_t v16 = v30;
            }
            else {
              unint64_t v26 = v28;
            }
          }
          while (v26);
        }
        uint64_t v15 = (v16 - a2) >> 3;
      }
      else
      {
        if (v8 >= 0) {
          uint64_t v14 = v8;
        }
        else {
          uint64_t v14 = v8 + 1;
        }
        uint64_t v15 = v14 >> 1;
        uint64_t v16 = &a2[8 * (v14 >> 1)];
        unint64_t v17 = a2;
        if (v11 != a2)
        {
          unint64_t v18 = (a2 - v11) >> 3;
          unint64_t v19 = bswap64(*(void *)(*(void *)v16 + 16));
          unint64_t v17 = v11;
          do
          {
            unint64_t v20 = v18 >> 1;
            unint64_t v21 = &v17[8 * (v18 >> 1)];
            uint64_t v23 = *(void *)v21;
            uint64_t v22 = v21 + 8;
            v18 += ~(v18 >> 1);
            if (v19 < bswap64(*(void *)(v23 + 16))) {
              unint64_t v18 = v20;
            }
            else {
              unint64_t v17 = v22;
            }
          }
          while (v18);
        }
        uint64_t v24 = (v17 - v11) >> 3;
      }
      uint64_t v32 = v16;
      if (v17 != a2)
      {
        uint64_t v32 = v17;
        if (a2 != v16)
        {
          if (v17 + 8 == a2)
          {
            uint64_t v72 = *(void *)v17;
            char v74 = a3;
            uint64_t v39 = v16 - a2;
            uint64_t v76 = a6;
            memmove(v17, a2, v16 - a2);
            a3 = v74;
            a6 = v76;
            uint64_t v32 = &v17[v39];
            *(void *)uint64_t v32 = v72;
          }
          else if (a2 + 8 == v16)
          {
            uint64_t v40 = *((void *)v16 - 1);
            uint64_t v32 = v17 + 8;
            if (v16 - 8 != v17)
            {
              uint64_t v75 = a3;
              unsigned int v77 = a6;
              uint64_t v73 = *((void *)v16 - 1);
              memmove(v17 + 8, v17, v16 - 8 - v17);
              uint64_t v40 = v73;
              a3 = v75;
              a6 = v77;
            }
            *(void *)unint64_t v17 = v40;
          }
          else
          {
            uint64_t v33 = (a2 - v17) >> 3;
            if (v33 == (v16 - a2) >> 3)
            {
              uint64_t v34 = 0;
              do
              {
                uint64_t v35 = *(void *)&v17[v34];
                *(void *)&v17[v34] = *(void *)&a2[v34];
                uint64_t v36 = (uint64_t)&v17[v34 + 8];
                *(void *)&a2[v34] = v35;
                uint64_t v37 = (uint64_t)&a2[v34 + 8];
                v34 += 8;
              }
              while ((char *)v36 != a2 && v37 != (void)v16);
              uint64_t v32 = a2;
            }
            else
            {
              uint64_t v41 = (v16 - a2) >> 3;
              uint64_t v42 = (a2 - v17) >> 3;
              do
              {
                uint64_t v43 = v42;
                uint64_t v42 = v41;
                uint64_t v41 = v43 % v41;
              }
              while (v41);
              if (v42)
              {
                long long v44 = &v17[8 * v42];
                do
                {
                  uint64_t v46 = *((void *)v44 - 1);
                  v44 -= 8;
                  uint64_t v45 = v46;
                  BOOL v47 = &v44[8 * v33];
                  char v48 = v44;
                  do
                  {
                    uint64_t v49 = v48;
                    char v48 = v47;
                    *(void *)uint64_t v49 = *(void *)v47;
                    BOOL v50 = __OFSUB__(v33, (v16 - v47) >> 3);
                    uint64_t v52 = v33 - ((v16 - v47) >> 3);
                    char v51 = (v52 < 0) ^ v50;
                    BOOL v47 = &v17[8 * v52];
                    if (v51) {
                      BOOL v47 = &v48[8 * v33];
                    }
                  }
                  while (v47 != v44);
                  *(void *)char v48 = v45;
                }
                while (v44 != v17);
              }
              uint64_t v32 = &v17[8 * ((v16 - a2) >> 3)];
            }
          }
        }
      }
      a4 -= v24;
      v8 -= v15;
      if (v24 + v15 >= a4 + v8)
      {
        uint64_t v57 = v8;
        std::string::size_type v58 = a6;
        double result = (char *)sub_1CCC426FC(v32, v16, a3, a4, v57, a6, a7);
        a6 = v58;
        uint64_t v16 = v17;
        uint64_t v8 = v15;
        a4 = v24;
        a3 = v32;
      }
      else
      {
        unint64_t v53 = v11;
        uint64_t v54 = v17;
        uint64_t v55 = a6;
        uint64_t v56 = a3;
        double result = (char *)sub_1CCC426FC(v53, v54, v32, v24, v15, a6, a7);
        a3 = v56;
        a6 = v55;
        uint64_t v11 = v32;
      }
      a2 = v16;
      if (!v8) {
        return result;
      }
    }
    if (a4 <= v8)
    {
      if (v11 != a2)
      {
        uint64_t v63 = 0;
        do
        {
          *(void *)&a6[v63] = *(void *)&v11[v63];
          v63 += 8;
        }
        while (&v11[v63] != a2);
        if (v63)
        {
          unint64_t v64 = a6;
          while (a2 != a3)
          {
            uint64_t v65 = *(void *)a2;
            unint64_t v66 = bswap64(*(void *)(*(void *)a2 + 16));
            unint64_t v67 = bswap64(*(void *)(*(void *)v64 + 16));
            BOOL v68 = v66 >= v67;
            BOOL v69 = v66 < v67;
            unsigned int v70 = v68;
            if (v68) {
              uint64_t v65 = *(void *)v64;
            }
            v64 += 8 * v70;
            a2 += 8 * v69;
            *(void *)uint64_t v11 = v65;
            v11 += 8;
            if (&a6[v63] == v64) {
              return result;
            }
          }
          return (char *)memmove(v11, v64, a6 - v64 + v63);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v59 = 0;
      do
      {
        *(void *)&a6[v59] = *(void *)&a2[v59];
        v59 += 8;
      }
      while (&a2[v59] != a3);
      if (v59)
      {
        uint64_t v60 = &a6[v59];
        uint64_t v61 = a3 - 8;
        while (a2 != v11)
        {
          uint64_t v62 = *((void *)v60 - 1);
          if (bswap64(*(void *)(v62 + 16)) >= bswap64(*(void *)(*((void *)a2 - 1) + 16)))
          {
            v60 -= 8;
          }
          else
          {
            uint64_t v62 = *((void *)a2 - 1);
            a2 -= 8;
          }
          *(void *)uint64_t v61 = v62;
          v61 -= 8;
          if (v60 == a6) {
            return result;
          }
        }
        if (v60 != a6)
        {
          uint64_t v71 = 0;
          do
          {
            *(void *)&v61[v71] = *(void *)&v60[v71 - 8];
            v71 -= 8;
          }
          while (&v60[v71] != a6);
        }
      }
    }
  }
  return result;
}

__n128 llvm::object::ELFObjectFileBase::ELFObjectFileBase(uint64_t a1, int a2, long long *a3)
{
  long long v4 = *a3;
  __n128 result = (__n128)a3[1];
  *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = a2;
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 16) = v4;
  *(__n128 *)(a1 + 32) = result;
  *(void *)a1 = &unk_1F2632A78;
  return result;
}

void llvm::object::ObjectFile::createELFObjectFile(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 8) > 0xFuLL)
  {
    __int16 v4 = *(_WORD *)(*(void *)a1 + 4);
    if (*(void *)a1) {
      goto LABEL_3;
    }
  }
  else
  {
    __int16 v4 = 0;
    if (*(void *)a1)
    {
LABEL_3:
      long long v5 = "Insufficient alignment";
      goto LABEL_16;
    }
  }
  if (v4 == 2)
  {
    int v9 = HIBYTE(v4);
    if (v9 == 2)
    {
      long long v11 = *(_OWORD *)(a1 + 16);
      long long v13 = *(_OWORD *)a1;
      long long v14 = v11;
      sub_1CD6DFF1C((uint64_t)v15, &v13, a2);
      if ((v17 & 1) == 0 || (uint64_t v8 = v15[0], v15[0] = 0, !v8)) {
        operator new();
      }
    }
    else
    {
      if (v9 != 1)
      {
LABEL_14:
        long long v5 = "Invalid ELF data";
        goto LABEL_16;
      }
      long long v12 = *(_OWORD *)(a1 + 16);
      long long v13 = *(_OWORD *)a1;
      long long v14 = v12;
      sub_1CD6DCFDC((uint64_t)v15, &v13, a2);
      if ((v17 & 1) == 0 || (uint64_t v8 = v15[0], v15[0] = 0, !v8)) {
        operator new();
      }
    }
  }
  else
  {
    if (v4 != 1)
    {
      long long v5 = "Invalid ELF class";
LABEL_16:
      v15[0] = v5;
      LOWORD(v++*(_DWORD *)(this + 16) = 259;
      operator new();
    }
    int v6 = HIBYTE(v4);
    if (v6 != 2)
    {
      if (v6 == 1)
      {
        long long v7 = *(_OWORD *)(a1 + 16);
        long long v13 = *(_OWORD *)a1;
        long long v14 = v7;
        sub_1CD6D6D10((uint64_t)v15, &v13, a2);
        if ((v17 & 1) == 0 || (uint64_t v8 = v15[0], v15[0] = 0, !v8)) {
          operator new();
        }
        goto LABEL_25;
      }
      goto LABEL_14;
    }
    long long v10 = *(_OWORD *)(a1 + 16);
    long long v13 = *(_OWORD *)a1;
    long long v14 = v10;
    sub_1CD6D9F70((uint64_t)v15, &v13, a2);
    if ((v17 & 1) == 0 || (uint64_t v8 = v15[0], v15[0] = 0, !v8)) {
      operator new();
    }
  }
LABEL_25:
  *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = *(unsigned char *)(a3 + 8) & 0xFE | 1;
  *(void *)a3 = v8;
}

void llvm::object::ELFObjectFileBase::getARMFeatures(llvm::object::ELFObjectFileBase *this@<X0>, int64x2_t *a2@<X8>)
{
  int64x2_t v47 = 0uLL;
  uint64_t v48 = 0;
  llvm::SubtargetFeatures::Split(&v47, (uint64_t)"", 0);
  v32[1] = (void **)"aeabi";
  v32[2] = (void **)5;
  long long v33 = 0u;
  long long v34 = 0u;
  int v35 = 1065353216;
  long long v36 = 0u;
  long long v37 = 0u;
  int v38 = 1065353216;
  uint64_t v39 = 0;
  uint64_t v40 = &unk_1E6852F98;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v41 = 52;
  __int16 v44 = 1;
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  v32[0] = (void **)&unk_1F26435B0;
  (*(void (**)(void **__return_ptr, llvm::object::ELFObjectFileBase *, void ***))(*(void *)this + 496))(&v31, this, v32);
  if (!v31)
  {
    long long v4 = v33;
    long long v5 = sub_1CD6D6BB8(v33, *((unint64_t *)&v33 + 1), 6u);
    if (v5) {
      BOOL v6 = *((_DWORD *)v5 + 5) == 10;
    }
    else {
      BOOL v6 = 0;
    }
    long long v7 = sub_1CD6D6BB8(v4, *((unint64_t *)&v4 + 1), 7u);
    if (v7)
    {
      int v8 = *((_DWORD *)v7 + 5);
      if (v8 == 65)
      {
        int v9 = "aclass";
        uint64_t v10 = 6;
      }
      else
      {
        if (v8 == 77)
        {
          llvm::SubtargetFeatures::AddFeature(&v47, "mclass", 6, 1);
          if (!v6) {
            goto LABEL_19;
          }
        }
        else
        {
          if (v8 != 82) {
            goto LABEL_19;
          }
          llvm::SubtargetFeatures::AddFeature(&v47, "rclass", 6, 1);
          if (!v6) {
            goto LABEL_19;
          }
        }
        int v9 = "hwdiv";
        uint64_t v10 = 5;
      }
      llvm::SubtargetFeatures::AddFeature(&v47, (unsigned __int8 *)v9, v10, 1);
    }
LABEL_19:
    long long v11 = sub_1CD6D6BB8(v33, *((unint64_t *)&v33 + 1), 9u);
    if (!v11) {
      goto LABEL_25;
    }
    int v12 = *((_DWORD *)v11 + 5);
    if (v12 == 2)
    {
      int v13 = 1;
    }
    else
    {
      if (v12) {
        goto LABEL_25;
      }
      llvm::SubtargetFeatures::AddFeature(&v47, "thumb", 5, 0);
      int v13 = 0;
    }
    llvm::SubtargetFeatures::AddFeature(&v47, "thumb2", 6, v13);
LABEL_25:
    long long v14 = sub_1CD6D6BB8(v33, *((unint64_t *)&v33 + 1), 0xAu);
    if (v14)
    {
      switch(*((_DWORD *)v14 + 5))
      {
        case 0:
          llvm::SubtargetFeatures::AddFeature(&v47, "vfp2sp", 6, 0);
          llvm::SubtargetFeatures::AddFeature(&v47, "vfp3d16sp", 9, 0);
          uint64_t v15 = "vfp4d16sp";
          uint64_t v16 = 9;
          int v17 = 0;
          goto LABEL_32;
        case 2:
          uint64_t v15 = "vfp2";
          goto LABEL_31;
        case 3:
        case 4:
          uint64_t v15 = "vfp3";
          goto LABEL_31;
        case 5:
        case 6:
          uint64_t v15 = "vfp4";
LABEL_31:
          uint64_t v16 = 4;
          int v17 = 1;
LABEL_32:
          llvm::SubtargetFeatures::AddFeature(&v47, (unsigned __int8 *)v15, v16, v17);
          break;
        default:
          break;
      }
    }
    uint64_t v18 = sub_1CD6D6BB8(v33, *((unint64_t *)&v33 + 1), 0xCu);
    if (!v18)
    {
LABEL_42:
      uint64_t v22 = sub_1CD6D6BB8(v33, *((unint64_t *)&v33 + 1), 0x30u);
      if (!v22) {
        goto LABEL_51;
      }
      int v23 = *((_DWORD *)v22 + 5);
      if (v23 == 2)
      {
        uint64_t v24 = "mve.fp";
        uint64_t v25 = 6;
      }
      else
      {
        if (v23 != 1)
        {
          if (v23) {
            goto LABEL_51;
          }
          llvm::SubtargetFeatures::AddFeature(&v47, "mve", 3, 0);
          uint64_t v24 = "mve.fp";
          uint64_t v25 = 6;
          int v26 = 0;
LABEL_50:
          llvm::SubtargetFeatures::AddFeature(&v47, (unsigned __int8 *)v24, v25, v26);
LABEL_51:
          unint64_t v27 = sub_1CD6D6BB8(v33, *((unint64_t *)&v33 + 1), 0x2Cu);
          if (v27)
          {
            int v28 = *((_DWORD *)v27 + 5);
            if (v28 == 1)
            {
              int v29 = 0;
              goto LABEL_56;
            }
            if (v28 == 2)
            {
              int v29 = 1;
LABEL_56:
              llvm::SubtargetFeatures::AddFeature(&v47, "hwdiv", 5, v29);
              llvm::SubtargetFeatures::AddFeature(&v47, "hwdiv-arm", 9, v29);
            }
          }
          *a2 = v47;
          a2[1].i64[0] = v48;
          uint64_t v48 = 0;
          int64x2_t v47 = 0uLL;
          goto LABEL_58;
        }
        llvm::SubtargetFeatures::AddFeature(&v47, "mve.fp", 6, 0);
        uint64_t v24 = "mve";
        uint64_t v25 = 3;
      }
      int v26 = 1;
      goto LABEL_50;
    }
    int v19 = *((_DWORD *)v18 + 5);
    if (v19 == 2)
    {
      llvm::SubtargetFeatures::AddFeature(&v47, "neon", 4, 1);
      unint64_t v20 = "fp16";
    }
    else
    {
      if (v19 != 1)
      {
        if (v19) {
          goto LABEL_42;
        }
        llvm::SubtargetFeatures::AddFeature(&v47, "neon", 4, 0);
        unint64_t v20 = "fp16";
        int v21 = 0;
        goto LABEL_41;
      }
      unint64_t v20 = "neon";
    }
    int v21 = 1;
LABEL_41:
    llvm::SubtargetFeatures::AddFeature(&v47, (unsigned __int8 *)v20, 4, v21);
    goto LABEL_42;
  }
  uint64_t v30 = v31;
  uint64_t v31 = 0;
  sub_1CD4515D0(&v30);
  if (v30) {
    (*(void (**)(void *))(*v30 + 8))(v30);
  }
  a2->i64[0] = 0;
  a2->i64[1] = 0;
  a2[1].i64[0] = 0;
  llvm::SubtargetFeatures::Split(a2, (uint64_t)"", 0);
  if (v31) {
    (*(void (**)(void *))(*v31 + 8))(v31);
  }
LABEL_58:
  sub_1CD6D6C64(v32);
  v32[0] = (void **)&v47;
  sub_1CB8338B8(v32);
}

void *llvm::object::ELFObjectFileBase::setARMSubArch(void *this, llvm::Triple *a2)
{
  if (!*((_DWORD *)a2 + 7))
  {
    unint64_t v3 = this;
    v14[1] = "aeabi";
    unint64_t v14[2] = 5;
    long long v15 = 0u;
    long long v16 = 0u;
    int v17 = 1065353216;
    long long v18 = 0u;
    long long v19 = 0u;
    int v20 = 1065353216;
    uint64_t v21 = 0;
    uint64_t v22 = &unk_1E6852F98;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v23 = 52;
    __int16 v26 = 1;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    v14[0] = &unk_1F26435B0;
    (*(void (**)(std::string *__return_ptr))(*this + 496))(&v12);
    if (v12.__r_.__value_.__r.__words[0])
    {
      int v13 = (void *)v12.__r_.__value_.__r.__words[0];
      v12.__r_.__value_.__r.__words[0] = 0;
      sub_1CD4515D0(&v13);
      if (v13) {
        (*(void (**)(void *))(*v13 + 8))(v13);
      }
      if (v12.__r_.__value_.__r.__words[0]) {
        (*(void (**)(std::string::size_type))(*(void *)v12.__r_.__value_.__l.__data_ + 8))(v12.__r_.__value_.__r.__words[0]);
      }
    }
    else
    {
      memset(&v12, 0, sizeof(v12));
      if ((*((_DWORD *)a2 + 6) - 39) >= 2) {
        long long v4 = "arm";
      }
      else {
        long long v4 = "thumb";
      }
      MEMORY[0x1D25D9630](&v12, v4);
      long long v5 = v15;
      BOOL v6 = sub_1CD6D6BB8(v15, *((unint64_t *)&v15 + 1), 6u);
      if (v6)
      {
        long long v7 = "v4";
        switch(*((_DWORD *)v6 + 5))
        {
          case 1:
            goto LABEL_32;
          case 2:
            long long v7 = "v4t";
            goto LABEL_32;
          case 3:
            long long v7 = "v5t";
            goto LABEL_32;
          case 4:
            long long v7 = "v5te";
            goto LABEL_32;
          case 5:
            long long v7 = "v5tej";
            goto LABEL_32;
          case 6:
            long long v7 = "v6";
            goto LABEL_32;
          case 7:
            long long v7 = "v6kz";
            goto LABEL_32;
          case 8:
            long long v7 = "v6t2";
            goto LABEL_32;
          case 9:
            long long v7 = "v6k";
            goto LABEL_32;
          case 0xA:
            int v8 = sub_1CD6D6BB8(v5, *((unint64_t *)&v5 + 1), 7u);
            if (v8 && *((_DWORD *)v8 + 5) == 77) {
              long long v7 = "v7m";
            }
            else {
              long long v7 = "v7";
            }
            goto LABEL_32;
          case 0xB:
            long long v7 = "v6m";
            goto LABEL_32;
          case 0xC:
            long long v7 = "v6sm";
            goto LABEL_32;
          case 0xD:
            long long v7 = "v7em";
            goto LABEL_32;
          case 0xE:
            long long v7 = "v8a";
            goto LABEL_32;
          case 0xF:
            long long v7 = "v8r";
            goto LABEL_32;
          case 0x10:
            long long v7 = "v8m.base";
            goto LABEL_32;
          case 0x11:
            long long v7 = "v8m.main";
            goto LABEL_32;
          case 0x15:
            long long v7 = "v8.1m.main";
LABEL_32:
            std::string::append(&v12, v7);
            break;
          default:
            break;
        }
      }
      unsigned int v9 = *((_DWORD *)v3 + 2);
      if (v9 <= 0x13 && ((1 << v9) & 0xAAC00) != 0) {
        std::string::append(&v12, "eb");
      }
      if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v10 = &v12;
      }
      else {
        uint64_t v10 = (std::string *)v12.__r_.__value_.__r.__words[0];
      }
      if ((v12.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t size = *((unsigned char *)&v12.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        uint64_t size = v12.__r_.__value_.__l.__size_;
      }
      llvm::Triple::setArchName(a2, v10, size);
      if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v12.__r_.__value_.__l.__data_);
      }
    }
    return sub_1CD6D6C64(v14);
  }
  return this;
}

void llvm::object::ELFObjectFileBase::getPltAddresses(llvm::object::ELFObjectFileBase *this@<X0>, void **a2@<X8>)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  v88[0] = 0;
  v88[1] = 0;
  uint64_t v89 = 0;
  llvm::object::ObjectFile::makeTriple(this, (llvm::Triple *)__p);
  long long v4 = llvm::TargetRegistry::lookupTarget((std::string::size_type)__p, (uint64_t)v88);
  if (!v4) {
    goto LABEL_5;
  }
  long long v5 = v4;
  if ((v87 - 41) < 2)
  {
    uint64_t v6 = 7;
    goto LABEL_7;
  }
  if ((v87 - 3) > 1)
  {
LABEL_5:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    goto LABEL_42;
  }
  uint64_t v6 = 1026;
LABEL_7:
  long long v7 = (uint64_t (*)(void))v4[8];
  if (v7) {
    uint64_t v8 = v7();
  }
  else {
    uint64_t v8 = 0;
  }
  unsigned int v9 = (uint64_t (*)(void))v5[9];
  if (!v9 || (uint64_t v10 = v9(v8)) == 0)
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    if (!v8) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  uint64_t v74 = v6;
  uint64_t v72 = v10;
  uint64_t v11 = (*(uint64_t (**)(llvm::object::ELFObjectFileBase *))(*(void *)this + 344))(this);
  uint64_t v13 = v12;
  uint64_t v14 = (*(uint64_t (**)(llvm::object::ELFObjectFileBase *))(*(void *)this + 352))(this);
  unint64_t v80 = v11;
  uint64_t v81 = v13;
  if (v13 == v15 && v11 == v14)
  {
LABEL_117:
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    goto LABEL_118;
  }
  uint64_t v17 = v14;
  uint64_t v18 = v15;
  unsigned __int8 v19 = 0;
  int v20 = 0;
  unsigned __int8 v68 = 0;
  int v71 = 0;
  unsigned __int8 v21 = 0;
  int v73 = 0;
  do
  {
    (*(void (**)(uint64_t **__return_ptr, uint64_t, uint64_t))(*(void *)v13 + 136))(&v90, v13, v11);
    if (v92)
    {
      uint64_t v24 = v90;
      uint64_t v90 = 0;
      __int16 v84 = v24;
      sub_1CD4515D0(&v84);
      if (v84) {
        (*(void (**)(uint64_t *))(*v84 + 8))(v84);
      }
    }
    else if (v91 == (uint64_t *)9)
    {
      if (*v90 == 0x6C702E616C65722ELL && *((unsigned char *)v90 + 8) == 116)
      {
LABEL_31:
        unsigned __int8 v19 = v80;
        unint64_t v75 = v80 >> 8;
        uint64_t v76 = v81;
        int v20 = 1;
      }
    }
    else if (v91 == (uint64_t *)8)
    {
      if (*v90 == 0x746C702E6C65722ELL) {
        goto LABEL_31;
      }
      if (*v90 == 0x746C702E746F672ELL)
      {
        uint64_t v67 = v81;
        unsigned __int8 v68 = v80;
        unint64_t v66 = v80 >> 8;
        int v71 = 1;
      }
    }
    else if (v91 == (uint64_t *)4 && *(_DWORD *)v90 == 1953263662)
    {
      unsigned __int8 v21 = v80;
      unint64_t v69 = v80 >> 8;
      uint64_t v70 = v81;
      int v73 = 1;
    }
    if (v92)
    {
      uint64_t v23 = v90;
      uint64_t v90 = 0;
      if (v23) {
        (*(void (**)(uint64_t *))(*v23 + 8))(v23);
      }
    }
    (*(void (**)(uint64_t, unint64_t *))(*(void *)v81 + 128))(v81, &v80);
    uint64_t v11 = v80;
    uint64_t v13 = v81;
  }
  while (v81 != v18 || v80 != v17);
  if (!v73 || !v20 || !v71) {
    goto LABEL_117;
  }
  unint64_t v25 = v21 | (v69 << 8);
  (*(void (**)(uint64_t **__return_ptr, uint64_t, unint64_t))(*(void *)v70 + 168))(&v90, v70, v25);
  if (v92)
  {
    uint64_t v83 = v90;
    sub_1CD4515D0(&v83);
    if (v83) {
      (*(void (**)(uint64_t *))(*v83 + 8))(v83);
    }
    goto LABEL_117;
  }
  (*(void (**)(uint64_t, unint64_t))(*(void *)v70 + 144))(v70, v25);
  (*(void (**)(uint64_t, unint64_t))(*(void *)v67 + 144))(v67, v68 | (v66 << 8));
  (*(void (**)(uint64_t **__return_ptr))(*(void *)v72 + 128))(&v90);
  unint64_t v80 = 0;
  uint64_t v81 = 0;
  unsigned int v82 = 0;
  __int16 v26 = v90;
  uint64_t v27 = v91;
  if (v90 != v91)
  {
    while (1)
    {
      uint64_t v29 = *v26;
      uint64_t v28 = v26[1];
      uint64_t v78 = v28;
      uint64_t v79 = v29;
      if (!v82) {
        break;
      }
      unsigned int v30 = (v82 - 1) & (37 * v28);
      uint64_t v31 = (void *)(v80 + 16 * v30);
      uint64_t v32 = *v31;
      if (v28 != *v31)
      {
        int v35 = 0;
        int v36 = 1;
        while (v32 != -1)
        {
          if (v35) {
            BOOL v37 = 0;
          }
          else {
            BOOL v37 = v32 == -2;
          }
          if (v37) {
            int v35 = v31;
          }
          unsigned int v38 = v30 + v36++;
          unsigned int v30 = v38 & (v82 - 1);
          uint64_t v31 = (void *)(v80 + 16 * v30);
          uint64_t v32 = *v31;
          if (v28 == *v31) {
            goto LABEL_54;
          }
        }
        if (v35) {
          long long v33 = v35;
        }
        else {
          long long v33 = v31;
        }
        goto LABEL_57;
      }
LABEL_54:
      v26 += 2;
      if (v26 == v27) {
        goto LABEL_70;
      }
    }
    long long v33 = 0;
LABEL_57:
    long long v34 = sub_1CD5EF768((uint64_t)&v80, (uint64_t)&v78, &v78, v33);
    *long long v34 = v78;
    v34[1] = v79;
    goto LABEL_54;
  }
LABEL_70:
  unint64_t v39 = v19 | (v75 << 8);
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v40 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v76 + 264))(v76, v39);
  uint64_t v42 = v41;
  uint64_t v43 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v76 + 272))(v76, v39);
  uint64_t v78 = v40;
  uint64_t v79 = v42;
  uint64_t v44 = v74;
  if (v40 != v43)
  {
    uint64_t v45 = v43;
    uint64_t v46 = (char *)a2[1];
    int64x2_t v47 = (char *)a2[2];
    uint64_t v48 = *a2;
    while (2)
    {
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v79 + 312))(v79, v40) != v44) {
        goto LABEL_110;
      }
      uint64_t v77 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v79 + 296))(v79, v78);
      uint64_t v49 = sub_1CC6AFC28((uint64_t *)&v80, &v77);
      if ((uint64_t *)(v80 + 16 * v82) == v49) {
        goto LABEL_110;
      }
      BOOL v50 = v49;
      uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v79 + 304))(v79, v78);
      if (v51 == (*(uint64_t (**)(llvm::object::ELFObjectFileBase *))(*(void *)this + 56))(this))
      {
        if (v46 < v47)
        {
          char *v46 = 0;
          v46[8] = 0;
          goto LABEL_79;
        }
        unint64_t v52 = 0xAAAAAAAAAAAAAAABLL * ((v46 - v48) >> 3) + 1;
        if (v52 > 0xAAAAAAAAAAAAAAALL) {
          goto LABEL_113;
        }
        if (0x5555555555555556 * ((v47 - v48) >> 3) > v52) {
          unint64_t v52 = 0x5555555555555556 * ((v47 - v48) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v47 - v48) >> 3) >= 0x555555555555555) {
          unint64_t v52 = 0xAAAAAAAAAAAAAAALL;
        }
        if (v52 > 0xAAAAAAAAAAAAAAALL) {
          goto LABEL_114;
        }
        uint64_t v53 = 3 * v52;
        uint64_t v54 = (char *)operator new(24 * v52);
        uint64_t v55 = &v54[8 * ((v46 - v48) >> 3)];
        *uint64_t v55 = 0;
        v55[8] = 0;
        *((void *)v55 + 2) = v50[1];
        if (v46 == v48)
        {
          uint64_t v57 = &v54[8 * ((v46 - v48) >> 3)];
        }
        else
        {
          uint64_t v56 = &v54[8 * ((v46 - v48) >> 3)];
          do
          {
            uint64_t v57 = v56 - 24;
            long long v58 = *(_OWORD *)(v46 - 24);
            *((void *)v56 - 1) = *((void *)v46 - 1);
            *(_OWORD *)(v56 - 24) = v58;
            v46 -= 24;
            v56 -= 24;
          }
          while (v46 != v48);
        }
        int64x2_t v47 = &v54[8 * v53];
        uint64_t v46 = v55 + 24;
        *a2 = v57;
        a2[1] = v55 + 24;
        a2[2] = v47;
        if (v48) {
          operator delete(v48);
        }
        uint64_t v48 = v57;
LABEL_104:
        uint64_t v44 = v74;
      }
      else
      {
        if (v46 < v47)
        {
          *(void *)uint64_t v46 = v51;
          v46[8] = 1;
LABEL_79:
          *((void *)v46 + 2) = v50[1];
          v46 += 24;
          goto LABEL_104;
        }
        unint64_t v59 = 0xAAAAAAAAAAAAAAABLL * ((v46 - v48) >> 3) + 1;
        if (v59 > 0xAAAAAAAAAAAAAAALL) {
LABEL_113:
        }
          abort();
        if (0x5555555555555556 * ((v47 - v48) >> 3) > v59) {
          unint64_t v59 = 0x5555555555555556 * ((v47 - v48) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v47 - v48) >> 3) >= 0x555555555555555) {
          unint64_t v59 = 0xAAAAAAAAAAAAAAALL;
        }
        if (v59 > 0xAAAAAAAAAAAAAAALL) {
LABEL_114:
        }
          sub_1CB833614();
        uint64_t v60 = 3 * v59;
        uint64_t v61 = (char *)operator new(24 * v59);
        uint64_t v62 = &v61[8 * ((v46 - v48) >> 3)];
        *(void *)uint64_t v62 = v51;
        v62[8] = 1;
        *((void *)v62 + 2) = v50[1];
        if (v46 == v48)
        {
          unint64_t v64 = &v61[8 * ((v46 - v48) >> 3)];
          uint64_t v44 = v74;
        }
        else
        {
          uint64_t v63 = &v61[8 * ((v46 - v48) >> 3)];
          uint64_t v44 = v74;
          do
          {
            unint64_t v64 = v63 - 24;
            long long v65 = *(_OWORD *)(v46 - 24);
            *((void *)v63 - 1) = *((void *)v46 - 1);
            *(_OWORD *)(v63 - 24) = v65;
            v46 -= 24;
            v63 -= 24;
          }
          while (v46 != v48);
        }
        int64x2_t v47 = &v61[8 * v60];
        uint64_t v46 = v62 + 24;
        *a2 = v64;
        a2[1] = v62 + 24;
        a2[2] = v47;
        if (v48) {
          operator delete(v48);
        }
        uint64_t v48 = v64;
      }
      a2[1] = v46;
LABEL_110:
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v79 + 288))(v79, &v78);
      uint64_t v40 = v78;
      if (v78 == v45) {
        break;
      }
      continue;
    }
  }
  MEMORY[0x1D25D9CD0](v80, 8);
  if (v90)
  {
    __int16 v91 = v90;
    operator delete(v90);
  }
LABEL_118:
  (*(void (**)(uint64_t))(*(void *)v72 + 8))(v72);
  if (v8) {
LABEL_41:
  }
    MEMORY[0x1D25D9CE0](v8, 0x10F0C40CB53E019);
LABEL_42:
  if (v86 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v89) < 0) {
    operator delete(v88[0]);
  }
}

void llvm::object::ELFObjectFileBase::readDynsymVersions(llvm::object::ELFObjectFileBase *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v342 = *MEMORY[0x1E4F143B8];
  (*(void (**)(unint64_t *__return_ptr))(*(void *)this + 504))(&v302);
  int v5 = *((_DWORD *)this + 2);
  uint64_t v6 = (uint64_t *)((char *)this + 56);
  if (v5 != 12)
  {
    if (v5 == 13)
    {
      unint64_t v7 = v302;
      uint64_t v8 = v303;
      uint64_t v295 = v304;
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::sections((void *)this + 7, (uint64_t)&v337);
      if (v338)
      {
        unsigned int v9 = 0;
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        uint64_t v12 = 40 * v338;
        uint64_t v13 = (int *)(v337 + 4);
        do
        {
          int v14 = *v13;
          if (*v13 == -16777361) {
            uint64_t v15 = v13 - 1;
          }
          else {
            uint64_t v15 = (int *)v10;
          }
          if (v14 == -33554577) {
            long long v16 = v13 - 1;
          }
          else {
            long long v16 = (int *)v11;
          }
          if (v14 == -33554577) {
            uint64_t v15 = (int *)v10;
          }
          if (v14 == -145)
          {
            unsigned int v9 = (unsigned int *)(v13 - 1);
          }
          else
          {
            uint64_t v11 = (uint64_t)v16;
            uint64_t v10 = (uint64_t)v15;
          }
          v13 += 10;
          v12 -= 40;
        }
        while (v12);
        if (v9)
        {
          llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,false>>::loadVersionMap((void *)this + 7, v10, v11, (uint64_t)v335);
          if ((v336 & 1) == 0)
          {
            uint64_t v17 = 0;
            uint64_t v313 = 0;
            int64x2_t v18 = 0uLL;
            int64x2_t v312 = 0u;
            uint64_t v310 = v8;
            uint64_t v311 = 0;
            unint64_t v309 = v7;
            if (v7 == v295) {
              goto LABEL_367;
            }
            uint64_t v19 = v295;
            while (1)
            {
              unsigned int v20 = ++v311;
              if (v9[9] != 0x2000000)
              {
                sub_1CD6CD2F0(v6, (uint64_t)v9, (char *)&v340);
                char v223 = std::string::insert(&v340, 0, "section ");
                std::string::size_type v224 = v223->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v223->__r_.__value_.__l.__data_;
                v316.__r_.__value_.__r.__words[2] = v224;
                v223->__r_.__value_.__l.__size_ = 0;
                v223->__r_.__value_.__r.__words[2] = 0;
                v223->__r_.__value_.__r.__words[0] = 0;
                uint64_t v225 = std::string::append(&v316, " has invalid sh_entsize: expected ");
                std::string::size_type v226 = v225->__r_.__value_.__r.__words[2];
                *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v225->__r_.__value_.__l.__data_;
                __p.__r_.__value_.__r.__words[2] = v226;
                v225->__r_.__value_.__l.__size_ = 0;
                v225->__r_.__value_.__r.__words[2] = 0;
                v225->__r_.__value_.__r.__words[0] = 0;
                v318.__r_.__value_.__r.__words[0] = 2;
                p_p = &__p;
                *(void *)&long long v324 = &v318;
                __int16 v325 = 2564;
                *(void *)&long long __dst = &p_p;
                uint64_t v329 = (std::string *)", but got ";
                __int16 v330 = 770;
                uint64_t v227 = bswap32(v9[9]);
                p_dst = (std::string *)&__dst;
                v332.i64[1] = v227;
                LOWORD(v334) = 2050;
                operator new();
              }
              std::string::size_type v21 = bswap32(v9[5]);
              if (v21)
              {
                sub_1CD6CD2F0(v6, (uint64_t)v9, (char *)&v318);
                size_t v233 = std::string::insert(&v318, 0, "section ");
                std::string::size_type v234 = v233->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v340.__r_.__value_.__l.__data_ = *(_OWORD *)&v233->__r_.__value_.__l.__data_;
                v340.__r_.__value_.__r.__words[2] = v234;
                v233->__r_.__value_.__l.__size_ = 0;
                v233->__r_.__value_.__r.__words[2] = 0;
                v233->__r_.__value_.__r.__words[0] = 0;
                size_t v235 = std::string::append(&v340, " has an invalid sh_size (");
                std::string::size_type v236 = v235->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v235->__r_.__value_.__l.__data_;
                v316.__r_.__value_.__r.__words[2] = v236;
                v235->__r_.__value_.__l.__size_ = 0;
                v235->__r_.__value_.__r.__words[2] = 0;
                v235->__r_.__value_.__r.__words[0] = 0;
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
                __p.__r_.__value_.__r.__words[2] = v21;
                __int16 v320 = 2052;
                p_p = &__p;
                *(void *)&long long v324 = ") which is not a multiple of its sh_entsize (";
                __int16 v325 = 770;
                int v237 = (std::string *)bswap32(v9[9]);
                *(void *)&long long __dst = &p_p;
                uint64_t v329 = v237;
                __int16 v330 = 2050;
                size_t v238 = ")";
                goto LABEL_374;
              }
              std::string::size_type v22 = bswap32(v9[4]);
              if (__CFADD__(v22, v21))
              {
                sub_1CD6CD2F0(v6, (uint64_t)v9, (char *)&v318);
                unint64_t v245 = std::string::insert(&v318, 0, "section ");
                std::string::size_type v246 = v245->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v340.__r_.__value_.__l.__data_ = *(_OWORD *)&v245->__r_.__value_.__l.__data_;
                v340.__r_.__value_.__r.__words[2] = v246;
                v245->__r_.__value_.__l.__size_ = 0;
                v245->__r_.__value_.__r.__words[2] = 0;
                v245->__r_.__value_.__r.__words[0] = 0;
                unint64_t v247 = std::string::append(&v340, " has a sh_offset (0x");
                std::string::size_type v248 = v247->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v247->__r_.__value_.__l.__data_;
                v316.__r_.__value_.__r.__words[2] = v248;
                v247->__r_.__value_.__l.__size_ = 0;
                v247->__r_.__value_.__r.__words[2] = 0;
                v247->__r_.__value_.__r.__words[0] = 0;
                v315.__r_.__value_.__r.__words[0] = v22;
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
                __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v315;
                __int16 v320 = 3588;
                p_p = &__p;
                *(void *)&long long v324 = ") + sh_size (0x";
                __int16 v325 = 770;
                v339.__r_.__value_.__r.__words[0] = v21;
                *(void *)&long long __dst = &p_p;
                uint64_t v329 = &v339;
                __int16 v330 = 3586;
                size_t v238 = ") that cannot be represented";
LABEL_374:
                p_dst = (std::string *)&__dst;
                v332.i64[1] = (uint64_t)v238;
                LOWORD(v334) = 770;
                operator new();
              }
              if (*((void *)this + 8) < (unint64_t)(v21 + v22))
              {
                sub_1CD6CD2F0(v6, (uint64_t)v9, (char *)&v339);
                uint64_t v253 = std::string::insert(&v339, 0, "section ");
                std::string::size_type v254 = v253->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v315.__r_.__value_.__l.__data_ = *(_OWORD *)&v253->__r_.__value_.__l.__data_;
                v315.__r_.__value_.__r.__words[2] = v254;
                v253->__r_.__value_.__l.__size_ = 0;
                v253->__r_.__value_.__r.__words[2] = 0;
                v253->__r_.__value_.__r.__words[0] = 0;
                uint64_t v255 = std::string::append(&v315, " has a sh_offset (0x");
                std::string::size_type v256 = v255->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v318.__r_.__value_.__l.__data_ = *(_OWORD *)&v255->__r_.__value_.__l.__data_;
                v318.__r_.__value_.__r.__words[2] = v256;
                v255->__r_.__value_.__l.__size_ = 0;
                v255->__r_.__value_.__r.__words[2] = 0;
                v255->__r_.__value_.__r.__words[0] = 0;
                *(void *)&long long v307 = v22;
                v340.__r_.__value_.__r.__words[0] = (std::string::size_type)&v318;
                v340.__r_.__value_.__r.__words[2] = (std::string::size_type)&v307;
                __int16 v341 = 3588;
                v316.__r_.__value_.__r.__words[0] = (std::string::size_type)&v340;
                v316.__r_.__value_.__r.__words[2] = (std::string::size_type)") + sh_size (0x";
                __int16 v317 = 770;
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
                __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v321;
                __int16 v320 = 3586;
                std::string::size_type v321 = v21;
                p_p = &__p;
                *(void *)&long long v324 = ") that is greater than the file size (0x";
                __int16 v325 = 770;
                uint64_t v314 = *((void *)this + 8);
                *(void *)&long long __dst = &p_p;
                uint64_t v329 = (std::string *)&v314;
                __int16 v330 = 3586;
                p_dst = (std::string *)&__dst;
                v332.i64[1] = (uint64_t)")";
                LOWORD(v334) = 770;
                operator new();
              }
              uint64_t v23 = v20;
              if (v20 >= v21 >> 1)
              {
                v316.__r_.__value_.__r.__words[0] = 2 * v20;
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"can't read an entry at 0x";
                __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v316;
                __int16 v320 = 3587;
                p_p = &__p;
                *(void *)&long long v324 = ": it goes past the end of the section (0x";
                __int16 v325 = 770;
                v340.__r_.__value_.__r.__words[0] = v21;
                *(void *)&long long __dst = &p_p;
                uint64_t v329 = &v340;
                __int16 v330 = 3586;
                p_dst = (std::string *)&__dst;
                v332.i64[1] = (uint64_t)")";
                LOWORD(v334) = 770;
                operator new();
              }
              uint64_t v24 = *v6;
              (*(void (**)(std::string *__return_ptr))(*(void *)v310 + 40))(&v339);
              if (v339.__r_.__value_.__s.__data_[8])
              {
                p_p = (std::string *)"unable to read flags for symbol with index ";
                *(void *)&long long v324 = &v311;
                __int16 v325 = 2563;
                *(void *)&long long __dst = &p_p;
                uint64_t v329 = (std::string *)": ";
                __int16 v330 = 770;
                std::string::size_type v48 = v339.__r_.__value_.__r.__words[0];
                v339.__r_.__value_.__r.__words[0] = 0;
                std::string::size_type v306 = v48;
                sub_1CD4FB504((uint64_t *)&v306, &__p);
                char v49 = v330;
                if ((_BYTE)v330)
                {
                  if (v330 == 1)
                  {
                    p_dst = &__p;
                    char v50 = 1;
                    char v49 = 4;
                  }
                  else
                  {
                    if (HIBYTE(v330) != 1) {
                      char v49 = 2;
                    }
                    uint64_t v54 = (void **)&__dst;
                    if (HIBYTE(v330) == 1) {
                      uint64_t v54 = (void **)__dst;
                    }
                    p_dst = (std::string *)v54;
                    v332.i64[0] = *((void *)&__dst + 1);
                    v332.i64[1] = (uint64_t)&__p;
                    char v50 = 4;
                  }
                }
                else
                {
                  char v50 = 1;
                }
                LOBYTE(v334) = v49;
                BYTE1(v334) = v50;
                operator new();
              }
              LOBYTE(v314) = 0;
              unint64_t v25 = v2 & 0xFFFFFFFFFFFF0000 | v339.__r_.__value_.__s.__data_[0] & 1 | 0x100;
              llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSymbolVersionByIndex(bswap32(*(unsigned __int16 *)(v24 + v22 + 2 * v23)) >> 16, &v314, (uint64_t)v335, v25, (uint64_t)&v340);
              if (v340.__r_.__value_.__s.__data_[16])
              {
                v316.__r_.__value_.__r.__words[0] = (std::string::size_type)"unable to get a version for entry ";
                v316.__r_.__value_.__r.__words[2] = (std::string::size_type)&v311;
                __int16 v317 = 2563;
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
                __p.__r_.__value_.__r.__words[2] = (std::string::size_type)" of ";
                __int16 v320 = 770;
                sub_1CCC2C378(&v318, v6, (uint64_t)v9);
                char v51 = v320;
                if (v320 == 1)
                {
                  p_p_p = &v318;
                  p_p = &v318;
                  long long v324 = v307;
                  __int16 v325 = 260;
                  int v326 = v321;
                  __int16 v327 = WORD2(v321);
                  char v52 = 4;
                  uint64_t v56 = size;
                }
                else
                {
                  if (!(_BYTE)v320)
                  {
                    char v52 = 0;
                    __int16 v325 = 256;
                    char v53 = 1;
                    goto LABEL_80;
                  }
                  p_p_p = (std::string *)&p_p;
                  uint64_t v57 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  char v52 = 2;
                  if (HIBYTE(v320) != 1)
                  {
                    char v51 = 2;
                    uint64_t v57 = &__p;
                  }
                  p_p = v57;
                  std::string::size_type size = __p.__r_.__value_.__l.__size_;
                  *(void *)&long long v324 = &v318;
                  LOBYTE(v325) = v51;
                  uint64_t v56 = 4;
                  HIBYTE(v325) = 4;
                }
                *(void *)&long long __dst = p_p_p;
                *((void *)&__dst + 1) = v56;
                char v53 = 3;
                uint64_t v329 = (std::string *)": ";
LABEL_80:
                LOBYTE(v330) = v52;
                HIBYTE(v330) = v53;
                if (v340.__r_.__value_.__s.__data_[16])
                {
                  std::string::size_type v58 = v340.__r_.__value_.__r.__words[0];
                  v340.__r_.__value_.__r.__words[0] = 0;
                }
                else
                {
                  std::string::size_type v58 = 0;
                }
                std::string::size_type v305 = v58;
                sub_1CD4FB504((uint64_t *)&v305, &v315);
                char v59 = v330;
                if ((_BYTE)v330)
                {
                  if (v330 == 1)
                  {
                    p_dst = &v315;
                    char v60 = 1;
                    char v59 = 4;
                  }
                  else
                  {
                    if (HIBYTE(v330) != 1) {
                      char v59 = 2;
                    }
                    uint64_t v61 = (void **)&__dst;
                    if (HIBYTE(v330) == 1) {
                      uint64_t v61 = (void **)__dst;
                    }
                    p_dst = (std::string *)v61;
                    v332.i64[0] = *((void *)&__dst + 1);
                    v332.i64[1] = (uint64_t)&v315;
                    char v60 = 4;
                  }
                }
                else
                {
                  char v60 = 1;
                }
                LOBYTE(v334) = v59;
                BYTE1(v334) = v60;
                operator new();
              }
              __int16 v26 = (const void *)v340.__r_.__value_.__r.__words[0];
              unint64_t v298 = v25;
              if (!v340.__r_.__value_.__r.__words[0])
              {
                long long __dst = 0uLL;
                uint64_t v329 = 0;
                goto LABEL_39;
              }
              std::string::size_type v27 = v340.__r_.__value_.__l.__size_;
              if (v340.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7) {
                goto LABEL_393;
              }
              if (v340.__r_.__value_.__l.__size_ >= 0x17)
              {
                std::string::size_type v29 = (v340.__r_.__value_.__l.__size_ & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v340.__r_.__value_.__l.__size_ | 7) != 0x17) {
                  std::string::size_type v29 = v340.__r_.__value_.__l.__size_ | 7;
                }
                std::string::size_type v30 = v29 + 1;
                uint64_t v28 = (long long *)operator new(v29 + 1);
                unint64_t v31 = v30 | 0x8000000000000000;
                uint64_t v6 = (uint64_t *)((char *)this + 56);
                *((void *)&__dst + 1) = v27;
                uint64_t v329 = (std::string *)v31;
                *(void *)&long long __dst = v28;
              }
              else
              {
                HIBYTE(v329) = v340.__r_.__value_.__s.__data_[8];
                uint64_t v28 = &__dst;
                if (!v340.__r_.__value_.__l.__size_) {
                  goto LABEL_38;
                }
              }
              memmove(v28, v26, v27);
LABEL_38:
              *((unsigned char *)v28 + v27) = 0;
LABEL_39:
              char v32 = v314;
              unint64_t v33 = v312.u64[1];
              long long v34 = v313;
              if (v312.i64[1] >= (unint64_t)v313)
              {
                uint64_t v36 = a2;
                uint64_t v37 = v312.i64[0];
                uint64_t v38 = (v312.i64[1] - v312.i64[0]) >> 5;
                unint64_t v39 = v38 + 1;
                if ((unint64_t)(v38 + 1) >> 59) {
                  goto LABEL_393;
                }
                if ((uint64_t)&v313[-v312.i64[0]] >> 4 > v39) {
                  unint64_t v39 = (uint64_t)&v313[-v312.i64[0]] >> 4;
                }
                if ((unint64_t)&v313[-v312.i64[0]] >= 0x7FFFFFFFFFFFFFE0) {
                  unint64_t v40 = 0x7FFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v40 = v39;
                }
                char v333 = 0;
                __int16 v334 = &v313;
                if (v40 >> 59) {
                  goto LABEL_394;
                }
                uint64_t v41 = (char *)operator new(32 * v40);
                uint64_t v42 = &v41[32 * v38];
                *(_OWORD *)uint64_t v42 = __dst;
                *((void *)v42 + 2) = v329;
                v42[24] = v32;
                if (v33 == v37)
                {
                  int64x2_t v45 = vdupq_n_s64(v33);
                  uint64_t v43 = &v41[32 * v38];
                  a2 = v36;
                  uint64_t v19 = v295;
                }
                else
                {
                  uint64_t v43 = &v41[32 * v38];
                  a2 = v36;
                  uint64_t v19 = v295;
                  do
                  {
                    long long v44 = *(_OWORD *)(v33 - 32);
                    *((void *)v43 - 2) = *(void *)(v33 - 16);
                    *((_OWORD *)v43 - 2) = v44;
                    *(void *)(v33 - 24) = 0;
                    *(void *)(v33 - ++*(_DWORD *)(this + 16) = 0;
                    *(void *)(v33 - 32) = 0;
                    *(v43 - ++*(_DWORD *)(this + 8) = *(unsigned char *)(v33 - 8);
                    v43 -= 32;
                    v33 -= 32;
                  }
                  while (v33 != v37);
                  int64x2_t v45 = v312;
                  long long v34 = v313;
                }
                unint64_t v35 = (unint64_t)(v42 + 32);
                v312.i64[0] = (uint64_t)v43;
                v312.i64[1] = (uint64_t)(v42 + 32);
                int64x2_t v332 = v45;
                uint64_t v313 = &v41[32 * v40];
                char v333 = v34;
                p_dst = (std::string *)v45.i64[0];
                sub_1CD573B00((uint64_t)&p_dst);
                uint64_t v6 = (uint64_t *)((char *)this + 56);
              }
              else
              {
                *(_OWORD *)v312.i64[1] = __dst;
                *(void *)(v33 + ++*(_DWORD *)(this + 16) = v329;
                *(unsigned char *)(v33 + 24) = v32;
                unint64_t v35 = v33 + 32;
              }
              v312.i64[1] = v35;
              unint64_t v2 = v298;
              if (v340.__r_.__value_.__s.__data_[16])
              {
                std::string::size_type v46 = v340.__r_.__value_.__r.__words[0];
                v340.__r_.__value_.__r.__words[0] = 0;
                if (v46) {
                  (*(void (**)(std::string::size_type))(*(void *)v46 + 8))(v46);
                }
              }
              if (v339.__r_.__value_.__s.__data_[8])
              {
                std::string::size_type v47 = v339.__r_.__value_.__r.__words[0];
                v339.__r_.__value_.__r.__words[0] = 0;
                if (v47) {
                  (*(void (**)(std::string::size_type))(*(void *)v47 + 8))(v47);
                }
              }
              (*(void (**)(uint64_t, unint64_t *))(*(void *)v310 + 24))(v310, &v309);
              if (v309 == v19) {
                goto LABEL_366;
              }
            }
          }
LABEL_365:
          uint64_t v222 = v335[0];
          v335[0] = 0;
          *(unsigned char *)(a2 + 24) |= 1u;
          *(void *)a2 = v222;
          goto LABEL_368;
        }
      }
LABEL_364:
      *(unsigned char *)(a2 + 24) &= ~1u;
      *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
      *(void *)(a2 + ++*(_DWORD *)(this + 16) = 0;
      *(void *)a2 = 0;
      int64x2_t v332 = 0uLL;
      p_dst = 0;
      *(void *)&long long __dst = &p_dst;
      sub_1CC658304((void ***)&__dst);
      return;
    }
    if (v5 == 14)
    {
      unint64_t v115 = v302;
      uint64_t v116 = v303;
      uint64_t v117 = v304;
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::sections((void *)this + 7, (uint64_t)&v337);
      if (!v338) {
        goto LABEL_364;
      }
      uint64_t v118 = 0;
      uint64_t v119 = 0;
      uint64_t v120 = 0;
      uint64_t v121 = v338 << 6;
      std::string::size_type v122 = (int *)(v337 + 4);
      do
      {
        int v123 = *v122;
        if (*v122 == 1879048190) {
          unint64_t v124 = v122 - 1;
        }
        else {
          unint64_t v124 = (int *)v119;
        }
        if (v123 == 1879048189) {
          long long v125 = v122 - 1;
        }
        else {
          long long v125 = (int *)v120;
        }
        if (v123 == 1879048189) {
          unint64_t v124 = (int *)v119;
        }
        if (v123 == 1879048191)
        {
          uint64_t v118 = v122 - 1;
        }
        else
        {
          uint64_t v120 = (uint64_t)v125;
          uint64_t v119 = (uint64_t)v124;
        }
        v122 += 16;
        v121 -= 64;
      }
      while (v121);
      if (!v118) {
        goto LABEL_364;
      }
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::loadVersionMap((void *)this + 7, v119, v120, (uint64_t)v335);
      if (v336) {
        goto LABEL_365;
      }
      uint64_t v17 = 0;
      uint64_t v313 = 0;
      int64x2_t v18 = 0uLL;
      int64x2_t v312 = 0u;
      uint64_t v310 = v116;
      uint64_t v311 = 0;
      unint64_t v309 = v115;
      if (v115 == v117) {
        goto LABEL_367;
      }
      uint64_t v300 = v117;
      while (1)
      {
        unsigned int v126 = ++v311;
        if (*((void *)v118 + 7) != 2)
        {
          sub_1CD6D0838(v6, (uint64_t)v118, (char *)&v340);
          int v261 = std::string::insert(&v340, 0, "section ");
          std::string::size_type v262 = v261->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v261->__r_.__value_.__l.__data_;
          v316.__r_.__value_.__r.__words[2] = v262;
          v261->__r_.__value_.__l.__size_ = 0;
          v261->__r_.__value_.__r.__words[2] = 0;
          v261->__r_.__value_.__r.__words[0] = 0;
          uint64_t v263 = std::string::append(&v316, " has invalid sh_entsize: expected ");
          std::string::size_type v264 = v263->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v263->__r_.__value_.__l.__data_;
          __p.__r_.__value_.__r.__words[2] = v264;
          v263->__r_.__value_.__l.__size_ = 0;
          v263->__r_.__value_.__r.__words[2] = 0;
          v263->__r_.__value_.__r.__words[0] = 0;
          v318.__r_.__value_.__r.__words[0] = 2;
          p_p = &__p;
          *(void *)&long long v324 = &v318;
          __int16 v325 = 2564;
          *(void *)&long long __dst = &p_p;
          uint64_t v329 = (std::string *)", but got ";
          __int16 v330 = 770;
          v315.__r_.__value_.__r.__words[0] = *((void *)v118 + 7);
          p_dst = (std::string *)&__dst;
          v332.i64[1] = (uint64_t)&v315;
          LOWORD(v334) = 3074;
          operator new();
        }
        uint64_t v128 = *((void *)v118 + 3);
        std::string::size_type v127 = *((void *)v118 + 4);
        *(void *)&long long v307 = v128;
        std::string::size_type v321 = v127;
        if (v127)
        {
          sub_1CD6D0838(v6, (uint64_t)v118, (char *)&v318);
          uint64_t v269 = std::string::insert(&v318, 0, "section ");
          std::string::size_type v270 = v269->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v340.__r_.__value_.__l.__data_ = *(_OWORD *)&v269->__r_.__value_.__l.__data_;
          v340.__r_.__value_.__r.__words[2] = v270;
          v269->__r_.__value_.__l.__size_ = 0;
          v269->__r_.__value_.__r.__words[2] = 0;
          v269->__r_.__value_.__r.__words[0] = 0;
          uint64_t v271 = std::string::append(&v340, " has an invalid sh_size (");
          std::string::size_type v272 = v271->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v271->__r_.__value_.__l.__data_;
          v316.__r_.__value_.__r.__words[2] = v272;
          v271->__r_.__value_.__l.__size_ = 0;
          v271->__r_.__value_.__r.__words[2] = 0;
          v271->__r_.__value_.__r.__words[0] = 0;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
          __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v321;
          __int16 v320 = 3076;
          p_p = &__p;
          *(void *)&long long v324 = ") which is not a multiple of its sh_entsize (";
          __int16 v325 = 770;
          v315.__r_.__value_.__r.__words[0] = *((void *)v118 + 7);
          *(void *)&long long __dst = &p_p;
          uint64_t v329 = &v315;
          __int16 v330 = 3074;
          int v273 = ")";
          goto LABEL_386;
        }
        if (__CFADD__(v128, v127))
        {
          sub_1CD6D0838(v6, (uint64_t)v118, (char *)&v318);
          unsigned __int8 v279 = std::string::insert(&v318, 0, "section ");
          std::string::size_type v280 = v279->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v340.__r_.__value_.__l.__data_ = *(_OWORD *)&v279->__r_.__value_.__l.__data_;
          v340.__r_.__value_.__r.__words[2] = v280;
          v279->__r_.__value_.__l.__size_ = 0;
          v279->__r_.__value_.__r.__words[2] = 0;
          v279->__r_.__value_.__r.__words[0] = 0;
          uint64_t v281 = std::string::append(&v340, " has a sh_offset (0x");
          std::string::size_type v282 = v281->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v281->__r_.__value_.__l.__data_;
          v316.__r_.__value_.__r.__words[2] = v282;
          v281->__r_.__value_.__l.__size_ = 0;
          v281->__r_.__value_.__r.__words[2] = 0;
          v281->__r_.__value_.__r.__words[0] = 0;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
          __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v307;
          __int16 v320 = 3588;
          p_p = &__p;
          *(void *)&long long v324 = ") + sh_size (0x";
          __int16 v325 = 770;
          *(void *)&long long __dst = &p_p;
          uint64_t v329 = (std::string *)&v321;
          __int16 v330 = 3586;
          int v273 = ") that cannot be represented";
LABEL_386:
          p_dst = (std::string *)&__dst;
          v332.i64[1] = (uint64_t)v273;
          LOWORD(v334) = 770;
          operator new();
        }
        if (v127 + v128 > *((void *)this + 8))
        {
          sub_1CD6D0838(v6, (uint64_t)v118, (char *)&v339);
          uint64_t v287 = std::string::insert(&v339, 0, "section ");
          std::string::size_type v288 = v287->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v315.__r_.__value_.__l.__data_ = *(_OWORD *)&v287->__r_.__value_.__l.__data_;
          v315.__r_.__value_.__r.__words[2] = v288;
          v287->__r_.__value_.__l.__size_ = 0;
          v287->__r_.__value_.__r.__words[2] = 0;
          v287->__r_.__value_.__r.__words[0] = 0;
          uint64_t v289 = std::string::append(&v315, " has a sh_offset (0x");
          std::string::size_type v290 = v289->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v318.__r_.__value_.__l.__data_ = *(_OWORD *)&v289->__r_.__value_.__l.__data_;
          v318.__r_.__value_.__r.__words[2] = v290;
          v289->__r_.__value_.__l.__size_ = 0;
          v289->__r_.__value_.__r.__words[2] = 0;
          v289->__r_.__value_.__r.__words[0] = 0;
          v340.__r_.__value_.__r.__words[0] = (std::string::size_type)&v318;
          v340.__r_.__value_.__r.__words[2] = (std::string::size_type)&v307;
          __int16 v341 = 3588;
          v316.__r_.__value_.__r.__words[0] = (std::string::size_type)&v340;
          v316.__r_.__value_.__r.__words[2] = (std::string::size_type)") + sh_size (0x";
          __int16 v317 = 770;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
          __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v321;
          __int16 v320 = 3586;
          p_p = &__p;
          *(void *)&long long v324 = ") that is greater than the file size (0x";
          __int16 v325 = 770;
          uint64_t v314 = *((void *)this + 8);
          *(void *)&long long __dst = &p_p;
          uint64_t v329 = (std::string *)&v314;
          __int16 v330 = 3586;
          p_dst = (std::string *)&__dst;
          v332.i64[1] = (uint64_t)")";
          LOWORD(v334) = 770;
          operator new();
        }
        uint64_t v129 = v126;
        if (v126 >= v127 >> 1)
        {
          v316.__r_.__value_.__r.__words[0] = 2 * v126;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"can't read an entry at 0x";
          __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v316;
          __int16 v320 = 3587;
          p_p = &__p;
          *(void *)&long long v324 = ": it goes past the end of the section (0x";
          __int16 v325 = 770;
          v340.__r_.__value_.__r.__words[0] = v127;
          *(void *)&long long __dst = &p_p;
          uint64_t v329 = &v340;
          __int16 v330 = 3586;
          p_dst = (std::string *)&__dst;
          v332.i64[1] = (uint64_t)")";
          LOWORD(v334) = 770;
          operator new();
        }
        uint64_t v130 = *v6;
        (*(void (**)(std::string *__return_ptr))(*(void *)v310 + 40))(&v339);
        if (v339.__r_.__value_.__s.__data_[8])
        {
          p_p = (std::string *)"unable to read flags for symbol with index ";
          *(void *)&long long v324 = &v311;
          __int16 v325 = 2563;
          *(void *)&long long __dst = &p_p;
          uint64_t v329 = (std::string *)": ";
          __int16 v330 = 770;
          std::string::size_type v154 = v339.__r_.__value_.__r.__words[0];
          v339.__r_.__value_.__r.__words[0] = 0;
          std::string::size_type v306 = v154;
          sub_1CD4FB504((uint64_t *)&v306, &__p);
          char v155 = v330;
          if ((_BYTE)v330)
          {
            if (v330 == 1)
            {
              p_dst = &__p;
              char v156 = 1;
              char v155 = 4;
            }
            else
            {
              if (HIBYTE(v330) != 1) {
                char v155 = 2;
              }
              long long v160 = (void **)&__dst;
              if (HIBYTE(v330) == 1) {
                long long v160 = (void **)__dst;
              }
              p_dst = (std::string *)v160;
              v332.i64[0] = *((void *)&__dst + 1);
              v332.i64[1] = (uint64_t)&__p;
              char v156 = 4;
            }
          }
          else
          {
            char v156 = 1;
          }
          LOBYTE(v334) = v155;
          BYTE1(v334) = v156;
          operator new();
        }
        LOBYTE(v314) = 0;
        unint64_t v115 = v115 & 0xFFFFFFFFFFFF0000 | v339.__r_.__value_.__s.__data_[0] & 1 | 0x100;
        llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSymbolVersionByIndex(*(_WORD *)(v130 + v128 + 2 * v129), &v314, (uint64_t)v335, v115, (uint64_t)&v340);
        if (v340.__r_.__value_.__s.__data_[16])
        {
          v316.__r_.__value_.__r.__words[0] = (std::string::size_type)"unable to get a version for entry ";
          v316.__r_.__value_.__r.__words[2] = (std::string::size_type)&v311;
          __int16 v317 = 2563;
          __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
          __p.__r_.__value_.__r.__words[2] = (std::string::size_type)" of ";
          __int16 v320 = 770;
          sub_1CCC327FC(&v318, v6, (uint64_t)v118);
          char v157 = v320;
          if (v320 == 1)
          {
            size_t v161 = &v318;
            p_p = &v318;
            long long v324 = v307;
            __int16 v325 = 260;
            int v326 = v321;
            __int16 v327 = WORD2(v321);
            char v158 = 4;
            uint64_t v162 = size;
          }
          else
          {
            if (!(_BYTE)v320)
            {
              char v158 = 0;
              __int16 v325 = 256;
              char v159 = 1;
              goto LABEL_261;
            }
            size_t v161 = (std::string *)&p_p;
            uint64_t v163 = (std::string *)__p.__r_.__value_.__r.__words[0];
            char v158 = 2;
            if (HIBYTE(v320) != 1)
            {
              char v157 = 2;
              uint64_t v163 = &__p;
            }
            p_p = v163;
            std::string::size_type size = __p.__r_.__value_.__l.__size_;
            *(void *)&long long v324 = &v318;
            LOBYTE(v325) = v157;
            uint64_t v162 = 4;
            HIBYTE(v325) = 4;
          }
          *(void *)&long long __dst = v161;
          *((void *)&__dst + 1) = v162;
          char v159 = 3;
          uint64_t v329 = (std::string *)": ";
LABEL_261:
          LOBYTE(v330) = v158;
          HIBYTE(v330) = v159;
          if (v340.__r_.__value_.__s.__data_[16])
          {
            std::string::size_type v164 = v340.__r_.__value_.__r.__words[0];
            v340.__r_.__value_.__r.__words[0] = 0;
          }
          else
          {
            std::string::size_type v164 = 0;
          }
          std::string::size_type v305 = v164;
          sub_1CD4FB504((uint64_t *)&v305, &v315);
          char v165 = v330;
          if ((_BYTE)v330)
          {
            if (v330 == 1)
            {
              p_dst = &v315;
              char v166 = 1;
              char v165 = 4;
            }
            else
            {
              if (HIBYTE(v330) != 1) {
                char v165 = 2;
              }
              unint64_t v167 = (void **)&__dst;
              if (HIBYTE(v330) == 1) {
                unint64_t v167 = (void **)__dst;
              }
              p_dst = (std::string *)v167;
              v332.i64[0] = *((void *)&__dst + 1);
              v332.i64[1] = (uint64_t)&v315;
              char v166 = 4;
            }
          }
          else
          {
            char v166 = 1;
          }
          LOBYTE(v334) = v165;
          BYTE1(v334) = v166;
          operator new();
        }
        uint64_t v131 = (const void *)v340.__r_.__value_.__r.__words[0];
        if (!v340.__r_.__value_.__r.__words[0])
        {
          uint64_t v134 = a2;
          long long __dst = 0uLL;
          uint64_t v329 = 0;
          goto LABEL_220;
        }
        std::string::size_type v132 = v340.__r_.__value_.__l.__size_;
        if (v340.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_393;
        }
        if (v340.__r_.__value_.__l.__size_ >= 0x17) {
          break;
        }
        HIBYTE(v329) = v340.__r_.__value_.__s.__data_[8];
        int v133 = &__dst;
        if (v340.__r_.__value_.__l.__size_) {
          goto LABEL_218;
        }
        uint64_t v134 = a2;
LABEL_219:
        *((unsigned char *)v133 + v132) = 0;
LABEL_220:
        char v138 = v314;
        unint64_t v139 = v312.u64[1];
        unsigned int v140 = v313;
        if (v312.i64[1] >= (unint64_t)v313)
        {
          uint64_t v143 = v312.i64[0];
          uint64_t v144 = (v312.i64[1] - v312.i64[0]) >> 5;
          unint64_t v145 = v144 + 1;
          if ((unint64_t)(v144 + 1) >> 59) {
            goto LABEL_393;
          }
          if ((uint64_t)&v313[-v312.i64[0]] >> 4 > v145) {
            unint64_t v145 = (uint64_t)&v313[-v312.i64[0]] >> 4;
          }
          if ((unint64_t)&v313[-v312.i64[0]] >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v146 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v146 = v145;
          }
          char v333 = 0;
          __int16 v334 = &v313;
          if (v146 >> 59) {
            goto LABEL_394;
          }
          uint64_t v147 = (char *)operator new(32 * v146);
          unint64_t v148 = &v147[32 * v144];
          *(_OWORD *)unint64_t v148 = __dst;
          *((void *)v148 + 2) = v329;
          v148[24] = v138;
          if (v139 == v143)
          {
            int64x2_t v151 = vdupq_n_s64(v139);
            unint64_t v149 = &v147[32 * v144];
            a2 = v134;
          }
          else
          {
            unint64_t v149 = &v147[32 * v144];
            a2 = v134;
            do
            {
              long long v150 = *(_OWORD *)(v139 - 32);
              *((void *)v149 - 2) = *(void *)(v139 - 16);
              *((_OWORD *)v149 - 2) = v150;
              *(void *)(v139 - 24) = 0;
              *(void *)(v139 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v139 - 32) = 0;
              *(v149 - ++*(_DWORD *)(this + 8) = *(unsigned char *)(v139 - 8);
              v149 -= 32;
              v139 -= 32;
            }
            while (v139 != v143);
            int64x2_t v151 = v312;
            unsigned int v140 = v313;
          }
          uint64_t v142 = v300;
          unint64_t v141 = (unint64_t)(v148 + 32);
          v312.i64[0] = (uint64_t)v149;
          v312.i64[1] = (uint64_t)(v148 + 32);
          int64x2_t v332 = v151;
          uint64_t v313 = &v147[32 * v146];
          char v333 = v140;
          p_dst = (std::string *)v151.i64[0];
          sub_1CD573B00((uint64_t)&p_dst);
          uint64_t v6 = (uint64_t *)((char *)this + 56);
        }
        else
        {
          *(_OWORD *)v312.i64[1] = __dst;
          *(void *)(v139 + ++*(_DWORD *)(this + 16) = v329;
          *(unsigned char *)(v139 + 24) = v138;
          unint64_t v141 = v139 + 32;
          a2 = v134;
          uint64_t v142 = v300;
        }
        v312.i64[1] = v141;
        if (v340.__r_.__value_.__s.__data_[16])
        {
          std::string::size_type v152 = v340.__r_.__value_.__r.__words[0];
          v340.__r_.__value_.__r.__words[0] = 0;
          if (v152) {
            (*(void (**)(std::string::size_type))(*(void *)v152 + 8))(v152);
          }
        }
        if (v339.__r_.__value_.__s.__data_[8])
        {
          std::string::size_type v153 = v339.__r_.__value_.__r.__words[0];
          v339.__r_.__value_.__r.__words[0] = 0;
          if (v153) {
            (*(void (**)(std::string::size_type))(*(void *)v153 + 8))(v153);
          }
        }
        (*(void (**)(uint64_t, unint64_t *))(*(void *)v310 + 24))(v310, &v309);
        if (v309 == v142) {
          goto LABEL_366;
        }
      }
      std::string::size_type v135 = (v340.__r_.__value_.__l.__size_ & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v340.__r_.__value_.__l.__size_ | 7) != 0x17) {
        std::string::size_type v135 = v340.__r_.__value_.__l.__size_ | 7;
      }
      std::string::size_type v136 = v135 + 1;
      int v133 = (long long *)operator new(v135 + 1);
      unint64_t v137 = v136 | 0x8000000000000000;
      uint64_t v6 = (uint64_t *)((char *)this + 56);
      *((void *)&__dst + 1) = v132;
      uint64_t v329 = (std::string *)v137;
      *(void *)&long long __dst = v133;
LABEL_218:
      uint64_t v134 = a2;
      memmove(v133, v131, v132);
      goto LABEL_219;
    }
    unint64_t v168 = v302;
    uint64_t v169 = v303;
    uint64_t v297 = v304;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::sections((void *)this + 7, (uint64_t)&v337);
    if (!v338) {
      goto LABEL_364;
    }
    unint64_t v170 = 0;
    uint64_t v171 = 0;
    uint64_t v172 = 0;
    uint64_t v173 = v338 << 6;
    unsigned int v174 = (int *)(v337 + 4);
    do
    {
      int v175 = *v174;
      if (*v174 == -16777361) {
        unint64_t v176 = v174 - 1;
      }
      else {
        unint64_t v176 = (int *)v171;
      }
      if (v175 == -33554577) {
        uint64_t v177 = v174 - 1;
      }
      else {
        uint64_t v177 = (int *)v172;
      }
      if (v175 == -33554577) {
        unint64_t v176 = (int *)v171;
      }
      if (v175 == -145)
      {
        unint64_t v170 = (unint64_t *)(v174 - 1);
      }
      else
      {
        uint64_t v172 = (uint64_t)v177;
        uint64_t v171 = (uint64_t)v176;
      }
      v174 += 16;
      v173 -= 64;
    }
    while (v173);
    if (!v170) {
      goto LABEL_364;
    }
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::loadVersionMap((void *)this + 7, v171, v172, (uint64_t)v335);
    if (v336) {
      goto LABEL_365;
    }
    uint64_t v17 = 0;
    uint64_t v313 = 0;
    int64x2_t v18 = 0uLL;
    int64x2_t v312 = 0u;
    uint64_t v310 = v169;
    uint64_t v311 = 0;
    unint64_t v309 = v168;
    if (v168 == v297) {
      goto LABEL_367;
    }
    uint64_t v178 = v297;
    while (1)
    {
      unsigned int v179 = ++v311;
      if (v170[7] != 0x200000000000000)
      {
        sub_1CD6D3754(v6, (uint64_t)v170, (char *)&v340);
        char v265 = std::string::insert(&v340, 0, "section ");
        std::string::size_type v266 = v265->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v265->__r_.__value_.__l.__data_;
        v316.__r_.__value_.__r.__words[2] = v266;
        v265->__r_.__value_.__l.__size_ = 0;
        v265->__r_.__value_.__r.__words[2] = 0;
        v265->__r_.__value_.__r.__words[0] = 0;
        int v267 = std::string::append(&v316, " has invalid sh_entsize: expected ");
        std::string::size_type v268 = v267->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v267->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v268;
        v267->__r_.__value_.__l.__size_ = 0;
        v267->__r_.__value_.__r.__words[2] = 0;
        v267->__r_.__value_.__r.__words[0] = 0;
        v318.__r_.__value_.__r.__words[0] = 2;
        p_p = &__p;
        *(void *)&long long v324 = &v318;
        __int16 v325 = 2564;
        *(void *)&long long __dst = &p_p;
        uint64_t v329 = (std::string *)", but got ";
        __int16 v330 = 770;
        v315.__r_.__value_.__r.__words[0] = bswap64(v170[7]);
        p_dst = (std::string *)&__dst;
        v332.i64[1] = (uint64_t)&v315;
        LOWORD(v334) = 3074;
        operator new();
      }
      unint64_t v180 = v170[4];
      unint64_t v181 = bswap64(v170[3]);
      *(void *)&long long v307 = v181;
      unint64_t v182 = bswap64(v180);
      std::string::size_type v321 = v182;
      if (v182)
      {
        sub_1CD6D3754(v6, (uint64_t)v170, (char *)&v318);
        uint64_t v274 = std::string::insert(&v318, 0, "section ");
        std::string::size_type v275 = v274->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v340.__r_.__value_.__l.__data_ = *(_OWORD *)&v274->__r_.__value_.__l.__data_;
        v340.__r_.__value_.__r.__words[2] = v275;
        v274->__r_.__value_.__l.__size_ = 0;
        v274->__r_.__value_.__r.__words[2] = 0;
        v274->__r_.__value_.__r.__words[0] = 0;
        uint64_t v276 = std::string::append(&v340, " has an invalid sh_size (");
        std::string::size_type v277 = v276->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v276->__r_.__value_.__l.__data_;
        v316.__r_.__value_.__r.__words[2] = v277;
        v276->__r_.__value_.__l.__size_ = 0;
        v276->__r_.__value_.__r.__words[2] = 0;
        v276->__r_.__value_.__r.__words[0] = 0;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
        __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v321;
        __int16 v320 = 3076;
        p_p = &__p;
        *(void *)&long long v324 = ") which is not a multiple of its sh_entsize (";
        __int16 v325 = 770;
        v315.__r_.__value_.__r.__words[0] = bswap64(v170[7]);
        *(void *)&long long __dst = &p_p;
        uint64_t v329 = &v315;
        __int16 v330 = 3074;
        __int16 v278 = ")";
        goto LABEL_388;
      }
      if (__CFADD__(v181, v182))
      {
        sub_1CD6D3754(v6, (uint64_t)v170, (char *)&v318);
        long long v283 = std::string::insert(&v318, 0, "section ");
        std::string::size_type v284 = v283->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v340.__r_.__value_.__l.__data_ = *(_OWORD *)&v283->__r_.__value_.__l.__data_;
        v340.__r_.__value_.__r.__words[2] = v284;
        v283->__r_.__value_.__l.__size_ = 0;
        v283->__r_.__value_.__r.__words[2] = 0;
        v283->__r_.__value_.__r.__words[0] = 0;
        long long v285 = std::string::append(&v340, " has a sh_offset (0x");
        std::string::size_type v286 = v285->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v285->__r_.__value_.__l.__data_;
        v316.__r_.__value_.__r.__words[2] = v286;
        v285->__r_.__value_.__l.__size_ = 0;
        v285->__r_.__value_.__r.__words[2] = 0;
        v285->__r_.__value_.__r.__words[0] = 0;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
        __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v307;
        __int16 v320 = 3588;
        p_p = &__p;
        *(void *)&long long v324 = ") + sh_size (0x";
        __int16 v325 = 770;
        *(void *)&long long __dst = &p_p;
        uint64_t v329 = (std::string *)&v321;
        __int16 v330 = 3586;
        __int16 v278 = ") that cannot be represented";
LABEL_388:
        p_dst = (std::string *)&__dst;
        v332.i64[1] = (uint64_t)v278;
        LOWORD(v334) = 770;
        operator new();
      }
      if (v182 + v181 > *((void *)this + 8))
      {
        sub_1CD6D3754(v6, (uint64_t)v170, (char *)&v339);
        int v291 = std::string::insert(&v339, 0, "section ");
        std::string::size_type v292 = v291->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v315.__r_.__value_.__l.__data_ = *(_OWORD *)&v291->__r_.__value_.__l.__data_;
        v315.__r_.__value_.__r.__words[2] = v292;
        v291->__r_.__value_.__l.__size_ = 0;
        v291->__r_.__value_.__r.__words[2] = 0;
        v291->__r_.__value_.__r.__words[0] = 0;
        uint64_t v293 = std::string::append(&v315, " has a sh_offset (0x");
        std::string::size_type v294 = v293->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v318.__r_.__value_.__l.__data_ = *(_OWORD *)&v293->__r_.__value_.__l.__data_;
        v318.__r_.__value_.__r.__words[2] = v294;
        v293->__r_.__value_.__l.__size_ = 0;
        v293->__r_.__value_.__r.__words[2] = 0;
        v293->__r_.__value_.__r.__words[0] = 0;
        v340.__r_.__value_.__r.__words[0] = (std::string::size_type)&v318;
        v340.__r_.__value_.__r.__words[2] = (std::string::size_type)&v307;
        __int16 v341 = 3588;
        v316.__r_.__value_.__r.__words[0] = (std::string::size_type)&v340;
        v316.__r_.__value_.__r.__words[2] = (std::string::size_type)") + sh_size (0x";
        __int16 v317 = 770;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
        __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v321;
        __int16 v320 = 3586;
        p_p = &__p;
        *(void *)&long long v324 = ") that is greater than the file size (0x";
        __int16 v325 = 770;
        uint64_t v314 = *((void *)this + 8);
        *(void *)&long long __dst = &p_p;
        uint64_t v329 = (std::string *)&v314;
        __int16 v330 = 3586;
        p_dst = (std::string *)&__dst;
        v332.i64[1] = (uint64_t)")";
        LOWORD(v334) = 770;
        operator new();
      }
      uint64_t v183 = v179;
      if (v179 >= v182 >> 1)
      {
        v316.__r_.__value_.__r.__words[0] = 2 * v179;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"can't read an entry at 0x";
        __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v316;
        __int16 v320 = 3587;
        p_p = &__p;
        *(void *)&long long v324 = ": it goes past the end of the section (0x";
        __int16 v325 = 770;
        v340.__r_.__value_.__r.__words[0] = v182;
        *(void *)&long long __dst = &p_p;
        uint64_t v329 = &v340;
        __int16 v330 = 3586;
        p_dst = (std::string *)&__dst;
        v332.i64[1] = (uint64_t)")";
        LOWORD(v334) = 770;
        operator new();
      }
      uint64_t v184 = *v6;
      (*(void (**)(std::string *__return_ptr))(*(void *)v310 + 40))(&v339);
      if (v339.__r_.__value_.__s.__data_[8])
      {
        p_p = (std::string *)"unable to read flags for symbol with index ";
        *(void *)&long long v324 = &v311;
        __int16 v325 = 2563;
        *(void *)&long long __dst = &p_p;
        uint64_t v329 = (std::string *)": ";
        __int16 v330 = 770;
        std::string::size_type v208 = v339.__r_.__value_.__r.__words[0];
        v339.__r_.__value_.__r.__words[0] = 0;
        std::string::size_type v308 = v208;
        sub_1CD4FB504((uint64_t *)&v308, &__p);
        char v209 = v330;
        if ((_BYTE)v330)
        {
          if (v330 == 1)
          {
            p_dst = &__p;
            char v210 = 1;
            char v209 = 4;
          }
          else
          {
            if (HIBYTE(v330) != 1) {
              char v209 = 2;
            }
            uint64_t v214 = (void **)&__dst;
            if (HIBYTE(v330) == 1) {
              uint64_t v214 = (void **)__dst;
            }
            p_dst = (std::string *)v214;
            v332.i64[0] = *((void *)&__dst + 1);
            v332.i64[1] = (uint64_t)&__p;
            char v210 = 4;
          }
        }
        else
        {
          char v210 = 1;
        }
        LOBYTE(v334) = v209;
        BYTE1(v334) = v210;
        operator new();
      }
      LOBYTE(v314) = 0;
      unint64_t v185 = v2 & 0xFFFFFFFFFFFF0000 | v339.__r_.__value_.__s.__data_[0] & 1 | 0x100;
      llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSymbolVersionByIndex(bswap32(*(unsigned __int16 *)(v184 + v181 + 2 * v183)) >> 16, &v314, (uint64_t)v335, v185, (uint64_t)&v340);
      if (v340.__r_.__value_.__s.__data_[16])
      {
        v316.__r_.__value_.__r.__words[0] = (std::string::size_type)"unable to get a version for entry ";
        v316.__r_.__value_.__r.__words[2] = (std::string::size_type)&v311;
        __int16 v317 = 2563;
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
        __p.__r_.__value_.__r.__words[2] = (std::string::size_type)" of ";
        __int16 v320 = 770;
        sub_1CCC39014(&v318, v6, (uint64_t)v170);
        char v211 = v320;
        if (v320 == 1)
        {
          size_t v215 = &v318;
          p_p = &v318;
          long long v324 = v307;
          __int16 v325 = 260;
          int v326 = v321;
          __int16 v327 = WORD2(v321);
          char v212 = 4;
          uint64_t v216 = size;
        }
        else
        {
          if (!(_BYTE)v320)
          {
            char v212 = 0;
            __int16 v325 = 256;
            char v213 = 1;
            goto LABEL_351;
          }
          size_t v215 = (std::string *)&p_p;
          uint64_t v217 = (std::string *)__p.__r_.__value_.__r.__words[0];
          char v212 = 2;
          if (HIBYTE(v320) != 1)
          {
            char v211 = 2;
            uint64_t v217 = &__p;
          }
          p_p = v217;
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
          *(void *)&long long v324 = &v318;
          LOBYTE(v325) = v211;
          uint64_t v216 = 4;
          HIBYTE(v325) = 4;
        }
        *(void *)&long long __dst = v215;
        *((void *)&__dst + 1) = v216;
        char v213 = 3;
        uint64_t v329 = (std::string *)": ";
LABEL_351:
        LOBYTE(v330) = v212;
        HIBYTE(v330) = v213;
        if (v340.__r_.__value_.__s.__data_[16])
        {
          std::string::size_type v218 = v340.__r_.__value_.__r.__words[0];
          v340.__r_.__value_.__r.__words[0] = 0;
        }
        else
        {
          std::string::size_type v218 = 0;
        }
        std::string::size_type v306 = v218;
        sub_1CD4FB504((uint64_t *)&v306, &v315);
        char v219 = v330;
        if ((_BYTE)v330)
        {
          if (v330 == 1)
          {
            p_dst = &v315;
            char v220 = 1;
            char v219 = 4;
          }
          else
          {
            if (HIBYTE(v330) != 1) {
              char v219 = 2;
            }
            unint64_t v221 = (void **)&__dst;
            if (HIBYTE(v330) == 1) {
              unint64_t v221 = (void **)__dst;
            }
            p_dst = (std::string *)v221;
            v332.i64[0] = *((void *)&__dst + 1);
            v332.i64[1] = (uint64_t)&v315;
            char v220 = 4;
          }
        }
        else
        {
          char v220 = 1;
        }
        LOBYTE(v334) = v219;
        BYTE1(v334) = v220;
        operator new();
      }
      long long v186 = (const void *)v340.__r_.__value_.__r.__words[0];
      unint64_t v301 = v185;
      if (!v340.__r_.__value_.__r.__words[0])
      {
        long long __dst = 0uLL;
        uint64_t v329 = 0;
        goto LABEL_310;
      }
      std::string::size_type v187 = v340.__r_.__value_.__l.__size_;
      if (v340.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_393;
      }
      if (v340.__r_.__value_.__l.__size_ >= 0x17)
      {
        std::string::size_type v189 = (v340.__r_.__value_.__l.__size_ & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v340.__r_.__value_.__l.__size_ | 7) != 0x17) {
          std::string::size_type v189 = v340.__r_.__value_.__l.__size_ | 7;
        }
        std::string::size_type v190 = v189 + 1;
        uint64_t v188 = (long long *)operator new(v189 + 1);
        unint64_t v191 = v190 | 0x8000000000000000;
        uint64_t v6 = (uint64_t *)((char *)this + 56);
        *((void *)&__dst + 1) = v187;
        uint64_t v329 = (std::string *)v191;
        *(void *)&long long __dst = v188;
      }
      else
      {
        HIBYTE(v329) = v340.__r_.__value_.__s.__data_[8];
        uint64_t v188 = &__dst;
        if (!v340.__r_.__value_.__l.__size_) {
          goto LABEL_309;
        }
      }
      memmove(v188, v186, v187);
LABEL_309:
      *((unsigned char *)v188 + v187) = 0;
LABEL_310:
      char v192 = v314;
      unint64_t v193 = v312.u64[1];
      int v194 = v313;
      if (v312.i64[1] >= (unint64_t)v313)
      {
        uint64_t v196 = a2;
        uint64_t v197 = v312.i64[0];
        uint64_t v198 = (v312.i64[1] - v312.i64[0]) >> 5;
        unint64_t v199 = v198 + 1;
        if ((unint64_t)(v198 + 1) >> 59) {
          goto LABEL_393;
        }
        if ((uint64_t)&v313[-v312.i64[0]] >> 4 > v199) {
          unint64_t v199 = (uint64_t)&v313[-v312.i64[0]] >> 4;
        }
        if ((unint64_t)&v313[-v312.i64[0]] >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v200 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v200 = v199;
        }
        char v333 = 0;
        __int16 v334 = &v313;
        if (v200 >> 59) {
          goto LABEL_394;
        }
        unint64_t v201 = (char *)operator new(32 * v200);
        uint64_t v202 = &v201[32 * v198];
        *(_OWORD *)uint64_t v202 = __dst;
        *((void *)v202 + 2) = v329;
        v202[24] = v192;
        if (v193 == v197)
        {
          int64x2_t v205 = vdupq_n_s64(v193);
          __int16 v203 = &v201[32 * v198];
          a2 = v196;
          uint64_t v178 = v297;
        }
        else
        {
          __int16 v203 = &v201[32 * v198];
          a2 = v196;
          uint64_t v178 = v297;
          do
          {
            long long v204 = *(_OWORD *)(v193 - 32);
            *((void *)v203 - 2) = *(void *)(v193 - 16);
            *((_OWORD *)v203 - 2) = v204;
            *(void *)(v193 - 24) = 0;
            *(void *)(v193 - ++*(_DWORD *)(this + 16) = 0;
            *(void *)(v193 - 32) = 0;
            *(v203 - ++*(_DWORD *)(this + 8) = *(unsigned char *)(v193 - 8);
            v203 -= 32;
            v193 -= 32;
          }
          while (v193 != v197);
          int64x2_t v205 = v312;
          int v194 = v313;
        }
        unint64_t v195 = (unint64_t)(v202 + 32);
        v312.i64[0] = (uint64_t)v203;
        v312.i64[1] = (uint64_t)(v202 + 32);
        int64x2_t v332 = v205;
        uint64_t v313 = &v201[32 * v200];
        char v333 = v194;
        p_dst = (std::string *)v205.i64[0];
        sub_1CD573B00((uint64_t)&p_dst);
        uint64_t v6 = (uint64_t *)((char *)this + 56);
      }
      else
      {
        *(_OWORD *)v312.i64[1] = __dst;
        *(void *)(v193 + ++*(_DWORD *)(this + 16) = v329;
        *(unsigned char *)(v193 + 24) = v192;
        unint64_t v195 = v193 + 32;
      }
      v312.i64[1] = v195;
      unint64_t v2 = v301;
      if (v340.__r_.__value_.__s.__data_[16])
      {
        std::string::size_type v206 = v340.__r_.__value_.__r.__words[0];
        v340.__r_.__value_.__r.__words[0] = 0;
        if (v206) {
          (*(void (**)(std::string::size_type))(*(void *)v206 + 8))(v206);
        }
      }
      if (v339.__r_.__value_.__s.__data_[8])
      {
        std::string::size_type v207 = v339.__r_.__value_.__r.__words[0];
        v339.__r_.__value_.__r.__words[0] = 0;
        if (v207) {
          (*(void (**)(std::string::size_type))(*(void *)v207 + 8))(v207);
        }
      }
      (*(void (**)(uint64_t, unint64_t *))(*(void *)v310 + 24))(v310, &v309);
      if (v309 == v178) {
        goto LABEL_366;
      }
    }
  }
  unint64_t v62 = v302;
  uint64_t v63 = v303;
  uint64_t v296 = v304;
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::sections((void *)this + 7, (uint64_t)&v337);
  if (!v338) {
    goto LABEL_364;
  }
  unint64_t v64 = 0;
  uint64_t v65 = 0;
  uint64_t v66 = 0;
  uint64_t v67 = 40 * v338;
  unsigned __int8 v68 = (int *)(v337 + 4);
  do
  {
    int v69 = *v68;
    if (*v68 == 1879048190) {
      uint64_t v70 = v68 - 1;
    }
    else {
      uint64_t v70 = (int *)v65;
    }
    if (v69 == 1879048189) {
      int v71 = v68 - 1;
    }
    else {
      int v71 = (int *)v66;
    }
    if (v69 == 1879048189) {
      uint64_t v70 = (int *)v65;
    }
    if (v69 == 1879048191)
    {
      unint64_t v64 = (unsigned int *)(v68 - 1);
    }
    else
    {
      uint64_t v66 = (uint64_t)v71;
      uint64_t v65 = (uint64_t)v70;
    }
    v68 += 10;
    v67 -= 40;
  }
  while (v67);
  if (!v64) {
    goto LABEL_364;
  }
  llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,false>>::loadVersionMap((void *)this + 7, v65, v66, (uint64_t)v335);
  if (v336) {
    goto LABEL_365;
  }
  uint64_t v17 = 0;
  uint64_t v313 = 0;
  int64x2_t v18 = 0uLL;
  int64x2_t v312 = 0u;
  uint64_t v310 = v63;
  uint64_t v311 = 0;
  unint64_t v309 = v62;
  if (v62 == v296) {
    goto LABEL_367;
  }
  uint64_t v72 = v296;
  do
  {
    unsigned int v73 = ++v311;
    if (v64[9] != 2)
    {
      sub_1CD6C9BF8(v6, (uint64_t)v64, (char *)&v340);
      uint64_t v228 = std::string::insert(&v340, 0, "section ");
      std::string::size_type v229 = v228->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v228->__r_.__value_.__l.__data_;
      v316.__r_.__value_.__r.__words[2] = v229;
      v228->__r_.__value_.__l.__size_ = 0;
      v228->__r_.__value_.__r.__words[2] = 0;
      v228->__r_.__value_.__r.__words[0] = 0;
      long long v230 = std::string::append(&v316, " has invalid sh_entsize: expected ");
      std::string::size_type v231 = v230->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v230->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v231;
      v230->__r_.__value_.__l.__size_ = 0;
      v230->__r_.__value_.__r.__words[2] = 0;
      v230->__r_.__value_.__r.__words[0] = 0;
      v318.__r_.__value_.__r.__words[0] = 2;
      p_p = &__p;
      *(void *)&long long v324 = &v318;
      __int16 v325 = 2564;
      *(void *)&long long __dst = &p_p;
      uint64_t v329 = (std::string *)", but got ";
      __int16 v330 = 770;
      uint64_t v232 = v64[9];
      p_dst = (std::string *)&__dst;
      v332.i64[1] = v232;
      LOWORD(v334) = 2050;
      operator new();
    }
    std::string::size_type v74 = v64[5];
    if (v74)
    {
      sub_1CD6C9BF8(v6, (uint64_t)v64, (char *)&v318);
      uint64_t v239 = std::string::insert(&v318, 0, "section ");
      std::string::size_type v240 = v239->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v340.__r_.__value_.__l.__data_ = *(_OWORD *)&v239->__r_.__value_.__l.__data_;
      v340.__r_.__value_.__r.__words[2] = v240;
      v239->__r_.__value_.__l.__size_ = 0;
      v239->__r_.__value_.__r.__words[2] = 0;
      v239->__r_.__value_.__r.__words[0] = 0;
      size_t v241 = std::string::append(&v340, " has an invalid sh_size (");
      std::string::size_type v242 = v241->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v241->__r_.__value_.__l.__data_;
      v316.__r_.__value_.__r.__words[2] = v242;
      v241->__r_.__value_.__l.__size_ = 0;
      v241->__r_.__value_.__r.__words[2] = 0;
      v241->__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
      __p.__r_.__value_.__r.__words[2] = v74;
      __int16 v320 = 2052;
      p_p = &__p;
      *(void *)&long long v324 = ") which is not a multiple of its sh_entsize (";
      __int16 v325 = 770;
      size_t v243 = (std::string *)v64[9];
      *(void *)&long long __dst = &p_p;
      uint64_t v329 = v243;
      __int16 v330 = 2050;
      uint64_t v244 = ")";
      goto LABEL_376;
    }
    std::string::size_type v75 = v64[4];
    if (__CFADD__(v75, v74))
    {
      sub_1CD6C9BF8(v6, (uint64_t)v64, (char *)&v318);
      int v249 = std::string::insert(&v318, 0, "section ");
      std::string::size_type v250 = v249->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v340.__r_.__value_.__l.__data_ = *(_OWORD *)&v249->__r_.__value_.__l.__data_;
      v340.__r_.__value_.__r.__words[2] = v250;
      v249->__r_.__value_.__l.__size_ = 0;
      v249->__r_.__value_.__r.__words[2] = 0;
      v249->__r_.__value_.__r.__words[0] = 0;
      long long v251 = std::string::append(&v340, " has a sh_offset (0x");
      std::string::size_type v252 = v251->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v316.__r_.__value_.__l.__data_ = *(_OWORD *)&v251->__r_.__value_.__l.__data_;
      v316.__r_.__value_.__r.__words[2] = v252;
      v251->__r_.__value_.__l.__size_ = 0;
      v251->__r_.__value_.__r.__words[2] = 0;
      v251->__r_.__value_.__r.__words[0] = 0;
      v315.__r_.__value_.__r.__words[0] = v75;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v315;
      __int16 v320 = 3588;
      p_p = &__p;
      *(void *)&long long v324 = ") + sh_size (0x";
      __int16 v325 = 770;
      v339.__r_.__value_.__r.__words[0] = v74;
      *(void *)&long long __dst = &p_p;
      uint64_t v329 = &v339;
      __int16 v330 = 3586;
      uint64_t v244 = ") that cannot be represented";
LABEL_376:
      p_dst = (std::string *)&__dst;
      v332.i64[1] = (uint64_t)v244;
      LOWORD(v334) = 770;
      operator new();
    }
    if (*((void *)this + 8) < (unint64_t)(v74 + v75))
    {
      sub_1CD6C9BF8(v6, (uint64_t)v64, (char *)&v339);
      long long v257 = std::string::insert(&v339, 0, "section ");
      std::string::size_type v258 = v257->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v315.__r_.__value_.__l.__data_ = *(_OWORD *)&v257->__r_.__value_.__l.__data_;
      v315.__r_.__value_.__r.__words[2] = v258;
      v257->__r_.__value_.__l.__size_ = 0;
      v257->__r_.__value_.__r.__words[2] = 0;
      v257->__r_.__value_.__r.__words[0] = 0;
      uint64_t v259 = std::string::append(&v315, " has a sh_offset (0x");
      std::string::size_type v260 = v259->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v318.__r_.__value_.__l.__data_ = *(_OWORD *)&v259->__r_.__value_.__l.__data_;
      v318.__r_.__value_.__r.__words[2] = v260;
      v259->__r_.__value_.__l.__size_ = 0;
      v259->__r_.__value_.__r.__words[2] = 0;
      v259->__r_.__value_.__r.__words[0] = 0;
      *(void *)&long long v307 = v75;
      v340.__r_.__value_.__r.__words[0] = (std::string::size_type)&v318;
      v340.__r_.__value_.__r.__words[2] = (std::string::size_type)&v307;
      __int16 v341 = 3588;
      v316.__r_.__value_.__r.__words[0] = (std::string::size_type)&v340;
      v316.__r_.__value_.__r.__words[2] = (std::string::size_type)") + sh_size (0x";
      __int16 v317 = 770;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v321;
      __int16 v320 = 3586;
      std::string::size_type v321 = v74;
      p_p = &__p;
      *(void *)&long long v324 = ") that is greater than the file size (0x";
      __int16 v325 = 770;
      uint64_t v314 = *((void *)this + 8);
      *(void *)&long long __dst = &p_p;
      uint64_t v329 = (std::string *)&v314;
      __int16 v330 = 3586;
      p_dst = (std::string *)&__dst;
      v332.i64[1] = (uint64_t)")";
      LOWORD(v334) = 770;
      operator new();
    }
    uint64_t v76 = v73;
    if (v73 >= v74 >> 1)
    {
      v316.__r_.__value_.__r.__words[0] = 2 * v73;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"can't read an entry at 0x";
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v316;
      __int16 v320 = 3587;
      p_p = &__p;
      *(void *)&long long v324 = ": it goes past the end of the section (0x";
      __int16 v325 = 770;
      v340.__r_.__value_.__r.__words[0] = v74;
      *(void *)&long long __dst = &p_p;
      uint64_t v329 = &v340;
      __int16 v330 = 3586;
      p_dst = (std::string *)&__dst;
      v332.i64[1] = (uint64_t)")";
      LOWORD(v334) = 770;
      operator new();
    }
    uint64_t v77 = *v6;
    (*(void (**)(std::string *__return_ptr))(*(void *)v310 + 40))(&v339);
    if (v339.__r_.__value_.__s.__data_[8])
    {
      p_p = (std::string *)"unable to read flags for symbol with index ";
      *(void *)&long long v324 = &v311;
      __int16 v325 = 2563;
      *(void *)&long long __dst = &p_p;
      uint64_t v329 = (std::string *)": ";
      __int16 v330 = 770;
      std::string::size_type v101 = v339.__r_.__value_.__r.__words[0];
      v339.__r_.__value_.__r.__words[0] = 0;
      std::string::size_type v306 = v101;
      sub_1CD4FB504((uint64_t *)&v306, &__p);
      char v102 = v330;
      if ((_BYTE)v330)
      {
        if (v330 == 1)
        {
          p_dst = &__p;
          char v103 = 1;
          char v102 = 4;
        }
        else
        {
          if (HIBYTE(v330) != 1) {
            char v102 = 2;
          }
          long long v107 = (void **)&__dst;
          if (HIBYTE(v330) == 1) {
            long long v107 = (void **)__dst;
          }
          p_dst = (std::string *)v107;
          v332.i64[0] = *((void *)&__dst + 1);
          v332.i64[1] = (uint64_t)&__p;
          char v103 = 4;
        }
      }
      else
      {
        char v103 = 1;
      }
      LOBYTE(v334) = v102;
      BYTE1(v334) = v103;
      operator new();
    }
    LOBYTE(v314) = 0;
    unint64_t v78 = v2 & 0xFFFFFFFFFFFF0000 | v339.__r_.__value_.__s.__data_[0] & 1 | 0x100;
    llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::getSymbolVersionByIndex(*(_WORD *)(v77 + v75 + 2 * v76), &v314, (uint64_t)v335, v78, (uint64_t)&v340);
    if (v340.__r_.__value_.__s.__data_[16])
    {
      v316.__r_.__value_.__r.__words[0] = (std::string::size_type)"unable to get a version for entry ";
      v316.__r_.__value_.__r.__words[2] = (std::string::size_type)&v311;
      __int16 v317 = 2563;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&v316;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)" of ";
      __int16 v320 = 770;
      sub_1CCC255A8(&v318, v6, (uint64_t)v64);
      char v104 = v320;
      if (v320 == 1)
      {
        int64_t v108 = &v318;
        p_p = &v318;
        long long v324 = v307;
        __int16 v325 = 260;
        int v326 = v321;
        __int16 v327 = WORD2(v321);
        char v105 = 4;
        uint64_t v109 = size;
      }
      else
      {
        if (!(_BYTE)v320)
        {
          char v105 = 0;
          __int16 v325 = 256;
          char v106 = 1;
          goto LABEL_170;
        }
        int64_t v108 = (std::string *)&p_p;
        long long v110 = (std::string *)__p.__r_.__value_.__r.__words[0];
        char v105 = 2;
        if (HIBYTE(v320) != 1)
        {
          char v104 = 2;
          long long v110 = &__p;
        }
        p_p = v110;
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
        *(void *)&long long v324 = &v318;
        LOBYTE(v325) = v104;
        uint64_t v109 = 4;
        HIBYTE(v325) = 4;
      }
      *(void *)&long long __dst = v108;
      *((void *)&__dst + 1) = v109;
      char v106 = 3;
      uint64_t v329 = (std::string *)": ";
LABEL_170:
      LOBYTE(v330) = v105;
      HIBYTE(v330) = v106;
      if (v340.__r_.__value_.__s.__data_[16])
      {
        std::string::size_type v111 = v340.__r_.__value_.__r.__words[0];
        v340.__r_.__value_.__r.__words[0] = 0;
      }
      else
      {
        std::string::size_type v111 = 0;
      }
      std::string::size_type v305 = v111;
      sub_1CD4FB504((uint64_t *)&v305, &v315);
      char v112 = v330;
      if ((_BYTE)v330)
      {
        if (v330 == 1)
        {
          p_dst = &v315;
          char v113 = 1;
          char v112 = 4;
        }
        else
        {
          if (HIBYTE(v330) != 1) {
            char v112 = 2;
          }
          unint64_t v114 = (void **)&__dst;
          if (HIBYTE(v330) == 1) {
            unint64_t v114 = (void **)__dst;
          }
          p_dst = (std::string *)v114;
          v332.i64[0] = *((void *)&__dst + 1);
          v332.i64[1] = (uint64_t)&v315;
          char v113 = 4;
        }
      }
      else
      {
        char v113 = 1;
      }
      LOBYTE(v334) = v112;
      BYTE1(v334) = v113;
      operator new();
    }
    uint64_t v79 = (const void *)v340.__r_.__value_.__r.__words[0];
    unint64_t v299 = v78;
    if (!v340.__r_.__value_.__r.__words[0])
    {
      long long __dst = 0uLL;
      uint64_t v329 = 0;
      goto LABEL_129;
    }
    std::string::size_type v80 = v340.__r_.__value_.__l.__size_;
    if (v340.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_393;
    }
    if (v340.__r_.__value_.__l.__size_ >= 0x17)
    {
      std::string::size_type v82 = (v340.__r_.__value_.__l.__size_ & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v340.__r_.__value_.__l.__size_ | 7) != 0x17) {
        std::string::size_type v82 = v340.__r_.__value_.__l.__size_ | 7;
      }
      std::string::size_type v83 = v82 + 1;
      uint64_t v81 = (long long *)operator new(v82 + 1);
      unint64_t v84 = v83 | 0x8000000000000000;
      uint64_t v6 = (uint64_t *)((char *)this + 56);
      *((void *)&__dst + 1) = v80;
      uint64_t v329 = (std::string *)v84;
      *(void *)&long long __dst = v81;
    }
    else
    {
      HIBYTE(v329) = v340.__r_.__value_.__s.__data_[8];
      uint64_t v81 = &__dst;
      if (!v340.__r_.__value_.__l.__size_) {
        goto LABEL_128;
      }
    }
    memmove(v81, v79, v80);
LABEL_128:
    *((unsigned char *)v81 + v80) = 0;
LABEL_129:
    char v85 = v314;
    unint64_t v86 = v312.u64[1];
    int v87 = v313;
    if (v312.i64[1] >= (unint64_t)v313)
    {
      uint64_t v89 = a2;
      uint64_t v90 = v312.i64[0];
      uint64_t v91 = (v312.i64[1] - v312.i64[0]) >> 5;
      unint64_t v92 = v91 + 1;
      if ((unint64_t)(v91 + 1) >> 59) {
LABEL_393:
      }
        abort();
      if ((uint64_t)&v313[-v312.i64[0]] >> 4 > v92) {
        unint64_t v92 = (uint64_t)&v313[-v312.i64[0]] >> 4;
      }
      if ((unint64_t)&v313[-v312.i64[0]] >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v93 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v93 = v92;
      }
      char v333 = 0;
      __int16 v334 = &v313;
      if (v93 >> 59) {
LABEL_394:
      }
        sub_1CB833614();
      char v94 = (char *)operator new(32 * v93);
      char v95 = &v94[32 * v91];
      *(_OWORD *)char v95 = __dst;
      *((void *)v95 + 2) = v329;
      v95[24] = v85;
      if (v86 == v90)
      {
        int64x2_t v98 = vdupq_n_s64(v86);
        char v96 = &v94[32 * v91];
        a2 = v89;
        uint64_t v72 = v296;
      }
      else
      {
        char v96 = &v94[32 * v91];
        a2 = v89;
        uint64_t v72 = v296;
        do
        {
          long long v97 = *(_OWORD *)(v86 - 32);
          *((void *)v96 - 2) = *(void *)(v86 - 16);
          *((_OWORD *)v96 - 2) = v97;
          *(void *)(v86 - 24) = 0;
          *(void *)(v86 - ++*(_DWORD *)(this + 16) = 0;
          *(void *)(v86 - 32) = 0;
          *(v96 - ++*(_DWORD *)(this + 8) = *(unsigned char *)(v86 - 8);
          v96 -= 32;
          v86 -= 32;
        }
        while (v86 != v90);
        int64x2_t v98 = v312;
        int v87 = v313;
      }
      unint64_t v88 = (unint64_t)(v95 + 32);
      v312.i64[0] = (uint64_t)v96;
      v312.i64[1] = (uint64_t)(v95 + 32);
      int64x2_t v332 = v98;
      uint64_t v313 = &v94[32 * v93];
      char v333 = v87;
      p_dst = (std::string *)v98.i64[0];
      sub_1CD573B00((uint64_t)&p_dst);
      uint64_t v6 = (uint64_t *)((char *)this + 56);
    }
    else
    {
      *(_OWORD *)v312.i64[1] = __dst;
      *(void *)(v86 + ++*(_DWORD *)(this + 16) = v329;
      *(unsigned char *)(v86 + 24) = v85;
      unint64_t v88 = v86 + 32;
    }
    v312.i64[1] = v88;
    unint64_t v2 = v299;
    if (v340.__r_.__value_.__s.__data_[16])
    {
      std::string::size_type v99 = v340.__r_.__value_.__r.__words[0];
      v340.__r_.__value_.__r.__words[0] = 0;
      if (v99) {
        (*(void (**)(std::string::size_type))(*(void *)v99 + 8))(v99);
      }
    }
    if (v339.__r_.__value_.__s.__data_[8])
    {
      std::string::size_type v100 = v339.__r_.__value_.__r.__words[0];
      v339.__r_.__value_.__r.__words[0] = 0;
      if (v100) {
        (*(void (**)(std::string::size_type))(*(void *)v100 + 8))(v100);
      }
    }
    (*(void (**)(uint64_t, unint64_t *))(*(void *)v310 + 24))(v310, &v309);
  }
  while (v309 != v72);
LABEL_366:
  int64x2_t v18 = v312;
  uint64_t v17 = v313;
LABEL_367:
  *(unsigned char *)(a2 + 24) &= ~1u;
  *(int64x2_t *)a2 = v18;
  *(void *)(a2 + ++*(_DWORD *)(this + 16) = v17;
  uint64_t v313 = 0;
  int64x2_t v312 = 0uLL;
  p_dst = (std::string *)&v312;
  sub_1CC658304((void ***)&p_dst);
LABEL_368:
  sub_1CCC49FA8((uint64_t)v335);
}

double sub_1CCC48030(uint64_t a1)
{
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = "riscv";
  *(void *)(a1 + ++*(_DWORD *)(this + 16) = 5;
  double result = 0.0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 56) = 1065353216;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 96) = 1065353216;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = &unk_1E6855888;
  *(void *)(a1 + 12++*(_DWORD *)(this + 8) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 120) = 6;
  *(_WORD *)(a1 + 144) = 1;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)a1 = &unk_1F2645338;
  return result;
}

void *sub_1CCC480A0@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1 + 7;
  double result = sub_1CD6D904C((uint64_t)&v34, a1 + 7, a2, HIDWORD(a2));
  uint64_t v8 = (void *)v34;
  if (v35)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v8;
    goto LABEL_74;
  }
  unsigned int v9 = *(unsigned __int8 *)(v34 + 12);
  if ((v9 & 0xF0) == 0x20) {
    int v10 = (2 * (v9 > 0xF)) | 4;
  }
  else {
    int v10 = 2 * (v9 > 0xF);
  }
  if (*(__int16 *)(v34 + 14) == -15) {
    int v11 = v10 | 8;
  }
  else {
    int v11 = v10;
  }
  uint64_t v12 = (unsigned int *)a1[10];
  if (v12)
  {
    double result = sub_1CD6CB19C(v6, v12, (uint64_t)&v31);
    uint64_t v13 = v31;
    if (v33)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v13;
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  int v14 = (unsigned int *)a1[9];
  if (v14)
  {
    double result = sub_1CD6CB19C(v6, v14, (uint64_t)&v31);
    uint64_t v15 = v31;
    if (v33)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v15;
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  if ((v9 & 0xF) - 3 < 2 || v8 == v13 || v8 == v15) {
    int v18 = v11 | 0x80;
  }
  else {
    int v18 = v11;
  }
  int v19 = *(unsigned __int16 *)(*v6 + 18);
  switch(v19)
  {
    case 183:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if ((v33 & 1) == 0)
      {
        int v20 = v18;
        if (v32 >= 2)
        {
          int v20 = v11 | 0x80;
          if (*(_WORD *)v31 != 25636)
          {
            if (*(_WORD *)v31 == 30756) {
              int v20 = v11 | 0x80;
            }
            else {
              int v20 = v18;
            }
          }
        }
        goto LABEL_57;
      }
      std::string::size_type v30 = v31;
      unint64_t v31 = 0;
      sub_1CD4515D0(&v30);
      double result = v30;
      if (!v30) {
        goto LABEL_56;
      }
      goto LABEL_55;
    case 40:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if (v33)
      {
        __int16 v26 = v31;
        unint64_t v31 = 0;
        std::string::size_type v29 = v26;
        sub_1CD4515D0(&v29);
        double result = v29;
        if (v29) {
          double result = (void *)(*(uint64_t (**)(void *))(*v29 + 8))(v29);
        }
        int v20 = v18;
        goto LABEL_49;
      }
      if (v32)
      {
        int v20 = v18;
        if (v32 == 1) {
          goto LABEL_49;
        }
        if (*(_WORD *)v31 != 25636)
        {
          int v20 = v11 | 0x80;
          if (*(_WORD *)v31 != 29732)
          {
            if (*(_WORD *)v31 == 24868) {
              int v20 = v11 | 0x80;
            }
            else {
              int v20 = v18;
            }
          }
          goto LABEL_49;
        }
      }
      int v20 = v11 | 0x80;
LABEL_49:
      if (v33)
      {
        double result = v31;
        unint64_t v31 = 0;
        if (result) {
          double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        }
      }
      if ((*((unsigned char *)v8 + 12) & 0xF) == 2) {
        v20 |= (*((_DWORD *)v8 + 1) & 1) << 8;
      }
      goto LABEL_60;
    case 243:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if ((v33 & 1) == 0)
      {
        if (v32) {
          int v20 = v18;
        }
        else {
          int v20 = v11 | 0x80;
        }
LABEL_57:
        if (v33)
        {
          double result = v31;
          unint64_t v31 = 0;
          if (result) {
            double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
          }
        }
        goto LABEL_60;
      }
      std::string::size_type v27 = v31;
      unint64_t v31 = 0;
      uint64_t v28 = v27;
      sub_1CD4515D0(&v28);
      double result = v28;
      if (!v28)
      {
LABEL_56:
        int v20 = v18;
        goto LABEL_57;
      }
LABEL_55:
      double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      goto LABEL_56;
  }
  int v20 = v18;
LABEL_60:
  int v21 = v20 | (*((_WORD *)v8 + 7) == 0);
  unsigned int v22 = *((unsigned __int8 *)v8 + 12);
  if ((v22 & 0xF) == 5 || *((unsigned __int16 *)v8 + 7) == 65522) {
    v21 |= 0x10u;
  }
  unsigned int v23 = v22 >> 4;
  if (v23 <= 0xA && ((1 << v23) & 0x406) != 0)
  {
    int v24 = *((unsigned char *)v8 + 13) & 3;
    BOOL v25 = (*((unsigned char *)v8 + 13) & 3) == 0;
    if (v24 == 3) {
      BOOL v25 = 1;
    }
    if (v25) {
      v21 |= 0x40u;
    }
  }
  else
  {
    int v24 = *((unsigned char *)v8 + 13) & 3;
  }
  if (v24 == 2) {
    v21 |= 0x200u;
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = v21;
LABEL_74:
  if (v35)
  {
    double result = (void *)v34;
    uint64_t v34 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

BOOL sub_1CCC485B4(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 136))(&v8);
  if (v10)
  {
    unint64_t v7 = (void *)v8;
    uint64_t v8 = 0;
    sub_1CD4515D0(&v7);
    if (v7) {
      (*(void (**)(void *))(*v7 + 8))(v7);
    }
    goto LABEL_22;
  }
  if (v9 < 6) {
    goto LABEL_22;
  }
  if (*(_DWORD *)v8 == 1650811950 && *(_WORD *)(v8 + 4) == 26485) {
    goto LABEL_19;
  }
  if (v9 < 7)
  {
LABEL_22:
    BOOL v4 = 0;
    goto LABEL_23;
  }
  if (*(_DWORD *)v8 != 1701083694 || *(_DWORD *)(v8 + 3) != 1735746149)
  {
    if (v9 == 10)
    {
      BOOL v4 = *(void *)v8 == 0x646E695F6264672ELL && *(_WORD *)(v8 + 8) == 30821;
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_19:
  BOOL v4 = 1;
LABEL_23:
  if (v10)
  {
    uint64_t v5 = v8;
    uint64_t v8 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  return v4;
}

void sub_1CCC487E0()
{
}

void *sub_1CCC4886C(void **a1)
{
  unint64_t v3 = *a1;
  *a1 = 0;
  sub_1CD6D954C(&v4, &v3);
  double result = v3;
  if (v3)
  {
    unint64_t v2 = *(uint64_t (**)(void))(*v3 + 8);
    return (void *)v2();
  }
  return result;
}

char *sub_1CCC488E4(char **a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v5 = (v4 - *a1) >> 4;
  unint64_t v6 = v5 + 1;
  if ((unint64_t)(v5 + 1) >> 60) {
    abort();
  }
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v6) {
    unint64_t v6 = v8 >> 3;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
    unint64_t v9 = 0xFFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v6;
  }
  if (v9 >> 60) {
    sub_1CB833614();
  }
  uint64_t v12 = (char *)operator new(16 * v9);
  uint64_t v13 = &v12[16 * v5];
  *(void *)uint64_t v13 = a2;
  *((void *)v13 + 1) = a3;
  int v14 = v13 + 16;
  if (v4 == v3)
  {
    uint64_t v15 = &v12[16 * v5];
  }
  else
  {
    do
    {
      uint64_t v15 = v13 - 16;
      *((_OWORD *)v13 - 1) = *((_OWORD *)v4 - 1);
      v4 -= 16;
      v13 -= 16;
    }
    while (v4 != v3);
  }
  *a1 = v15;
  a1[1] = v14;
  a1[2] = &v12[16 * v9];
  if (v3) {
    operator delete(v3);
  }
  return v14;
}

void *sub_1CCC489D0@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = a1 + 7;
  double result = sub_1CD6DC39C((uint64_t)&v34, a1 + 7, a2, HIDWORD(a2));
  uint64_t v8 = (void *)v34;
  if (v35)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v8;
    goto LABEL_74;
  }
  unsigned int v9 = *(unsigned __int8 *)(v34 + 12);
  if ((v9 & 0xF0) == 0x20) {
    int v10 = (2 * (v9 > 0xF)) | 4;
  }
  else {
    int v10 = 2 * (v9 > 0xF);
  }
  if (*(__int16 *)(v34 + 14) == -3585) {
    int v11 = v10 | 8;
  }
  else {
    int v11 = v10;
  }
  uint64_t v12 = (unsigned int *)a1[10];
  if (v12)
  {
    double result = sub_1CD6CE6A4(v6, v12, (uint64_t)&v31);
    uint64_t v13 = v31;
    if (v33)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v13;
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  int v14 = (unsigned int *)a1[9];
  if (v14)
  {
    double result = sub_1CD6CE6A4(v6, v14, (uint64_t)&v31);
    uint64_t v15 = v31;
    if (v33)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v15;
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  if ((v9 & 0xF) - 3 < 2 || v8 == v13 || v8 == v15) {
    int v18 = v11 | 0x80;
  }
  else {
    int v18 = v11;
  }
  int v19 = *(unsigned __int16 *)(*v6 + 18);
  switch(v19)
  {
    case 46848:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if ((v33 & 1) == 0)
      {
        int v20 = v18;
        if (v32 >= 2)
        {
          int v20 = v11 | 0x80;
          if (*(_WORD *)v31 != 25636)
          {
            if (*(_WORD *)v31 == 30756) {
              int v20 = v11 | 0x80;
            }
            else {
              int v20 = v18;
            }
          }
        }
        goto LABEL_57;
      }
      std::string::size_type v30 = v31;
      unint64_t v31 = 0;
      sub_1CD4515D0(&v30);
      double result = v30;
      if (!v30) {
        goto LABEL_56;
      }
      goto LABEL_55;
    case 10240:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if (v33)
      {
        __int16 v26 = v31;
        unint64_t v31 = 0;
        std::string::size_type v29 = v26;
        sub_1CD4515D0(&v29);
        double result = v29;
        if (v29) {
          double result = (void *)(*(uint64_t (**)(void *))(*v29 + 8))(v29);
        }
        int v20 = v18;
        goto LABEL_49;
      }
      if (v32)
      {
        int v20 = v18;
        if (v32 == 1) {
          goto LABEL_49;
        }
        if (*(_WORD *)v31 != 25636)
        {
          int v20 = v11 | 0x80;
          if (*(_WORD *)v31 != 29732)
          {
            if (*(_WORD *)v31 == 24868) {
              int v20 = v11 | 0x80;
            }
            else {
              int v20 = v18;
            }
          }
          goto LABEL_49;
        }
      }
      int v20 = v11 | 0x80;
LABEL_49:
      if (v33)
      {
        double result = v31;
        unint64_t v31 = 0;
        if (result) {
          double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        }
      }
      if ((*((unsigned char *)v8 + 12) & 0xF) == 2) {
        v20 |= *((_WORD *)v8 + 3) & 0x100;
      }
      goto LABEL_60;
    case 62208:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if ((v33 & 1) == 0)
      {
        if (v32) {
          int v20 = v18;
        }
        else {
          int v20 = v11 | 0x80;
        }
LABEL_57:
        if (v33)
        {
          double result = v31;
          unint64_t v31 = 0;
          if (result) {
            double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
          }
        }
        goto LABEL_60;
      }
      std::string::size_type v27 = v31;
      unint64_t v31 = 0;
      uint64_t v28 = v27;
      sub_1CD4515D0(&v28);
      double result = v28;
      if (!v28)
      {
LABEL_56:
        int v20 = v18;
        goto LABEL_57;
      }
LABEL_55:
      double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      goto LABEL_56;
  }
  int v20 = v18;
LABEL_60:
  int v21 = v20 | (*((_WORD *)v8 + 7) == 0);
  unsigned int v22 = *((unsigned __int8 *)v8 + 12);
  if ((v22 & 0xF) == 5 || *((unsigned __int16 *)v8 + 7) == 62207) {
    v21 |= 0x10u;
  }
  unsigned int v23 = v22 >> 4;
  if (v23 <= 0xA && ((1 << v23) & 0x406) != 0)
  {
    int v24 = *((unsigned char *)v8 + 13) & 3;
    BOOL v25 = (*((unsigned char *)v8 + 13) & 3) == 0;
    if (v24 == 3) {
      BOOL v25 = 1;
    }
    if (v25) {
      v21 |= 0x40u;
    }
  }
  else
  {
    int v24 = *((unsigned char *)v8 + 13) & 3;
  }
  if (v24 == 2) {
    v21 |= 0x200u;
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = v21;
LABEL_74:
  if (v35)
  {
    double result = (void *)v34;
    uint64_t v34 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

BOOL sub_1CCC48EF0(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 136))(&v8);
  if (v10)
  {
    unint64_t v7 = (void *)v8;
    uint64_t v8 = 0;
    sub_1CD4515D0(&v7);
    if (v7) {
      (*(void (**)(void *))(*v7 + 8))(v7);
    }
    goto LABEL_22;
  }
  if (v9 < 6) {
    goto LABEL_22;
  }
  if (*(_DWORD *)v8 == 1650811950 && *(_WORD *)(v8 + 4) == 26485) {
    goto LABEL_19;
  }
  if (v9 < 7)
  {
LABEL_22:
    BOOL v4 = 0;
    goto LABEL_23;
  }
  if (*(_DWORD *)v8 != 1701083694 || *(_DWORD *)(v8 + 3) != 1735746149)
  {
    if (v9 == 10)
    {
      BOOL v4 = *(void *)v8 == 0x646E695F6264672ELL && *(_WORD *)(v8 + 8) == 30821;
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_19:
  BOOL v4 = 1;
LABEL_23:
  if (v10)
  {
    uint64_t v5 = v8;
    uint64_t v8 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  return v4;
}

void *sub_1CCC4911C@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = a1 + 7;
  double result = sub_1CD6DF398((uint64_t)&v34, a1 + 7, a2, HIDWORD(a2));
  uint64_t v8 = (void *)v34;
  if (v35)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v8;
    goto LABEL_74;
  }
  unsigned int v9 = *(unsigned __int8 *)(v34 + 4);
  if ((v9 & 0xF0) == 0x20) {
    int v10 = (2 * (v9 > 0xF)) | 4;
  }
  else {
    int v10 = 2 * (v9 > 0xF);
  }
  if (*(__int16 *)(v34 + 6) == -15) {
    int v11 = v10 | 8;
  }
  else {
    int v11 = v10;
  }
  uint64_t v12 = (void *)a1[10];
  if (v12)
  {
    double result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relas(v6, v12, (uint64_t)&v31);
    uint64_t v13 = v31;
    if (v33)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v13;
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  int v14 = (void *)a1[9];
  if (v14)
  {
    double result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)1,true>>::relas(v6, v14, (uint64_t)&v31);
    uint64_t v15 = v31;
    if (v33)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v15;
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  if ((v9 & 0xF) - 3 < 2 || v8 == v13 || v8 == v15) {
    int v18 = v11 | 0x80;
  }
  else {
    int v18 = v11;
  }
  int v19 = *(unsigned __int16 *)(*v6 + 18);
  switch(v19)
  {
    case 183:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if ((v33 & 1) == 0)
      {
        int v20 = v18;
        if (v32 >= 2)
        {
          int v20 = v11 | 0x80;
          if (*(_WORD *)v31 != 25636)
          {
            if (*(_WORD *)v31 == 30756) {
              int v20 = v11 | 0x80;
            }
            else {
              int v20 = v18;
            }
          }
        }
        goto LABEL_57;
      }
      std::string::size_type v30 = v31;
      unint64_t v31 = 0;
      sub_1CD4515D0(&v30);
      double result = v30;
      if (!v30) {
        goto LABEL_56;
      }
      goto LABEL_55;
    case 40:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if (v33)
      {
        __int16 v26 = v31;
        unint64_t v31 = 0;
        std::string::size_type v29 = v26;
        sub_1CD4515D0(&v29);
        double result = v29;
        if (v29) {
          double result = (void *)(*(uint64_t (**)(void *))(*v29 + 8))(v29);
        }
        int v20 = v18;
        goto LABEL_49;
      }
      if (v32)
      {
        int v20 = v18;
        if (v32 == 1) {
          goto LABEL_49;
        }
        if (*(_WORD *)v31 != 25636)
        {
          int v20 = v11 | 0x80;
          if (*(_WORD *)v31 != 29732)
          {
            if (*(_WORD *)v31 == 24868) {
              int v20 = v11 | 0x80;
            }
            else {
              int v20 = v18;
            }
          }
          goto LABEL_49;
        }
      }
      int v20 = v11 | 0x80;
LABEL_49:
      if (v33)
      {
        double result = v31;
        unint64_t v31 = 0;
        if (result) {
          double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        }
      }
      if ((*((unsigned char *)v8 + 4) & 0xF) == 2) {
        v20 |= (v8[1] & 1) << 8;
      }
      goto LABEL_60;
    case 243:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if ((v33 & 1) == 0)
      {
        if (v32) {
          int v20 = v18;
        }
        else {
          int v20 = v11 | 0x80;
        }
LABEL_57:
        if (v33)
        {
          double result = v31;
          unint64_t v31 = 0;
          if (result) {
            double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
          }
        }
        goto LABEL_60;
      }
      std::string::size_type v27 = v31;
      unint64_t v31 = 0;
      uint64_t v28 = v27;
      sub_1CD4515D0(&v28);
      double result = v28;
      if (!v28)
      {
LABEL_56:
        int v20 = v18;
        goto LABEL_57;
      }
LABEL_55:
      double result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      goto LABEL_56;
  }
  int v20 = v18;
LABEL_60:
  int v21 = v20 | (*((_WORD *)v8 + 3) == 0);
  unsigned int v22 = *((unsigned __int8 *)v8 + 4);
  if ((v22 & 0xF) == 5 || *((unsigned __int16 *)v8 + 3) == 65522) {
    v21 |= 0x10u;
  }
  unsigned int v23 = v22 >> 4;
  if (v23 <= 0xA && ((1 << v23) & 0x406) != 0)
  {
    int v24 = *((unsigned char *)v8 + 5) & 3;
    BOOL v25 = (*((unsigned char *)v8 + 5) & 3) == 0;
    if (v24 == 3) {
      BOOL v25 = 1;
    }
    if (v25) {
      v21 |= 0x40u;
    }
  }
  else
  {
    int v24 = *((unsigned char *)v8 + 5) & 3;
  }
  if (v24 == 2) {
    v21 |= 0x200u;
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = v21;
LABEL_74:
  if (v35)
  {
    double result = (void *)v34;
    uint64_t v34 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

BOOL sub_1CCC49630(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 136))(&v8);
  if (v10)
  {
    unint64_t v7 = (void *)v8;
    uint64_t v8 = 0;
    sub_1CD4515D0(&v7);
    if (v7) {
      (*(void (**)(void *))(*v7 + 8))(v7);
    }
    goto LABEL_22;
  }
  if (v9 < 6) {
    goto LABEL_22;
  }
  if (*(_DWORD *)v8 == 1650811950 && *(_WORD *)(v8 + 4) == 26485) {
    goto LABEL_19;
  }
  if (v9 < 7)
  {
LABEL_22:
    BOOL v4 = 0;
    goto LABEL_23;
  }
  if (*(_DWORD *)v8 != 1701083694 || *(_DWORD *)(v8 + 3) != 1735746149)
  {
    if (v9 == 10)
    {
      BOOL v4 = *(void *)v8 == 0x646E695F6264672ELL && *(_WORD *)(v8 + 8) == 30821;
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_19:
  BOOL v4 = 1;
LABEL_23:
  if (v10)
  {
    uint64_t v5 = v8;
    uint64_t v8 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  return v4;
}

unint64_t *sub_1CCC4985C@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = a1 + 7;
  double result = sub_1CD6E23D0((uint64_t)&v34, a1 + 7, a2, HIDWORD(a2));
  uint64_t v8 = (void *)v34;
  if (v35)
  {
    uint64_t v34 = 0;
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v8;
    goto LABEL_74;
  }
  unsigned int v9 = *(unsigned __int8 *)(v34 + 4);
  if ((v9 & 0xF0) == 0x20) {
    int v10 = (2 * (v9 > 0xF)) | 4;
  }
  else {
    int v10 = 2 * (v9 > 0xF);
  }
  if (*(__int16 *)(v34 + 6) == -3585) {
    int v11 = v10 | 8;
  }
  else {
    int v11 = v10;
  }
  uint64_t v12 = (unint64_t *)a1[10];
  if (v12)
  {
    double result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::relas(v6, v12, (uint64_t)&v31);
    uint64_t v13 = v31;
    if (v33)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v13;
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  int v14 = (unint64_t *)a1[9];
  if (v14)
  {
    double result = llvm::object::ELFFile<llvm::object::ELFType<(llvm::support::endianness)0,true>>::relas(v6, v14, (uint64_t)&v31);
    uint64_t v15 = v31;
    if (v33)
    {
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v15;
      goto LABEL_74;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  if ((v9 & 0xF) - 3 < 2 || v8 == v13 || v8 == v15) {
    int v18 = v11 | 0x80;
  }
  else {
    int v18 = v11;
  }
  int v19 = *(unsigned __int16 *)(*v6 + 18);
  switch(v19)
  {
    case 46848:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if ((v33 & 1) == 0)
      {
        int v20 = v18;
        if (v32 >= 2)
        {
          int v20 = v11 | 0x80;
          if (*(_WORD *)v31 != 25636)
          {
            if (*(_WORD *)v31 == 30756) {
              int v20 = v11 | 0x80;
            }
            else {
              int v20 = v18;
            }
          }
        }
        goto LABEL_57;
      }
      std::string::size_type v30 = v31;
      unint64_t v31 = 0;
      sub_1CD4515D0(&v30);
      double result = v30;
      if (!v30) {
        goto LABEL_56;
      }
      goto LABEL_55;
    case 10240:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if (v33)
      {
        __int16 v26 = v31;
        unint64_t v31 = 0;
        std::string::size_type v29 = v26;
        sub_1CD4515D0(&v29);
        double result = v29;
        if (v29) {
          double result = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*v29 + 8))(v29);
        }
        int v20 = v18;
        goto LABEL_49;
      }
      if (v32)
      {
        int v20 = v18;
        if (v32 == 1) {
          goto LABEL_49;
        }
        if (*(_WORD *)v31 != 25636)
        {
          int v20 = v11 | 0x80;
          if (*(_WORD *)v31 != 29732)
          {
            if (*(_WORD *)v31 == 24868) {
              int v20 = v11 | 0x80;
            }
            else {
              int v20 = v18;
            }
          }
          goto LABEL_49;
        }
      }
      int v20 = v11 | 0x80;
LABEL_49:
      if (v33)
      {
        double result = v31;
        unint64_t v31 = 0;
        if (result) {
          double result = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
        }
      }
      if ((*((unsigned char *)v8 + 4) & 0xF) == 2) {
        v20 |= *((_WORD *)v8 + 7) & 0x100;
      }
      goto LABEL_60;
    case 62208:
      double result = (*(void *(**)(void **__return_ptr, void *, uint64_t))(*a1 + 72))(&v31, a1, a2);
      if ((v33 & 1) == 0)
      {
        if (v32) {
          int v20 = v18;
        }
        else {
          int v20 = v11 | 0x80;
        }
LABEL_57:
        if (v33)
        {
          double result = v31;
          unint64_t v31 = 0;
          if (result) {
            double result = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
          }
        }
        goto LABEL_60;
      }
      std::string::size_type v27 = v31;
      unint64_t v31 = 0;
      uint64_t v28 = v27;
      sub_1CD4515D0(&v28);
      double result = v28;
      if (!v28)
      {
LABEL_56:
        int v20 = v18;
        goto LABEL_57;
      }
LABEL_55:
      double result = (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
      goto LABEL_56;
  }
  int v20 = v18;
LABEL_60:
  int v21 = v20 | (*((_WORD *)v8 + 3) == 0);
  unsigned int v22 = *((unsigned __int8 *)v8 + 4);
  if ((v22 & 0xF) == 5 || *((unsigned __int16 *)v8 + 3) == 62207) {
    v21 |= 0x10u;
  }
  unsigned int v23 = v22 >> 4;
  if (v23 <= 0xA && ((1 << v23) & 0x406) != 0)
  {
    int v24 = *((unsigned char *)v8 + 5) & 3;
    BOOL v25 = (*((unsigned char *)v8 + 5) & 3) == 0;
    if (v24 == 3) {
      BOOL v25 = 1;
    }
    if (v25) {
      v21 |= 0x40u;
    }
  }
  else
  {
    int v24 = *((unsigned char *)v8 + 5) & 3;
  }
  if (v24 == 2) {
    v21 |= 0x200u;
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = v21;
LABEL_74:
  if (v35)
  {
    double result = (unint64_t *)v34;
    uint64_t v34 = 0;
    if (result) {
      return (unint64_t *)(*(uint64_t (**)(unint64_t *))(*result + 8))(result);
    }
  }
  return result;
}

BOOL sub_1CCC49D7C(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 136))(&v8);
  if (v10)
  {
    unint64_t v7 = (void *)v8;
    uint64_t v8 = 0;
    sub_1CD4515D0(&v7);
    if (v7) {
      (*(void (**)(void *))(*v7 + 8))(v7);
    }
    goto LABEL_22;
  }
  if (v9 < 6) {
    goto LABEL_22;
  }
  if (*(_DWORD *)v8 == 1650811950 && *(_WORD *)(v8 + 4) == 26485) {
    goto LABEL_19;
  }
  if (v9 < 7)
  {
LABEL_22:
    BOOL v4 = 0;
    goto LABEL_23;
  }
  if (*(_DWORD *)v8 != 1701083694 || *(_DWORD *)(v8 + 3) != 1735746149)
  {
    if (v9 == 10)
    {
      BOOL v4 = *(void *)v8 == 0x646E695F6264672ELL && *(_WORD *)(v8 + 8) == 30821;
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_19:
  BOOL v4 = 1;
LABEL_23:
  if (v10)
  {
    uint64_t v5 = v8;
    uint64_t v8 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  return v4;
}

uint64_t sub_1CCC49FA8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16))
  {
    unint64_t v2 = *(char **)a1;
    *(void *)a1 = 0;
    if (v2) {
      (*(void (**)(char *))(*(void *)v2 + 8))(v2);
    }
  }
  else
  {
    sub_1CCC3FDC0((char **)a1);
  }
  return a1;
}

llvm::object::GenericBinaryError *llvm::object::GenericBinaryError::GenericBinaryError(llvm::object::GenericBinaryError *this, const llvm::Twine *a2)
{
  BOOL v4 = (void *)sub_1CD6E3268((uint64_t)this);
  void *v4 = &unk_1F2633568;
  llvm::Twine::str(a2, v4 + 3);
  return this;
}

{
  void *v4;

  BOOL v4 = (void *)sub_1CD6E3268((uint64_t)this);
  void *v4 = &unk_1F2633568;
  llvm::Twine::str(a2, v4 + 3);
  return this;
}

atomic_ullong llvm::object::object_category(llvm::object *this)
{
  if (!atomic_load_explicit(qword_1EA61DED0, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EA61DED0, (void *(*)(void))sub_1CCC4A2B8, (void (*)(void *))sub_1CCC4A300);
  }
  return qword_1EA61DED0[0];
}

char **llvm::object::isNotObjectErrorInvalidFileType@<X0>(char **result@<X0>, void *a2@<X8>)
{
  unint64_t v3 = *result;
  *double result = 0;
  if (v3)
  {
    if ((*(unsigned int (**)(char *, void *))(*(void *)v3 + 48))(v3, &llvm::ErrorList::ID))
    {
      *a2 = 0;
      BOOL v4 = (uint64_t *)*((void *)v3 + 1);
      uint64_t v5 = (uint64_t *)*((void *)v3 + 2);
      if (v4 != v5)
      {
        unint64_t v6 = 0;
        do
        {
          uint64_t v12 = v6;
          uint64_t v7 = *v4;
          uint64_t *v4 = 0;
          uint64_t v10 = v7;
          sub_1CCC4A58C(&v11, &v10);
          sub_1CD451630(&v12, &v11, &v13);
          unint64_t v6 = v13;
          *a2 = v13;
          uint64_t v13 = 0;
          if (v11) {
            (*(void (**)(char *))(*(void *)v11 + 8))(v11);
          }
          uint64_t v8 = v10;
          uint64_t v10 = 0;
          if (v8) {
            (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
          }
          if (v12) {
            (*(void (**)(char *))(*(void *)v12 + 8))(v12);
          }
          ++v4;
        }
        while (v4 != v5);
      }
      return (char **)(*(uint64_t (**)(char *))(*(void *)v3 + 8))(v3);
    }
    else
    {
      uint64_t v13 = v3;
      sub_1CCC4A58C(a2, &v13);
      double result = (char **)v13;
      if (v13)
      {
        unint64_t v9 = *(uint64_t (**)(void))(*(void *)v13 + 8);
        return (char **)v9();
      }
    }
  }
  else
  {
    *a2 = 0;
  }
  return result;
}

uint64_t sub_1CCC4A2AC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void sub_1CCC4A2B8()
{
}

uint64_t sub_1CCC4A300(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void sub_1CCC4A330(std::error_category *a1)
{
  std::error_category::~error_category(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CCC4A368()
{
  return "llvm.object";
}

double sub_1CCC4A374@<D0>(int a1@<W1>, uint64_t a2@<X8>)
{
  switch(a1)
  {
    case 2:
      uint64_t v5 = (char *)operator new(0x38uLL);
      *(void *)a2 = v5;
      *(_OWORD *)(a2 + ++*(_DWORD *)(this + 8) = xmmword_1CFB2C170;
      strcpy(v5, "The file was not recognized as a valid object file");
      double result = *(double *)" valid object file";
      break;
    case 3:
      unint64_t v6 = (char *)operator new(0x38uLL);
      *(void *)a2 = v6;
      *(_OWORD *)(a2 + ++*(_DWORD *)(this + 8) = xmmword_1CFB2C160;
      strcpy(v6, "Invalid data was encountered while parsing the file");
      double result = *(double *)"le parsing the file";
      break;
    case 4:
      uint64_t v7 = (char *)operator new(0x38uLL);
      *(void *)a2 = v7;
      *(_OWORD *)(a2 + ++*(_DWORD *)(this + 8) = xmmword_1CFB2C150;
      strcpy(v7, "The end of the file was unexpectedly encountered");
      double result = *(double *)"edly encountered";
      break;
    case 5:
      uint64_t v8 = (char *)operator new(0x30uLL);
      *(void *)a2 = v8;
      *(_OWORD *)(a2 + ++*(_DWORD *)(this + 8) = xmmword_1CFB2C140;
      strcpy(v8, "String table must end with a null terminator");
      double result = *(double *)" null terminator";
      break;
    case 6:
      *(unsigned char *)(a2 + 23) = 21;
      double result = *(double *)"Invalid section index";
      strcpy((char *)a2, "Invalid section index");
      break;
    case 7:
      unint64_t v9 = (char *)operator new(0x30uLL);
      *(void *)a2 = v9;
      *(_OWORD *)(a2 + ++*(_DWORD *)(this + 8) = xmmword_1CD96D870;
      double result = *(double *)"Bitcode section not found in object file";
      strcpy(v9, "Bitcode section not found in object file");
      break;
    case 8:
      *(unsigned char *)(a2 + 23) = 20;
      double result = *(double *)"Invalid symbol index";
      strcpy((char *)a2, "Invalid symbol index");
      break;
    default:
      unint64_t v3 = (char *)operator new(0x30uLL);
      *(void *)a2 = v3;
      *(_OWORD *)(a2 + ++*(_DWORD *)(this + 8) = xmmword_1CFB1B7C0;
      strcpy(v3, "No object file for requested architecture");
      double result = *(double *)"ted architecture";
      break;
  }
  return result;
}

void sub_1CCC4A58C(void *a1, void *a2)
{
  int v4 = (*(uint64_t (**)(void, void *))(*(void *)*a2 + 48))(*a2, &llvm::ECError::ID);
  uint64_t v5 = *a2;
  *a2 = 0;
  if (v4)
  {
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
    uint64_t v8 = v7;
    if (!atomic_load_explicit(qword_1EA61DED0, memory_order_acquire)) {
      llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EA61DED0, (void *(*)(void))sub_1CCC4A2B8, (void (*)(void *))sub_1CCC4A300);
    }
    BOOL v9 = v8 == qword_1EA61DED0[0] && v6 == 2;
    if (v9) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v5;
    }
    *a1 = v10;
    if (v9)
    {
      uint64_t v11 = *(void (**)(uint64_t))(*(void *)v5 + 8);
      v11(v5);
    }
  }
  else
  {
    *a1 = v5;
  }
}

llvm::raw_ostream *printFaultType(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  if (result == 1)
  {
    uint64_t v3 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v3) <= 0xB) {
      return llvm::raw_ostream::write(this, "FaultingLoad", 0xCuLL);
    }
    *(_DWORD *)(v3 + ++*(_DWORD *)(this + 8) = 1684107084;
    *(void *)uint64_t v3 = *(void *)"FaultingLoad";
    uint64_t v5 = *((void *)this + 4) + 12;
    goto LABEL_13;
  }
  if (result != 2)
  {
    int v4 = (void *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v4 <= 0xCuLL) {
      return llvm::raw_ostream::write(this, "FaultingStore", 0xDuLL);
    }
    qmemcpy(v4, "FaultingStore", 13);
    uint64_t v5 = *((void *)this + 4) + 13;
    goto LABEL_13;
  }
  uint64_t v2 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v2) > 0x10)
  {
    *(unsigned char *)(v2 + ++*(_DWORD *)(this + 16) = 101;
    *(_OWORD *)uint64_t v2 = *(_OWORD *)"FaultingLoadStore";
    uint64_t v5 = *((void *)this + 4) + 17;
LABEL_13:
    *((void *)this + 4) = v5;
    return result;
  }
  return llvm::raw_ostream::write(this, "FaultingLoadStore", 0x11uLL);
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *this, unsigned int **a2)
{
  uint64_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 0xB)
  {
    *(_DWORD *)(v4 + ++*(_DWORD *)(this + 8) = 540697710;
    *(void *)uint64_t v4 = *(void *)"Fault kind: ";
    *((void *)this + 4) += 12;
  }
  else
  {
    llvm::raw_ostream::write(this, "Fault kind: ", 0xCuLL);
  }
  printFaultType((llvm::raw_ostream *)**a2, this);
  uint64_t v5 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v5 > 0x15uLL)
  {
    qmemcpy(v5, ", faulting PC offset: ", 22);
    *((void *)this + 4) += 22;
  }
  else
  {
    llvm::raw_ostream::write(this, ", faulting PC offset: ", 0x16uLL);
  }
  sub_1CD098D14(this, (*a2)[1], 0, 0, 0);
  int v6 = (void *)*((void *)this + 4);
  if (*((void *)this + 3) - (void)v6 > 0x15uLL)
  {
    qmemcpy(v6, ", handling PC offset: ", 22);
    *((void *)this + 4) += 22;
  }
  else
  {
    llvm::raw_ostream::write(this, ", handling PC offset: ", 0x16uLL);
  }
  sub_1CD098D14(this, (*a2)[2], 0, 0, 0);
  return this;
}

llvm::raw_ostream *llvm::operator<<(llvm::raw_ostream *this, unsigned __int8 **a2)
{
  uint64_t v4 = *((void *)this + 4);
  if ((unint64_t)(*((void *)this + 3) - v4) > 8)
  {
    *(unsigned char *)(v4 + ++*(_DWORD *)(this + 8) = 32;
    *(void *)uint64_t v4 = *(void *)"Version: ";
    *((void *)this + 4) += 9;
  }
  else
  {
    llvm::raw_ostream::write(this, "Version: ", 9uLL);
  }
  uint64_t v13 = **a2;
  int v14 = 0;
  int v15 = 2;
  __int16 v16 = 1;
  char v17 = 1;
  llvm::raw_ostream::operator<<(this, (uint64_t)&v13);
  uint64_t v5 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v5)
  {
    llvm::raw_ostream::write(this, "\n", 1uLL);
    int v6 = (void *)*((void *)this + 4);
  }
  else
  {
    unsigned char *v5 = 10;
    int v6 = (void *)(*((void *)this + 4) + 1);
    *((void *)this + 4) = v6;
  }
  if (*((void *)this + 3) - (void)v6 > 0xDuLL)
  {
    qmemcpy(v6, "NumFunctions: ", 14);
    *((void *)this + 4) += 14;
  }
  else
  {
    llvm::raw_ostream::write(this, "NumFunctions: ", 0xEuLL);
  }
  sub_1CD098D14(this, *((unsigned int *)*a2 + 1), 0, 0, 0);
  uint64_t v7 = (unsigned char *)*((void *)this + 4);
  if (*((unsigned char **)this + 3) == v7)
  {
    llvm::raw_ostream::write(this, "\n", 1uLL);
  }
  else
  {
    *uint64_t v7 = 10;
    ++*((void *)this + 4);
  }
  int v8 = *((_DWORD *)*a2 + 1);
  if (v8)
  {
    BOOL v9 = 0;
    uint64_t v10 = 0;
    int v11 = 0;
    uint64_t v13 = 0;
    int v14 = 0;
    do
    {
      if (v11)
      {
        v10 += 12 * *(unsigned int *)(v10 + 8) + 16;
      }
      else
      {
        BOOL v9 = a2[1];
        uint64_t v10 = (uint64_t)(*a2 + 8);
      }
      uint64_t v13 = v10;
      int v14 = v9;
      llvm::operator<<(this, (uint64_t)&v13);
      ++v11;
    }
    while (v8 != v11);
  }
  return this;
}

void llvm::object::IRObjectFile::moveSymbolNext(uint64_t a1, void *a2)
{
  *a2 += 8;
}

void llvm::object::IRObjectFile::printSymbolName(uint64_t a1@<X0>, llvm::raw_ostream *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
}

uint64_t llvm::object::IRObjectFile::getSymbolFlags@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result = llvm::ModuleSymbolTable::getSymbolFlags(a1 + 72, *a2);
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(_DWORD *)a3 = result;
  return result;
}

__n128 llvm::object::IRObjectFile::findBitcodeInObject@<Q0>(__n128 *this@<X0>, const llvm::object::ObjectFile *a2@<X1>, __n128 *a3@<X8>)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (*(uint64_t (**)(__n128 *, const llvm::object::ObjectFile *))(this->n128_u64[0] + 344))(this, a2);
  uint64_t v7 = v6;
  int v8 = (llvm::object *)(*(uint64_t (**)(__n128 *))(this->n128_u64[0] + 352))(this);
  uint64_t v17 = v5;
  uint64_t v18 = v7;
  if (v7 == v9 && v5 == (void)v8) {
    goto LABEL_15;
  }
  int v11 = v8;
  uint64_t v12 = v9;
  while (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v7 + 224))(v7, v5))
  {
    int v8 = (llvm::object *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v18 + 128))(v18, &v17);
    uint64_t v5 = v17;
    uint64_t v7 = v18;
    if (v18 == v12 && v17 == (void)v11) {
      goto LABEL_15;
    }
  }
  int v8 = (llvm::object *)(*(void *(**)(unint64_t *__return_ptr))(*(void *)v18 + 168))(&v19);
  unint64_t v15 = v19;
  if (v21)
  {
    a3[2].n128_u8[0] |= 1u;
    a3->n128_u64[0] = v15;
    return result;
  }
  unint64_t v16 = v20;
  if (v20 <= 1)
  {
LABEL_15:
    *(void *)&v23.__val_ = llvm::object::object_category(v8);
    llvm::errorCodeToError((llvm *)7, v23, a3);
    a3[2].n128_u8[0] |= 1u;
  }
  else
  {
    a3[2].n128_u8[0] &= ~1u;
    a3->n128_u64[0] = v15;
    a3->n128_u64[1] = v16;
    __n128 result = this[2];
    a3[1] = result;
  }
  return result;
}

uint64_t llvm::object::IRObjectFile::create@<X0>(_OWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  long long v3 = a1[1];
  v25[0] = *a1;
  v25[1] = v3;
  uint64_t result = llvm::object::IRObjectFile::findBitcodeInMemBuffer((uint64_t)v25, (uint64_t)v30);
  if (v31)
  {
    uint64_t v13 = *(void *)&v30[0];
    *(unsigned char *)(a2 + 8) |= 1u;
    *(void *)a2 = v13;
  }
  else
  {
    v24[0] = v30[0];
    v24[1] = v30[1];
    llvm::getBitcodeModuleList(v24, (uint64_t)v28);
    if (v29)
    {
      uint64_t v14 = v28[0];
      v28[0] = 0;
      *(unsigned char *)(a2 + 8) |= 1u;
      *(void *)a2 = v14;
    }
    else
    {
      __p[0] = 0;
      __p[1] = 0;
      std::error_code v23 = 0;
      uint64_t v5 = (long long *)v28[0];
      uint64_t v6 = (long long *)v28[1];
      while (1)
      {
        if (v5 == v6) {
          operator new();
        }
        long long v7 = *v5;
        long long v8 = v5[1];
        long long v9 = v5[3];
        v21[2] = v5[2];
        v21[3] = v9;
        v21[0] = v7;
        v21[1] = v8;
        llvm::BitcodeModule::getLazyModule((llvm::BitcodeModule *)v21, (uint64_t)&v26);
        if (v27) {
          break;
        }
        uint64_t v10 = (char *)__p[1];
        if (__p[1] >= v23)
        {
          uint64_t v12 = sub_1CCC4B63C((char **)__p, &v26);
        }
        else
        {
          uint64_t v11 = v26;
          uint64_t v26 = 0;
          *(void *)__p[1] = v11;
          uint64_t v12 = v10 + 8;
        }
        __p[1] = v12;
        sub_1CC1CC83C((uint64_t)&v26);
        v5 += 4;
      }
      uint64_t v15 = v26;
      uint64_t v26 = 0;
      *(unsigned char *)(a2 + 8) |= 1u;
      *(void *)a2 = v15;
      sub_1CC1CC83C((uint64_t)&v26);
      unint64_t v16 = __p[0];
      if (__p[0])
      {
        uint64_t v17 = __p[1];
        uint64_t v18 = __p[0];
        if (__p[1] != __p[0])
        {
          do
          {
            unint64_t v20 = (llvm::Module *)*--v17;
            unint64_t v19 = v20;
            *uint64_t v17 = 0;
            if (v20)
            {
              llvm::Module::~Module(v19);
              MEMORY[0x1D25D9CE0]();
            }
          }
          while (v17 != v16);
          uint64_t v18 = __p[0];
        }
        __p[1] = v16;
        operator delete(v18);
      }
    }
    return sub_1CC1EB7C0((uint64_t)v28);
  }
  return result;
}

void llvm::object::readIRSymtab(_OWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v17 = 0;
  uint64_t v18 = &v21;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  char v21 = &v23;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v3 = a1[1];
  v15[0] = *a1;
  v15[1] = v3;
  llvm::object::IRObjectFile::findBitcodeInMemBuffer((uint64_t)v15, (uint64_t)v41);
  if (v42)
  {
    uint64_t v5 = *(void *)&v41[0];
    *(unsigned char *)(a2 + 184) |= 1u;
    *(void *)a2 = v5;
    goto LABEL_31;
  }
  v14[0] = v41[0];
  v14[1] = v41[1];
  llvm::getBitcodeFileContents((uint64_t)v14, (uint64_t)&v38);
  if ((v40 & 1) == 0)
  {
    llvm::irsymtab::readBitcode((llvm *)&v38, (uint64_t)&v30);
    if (v37)
    {
      long long v7 = v30;
      std::string::size_type v30 = 0;
      *(unsigned char *)(a2 + 184) |= 1u;
      *(void *)a2 = v7;
    }
    else
    {
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      *(_OWORD *)std::string __p = v38;
      uint64_t v17 = v39;
      uint64_t v39 = 0;
      long long v38 = 0uLL;
      uint64_t v4 = v31;
      if (v31)
      {
        if (v18 != &v21)
        {
          free(v18);
          uint64_t v4 = v31;
        }
        uint64_t v18 = v30;
        uint64_t v19 = v4;
        uint64_t v20 = v32;
        std::string::size_type v30 = &v33;
        uint64_t v31 = 0;
        uint64_t v32 = 0;
      }
      else
      {
        uint64_t v19 = 0;
      }
      uint64_t v9 = v34;
      if (v34)
      {
        if (v21 != &v23)
        {
          free(v21);
          uint64_t v9 = v34;
          uint64_t v4 = v19;
        }
        char v21 = v33;
        *(void *)&long long v22 = v9;
        *((void *)&v22 + 1) = v35;
        char v33 = v36;
        uint64_t v34 = 0;
        uint64_t v35 = 0;
      }
      else
      {
        *(void *)&long long v22 = 0;
      }
      long long v27 = v36[4];
      long long v28 = v36[5];
      long long v29 = v36[6];
      long long v23 = v36[0];
      long long v24 = v36[1];
      long long v25 = v36[2];
      long long v26 = v36[3];
      *(unsigned char *)(a2 + 184) &= ~1u;
      *(_OWORD *)a2 = *(_OWORD *)__p;
      uint64_t v10 = v17;
      *(void *)(a2 + 24) = a2 + 48;
      *(void *)(a2 + ++*(_DWORD *)(this + 16) = v10;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v17 = 0;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      if (v4)
      {
        sub_1CC1B8518(a2 + 24, (uint64_t)&v18);
        uint64_t v9 = v22;
      }
      *(void *)(a2 + 56) = 0;
      *(void *)(a2 + 64) = 0;
      *(void *)(a2 + 4++*(_DWORD *)(this + 8) = a2 + 72;
      if (v9) {
        sub_1CC1B8518(a2 + 48, (uint64_t)&v21);
      }
      long long v11 = v28;
      *(_OWORD *)(a2 + 136) = v27;
      *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = v11;
      *(_OWORD *)(a2 + 16++*(_DWORD *)(this + 8) = v29;
      long long v12 = v24;
      *(_OWORD *)(a2 + 72) = v23;
      *(_OWORD *)(a2 + 8++*(_DWORD *)(this + 8) = v12;
      long long v13 = v26;
      *(_OWORD *)(a2 + 104) = v25;
      *(_OWORD *)(a2 + 120) = v13;
      if ((v37 & 1) == 0)
      {
        if (v33 != v36) {
          free(v33);
        }
        if (v30 != &v33) {
          free(v30);
        }
        goto LABEL_30;
      }
    }
    long long v8 = v30;
    std::string::size_type v30 = 0;
    if (v8) {
      (*(void (**)(void *))(*(void *)v8 + 8))(v8);
    }
    goto LABEL_30;
  }
  uint64_t v6 = v38;
  *(void *)&long long v38 = 0;
  *(unsigned char *)(a2 + 184) |= 1u;
  *(void *)a2 = v6;
LABEL_30:
  sub_1CC1EBA40((uint64_t)&v38);
LABEL_31:
  if (v21 != &v23) {
    free(v21);
  }
  if (v18 != &v21) {
    free(v18);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

uint64_t sub_1CCC4B504(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 128), 8);
  uint64_t v2 = *(void **)(a1 + 104);
  if (v2)
  {
    *(void *)(a1 + 112) = v2;
    operator delete(v2);
  }
  sub_1CCB7266C(a1 + 8);
  uint64_t v3 = *(unsigned int *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = *(uint64_t **)(a1 + 24);
    uint64_t v5 = 8 * v3;
    do
    {
      uint64_t v6 = *v4++;
      MEMORY[0x1D25D9CD0](v6, 8);
      v5 -= 8;
    }
    while (v5);
  }
  long long v7 = *(uint64_t **)(a1 + 72);
  uint64_t v8 = *(unsigned int *)(a1 + 80);
  if (v8)
  {
    uint64_t v11 = 16 * v8;
    do
    {
      uint64_t v12 = *v7;
      v7 += 2;
      MEMORY[0x1D25D9CD0](v12, 8);
      v11 -= 16;
    }
    while (v11);
    long long v7 = *(uint64_t **)(a1 + 72);
  }
  if (v7 != (uint64_t *)(a1 + 88)) {
    free(v7);
  }
  uint64_t v9 = *(void **)(a1 + 24);
  if (v9 != (void *)(a1 + 40)) {
    free(v9);
  }
  return a1;
}

llvm::Module *sub_1CCC4B5D4(llvm::Module *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (void *)*((void *)result + 1);
  while (v4 != a2)
  {
    uint64_t v5 = (llvm::Module *)*--v4;
    uint64_t result = v5;
    void *v4 = 0;
    if (v5)
    {
      llvm::Module::~Module(result);
      uint64_t result = (llvm::Module *)MEMORY[0x1D25D9CE0]();
    }
  }
  *((void *)v3 + 1) = a2;
  return result;
}

char *sub_1CCC4B63C(char **a1, uint64_t *a2)
{
  uint64_t v2 = (a1[1] - *a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v6 = a1[2] - *a1;
  if (v6 >> 2 > v3) {
    unint64_t v3 = v6 >> 2;
  }
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v7 = v3;
  }
  if (v7)
  {
    if (v7 >> 61) {
      sub_1CB833614();
    }
    uint64_t v8 = (char *)operator new(8 * v7);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v9 = &v8[8 * v2];
  uint64_t v10 = &v8[8 * v7];
  uint64_t v11 = *a2;
  *a2 = 0;
  *(void *)uint64_t v9 = v11;
  uint64_t v12 = v9 + 8;
  long long v13 = *a1;
  uint64_t v14 = a1[1];
  if (v14 == *a1)
  {
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
  }
  else
  {
    do
    {
      uint64_t v15 = *((void *)v14 - 1);
      v14 -= 8;
      *(void *)uint64_t v14 = 0;
      *((void *)v9 - 1) = v15;
      v9 -= 8;
    }
    while (v14 != v13);
    uint64_t v14 = *a1;
    unint64_t v16 = a1[1];
    *a1 = v9;
    a1[1] = v12;
    a1[2] = v10;
    while (v16 != v14)
    {
      uint64_t v18 = (llvm::Module *)*((void *)v16 - 1);
      v16 -= 8;
      uint64_t v17 = v18;
      *(void *)unint64_t v16 = 0;
      if (v18)
      {
        llvm::Module::~Module(v17);
        MEMORY[0x1D25D9CE0]();
      }
    }
  }
  if (v14) {
    operator delete(v14);
  }
  return v12;
}

uint64_t llvm::irsymtab::build@<X0>(llvm::Module **a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X8>)
{
  uint64_t v372 = *MEMORY[0x1E4F143B8];
  int v327 = 0;
  char v331 = 0;
  uint64_t v332 = 0;
  v313[0] = 0;
  v313[1] = 0;
  int v314 = 0;
  v315[0] = 0;
  v315[1] = 0;
  int v316 = 0;
  memset(__p, 0, sizeof(__p));
  long long v318 = 0u;
  long long v319 = 0u;
  long long v320 = 0u;
  long long v321 = 0u;
  long long v322 = 0u;
  long long v323 = 0u;
  long long v324 = 0u;
  int v333 = 0;
  __int16 v334 = &v324;
  __src = 0;
  char v336 = 0;
  unint64_t v337 = 0;
  uint64_t v325 = 0;
  int v326 = &unk_1F2646F30;
  uint64_t v328 = 0;
  uint64_t v329 = 0;
  long long __dst = 0;
  uint64_t v10 = qword_1EBCEF408;
  if (qword_1EBCEF408) {
    size_t v11 = strlen((const char *)qword_1EBCEF408);
  }
  else {
    size_t v11 = 0;
  }
  unsigned int v12 = v11;
  unsigned int v13 = sub_1CD0B03C8((void *)qword_1EBCEF408, qword_1EBCEF408 + v11);
  unsigned int v296 = v12;
  int v294 = llvm::StringTableBuilder::add(a4, v10, v12 | ((unint64_t)v13 << 32));
  char v14 = *((unsigned char *)*a1 + 239);
  if (v14 >= 0) {
    uint64_t v15 = (void *)((char *)*a1 + 216);
  }
  else {
    uint64_t v15 = (void *)*((void *)*a1 + 27);
  }
  if (v14 >= 0) {
    uint64_t v16 = v14 & 0x7F;
  }
  else {
    uint64_t v16 = *((void *)*a1 + 28);
  }
  unsigned int v17 = sub_1CD0B03C8(v15, (uint64_t)v15 + v16);
  int v295 = v16;
  int v293 = llvm::StringTableBuilder::add(a4, (uint64_t)v15, v16 | ((unint64_t)v17 << 32));
  char v18 = *((unsigned char *)*a1 + 215);
  if (v18 >= 0) {
    uint64_t v19 = (void *)((char *)*a1 + 192);
  }
  else {
    uint64_t v19 = (void *)*((void *)*a1 + 24);
  }
  if (v18 >= 0) {
    uint64_t v20 = v18 & 0x7F;
  }
  else {
    uint64_t v20 = *((void *)*a1 + 25);
  }
  unsigned int v21 = sub_1CD0B03C8(v19, (uint64_t)v19 + v20);
  int v292 = v20;
  int v291 = llvm::StringTableBuilder::add(a4, (uint64_t)v19, v20 | ((unint64_t)v21 << 32));
  long long v22 = (char *)*a1 + 216;
  __int16 v371 = 260;
  uint64_t v368 = (char *)v22;
  long long v23 = llvm::Triple::Triple((llvm::Triple *)&v355, (const llvm::Twine *)&v368);
  if (SBYTE7(__p[1]) < 0) {
    operator delete(*(void **)&__p[0]);
  }
  __p[0] = v355;
  *(void *)&__p[1] = v356;
  *(_OWORD *)((char *)&__p[1] + ++*(_DWORD *)(this + 8) = v357;
  *((void *)&__p[2] + 1) = v358[0];
  uint64_t v303 = a6;
  if (a2)
  {
    uint64_t v297 = &a1[a2];
    do
    {
      long long v24 = *a1;
      if (*((char *)*a1 + 503) < 0)
      {
        if (!*((void *)v24 + 61))
        {
LABEL_471:
          llvm::inconvertibleErrorCode(v23);
          operator new();
        }
      }
      else if (!*((unsigned char *)*a1 + 503))
      {
        goto LABEL_471;
      }
      unint64_t v298 = a1;
      int v365 = (llvm *)v367;
      uint64_t v366 = 0x400000000;
      llvm::collectUsedGlobalVariables((uint64_t)v24, (uint64_t)&v365, 0);
      llvm::collectUsedGlobalVariables((uint64_t)v24, (uint64_t)&v365, 1);
      sub_1CC92C6E4((uint64_t)&v338, v365, (void *)v365 + v366);
      long long v355 = 0uLL;
      uint64_t v356 = 0;
      *(void *)&long long v357 = v358;
      *((void *)&v357 + 1) = 0x400000000;
      v359 = (char *)&v360 + 8;
      long long v360 = 0u;
      long long v361 = 0u;
      long long v362 = 0u;
      long long v363 = 0u;
      int v364 = 0;
      llvm::ModuleSymbolTable::addModule((llvm::ModuleSymbolTable *)&v355, v24);
      int v25 = -1431655765 * ((*((void *)&v321 + 1) - (void)v321) >> 3);
      int v26 = (((void)v362 - *((void *)&v361 + 1)) >> 3) - 1431655765 * ((*((void *)&v321 + 1) - (void)v321) >> 3);
      int v27 = -1431655765 * (((void)v323 - *((void *)&v322 + 1)) >> 3);
      long long v28 = (_DWORD *)v320;
      if ((unint64_t)v320 >= *((void *)&v320 + 1))
      {
        std::string::size_type v30 = (_DWORD *)*((void *)&v319 + 1);
        unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v320 - *((void *)&v319 + 1)) >> 2);
        unint64_t v32 = v31 + 1;
        if (v31 + 1 > 0x1555555555555555) {
LABEL_493:
        }
          abort();
        if (0x5555555555555556 * ((uint64_t)(*((void *)&v320 + 1) - *((void *)&v319 + 1)) >> 2) > v32) {
          unint64_t v32 = 0x5555555555555556 * ((uint64_t)(*((void *)&v320 + 1) - *((void *)&v319 + 1)) >> 2);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v320 + 1) - *((void *)&v319 + 1)) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
          unint64_t v33 = 0x1555555555555555;
        }
        else {
          unint64_t v33 = v32;
        }
        if (v33)
        {
          if (v33 > 0x1555555555555555) {
LABEL_494:
          }
            sub_1CB833614();
          uint64_t v34 = (char *)operator new(12 * v33);
        }
        else
        {
          uint64_t v34 = 0;
        }
        uint64_t v35 = &v34[12 * v31];
        *(_DWORD *)uint64_t v35 = v25;
        *((_DWORD *)v35 + 1) = v26;
        *((_DWORD *)v35 + 2) = v27;
        uint64_t v36 = v35;
        if (v28 == v30)
        {
          a6 = v303;
        }
        else
        {
          a6 = v303;
          do
          {
            uint64_t v37 = *(void *)(v28 - 3);
            v28 -= 3;
            int v38 = v28[2];
            *(void *)(v36 - 12) = v37;
            v36 -= 12;
            *((_DWORD *)v36 + 2) = v38;
          }
          while (v28 != v30);
          long long v28 = (_DWORD *)*((void *)&v319 + 1);
        }
        long long v29 = v35 + 12;
        *((void *)&v319 + 1) = v36;
        *(void *)&long long v320 = v35 + 12;
        *((void *)&v320 + 1) = &v34[12 * v33];
        if (v28) {
          operator delete(v28);
        }
      }
      else
      {
        *(_DWORD *)long long v320 = v25;
        v28[1] = v26;
        long long v29 = v28 + 3;
        v28[2] = v27;
      }
      *(void *)&long long v320 = v29;
      int v39 = HIDWORD(__p[2]);
      if (HIDWORD(__p[2]) == 1)
      {
        uint64_t v40 = *((void *)v24 + 20);
        if (v40)
        {
          (*(void (**)(uint64_t))(*(void *)v40 + 32))(v40);
          if (*a6) {
            goto LABEL_434;
          }
        }
        else
        {
          *a6 = 0;
        }
        uint64_t v368 = "llvm.linker.options";
        __int16 v371 = 259;
        uint64_t NamedMetadata = llvm::Module::getNamedMetadata(v24, (const char **)&v368);
        if (NamedMetadata)
        {
          uint64_t v42 = NamedMetadata;
          uint64_t v43 = *(unsigned int *)(*(void *)(NamedMetadata + 48) + 8);
          if (v43)
          {
            for (uint64_t i = 0; i != v43; ++i)
            {
              uint64_t v45 = *(void *)(**(void **)(v42 + 48) + 8 * i);
              uint64_t v46 = *(unsigned int *)(v45 + 8);
              if (v46)
              {
                uint64_t v47 = -8 * v46;
                do
                {
                  if (v329 == __dst)
                  {
                    llvm::raw_ostream::write((llvm::raw_ostream *)&v326, " ", 1uLL);
                    std::string::size_type v48 = (char *)__dst;
                  }
                  else
                  {
                    *(unsigned char *)long long __dst = 32;
                    std::string::size_type v48 = (char *)__dst + 1;
                    long long __dst = (char *)__dst + 1;
                  }
                  char v49 = *(size_t **)(*(void *)(v45 + v47) + 8);
                  size_t v52 = *v49;
                  char v50 = v49 + 3;
                  size_t v51 = v52;
                  if (v52 <= v329 - v48)
                  {
                    if (v51)
                    {
                      memcpy(v48, v50, v51);
                      long long __dst = (char *)__dst + v51;
                    }
                  }
                  else
                  {
                    llvm::raw_ostream::write((llvm::raw_ostream *)&v326, (const char *)v50, v51);
                  }
                  v47 += 8;
                }
                while (v47);
              }
            }
          }
        }
        int v39 = HIDWORD(__p[2]);
      }
      if (v39 == 3)
      {
        uint64_t v53 = *((void *)v24 + 20);
        if (v53)
        {
          (*(void (**)(uint64_t))(*(void *)v53 + 32))(v53);
          if (*a6) {
            goto LABEL_434;
          }
        }
        else
        {
          *a6 = 0;
        }
        uint64_t v368 = "llvm.dependent-libraries";
        __int16 v371 = 259;
        uint64_t v54 = llvm::Module::getNamedMetadata(v24, (const char **)&v368);
        if (v54)
        {
          uint64_t v55 = v54;
          uint64_t v56 = *(unsigned int *)(*(void *)(v54 + 48) + 8);
          if (v56)
          {
            for (uint64_t j = 0; j != v56; ++j)
            {
              uint64_t v58 = *(void *)(**(void **)(v55 + 48) + 8 * j);
              char v59 = *(uint64_t **)(*(void *)(v58 - 8 * *(unsigned int *)(v58 + 8)) + 8);
              uint64_t v61 = *v59;
              v59 += 3;
              unsigned int v60 = v61;
              unsigned int v62 = sub_1CD0B03C8(v59, (uint64_t)v59 + v61);
              unsigned int v63 = llvm::StringTableBuilder::add(a4, (uint64_t)v59, v61 | ((unint64_t)v62 << 32));
              unsigned int v64 = v63;
              uint64_t v65 = v336;
              if ((unint64_t)v336 >= v337)
              {
                uint64_t v67 = (char *)__src;
                int64_t v68 = (v336 - (unsigned char *)__src) >> 3;
                unint64_t v69 = v68 + 1;
                if ((unint64_t)(v68 + 1) >> 61) {
                  goto LABEL_493;
                }
                uint64_t v70 = v337 - (void)__src;
                if ((uint64_t)(v337 - (void)__src) >> 2 > v69) {
                  unint64_t v69 = v70 >> 2;
                }
                if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v71 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v71 = v69;
                }
                if (v71)
                {
                  if (v71 >> 61) {
                    goto LABEL_494;
                  }
                  uint64_t v72 = (char *)operator new(8 * v71);
                }
                else
                {
                  uint64_t v72 = 0;
                }
                unsigned int v73 = &v72[8 * v68];
                *(void *)unsigned int v73 = v64 | ((unint64_t)v60 << 32);
                uint64_t v66 = v73 + 8;
                if (v65 != v67)
                {
                  do
                  {
                    uint64_t v74 = *((void *)v65 - 1);
                    v65 -= 8;
                    *((void *)v73 - 1) = v74;
                    v73 -= 8;
                  }
                  while (v65 != v67);
                  uint64_t v65 = (char *)__src;
                }
                __src = v73;
                char v336 = v66;
                unint64_t v337 = (unint64_t)&v72[8 * v71];
                if (v65) {
                  operator delete(v65);
                }
                a6 = v303;
              }
              else
              {
                *(void *)char v336 = v63 | ((unint64_t)v60 << 32);
                uint64_t v66 = v65 + 8;
              }
              char v336 = v66;
            }
          }
        }
      }
      std::string::size_type v75 = (uint64_t *)*((void *)&v361 + 1);
      std::string::size_type v306 = (uint64_t *)v362;
      if ((void)v362 != *((void *)&v361 + 1))
      {
        do
        {
          uint64_t v76 = *v75;
          uint64_t v77 = (void *)*((void *)&v321 + 1);
          if (*((void *)&v321 + 1) >= (unint64_t)v322)
          {
            uint64_t v79 = (void *)v321;
            unint64_t v80 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v321 + 1) - v321) >> 3);
            unint64_t v81 = v80 + 1;
            if (v80 + 1 > 0xAAAAAAAAAAAAAAALL) {
              goto LABEL_493;
            }
            if (0x5555555555555556 * ((uint64_t)(v322 - v321) >> 3) > v81) {
              unint64_t v81 = 0x5555555555555556 * ((uint64_t)(v322 - v321) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v322 - v321) >> 3) >= 0x555555555555555) {
              unint64_t v82 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v82 = v81;
            }
            if (v82)
            {
              if (v82 > 0xAAAAAAAAAAAAAAALL) {
                goto LABEL_494;
              }
              std::string::size_type v83 = (char *)operator new(24 * v82);
            }
            else
            {
              std::string::size_type v83 = 0;
            }
            unint64_t v84 = &v83[24 * v80];
            *(void *)unint64_t v84 = 0;
            *((void *)v84 + 1) = 0;
            *((void *)v84 + 2) = 0;
            char v85 = v84;
            if (v77 != v79)
            {
              do
              {
                long long v86 = *(_OWORD *)(v77 - 3);
                *((void *)v85 - 1) = *(v77 - 1);
                *(_OWORD *)(v85 - 24) = v86;
                v85 -= 24;
                v77 -= 3;
              }
              while (v77 != v79);
              uint64_t v77 = (void *)v321;
            }
            unint64_t v78 = v84 + 24;
            *(void *)&long long v321 = v85;
            *((void *)&v321 + 1) = v84 + 24;
            *(void *)&long long v322 = &v83[24 * v82];
            if (v77) {
              operator delete(v77);
            }
          }
          else
          {
            **((void **)&v321 + 1) = 0;
            v77[1] = 0;
            unint64_t v78 = v77 + 3;
            v77[2] = 0;
          }
          std::string::size_type v308 = v75;
          *((void *)&v321 + 1) = v78;
          *(v78 - 3) = 0;
          *(v78 - 2) = 0;
          *(v78 - 1) = 0;
          uint64_t v368 = (char *)&v370;
          long long v369 = xmmword_1CD96DBD0;
          DWORD2(v342) = 0;
          char v346 = 0;
          uint64_t v347 = 0;
          *(void *)&long long v342 = &unk_1F2646FA8;
          v349 = (const char **)&v368;
          int v348 = 0;
          uint64_t v344 = 0;
          int v345 = 0;
          v343 = 0;
          llvm::ModuleSymbolTable::printSymbolName((uint64_t)&v355, (llvm::raw_ostream *)&v342, v76);
          *(void *)&long long v342 = &unk_1F2646B98;
          if (v348 == 1 && v343) {
            MEMORY[0x1D25D9CB0](v343, 0x1000C8077774924);
          }
          unint64_t v88 = v368;
          size_t v87 = v369;
          uint64_t v89 = (void *)sub_1CB906F34(a5, v369 + 1, 0);
          uint64_t v90 = v89;
          if (v87) {
            memcpy(v89, v88, v87);
          }
          *((unsigned char *)v90 + v87) = 0;
          unsigned int v91 = sub_1CD0B03C8(v90, (uint64_t)v90 + v87);
          *((_DWORD *)v78 - 6) = llvm::StringTableBuilder::add(a4, (uint64_t)v90, v87 | ((unint64_t)v91 << 32));
          *((_DWORD *)v78 - 5) = v87;
          int SymbolFlags = llvm::ModuleSymbolTable::getSymbolFlags((uint64_t)&v355, v76);
          int v93 = SymbolFlags;
          if (SymbolFlags)
          {
            *((_DWORD *)v78 - 1) |= 8u;
            if ((SymbolFlags & 4) == 0)
            {
LABEL_110:
              if ((SymbolFlags & 0x10) == 0) {
                goto LABEL_111;
              }
              goto LABEL_131;
            }
          }
          else if ((SymbolFlags & 4) == 0)
          {
            goto LABEL_110;
          }
          *((_DWORD *)v78 - 1) |= 0x10u;
          if ((SymbolFlags & 0x10) == 0)
          {
LABEL_111:
            if ((SymbolFlags & 0x20) == 0) {
              goto LABEL_112;
            }
            goto LABEL_132;
          }
LABEL_131:
          *((_DWORD *)v78 - 1) |= 0x20u;
          if ((SymbolFlags & 0x20) == 0)
          {
LABEL_112:
            if ((SymbolFlags & 2) == 0) {
              goto LABEL_113;
            }
            goto LABEL_133;
          }
LABEL_132:
          *((_DWORD *)v78 - 1) |= 0x40u;
          if ((SymbolFlags & 2) == 0)
          {
LABEL_113:
            if ((SymbolFlags & 0x80) != 0) {
              goto LABEL_134;
            }
            goto LABEL_114;
          }
LABEL_133:
          *((_DWORD *)v78 - 1) |= 0x400u;
          if ((SymbolFlags & 0x80) != 0)
          {
LABEL_134:
            *((_DWORD *)v78 - 1) |= 0x800u;
            if ((SymbolFlags & 0x800) == 0) {
              goto LABEL_116;
            }
LABEL_115:
            *((_DWORD *)v78 - 1) |= 0x2000u;
            goto LABEL_116;
          }
LABEL_114:
          if ((SymbolFlags & 0x800) != 0) {
            goto LABEL_115;
          }
LABEL_116:
          *((_DWORD *)v78 - 2) = -1;
          if ((v76 & 4) != 0 || (char v94 = (uint64_t ***)(v76 & 0xFFFFFFFFFFFFFFF8)) == 0)
          {
            if (SymbolFlags) {
              *((_DWORD *)v78 - 1) |= 0x80u;
            }
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EBCBE588))
            {
              unint64_t v257 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v257 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v257;
              __cxa_guard_release(&qword_1EBCBE588);
            }
            uint64_t v104 = 0;
            *((_DWORD *)v78 - 4) = llvm::StringTableBuilder::add(a4, (uint64_t)"", (qword_1EBCBE580 << 32) ^ 0x2F90404F00000000);
            *((_DWORD *)v78 - 3) = 0;
            goto LABEL_309;
          }
          unsigned int v95 = v94 >> 4;
          if ((*((unsigned char *)v94 + 23) & 0x10) != 0)
          {
            uint64_t v96 = ***v94;
            uint64_t v97 = *(void *)(v96 + 152);
            uint64_t v98 = *(unsigned int *)(v96 + 168);
            if (!v98) {
              goto LABEL_136;
            }
            LODWORD(v99) = (v98 - 1) & (v95 ^ (v94 >> 9));
            std::string::size_type v100 = (uint64_t ****)(v97 + 16 * v99);
            std::string::size_type v101 = *v100;
            if (*v100 != v94)
            {
              int v102 = 1;
              while (v101 != (uint64_t ***)-4096)
              {
                int v103 = v99 + v102++;
                uint64_t v99 = v103 & (v98 - 1);
                std::string::size_type v101 = *(uint64_t ****)(v97 + 16 * v99);
                if (v101 == v94)
                {
                  std::string::size_type v100 = (uint64_t ****)(v97 + 16 * v99);
                  goto LABEL_137;
                }
              }
LABEL_136:
              std::string::size_type v100 = (uint64_t ****)(v97 + 16 * v98);
            }
LABEL_137:
            char v105 = v100[1];
            int64_t v108 = *v105;
            char v106 = (char *)(v105 + 2);
            long long v107 = v108;
            goto LABEL_138;
          }
          long long v107 = 0;
          char v106 = &byte_1CFBCE98E;
LABEL_138:
          unsigned int v109 = sub_1CD0B03C8(v106, (uint64_t)v107 + (void)v106);
          *((_DWORD *)v78 - 4) = llvm::StringTableBuilder::add(a4, (uint64_t)v106, v107 | ((unint64_t)v109 << 32));
          *((_DWORD *)v78 - 3) = v107;
          if ((*((unsigned char *)v94 + 23) & 0x10) != 0)
          {
            uint64_t v110 = ***v94;
            uint64_t v111 = *(void *)(v110 + 152);
            uint64_t v112 = *(unsigned int *)(v110 + 168);
            if (!v112) {
              goto LABEL_145;
            }
            LODWORD(v113) = (v112 - 1) & (v95 ^ (v94 >> 9));
            unint64_t v114 = (uint64_t ****)(v111 + 16 * v113);
            unint64_t v115 = *v114;
            if (*v114 != v94)
            {
              int v116 = 1;
              while (v115 != (uint64_t ***)-4096)
              {
                int v117 = v113 + v116++;
                uint64_t v113 = v117 & (v112 - 1);
                unint64_t v115 = *(uint64_t ****)(v111 + 16 * v113);
                if (v115 == v94)
                {
                  unint64_t v114 = (uint64_t ****)(v111 + 16 * v113);
                  goto LABEL_146;
                }
              }
LABEL_145:
              unint64_t v114 = (uint64_t ****)(v111 + 16 * v112);
            }
LABEL_146:
            uint64_t v118 = v114[1];
            size_t v121 = (size_t)*v118;
            uint64_t v119 = (char *)(v118 + 2);
            size_t v120 = v121;
            goto LABEL_147;
          }
          size_t v120 = 0;
          uint64_t v119 = &byte_1CFBCE98E;
LABEL_147:
          uint64_t v122 = 5120;
          int v123 = (const char **)off_1EA6167D0;
          while (1)
          {
            size_t v124 = *v123 ? strlen(*v123) : 0;
            if (v124 == v120)
            {
              if (!v120) {
                break;
              }
              size_t v124 = memcmp(*v123, v119, v120);
              if (!v124) {
                break;
              }
            }
            ++v123;
            v122 -= 8;
            if (!v122)
            {
              int v123 = (const char **)&llvm::object::WasmSectionOrderChecker::DisallowedPredecessors;
              break;
            }
          }
          long long v125 = v338;
          if (v339 == v338)
          {
            unsigned int v126 = v341;
            std::string::size_type v127 = (char *)v339 + 8 * v341;
            if (v341)
            {
              uint64_t v128 = 0;
              while (*(uint64_t ****)((char *)v339 + v128) != v94)
              {
                v128 += 8;
                if (8 * v341 == v128) {
                  goto LABEL_175;
                }
              }
              std::string::size_type v127 = (char *)v339 + v128;
            }
LABEL_175:
            long long v125 = v339;
          }
          else
          {
            unsigned int v129 = v340 - 1;
            unsigned int v130 = (v340 - 1) & (v95 ^ (v94 >> 9));
            std::string::size_type v127 = (char *)v339 + 8 * v130;
            uint64_t v131 = *(uint64_t ****)v127;
            if (*(void *)v127 == -1)
            {
              std::string::size_type v132 = 0;
LABEL_208:
              if (v132) {
                std::string::size_type v127 = v132;
              }
              unsigned int v126 = v341;
              if (*(uint64_t ****)v127 != v94) {
                std::string::size_type v127 = (char *)v339 + 8 * v340;
              }
            }
            else
            {
              std::string::size_type v132 = 0;
              int v133 = 1;
              while (v131 != v94)
              {
                if (v132) {
                  BOOL v134 = 0;
                }
                else {
                  BOOL v134 = v131 == (uint64_t ***)-2;
                }
                if (v134) {
                  std::string::size_type v132 = v127;
                }
                unsigned int v135 = v130 + v133++;
                unsigned int v130 = v135 & v129;
                std::string::size_type v127 = (char *)v339 + 8 * (v135 & v129);
                uint64_t v131 = *(uint64_t ****)v127;
                if (*(void *)v127 == -1) {
                  goto LABEL_208;
                }
              }
              unsigned int v126 = v341;
            }
          }
          if (v339 == v125) {
            unsigned int v136 = v126;
          }
          else {
            unsigned int v136 = v340;
          }
          if (v127 != (char *)v339 + 8 * v136 || (char *)v123 - (char *)off_1EA6167D0 != 5120) {
            *((_DWORD *)v78 - 1) |= 0x80u;
          }
          unsigned int v138 = *((_DWORD *)v94 + 8);
          if ((v138 & 0x1C00) != 0)
          {
            *((_DWORD *)v78 - 1) |= 0x100u;
            unsigned int v138 = *((_DWORD *)v94 + 8);
          }
          if ((v138 & 0xC0) == 0x80)
          {
            *((_DWORD *)v78 - 1) |= 0x1000u;
            unsigned int v138 = *((_DWORD *)v94 + 8);
          }
          if ((v138 & 0xF) != 3) {
            goto LABEL_189;
          }
          if ((v138 & 0xC0) == 0x80)
          {
            int v139 = *((_DWORD *)v78 - 1);
LABEL_260:
            v139 |= 0x200u;
            *((_DWORD *)v78 - 1) = v139;
            unsigned int v138 = *((_DWORD *)v94 + 8);
            goto LABEL_190;
          }
          if (*((unsigned char *)v94 + 16) != 3 || ((_BYTE)v94[10] & 1) != 0)
          {
            int v139 = *((_DWORD *)v78 - 1);
            if ((v138 & 0xC0) != 0) {
              goto LABEL_260;
            }
          }
          else
          {
LABEL_189:
            int v139 = *((_DWORD *)v78 - 1);
          }
LABEL_190:
          *((_DWORD *)v78 - 1) = (v138 >> 4) & 3 | v139;
          if ((v93 & 0x10) != 0)
          {
            if (*((unsigned char *)v94 + 16) != 3)
            {
              llvm::inconvertibleErrorCode((llvm *)v124);
              operator new();
            }
            unint64_t v141 = (llvm::DataLayout *)(v94[5] + 34);
            uint64_t v142 = (llvm::Type *)v94[3];
            uint64_t v143 = sub_1CB83544C((uint64_t)v141, (uint64_t)v142);
            BOOL v145 = v144 == 1;
            char Alignment = llvm::DataLayout::getAlignment(v141, v142, 1);
            if (v145) {
            *((_DWORD *)v78 - 1) |= 4u;
            }
            unint64_t v148 = (void *)v323;
            if ((unint64_t)v323 >= *((void *)&v323 + 1))
            {
              long long v150 = (void *)*((void *)&v322 + 1);
              unint64_t v151 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v323 - *((void *)&v322 + 1)) >> 3);
              unint64_t v152 = v151 + 1;
              if (v151 + 1 > 0xAAAAAAAAAAAAAAALL) {
                goto LABEL_493;
              }
              if (0x5555555555555556 * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3) > v152) {
                unint64_t v152 = 0x5555555555555556 * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3) >= 0x555555555555555) {
                unint64_t v153 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                unint64_t v153 = v152;
              }
              if (v153)
              {
                if (v153 > 0xAAAAAAAAAAAAAAALL) {
                  goto LABEL_494;
                }
                std::string::size_type v154 = (char *)operator new(24 * v153);
              }
              else
              {
                std::string::size_type v154 = 0;
              }
              char v155 = &v154[24 * v151];
              *(void *)char v155 = 0;
              *((void *)v155 + 1) = 0;
              *((void *)v155 + 2) = 0;
              char v156 = v155;
              if (v148 != v150)
              {
                do
                {
                  long long v157 = *(_OWORD *)(v148 - 3);
                  *((void *)v156 - 1) = *(v148 - 1);
                  *(_OWORD *)(v156 - 24) = v157;
                  v156 -= 24;
                  v148 -= 3;
                }
                while (v148 != v150);
                unint64_t v148 = (void *)*((void *)&v322 + 1);
              }
              char v158 = &v154[24 * v153];
              unint64_t v149 = v155 + 24;
              *((void *)&v322 + 1) = v156;
              *(void *)&long long v323 = v155 + 24;
              *((void *)&v323 + 1) = v158;
              if (v148) {
                operator delete(v148);
              }
            }
            else
            {
              *(void *)long long v323 = 0;
              v148[1] = 0;
              unint64_t v149 = v148 + 3;
              v148[2] = 0;
            }
            *(void *)&long long v323 = v149;
            *(v149 - 3) = 0;
            *(v149 - 2) = 0;
            *(v149 - 1) = 0;
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EBCBE588))
            {
              unint64_t v258 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v258 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v258;
              __cxa_guard_release(&qword_1EBCBE588);
            }
            *((_DWORD *)v149 - 4) = llvm::StringTableBuilder::add(a4, (uint64_t)"", (qword_1EBCBE580 << 32) ^ 0x2F90404F00000000);
            *((_DWORD *)v149 - 3) = 0;
            if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
              && __cxa_guard_acquire(&qword_1EBCBE588))
            {
              unint64_t v259 = llvm::hashing::detail::fixed_seed_override;
              if (!llvm::hashing::detail::fixed_seed_override) {
                unint64_t v259 = 0xFF51AFD7ED558CCDLL;
              }
              qword_1EBCBE580 = v259;
              __cxa_guard_release(&qword_1EBCBE588);
            }
            *((_DWORD *)v149 - 2) = llvm::StringTableBuilder::add(a4, (uint64_t)"", (qword_1EBCBE580 << 32) ^ 0x2F90404F00000000);
            *((_DWORD *)v149 - 1) = 0;
            *((_DWORD *)v149 - 6) = ((1 << Alignment) - 1 + ((unint64_t)(v143 + 7) >> 3)) & -(1 << Alignment);
            char v159 = *((_WORD *)v94 + 17);
            BOOL v160 = (v159 & 0x3F) == 0;
            char v161 = (v159 & 0x3F) - 1;
            if (v160) {
              char v161 = 0;
            }
            uint64_t v162 = 1 << v161;
            if (v160) {
              LODWORD(v162) = 0;
            }
            *((_DWORD *)v149 - 5) = v162;
            unsigned int v140 = v149 - 3;
          }
          else
          {
            unsigned int v140 = 0;
          }
          long long v342 = 0uLL;
          LODWORD(v343) = 0;
          uint64_t v163 = (uint64_t ***)sub_1CC5BE54C((uint64_t)v94, (uint64_t)&v342);
          ResolverFunction = (llvm *)MEMORY[0x1D25D9CD0](v342, 8);
          if (!v163)
          {
            if (*((unsigned char *)v94 + 16) != 2
              || (ResolverFunction = (llvm *)llvm::GlobalIFunc::getResolverFunction((llvm::GlobalIFunc *)v94),
                  (uint64_t v163 = (uint64_t ***)ResolverFunction) == 0))
            {
              llvm::inconvertibleErrorCode(ResolverFunction);
              operator new();
            }
          }
          char v166 = (size_t **)v163[6];
          if (!v166) {
            goto LABEL_227;
          }
          uint64_t v184 = (uint64_t)v94[5];
          *(void *)&long long v342 = v163[6];
          DWORD2(v342) = -1431655765 * ((*((void *)&v318 + 1) - (void)v318) >> 2);
          sub_1CD40E370((uint64_t)&v352, (uint64_t)v313, (uint64_t *)&v342, (_DWORD *)&v342 + 2);
          if (!(_BYTE)v354) {
            goto LABEL_394;
          }
          long long v350 = 0uLL;
          uint64_t v351 = 0;
          if (HIDWORD(__p[2]) != 1)
          {
            char v219 = *v166 + 9;
            size_t v218 = **v166;
            if (v218 >= 0x7FFFFFFFFFFFFFF8) {
              goto LABEL_493;
            }
            if (v218 >= 0x17)
            {
              uint64_t v223 = (v218 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v218 | 7) != 0x17) {
                uint64_t v223 = v218 | 7;
              }
              uint64_t v301 = v223 + 1;
              char v220 = (long long *)operator new(v223 + 1);
              v343 = (char *)(v301 | 0x8000000000000000);
              *(void *)&long long v342 = v220;
              *((void *)&v342 + 1) = v218;
            }
            else
            {
              HIBYTE(v343) = **v166;
              char v220 = &v342;
              if (!v218)
              {
LABEL_337:
                unint64_t v302 = v140;
                *((unsigned char *)v220 + v21++*(_DWORD *)(this + 8) = 0;
                if (SHIBYTE(v351) < 0) {
                  operator delete((void *)v350);
                }
                long long v350 = v342;
                uint64_t v351 = v343;
                goto LABEL_366;
              }
            }
            memmove(v220, v219, v218);
            goto LABEL_337;
          }
          NamedValue = (const llvm::GlobalValue *)llvm::Module::getNamedValue(v184, (unsigned __int8 *)*v166 + 72, **v166);
          long long v186 = NamedValue;
          if (!NamedValue)
          {
            llvm::inconvertibleErrorCode(0);
            operator new();
          }
          if ((*((_DWORD *)NamedValue + 8) & 0xFu) - 7 > 1)
          {
            unint64_t v302 = v140;
            DWORD2(v342) = 0;
            char v346 = 0;
            uint64_t v347 = 0;
            *(void *)&long long v342 = &unk_1F2646F30;
            v349 = (const char **)&v350;
            int v348 = 0;
            uint64_t v344 = 0;
            int v345 = 0;
            v343 = 0;
            llvm::Mangler::getNameWithPrefix((llvm::Mangler *)v315, (char **)&v342, NamedValue, 0);
            *(void *)&long long v342 = &unk_1F2646B98;
            if (v348 == 1 && v343) {
              MEMORY[0x1D25D9CB0](v343, 0x1000C8077774924);
            }
LABEL_366:
            int v234 = SHIBYTE(v351);
            size_t v235 = (long long *)v350;
            if (SHIBYTE(v351) >= 0) {
              size_t v236 = HIBYTE(v351) & 0x7F;
            }
            else {
              size_t v236 = *((void *)&v350 + 1);
            }
            int v237 = (void *)sub_1CB906F34(a5, v236 + 1, 0);
            size_t v238 = v237;
            if (v236)
            {
              if (v234 >= 0) {
                uint64_t v239 = &v350;
              }
              else {
                uint64_t v239 = v235;
              }
              memcpy(v237, v239, v236);
            }
            *((unsigned char *)v238 + v236) = 0;
            int v240 = v236;
            unsigned int v241 = sub_1CD0B03C8(v238, (uint64_t)v238 + v236);
            int v242 = llvm::StringTableBuilder::add(a4, (uint64_t)v238, v236 | ((unint64_t)v241 << 32));
            int v243 = v242;
            int v244 = *((_DWORD *)v166 + 2);
            unint64_t v245 = (_DWORD *)*((void *)&v318 + 1);
            if (*((void *)&v318 + 1) >= (unint64_t)v319)
            {
              int v299 = v240;
              unint64_t v247 = (_DWORD *)v318;
              unint64_t v248 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v318 + 1) - v318) >> 2);
              unint64_t v249 = v248 + 1;
              if (v248 + 1 > 0x1555555555555555) {
                goto LABEL_493;
              }
              if (0x5555555555555556 * ((uint64_t)(v319 - v318) >> 2) > v249) {
                unint64_t v249 = 0x5555555555555556 * ((uint64_t)(v319 - v318) >> 2);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v319 - v318) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                unint64_t v249 = 0x1555555555555555;
              }
              unint64_t v290 = v249;
              if (v249)
              {
                if (v249 > 0x1555555555555555) {
                  goto LABEL_494;
                }
                int v250 = v244;
                long long v251 = (char *)operator new(12 * v249);
                int v244 = v250;
              }
              else
              {
                long long v251 = 0;
              }
              std::string::size_type v252 = &v251[12 * v248];
              *(_DWORD *)std::string::size_type v252 = v243;
              *((_DWORD *)v252 + 1) = v299;
              *((_DWORD *)v252 + 2) = v244;
              uint64_t v253 = v252;
              if (v245 == v247)
              {
                unint64_t v254 = v290;
              }
              else
              {
                unint64_t v254 = v290;
                do
                {
                  uint64_t v255 = *(void *)(v245 - 3);
                  v245 -= 3;
                  int v256 = v245[2];
                  *(void *)(v253 - 12) = v255;
                  v253 -= 12;
                  *((_DWORD *)v253 + 2) = v256;
                }
                while (v245 != v247);
                unint64_t v245 = (_DWORD *)v318;
              }
              std::string::size_type v246 = v252 + 12;
              *(void *)&long long v318 = v253;
              *((void *)&v318 + 1) = v252 + 12;
              *(void *)&long long v319 = &v251[12 * v254];
              unsigned int v140 = v302;
              if (v245) {
                operator delete(v245);
              }
            }
            else
            {
              **((_DWORD **)&v318 + 1) = v242;
              v245[1] = v240;
              std::string::size_type v246 = v245 + 3;
              v245[2] = v244;
              unsigned int v140 = v302;
            }
            *((void *)&v318 + 1) = v246;
            if (SHIBYTE(v351) < 0) {
              operator delete((void *)v350);
            }
LABEL_394:
            LODWORD(v104) = *((_DWORD *)v352 + 2);
LABEL_395:
            *((_DWORD *)v78 - 2) = v104;
LABEL_227:
            if (HIDWORD(__p[2]) != 1
              || (llvm::emitLinkerFlagsForGlobalCOFF((llvm *)&v326, (llvm::raw_ostream *)v94, (const llvm::GlobalValue *)__p, (const llvm::Triple *)v315, v165), (~v93 & 0x24) != 0))
            {
              a6 = v303;
            }
            else
            {
              unint64_t v167 = llvm::Value::stripPointerCasts((llvm::Value *)*(v94 - 4));
              a6 = v303;
              if (!v167 || *((unsigned __int8 *)v167 + 16) >= 4u)
              {
                llvm::inconvertibleErrorCode(v167);
                operator new();
              }
              size_t v353 = 0;
              uint64_t v352 = 0;
              uint64_t v354 = 0;
              DWORD2(v342) = 0;
              char v346 = 0;
              uint64_t v347 = 0;
              *(void *)&long long v342 = &unk_1F2646F30;
              v349 = (const char **)&v352;
              int v348 = 0;
              uint64_t v344 = 0;
              int v345 = 0;
              v343 = 0;
              llvm::ModuleSymbolTable::printSymbolName((uint64_t)&v355, (llvm::raw_ostream *)&v342, (unint64_t)v167 & 0xFFFFFFFFFFFFFFFBLL);
              if (v345 != v343)
              {
                int v345 = v343;
                llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v342, v343);
              }
              uint64_t v300 = v140;
              if (!v140)
              {
                *((_DWORD *)v78 - 1) |= 4u;
                unint64_t v168 = (void *)v323;
                if ((unint64_t)v323 >= *((void *)&v323 + 1))
                {
                  int v194 = (void *)*((void *)&v322 + 1);
                  unint64_t v195 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v323 - *((void *)&v322 + 1)) >> 3);
                  unint64_t v196 = v195 + 1;
                  if (v195 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    goto LABEL_493;
                  }
                  if (0x5555555555555556 * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3) > v196) {
                    unint64_t v196 = 0x5555555555555556 * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3) >= 0x555555555555555) {
                    unint64_t v197 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    unint64_t v197 = v196;
                  }
                  if (v197)
                  {
                    if (v197 > 0xAAAAAAAAAAAAAAALL) {
                      goto LABEL_494;
                    }
                    uint64_t v198 = (char *)operator new(24 * v197);
                  }
                  else
                  {
                    uint64_t v198 = 0;
                  }
                  std::string::size_type v224 = &v198[24 * v195];
                  *(void *)std::string::size_type v224 = 0;
                  *((void *)v224 + 1) = 0;
                  *((void *)v224 + 2) = 0;
                  uint64_t v225 = v224;
                  if (v168 != v194)
                  {
                    do
                    {
                      long long v226 = *(_OWORD *)(v168 - 3);
                      *((void *)v225 - 1) = *(v168 - 1);
                      *(_OWORD *)(v225 - 24) = v226;
                      v225 -= 24;
                      v168 -= 3;
                    }
                    while (v168 != v194);
                    unint64_t v168 = (void *)*((void *)&v322 + 1);
                  }
                  uint64_t v169 = v224 + 24;
                  *((void *)&v322 + 1) = v225;
                  *(void *)&long long v323 = v224 + 24;
                  *((void *)&v323 + 1) = &v198[24 * v197];
                  if (v168) {
                    operator delete(v168);
                  }
                }
                else
                {
                  *(void *)long long v323 = 0;
                  v168[1] = 0;
                  uint64_t v169 = v168 + 3;
                  v168[2] = 0;
                }
                *(void *)&long long v323 = v169;
                *(v169 - 3) = 0;
                *(v169 - 2) = 0;
                uint64_t v300 = v169 - 3;
                *(v169 - 1) = 0;
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EBCBE588))
                {
                  unint64_t v262 = llvm::hashing::detail::fixed_seed_override;
                  if (!llvm::hashing::detail::fixed_seed_override) {
                    unint64_t v262 = 0xFF51AFD7ED558CCDLL;
                  }
                  qword_1EBCBE580 = v262;
                  __cxa_guard_release(&qword_1EBCBE588);
                }
                *((_DWORD *)v169 - 4) = llvm::StringTableBuilder::add(a4, (uint64_t)"", (qword_1EBCBE580 << 32) ^ 0x2F90404F00000000);
                *((_DWORD *)v169 - 3) = 0;
                if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
                  && __cxa_guard_acquire(&qword_1EBCBE588))
                {
                  unint64_t v263 = llvm::hashing::detail::fixed_seed_override;
                  if (!llvm::hashing::detail::fixed_seed_override) {
                    unint64_t v263 = 0xFF51AFD7ED558CCDLL;
                  }
                  qword_1EBCBE580 = v263;
                  __cxa_guard_release(&qword_1EBCBE588);
                }
                *((_DWORD *)v169 - 2) = llvm::StringTableBuilder::add(a4, (uint64_t)"", (qword_1EBCBE580 << 32) ^ 0x2F90404F00000000);
                *((_DWORD *)v169 - 1) = 0;
              }
              int v227 = SHIBYTE(v354);
              uint64_t v228 = (void **)v352;
              if (v354 >= 0) {
                size_t v229 = HIBYTE(v354) & 0x7F;
              }
              else {
                size_t v229 = v353;
              }
              long long v230 = (void *)sub_1CB906F34(a5, v229 + 1, 0);
              std::string::size_type v231 = v230;
              if (v229)
              {
                if (v227 >= 0) {
                  uint64_t v232 = &v352;
                }
                else {
                  uint64_t v232 = v228;
                }
                memcpy(v230, v232, v229);
              }
              *((unsigned char *)v231 + v229) = 0;
              unsigned int v233 = sub_1CD0B03C8(v231, (uint64_t)v231 + v229);
              unsigned int v140 = v300;
              *((_DWORD *)v300 + 2) = llvm::StringTableBuilder::add(a4, (uint64_t)v231, v229 | ((unint64_t)v233 << 32));
              *((_DWORD *)v300 + 3) = v229;
              *(void *)&long long v342 = &unk_1F2646B98;
              if (v348 == 1 && v343) {
                MEMORY[0x1D25D9CB0](v343, 0x1000C8077774924);
              }
              if (SHIBYTE(v354) < 0) {
                operator delete(v352);
              }
            }
            if ((*((unsigned char *)v163 + 34) & 0x40) == 0)
            {
LABEL_244:
              uint64_t v104 = 0;
              goto LABEL_309;
            }
            uint64_t v170 = ***v163;
            *(void *)&long long v342 = v163;
            int v171 = *(_DWORD *)(v170 + 2520);
            unsigned int v172 = v163 >> 4;
            if (v171)
            {
              uint64_t v173 = *(void *)(v170 + 2504);
              int v174 = v171 - 1;
              unsigned int v175 = v174 & (v172 ^ (v163 >> 9));
              unint64_t v176 = (uint64_t ****)(v173 + 24 * v175);
              uint64_t v177 = *v176;
              if (*v176 == v163) {
                goto LABEL_240;
              }
              unint64_t v180 = 0;
              int v181 = 1;
              while (v177 != (uint64_t ***)-4096)
              {
                if (v180) {
                  BOOL v182 = 0;
                }
                else {
                  BOOL v182 = v177 == (uint64_t ***)-8192;
                }
                if (v182) {
                  unint64_t v180 = v176;
                }
                unsigned int v183 = v175 + v181++;
                unsigned int v175 = v183 & v174;
                unint64_t v176 = (uint64_t ****)(v173 + 24 * v175);
                uint64_t v177 = *v176;
                if (*v176 == v163) {
                  goto LABEL_240;
                }
              }
              if (v180) {
                char v192 = v180;
              }
              else {
                char v192 = v176;
              }
            }
            else
            {
              char v192 = 0;
            }
            unint64_t v176 = (uint64_t ****)sub_1CC5BF31C(v170 + 2504, (uint64_t)&v342, (uint64_t *)&v342, v192);
            unint64_t v193 = (uint64_t ***)v342;
            v176[1] = 0;
            v176[2] = 0;
            *unint64_t v176 = v193;
LABEL_240:
            if (!v176[2]) {
              goto LABEL_244;
            }
            if (!v140)
            {
              *((_DWORD *)v78 - 1) |= 4u;
              uint64_t v178 = (void *)v323;
              if ((unint64_t)v323 >= *((void *)&v323 + 1))
              {
                std::string::size_type v187 = (void *)*((void *)&v322 + 1);
                unint64_t v188 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v323 - *((void *)&v322 + 1)) >> 3);
                unint64_t v189 = v188 + 1;
                if (v188 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  goto LABEL_493;
                }
                if (0x5555555555555556 * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3) > v189) {
                  unint64_t v189 = 0x5555555555555556 * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v323 + 1) - *((void *)&v322 + 1)) >> 3) >= 0x555555555555555) {
                  unint64_t v190 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v190 = v189;
                }
                if (v190)
                {
                  if (v190 > 0xAAAAAAAAAAAAAAALL) {
                    goto LABEL_494;
                  }
                  unint64_t v191 = (char *)operator new(24 * v190);
                }
                else
                {
                  unint64_t v191 = 0;
                }
                unint64_t v199 = &v191[24 * v188];
                *(void *)unint64_t v199 = 0;
                *((void *)v199 + 1) = 0;
                *((void *)v199 + 2) = 0;
                unint64_t v200 = v199;
                if (v178 != v187)
                {
                  do
                  {
                    long long v201 = *(_OWORD *)(v178 - 3);
                    *((void *)v200 - 1) = *(v178 - 1);
                    *(_OWORD *)(v200 - 24) = v201;
                    v200 -= 24;
                    v178 -= 3;
                  }
                  while (v178 != v187);
                  uint64_t v178 = (void *)*((void *)&v322 + 1);
                }
                unsigned int v179 = v199 + 24;
                *((void *)&v322 + 1) = v200;
                *(void *)&long long v323 = v199 + 24;
                *((void *)&v323 + 1) = &v191[24 * v190];
                if (v178) {
                  operator delete(v178);
                }
              }
              else
              {
                *(void *)long long v323 = 0;
                v178[1] = 0;
                unsigned int v179 = v178 + 3;
                v178[2] = 0;
              }
              *(void *)&long long v323 = v179;
              *(v179 - 3) = 0;
              *(v179 - 2) = 0;
              *(v179 - 1) = 0;
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EBCBE588))
              {
                unint64_t v260 = llvm::hashing::detail::fixed_seed_override;
                if (!llvm::hashing::detail::fixed_seed_override) {
                  unint64_t v260 = 0xFF51AFD7ED558CCDLL;
                }
                qword_1EBCBE580 = v260;
                __cxa_guard_release(&qword_1EBCBE588);
              }
              *((_DWORD *)v179 - 4) = llvm::StringTableBuilder::add(a4, (uint64_t)"", (qword_1EBCBE580 << 32) ^ 0x2F90404F00000000);
              *((_DWORD *)v179 - 3) = 0;
              if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCBE588, memory_order_acquire) & 1) == 0
                && __cxa_guard_acquire(&qword_1EBCBE588))
              {
                unint64_t v261 = llvm::hashing::detail::fixed_seed_override;
                if (!llvm::hashing::detail::fixed_seed_override) {
                  unint64_t v261 = 0xFF51AFD7ED558CCDLL;
                }
                qword_1EBCBE580 = v261;
                __cxa_guard_release(&qword_1EBCBE588);
              }
              *((_DWORD *)v179 - 2) = llvm::StringTableBuilder::add(a4, (uint64_t)"", (qword_1EBCBE580 << 32) ^ 0x2F90404F00000000);
              *((_DWORD *)v179 - 1) = 0;
              unsigned int v140 = v179 - 3;
            }
            if ((*((unsigned char *)v163 + 34) & 0x40) == 0)
            {
              uint64_t v202 = 0;
              size_t v203 = 0;
LABEL_306:
              char v211 = (void *)sub_1CB906F34(a5, v203 + 1, 0);
              char v212 = v211;
              if (v203) {
                memcpy(v211, v202, v203);
              }
              *((unsigned char *)v212 + v203) = 0;
              unsigned int v213 = sub_1CD0B03C8(v212, (uint64_t)v212 + v203);
              uint64_t v104 = 0;
              *((_DWORD *)v140 + 4) = llvm::StringTableBuilder::add(a4, (uint64_t)v212, v203 | ((unint64_t)v213 << 32));
              *((_DWORD *)v140 + 5) = v203;
              goto LABEL_309;
            }
            uint64_t v204 = ***v163;
            *(void *)&long long v342 = v163;
            int v205 = *(_DWORD *)(v204 + 2520);
            if (v205)
            {
              uint64_t v206 = *(void *)(v204 + 2504);
              int v207 = v205 - 1;
              unsigned int v208 = v207 & (v172 ^ (v163 >> 9));
              char v209 = (uint64_t ****)(v206 + 24 * v208);
              char v210 = *v209;
              if (*v209 == v163)
              {
LABEL_305:
                uint64_t v202 = v209[1];
                size_t v203 = (size_t)v209[2];
                goto LABEL_306;
              }
              uint64_t v214 = 0;
              int v215 = 1;
              while (v210 != (uint64_t ***)-4096)
              {
                if (v214) {
                  BOOL v216 = 0;
                }
                else {
                  BOOL v216 = v210 == (uint64_t ***)-8192;
                }
                if (v216) {
                  uint64_t v214 = v209;
                }
                unsigned int v217 = v208 + v215++;
                unsigned int v208 = v217 & v207;
                char v209 = (uint64_t ****)(v206 + 24 * v208);
                char v210 = *v209;
                if (*v209 == v163) {
                  goto LABEL_305;
                }
              }
              if (v214) {
                unint64_t v221 = v214;
              }
              else {
                unint64_t v221 = v209;
              }
            }
            else
            {
              unint64_t v221 = 0;
            }
            char v209 = (uint64_t ****)sub_1CC5BF31C(v204 + 2504, (uint64_t)&v342, (uint64_t *)&v342, v221);
            uint64_t v222 = (uint64_t ***)v342;
            v209[1] = 0;
            v209[2] = 0;
            *char v209 = v222;
            goto LABEL_305;
          }
          *((_DWORD *)v352 + 2) = -1;
          uint64_t v104 = 0xFFFFFFFFLL;
          a6 = v303;
          if (SHIBYTE(v351) < 0) {
            operator delete((void *)v350);
          }
          if (v186) {
            goto LABEL_395;
          }
LABEL_309:
          *a6 = v104;
          if (v368 != (char *)&v370)
          {
            free(v368);
            uint64_t v104 = *a6;
          }
          if (v104) {
            goto LABEL_434;
          }
          std::string::size_type v75 = v308 + 1;
        }
        while (v308 + 1 != v306);
      }
      *a6 = 0;
LABEL_434:
      MEMORY[0x1D25D9CD0](v363, 8);
      if (*((void *)&v361 + 1))
      {
        *(void *)&long long v362 = *((void *)&v361 + 1);
        operator delete(*((void **)&v361 + 1));
      }
      sub_1CCB7266C((uint64_t)&v355 + 8);
      if (DWORD2(v357))
      {
        std::string::size_type v264 = (uint64_t *)v357;
        uint64_t v265 = 8 * DWORD2(v357);
        do
        {
          uint64_t v266 = *v264++;
          MEMORY[0x1D25D9CD0](v266, 8);
          v265 -= 8;
        }
        while (v265);
      }
      int v267 = (uint64_t *)v359;
      if (v360)
      {
        uint64_t v268 = 16 * v360;
        do
        {
          uint64_t v269 = *v267;
          v267 += 2;
          MEMORY[0x1D25D9CD0](v269, 8);
          v268 -= 16;
        }
        while (v268);
        int v267 = (uint64_t *)v359;
      }
      if (v267 != (uint64_t *)((char *)&v360 + 8)) {
        free(v267);
      }
      if ((void *)v357 != v358) {
        free((void *)v357);
      }
      if (v339 != v338) {
        free(v339);
      }
      long long v23 = v365;
      if (v365 != (llvm *)v367) {
        free(v365);
      }
      if (*a6) {
        goto LABEL_472;
      }
      a1 = v298 + 1;
    }
    while (v298 + 1 != v297);
  }
  if (__dst != v328)
  {
    long long __dst = v328;
    llvm::raw_ostream::flush_tied_then_write((llvm::raw_ostream *)&v326, v328);
  }
  int v270 = SHIBYTE(v325);
  uint64_t v271 = (long long *)v324;
  if (v325 >= 0) {
    size_t v272 = HIBYTE(v325) & 0x7F;
  }
  else {
    size_t v272 = *((void *)&v324 + 1);
  }
  int v273 = (void *)sub_1CB906F34(a5, v272 + 1, 0);
  uint64_t v274 = v273;
  if (v272)
  {
    if (v270 >= 0) {
      std::string::size_type v275 = &v324;
    }
    else {
      std::string::size_type v275 = v271;
    }
    memcpy(v273, v275, v272);
  }
  *((unsigned char *)v274 + v272) = 0;
  unsigned int v276 = sub_1CD0B03C8(v274, (uint64_t)v274 + v272);
  int v277 = llvm::StringTableBuilder::add(a4, (uint64_t)v274, v272 | ((unint64_t)v276 << 32));
  __int16 v278 = a3;
  unint64_t v279 = a3[1];
  int v309 = v277;
  if (v279 == 76)
  {
    uint64_t v280 = 76;
  }
  else
  {
    if (v279 <= 0x4C)
    {
      if ((unint64_t)a3[2] <= 0x4B) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      bzero((void *)(*a3 + v279), 76 - v279);
    }
    a3[1] = 76;
    __int16 v278 = a3;
    uint64_t v280 = a3[1];
  }
  int v305 = v280;
  int v307 = -1431655765 * (((void)v320 - *((void *)&v319 + 1)) >> 2);
  sub_1CCBEA54C(v278, *v278 + v280, *((char **)&v319 + 1), (char *)v320);
  int v304 = -1431655765 * ((*((void *)&v318 + 1) - (void)v318) >> 2);
  uint64_t v281 = a3[1];
  sub_1CCBEA54C(a3, *a3 + v281, (char *)v318, *((char **)&v318 + 1));
  int v282 = -1431655765 * ((*((void *)&v321 + 1) - (void)v321) >> 3);
  uint64_t v283 = a3[1];
  sub_1CCBEA54C(a3, *a3 + v283, (char *)v321, *((char **)&v321 + 1));
  int v284 = -1431655765 * (((void)v323 - *((void *)&v322 + 1)) >> 3);
  uint64_t v285 = a3[1];
  sub_1CCBEA54C(a3, *a3 + v285, *((char **)&v322 + 1), (char *)v323);
  unint64_t v286 = (unint64_t)(v336 - (unsigned char *)__src) >> 3;
  uint64_t v287 = a3[1];
  sub_1CCBEA54C(a3, *a3 + v287, (char *)__src, v336);
  std::string::size_type v288 = (_DWORD *)*a3;
  _DWORD *v288 = 3;
  v288[1] = v294;
  v288[2] = v296;
  v288[3] = v305;
  v288[4] = v307;
  v288[5] = v281;
  v288[6] = v304;
  v288[7] = v283;
  char v288[8] = v282;
  v288[9] = v285;
  v288[10] = v284;
  v288[11] = v293;
  v288[12] = v295;
  v288[13] = v291;
  v288[14] = v292;
  v288[15] = v309;
  v288[16] = v272;
  v288[17] = v287;
  v288[18] = v286;
  *uint64_t v303 = 0;
LABEL_472:
  if (__src)
  {
    char v336 = (char *)__src;
    operator delete(__src);
  }
  int v326 = &unk_1F2646B98;
  if (v333 == 1 && v328) {
    MEMORY[0x1D25D9CB0](v328, 0x1000C8077774924);
  }
  if (SHIBYTE(v325) < 0) {
    operator delete((void *)v324);
  }
  if (*((void *)&v322 + 1))
  {
    *(void *)&long long v323 = *((void *)&v322 + 1);
    operator delete(*((void **)&v322 + 1));
  }
  if ((void)v321)
  {
    *((void *)&v321 + 1) = v321;
    operator delete((void *)v321);
  }
  if (*((void *)&v319 + 1))
  {
    *(void *)&long long v320 = *((void *)&v319 + 1);
    operator delete(*((void **)&v319 + 1));
  }
  if ((void)v318)
  {
    *((void *)&v318 + 1) = v318;
    operator delete((void *)v318);
  }
  if (SBYTE7(__p[1]) < 0) {
    operator delete(*(void **)&__p[0]);
  }
  MEMORY[0x1D25D9CD0](v315[0], 8);
  return MEMORY[0x1D25D9CD0](v313[0], 8);
}

void llvm::irsymtab::readBitcode(llvm *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)a1;
  uint64_t v4 = *((void *)a1 + 1);
  if (*(void *)a1 == v4)
  {
    llvm::inconvertibleErrorCode(a1);
    operator new();
  }
  if (byte_1EBD0A358)
  {
    uint64_t v6 = *((void *)a1 + 3);
    unint64_t v5 = *((void *)a1 + 4);
    uint64_t v8 = *((void *)a1 + 5);
    uint64_t v7 = *((void *)a1 + 6);
    goto LABEL_4;
  }
  uint64_t v7 = *((void *)a1 + 6);
  if (!v7) {
    goto LABEL_17;
  }
  unint64_t v5 = *((void *)a1 + 4);
  if (v5 <= 0x4B) {
    goto LABEL_17;
  }
  uint64_t v6 = *((void *)a1 + 3);
  if (*(_DWORD *)v6 != 3) {
    goto LABEL_17;
  }
  uint64_t v8 = *((void *)a1 + 5);
  size_t v17 = *(unsigned int *)(v6 + 8);
  if (!qword_1EBCEF408)
  {
    if (!v17) {
      goto LABEL_4;
    }
LABEL_17:
    sub_1CCC4DCF8();
  }
  if (strlen((const char *)qword_1EBCEF408) != v17
    || v17 && memcmp((const void *)(v8 + *(unsigned int *)(v6 + 4)), (const void *)qword_1EBCEF408, v17))
  {
    goto LABEL_17;
  }
LABEL_4:
  char v18 = &v21;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  unint64_t v9 = *(void *)(v6 + 12);
  unint64_t v10 = *(void *)(v6 + 20);
  unint64_t v11 = *(void *)(v6 + 28);
  unint64_t v12 = *(void *)(v6 + 36);
  unint64_t v13 = *(void *)(v6 + 68);
  *(void *)&long long v21 = v6;
  *((void *)&v21 + 1) = v5;
  *(void *)&long long v22 = v8;
  *((void *)&v22 + 1) = v7;
  *(void *)&long long v23 = v6 + v9;
  *((void *)&v23 + 1) = HIDWORD(v9);
  *(void *)&long long v24 = v6 + v10;
  *((void *)&v24 + 1) = HIDWORD(v10);
  *(void *)&long long v25 = v6 + v11;
  *((void *)&v25 + 1) = HIDWORD(v11);
  *(void *)&long long v26 = v6 + v12;
  *((void *)&v26 + 1) = HIDWORD(v12);
  *(void *)&long long v27 = v6 + v13;
  *((void *)&v27 + 1) = HIDWORD(v13);
  if (HIDWORD(v9) != (v4 - v3) >> 6) {
    sub_1CCC4DCF8();
  }
  *(unsigned char *)(a2 + 160) &= ~1u;
  *(void *)(a2 + 24) = a2 + 48;
  *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
  *(void *)(a2 + ++*(_DWORD *)(this + 16) = 0;
  *(void *)a2 = a2 + 24;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  long long v14 = v26;
  *(_OWORD *)(a2 + 112) = v25;
  *(_OWORD *)(a2 + 12++*(_DWORD *)(this + 8) = v14;
  *(_OWORD *)(a2 + 144) = v27;
  long long v15 = v22;
  *(_OWORD *)(a2 + 4++*(_DWORD *)(this + 8) = v21;
  *(_OWORD *)(a2 + 64) = v15;
  long long v16 = v24;
  *(_OWORD *)(a2 + 80) = v23;
  *(_OWORD *)(a2 + 96) = v16;
}

void sub_1CCC4DCF8()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = &v4;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = (unsigned __int8 *)v6;
  long long v5 = 0u;
  memset(v6, 0, sizeof(v6));
  llvm::LLVMContext::LLVMContext((llvm::LLVMContext *)v0);
}

char *sub_1CCC4E1E0()
{
  char v4 = 0;
  long long v5 = &v4;
  int v3 = 1;
  v2.n128_u64[0] = (unint64_t)"Disable automatic bitcode upgrade for version mismatch";
  v2.n128_u64[1] = 54;
  sub_1CBA9E5B0((llvm::cl::Option *)&DisableBitcodeVersionUpgrade, "disable-bitcode-version-upgrade", &v5, &v3, &v2);
  __cxa_atexit((void (*)(void *))sub_1CB9064B0, &DisableBitcodeVersionUpgrade, &dword_1CB82C000);
  uint64_t result = getenv("LLVM_OVERRIDE_PRODUCER");
  uint64_t v1 = a32023408_0;
  if (result) {
    uint64_t v1 = result;
  }
  qword_1EBCEF408 = (uint64_t)v1;
  return result;
}

void llvm::object::MachOObjectFile::create()
{
  uint64_t v0 = 0;
  operator new();
}

uint64_t llvm::object::MachOObjectFile::MachOObjectFile(uint64_t a1, long long *a2, int a3, int a4, uint64_t *a5, int a6, unsigned int a7)
{
  uint64_t v411 = *MEMORY[0x1E4F143B8];
  long long v10 = *a2;
  long long v9 = a2[1];
  if (a4) {
    int v11 = 18;
  }
  else {
    int v11 = 16;
  }
  if (a4) {
    int v12 = 19;
  }
  else {
    int v12 = 17;
  }
  if (!a3) {
    int v11 = v12;
  }
  *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = v11;
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 16) = v10;
  *(_OWORD *)(a1 + 32) = v9;
  *(void *)a1 = &unk_1F26336A0;
  *(void *)(a1 + 80) = a1 + 96;
  *(void *)(a1 + 8++*(_DWORD *)(this + 8) = 0x100000000;
  *(void *)(a1 + 104) = a1 + 120;
  *(void *)(a1 + 112) = 0x100000000;
  *(void *)(a1 + 12++*(_DWORD *)(this + 8) = a1 + 144;
  *(void *)(a1 + 136) = 0x400000000;
  *(void *)(a1 + 20++*(_DWORD *)(this + 8) = a1 + 224;
  unint64_t v13 = (void *)(a1 + 208);
  *(void *)(a1 + 2++*(_DWORD *)(this + 16) = 0x100000000;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x100000000;
  *(void *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 32++*(_DWORD *)(this + 8) = 0u;
  *(unsigned char *)(a1 + 344) = 0;
  uint64_t v15 = *(void *)(a1 + 16);
  uint64_t v14 = *(void *)(a1 + 24);
  if ((v11 & 2) != 0)
  {
    if ((unint64_t)v14 <= 0x1F)
    {
      v394.i64[0] = (uint64_t)"the mach header extends past the end of the file";
      LOWORD(v396) = 259;
      sub_1CCC51CE4((uint64_t)v405, v394.i64);
    }
    if (v14 < 32)
    {
      v394.i64[0] = (uint64_t)"Structure read out-of-range";
      LOWORD(v396) = 259;
      sub_1CCC51CE4((uint64_t)v405, v394.i64);
    }
    unsigned int v17 = *(_DWORD *)v15;
    uint64_t v16 = *(unsigned int *)(v15 + 4);
    int8x16_t v18 = *(int8x16_t *)(v15 + 8);
    int8x8_t v19 = *(int8x8_t *)(v15 + 24);
    if (!a3 && a4)
    {
      unsigned int v17 = bswap32(v17);
      uint64_t v16 = bswap32(v16);
      int8x16_t v18 = vrev32q_s8(v18);
      int8x8_t v19 = vrev32_s8(v19);
    }
    *(void *)(a1 + 4++*(_DWORD *)(this + 8) = v17 | (unint64_t)(v16 << 32);
    *(int8x16_t *)(a1 + 56) = v18;
    *(int8x8_t *)(a1 + 72) = v19;
    uint64_t v20 = 32;
  }
  else
  {
    if ((unint64_t)v14 <= 0x1B)
    {
      v394.i64[0] = (uint64_t)"the mach header extends past the end of the file";
      LOWORD(v396) = 259;
      sub_1CCC51CE4((uint64_t)v405, v394.i64);
    }
    if (v14 < 28)
    {
      v394.i64[0] = (uint64_t)"Structure read out-of-range";
      LOWORD(v396) = 259;
      sub_1CCC51CE4((uint64_t)v405, v394.i64);
    }
    unsigned int v22 = *(_DWORD *)v15;
    uint64_t v21 = *(unsigned int *)(v15 + 4);
    int8x16_t v23 = *(int8x16_t *)(v15 + 8);
    unsigned int v24 = *(_DWORD *)(v15 + 24);
    if ((v11 | 2) == 0x13)
    {
      unsigned int v22 = bswap32(v22);
      uint64_t v21 = bswap32(v21);
      int8x16_t v23 = vrev32q_s8(v23);
      unsigned int v24 = bswap32(v24);
    }
    *(void *)(a1 + 4++*(_DWORD *)(this + 8) = v22 | (unint64_t)(v21 << 32);
    *(int8x16_t *)(a1 + 56) = v23;
    *(_DWORD *)(a1 + 72) = v24;
    uint64_t v20 = 28;
  }
  if (!*a5)
  {
    uint64_t v25 = *(unsigned int *)(a1 + 68);
    if (v20 + v25 > *(void *)(a1 + 24))
    {
      v394.i64[0] = (uint64_t)"load commands extend past the end of the file";
      LOWORD(v396) = 259;
      sub_1CCC51CE4((uint64_t)v405, v394.i64);
    }
    uint64_t v26 = *(void *)(a1 + 16);
    if (a6 && *(_DWORD *)(a1 + 52) != a6)
    {
      *(void *)v405 = "universal header architecture: ";
      *(void *)&long long v406 = a7;
      LOWORD(v407) = 2051;
      v394.i64[0] = (uint64_t)v405;
      *(void *)&long long v395 = "'s cputype does not match object file's mach header";
      LOWORD(v396) = 770;
      sub_1CCC51CE4((uint64_t)v389, v394.i64);
    }
    int v357 = *(_DWORD *)(a1 + 72);
    unint64_t v359 = v20 + v25;
    long long v28 = operator new(0x28uLL);
    v28[2] = 0;
    void v28[3] = v359;
    void v28[4] = "Mach-O headers";
    void *v28 = &v368;
    v28[1] = &v368;
    std::string __p = v28;
    uint64_t v368 = v28;
    uint64_t v370 = 1;
    uint64_t v29 = *(unsigned int *)(a1 + 64);
    if (!v29)
    {
      uint64_t v30 = 0;
      uint64_t v366 = 0;
      uint64_t v365 = 0;
      goto LABEL_36;
    }
    if (v25 <= 7)
    {
      v394.i64[0] = (uint64_t)"load command 0 extends past the end all load commands in the file";
      LOWORD(v396) = 259;
      sub_1CCC51CE4((uint64_t)v405, v394.i64);
    }
    uint64_t v34 = 28;
    if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
      uint64_t v34 = 32;
    }
    sub_1CCC6803C((uint64_t)v405, a1, (_DWORD *)(v26 + v34), 0);
    if (v406)
    {
      uint64_t v69 = *(void *)v405;
      goto LABEL_622;
    }
    unint64_t v35 = 0;
    uint64_t v353 = 0;
    uint64_t v354 = 0;
    uint64_t v355 = 0;
    uint64_t v352 = 0;
    uint64_t v30 = 0;
    uint64_t v36 = 0;
    uint64_t v349 = 0;
    uint64_t v350 = 0;
    uint64_t v351 = (void *)(a1 + 16);
    long long v367 = *(_OWORD *)v405;
    uint64_t v366 = 0;
    uint64_t v365 = 0;
    uint64_t v364 = 0;
    long long v363 = 0;
    uint64_t v362 = 0;
    unint64_t v360 = (v29 - 1);
    uint64_t v356 = v29;
    while (2)
    {
      if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12)
      {
        if ((BYTE12(v367) & 7) != 0)
        {
          BOOL v37 = (BYTE12(v367) & 3) == 0 && *(_DWORD *)(a1 + 60) == 4;
          if (!v37 || DWORD2(v367) != 4)
          {
            *(void *)v405 = "load command ";
            *(void *)&long long v406 = v35;
            LOWORD(v407) = 2051;
            uint64_t v239 = " cmdsize not a multiple of 8";
            goto LABEL_641;
          }
        }
      }
      else if ((BYTE12(v367) & 3) != 0)
      {
        *(void *)v405 = "load command ";
        *(void *)&long long v406 = v35;
        LOWORD(v407) = 2051;
        uint64_t v239 = " cmdsize not a multiple of 4";
LABEL_641:
        v394.i64[0] = (uint64_t)v405;
        *(void *)&long long v395 = v239;
        LOWORD(v396) = 770;
        sub_1CCC51CE4((uint64_t)v389, v394.i64);
      }
      unint64_t v39 = *(unsigned int *)(a1 + 136);
      if (v39 >= *(unsigned int *)(a1 + 140)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_OWORD *)(*(void *)(a1 + 128) + 16 * v39) = v367;
      ++*(_DWORD *)(a1 + 136);
      if (SDWORD2(v367) <= -2147483597)
      {
        switch(DWORD2(v367))
        {
          case 0x80000018:
            uint64_t v41 = a1;
            unsigned int v42 = v35;
            uint64_t v43 = "LC_LOAD_WEAK_DYLIB";
            goto LABEL_130;
          case 0x80000019:
          case 0x8000001A:
          case 0x8000001B:
          case 0x8000001D:
          case 0x8000001E:
          case 0x80000020:
          case 0x80000021:
            goto LABEL_73;
          case 0x8000001C:
            if (HIDWORD(v367) > 0xB)
            {
              unint64_t v96 = *(void *)(a1 + 16);
              if ((unint64_t)v367 < v96 || (uint64_t)v367 + 12 > v96 + *(void *)(a1 + 24))
              {
LABEL_186:
                uint64_t v70 = "Structure read out-of-range";
LABEL_187:
                v394.i64[0] = (uint64_t)v70;
                LOWORD(v396) = 259;
                sub_1CCC51CE4((uint64_t)v405, v394.i64);
              }
              unsigned int v97 = *(_DWORD *)(v367 + 4);
              unsigned int v98 = *(_DWORD *)(v367 + 8);
              unsigned int v99 = *(_DWORD *)(a1 + 8);
              unsigned int v100 = bswap32(v97);
              unsigned int v101 = bswap32(v98);
              if (((1 << v99) & 0xAAC00) == 0)
              {
                unsigned int v101 = *(_DWORD *)(v367 + 8);
                unsigned int v100 = *(_DWORD *)(v367 + 4);
              }
              if (v99 <= 0x13)
              {
                unsigned int v98 = v101;
                unsigned int v97 = v100;
              }
              if (v98 > 0xB)
              {
                BOOL v163 = v97 >= v98;
                unsigned int v164 = v97 - v98;
                if (v164 != 0 && v163)
                {
                  char v165 = (unsigned __int8 *)(v367 + v98);
                  do
                  {
                    if (!*v165++) {
                      goto LABEL_234;
                    }
                    --v164;
                  }
                  while (v164);
                  *(void *)v405 = "load command ";
                  *(void *)&long long v406 = v309 & 0xFFFFFFFF00000000 | v35;
                  LOWORD(v407) = 2051;
                  v394.i64[0] = (uint64_t)v405;
                  char v49 = " LC_RPATH library name extends past the end of the load command";
                }
                else
                {
                  *(void *)v405 = "load command ";
                  *(void *)&long long v406 = v328 & 0xFFFFFFFF00000000 | v35;
                  LOWORD(v407) = 2051;
                  v394.i64[0] = (uint64_t)v405;
                  char v49 = " LC_RPATH path.offset field extends past the end of the load command";
                }
              }
              else
              {
                *(void *)v405 = "load command ";
                *(void *)&long long v406 = v338 & 0xFFFFFFFF00000000 | v35;
                LOWORD(v407) = 2051;
                v394.i64[0] = (uint64_t)v405;
                char v49 = " LC_RPATH path.offset field too small, not past the end of the rpath_command struct";
              }
            }
            else
            {
              *(void *)v405 = "load command ";
              *(void *)&long long v406 = v347 & 0xFFFFFFFF00000000 | v35;
              LOWORD(v407) = 2051;
              v394.i64[0] = (uint64_t)v405;
              char v49 = " LC_RPATH cmdsize too small";
            }
            *(void *)&long long v395 = v49;
LABEL_429:
            __int16 v58 = 770;
LABEL_430:
            LOWORD(v396) = v58;
            sub_1CCC51CE4((uint64_t)v389, v394.i64);
          case 0x8000001F:
            uint64_t v41 = a1;
            unsigned int v42 = v35;
            uint64_t v43 = "LC_REEXPORT_DYLIB";
            goto LABEL_130;
          case 0x80000022:
            uint64_t v50 = a1;
            unsigned int v51 = v35;
            size_t v52 = (void *)(a1 + 304);
            uint64_t v53 = "LC_DYLD_INFO_ONLY";
LABEL_143:
            sub_1CCC52134(&v394, v50, (uint64_t)&v367, v51, v52, v53, (uint64_t *)&v368);
            goto LABEL_154;
          case 0x80000023:
            uint64_t v41 = a1;
            unsigned int v42 = v35;
            uint64_t v43 = "LC_LOAD_UPWARD_DYLIB";
LABEL_130:
            sub_1CCC5260C(&v394, v41, (uint64_t)&v367, v42, v43);
            uint64_t v83 = v394.i64[0];
            *a5 = v394.i64[0];
            if (v83) {
              goto LABEL_623;
            }
            unint64_t v84 = *(unsigned int *)(a1 + 112);
            if (v84 >= *(unsigned int *)(a1 + 116)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(void *)(*(void *)(a1 + 104) + 8 * v84) = v367;
            ++*(_DWORD *)(a1 + 112);
            goto LABEL_133;
          default:
            if (DWORD2(v367) != -2147483608)
            {
              if (DWORD2(v367) != -2147483597)
              {
LABEL_73:
                if (DWORD2(v367) <= 0x17 && ((1 << SBYTE8(v367)) & 0xC107C8) != 0)
                {
                  *(void *)&long long v400 = "load command ";
                  *(void *)&long long v401 = v35;
                  LOWORD(v402) = 2051;
                  *(void *)int v389 = &v400;
                  *(void *)&long long v390 = " for cmd value of: ";
                  LOWORD(v391) = 770;
                  *(void *)v405 = v389;
                  *(void *)&long long v406 = DWORD2(v367);
                  LOWORD(v407) = 2050;
                  v394.i64[0] = (uint64_t)v405;
                  *(void *)&long long v395 = " is obsolete and not supported";
                  LOWORD(v396) = 770;
                  sub_1CCC51CE4((uint64_t)v386, v394.i64);
                }
                goto LABEL_156;
              }
              uint64_t v44 = a1;
              unsigned int v45 = v35;
              uint64_t v46 = (uint64_t *)(a1 + 312);
              uint64_t v47 = "LC_DYLD_EXPORTS_TRIE";
              std::string::size_type v48 = "export trie";
LABEL_146:
              sub_1CCC51DC8(&v394, v44, (uint64_t)&v367, v45, v46, v47, (uint64_t *)&v368, v48);
LABEL_154:
              uint64_t v102 = v394.i64[0];
              goto LABEL_155;
            }
            if (HIDWORD(v367) == 24)
            {
              if (!v354)
              {
                uint64_t v354 = v367;
                goto LABEL_156;
              }
              std::string::size_type v246 = "more than one LC_MAIN command";
              goto LABEL_620;
            }
            unint64_t v245 = "LC_MAIN command ";
            goto LABEL_640;
        }
      }
      switch(DWORD2(v367))
      {
        case 1:
          if (HIDWORD(v367) <= 0x37)
          {
            *(void *)&long long v400 = "load command ";
            *(void *)&long long v401 = v340 & 0xFFFFFFFF00000000 | v35;
            LOWORD(v402) = 2051;
            *(void *)int v389 = &v400;
            *(void *)&long long v390 = " ";
            LOWORD(v391) = 770;
            uint64_t v40 = "LC_SEGMENT";
LABEL_121:
            *(void *)v405 = v389;
            *(void *)&long long v406 = v40;
            LOWORD(v407) = 770;
            unint64_t v81 = v405;
            unint64_t v82 = " cmdsize too small";
            goto LABEL_202;
          }
          sub_1CCC6FB90((uint64_t)v389, a1, v367);
          if (BYTE8(v392)) {
            goto LABEL_431;
          }
          long long v400 = *(_OWORD *)v389;
          long long v401 = v390;
          long long v402 = v391;
          *(void *)&long long v403 = v392;
          if (v392 > 0x3C3C3C3 || 68 * (int)v392 > (HIDWORD(v367) - 56))
          {
            v383[0] = "load command ";
            unint64_t v384 = v337 & 0xFFFFFFFF00000000 | v35;
            __int16 v385 = 2051;
            v386[0] = (uint64_t)v383;
            uint64_t v387 = " inconsistent cmdsize in ";
            __int16 v388 = 770;
            *(void *)v405 = v386;
            *(void *)&long long v406 = "LC_SEGMENT";
            LOWORD(v407) = 770;
            unint64_t v81 = v405;
            goto LABEL_201;
          }
          unint64_t v332 = *(void *)(a1 + 24);
          if (!v392)
          {
LABEL_437:
            if (v332 >= v402)
            {
              if (DWORD1(v402) + (unint64_t)v402 <= v332)
              {
                if (!HIDWORD(v401) || DWORD1(v402) <= HIDWORD(v401))
                {
                  BOOL v226 = strlen((const char *)&v400 + 8) == 10
                      && *((void *)&v400 + 1) == 0x455A454741505F5FLL
                      && (unsigned __int16)v401 == 20306;
                  *(unsigned char *)(a1 + 344) |= v226;
                  *a5 = 0;
LABEL_133:
                  uint64_t v29 = v356;
                  goto LABEL_156;
                }
                v383[0] = "load command ";
                unint64_t v384 = v285 & 0xFFFFFFFF00000000 | v35;
                __int16 v385 = 2051;
                v386[0] = (uint64_t)v383;
                uint64_t v387 = " filesize field in ";
                __int16 v388 = 770;
                *(void *)v405 = v386;
                *(void *)&long long v406 = "LC_SEGMENT";
                LOWORD(v407) = 770;
                size_t v218 = " greater than vmsize field";
              }
              else
              {
                v383[0] = "load command ";
                unint64_t v384 = v296 & 0xFFFFFFFF00000000 | v35;
                __int16 v385 = 2051;
                v386[0] = (uint64_t)v383;
                uint64_t v387 = " fileoff field plus filesize field in ";
                __int16 v388 = 770;
                *(void *)v405 = v386;
                *(void *)&long long v406 = "LC_SEGMENT";
                LOWORD(v407) = 770;
                size_t v218 = " extends past the end of the file";
              }
              v394.i64[0] = (uint64_t)v405;
              *(void *)&long long v395 = v218;
              LOWORD(v396) = 770;
              sub_1CCC51CE4((uint64_t)&v361, v394.i64);
            }
            v383[0] = "load command ";
            unint64_t v384 = v302 & 0xFFFFFFFF00000000 | v35;
            __int16 v385 = 2051;
            v386[0] = (uint64_t)v383;
            uint64_t v387 = " fileoff field in ";
            __int16 v388 = 770;
            *(void *)v405 = v386;
            *(void *)&long long v406 = "LC_SEGMENT";
            LOWORD(v407) = 770;
            unint64_t v81 = v405;
            unint64_t v82 = " extends past the end of the file";
            goto LABEL_202;
          }
          uint64_t v167 = 0;
          int v319 = v402;
          unint64_t v310 = DWORD1(v402);
          unsigned int v306 = DWORD2(v401);
          int v325 = HIDWORD(v401);
          unint64_t v313 = DWORD2(v401) + (unint64_t)HIDWORD(v401);
          unint64_t v322 = v392;
          uint64_t v346 = v30;
          int v348 = v36;
          while (1)
          {
            if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
              uint64_t v168 = 72;
            }
            else {
              uint64_t v168 = 56;
            }
            if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
              int v169 = 80;
            }
            else {
              int v169 = 68;
            }
            unint64_t v170 = *(unsigned int *)(a1 + 88);
            if (v170 >= *(unsigned int *)(a1 + 92)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v171 = v167;
            unint64_t v172 = v168 + v367 + (v169 * v167);
            *(void *)(*(void *)(a1 + 80) + 8 * v170) = v172;
            ++*(_DWORD *)(a1 + 88);
            unint64_t v173 = v172;
            sub_1CCC65770((uint64_t)&v394, a1, v172);
            if (BYTE8(v398)) {
              goto LABEL_479;
            }
            long long v407 = v396;
            long long v408 = v397;
            LODWORD(v409) = v398;
            *(int8x16_t *)v405 = v394;
            long long v406 = v395;
            int v174 = *(_DWORD *)(a1 + 60);
            uint64_t v29 = v356;
            unint64_t v175 = v332;
            if (v174 == 9)
            {
              uint64_t v176 = DWORD1(v407);
            }
            else
            {
              BOOL v178 = v174 == 10 || DWORD2(v408) == 1 || DWORD2(v408) == 18;
              int v179 = !v178;
              if (!v178 && v332 < DWORD2(v407))
              {
                v371[0] = "offset field of section ";
                unint64_t v372 = v281 & 0xFFFFFFFF00000000 | v171;
                __int16 v373 = 2051;
                v374[0] = v371;
                v375 = " in ";
                __int16 v376 = 770;
                v377[0] = v374;
                unsigned int v378 = "LC_SEGMENT";
                __int16 v379 = 770;
                v380[0] = v377;
                uint64_t v381 = " command ";
                __int16 v382 = 770;
                unint64_t v223 = v282 & 0xFFFFFFFF00000000 | v35;
                v383[0] = v380;
                goto LABEL_534;
              }
              if (v319) {
                int v180 = 0;
              }
              else {
                int v180 = v179;
              }
              uint64_t v176 = DWORD1(v407);
              if (v180 == 1 && v359 > DWORD2(v407) && DWORD1(v407))
              {
                v371[0] = "offset field of section ";
                unint64_t v372 = v260 & 0xFFFFFFFF00000000 | v171;
                __int16 v373 = 2051;
                v374[0] = v371;
                v375 = " in ";
                __int16 v376 = 770;
                v377[0] = v374;
                unsigned int v378 = "LC_SEGMENT";
                __int16 v379 = 770;
                v380[0] = v377;
                uint64_t v381 = " command ";
                __int16 v382 = 770;
                v383[0] = v380;
                unint64_t v384 = v261 & 0xFFFFFFFF00000000 | v35;
                __int16 v385 = 2050;
                size_t v229 = " not past the headers of the file";
LABEL_535:
                v386[0] = (uint64_t)v383;
                uint64_t v387 = v229;
                __int16 v388 = 770;
                sub_1CCC51CE4((uint64_t)&v361, v386);
              }
              unint64_t v175 = v332;
              if (DWORD1(v407) + (unint64_t)DWORD2(v407) > v332) {
                int v181 = v179;
              }
              else {
                int v181 = 0;
              }
              if (v181 == 1)
              {
                v371[0] = "offset field plus size field of section ";
                unint64_t v372 = v277 & 0xFFFFFFFF00000000 | v171;
                __int16 v373 = 2051;
                v374[0] = v371;
                v375 = " in ";
                __int16 v376 = 770;
                v377[0] = v374;
                unsigned int v378 = "LC_SEGMENT";
                __int16 v379 = 770;
                v380[0] = v377;
                uint64_t v381 = " command ";
                __int16 v382 = 770;
                unint64_t v223 = v278 & 0xFFFFFFFF00000000 | v35;
                v383[0] = v380;
                goto LABEL_534;
              }
              if (DWORD1(v407) <= v310) {
                int v179 = 0;
              }
              if (v179 == 1)
              {
                v371[0] = "size field of section ";
                unint64_t v372 = v269 & 0xFFFFFFFF00000000 | v171;
                __int16 v373 = 2051;
                v374[0] = v371;
                v375 = " in ";
                __int16 v376 = 770;
                v377[0] = v374;
                unsigned int v378 = "LC_SEGMENT";
                __int16 v379 = 770;
                v380[0] = v377;
                uint64_t v381 = " command ";
                __int16 v382 = 770;
                v383[0] = v380;
                unint64_t v384 = v270 & 0xFFFFFFFF00000000 | v35;
                __int16 v385 = 2050;
                size_t v229 = " greater than the segment";
                goto LABEL_535;
              }
              if (v174 != 10 && DWORD1(v407) && v407 < v306)
              {
                v371[0] = "addr field of section ";
                unint64_t v372 = v265 & 0xFFFFFFFF00000000 | v171;
                __int16 v373 = 2051;
                v374[0] = v371;
                v375 = " in ";
                __int16 v376 = 770;
                v377[0] = v374;
                unsigned int v378 = "LC_SEGMENT";
                __int16 v379 = 770;
                v380[0] = v377;
                uint64_t v381 = " command ";
                __int16 v382 = 770;
                v383[0] = v380;
                unint64_t v384 = v266 & 0xFFFFFFFF00000000 | v35;
                __int16 v385 = 2050;
                size_t v229 = " less than the segment's vmaddr";
                goto LABEL_535;
              }
            }
            if (v325 && v176 && (unint64_t)v407 + v176 > v313)
            {
              v371[0] = "addr field plus size of section ";
              unint64_t v372 = v274 & 0xFFFFFFFF00000000 | v171;
              __int16 v373 = 2051;
              v374[0] = v371;
              v375 = " in ";
              __int16 v376 = 770;
              v377[0] = v374;
              unsigned int v378 = "LC_SEGMENT";
              __int16 v379 = 770;
              v380[0] = v377;
              uint64_t v381 = " command ";
              __int16 v382 = 770;
              v383[0] = v380;
              unint64_t v384 = v271 & 0xFFFFFFFF00000000 | v35;
              __int16 v385 = 2050;
              size_t v229 = " greater than than the segment's vmaddr plus vmsize";
              goto LABEL_535;
            }
            if (v174 != 9 && v174 != 10 && DWORD2(v408) != 1 && DWORD2(v408) != 18)
            {
              sub_1CCC681C8(&v361, (uint64_t *)&v368, DWORD2(v407), v176, "section contents");
              unint64_t v175 = v332;
              if (v361) {
                break;
              }
            }
            if (v175 < v408)
            {
              v371[0] = "reloff field of section ";
              unint64_t v372 = v292 & 0xFFFFFFFF00000000 | v171;
              __int16 v373 = 2051;
              v374[0] = v371;
              v375 = " in ";
              __int16 v376 = 770;
              v377[0] = v374;
              unsigned int v378 = "LC_SEGMENT";
              __int16 v379 = 770;
              v380[0] = v377;
              uint64_t v381 = " command ";
              __int16 v382 = 770;
              unint64_t v223 = v293 & 0xFFFFFFFF00000000 | v35;
              v383[0] = v380;
LABEL_534:
              unint64_t v384 = v223;
              __int16 v385 = 2050;
              size_t v229 = " extends past the end of the file";
              goto LABEL_535;
            }
            if (v408 + 8 * (unint64_t)DWORD1(v408) > v175)
            {
              v371[0] = "reloff field plus nreloc field times sizeof(struct relocation_info) of section ";
              unint64_t v372 = v288 & 0xFFFFFFFF00000000 | v171;
              __int16 v373 = 2051;
              v374[0] = v371;
              v375 = " in ";
              __int16 v376 = 770;
              v377[0] = v374;
              unsigned int v378 = "LC_SEGMENT";
              __int16 v379 = 770;
              v380[0] = v377;
              uint64_t v381 = " command ";
              __int16 v382 = 770;
              unint64_t v223 = v289 & 0xFFFFFFFF00000000 | v35;
              v383[0] = v380;
              goto LABEL_534;
            }
            sub_1CCC681C8(&v361, (uint64_t *)&v368, v408, 8 * DWORD1(v408), "section relocation entries");
            if (v361) {
              break;
            }
            if (strlen((const char *)&v406) == 6)
            {
              BOOL v182 = v406 == 1163157343 && WORD2(v406) == 21592;
              if (v182
                && strlen(v405) == 14
                && *(void *)v405 == 0x5F6E696168635F5FLL
                && *(void *)&v405[6] == 0x7374726174735F6ELL)
              {
                *(void *)(a1 + 352) = v173;
              }
            }
            uint64_t v167 = v171 + 1;
            BOOL v163 = v171 + 1 >= v322;
            uint64_t v36 = v348;
            uint64_t v30 = v346;
            if (v163) {
              goto LABEL_437;
            }
          }
          uint64_t v30 = v346;
LABEL_537:
          uint64_t v36 = v348;
LABEL_203:
          uint64_t v102 = v361;
LABEL_155:
          *a5 = v102;
          if (v102)
          {
LABEL_623:
            if (v370)
            {
              unsigned int v241 = __p;
              uint64_t v242 = (uint64_t)v368;
              uint64_t v243 = *(void *)__p;
              *(void *)(v243 + ++*(_DWORD *)(this + 8) = v368[1];
              **(void **)(v242 + ++*(_DWORD *)(this + 8) = v243;
              uint64_t v370 = 0;
              if (v241 != &v368)
              {
                do
                {
                  int v244 = (uint64_t *)v241[1];
                  operator delete(v241);
                  unsigned int v241 = v244;
                }
                while (v244 != (uint64_t *)&v368);
              }
            }
            if (!*a5) {
              *a5 = 0;
            }
            return a1;
          }
LABEL_156:
          if (v35 >= v360) {
            goto LABEL_163;
          }
          long long v86 = (_DWORD *)(v367 + HIDWORD(v367));
          uint64_t v87 = 28;
          if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
            uint64_t v87 = 32;
          }
          if ((unint64_t)(v86 + 2) > *(void *)(a1 + 16) + (unint64_t)*(unsigned int *)(a1 + 68) + v87)
          {
            *(void *)v405 = "load command ";
            *(void *)&long long v406 = (v35 + 1) | v358 & 0xFFFFFFFF00000000;
            LOWORD(v407) = 2051;
            v394.i64[0] = (uint64_t)v405;
            *(void *)&long long v395 = " extends past the end all load commands in the file";
            LOWORD(v396) = 770;
            sub_1CCC51CE4((uint64_t)v389, v394.i64);
          }
          sub_1CCC6803C((uint64_t)v389, a1, v86, v35 + 1);
          if (v390)
          {
            uint64_t v69 = *(void *)v389;
            goto LABEL_622;
          }
          long long v367 = *(_OWORD *)v389;
LABEL_163:
          if (++v35 == v29)
          {
            if (v363 && v36)
            {
              uint64_t v238 = sub_1CCC54354(a1, v363);
              if ((v357 & 0x8000000) != 0 && v238 != 36)
              {
                std::string::size_type v246 = "MH_SIM_SUPPORT files only support LC_BUILD_VERSION and LC_VERSION_MIN_MACOSX load commands";
                goto LABEL_620;
              }
              if ((v357 & 0x8000000) == 0 && v238 != 36)
              {
                std::string::size_type v246 = "LC_BUILD_VERSION and some LC_VERSION_MIN load command also found";
                goto LABEL_620;
              }
            }
LABEL_36:
            unint64_t v31 = *(long long **)(a1 + 272);
            uint64_t v32 = *(void *)(a1 + 280);
            if (v31)
            {
              if (v32)
              {
                memset(v389, 0, sizeof(v389));
                *(void *)&long long v390 = 0;
                sub_1CCC530A4((uint64_t)v389, a1, v31);
                long long v398 = 0u;
                long long v397 = 0u;
                long long v396 = 0u;
                long long v395 = 0u;
                int8x16_t v394 = 0u;
                sub_1CCC543D4(a1, *(_OWORD **)(a1 + 280), (uint64_t)&v394);
                if (v394.i32[3])
                {
                  if (v394.i32[2] > *(_DWORD *)&v389[12])
                  {
                    unint64_t v33 = "ilocalsym in LC_DYSYMTAB load command extends past the end of the symbol table";
                    goto LABEL_613;
                  }
                  if (v394.u32[2] + (unint64_t)v394.u32[3] > *(unsigned int *)&v389[12])
                  {
                    unint64_t v33 = "ilocalsym plus nlocalsym in LC_DYSYMTAB load command extends past the end of the symbol table";
                    goto LABEL_613;
                  }
                }
                if (DWORD1(v395))
                {
                  if (v395 > *(_DWORD *)&v389[12])
                  {
                    unint64_t v33 = "iextdefsym in LC_DYSYMTAB load command extends past the end of the symbol table";
                    goto LABEL_613;
                  }
                  if (v395 + (unint64_t)DWORD1(v395) > *(unsigned int *)&v389[12])
                  {
                    unint64_t v33 = "iextdefsym plus nextdefsym in LC_DYSYMTAB load command extends past the end of the symbol table";
                    goto LABEL_613;
                  }
                }
                if (HIDWORD(v395))
                {
                  if (DWORD2(v395) > *(_DWORD *)&v389[12])
                  {
                    unint64_t v33 = "iundefsym in LC_DYSYMTAB load command extends past the end of the symbol table";
                    goto LABEL_613;
                  }
                  if (DWORD2(v395) + (unint64_t)HIDWORD(v395) > *(unsigned int *)&v389[12])
                  {
                    unint64_t v33 = "iundefsym plus nundefsym in LC_DYSYMTAB load  command extends past the end of the symbol table";
LABEL_613:
                    *(void *)v405 = v33;
                    LOWORD(v407) = 259;
                    sub_1CCC51CE4((uint64_t)&v400, (uint64_t *)v405);
                  }
                }
              }
            }
            else if (v32)
            {
              std::string::size_type v246 = "contains LC_DYSYMTAB load command without a LC_SYMTAB load command";
              goto LABEL_620;
            }
            int v240 = *(_DWORD *)(a1 + 60);
            if (v240 != 6 && v240 != 9 && v240 != 14 || v30)
            {
              *a5 = 0;
              goto LABEL_623;
            }
            std::string::size_type v246 = "no LC_ID_DYLIB load command in dynamic library filetype";
LABEL_620:
            v394.i64[0] = (uint64_t)v246;
            LOWORD(v396) = 259;
            sub_1CCC51CE4((uint64_t)v405, v394.i64);
          }
          continue;
        case 2:
          if (HIDWORD(v367) <= 0x17)
          {
            *(void *)v405 = "load command ";
            *(void *)&long long v406 = v342 & 0xFFFFFFFF00000000 | v35;
            LOWORD(v407) = 2051;
            uint64_t v67 = " LC_SYMTAB cmdsize too small";
LABEL_137:
            v394.i64[0] = (uint64_t)v405;
            *(void *)&long long v395 = v67;
            __int16 v85 = 770;
            goto LABEL_286;
          }
          if (*(void *)(a1 + 272))
          {
            uint64_t v104 = "more than one LC_SYMTAB command";
LABEL_285:
            v394.i64[0] = (uint64_t)v104;
            __int16 v85 = 259;
LABEL_286:
            LOWORD(v396) = v85;
            sub_1CCC51CE4((uint64_t)v386, v394.i64);
          }
          unint64_t v137 = *(void *)(a1 + 16);
          if ((unint64_t)v367 < v137 || (unint64_t v138 = *(void *)(a1 + 24), (uint64_t)v367 + 24 > v137 + v138))
          {
LABEL_265:
            v394.i64[0] = (uint64_t)"Structure read out-of-range";
            LOWORD(v396) = 259;
            sub_1CCC51CE4((uint64_t)v405, v394.i64);
          }
          int v348 = v36;
          unsigned int v140 = *(_DWORD *)(v367 + 4);
          unsigned int v139 = *(_DWORD *)(v367 + 8);
          unsigned int v141 = *(_DWORD *)(v367 + 12);
          unsigned int v142 = *(_DWORD *)(v367 + 16);
          unsigned int v143 = *(_DWORD *)(v367 + 20);
          unsigned int v144 = *(_DWORD *)(a1 + 8);
          if (v144 > 0x13)
          {
            uint64_t v145 = v317;
          }
          else
          {
            uint64_t v145 = v317;
            if (((1 << v144) & 0xAAC00) != 0)
            {
              unsigned int v140 = bswap32(v140);
              unsigned int v139 = bswap32(v139);
              unsigned int v141 = bswap32(v141);
              unsigned int v142 = bswap32(v142);
              unsigned int v143 = bswap32(v143);
            }
          }
          if (v140 != 24)
          {
            *(void *)v405 = "LC_SYMTAB command ";
            *(void *)&long long v406 = v145 & 0xFFFFFFFF00000000 | v35;
            LOWORD(v407) = 2051;
            long long v201 = " has incorrect cmdsize";
            goto LABEL_513;
          }
          if (v138 < v139)
          {
            *(void *)v405 = "symoff field of LC_SYMTAB command ";
            *(void *)&long long v406 = v304 & 0xFFFFFFFF00000000 | v35;
LABEL_492:
            __int16 v221 = 2051;
LABEL_512:
            LOWORD(v407) = v221;
            long long v201 = " extends past the end of the file";
LABEL_513:
            v394.i64[0] = (uint64_t)v405;
            *(void *)&long long v395 = v201;
            LOWORD(v396) = 770;
            sub_1CCC51CE4((uint64_t)v386, v394.i64);
          }
          unsigned int v334 = v143;
          unint64_t v205 = v139;
          unsigned int v206 = v144 & 0xFFFFFFFE;
          uint64_t v207 = 16 * v141;
          uint64_t v208 = 12 * v141;
          if (v206 == 18) {
            uint64_t v209 = v207;
          }
          else {
            uint64_t v209 = v208;
          }
          if (v206 == 18) {
            char v210 = "struct nlist_64";
          }
          else {
            char v210 = "struct nlist";
          }
          if (v209 + v205 > v138)
          {
            if (*v210)
            {
              char v211 = (const char *)&v400;
              *(void *)&long long v401 = v210;
              char v212 = 3;
              char v213 = 2;
            }
            else
            {
              char v212 = 1;
              char v211 = "symoff field plus nsyms field times sizeof(";
              char v213 = 3;
            }
            *(void *)&long long v400 = "symoff field plus nsyms field times sizeof(";
            LOBYTE(v402) = 3;
            BYTE1(v402) = v212;
            *(void *)int v389 = v211;
            *(void *)&long long v390 = ") of LC_SYMTAB command ";
            LOBYTE(v391) = v213;
            BYTE1(v391) = 3;
            *(void *)v405 = v389;
            *(void *)&long long v406 = v297 & 0xFFFFFFFF00000000 | v35;
            __int16 v221 = 2050;
            goto LABEL_512;
          }
          sub_1CCC681C8(v386, (uint64_t *)&v368, v205, v209, "symbol table");
          uint64_t v69 = v386[0];
          if (v386[0]) {
            goto LABEL_622;
          }
          if (v138 < v142)
          {
            unint64_t v220 = v294 & 0xFFFFFFFF00000000 | v35;
            *(void *)v405 = "stroff field of LC_SYMTAB command ";
LABEL_491:
            *(void *)&long long v406 = v220;
            goto LABEL_492;
          }
          if (v142 + (unint64_t)v334 > v138)
          {
            unint64_t v220 = v283 & 0xFFFFFFFF00000000 | v35;
            *(void *)v405 = "stroff field plus strsize field of LC_SYMTAB command ";
            goto LABEL_491;
          }
          sub_1CCC681C8(v386, (uint64_t *)&v368, v142, v334, "string table");
          uint64_t v69 = v386[0];
          if (v386[0]) {
            goto LABEL_622;
          }
          *(void *)(a1 + 272) = v367;
          goto LABEL_563;
        case 3:
        case 6:
        case 7:
        case 9:
        case 0xA:
        case 0x10:
        case 0x17:
        case 0x18:
        case 0x1C:
        case 0x1F:
        case 0x23:
        case 0x28:
          goto LABEL_73;
        case 4:
          sub_1CCC53688((uint64_t)&v394, a1, v367, HIDWORD(v367), v35, "LC_THREAD");
          goto LABEL_154;
        case 5:
          sub_1CCC53688((uint64_t)&v394, a1, v367, HIDWORD(v367), v35, "LC_UNIXTHREAD");
          uint64_t v68 = v394.i64[0];
          *a5 = v394.i64[0];
          if (v68) {
            goto LABEL_623;
          }
          if (!v352)
          {
            uint64_t v352 = v367;
            goto LABEL_156;
          }
          std::string::size_type v246 = "more than one LC_UNIXTHREAD command";
          goto LABEL_620;
        case 8:
          goto LABEL_163;
        case 0xB:
          if (HIDWORD(v367) <= 0x4F)
          {
            *(void *)v405 = "load command ";
            *(void *)&long long v406 = v343 & 0xFFFFFFFF00000000 | v35;
            LOWORD(v407) = 2051;
            uint64_t v67 = " LC_DYSYMTAB cmdsize too small";
            goto LABEL_137;
          }
          if (*(void *)(a1 + 280))
          {
            uint64_t v104 = "more than one LC_DYSYMTAB command";
            goto LABEL_285;
          }
          unint64_t v146 = *(void *)(a1 + 16);
          if ((unint64_t)v367 < v146 || (unint64_t v147 = *(void *)(a1 + 24), (uint64_t)v367 + 80 > v146 + v147))
          {
            uint64_t v104 = "Structure read out-of-range";
            goto LABEL_285;
          }
          unsigned int v148 = *(_DWORD *)(v367 + 4);
          unsigned int v150 = *(_DWORD *)(v367 + 32);
          unsigned int v149 = *(_DWORD *)(v367 + 36);
          unsigned int v152 = *(_DWORD *)(v367 + 40);
          unsigned int v151 = *(_DWORD *)(v367 + 44);
          unsigned int v154 = *(_DWORD *)(v367 + 48);
          unsigned int v153 = *(_DWORD *)(v367 + 52);
          unsigned int v156 = *(_DWORD *)(v367 + 56);
          unsigned int v155 = *(_DWORD *)(v367 + 60);
          unsigned int v158 = *(_DWORD *)(v367 + 64);
          unsigned int v157 = *(_DWORD *)(v367 + 68);
          unsigned int v160 = *(_DWORD *)(v367 + 72);
          unsigned int v159 = *(_DWORD *)(v367 + 76);
          unsigned int v161 = *(_DWORD *)(a1 + 8);
          if (v161 > 0x13)
          {
            uint64_t v162 = v318;
          }
          else
          {
            BOOL v37 = ((1 << v161) & 0xAAC00) == 0;
            uint64_t v162 = v318;
            if (!v37)
            {
              unsigned int v148 = bswap32(v148);
              unsigned int v150 = bswap32(v150);
              unsigned int v149 = bswap32(v149);
              unsigned int v152 = bswap32(v152);
              unsigned int v151 = bswap32(v151);
              unsigned int v154 = bswap32(v154);
              unsigned int v153 = bswap32(v153);
              unsigned int v156 = bswap32(v156);
              unsigned int v155 = bswap32(v155);
              unsigned int v158 = bswap32(v158);
              unsigned int v157 = bswap32(v157);
              unsigned int v160 = bswap32(v160);
              unsigned int v159 = bswap32(v159);
            }
          }
          if (v148 != 80)
          {
            *(void *)v405 = "LC_DYSYMTAB command ";
            *(void *)&long long v406 = v162 & 0xFFFFFFFF00000000 | v35;
            LOWORD(v407) = 2051;
            uint64_t v202 = " has incorrect cmdsize";
            goto LABEL_456;
          }
          if (v147 < v150)
          {
            *(void *)v405 = "tocoff field of LC_DYSYMTAB command ";
            *(void *)&long long v406 = v305 & 0xFFFFFFFF00000000 | v35;
LABEL_454:
            __int16 v215 = 2051;
LABEL_455:
            LOWORD(v407) = v215;
            uint64_t v202 = " extends past the end of the file";
LABEL_456:
            v394.i64[0] = (uint64_t)v405;
            *(void *)&long long v395 = v202;
            LOWORD(v396) = 770;
            sub_1CCC51CE4((uint64_t)v386, v394.i64);
          }
          unsigned int v327 = v151;
          unsigned int v324 = v154;
          unsigned int v321 = v153;
          unsigned int v315 = v156;
          unsigned int v312 = v155;
          unsigned int v308 = v158;
          unsigned int v303 = v157;
          unsigned int v300 = v160;
          unsigned int v299 = v159;
          unint64_t v335 = *(void *)(a1 + 24);
          if (v150 + 8 * (unint64_t)v149 > v147)
          {
            unint64_t v214 = v298 & 0xFFFFFFFF00000000 | v35;
            *(void *)v405 = "tocoff field plus ntoc field times sizeof(struct dylib_table_of_contents) of LC_DYSYMTAB command ";
LABEL_453:
            *(void *)&long long v406 = v214;
            goto LABEL_454;
          }
          sub_1CCC681C8(v386, (uint64_t *)&v368, v150, 8 * v149, "table of contents");
          if (!v386[0])
          {
            if (v335 < v152)
            {
              unint64_t v214 = v262 & 0xFFFFFFFF00000000 | v35;
              *(void *)v405 = "modtaboff field of LC_DYSYMTAB command ";
              goto LABEL_453;
            }
            unsigned int v231 = *(_DWORD *)(a1 + 8) & 0xFFFFFFFE;
            uint64_t v232 = "struct dylib_module_64";
            BOOL v233 = v231 == 18;
            if (v231 != 18) {
              uint64_t v232 = "struct dylib_module";
            }
            unsigned int v234 = 52;
            if (v233) {
              unsigned int v234 = 56;
            }
            if (v152 + v234 * (unint64_t)v327 > v335)
            {
              if (*v232)
              {
                size_t v235 = (const char *)&v400;
                *(void *)&long long v401 = v232;
                char v236 = 3;
                char v237 = 2;
              }
              else
              {
                char v236 = 1;
                size_t v235 = "modtaboff field plus nmodtab field times sizeof(";
                char v237 = 3;
              }
              *(void *)&long long v400 = "modtaboff field plus nmodtab field times sizeof(";
              LOBYTE(v402) = 3;
              BYTE1(v402) = v236;
              *(void *)int v389 = v235;
              *(void *)&long long v390 = ") of LC_DYSYMTAB command ";
              LOBYTE(v391) = v237;
              BYTE1(v391) = 3;
              *(void *)v405 = v389;
              *(void *)&long long v406 = v257 & 0xFFFFFFFF00000000 | v35;
              __int16 v215 = 2050;
              goto LABEL_455;
            }
            sub_1CCC681C8(v386, (uint64_t *)&v368, v152, v234 * (unint64_t)v327, "module table");
            if (!v386[0])
            {
              if (v335 < v324)
              {
                unint64_t v214 = v254 & 0xFFFFFFFF00000000 | v35;
                *(void *)v405 = "extrefsymoff field of LC_DYSYMTAB command ";
                goto LABEL_453;
              }
              if (v324 + 4 * (unint64_t)v321 > v335)
              {
                unint64_t v214 = v253 & 0xFFFFFFFF00000000 | v35;
                *(void *)v405 = "extrefsymoff field plus nextrefsyms field times sizeof(struct dylib_reference) of LC_D"
                                  "YSYMTAB command ";
                goto LABEL_453;
              }
              sub_1CCC681C8(v386, (uint64_t *)&v368, v324, 4 * v321, "reference table");
              if (!v386[0])
              {
                if (v335 < v315)
                {
                  unint64_t v214 = v252 & 0xFFFFFFFF00000000 | v35;
                  *(void *)v405 = "indirectsymoff field of LC_DYSYMTAB command ";
                  goto LABEL_453;
                }
                if (v315 + 4 * (unint64_t)v312 > v335)
                {
                  unint64_t v214 = v251 & 0xFFFFFFFF00000000 | v35;
                  *(void *)v405 = "indirectsymoff field plus nindirectsyms field times sizeof(uint32_t) of LC_DYSYMTAB command ";
                  goto LABEL_453;
                }
                sub_1CCC681C8(v386, (uint64_t *)&v368, v315, 4 * v312, "indirect table");
                if (!v386[0])
                {
                  if (v335 < v308)
                  {
                    unint64_t v214 = v250 & 0xFFFFFFFF00000000 | v35;
                    *(void *)v405 = "extreloff field of LC_DYSYMTAB command ";
                    goto LABEL_453;
                  }
                  if (v308 + 8 * (unint64_t)v303 > v335)
                  {
                    unint64_t v214 = v249 & 0xFFFFFFFF00000000 | v35;
                    *(void *)v405 = "extreloff field plus nextrel field times sizeof(struct relocation_info) of LC_DYSYMTAB command ";
                    goto LABEL_453;
                  }
                  sub_1CCC681C8(v386, (uint64_t *)&v368, v308, 8 * v303, "external relocation table");
                  if (!v386[0])
                  {
                    if (v335 < v300)
                    {
                      unint64_t v214 = v248 & 0xFFFFFFFF00000000 | v35;
                      *(void *)v405 = "locreloff field of LC_DYSYMTAB command ";
                      goto LABEL_453;
                    }
                    if (v300 + 8 * (unint64_t)v299 > v335)
                    {
                      unint64_t v214 = v247 & 0xFFFFFFFF00000000 | v35;
                      *(void *)v405 = "locreloff field plus nlocrel field times sizeof(struct relocation_info) of LC_DYSYMTAB command ";
                      goto LABEL_453;
                    }
                    sub_1CCC681C8(v386, (uint64_t *)&v368, v300, 8 * v299, "local relocation table");
                    if (!v386[0])
                    {
                      *(void *)(a1 + 280) = v367;
                      v386[0] = 0;
                    }
                  }
                }
              }
            }
          }
          uint64_t v29 = v356;
          uint64_t v102 = v386[0];
          goto LABEL_155;
        case 0xC:
          uint64_t v43 = "LC_LOAD_DYLIB";
          goto LABEL_129;
        case 0xD:
          sub_1CCC5260C(v405, a1, (uint64_t)&v367, v35, "LC_ID_DYLIB");
          uint64_t v69 = *(void *)v405;
          if (*(void *)v405) {
            goto LABEL_622;
          }
          if (v30)
          {
            uint64_t v70 = "more than one LC_ID_DYLIB command";
            goto LABEL_187;
          }
          unsigned int v118 = *(_DWORD *)(a1 + 60);
          if (v118 <= 0xE && ((1 << v118) & 0x4240) != 0)
          {
            uint64_t v30 = v367;
LABEL_234:
            *a5 = 0;
            goto LABEL_156;
          }
          uint64_t v70 = "LC_ID_DYLIB load command in non-dynamic library file type";
          goto LABEL_187;
        case 0xE:
          unint64_t v55 = v367;
          unsigned int v56 = HIDWORD(v367);
          uint64_t v57 = "LC_LOAD_DYLINKER";
          goto LABEL_148;
        case 0xF:
          unint64_t v55 = v367;
          unsigned int v56 = HIDWORD(v367);
          uint64_t v57 = "LC_ID_DYLINKER";
          goto LABEL_148;
        case 0x11:
          if (HIDWORD(v367) == 40)
          {
            if (v355)
            {
              std::string::size_type v246 = "more than one LC_ROUTINES and or LC_ROUTINES_64 command";
              goto LABEL_620;
            }
            goto LABEL_124;
          }
          unint64_t v245 = "LC_ROUTINES command ";
          goto LABEL_640;
        case 0x12:
          if (HIDWORD(v367) > 0xB)
          {
            sub_1CCC5312C(a1, (_DWORD *)v367);
            unsigned int v72 = v71;
            uint64_t v73 = v367;
            unsigned int v74 = HIDWORD(v367);
            std::string::size_type v75 = "LC_SUB_FRAMEWORK";
            uint64_t v76 = "sub_framework_command";
            uint64_t v77 = "umbrella";
LABEL_118:
            sub_1CCC531AC(&v394, v73, v74, v35, v75, v76, v72, v77);
            goto LABEL_154;
          }
          *(void *)v405 = "load command ";
          *(void *)&long long v406 = v35;
          LOWORD(v407) = 2051;
          uint64_t v239 = " LC_SUB_FRAMEWORK cmdsize too small";
          goto LABEL_641;
        case 0x13:
          if (HIDWORD(v367) > 0xB)
          {
            sub_1CCC5312C(a1, (_DWORD *)v367);
            unsigned int v72 = v78;
            uint64_t v73 = v367;
            unsigned int v74 = HIDWORD(v367);
            std::string::size_type v75 = "LC_SUB_UMBRELLA";
            uint64_t v76 = "sub_umbrella_command";
            uint64_t v77 = "sub_umbrella";
            goto LABEL_118;
          }
          *(void *)v405 = "load command ";
          *(void *)&long long v406 = v35;
          LOWORD(v407) = 2051;
          uint64_t v239 = " LC_SUB_UMBRELLA cmdsize too small";
          goto LABEL_641;
        case 0x14:
          if (HIDWORD(v367) > 0xB)
          {
            sub_1CCC5312C(a1, (_DWORD *)v367);
            unsigned int v72 = v79;
            uint64_t v73 = v367;
            unsigned int v74 = HIDWORD(v367);
            std::string::size_type v75 = "LC_SUB_CLIENT";
            uint64_t v76 = "sub_client_command";
            uint64_t v77 = "client";
            goto LABEL_118;
          }
          *(void *)v405 = "load command ";
          *(void *)&long long v406 = v35;
          LOWORD(v407) = 2051;
          uint64_t v239 = " LC_SUB_CLIENT cmdsize too small";
          goto LABEL_641;
        case 0x15:
          if (HIDWORD(v367) > 0xB)
          {
            sub_1CCC5312C(a1, (_DWORD *)v367);
            unsigned int v72 = v80;
            uint64_t v73 = v367;
            unsigned int v74 = HIDWORD(v367);
            std::string::size_type v75 = "LC_SUB_LIBRARY";
            uint64_t v76 = "sub_library_command";
            uint64_t v77 = "sub_library";
            goto LABEL_118;
          }
          *(void *)v405 = "load command ";
          *(void *)&long long v406 = v35;
          LOWORD(v407) = 2051;
          uint64_t v239 = " LC_SUB_LIBRARY cmdsize too small";
          goto LABEL_641;
        case 0x16:
          if (HIDWORD(v367) == 16)
          {
            if (v350)
            {
              v394.i64[0] = (uint64_t)"more than one LC_TWOLEVEL_HINTS command";
              __int16 v58 = 259;
              goto LABEL_430;
            }
            unint64_t v128 = *(void *)(a1 + 16);
            if ((unint64_t)v367 < v128 || (unint64_t v129 = *(void *)(a1 + 24), (uint64_t)v367 + 16 > v128 + v129))
            {
              v394.i64[0] = (uint64_t)"Structure read out-of-range";
              LOWORD(v396) = 259;
              sub_1CCC51CE4((uint64_t)v405, v394.i64);
            }
            unsigned int v131 = *(_DWORD *)(v367 + 8);
            unsigned int v130 = *(_DWORD *)(v367 + 12);
            unsigned int v132 = *(_DWORD *)(a1 + 8);
            unsigned int v133 = bswap32(v131);
            unsigned int v134 = bswap32(v130);
            if (((1 << v132) & 0xAAC00) == 0)
            {
              unsigned int v134 = *(_DWORD *)(v367 + 12);
              unsigned int v133 = *(_DWORD *)(v367 + 8);
            }
            if (v132 > 0x13)
            {
              unint64_t v135 = v131;
            }
            else
            {
              unsigned int v130 = v134;
              unint64_t v135 = v133;
            }
            if (v129 < v135)
            {
              unsigned int v136 = "offset field of LC_TWOLEVEL_HINTS command ";
LABEL_426:
              *(void *)v405 = v136;
              *(void *)&long long v406 = v35;
LABEL_427:
              LOWORD(v407) = 2051;
              int v103 = " extends past the end of the file";
              goto LABEL_428;
            }
            if (v135 + 4 * v130 > v129)
            {
              unsigned int v136 = "offset field plus nhints times sizeof(struct twolevel_hint) field of LC_TWOLEVEL_HINTS command ";
              goto LABEL_426;
            }
            sub_1CCC681C8(v389, (uint64_t *)&v368, v135, 4 * v130, "two level hints");
            uint64_t v69 = *(void *)v389;
            if (!*(void *)v389)
            {
              uint64_t v350 = v367;
              goto LABEL_234;
            }
LABEL_622:
            *a5 = v69;
            goto LABEL_623;
          }
          *(void *)v405 = "load command ";
          *(void *)&long long v406 = v35;
          LOWORD(v407) = 2051;
          int v103 = " LC_TWOLEVEL_HINTS has incorrect cmdsize";
          goto LABEL_428;
        case 0x19:
          if (HIDWORD(v367) <= 0x47)
          {
            *(void *)&long long v400 = "load command ";
            *(void *)&long long v401 = v341 & 0xFFFFFFFF00000000 | v35;
            LOWORD(v402) = 2051;
            *(void *)int v389 = &v400;
            *(void *)&long long v390 = " ";
            LOWORD(v391) = 770;
            uint64_t v40 = "LC_SEGMENT_64";
            goto LABEL_121;
          }
          sub_1CCC6FAAC((uint64_t)v405, a1, v367);
          if (v410)
          {
            uint64_t v361 = *(void *)v405;
            goto LABEL_203;
          }
          long long v402 = v407;
          long long v403 = v408;
          uint64_t v404 = v409;
          long long v400 = *(_OWORD *)v405;
          long long v401 = v406;
          if (v409 > 0x3333333 || 80 * (int)v409 > (HIDWORD(v367) - 72))
          {
            v383[0] = "load command ";
            unint64_t v384 = v330 & 0xFFFFFFFF00000000 | v35;
            __int16 v385 = 2051;
            v386[0] = (uint64_t)v383;
            uint64_t v387 = " inconsistent cmdsize in ";
            __int16 v388 = 770;
            *(void *)int v389 = v386;
            *(void *)&long long v390 = "LC_SEGMENT_64";
            LOWORD(v391) = 770;
            unint64_t v81 = v389;
LABEL_201:
            unint64_t v82 = " for the number of sections";
LABEL_202:
            v394.i64[0] = (uint64_t)v81;
            *(void *)&long long v395 = v82;
            LOWORD(v396) = 770;
            sub_1CCC51CE4((uint64_t)&v361, v394.i64);
          }
          int v348 = v36;
          unint64_t v184 = *(void *)(a1 + 24);
          unint64_t v320 = *((void *)&v402 + 1);
          if (v409)
          {
            uint64_t v185 = 0;
            unint64_t v311 = v403;
            unint64_t v307 = *((void *)&v401 + 1);
            uint64_t v326 = v402;
            unint64_t v314 = v402 + *((void *)&v401 + 1);
            int v323 = v409;
            uint64_t v346 = v30;
            unint64_t v333 = *(void *)(a1 + 24);
            do
            {
              if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
                int v186 = 80;
              }
              else {
                int v186 = 68;
              }
              if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
                uint64_t v187 = 72;
              }
              else {
                uint64_t v187 = 56;
              }
              unint64_t v188 = *(unsigned int *)(a1 + 88);
              if (v188 >= *(unsigned int *)(a1 + 92)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              uint64_t v189 = v187 + v367;
              uint64_t v190 = v185;
              unint64_t v191 = v189 + (v186 * v185);
              *(void *)(*(void *)(a1 + 80) + 8 * v18++*(_DWORD *)(this + 8) = v191;
              ++*(_DWORD *)(a1 + 88);
              sub_1CCC65698((uint64_t)&v394, a1, v191);
              if (v399)
              {
LABEL_479:
                uint64_t v361 = v394.i64[0];
                uint64_t v30 = v346;
                uint64_t v29 = v356;
                goto LABEL_537;
              }
              long long v391 = v396;
              long long v392 = v397;
              long long v393 = v398;
              long long v390 = v395;
              *(int8x16_t *)int v389 = v394;
              int v192 = *(_DWORD *)(a1 + 60);
              unint64_t v184 = v333;
              if (v192 == 9)
              {
                uint64_t v193 = *((void *)&v391 + 1);
              }
              else
              {
                BOOL v195 = v192 == 10 || v393 == 1 || v393 == 18;
                int v196 = !v195;
                if (!v195 && v333 < v392)
                {
                  v371[0] = "offset field of section ";
                  unint64_t v372 = (v279 & 0xFFFFFFFF00000000) + v190;
                  __int16 v373 = 2051;
                  v374[0] = v371;
                  v375 = " in ";
                  __int16 v376 = 770;
                  v377[0] = v374;
                  unsigned int v378 = "LC_SEGMENT_64";
                  __int16 v379 = 770;
                  v380[0] = v377;
                  uint64_t v381 = " command ";
                  __int16 v382 = 770;
                  unint64_t v224 = v280 & 0xFFFFFFFF00000000 | v35;
                  v383[0] = v380;
LABEL_539:
                  unint64_t v384 = v224;
                  __int16 v385 = 2050;
                  long long v230 = " extends past the end of the file";
                  goto LABEL_540;
                }
                if (v320) {
                  int v197 = 0;
                }
                else {
                  int v197 = v196;
                }
                uint64_t v193 = *((void *)&v391 + 1);
                if (v197 == 1 && v359 > v392 && *((void *)&v391 + 1))
                {
                  v371[0] = "offset field of section ";
                  unint64_t v372 = (v258 & 0xFFFFFFFF00000000) + v190;
                  __int16 v373 = 2051;
                  v374[0] = v371;
                  v375 = " in ";
                  __int16 v376 = 770;
                  v377[0] = v374;
                  unsigned int v378 = "LC_SEGMENT_64";
                  __int16 v379 = 770;
                  v380[0] = v377;
                  uint64_t v381 = " command ";
                  __int16 v382 = 770;
                  v383[0] = v380;
                  unint64_t v384 = v259 & 0xFFFFFFFF00000000 | v35;
                  __int16 v385 = 2050;
                  long long v230 = " not past the headers of the file";
LABEL_540:
                  v386[0] = (uint64_t)v383;
                  uint64_t v387 = v230;
                  __int16 v388 = 770;
                  sub_1CCC51CE4((uint64_t)&v361, v386);
                }
                if (*((void *)&v391 + 1) + (unint64_t)v392 > v333) {
                  int v198 = v196;
                }
                else {
                  int v198 = 0;
                }
                if (v198 == 1)
                {
                  v371[0] = "offset field plus size field of section ";
                  unint64_t v372 = (v275 & 0xFFFFFFFF00000000) + v190;
                  __int16 v373 = 2051;
                  v374[0] = v371;
                  v375 = " in ";
                  __int16 v376 = 770;
                  v377[0] = v374;
                  unsigned int v378 = "LC_SEGMENT_64";
                  __int16 v379 = 770;
                  v380[0] = v377;
                  uint64_t v381 = " command ";
                  __int16 v382 = 770;
                  unint64_t v224 = v276 & 0xFFFFFFFF00000000 | v35;
                  v383[0] = v380;
                  goto LABEL_539;
                }
                if (*((void *)&v391 + 1) <= v311) {
                  int v196 = 0;
                }
                if (v196 == 1)
                {
                  v371[0] = "size field of section ";
                  unint64_t v372 = (v267 & 0xFFFFFFFF00000000) + v190;
                  __int16 v373 = 2051;
                  v374[0] = v371;
                  v375 = " in ";
                  __int16 v376 = 770;
                  v377[0] = v374;
                  unsigned int v378 = "LC_SEGMENT_64";
                  __int16 v379 = 770;
                  v380[0] = v377;
                  uint64_t v381 = " command ";
                  __int16 v382 = 770;
                  v383[0] = v380;
                  unint64_t v384 = v268 & 0xFFFFFFFF00000000 | v35;
                  __int16 v385 = 2050;
                  long long v230 = " greater than the segment";
                  goto LABEL_540;
                }
                if (v192 != 10 && *((void *)&v391 + 1) && (unint64_t)v391 < v307)
                {
                  v371[0] = "addr field of section ";
                  unint64_t v372 = (v263 & 0xFFFFFFFF00000000) + v190;
                  __int16 v373 = 2051;
                  v374[0] = v371;
                  v375 = " in ";
                  __int16 v376 = 770;
                  v377[0] = v374;
                  unsigned int v378 = "LC_SEGMENT_64";
                  __int16 v379 = 770;
                  v380[0] = v377;
                  uint64_t v381 = " command ";
                  __int16 v382 = 770;
                  v383[0] = v380;
                  unint64_t v384 = v264 & 0xFFFFFFFF00000000 | v35;
                  __int16 v385 = 2050;
                  long long v230 = " less than the segment's vmaddr";
                  goto LABEL_540;
                }
              }
              if (v326 && v193 && (uint64_t)v391 + v193 > v314)
              {
                v371[0] = "addr field plus size of section ";
                unint64_t v372 = (v272 & 0xFFFFFFFF00000000) + v190;
                __int16 v373 = 2051;
                v374[0] = v371;
                v375 = " in ";
                __int16 v376 = 770;
                v377[0] = v374;
                unsigned int v378 = "LC_SEGMENT_64";
                __int16 v379 = 770;
                v380[0] = v377;
                uint64_t v381 = " command ";
                __int16 v382 = 770;
                v383[0] = v380;
                unint64_t v384 = v273 & 0xFFFFFFFF00000000 | v35;
                __int16 v385 = 2050;
                long long v230 = " greater than than the segment's vmaddr plus vmsize";
                goto LABEL_540;
              }
              if (v192 != 9 && v192 != 10 && v393 != 1 && v393 != 18)
              {
                sub_1CCC681C8(&v361, (uint64_t *)&v368, v392, v193, "section contents");
                if (v361)
                {
LABEL_541:
                  uint64_t v29 = v356;
                  uint64_t v36 = v348;
                  uint64_t v30 = v346;
                  goto LABEL_203;
                }
              }
              if (v333 < DWORD2(v392))
              {
                v371[0] = "reloff field of section ";
                unint64_t v372 = (v290 & 0xFFFFFFFF00000000) + v190;
                __int16 v373 = 2051;
                v374[0] = v371;
                v375 = " in ";
                __int16 v376 = 770;
                v377[0] = v374;
                unsigned int v378 = "LC_SEGMENT_64";
                __int16 v379 = 770;
                v380[0] = v377;
                uint64_t v381 = " command ";
                __int16 v382 = 770;
                unint64_t v224 = v291 & 0xFFFFFFFF00000000 | v35;
                v383[0] = v380;
                goto LABEL_539;
              }
              if (DWORD2(v392) + 8 * (unint64_t)HIDWORD(v392) > v333)
              {
                v371[0] = "reloff field plus nreloc field times sizeof(struct relocation_info) of section ";
                unint64_t v372 = (v286 & 0xFFFFFFFF00000000) + v190;
                __int16 v373 = 2051;
                v374[0] = v371;
                v375 = " in ";
                __int16 v376 = 770;
                v377[0] = v374;
                unsigned int v378 = "LC_SEGMENT_64";
                __int16 v379 = 770;
                v380[0] = v377;
                uint64_t v381 = " command ";
                __int16 v382 = 770;
                unint64_t v224 = v287 & 0xFFFFFFFF00000000 | v35;
                v383[0] = v380;
                goto LABEL_539;
              }
              sub_1CCC681C8(&v361, (uint64_t *)&v368, DWORD2(v392), 8 * HIDWORD(v392), "section relocation entries");
              if (v361) {
                goto LABEL_541;
              }
              if (strlen((const char *)&v390) == 6)
              {
                BOOL v199 = v390 == 1163157343 && WORD2(v390) == 21592;
                if (v199
                  && strlen(v389) == 14
                  && *(void *)v389 == 0x5F6E696168635F5FLL
                  && *(void *)&v389[6] == 0x7374726174735F6ELL)
                {
                  *(void *)(a1 + 352) = v191;
                }
              }
              uint64_t v185 = v190 + 1;
              BOOL v37 = v323 == v190 + 1;
              uint64_t v30 = v346;
            }
            while (!v37);
          }
          if (v320 > v184)
          {
            v383[0] = "load command ";
            unint64_t v384 = v301 & 0xFFFFFFFF00000000 | v35;
            __int16 v385 = 2051;
            uint64_t v204 = " fileoff field in ";
LABEL_471:
            v386[0] = (uint64_t)v383;
            uint64_t v387 = v204;
            __int16 v388 = 770;
            *(void *)int v389 = v386;
            *(void *)&long long v390 = "LC_SEGMENT_64";
            LOWORD(v391) = 770;
            char v219 = " extends past the end of the file";
            goto LABEL_472;
          }
          if ((unint64_t)v403 + v320 > v184)
          {
            v383[0] = "load command ";
            unint64_t v384 = v295 & 0xFFFFFFFF00000000 | v35;
            __int16 v385 = 2051;
            uint64_t v204 = " fileoff field plus filesize field in ";
            goto LABEL_471;
          }
          if ((void)v402 && (unint64_t)v403 > (unint64_t)v402)
          {
            v383[0] = "load command ";
            unint64_t v384 = v284 & 0xFFFFFFFF00000000 | v35;
            __int16 v385 = 2051;
            v386[0] = (uint64_t)v383;
            uint64_t v387 = " filesize field in ";
            __int16 v388 = 770;
            *(void *)int v389 = v386;
            *(void *)&long long v390 = "LC_SEGMENT_64";
            LOWORD(v391) = 770;
            char v219 = " greater than vmsize field";
LABEL_472:
            v394.i64[0] = (uint64_t)v389;
            *(void *)&long long v395 = v219;
            LOWORD(v396) = 770;
            sub_1CCC51CE4((uint64_t)&v361, v394.i64);
          }
          BOOL v228 = strlen((const char *)&v400 + 8) == 10
              && *((void *)&v400 + 1) == 0x455A454741505F5FLL
              && (unsigned __int16)v401 == 20306;
          *(unsigned char *)(a1 + 344) |= v228;
LABEL_563:
          *a5 = 0;
          goto LABEL_229;
        case 0x1A:
          if (HIDWORD(v367) == 72)
          {
            if (v355)
            {
              std::string::size_type v246 = "more than one LC_ROUTINES_64 and or LC_ROUTINES command";
              goto LABEL_620;
            }
LABEL_124:
            uint64_t v355 = v367;
            goto LABEL_156;
          }
          unint64_t v245 = "LC_ROUTINES_64 command ";
          goto LABEL_640;
        case 0x1B:
          if (HIDWORD(v367) == 24)
          {
            if (!*(void *)(a1 + 336))
            {
              *(void *)(a1 + 336) = v367;
              goto LABEL_156;
            }
            std::string::size_type v246 = "more than one LC_UUID command";
            goto LABEL_620;
          }
          unint64_t v245 = "LC_UUID command ";
          goto LABEL_640;
        case 0x1D:
          uint64_t v47 = "LC_CODE_SIGNATURE";
          std::string::size_type v48 = "code signature data";
          uint64_t v46 = &v364;
          goto LABEL_127;
        case 0x1E:
          uint64_t v47 = "LC_SEGMENT_SPLIT_INFO";
          std::string::size_type v48 = "split info data";
          uint64_t v46 = &v366;
          goto LABEL_127;
        case 0x20:
          uint64_t v43 = "LC_LAZY_LOAD_DYLIB";
LABEL_129:
          uint64_t v41 = a1;
          unsigned int v42 = v35;
          goto LABEL_130;
        case 0x21:
          if (HIDWORD(v367) == 20)
          {
            int8x16_t v394 = 0uLL;
            LODWORD(v395) = 0;
            sub_1CCC52F18(&v394, a1, (int8x16_t *)v367);
            unint64_t v59 = v394.u32[2];
            uint64_t v60 = v394.u32[3];
            unint64_t v61 = *(void *)(a1 + 24);
            uint64_t v62 = v367;
            unsigned int v63 = "LC_ENCRYPTION_INFO";
            goto LABEL_141;
          }
          unint64_t v245 = "LC_ENCRYPTION_INFO command ";
          goto LABEL_640;
        case 0x22:
          uint64_t v53 = "LC_DYLD_INFO";
          uint64_t v50 = a1;
          unsigned int v51 = v35;
          size_t v52 = (void *)(a1 + 304);
          goto LABEL_143;
        case 0x24:
          uint64_t v64 = v367;
          int v65 = HIDWORD(v367);
          uint64_t v66 = "LC_VERSION_MIN_MACOSX";
          goto LABEL_153;
        case 0x25:
          uint64_t v64 = v367;
          int v65 = HIDWORD(v367);
          uint64_t v66 = "LC_VERSION_MIN_IPHONEOS";
          goto LABEL_153;
        case 0x26:
          uint64_t v47 = "LC_FUNCTION_STARTS";
          std::string::size_type v48 = "function starts data";
          uint64_t v44 = a1;
          unsigned int v45 = v35;
          uint64_t v46 = (uint64_t *)(a1 + 320);
          goto LABEL_146;
        case 0x27:
          unint64_t v55 = v367;
          unsigned int v56 = HIDWORD(v367);
          uint64_t v57 = "LC_DYLD_ENVIRONMENT";
LABEL_148:
          sub_1CCC52A00(&v394, a1, v55, v56, v35, v57);
          goto LABEL_154;
        case 0x29:
          uint64_t v47 = "LC_DATA_IN_CODE";
          std::string::size_type v48 = "data in code info";
          uint64_t v44 = a1;
          unsigned int v45 = v35;
          uint64_t v46 = (uint64_t *)(a1 + 288);
          goto LABEL_146;
        case 0x2A:
          if (HIDWORD(v367) == 16)
          {
            if (!v353)
            {
              uint64_t v353 = v367;
              goto LABEL_156;
            }
            std::string::size_type v246 = "more than one LC_SOURCE_VERSION command";
            goto LABEL_620;
          }
          unint64_t v245 = "LC_SOURCE_VERSION command ";
          goto LABEL_640;
        case 0x2B:
          uint64_t v47 = "LC_DYLIB_CODE_SIGN_DRS";
          std::string::size_type v48 = "code signing RDs data";
          uint64_t v46 = &v365;
LABEL_127:
          uint64_t v44 = a1;
          unsigned int v45 = v35;
          goto LABEL_146;
        case 0x2C:
          if (HIDWORD(v367) == 24)
          {
            int8x16_t v394 = 0uLL;
            *(void *)&long long v395 = 0;
            sub_1CCC530A4((uint64_t)&v394, a1, (long long *)v367);
            unint64_t v59 = v394.u32[2];
            uint64_t v60 = v394.u32[3];
            unint64_t v61 = *(void *)(a1 + 24);
            uint64_t v62 = v367;
            unsigned int v63 = "LC_ENCRYPTION_INFO_64";
LABEL_141:
            sub_1CCC52FA0(v405, v61, v62, v35, v59, v60, &v362, v63);
            uint64_t v102 = *(void *)v405;
            goto LABEL_155;
          }
          unint64_t v245 = "LC_ENCRYPTION_INFO_64 command ";
LABEL_640:
          *(void *)v405 = v245;
          *(void *)&long long v406 = v35;
          LOWORD(v407) = 2051;
          uint64_t v239 = " has incorrect cmdsize";
          goto LABEL_641;
        case 0x2D:
          if (HIDWORD(v367) <= 0xB)
          {
            *(void *)v405 = "load command ";
            *(void *)&long long v406 = v35;
            LOWORD(v407) = 2051;
            uint64_t v67 = " LC_LINKER_OPTION cmdsize too small";
            goto LABEL_137;
          }
          if ((unint64_t)v367 < *v351) {
            goto LABEL_265;
          }
          char v105 = (unsigned char *)(v367 + 12);
          if ((unint64_t)(v367 + 12) > *v351 + *(void *)(a1 + 24)) {
            goto LABEL_265;
          }
          uint64_t v345 = v30;
          LODWORD(v106) = *(_DWORD *)(v367 + 8);
          unsigned int v107 = *(_DWORD *)(a1 + 8);
          unsigned int v108 = bswap32(*(_DWORD *)(v367 + 4));
          unsigned int v109 = bswap32(v106);
          if (((1 << v107) & 0xAAC00) == 0)
          {
            unsigned int v109 = *(_DWORD *)(v367 + 8);
            unsigned int v108 = *(_DWORD *)(v367 + 4);
          }
          if (v107 <= 0x13) {
            uint64_t v106 = v109;
          }
          else {
            uint64_t v106 = v106;
          }
          uint64_t v331 = v106;
          if (v107 <= 0x13) {
            unsigned int v110 = v108;
          }
          else {
            unsigned int v110 = *(_DWORD *)(v367 + 4);
          }
          int v348 = v36;
          LODWORD(v36) = 0;
          unsigned int v111 = v110 - 12;
          if (v110 != 12)
          {
            while (1)
            {
              if (!*v105)
              {
                do
                {
                  unsigned int v112 = v111;
                  int v113 = *++v105;
                  --v111;
                  if (v113) {
                    BOOL v114 = 1;
                  }
                  else {
                    BOOL v114 = v112 == 1;
                  }
                }
                while (!v114);
                if (v112 == 1) {
                  goto LABEL_227;
                }
              }
              uint64_t v36 = (long long *)(v36 + 1);
              unint64_t v115 = memchr(v105, 0, v111);
              if (!v115) {
                break;
              }
              unsigned int v116 = v115 - v105;
              if (v115 - v105 == -1) {
                break;
              }
              if (v111 < v116) {
                unsigned int v116 = v111;
              }
              uint64_t v117 = v116 + 1;
              v105 += v117;
              v111 -= v117;
              if (!v111) {
                goto LABEL_227;
              }
            }
            *(void *)&long long v400 = "load command ";
            *(void *)&long long v401 = v35;
            LOWORD(v402) = 2051;
            *(void *)int v389 = &v400;
            *(void *)&long long v390 = " LC_LINKER_OPTION string #";
            LOWORD(v391) = 770;
            *(void *)v405 = v389;
            *(void *)&long long v406 = v36;
            LOWORD(v407) = 2050;
            size_t v203 = " is not NULL terminated";
LABEL_436:
            v394.i64[0] = (uint64_t)v405;
            *(void *)&long long v395 = v203;
            LOWORD(v396) = 770;
            sub_1CCC51CE4((uint64_t)v386, v394.i64);
          }
LABEL_227:
          if (v331 != v36)
          {
            *(void *)&long long v400 = "load command ";
            *(void *)&long long v401 = v35;
            LOWORD(v402) = 2051;
            *(void *)int v389 = &v400;
            *(void *)&long long v390 = " LC_LINKER_OPTION string count ";
            LOWORD(v391) = 770;
            *(void *)v405 = v389;
            *(void *)&long long v406 = v331;
            LOWORD(v407) = 2050;
            size_t v203 = " does not match number of strings";
            goto LABEL_436;
          }
          goto LABEL_228;
        case 0x2E:
          uint64_t v47 = "LC_LINKER_OPTIMIZATION_HINT";
          std::string::size_type v48 = "linker optimization hints";
          uint64_t v44 = a1;
          unsigned int v45 = v35;
          uint64_t v46 = (uint64_t *)(a1 + 296);
          goto LABEL_146;
        case 0x2F:
          uint64_t v64 = v367;
          int v65 = HIDWORD(v367);
          uint64_t v66 = "LC_VERSION_MIN_TVOS";
          goto LABEL_153;
        case 0x30:
          uint64_t v64 = v367;
          int v65 = HIDWORD(v367);
          uint64_t v66 = "LC_VERSION_MIN_WATCHOS";
LABEL_153:
          sub_1CCC52DF0(&v394, v64, v65, v35, &v363, v66);
          goto LABEL_154;
        case 0x31:
          if (HIDWORD(v367) != 40)
          {
            *(void *)v405 = "load command ";
            *(void *)&long long v406 = v344 & 0xFFFFFFFF00000000 | v35;
            LOWORD(v407) = 2051;
            int v103 = " LC_NOTE has incorrect cmdsize";
LABEL_428:
            v394.i64[0] = (uint64_t)v405;
            *(void *)&long long v395 = v103;
            goto LABEL_429;
          }
          unint64_t v88 = *(void *)(a1 + 16);
          if ((unint64_t)v367 >= v88)
          {
            unint64_t v89 = *(void *)(a1 + 24);
            if ((uint64_t)v367 + 40 <= v88 + v89)
            {
              unsigned int v90 = *(_DWORD *)(a1 + 8);
              unint64_t v91 = bswap64(*(void *)(v367 + 24));
              unint64_t v92 = bswap64(*(void *)(v367 + 32));
              if (((1 << v90) & 0xAAC00) == 0)
              {
                unint64_t v92 = *(void *)(v367 + 32);
                unint64_t v91 = *(void *)(v367 + 24);
              }
              if (v90 <= 0x13) {
                uint64_t v93 = v92;
              }
              else {
                uint64_t v93 = *(void *)(v367 + 32);
              }
              if (v90 <= 0x13) {
                unint64_t v94 = v91;
              }
              else {
                unint64_t v94 = *(void *)(v367 + 24);
              }
              if (v94 <= v89)
              {
                if (v94 + v93 <= v89)
                {
                  sub_1CCC681C8(v389, (uint64_t *)&v368, v94, v93, "LC_NOTE data");
LABEL_431:
                  uint64_t v102 = *(void *)v389;
                  goto LABEL_155;
                }
                unint64_t v95 = v316 & 0xFFFFFFFF00000000 | v35;
                *(void *)v405 = "size field plus offset field of LC_NOTE command ";
              }
              else
              {
                unint64_t v95 = v329 & 0xFFFFFFFF00000000 | v35;
                *(void *)v405 = "offset field of LC_NOTE command ";
              }
              *(void *)&long long v406 = v95;
              goto LABEL_427;
            }
          }
          goto LABEL_186;
        case 0x32:
          int v348 = v36;
          if ((unint64_t)v367 < *v351
            || (uint64_t v54 = v367 + 24, (unint64_t)(v367 + 24) > *v351 + *(void *)(a1 + 24)))
          {
            v394.i64[0] = (uint64_t)"Structure read out-of-range";
            LOWORD(v396) = 259;
            sub_1CCC51CE4((uint64_t)v405, v394.i64);
          }
          uint64_t v345 = v30;
          unsigned int v119 = *(_DWORD *)(v367 + 20);
          unsigned int v120 = *(_DWORD *)(a1 + 8);
          unsigned int v121 = bswap32(*(_DWORD *)(v367 + 8));
          unsigned int v122 = bswap32(v119);
          if (((1 << v120) & 0xAAC00) == 0)
          {
            unsigned int v122 = *(_DWORD *)(v367 + 20);
            unsigned int v121 = *(_DWORD *)(v367 + 8);
          }
          if (v120 <= 0x13) {
            unint64_t v123 = v122;
          }
          else {
            unint64_t v123 = v119;
          }
          if (v120 <= 0x13) {
            unsigned int v124 = v121;
          }
          else {
            unsigned int v124 = *(_DWORD *)(v367 + 8);
          }
          uint64_t v125 = 8 * v123;
          if (v125 + 24 != HIDWORD(v367))
          {
            *(void *)v405 = "load command ";
            *(void *)&long long v406 = v339 & 0xFFFFFFFF00000000 | v35;
            LOWORD(v407) = 2051;
            unsigned int v126 = " LC_BUILD_VERSION_COMMAND has incorrect cmdsize";
LABEL_245:
            v394.i64[0] = (uint64_t)v405;
            *(void *)&long long v395 = v126;
            __int16 v127 = 770;
            goto LABEL_246;
          }
          unsigned int v336 = v124;
          sub_1CD42769C((uint64_t)v13, v123);
          if (v123)
          {
            uint64_t v216 = 0;
            do
            {
              *(void *)(*v13 + v2++*(_DWORD *)(this + 16) = v54 + v216;
              v216 += 8;
            }
            while (v125 != v216);
          }
          if (v348)
          {
            if ((v357 & 0x8000000) == 0 && v349)
            {
              unsigned int v217 = "more than two LC_BUILD_VERSION load commands";
LABEL_509:
              v394.i64[0] = (uint64_t)v217;
              __int16 v127 = 259;
LABEL_246:
              LOWORD(v396) = v127;
              sub_1CCC51CE4((uint64_t)&v400, v394.i64);
            }
            uint64_t v349 = v367;
            memset(v389, 0, sizeof(v389));
            *(void *)&long long v390 = 0;
            sub_1CCC530A4((uint64_t)v389, a1, v348);
            if (*(_DWORD *)&v389[8] != 6 && *(_DWORD *)&v389[8] != 1
              || *(_DWORD *)&v389[8] == 1 && v336 != 6
              || *(_DWORD *)&v389[8] == 6 && v336 != 1)
            {
              if ((v357 & 0x8000000) == 0)
              {
                unsigned int v217 = "the two LC_BUILD_VERSION load commands are not for the platforms MACOS and MACCATALYST";
                goto LABEL_509;
              }
              if (v336 - 6 >= 4 && v336 != 1)
              {
                unint64_t v222 = v255 & 0xFFFFFFFF00000000 | v35;
                *(void *)v405 = "the LC_BUILD_VERSION, command ";
                goto LABEL_558;
              }
            }
          }
          else
          {
            int v348 = (long long *)v367;
            if ((v357 & 0x8000000) != 0 && v336 - 6 >= 4 && v336 != 1)
            {
              unint64_t v222 = v256 & 0xFFFFFFFF00000000 | v35;
              *(void *)v405 = "the LC_BUILD_VERSION, command ";
LABEL_558:
              *(void *)&long long v406 = v222;
              LOWORD(v407) = 2051;
              unsigned int v126 = ", platform value is not allowed when the mach header flag MH_SIM_SUPPORT is set";
              goto LABEL_245;
            }
          }
LABEL_228:
          *a5 = 0;
          uint64_t v30 = v345;
LABEL_229:
          uint64_t v29 = v356;
          uint64_t v36 = v348;
          goto LABEL_156;
        default:
          if (DWORD2(v367) != -2147483596) {
            goto LABEL_73;
          }
          uint64_t v44 = a1;
          unsigned int v45 = v35;
          uint64_t v46 = (uint64_t *)(a1 + 328);
          uint64_t v47 = "LC_DYLD_CHAINED_FIXUPS";
          std::string::size_type v48 = "chained fixups";
          goto LABEL_146;
      }
    }
  }
  return a1;
}

BOOL llvm::object::MachOObjectFile::is64Bit(llvm::object::MachOObjectFile *this)
{
  return (*((_DWORD *)this + 2) & 0xFFFFFFFE) == 18;
}

uint64_t llvm::object::MachOObjectFile::getHeader(llvm::object::MachOObjectFile *this)
{
  return (uint64_t)this + 48;
}

void sub_1CCC51CE4(uint64_t a1, uint64_t *a2)
{
  int v2 = *((unsigned __int8 *)a2 + 32);
  if (*((unsigned char *)a2 + 32))
  {
    if (v2 == 1)
    {
      int v3 = "truncated or malformed object (";
      v8[0] = "truncated or malformed object (";
      __int16 v9 = 259;
      char v4 = 3;
    }
    else
    {
      uint64_t v6 = (uint64_t *)*a2;
      uint64_t v7 = a2[1];
      char v4 = 2;
      if (*((unsigned char *)a2 + 33) != 1)
      {
        LOBYTE(v2) = 2;
        uint64_t v6 = a2;
      }
      v8[0] = "truncated or malformed object (";
      _OWORD v8[2] = v6;
      v8[3] = v7;
      LOBYTE(v9) = 3;
      HIBYTE(v9) = v2;
      int v3 = (const char *)v8;
    }
    long long v10 = v3;
    int v11 = ")";
    char v5 = 3;
  }
  else
  {
    char v4 = 0;
    __int16 v9 = 256;
    char v5 = 1;
  }
  char v12 = v4;
  char v13 = v5;
  operator new();
}

int8x16_t *sub_1CCC51DC8(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5, unsigned char *a6, uint64_t *a7, unsigned char *a8)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a3 + 12) <= 0xFu)
  {
    v31[0] = "load command ";
    unint64_t v32 = a4;
    __int16 v33 = 2051;
    *(void *)&long long v34 = v31;
    *(void *)&long long v35 = " ";
    LOWORD(v36) = 770;
    if (*a6)
    {
      int v11 = &v34;
      *(void *)&long long v37 = &v34;
      *(void *)&long long v38 = a6;
      LOWORD(v39) = 770;
      char v12 = 2;
      char v13 = &v37;
LABEL_4:
      v40[0] = (uint64_t)v13;
      v40[1] = (uint64_t)v11;
      uint64_t v41 = " cmdsize too small";
      LOBYTE(v42) = v12;
LABEL_19:
      HIBYTE(v42) = 3;
      goto LABEL_37;
    }
    long long v37 = v34;
    long long v38 = v35;
    uint64_t v39 = v36;
    char v12 = v36;
    if (v36 != 1)
    {
      int v11 = (long long *)*((void *)&v37 + 1);
      char v13 = &v37;
      if (BYTE1(v39) == 1) {
        char v13 = (long long *)v37;
      }
      else {
        char v12 = 2;
      }
      goto LABEL_4;
    }
    v40[0] = (uint64_t)" cmdsize too small";
    __int16 v27 = 259;
LABEL_36:
    __int16 v42 = v27;
LABEL_37:
    sub_1CCC51CE4((uint64_t)a1, v40);
  }
  if (*a5)
  {
    int v15 = *a6;
    uint64_t v16 = "more than one ";
    if (*a6)
    {
      *(void *)&long long v37 = "more than one ";
      *(void *)&long long v38 = a6;
      LOWORD(v39) = 771;
      char v17 = 2;
    }
    else
    {
      *(void *)&long long v37 = "more than one ";
      LOWORD(v39) = 259;
      char v17 = 3;
    }
    if (v15) {
      uint64_t v16 = (const char *)&v37;
    }
    v40[0] = (uint64_t)v16;
    uint64_t v41 = " command";
    LOBYTE(v42) = v17;
    goto LABEL_19;
  }
  uint64_t result = sub_1CCC6517C(&v43, a2, *(int8x16_t **)a3);
  if (v44)
  {
    *a1 = v43.i64[0];
  }
  else
  {
    if (v43.i32[1] != 16)
    {
      if (*a6)
      {
        *(void *)&long long v34 = a6;
        *(void *)&long long v35 = " command ";
        LOWORD(v36) = 771;
        long long v28 = (const char *)&v34;
        char v29 = 2;
      }
      else
      {
        long long v28 = " command ";
        *(void *)&long long v34 = " command ";
        LOWORD(v36) = 259;
        char v29 = 3;
      }
      *(void *)&long long v37 = v28;
      *(void *)&long long v38 = a4;
      LOBYTE(v39) = v29;
      BYTE1(v39) = 8;
      uint64_t v30 = " has incorrect cmdsize";
LABEL_35:
      v40[0] = (uint64_t)&v37;
      uint64_t v41 = v30;
      __int16 v27 = 770;
      goto LABEL_36;
    }
    unint64_t v23 = *(void *)(a2 + 24);
    if (v23 < v43.u32[2])
    {
      int v24 = *a6;
      uint64_t v25 = "dataoff field of ";
      if (*a6)
      {
LABEL_14:
        v31[0] = v25;
        unint64_t v32 = (unint64_t)a6;
        __int16 v33 = 771;
        char v26 = 2;
LABEL_30:
        if (v24) {
          uint64_t v25 = (const char *)v31;
        }
        *(void *)&long long v34 = v25;
        *(void *)&long long v35 = " command ";
        LOBYTE(v36) = v26;
        BYTE1(v36) = 3;
        *(void *)&long long v37 = &v34;
        *(void *)&long long v38 = a4;
        LOWORD(v39) = 2050;
        uint64_t v30 = " extends past the end of the file";
        goto LABEL_35;
      }
LABEL_29:
      v31[0] = v25;
      __int16 v33 = 259;
      char v26 = 3;
      goto LABEL_30;
    }
    if (v43.u32[2] + (unint64_t)v43.u32[3] > v23)
    {
      int v24 = *a6;
      uint64_t v25 = "dataoff field plus datasize field of ";
      if (*a6) {
        goto LABEL_14;
      }
      goto LABEL_29;
    }
    uint64_t result = (int8x16_t *)sub_1CCC681C8(a1, a7, v43.u32[2], v43.u32[3], a8);
    if (!*a1)
    {
      *a5 = *(void *)a3;
      *a1 = 0;
    }
  }
  return result;
}

int8x16_t *sub_1CCC52134(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, void *a5, unsigned char *a6, uint64_t *a7)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a3 + 12) <= 0x2Fu)
  {
    v37[0] = "load command ";
    unint64_t v38 = a4;
    __int16 v39 = 2051;
    *(void *)&long long v40 = v37;
    *(void *)&long long v41 = " ";
    LOWORD(v42) = 770;
    if (*a6)
    {
      long long v10 = &v40;
      *(void *)&long long v43 = &v40;
      *(void *)&long long v44 = a6;
      LOWORD(v45) = 770;
      char v11 = 2;
      char v12 = &v43;
LABEL_4:
      v46.i64[0] = (uint64_t)v12;
      v46.i64[1] = (uint64_t)v10;
      uint64_t v47 = " cmdsize too small";
      LOBYTE(v50) = v11;
      BYTE1(v50) = 3;
LABEL_8:
      int v15 = &v46;
      goto LABEL_9;
    }
    long long v43 = v40;
    long long v44 = v41;
    uint64_t v45 = v42;
    char v11 = v42;
    if (v42 != 1)
    {
      long long v10 = (long long *)*((void *)&v43 + 1);
      char v12 = &v43;
      if (BYTE1(v45) == 1) {
        char v12 = (long long *)v43;
      }
      else {
        char v11 = 2;
      }
      goto LABEL_4;
    }
    uint64_t v14 = " cmdsize too small";
LABEL_7:
    v46.i64[0] = (uint64_t)v14;
    LOWORD(v50) = 259;
    goto LABEL_8;
  }
  if (*a5)
  {
    uint64_t v14 = "more than one LC_DYLD_INFO and or LC_DYLD_INFO_ONLY command";
    goto LABEL_7;
  }
  uint64_t result = sub_1CCC64EA4(&v46, a2, *(int8x16_t **)a3);
  if (v54)
  {
    *a1 = v46.i64[0];
  }
  else
  {
    if (v46.i32[1] != 48)
    {
      if (*a6)
      {
        v37[0] = a6;
        unint64_t v38 = (unint64_t)" command ";
        __int16 v39 = 771;
        int v24 = (const char *)v37;
        char v25 = 2;
      }
      else
      {
        int v24 = " command ";
        v37[0] = " command ";
        __int16 v39 = 259;
        char v25 = 3;
      }
      *(void *)&long long v40 = v24;
      *(void *)&long long v41 = a4;
      LOBYTE(v42) = v25;
      BYTE1(v42) = 8;
      char v26 = " has incorrect cmdsize";
LABEL_33:
      *(void *)&long long v43 = &v40;
      *(void *)&long long v44 = v26;
      LOWORD(v45) = 770;
      int v15 = (int8x16_t *)&v43;
LABEL_9:
      sub_1CCC51CE4((uint64_t)a1, v15->i64);
    }
    unint64_t v20 = *(void *)(a2 + 24);
    if (v20 < v46.u32[2])
    {
      int v21 = *a6;
      unsigned int v22 = "rebase_off field of ";
      if (*a6)
      {
LABEL_17:
        v35[0] = v22;
        v35[2] = a6;
        __int16 v36 = 771;
        char v23 = 2;
LABEL_28:
        if (v21) {
          unsigned int v22 = (const char *)v35;
        }
        v37[0] = v22;
        unint64_t v38 = (unint64_t)" command ";
        LOBYTE(v39) = v23;
        HIBYTE(v39) = 3;
        *(void *)&long long v40 = v37;
        *(void *)&long long v41 = a4;
        LOWORD(v42) = 2050;
        char v26 = " extends past the end of the file";
        goto LABEL_33;
      }
LABEL_27:
      v35[0] = v22;
      __int16 v36 = 259;
      char v23 = 3;
      goto LABEL_28;
    }
    if (v46.u32[2] + (unint64_t)v46.u32[3] > v20)
    {
      int v21 = *a6;
      unsigned int v22 = "rebase_off field plus rebase_size field of ";
      if (*a6) {
        goto LABEL_17;
      }
      goto LABEL_27;
    }
    unint64_t v28 = v47;
    uint64_t v27 = HIDWORD(v47);
    unint64_t v29 = v48;
    unint64_t v33 = v50;
    uint64_t v34 = v49;
    uint64_t v32 = v51;
    unint64_t v31 = v52;
    uint64_t v30 = v53;
    uint64_t result = (int8x16_t *)sub_1CCC681C8(a1, a7, v46.u32[2], v46.u32[3], "dyld rebase info");
    if (!*a1)
    {
      if (v20 < v28)
      {
        int v21 = *a6;
        unsigned int v22 = "bind_off field of ";
        if (*a6) {
          goto LABEL_17;
        }
        goto LABEL_27;
      }
      if (v27 + v28 > v20)
      {
        int v21 = *a6;
        unsigned int v22 = "bind_off field plus bind_size field of ";
        if (*a6) {
          goto LABEL_17;
        }
        goto LABEL_27;
      }
      uint64_t result = (int8x16_t *)sub_1CCC681C8(a1, a7, v28, v27, "dyld bind info");
      if (!*a1)
      {
        if (v20 < v29)
        {
          int v21 = *a6;
          unsigned int v22 = "weak_bind_off field of ";
          if (*a6) {
            goto LABEL_17;
          }
          goto LABEL_27;
        }
        if (v34 + v29 > v20)
        {
          int v21 = *a6;
          unsigned int v22 = "weak_bind_off field plus weak_bind_size field of ";
          if (*a6) {
            goto LABEL_17;
          }
          goto LABEL_27;
        }
        uint64_t result = (int8x16_t *)sub_1CCC681C8(a1, a7, v29, v34, "dyld weak bind info");
        if (!*a1)
        {
          if (v20 < v33)
          {
            int v21 = *a6;
            unsigned int v22 = "lazy_bind_off field of ";
            if (*a6) {
              goto LABEL_17;
            }
            goto LABEL_27;
          }
          if (v32 + v33 > v20)
          {
            int v21 = *a6;
            unsigned int v22 = "lazy_bind_off field plus lazy_bind_size field of ";
            if (*a6) {
              goto LABEL_17;
            }
            goto LABEL_27;
          }
          uint64_t result = (int8x16_t *)sub_1CCC681C8(a1, a7, v33, v32, "dyld lazy bind info");
          if (!*a1)
          {
            if (v20 < v31)
            {
              int v21 = *a6;
              unsigned int v22 = "export_off field of ";
              if (*a6) {
                goto LABEL_17;
              }
              goto LABEL_27;
            }
            if (v30 + v31 > v20)
            {
              int v21 = *a6;
              unsigned int v22 = "export_off field plus export_size field of ";
              if (*a6) {
                goto LABEL_17;
              }
              goto LABEL_27;
            }
            uint64_t result = (int8x16_t *)sub_1CCC681C8(a1, a7, v31, v30, "dyld export info");
            if (!*a1)
            {
              *a5 = *(void *)a3;
              *a1 = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CCC5260C(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned char *a5)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a3 + 12) <= 0x17u)
  {
    v24[0] = "load command ";
    uint64_t v25 = a4;
    __int16 v26 = 2051;
    *(void *)&long long v27 = v24;
    *(void *)&long long v28 = " ";
    LOWORD(v29) = 770;
    if (*a5)
    {
      uint64_t v8 = &v27;
      *(void *)&long long v30 = &v27;
      *(void *)&long long v31 = a5;
      LOWORD(v32) = 770;
      char v9 = 2;
      long long v10 = (const char *)&v30;
    }
    else
    {
      long long v30 = v27;
      long long v31 = v28;
      uint64_t v32 = v29;
      char v9 = v29;
      if (v29 == 1)
      {
        int v21 = " cmdsize too small";
        goto LABEL_44;
      }
      uint64_t v8 = (long long *)*((void *)&v30 + 1);
      long long v10 = (const char *)&v30;
      if (BYTE1(v32) == 1) {
        long long v10 = (const char *)v30;
      }
      else {
        char v9 = 2;
      }
    }
    unint64_t v33 = v10;
    uint64_t v34 = v8;
    char v11 = " cmdsize too small";
    goto LABEL_5;
  }
  uint64_t result = sub_1CCC560B8((uint64_t)&v37, a2, *(void *)a3);
  if (v39)
  {
    *a1 = v37;
  }
  else
  {
    if (v38 <= 0x17)
    {
      v24[0] = "load command ";
      uint64_t v25 = a4;
      __int16 v26 = 2051;
      *(void *)&long long v27 = v24;
      *(void *)&long long v28 = " ";
      LOWORD(v29) = 770;
      if (*a5)
      {
        uint64_t v14 = &v27;
        *(void *)&long long v30 = &v27;
        *(void *)&long long v31 = a5;
        LOWORD(v32) = 770;
        char v9 = 2;
        int v15 = (const char *)&v30;
      }
      else
      {
        long long v30 = v27;
        long long v31 = v28;
        uint64_t v32 = v29;
        char v9 = v29;
        if (v29 == 1)
        {
          int v21 = " name.offset field too small, not past the end of the dylib_command struct";
          goto LABEL_44;
        }
        uint64_t v14 = (long long *)*((void *)&v30 + 1);
        int v15 = (const char *)&v30;
        if (BYTE1(v32) == 1) {
          int v15 = (const char *)v30;
        }
        else {
          char v9 = 2;
        }
      }
      unint64_t v33 = v15;
      uint64_t v34 = v14;
      char v11 = " name.offset field too small, not past the end of the dylib_command struct";
      goto LABEL_5;
    }
    if (HIDWORD(v37) <= v38)
    {
      v24[0] = "load command ";
      uint64_t v25 = a4;
      __int16 v26 = 2051;
      *(void *)&long long v27 = v24;
      *(void *)&long long v28 = " ";
      LOWORD(v29) = 770;
      if (*a5)
      {
        unsigned int v22 = &v27;
        *(void *)&long long v30 = &v27;
        *(void *)&long long v31 = a5;
        LOWORD(v32) = 770;
        char v9 = 2;
        char v23 = (const char *)&v30;
      }
      else
      {
        long long v30 = v27;
        long long v31 = v28;
        uint64_t v32 = v29;
        char v9 = v29;
        if (v29 == 1)
        {
          int v21 = " name.offset field extends past the end of the load command";
          goto LABEL_44;
        }
        unsigned int v22 = (long long *)*((void *)&v30 + 1);
        char v23 = (const char *)&v30;
        if (BYTE1(v32) == 1) {
          char v23 = (const char *)v30;
        }
        else {
          char v9 = 2;
        }
      }
      unint64_t v33 = v23;
      uint64_t v34 = v22;
      char v11 = " name.offset field extends past the end of the load command";
      goto LABEL_5;
    }
    uint64_t v16 = (unsigned __int8 *)(*(void *)a3 + v38);
    unsigned int v17 = HIDWORD(v37) - v38;
    while (*v16++)
    {
      if (!--v17)
      {
        v24[0] = "load command ";
        uint64_t v25 = a4;
        __int16 v26 = 2051;
        *(void *)&long long v27 = v24;
        *(void *)&long long v28 = " ";
        LOWORD(v29) = 770;
        if (*a5)
        {
          int8x8_t v19 = &v27;
          *(void *)&long long v30 = &v27;
          *(void *)&long long v31 = a5;
          LOWORD(v32) = 770;
          char v9 = 2;
          unint64_t v20 = (const char *)&v30;
          goto LABEL_20;
        }
        long long v30 = v27;
        long long v31 = v28;
        uint64_t v32 = v29;
        char v9 = v29;
        if (v29 != 1)
        {
          int8x8_t v19 = (long long *)*((void *)&v30 + 1);
          unint64_t v20 = (const char *)&v30;
          if (BYTE1(v32) == 1) {
            unint64_t v20 = (const char *)v30;
          }
          else {
            char v9 = 2;
          }
LABEL_20:
          unint64_t v33 = v20;
          uint64_t v34 = v19;
          char v11 = " library name extends past the end of the load command";
LABEL_5:
          long long v35 = v11;
          LOBYTE(v36) = v9;
          HIBYTE(v36) = 3;
LABEL_45:
          sub_1CCC51CE4((uint64_t)a1, (uint64_t *)&v33);
        }
        int v21 = " library name extends past the end of the load command";
LABEL_44:
        unint64_t v33 = v21;
        __int16 v36 = 259;
        goto LABEL_45;
      }
    }
    *a1 = 0;
  }
  return result;
}

void *sub_1CCC52A00(void *result, uint64_t a2, unint64_t a3, unsigned int a4, unsigned int a5, unsigned char *a6)
{
  if (a4 <= 0xB)
  {
    v30[0] = "load command ";
    uint64_t v31 = a5;
    __int16 v32 = 2051;
    *(void *)&long long v33 = v30;
    *(void *)&long long v34 = " ";
    LOWORD(v35) = 770;
    if (*a6)
    {
      uint64_t v6 = &v33;
      *(void *)&long long v36 = &v33;
      *(void *)&long long v37 = a6;
      LOWORD(v3++*(_DWORD *)(this + 8) = 770;
      char v7 = 2;
      uint64_t v8 = (const char *)&v36;
    }
    else
    {
      long long v36 = v33;
      long long v37 = v34;
      uint64_t v38 = v35;
      char v7 = v35;
      if (v35 == 1)
      {
        long long v27 = " cmdsize too small";
        goto LABEL_32;
      }
      uint64_t v6 = (long long *)*((void *)&v36 + 1);
      uint64_t v8 = (const char *)&v36;
      if (BYTE1(v38) == 1) {
        uint64_t v8 = (const char *)v36;
      }
      else {
        char v7 = 2;
      }
    }
    char v39 = v8;
    uint64_t v40 = v6;
    char v9 = " cmdsize too small";
    goto LABEL_5;
  }
  unint64_t v10 = *(void *)(a2 + 16);
  BOOL v11 = v10 > a3 || a3 + 12 > v10 + *(void *)(a2 + 24);
  if (v11)
  {
    char v39 = "Structure read out-of-range";
    __int16 v42 = 259;
    sub_1CCC51CE4((uint64_t)&v36, (uint64_t *)&v39);
  }
  unsigned int v12 = *(_DWORD *)(a3 + 4);
  unsigned int v13 = *(_DWORD *)(a3 + 8);
  unsigned int v14 = *(_DWORD *)(a2 + 8);
  BOOL v11 = v14 > 0x13;
  int v15 = (1 << v14) & 0xAAC00;
  BOOL v16 = v11 || v15 == 0;
  unsigned int v17 = bswap32(v12);
  unsigned int v18 = bswap32(v13);
  if (!v16)
  {
    unsigned int v13 = v18;
    unsigned int v12 = v17;
  }
  if (v13 <= 0xB)
  {
    v30[0] = "load command ";
    uint64_t v31 = a5;
    __int16 v32 = 2051;
    *(void *)&long long v33 = v30;
    *(void *)&long long v34 = " ";
    LOWORD(v35) = 770;
    if (*a6)
    {
      int8x8_t v19 = &v33;
      *(void *)&long long v36 = &v33;
      *(void *)&long long v37 = a6;
      LOWORD(v3++*(_DWORD *)(this + 8) = 770;
      char v7 = 2;
      unint64_t v20 = (const char *)&v36;
    }
    else
    {
      long long v36 = v33;
      long long v37 = v34;
      uint64_t v38 = v35;
      char v7 = v35;
      if (v35 == 1)
      {
        long long v27 = " name.offset field too small, not past the end of the dylinker_command struct";
        goto LABEL_32;
      }
      int8x8_t v19 = (long long *)*((void *)&v36 + 1);
      unint64_t v20 = (const char *)&v36;
      if (BYTE1(v38) == 1) {
        unint64_t v20 = (const char *)v36;
      }
      else {
        char v7 = 2;
      }
    }
    char v39 = v20;
    uint64_t v40 = v19;
    char v9 = " name.offset field too small, not past the end of the dylinker_command struct";
    goto LABEL_5;
  }
  BOOL v21 = v12 >= v13;
  unsigned int v22 = v12 - v13;
  if (v22 == 0 || !v21)
  {
    v30[0] = "load command ";
    uint64_t v31 = a5;
    __int16 v32 = 2051;
    *(void *)&long long v33 = v30;
    *(void *)&long long v34 = " ";
    LOWORD(v35) = 770;
    if (*a6)
    {
      long long v28 = &v33;
      *(void *)&long long v36 = &v33;
      *(void *)&long long v37 = a6;
      LOWORD(v3++*(_DWORD *)(this + 8) = 770;
      char v7 = 2;
      uint64_t v29 = (const char *)&v36;
    }
    else
    {
      long long v36 = v33;
      long long v37 = v34;
      uint64_t v38 = v35;
      char v7 = v35;
      if (v35 == 1)
      {
        long long v27 = " name.offset field extends past the end of the load command";
        goto LABEL_32;
      }
      long long v28 = (long long *)*((void *)&v36 + 1);
      uint64_t v29 = (const char *)&v36;
      if (BYTE1(v38) == 1) {
        uint64_t v29 = (const char *)v36;
      }
      else {
        char v7 = 2;
      }
    }
    char v39 = v29;
    uint64_t v40 = v28;
    char v9 = " name.offset field extends past the end of the load command";
    goto LABEL_5;
  }
  char v23 = (unsigned __int8 *)(a3 + v13);
  while (*v23++)
  {
    if (!--v22)
    {
      v30[0] = "load command ";
      uint64_t v31 = a5;
      __int16 v32 = 2051;
      *(void *)&long long v33 = v30;
      *(void *)&long long v34 = " ";
      LOWORD(v35) = 770;
      if (*a6)
      {
        uint64_t v25 = &v33;
        *(void *)&long long v36 = &v33;
        *(void *)&long long v37 = a6;
        LOWORD(v3++*(_DWORD *)(this + 8) = 770;
        char v7 = 2;
        __int16 v26 = (const char *)&v36;
        goto LABEL_30;
      }
      long long v36 = v33;
      long long v37 = v34;
      uint64_t v38 = v35;
      char v7 = v35;
      if (v35 != 1)
      {
        uint64_t v25 = (long long *)*((void *)&v36 + 1);
        __int16 v26 = (const char *)&v36;
        if (BYTE1(v38) == 1) {
          __int16 v26 = (const char *)v36;
        }
        else {
          char v7 = 2;
        }
LABEL_30:
        char v39 = v26;
        uint64_t v40 = v25;
        char v9 = " dyld name extends past the end of the load command";
LABEL_5:
        long long v41 = v9;
        LOBYTE(v42) = v7;
        HIBYTE(v42) = 3;
LABEL_33:
        sub_1CCC51CE4((uint64_t)result, (uint64_t *)&v39);
      }
      long long v27 = " dyld name extends past the end of the load command";
LABEL_32:
      char v39 = v27;
      __int16 v42 = 259;
      goto LABEL_33;
    }
  }
  *uint64_t result = 0;
  return result;
}

void *sub_1CCC52DF0(void *result, uint64_t a2, int a3, unsigned int a4, void *a5, unsigned char *a6)
{
  if (a3 != 16)
  {
    v10[0] = "load command ";
    v10[2] = a4;
    __int16 v11 = 2051;
    *(void *)&long long v12 = v10;
    *(void *)&long long v13 = " ";
    LOWORD(v14) = 770;
    if (*a6)
    {
      char v7 = &v12;
      *(void *)&long long v15 = &v12;
      *(void *)&long long v16 = a6;
      LOWORD(v17) = 770;
      char v8 = 2;
      char v9 = &v15;
    }
    else
    {
      long long v15 = v12;
      long long v16 = v13;
      uint64_t v17 = v14;
      char v8 = v14;
      if (v14 == 1)
      {
        uint64_t v6 = " has incorrect cmdsize";
        goto LABEL_4;
      }
      char v7 = (long long *)*((void *)&v15 + 1);
      char v9 = &v15;
      if (BYTE1(v17) == 1) {
        char v9 = (long long *)v15;
      }
      else {
        char v8 = 2;
      }
    }
    v18[0] = (uint64_t)v9;
    v18[1] = (uint64_t)v7;
    v18[2] = (uint64_t)" has incorrect cmdsize";
    LOBYTE(v19) = v8;
    HIBYTE(v19) = 3;
LABEL_8:
    sub_1CCC51CE4((uint64_t)result, v18);
  }
  if (*a5)
  {
    uint64_t v6 = "more than one LC_VERSION_MIN_MACOSX, LC_VERSION_MIN_IPHONEOS, LC_VERSION_MIN_TVOS or LC_VERSION_MIN_WATCHOS command";
LABEL_4:
    v18[0] = (uint64_t)v6;
    __int16 v19 = 259;
    goto LABEL_8;
  }
  *a5 = a2;
  *uint64_t result = 0;
  return result;
}

int8x16_t sub_1CCC52F18(int8x16_t *a1, uint64_t a2, int8x16_t *a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > (unint64_t)a3 || (unint64_t)a3[1].u64 + 4 > v3 + *(void *)(a2 + 24);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  int8x16_t result = *a3;
  *a1 = *a3;
  a1[1].i32[0] = a3[1].i32[0];
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  if (!v4 && v7 != 0)
  {
    int8x16_t result = vrev32q_s8(*a1);
    *a1 = result;
    a1[1].i32[0] = bswap32(a1[1].u32[0]);
  }
  return result;
}

void *sub_1CCC52FA0(void *result, unint64_t a2, uint64_t a3, unsigned int a4, unint64_t a5, uint64_t a6, void *a7, unsigned char *a8)
{
  if (*a7)
  {
    v19[0] = (uint64_t)"more than one LC_ENCRYPTION_INFO and or LC_ENCRYPTION_INFO_64 command";
    __int16 v8 = 259;
    goto LABEL_12;
  }
  if (a2 < a5)
  {
    int v9 = *a8;
    unint64_t v10 = "cryptoff field of ";
    if (*a8)
    {
LABEL_5:
      v12[0] = v10;
      uint64_t v12[2] = a8;
      __int16 v13 = 771;
      char v11 = 2;
LABEL_9:
      if (v9) {
        unint64_t v10 = (const char *)v12;
      }
      v14[0] = v10;
      _OWORD v14[2] = " command ";
      char v15 = v11;
      char v16 = 3;
      v17[0] = v14;
      void v17[2] = a4;
      __int16 v18 = 2050;
      v19[0] = (uint64_t)v17;
      void v19[2] = (uint64_t)" extends past the end of the file";
      __int16 v8 = 770;
LABEL_12:
      __int16 v20 = v8;
      sub_1CCC51CE4((uint64_t)result, v19);
    }
LABEL_8:
    v12[0] = v10;
    __int16 v13 = 259;
    char v11 = 3;
    goto LABEL_9;
  }
  if (a6 + a5 > a2)
  {
    int v9 = *a8;
    unint64_t v10 = "cryptoff field plus cryptsize field of ";
    if (*a8) {
      goto LABEL_5;
    }
    goto LABEL_8;
  }
  *a7 = a3;
  *int8x16_t result = 0;
  return result;
}

double sub_1CCC530A4(uint64_t a1, uint64_t a2, long long *a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > (unint64_t)a3 || (unint64_t)a3 + 24 > v3 + *(void *)(a2 + 24);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v5 = *a3;
  *(_OWORD *)a1 = *a3;
  *(void *)(a1 + ++*(_DWORD *)(this + 16) = *((void *)a3 + 2);
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  if (!v4 && v7 != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(int8x8_t *)&long long v5 = vrev32_s8(*(int8x8_t *)(a1 + 16));
    *(void *)(a1 + ++*(_DWORD *)(this + 16) = v5;
  }
  return *(double *)&v5;
}

uint64_t sub_1CCC5312C(uint64_t a1, _DWORD *a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = v2 > (unint64_t)a2 || (unint64_t)(a2 + 3) > v2 + *(void *)(a1 + 24);
  if (v3) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  LODWORD(v4) = *a2;
  LODWORD(v5) = a2[1];
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  BOOL v3 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  BOOL v8 = v3 || v7 == 0;
  unsigned int v9 = bswap32(v4);
  unsigned int v10 = bswap32(v5);
  if (v8) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = v9;
  }
  if (v8) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = v10;
  }
  return v4 | (v5 << 32);
}

void *sub_1CCC531AC(void *result, uint64_t a2, unsigned int a3, unsigned int a4, unsigned char *a5, unsigned char *a6, unsigned int a7, unsigned char *a8)
{
  if (a7 <= 0xB)
  {
    v31[0] = "load command ";
    void v31[2] = a4;
    __int16 v32 = 2051;
    BOOL v8 = " ";
    *(void *)&long long v33 = v31;
    *(void *)&long long v34 = " ";
    LOWORD(v35) = 770;
    if (*a5)
    {
      unsigned int v9 = &v33;
      *(void *)&long long v36 = &v33;
      *(void *)&long long v37 = a5;
      LOWORD(v3++*(_DWORD *)(this + 8) = 770;
      char v10 = 2;
      char v11 = &v36;
    }
    else
    {
      long long v36 = v33;
      long long v37 = v34;
      uint64_t v38 = v35;
      char v10 = v35;
      if (v35 == 1)
      {
        *(void *)&long long v39 = " ";
        LOWORD(v41) = 259;
        if (*a8)
        {
          char v12 = 3;
          goto LABEL_6;
        }
LABEL_30:
        long long v42 = v39;
        long long v43 = v40;
        uint64_t v44 = v41;
        char v12 = v41;
        goto LABEL_31;
      }
      unsigned int v9 = (long long *)*((void *)&v36 + 1);
      char v11 = &v36;
      if (BYTE1(v38) == 1) {
        char v11 = (long long *)v36;
      }
      else {
        char v10 = 2;
      }
    }
    *(void *)&long long v39 = v11;
    *((void *)&v39 + 1) = v9;
    *(void *)&long long v40 = " ";
    LOBYTE(v41) = v10;
    BYTE1(v41) = 3;
    if (*a8)
    {
      char v12 = 2;
      BOOL v8 = (const char *)&v39;
LABEL_6:
      *(void *)&long long v42 = v8;
      *(void *)&long long v43 = a8;
      LOBYTE(v44) = v12;
      BYTE1(v44) = 3;
LABEL_31:
      __int16 v26 = (long long *)v42;
      char v27 = 2;
      if (BYTE1(v44) != 1)
      {
        char v12 = 2;
        __int16 v26 = &v42;
      }
      *(void *)&long long v45 = v26;
      *((void *)&v45 + 1) = *((void *)&v42 + 1);
      *(void *)&long long v46 = ".offset field too small, not past the end of the ";
      LOBYTE(v47) = v12;
      BYTE1(v47) = 3;
      if (*a6)
      {
        *(void *)&long long v48 = &v45;
        *(void *)&long long v49 = a6;
        goto LABEL_60;
      }
      long long v48 = v45;
      long long v49 = v46;
      uint64_t v50 = v47;
LABEL_61:
      sub_1CCC51CE4((uint64_t)result, (uint64_t *)&v48);
    }
    goto LABEL_30;
  }
  int v13 = a3 - a7;
  if (a3 <= a7)
  {
    *(void *)&long long v33 = "load command ";
    *(void *)&long long v34 = a4;
    LOWORD(v35) = 2051;
    BOOL v21 = " ";
    *(void *)&long long v36 = &v33;
    *(void *)&long long v37 = " ";
    LOWORD(v3++*(_DWORD *)(this + 8) = 770;
    if (*a5)
    {
      unsigned int v22 = &v36;
      *(void *)&long long v39 = &v36;
      *(void *)&long long v40 = a5;
      LOWORD(v41) = 770;
      char v23 = 2;
      int v24 = &v39;
    }
    else
    {
      long long v39 = v36;
      long long v40 = v37;
      uint64_t v41 = v38;
      char v23 = v38;
      if (v38 == 1)
      {
        *(void *)&long long v42 = " ";
        LOWORD(v44) = 259;
        if (*a8)
        {
          char v25 = 3;
          goto LABEL_20;
        }
LABEL_43:
        long long v45 = v42;
        long long v46 = v43;
        uint64_t v47 = v44;
        char v25 = v44;
        goto LABEL_44;
      }
      unsigned int v22 = (long long *)*((void *)&v39 + 1);
      int v24 = &v39;
      if (BYTE1(v41) == 1) {
        int v24 = (long long *)v39;
      }
      else {
        char v23 = 2;
      }
    }
    *(void *)&long long v42 = v24;
    *((void *)&v42 + 1) = v22;
    *(void *)&long long v43 = " ";
    LOBYTE(v44) = v23;
    BYTE1(v44) = 3;
    if (*a8)
    {
      char v25 = 2;
      BOOL v21 = (const char *)&v42;
LABEL_20:
      *(void *)&long long v45 = v21;
      *(void *)&long long v46 = a8;
      LOBYTE(v47) = v25;
      BYTE1(v47) = 3;
LABEL_44:
      if (BYTE1(v47) == 1) {
        char v27 = v25;
      }
      else {
        char v27 = 2;
      }
      long long v28 = &v45;
      if (BYTE1(v47) == 1) {
        long long v28 = (long long *)v45;
      }
      *(void *)&long long v48 = v28;
      *((void *)&v48 + 1) = *((void *)&v45 + 1);
      uint64_t v29 = ".offset field extends past the end of the load command";
      goto LABEL_59;
    }
    goto LABEL_43;
  }
  uint64_t v14 = (unsigned __int8 *)(a2 + a7);
  while (*v14++)
  {
    if (!--v13)
    {
      *(void *)&long long v33 = "load command ";
      *(void *)&long long v34 = a4;
      LOWORD(v35) = 2051;
      char v16 = " ";
      *(void *)&long long v36 = &v33;
      *(void *)&long long v37 = " ";
      LOWORD(v3++*(_DWORD *)(this + 8) = 770;
      if (*a5)
      {
        uint64_t v17 = &v36;
        *(void *)&long long v39 = &v36;
        *(void *)&long long v40 = a5;
        LOWORD(v41) = 770;
        char v18 = 2;
        __int16 v19 = &v39;
        goto LABEL_13;
      }
      long long v39 = v36;
      long long v40 = v37;
      uint64_t v41 = v38;
      char v18 = v38;
      if (v38 == 1)
      {
        *(void *)&long long v42 = " ";
        LOWORD(v44) = 259;
        if (!*a8) {
          goto LABEL_52;
        }
        char v20 = 3;
LABEL_15:
        *(void *)&long long v45 = v16;
        *(void *)&long long v46 = a8;
        LOBYTE(v47) = v20;
        BYTE1(v47) = 3;
      }
      else
      {
        uint64_t v17 = (long long *)*((void *)&v39 + 1);
        __int16 v19 = &v39;
        if (BYTE1(v41) == 1) {
          __int16 v19 = (long long *)v39;
        }
        else {
          char v18 = 2;
        }
LABEL_13:
        *(void *)&long long v42 = v19;
        *((void *)&v42 + 1) = v17;
        *(void *)&long long v43 = " ";
        LOBYTE(v44) = v18;
        BYTE1(v44) = 3;
        if (*a8)
        {
          char v20 = 2;
          char v16 = (const char *)&v42;
          goto LABEL_15;
        }
LABEL_52:
        long long v45 = v42;
        long long v46 = v43;
        uint64_t v47 = v44;
        char v20 = v44;
      }
      if (BYTE1(v47) == 1) {
        char v27 = v20;
      }
      else {
        char v27 = 2;
      }
      long long v30 = &v45;
      if (BYTE1(v47) == 1) {
        long long v30 = (long long *)v45;
      }
      *(void *)&long long v48 = v30;
      *((void *)&v48 + 1) = *((void *)&v45 + 1);
      uint64_t v29 = " name extends past the end of the load command";
LABEL_59:
      *(void *)&long long v49 = v29;
LABEL_60:
      LOBYTE(v50) = v27;
      BYTE1(v50) = 3;
      goto LABEL_61;
    }
  }
  *int8x16_t result = 0;
  return result;
}

uint64_t sub_1CCC53688(uint64_t result, uint64_t a2, unint64_t a3, unsigned int a4, unsigned int a5, unsigned char *a6)
{
  unsigned int v6 = (void *)result;
  if (a4 <= 7)
  {
    *(void *)&long long v53 = "load command ";
    *(void *)&long long v54 = a5;
    LOWORD(v55) = 2051;
    uint64_t v7 = *a6;
    if (*a6)
    {
      *(void *)&long long v56 = &v53;
      *(void *)&long long v57 = a6;
      LOWORD(v5++*(_DWORD *)(this + 8) = 770;
      char v8 = 2;
      unsigned int v9 = (const char *)&v56;
    }
    else
    {
      long long v56 = v53;
      long long v57 = v54;
      uint64_t v58 = v55;
      char v8 = v55;
      if (v55 == 1)
      {
        int v24 = " cmdsize too small";
        goto LABEL_77;
      }
      uint64_t v7 = *((void *)&v56 + 1);
      unsigned int v9 = (const char *)&v56;
      if (BYTE1(v58) == 1) {
        unsigned int v9 = (const char *)v56;
      }
      else {
        char v8 = 2;
      }
    }
    unint64_t v59 = v9;
    uint64_t v60 = v7;
    char v10 = " cmdsize too small";
    goto LABEL_5;
  }
  unint64_t v11 = *(void *)(a2 + 16);
  if (v11 > a3 || (char v12 = (unsigned int *)(a3 + 8), a3 + 8 > v11 + *(void *)(a2 + 24)))
  {
    unint64_t v59 = "Structure read out-of-range";
    __int16 v62 = 259;
    sub_1CCC51CE4((uint64_t)&v56, (uint64_t *)&v59);
  }
  unsigned int v13 = *(_DWORD *)(a2 + 8);
  BOOL v14 = v13 > 0x13 || ((1 << v13) & 0xAAC00) == 0;
  unsigned int v15 = bswap32(*(_DWORD *)(a3 + 4));
  if (v14) {
    unsigned int v16 = *(_DWORD *)(a3 + 4);
  }
  else {
    unsigned int v16 = v15;
  }
  if (v16 >= 9)
  {
    unsigned int v17 = 0;
    uint64_t v18 = *(unsigned int *)(a2 + 52);
    int8x16_t result = 16777223;
    unint64_t v19 = a3 + v16;
    do
    {
      if ((unint64_t)(v12 + 1) > v19)
      {
        v50[0] = "load command ";
        uint64_t v51 = a5;
        __int16 v52 = 2051;
        char v25 = "flavor in ";
        goto LABEL_84;
      }
      LODWORD(v20) = *v12;
      unsigned int v21 = bswap32(*v12);
      if (((1 << v13) & 0xAAC00) == 0) {
        unsigned int v21 = *v12;
      }
      if (v13 <= 0x13) {
        uint64_t v20 = v21;
      }
      else {
        uint64_t v20 = v20;
      }
      if ((unint64_t)(v12 + 2) > v19)
      {
        v50[0] = "load command ";
        uint64_t v51 = a5;
        __int16 v52 = 2051;
        char v25 = " count in ";
LABEL_84:
        *(void *)&long long v53 = v50;
        *(void *)&long long v54 = v25;
        uint64_t v26 = 770;
        LOWORD(v55) = 770;
        if (*a6)
        {
          *(void *)&long long v56 = &v53;
          *(void *)&long long v57 = a6;
          LOWORD(v5++*(_DWORD *)(this + 8) = 770;
          char v8 = 2;
          char v27 = (const char *)&v56;
        }
        else
        {
          long long v56 = v53;
          long long v57 = v54;
          uint64_t v58 = v55;
          char v8 = v55;
          if (v55 == 1)
          {
            int v24 = " extends past end of command";
            goto LABEL_77;
          }
          uint64_t v26 = *((void *)&v56 + 1);
          char v27 = (const char *)&v56;
          if (BYTE1(v58) == 1) {
            char v27 = (const char *)v56;
          }
          else {
            char v8 = 2;
          }
        }
        unint64_t v59 = v27;
        uint64_t v60 = v26;
        char v10 = " extends past end of command";
        goto LABEL_5;
      }
      unsigned int v22 = bswap32(v12[1]);
      if (((1 << v13) & 0xAAC00) == 0) {
        unsigned int v22 = v12[1];
      }
      if (v13 <= 0x13) {
        unsigned int v23 = v22;
      }
      else {
        unsigned int v23 = v12[1];
      }
      if ((int)v18 > 16777222)
      {
        if (v18 == 16777223)
        {
          switch((int)v20)
          {
            case 4:
              if (v23 != 42)
              {
                v44[0] = "load command ";
                uint64_t v45 = a5;
                __int16 v46 = 2051;
                v47[0] = v44;
                long long v48 = " count not x86_THREAD_STATE64_COUNT for flavor number ";
                __int16 v49 = 770;
                v50[0] = v47;
                uint64_t v51 = v17;
                __int16 v52 = 2050;
                long long v28 = " which is a x86_THREAD_STATE64 flavor in ";
                goto LABEL_104;
              }
              v12 += 44;
              if ((unint64_t)v12 > v19)
              {
                v50[0] = "load command ";
                uint64_t v51 = a5;
                __int16 v52 = 2051;
                long long v33 = " x86_THREAD_STATE64 extends past end of command in ";
                goto LABEL_110;
              }
              break;
            case 6:
              if (v23 != 4)
              {
                v44[0] = "load command ";
                uint64_t v45 = a5;
                __int16 v46 = 2051;
                v47[0] = v44;
                long long v48 = " count not x86_EXCEPTION_STATE64_COUNT for flavor number ";
                __int16 v49 = 770;
                v50[0] = v47;
                uint64_t v51 = v17;
                __int16 v52 = 2050;
                long long v28 = " which is a x86_EXCEPTION_STATE64 flavor in ";
                goto LABEL_104;
              }
              v12 += 6;
              if ((unint64_t)v12 > v19)
              {
                v50[0] = "load command ";
                uint64_t v51 = a5;
                __int16 v52 = 2051;
                long long v33 = " x86_EXCEPTION_STATE64 extends past end of command in ";
                goto LABEL_110;
              }
              break;
            case 7:
              if (v23 != 44)
              {
                v44[0] = "load command ";
                uint64_t v45 = a5;
                __int16 v46 = 2051;
                v47[0] = v44;
                long long v48 = " count not x86_THREAD_STATE_COUNT for flavor number ";
                __int16 v49 = 770;
                v50[0] = v47;
                uint64_t v51 = v17;
                __int16 v52 = 2050;
                uint64_t v31 = " which is a x86_THREAD_STATE flavor in ";
                goto LABEL_101;
              }
              v12 += 46;
              if ((unint64_t)v12 > v19)
              {
                v50[0] = "load command ";
                uint64_t v51 = a5;
                __int16 v52 = 2051;
                long long v34 = " x86_THREAD_STATE extends past end of command in ";
                goto LABEL_107;
              }
              break;
            case 8:
              if (v23 != 133)
              {
                v44[0] = "load command ";
                uint64_t v45 = a5;
                __int16 v46 = 2051;
                v47[0] = v44;
                long long v48 = " count not x86_FLOAT_STATE_COUNT for flavor number ";
                __int16 v49 = 770;
                v50[0] = v47;
                uint64_t v51 = v17;
                __int16 v52 = 2050;
                uint64_t v31 = " which is a x86_FLOAT_STATE flavor in ";
                goto LABEL_101;
              }
              v12 += 135;
              if ((unint64_t)v12 > v19)
              {
                v50[0] = "load command ";
                uint64_t v51 = a5;
                __int16 v52 = 2051;
                long long v34 = " x86_FLOAT_STATE extends past end of command in ";
                goto LABEL_107;
              }
              break;
            case 9:
              if (v23 != 6)
              {
                v44[0] = "load command ";
                uint64_t v45 = a5;
                __int16 v46 = 2051;
                v47[0] = v44;
                long long v48 = " count not x86_EXCEPTION_STATE_COUNT for flavor number ";
                __int16 v49 = 770;
                v50[0] = v47;
                uint64_t v51 = v17;
                __int16 v52 = 2050;
                uint64_t v31 = " which is a x86_EXCEPTION_STATE flavor in ";
                goto LABEL_101;
              }
              v12 += 8;
              if ((unint64_t)v12 > v19)
              {
                v50[0] = "load command ";
                uint64_t v51 = a5;
                __int16 v52 = 2051;
                long long v34 = " x86_EXCEPTION_STATE extends past end of command in ";
                goto LABEL_107;
              }
              break;
            default:
              goto LABEL_91;
          }
        }
        else
        {
          if (v18 != 16777228 && v18 != 33554444)
          {
LABEL_93:
            v44[0] = "unknown cputype (";
            uint64_t v45 = v18;
            __int16 v46 = 2051;
            v47[0] = v44;
            long long v48 = ") load command ";
            uint64_t v29 = 770;
            __int16 v49 = 770;
            v50[0] = v47;
            uint64_t v51 = a5;
            __int16 v52 = 2050;
            *(void *)&long long v53 = v50;
            *(void *)&long long v54 = " for ";
            LOWORD(v55) = 770;
            if (*a6)
            {
              *(void *)&long long v56 = &v53;
              *(void *)&long long v57 = a6;
              LOWORD(v5++*(_DWORD *)(this + 8) = 770;
              char v8 = 2;
              long long v30 = (const char *)&v56;
            }
            else
            {
              long long v56 = v53;
              long long v57 = v54;
              uint64_t v58 = v55;
              char v8 = v55;
              if (v55 == 1)
              {
                int v24 = " command can't be checked";
                goto LABEL_77;
              }
              uint64_t v29 = *((void *)&v56 + 1);
              long long v30 = (const char *)&v56;
              if (BYTE1(v58) == 1) {
                long long v30 = (const char *)v56;
              }
              else {
                char v8 = 2;
              }
            }
            unint64_t v59 = v30;
            uint64_t v60 = v29;
            char v10 = " command can't be checked";
            goto LABEL_5;
          }
          if (v20 == 7)
          {
            if (v23 != 4)
            {
              v44[0] = "load command ";
              uint64_t v45 = a5;
              __int16 v46 = 2051;
              v47[0] = v44;
              long long v48 = " count not ARM_EXCEPTION_STATE64_COUNT for flavor number ";
              __int16 v49 = 770;
              v50[0] = v47;
              uint64_t v51 = v17;
              __int16 v52 = 2050;
              long long v28 = " which is a ARM_EXCEPTION_STATE64 flavor in ";
              goto LABEL_104;
            }
            v12 += 6;
            if ((unint64_t)v12 > v19)
            {
              v50[0] = "load command ";
              uint64_t v51 = a5;
              __int16 v52 = 2051;
              long long v33 = " ARM_EXCEPTION_STATE64 extends past end of command in ";
LABEL_110:
              *(void *)&long long v53 = v50;
              *(void *)&long long v54 = v33;
              uint64_t v32 = 770;
              LOWORD(v55) = 770;
              if (*a6)
              {
LABEL_111:
                *(void *)&long long v56 = &v53;
                *(void *)&long long v57 = a6;
                LOWORD(v5++*(_DWORD *)(this + 8) = 770;
LABEL_112:
                char v8 = 2;
                long long v37 = (const char *)&v56;
LABEL_113:
                unint64_t v59 = v37;
                uint64_t v60 = v32;
                char v10 = " command";
LABEL_5:
                unint64_t v61 = v10;
                LOBYTE(v62) = v8;
                HIBYTE(v62) = 3;
LABEL_78:
                sub_1CCC51CE4((uint64_t)v6, (uint64_t *)&v59);
              }
LABEL_114:
              long long v56 = v53;
              long long v57 = v54;
              uint64_t v58 = v55;
              char v8 = v55;
              if (v55 != 1)
              {
                uint64_t v32 = *((void *)&v56 + 1);
                long long v36 = (const char *)v56;
                int v35 = BYTE1(v58);
LABEL_116:
                BOOL v14 = v35 == 1;
                long long v37 = (const char *)&v56;
                if (v14) {
                  long long v37 = v36;
                }
                else {
                  char v8 = 2;
                }
                goto LABEL_113;
              }
LABEL_119:
              int v24 = " command";
LABEL_77:
              unint64_t v59 = v24;
              __int16 v62 = 259;
              goto LABEL_78;
            }
          }
          else
          {
            if (v20 != 6) {
              goto LABEL_91;
            }
            if (v23 != 68)
            {
              v44[0] = "load command ";
              uint64_t v45 = a5;
              __int16 v46 = 2051;
              v47[0] = v44;
              long long v48 = " count not ARM_THREAD_STATE64_COUNT for flavor number ";
              __int16 v49 = 770;
              v50[0] = v47;
              uint64_t v51 = v17;
              __int16 v52 = 2050;
              long long v28 = " which is a ARM_THREAD_STATE64 flavor in ";
              goto LABEL_104;
            }
            v12 += 70;
            if ((unint64_t)v12 > v19)
            {
              v50[0] = "load command ";
              uint64_t v51 = a5;
              __int16 v52 = 2051;
              long long v33 = " ARM_THREAD_STATE64 extends past end of command in ";
              goto LABEL_110;
            }
          }
        }
      }
      else
      {
        switch(v18)
        {
          case 7:
            if (v20 != 1)
            {
              v38[0] = "load command ";
              uint64_t v39 = a5;
              __int16 v40 = 2051;
              v41[0] = v38;
              long long v42 = " unknown flavor (";
              __int16 v43 = 770;
              v44[0] = v41;
              uint64_t v45 = v20;
              __int16 v46 = 2050;
              v47[0] = v44;
              long long v48 = ") for flavor number ";
              __int16 v49 = 770;
              v50[0] = v47;
              uint64_t v51 = v17;
              __int16 v52 = 2050;
              uint64_t v31 = " in ";
              goto LABEL_101;
            }
            if (v23 != 16)
            {
              v44[0] = "load command ";
              uint64_t v45 = a5;
              __int16 v46 = 2051;
              v47[0] = v44;
              long long v48 = " count not x86_THREAD_STATE32_COUNT for flavor number ";
              __int16 v49 = 770;
              v50[0] = v47;
              uint64_t v51 = v17;
              __int16 v52 = 2050;
              uint64_t v31 = " which is a x86_THREAD_STATE32 flavor in ";
LABEL_101:
              *(void *)&long long v53 = v50;
              *(void *)&long long v54 = v31;
              LOWORD(v55) = 770;
              uint64_t v32 = *a6;
              if (*a6) {
                goto LABEL_105;
              }
              goto LABEL_108;
            }
            v12 += 18;
            if ((unint64_t)v12 > v19)
            {
              v50[0] = "load command ";
              uint64_t v51 = a5;
              __int16 v52 = 2051;
              long long v34 = " x86_THREAD_STATE32 extends past end of command in ";
LABEL_107:
              *(void *)&long long v53 = v50;
              *(void *)&long long v54 = v34;
              uint64_t v32 = 770;
              LOWORD(v55) = 770;
              if (*a6) {
                goto LABEL_111;
              }
LABEL_108:
              long long v56 = v53;
              long long v57 = v54;
              uint64_t v58 = v55;
              char v8 = v55;
              if (v55 != 1)
              {
                int v35 = BYTE1(v58);
                uint64_t v32 = *((void *)&v56 + 1);
                long long v36 = (const char *)v56;
                goto LABEL_116;
              }
              goto LABEL_119;
            }
            break;
          case 0xC:
            if (v20 != 1) {
              goto LABEL_91;
            }
            if (v23 != 17)
            {
              v44[0] = "load command ";
              uint64_t v45 = a5;
              __int16 v46 = 2051;
              v47[0] = v44;
              long long v48 = " count not ARM_THREAD_STATE_COUNT for flavor number ";
              __int16 v49 = 770;
              v50[0] = v47;
              uint64_t v51 = v17;
              __int16 v52 = 2050;
              long long v28 = " which is a ARM_THREAD_STATE flavor in ";
              goto LABEL_104;
            }
            v12 += 19;
            if ((unint64_t)v12 > v19)
            {
              v50[0] = "load command ";
              uint64_t v51 = a5;
              __int16 v52 = 2051;
              long long v33 = " ARM_THREAD_STATE extends past end of command in ";
              goto LABEL_110;
            }
            break;
          case 0x12:
            if (v20 != 1)
            {
LABEL_91:
              v38[0] = "load command ";
              uint64_t v39 = a5;
              __int16 v40 = 2051;
              v41[0] = v38;
              long long v42 = " unknown flavor (";
              __int16 v43 = 770;
              v44[0] = v41;
              uint64_t v45 = v20;
              __int16 v46 = 2050;
              v47[0] = v44;
              long long v48 = ") for flavor number ";
              __int16 v49 = 770;
              v50[0] = v47;
              uint64_t v51 = v17;
              __int16 v52 = 2050;
              long long v28 = " in ";
              goto LABEL_104;
            }
            if (v23 != 40)
            {
              v44[0] = "load command ";
              uint64_t v45 = a5;
              __int16 v46 = 2051;
              v47[0] = v44;
              long long v48 = " count not PPC_THREAD_STATE_COUNT for flavor number ";
              __int16 v49 = 770;
              v50[0] = v47;
              uint64_t v51 = v17;
              __int16 v52 = 2050;
              long long v28 = " which is a PPC_THREAD_STATE flavor in ";
LABEL_104:
              *(void *)&long long v53 = v50;
              *(void *)&long long v54 = v28;
              LOWORD(v55) = 770;
              uint64_t v32 = *a6;
              if (!*a6) {
                goto LABEL_114;
              }
LABEL_105:
              *(void *)&long long v56 = &v53;
              *(void *)&long long v57 = a6;
              LOWORD(v5++*(_DWORD *)(this + 8) = 770;
              goto LABEL_112;
            }
            v12 += 42;
            if ((unint64_t)v12 > v19)
            {
              v50[0] = "load command ";
              uint64_t v51 = a5;
              __int16 v52 = 2051;
              long long v33 = " PPC_THREAD_STATE extends past end of command in ";
              goto LABEL_110;
            }
            break;
          default:
            goto LABEL_93;
        }
      }
      ++v17;
    }
    while ((unint64_t)v12 < v19);
  }
  *unsigned int v6 = 0;
  return result;
}

uint64_t sub_1CCC54354(uint64_t a1, _DWORD *a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = v2 > (unint64_t)a2 || (unint64_t)(a2 + 4) > v2 + *(void *)(a1 + 24);
  if (v3) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  LODWORD(v4) = *a2;
  LODWORD(v5) = a2[1];
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  BOOL v3 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  BOOL v8 = v3 || v7 == 0;
  unsigned int v9 = bswap32(v4);
  unsigned int v10 = bswap32(v5);
  if (v8) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = v9;
  }
  if (v8) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = v10;
  }
  return v4 | (v5 << 32);
}

double sub_1CCC543D4@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 > (unint64_t)a2 || (unint64_t)(a2 + 5) > v3 + *(void *)(a1 + 24)) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v5 = a2[3];
  *(_OWORD *)(a3 + 32) = a2[2];
  *(_OWORD *)(a3 + 4++*(_DWORD *)(this + 8) = v5;
  *(_OWORD *)(a3 + 64) = a2[4];
  long long v6 = a2[1];
  *(_OWORD *)a3 = *a2;
  *(_OWORD *)(a3 + ++*(_DWORD *)(this + 16) = v6;
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  if (v7 <= 0x13 && ((1 << v7) & 0xAAC00) != 0)
  {
    *(void *)&long long v6 = sub_1CD6E4DF0((int8x16_t *)a3).u64[0];
  }
  return *(double *)&v6;
}

uint64_t *llvm::object::MachOObjectFile::checkSymbolTable@<X0>(llvm::object::MachOObjectFile *this@<X0>, void *a2@<X8>, __n128 a3@<Q0>)
{
  int v5 = *((_DWORD *)this + 18);
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  long long v6 = (long long *)*((void *)this + 34);
  if (v6)
  {
    a3.n128_f64[0] = sub_1CCC530A4((uint64_t)&v31, (uint64_t)this, v6);
  }
  else
  {
    uint64_t v32 = 0;
    uint64_t v33 = 0;
  }
  unsigned int v7 = (uint64_t *)(*(uint64_t (**)(llvm::object::MachOObjectFile *, __n128))(*(void *)this + 48))(this, a3);
  uint64_t v9 = v8;
  int8x16_t result = (uint64_t *)(*(uint64_t (**)(llvm::object::MachOObjectFile *))(*(void *)this + 56))(this);
  uint64_t v29 = v7;
  uint64_t v30 = v9;
  if (v7 != result)
  {
    uint64_t v11 = (uint64_t)result;
    unsigned int v12 = 0;
    unint64_t v13 = HIDWORD(v33);
    do
    {
      if ((*((_DWORD *)this + 2) & 0xFFFFFFFE) == 0x12)
      {
        unint64_t Symbol64TableEntry = llvm::object::MachOObjectFile::getSymbol64TableEntry((uint64_t)this, v7);
      }
      else
      {
        unint64_t Symbol64TableEntry = llvm::object::MachOObjectFile::getSymbolTableEntry((uint64_t)this, v7);
        unint64_t v15 = v15;
      }
      if ((Symbol64TableEntry & 0xE000000000) == 0)
      {
        int v16 = BYTE4(Symbol64TableEntry) & 0xE;
        if (v16 == 10)
        {
          if (v15 >= v13)
          {
            unsigned int v22 = "bad n_value: ";
            unint64_t v23 = v15;
            __int16 v24 = 2307;
            uint64_t v20 = " past the end of string table, for N_INDR symbol at index ";
            goto LABEL_35;
          }
        }
        else if (v16 == 14 {
               && ((Symbol64TableEntry & 0xFF0000000000) == 0
        }
                || BYTE5(Symbol64TableEntry) > (unint64_t)*((unsigned int *)this + 22)))
        {
          unsigned int v22 = "bad section index: ";
          unint64_t v23 = BYTE5(Symbol64TableEntry);
          __int16 v21 = 2307;
          goto LABEL_33;
        }
        if ((v5 & 0x80) != 0)
        {
          BOOL v17 = (Symbol64TableEntry & 0xE00000000) == 0 && v15 == 0;
          BOOL v18 = v17;
          if (v16 == 12 || v18)
          {
            unint64_t v19 = HIBYTE(Symbol64TableEntry);
            if (HIBYTE(Symbol64TableEntry) - 254 >= 2u
              && v19
              && (v19 - 1) >= (unint64_t)*((unsigned int *)this + 28))
            {
              unsigned int v22 = "bad library ordinal: ";
              unint64_t v23 = HIBYTE(Symbol64TableEntry);
              __int16 v21 = 2051;
LABEL_33:
              __int16 v24 = v21;
              uint64_t v20 = " for symbol at index ";
LABEL_35:
              v25[0] = &v22;
              _OWORD v25[2] = v20;
              __int16 v26 = 770;
              v27[0] = (uint64_t)v25;
              v27[2] = v12;
              __int16 v28 = 2050;
              sub_1CCC51CE4((uint64_t)a2, v27);
            }
          }
        }
      }
      if (v13 <= Symbol64TableEntry)
      {
        unsigned int v22 = "bad string table index: ";
        unint64_t v23 = Symbol64TableEntry;
        __int16 v24 = 2307;
        uint64_t v20 = " past the end of string table, for symbol at index ";
        goto LABEL_35;
      }
      ++v12;
      int8x16_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)v30 + 24))(v30, &v29);
      unsigned int v7 = v29;
    }
    while (v29 != (uint64_t *)v11);
  }
  *a2 = 0;
  return result;
}

uint64_t llvm::object::MachOObjectFile::getHeader64(llvm::object::MachOObjectFile *this)
{
  return (uint64_t)this + 48;
}

double llvm::object::MachOObjectFile::getSymtabLoadCommand@<D0>(llvm::object::MachOObjectFile *this@<X0>, void *a2@<X8>)
{
  unint64_t v2 = (long long *)*((void *)this + 34);
  if (v2) {
    return sub_1CCC530A4((uint64_t)a2, (uint64_t)this, v2);
  }
  *(void *)&double result = 0x1800000002;
  *a2 = 0x1800000002;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

uint64_t sub_1CCC54734(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = v2 > (unint64_t)a2 || (unint64_t)(a2 + 1) > v2 + *(void *)(a1 + 24);
  if (v3) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  uint64_t v4 = *a2;
  unint64_t v5 = HIWORD(*a2);
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  BOOL v3 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  BOOL v8 = v3 || v7 == 0;
  LODWORD(v9) = bswap32(v4);
  unsigned int v10 = __rev16(v5);
  if (v8) {
    uint64_t v9 = v4;
  }
  else {
    uint64_t v9 = v9;
  }
  if (v8) {
    unint64_t v5 = v5;
  }
  else {
    unint64_t v5 = v10;
  }
  return v4 & 0xFFFF00000000 | (v5 << 48) | v9;
}

uint64_t llvm::object::MachOObjectFile::getSectionType(uint64_t a1, unsigned int a2)
{
  return sub_1CCC547D0(a1, a2);
}

uint64_t sub_1CCC547D0(uint64_t a1, unsigned int a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12)
  {
    long long v6 = 0u;
    long long v7 = 0u;
    long long v4 = 0u;
    long long v5 = 0u;
    long long v3 = 0u;
    sub_1CCC64584(a1, *(_OWORD **)(*(void *)(a1 + 80) + 8 * a2), (uint64_t)&v3);
    return v7;
  }
  else
  {
    LODWORD(v7) = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    long long v3 = 0u;
    long long v4 = 0u;
    sub_1CCC644F0(a1, *(void *)(*(void *)(a1 + 80) + 8 * a2), (uint64_t)&v3);
    return DWORD2(v6);
  }
}

uint64_t llvm::object::MachOObjectFile::getNValue(uint64_t a1, uint64_t *a2)
{
  if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12)
  {
    llvm::object::MachOObjectFile::getSymbol64TableEntry(a1, a2);
    return v2;
  }
  else
  {
    llvm::object::MachOObjectFile::getSymbolTableEntry(a1, a2);
    return v4;
  }
}

uint64_t llvm::object::MachOObjectFile::getIndirectName(llvm::object::MachOObjectFile *a1, uint64_t *a2, unint64_t *a3)
{
  unint64_t StringTableData = llvm::object::MachOObjectFile::getStringTableData(a1);
  unint64_t v8 = v7;
  uint64_t SymbolTableEntry = sub_1CCC54734((uint64_t)a1, a2);
  if ((SymbolTableEntry & 0xE00000000) == 0xA00000000
    && ((*((_DWORD *)a1 + 2) & 0xFFFFFFFE) != 0x12
      ? (SymbolTableEntry = llvm::object::MachOObjectFile::getSymbolTableEntry((uint64_t)a1, a2), unint64_t v12 = v12)
      : (uint64_t SymbolTableEntry = llvm::object::MachOObjectFile::getSymbol64TableEntry((uint64_t)a1, a2)),
        v12 < v8))
  {
    unint64_t v13 = StringTableData + v12;
    if (StringTableData) {
      size_t v14 = strlen((const char *)(StringTableData + v12));
    }
    else {
      size_t v14 = 0;
    }
    *a3 = v13;
    a3[1] = v14;
    std::system_category();
    return 0;
  }
  else
  {
    uint64_t v10 = 3;
    llvm::object::object_category((llvm::object *)SymbolTableEntry);
  }
  return v10;
}

uint64_t llvm::object::MachOObjectFile::getSymbolSectionID(uint64_t a1, uint64_t *a2)
{
  return ((unsigned __int16)((unint64_t)sub_1CCC54734(a1, a2) >> 32) >> 8) - 1;
}

void llvm::object::MachOObjectFile::moveSectionNext(uint64_t a1, _DWORD *a2)
{
}

size_t llvm::object::MachOObjectFile::getSectionName@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 80) + 8 * a2);
  if (*(unsigned char *)(v4 + 15)) {
    size_t result = 16;
  }
  else {
    size_t result = strlen(*(const char **)(*(void *)(a1 + 80) + 8 * a2));
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v4;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = result;
  return result;
}

uint64_t llvm::object::MachOObjectFile::getSectionRawName(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 80) + 8 * a2);
}

double llvm::object::MachOObjectFile::getSection64@<D0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  return sub_1CCC64584(a1, *(_OWORD **)(*(void *)(a1 + 80) + 8 * a2), a3);
}

double llvm::object::MachOObjectFile::getSection@<D0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)&double result = sub_1CCC644F0(a1, *(void *)(*(void *)(a1 + 80) + 8 * a2), a3).u64[0];
  return result;
}

uint64_t llvm::object::MachOObjectFile::getSectionContents(llvm::object::MachOObjectFile *this, unsigned int a2)
{
  uint64_t v2 = a2;
  if (*((void *)this + 3) < (unint64_t)a2) {
    uint64_t v2 = *((void *)this + 3);
  }
  return *((void *)this + 2) + v2;
}

void llvm::object::MachOObjectFile::getSectionContents(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12)
  {
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v10 = 0u;
    sub_1CCC64584(a1, *(_OWORD **)(*(void *)(a1 + 80) + 8 * a2), (uint64_t)&v10);
    LODWORD(v5) = v13;
    unint64_t v6 = *((void *)&v12 + 1);
  }
  else
  {
    LODWORD(v14) = 0;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    sub_1CCC644F0(a1, *(void *)(*(void *)(a1 + 80) + 8 * a2), (uint64_t)&v10);
    unint64_t v6 = DWORD1(v12);
    LODWORD(v5) = DWORD2(v12);
  }
  unint64_t v7 = *(void *)(a1 + 24);
  if (v7 >= v5) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 24);
  }
  uint64_t v8 = *(void *)(a1 + 16) + v5;
  unint64_t v9 = v7 - v5;
  if (v9 < v6) {
    unint64_t v6 = v9;
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v8;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v6;
}

uint64_t llvm::object::MachOObjectFile::getSection@<X0>(uint64_t this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (!a2 || *(_DWORD *)(this + 88) < a2)
  {
    v3[0] = (uint64_t)"bad section index: ";
    void v3[2] = a2;
    __int16 v4 = 2307;
    sub_1CCC51CE4(a3, v3);
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = a2 - 1;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = this;
  return this;
}

double llvm::object::MachOObjectFile::getSection@<D0>(uint64_t a1@<X0>, const void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 344))(a1);
  uint64_t v10 = v9;
  long long v11 = (llvm::object *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 352))(a1);
  *(void *)&long long v19 = v8;
  *((void *)&v19 + 1) = v10;
  if (v10 == v12 && v8 == (void)v11)
  {
LABEL_15:
    *(void *)&v23.__val_ = llvm::object::object_category(v11);
    llvm::errorCodeToError((llvm *)3, v23, (void *)a4);
    *(unsigned char *)(a4 + 16) |= 1u;
  }
  else
  {
    long long v14 = v11;
    uint64_t v15 = v12;
    while (1)
    {
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)v10 + 136))(__s1, v10, v8);
      if (v21)
      {
        BOOL v18 = __s1[0];
        *(unsigned char *)(a4 + 16) |= 1u;
        *(void *)a4 = v18;
        return result;
      }
      if (__s1[1] == a3 && (!a3 || !memcmp(__s1[0], a2, (size_t)a3))) {
        break;
      }
      long long v11 = (llvm::object *)(*(uint64_t (**)(void, long long *))(**((void **)&v19 + 1) + 128))(*((void *)&v19 + 1), &v19);
      uint64_t v10 = *((void *)&v19 + 1);
      uint64_t v8 = v19;
      if (*((void *)&v19 + 1) == v15 && (void)v19 == (void)v14) {
        goto LABEL_15;
      }
    }
    *(unsigned char *)(a4 + 16) &= ~1u;
    double result = *(double *)&v19;
    *(_OWORD *)a4 = v19;
  }
  return result;
}

uint64_t llvm::object::MachOObjectFile::isSectionText(uint64_t a1, unsigned int a2)
{
  return sub_1CCC547D0(a1, a2) >> 31;
}

BOOL llvm::object::MachOObjectFile::isSectionData(uint64_t a1, unsigned int a2)
{
  int v2 = sub_1CCC547D0(a1, a2);
  BOOL v4 = v2 != 1 && v2 != 12;
  return v2 >= 0 && v4;
}

uint64_t llvm::object::MachOObjectFile::isDebugSection(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)a1 + 136))(&v9);
  if (v11)
  {
    uint64_t v8 = (void *)v9;
    uint64_t v9 = 0;
    sub_1CD4515D0(&v8);
    if (v8) {
      (*(void (**)(void *))(*v8 + 8))(v8);
    }
    goto LABEL_3;
  }
  if (v10 < 7)
  {
LABEL_3:
    uint64_t v1 = 0;
    goto LABEL_29;
  }
  if (*(_DWORD *)v9 == 1701076831 && *(_DWORD *)(v9 + 3) == 1735746149) {
    goto LABEL_28;
  }
  if (v10 >= 8)
  {
    if (*(void *)v9 != 0x67756265647A5F5FLL && (*(_DWORD *)v9 != 1885429599 || *(_DWORD *)(v9 + 3) != 1701605488))
    {
      if (v10 != 11) {
        goto LABEL_3;
      }
      if (*(void *)v9 != 0x6E695F6264675F5FLL || *(void *)(v9 + 3) != 0x7865646E695F6264)
      {
        BOOL v3 = *(void *)v9 == 0x5F74666977735F5FLL && *(void *)(v9 + 3) == 0x7473615F74666977;
        goto LABEL_12;
      }
    }
LABEL_28:
    uint64_t v1 = 1;
    goto LABEL_29;
  }
  BOOL v3 = *(_DWORD *)v9 == 1885429599 && *(_DWORD *)(v9 + 3) == 1701605488;
LABEL_12:
  uint64_t v1 = v3;
LABEL_29:
  if (v11)
  {
    uint64_t v6 = v9;
    uint64_t v9 = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
  }
  return v1;
}

uint64_t llvm::object::MachOObjectFile::getSegmentContents(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(unsigned int *)(a1 + 136);
  if (v3)
  {
    uint64_t v7 = *(void *)(a1 + 128);
    uint64_t v8 = v7 + 16 * v3;
    do
    {
      unint64_t v9 = *(void *)v7;
      int v10 = *(_DWORD *)(v7 + 8);
      if (v10 == 25)
      {
        sub_1CCC6FAAC((uint64_t)&v17, a1, v9);
        if (v24)
        {
LABEL_23:
          int v16 = v17;
          sub_1CD4515D0(&v16);
          if (v16) {
            (*(void (**)(void *))(*v16 + 8))(v16);
          }
          goto LABEL_25;
        }
        if (a3 <= 0x10 && (!a3 || !memcmp(v18, a2, a3)))
        {
          uint64_t v11 = *(void *)(a1 + 16);
          unint64_t v12 = *(void *)(a1 + 24);
          unint64_t v13 = v21;
          unint64_t v14 = v22 + v21;
LABEL_15:
          if (v12 < v13) {
            unint64_t v13 = v12;
          }
          if (v13 > v14) {
            unint64_t v14 = v13;
          }
          if (v12 >= v14) {
            unint64_t v12 = v14;
          }
          uint64_t result = v11 + v13;
          if (v12 != v13) {
            return result;
          }
        }
      }
      else if (v10 == 1)
      {
        sub_1CCC6FB90((uint64_t)&v17, a1, v9);
        if (v23) {
          goto LABEL_23;
        }
        if (a3 <= 0x10 && (!a3 || !memcmp(v18, a2, a3)))
        {
          uint64_t v11 = *(void *)(a1 + 16);
          unint64_t v12 = *(void *)(a1 + 24);
          unint64_t v13 = v19;
          unint64_t v14 = v20 + v19;
          goto LABEL_15;
        }
      }
LABEL_25:
      v7 += 16;
    }
    while (v7 != v8);
  }
  return 0;
}

uint64_t llvm::object::MachOObjectFile::load_commands(llvm::object::MachOObjectFile *this)
{
  return *((void *)this + 16);
}

uint64_t llvm::object::MachOObjectFile::getSectionID(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t llvm::object::MachOObjectFile::isSectionBitcode(void *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1[10] + 8 * a2);
  uint64_t v5 = v4 + 16;
  if (*(unsigned char *)(v4 + 31)) {
    size_t v6 = 16;
  }
  else {
    size_t v6 = strlen((const char *)v5);
  }
  (*(void (**)(void *__return_ptr, void *, uint64_t))(*a1 + 136))(v10, a1, a2);
  if (v11)
  {
    uint64_t result = v10[0];
    v10[0] = 0;
    if (!result) {
      return result;
    }
    (*(void (**)(uint64_t))(*(void *)result + 8))(result);
    return 0;
  }
  if (v6 != 6) {
    return 0;
  }
  BOOL v8 = *(_DWORD *)v5 == 1280073567 && *(_WORD *)(v5 + 4) == 19798;
  if (!v8 || v10[1] != 9) {
    return 0;
  }
  return *(void *)v10[0] == 0x646F637469625F5FLL && *(unsigned char *)(v10[0] + 8) == 101;
}

const char *llvm::object::MachOObjectFile::getSectionFinalSegmentName(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 80) + 8 * a2);
  uint64_t v3 = (const char *)(v2 + 16);
  if (!*(unsigned char *)(v2 + 31)) {
    strlen(v3);
  }
  return v3;
}

uint64_t llvm::object::MachOObjectFile::extrel_begin(llvm::object::MachOObjectFile *this)
{
  return 0;
}

unint64_t llvm::object::MachOObjectFile::extrel_end(llvm::object::MachOObjectFile *this)
{
  uint64_t v1 = (_OWORD *)*((void *)this + 35);
  if (!v1) {
    return 0;
  }
  long long v4 = 0u;
  memset(v3, 0, sizeof(v3));
  sub_1CCC543D4((uint64_t)this, v1, (uint64_t)v3);
  return (unint64_t)DWORD1(v4) << 32;
}

uint64_t llvm::object::MachOObjectFile::locrel_begin(llvm::object::MachOObjectFile *this)
{
  return 1;
}

unint64_t llvm::object::MachOObjectFile::locrel_end(llvm::object::MachOObjectFile *this)
{
  uint64_t v1 = (_OWORD *)*((void *)this + 35);
  if (!v1) {
    return 1;
  }
  long long v4 = 0u;
  memset(v3, 0, sizeof(v3));
  sub_1CCC543D4((uint64_t)this, v1, (uint64_t)v3);
  return ((unint64_t)HIDWORD(v4) << 32) | 1;
}

uint64_t llvm::object::MachOObjectFile::getAnyRelocationAddress(uint64_t a1, unsigned int *a2)
{
  unsigned int v2 = *a2;
  if ((*a2 & 0x80000000) == 0 || *(_DWORD *)(a1 + 52) == 16777223) {
    return v2;
  }
  else {
    return v2 & 0xFFFFFF;
  }
}

BOOL llvm::object::MachOObjectFile::isRelocationScattered(uint64_t a1, int *a2)
{
  return *(_DWORD *)(a1 + 52) != 16777223 && *a2 < 0;
}

uint64_t llvm::object::MachOObjectFile::getPlainRelocationSymbolNum(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  BOOL v3 = v2 > 0x13;
  int v4 = (1 << v2) & 0xAAC00;
  if (v3 || v4 == 0) {
    return *(_DWORD *)(a2 + 4) & 0xFFFFFF;
  }
  else {
    return *(_DWORD *)(a2 + 4) >> 8;
  }
}

BOOL llvm::object::MachOObjectFile::getPlainRelocationExternal(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  BOOL v3 = v2 >= 0x13;
  BOOL v5 = v2 == 19;
  int v4 = (1 << v2) & 0xAAC00;
  BOOL v5 = !v5 && v3 || v4 == 0;
  if (v5) {
    int v6 = (*(_DWORD *)(a2 + 4) >> 27) & 1;
  }
  else {
    int v6 = *(_DWORD *)(a2 + 4) & 0x10;
  }
  return v6 != 0;
}

uint64_t llvm::object::MachOObjectFile::getRelocationSection(_DWORD *a1, unint64_t a2)
{
  uint64_t Relocation = llvm::object::MachOObjectFile::getRelocation((uint64_t)a1, a2);
  return llvm::object::MachOObjectFile::getAnyRelocationSection(a1, &Relocation);
}

uint64_t llvm::object::MachOObjectFile::getAnyRelocationSection(_DWORD *a1, _DWORD *a2)
{
  if (a1[13] != 16777223 && (*a2 & 0x80000000) != 0) {
    return (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 352))(a1);
  }
  unsigned int v2 = a1[2];
  if (v2 > 0x13 || ((1 << v2) & 0xAAC00) == 0)
  {
    unsigned int v4 = a2[1];
    if ((v4 >> 27)) {
      return (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 352))(a1);
    }
  }
  else
  {
    unsigned int v4 = a2[1];
    if ((v4 & 0x10) != 0) {
      return (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 352))(a1);
    }
  }
  if (v2 <= 0x13 && ((1 << v2) & 0xAAC00) != 0)
  {
    unsigned int v6 = v4 >> 8;
    if (!(v4 >> 8)) {
      return (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 352))(a1);
    }
  }
  else
  {
    unsigned int v6 = v4 & 0xFFFFFF;
    if ((v4 & 0xFFFFFF) == 0) {
      return (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 352))(a1);
    }
  }
  if (a1[22] < v6) {
    return (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 352))(a1);
  }
  return v6 - 1;
}

uint64_t llvm::object::MachOObjectFile::getAnyRelocationType(uint64_t a1, _DWORD *a2)
{
  if (*(_DWORD *)(a1 + 52) != 16777223 && (*a2 & 0x80000000) != 0) {
    return HIBYTE(*a2) & 0xF;
  }
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  BOOL v4 = v3 > 0x13;
  int v5 = (1 << v3) & 0xAAC00;
  if (v4 || v5 == 0) {
    return a2[1] >> 28;
  }
  else {
    return a2[1] & 0xF;
  }
}

uint64_t llvm::object::MachOObjectFile::getRelocationLength(uint64_t a1, unint64_t a2)
{
  uint64_t Relocation = llvm::object::MachOObjectFile::getRelocation(a1, a2);
  if (*(_DWORD *)(a1 + 52) == 16777223 || (Relocation & 0x80000000) == 0)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 8) - 10;
    if (v5 > 9) {
      LOBYTE(v6) = 25;
    }
    else {
      int v6 = dword_1CFB2C198[v5];
    }
    int v4 = HIDWORD(Relocation) >> v6;
  }
  else
  {
    int v4 = Relocation >> 28;
  }
  return v4 & 3;
}

uint64_t llvm::object::MachOObjectFile::getAnyRelocationLength(uint64_t a1, _DWORD *a2)
{
  if (*(_DWORD *)(a1 + 52) == 16777223 || (*a2 & 0x80000000) == 0)
  {
    int v3 = *(_DWORD *)(a1 + 8) - 10;
    if (v3 > 9) {
      LOBYTE(v4) = 25;
    }
    else {
      int v4 = dword_1CFB2C198[v3];
    }
    int v2 = a2[1] >> v4;
  }
  else
  {
    int v2 = *a2 >> 28;
  }
  return v2 & 3;
}

char *llvm::object::MachOObjectFile::guessLibraryShortName(uint64_t a1, unint64_t a2, unsigned char *a3, void *a4)
{
  uint64_t v8 = a1 - 1;
  *a3 = 0;
  unint64_t v9 = a2;
  *a4 = 0;
  a4[1] = 0;
  unint64_t v10 = a2;
  do
  {
    if (!v10) {
      goto LABEL_101;
    }
    unint64_t v11 = v10--;
  }
  while (*(unsigned char *)(v8 + v11) != 47);
  if (v11 <= 1) {
    goto LABEL_101;
  }
  if (a2 < v11) {
    unint64_t v11 = a2;
  }
  uint64_t v12 = (char *)(a1 + v11);
  unint64_t v13 = a2 - v11;
  unint64_t v14 = (unsigned __int8 *)(a2 + a1 - 1);
  size_t v15 = v13;
  do
  {
    if (!v15) {
      goto LABEL_24;
    }
    --v15;
    int v16 = *v14--;
  }
  while (v16 != 95);
  if (v13 < 2)
  {
LABEL_24:
    size_t v17 = v13;
    goto LABEL_25;
  }
  if (v13 >= v15) {
    size_t v17 = v15;
  }
  else {
    size_t v17 = v13;
  }
  BOOL v18 = &v12[v17];
  *a4 = &v12[v17];
  a4[1] = v13 - v17;
  if (v13 - v17 == 8)
  {
    if (*(void *)v18 == 0x656C69666F72705FLL) {
      goto LABEL_25;
    }
    goto LABEL_23;
  }
  if (v13 - v17 != 6
    || ((int v19 = *(_DWORD *)v18, v20 = *((unsigned __int16 *)v18 + 2), v19 == 1650811999)
      ? (BOOL v21 = v20 == 26485)
      : (BOOL v21 = 0),
        !v21))
  {
LABEL_23:
    *a4 = 0;
    a4[1] = 0;
    goto LABEL_24;
  }
LABEL_25:
  if (a2 < v10) {
    unint64_t v10 = a2;
  }
  while (v10)
  {
    unint64_t v22 = v10 - 1;
    int v23 = *(unsigned __int8 *)(v8 + v10--);
    if (v23 == 47) {
      goto LABEL_31;
    }
  }
  unint64_t v22 = -1;
LABEL_31:
  unint64_t v24 = v22 + 1 + v17;
  if (a2 >= v22 + 1) {
    unint64_t v25 = v22 + 1;
  }
  else {
    unint64_t v25 = a2;
  }
  if (v25 <= v24) {
    unint64_t v26 = v22 + 1 + v17;
  }
  else {
    unint64_t v26 = v25;
  }
  if (a2 < v26) {
    unint64_t v26 = a2;
  }
  unint64_t v27 = v26 - v25;
  if (a2 >= v24) {
    unint64_t v28 = v22 + 1 + v17;
  }
  else {
    unint64_t v28 = a2;
  }
  if (v28 <= v24 + 11) {
    unint64_t v29 = v24 + 11;
  }
  else {
    unint64_t v29 = v28;
  }
  if (a2 < v29) {
    unint64_t v29 = a2;
  }
  if (v27 == v17)
  {
    unint64_t v30 = v29 - v28;
    if (v17)
    {
      unint64_t v74 = v30;
      uint64_t v31 = v12;
      int v32 = memcmp((const void *)(a1 + v25), v12, v17);
      uint64_t v12 = v31;
      if (v32 || v74 != 11) {
        goto LABEL_57;
      }
    }
    else if (v30 != 11)
    {
      goto LABEL_57;
    }
    if (*(void *)(a1 + v28) == 0x6F77656D6172662ELL && *(void *)(a1 + v28 + 3) == 0x2F6B726F77656D61) {
      goto LABEL_145;
    }
  }
LABEL_57:
  if (v22 != -1)
  {
    unint64_t v34 = a2 >= v22 ? v22 : a2;
    do
    {
      if (!v34) {
        goto LABEL_101;
      }
      unint64_t v35 = v34--;
    }
    while (*(unsigned char *)(v8 + v35) != 47);
    if (v35 >= 2)
    {
      if (a2 < v35) {
        unint64_t v35 = a2;
      }
      if (a2 - v35 >= 9)
      {
        long long v36 = (uint64_t *)(a1 + v35);
        uint64_t v37 = *v36;
        int v38 = *((unsigned __int8 *)v36 + 8);
        if (v37 == 0x736E6F6973726556 && v38 == 47)
        {
          if (a2 >= v34) {
            unint64_t v40 = v34;
          }
          else {
            unint64_t v40 = a2;
          }
          do
          {
            unint64_t v41 = v40;
            if (!v40) {
              break;
            }
            --v40;
          }
          while (*(unsigned char *)(v8 + v41) != 47);
          unint64_t v42 = v17 + v41;
          if (a2 < v41) {
            unint64_t v41 = a2;
          }
          if (v41 <= v42) {
            unint64_t v43 = v42;
          }
          else {
            unint64_t v43 = v41;
          }
          if (a2 < v43) {
            unint64_t v43 = a2;
          }
          unint64_t v44 = v43 - v41;
          if (a2 >= v42) {
            unint64_t v45 = v42;
          }
          else {
            unint64_t v45 = a2;
          }
          if (v45 <= v42 + 11) {
            unint64_t v46 = v42 + 11;
          }
          else {
            unint64_t v46 = v45;
          }
          if (a2 < v46) {
            unint64_t v46 = a2;
          }
          if (v44 == v17)
          {
            unint64_t v47 = v46 - v45;
            if (!v17)
            {
LABEL_96:
              if (v47 != 11) {
                goto LABEL_101;
              }
              if (*(void *)(a1 + v45) != 0x6F77656D6172662ELL || *(void *)(a1 + v45 + 3) != 0x2F6B726F77656D61) {
                goto LABEL_101;
              }
LABEL_145:
              *a3 = 1;
              return v12;
            }
            long long v48 = v12;
            if (!memcmp((const void *)(a1 + v41), v12, v17))
            {
              uint64_t v12 = v48;
              goto LABEL_96;
            }
          }
        }
      }
    }
  }
LABEL_101:
  unint64_t v50 = v9;
  do
  {
    if (!v50) {
      return 0;
    }
    unint64_t v51 = v50--;
  }
  while (*(unsigned char *)(v8 + v51) != 46);
  if (v51 < 2) {
    return 0;
  }
  if (a2 >= v50) {
    unint64_t v52 = v50;
  }
  else {
    unint64_t v52 = a2;
  }
  long long v53 = (int *)(a1 + v52);
  if (a2 - v52 == 4)
  {
    if (*v53 != 2020897070) {
      return 0;
    }
    if (a2 >= v50) {
      unint64_t v63 = v50;
    }
    else {
      unint64_t v63 = a2;
    }
    unint64_t v64 = v63 - 1;
    do
    {
      if (v64 == -1) {
        return (char *)a1;
      }
      int v65 = *(unsigned __int8 *)(a1 + v64--);
    }
    while (v65 != 47);
    unint64_t v59 = v64 + 2;
LABEL_148:
    if (a2 < v59) {
      unint64_t v59 = a2;
    }
    return (char *)(a1 + v59);
  }
  else
  {
    if (a2 - v52 != 6) {
      return 0;
    }
    int v54 = *v53;
    int v55 = *((unsigned __int16 *)v53 + 2);
    if (v54 != 1819894830 || v55 != 25193) {
      return 0;
    }
    if (v50 >= 3)
    {
      unint64_t v57 = v50 - 1;
      if (a2 >= v50 - 2) {
        unint64_t v58 = v50 - 2;
      }
      else {
        unint64_t v58 = a2;
      }
      if (v58 > v57) {
        unint64_t v57 = v58;
      }
      if (a2 < v57) {
        unint64_t v57 = a2;
      }
      if (v57 - v58 == 1)
      {
        if (*(unsigned char *)(a1 + v58) == 46) {
          v50 -= 2;
        }
        if (a2 >= v50) {
          unint64_t v52 = v50;
        }
        else {
          unint64_t v52 = a2;
        }
      }
    }
    do
    {
      unint64_t v59 = v52;
      if (!v52) {
        break;
      }
      --v52;
    }
    while (*(unsigned char *)(v8 + v59) != 47);
    do
    {
      if (!v9) {
        goto LABEL_148;
      }
      unint64_t v60 = v9 - 1;
      int v61 = *(unsigned __int8 *)(v8 + v9--);
    }
    while (v61 != 95);
    if (v59 == v60) {
      goto LABEL_148;
    }
    if (a2 < v59) {
      unint64_t v59 = a2;
    }
    uint64_t v12 = (char *)(a1 + v59);
    if (a2 >= v60) {
      unint64_t v66 = v60;
    }
    else {
      unint64_t v66 = a2;
    }
    if (v66 <= v50) {
      unint64_t v67 = v50;
    }
    else {
      unint64_t v67 = v66;
    }
    if (a2 >= v67) {
      unint64_t v68 = v67;
    }
    else {
      unint64_t v68 = a2;
    }
    uint64_t v69 = (int *)(a1 + v66);
    unint64_t v70 = v68 - v66;
    *a4 = v69;
    a4[1] = v70;
    if (v70 == 8)
    {
      if (*(void *)v69 == 0x656C69666F72705FLL) {
        return v12;
      }
      goto LABEL_172;
    }
    if (v70 != 6
      || ((int v71 = *v69, v72 = *((unsigned __int16 *)v69 + 2), v71 == 1650811999) ? (v73 = v72 == 26485) : (v73 = 0), !v73))
    {
LABEL_172:
      *a4 = 0;
      a4[1] = 0;
    }
  }
  return v12;
}

unint64_t llvm::object::MachOObjectFile::getLibraryShortName(llvm::object::MachOObjectFile *this, llvm::StringRef *a2)
{
  v12[0] = 0;
  v12[1] = 0;
  uint64_t LibraryName = llvm::object::MachOObjectFile::getLibraryName(this, a2);
  uint64_t v4 = LibraryName;
  if (LibraryName)
  {
    unsigned int v5 = LibraryName;
  }
  else
  {
    v9[0] = llvm::object::MachOObjectFile::guessLibraryShortName(0, 0, &v11, &v10);
    v9[1] = v6;
    uint64_t v7 = v9;
    if (!v6) {
      uint64_t v7 = v12;
    }
    *(_OWORD *)a2 = *(_OWORD *)v7;
    std::system_category();
    unsigned int v5 = 0;
  }
  return v4 & 0xFFFFFFFF00000000 | v5;
}

uint64_t llvm::object::MachOObjectFile::getLibraryName(llvm::object::MachOObjectFile *this, llvm::StringRef *a2)
{
  uint64_t v2 = *((unsigned int *)this + 34);
  if (!v2) {
    goto LABEL_10;
  }
  uint64_t v4 = *((void *)this + 16);
  uint64_t v5 = 16 * v2;
  while (*(_DWORD *)(v4 + 8) != 13)
  {
    v4 += 16;
    v5 -= 16;
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_1CCC530A4((uint64_t)&v10, (uint64_t)this, *(long long **)v4);
  uint64_t v6 = *(long long **)v4;
  uint64_t v7 = (const char *)(*(void *)v4 + v11);
  this = v6 ? (llvm::object::MachOObjectFile *)strlen(v7) : 0;
  if ((unint64_t)this + v11 <= HIDWORD(v10))
  {
    *(void *)a2 = v7;
    *((void *)a2 + 1) = this;
    std::system_category();
    return 0;
  }
  else
  {
LABEL_10:
    uint64_t v8 = 3;
    llvm::object::object_category(this);
  }
  return v8;
}

uint64_t llvm::object::MachOObjectFile::end_load_commands(llvm::object::MachOObjectFile *this)
{
  return *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
}

double llvm::object::MachOObjectFile::getDylibIDLoadCommand@<D0>(uint64_t a1@<X0>, long long **a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CCC530A4(a3, a1, *a2);
}

uint64_t llvm::object::MachOObjectFile::getLibraryShortNameByIndex(llvm::object::MachOObjectFile *this, unsigned int a2, llvm::StringRef *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 28) <= a2)
  {
    uint64_t v7 = 3;
    llvm::object::object_category(this);
  }
  else
  {
    uint64_t v6 = (void *)((char *)this + 232);
    if (*((_DWORD *)this + 60))
    {
LABEL_3:
      *(_OWORD *)a3 = *(_OWORD *)(*v6 + 16 * a2);
      std::system_category();
      return 0;
    }
    else
    {
      uint64_t v8 = 0;
      while (1)
      {
        unint64_t v9 = (llvm::object *)sub_1CCC560B8((uint64_t)&v21, (uint64_t)this, *(void *)(*((void *)this + 13) + 8 * v8));
        if (v23) {
          break;
        }
        if (v22 >= HIDWORD(v21)
          || ((uint64_t v10 = *(void *)(*((void *)this + 13) + 8 * v8), v11 = v10 + v22, !v10)
            ? (unint64_t v12 = 0)
            : (unint64_t v9 = (llvm::object *)strlen((const char *)(v10 + v22)), v12 = (unint64_t)v9),
              v12 + v22 >= HIDWORD(v21)))
        {
          llvm::object::object_category(v9);
          return 3;
        }
        unint64_t v13 = llvm::object::MachOObjectFile::guessLibraryShortName(v11, v12, &v19, &v20);
        unint64_t v15 = *((unsigned int *)this + 60);
        unint64_t v16 = *((unsigned int *)this + 61);
        if (v14)
        {
          if (v15 >= v16) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          size_t v17 = (void *)(*v6 + 16 * v15);
          *size_t v17 = v13;
          unint64_t v12 = v14;
        }
        else
        {
          if (v15 >= v16) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          size_t v17 = (void *)(*v6 + 16 * v15);
          *size_t v17 = v11;
        }
        v17[1] = v12;
        ++*((_DWORD *)this + 60);
        if (++v8 >= (unint64_t)*((unsigned int *)this + 28)) {
          goto LABEL_3;
        }
      }
      llvm::object::object_category(v9);
      if (v21) {
        (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
      }
      return 3;
    }
  }
  return v7;
}

uint64_t sub_1CCC560B8(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > a3 || a3 + 24 > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v10 = "Structure read out-of-range";
    __int16 v11 = 259;
    sub_1CCC51CE4((uint64_t)&v12, (uint64_t *)&v10);
  }
  int8x16_t v5 = *(int8x16_t *)a3;
  int8x8_t v6 = *(int8x8_t *)(a3 + 16);
  unsigned int v7 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v7 > 0x13;
  int v8 = (1 << v7) & 0xAAC00;
  if (!v4 && v8 != 0)
  {
    int8x16_t v5 = vrev32q_s8(v5);
    int8x8_t v6 = vrev32_s8(v6);
  }
  *(unsigned char *)(result + 24) &= ~1u;
  *(int8x16_t *)uint64_t result = v5;
  *(int8x8_t *)(result + ++*(_DWORD *)(this + 16) = v6;
  return result;
}

uint64_t llvm::object::MachOObjectFile::getLibraryNameByIndex(llvm::object::MachOObjectFile *this, unsigned int a2, llvm::StringRef *a3)
{
  if (*((_DWORD *)this + 28) <= a2) {
    goto LABEL_8;
  }
  BOOL v4 = this;
  uint64_t v5 = a2;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  sub_1CCC530A4((uint64_t)&v10, (uint64_t)this, *(long long **)(*((void *)this + 13) + 8 * a2));
  if (v11 >= HIDWORD(v10)) {
    goto LABEL_8;
  }
  uint64_t v6 = *(void *)(*((void *)v4 + 13) + 8 * v5);
  uint64_t v7 = v6 + v11;
  this = v6 ? (llvm::object::MachOObjectFile *)strlen((const char *)(v6 + v11)) : 0;
  if ((unint64_t)this + v11 >= HIDWORD(v10))
  {
LABEL_8:
    uint64_t v8 = 3;
    llvm::object::object_category(this);
  }
  else
  {
    *(void *)a3 = v7;
    *((void *)a3 + 1) = this;
    std::system_category();
    return 0;
  }
  return v8;
}

uint64_t llvm::object::MachOObjectFile::getLibraryCount(llvm::object::MachOObjectFile *this)
{
  return *((unsigned int *)this + 28);
}

uint64_t llvm::object::MachOObjectFile::getRelocationRelocatedSection(uint64_t a1, unsigned int a2)
{
  return a2;
}

uint64_t llvm::object::MachOObjectFile::section_begin(llvm::object::MachOObjectFile *this)
{
  return 0;
}

uint64_t llvm::object::MachOObjectFile::section_end(llvm::object::MachOObjectFile *this)
{
  return *((unsigned int *)this + 22);
}

llvm::Triple *llvm::object::MachOObjectFile::getArchTriple@<X0>(llvm::Triple *this@<X0>, const char **a2@<X3>, unsigned int a3@<W1>, void *a4@<X2>, llvm::Triple *a5@<X8>)
{
  if (a4) {
    *a4 = 0;
  }
  if (a2) {
    *a2 = 0;
  }
  if ((int)this <= 22)
  {
    if (this == 7)
    {
      int v9 = a3 & 0xFFFFFF;
      if ((a3 & 0xFFFFFF) == 5)
      {
        if (a2) {
          *a2 = "i586";
        }
        uint64_t v6 = "i586-apple-darwin";
        goto LABEL_552;
      }
      if (v9 == 4)
      {
        if (a2) {
          *a2 = "i486";
        }
        uint64_t v6 = "i486-apple-darwin";
        goto LABEL_552;
      }
      if (v9 == 3)
      {
        if (a2) {
          *a2 = "i386";
        }
        uint64_t v6 = "i386-apple-darwin";
        goto LABEL_552;
      }
    }
    else
    {
      if (this == 12)
      {
        switch(a3 & 0xFFFFFF)
        {
          case 5u:
            if (a2) {
              *a2 = "armv4t";
            }
            uint64_t v6 = "armv4t-apple-darwin";
            goto LABEL_552;
          case 6u:
            if (a2) {
              *a2 = "armv6";
            }
            uint64_t v6 = "armv6-apple-darwin";
            goto LABEL_552;
          case 7u:
            if (a2) {
              *a2 = "armv5e";
            }
            uint64_t v6 = "armv5e-apple-darwin";
            goto LABEL_552;
          case 8u:
            if (a2) {
              *a2 = "xscale";
            }
            uint64_t v6 = "xscale-apple-darwin";
            goto LABEL_552;
          case 9u:
            if (a2) {
              *a2 = "armv7";
            }
            uint64_t v6 = "armv7-apple-darwin";
            goto LABEL_552;
          case 0xBu:
            if (a4) {
              *a4 = "cortex-a7";
            }
            if (a2) {
              *a2 = "armv7s";
            }
            uint64_t v6 = "armv7s-apple-darwin";
            goto LABEL_552;
          case 0xCu:
            if (a4) {
              *a4 = "cortex-a7";
            }
            if (a2) {
              *a2 = "armv7k";
            }
            uint64_t v6 = "armv7k-apple-darwin";
            goto LABEL_552;
          case 0xEu:
            if (a4) {
              *a4 = "cortex-m0";
            }
            if (a2) {
              *a2 = "armv6m";
            }
            uint64_t v6 = "armv6m-apple-darwin";
            goto LABEL_552;
          case 0xFu:
            if (a4) {
              *a4 = "cortex-m3";
            }
            if (a2) {
              *a2 = "armv7m";
            }
            uint64_t v6 = "thumbv7m-apple-darwin";
            goto LABEL_552;
          case 0x10u:
            if (a4) {
              *a4 = "cortex-m4";
            }
            if (a2) {
              *a2 = "armv7em";
            }
            uint64_t v6 = "thumbv7em-apple-darwin";
            goto LABEL_552;
          default:
            goto LABEL_248;
        }
      }
      if (this == 18 && (a3 & 0xFFFFFF) == 0)
      {
        if (a2) {
          *a2 = "ppc";
        }
        uint64_t v6 = "ppc-apple-darwin";
        goto LABEL_552;
      }
    }
LABEL_248:
    *((_OWORD *)a5 + 1) = 0u;
    *((_OWORD *)a5 + 2) = 0u;
    *(_OWORD *)a5 = 0u;
    return this;
  }
  switch((int)this)
  {
    case 16777223:
      if ((a3 & 0xFFFFFF) == 8)
      {
        if (a2) {
          *a2 = "x86_64h";
        }
        uint64_t v6 = "x86_64h-apple-darwin";
      }
      else
      {
        if ((a3 & 0xFFFFFF) != 3) {
          goto LABEL_248;
        }
        if (a2) {
          *a2 = "x86_64";
        }
        uint64_t v6 = "x86_64-apple-darwin";
      }
      break;
    case 16777224:
    case 16777225:
    case 16777226:
    case 16777227:
    case 16777229:
    case 16777230:
    case 16777231:
    case 16777232:
    case 16777233:
      goto LABEL_248;
    case 16777228:
      if ((a3 & 0xFFFFFF) == 2)
      {
        if (a4) {
          *a4 = "apple-a12";
        }
        if (a2) {
          *a2 = "arm64e";
        }
        uint64_t v6 = "arm64e-apple-darwin";
      }
      else
      {
        if ((a3 & 0xFFFFFF) != 0) {
          goto LABEL_248;
        }
        if (a4) {
          *a4 = "cyclone";
        }
        if (a2) {
          *a2 = "arm64";
        }
        uint64_t v6 = "arm64-apple-darwin";
      }
      break;
    case 16777234:
      if ((a3 & 0xFFFFFF) != 0) {
        goto LABEL_248;
      }
      if (a2) {
        *a2 = "ppc64";
      }
      uint64_t v6 = "ppc64-apple-darwin";
      break;
    case 16777235:
      switch(a3 & 0xF)
      {
        case 0u:
          int v10 = (a3 >> 4);
          if (v10 == 2)
          {
            if (a4) {
              *a4 = "gx2-b0";
            }
            if (a2) {
              *a2 = "applegpu_gx2";
            }
            uint64_t v6 = "applegpu_gx2-apple-ios";
          }
          else if (v10 == 1)
          {
            if (a4) {
              *a4 = "gx2-a0";
            }
            if (a2) {
              *a2 = "gx2_a0";
            }
            uint64_t v6 = "gx2_a0-apple-ios";
          }
          else
          {
            uint64_t v6 = "agx0-apple-ios";
          }
          goto LABEL_552;
        case 1u:
          switch((a3 >> 4))
          {
            case 1u:
              if (a4) {
                *a4 = "g4p-b1";
              }
              if (a2) {
                *a2 = "applegpu_g4p";
              }
              uint64_t v6 = "applegpu_g4p-apple-ios";
              break;
            case 2u:
              if (a4) {
                *a4 = "g4g-a0";
              }
              if (a2) {
                *a2 = "g4g_a0";
              }
              uint64_t v6 = "g4g_a0-apple-ios";
              break;
            case 3u:
              if (a4) {
                *a4 = "g4g-a1";
              }
              if (a2) {
                *a2 = "applegpu_g4g";
              }
              uint64_t v6 = "applegpu_g4g-apple-ios";
              break;
            case 4u:
              if (a4) {
                *a4 = "g5p-c0";
              }
              if (a2) {
                *a2 = "applegpu_g5p";
              }
              uint64_t v6 = "applegpu_g5p-apple-ios";
              break;
            case 5u:
              if (a4) {
                *a4 = "g9p-a0";
              }
              if (a2) {
                *a2 = "applegpu_g9p";
              }
              uint64_t v6 = "applegpu_g9p-apple-ios";
              break;
            case 6u:
              if (a4) {
                *a4 = "g9g-a0";
              }
              if (a2) {
                *a2 = "applegpu_g9g";
              }
              uint64_t v6 = "applegpu_g9g-apple-ios";
              break;
            default:
              uint64_t v6 = "agx1-apple-ios";
              break;
          }
          goto LABEL_552;
        case 2u:
          switch((a3 >> 4))
          {
            case 2u:
              if (a4) {
                *a4 = "g10p-b0";
              }
              if (a2) {
                *a2 = "applegpu_g10p";
              }
              uint64_t v6 = "applegpu_g10p-apple-ios";
              break;
            case 3u:
            case 0xAu:
            case 0xBu:
            case 0xEu:
            case 0xFu:
            case 0x10u:
            case 0x15u:
            case 0x1Cu:
            case 0x1Du:
              goto LABEL_416;
            case 4u:
              if (a4) {
                *a4 = "g11m-a0";
              }
              if (a2) {
                *a2 = "g11m_a0";
              }
              uint64_t v6 = "g11m_a0-apple-ios";
              break;
            case 5u:
              if (a4) {
                *a4 = "g11m-b0";
              }
              if (a2) {
                *a2 = "applegpu_g11m";
              }
              uint64_t v6 = "applegpu_g11m-apple-ios";
              break;
            case 6u:
              if (a4) {
                *a4 = "g11p-a0";
              }
              if (a2) {
                *a2 = "g11p_a0";
              }
              uint64_t v6 = "g11p_a0-apple-ios";
              break;
            case 7u:
              if (a4) {
                *a4 = "g11p-b0";
              }
              if (a2) {
                *a2 = "applegpu_g11p";
              }
              uint64_t v6 = "applegpu_g11p-apple-ios";
              break;
            case 8u:
              if (a4) {
                *a4 = "g11g-a0";
              }
              if (a2) {
                *a2 = "g11g_a0";
              }
              uint64_t v6 = "g11g_a0-apple-ios";
              break;
            case 9u:
              if (a4) {
                *a4 = "g11g-b0";
              }
              if (a2) {
                *a2 = "applegpu_g11g";
              }
              uint64_t v6 = "applegpu_g11g-apple-ios";
              break;
            case 0xCu:
              if (a4) {
                *a4 = "g12p-a0";
              }
              if (a2) {
                *a2 = "g12p_a0";
              }
              uint64_t v6 = "g12p_a0-apple-ios";
              break;
            case 0xDu:
              if (a4) {
                *a4 = "g12p-b0";
              }
              if (a2) {
                *a2 = "applegpu_g12p";
              }
              uint64_t v6 = "applegpu_g12p-apple-ios";
              break;
            case 0x11u:
              if (a4) {
                *a4 = "g13p-a0";
              }
              if (a2) {
                *a2 = "g13p_a0";
              }
              uint64_t v6 = "g13p_a0-apple-ios";
              break;
            case 0x12u:
              if (a4) {
                *a4 = "g13p-b0";
              }
              if (a2) {
                *a2 = "applegpu_g13p";
              }
              uint64_t v6 = "applegpu_g13p-apple-ios";
              break;
            case 0x13u:
              if (a4) {
                *a4 = "g13g-a0";
              }
              if (a2) {
                *a2 = "g13g_a0";
              }
              uint64_t v6 = "g13g_a0-apple-ios";
              break;
            case 0x14u:
              if (a4) {
                *a4 = "g13g-b0";
              }
              if (a2) {
                *a2 = "applegpu_g13g";
              }
              uint64_t v6 = "applegpu_g13g-apple-ios";
              break;
            case 0x16u:
              if (a4) {
                *a4 = "g14p-a0";
              }
              if (a2) {
                *a2 = "g14p_a0";
              }
              uint64_t v6 = "g14p_a0-apple-ios";
              break;
            case 0x17u:
              if (a4) {
                *a4 = "g14p-b0";
              }
              if (a2) {
                *a2 = "applegpu_g14p";
              }
              uint64_t v6 = "applegpu_g14p-apple-ios";
              break;
            case 0x18u:
              if (a4) {
                *a4 = "g14g-a0";
              }
              if (a2) {
                *a2 = "g14g_a0";
              }
              uint64_t v6 = "g14g_a0-apple-ios";
              break;
            case 0x19u:
              if (a4) {
                *a4 = "g14g-b0";
              }
              if (a2) {
                *a2 = "applegpu_g14g";
              }
              uint64_t v6 = "applegpu_g14g-apple-ios";
              break;
            case 0x1Au:
              if (a4) {
                *a4 = "g14s-a0";
              }
              if (a2) {
                *a2 = "g14s_a0";
              }
              uint64_t v6 = "g14s_a0-apple-ios";
              break;
            case 0x1Bu:
              if (a4) {
                *a4 = "g14s-b0";
              }
              if (a2) {
                *a2 = "applegpu_g14s";
              }
              uint64_t v6 = "applegpu_g14s-apple-ios";
              break;
            case 0x1Eu:
              if (a4) {
                *a4 = "g14d-a0";
              }
              if (a2) {
                *a2 = "g14d_a0";
              }
              uint64_t v6 = "g14d_a0-apple-ios";
              break;
            case 0x1Fu:
              if (a4) {
                *a4 = "g14d-b0";
              }
              if (a2) {
                *a2 = "applegpu_g14d";
              }
              uint64_t v6 = "applegpu_g14d-apple-ios";
              break;
            case 0x20u:
              if (a4) {
                *a4 = "g13s-a0";
              }
              if (a2) {
                *a2 = "g13s_a0";
              }
              uint64_t v6 = "g13s_a0-apple-ios";
              break;
            case 0x21u:
              if (a4) {
                *a4 = "g13s-b0";
              }
              if (a2) {
                *a2 = "applegpu_g13s";
              }
              uint64_t v6 = "applegpu_g13s-apple-ios";
              break;
            case 0x22u:
              if (a4) {
                *a4 = "g13c-a0";
              }
              if (a2) {
                *a2 = "g13c_a0";
              }
              uint64_t v6 = "g13c_a0-apple-ios";
              break;
            case 0x23u:
              if (a4) {
                *a4 = "g13c-b0";
              }
              if (a2) {
                *a2 = "applegpu_g13c";
              }
              uint64_t v6 = "applegpu_g13c-apple-ios";
              break;
            case 0x24u:
              if (a4) {
                *a4 = "g13d-a0";
              }
              if (a2) {
                *a2 = "g13d_a0";
              }
              uint64_t v6 = "g13d_a0-apple-ios";
              break;
            case 0x25u:
              if (a4) {
                *a4 = "g13d-b0";
              }
              if (a2) {
                *a2 = "applegpu_g13d";
              }
              uint64_t v6 = "applegpu_g13d-apple-ios";
              break;
            case 0x26u:
              if (a4) {
                *a4 = "g15p-b0";
              }
              if (a2) {
                *a2 = "applegpu_g15p";
              }
              uint64_t v6 = "applegpu_g15p-apple-ios";
              break;
            default:
              if ((a3 >> 4) == 100)
              {
                if (a4) {
                  *a4 = "g11g-a0";
                }
                if (a2) {
                  *a2 = "applegpu_g11g_8fstp";
                }
                uint64_t v6 = "applegpu_g11g_8fstp-apple-ios";
              }
              else
              {
LABEL_416:
                uint64_t v6 = "agx2-apple-ios";
              }
              break;
          }
          goto LABEL_552;
        case 3u:
          switch((a3 >> 4))
          {
            case 4u:
              if (a4) {
                *a4 = "g15g-a0";
              }
              if (a2) {
                *a2 = "g15g_a0";
              }
              uint64_t v6 = "g15g_a0-apple-ios";
              break;
            case 5u:
              if (a4) {
                *a4 = "g15g-b0";
              }
              if (a2) {
                *a2 = "g15g_b0";
              }
              uint64_t v6 = "g15g_b0-apple-ios";
              break;
            case 6u:
              if (a4) {
                *a4 = "g15s-a0";
              }
              if (a2) {
                *a2 = "g15s_a0";
              }
              uint64_t v6 = "g15s_a0-apple-ios";
              break;
            case 7u:
              if (a4) {
                *a4 = "g15s-b0";
              }
              if (a2) {
                *a2 = "g15s_b0";
              }
              uint64_t v6 = "g15s_b0-apple-ios";
              break;
            case 0xEu:
              if (a4) {
                *a4 = "g16p-a0";
              }
              if (a2) {
                *a2 = "g16p_a0";
              }
              uint64_t v6 = "g16p_a0-apple-ios";
              break;
            case 0xFu:
              if (a4) {
                *a4 = "g16p-b0";
              }
              if (a2) {
                *a2 = "g16p_b0";
              }
              uint64_t v6 = "g16p_b0-apple-ios";
              break;
            case 0x10u:
              if (a4) {
                *a4 = "g16g-a0";
              }
              if (a2) {
                *a2 = "g16g_a0";
              }
              uint64_t v6 = "g16g_a0-apple-ios";
              break;
            case 0x11u:
              if (a4) {
                *a4 = "g15g-c0";
              }
              if (a2) {
                *a2 = "applegpu_g15g";
              }
              uint64_t v6 = "applegpu_g15g-apple-ios";
              break;
            case 0x12u:
              if (a4) {
                *a4 = "g16s-a0";
              }
              if (a2) {
                *a2 = "g16s_a0";
              }
              uint64_t v6 = "g16s_a0-apple-ios";
              break;
            case 0x14u:
              if (a4) {
                *a4 = "g17p-a0";
              }
              if (a2) {
                *a2 = "applegpu_g17p";
              }
              uint64_t v6 = "applegpu_g17p-apple-ios";
              break;
            case 0x19u:
              if (a4) {
                *a4 = "g16g-b0";
              }
              if (a2) {
                *a2 = "applegpu_g16g";
              }
              uint64_t v6 = "applegpu_g16g-apple-ios";
              break;
            case 0x1Au:
              if (a4) {
                *a4 = "g15s-b1";
              }
              if (a2) {
                *a2 = "applegpu_g15s";
              }
              uint64_t v6 = "applegpu_g15s-apple-ios";
              break;
            case 0x1Bu:
              if (a4) {
                *a4 = "g16p-b1";
              }
              if (a2) {
                *a2 = "applegpu_g16p";
              }
              uint64_t v6 = "applegpu_g16p-apple-ios";
              break;
            case 0x1Du:
              if (a4) {
                *a4 = "g16s-b0";
              }
              if (a2) {
                *a2 = "applegpu_g16s";
              }
              uint64_t v6 = "applegpu_g16s-apple-ios";
              break;
            default:
              uint64_t v6 = "agx3-apple-ios";
              break;
          }
          goto LABEL_552;
        default:
          goto LABEL_248;
      }
    case 16777236:
      int v11 = a3 & 0xFFFFFF;
      if ((a3 & 0xFFFFFF) <= 0x1388)
      {
        switch(v11)
        {
          case 4000:
            if (a2) {
              *a2 = "amdgpu_gfx600";
            }
            uint64_t v6 = "amdgpu_gfx600-apple-darwin";
            goto LABEL_552;
          case 4001:
            if (a2) {
              *a2 = "amdgpu_gfx600_nwh";
            }
            uint64_t v6 = "amdgpu_gfx600_nwh-apple-darwin";
            goto LABEL_552;
          case 4002:
            if (a2) {
              *a2 = "amdgpu_gfx701";
            }
            uint64_t v6 = "amdgpu_gfx701-apple-darwin";
            goto LABEL_552;
          case 4003:
            if (a2) {
              *a2 = "amdgpu_gfx704";
            }
            uint64_t v6 = "amdgpu_gfx704-apple-darwin";
            goto LABEL_552;
          case 4004:
            if (a2) {
              *a2 = "amdgpu_gfx803";
            }
            uint64_t v6 = "amdgpu_gfx803-apple-darwin";
            goto LABEL_552;
          case 4005:
            if (a2) {
              *a2 = "amdgpu_gfx802";
            }
            uint64_t v6 = "amdgpu_gfx802-apple-darwin";
            goto LABEL_552;
          default:
            if (v11 != 5000) {
              goto LABEL_248;
            }
            if (a2) {
              *a2 = "amdgpu_gfx900";
            }
            uint64_t v6 = "amdgpu_gfx900-apple-darwin";
            break;
        }
      }
      else
      {
        switch(v11)
        {
          case 6000:
            if (a2) {
              *a2 = "amdgpu_gfx1010_nsgc";
            }
            uint64_t v6 = "amdgpu_gfx1010_nsgc-apple-darwin";
            goto LABEL_552;
          case 6001:
            if (a2) {
              *a2 = "amdgpu_gfx1010";
            }
            uint64_t v6 = "amdgpu_gfx1010-apple-darwin";
            goto LABEL_552;
          case 6002:
            if (a2) {
              *a2 = "amdgpu_gfx1011";
            }
            uint64_t v6 = "amdgpu_gfx1011-apple-darwin";
            goto LABEL_552;
          case 6003:
            if (a2) {
              *a2 = "amdgpu_gfx1012";
            }
            uint64_t v6 = "amdgpu_gfx1012-apple-darwin";
            goto LABEL_552;
          case 6004:
            if (a2) {
              *a2 = "amdgpu_gfx1030";
            }
            uint64_t v6 = "amdgpu_gfx1030-apple-darwin";
            goto LABEL_552;
          case 6005:
            if (a2) {
              *a2 = "amdgpu_gfx1032";
            }
            uint64_t v6 = "amdgpu_gfx1032-apple-darwin";
            goto LABEL_552;
          default:
            if (v11 == 5001)
            {
              if (a2) {
                *a2 = "amdgpu_gfx904";
              }
              uint64_t v6 = "amdgpu_gfx904-apple-darwin";
            }
            else
            {
              if (v11 != 5002) {
                goto LABEL_248;
              }
              if (a2) {
                *a2 = "amdgpu_gfx906";
              }
              uint64_t v6 = "amdgpu_gfx906-apple-darwin";
            }
            break;
        }
      }
      break;
    case 16777237:
      int v12 = a3 & 0xFFFFFF;
      if ((a3 & 0xFFFFFF) > 0x9501FF)
      {
        if ((a3 & 0xFFFFFF) <= 0x950203)
        {
          if (v12 == 9765376)
          {
            if (a2) {
              *a2 = "intelgpu_kbl_gt2r0";
            }
            uint64_t v6 = "intelgpu_kbl_gt2r0-apple-darwin";
          }
          else
          {
            if (v12 != 9765378) {
              goto LABEL_248;
            }
            if (a2) {
              *a2 = "intelgpu_kbl_gt2r2";
            }
            uint64_t v6 = "intelgpu_kbl_gt2r2-apple-darwin";
          }
        }
        else
        {
          switch(v12)
          {
            case 9765380:
              if (a2) {
                *a2 = "intelgpu_kbl_gt2r4";
              }
              uint64_t v6 = "intelgpu_kbl_gt2r4-apple-darwin";
              break;
            case 9765633:
              if (a2) {
                *a2 = "intelgpu_kbl_gt3r1";
              }
              uint64_t v6 = "intelgpu_kbl_gt3r1-apple-darwin";
              break;
            case 9765638:
              if (a2) {
                *a2 = "intelgpu_kbl_gt3r6";
              }
              uint64_t v6 = "intelgpu_kbl_gt3r6-apple-darwin";
              break;
            default:
              goto LABEL_248;
          }
        }
      }
      else if ((a3 & 0xFFFFFF) <= 0x90309)
      {
        if (v12 == 590342)
        {
          if (a2) {
            *a2 = "intelgpu_skl_gt2r6";
          }
          uint64_t v6 = "intelgpu_skl_gt2r6-apple-darwin";
        }
        else
        {
          if (v12 != 590343) {
            goto LABEL_248;
          }
          if (a2) {
            *a2 = "intelgpu_skl_gt2r7";
          }
          uint64_t v6 = "intelgpu_skl_gt2r7-apple-darwin";
        }
      }
      else
      {
        switch(v12)
        {
          case 590602:
            if (a2) {
              *a2 = "intelgpu_skl_gt3r10";
            }
            uint64_t v6 = "intelgpu_skl_gt3r10-apple-darwin";
            break;
          case 1115655:
            if (a2) {
              *a2 = "intelgpu_icl_1x6x8r7";
            }
            uint64_t v6 = "intelgpu_icl_1x6x8r7-apple-darwin";
            break;
          case 1116167:
            if (a2) {
              *a2 = "intelgpu_icl_1x8x8r7";
            }
            uint64_t v6 = "intelgpu_icl_1x8x8r7-apple-darwin";
            break;
          default:
            goto LABEL_248;
        }
      }
      break;
    case 16777238:
      switch(a3 & 0xFFFFFF)
      {
        case 1u:
          if (a2) {
            *a2 = "nvidiagpu_gk";
          }
          uint64_t v6 = "nvidiagpu_gk-apple-darwin";
          goto LABEL_552;
        case 2u:
          if (a2) {
            *a2 = "nvidiagpu_gm";
          }
          uint64_t v6 = "nvidiagpu_gm-apple-darwin";
          goto LABEL_552;
        case 3u:
          if (a2) {
            *a2 = "nvidiagpu_gp";
          }
          uint64_t v6 = "nvidiagpu_gp-apple-darwin";
          goto LABEL_552;
        case 4u:
          if (a2) {
            *a2 = "nvidiagpu_gv";
          }
          uint64_t v6 = "nvidiagpu_gv-apple-darwin";
          goto LABEL_552;
        default:
          goto LABEL_248;
      }
    case 16777239:
      goto LABEL_27;
    default:
      if (this == 23)
      {
LABEL_27:
        switch(a3 & 0xFFFFFF)
        {
          case 1u:
            if (a2)
            {
              uint64_t v7 = "air64_v16";
              if (this == 23) {
                uint64_t v7 = "air32_v16";
              }
              *a2 = v7;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v16-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v16-apple-darwin";
            }
            break;
          case 2u:
            if (a2)
            {
              unint64_t v13 = "air64_v18";
              if (this == 23) {
                unint64_t v13 = "air32_v18";
              }
              *a2 = v13;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v18-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v18-apple-darwin";
            }
            break;
          case 3u:
            if (a2)
            {
              unint64_t v14 = "air64_v111";
              if (this == 23) {
                unint64_t v14 = "air32_v111";
              }
              *a2 = v14;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v111-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v111-apple-darwin";
            }
            break;
          case 4u:
            if (a2)
            {
              unint64_t v15 = "air64_v20";
              if (this == 23) {
                unint64_t v15 = "air32_v20";
              }
              *a2 = v15;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v20-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v20-apple-darwin";
            }
            break;
          case 5u:
            if (a2)
            {
              unint64_t v16 = "air64_v21";
              if (this == 23) {
                unint64_t v16 = "air32_v21";
              }
              *a2 = v16;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v21-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v21-apple-darwin";
            }
            break;
          case 6u:
            if (a2)
            {
              size_t v17 = "air64_v22";
              if (this == 23) {
                size_t v17 = "air32_v22";
              }
              *a2 = v17;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v22-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v22-apple-darwin";
            }
            break;
          case 7u:
            if (a2)
            {
              BOOL v18 = "air64_v23";
              if (this == 23) {
                BOOL v18 = "air32_v23";
              }
              *a2 = v18;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v23-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v23-apple-darwin";
            }
            break;
          case 8u:
            if (a2)
            {
              char v19 = "air64_v24";
              if (this == 23) {
                char v19 = "air32_v24";
              }
              *a2 = v19;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v24-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v24-apple-darwin";
            }
            break;
          case 9u:
            if (a2)
            {
              uint64_t v20 = "air64_v25";
              if (this == 23) {
                uint64_t v20 = "air32_v25";
              }
              *a2 = v20;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v25-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v25-apple-darwin";
            }
            break;
          case 0xAu:
            if (a2)
            {
              uint64_t v21 = "air64_v26";
              if (this == 23) {
                uint64_t v21 = "air32_v26";
              }
              *a2 = v21;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v26-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v26-apple-darwin";
            }
            break;
          case 0xBu:
            if (a2)
            {
              unsigned int v22 = "air64_v27";
              if (this == 23) {
                unsigned int v22 = "air32_v27";
              }
              *a2 = v22;
            }
            HIBYTE(v24) = 1;
            if (this == 23) {
              uint64_t v8 = "air32_v27-apple-darwin";
            }
            else {
              uint64_t v8 = "air64_v27-apple-darwin";
            }
            break;
          default:
            goto LABEL_248;
        }
        char v23 = v8;
        LOBYTE(v24) = 3;
        return llvm::Triple::Triple(a5, (const llvm::Twine *)&v23);
      }
      if (this != 33554444 || (a3 & 0xFFFFFF) != 1) {
        goto LABEL_248;
      }
      if (a4) {
        *a4 = "apple-s4";
      }
      if (a2) {
        *a2 = "arm64_32";
      }
      uint64_t v6 = "arm64_32-apple-darwin";
      break;
  }
LABEL_552:
  char v23 = v6;
  __int16 v24 = 259;
  return llvm::Triple::Triple(a5, (const llvm::Twine *)&v23);
}

void llvm::object::MachOObjectFile::getHostArch(llvm::Triple *a1@<X8>)
{
  llvm::sys::getDefaultTargetTriple((uint64_t)__p);
  __int16 v6 = 260;
  uint64_t v5 = __p;
  llvm::Triple::Triple(a1, (const llvm::Twine *)&v5);
  if (v4 < 0) {
    operator delete(__p[0]);
  }
}

BOOL llvm::object::MachOObjectFile::isValidArch(void *__s2, char *__n)
{
  uint64_t v4 = 0;
  uint64_t v5 = &off_1E684EE28;
  while ((&off_1E684EE28)[v4 + 1] != __n)
  {
LABEL_5:
    v5 += 2;
    v4 += 2;
    if (v4 == 248)
    {
      uint64_t v5 = &off_1E684F5E8;
      return (char *)v5 - (char *)&off_1E684EE28 != 1984;
    }
  }
  if (__n)
  {
    if (!memcmp((&off_1E684EE28)[v4], __s2, (size_t)__n)) {
      return (char *)v5 - (char *)&off_1E684EE28 != 1984;
    }
    goto LABEL_5;
  }
  uint64_t v5 = &(&off_1E684EE28)[v4];
  return (char *)v5 - (char *)&off_1E684EE28 != 1984;
}

char **llvm::object::MachOObjectFile::getValidArchs(llvm::object::MachOObjectFile *this)
{
  return &off_1E684EE28;
}

llvm::Triple *llvm::object::MachOObjectFile::getArchTriple@<X0>(llvm::object::MachOObjectFile *this@<X0>, const char **a2@<X1>, llvm::Triple *a3@<X8>)
{
  return llvm::object::MachOObjectFile::getArchTriple((llvm::Triple *)*((unsigned int *)this + 13), 0, *((_DWORD *)this + 14), a2, a3);
}

void llvm::object::MachOObjectFile::getTargetTriple(llvm::object::MachOObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getArchTriple((llvm::Triple *)*((unsigned int *)this + 13), 0, *((_DWORD *)this + 14), 0, (llvm::Triple *)a2);
  if ((vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(*(int32x4_t *)(a2 + 24), *(int32x4_t *)(a2 + 24)))) & 1) == 0
    && !*(_DWORD *)(a2 + 40)
    && *(_DWORD *)(a2 + 44) == 0)
  {
    return;
  }
  uint64_t v5 = *((unsigned int *)this + 34);
  if (!v5) {
    return;
  }
  uint64_t v6 = *((void *)this + 16);
  uint64_t v7 = (_DWORD **)(v6 + 16 * v5);
  uint64_t v8 = (long long **)(v6 + 8);
  uint64_t v9 = 16 * v5;
  uint64_t v10 = v9;
  while (*(_DWORD *)v8 != 50)
  {
    v8 += 2;
    v10 -= 16;
    if (!v10)
    {
      int v11 = (unsigned int *)(v6 + 8);
      while (1)
      {
        unsigned int v12 = *v11;
        v11 += 4;
        uint64_t v13 = (1 << v12) & 0x1803000000000;
        if (v12 <= 0x30 && v13 != 0) {
          break;
        }
        v9 -= 16;
        if (!v9) {
          return;
        }
      }
      int v15 = sub_1CCC54354((uint64_t)this, *v7);
      __int16 v18 = v16;
      unint64_t v91 = (char *)v93;
      *((void *)&v92 + 1) = 16;
      if (v15 > 46)
      {
        if (v15 == 47)
        {
          v93[0] = 1936684660;
          uint64_t v19 = 4;
        }
        else
        {
          qmemcpy(v93, "watchos", 7);
          uint64_t v19 = 7;
        }
      }
      else if (v15 == 36)
      {
        qmemcpy(v93, "macos", 5);
        uint64_t v19 = 5;
      }
      else
      {
        qmemcpy(v93, "ios", 3);
        uint64_t v19 = 3;
      }
      *(void *)&long long v92 = v19;
      unint64_t v20 = HIBYTE(v16);
      unint64_t v21 = v17;
      if (v17)
      {
        unsigned int v22 = &v88.__r_.__value_.__s.__data_[21];
        do
        {
          *--unsigned int v22 = (v21 % 0xA) | 0x30;
          BOOL v23 = v21 > 9;
          v21 /= 0xAuLL;
        }
        while (v23);
      }
      else
      {
        unsigned int v22 = &v88.__r_.__value_.__s.__data_[20];
        v88.__r_.__value_.__s.__data_[20] = 48;
      }
      sub_1CC028D80(&v87, v22, &v88.__r_.__value_.__s.__data_[21], (char *)&v88.__r_.__value_.__r.__words[2] + 5 - v22);
      __int16 v24 = std::string::append(&v87, ".");
      std::string::size_type v25 = v24->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
      __dst.__r_.__value_.__r.__words[2] = v25;
      v24->__r_.__value_.__l.__size_ = 0;
      v24->__r_.__value_.__r.__words[2] = 0;
      v24->__r_.__value_.__r.__words[0] = 0;
      if (HIBYTE(v18))
      {
        unint64_t v26 = &v88.__r_.__value_.__s.__data_[21];
        do
        {
          *--unint64_t v26 = (v20 % 0xA) | 0x30;
          BOOL v23 = v20 > 9;
          v20 /= 0xAuLL;
        }
        while (v23);
      }
      else
      {
        unint64_t v26 = &v88.__r_.__value_.__s.__data_[20];
        v88.__r_.__value_.__s.__data_[20] = 48;
      }
      sub_1CC028D80(&__p, v26, &v88.__r_.__value_.__s.__data_[21], (char *)&v88.__r_.__value_.__r.__words[2] + 5 - v26);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      unint64_t v29 = std::string::append(&__dst, (const std::string::value_type *)p_p, size);
      std::string v88 = *v29;
      v29->__r_.__value_.__r.__words[0] = 0;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      int v30 = SHIBYTE(v88.__r_.__value_.__r.__words[2]);
      uint64_t v31 = (void *)v88.__r_.__value_.__r.__words[0];
      if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        int v32 = &v88;
      }
      else {
        int v32 = (std::string *)v88.__r_.__value_.__r.__words[0];
      }
      if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        size_t v33 = *((unsigned char *)&v88.__r_.__value_.__s + 23) & 0x7F;
      }
      else {
        size_t v33 = v88.__r_.__value_.__l.__size_;
      }
      uint64_t v34 = v92;
      if (*((void *)&v92 + 1) < (unint64_t)v92 + v33) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      if (v33)
      {
        memcpy(&v91[v92], v32, v33);
        uint64_t v34 = v92;
      }
      *(void *)&long long v92 = v34 + v33;
      if (v30 < 0) {
        operator delete(v31);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v87.__r_.__value_.__l.__data_);
      }
      unint64_t v35 = v18;
      if ((_BYTE)v18)
      {
        uint64_t v36 = 0;
        do
        {
          *((unsigned char *)&v88.__r_.__value_.__r.__words[2] + v36-- + 4) = (v35 % 0xA) | 0x30;
          BOOL v23 = v35 > 9;
          v35 /= 0xAuLL;
        }
        while (v23);
        sub_1CC028D80(&__dst, (char *)&v88.__r_.__value_.__r.__words[2] + v36 + 5, &v88.__r_.__value_.__s.__data_[21], -v36);
        uint64_t v37 = std::string::insert(&__dst, 0, ".");
        std::string v88 = *v37;
        v37->__r_.__value_.__r.__words[0] = 0;
        v37->__r_.__value_.__l.__size_ = 0;
        v37->__r_.__value_.__r.__words[2] = 0;
        int v38 = SHIBYTE(v88.__r_.__value_.__r.__words[2]);
        uint64_t v39 = (void *)v88.__r_.__value_.__r.__words[0];
        if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unint64_t v40 = &v88;
        }
        else {
          unint64_t v40 = (std::string *)v88.__r_.__value_.__r.__words[0];
        }
        if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v41 = *((unsigned char *)&v88.__r_.__value_.__s + 23) & 0x7F;
        }
        else {
          size_t v41 = v88.__r_.__value_.__l.__size_;
        }
        uint64_t v42 = v92;
        if (*((void *)&v92 + 1) < (unint64_t)v92 + v41) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        if (v41)
        {
          memcpy(&v91[v92], v40, v41);
          uint64_t v42 = v92;
        }
        *(void *)&long long v92 = v42 + v41;
        if (v38 < 0) {
          operator delete(v39);
        }
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
      }
      unint64_t v43 = v91;
      if (v91 != (char *)v93) {
        goto LABEL_75;
      }
      return;
    }
  }
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  uint64_t v83 = 0;
  sub_1CCC530A4((uint64_t)&v81, (uint64_t)this, *(v8 - 1));
  v88.__r_.__value_.__r.__words[0] = (std::string::size_type)v89;
  v88.__r_.__value_.__r.__words[2] = 16;
  switch((int)v82)
  {
    case 2:
      qmemcpy(v89, "ios", 3);
      std::string::size_type v44 = 3;
      break;
    case 3:
      int v45 = 1936684660;
      goto LABEL_82;
    case 4:
      qmemcpy(v89, "watchos", 7);
      std::string::size_type v44 = 7;
      break;
    case 5:
      *(void *)unint64_t v89 = 0x736F656764697262;
      std::string::size_type v44 = 8;
      break;
    case 6:
      qmemcpy(v89, "ios-macabi", 10);
      std::string::size_type v44 = 10;
      break;
    case 7:
      qmemcpy(v89, "ios-simulator", 13);
      std::string::size_type v44 = 13;
      break;
    case 8:
      unint64_t v46 = "tvos-simulator";
      goto LABEL_89;
    case 9:
      v88.__r_.__value_.__l.__size_ = 0;
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    case 10:
      __break(1u);
      JUMPOUT(0x1CCC58698);
    case 11:
      int v45 = 1936683640;
LABEL_82:
      *(_DWORD *)unint64_t v89 = v45;
      std::string::size_type v44 = 4;
      break;
    case 12:
      unint64_t v46 = "xros-simulator";
LABEL_89:
      *(void *)unint64_t v89 = *(void *)v46;
      *(void *)&v89[6] = *(void *)(v46 + 6);
      std::string::size_type v44 = 14;
      break;
    default:
      qmemcpy(v89, "macos", 5);
      std::string::size_type v44 = 5;
      break;
  }
  v88.__r_.__value_.__l.__size_ = v44;
  unsigned __int8 v47 = BYTE4(v82);
  unint64_t v48 = BYTE5(v82);
  unint64_t v91 = (char *)v93;
  long long v92 = xmmword_1CDC7F9D0;
  if (HIDWORD(v82) >= 0x10000)
  {
    unint64_t v50 = (unint64_t)HIDWORD(v82) >> 16;
    __int16 v49 = &__dst.__r_.__value_.__s.__data_[21];
    do
    {
      *--__int16 v49 = (v50 % 0xA) | 0x30;
      BOOL v23 = v50 > 9;
      v50 /= 0xAuLL;
    }
    while (v23);
  }
  else
  {
    __int16 v49 = &__dst.__r_.__value_.__s.__data_[20];
    __dst.__r_.__value_.__s.__data_[20] = 48;
  }
  sub_1CC028D80(&__p, v49, &__dst.__r_.__value_.__s.__data_[21], (char *)&__dst.__r_.__value_.__r.__words[2] + 5 - v49);
  unint64_t v51 = std::string::append(&__p, ".");
  std::string::size_type v52 = v51->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v87.__r_.__value_.__l.__data_ = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
  v87.__r_.__value_.__r.__words[2] = v52;
  v51->__r_.__value_.__l.__size_ = 0;
  v51->__r_.__value_.__r.__words[2] = 0;
  v51->__r_.__value_.__r.__words[0] = 0;
  if (v48)
  {
    long long v53 = &__dst.__r_.__value_.__s.__data_[21];
    do
    {
      *--long long v53 = (v48 % 0xA) | 0x30;
      BOOL v23 = v48 > 9;
      v48 /= 0xAuLL;
    }
    while (v23);
  }
  else
  {
    long long v53 = &__dst.__r_.__value_.__s.__data_[20];
    __dst.__r_.__value_.__s.__data_[20] = 48;
  }
  sub_1CC028D80(v84, v53, &__dst.__r_.__value_.__s.__data_[21], (char *)&__dst.__r_.__value_.__r.__words[2] + 5 - v53);
  if (v85 >= 0) {
    int v54 = v84;
  }
  else {
    int v54 = (void **)v84[0];
  }
  if (v85 >= 0) {
    std::string::size_type v55 = v85 & 0x7F;
  }
  else {
    std::string::size_type v55 = (std::string::size_type)v84[1];
  }
  long long v56 = std::string::append(&v87, (const std::string::value_type *)v54, v55);
  std::string __dst = *v56;
  v56->__r_.__value_.__r.__words[0] = 0;
  v56->__r_.__value_.__l.__size_ = 0;
  v56->__r_.__value_.__r.__words[2] = 0;
  int v57 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  unint64_t v58 = (void *)__dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v60 = *((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v60 = __dst.__r_.__value_.__l.__size_;
  }
  *(void *)&long long v92 = 0;
  if (*((void *)&v92 + 1) < v60) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v61 = 0;
  if (v60)
  {
    memcpy(v91, p_dst, v60);
    uint64_t v61 = v92;
  }
  *(void *)&long long v92 = v61 + v60;
  if (v57 < 0) {
    operator delete(v58);
  }
  if (v85 < 0) {
    operator delete(v84[0]);
  }
  unint64_t v62 = v47;
  if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v87.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v47)
  {
    uint64_t v63 = 0;
    do
    {
      __dst.__r_.__value_.__s.__data_[v63-- + 20] = (v62 % 0xA) | 0x30;
      BOOL v23 = v62 > 9;
      v62 /= 0xAuLL;
    }
    while (v23);
    sub_1CC028D80(&v87, &__dst.__r_.__value_.__s.__data_[v63 + 21], &__dst.__r_.__value_.__s.__data_[21], -v63);
    unint64_t v64 = std::string::insert(&v87, 0, ".");
    std::string __dst = *v64;
    v64->__r_.__value_.__r.__words[0] = 0;
    v64->__r_.__value_.__l.__size_ = 0;
    v64->__r_.__value_.__r.__words[2] = 0;
    int v65 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
    unint64_t v66 = (void *)__dst.__r_.__value_.__r.__words[0];
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      unint64_t v67 = &__dst;
    }
    else {
      unint64_t v67 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      size_t v68 = *((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x7F;
    }
    else {
      size_t v68 = __dst.__r_.__value_.__l.__size_;
    }
    uint64_t v69 = v92;
    if (*((void *)&v92 + 1) < (unint64_t)v92 + v68) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    if (v68)
    {
      memcpy(&v91[v92], v67, v68);
      uint64_t v69 = v92;
    }
    *(void *)&long long v92 = v69 + v68;
    if (v65 < 0) {
      operator delete(v66);
    }
    if (SHIBYTE(v87.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v87.__r_.__value_.__l.__data_);
    }
  }
  std::string::size_type v70 = v92;
  if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  int v71 = v91;
  if ((unint64_t)v92 >= 0x17)
  {
    uint64_t v73 = (v92 & 0xFFFFFFFFFFFFFFF8) + 8;
    if (((unint64_t)v92 | 7) != 0x17) {
      uint64_t v73 = v92 | 7;
    }
    uint64_t v74 = v73 + 1;
    int v72 = operator new(v73 + 1);
    __dst.__r_.__value_.__l.__size_ = v70;
    __dst.__r_.__value_.__r.__words[2] = v74 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v72;
    goto LABEL_145;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v92;
  int v72 = &__dst;
  if ((void)v92) {
LABEL_145:
  }
    memmove(v72, v71, v70);
  *((unsigned char *)v72 + v70) = 0;
  if (v91 != (char *)v93) {
    free(v91);
  }
  int v75 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  uint64_t v76 = (void *)__dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v77 = &__dst;
  }
  else {
    uint64_t v77 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t v78 = *((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    size_t v78 = __dst.__r_.__value_.__l.__size_;
  }
  std::string::size_type v79 = v88.__r_.__value_.__l.__size_;
  if (v88.__r_.__value_.__r.__words[2] < v88.__r_.__value_.__l.__size_ + v78) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v78)
  {
    memcpy((void *)(v88.__r_.__value_.__r.__words[0] + v88.__r_.__value_.__l.__size_), v77, v78);
    std::string::size_type v79 = v88.__r_.__value_.__l.__size_;
  }
  std::string::size_type v80 = v79 + v78;
  v88.__r_.__value_.__l.__size_ = v79 + v78;
  if (v75 < 0)
  {
    operator delete(v76);
    std::string::size_type v80 = v88.__r_.__value_.__l.__size_;
  }
  llvm::Triple::setOSAndEnvironmentName((llvm::Triple *)a2, (uint64_t)v88.__r_.__value_.__l.__data_, v80);
  unint64_t v43 = (void *)v88.__r_.__value_.__r.__words[0];
  if (v88.__r_.__value_.__l.__data_ != v89) {
LABEL_75:
  }
    free(v43);
}

double llvm::object::MachOObjectFile::getBuildVersionLoadCommand@<D0>(uint64_t a1@<X0>, long long **a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CCC530A4(a3, a1, *a2);
}

uint64_t llvm::object::MachOObjectFile::getVersionMinLoadCommand(uint64_t a1, _DWORD **a2)
{
  return sub_1CCC54354(a1, *a2);
}

uint64_t llvm::object::MachOObjectFile::section_rel_begin(llvm::object::MachOObjectFile *this, unsigned int a2)
{
  return (*(uint64_t (**)(llvm::object::MachOObjectFile *, void))(*(void *)this + 264))(this, a2);
}

uint64_t llvm::object::MachOObjectFile::section_rel_end(llvm::object::MachOObjectFile *this, unsigned int a2)
{
  return (*(uint64_t (**)(llvm::object::MachOObjectFile *, void))(*(void *)this + 272))(this, a2);
}

uint64_t llvm::object::MachOObjectFile::begin_dices(llvm::object::MachOObjectFile *this)
{
  uint64_t v2 = (_DWORD *)*((void *)this + 36);
  if (!v2) {
    return 0;
  }
  sub_1CCC54354((uint64_t)this, v2);
  return *((void *)this + 2) + v3;
}

uint64_t llvm::object::MachOObjectFile::getDataInCodeLoadCommand(llvm::object::MachOObjectFile *this)
{
  uint64_t v1 = (_DWORD *)*((void *)this + 36);
  if (v1) {
    return sub_1CCC54354((uint64_t)this, v1);
  }
  else {
    return 0x1000000029;
  }
}

uint64_t llvm::object::MachOObjectFile::end_dices(llvm::object::MachOObjectFile *this)
{
  uint64_t v2 = (_DWORD *)*((void *)this + 36);
  if (!v2) {
    return 0;
  }
  sub_1CCC54354((uint64_t)this, v2);
  return *((void *)this + 2) + (v4 + v3);
}

double llvm::object::ExportEntry::ExportEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = a3;
  *(void *)(a1 + ++*(_DWORD *)(this + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a1 + 56;
  *(_OWORD *)(a1 + 40) = xmmword_1CD96DBF0;
  *(void *)(a1 + 312) = a1 + 328;
  *(void *)&double result = 0x1000000000;
  *(void *)(a1 + 320) = 0x1000000000;
  *(unsigned char *)(a1 + 1352) = 0;
  return result;
}

{
  double result;

  *(void *)a1 = a2;
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = a3;
  *(void *)(a1 + ++*(_DWORD *)(this + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a1 + 56;
  *(_OWORD *)(a1 + 40) = xmmword_1CD96DBF0;
  *(void *)(a1 + 312) = a1 + 328;
  *(void *)&double result = 0x1000000000;
  *(void *)(a1 + 320) = 0x1000000000;
  *(unsigned char *)(a1 + 1352) = 0;
  return result;
}

const char *llvm::object::ExportEntry::moveToFirst(llvm::object::ExportEntry *this)
{
  uint64_t v2 = *(void **)this;
  double result = llvm::object::ExportEntry::pushNode(this, 0);
  if (**(void **)this)
  {
LABEL_5:
    if (!v2) {
      return result;
    }
    goto LABEL_6;
  }
  unint64_t v4 = *((void *)this + 39) + ((unint64_t)*((unsigned int *)this + 80) << 6);
  if (*(unsigned char *)(v4 - 4) || *(_DWORD *)(v4 - 16))
  {
    double result = llvm::object::ExportEntry::pushDownUntilBottom((const char *)this);
    goto LABEL_5;
  }
  *((_DWORD *)this + 80) = 0;
  *((unsigned char *)this + 1352) = 1;
  if (!v2) {
    return result;
  }
LABEL_6:
  if (!*v2) {
    void *v2 = 0;
  }
  return result;
}

const char *llvm::object::ExportEntry::pushNode(llvm::object::ExportEntry *this, uint64_t a2)
{
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  unsigned int v5 = 0;
  uint64_t v110 = a2;
  uint64_t v6 = *(void **)this;
  uint64_t v8 = *((void *)this + 2);
  uint64_t v7 = *((void *)this + 3);
  uint64_t v9 = v8 + a2;
  *(void *)&long long v108 = v8 + a2;
  memset(v109, 0, 45);
  unint64_t v10 = v8 + v7;
  int v11 = v8 + v7;
  uint64_t v12 = v7 - a2;
  uint64_t v13 = "malformed uleb128, extends past end";
  double result = "uleb128 too big for uint64";
  int v15 = v8 + a2;
  do
  {
    if (v12 == v3) {
      goto LABEL_13;
    }
    char v16 = *(unsigned char *)(v9 + v3);
    uint64_t v17 = v16 & 0x7F;
    if (v5 >= 0x40 && (v16 & 0x7F) != 0)
    {
      int v11 = v9 + v3;
      uint64_t v13 = "uleb128 too big for uint64";
LABEL_13:
      unint64_t v20 = v9 + (v11 - v9);
      if (v20 <= v10) {
        unint64_t v10 = v20;
      }
      *((void *)&v108 + 1) = v10;
      uint64_t v107 = 0;
      int v21 = *(unsigned __int8 *)v13;
      unsigned int v22 = "export info size ";
      if (!*v13) {
        goto LABEL_141;
      }
      v98[0] = "export info size ";
      unsigned int v99 = v13;
      goto LABEL_17;
    }
    if ((unint64_t)(v17 << v5) >> v5 != v17)
    {
      int v11 = v15;
      uint64_t v13 = "uleb128 too big for uint64";
      goto LABEL_13;
    }
    v4 += v17 << v5;
    v5 += 7;
    ++v15;
    ++v3;
  }
  while (v16 < 0);
  unint64_t v18 = v9 + v3;
  if (v18 > v10) {
    unint64_t v18 = v10;
  }
  *((void *)&v108 + 1) = v18;
  uint64_t v107 = v4;
  v109[44] = v4 != 0;
  uint64_t v19 = (unsigned __int8 *)(v18 + v4);
  if (v18 + v4 > v10)
  {
    v95[0] = "export info size: 0x";
    unint64_t v96 = (const char *)&v107;
    __int16 v97 = 3587;
    v98[0] = v95;
    unsigned int v99 = " in export trie data at node: 0x";
    __int16 v100 = 770;
    v101[0] = v98;
    uint64_t v102 = (const char *)&v110;
    __int16 v103 = 3586;
    v104[0] = (uint64_t)v101;
    char v105 = " too big and extends past end of trie data";
    __int16 v106 = 770;
    sub_1CCC51CE4((uint64_t)v91, v104);
  }
  if (!v4) {
    goto LABEL_122;
  }
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  unsigned int v26 = 0;
  if (v8 + a2 + (unint64_t)v3 >= v10) {
    unint64_t v27 = v10;
  }
  else {
    unint64_t v27 = v8 + a2 + v3;
  }
  unint64_t v28 = "malformed uleb128, extends past end";
  int v29 = v18;
  while (2)
  {
    if (v27 + v24 == v10) {
      goto LABEL_39;
    }
    char v30 = *(unsigned char *)(v27 + v24);
    uint64_t v31 = v30 & 0x7F;
    if (v26 >= 0x40 && (v30 & 0x7F) != 0)
    {
      unint64_t v33 = v8 + a2 + v3;
      if (v33 >= v10) {
        LODWORD(v33) = v10;
      }
      int v11 = v33 + v24;
      unint64_t v28 = "uleb128 too big for uint64";
      goto LABEL_39;
    }
    if ((unint64_t)(v31 << v26) >> v26 != v31)
    {
      int v11 = v29;
      unint64_t v28 = "uleb128 too big for uint64";
LABEL_39:
      unint64_t v34 = v18 + (v11 - v18);
      if (v34 <= v10) {
        unint64_t v10 = v34;
      }
      *((void *)&v108 + 1) = v10;
      *(void *)unsigned int v109 = 0;
      int v21 = *(unsigned __int8 *)v28;
      unsigned int v22 = "flags ";
      if (!*v28) {
        goto LABEL_141;
      }
      v98[0] = "flags ";
      unsigned int v99 = v28;
      goto LABEL_17;
    }
    v25 += v31 << v26;
    v26 += 7;
    ++v29;
    ++v24;
    if (v30 < 0) {
      continue;
    }
    break;
  }
  unint64_t v32 = v18 + v24;
  if (v32 > v10) {
    unint64_t v32 = v10;
  }
  *((void *)&v108 + 1) = v32;
  *(void *)unsigned int v109 = v25;
  if ((v25 & 1) != 0 && (v25 & 3) != 1)
  {
    v91[0] = "unsupported exported symbol kind: ";
    unint64_t v92 = v25 & 3;
    __int16 v93 = 2307;
    v95[0] = v91;
    unint64_t v96 = " in flags: 0x";
    __int16 v97 = 770;
    v98[0] = v95;
    unsigned int v99 = v109;
    goto LABEL_33;
  }
  if ((v25 & 8) != 0)
  {
    double result = 0;
    uint64_t v55 = 0;
    unsigned int v56 = 0;
    *(void *)&v109[8] = 0;
    unint64_t v57 = v8 + a2 + v3;
    if (v57 >= v10) {
      unint64_t v57 = v10;
    }
    unint64_t v58 = v57 + v24;
    if (v10 >= v58) {
      unint64_t v59 = v58;
    }
    else {
      unint64_t v59 = v10;
    }
    size_t v60 = "malformed uleb128, extends past end";
    int v61 = v32;
    while (1)
    {
      if (&result[v59] == (const char *)v10) {
        goto LABEL_108;
      }
      char v62 = result[v59];
      uint64_t v63 = v62 & 0x7F;
      if (v56 >= 0x40 && (v62 & 0x7F) != 0) {
        break;
      }
      if ((unint64_t)(v63 << v56) >> v56 != v63)
      {
        int v11 = v61;
        size_t v60 = "uleb128 too big for uint64";
LABEL_108:
        unint64_t v72 = v32 + (v11 - v32);
        if (v72 <= v10) {
          unint64_t v10 = v72;
        }
        *((void *)&v108 + 1) = v10;
        *(void *)&v109[16] = 0;
        int v21 = *(unsigned __int8 *)v60;
        unsigned int v22 = "dylib ordinal of re-export ";
        if (!*v60) {
          goto LABEL_141;
        }
        v98[0] = "dylib ordinal of re-export ";
        unsigned int v99 = v60;
        goto LABEL_17;
      }
      v55 += v63 << v56;
      v56 += 7;
      ++v61;
      ++result;
      if ((v62 & 0x80) == 0)
      {
        unint64_t v64 = (unsigned __int8 *)(v32 + result);
        if ((unint64_t)v64 > v10) {
          unint64_t v64 = (unsigned __int8 *)v10;
        }
        *((void *)&v108 + 1) = v64;
        *(void *)&v109[16] = v55;
        uint64_t v65 = *((void *)this + 1);
        if (v65)
        {
          if (v55 > 0)
          {
            unint64_t v66 = (const char *)*(unsigned int *)(v65 + 112);
            if (v55 > (unint64_t)v66)
            {
              v91[0] = "bad library ordinal: ";
              unint64_t v92 = v55;
              __int16 v93 = 2307;
              v95[0] = v91;
              unint64_t v96 = " (max ";
              __int16 v97 = 770;
              v98[0] = v95;
              unsigned int v99 = v66;
              __int16 v100 = 2306;
              v101[0] = v98;
              uint64_t v102 = ") in export trie data at node: 0x";
              __int16 v103 = 770;
              v104[0] = (uint64_t)v101;
              char v105 = (const char *)&v110;
              __int16 v106 = 3586;
              goto LABEL_34;
            }
          }
        }
        *(void *)&v109[24] = v64;
        std::string::size_type v44 = v64 + 1;
        if (!*v64) {
          goto LABEL_119;
        }
        if ((unint64_t)v44 >= v10)
        {
          v101[0] = "import name of re-export in export trie data at node: 0x";
          uint64_t v102 = (const char *)&v110;
          __int16 v103 = 3587;
          uint64_t v77 = " starts past end of trie data";
        }
        else
        {
          if (!*v44) {
            goto LABEL_118;
          }
          while ((unint64_t)v44 < v10)
          {
            if (!*++v44)
            {
              unint64_t v64 = v44 - 1;
LABEL_118:
              std::string::size_type v44 = v64 + 2;
LABEL_119:
              *((void *)&v108 + 1) = v44;
              goto LABEL_120;
            }
          }
          uint64_t v76 = "import name of re-export in export trie data at node: 0x";
LABEL_125:
          v101[0] = v76;
          uint64_t v102 = (const char *)&v110;
          __int16 v103 = 3587;
          uint64_t v77 = " extends past end of trie data";
        }
        v104[0] = (uint64_t)v101;
        char v105 = v77;
        __int16 v106 = 770;
        sub_1CCC51CE4((uint64_t)v98, v104);
      }
    }
    unint64_t v69 = v8 + a2 + v3;
    if (v69 >= v10) {
      unint64_t v69 = v10;
    }
    unint64_t v70 = v69 + v24;
    if (v10 < v70) {
      LODWORD(v70) = v10;
    }
    int v11 = v70 + result;
    size_t v60 = "uleb128 too big for uint64";
    goto LABEL_108;
  }
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  unsigned int v37 = 0;
  unint64_t v38 = v8 + a2 + v3;
  if (v38 >= v10) {
    unint64_t v38 = v10;
  }
  unint64_t v39 = v38 + v24;
  if (v10 >= v39) {
    unint64_t v40 = v39;
  }
  else {
    unint64_t v40 = v10;
  }
  double result = "malformed uleb128, extends past end";
  int v41 = v32;
  while (2)
  {
    if (v40 + v35 == v10) {
      goto LABEL_103;
    }
    char v42 = *(unsigned char *)(v40 + v35);
    uint64_t v43 = v42 & 0x7F;
    if (v37 >= 0x40 && (v42 & 0x7F) != 0)
    {
      unint64_t v67 = v8 + a2 + v3;
      if (v67 >= v10) {
        unint64_t v67 = v10;
      }
      unint64_t v68 = v67 + v24;
      if (v10 < v68) {
        LODWORD(v6++*(_DWORD *)(this + 8) = v10;
      }
      int v11 = v68 + v35;
      double result = "uleb128 too big for uint64";
LABEL_103:
      unint64_t v71 = v32 + (v11 - v32);
      if (v71 <= v10) {
        unint64_t v10 = v71;
      }
      *((void *)&v108 + 1) = v10;
      *(void *)&v109[8] = 0;
      int v21 = *(unsigned __int8 *)result;
      unsigned int v22 = "address ";
      if (!*result) {
        goto LABEL_141;
      }
      goto LABEL_106;
    }
    if ((unint64_t)(v43 << v37) >> v37 != v43)
    {
      int v11 = v41;
      double result = "uleb128 too big for uint64";
      goto LABEL_103;
    }
    v36 += v43 << v37;
    v37 += 7;
    ++v41;
    ++v35;
    if (v42 < 0) {
      continue;
    }
    break;
  }
  std::string::size_type v44 = (unsigned __int8 *)(v32 + v35);
  if ((unint64_t)v44 > v10) {
    std::string::size_type v44 = (unsigned __int8 *)v10;
  }
  *((void *)&v108 + 1) = v44;
  *(void *)&v109[8] = v36;
  if ((v25 & 0x10) != 0)
  {
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    unsigned int v47 = 0;
    unint64_t v48 = v8 + a2 + v3;
    if (v48 >= v10) {
      unint64_t v48 = v10;
    }
    unint64_t v49 = v48 + v24;
    if (v10 < v49) {
      unint64_t v49 = v10;
    }
    unint64_t v50 = v49 + v35;
    if (v10 >= v50) {
      unint64_t v51 = v50;
    }
    else {
      unint64_t v51 = v10;
    }
    double result = "malformed uleb128, extends past end";
    int v52 = (int)v44;
    while (1)
    {
      if (v51 + v45 == v10) {
        goto LABEL_138;
      }
      char v53 = *(unsigned char *)(v51 + v45);
      uint64_t v54 = v53 & 0x7F;
      if (v47 >= 0x40 && (v53 & 0x7F) != 0) {
        break;
      }
      if ((unint64_t)(v54 << v47) >> v47 != v54)
      {
        int v11 = v52;
        double result = "uleb128 too big for uint64";
        goto LABEL_138;
      }
      v46 += v54 << v47;
      v47 += 7;
      ++v52;
      ++v45;
      if ((v53 & 0x80) == 0)
      {
        if ((unint64_t)&v44[v45] <= v10) {
          v44 += v45;
        }
        else {
          std::string::size_type v44 = (unsigned __int8 *)v10;
        }
        *((void *)&v108 + 1) = v44;
        *(void *)&v109[16] = v46;
        goto LABEL_120;
      }
    }
    unint64_t v85 = v8 + a2 + v3;
    if (v85 >= v10) {
      unint64_t v85 = v10;
    }
    unint64_t v86 = v85 + v24;
    if (v10 < v86) {
      unint64_t v86 = v10;
    }
    unint64_t v87 = v86 + v35;
    if (v10 < v87) {
      LODWORD(v87) = v10;
    }
    int v11 = v87 + v45;
    double result = "uleb128 too big for uint64";
LABEL_138:
    std::string v88 = &v44[v11 - v44];
    if ((unint64_t)v88 <= v10) {
      unint64_t v10 = (unint64_t)v88;
    }
    *((void *)&v108 + 1) = v10;
    *(void *)&v109[16] = 0;
    int v21 = *(unsigned __int8 *)result;
    unsigned int v22 = "resolver of stub and resolver ";
    if (!*result)
    {
LABEL_141:
      v98[0] = v22;
      __int16 v100 = 259;
      char v23 = 3;
LABEL_142:
      if (v21) {
        unsigned int v22 = (const char *)v98;
      }
      v101[0] = v22;
      uint64_t v102 = " in export trie data at node: 0x";
      LOBYTE(v103) = v23;
      HIBYTE(v103) = 3;
      v104[0] = (uint64_t)v101;
      char v105 = (const char *)&v110;
      __int16 v106 = 3586;
      sub_1CCC51CE4((uint64_t)v95, v104);
    }
LABEL_106:
    v98[0] = v22;
    unsigned int v99 = result;
LABEL_17:
    __int16 v100 = 771;
    char v23 = 2;
    goto LABEL_142;
  }
LABEL_120:
  if (v19 != v44)
  {
    unint64_t v92 = (unint64_t)&v107;
    __int16 v93 = 3587;
    v95[0] = v91;
    unint64_t v96 = " where actual size was: 0x";
    __int16 v97 = 770;
    unsigned int v90 = &v44[-v18];
    v91[0] = "inconsistant export info size: 0x";
    v98[0] = v95;
    unsigned int v99 = (const char *)&v90;
LABEL_33:
    __int16 v100 = 3586;
    v101[0] = v98;
    uint64_t v102 = " in export trie data at node: 0x";
    __int16 v103 = 770;
    v104[0] = (uint64_t)v101;
    char v105 = (const char *)&v110;
    __int16 v106 = 3586;
LABEL_34:
    sub_1CCC51CE4((uint64_t)&v94, v104);
  }
LABEL_122:
  int v75 = *v19;
  uint64_t v74 = v19 + 1;
  *(_DWORD *)&v109[32] = v75;
  if (v75 && (unint64_t)v74 >= v10)
  {
    uint64_t v76 = "byte for count of childern in export trie data at node: 0x";
    goto LABEL_125;
  }
  *((void *)&v108 + 1) = v74;
  uint64_t v78 = *((void *)this + 5);
  *(_DWORD *)&v109[36] = 0;
  *(_DWORD *)&v109[40] = v78;
  uint64_t v79 = *((unsigned int *)this + 80);
  unint64_t v80 = *((void *)this + 39);
  if (v79 >= *((_DWORD *)this + 81))
  {
    BOOL v89 = v80 + (v79 << 6) > (unint64_t)&v108;
    if (v80 > (unint64_t)&v108 || !v89) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v81 = (_OWORD *)(v80 + ((unint64_t)*((unsigned int *)this + 80) << 6));
  long long v82 = v108;
  long long v83 = *(_OWORD *)v109;
  long long v84 = *(_OWORD *)&v109[32];
  v81[2] = *(_OWORD *)&v109[16];
  v81[3] = v84;
  *uint64_t v81 = v82;
  v81[1] = v83;
  ++*((_DWORD *)this + 80);
  if (v6)
  {
    if (!*v6) {
      *uint64_t v6 = 0;
    }
  }
  return result;
}

uint64_t llvm::object::ExportEntry::moveToEnd(uint64_t this)
{
  *(_DWORD *)(this + 320) = 0;
  *(unsigned char *)(this + 1352) = 1;
  return this;
}

const char *llvm::object::ExportEntry::pushDownUntilBottom(const char *this)
{
  uint64_t v1 = (uint64_t)this;
  uint64_t v2 = *(void **)this;
  uint64_t v3 = this + 32;
  while (1)
  {
    unint64_t v4 = *(void *)(v1 + 312) + ((unint64_t)*(unsigned int *)(v1 + 320) << 6);
    if (*(_DWORD *)(v4 - 12) >= *(_DWORD *)(v4 - 16)) {
      break;
    }
    unint64_t v5 = *(unsigned int *)(v4 - 8);
    unint64_t v6 = *(void *)(v1 + 40);
    if (v6 != v5)
    {
      if (v6 <= v5)
      {
        if (*(void *)(v1 + 48) < v5) {
          llvm::SmallVectorBase<unsigned long long>::grow_pod();
        }
        if (v5 != v6) {
          bzero((void *)(*v3 + v6), v5 - v6);
        }
      }
      *(void *)(v1 + 40) = v5;
    }
    uint64_t v7 = *(char **)(v4 - 56);
    for (char i = *v7; *v7; char i = *v7)
    {
      if ((unint64_t)v7 >= *(void *)(v1 + 16) + *(void *)(v1 + 24)) {
        break;
      }
      if (v5 + 1 > *(void *)(v1 + 48)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(unsigned char *)(*(void *)(v1 + 32) + v5) = i;
      unint64_t v5 = *(void *)(v1 + 40) + 1;
      *(void *)(v1 + 40) = v5;
      uint64_t v7 = (char *)(*(void *)(v4 - 56) + 1);
      *(void *)(v4 - 56) = v7;
    }
    uint64_t v10 = *(void *)(v1 + 16);
    uint64_t v9 = *(void *)(v1 + 24);
    int v11 = (char *)(v10 + v9);
    if ((unint64_t)v7 >= v10 + v9)
    {
      uint64_t v33 = *(void *)(v4 - 64) - v10;
      v34[0] = "edge sub-string in export trie data at node: 0x";
      v34[2] = &v33;
      __int16 v35 = 3587;
      v36[0] = v34;
      unsigned int v37 = " for child #";
      __int16 v28 = 770;
      __int16 v38 = 770;
      int v29 = (const char *)*(unsigned int *)(v4 - 12);
      v39[0] = v36;
      unint64_t v40 = v29;
      __int16 v41 = 2306;
      v42[0] = (uint64_t)v39;
      uint64_t v43 = " extends past end of trie data";
      goto LABEL_38;
    }
    uint64_t v12 = 0;
    unsigned int v13 = 0;
    unint64_t v14 = v7 + 1;
    *(void *)(v4 - 56) = v14;
    v34[0] = 0;
    int v15 = v9 + v10;
    char v16 = v14;
    while (v16 != v11)
    {
      char v17 = *v16;
      uint64_t v18 = *v16 & 0x7F;
      if (v13 >= 0x40 && (*v16 & 0x7F) != 0 || (unint64_t)(v18 << v13) >> v13 != v18)
      {
        char v20 = 0;
        uint64_t v12 = 0;
        uint64_t v19 = "uleb128 too big for uint64";
        goto LABEL_19;
      }
      v12 += v18 << v13;
      v13 += 7;
      ++v16;
      if ((v17 & 0x80) == 0)
      {
        uint64_t v19 = 0;
        char v20 = 1;
LABEL_19:
        int v15 = (int)v16;
        goto LABEL_21;
      }
    }
    char v20 = 0;
    uint64_t v12 = 0;
    uint64_t v19 = "malformed uleb128, extends past end";
LABEL_21:
    int v21 = &v14[v15 - v14];
    *(void *)(v4 - 56) = v21;
    unsigned int v22 = (char *)(*(void *)(v1 + 16) + v9);
    if (v21 <= v22) {
      unsigned int v22 = v21;
    }
    *(void *)(v4 - 56) = v22;
    v34[0] = v12;
    if ((v20 & 1) == 0)
    {
      int v30 = *(unsigned __int8 *)v19;
      uint64_t v31 = "child node offset ";
      if (*v19)
      {
        v36[0] = "child node offset ";
        unsigned int v37 = v19;
        __int16 v38 = 771;
        char v32 = 2;
      }
      else
      {
        v36[0] = "child node offset ";
        __int16 v38 = 259;
        char v32 = 3;
      }
      if (v30) {
        uint64_t v31 = (const char *)v36;
      }
      v39[0] = v31;
      unint64_t v40 = " in export trie data at node: 0x";
      LOBYTE(v41) = v32;
      HIBYTE(v41) = 3;
      uint64_t v33 = *(void *)(v4 - 64) - *(void *)(v1 + 16);
      unint64_t v27 = (const char *)&v33;
      goto LABEL_37;
    }
    uint64_t v23 = *(unsigned int *)(v1 + 320);
    if (v23)
    {
      uint64_t v24 = *(void **)(v1 + 312);
      uint64_t v25 = *(void *)(v1 + 16);
      uint64_t v26 = v23 << 6;
      while (*v24 != v25 + v12)
      {
        v24 += 8;
        v26 -= 64;
        if (!v26) {
          goto LABEL_28;
        }
      }
      uint64_t v33 = *(void *)(v4 - 64) - v25;
      v36[0] = "loop in childern in export trie data at node: 0x";
      unsigned int v37 = (const char *)&v33;
      __int16 v38 = 3587;
      v39[0] = v36;
      unint64_t v40 = " back to node: 0x";
      __int16 v41 = 770;
      unint64_t v27 = (const char *)v34;
LABEL_37:
      v42[0] = (uint64_t)v39;
      uint64_t v43 = v27;
      __int16 v28 = 3586;
LABEL_38:
      __int16 v44 = v28;
      sub_1CCC51CE4((uint64_t)&v45, v42);
    }
LABEL_28:
    ++*(_DWORD *)(v4 - 12);
    this = llvm::object::ExportEntry::pushNode((llvm::object::ExportEntry *)v1, v12);
    if (**(void **)v1) {
      goto LABEL_39;
    }
  }
  if (!*(unsigned char *)(v4 - 4))
  {
    v36[0] = *(void *)(v4 - 64) - *(void *)(v1 + 16);
    v42[0] = (uint64_t)"node is not an export node in export trie data at node: 0x";
    uint64_t v43 = (const char *)v36;
    __int16 v44 = 3587;
    sub_1CCC51CE4((uint64_t)v39, v42);
  }
LABEL_39:
  if (v2)
  {
    if (!*v2) {
      void *v2 = 0;
    }
  }
  return this;
}

uint64_t llvm::object::ExportEntry::operator==(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 1352);
  int v3 = *(unsigned __int8 *)(a2 + 1352);
  if (v2 | v3) {
    return v2 == v3;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 320);
  if (v6 != *(_DWORD *)(a2 + 320)) {
    return 0;
  }
  size_t v7 = *(void *)(a2 + 40);
  if (*(void *)(a1 + 40) != v7 || v7 && memcmp(*(const void **)(a1 + 32), *(const void **)(a2 + 32), v7)) {
    return 0;
  }
  if (!v6) {
    return 1;
  }
  uint64_t v9 = *(uint64_t **)(a1 + 312);
  uint64_t v10 = *(uint64_t **)(a2 + 312);
  uint64_t v11 = v6 - 1;
  do
  {
    uint64_t v13 = *v9;
    v9 += 8;
    uint64_t v12 = v13;
    uint64_t v15 = *v10;
    v10 += 8;
    uint64_t v14 = v15;
    BOOL v17 = v11-- != 0;
    uint64_t result = v12 == v14;
  }
  while (v12 == v14 && v17);
  return result;
}

uint64_t llvm::object::ExportEntry::readULEB128(llvm::object::ExportEntry *this, char **a2, const char **a3)
{
  int v8 = 0;
  uint64_t result = sub_1CBF28C40(*a2, &v8, (char *)(*((void *)this + 2) + *((void *)this + 3)), a3);
  uint64_t v6 = (const unsigned __int8 *)&(*a2)[v8];
  *a2 = (char *)v6;
  uint64_t v7 = *((void *)this + 3);
  if ((unint64_t)v6 > *((void *)this + 2) + v7) {
    uint64_t v6 = (const unsigned __int8 *)(*((void *)this + 2) + v7);
  }
  *a2 = (char *)v6;
  return result;
}

uint64_t llvm::object::ExportEntry::name(llvm::object::ExportEntry *this)
{
  return *((void *)this + 4);
}

uint64_t llvm::object::ExportEntry::flags(llvm::object::ExportEntry *this)
{
  return *(void *)(*((void *)this + 39) + ((unint64_t)*((unsigned int *)this + 80) << 6) - 48);
}

uint64_t llvm::object::ExportEntry::address(llvm::object::ExportEntry *this)
{
  return *(void *)(*((void *)this + 39) + ((unint64_t)*((unsigned int *)this + 80) << 6) - 40);
}

uint64_t llvm::object::ExportEntry::other(llvm::object::ExportEntry *this)
{
  return *(void *)(*((void *)this + 39) + ((unint64_t)*((unsigned int *)this + 80) << 6) - 32);
}

uint64_t llvm::object::ExportEntry::otherName(llvm::object::ExportEntry *this)
{
  unint64_t v1 = *((void *)this + 39) + ((unint64_t)*((unsigned int *)this + 80) << 6);
  uint64_t v2 = *(void *)(v1 - 24);
  if (v2) {
    strlen(*(const char **)(v1 - 24));
  }
  return v2;
}

uint64_t llvm::object::ExportEntry::nodeOffset(llvm::object::ExportEntry *this)
{
  return (*(_DWORD *)(*((void *)this + 39) + ((unint64_t)*((unsigned int *)this + 80) << 6) - 64)
                      - *((_DWORD *)this + 4));
}

double llvm::object::ExportEntry::NodeState::NodeState(llvm::object::ExportEntry::NodeState *this, const unsigned __int8 *a2)
{
  *(void *)this = a2;
  *((void *)this + 1) = a2;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 45) = 0u;
  return result;
}

{
  double result;

  *(void *)this = a2;
  *((void *)this + 1) = a2;
  double result = 0.0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 45) = 0u;
  return result;
}

void llvm::object::ExportEntry::moveNext(llvm::object::ExportEntry *this)
{
  uint64_t v2 = *((void *)this + 39);
  uint64_t v3 = *((unsigned int *)this + 80);
  uint64_t v4 = v2 + (v3 << 6);
  if (!*(unsigned char *)(v4 - 4))
  {
    uint64_t v9 = *(void *)(v4 - 64) - *((void *)this + 2);
    v10[0] = (uint64_t)"node is not an export node in export trie data at node: 0x";
    void v10[2] = (uint64_t)&v9;
    __int16 v11 = 3587;
    sub_1CCC51CE4((uint64_t)&v12, v10);
  }
  unsigned int v5 = v3 - 1;
  while (1)
  {
    if (!v5)
    {
      *((_DWORD *)this + 80) = 0;
      *((unsigned char *)this + 1352) = 1;
      return;
    }
    uint64_t v6 = v2 + ((unint64_t)v5 << 6);
    if (*(_DWORD *)(v6 - 12) < *(_DWORD *)(v6 - 16)) {
      break;
    }
    --v5;
    if (*(unsigned char *)(v6 - 4))
    {
      *((_DWORD *)this + 80) = v5 + 1;
      unint64_t v7 = *(unsigned int *)(v6 - 8);
      unint64_t v8 = *((void *)this + 5);
      if (v8 != v7)
      {
        if (v8 <= v7)
        {
          if (*((void *)this + 6) < v7) {
            llvm::SmallVectorBase<unsigned long long>::grow_pod();
          }
          if (v7 != v8) {
            bzero((void *)(*((void *)this + 4) + v8), v7 - v8);
          }
        }
        *((void *)this + 5) = v7;
      }
      return;
    }
  }
  *((_DWORD *)this + 80) = v5;

  llvm::object::ExportEntry::pushDownUntilBottom((const char *)this);
}

void llvm::object::MachOObjectFile::exports(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v4;
  uint64_t v13 = v12;
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v62 = v4;
  *((void *)&v62 + 1) = v5;
  *(void *)&long long v63 = v9;
  *((void *)&v63 + 1) = v7;
  long long v65 = xmmword_1CD96DBF0;
  unint64_t v64 = v66;
  unint64_t v67 = v69;
  uint64_t v68 = 0x1000000000;
  char v70 = 0;
  if (v7)
  {
    llvm::object::ExportEntry::moveToFirst((llvm::object::ExportEntry *)&v62);
    uint64_t v14 = v65;
  }
  else
  {
    uint64_t v14 = 0;
    char v70 = 1;
  }
  *(void *)&long long v53 = v11;
  *((void *)&v53 + 1) = v6;
  *(void *)&long long v54 = v10;
  *((void *)&v54 + 1) = v8;
  long long v56 = xmmword_1CD96DBF0;
  uint64_t v55 = v57;
  unint64_t v58 = v60;
  uint64_t v59 = 0x1000000000;
  char v61 = 1;
  long long v35 = v62;
  long long v36 = v63;
  unsigned int v37 = v39;
  long long v38 = xmmword_1CD96DBF0;
  if (v14) {
    sub_1CC223970((uint64_t)&v37, (uint64_t)&v64);
  }
  unint64_t v40 = v42;
  uint64_t v41 = 0x1000000000;
  if (v68) {
    sub_1CCC684A0((uint64_t)&v40, (uint64_t)&v67);
  }
  char v43 = v70;
  long long v44 = v35;
  long long v45 = v36;
  uint64_t v46 = v48;
  long long v47 = xmmword_1CD96DBF0;
  if ((void)v38) {
    sub_1CC1B8518((uint64_t)&v46, (uint64_t)&v37);
  }
  unint64_t v49 = v51;
  uint64_t v50 = 0x1000000000;
  if (v41) {
    sub_1CCC6FC68((uint64_t)&v49, (uint64_t)&v40);
  }
  char v52 = v43;
  long long v17 = v53;
  long long v18 = v54;
  uint64_t v19 = v21;
  long long v20 = xmmword_1CD96DBF0;
  if ((void)v56) {
    sub_1CC223970((uint64_t)&v19, (uint64_t)&v55);
  }
  unsigned int v22 = v24;
  uint64_t v23 = 0x1000000000;
  if (v59) {
    sub_1CCC684A0((uint64_t)&v22, (uint64_t)&v58);
  }
  char v25 = v61;
  long long v26 = v17;
  long long v27 = v18;
  __int16 v28 = v30;
  long long v29 = xmmword_1CD96DBF0;
  if ((void)v20) {
    sub_1CC1B8518((uint64_t)&v28, (uint64_t)&v19);
  }
  uint64_t v31 = v33;
  uint64_t v32 = 0x1000000000;
  if (v23) {
    sub_1CCC6FC68((uint64_t)&v31, (uint64_t)&v22);
  }
  char v34 = v25;
  long long v80 = v44;
  long long v81 = v45;
  long long v82 = v84;
  long long v83 = xmmword_1CD96DBF0;
  if ((void)v47) {
    sub_1CC1B8518((uint64_t)&v82, (uint64_t)&v46);
  }
  unint64_t v85 = v87;
  uint64_t v86 = 0x1000000000;
  if (v50) {
    sub_1CCC6FC68((uint64_t)&v85, (uint64_t)&v49);
  }
  char v88 = v52;
  long long v71 = v26;
  long long v72 = v27;
  uint64_t v73 = v75;
  long long v74 = xmmword_1CD96DBF0;
  if ((void)v29) {
    sub_1CC1B8518((uint64_t)&v73, (uint64_t)&v28);
  }
  uint64_t v76 = v78;
  uint64_t v77 = 0x1000000000;
  if (v32) {
    sub_1CCC6FC68((uint64_t)&v76, (uint64_t)&v31);
  }
  char v79 = v34;
  long long v15 = v81;
  *(_OWORD *)uint64_t v13 = v80;
  *(_OWORD *)(v13 + ++*(_DWORD *)(this + 16) = v15;
  *(void *)(v13 + 32) = v13 + 56;
  *(_OWORD *)(v13 + 40) = xmmword_1CD96DBF0;
  if ((void)v83) {
    sub_1CC1B8518(v13 + 32, (uint64_t)&v82);
  }
  *(void *)(v13 + 312) = v13 + 328;
  *(void *)(v13 + 320) = 0x1000000000;
  if (v86) {
    sub_1CCC6FC68(v13 + 312, (uint64_t)&v85);
  }
  *(unsigned char *)(v13 + 1352) = v88;
  long long v16 = v72;
  *(_OWORD *)(v13 + 1360) = v71;
  *(_OWORD *)(v13 + 1376) = v16;
  *(void *)(v13 + 1392) = v13 + 1416;
  *(void *)(v13 + 1400) = 0;
  *(void *)(v13 + 140++*(_DWORD *)(this + 8) = 256;
  if ((void)v74) {
    sub_1CC1B8518(v13 + 1392, (uint64_t)&v73);
  }
  *(void *)(v13 + 1672) = v13 + 1688;
  *(void *)(v13 + 1680) = 0x1000000000;
  if (v77) {
    sub_1CCC6FC68(v13 + 1672, (uint64_t)&v76);
  }
  *(unsigned char *)(v13 + 2712) = v79;
  if (v76 != v78) {
    free(v76);
  }
  if (v73 != v75) {
    free(v73);
  }
  if (v85 != v87) {
    free(v85);
  }
  if (v82 != v84) {
    free(v82);
  }
  if (v31 != v33) {
    free(v31);
  }
  if (v28 != v30) {
    free(v28);
  }
  if (v22 != v24) {
    free(v22);
  }
  if (v19 != v21) {
    free(v19);
  }
  if (v49 != v51) {
    free(v49);
  }
  if (v46 != v48) {
    free(v46);
  }
  if (v40 != v42) {
    free(v40);
  }
  if (v37 != v39) {
    free(v37);
  }
  if (v58 != v60) {
    free(v58);
  }
  if (v55 != v57) {
    free(v55);
  }
  if (v67 != v69) {
    free(v67);
  }
  if (v64 != v66) {
    free(v64);
  }
}

void llvm::object::MachOObjectFile::exports(llvm::object::MachOObjectFile *a1, uint64_t a2)
{
  uint64_t DyldInfoExportsTrie = llvm::object::MachOObjectFile::getDyldInfoExportsTrie(a1);

  llvm::object::MachOObjectFile::exports(a2, DyldInfoExportsTrie, v4, (uint64_t)a1);
}

uint64_t llvm::object::MachOObjectFile::getDyldInfoExportsTrie(llvm::object::MachOObjectFile *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (int8x16_t *)*((void *)this + 38);
  if (v2)
  {
    sub_1CCC64EA4(v6, (uint64_t)this, v2);
    if (v8)
    {
      uint64_t result = v6[0].i64[0];
      if (v6[0].i64[0])
      {
        (*(void (**)(uint64_t))(*(void *)v6[0].i64[0] + 8))(v6[0].i64[0]);
        return 0;
      }
    }
    else
    {
      return *((void *)this + 2) + v7;
    }
  }
  else
  {
    uint64_t v4 = (_DWORD *)*((void *)this + 39);
    if (v4)
    {
      sub_1CCC54354((uint64_t)this, v4);
      return *((void *)this + 2) + v5;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = a2;
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = a3;
  *(void *)(a1 + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(a1 + 24) = -1;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4++*(_DWORD *)(this + 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(unsigned char *)(a1 + 80) = 0;
  uint64_t v4 = *(unsigned int *)(a3 + 136);
  if (!v4) {
    return a1;
  }
  uint64_t v6 = *(void *)(a3 + 128);
  uint64_t v7 = 16 * v4;
  while (1)
  {
    int v8 = *(_DWORD *)(v6 + 8);
    if (v8 == 25) {
      break;
    }
    if (v8 == 1)
    {
      *(void *)&long long v16 = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      long long v13 = 0u;
      llvm::object::MachOObjectFile::getSegmentLoadCommand(a3, (unint64_t *)v6, (uint64_t)&v13);
      if (strlen((const char *)&v13 + 8) == 6 && DWORD2(v13) == 1163157343 && WORD6(v13) == 21592)
      {
        uint64_t v11 = DWORD2(v14);
        goto LABEL_20;
      }
    }
LABEL_17:
    v6 += 16;
    v7 -= 16;
    if (!v7) {
      return a1;
    }
  }
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  llvm::object::MachOObjectFile::getSegment64LoadCommand(a3, (unint64_t *)v6, (uint64_t)&v13);
  if (strlen((const char *)&v13 + 8) != 6) {
    goto LABEL_17;
  }
  if (DWORD2(v13) != 1163157343 || WORD6(v13) != 21592) {
    goto LABEL_17;
  }
  uint64_t v11 = *((void *)&v14 + 1);
LABEL_20:
  *(void *)(a1 + 8++*(_DWORD *)(this + 8) = v11;
  return a1;
}

int8x16_t llvm::object::MachOObjectFile::getSegmentLoadCommand@<Q0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *(void *)(a1 + 16);
  if (*a2 < v4 || *a2 + 56 > v4 + *(void *)(a1 + 24)) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v6 = *(_OWORD *)(v3 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v3;
  *(_OWORD *)(a3 + ++*(_DWORD *)(this + 16) = v6;
  int8x16_t result = *(int8x16_t *)(v3 + 32);
  *(int8x16_t *)(a3 + 32) = result;
  *(void *)(a3 + 4++*(_DWORD *)(this + 8) = *(void *)(v3 + 48);
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  if (v8 <= 0x13 && ((1 << v8) & 0xAAC00) != 0)
  {
    *(int8x8_t *)a3 = vrev32_s8(*(int8x8_t *)a3);
    *(int8x16_t *)(a3 + 24) = vrev32q_s8(*(int8x16_t *)(a3 + 24));
    int8x16_t result = vrev32q_s8(*(int8x16_t *)(a3 + 40));
    *(int8x16_t *)(a3 + 40) = result;
  }
  return result;
}

int8x16_t llvm::object::MachOObjectFile::getSegment64LoadCommand@<Q0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *(void *)(a1 + 16);
  if (*a2 < v4 || *a2 + 72 > v4 + *(void *)(a1 + 24)) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v6 = *(_OWORD *)(v3 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v3 + 32);
  *(_OWORD *)(a3 + 4++*(_DWORD *)(this + 8) = v6;
  *(void *)(a3 + 64) = *(void *)(v3 + 64);
  int8x16_t result = *(int8x16_t *)(v3 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v3;
  *(int8x16_t *)(a3 + ++*(_DWORD *)(this + 16) = result;
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  if (v8 <= 0x13 && ((1 << v8) & 0xAAC00) != 0)
  {
    *(int8x8_t *)a3 = vrev32_s8(*(int8x8_t *)a3);
    *(int8x16_t *)(a3 + 24) = vrev64q_s8(*(int8x16_t *)(a3 + 24));
    *(int8x16_t *)(a3 + 40) = vrev64q_s8(*(int8x16_t *)(a3 + 40));
    int8x16_t result = vrev32q_s8(*(int8x16_t *)(a3 + 56));
    *(int8x16_t *)(a3 + 56) = result;
  }
  return result;
}

uint64_t llvm::object::MachOAbstractFixupEntry::segmentOffset(llvm::object::MachOAbstractFixupEntry *this)
{
  return *((void *)this + 2);
}

uint64_t llvm::object::MachOAbstractFixupEntry::segmentAddress(llvm::object::MachOAbstractFixupEntry *this)
{
  unint64_t v1 = *(uint64_t **)(*((void *)this + 1) + 264);
  uint64_t v2 = *v1;
  unsigned int v3 = *((_DWORD *)v1 + 2);
  if (v3)
  {
    uint64_t v4 = v2 + 88 * v3;
    uint64_t v5 = 88 * v3;
    while (*(_DWORD *)(v2 + 80) != *((_DWORD *)this + 6) || *(void *)(v2 + 64) || !*(void *)(v2 + 8))
    {
      v2 += 88;
      v5 -= 88;
      if (!v5)
      {
        uint64_t v2 = v4;
        return *(void *)(v2 + 72);
      }
    }
  }
  return *(void *)(v2 + 72);
}

uint64_t llvm::object::MachOAbstractFixupEntry::segmentName(uint64_t this)
{
  unint64_t v1 = *(_DWORD **)(*(void *)(this + 8) + 264);
  unsigned int v2 = v1[2];
  if (v2)
  {
    unsigned int v3 = (_DWORD *)(*(void *)v1 + 80);
    uint64_t v4 = 88 * v2;
    while (*v3 != *(_DWORD *)(this + 24))
    {
      v3 += 22;
      v4 -= 88;
      if (!v4) {
        return this;
      }
    }
    return *((void *)v3 - 4);
  }
  return this;
}

uint64_t llvm::object::MachOAbstractFixupEntry::sectionName(llvm::object::MachOAbstractFixupEntry *this)
{
  unint64_t v1 = *(uint64_t **)(*((void *)this + 1) + 264);
  uint64_t v2 = *v1;
  unsigned int v3 = *((_DWORD *)v1 + 2);
  if (v3)
  {
    unint64_t v4 = *((void *)this + 2);
    uint64_t v5 = v2 + 88 * v3;
    uint64_t v6 = 88 * v3;
    while (1)
    {
      if (*(_DWORD *)(v2 + 80) == *((_DWORD *)this + 6))
      {
        unint64_t v7 = *(void *)(v2 + 64);
        if (v7 <= v4 && *(void *)(v2 + 8) + v7 > v4) {
          break;
        }
      }
      v2 += 88;
      v6 -= 88;
      if (!v6)
      {
        uint64_t v2 = v5;
        return *(void *)(v2 + 32);
      }
    }
  }
  return *(void *)(v2 + 32);
}

unint64_t llvm::object::MachOAbstractFixupEntry::address(llvm::object::MachOAbstractFixupEntry *this)
{
  unint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *(uint64_t **)(*((void *)this + 1) + 264);
  uint64_t v3 = *v2;
  unsigned int v4 = *((_DWORD *)v2 + 2);
  if (v4)
  {
    uint64_t v5 = v3 + 88 * v4;
    uint64_t v6 = 88 * v4;
    while (1)
    {
      if (*(_DWORD *)(v3 + 80) == *((_DWORD *)this + 6))
      {
        unint64_t v7 = *(void *)(v3 + 64);
        if (v7 <= v1 && *(void *)(v3 + 8) + v7 > v1) {
          break;
        }
      }
      v3 += 88;
      v6 -= 88;
      if (!v6)
      {
        uint64_t v3 = v5;
        return *(void *)(v3 + 72) + v1;
      }
    }
  }
  return *(void *)(v3 + 72) + v1;
}

uint64_t llvm::object::MachOAbstractFixupEntry::symbolName(llvm::object::MachOAbstractFixupEntry *this)
{
  return *((void *)this + 4);
}

uint64_t llvm::object::MachOAbstractFixupEntry::addend(llvm::object::MachOAbstractFixupEntry *this)
{
  return *((void *)this + 7);
}

uint64_t llvm::object::MachOAbstractFixupEntry::flags(llvm::object::MachOAbstractFixupEntry *this)
{
  return *((unsigned int *)this + 13);
}

uint64_t llvm::object::MachOAbstractFixupEntry::ordinal(llvm::object::MachOAbstractFixupEntry *this)
{
  return *((unsigned int *)this + 12);
}

const char *llvm::object::MachOAbstractFixupEntry::typeName(llvm::object::MachOAbstractFixupEntry *this)
{
  return "unknown";
}

uint64_t llvm::object::MachOAbstractFixupEntry::moveToFirst(uint64_t this)
{
  *(void *)(this + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 24) = -1;
  *(unsigned char *)(this + 80) = 0;
  *(void *)(this + 4++*(_DWORD *)(this + 8) = 0;
  *(void *)(this + 56) = 0;
  return this;
}

uint64_t llvm::object::MachOAbstractFixupEntry::moveToEnd(uint64_t this)
{
  *(unsigned char *)(this + 80) = 1;
  return this;
}

uint64_t llvm::object::MachOChainedFixupEntry::MachOChainedFixupEntry(uint64_t a1, long long **a2, llvm::object::MachOObjectFile *a3, int a4, int a5)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry(a1, (uint64_t)a2, (uint64_t)a3);
  *(_OWORD *)(v10 + 96) = 0u;
  uint64_t v11 = v10 + 96;
  *(_OWORD *)(v10 + 112) = 0u;
  *(_OWORD *)(v10 + 12++*(_DWORD *)(this + 8) = 0u;
  *(_DWORD *)(v10 + 144) = 0;
  *(_DWORD *)(v10 + 14++*(_DWORD *)(this + 8) = a4;
  if (!a5) {
    goto LABEL_37;
  }
  uint64_t v12 = (uint64_t *)(v10 + 120);
  if (*((void *)a3 + 44))
  {
    llvm::object::MachOObjectFile::getDyldSectionChainStarts(a3, (uint64_t)&v38);
    char v13 = v40;
    if ((v40 & 1) == 0)
    {
LABEL_4:
      if (v12 != (uint64_t *)&v38)
      {
        sub_1CCC6FE18(v12, v38, v39, 0x6DB6DB6DB6DB6DB7 * (((char *)v39 - (char *)v38) >> 3));
        char v13 = v40;
      }
      if ((v13 & 1) == 0)
      {
        unsigned int v37 = &v38;
        sub_1CCC6FD8C((void ***)&v37);
        goto LABEL_37;
      }
      goto LABEL_23;
    }
    long long v26 = v38;
    long long v38 = 0;
    *a2 = v26;
LABEL_23:
    long long v27 = v38;
    long long v38 = 0;
    if (v27) {
      (*(void (**)(long long *))(*(void *)v27 + 8))(v27);
    }
LABEL_37:
    if (!a2) {
      return a1;
    }
    goto LABEL_38;
  }
  llvm::object::MachOObjectFile::getDyldChainedFixupTargets((int8x16_t **)a3, (uint64_t)&v38);
  if ((v40 & 1) == 0)
  {
    if ((long long **)v11 == &v38)
    {
LABEL_36:
      sub_1CC1EB7C0((uint64_t)&v38);
      if (*(void *)(a1 + 128) != *(void *)(a1 + 120)) {
        goto LABEL_37;
      }
      llvm::object::MachOObjectFile::getDyldChainedFixupsInSegment(a3, (uint64_t)&v38);
      char v13 = v40;
      if ((v40 & 1) == 0) {
        goto LABEL_4;
      }
      long long v35 = v38;
      long long v38 = 0;
      *a2 = v35;
      goto LABEL_23;
    }
    long long v14 = v38;
    long long v15 = v39;
    int64_t v36 = (char *)v39 - (char *)v38;
    unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v39 - (char *)v38) >> 3);
    uint64_t v17 = *(void *)(a1 + 112);
    uint64_t v18 = *(char **)(a1 + 96);
    if (0xCCCCCCCCCCCCCCCDLL * ((v17 - (uint64_t)v18) >> 3) < v16)
    {
      if (v18)
      {
        *(void *)(a1 + 104) = v18;
        operator delete(v18);
        uint64_t v17 = 0;
        *(void *)uint64_t v11 = 0;
        *(void *)(v11 + ++*(_DWORD *)(this + 8) = 0;
        *(void *)(v11 + ++*(_DWORD *)(this + 16) = 0;
      }
      if (v16 > 0x666666666666666) {
        goto LABEL_43;
      }
      unint64_t v19 = 0xCCCCCCCCCCCCCCCDLL * (v17 >> 3);
      uint64_t v20 = 2 * v19;
      if (2 * v19 <= v16) {
        uint64_t v20 = v16;
      }
      unint64_t v21 = v19 >= 0x333333333333333 ? 0x666666666666666 : v20;
      if (v21 > 0x666666666666666) {
LABEL_43:
      }
        abort();
      uint64_t v22 = 5 * v21;
      uint64_t v23 = (char *)operator new(40 * v21);
      uint64_t v18 = v23;
      *(void *)(a1 + 104) = v23;
      uint64_t v24 = (char **)(a1 + 104);
      *(void *)(a1 + 96) = v23;
      *(void *)(a1 + 112) = &v23[8 * v22];
      if (v15 != v14)
      {
        int64_t v25 = v36;
        memcpy(v23, v14, v36 - 7);
LABEL_35:
        *uint64_t v24 = &v18[v25];
        goto LABEL_36;
      }
LABEL_34:
      int64_t v25 = v36;
      goto LABEL_35;
    }
    uint64_t v24 = (char **)(a1 + 104);
    long long v29 = *(unsigned char **)(a1 + 104);
    if (0xCCCCCCCCCCCCCCCDLL * ((v29 - v18) >> 3) >= v16)
    {
      if (v39 == v38) {
        goto LABEL_34;
      }
      int64_t v25 = (char *)v39 - (char *)v38;
      size_t v31 = v36 - 7;
      uint64_t v32 = *(void **)(a1 + 96);
      uint64_t v33 = v38;
    }
    else
    {
      int v30 = (long long *)((char *)v38 + 8 * ((v29 - v18) >> 3));
      if (v29 != v18)
      {
        memmove(*(void **)(a1 + 96), v38, v29 - v18 - 7);
        uint64_t v18 = *v24;
      }
      int64_t v25 = (char *)v15 - (char *)v30;
      if (v15 == v30) {
        goto LABEL_35;
      }
      size_t v31 = v25 - 7;
      uint64_t v32 = v18;
      uint64_t v33 = v30;
    }
    memmove(v32, v33, v31);
    goto LABEL_35;
  }
  __int16 v28 = v38;
  long long v38 = 0;
  *a2 = v28;
  sub_1CC1EB7C0((uint64_t)&v38);
LABEL_38:
  if (!*a2) {
    *a2 = 0;
  }
  return a1;
}

void llvm::object::MachOObjectFile::getDyldSectionChainStarts(llvm::object::MachOObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  int64x2_t v42 = 0uLL;
  unint64_t v43 = 0;
  unint64_t v3 = *((void *)this + 44);
  if (!v3)
  {
    *(unsigned char *)(a2 + 24) &= ~1u;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
    *(void *)(a2 + ++*(_DWORD *)(this + 16) = 0;
    *(void *)a2 = 0;
    goto LABEL_41;
  }
  if ((*((_DWORD *)this + 2) & 0xFFFFFFFE) == 0x12)
  {
    sub_1CCC65698((uint64_t)v44, (uint64_t)this, v3);
    if ((v49 & 1) == 0)
    {
      unint64_t v5 = v46;
      unint64_t v6 = v47;
      goto LABEL_8;
    }
LABEL_36:
    uint64_t v25 = *(void *)&v44[0];
    *(unsigned char *)(a2 + 24) |= 1u;
    *(void *)a2 = v25;
    goto LABEL_41;
  }
  sub_1CCC65770((uint64_t)v44, (uint64_t)this, v3);
  if (v48) {
    goto LABEL_36;
  }
  unint64_t v5 = HIDWORD(v45);
  unint64_t v6 = v46;
LABEL_8:
  unint64_t v41 = v6;
  if (!(v6 | v5))
  {
    *(unsigned char *)(a2 + 24) &= ~1u;
    *(int64x2_t *)a2 = v42;
    *(void *)(a2 + ++*(_DWORD *)(this + 16) = v43;
    int64x2_t v42 = 0uLL;
    unint64_t v43 = 0;
    goto LABEL_41;
  }
  unint64_t v7 = *((void *)this + 3);
  if (v6 >= v7)
  {
    v38[0] = (uint64_t)"bad chained fixups: chain starts section ";
    __int16 v39 = 259;
    __int16 v37 = 268;
    v36[0] = (uint64_t)&v41;
    sub_1CD3E3950(v38, v36, (uint64_t)v40);
    long long v27 = " starts past end of file";
LABEL_47:
    v34[0] = (uint64_t)v27;
    __int16 v35 = 259;
    __int16 v28 = v34;
LABEL_49:
    sub_1CD3E3950(v40, v28, (uint64_t)v44);
    long long v26 = (llvm *)v44;
    goto LABEL_43;
  }
  if (v5 + v6 > v7)
  {
    v38[0] = (uint64_t)"bad chained fixups: chain starts section ";
    __int16 v39 = 259;
    __int16 v37 = 268;
    v36[0] = (uint64_t)&v41;
    sub_1CD3E3950(v38, v36, (uint64_t)v40);
    long long v27 = " extends past end of file";
    goto LABEL_47;
  }
  unsigned int v8 = (unsigned int *)(*((void *)this + 2) + v6);
  unsigned int v9 = *((_DWORD *)this + 2);
  unsigned int v10 = bswap32(*v8);
  unsigned int v11 = bswap32(v8[1]);
  if (((1 << v9) & 0xAAC00) != 0)
  {
    int v12 = 0;
  }
  else
  {
    unsigned int v10 = *v8;
    int v12 = 1;
  }
  if (((1 << v9) & 0xAAC00) == 0) {
    unsigned int v11 = v8[1];
  }
  if (v9 <= 0x13) {
    unsigned int v13 = v10;
  }
  else {
    unsigned int v13 = *v8;
  }
  if (v9 <= 0x13) {
    int v14 = v12;
  }
  else {
    int v14 = 1;
  }
  if (v9 <= 0x13) {
    unsigned int v15 = v11;
  }
  else {
    unsigned int v15 = v8[1];
  }
  if (v13 - 13 <= 0xFFFFFFF3)
  {
    v36[0] = (uint64_t)"bad chained fixups: chain starts section ";
    __int16 v37 = 259;
    v34[0] = (uint64_t)"pointer format ";
    __int16 v35 = 259;
    sub_1CD3E3950(v36, v34, (uint64_t)v38);
    __int16 v33 = 264;
    LODWORD(v32[0]) = v13;
    sub_1CD3E3950(v38, v32, (uint64_t)v40);
    int v30 = " is invalid";
    __int16 v31 = 259;
    __int16 v28 = (uint64_t *)&v30;
    goto LABEL_49;
  }
  LOWORD(v44[0]) = v13;
  memset((char *)v44 + 8, 0, 20);
  unint64_t v46 = 0;
  uint64_t v47 = 0;
  long long v45 = 0;
  if (v15)
  {
    uint64_t v16 = 0;
    uint64_t v17 = -(uint64_t)v15;
    unint64_t v18 = 8;
    while (v18 <= v5)
    {
      unsigned int v19 = bswap32(v8[v18 / 4]);
      if (v14) {
        unsigned int v20 = v8[v18 / 4];
      }
      else {
        unsigned int v20 = v19;
      }
      llvm::object::ChainedFixupsInSegment::walkFixupChain((llvm::object::ChainedFixupsInSegment *)v44, this, 0, 0, v20, (unint64_t *)v40);
      if (v40[0])
      {
        uint64_t v29 = v40[0];
        llvm::report_fatal_error(&v29);
      }
      --v16;
      v18 += 4;
      if (v17 == v16) {
        goto LABEL_34;
      }
    }
    v36[0] = (uint64_t)"bad chained fixups: chain start ";
    __int16 v37 = 259;
    __int16 v35 = 264;
    LODWORD(v34[0]) = -(int)v16;
    sub_1CD3E3950(v36, v34, (uint64_t)v38);
    v32[0] = (uint64_t)" extends past section data";
    __int16 v33 = 259;
    sub_1CD3E3950(v38, v32, (uint64_t)v40);
    long long v26 = (llvm *)v40;
LABEL_43:
    llvm::report_fatal_error(v26, (const llvm::Twine *)1);
  }
LABEL_34:
  uint64_t v22 = v42.i64[1];
  unint64_t v21 = v43;
  if (v42.i64[1] >= v43)
  {
    uint64_t v24 = sub_1CCC70274(&v42, (uint64_t)v44);
    unint64_t v21 = v43;
    uint64_t v23 = v45;
  }
  else
  {
    *(_OWORD *)v42.i64[1] = v44[0];
    *(_OWORD *)(v22 + 12) = *(_OWORD *)((char *)v44 + 12);
    *(void *)(v22 + 40) = 0;
    *(void *)(v22 + 4++*(_DWORD *)(this + 8) = 0;
    *(void *)(v22 + 32) = 0;
    uint64_t v23 = v45;
    sub_1CBFCBA2C((void *)(v22 + 32), v45, v46, (uint64_t)(v46 - (void)v45) >> 3);
    uint64_t v24 = (char *)(v22 + 56);
  }
  *(unsigned char *)(a2 + 24) &= ~1u;
  *(void *)a2 = v42.i64[0];
  *(void *)(a2 + ++*(_DWORD *)(this + 8) = v24;
  *(void *)(a2 + ++*(_DWORD *)(this + 16) = v21;
  unint64_t v43 = 0;
  int64x2_t v42 = 0uLL;
  if (v23) {
    operator delete(v23);
  }
LABEL_41:
  *(void *)&v44[0] = &v42;
  sub_1CCC6FD8C((void ***)v44);
}

void llvm::object::MachOObjectFile::getDyldChainedFixupTargets(int8x16_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getChainedFixupsHeader((uint64_t)this, (uint64_t)&v92);
  if (v98)
  {
    uint64_t v55 = v92;
    uint64_t v92 = 0;
    *(unsigned char *)(a2 + 24) |= 1u;
    *(void *)a2 = v55;
  }
  else if (v97)
  {
    int v4 = v93;
    uint64_t v5 = v94;
    uint64_t v7 = v95;
    int v6 = v96;
    uint64_t v59 = this;
    sub_1CCC6517C(&v90, (uint64_t)this, this[41]);
    if (v91)
    {
      uint64_t v56 = v90.i64[0];
      v90.i64[0] = 0;
      *(unsigned char *)(a2 + 24) |= 1u;
      *(void *)a2 = v56;
    }
    else
    {
      uint64_t v58 = a2;
      if (v7)
      {
        uint64_t v8 = 0;
        unsigned int v9 = 0;
        unsigned int v10 = 0;
        unsigned int v11 = 0;
        unint64_t v64 = &v59[2]->i8[v90.u32[2] + v5];
        long long v65 = v59[2];
        unsigned int v12 = v90.i32[3] - v5;
        unsigned int v13 = v59;
        unsigned int v60 = v12;
        int v61 = v90.i32[2] + v4;
        int v63 = v6;
        uint64_t v62 = v7;
        while (1)
        {
          switch(v6)
          {
            case 3:
              uint64_t v24 = v13[2];
              uint64_t v25 = (unint64_t *)((char *)v24->u64 + (v61 + 16 * v8));
              if ((__int8 *)(v25 + 2) > &v13[3]->i8[(void)v24]) {
                goto LABEL_92;
              }
              unint64_t v27 = *v25;
              unint64_t v26 = v25[1];
              unsigned int v28 = *((_DWORD *)v13 + 2);
              unint64_t v29 = bswap64(v27);
              unint64_t v30 = bswap64(v26);
              if (((1 << v28) & 0xAAC00) == 0)
              {
                unint64_t v30 = v26;
                unint64_t v29 = v27;
              }
              if (v28 <= 0x13) {
                unint64_t v22 = v30;
              }
              else {
                unint64_t v22 = v26;
              }
              if (v28 <= 0x13) {
                unint64_t v31 = v29;
              }
              else {
                unint64_t v31 = v27;
              }
              unint64_t v19 = HIDWORD(v31);
              uint64_t v20 = (v31 >> 16) & 1;
              LODWORD(v31) = (unsigned __int16)v31;
              int v32 = v31;
              if ((unsigned __int16)v31 == 65534) {
                LODWORD(v31) = -2;
              }
              if (v32 == 0xFFFF) {
                LODWORD(v31) = -1;
              }
              if (v32 == 65533) {
                int v23 = -3;
              }
              else {
                int v23 = v31;
              }
              break;
            case 2:
              __int16 v33 = v13[2];
              char v34 = (unsigned __int32 *)((char *)v33->u32 + (v61 + 8 * v8));
              if ((__int8 *)(v34 + 2) > &v13[3]->i8[(void)v33])
              {
LABEL_92:
                v88[0] = (uint64_t)"Structure read out-of-range";
                __int16 v89 = 259;
                sub_1CCC51CE4((uint64_t)v87, v88);
              }
              unsigned int v36 = *v34;
              signed int v35 = v34[1];
              unsigned int v37 = *((_DWORD *)v13 + 2);
              unsigned int v38 = bswap32(v36);
              unsigned int v39 = bswap32(v35);
              if (((1 << v37) & 0xAAC00) == 0)
              {
                unsigned int v39 = v35;
                unsigned int v38 = v36;
              }
              if (v37 <= 0x13)
              {
                signed int v35 = v39;
                unsigned int v36 = v38;
              }
              LODWORD(v19) = v36 >> 9;
              unint64_t v22 = v35;
              LODWORD(v20) = (v36 >> 8) & 1;
              int v40 = v36;
              if (v36 == 254) {
                unsigned int v36 = -2;
              }
              else {
                unsigned int v36 = v36;
              }
              if (v40 == 255) {
                unsigned int v36 = -1;
              }
              if (v40 == 253) {
                int v23 = -3;
              }
              else {
                int v23 = v36;
              }
              break;
            case 1:
              int v14 = v13[2];
              unsigned int v15 = (unsigned __int32 *)((char *)v14->u32 + (v61 + 4 * v8));
              if ((__int8 *)(v15 + 1) > &v13[3]->i8[(void)v14]) {
                goto LABEL_92;
              }
              unsigned int v16 = *v15;
              unsigned int v17 = *((_DWORD *)v13 + 2);
              unsigned int v18 = bswap32(v16);
              if (((1 << v17) & 0xAAC00) == 0) {
                unsigned int v18 = v16;
              }
              if (v17 <= 0x13) {
                unsigned int v16 = v18;
              }
              LODWORD(v19) = v16 >> 9;
              LODWORD(v20) = (v16 >> 8) & 1;
              if (v16 == 254) {
                int v21 = -2;
              }
              else {
                int v21 = v16;
              }
              if (v16 == 255) {
                int v21 = -1;
              }
              unint64_t v22 = 0;
              if (v16 == 253) {
                int v23 = -3;
              }
              else {
                int v23 = v21;
              }
              break;
            default:
              int v23 = 0;
              LODWORD(v19) = 0;
              unint64_t v22 = 0;
              LOBYTE(v20) = 0;
              goto LABEL_54;
          }
          if (v19 > v60)
          {
            v78[0] = (uint64_t)"bad chained fixups: import #";
            __int16 v79 = 259;
            __int16 v77 = 264;
            LODWORD(v76[0]) = v8;
            sub_1CD3E3950(v78, v76, (uint64_t)v80);
            long long v74 = " symbol offset extends past end: ";
            __int16 v75 = 259;
            sub_1CD3E3950(v80, (uint64_t *)&v74, (uint64_t)v82);
            __int16 v73 = 264;
            LODWORD(v72[0]) = v19;
            sub_1CD3E3950(v82, v72, (uint64_t)v84);
            char v70 = " (max ";
            __int16 v71 = 259;
            sub_1CD3E3950(v84, (uint64_t *)&v70, (uint64_t)v86);
            __int16 v69 = 264;
            LODWORD(v68[0]) = v60;
            sub_1CD3E3950(v86, v68, (uint64_t)v87);
            unint64_t v66 = ")";
            __int16 v67 = 259;
            unint64_t v57 = (uint64_t *)&v66;
            goto LABEL_94;
          }
LABEL_54:
          unint64_t v41 = &v64[v19];
          if (v65)
          {
            char v42 = v20;
            size_t v43 = strlen(v41);
            LOBYTE(v20) = v42;
            size_t v44 = v43;
          }
          else
          {
            size_t v44 = 0;
          }
          if (v23 >= 1 && *((_DWORD *)v13 + 28) <= (v23 - 1))
          {
            v84[0] = (uint64_t)"bad chained fixups: import #";
            __int16 v85 = 259;
            __int16 v83 = 264;
            LODWORD(v82[0]) = v8;
            sub_1CD3E3950(v84, v82, (uint64_t)v86);
            v80[0] = (uint64_t)" bad library ordinal: ";
            __int16 v81 = 259;
            sub_1CD3E3950(v86, v80, (uint64_t)v87);
            __int16 v79 = 265;
            LODWORD(v78[0]) = v23;
            unint64_t v57 = v78;
LABEL_94:
            sub_1CD3E3950(v87, v57, (uint64_t)v88);
            llvm::report_fatal_error((llvm *)v88, (const llvm::Twine *)1);
          }
          if (v10 >= v9)
          {
            unint64_t v47 = 0xCCCCCCCCCCCCCCCDLL * (((char *)v10 - v11) >> 3) + 1;
            if (v47 > 0x666666666666666) {
              abort();
            }
            if (0x999999999999999ALL * (((char *)v9 - v11) >> 3) > v47) {
              unint64_t v47 = 0x999999999999999ALL * (((char *)v9 - v11) >> 3);
            }
            if (0xCCCCCCCCCCCCCCCDLL * (((char *)v9 - v11) >> 3) >= 0x333333333333333) {
              unint64_t v48 = 0x666666666666666;
            }
            else {
              unint64_t v48 = v47;
            }
            if (v48)
            {
              if (v48 > 0x666666666666666) {
                sub_1CB833614();
              }
              char v49 = v20;
              uint64_t v50 = (char *)operator new(40 * v48);
              LOBYTE(v20) = v49;
            }
            else
            {
              uint64_t v50 = 0;
            }
            unint64_t v51 = &v50[8 * (((char *)v10 - v11) >> 3)];
            *(_DWORD *)unint64_t v51 = v23;
            *((void *)v51 + 1) = v41;
            *((void *)v51 + 2) = v44;
            *((void *)v51 + 3) = v22;
            v51[32] = v20;
            if (v10 == (int *)v11)
            {
              unsigned int v11 = &v50[8 * (((char *)v10 - v11) >> 3)];
              unsigned int v13 = v59;
              uint64_t v46 = v62;
            }
            else
            {
              char v52 = &v50[8 * (((char *)v10 - v11) >> 3)];
              unsigned int v13 = v59;
              uint64_t v46 = v62;
              do
              {
                long long v53 = *(_OWORD *)(v10 - 10);
                long long v54 = *(_OWORD *)(v10 - 6);
                *(v52 - ++*(_DWORD *)(this + 8) = *((unsigned char *)v10 - 8);
                *(_OWORD *)(v52 - 24) = v54;
                *(_OWORD *)(v52 - 40) = v53;
                v52 -= 40;
                v10 -= 10;
              }
              while (v10 != (int *)v11);
              unsigned int v10 = (int *)v11;
              unsigned int v11 = v52;
            }
            int v6 = v63;
            unsigned int v9 = (int *)&v50[40 * v48];
            long long v45 = (int *)(v51 + 40);
            if (v10) {
              operator delete(v10);
            }
          }
          else
          {
            *unsigned int v10 = v23;
            *((void *)v10 + 1) = v41;
            *((void *)v10 + 2) = v44;
            *((void *)v10 + 3) = v22;
            *((unsigned char *)v10 + 32) = v20;
            *(int *)((char *)v10 + 33) = v88[0];
            v10[9] = *(_DWORD *)((char *)v88 + 3);
            long long v45 = v10 + 10;
            uint64_t v46 = v62;
            int v6 = v63;
          }
          ++v8;
          unsigned int v10 = v45;
          if (v8 == v46) {
            goto LABEL_84;
          }
        }
      }
      unsigned int v11 = 0;
      long long v45 = 0;
      unsigned int v9 = 0;
LABEL_84:
      *(unsigned char *)(v58 + 24) &= ~1u;
      *(void *)uint64_t v58 = v11;
      *(void *)(v58 + ++*(_DWORD *)(this + 8) = v45;
      *(void *)(v58 + ++*(_DWORD *)(this + 16) = v9;
    }
    if ((v91 & 1) != 0 && v90.i64[0]) {
      (*(void (**)(uint64_t))(*(void *)v90.i64[0] + 8))(v90.i64[0]);
    }
  }
  else
  {
    *(unsigned char *)(a2 + 24) &= ~1u;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
    *(void *)(a2 + ++*(_DWORD *)(this + 16) = 0;
    *(void *)a2 = 0;
  }
  if (v98)
  {
    if (v92) {
      (*(void (**)(uint64_t))(*(void *)v92 + 8))(v92);
    }
  }
}

void llvm::object::MachOObjectFile::getDyldChainedFixupsInSegment(llvm::object::MachOObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v137 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (int8x16_t *)*((void *)this + 41);
  if (!v3)
  {
    *(unsigned char *)(a2 + 24) &= ~1u;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
    *(void *)(a2 + ++*(_DWORD *)(this + 16) = 0;
    *(void *)a2 = 0;
    memset(v131, 0, 24);
    v129[0] = (void **)v131;
    sub_1CCC6FD8C(v129);
    return;
  }
  sub_1CCC6517C(&v135, (uint64_t)this, v3);
  if (v136)
  {
    uint64_t v34 = v135.i64[0];
    *(unsigned char *)(a2 + 24) |= 1u;
    *(void *)a2 = v34;
    return;
  }
  int64x2_t v127 = 0uLL;
  unint64_t v128 = 0;
  if (!v135.i32[2])
  {
    *(unsigned char *)(a2 + 24) &= ~1u;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = 0;
    *(void *)(a2 + ++*(_DWORD *)(this + 16) = 0;
    *(void *)a2 = 0;
    goto LABEL_119;
  }
  __int32 v91 = v135.i32[3];
  uint64_t v93 = v135.u32[2];
  uint64_t v88 = a2;
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    int v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = *((void *)this + 16);
    uint64_t v9 = v8 + 16 * v5;
    uint64_t v95 = v9;
    char v98 = 0;
    while (1)
    {
      int v10 = *(_DWORD *)(v8 + 8);
      if (v10 == 25) {
        break;
      }
      if (v10 == 1)
      {
        *(void *)&long long v133 = 0;
        long long v132 = 0u;
        memset(v131, 0, sizeof(v131));
        llvm::object::MachOObjectFile::getSegmentLoadCommand((uint64_t)this, (unint64_t *)v8, (uint64_t)v131);
        size_t v11 = strlen((const char *)v131 + 8);
        size_t v12 = v11;
        uint64_t v13 = DWORD2(v131[1]);
        uint64_t v14 = HIDWORD(v131[1]);
        uint64_t v16 = v132;
        uint64_t v15 = DWORD1(v132);
        if (v6 < v98)
        {
          *(void *)int v6 = (char *)v131 + 8;
          *((void *)v6 + 1) = v11;
          *((void *)v6 + 2) = v13;
          *((void *)v6 + 3) = v14;
          unsigned int v17 = v6 + 48;
          *((void *)v6 + 4) = v16;
          *((void *)v6 + 5) = v15;
LABEL_41:
          int v6 = v17;
          goto LABEL_42;
        }
        unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4) + 1;
        unint64_t v24 = 0x555555555555555;
        if (v23 > 0x555555555555555) {
          goto LABEL_131;
        }
        if (0x5555555555555556 * ((v98 - v7) >> 4) > v23) {
          unint64_t v23 = 0x5555555555555556 * ((v98 - v7) >> 4);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v98 - v7) >> 4) < 0x2AAAAAAAAAAAAAALL) {
          unint64_t v24 = v23;
        }
        if (v24)
        {
          if (v24 > 0x555555555555555) {
            goto LABEL_139;
          }
          uint64_t v25 = DWORD1(v132);
          unint64_t v99 = v24;
          unint64_t v26 = (char *)operator new(48 * v24);
          unint64_t v24 = v99;
          uint64_t v15 = v25;
        }
        else
        {
          unint64_t v26 = 0;
        }
        unsigned int v28 = &v26[16 * ((v6 - v7) >> 4)];
        *(void *)unsigned int v28 = (char *)v131 + 8;
        *((void *)v28 + 1) = v12;
        *((void *)v28 + 2) = v13;
        *((void *)v28 + 3) = v14;
        *((void *)v28 + 4) = v16;
        *((void *)v28 + 5) = v15;
        if (v6 != v7)
        {
          unint64_t v29 = &v26[16 * ((v6 - v7) >> 4)];
          uint64_t v9 = v95;
          do
          {
            long long v30 = *((_OWORD *)v6 - 3);
            long long v31 = *((_OWORD *)v6 - 1);
            *((_OWORD *)v29 - 2) = *((_OWORD *)v6 - 2);
            *((_OWORD *)v29 - 1) = v31;
            *((_OWORD *)v29 - 3) = v30;
            v29 -= 48;
            v6 -= 48;
          }
          while (v6 != v7);
          goto LABEL_37;
        }
LABEL_38:
        uint64_t v7 = v28;
        uint64_t v9 = v95;
        goto LABEL_39;
      }
LABEL_42:
      v8 += 16;
      if (v8 == v9) {
        goto LABEL_48;
      }
    }
    uint64_t v134 = 0;
    long long v132 = 0u;
    long long v133 = 0u;
    memset(v131, 0, sizeof(v131));
    llvm::object::MachOObjectFile::getSegment64LoadCommand((uint64_t)this, (unint64_t *)v8, (uint64_t)v131);
    size_t v18 = strlen((const char *)v131 + 8);
    size_t v19 = v18;
    uint64_t v20 = *((void *)&v131[1] + 1);
    long long v22 = v132;
    uint64_t v21 = v133;
    if (v6 < v98)
    {
      *(void *)int v6 = (char *)v131 + 8;
      *((void *)v6 + 1) = v18;
      *((void *)v6 + 2) = v20;
      *(_OWORD *)(v6 + 24) = v22;
      unsigned int v17 = v6 + 48;
      *((void *)v6 + 5) = v21;
      uint64_t v9 = v95;
      goto LABEL_41;
    }
    unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 4) + 1;
    unint64_t v24 = 0x555555555555555;
    if (v27 > 0x555555555555555) {
LABEL_131:
    }
      abort();
    if (0x5555555555555556 * ((v98 - v7) >> 4) > v27) {
      unint64_t v27 = 0x5555555555555556 * ((v98 - v7) >> 4);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((v98 - v7) >> 4) < 0x2AAAAAAAAAAAAAALL) {
      unint64_t v24 = v27;
    }
    if (v24)
    {
      if (v24 > 0x555555555555555) {
LABEL_139:
      }
        sub_1CB833614();
      unint64_t v100 = v24;
      unint64_t v26 = (char *)operator new(48 * v24);
      unint64_t v24 = v100;
    }
    else
    {
      unint64_t v26 = 0;
    }
    unsigned int v28 = &v26[16 * ((v6 - v7) >> 4)];
    *(void *)unsigned int v28 = (char *)v131 + 8;
    *((void *)v28 + 1) = v19;
    *((void *)v28 + 2) = v20;
    *(_OWORD *)(v28 + 24) = v22;
    *((void *)v28 + 5) = v21;
    if (v6 == v7) {
      goto LABEL_38;
    }
    unint64_t v29 = &v26[16 * ((v6 - v7) >> 4)];
    uint64_t v9 = v95;
    do
    {
      long long v32 = *((_OWORD *)v6 - 3);
      long long v33 = *((_OWORD *)v6 - 1);
      *((_OWORD *)v29 - 2) = *((_OWORD *)v6 - 2);
      *((_OWORD *)v29 - 1) = v33;
      *((_OWORD *)v29 - 3) = v32;
      v29 -= 48;
      v6 -= 48;
    }
    while (v6 != v7);
LABEL_37:
    int v6 = v7;
    uint64_t v7 = v29;
LABEL_39:
    char v98 = &v26[48 * v24];
    unsigned int v17 = v28 + 48;
    if (v6) {
      operator delete(v6);
    }
    goto LABEL_41;
  }
  uint64_t v7 = 0;
LABEL_48:
  sub_1CCC65230((uint64_t)v129, (uint64_t)this, *((void *)this + 2) + v93);
  if (v130)
  {
    __int16 v81 = v129[0];
    *(unsigned char *)(v88 + 24) |= 1u;
    *(void *)uint64_t v88 = v81;
    if (!v7) {
      goto LABEL_119;
    }
    goto LABEL_118;
  }
  if (LODWORD(v129[0]))
  {
    v125[0] = (uint64_t)"bad chained fixups: unknown version: ";
    __int16 v126 = 259;
    __int16 v124 = 264;
    LODWORD(v123[0]) = v129[0];
    unint64_t v87 = v123;
LABEL_137:
    sub_1CD3E3950(v125, v87, (uint64_t)v131);
    long long v82 = (llvm *)v131;
    goto LABEL_125;
  }
  if (HIDWORD(v129[0]) <= 0x1B)
  {
    v123[0] = (uint64_t)"bad chained fixups: image starts offset ";
    __int16 v124 = 259;
    __int16 v122 = 264;
    LODWORD(v121[0]) = HIDWORD(v129[0]);
    sub_1CD3E3950(v123, v121, (uint64_t)v125);
    v119[0] = (uint64_t)" overlaps with chained fixups header";
    __int16 v120 = 259;
    unint64_t v87 = v119;
    goto LABEL_137;
  }
  int v89 = HIDWORD(v129[0]);
  uint64_t v35 = HIDWORD(v129[0]) + v93;
  unint64_t v36 = (v91 + v93);
  if (v35 + 8 > v36)
  {
    v121[0] = (uint64_t)"bad chained fixups: image starts end ";
    __int16 v122 = 259;
    v112[0] = HIDWORD(v129[0]) + v93 + 8;
    __int16 v120 = 268;
    v119[0] = (uint64_t)v112;
    sub_1CD3E3950(v121, v119, (uint64_t)v123);
    v117[0] = (uint64_t)" extends past end ";
    __int16 v118 = 259;
    sub_1CD3E3950(v123, v117, (uint64_t)v125);
    __int16 v116 = 264;
    LODWORD(v115[0]) = v91 + v93;
    unint64_t v87 = v115;
    goto LABEL_137;
  }
  char v97 = (unsigned int *)(*((void *)this + 2) + v35);
  LODWORD(v37) = *v97;
  unsigned int v38 = *((_DWORD *)this + 2);
  unsigned int v39 = bswap32(*v97);
  if (((1 << v38) & 0xAAC00) == 0) {
    unsigned int v39 = *v97;
  }
  BOOL v40 = v38 > 0x13 || ((1 << v38) & 0xAAC00) == 0;
  if (v38 <= 0x13) {
    uint64_t v37 = v39;
  }
  else {
    uint64_t v37 = v37;
  }
  uint64_t v96 = v37;
  if (v37)
  {
    uint64_t v41 = 0;
    uint64_t v90 = HIDWORD(v129[0]) + v93;
    unint64_t v92 = (v91 + v93);
    do
    {
      unint64_t v42 = v35 + 4 * v41;
      unint64_t v114 = v42;
      if (v42 > v36)
      {
        v117[0] = (uint64_t)"bad chained fixups: seg_info_offset ";
        __int16 v118 = 259;
        __int16 v116 = 264;
        LODWORD(v115[0]) = v41;
        sub_1CD3E3950(v117, v115, (uint64_t)v119);
        v112[0] = (uint64_t)" at ";
        __int16 v113 = 259;
        sub_1CD3E3950(v119, v112, (uint64_t)v121);
        __int16 v111 = 268;
        __int16 v85 = (uint64_t *)&v114;
        goto LABEL_134;
      }
      uint64_t v43 = v42 + 4;
      if (v42 + 4 > v36)
      {
        v117[0] = (uint64_t)"bad chained fixups: seg_info_offset ";
        __int16 v118 = 259;
        __int16 v116 = 264;
        LODWORD(v115[0]) = v41;
        sub_1CD3E3950(v117, v115, (uint64_t)v119);
        v112[0] = (uint64_t)" at ";
        __int16 v113 = 259;
        sub_1CD3E3950(v119, v112, (uint64_t)v121);
        v104[0] = v43;
        __int16 v111 = 268;
        v110[0] = (uint64_t)v104;
        sub_1CD3E3950(v121, v110, (uint64_t)v123);
        uint64_t v86 = " extends past end ";
        goto LABEL_136;
      }
      unsigned int v44 = v97[v41 + 1];
      unsigned int v45 = bswap32(v44);
      if (!v40) {
        unsigned int v44 = v45;
      }
      if (v44)
      {
        uint64_t v46 = v44 + v35;
        if (v46 > v36)
        {
          v117[0] = (uint64_t)"bad chained fixups: segment start ";
          __int16 v118 = 259;
          __int16 v116 = 264;
          LODWORD(v115[0]) = v41;
          sub_1CD3E3950(v117, v115, (uint64_t)v119);
          v112[0] = (uint64_t)" offset ";
          __int16 v113 = 259;
          sub_1CD3E3950(v119, v112, (uint64_t)v121);
          __int16 v111 = 264;
          LODWORD(v110[0]) = v46;
          sub_1CD3E3950(v121, v110, (uint64_t)v123);
          uint64_t v86 = " starts past end ";
          goto LABEL_136;
        }
        if (v46 + 24 > v36)
        {
          v117[0] = (uint64_t)"bad chained fixups: segment start ";
          __int16 v118 = 259;
          __int16 v116 = 264;
          LODWORD(v115[0]) = v41;
          sub_1CD3E3950(v117, v115, (uint64_t)v119);
          v112[0] = (uint64_t)" end ";
          __int16 v113 = 259;
          sub_1CD3E3950(v119, v112, (uint64_t)v121);
          v104[0] = v46 + 24;
          __int16 v111 = 266;
          __int16 v85 = v104;
LABEL_134:
          v110[0] = (uint64_t)v85;
          sub_1CD3E3950(v121, v110, (uint64_t)v123);
          uint64_t v86 = " starts past end ";
LABEL_136:
          v108[0] = (uint64_t)v86;
          __int16 v109 = 259;
          sub_1CD3E3950(v123, v108, (uint64_t)v125);
          __int16 v107 = 264;
          LODWORD(v106[0]) = v36;
          unint64_t v87 = v106;
          goto LABEL_137;
        }
        uint64_t v47 = *((void *)this + 2) + v46;
        unsigned int v48 = *(_DWORD *)v47;
        unsigned int v49 = *(unsigned __int16 *)(v47 + 4);
        unsigned int v50 = *(unsigned __int16 *)(v47 + 6);
        unsigned int v51 = *(_DWORD *)(v47 + 16);
        unsigned int v52 = *(unsigned __int16 *)(v47 + 20);
        if (!v40)
        {
          unsigned int v48 = bswap32(v48);
          unsigned int v49 = __rev16(v49);
          unsigned int v50 = __rev16(v50);
          unsigned int v51 = bswap32(v51);
          unsigned int v52 = bswap32(v52);
        }
        int v53 = v48 + v89;
        if (v48 + v89 > v36)
        {
          v117[0] = (uint64_t)"bad chained fixups: segment start ";
          __int16 v118 = 259;
          __int16 v116 = 264;
          LODWORD(v115[0]) = v41;
          sub_1CD3E3950(v117, v115, (uint64_t)v119);
          v112[0] = (uint64_t)" end ";
          __int16 v113 = 259;
          sub_1CD3E3950(v119, v112, (uint64_t)v121);
          __int16 v111 = 264;
          LODWORD(v110[0]) = v53;
          sub_1CD3E3950(v121, v110, (uint64_t)v123);
          uint64_t v86 = " extends past end ";
          goto LABEL_136;
        }
        long long v54 = &v7[48 * v41];
        uint64_t v55 = *((void *)v54 + 2);
        uint64_t v56 = *((void *)v54 + 4);
        if (v49 != 4096 && v49 != 0x4000)
        {
          v119[0] = (uint64_t)"bad chained fixups: segment start ";
          __int16 v120 = 259;
          __int16 v118 = 264;
          LODWORD(v117[0]) = v41;
          sub_1CD3E3950(v119, v117, (uint64_t)v121);
          v115[0] = (uint64_t)" page size ";
          __int16 v116 = 259;
          sub_1CD3E3950(v121, v115, (uint64_t)v123);
          __int16 v113 = 265;
          LODWORD(v112[0]) = v49;
          sub_1CD3E3950(v123, v112, (uint64_t)v125);
          v110[0] = (uint64_t)" is invalid";
          __int16 v111 = 259;
LABEL_142:
          unint64_t v87 = v110;
          goto LABEL_137;
        }
        unsigned int v94 = v48;
        uint64_t v101 = v41;
        if ((unsigned __int16)(v50 - 13) <= 0xFFF3u)
        {
          v119[0] = (uint64_t)"bad chained fixups: segment start ";
          __int16 v120 = 259;
          __int16 v118 = 264;
          LODWORD(v117[0]) = v41;
          sub_1CD3E3950(v119, v117, (uint64_t)v121);
          v115[0] = (uint64_t)" pointer format ";
          __int16 v116 = 259;
          sub_1CD3E3950(v121, v115, (uint64_t)v123);
          __int16 v113 = 265;
          LODWORD(v112[0]) = v50;
          sub_1CD3E3950(v123, v112, (uint64_t)v125);
          v110[0] = (uint64_t)" is invalid";
          __int16 v111 = 259;
          goto LABEL_142;
        }
        LOWORD(v131[0]) = v50;
        *((void *)&v131[0] + 1) = v55;
        *(void *)&v131[1] = v56;
        DWORD2(v131[1]) = v51;
        *(void *)&long long v133 = 0;
        long long v132 = 0uLL;
        if (v52)
        {
          if (v48 >= 0x18)
          {
            uint64_t v57 = 0;
            unsigned __int16 v58 = 0;
            while (1)
            {
              unsigned int v59 = *(unsigned __int16 *)(v47 + 2 * v57 + 22);
              unsigned int v60 = bswap32(v59) >> 16;
              if (!v40) {
                LOWORD(v59) = v60;
              }
              if ((_WORD)v59 != 0xFFFF)
              {
                if ((__int16)v59 < 0)
                {
                  unsigned __int16 v61 = v59 & 0x7FFF;
                  while (1)
                  {
                    int v62 = v61;
                    if (2 * (unint64_t)v61 + 24 > v94) {
                      break;
                    }
                    unsigned int v63 = bswap32(*(unsigned __int16 *)(v47 + 2 * v61 + 22)) >> 16;
                    if (v40) {
                      __int16 v64 = *(_WORD *)(v47 + 2 * v61 + 22);
                    }
                    else {
                      __int16 v64 = v63;
                    }
                    llvm::object::ChainedFixupsInSegment::walkFixupChain((llvm::object::ChainedFixupsInSegment *)v131, this, v49, v58, v64 & 0x7FFF, (unint64_t *)v125);
                    if (v125[0])
                    {
                      uint64_t v103 = v125[0];
                      long long v84 = &v103;
LABEL_127:
                      llvm::report_fatal_error(v84);
                    }
                    unsigned __int16 v61 = v62 + 1;
                    if (v64 < 0) {
                      goto LABEL_91;
                    }
                  }
                  v115[0] = (uint64_t)"bad chained fixups: segment start ";
                  __int16 v116 = 259;
                  __int16 v113 = 264;
                  LODWORD(v112[0]) = v101;
                  sub_1CD3E3950(v115, v112, (uint64_t)v117);
                  v110[0] = (uint64_t)" chain_start index ";
                  __int16 v111 = 259;
                  sub_1CD3E3950(v117, v110, (uint64_t)v119);
                  __int16 v109 = 265;
                  LODWORD(v108[0]) = v62;
                  sub_1CD3E3950(v119, v108, (uint64_t)v121);
                  v106[0] = (uint64_t)" extends past seg_info size ";
                  __int16 v107 = 259;
                  sub_1CD3E3950(v121, v106, (uint64_t)v123);
                  __int16 v105 = 264;
                  goto LABEL_124;
                }
                llvm::object::ChainedFixupsInSegment::walkFixupChain((llvm::object::ChainedFixupsInSegment *)v131, this, v49, v58, (unsigned __int16)v59, (unint64_t *)v125);
                if (v125[0])
                {
                  uint64_t v102 = v125[0];
                  long long v84 = &v102;
                  goto LABEL_127;
                }
              }
LABEL_91:
              if (v52 <= ++v58) {
                goto LABEL_94;
              }
              uint64_t v57 = v58;
              if (2 * (unint64_t)v58 + 24 > v94)
              {
                int v83 = v58;
                goto LABEL_128;
              }
            }
          }
          int v83 = 0;
LABEL_128:
          v115[0] = (uint64_t)"bad chained fixups: segment start ";
          __int16 v116 = 259;
          __int16 v113 = 264;
          LODWORD(v112[0]) = v101;
          sub_1CD3E3950(v115, v112, (uint64_t)v117);
          v110[0] = (uint64_t)" page_start index ";
          __int16 v111 = 259;
          sub_1CD3E3950(v117, v110, (uint64_t)v119);
          __int16 v109 = 265;
          LODWORD(v108[0]) = v83;
          sub_1CD3E3950(v119, v108, (uint64_t)v121);
          v106[0] = (uint64_t)" extends past seg_info size ";
          __int16 v107 = 259;
          sub_1CD3E3950(v121, v106, (uint64_t)v123);
          __int16 v105 = 264;
LABEL_124:
          LODWORD(v104[0]) = v94;
          sub_1CD3E3950(v123, v104, (uint64_t)v125);
          long long v82 = (llvm *)v125;
LABEL_125:
          llvm::report_fatal_error(v82, (const llvm::Twine *)1);
        }
LABEL_94:
        uint64_t v65 = v127.i64[1];
        if (v127.i64[1] >= v128)
        {
          __int16 v67 = sub_1CCC70274(&v127, (uint64_t)v131);
          unint64_t v66 = (void *)v132;
        }
        else
        {
          *(_OWORD *)v127.i64[1] = v131[0];
          *(_OWORD *)(v65 + 12) = *(_OWORD *)((char *)v131 + 12);
          *(void *)(v65 + 40) = 0;
          *(void *)(v65 + 4++*(_DWORD *)(this + 8) = 0;
          *(void *)(v65 + 32) = 0;
          unint64_t v66 = (void *)v132;
          sub_1CBFCBA2C((void *)(v65 + 32), (const void *)v132, *((uint64_t *)&v132 + 1), (uint64_t)(*((void *)&v132 + 1) - v132) >> 3);
          __int16 v67 = (char *)(v65 + 56);
        }
        uint64_t v35 = v90;
        unint64_t v36 = v92;
        uint64_t v41 = v101;
        v127.i64[1] = (uint64_t)v67;
        if (v66) {
          operator delete(v66);
        }
      }
      else
      {
        unint64_t v68 = v127.u64[1];
        unint64_t v69 = v128;
        if (v127.i64[1] >= v128)
        {
          uint64_t v71 = v41;
          uint64_t v72 = v127.i64[0];
          uint64_t v73 = 0x6DB6DB6DB6DB6DB7 * ((v127.i64[1] - v127.i64[0]) >> 3);
          unint64_t v74 = v73 + 1;
          if ((unint64_t)(v73 + 1) > 0x492492492492492) {
            goto LABEL_131;
          }
          if (0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v128 - v127.i64[0]) >> 3) > v74) {
            unint64_t v74 = 0xDB6DB6DB6DB6DB6ELL * ((uint64_t)(v128 - v127.i64[0]) >> 3);
          }
          if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v128 - v127.i64[0]) >> 3)) >= 0x249249249249249) {
            unint64_t v74 = 0x492492492492492;
          }
          *(void *)&long long v132 = &v128;
          if (v74 > 0x492492492492492) {
            goto LABEL_139;
          }
          uint64_t v75 = 56 * v74;
          uint64_t v76 = (char *)operator new(56 * v74);
          uint64_t v77 = (uint64_t)&v76[56 * v73];
          *(void *)&v131[0] = v76;
          *((void *)&v131[0] + 1) = v77;
          uint64_t v78 = &v76[v75];
          *(_WORD *)uint64_t v77 = 0;
          uint64_t v70 = v77 + 56;
          *(void *)(v77 + ++*(_DWORD *)(this + 8) = 0;
          *(void *)(v77 + ++*(_DWORD *)(this + 16) = 0;
          *(_DWORD *)(v77 + 24) = 0;
          *(void *)(v77 + 40) = 0;
          *(void *)(v77 + 4++*(_DWORD *)(this + 8) = 0;
          *(void *)(v77 + 32) = 0;
          *(void *)&v131[1] = v77 + 56;
          *((void *)&v131[1] + 1) = v78;
          if (v68 == v72)
          {
            int64x2_t v80 = vdupq_n_s64(v68);
            unint64_t v36 = v92;
            uint64_t v41 = v71;
          }
          else
          {
            unint64_t v36 = v92;
            uint64_t v41 = v71;
            do
            {
              long long v79 = *(_OWORD *)(v68 - 56);
              *(_OWORD *)(v77 - 44) = *(_OWORD *)(v68 - 44);
              *(_OWORD *)(v77 - 56) = v79;
              *(void *)(v77 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v77 - ++*(_DWORD *)(this + 8) = 0;
              *(void *)(v77 - 24) = 0;
              *(_OWORD *)(v77 - 24) = *(_OWORD *)(v68 - 24);
              *(void *)(v77 - ++*(_DWORD *)(this + 8) = *(void *)(v68 - 8);
              v77 -= 56;
              *(void *)(v68 - 24) = 0;
              *(void *)(v68 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v68 - ++*(_DWORD *)(this + 8) = 0;
              v68 -= 56;
            }
            while (v68 != v72);
            int64x2_t v80 = v127;
            unint64_t v69 = v128;
            uint64_t v78 = (char *)*((void *)&v131[1] + 1);
            uint64_t v70 = *(void *)&v131[1];
          }
          uint64_t v35 = v90;
          v127.i64[0] = v77;
          v127.i64[1] = v70;
          *(int64x2_t *)((char *)v131 + ++*(_DWORD *)(this + 8) = v80;
          unint64_t v128 = (unint64_t)v78;
          *((void *)&v131[1] + 1) = v69;
          *(void *)&v131[0] = v80.i64[0];
          sub_1CCC70210((uint64_t)v131);
        }
        else
        {
          *(_WORD *)v127.i64[1] = 0;
          uint64_t v70 = v68 + 56;
          *(void *)(v68 + ++*(_DWORD *)(this + 8) = 0;
          *(void *)(v68 + ++*(_DWORD *)(this + 16) = 0;
          *(_DWORD *)(v68 + 24) = 0;
          *(void *)(v68 + 40) = 0;
          *(void *)(v68 + 4++*(_DWORD *)(this + 8) = 0;
          *(void *)(v68 + 32) = 0;
        }
        v127.i64[1] = v70;
      }
      ++v41;
    }
    while (v41 != v96);
  }
  *(unsigned char *)(v88 + 24) &= ~1u;
  *(int64x2_t *)uint64_t v88 = v127;
  *(void *)(v88 + ++*(_DWORD *)(this + 16) = v128;
  int64x2_t v127 = 0uLL;
  unint64_t v128 = 0;
  if (!v7) {
    goto LABEL_119;
  }
LABEL_118:
  operator delete(v7);
LABEL_119:
  *(void *)&v131[0] = &v127;
  sub_1CCC6FD8C((void ***)v131);
  if (v136)
  {
    if (v135.i64[0]) {
      (*(void (**)(uint64_t))(*(void *)v135.i64[0] + 8))(v135.i64[0]);
    }
  }
}

const char *llvm::object::MachOChainedFixupEntry::moveToFirst(const char *this)
{
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = -1;
  *((unsigned char *)this + 80) = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  return llvm::object::MachOChainedFixupEntry::moveNext(this);
}

const char *llvm::object::MachOChainedFixupEntry::moveNext(const char *this)
{
  unint64_t v1 = *(void **)this;
  if (!this[80])
  {
    uint64_t v2 = (uint64_t)this;
    unint64_t v3 = (int *)(this + 24);
    int v4 = this + 32;
    uint64_t v5 = *((void *)this + 1);
    do
    {
      uint64_t v6 = *(void *)(v5 + 352);
      if (v6)
      {
        int v7 = 0;
      }
      else
      {
        int v7 = *v3;
        if (*v3 == -1)
        {
          LODWORD(v6) = 0;
          *(_DWORD *)(v2 + 24) = 0;
LABEL_27:
          *(_DWORD *)(v2 + 144) = 0;
          continue;
        }
      }
      uint64_t v8 = *(void *)(v2 + 120);
      if (0x6DB6DB6DB6DB6DB7 * ((*(void *)(v2 + 128) - v8) >> 3) <= (unint64_t)v7)
      {
        *(unsigned char *)(v2 + 80) = 1;
        break;
      }
      unint64_t v9 = *(unsigned int *)(v2 + 144);
      uint64_t v10 = v8 + 56 * v7;
      uint64_t v12 = *(void *)(v10 + 32);
      uint64_t v13 = *(void *)(v10 + 40);
      size_t v11 = (void *)(v10 + 32);
      if (v9 >= (v13 - v12) >> 3)
      {
        if (v6)
        {
          LODWORD(v6) = 1;
          *(unsigned char *)(v2 + 80) = 1;
        }
        else
        {
          ++*v3;
        }
        goto LABEL_27;
      }
      uint64_t v14 = (unsigned __int16 *)(v8 + 56 * v7);
      *(void *)(v2 + ++*(_DWORD *)(this + 16) = 0;
      *(unsigned char *)(v2 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
      _OWORD *v4 = 0u;
      v4[1] = 0u;
      void v4[2] = 0u;
      unsigned int v15 = *v14;
      unint64_t v72 = *((void *)v14 + 2);
      *(_DWORD *)(v2 + 144) = v9 + 1;
      uint64_t v16 = *(void *)(*v11 + 8 * v9);
      if (v6) {
        llvm::object::MachOChainedFixupEntry::findSegmentIndexAndOffset((llvm::object::MachOChainedFixupEntry *)v2, *(void *)(*v11 + 8 * v9), v3, &v72);
      }
      switch(v15)
      {
        case 1u:
        case 7u:
        case 9u:
        case 0xAu:
        case 0xCu:
          int64_t v17 = sub_1CCC5CC38(*(void *)(v2 + 8), (unint64_t *)(*(void *)(*(void *)(v2 + 8) + 16) + v16));
          *(void *)(v2 + 72) = v17;
          LODWORD(v1++*(_DWORD *)(this + 8) = v16 - v72;
          *(void *)(v2 + ++*(_DWORD *)(this + 16) = v16 - v72;
          *(unsigned char *)(v2 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = v17 < 0;
          if ((v17 & 0x4000000000000000) != 0)
          {
            unint64_t v22 = HIDWORD(v17) & 0x7FFFF;
            if (v15 == 12) {
              unint64_t v23 = v17 & 0xFFFFFF;
            }
            else {
              unint64_t v23 = (unsigned __int16)v17;
            }
            unint64_t v71 = v23;
            if (v17 < 0) {
              unint64_t v22 = 0;
            }
            uint64_t v29 = *(void *)(v2 + 96);
            if (v23 >= 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(v2 + 104) - v29) >> 3))
            {
              unint64_t v57 = 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(v2 + 104) - v29) >> 3);
              v58[0] = "out of range bind ordinal ";
              unsigned int v59 = (uint64_t *)&v71;
              __int16 v60 = 3075;
              v61[0] = v58;
              int v62 = " (num entries: ";
              __int16 v63 = 770;
              v64[0] = v61;
              uint64_t v65 = &v57;
              __int16 v66 = 2562;
              v67[0] = (uint64_t)v64;
              unint64_t v68 = ")";
              __int16 v69 = 770;
              sub_1CCC51CE4((uint64_t)&v70, v67);
            }
            long long v30 = (int *)(v29 + 40 * v23);
            int v31 = *(_DWORD *)(v2 + 148);
            if (v31 == 2)
            {
              int v32 = *v30;
              if (v32 != -3) {
                goto LABEL_86;
              }
            }
            else if (v31 == 1)
            {
              int v32 = *v30;
              if (v32 == -3) {
                goto LABEL_86;
              }
            }
            else
            {
              if (v31) {
                goto LABEL_86;
              }
              int v32 = *v30;
            }
            uint64_t v49 = v29 + 40 * v23;
            *(_OWORD *)(v2 + 32) = *(_OWORD *)(v49 + 8);
            *(_DWORD *)(v2 + 4++*(_DWORD *)(this + 8) = v32;
            if (*(unsigned char *)(v49 + 32)) {
              *(_DWORD *)(v2 + 52) = 1;
            }
            if (v22 >= 0x40000) {
              v22 |= 0xFFFFFFFFFFFC0000;
            }
            uint64_t v50 = *(void *)(v29 + 40 * v23 + 24);
            goto LABEL_76;
          }
          int v19 = *(_DWORD *)(v2 + 148);
          if (v19 != 3 && v19) {
            goto LABEL_86;
          }
          if (v17 < 0)
          {
            unint64_t v20 = v17;
            goto LABEL_66;
          }
          unint64_t v20 = v17 & 0x7FFFFFFFFFFLL | ((unint64_t)((unint64_t)v17 >> 43) << 56);
          *(void *)(v2 + 64) = v20;
          char v21 = 1;
          if (v15 > 0xC || ((1 << v15) & 0x1280) == 0) {
            goto LABEL_87;
          }
          goto LABEL_66;
        case 2u:
        case 6u:
          unint64_t v24 = sub_1CCC5CC38(*(void *)(v2 + 8), (unint64_t *)(*(void *)(*(void *)(v2 + 8) + 16) + v16));
          *(void *)(v2 + 72) = v24;
          LODWORD(v1++*(_DWORD *)(this + 8) = v16 - v72;
          *(void *)(v2 + ++*(_DWORD *)(this + 16) = v16 - v72;
          if ((v24 & 0x8000000000000000) != 0)
          {
            unsigned int v43 = v24 & 0xFFFFFF;
            uint64_t v44 = *(void *)(v2 + 96);
            unint64_t v45 = 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(v2 + 104) - v44) >> 3);
            if ((v24 & 0xFFFFFF) >= v45)
            {
              uint64_t v70 = v24 & 0xFFFFFF;
              unint64_t v57 = v45;
              v58[0] = "out of range bind ordinal ";
              unsigned int v59 = &v70;
              __int16 v60 = 3075;
              v61[0] = v58;
              int v62 = " (num entries: ";
              __int16 v63 = 770;
              uint64_t v56 = (uint64_t *)&v57;
              goto LABEL_105;
            }
            uint64_t v46 = (int *)(v44 + 40 * v43);
            int v47 = *(_DWORD *)(v2 + 148);
            if (v47 == 2)
            {
              int v48 = *v46;
              if (v48 != -3) {
                goto LABEL_86;
              }
            }
            else if (v47 == 1)
            {
              int v48 = *v46;
              if (v48 == -3) {
                goto LABEL_86;
              }
            }
            else
            {
              if (v47) {
                goto LABEL_86;
              }
              int v48 = *v46;
            }
            uint64_t v52 = v44 + 40 * v43;
            *(_OWORD *)(v2 + 32) = *(_OWORD *)(v52 + 8);
            *(_DWORD *)(v2 + 4++*(_DWORD *)(this + 8) = v48;
            if (*(unsigned char *)(v52 + 32)) {
              *(_DWORD *)(v2 + 52) = 1;
            }
            uint64_t v51 = *(void *)(v44 + 40 * v43 + 24) + BYTE3(v24);
            goto LABEL_83;
          }
          int v25 = *(_DWORD *)(v2 + 148);
          if (v25 != 3 && v25) {
            goto LABEL_86;
          }
          unint64_t v20 = v24 & 0xFFFFFFFFFLL | ((unint64_t)(v24 >> 36) << 56);
          *(void *)(v2 + 64) = v20;
          if (v15 == 6)
          {
LABEL_66:
            unint64_t v28 = *(void *)(v2 + 88) + v20;
LABEL_67:
            *(void *)(v2 + 64) = v28;
          }
          goto LABEL_84;
        case 3u:
          unsigned int v33 = sub_1CCC5CCA4(*(void *)(v2 + 8), (unsigned int *)(*(void *)(*(void *)(v2 + 8) + 16) + v16));
          *(void *)(v2 + 72) = v33;
          LODWORD(v1++*(_DWORD *)(this + 8) = v16 - v72;
          *(void *)(v2 + ++*(_DWORD *)(this + 16) = v16 - v72;
          if ((v33 & 0x80000000) == 0) {
            goto LABEL_57;
          }
          unint64_t v34 = v33 & 0xFFFFF;
          uint64_t v35 = *(void *)(v2 + 96);
          unint64_t v36 = 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(v2 + 104) - v35) >> 3);
          if (v36 <= v34)
          {
            v58[0] = "out of range bind ordinal ";
            unsigned int v59 = (uint64_t *)(v33 & 0xFFFFF);
            __int16 v60 = 2051;
            v61[0] = v58;
            int v62 = " (num entries: ";
            __int16 v63 = 770;
            uint64_t v70 = v36;
            uint64_t v56 = &v70;
LABEL_105:
            v64[0] = v61;
            uint64_t v65 = (unint64_t *)v56;
            __int16 v66 = 2562;
            v67[0] = (uint64_t)v64;
            unint64_t v68 = ")";
            __int16 v69 = 770;
            sub_1CCC51CE4((uint64_t)&v71, v67);
          }
          uint64_t v37 = (int *)(v35 + 40 * v34);
          int v38 = *(_DWORD *)(v2 + 148);
          if (v38 == 2)
          {
            int v39 = *v37;
            if (v39 != -3) {
              goto LABEL_86;
            }
          }
          else if (v38 == 1)
          {
            int v39 = *v37;
            if (v39 == -3)
            {
LABEL_86:
              char v21 = 0;
              goto LABEL_87;
            }
          }
          else
          {
            if (v38) {
              goto LABEL_86;
            }
            int v39 = *v37;
          }
          uint64_t v54 = v35 + 40 * v34;
          *(_OWORD *)(v2 + 32) = *(_OWORD *)(v54 + 8);
          *(_DWORD *)(v2 + 4++*(_DWORD *)(this + 8) = v39;
          if (*(unsigned char *)(v54 + 32)) {
            *(_DWORD *)(v2 + 52) = 1;
          }
          uint64_t v50 = *(void *)(v35 + 40 * v34 + 24);
          unint64_t v22 = (v33 >> 20) & 0x3F;
LABEL_76:
          uint64_t v51 = v50 + v22;
LABEL_83:
          *(void *)(v2 + 56) = v51;
LABEL_84:
          char v21 = 1;
LABEL_87:
          uint64_t v5 = *(void *)(v2 + 8);
          if ((*(_DWORD *)(v5 + 8) & 0xFFFFFFFE) == 0x12) {
            int v53 = 8;
          }
          else {
            int v53 = 4;
          }
          this = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(v5 + 264), *(_DWORD *)(v2 + 24), v18, v53, 1u, 0);
          if (this)
          {
            HIBYTE(v69) = 1;
            if (*this)
            {
              v67[0] = (uint64_t)this;
              char v55 = 3;
            }
            else
            {
              char v55 = 1;
            }
            LOBYTE(v69) = v55;
            sub_1CCC51CE4((uint64_t)v64, v67);
          }
          LODWORD(v6) = *(unsigned __int8 *)(v2 + 80);
          if (v21) {
            goto LABEL_2;
          }
          break;
        case 4u:
          unsigned int v40 = sub_1CCC5CCA4(*(void *)(v2 + 8), (unsigned int *)(*(void *)(*(void *)(v2 + 8) + 16) + v16));
          *(void *)(v2 + 72) = v40;
          LODWORD(v1++*(_DWORD *)(this + 8) = v16 - v72;
          *(void *)(v2 + ++*(_DWORD *)(this + 16) = v16 - v72;
          int v41 = *(_DWORD *)(v2 + 148);
          if (v41 != 3 && v41) {
            goto LABEL_86;
          }
          unint64_t v28 = v40 & 0x3FFFFFFF;
          goto LABEL_67;
        case 5u:
          unsigned int v33 = sub_1CCC5CCA4(*(void *)(v2 + 8), (unsigned int *)(*(void *)(*(void *)(v2 + 8) + 16) + v16));
          *(void *)(v2 + 72) = v33;
          LODWORD(v1++*(_DWORD *)(this + 8) = v16 - v72;
          *(void *)(v2 + ++*(_DWORD *)(this + 16) = v16 - v72;
LABEL_57:
          int v42 = *(_DWORD *)(v2 + 148);
          if (v42 != 3 && v42) {
            goto LABEL_86;
          }
          unint64_t v28 = v33 & 0x3FFFFFF;
          goto LABEL_67;
        case 8u:
        case 0xBu:
          unsigned int v26 = sub_1CCC5CCA4(*(void *)(v2 + 8), (unsigned int *)(*(void *)(*(void *)(v2 + 8) + 16) + v16));
          *(void *)(v2 + 72) = v26;
          LODWORD(v1++*(_DWORD *)(this + 8) = v16 - v72;
          *(void *)(v2 + ++*(_DWORD *)(this + 16) = v16 - v72;
          int v27 = *(_DWORD *)(v2 + 148);
          if (v27 != 3 && v27) {
            goto LABEL_86;
          }
          unint64_t v28 = v26 & 0x3FFFFFFF;
          goto LABEL_67;
        default:
          char v21 = 0;
          uint64_t v18 = *(void *)(v2 + 16);
          goto LABEL_87;
      }
    }
    while (!v6);
  }
LABEL_2:
  if (v1)
  {
    if (!*v1) {
      *unint64_t v1 = 0;
    }
  }
  return this;
}

uint64_t llvm::object::MachOChainedFixupEntry::moveToEnd(uint64_t this)
{
  *(unsigned char *)(this + 80) = 1;
  return this;
}

void llvm::object::MachOChainedFixupEntry::findSegmentIndexAndOffset(llvm::object::MachOChainedFixupEntry *this, unint64_t a2, int *a3, unint64_t *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = *(unsigned int *)(v4 + 136);
  if (v5)
  {
    int v10 = 0;
    uint64_t v11 = *(void *)(v4 + 128);
    for (uint64_t i = 16 * v5; i; i -= 16)
    {
      int v13 = *(_DWORD *)(v11 + 8);
      if (v13 == 25)
      {
        uint64_t v20 = 0;
        long long v18 = 0u;
        long long v19 = 0u;
        long long v16 = 0u;
        long long v17 = 0u;
        llvm::object::MachOObjectFile::getSegment64LoadCommand(*((void *)this + 1), (unint64_t *)v11, (uint64_t)&v16);
        unint64_t v14 = *((void *)&v18 + 1);
        if (*((void *)&v18 + 1) > a2) {
          goto LABEL_10;
        }
        unint64_t v15 = v19 + *((void *)&v18 + 1);
      }
      else
      {
        if (v13 != 1) {
          goto LABEL_10;
        }
        *(void *)&long long v19 = 0;
        long long v17 = 0u;
        long long v18 = 0u;
        long long v16 = 0u;
        llvm::object::MachOObjectFile::getSegmentLoadCommand(*((void *)this + 1), (unint64_t *)v11, (uint64_t)&v16);
        unint64_t v14 = v18;
        if (v18 > a2) {
          goto LABEL_10;
        }
        unint64_t v15 = (DWORD1(v18) + v18);
      }
      if (v15 > a2)
      {
        *a4 = v14;
        *a3 = v10;
        return;
      }
LABEL_10:
      ++v10;
      v11 += 16;
    }
  }
}

unint64_t sub_1CCC5CC38(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = v2 > (unint64_t)a2 || (unint64_t)(a2 + 1) > v2 + *(void *)(a1 + 24);
  if (v3) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  uint64_t v4 = a1;
  unint64_t result = *a2;
  LODWORD(v4) = *(_DWORD *)(v4 + 8);
  BOOL v3 = v4 > 0x13;
  int v6 = (1 << v4) & 0xAAC00;
  if (!v3 && v6 != 0) {
    return bswap64(result);
  }
  return result;
}

uint64_t sub_1CCC5CCA4(uint64_t a1, unsigned int *a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = v2 > (unint64_t)a2 || (unint64_t)(a2 + 1) > v2 + *(void *)(a1 + 24);
  if (v3) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  uint64_t v4 = a1;
  uint64_t result = *a2;
  LODWORD(v4) = *(_DWORD *)(v4 + 8);
  BOOL v3 = v4 > 0x13;
  int v6 = (1 << v4) & 0xAAC00;
  if (!v3 && v6 != 0) {
    return bswap32(result);
  }
  return result;
}

BOOL llvm::object::MachOChainedFixupEntry::operator==(uint64_t a1, uint64_t a2)
{
  return *(unsigned __int8 *)(a1 + 80) == *(unsigned __int8 *)(a2 + 80)
      || *(_DWORD *)(a1 + 144) == *(_DWORD *)(a2 + 144) && *(void *)(a1 + 120) == *(void *)(a2 + 120);
}

double llvm::object::MachORebaseEntry::MachORebaseEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7)
{
  uint64_t v11 = llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry(a1, a2, a3);
  *(void *)(v11 + 96) = a4;
  *(void *)(v11 + 104) = a5;
  if (a6) {
    char v12 = 8;
  }
  else {
    char v12 = 4;
  }
  *(void *)(v11 + 12++*(_DWORD *)(this + 8) = 0;
  *(void *)(v11 + 136) = 0;
  *(void *)(v11 + 120) = a4;
  *(unsigned char *)(v11 + 144) = v12;
  *(_WORD *)(v11 + 145) = 0;
  *(_DWORD *)(v11 + 14++*(_DWORD *)(this + 8) = 3;
  *(unsigned char *)(v11 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
  *(unsigned char *)(v11 + 153) = a7;
  double result = 0.0;
  *(_OWORD *)(v11 + 160) = 0u;
  *(_OWORD *)(v11 + 176) = 0u;
  *(_OWORD *)(v11 + 18++*(_DWORD *)(this + 8) = 0u;
  return result;
}

{
  uint64_t v11;
  char v12;
  double result;

  uint64_t v11 = llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry(a1, a2, a3);
  *(void *)(v11 + 96) = a4;
  *(void *)(v11 + 104) = a5;
  if (a6) {
    char v12 = 8;
  }
  else {
    char v12 = 4;
  }
  *(void *)(v11 + 12++*(_DWORD *)(this + 8) = 0;
  *(void *)(v11 + 136) = 0;
  *(void *)(v11 + 120) = a4;
  *(unsigned char *)(v11 + 144) = v12;
  *(_WORD *)(v11 + 145) = 0;
  *(_DWORD *)(v11 + 14++*(_DWORD *)(this + 8) = 3;
  *(unsigned char *)(v11 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
  *(unsigned char *)(v11 + 153) = a7;
  double result = 0.0;
  *(_OWORD *)(v11 + 160) = 0u;
  *(_OWORD *)(v11 + 176) = 0u;
  *(_OWORD *)(v11 + 18++*(_DWORD *)(this + 8) = 0u;
  return result;
}

double llvm::object::MachORebaseBindEntry::MachORebaseBindEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, char a8)
{
  uint64_t v13 = llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry(a1, a2, a3);
  *(void *)(v13 + 96) = a4;
  *(void *)(v13 + 104) = a5;
  if (a6) {
    char v14 = 8;
  }
  else {
    char v14 = 4;
  }
  *(void *)(v13 + 12++*(_DWORD *)(this + 8) = 0;
  *(void *)(v13 + 136) = 0;
  *(void *)(v13 + 120) = a4;
  *(unsigned char *)(v13 + 144) = v14;
  *(_WORD *)(v13 + 145) = 0;
  *(_DWORD *)(v13 + 14++*(_DWORD *)(this + 8) = a7;
  *(unsigned char *)(v13 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
  *(unsigned char *)(v13 + 153) = a8;
  double result = 0.0;
  *(_OWORD *)(v13 + 160) = 0u;
  *(_OWORD *)(v13 + 176) = 0u;
  *(_OWORD *)(v13 + 18++*(_DWORD *)(this + 8) = 0u;
  return result;
}

{
  uint64_t v13;
  char v14;
  double result;

  uint64_t v13 = llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry(a1, a2, a3);
  *(void *)(v13 + 96) = a4;
  *(void *)(v13 + 104) = a5;
  if (a6) {
    char v14 = 8;
  }
  else {
    char v14 = 4;
  }
  *(void *)(v13 + 12++*(_DWORD *)(this + 8) = 0;
  *(void *)(v13 + 136) = 0;
  *(void *)(v13 + 120) = a4;
  *(unsigned char *)(v13 + 144) = v14;
  *(_WORD *)(v13 + 145) = 0;
  *(_DWORD *)(v13 + 14++*(_DWORD *)(this + 8) = a7;
  *(unsigned char *)(v13 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
  *(unsigned char *)(v13 + 153) = a8;
  double result = 0.0;
  *(_OWORD *)(v13 + 160) = 0u;
  *(_OWORD *)(v13 + 176) = 0u;
  *(_OWORD *)(v13 + 18++*(_DWORD *)(this + 8) = 0u;
  return result;
}

void llvm::object::MachORebaseBindEntry::moveToFirst(llvm::object::MachORebaseBindEntry *this)
{
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = -1;
  *((unsigned char *)this + 80) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 15) = *((void *)this + 12);
  llvm::object::MachORebaseBindEntry::moveNext(this);
}

void llvm::object::MachORebaseBindEntry::moveNext(llvm::object::MachORebaseBindEntry *this)
{
  unint64_t v2 = *(void **)this;
  int v3 = *((_DWORD *)this + 37);
  if (v3 != 3)
  {
    if (!*((unsigned char *)this + 153))
    {
LABEL_38:
      uint64_t v4 = *((void *)this + 16);
      *((void *)this + 2) += *((void *)this + 17);
      if (v4) {
        goto LABEL_39;
      }
      unint64_t v27 = *((void *)this + 15);
      if (v27 == *((void *)this + 12) + *((void *)this + 13)) {
        goto LABEL_174;
      }
      unint64_t v28 = "malformed sleb128, extends past end";
      while (2)
      {
        uint64_t v29 = (unsigned char *)(v27 + 1);
        *((void *)this + 14) = v27;
        *((void *)this + 15) = v27 + 1;
        unsigned int v30 = *(unsigned __int8 *)v27;
        unsigned __int8 v31 = *(unsigned char *)v27;
        unsigned int v32 = v30 & 0xF;
        switch(v30 >> 4)
        {
          case 0u:
            uint64_t v33 = *((void *)this + 12);
            uint64_t v34 = *((void *)this + 13);
            unint64_t v35 = v33 + v34;
            if (*((_DWORD *)this + 37) == 1 && (unint64_t)v29 < v35)
            {
              char v37 = 0;
              unint64_t v38 = ~v27 + v34 + v33;
              do
              {
                int v39 = *v29++;
                v37 |= v39 != 0;
                --v38;
              }
              while (v38);
              if (v37) {
                goto LABEL_173;
              }
            }
            *((unsigned char *)this + 80) = 1;
            *((void *)this + 15) = v35;
LABEL_480:
            *((void *)this + ++*(_DWORD *)(this + 16) = 0;
            goto LABEL_481;
          case 1u:
            if (*((_DWORD *)this + 37) != 2)
            {
              *((_DWORD *)this + 12) = v32;
              *((unsigned char *)this + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 1;
              uint64_t v90 = (const char *)*(unsigned int *)(*((void *)this + 1) + 112);
              if (v90 < v32)
              {
                v274[0] = "for BIND_OPCODE_SET_DYLIB_ORDINAL_IMM bad library ordinal: ";
                uint64_t v275 = v30 & 0xF;
                __int16 v276 = 2307;
                v277[0] = v274;
                uint64_t v278 = " (max ";
                __int16 v279 = 770;
                uint64_t v281 = (const char *)v277;
                uint64_t v283 = v90;
                __int16 v284 = 2306;
                uint64_t v285 = (const char *)&v281;
                uint64_t v287 = ") for opcode at: 0x";
                __int16 v288 = 770;
                uint64_t v48 = *((void *)this + 12);
LABEL_281:
                uint64_t v273 = (unsigned __int8 *)(v27 - v48);
                v289[0] = (uint64_t)&v285;
                uint64_t v290 = (const char *)&v273;
                __int16 v291 = 3586;
                sub_1CCC51CE4((uint64_t)&v280, v289);
              }
              goto LABEL_173;
            }
            uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
            int v186 = "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM not allowed in weak bind table for opcode at: 0x";
            goto LABEL_429;
          case 2u:
            if (*((_DWORD *)this + 37) == 2)
            {
              uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
              int v186 = "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB not allowed in weak bind table for opcode at: 0x";
              goto LABEL_429;
            }
            uint64_t v70 = 0;
            uint64_t v71 = 0;
            unsigned int v72 = 0;
            uint64_t v48 = *((void *)this + 12);
            uint64_t v73 = *((void *)this + 13);
            unint64_t v74 = (unsigned char *)(v48 + v73);
            do
            {
              if (&v29[v70] == v74)
              {
                LODWORD(v70) = v48 + v73 + ~v27;
                unint64_t v123 = "malformed uleb128, extends past end";
LABEL_188:
                unint64_t v129 = &v29[v70];
                if (v129 <= v74) {
                  unint64_t v74 = v129;
                }
                *((void *)this + 15) = v74;
                *((_DWORD *)this + 12) = 0;
                *((unsigned char *)this + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 1;
                int v130 = *(unsigned __int8 *)v123;
                unsigned int v131 = "for BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB ";
                if (*v123)
                {
                  uint64_t v281 = "for BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB ";
                  uint64_t v283 = v123;
LABEL_192:
                  __int16 v284 = 771;
                  char v132 = 2;
                }
                else
                {
LABEL_472:
                  uint64_t v281 = v131;
                  __int16 v284 = 259;
                  char v132 = 3;
                }
                if (v130) {
                  unsigned int v131 = (const char *)&v281;
                }
                uint64_t v285 = v131;
                uint64_t v287 = " for opcode at: 0x";
                goto LABEL_476;
              }
              char v75 = v29[v70];
              uint64_t v76 = v75 & 0x7F;
              if (v72 >= 0x40 && (v75 & 0x7F) != 0 || (unint64_t)(v76 << v72) >> v72 != v76)
              {
                unint64_t v123 = "uleb128 too big for uint64";
                goto LABEL_188;
              }
              v71 += v76 << v72;
              v72 += 7;
              ++v70;
            }
            while (v75 < 0);
            uint64_t v77 = &v29[v70];
            if (v77 <= v74) {
              unint64_t v74 = v77;
            }
            *((void *)this + 15) = v74;
            *((_DWORD *)this + 12) = v71;
            *((unsigned char *)this + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 1;
            uint64_t v78 = (const char *)*(unsigned int *)(*((void *)this + 1) + 112);
            if ((int)v78 < (int)v71)
            {
              v274[0] = "for BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB bad library ordinal: ";
              uint64_t v275 = v71;
              __int16 v276 = 2307;
              v277[0] = v274;
              uint64_t v278 = " (max ";
              __int16 v279 = 770;
              uint64_t v281 = (const char *)v277;
              uint64_t v283 = v78;
              __int16 v284 = 2306;
              uint64_t v285 = (const char *)&v281;
              uint64_t v287 = ") for opcode at: 0x";
              __int16 v288 = 770;
              goto LABEL_281;
            }
LABEL_173:
            unint64_t v27 = *((void *)this + 15);
            continue;
          case 3u:
            if (*((_DWORD *)this + 37) == 2)
            {
              uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
              int v186 = "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM not allowed in weak bind table for opcode at: 0x";
              goto LABEL_429;
            }
            if ((v30 & 0xF) != 0)
            {
              long long v79 = (const char *)(*(_DWORD *)&v31 | 0xFFFFFFF0);
              *((_DWORD *)this + 12) = v79;
              if (v79 <= 0xFFFFFFFC)
              {
                unsigned int v206 = "for BIND_OPCODE_SET_DYLIB_SPECIAL_IMM unknown special ordinal: ";
LABEL_323:
                uint64_t v281 = v206;
                uint64_t v283 = v79;
                __int16 v284 = 2307;
                uint64_t v285 = (const char *)&v281;
                uint64_t v287 = " for opcode at: 0x";
                __int16 v288 = 770;
                goto LABEL_403;
              }
            }
            else
            {
              *((_DWORD *)this + 12) = 0;
            }
            *((unsigned char *)this + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 1;
            goto LABEL_173;
          case 4u:
            *((_DWORD *)this + 13) = v32;
            uint64_t v40 = *((void *)this + 12);
            uint64_t v41 = *((void *)this + 13);
            int v42 = (unsigned __int8 *)(v27 + 1);
            if (!*v29) {
              goto LABEL_56;
            }
            unsigned int v43 = (unsigned __int8 *)(v27 + 2);
            do
            {
              int v42 = v43 - 1;
              if ((unint64_t)(v43 - 1) >= v40 + v41) {
                goto LABEL_56;
              }
              *((void *)this + 15) = v43;
            }
            while (*v43++);
            int v42 = v43 - 1;
LABEL_56:
            if (v42 != (unsigned __int8 *)(v40 + v41))
            {
              *((void *)this + 4) = v29;
              *((void *)this + 5) = v42 - v29;
              *((void *)this + 15) = v42 + 1;
              if (v32 >= 8 && *((_DWORD *)this + 37) == 2) {
                goto LABEL_481;
              }
              goto LABEL_173;
            }
            uint64_t v185 = (unsigned __int8 *)(v27 - v40);
            int v186 = "for BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM symbol name extends past opcodes for opcode at: 0x";
            goto LABEL_429;
          case 5u:
            *((unsigned char *)this + 146) = v32;
            if (v32 < 4) {
              goto LABEL_173;
            }
            long long v79 = (const char *)(v30 & 0xF);
            unsigned int v206 = "for BIND_OPCODE_SET_TYPE_IMM bad bind type: ";
            goto LABEL_323;
          case 6u:
            uint64_t v91 = 0;
            uint64_t v92 = 0;
            unsigned int v93 = 0;
            uint64_t v48 = *((void *)this + 12);
            unsigned int v94 = (unsigned char *)(v48 + *((void *)this + 13));
            LODWORD(v95) = v27 + 1;
            while (&v29[v91] != v94)
            {
              char v96 = v29[v91];
              uint64_t v97 = v96 & 0x7F;
              if (v93 >= 0x40)
              {
                if (((v92 >> 63) & 0x7F) != v97)
                {
                  LODWORD(v95) = v27 + v91 + 1;
                  unint64_t v28 = "sleb128 too big for int64";
                  goto LABEL_468;
                }
              }
              else if (v93 == 63)
              {
                BOOL v98 = v97 == 127 || v97 == 0;
                if (!v98)
                {
                  unint64_t v28 = "sleb128 too big for int64";
                  goto LABEL_468;
                }
              }
              v92 |= v97 << v93;
              v93 += 7;
              LODWORD(v95) = v95 + 1;
              ++v91;
              if ((v96 & 0x80) == 0)
              {
                BOOL v108 = (v96 & 0x40) == 0 || v93 > 0x3F;
                uint64_t v109 = -1 << v93;
                if (v108) {
                  uint64_t v109 = 0;
                }
                uint64_t v110 = v92 | v109;
                __int16 v111 = &v29[v91];
                if (v111 <= v94) {
                  unsigned int v94 = v111;
                }
                *((void *)this + 15) = v94;
                *((void *)this + 7) = v110;
                goto LABEL_173;
              }
            }
            uint64_t v95 = v48 + *((void *)this + 13);
LABEL_468:
            if (&v29[(v95 - v29)] <= v94) {
              unsigned int v94 = &v29[(v95 - v29)];
            }
            *((void *)this + 15) = v94;
            *((void *)this + 7) = 0;
            int v130 = *(unsigned __int8 *)v28;
            unsigned int v131 = "for BIND_OPCODE_SET_ADDEND_SLEB ";
            if (!*v28) {
              goto LABEL_472;
            }
            uint64_t v281 = "for BIND_OPCODE_SET_ADDEND_SLEB ";
            uint64_t v283 = v28;
            goto LABEL_192;
          case 7u:
            uint64_t v80 = 0;
            uint64_t v81 = 0;
            unsigned int v82 = 0;
            *((_DWORD *)this + 6) = v32;
            uint64_t v84 = *((void *)this + 12);
            uint64_t v83 = *((void *)this + 13);
            __int16 v85 = (unsigned char *)(v84 + v83);
            do
            {
              if (&v29[v80] == v85)
              {
                LODWORD(v80) = v84 + v83 + ~v27;
                __int16 v122 = "malformed uleb128, extends past end";
LABEL_178:
                __int16 v124 = &v29[v80];
                if (v124 <= v85) {
                  __int16 v85 = v124;
                }
                *((void *)this + 15) = v85;
                *((void *)this + 2) = 0;
                int v125 = *(unsigned __int8 *)v122;
                if (*v122)
                {
                  uint64_t v281 = "for BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
                  uint64_t v283 = v122;
                  __int16 v284 = 771;
                  char v126 = 2;
                }
                else
                {
                  uint64_t v281 = "for BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
                  __int16 v284 = 259;
                  char v126 = 3;
                }
                BOOL v98 = v125 == 0;
                int64x2_t v127 = &v281;
                if (v98) {
                  int64x2_t v127 = (const char **)"for BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
                }
                uint64_t v285 = (const char *)v127;
                uint64_t v287 = " for opcode at: 0x";
                LOBYTE(v28++*(_DWORD *)(this + 8) = v126;
                goto LABEL_186;
              }
              char v86 = v29[v80];
              uint64_t v87 = v86 & 0x7F;
              if (v82 >= 0x40 && (v86 & 0x7F) != 0 || (unint64_t)(v87 << v82) >> v82 != v87)
              {
                __int16 v122 = "uleb128 too big for uint64";
                goto LABEL_178;
              }
              v81 += v87 << v82;
              v82 += 7;
              ++v80;
            }
            while (v86 < 0);
            uint64_t v88 = &v29[v80];
            if (v88 <= v85) {
              __int16 v85 = v88;
            }
            *((void *)this + 15) = v85;
            *((void *)this + 2) = v81;
            int v89 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), v32, v81, *((unsigned __int8 *)this + 144), 1u, 0);
            if (!v89) {
              goto LABEL_173;
            }
            int v232 = *(unsigned __int8 *)v89;
            BOOL v233 = (const char **)"for BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
            if (*v89)
            {
              uint64_t v281 = "for BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
              uint64_t v283 = v89;
              __int16 v284 = 771;
              char v192 = 2;
            }
            else
            {
              uint64_t v281 = "for BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
              __int16 v284 = 259;
              char v192 = 3;
            }
            if (v232) {
              BOOL v233 = &v281;
            }
            uint64_t v285 = (const char *)v233;
            uint64_t v287 = " for opcode at: 0x";
LABEL_354:
            LOBYTE(v28++*(_DWORD *)(this + 8) = v192;
            goto LABEL_186;
          case 8u:
            uint64_t v99 = 0;
            uint64_t v100 = 0;
            unsigned int v101 = 0;
            uint64_t v84 = *((void *)this + 12);
            uint64_t v102 = *((void *)this + 13);
            uint64_t v103 = (unsigned char *)(v84 + v102);
            while (1)
            {
              if (&v29[v99] == v103)
              {
                char v107 = 0;
                uint64_t v100 = 0;
                LODWORD(v99) = v84 + v102 + ~v27;
                __int16 v106 = "malformed uleb128, extends past end";
                goto LABEL_159;
              }
              char v104 = v29[v99];
              uint64_t v105 = v104 & 0x7F;
              if (v101 >= 0x40 && (v104 & 0x7F) != 0) {
                break;
              }
              if ((unint64_t)(v105 << v101) >> v101 != v105) {
                break;
              }
              v100 += v105 << v101;
              v101 += 7;
              ++v99;
              if ((v104 & 0x80) == 0)
              {
                __int16 v106 = 0;
                char v107 = 1;
LABEL_159:
                unint64_t v115 = &v29[v99];
                if (v115 <= v103) {
                  uint64_t v103 = v115;
                }
                *((void *)this + 15) = v103;
                uint64_t v116 = *((void *)this + 2) + v100;
                *((void *)this + 2) = v116;
                if ((v107 & 1) == 0)
                {
                  int v190 = *(unsigned __int8 *)v106;
                  unint64_t v191 = (const char **)"for BIND_OPCODE_ADD_ADDR_ULEB ";
                  if (*v106)
                  {
                    uint64_t v281 = "for BIND_OPCODE_ADD_ADDR_ULEB ";
                    uint64_t v283 = v106;
                    __int16 v284 = 771;
                    char v192 = 2;
                  }
                  else
                  {
                    uint64_t v281 = "for BIND_OPCODE_ADD_ADDR_ULEB ";
                    __int16 v284 = 259;
                    char v192 = 3;
                  }
                  if (v190) {
                    unint64_t v191 = &v281;
                  }
                  uint64_t v285 = (const char *)v191;
                  uint64_t v286 = v282;
                  uint64_t v287 = " for opcode at: 0x";
                  goto LABEL_354;
                }
                uint64_t v117 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), v116, *((unsigned __int8 *)this + 144), 1u, 0);
                if (!v117) {
                  goto LABEL_173;
                }
                if (*v117)
                {
                  uint64_t v281 = "for BIND_OPCODE_ADD_ADDR_ULEB ";
                  uint64_t v283 = v117;
                  __int16 v284 = 771;
                  char v193 = 2;
                  int v194 = &v281;
                }
                else
                {
                  int v194 = (const char **)"for BIND_OPCODE_ADD_ADDR_ULEB ";
                  uint64_t v281 = "for BIND_OPCODE_ADD_ADDR_ULEB ";
                  __int16 v284 = 259;
                  char v193 = 3;
                }
                uint64_t v285 = (const char *)v194;
                uint64_t v286 = v282;
                uint64_t v287 = " for opcode at: 0x";
                LOBYTE(v28++*(_DWORD *)(this + 8) = v193;
LABEL_186:
                HIBYTE(v28++*(_DWORD *)(this + 8) = 3;
                unint64_t v128 = (unsigned __int8 *)(v27 - v84);
                goto LABEL_478;
              }
            }
            char v107 = 0;
            uint64_t v100 = 0;
            __int16 v106 = "uleb128 too big for uint64";
            goto LABEL_159;
          case 9u:
            uint64_t v56 = *((unsigned __int8 *)this + 144);
            *((void *)this + ++*(_DWORD *)(this + 16) = 0;
            *((void *)this + 17) = v56;
            int v57 = *((unsigned __int8 *)this + 153);
            if (*((unsigned char *)this + 153)
              || (unsigned __int16 v58 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), *((void *)this + 2), v56, 1u, 0)) == 0)
            {
              uint64_t v59 = *((void *)this + 5);
              if (v59)
              {
                if (*((unsigned char *)this + 152) || *((_DWORD *)this + 37) == 2)
                {
                  if (!v57) {
                    goto LABEL_481;
                  }
                  unsigned __int16 v61 = (char *)*((void *)this + 21);
                  __int16 v60 = (char *)*((void *)this + 22);
                  unint64_t v62 = (v60 - v61) >> 5;
                  if (v62 < *((void *)this + 20))
                  {
                    uint64_t v272 = v2;
                    uint64_t v63 = *((void *)this + 4);
                    uint64_t v64 = *((void *)this + 7);
                    int v65 = *((_DWORD *)this + 12);
                    int v66 = *((_DWORD *)this + 13);
                    char v67 = *((unsigned char *)this + 146);
                    unint64_t v68 = *((void *)this + 23);
                    if ((unint64_t)v60 >= v68)
                    {
                      unint64_t v112 = v62 + 1;
                      if ((v62 + 1) >> 59) {
                        goto LABEL_465;
                      }
                      uint64_t v113 = v68 - (void)v61;
                      if (v113 >> 4 > v112) {
                        unint64_t v112 = v113 >> 4;
                      }
                      if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFE0) {
                        unint64_t v112 = 0x7FFFFFFFFFFFFFFLL;
                      }
                      unint64_t v271 = v112;
                      if (v112)
                      {
                        if (v112 >> 59) {
                          sub_1CB833614();
                        }
                        unint64_t v114 = (char *)operator new(32 * v112);
                      }
                      else
                      {
                        unint64_t v114 = 0;
                      }
                      __int16 v118 = &v114[32 * v62];
                      *(void *)__int16 v118 = v63;
                      *((void *)v118 + 1) = v59;
                      *((void *)v118 + 2) = v64;
                      *((_DWORD *)v118 + 6) = v65;
                      v118[28] = v66;
                      v118[29] = v67;
                      unsigned int v119 = v118;
                      if (v60 == v61)
                      {
                        unint64_t v120 = v271;
                        unint64_t v2 = v272;
                        unint64_t v28 = "malformed sleb128, extends past end";
                      }
                      else
                      {
                        unint64_t v120 = v271;
                        unint64_t v2 = v272;
                        unint64_t v28 = "malformed sleb128, extends past end";
                        do
                        {
                          long long v121 = *((_OWORD *)v60 - 2);
                          *(_OWORD *)(v119 - 1++*(_DWORD *)(this + 8) = *(_OWORD *)(v60 - 18);
                          *((_OWORD *)v119 - 2) = v121;
                          v119 -= 32;
                          v60 -= 32;
                        }
                        while (v60 != v61);
                        __int16 v60 = (char *)*((void *)this + 21);
                      }
                      __int16 v69 = v118 + 32;
                      *((void *)this + 21) = v119;
                      *((void *)this + 22) = v118 + 32;
                      *((void *)this + 23) = &v114[32 * v120];
                      if (v60) {
                        operator delete(v60);
                      }
                    }
                    else
                    {
                      *(void *)__int16 v60 = v63;
                      *((void *)v60 + 1) = v59;
                      *((void *)v60 + 2) = v64;
                      *((_DWORD *)v60 + 6) = v65;
                      v60[28] = v66;
                      __int16 v69 = v60 + 32;
                      v60[29] = v67;
                      unint64_t v2 = v272;
                      unint64_t v28 = "malformed sleb128, extends past end";
                    }
                    *((void *)this + 22) = v69;
                    goto LABEL_173;
                  }
                  uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
                  int v186 = "at BIND_OPCODE_DO_BIND (incorrect ordinal table size, number of BIND_OPCODE_DO_BIND opcodes exc"
                         "eed the count in previous BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB) at BIND_OPC"
                         "ODE_DO_BIND at: 0x";
                }
                else
                {
                  uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
                  int v186 = "for BIND_OPCODE_DO_BIND missing preceding BIND_OPCODE_SET_DYLIB_ORDINAL_* for opcode at: 0x";
                }
              }
              else
              {
                uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
                int v186 = "for BIND_OPCODE_DO_BIND missing preceding BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM for opcode at: 0x";
              }
LABEL_429:
              uint64_t v281 = (const char *)v185;
              v289[0] = (uint64_t)v186;
              uint64_t v290 = (const char *)&v281;
              __int16 v291 = 3587;
              sub_1CCC51CE4((uint64_t)&v285, v289);
            }
            int v222 = *(unsigned __int8 *)v58;
            unint64_t v223 = "for BIND_OPCODE_DO_BIND ";
            if (!*v58) {
              goto LABEL_349;
            }
            goto LABEL_345;
          case 0xAu:
            int v187 = *((_DWORD *)this + 37);
            if (v187 == 1)
            {
              uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
              int v186 = "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB not allowed in lazy bind table for opcode at: 0x";
              goto LABEL_429;
            }
            uint64_t v216 = v2;
            int v217 = *((_DWORD *)this + 6);
            uint64_t v219 = *((void *)this + 1);
            uint64_t v218 = *((void *)this + 2);
            uint64_t v220 = *((unsigned __int8 *)this + 144);
            __int16 v221 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(v219 + 264), v217, v218, *((unsigned __int8 *)this + 144), 1u, 0);
            if (!v221)
            {
              if (*((void *)this + 5))
              {
                if (v187 == 2 || *((unsigned char *)this + 152))
                {
                  uint64_t v253 = 0;
                  unsigned int v254 = 0;
                  uint64_t v255 = *((void *)this + 12);
                  uint64_t v256 = (char *)(v255 + *((void *)this + 13));
                  uint64_t v257 = "malformed uleb128, extends past end";
                  uint64_t v258 = (char *)(v27 + 1);
                  while (v258 != v256)
                  {
                    char v259 = *v258;
                    uint64_t v260 = *v258 & 0x7F;
                    if (v254 >= 0x40 && (*v258 & 0x7F) != 0 || (unint64_t)(v260 << v254) >> v254 != v260)
                    {
                      char v261 = 0;
                      uint64_t v253 = 0;
                      uint64_t v257 = "uleb128 too big for uint64";
                      goto LABEL_447;
                    }
                    v253 += v260 << v254;
                    v254 += 7;
                    ++v258;
                    if ((v259 & 0x80) == 0)
                    {
                      uint64_t v257 = 0;
                      char v261 = 1;
                      goto LABEL_447;
                    }
                  }
                  char v261 = 0;
                  uint64_t v253 = 0;
                  uint64_t v258 = (char *)(v255 + *((void *)this + 13));
LABEL_447:
                  uint64_t v263 = &v29[v258 - v29];
                  if (v263 <= v256) {
                    uint64_t v256 = v263;
                  }
                  *((void *)this + 15) = v256;
                  *((void *)this + 17) = v253 + v220;
                  if (v261)
                  {
                    uint64_t v264 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(v219 + 264), v217, (int)v253 + (int)v220 + (int)v218, v220, 1u, 0);
                    if (!v264)
                    {
                      *((void *)this + ++*(_DWORD *)(this + 16) = 0;
                      unint64_t v2 = v216;
                      goto LABEL_481;
                    }
                    int v265 = *(unsigned __int8 *)v264;
                    uint64_t v266 = (const char **)"for BIND_OPCODE_ADD_ADDR_ULEB (after adding ULEB) ";
                    if (*v264)
                    {
                      uint64_t v281 = "for BIND_OPCODE_ADD_ADDR_ULEB (after adding ULEB) ";
                      uint64_t v283 = v264;
                      __int16 v284 = 771;
                      char v267 = 2;
                    }
                    else
                    {
                      uint64_t v281 = "for BIND_OPCODE_ADD_ADDR_ULEB (after adding ULEB) ";
                      __int16 v284 = 259;
                      char v267 = 3;
                    }
                    if (v265) {
                      uint64_t v266 = &v281;
                    }
                    uint64_t v285 = (const char *)v266;
                    uint64_t v286 = v282;
                    uint64_t v287 = " for opcode at: 0x";
                    LOBYTE(v28++*(_DWORD *)(this + 8) = v267;
                  }
                  else
                  {
                    int v268 = *(unsigned __int8 *)v257;
                    if (*v257)
                    {
                      uint64_t v281 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB ";
                      uint64_t v283 = v257;
                      __int16 v284 = 771;
                      char v269 = 2;
                    }
                    else
                    {
                      uint64_t v281 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB ";
                      __int16 v284 = 259;
                      char v269 = 3;
                    }
                    BOOL v98 = v268 == 0;
                    uint64_t v270 = &v281;
                    if (v98) {
                      uint64_t v270 = (const char **)"for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB ";
                    }
                    uint64_t v285 = (const char *)v270;
                    uint64_t v286 = v282;
                    uint64_t v287 = " for opcode at: 0x";
                    LOBYTE(v28++*(_DWORD *)(this + 8) = v269;
                  }
                  HIBYTE(v28++*(_DWORD *)(this + 8) = 3;
                  v274[0] = v27 - v255;
                  v289[0] = (uint64_t)&v285;
                  uint64_t v290 = (const char *)v274;
                  __int16 v291 = 3586;
                  sub_1CCC51CE4((uint64_t)v277, v289);
                }
                unsigned int v234 = (const char *)(v27 - *((void *)this + 12));
                size_t v235 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB missing preceding BIND_OPCODE_SET_DYLIB_ORDINAL_* for opcode at: 0x";
              }
              else
              {
                unsigned int v234 = (const char *)(v27 - *((void *)this + 12));
                size_t v235 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB missing preceding BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM"
                       " for opcode at: 0x";
              }
              uint64_t v281 = v234;
              v289[0] = (uint64_t)v235;
              uint64_t v290 = (const char *)&v281;
              __int16 v291 = 3587;
              sub_1CCC51CE4((uint64_t)&v285, v289);
            }
            int v222 = *(unsigned __int8 *)v221;
            unint64_t v223 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB ";
            if (*v221)
            {
              uint64_t v281 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB ";
              uint64_t v283 = v221;
              __int16 v284 = 771;
              char v224 = 2;
            }
            else
            {
              uint64_t v281 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB ";
              __int16 v284 = 259;
              char v224 = 3;
            }
            goto LABEL_399;
          case 0xBu:
            int v188 = *((_DWORD *)this + 37);
            if (v188 == 1)
            {
              uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
              int v186 = "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED not allowed in lazy bind table for opcode at: 0x";
              goto LABEL_429;
            }
            if (!*((void *)this + 5))
            {
              uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
              int v186 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED missing preceding BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS"
                     "_IMM for opcode at: 0x";
              goto LABEL_429;
            }
            if (v188 != 2 && *((unsigned char *)this + 152) == 0)
            {
              uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
              int v186 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED missing preceding BIND_OPCODE_SET_DYLIB_ORDINAL_* for opcode at: 0x";
              goto LABEL_429;
            }
            int v226 = *((unsigned __int8 *)this + 144);
            unint64_t v227 = *((unsigned __int8 *)this + 144) * (unint64_t)(v32 + 1);
            *((void *)this + ++*(_DWORD *)(this + 16) = 0;
            *((void *)this + 17) = v227;
            BOOL v228 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), *((void *)this + 2) + v226 * (v32 + 1), v226, 1u, 0);
            if (!v228) {
              goto LABEL_481;
            }
            int v229 = *(unsigned __int8 *)v228;
            long long v230 = (const char **)"for BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED ";
            if (*v228)
            {
              uint64_t v281 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED ";
              uint64_t v283 = v228;
              __int16 v284 = 771;
              char v224 = 2;
            }
            else
            {
              uint64_t v281 = "for BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED ";
              __int16 v284 = 259;
              char v224 = 3;
            }
            if (v229) {
              long long v230 = &v281;
            }
            uint64_t v285 = (const char *)v230;
            uint64_t v287 = " for opcode at: 0x";
            goto LABEL_402;
          case 0xCu:
            int v184 = *((_DWORD *)this + 37);
            if (v184 == 1)
            {
              uint64_t v185 = (unsigned __int8 *)(v27 - *((void *)this + 12));
              int v186 = "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB not allowed in lazy bind table for opcode at: 0x";
              goto LABEL_429;
            }
            uint64_t v207 = 0;
            unsigned int v208 = 0;
            uint64_t v209 = *((void *)this + 12);
            char v210 = (char *)(v209 + *((void *)this + 13));
            char v211 = "malformed uleb128, extends past end";
            char v212 = (char *)(v27 + 1);
            while (v212 != v210)
            {
              char v213 = *v212;
              uint64_t v214 = *v212 & 0x7F;
              if (v208 >= 0x40 && (*v212 & 0x7F) != 0 || (unint64_t)(v214 << v208) >> v208 != v214)
              {
                char v215 = 0;
                LODWORD(v207) = 0;
                char v211 = "uleb128 too big for uint64";
                goto LABEL_383;
              }
              v207 += v214 << v208;
              v208 += 7;
              ++v212;
              if ((v213 & 0x80) == 0)
              {
                char v211 = 0;
                char v215 = 1;
                goto LABEL_383;
              }
            }
            char v215 = 0;
            LODWORD(v207) = 0;
            char v212 = (char *)(v209 + *((void *)this + 13));
LABEL_383:
            uint64_t v239 = &v29[v212 - v29];
            if (v239 > v210) {
              uint64_t v239 = (char *)(v209 + *((void *)this + 13));
            }
            uint64_t v240 = (v207 - 1);
            if (!v207) {
              uint64_t v240 = 0;
            }
            *((void *)this + 15) = v239;
            *((void *)this + ++*(_DWORD *)(this + 16) = v240;
            if (v215)
            {
              uint64_t v241 = 0;
              unsigned int v242 = 0;
              char v211 = "malformed uleb128, extends past end";
              uint64_t v243 = v239;
              while (v243 != v210)
              {
                char v244 = *v243;
                uint64_t v245 = *v243 & 0x7F;
                if (v242 >= 0x40 && (*v243 & 0x7F) != 0 || (unint64_t)(v245 << v242) >> v242 != v245)
                {
                  char v246 = 0;
                  LODWORD(v241) = 0;
                  char v211 = "uleb128 too big for uint64";
                  goto LABEL_411;
                }
                v241 += v245 << v242;
                v242 += 7;
                ++v243;
                if ((v244 & 0x80) == 0)
                {
                  char v211 = 0;
                  char v246 = 1;
                  goto LABEL_411;
                }
              }
              char v246 = 0;
              LODWORD(v241) = 0;
              LODWORD(v243) = v210;
LABEL_411:
              uint64_t v249 = &v239[v243 - v239];
              if (v249 <= v210) {
                char v210 = v249;
              }
              *((void *)this + 15) = v210;
              int v250 = *((unsigned __int8 *)this + 144);
              uint64_t v251 = (v241 + v250);
              *((void *)this + 17) = v251;
              if (v246)
              {
                if (!*((void *)this + 5))
                {
                  uint64_t v185 = (unsigned __int8 *)(v27 - v209);
                  int v186 = "for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB missing preceding BIND_OPCODE_SET_SYMBOL_TRAIL"
                         "ING_FLAGS_IMM for opcode at: 0x";
                  goto LABEL_429;
                }
                if (v184 != 2 && !*((unsigned char *)this + 152))
                {
                  uint64_t v185 = (unsigned __int8 *)(v27 - v209);
                  int v186 = "for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB missing preceding BIND_OPCODE_SET_DYLIB_ORDINA"
                         "L_* for opcode at: 0x";
                  goto LABEL_429;
                }
                uint64_t v262 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), *((void *)this + 2) + v251, v250, v207, v241);
                if (!v262) {
                  goto LABEL_481;
                }
                int v247 = *(unsigned __int8 *)v262;
                uint64_t v248 = "for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB ";
                if (*v262)
                {
                  uint64_t v281 = "for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB ";
                  uint64_t v283 = v262;
                  goto LABEL_420;
                }
LABEL_433:
                uint64_t v281 = v248;
                __int16 v284 = 259;
                char v252 = 3;
                goto LABEL_434;
              }
              int v247 = *(unsigned __int8 *)v211;
              uint64_t v248 = "for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB (skip value) ";
              if (!*v211) {
                goto LABEL_433;
              }
            }
            else
            {
              int v247 = *(unsigned __int8 *)v211;
              uint64_t v248 = "for BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB  (count value) ";
              if (!*v211) {
                goto LABEL_433;
              }
            }
            uint64_t v281 = v248;
            uint64_t v283 = v211;
LABEL_420:
            __int16 v284 = 771;
            char v252 = 2;
LABEL_434:
            if (v247) {
              uint64_t v248 = (const char *)&v281;
            }
            uint64_t v285 = v248;
            uint64_t v286 = v282;
            uint64_t v287 = " for opcode at: 0x";
            LOBYTE(v28++*(_DWORD *)(this + 8) = v252;
            HIBYTE(v28++*(_DWORD *)(this + 8) = 3;
            unint64_t v128 = (unsigned __int8 *)(v27 - v209);
            goto LABEL_478;
          case 0xDu:
            if (v32 != 1)
            {
              if ((v30 & 0xF) != 0)
              {
                v277[0] = "bad bind sub-obcode of BIND_OPCODE_THREADED (bad sub-opcode value 0x";
                uint64_t v278 = (const char *)&v280;
                __int16 v279 = 3587;
                uint64_t v280 = (unsigned __int8 *)(v30 & 0xF);
                uint64_t v281 = (const char *)v277;
                uint64_t v283 = " for opcode at: 0x";
                __int16 v284 = 770;
                uint64_t v273 = (unsigned __int8 *)(v27 - *((void *)this + 12));
                uint64_t v285 = (const char *)&v281;
                uint64_t v287 = (const char *)&v273;
                __int16 v288 = 3586;
                v289[0] = (uint64_t)&v285;
                uint64_t v290 = ")";
                __int16 v291 = 770;
                sub_1CCC51CE4((uint64_t)v274, v289);
              }
              uint64_t v45 = 0;
              unint64_t v46 = 0;
              unsigned int v47 = 0;
              uint64_t v48 = *((void *)this + 12);
              uint64_t v49 = *((void *)this + 13);
              uint64_t v50 = (unsigned char *)(v48 + v49);
              while (&v29[v45] != v50)
              {
                char v51 = v29[v45];
                uint64_t v52 = v51 & 0x7F;
                if (v47 >= 0x40 && (v51 & 0x7F) != 0 || (unint64_t)(v52 << v47) >> v47 != v52)
                {
                  long long v133 = "uleb128 too big for uint64";
                  goto LABEL_195;
                }
                v46 += v52 << v47;
                v47 += 7;
                ++v45;
                if ((v51 & 0x80) == 0)
                {
                  int v53 = &v29[v45];
                  if (v53 > v50) {
                    int v53 = v50;
                  }
                  *((void *)this + 15) = v53;
                  *((void *)this + 20) = v46;
                  uint64_t v54 = (void *)*((void *)this + 21);
                  *((void *)this + 22) = v54;
                  if (v46 <= (uint64_t)(*((void *)this + 23) - (void)v54) >> 5) {
                    goto LABEL_74;
                  }
                  if (!(v46 >> 59))
                  {
                    char v55 = (char *)operator new(32 * v46);
                    *((void *)this + 21) = v55;
                    *((void *)this + 22) = v55;
                    *((void *)this + 23) = &v55[32 * v46];
                    if (v54) {
                      operator delete(v54);
                    }
LABEL_74:
                    *((unsigned char *)this + 153) = 1;
                    goto LABEL_173;
                  }
LABEL_465:
                  abort();
                }
              }
              LODWORD(v45) = v48 + v49 + ~v27;
              long long v133 = "malformed uleb128, extends past end";
LABEL_195:
              uint64_t v134 = &v29[v45];
              if (v134 <= v50) {
                uint64_t v50 = v134;
              }
              *((void *)this + 15) = v50;
              *((void *)this + 20) = 0;
              int v135 = *(unsigned __int8 *)v133;
              char v136 = (const char **)"for BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB ";
              if (*v133)
              {
                uint64_t v281 = "for BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB ";
                uint64_t v283 = v133;
                __int16 v284 = 771;
                char v132 = 2;
              }
              else
              {
                uint64_t v281 = "for BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB ";
                __int16 v284 = 259;
                char v132 = 3;
              }
              if (v135) {
                char v136 = &v281;
              }
              uint64_t v285 = (const char *)v136;
              uint64_t v286 = v282;
              uint64_t v287 = " for opcode at: 0x";
LABEL_476:
              LOBYTE(v28++*(_DWORD *)(this + 8) = v132;
              HIBYTE(v28++*(_DWORD *)(this + 8) = 3;
LABEL_477:
              unint64_t v128 = (unsigned __int8 *)(v27 - v48);
              goto LABEL_478;
            }
            if (*((void *)this + 20) == (uint64_t)(*((void *)this + 22) - *((void *)this + 21)) >> 5)
            {
              unsigned __int16 v58 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), *((void *)this + 2), *((unsigned __int8 *)this + 144), 1u, 0);
              if (v58)
              {
                int v222 = *(unsigned __int8 *)v58;
                unint64_t v223 = "for BIND_SUBOPCODE_THREADED_APPLY ";
                if (*v58)
                {
LABEL_345:
                  uint64_t v281 = v223;
                  uint64_t v283 = v58;
                  __int16 v284 = 771;
                  char v224 = 2;
                }
                else
                {
LABEL_349:
                  uint64_t v281 = v223;
                  __int16 v284 = 259;
                  char v224 = 3;
                }
LABEL_399:
                if (v222) {
                  unint64_t v223 = (const char *)&v281;
                }
                uint64_t v285 = v223;
                uint64_t v286 = v282;
                uint64_t v287 = " for opcode at: 0x";
LABEL_402:
                LOBYTE(v28++*(_DWORD *)(this + 8) = v224;
                HIBYTE(v28++*(_DWORD *)(this + 8) = 3;
LABEL_403:
                uint64_t v48 = *((void *)this + 12);
                goto LABEL_477;
              }
              if ((llvm::object::MachOAbstractFixupEntry::address(this) & 3) == 0)
              {
                if (llvm::object::MachORebaseBindEntry::getNextThreadedEntry(this, 1, *((_DWORD *)this + 37) != 3)) {
                  goto LABEL_481;
                }
                goto LABEL_173;
              }
              v277[0] = v27 - *((void *)this + 12);
              uint64_t v285 = "for BIND_SUBOPCODE_THREADED_APPLY for opcode at: 0x";
              uint64_t v287 = (const char *)v277;
              __int16 v288 = 3587;
              unsigned int v231 = " bad segOffset, not 8-byte aligned";
            }
            else
            {
              v277[0] = v27 - *((void *)this + 12);
              uint64_t v285 = "at BIND_SUBOPCODE_THREADED_APPLY (incorrect ordinal table size, count of previous BIND_OPCODE_DO_BI"
                     "ND opcodes don't match count in previous BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB a"
                     "t BIND_SUBOPCODE_THREADED_APPLY at: 0x";
              uint64_t v287 = (const char *)v277;
              __int16 v288 = 3587;
              unsigned int v231 = ")";
            }
            v289[0] = (uint64_t)&v285;
            uint64_t v290 = v231;
            __int16 v291 = 770;
            sub_1CCC51CE4((uint64_t)&v281, v289);
          default:
            v274[0] = v31 & 0xF0;
            uint64_t v281 = "bad bind info (bad opcode value 0x";
            uint64_t v283 = (const char *)v274;
            __int16 v284 = 3587;
            uint64_t v285 = (const char *)&v281;
            uint64_t v287 = " for opcode at: 0x";
            __int16 v288 = 770;
            int v181 = (unsigned __int8 *)(v27 - *((void *)this + 12));
LABEL_271:
            uint64_t v280 = v181;
            uint64_t v189 = (const char *)&v280;
            goto LABEL_479;
        }
      }
    }
LABEL_36:
    if (*((_DWORD *)this + 50) && (llvm::object::MachORebaseBindEntry::getNextThreadedEntry(this, 0, v3 != 3) & 1) != 0) {
      goto LABEL_481;
    }
    goto LABEL_38;
  }
  if (*((unsigned char *)this + 153)) {
    goto LABEL_36;
  }
  uint64_t v4 = *((void *)this + 16);
  uint64_t v5 = *((void *)this + 2) + *((void *)this + 17);
  *((void *)this + 2) = v5;
  if (v4)
  {
LABEL_39:
    *((void *)this + ++*(_DWORD *)(this + 16) = v4 - 1;
    goto LABEL_481;
  }
  int v6 = (unsigned __int8 *)*((void *)this + 15);
  uint64_t v7 = *((void *)this + 12);
  uint64_t v8 = *((void *)this + 13);
  unint64_t v9 = (unsigned __int8 *)(v7 + v8);
  if (v6 == (unsigned __int8 *)(v7 + v8))
  {
LABEL_174:
    *((unsigned char *)this + 80) = 1;
    goto LABEL_481;
  }
LABEL_5:
  while (2)
  {
    int v10 = v6 + 1;
    while (1)
    {
      uint64_t v11 = v6++;
      *((void *)this + 15) = v6;
      unsigned int v12 = *v11;
      unsigned int v13 = v12 & 0xF;
      if (v12 >> 4 != 1) {
        break;
      }
      *((unsigned char *)this + 145) = v13;
      ++v10;
      if (v13 >= 4)
      {
        uint64_t v281 = "for REBASE_OPCODE_SET_TYPE_IMM bad bind type: ";
        uint64_t v283 = (const char *)(v12 & 0xF);
        __int16 v284 = 2307;
        uint64_t v285 = (const char *)&v281;
        uint64_t v287 = " for opcode at: 0x";
        __int16 v288 = 770;
        goto LABEL_380;
      }
    }
    switch(v12 >> 4)
    {
      case 0u:
        *((unsigned char *)this + 80) = 1;
        *((void *)this + 15) = v9;
        goto LABEL_480;
      case 2u:
        uint64_t v14 = 0;
        uint64_t v5 = 0;
        unsigned int v15 = 0;
        *((_DWORD *)this + 6) = v13;
        do
        {
          if (&v10[v14] == v9)
          {
            LODWORD(v14) = v8 + v7 + ~v11;
            unsigned int v183 = "malformed uleb128, extends past end";
LABEL_284:
            BOOL v195 = &v6[v14];
            if (v195 > v9) {
              BOOL v195 = (unsigned __int8 *)(v7 + v8);
            }
            *((void *)this + 15) = v195;
            *((void *)this + 2) = 0;
            int v196 = *(unsigned __int8 *)v183;
            if (*v183)
            {
              uint64_t v281 = "for REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
              uint64_t v283 = v183;
              __int16 v284 = 771;
              char v197 = 2;
            }
            else
            {
              uint64_t v281 = "for REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
              __int16 v284 = 259;
              char v197 = 3;
            }
            int v198 = "for REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
LABEL_320:
            BOOL v98 = v196 == 0;
            unint64_t v205 = &v281;
            if (v98) {
              unint64_t v205 = (const char **)v198;
            }
            uint64_t v285 = (const char *)v205;
            uint64_t v287 = " for opcode at: 0x";
            LOBYTE(v28++*(_DWORD *)(this + 8) = v197;
            goto LABEL_379;
          }
          unsigned __int8 v16 = v10[v14];
          uint64_t v17 = v16 & 0x7F;
          if (v15 >= 0x40 && (v16 & 0x7F) != 0 || (unint64_t)(v17 << v15) >> v15 != v17)
          {
            unsigned int v183 = "uleb128 too big for uint64";
            goto LABEL_284;
          }
          v5 += v17 << v15;
          v15 += 7;
          ++v14;
        }
        while ((v16 & 0x80) != 0);
        if (&v6[v14] <= v9) {
          v6 += v14;
        }
        else {
          int v6 = (unsigned __int8 *)(v7 + v8);
        }
        *((void *)this + 15) = v6;
        *((void *)this + 2) = v5;
        long long v18 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), v13, v5, *((unsigned __int8 *)this + 144), 1u, 0);
        if (v18)
        {
          int v25 = *(unsigned __int8 *)v18;
          unsigned int v26 = "for REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB ";
          if (!*v18) {
            goto LABEL_256;
          }
LABEL_207:
          uint64_t v281 = v26;
          uint64_t v283 = v18;
          __int16 v284 = 771;
          char v139 = 2;
LABEL_257:
          if (v25) {
            unsigned int v26 = (const char *)&v281;
          }
          uint64_t v285 = v26;
          uint64_t v287 = " for opcode at: 0x";
          LOBYTE(v28++*(_DWORD *)(this + 8) = v139;
LABEL_379:
          HIBYTE(v28++*(_DWORD *)(this + 8) = 3;
LABEL_380:
          unint64_t v128 = &v11[-v7];
LABEL_478:
          v274[0] = v128;
          uint64_t v189 = (const char *)v274;
LABEL_479:
          v289[0] = (uint64_t)&v285;
          uint64_t v290 = v189;
          __int16 v291 = 3586;
          sub_1CCC51CE4((uint64_t)v277, v289);
        }
        continue;
      case 3u:
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        unsigned int v21 = 0;
        while (&v10[v19] != v9)
        {
          unsigned __int8 v22 = v10[v19];
          uint64_t v23 = v22 & 0x7F;
          if (v21 >= 0x40 && (v22 & 0x7F) != 0 || (unint64_t)(v23 << v21) >> v21 != v23)
          {
            BOOL v182 = "uleb128 too big for uint64";
            goto LABEL_291;
          }
          v20 += v23 << v21;
          v21 += 7;
          ++v19;
          if ((v22 & 0x80) == 0)
          {
            if (&v6[v19] <= v9) {
              v6 += v19;
            }
            else {
              int v6 = (unsigned __int8 *)(v7 + v8);
            }
            *((void *)this + 15) = v6;
            v5 += v20;
            *((void *)this + 2) = v5;
            long long v18 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), v5, *((unsigned __int8 *)this + 144), 1u, 0);
            if (v18)
            {
              int v25 = *(unsigned __int8 *)v18;
              unsigned int v26 = "for REBASE_OPCODE_ADD_ADDR_ULEB ";
              if (*v18) {
                goto LABEL_207;
              }
LABEL_256:
              uint64_t v281 = v26;
              __int16 v284 = 259;
              char v139 = 3;
              goto LABEL_257;
            }
            goto LABEL_5;
          }
        }
        LODWORD(v19) = v8 + v7 + ~v11;
        BOOL v182 = "malformed uleb128, extends past end";
LABEL_291:
        BOOL v199 = &v6[v19];
        if (v199 > v9) {
          BOOL v199 = (unsigned __int8 *)(v7 + v8);
        }
        *((void *)this + 15) = v199;
        *((void *)this + 2) = v5;
        int v196 = *(unsigned __int8 *)v182;
        if (*v182)
        {
          uint64_t v281 = "for REBASE_OPCODE_ADD_ADDR_ULEB ";
          uint64_t v283 = v182;
          __int16 v284 = 771;
          char v197 = 2;
        }
        else
        {
          uint64_t v281 = "for REBASE_OPCODE_ADD_ADDR_ULEB ";
          __int16 v284 = 259;
          char v197 = 3;
        }
        int v198 = "for REBASE_OPCODE_ADD_ADDR_ULEB ";
        goto LABEL_320;
      case 4u:
        int v24 = *((unsigned __int8 *)this + 144);
        v5 += *((unsigned __int8 *)this + 144) * (unint64_t)(v12 & 0xF);
        *((void *)this + 2) = v5;
        long long v18 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), v5, v24, 1u, 0);
        if (!v18) {
          continue;
        }
        int v25 = *(unsigned __int8 *)v18;
        unsigned int v26 = "for REBASE_OPCODE_ADD_ADDR_IMM_SCALED ";
        if (!*v18) {
          goto LABEL_256;
        }
        goto LABEL_207;
      case 5u:
        uint64_t v137 = *((unsigned __int8 *)this + 144);
        uint64_t v138 = v13 - 1;
        if ((v12 & 0xF) == 0) {
          uint64_t v138 = 0;
        }
        *((void *)this + ++*(_DWORD *)(this + 16) = v138;
        *((void *)this + 17) = v137;
        long long v18 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), v5, v137, v13, 0);
        if (!v18) {
          goto LABEL_481;
        }
        int v25 = *(unsigned __int8 *)v18;
        unsigned int v26 = "for REBASE_OPCODE_DO_REBASE_IMM_TIMES ";
        if (*v18) {
          goto LABEL_207;
        }
        goto LABEL_256;
      case 6u:
        uint64_t v170 = 0;
        unsigned int v171 = 0;
        uint64_t v172 = *((unsigned __int8 *)this + 144);
        *((void *)this + 17) = v172;
        int v173 = v8 + v7;
        uint64_t v174 = 1;
        unint64_t v175 = "malformed uleb128, extends past end";
        int v176 = (int)v6;
        while (1)
        {
          if (&v11[v174] == v9) {
            goto LABEL_314;
          }
          unsigned __int8 v177 = v11[v174];
          uint64_t v178 = v177 & 0x7F;
          if (v171 >= 0x40 && (v177 & 0x7F) != 0)
          {
            int v173 = v11 + v174;
            unint64_t v175 = "uleb128 too big for uint64";
            goto LABEL_314;
          }
          if ((unint64_t)(v178 << v171) >> v171 != v178) {
            break;
          }
          v170 += v178 << v171;
          v171 += 7;
          ++v176;
          ++v174;
          if ((v177 & 0x80) == 0)
          {
            int v179 = &v6[(v174 - 1)];
            if (v179 > v9) {
              int v179 = (unsigned __int8 *)(v7 + v8);
            }
            uint64_t v180 = (v170 - 1);
            if (!v170) {
              uint64_t v180 = 0;
            }
            *((void *)this + 15) = v179;
            *((void *)this + ++*(_DWORD *)(this + 16) = v180;
            long long v18 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), v5, v172, v170, 0);
            if (v18)
            {
              int v25 = *(unsigned __int8 *)v18;
              unsigned int v26 = "for REBASE_OPCODE_DO_REBASE_ULEB_TIMES ";
              if (!*v18) {
                goto LABEL_256;
              }
              goto LABEL_207;
            }
            goto LABEL_481;
          }
        }
        int v173 = v176;
        unint64_t v175 = "uleb128 too big for uint64";
LABEL_314:
        uint64_t v204 = &v6[v173 - v6];
        if (v204 > v9) {
          uint64_t v204 = (unsigned __int8 *)(v7 + v8);
        }
        *((void *)this + 15) = v204;
        int v196 = *(unsigned __int8 *)v175;
        if (*v175)
        {
          uint64_t v281 = "for REBASE_OPCODE_DO_REBASE_ULEB_TIMES ";
          uint64_t v283 = v175;
          __int16 v284 = 771;
          char v197 = 2;
        }
        else
        {
          uint64_t v281 = "for REBASE_OPCODE_DO_REBASE_ULEB_TIMES ";
          __int16 v284 = 259;
          char v197 = 3;
        }
        int v198 = "for REBASE_OPCODE_DO_REBASE_ULEB_TIMES ";
        goto LABEL_320;
      case 7u:
        uint64_t v140 = 0;
        unsigned int v141 = 0;
        int v142 = v8 + v7;
        uint64_t v143 = 1;
        unsigned int v144 = "malformed uleb128, extends past end";
        int v145 = (int)v6;
        while (1)
        {
          if (&v11[v143] == v9) {
            goto LABEL_301;
          }
          unsigned __int8 v146 = v11[v143];
          uint64_t v147 = v146 & 0x7F;
          if (v141 >= 0x40 && (v146 & 0x7F) != 0)
          {
            int v142 = v11 + v143;
            unsigned int v144 = "uleb128 too big for uint64";
            goto LABEL_301;
          }
          if ((unint64_t)(v147 << v141) >> v141 != v147) {
            break;
          }
          v140 += v147 << v141;
          v141 += 7;
          ++v145;
          ++v143;
          if ((v146 & 0x80) == 0)
          {
            unsigned int v148 = &v6[(v143 - 1)];
            if (v148 > v9) {
              unsigned int v148 = (unsigned __int8 *)(v7 + v8);
            }
            int v149 = *((unsigned __int8 *)this + 144);
            *((void *)this + ++*(_DWORD *)(this + 16) = 0;
            *((void *)this + 17) = (v140 + v149);
            *((void *)this + 15) = v148;
            long long v18 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), v5, v149, 1u, v140);
            if (v18)
            {
              int v25 = *(unsigned __int8 *)v18;
              unsigned int v26 = "for REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB ";
              if (!*v18) {
                goto LABEL_256;
              }
              goto LABEL_207;
            }
            goto LABEL_481;
          }
        }
        int v142 = v145;
        unsigned int v144 = "uleb128 too big for uint64";
LABEL_301:
        unint64_t v200 = &v6[v142 - v6];
        if (v200 > v9) {
          unint64_t v200 = (unsigned __int8 *)(v7 + v8);
        }
        *((void *)this + 15) = v200;
        int v196 = *(unsigned __int8 *)v144;
        if (*v144)
        {
          uint64_t v281 = "for REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB ";
          uint64_t v283 = v144;
          __int16 v284 = 771;
          char v197 = 2;
        }
        else
        {
          uint64_t v281 = "for REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB ";
          __int16 v284 = 259;
          char v197 = 3;
        }
        int v198 = "for REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB ";
        goto LABEL_320;
      case 8u:
        uint64_t v150 = 0;
        uint64_t v151 = 0;
        unsigned int v152 = 0;
        int v153 = v8 + v7;
        unsigned int v154 = "malformed uleb128, extends past end";
        int v155 = (int)v6;
        break;
      default:
        v274[0] = v12 & 0xF0;
        uint64_t v281 = "bad rebase info (bad opcode value 0x";
        uint64_t v283 = (const char *)v274;
        __int16 v284 = 3587;
        uint64_t v285 = (const char *)&v281;
        uint64_t v287 = " for opcode at: 0x";
        __int16 v288 = 770;
        int v181 = &v11[-v7];
        goto LABEL_271;
    }
    break;
  }
  do
  {
    if (&v10[v150] == v9) {
      goto LABEL_308;
    }
    unsigned __int8 v156 = v10[v150];
    uint64_t v157 = v156 & 0x7F;
    if (v152 >= 0x40 && (v156 & 0x7F) != 0)
    {
      int v153 = v10 + v150;
      unsigned int v154 = "uleb128 too big for uint64";
      goto LABEL_308;
    }
    if ((unint64_t)(v157 << v152) >> v152 != v157)
    {
      int v153 = v155;
      unsigned int v154 = "uleb128 too big for uint64";
LABEL_308:
      long long v201 = &v6[v153 - v6];
      if (v201 > v9) {
        long long v201 = (unsigned __int8 *)(v7 + v8);
      }
      *((void *)this + 15) = v201;
      int v202 = *(unsigned __int8 *)v154;
      if (*v154)
      {
        uint64_t v281 = "for REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB ";
        uint64_t v283 = v154;
LABEL_312:
        __int16 v284 = 771;
        char v203 = 2;
LABEL_376:
        BOOL v98 = v202 == 0;
        uint64_t v238 = &v281;
        if (v98) {
          uint64_t v238 = (const char **)"for REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB ";
        }
        uint64_t v285 = (const char *)v238;
        uint64_t v287 = " for opcode at: 0x";
        LOBYTE(v28++*(_DWORD *)(this + 8) = v203;
        goto LABEL_379;
      }
LABEL_375:
      uint64_t v281 = "for REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB ";
      __int16 v284 = 259;
      char v203 = 3;
      goto LABEL_376;
    }
    v151 += v157 << v152;
    v152 += 7;
    ++v155;
    ++v150;
  }
  while ((v156 & 0x80) != 0);
  uint64_t v158 = 0;
  uint64_t v159 = 0;
  unsigned int v160 = 0;
  unsigned int v161 = &v6[v150];
  if (v161 > v9) {
    unsigned int v161 = (unsigned __int8 *)(v7 + v8);
  }
  uint64_t v162 = (v151 - 1);
  if (!v151) {
    uint64_t v162 = 0;
  }
  *((void *)this + 15) = v161;
  *((void *)this + ++*(_DWORD *)(this + 16) = v162;
  if (v9 >= &v10[v150]) {
    BOOL v163 = &v10[v150];
  }
  else {
    BOOL v163 = (unsigned __int8 *)(v7 + v8);
  }
  unsigned int v164 = "malformed uleb128, extends past end";
  int v165 = (int)v161;
  while (2)
  {
    if (&v163[v158] == v9)
    {
      int v165 = v7 + v8;
      goto LABEL_371;
    }
    unsigned __int8 v166 = v163[v158];
    uint64_t v167 = v166 & 0x7F;
    if (v160 >= 0x40 && (v166 & 0x7F) != 0)
    {
      unint64_t v236 = (unint64_t)&v10[v150];
      if ((unint64_t)v9 < v236) {
        LODWORD(v236) = v7 + v8;
      }
      int v165 = v236 + v158;
      unsigned int v164 = "uleb128 too big for uint64";
LABEL_371:
      unint64_t v237 = (unint64_t)&v161[v165 - v161];
      if (v237 > (unint64_t)v9) {
        unint64_t v237 = v7 + v8;
      }
      *((void *)this + 15) = v237;
      int v202 = *(unsigned __int8 *)v164;
      if (*v164)
      {
        uint64_t v281 = "for REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB ";
        uint64_t v283 = v164;
        goto LABEL_312;
      }
      goto LABEL_375;
    }
    if ((unint64_t)(v167 << v160) >> v160 != v167)
    {
      unsigned int v164 = "uleb128 too big for uint64";
      goto LABEL_371;
    }
    v159 += v167 << v160;
    v160 += 7;
    ++v165;
    ++v158;
    if ((v166 & 0x80) != 0) {
      continue;
    }
    break;
  }
  unint64_t v168 = (unint64_t)&v161[v158];
  if (v168 > (unint64_t)v9) {
    unint64_t v168 = v7 + v8;
  }
  *((void *)this + 15) = v168;
  int v169 = *((unsigned __int8 *)this + 144);
  *((void *)this + 17) = (v159 + v169);
  long long v18 = llvm::object::BindRebaseSegInfo::checkSegAndOffsets(*(llvm::object::BindRebaseSegInfo **)(*((void *)this + 1) + 264), *((_DWORD *)this + 6), v5, v169, v151, v159);
  if (v18)
  {
    int v25 = *(unsigned __int8 *)v18;
    unsigned int v26 = "for REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB ";
    if (!*v18) {
      goto LABEL_256;
    }
    goto LABEL_207;
  }
LABEL_481:
  if (v2)
  {
    if (!*v2) {
      void *v2 = 0;
    }
  }
}

uint64_t llvm::object::MachORebaseBindEntry::moveToEnd(uint64_t this)
{
  *(unsigned char *)(this + 80) = 1;
  *(void *)(this + 120) = *(void *)(this + 96) + *(void *)(this + 104);
  *(void *)(this + 12++*(_DWORD *)(this + 8) = 0;
  return this;
}

uint64_t llvm::object::MachORebaseBindEntry::readULEB128(char **this, const char **a2)
{
  int v6 = 0;
  uint64_t result = sub_1CBF28C40(this[15], &v6, &this[13][(void)this[12]], a2);
  uint64_t v4 = &this[15][v6];
  uint64_t v5 = this[13];
  if (v4 > &v5[(void)this[12]]) {
    uint64_t v4 = &v5[(void)this[12]];
  }
  this[15] = v4;
  return result;
}

uint64_t llvm::object::MachORebaseBindEntry::getNextThreadedEntry(llvm::object::MachORebaseBindEntry *this, int a2, int a3)
{
  int v5 = *((_DWORD *)this + 6);
  uint64_t v7 = *((void *)this + 1);
  unint64_t v6 = *((void *)this + 2);
  uint64_t v8 = *(llvm::object::BindRebaseSegInfo **)(v7 + 264);
  uint64_t v9 = *(void *)v8;
  unsigned int v10 = *((_DWORD *)v8 + 2);
  if (v10)
  {
    uint64_t v11 = v9 + 88 * v10;
    uint64_t v12 = 88 * v10;
    while (1)
    {
      if (*(_DWORD *)(v9 + 80) == v5)
      {
        unint64_t v13 = *(void *)(v9 + 64);
        if (v13 <= v6 && *(void *)(v9 + 8) + v13 > v6) {
          break;
        }
      }
      v9 += 88;
      v12 -= 88;
      if (!v12)
      {
        uint64_t v9 = v11;
        break;
      }
    }
  }
  unint64_t v14 = *(void *)(v9 + 72) + v6;
  v51[0] = v14;
  if (a2)
  {
    *((void *)this + 24) = v14 & 0xFFFFFFFFFFFFC000;
  }
  else
  {
    v6 += (8 * *((_DWORD *)this + 50));
    *((void *)this + 2) = v6;
  }
  unsigned int v26 = (_OWORD *)((char *)this + 32);
  while (1)
  {
    unint64_t v15 = *(void *)llvm::object::BindRebaseSegInfo::contents(v8, v5, v6);
    unint64_t v50 = v15;
    unsigned int v16 = *(_DWORD *)(v7 + 8);
    BOOL v17 = v16 > 0x13;
    int v18 = (1 << v16) & 0xAAC00;
    if (!v17 && v18 != 0)
    {
      unint64_t v15 = bswap64(v15);
      unint64_t v50 = v15;
    }
    *((void *)this + 9) = v15;
    if ((v15 & 0x4000000000000000) != 0 && a3)
    {
      uint64_t v49 = (unsigned __int16)v15;
      if ((unint64_t)(unsigned __int16)v15 > *((void *)this + 20))
      {
        uint64_t v27 = *((void *)this + 14) - *((void *)this + 12);
        v28[0] = "bad bind info (for BIND_SUBOPCODE_THREADED_APPLY for opcode at: 0x";
        v28[2] = &v27;
        __int16 v29 = 3587;
        v30[0] = v28;
        void v30[2] = " bad ordinal: 0x";
        __int16 v31 = 770;
        v32[0] = v30;
        v32[2] = &v49;
        __int16 v33 = 3586;
        v34[0] = v32;
        v34[2] = " in pointer: 0x";
        __int16 v35 = 770;
        v36[0] = v34;
        char v37 = &v50;
        __int16 v38 = 3586;
        v39[0] = v36;
        uint64_t v40 = " at address: 0x";
        __int16 v41 = 770;
        v42[0] = v39;
        unsigned int v43 = v51;
        __int16 v44 = 3586;
        v45[0] = (uint64_t)v42;
        unint64_t v46 = ")";
        __int16 v47 = 770;
        sub_1CCC51CE4((uint64_t)&v48, v45);
      }
      uint64_t v20 = *((void *)this + 21) + 32 * (unsigned __int16)v15;
      *unsigned int v26 = *(_OWORD *)v20;
      *((_DWORD *)this + 12) = *(_DWORD *)(v20 + 24);
      *((_DWORD *)this + 13) = *(unsigned __int8 *)(v20 + 28);
      *((void *)this + 7) = *(void *)(v20 + 16);
      *((unsigned char *)this + 146) = *(unsigned char *)(v20 + 29);
      *((void *)this + ++*(_DWORD *)(this + 8) = 0;
      goto LABEL_26;
    }
    uint64_t v21 = 0;
    if ((v15 & 0x4000000000000000) == 0 && (a3 & 1) == 0)
    {
      if ((v15 & 0x8000000000000000) != 0) {
        *((void *)this + ++*(_DWORD *)(this + 8) = *((void *)this + 11) + v15;
      }
      else {
        *((void *)this + ++*(_DWORD *)(this + 8) = v15 & 0x7FFFFFFFFFFLL | ((unint64_t)(v15 >> 43) << 56);
      }
LABEL_26:
      uint64_t v21 = 1;
    }
    uint64_t v22 = (v15 >> 51) & 0x7FF;
    if (!v22) {
      break;
    }
    uint64_t v23 = (8 * v22);
    v6 += v23;
    uint64_t v8 = *(llvm::object::BindRebaseSegInfo **)(v7 + 264);
    if (llvm::object::BindRebaseSegInfo::checkSegAndOffsets(v8, v5, v6, 8, 1u, 0))
    {
      v32[0] = *((void *)this + 14) - *((void *)this + 12);
      v36[0] = "bad bind info (for BIND_SUBOPCODE_THREADED_APPLY for opcode at: 0x";
      char v37 = v32;
      __int16 v38 = 3587;
      v39[0] = v36;
      uint64_t v40 = " offset to next pointer in the chain after one at address: 0x";
      __int16 v41 = 770;
      v42[0] = v39;
      unsigned int v43 = v51;
      __int16 v44 = 3586;
      int v24 = " is past end of segment)";
      goto LABEL_35;
    }
    if (*((void *)this + 24) != ((v14 + v23) & 0xFFFFFFFFFFFFC000))
    {
      v32[0] = *((void *)this + 14) - *((void *)this + 12);
      v36[0] = "bad bind info (for BIND_SUBOPCODE_THREADED_APPLY for opcode at: 0x";
      char v37 = v32;
      __int16 v38 = 3587;
      v39[0] = v36;
      uint64_t v40 = " offset to next pointer in the chain after one at address: 0x";
      __int16 v41 = 770;
      v42[0] = v39;
      unsigned int v43 = v51;
      __int16 v44 = 3586;
      int v24 = " is past end of the same page)";
LABEL_35:
      v45[0] = (uint64_t)v42;
      unint64_t v46 = v24;
      __int16 v47 = 770;
      sub_1CCC51CE4((uint64_t)v34, v45);
    }
    if (v21) {
      break;
    }
    *((void *)this + 2) = v6;
  }
  *((_DWORD *)this + 50) = v22;
  return v21;
}

uint64_t llvm::object::MachORebaseBindEntry::readSLEB128(llvm::object::MachORebaseBindEntry *this, const char **a2)
{
  unint64_t v2 = (char *)*((void *)this + 15);
  uint64_t v3 = *((void *)this + 13);
  uint64_t v4 = (char *)(*((void *)this + 12) + v3);
  if (a2) {
    *a2 = 0;
  }
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  uint64_t v7 = v2;
  while (v7 != v4)
  {
    char v8 = *v7;
    uint64_t v9 = *v7 & 0x7F;
    if (v6 >= 0x40)
    {
      if (((v5 >> 63) & 0x7F) != v9) {
        goto LABEL_13;
      }
    }
    else if (v6 == 63 && (*v7 & 0x7F) != 0 && v9 != 127)
    {
LABEL_13:
      uint64_t v10 = 0;
      if (a2) {
        *a2 = "sleb128 too big for int64";
      }
LABEL_21:
      LODWORD(v4) = v7;
      goto LABEL_22;
    }
    v5 |= v9 << v6;
    v6 += 7;
    ++v7;
    if ((v8 & 0x80) == 0)
    {
      BOOL v11 = (v8 & 0x40) == 0 || v6 > 0x3F;
      uint64_t v12 = -1 << v6;
      if (v11) {
        uint64_t v12 = 0;
      }
      uint64_t v10 = v5 | v12;
      goto LABEL_21;
    }
  }
  uint64_t v10 = 0;
  if (a2) {
    *a2 = "malformed sleb128, extends past end";
  }
LABEL_22:
  unint64_t v13 = *((void *)this + 15) + (v4 - v2);
  unint64_t v14 = *((void *)this + 12) + v3;
  if (v13 <= v14) {
    unint64_t v14 = v13;
  }
  *((void *)this + 15) = v14;
  return v10;
}

const char *llvm::object::MachOChainedFixupEntry::typeName(llvm::object::MachOChainedFixupEntry *this)
{
  unint64_t v1 = "rebase aptr";
  if (!*((unsigned char *)this + 152)) {
    unint64_t v1 = "rebase ptr";
  }
  unint64_t v2 = "bind aptr";
  if (!*((unsigned char *)this + 152)) {
    unint64_t v2 = "bind ptr";
  }
  if (*((_DWORD *)this + 37) == 3) {
    return v1;
  }
  else {
    return v2;
  }
}

uint64_t llvm::object::MachOChainedFixupEntry::sectionName(llvm::object::MachOChainedFixupEntry *this)
{
  unint64_t v1 = *(uint64_t **)(*((void *)this + 1) + 264);
  uint64_t v2 = *v1;
  unsigned int v3 = *((_DWORD *)v1 + 2);
  if (v3)
  {
    unint64_t v4 = *((void *)this + 2);
    uint64_t v5 = v2 + 88 * v3;
    uint64_t v6 = 88 * v3;
    while (1)
    {
      if (*(_DWORD *)(v2 + 80) == *((_DWORD *)this + 6))
      {
        unint64_t v7 = *(void *)(v2 + 64);
        if (v7 <= v4 && *(void *)(v2 + 8) + v7 > v4) {
          break;
        }
      }
      v2 += 88;
      v6 -= 88;
      if (!v6)
      {
        uint64_t v2 = v5;
        return *(void *)(v2 + 32);
      }
    }
  }
  return *(void *)(v2 + 32);
}

const char *llvm::object::MachOChainedFixupEntry::authKeyName(llvm::object::MachOChainedFixupEntry *this)
{
  if (*((unsigned char *)this + 152)) {
    return (&off_1E684F5E8)[(*((void *)this + 9) >> 49) & 3];
  }
  else {
    return "(unknown)";
  }
}

char *llvm::object::MachORebaseBindEntry::typeName(llvm::object::MachORebaseBindEntry *this)
{
  if (*((_DWORD *)this + 37) == 3)
  {
    unsigned int v1 = *((unsigned __int8 *)this + 145) - 1;
    if (v1 >= 3) {
      return "unknown";
    }
  }
  else
  {
    unsigned int v1 = *((unsigned __int8 *)this + 146) - 1;
    if (v1 > 2) {
      return "unknown";
    }
  }
  return (&off_1E684F608)[(char)v1];
}

BOOL llvm::object::MachORebaseBindEntry::operator==(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 120) == *(void *)(a2 + 120)
      && *(void *)(a1 + 128) == *(void *)(a2 + 128)
      && *(unsigned __int8 *)(a1 + 80) == *(unsigned __int8 *)(a2 + 80);
}

void llvm::object::MachOObjectFile::rebaseTable(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, char a6@<W5>, uint64_t a7@<X8>)
{
  if (!*(void *)(a2 + 264)) {
    operator new();
  }
  llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry((uint64_t)&v58, a1, a2);
  *(void *)&long long v64 = a3;
  *((void *)&v64 + 1) = a4;
  if (a5) {
    char v14 = 8;
  }
  else {
    char v14 = 4;
  }
  long long v66 = 0u;
  LOBYTE(v67) = v14;
  *(_WORD *)((char *)&v67 + 1) = 0;
  DWORD1(v67) = 3;
  BYTE8(v67) = 0;
  BYTE9(v67) = a6;
  *(void *)&long long v59 = 0;
  *(_OWORD *)unint64_t v68 = 0u;
  memset(v69, 0, 28);
  DWORD2(v59) = -1;
  LOBYTE(v63) = 0;
  long long v61 = 0u;
  *((void *)&v65 + 1) = a3;
  llvm::object::MachORebaseBindEntry::moveNext((llvm::object::MachORebaseBindEntry *)&v58);
  llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry((uint64_t)v50, a1, a2);
  *(void *)&long long v52 = a3;
  *((void *)&v52 + 1) = a4;
  LOBYTE(v55) = v14;
  *(_WORD *)((char *)&v55 + 1) = 0;
  DWORD1(v55) = 3;
  BYTE8(v55) = 0;
  BYTE9(v55) = a6;
  *(_OWORD *)std::string __p = 0u;
  memset(v57, 0, 28);
  LOBYTE(v51) = 1;
  *((void *)&v53 + 1) = a3 + a4;
  long long v54 = 0u;
  long long v39 = v60;
  long long v40 = v61;
  long long v41 = v62;
  long long v42 = v63;
  long long v37 = v58;
  long long v38 = v59;
  long long v45 = v66;
  long long v46 = v67;
  long long v43 = v64;
  long long v44 = v65;
  __int16 v47 = v68[0];
  uint64_t v49 = 0;
  long long v48 = 0u;
  sub_1CCC68578(&v48, v68[1], *(uint64_t *)&v69[0], (uint64_t)(*(void *)&v69[0] - (unint64_t)v68[1]) >> 5);
  long long v15 = v40;
  *(_OWORD *)(a7 + 32) = v39;
  *(_OWORD *)(a7 + 4++*(_DWORD *)(this + 8) = v15;
  long long v16 = v42;
  *(_OWORD *)(a7 + 64) = v41;
  *(_OWORD *)(a7 + 80) = v16;
  long long v17 = v38;
  *(_OWORD *)a7 = v37;
  *(_OWORD *)(a7 + ++*(_DWORD *)(this + 16) = v17;
  long long v18 = v46;
  *(_OWORD *)(a7 + 12++*(_DWORD *)(this + 8) = v45;
  *(_OWORD *)(a7 + 144) = v18;
  uint64_t v19 = v49;
  *(void *)(a7 + 160) = v47;
  long long v20 = v44;
  *(_OWORD *)(a7 + 96) = v43;
  *(_OWORD *)(a7 + 112) = v20;
  *(void *)(a7 + 192) = *(void *)&v69[1];
  *(_DWORD *)(a7 + 200) = DWORD2(v69[1]);
  long long v26 = v50[2];
  long long v27 = v50[3];
  long long v28 = v50[4];
  long long v29 = v51;
  long long v24 = v50[0];
  long long v25 = v50[1];
  long long v32 = v54;
  long long v33 = v55;
  long long v30 = v52;
  long long v31 = v53;
  uint64_t v34 = __p[0];
  uint64_t v36 = 0;
  long long v35 = 0u;
  sub_1CCC68578(&v35, __p[1], *(uint64_t *)&v57[0], (uint64_t)(*(void *)&v57[0] - (unint64_t)__p[1]) >> 5);
  *(_OWORD *)(a7 + 240) = v26;
  *(_OWORD *)(a7 + 256) = v27;
  *(_OWORD *)(a7 + 272) = v28;
  *(_OWORD *)(a7 + 28++*(_DWORD *)(this + 8) = v29;
  *(_OWORD *)(a7 + 20++*(_DWORD *)(this + 8) = v24;
  *(_OWORD *)(a7 + 224) = v25;
  *(_OWORD *)(a7 + 336) = v32;
  *(_OWORD *)(a7 + 352) = v33;
  uint64_t v21 = v36;
  *(void *)(a7 + 36++*(_DWORD *)(this + 8) = v34;
  *(_OWORD *)(a7 + 304) = v30;
  *(_OWORD *)(a7 + 320) = v31;
  *(_DWORD *)(a7 + 40++*(_DWORD *)(this + 8) = DWORD2(v57[1]);
  *(_OWORD *)(a7 + 16++*(_DWORD *)(this + 8) = v48;
  *(void *)(a7 + 184) = v19;
  *(_OWORD *)(a7 + 376) = v35;
  uint64_t v22 = *(void *)&v57[1];
  uint64_t v23 = __p[1];
  *(void *)(a7 + 392) = v21;
  *(void *)(a7 + 400) = v22;
  if (v23)
  {
    *(void *)&v57[0] = v23;
    operator delete(v23);
  }
  if (v68[1])
  {
    *(void **)&v69[0] = v68[1];
    operator delete(v68[1]);
  }
}

void llvm::object::MachOObjectFile::rebaseTable(llvm::object::MachOObjectFile *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  llvm::object::MachOObjectFile::getDyldInfoRebaseOpcodes(a1);
  if (!v6 && *((_DWORD *)a1 + 13) == 16777228 && (*((_DWORD *)a1 + 14) & 0xFFFFFF) == 2)
  {
    uint64_t DyldInfoBindOpcodes = llvm::object::MachOObjectFile::getDyldInfoBindOpcodes(a1);
    uint64_t v9 = v8;
    BOOL v10 = (*((_DWORD *)a1 + 2) & 0xFFFFFFFE) == 18;
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    uint64_t v13 = (uint64_t)a1;
    char v14 = 1;
  }
  else
  {
    uint64_t DyldInfoBindOpcodes = llvm::object::MachOObjectFile::getDyldInfoRebaseOpcodes(a1);
    uint64_t v9 = v15;
    BOOL v10 = (*((_DWORD *)a1 + 2) & 0xFFFFFFFE) == 18;
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    uint64_t v13 = (uint64_t)a1;
    char v14 = 0;
  }

  llvm::object::MachOObjectFile::rebaseTable(v12, v13, DyldInfoBindOpcodes, v9, v10, v14, v11);
}

uint64_t llvm::object::MachOObjectFile::getDyldInfoRebaseOpcodes(llvm::object::MachOObjectFile *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = (int8x16_t *)*((void *)this + 38);
  if (!v1) {
    return 0;
  }
  sub_1CCC64EA4(&v4, (uint64_t)this, v1);
  if ((v5 & 1) == 0) {
    return *((void *)this + 2) + v4.u32[2];
  }
  uint64_t result = v4.i64[0];
  if (v4.i64[0])
  {
    (*(void (**)(uint64_t))(*(void *)v4.i64[0] + 8))(v4.i64[0]);
    return 0;
  }
  return result;
}

uint64_t llvm::object::MachOObjectFile::getDyldInfoBindOpcodes(llvm::object::MachOObjectFile *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = (int8x16_t *)*((void *)this + 38);
  if (!v1) {
    return 0;
  }
  sub_1CCC64EA4(&v4, (uint64_t)this, v1);
  if ((v6 & 1) == 0) {
    return *((void *)this + 2) + v5;
  }
  uint64_t result = v4.i64[0];
  if (v4.i64[0])
  {
    (*(void (**)(uint64_t))(*(void *)v4.i64[0] + 8))(v4.i64[0]);
    return 0;
  }
  return result;
}

double llvm::object::MachOBindEntry::MachOBindEntry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t v11 = llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry(a1, a2, a3);
  *(void *)(v11 + 96) = a4;
  *(void *)(v11 + 104) = a5;
  if (a6) {
    char v12 = 8;
  }
  else {
    char v12 = 4;
  }
  *(void *)(v11 + 12++*(_DWORD *)(this + 8) = 0;
  *(void *)(v11 + 136) = 0;
  *(void *)(v11 + 120) = a4;
  *(unsigned char *)(v11 + 144) = v12;
  *(_WORD *)(v11 + 145) = 0;
  *(_DWORD *)(v11 + 14++*(_DWORD *)(this + 8) = a7;
  *(_WORD *)(v11 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
  double result = 0.0;
  *(_OWORD *)(v11 + 160) = 0u;
  *(_OWORD *)(v11 + 176) = 0u;
  *(_OWORD *)(v11 + 18++*(_DWORD *)(this + 8) = 0u;
  return result;
}

{
  uint64_t v11;
  char v12;
  double result;

  uint64_t v11 = llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry(a1, a2, a3);
  *(void *)(v11 + 96) = a4;
  *(void *)(v11 + 104) = a5;
  if (a6) {
    char v12 = 8;
  }
  else {
    char v12 = 4;
  }
  *(void *)(v11 + 12++*(_DWORD *)(this + 8) = 0;
  *(void *)(v11 + 136) = 0;
  *(void *)(v11 + 120) = a4;
  *(unsigned char *)(v11 + 144) = v12;
  *(_WORD *)(v11 + 145) = 0;
  *(_DWORD *)(v11 + 14++*(_DWORD *)(this + 8) = a7;
  *(_WORD *)(v11 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = 0;
  double result = 0.0;
  *(_OWORD *)(v11 + 160) = 0u;
  *(_OWORD *)(v11 + 176) = 0u;
  *(_OWORD *)(v11 + 18++*(_DWORD *)(this + 8) = 0u;
  return result;
}

llvm::object::BindRebaseSegInfo *llvm::object::BindRebaseSegInfo::BindRebaseSegInfo(llvm::object::BindRebaseSegInfo *this, const llvm::object::MachOObjectFile *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  *(void *)this = (char *)this + 16;
  *((void *)this + 1) = 0x2000000000;
  int v4 = *((unsigned __int8 *)a2 + 344);
  uint64_t v5 = (*(uint64_t (**)(const llvm::object::MachOObjectFile *))(*(void *)a2 + 344))(a2);
  uint64_t v7 = v6;
  uint64_t v8 = (*(uint64_t (**)(const llvm::object::MachOObjectFile *))(*(void *)a2 + 352))(a2);
  uint64_t v38 = v5;
  uint64_t v39 = v7;
  uint64_t v29 = v8;
  if (v7 != v9 || v5 != v8)
  {
    uint64_t v11 = v9;
    uint64_t v12 = 0;
    size_t v13 = 0;
    char v14 = 0;
    do
    {
      long long v34 = 0u;
      long long v35 = 0u;
      long long v33 = 0u;
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v7 + 136))(&v40, v7, v5);
      if (v41)
      {
        long long v26 = (void *)v40;
        *(void *)&long long v40 = 0;
        long long v31 = v26;
        sub_1CD4515D0(&v31);
        if (v31) {
          (*(void (**)(void *))(*v31 + 8))(v31);
        }
      }
      else
      {
        long long v34 = v40;
      }
      *(void *)&long long v32 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v39 + 144))(v39, v38);
      *((void *)&v32 + 1) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v39 + 160))(v39, v38);
      (*(void (**)(long long *__return_ptr))(*(void *)v39 + 168))(&v42);
      if (v43)
      {
        uint64_t v30 = v42;
        llvm::report_fatal_error(&v30);
      }
      long long v33 = v42;
      uint64_t v15 = *(void *)(*((void *)a2 + 10) + 8 * v38);
      long long v16 = (const char *)(v15 + 16);
      if (*(unsigned char *)(v15 + 31)) {
        size_t v17 = 16;
      }
      else {
        size_t v17 = strlen(v16);
      }
      *(void *)&long long v35 = v16;
      *((void *)&v35 + 1) = v17;
      if (v17 != v13 || v13 && memcmp(v16, v14, v13))
      {
        ++v4;
        uint64_t v12 = v32;
        char v14 = v16;
        size_t v13 = v17;
      }
      LODWORD(v37) = v4 - 1;
      *(void *)&long long v36 = v32 - v12;
      *((void *)&v36 + 1) = v12;
      unsigned int v18 = *((_DWORD *)this + 2);
      unint64_t v19 = *(void *)this;
      if (v18 >= *((_DWORD *)this + 3))
      {
        BOOL v27 = v19 + 88 * v18 > (unint64_t)&v32;
        if (v19 > (unint64_t)&v32 || !v27) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v20 = v19 + 88 * *((unsigned int *)this + 2);
      long long v21 = v33;
      *(_OWORD *)uint64_t v20 = v32;
      *(_OWORD *)(v20 + ++*(_DWORD *)(this + 16) = v21;
      long long v22 = v34;
      long long v23 = v35;
      long long v24 = v36;
      *(void *)(v20 + 80) = v37;
      *(_OWORD *)(v20 + 4++*(_DWORD *)(this + 8) = v23;
      *(_OWORD *)(v20 + 64) = v24;
      *(_OWORD *)(v20 + 32) = v22;
      ++*((_DWORD *)this + 2);
      if (v41)
      {
        uint64_t v25 = v40;
        *(void *)&long long v40 = 0;
        if (v25) {
          (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
        }
      }
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v39 + 128))(v39, &v38);
      uint64_t v5 = v38;
      uint64_t v7 = v39;
    }
    while (v39 != v11 || v38 != v29);
  }
  *((_DWORD *)this + 70++*(_DWORD *)(this + 8) = v4;
  return this;
}

const char *llvm::object::BindRebaseSegInfo::checkSegAndOffsets(llvm::object::BindRebaseSegInfo *this, int a2, int a3, int a4, unsigned int a5, int a6)
{
  if (a2 == -1) {
    return "missing preceding *_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB";
  }
  if (*((_DWORD *)this + 708) <= a2) {
    return "bad segIndex (too large)";
  }
  if (!a5) {
    return 0;
  }
  unsigned int v6 = *((_DWORD *)this + 2);
  if (!v6) {
    return "bad offset, not in section";
  }
  uint64_t v7 = 0;
  uint64_t v8 = a5;
  uint64_t v9 = 88 * v6;
  uint64_t v10 = *(void *)this + 80;
  while (1)
  {
    unint64_t v11 = (a3 + (a4 + a6) * v7);
    uint64_t v12 = (_DWORD *)v10;
    uint64_t v13 = v9;
    while (1)
    {
      if (*v12 == a2)
      {
        unint64_t v14 = *((void *)v12 - 2);
        if (v14 <= v11)
        {
          unint64_t v15 = *((void *)v12 - 9) + v14;
          if (v15 > v11) {
            break;
          }
        }
      }
      v12 += 22;
      v13 -= 88;
      if (!v13) {
        return "bad offset, not in section";
      }
    }
    if (v15 < (v11 + a4)) {
      break;
    }
    double result = 0;
    if (++v7 == v8) {
      return result;
    }
  }
  return "bad offset, extends beyond section boundary";
}

_DWORD *llvm::object::BindRebaseSegInfo::segmentName(_DWORD *this, int a2)
{
  unsigned int v2 = this[2];
  if (v2)
  {
    unsigned int v3 = (_DWORD *)(*(void *)this + 80);
    uint64_t v4 = 88 * v2;
    while (*v3 != a2)
    {
      v3 += 22;
      v4 -= 88;
      if (!v4) {
        return this;
      }
    }
    return (_DWORD *)*((void *)v3 - 4);
  }
  return this;
}

uint64_t llvm::object::BindRebaseSegInfo::findSection(llvm::object::BindRebaseSegInfo *this, int a2, unint64_t a3)
{
  uint64_t result = *(void *)this;
  unsigned int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    uint64_t v6 = result + 88 * v5;
    uint64_t v7 = 88 * v5;
    while (1)
    {
      if (*(_DWORD *)(result + 80) == a2)
      {
        unint64_t v8 = *(void *)(result + 64);
        if (v8 <= a3 && *(void *)(result + 8) + v8 > a3) {
          break;
        }
      }
      result += 88;
      v7 -= 88;
      if (!v7) {
        return v6;
      }
    }
  }
  return result;
}

uint64_t llvm::object::BindRebaseSegInfo::sectionName(llvm::object::BindRebaseSegInfo *this, int a2, unint64_t a3)
{
  uint64_t v3 = *(void *)this;
  unsigned int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    uint64_t v5 = v3 + 88 * v4;
    uint64_t v6 = 88 * v4;
    while (1)
    {
      if (*(_DWORD *)(v3 + 80) == a2)
      {
        unint64_t v7 = *(void *)(v3 + 64);
        if (v7 <= a3 && *(void *)(v3 + 8) + v7 > a3) {
          break;
        }
      }
      v3 += 88;
      v6 -= 88;
      if (!v6)
      {
        uint64_t v3 = v5;
        return *(void *)(v3 + 32);
      }
    }
  }
  return *(void *)(v3 + 32);
}

unint64_t llvm::object::BindRebaseSegInfo::address(llvm::object::BindRebaseSegInfo *this, int a2, unint64_t a3)
{
  uint64_t v3 = *(void *)this;
  unsigned int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    uint64_t v5 = v3 + 88 * v4;
    uint64_t v6 = 88 * v4;
    while (1)
    {
      if (*(_DWORD *)(v3 + 80) == a2)
      {
        unint64_t v7 = *(void *)(v3 + 64);
        if (v7 <= a3 && *(void *)(v3 + 8) + v7 > a3) {
          break;
        }
      }
      v3 += 88;
      v6 -= 88;
      if (!v6)
      {
        uint64_t v3 = v5;
        return *(void *)(v3 + 72) + a3;
      }
    }
  }
  return *(void *)(v3 + 72) + a3;
}

uint64_t llvm::object::BindRebaseSegInfo::contents(llvm::object::BindRebaseSegInfo *this, int a2, unint64_t a3)
{
  uint64_t v3 = *(void *)this;
  unsigned int v4 = *((_DWORD *)this + 2);
  if (v4)
  {
    uint64_t v5 = v3 + 88 * v4;
    uint64_t v6 = 88 * v4;
    while (1)
    {
      if (*(_DWORD *)(v3 + 80) == a2)
      {
        unint64_t v7 = *(void *)(v3 + 64);
        if (v7 <= a3 && *(void *)(v3 + 8) + v7 > a3) {
          break;
        }
      }
      v3 += 88;
      v6 -= 88;
      if (!v6)
      {
        uint64_t v3 = v5;
        break;
      }
    }
  }
  unint64_t v8 = a3 - *(void *)(v3 + 64);
  uint64_t v9 = *(void *)(v3 + 16);
  unint64_t v10 = *(void *)(v3 + 24);
  if (v10 < v8) {
    unint64_t v8 = v10;
  }
  return v9 + v8;
}

void llvm::object::MachOObjectFile::bindTable(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, int a6@<W5>, uint64_t a7@<X8>)
{
  if (!*(void *)(a2 + 264)) {
    operator new();
  }
  llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry((uint64_t)&v58, a1, a2);
  *(void *)&long long v64 = a3;
  *((void *)&v64 + 1) = a4;
  if (a5) {
    char v14 = 8;
  }
  else {
    char v14 = 4;
  }
  long long v66 = 0u;
  LOBYTE(v67) = v14;
  *(_WORD *)((char *)&v67 + 1) = 0;
  DWORD1(v67) = a6;
  WORD4(v67) = 0;
  *(void *)&long long v59 = 0;
  *(_OWORD *)unint64_t v68 = 0u;
  memset(v69, 0, 28);
  DWORD2(v59) = -1;
  LOBYTE(v63) = 0;
  long long v61 = 0u;
  *((void *)&v65 + 1) = a3;
  llvm::object::MachORebaseBindEntry::moveNext((llvm::object::MachORebaseBindEntry *)&v58);
  llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry((uint64_t)v50, a1, a2);
  *(void *)&long long v52 = a3;
  *((void *)&v52 + 1) = a4;
  LOBYTE(v55) = v14;
  *(_WORD *)((char *)&v55 + 1) = 0;
  DWORD1(v55) = a6;
  WORD4(v55) = 0;
  *(_OWORD *)std::string __p = 0u;
  memset(v57, 0, 28);
  LOBYTE(v51) = 1;
  *((void *)&v53 + 1) = a3 + a4;
  long long v54 = 0u;
  long long v39 = v60;
  long long v40 = v61;
  long long v41 = v62;
  long long v42 = v63;
  long long v37 = v58;
  long long v38 = v59;
  long long v45 = v66;
  long long v46 = v67;
  long long v43 = v64;
  long long v44 = v65;
  __int16 v47 = v68[0];
  uint64_t v49 = 0;
  long long v48 = 0u;
  sub_1CCC68578(&v48, v68[1], *(uint64_t *)&v69[0], (uint64_t)(*(void *)&v69[0] - (unint64_t)v68[1]) >> 5);
  long long v15 = v40;
  *(_OWORD *)(a7 + 32) = v39;
  *(_OWORD *)(a7 + 4++*(_DWORD *)(this + 8) = v15;
  long long v16 = v42;
  *(_OWORD *)(a7 + 64) = v41;
  *(_OWORD *)(a7 + 80) = v16;
  long long v17 = v38;
  *(_OWORD *)a7 = v37;
  *(_OWORD *)(a7 + ++*(_DWORD *)(this + 16) = v17;
  long long v18 = v46;
  *(_OWORD *)(a7 + 12++*(_DWORD *)(this + 8) = v45;
  *(_OWORD *)(a7 + 144) = v18;
  uint64_t v19 = v49;
  *(void *)(a7 + 160) = v47;
  long long v20 = v44;
  *(_OWORD *)(a7 + 96) = v43;
  *(_OWORD *)(a7 + 112) = v20;
  *(void *)(a7 + 192) = *(void *)&v69[1];
  *(_DWORD *)(a7 + 200) = DWORD2(v69[1]);
  long long v26 = v50[2];
  long long v27 = v50[3];
  long long v28 = v50[4];
  long long v29 = v51;
  long long v24 = v50[0];
  long long v25 = v50[1];
  long long v32 = v54;
  long long v33 = v55;
  long long v30 = v52;
  long long v31 = v53;
  long long v34 = __p[0];
  uint64_t v36 = 0;
  long long v35 = 0u;
  sub_1CCC68578(&v35, __p[1], *(uint64_t *)&v57[0], (uint64_t)(*(void *)&v57[0] - (unint64_t)__p[1]) >> 5);
  *(_OWORD *)(a7 + 240) = v26;
  *(_OWORD *)(a7 + 256) = v27;
  *(_OWORD *)(a7 + 272) = v28;
  *(_OWORD *)(a7 + 28++*(_DWORD *)(this + 8) = v29;
  *(_OWORD *)(a7 + 20++*(_DWORD *)(this + 8) = v24;
  *(_OWORD *)(a7 + 224) = v25;
  *(_OWORD *)(a7 + 336) = v32;
  *(_OWORD *)(a7 + 352) = v33;
  uint64_t v21 = v36;
  *(void *)(a7 + 36++*(_DWORD *)(this + 8) = v34;
  *(_OWORD *)(a7 + 304) = v30;
  *(_OWORD *)(a7 + 320) = v31;
  *(_DWORD *)(a7 + 40++*(_DWORD *)(this + 8) = DWORD2(v57[1]);
  *(_OWORD *)(a7 + 16++*(_DWORD *)(this + 8) = v48;
  *(void *)(a7 + 184) = v19;
  *(_OWORD *)(a7 + 376) = v35;
  uint64_t v22 = *(void *)&v57[1];
  long long v23 = __p[1];
  *(void *)(a7 + 392) = v21;
  *(void *)(a7 + 400) = v22;
  if (v23)
  {
    *(void *)&v57[0] = v23;
    operator delete(v23);
  }
  if (v68[1])
  {
    *(void **)&v69[0] = v68[1];
    operator delete(v68[1]);
  }
}

void llvm::object::MachOObjectFile::bindTable(llvm::object::MachOObjectFile *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t DyldInfoBindOpcodes = llvm::object::MachOObjectFile::getDyldInfoBindOpcodes(a1);
  BOOL v8 = (*((_DWORD *)a1 + 2) & 0xFFFFFFFE) == 18;

  llvm::object::MachOObjectFile::bindTable(a2, (uint64_t)a1, DyldInfoBindOpcodes, v6, v8, 0, a3);
}

void llvm::object::MachOObjectFile::lazyBindTable(llvm::object::MachOObjectFile *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t DyldInfoLazyBindOpcodes = llvm::object::MachOObjectFile::getDyldInfoLazyBindOpcodes(a1);
  BOOL v8 = (*((_DWORD *)a1 + 2) & 0xFFFFFFFE) == 18;

  llvm::object::MachOObjectFile::bindTable(a2, (uint64_t)a1, DyldInfoLazyBindOpcodes, v6, v8, 1, a3);
}

uint64_t llvm::object::MachOObjectFile::getDyldInfoLazyBindOpcodes(llvm::object::MachOObjectFile *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = (int8x16_t *)*((void *)this + 38);
  if (!v1) {
    return 0;
  }
  sub_1CCC64EA4(v4, (uint64_t)this, v1);
  if ((v6 & 1) == 0) {
    return *((void *)this + 2) + v5;
  }
  uint64_t result = v4[0].i64[0];
  if (v4[0].i64[0])
  {
    (*(void (**)(uint64_t))(*(void *)v4[0].i64[0] + 8))(v4[0].i64[0]);
    return 0;
  }
  return result;
}

void llvm::object::MachOObjectFile::weakBindTable(llvm::object::MachOObjectFile *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t DyldInfoWeakBindOpcodes = llvm::object::MachOObjectFile::getDyldInfoWeakBindOpcodes(a1);
  BOOL v8 = (*((_DWORD *)a1 + 2) & 0xFFFFFFFE) == 18;

  llvm::object::MachOObjectFile::bindTable(a2, (uint64_t)a1, DyldInfoWeakBindOpcodes, v6, v8, 2, a3);
}

uint64_t llvm::object::MachOObjectFile::getDyldInfoWeakBindOpcodes(llvm::object::MachOObjectFile *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = (int8x16_t *)*((void *)this + 38);
  if (!v1) {
    return 0;
  }
  sub_1CCC64EA4(&v4, (uint64_t)this, v1);
  if ((v6 & 1) == 0) {
    return *((void *)this + 2) + v5;
  }
  uint64_t result = v4.i64[0];
  if (v4.i64[0])
  {
    (*(void (**)(uint64_t))(*(void *)v4.i64[0] + 8))(v4.i64[0]);
    return 0;
  }
  return result;
}

void llvm::object::MachOObjectFile::fixupTable(llvm::object::MachOObjectFile *a1@<X0>, long long **a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (!*((void *)a1 + 33)) {
    operator new();
  }
  llvm::object::MachOChainedFixupEntry::MachOChainedFixupEntry((uint64_t)&v75, a2, a1, a3, 1);
  *(void *)&long long v76 = 0;
  DWORD2(v76) = -1;
  LOBYTE(v80) = 0;
  LODWORD(v85) = 0;
  long long v78 = 0uLL;
  llvm::object::MachOChainedFixupEntry::moveNext((const char *)&v75);
  llvm::object::MachOAbstractFixupEntry::MachOAbstractFixupEntry((uint64_t)v68, (uint64_t)a2, (uint64_t)a1);
  long long v71 = 0u;
  long long v72 = 0u;
  *(_OWORD *)uint64_t v70 = 0u;
  LODWORD(v73) = 0;
  HIDWORD(v73) = a3;
  if (!*a2) {
    *a2 = 0;
  }
  LOBYTE(v69) = 1;
  long long v48 = v77;
  long long v49 = v78;
  long long v50 = v79;
  long long v51 = v80;
  long long v46 = v75;
  long long v47 = v76;
  long long v53 = 0uLL;
  long long v52 = 0;
  sub_1CCC685FC(&v52, v81, (uint64_t)v82, 0xCCCCCCCCCCCCCCCDLL * ((v82 - (unsigned char *)v81) >> 3));
  long long v54 = 0uLL;
  uint64_t v55 = 0;
  sub_1CCC6868C(&v54, v83, v84, 0x6DB6DB6DB6DB6DB7 * (((char *)v84 - (char *)v83) >> 3));
  uint64_t v56 = v85;
  char v57 = v86;
  long long v60 = v48;
  long long v61 = v49;
  long long v62 = v50;
  long long v63 = v51;
  long long v58 = v46;
  long long v59 = v47;
  BOOL v8 = v52;
  uint64_t v9 = v55;
  v64[0] = v52;
  long long v22 = v53;
  v64[1] = (void *)v53;
  long long v52 = 0;
  long long v53 = 0uLL;
  long long v23 = v54;
  uint64_t v55 = 0;
  long long v54 = 0uLL;
  char v67 = v86;
  uint64_t v66 = v85;
  long long v24 = v68[0];
  long long v25 = v68[1];
  long long v28 = v68[4];
  long long v29 = v69;
  long long v26 = v68[2];
  long long v27 = v68[3];
  v30[0] = 0;
  v30[1] = 0;
  uint64_t v31 = 0;
  sub_1CCC685FC(v30, v70[0], (uint64_t)v70[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)v70[1] - (char *)v70[0]) >> 3));
  long long v32 = 0uLL;
  uint64_t v33 = 0;
  sub_1CCC6868C(&v32, *((long long **)&v71 + 1), (long long *)v72, 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v72 - *((void *)&v71 + 1)) >> 3));
  long long v38 = v26;
  long long v39 = v27;
  long long v40 = v28;
  long long v41 = v29;
  long long v36 = v24;
  long long v37 = v25;
  long long v10 = v60;
  long long v11 = v61;
  void v98[2] = v60;
  v98[3] = v61;
  long long v12 = v62;
  long long v13 = v63;
  v98[4] = v62;
  v98[5] = v63;
  long long v14 = v59;
  v98[0] = v58;
  v98[1] = v59;
  long long v87 = v24;
  long long v88 = v25;
  long long v92 = v29;
  long long v91 = v28;
  long long v90 = v27;
  long long v89 = v26;
  memset(v65, 0, sizeof(v65));
  *(_OWORD *)long long v64 = 0u;
  memset(v43, 0, sizeof(v43));
  *(_OWORD *)long long v42 = 0u;
  *(_OWORD *)a4 = v58;
  *(_OWORD *)(a4 + ++*(_DWORD *)(this + 16) = v14;
  *(_OWORD *)(a4 + 64) = v12;
  *(_OWORD *)(a4 + 80) = v13;
  uint64_t v15 = v73;
  uint64_t v34 = v73;
  char v35 = v74;
  uint64_t v16 = v31;
  *(_OWORD *)(a4 + 32) = v10;
  *(_OWORD *)(a4 + 4++*(_DWORD *)(this + 8) = v11;
  long long v17 = *(_OWORD *)v30;
  v30[0] = 0;
  v30[1] = 0;
  char v45 = v74;
  uint64_t v44 = v15;
  char v103 = v67;
  uint64_t v18 = v66;
  v102[3] = v66;
  char v97 = v74;
  uint64_t v19 = v73;
  v96[3] = v73;
  uint64_t v20 = v33;
  *(_OWORD *)(a4 + 104) = v22;
  long long v21 = v32;
  uint64_t v31 = 0;
  long long v32 = 0uLL;
  uint64_t v33 = 0;
  *(void *)(a4 + 96) = v8;
  uint64_t v100 = 0;
  uint64_t v99 = 0;
  *(_OWORD *)(a4 + 120) = v23;
  uint64_t v101 = 0;
  memset(v102, 0, 24);
  *(unsigned char *)(a4 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = v67;
  *(void *)(a4 + 136) = v9;
  *(void *)(a4 + 144) = v18;
  *(_OWORD *)(a4 + 160) = v24;
  *(_OWORD *)(a4 + 176) = v25;
  *(_OWORD *)(a4 + 224) = v28;
  *(_OWORD *)(a4 + 240) = v29;
  *(_OWORD *)(a4 + 192) = v26;
  *(_OWORD *)(a4 + 20++*(_DWORD *)(this + 8) = v27;
  *(_OWORD *)(a4 + 256) = v17;
  *(void *)(a4 + 272) = v16;
  unsigned int v94 = 0;
  std::string __p = 0;
  *(_OWORD *)(a4 + 280) = v21;
  uint64_t v95 = 0;
  memset(v96, 0, 24);
  *(unsigned char *)(a4 + 312) = v74;
  *(void *)(a4 + 296) = v20;
  *(void *)(a4 + 304) = v19;
  v104[0] = (void **)v96;
  sub_1CCC6FD8C(v104);
  if (__p)
  {
    unsigned int v94 = __p;
    operator delete(__p);
  }
  v104[0] = (void **)v102;
  sub_1CCC6FD8C(v104);
  if (v99)
  {
    uint64_t v100 = v99;
    operator delete(v99);
  }
  *(void *)&v98[0] = (char *)v43 + 8;
  sub_1CCC6FD8C((void ***)v98);
  if (v42[0])
  {
    v42[1] = v42[0];
    operator delete(v42[0]);
  }
  *(void *)&v98[0] = &v32;
  sub_1CCC6FD8C((void ***)v98);
  if (v30[0])
  {
    v30[1] = v30[0];
    operator delete(v30[0]);
  }
  *(void *)&v98[0] = (char *)v65 + 8;
  sub_1CCC6FD8C((void ***)v98);
  if (v64[0])
  {
    v64[1] = v64[0];
    operator delete(v64[0]);
  }
  *(void *)&v98[0] = &v54;
  sub_1CCC6FD8C((void ***)v98);
  if (v52)
  {
    *(void *)&long long v53 = v52;
    operator delete(v52);
  }
  *(void *)&v98[0] = (char *)&v71 + 8;
  sub_1CCC6FD8C((void ***)v98);
  if (v70[0])
  {
    v70[1] = v70[0];
    operator delete(v70[0]);
  }
  *(void *)&v98[0] = &v83;
  sub_1CCC6FD8C((void ***)v98);
  if (v81)
  {
    unsigned int v82 = v81;
    operator delete(v81);
  }
}

BOOL llvm::object::MachOObjectFile::containsAIRBuildTables(llvm::object::MachOObjectFile *this)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 16);
  uint64_t v3 = *((unsigned int *)this + 34);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 16 * v3;
    while (1)
    {
      if (*(_DWORD *)(v2 + 8) == 49)
      {
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)this, (unint64_t *)v2, (uint64_t)&v18);
        switch(strlen((const char *)&v19))
        {
          case 0xAuLL:
            if ((void)v19 == 0x55444F4D5F524941 && WORD4(v19) == 17740) {
              return v2 != *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
            }
            if ((void)v19 == 0x454A424F5F524941 && WORD4(v19) == 21571) {
              return v2 != *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
            }
            int v8 = WORD4(v19);
            BOOL v9 = (void)v19 == 0x485341485F524941;
            int v10 = 21317;
            break;
          case 0xCuLL:
            if ((void)v19 == 0x4154454D5F524941 && DWORD2(v19) == 1112099916) {
              return v2 != *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
            }
            if ((void)v19 == 0x455049505F524941 && DWORD2(v19) == 1162758476) {
              return v2 != *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
            }
            int v8 = DWORD2(v19);
            BOOL v9 = (void)v19 == 0x545254535F524941;
            int v10 = 1162625601;
            break;
          case 0xEuLL:
            if (((void)v19 != 0x444145485F524941 || *(void *)((char *)&v19 + 6) != 0x5458455F52454441)
              && ((void)v19 != 0x435345445F524941 || *(void *)((char *)&v19 + 6) != 0x524F545049524353))
            {
              goto LABEL_43;
            }
            return v2 != *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
          case 0x10uLL:
            if ((void)v19 != 0x454A424F5F524941 || *((void *)&v19 + 1) != 0x5845444E495F5443) {
              goto LABEL_43;
            }
            return v2 != *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
          default:
            goto LABEL_43;
        }
        if (v9 && v8 == v10) {
          break;
        }
      }
LABEL_43:
      v2 += 16;
      v4 -= 16;
      if (!v4)
      {
        uint64_t v2 = v5;
        return v2 != *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
      }
    }
  }
  return v2 != *((void *)this + 16) + 16 * *((unsigned int *)this + 34);
}

void llvm::object::MachOObjectFile::getAIRMetalLibNote(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    char v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v23 = 0;
        long long v21 = 0u;
        long long v22 = 0u;
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)&v21);
        if (!BYTE7(v22))
        {
          this = (unint64_t **)strlen((const char *)&v21 + 8);
          if (this == (unint64_t **)12
            && *((void *)&v21 + 1) == 0x4154454D5F524941
            && v22 == 1112099916)
          {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v4 = v6;
        break;
      }
    }
    BOOL v9 = v4;
    uint64_t v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v25.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v25, (void *)a2);
    *(unsigned char *)(a2 + 16) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v19);
    if (v20 < 0
      || (uint64_t v11 = *((void *)v2 + 2), v12 = v11 + v20, v11 + v20 + 16 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&long long v21 = "Structure read out-of-range";
      LOWORD(v23) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)&v21);
    }
    unint64_t v13 = *(void *)v12;
    unsigned int v15 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    unsigned int v16 = *((_DWORD *)v2 + 2);
    unint64_t v17 = bswap64(v13);
    unsigned int v18 = bswap32(v15);
    if (((1 << v16) & 0xAAC00) == 0)
    {
      unsigned int v18 = v15;
      unint64_t v17 = v13;
    }
    if (v16 <= 0x13) {
      unsigned int v15 = v18;
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    if (v16 <= 0x13) {
      unint64_t v13 = v17;
    }
    *(void *)a2 = v13;
    *(_DWORD *)(a2 + ++*(_DWORD *)(this + 8) = v15;
    *(_DWORD *)(a2 + 12) = v14;
  }
}

void llvm::object::MachOObjectFile::getAIRModuleNote(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    char v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v23 = 0;
        long long v21 = 0u;
        long long v22 = 0u;
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)&v21);
        if (!BYTE7(v22))
        {
          this = (unint64_t **)strlen((const char *)&v21 + 8);
          if (this == (unint64_t **)10
            && *((void *)&v21 + 1) == 0x55444F4D5F524941
            && (unsigned __int16)v22 == 17740)
          {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v4 = v6;
        break;
      }
    }
    BOOL v9 = v4;
    uint64_t v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v25.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v25, (void *)a2);
    *(unsigned char *)(a2 + 16) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v19);
    if (v20 < 0
      || (uint64_t v11 = *((void *)v2 + 2), v12 = v11 + v20, v11 + v20 + 16 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&long long v21 = "Structure read out-of-range";
      LOWORD(v23) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)&v21);
    }
    unint64_t v13 = *(void *)v12;
    unsigned int v15 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    unsigned int v16 = *((_DWORD *)v2 + 2);
    unint64_t v17 = bswap64(v13);
    unsigned int v18 = bswap32(v15);
    if (((1 << v16) & 0xAAC00) == 0)
    {
      unsigned int v18 = v15;
      unint64_t v17 = v13;
    }
    if (v16 <= 0x13) {
      unsigned int v15 = v18;
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    if (v16 <= 0x13) {
      unint64_t v13 = v17;
    }
    *(void *)a2 = v13;
    *(_DWORD *)(a2 + ++*(_DWORD *)(this + 8) = v15;
    *(_DWORD *)(a2 + 12) = v14;
  }
}

void llvm::object::MachOObjectFile::getAIRDescriptorNote(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    char v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v22 = 0;
        memset(v21, 0, sizeof(v21));
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)v21);
        if (!BYTE7(v21[1]))
        {
          this = (unint64_t **)strlen((const char *)v21 + 8);
          if (this == (unint64_t **)14
            && *((void *)&v21[0] + 1) == 0x435345445F524941
            && *(void *)((char *)v21 + 14) == 0x524F545049524353)
          {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v4 = v6;
        break;
      }
    }
    BOOL v9 = v4;
    uint64_t v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v24.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v24, (void *)a2);
    *(unsigned char *)(a2 + 16) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v19);
    if (v20 < 0
      || (uint64_t v11 = *((void *)v2 + 2), v12 = v11 + v20, v11 + v20 + 16 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&v21[0] = "Structure read out-of-range";
      LOWORD(v22) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)v21);
    }
    unint64_t v13 = *(void *)v12;
    unsigned int v15 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    unsigned int v16 = *((_DWORD *)v2 + 2);
    unint64_t v17 = bswap64(v13);
    unsigned int v18 = bswap32(v15);
    if (((1 << v16) & 0xAAC00) == 0)
    {
      unsigned int v18 = v15;
      unint64_t v17 = v13;
    }
    if (v16 <= 0x13) {
      unsigned int v15 = v18;
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    if (v16 <= 0x13) {
      unint64_t v13 = v17;
    }
    *(void *)a2 = v13;
    *(_DWORD *)(a2 + ++*(_DWORD *)(this + 8) = v15;
    *(_DWORD *)(a2 + 12) = v14;
  }
}

void llvm::object::MachOObjectFile::getAIRObjectNote(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    char v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v23 = 0;
        long long v21 = 0u;
        long long v22 = 0u;
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)&v21);
        if (!BYTE7(v22))
        {
          this = (unint64_t **)strlen((const char *)&v21 + 8);
          if (this == (unint64_t **)10
            && *((void *)&v21 + 1) == 0x454A424F5F524941
            && (unsigned __int16)v22 == 21571)
          {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v4 = v6;
        break;
      }
    }
    BOOL v9 = v4;
    uint64_t v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v25.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v25, (void *)a2);
    *(unsigned char *)(a2 + 16) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v19);
    if (v20 < 0
      || (uint64_t v11 = *((void *)v2 + 2), v12 = v11 + v20, v11 + v20 + 16 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&long long v21 = "Structure read out-of-range";
      LOWORD(v23) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)&v21);
    }
    unint64_t v13 = *(void *)v12;
    unsigned int v15 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    unsigned int v16 = *((_DWORD *)v2 + 2);
    unint64_t v17 = bswap64(v13);
    unsigned int v18 = bswap32(v15);
    if (((1 << v16) & 0xAAC00) == 0)
    {
      unsigned int v18 = v15;
      unint64_t v17 = v13;
    }
    if (v16 <= 0x13) {
      unsigned int v15 = v18;
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    if (v16 <= 0x13) {
      unint64_t v13 = v17;
    }
    *(void *)a2 = v13;
    *(_DWORD *)(a2 + ++*(_DWORD *)(this + 8) = v15;
    *(_DWORD *)(a2 + 12) = v14;
  }
}

void llvm::object::MachOObjectFile::getAIRObjectIndexNote(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    char v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v23 = 0;
        long long v21 = 0u;
        long long v22 = 0u;
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)&v21);
        if (BYTE7(v22) || (this = (unint64_t **)strlen((const char *)&v21 + 8), this == (unint64_t **)16))
        {
          if (*((void *)&v21 + 1) == 0x454A424F5F524941 && (void)v22 == 0x5845444E495F5443) {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v4 = v6;
        break;
      }
    }
    BOOL v9 = v4;
    uint64_t v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v25.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v25, (void *)a2);
    *(unsigned char *)(a2 + 16) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v19);
    if (v20 < 0
      || (uint64_t v11 = *((void *)v2 + 2), v12 = v11 + v20, v11 + v20 + 16 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&long long v21 = "Structure read out-of-range";
      LOWORD(v23) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)&v21);
    }
    unint64_t v13 = *(void *)v12;
    unsigned int v15 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    unsigned int v16 = *((_DWORD *)v2 + 2);
    unint64_t v17 = bswap64(v13);
    unsigned int v18 = bswap32(v15);
    if (((1 << v16) & 0xAAC00) == 0)
    {
      unsigned int v18 = v15;
      unint64_t v17 = v13;
    }
    if (v16 <= 0x13) {
      unsigned int v15 = v18;
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    if (v16 <= 0x13) {
      unint64_t v13 = v17;
    }
    *(void *)a2 = v13;
    *(_DWORD *)(a2 + ++*(_DWORD *)(this + 8) = v15;
    *(_DWORD *)(a2 + 12) = v14;
  }
}

void llvm::object::MachOObjectFile::getAIRPipelineNote(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    char v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v23 = 0;
        long long v21 = 0u;
        long long v22 = 0u;
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)&v21);
        if (!BYTE7(v22))
        {
          this = (unint64_t **)strlen((const char *)&v21 + 8);
          if (this == (unint64_t **)12
            && *((void *)&v21 + 1) == 0x455049505F524941
            && v22 == 1162758476)
          {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v4 = v6;
        break;
      }
    }
    BOOL v9 = v4;
    uint64_t v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v25.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v25, (void *)a2);
    *(unsigned char *)(a2 + 16) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v19);
    if (v20 < 0
      || (uint64_t v11 = *((void *)v2 + 2), v12 = v11 + v20, v11 + v20 + 16 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&long long v21 = "Structure read out-of-range";
      LOWORD(v23) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)&v21);
    }
    unint64_t v13 = *(void *)v12;
    unsigned int v15 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    unsigned int v16 = *((_DWORD *)v2 + 2);
    unint64_t v17 = bswap64(v13);
    unsigned int v18 = bswap32(v15);
    if (((1 << v16) & 0xAAC00) == 0)
    {
      unsigned int v18 = v15;
      unint64_t v17 = v13;
    }
    if (v16 <= 0x13) {
      unsigned int v15 = v18;
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    if (v16 <= 0x13) {
      unint64_t v13 = v17;
    }
    *(void *)a2 = v13;
    *(_DWORD *)(a2 + ++*(_DWORD *)(this + 8) = v15;
    *(_DWORD *)(a2 + 12) = v14;
  }
}

void llvm::object::MachOObjectFile::getAIRHashesNote(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    char v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v23 = 0;
        long long v21 = 0u;
        long long v22 = 0u;
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)&v21);
        if (!BYTE7(v22))
        {
          this = (unint64_t **)strlen((const char *)&v21 + 8);
          if (this == (unint64_t **)10
            && *((void *)&v21 + 1) == 0x485341485F524941
            && (unsigned __int16)v22 == 21317)
          {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v4 = v6;
        break;
      }
    }
    BOOL v9 = v4;
    uint64_t v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v25.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v25, (void *)a2);
    *(unsigned char *)(a2 + 16) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v19);
    if (v20 < 0
      || (uint64_t v11 = *((void *)v2 + 2), v12 = v11 + v20, v11 + v20 + 16 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&long long v21 = "Structure read out-of-range";
      LOWORD(v23) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)&v21);
    }
    unint64_t v13 = *(void *)v12;
    unsigned int v15 = *(_DWORD *)(v12 + 8);
    int v14 = *(_DWORD *)(v12 + 12);
    unsigned int v16 = *((_DWORD *)v2 + 2);
    unint64_t v17 = bswap64(v13);
    unsigned int v18 = bswap32(v15);
    if (((1 << v16) & 0xAAC00) == 0)
    {
      unsigned int v18 = v15;
      unint64_t v17 = v13;
    }
    if (v16 <= 0x13) {
      unsigned int v15 = v18;
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    if (v16 <= 0x13) {
      unint64_t v13 = v17;
    }
    *(void *)a2 = v13;
    *(_DWORD *)(a2 + ++*(_DWORD *)(this + 8) = v15;
    *(_DWORD *)(a2 + 12) = v14;
  }
}

void llvm::object::MachOObjectFile::getAIRStringTableNote(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    char v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v18 = 0;
        long long v16 = 0u;
        long long v17 = 0u;
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)&v16);
        if (!BYTE7(v17))
        {
          this = (unint64_t **)strlen((const char *)&v16 + 8);
          if (this == (unint64_t **)12
            && *((void *)&v16 + 1) == 0x545254535F524941
            && v17 == 1162625601)
          {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        uint64_t v4 = v6;
        break;
      }
    }
    BOOL v9 = v4;
    uint64_t v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    BOOL v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v20.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v20, (void *)a2);
    *(unsigned char *)(a2 + 16) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v14);
    if (v15 < 0 || (uint64_t v11 = *((void *)v2 + 2), v11 + v15 + 16 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&long long v16 = "Structure read out-of-range";
      LOWORD(v1++*(_DWORD *)(this + 8) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)&v16);
    }
    int8x16_t v12 = *(int8x16_t *)(v11 + v15);
    unsigned int v13 = *((_DWORD *)v2 + 2);
    if (v13 <= 0x13 && ((1 << v13) & 0xAAC00) != 0) {
      int8x16_t v12 = vrev64q_s8(v12);
    }
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(int8x16_t *)a2 = v12;
  }
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_metallib>::AIRBuildTableEntry(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 64) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 72) = a6;
  return result;
}

{
  *(void *)uint64_t result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 64) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 72) = a6;
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_metallib>::moveNext(uint64_t result, unsigned int a2)
{
  uint64_t v2 = *(void *)(result + 8) + 40 * a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = v2;
  unsigned int v3 = *(_DWORD *)(result + 20);
  unsigned int v4 = *(_DWORD *)(result + 16) + a2;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = v4;
  if (v4 < v3)
  {
    if (v2 < 0
      || (uint64_t v5 = *(void *)(*(void *)result + 16),
          uint64_t v6 = v5 + v2,
          v6 + 40 > (unint64_t)(v5 + *(void *)(*(void *)result + 24))))
    {
      llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
    }
    unint64_t v7 = *(void *)(v6 + 16);
    unint64_t v8 = *(void *)(v6 + 24);
    double v9 = *(double *)(v6 + 32);
    unsigned int v10 = *(_DWORD *)(*(void *)result + 8);
    double v11 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)&v9));
    unsigned int v12 = bswap32(v7);
    unint64_t v13 = bswap64(v7);
    unint64_t v14 = bswap64(v8);
    if (LOBYTE(v11)) {
      unint64_t v15 = HIDWORD(v13);
    }
    else {
      unint64_t v15 = HIDWORD(v7);
    }
    if (LOBYTE(v11))
    {
      unsigned int v12 = v13;
      unint64_t v16 = v14;
    }
    else
    {
      unint64_t v16 = *(void *)(v6 + 24);
    }
    BOOL v17 = v10 > 0x13;
    int v18 = (1 << v10) & 0xAAC00;
    BOOL v19 = v17 || v18 == 0;
    if (v19) {
      unint64_t v20 = HIDWORD(v7);
    }
    else {
      unint64_t v20 = v15;
    }
    if (v19) {
      unint64_t v7 = v7;
    }
    else {
      unint64_t v7 = v12;
    }
    if (!v19)
    {
      unint64_t v8 = v16;
      double v9 = v11;
    }
    *(_OWORD *)(result + 24) = *(_OWORD *)v6;
    *(void *)(result + 40) = v7 | (v20 << 32);
    *(void *)(result + 4++*(_DWORD *)(this + 8) = v8;
    *(double *)(result + 56) = v9;
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_metallib>::moveToFirst(uint64_t result)
{
  if (*(_DWORD *)(result + 20))
  {
    *(void *)(result + 8) -= 40;
    --*(_DWORD *)(result + 16);
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_metallib>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_metallib>::moveToEnd(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 20);
  if (v1)
  {
    unsigned int v2 = v1 - 1;
    *(void *)(result + 8) += 40 * v2;
    *(_DWORD *)(result + 16) += v2;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_metallib>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_module>::AIRBuildTableEntry(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 64) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 72) = a6;
  return result;
}

{
  *(void *)uint64_t result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 64) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 72) = a6;
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_module>::moveNext(uint64_t result, unsigned int a2)
{
  uint64_t v2 = *(void *)(result + 8) + 40 * a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = v2;
  unsigned int v3 = *(_DWORD *)(result + 20);
  unsigned int v4 = *(_DWORD *)(result + 16) + a2;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = v4;
  if (v4 < v3)
  {
    if (v2 < 0
      || (uint64_t v5 = *(void *)(*(void *)result + 16),
          uint64_t v6 = (double *)(v5 + v2),
          (unint64_t)(v6 + 5) > v5 + *(void *)(*(void *)result + 24)))
    {
      llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
    }
    double v7 = v6[4];
    unsigned int v8 = *(_DWORD *)(*(void *)result + 8);
    BOOL v9 = v8 > 0x13;
    int v10 = (1 << v8) & 0xAAC00;
    BOOL v11 = v9 || v10 == 0;
    double v12 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)&v7));
    if (!v11) {
      double v7 = v12;
    }
    long long v13 = *(_OWORD *)v6;
    *(_OWORD *)(result + 40) = *((_OWORD *)v6 + 1);
    *(_OWORD *)(result + 24) = v13;
    *(double *)(result + 56) = v7;
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_module>::moveToFirst(uint64_t result)
{
  if (*(_DWORD *)(result + 20))
  {
    *(void *)(result + 8) -= 40;
    --*(_DWORD *)(result + 16);
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_module>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_module>::moveToEnd(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 20);
  if (v1)
  {
    unsigned int v2 = v1 - 1;
    *(void *)(result + 8) += 40 * v2;
    *(_DWORD *)(result + 16) += v2;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_module>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_descriptor>::AIRBuildTableEntry(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 80) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 8++*(_DWORD *)(this + 8) = a6;
  return result;
}

{
  *(void *)uint64_t result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 80) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 8++*(_DWORD *)(this + 8) = a6;
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_descriptor>::moveNext(uint64_t result, unsigned int a2)
{
  uint64_t v2 = *(void *)(result + 8) + 56 * a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = v2;
  unsigned int v3 = *(_DWORD *)(result + 20);
  unsigned int v4 = *(_DWORD *)(result + 16) + a2;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = v4;
  if (v4 < v3)
  {
    if (v2 < 0
      || (uint64_t v5 = *(void *)(*(void *)result + 16),
          uint64_t v6 = (long long *)(v5 + v2),
          (unint64_t)v6 + 56 > v5 + *(void *)(*(void *)result + 24)))
    {
      llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
    }
    unint64_t v7 = *((void *)v6 + 4);
    unint64_t v8 = *((void *)v6 + 5);
    double v9 = *((double *)v6 + 6);
    unsigned int v10 = *(_DWORD *)(*(void *)result + 8);
    double v11 = COERCE_DOUBLE(vrev32_s8(*(int8x8_t *)&v9));
    unint64_t v12 = bswap64(v7);
    unint64_t v13 = bswap64(v8);
    unsigned int v14 = bswap32(v7);
    if (LOBYTE(v11)) {
      unint64_t v15 = HIDWORD(v7);
    }
    else {
      unint64_t v15 = HIDWORD(v12);
    }
    if (LOBYTE(v11))
    {
      LODWORD(v12) = v14;
      unint64_t v16 = *((void *)v6 + 5);
    }
    else
    {
      unint64_t v16 = v13;
    }
    BOOL v17 = v10 > 0x13;
    int v18 = (1 << v10) & 0xAAC00;
    BOOL v19 = v17 || v18 == 0;
    if (v19) {
      unint64_t v20 = HIDWORD(v7);
    }
    else {
      unint64_t v20 = v15;
    }
    if (v19) {
      unint64_t v7 = v7;
    }
    else {
      unint64_t v7 = v12;
    }
    if (!v19)
    {
      unint64_t v8 = v16;
      double v9 = v11;
    }
    long long v21 = *v6;
    *(_OWORD *)(result + 40) = v6[1];
    *(_OWORD *)(result + 24) = v21;
    *(void *)(result + 56) = v7 | (v20 << 32);
    *(void *)(result + 64) = v8;
    *(double *)(result + 72) = v9;
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_descriptor>::moveToFirst(uint64_t result)
{
  if (*(_DWORD *)(result + 20))
  {
    *(void *)(result + 8) -= 56;
    --*(_DWORD *)(result + 16);
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_descriptor>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_descriptor>::moveToEnd(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 20);
  if (v1)
  {
    unsigned int v2 = v1 - 1;
    *(void *)(result + 8) += 56 * v2;
    *(_DWORD *)(result + 16) += v2;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_descriptor>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object>::AIRBuildTableEntry(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)uint64_t result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 64) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 72) = a6;
  return result;
}

{
  *(void *)uint64_t result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 64) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 72) = a6;
  return result;
}

double llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object>::moveNext(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 8) + 36 * a2;
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = v2;
  unsigned int v3 = *(_DWORD *)(a1 + 20);
  unsigned int v4 = *(_DWORD *)(a1 + 16) + a2;
  *(_DWORD *)(a1 + ++*(_DWORD *)(this + 16) = v4;
  if (v4 < v3)
  {
    sub_1CCC623E0(v8, *(void *)a1, (int8x16_t *)(*(void *)(*(void *)a1 + 16) + v2));
    double result = *(double *)v8[0].i64;
    int8x16_t v7 = v8[1];
    *(int8x16_t *)(a1 + 24) = v8[0];
    *(int8x16_t *)(a1 + 40) = v7;
    *(_DWORD *)(a1 + 56) = v9;
  }
  return result;
}

int8x16_t *sub_1CCC623E0(int8x16_t *result, uint64_t a2, int8x16_t *a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > (unint64_t)a3 || (unint64_t)a3[2].u64 + 4 > v3 + *(void *)(a2 + 24);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  int8x16_t v5 = a3[1];
  *double result = *a3;
  result[1] = v5;
  result[2].i32[0] = a3[2].i32[0];
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  if (!v4 && v7 != 0)
  {
    unsigned int v9 = bswap32(result[2].u32[0]);
    result[2].i32[0] = v9;
    *double result = vrev32q_s8(*result);
    result[1].i32[0] = bswap32(result[1].u32[0]);
    if ((v9 & 2) == 0) {
      result[1].i32[1] = bswap32(result[1].u32[1]);
    }
    result[1].i32[2] = bswap32(result[1].u32[2]);
    if ((v9 & 1) == 0) {
      result[1].i32[3] = bswap32(result[1].u32[3]);
    }
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object>::moveToFirst(uint64_t result)
{
  if (*(_DWORD *)(result + 20))
  {
    *(void *)(result + 8) -= 36;
    --*(_DWORD *)(result + 16);
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object>::moveToEnd(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 20);
  if (v1)
  {
    unsigned int v2 = v1 - 1;
    *(void *)(result + 8) += 36 * v2;
    *(_DWORD *)(result + 16) += v2;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object_index>::AIRBuildTableEntry(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  *(void *)double result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 4++*(_DWORD *)(this + 8) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 56) = a6;
  return result;
}

{
  *(void *)double result = a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = a3;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(result + 20) = a4;
  *(void *)(result + 4++*(_DWORD *)(this + 8) = *(void *)(a2 + 16) + a5;
  *(void *)(result + 56) = a6;
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object_index>::moveNext(uint64_t result, unsigned int a2)
{
  uint64_t v2 = *(void *)(result + 8) + 24 * a2;
  *(void *)(result + ++*(_DWORD *)(this + 8) = v2;
  unsigned int v3 = *(_DWORD *)(result + 20);
  unsigned int v4 = *(_DWORD *)(result + 16) + a2;
  *(_DWORD *)(result + ++*(_DWORD *)(this + 16) = v4;
  if (v4 < v3)
  {
    if (v2 < 0
      || (uint64_t v5 = *(void *)(*(void *)result + 16),
          uint64_t v6 = v5 + v2,
          v6 + 24 > (unint64_t)(v5 + *(void *)(*(void *)result + 24))))
    {
      llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
    }
    int8x16_t v7 = *(int8x16_t *)v6;
    int8x8_t v8 = *(int8x8_t *)(v6 + 16);
    unsigned int v9 = *(_DWORD *)(*(void *)result + 8);
    BOOL v10 = v9 > 0x13;
    int v11 = (1 << v9) & 0xAAC00;
    if (!v10 && v11 != 0)
    {
      int8x16_t v7 = vrev32q_s8(v7);
      int8x8_t v8 = vrev32_s8(v8);
    }
    *(int8x16_t *)(result + 24) = v7;
    *(int8x8_t *)(result + 40) = v8;
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object_index>::moveToFirst(uint64_t result)
{
  if (*(_DWORD *)(result + 20))
  {
    *(void *)(result + 8) -= 24;
    --*(_DWORD *)(result + 16);
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object_index>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object_index>::moveToEnd(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 20);
  if (v1)
  {
    unsigned int v2 = v1 - 1;
    *(void *)(result + 8) += 24 * v2;
    *(_DWORD *)(result + 16) += v2;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object_index>::moveNext();
  }
  return result;
}

uint64_t llvm::object::AIRMetalLib::find@<X0>(void *__s2@<X1>, uint64_t result@<X0>, unint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v5 = (void *)(*(void *)(*(void *)result + 16) + *(void *)(result + 8));
  uint64_t v6 = (_OWORD *)(result + 80);
  int v18 = (void *)(*(void *)(*(void *)(result + 80) + 16) + *(void *)(result + 88));
  if (v18 != v5)
  {
    unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * (v18 - v5);
    if (a3 >= 0x10) {
      size_t v8 = 16;
    }
    else {
      size_t v8 = a3;
    }
    if (a3 > 0x10) {
      int v9 = -1;
    }
    else {
      int v9 = 1;
    }
    if (a3 == 16) {
      int v10 = 0;
    }
    else {
      int v10 = v9;
    }
    do
    {
      int v11 = &v5[5 * (v7 >> 1)];
      if (v8 && (double result = memcmp(&v5[5 * (v7 >> 1)], __s2, v8), result)) {
        int v12 = ((int)result >> 31) | 1;
      }
      else {
        int v12 = v10;
      }
      if (v12 == -1) {
        v7 += ~(v7 >> 1);
      }
      else {
        v7 >>= 1;
      }
      if (v12 == -1) {
        uint64_t v5 = v11 + 5;
      }
    }
    while (v7);
  }
  if (v5 != v18 && a3 == 16 && *v5 == *__s2 && v5[1] == __s2[1]) {
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_metallib>::moveNext();
  }
  long long v15 = v6[3];
  a4[2] = v6[2];
  a4[3] = v15;
  a4[4] = v6[4];
  long long v16 = v6[1];
  *a4 = *v6;
  a4[1] = v16;
  return result;
}

void llvm::object::MachOObjectFile::AIRMetalLibTable(uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getAIRHeaderExt((unint64_t **)a1, (uint64_t)&v28);
  if ((v35 & 1) == 0)
  {
    uint64_t v6 = v28;
    int v7 = v31;
    uint64_t v9 = v33;
    uint64_t v8 = v34;
    goto LABEL_3;
  }
  llvm::object::MachOObjectFile::getAIRMetalLibNote((unint64_t **)a1, (uint64_t)&v21);
  if (v22)
  {
    BOOL v19 = (void *)v21;
    sub_1CD4515D0(&v19);
    if (v19) {
      (*(void (**)(void *))(*v19 + 8))(v19);
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    int v7 = 0;
    uint64_t v6 = 0;
    uint64_t v18 = v28;
  }
  else
  {
    unint64_t v20 = (void *)v28;
    sub_1CD4515D0(&v20);
    if (v20) {
      (*(void (**)(void *))(*v20 + 8))(v20);
    }
    uint64_t v6 = v21;
    int v7 = DWORD2(v21);
    llvm::object::MachOObjectFile::getAIRStringTableNote((unint64_t **)a1, (uint64_t)v26);
    if ((v27 & 1) == 0)
    {
      uint64_t v9 = v26[0];
      uint64_t v8 = v26[1];
      goto LABEL_3;
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v18 = v26[0];
  }
  *a2 = v18;
LABEL_3:
  *(void *)&long long v28 = a1;
  *((void *)&v28 + 1) = v6;
  LODWORD(v29) = 0;
  DWORD1(v29) = v7;
  uint64_t v10 = *(void *)(a1 + 16) + v9;
  *(void *)&long long v32 = v10;
  *((void *)&v32 + 1) = v8;
  if (v7)
  {
    *((void *)&v28 + 1) = v6 - 40;
    LODWORD(v29) = -1;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_metallib>::moveNext();
  }
  *(void *)&long long v21 = a1;
  *((void *)&v21 + 1) = v6;
  *(void *)&long long v22 = 0;
  *(void *)&long long v25 = v10;
  *((void *)&v25 + 1) = v8;
  long long v11 = v29;
  long long v12 = v31;
  long long v13 = v32;
  a3[2] = v30;
  a3[3] = v12;
  *a3 = v28;
  a3[1] = v11;
  long long v14 = v23;
  long long v15 = v24;
  long long v16 = v21;
  a3[6] = v22;
  a3[7] = v14;
  long long v17 = v25;
  a3[8] = v15;
  a3[9] = v17;
  a3[4] = v13;
  a3[5] = v16;
  if (!*a2) {
    *a2 = 0;
  }
}

void llvm::object::MachOObjectFile::getAIRHeaderExt(unint64_t **this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = (llvm::object::MachOObjectFile *)this;
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = this[16];
  uint64_t v5 = *((unsigned int *)this + 34);
  if (v5)
  {
    uint64_t v6 = &v4[2 * v5];
    uint64_t v7 = 16 * v5;
    while (1)
    {
      if (*((_DWORD *)v4 + 2) == 49)
      {
        uint64_t v23 = 0;
        memset(v22, 0, sizeof(v22));
        llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v4, (uint64_t)v22);
        if (!BYTE7(v22[1]))
        {
          this = (unint64_t **)strlen((const char *)v22 + 8);
          if (this == (unint64_t **)14
            && *((void *)&v22[0] + 1) == 0x444145485F524941
            && *(void *)((char *)v22 + 14) == 0x5458455F52454441)
          {
            break;
          }
        }
      }
      v4 += 2;
      v7 -= 16;
      if (!v7)
      {
        unsigned int v4 = v6;
        break;
      }
    }
    uint64_t v9 = v4;
    unsigned int v4 = (unint64_t *)*((void *)v2 + 16);
    uint64_t v10 = *((unsigned int *)v2 + 34);
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = this[16];
  }
  if (v9 == &v4[2 * v10])
  {
    *(void *)&v25.__val_ = llvm::object::object_category((llvm::object *)this);
    llvm::errorCodeToError((llvm *)3, v25, (void *)a2);
    *(unsigned char *)(a2 + 96) |= 1u;
  }
  else
  {
    llvm::object::MachOObjectFile::getNoteLoadCommand((uint64_t)v2, v9, (uint64_t)v20);
    if (v21 < 0
      || (uint64_t v11 = *((void *)v2 + 2),
          long long v12 = (int8x16_t *)(v11 + v21),
          v11 + v21 + 96 > (unint64_t)(v11 + *((void *)v2 + 3))))
    {
      *(void *)&v22[0] = "Structure read out-of-range";
      LOWORD(v23) = 259;
      sub_1CCC51CE4(a2, (uint64_t *)v22);
    }
    int8x16_t v13 = *v12;
    int8x16_t v14 = v12[1];
    int8x16_t v16 = v12[2];
    int8x16_t v15 = v12[3];
    int8x16_t v17 = v12[4];
    int8x16_t v18 = v12[5];
    unsigned int v19 = *((_DWORD *)v2 + 2);
    if (v19 <= 0x13 && ((1 << v19) & 0xAAC00) != 0)
    {
      int8x16_t v13 = vrev64q_s8(v13);
      int8x16_t v14 = vrev64q_s8(v14);
      int8x16_t v16 = vrev64q_s8(v16);
      int8x16_t v15 = vrev32q_s8(v15);
      int8x16_t v17 = vrev32q_s8(v17);
      int8x16_t v18 = vrev64q_s8(v18);
    }
    *(unsigned char *)(a2 + 96) &= ~1u;
    *(int8x16_t *)a2 = v13;
    *(int8x16_t *)(a2 + ++*(_DWORD *)(this + 16) = v14;
    *(int8x16_t *)(a2 + 32) = v16;
    *(int8x16_t *)(a2 + 4++*(_DWORD *)(this + 8) = v15;
    *(int8x16_t *)(a2 + 64) = v17;
    *(int8x16_t *)(a2 + 80) = v18;
  }
}

uint64_t llvm::object::AIRModule::find@<X0>(void *__s2@<X1>, uint64_t result@<X0>, unint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v5 = (void *)(*(void *)(*(void *)result + 16) + *(void *)(result + 8));
  uint64_t v6 = (_OWORD *)(result + 80);
  unint64_t v20 = (void *)(*(void *)(*(void *)(result + 80) + 16) + *(void *)(result + 88));
  if (v20 != v5)
  {
    unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * (v20 - v5);
    if (a3 >= 0x20) {
      size_t v8 = 32;
    }
    else {
      size_t v8 = a3;
    }
    if (a3 > 0x20) {
      int v9 = -1;
    }
    else {
      int v9 = 1;
    }
    if (a3 == 32) {
      int v10 = 0;
    }
    else {
      int v10 = v9;
    }
    do
    {
      uint64_t v11 = &v5[5 * (v7 >> 1)];
      if (v8 && (double result = memcmp(&v5[5 * (v7 >> 1)], __s2, v8), result)) {
        int v12 = ((int)result >> 31) | 1;
      }
      else {
        int v12 = v10;
      }
      if (v12 == -1) {
        v7 += ~(v7 >> 1);
      }
      else {
        v7 >>= 1;
      }
      if (v12 == -1) {
        uint64_t v5 = v11 + 5;
      }
    }
    while (v7);
  }
  if (v5 != v20 && a3 == 32 && *v5 == *__s2 && v5[1] == __s2[1] && v5[2] == __s2[2] && v5[3] == __s2[3]) {
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_module>::moveNext();
  }
  long long v16 = v6[3];
  a4[2] = v6[2];
  a4[3] = v16;
  a4[4] = v6[4];
  long long v17 = v6[1];
  *a4 = *v6;
  a4[1] = v17;
  return result;
}

void llvm::object::MachOObjectFile::AIRModuleTable(uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getAIRHeaderExt((unint64_t **)a1, (uint64_t)&v22);
  if (v27)
  {
    llvm::object::MachOObjectFile::getAIRModuleNote((unint64_t **)a1, (uint64_t)&v17);
    if (v18)
    {
      int8x16_t v15 = (void *)v17;
      sub_1CD4515D0(&v15);
      if (v15) {
        (*(void (**)(void *))(*v15 + 8))(v15);
      }
      int v7 = 0;
      uint64_t v6 = 0;
      *a2 = v22;
    }
    else
    {
      long long v16 = (void *)v22;
      sub_1CD4515D0(&v16);
      if (v16) {
        (*(void (**)(void *))(*v16 + 8))(v16);
      }
      int v7 = DWORD2(v17);
      uint64_t v6 = v17;
    }
  }
  else
  {
    uint64_t v6 = *((void *)&v22 + 1);
    int v7 = DWORD1(v25);
  }
  *(void *)&long long v22 = a1;
  *((void *)&v22 + 1) = v6;
  LODWORD(v23) = 0;
  DWORD1(v23) = v7;
  unint64_t v8 = *(void *)(a1 + 16);
  long long v26 = v8;
  if (v7)
  {
    *((void *)&v22 + 1) = v6 - 40;
    LODWORD(v23) = -1;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_module>::moveNext();
  }
  *(void *)&long long v17 = a1;
  *((void *)&v17 + 1) = v6;
  *(void *)&long long v18 = 0;
  long long v21 = v8;
  long long v9 = v25;
  a3[2] = v24;
  a3[3] = v9;
  long long v10 = v23;
  *a3 = v22;
  a3[1] = v10;
  long long v11 = v19;
  long long v12 = v20;
  long long v13 = v17;
  a3[6] = v18;
  a3[7] = v11;
  long long v14 = v21;
  a3[8] = v12;
  a3[9] = v14;
  a3[4] = v26;
  a3[5] = v13;
  if (!*a2) {
    *a2 = 0;
  }
}

uint64_t llvm::object::AIRDescriptor::find@<X0>(void *__s2@<X1>, uint64_t result@<X0>, unint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  uint64_t v5 = (void *)(*(void *)(*(void *)result + 16) + *(void *)(result + 8));
  uint64_t v6 = (_OWORD *)(result + 96);
  long long v21 = (void *)(*(void *)(*(void *)(result + 96) + 16) + *(void *)(result + 104));
  if (v21 != v5)
  {
    unint64_t v7 = 0x6DB6DB6DB6DB6DB7 * (v21 - v5);
    if (a3 >= 0x20) {
      size_t v8 = 32;
    }
    else {
      size_t v8 = a3;
    }
    if (a3 > 0x20) {
      int v9 = -1;
    }
    else {
      int v9 = 1;
    }
    if (a3 == 32) {
      int v10 = 0;
    }
    else {
      int v10 = v9;
    }
    do
    {
      long long v11 = &v5[7 * (v7 >> 1)];
      if (v8 && (double result = memcmp(&v5[7 * (v7 >> 1)], __s2, v8), result)) {
        int v12 = ((int)result >> 31) | 1;
      }
      else {
        int v12 = v10;
      }
      if (v12 == -1) {
        v7 += ~(v7 >> 1);
      }
      else {
        v7 >>= 1;
      }
      if (v12 == -1) {
        uint64_t v5 = v11 + 7;
      }
    }
    while (v7);
  }
  if (v5 != v21 && a3 == 32 && *v5 == *__s2 && v5[1] == __s2[1] && v5[2] == __s2[2] && v5[3] == __s2[3]) {
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_descriptor>::moveNext();
  }
  long long v16 = v6[3];
  a4[2] = v6[2];
  a4[3] = v16;
  long long v17 = v6[5];
  a4[4] = v6[4];
  a4[5] = v17;
  long long v18 = v6[1];
  *a4 = *v6;
  a4[1] = v18;
  return result;
}

void llvm::object::MachOObjectFile::AIRDescriptorTable(uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getAIRHeaderExt((unint64_t **)a1, (uint64_t)&v28);
  if ((v34 & 1) == 0)
  {
    uint64_t v6 = v29;
    int v7 = DWORD2(v31);
    uint64_t v8 = *((void *)&v33 + 1);
    uint64_t v9 = v33;
    goto LABEL_3;
  }
  llvm::object::MachOObjectFile::getAIRDescriptorNote((unint64_t **)a1, (uint64_t)&v20);
  if (v21)
  {
    long long v18 = (void *)v20;
    sub_1CD4515D0(&v18);
    if (v18) {
      (*(void (**)(void *))(*v18 + 8))(v18);
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    int v7 = 0;
    uint64_t v6 = 0;
    uint64_t v17 = v28;
  }
  else
  {
    long long v19 = (void *)v28;
    sub_1CD4515D0(&v19);
    if (v19) {
      (*(void (**)(void *))(*v19 + 8))(v19);
    }
    uint64_t v6 = v20;
    int v7 = DWORD2(v20);
    llvm::object::MachOObjectFile::getAIRStringTableNote((unint64_t **)a1, (uint64_t)v26);
    if ((v27 & 1) == 0)
    {
      uint64_t v9 = v26[0];
      uint64_t v8 = v26[1];
      goto LABEL_3;
    }
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    uint64_t v17 = v26[0];
  }
  *a2 = v17;
LABEL_3:
  *(void *)&long long v28 = a1;
  *((void *)&v28 + 1) = v6;
  LODWORD(v29) = 0;
  DWORD1(v29) = v7;
  uint64_t v10 = *(void *)(a1 + 16) + v9;
  *(void *)&long long v33 = v10;
  *((void *)&v33 + 1) = v8;
  if (v7)
  {
    *((void *)&v28 + 1) = v6 - 56;
    LODWORD(v29) = -1;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_descriptor>::moveNext();
  }
  *(void *)&long long v20 = a1;
  *((void *)&v20 + 1) = v6;
  *(void *)&long long v21 = 0;
  *(void *)&long long v25 = v10;
  *((void *)&v25 + 1) = v8;
  long long v11 = v31;
  a3[2] = v30;
  a3[3] = v11;
  long long v12 = v33;
  a3[4] = v32;
  a3[5] = v12;
  long long v13 = v29;
  *a3 = v28;
  a3[1] = v13;
  long long v14 = v23;
  a3[8] = v22;
  a3[9] = v14;
  long long v15 = v25;
  a3[10] = v24;
  a3[11] = v15;
  long long v16 = v21;
  a3[6] = v20;
  a3[7] = v16;
  if (!*a2) {
    *a2 = 0;
  }
}

__n128 llvm::object::AIRObject::find@<Q0>(llvm::object::AIRObject *this@<X0>, unsigned __int32 a2@<W1>, unsigned __int32 a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unsigned int v25 = a4 & 4;
  uint64_t v9 = (int8x16_t *)(*(void *)(*(void *)this + 16) + *((void *)this + 1));
  uint64_t v10 = (char *)this + 80;
  long long v23 = v9;
  long long v24 = (int8x16_t *)(*(void *)(*((void *)this + 10) + 16) + *((void *)this + 11));
  if (v24 != v9)
  {
    unint64_t v11 = 0x8E38E38E38E38E39 * (((char *)v24 - (char *)v9) >> 2);
    do
    {
      unint64_t v12 = v11 >> 1;
      int v28 = 0;
      int8x16_t v26 = 0u;
      long long v27 = 0u;
      sub_1CCC623E0(&v26, *(void *)this, (int8x16_t *)((char *)v9 + 36 * (v11 >> 1)));
      if (v26.i32[0] < a2 || v26.i32[0] <= a2 && (v26.i32[1] < a3 || v26.i32[1] <= a3 && (v28 & 4u) < v25))
      {
        uint64_t v9 = (int8x16_t *)((char *)v9 + 36 * (v11 >> 1) + 36);
        unint64_t v12 = v11 + ~v12;
      }
      unint64_t v11 = v12;
    }
    while (v12);
  }
  if (v9 != v24
    && (v28 = 0, int8x16_t v26 = 0u, v27 = 0u, sub_1CCC623E0(&v26, *(void *)this, v9), v26.i64[0] == __PAIR64__(a3, a2))
    && (v28 & 4) == v25)
  {
    uint64_t v15 = *(void *)this;
    uint64_t v14 = *((void *)this + 1);
    int v16 = *((_DWORD *)this + 4);
    unsigned int v17 = *((_DWORD *)this + 5);
    long long v18 = *(_OWORD *)((char *)this + 40);
    int8x16_t v26 = *(int8x16_t *)((char *)this + 24);
    long long v27 = v18;
    int v28 = *((_DWORD *)this + 14);
    long long v29 = *(_OWORD *)((char *)this + 60);
    int v30 = *((_DWORD *)this + 19);
    uint64_t v19 = v14 + 34359738372 * (((char *)v9 - (char *)v23) >> 2);
    unsigned int v20 = v16 + 954437177 * (((char *)v9 - (char *)v23) >> 2);
    if (v20 < v17) {
      sub_1CCC623E0(&v26, v15, (int8x16_t *)(*(void *)(v15 + 16) + v19));
    }
    long long v21 = v27;
    *(int8x16_t *)(a5 + 24) = v26;
    *(void *)a5 = v15;
    *(void *)(a5 + ++*(_DWORD *)(this + 8) = v19;
    *(_DWORD *)(a5 + ++*(_DWORD *)(this + 16) = v20;
    *(_DWORD *)(a5 + 20) = v17;
    *(_OWORD *)(a5 + 40) = v21;
    *(_DWORD *)(a5 + 56) = v28;
    result.n128_u64[0] = v29;
    *(_OWORD *)(a5 + 60) = v29;
    *(_DWORD *)(a5 + 76) = v30;
  }
  else
  {
    long long v22 = *((_OWORD *)v10 + 3);
    *(_OWORD *)(a5 + 32) = *((_OWORD *)v10 + 2);
    *(_OWORD *)(a5 + 4++*(_DWORD *)(this + 8) = v22;
    *(_OWORD *)(a5 + 64) = *((_OWORD *)v10 + 4);
    __n128 result = *((__n128 *)v10 + 1);
    *(_OWORD *)a5 = *(_OWORD *)v10;
    *(__n128 *)(a5 + ++*(_DWORD *)(this + 16) = result;
  }
  return result;
}

void llvm::object::MachOObjectFile::AIRObjectTable(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getAIRHeaderExt((unint64_t **)a1, (uint64_t)&v22);
  if (v28)
  {
    llvm::object::MachOObjectFile::getAIRObjectNote((unint64_t **)a1, (uint64_t)&v19);
    if (v21)
    {
      uint64_t v15 = v19;
      sub_1CD4515D0(&v15);
      if (v15) {
        (*(void (**)(void *))(*v15 + 8))(v15);
      }
      uint64_t v6 = 0;
      uint64_t v9 = 0;
      uint64_t v8 = 0;
      *a2 = v22.i64[0];
      uint64_t v10 = *(void *)(a1 + 16);
      uint64_t v11 = v10;
      goto LABEL_13;
    }
    int v16 = (void *)v22.i64[0];
    sub_1CD4515D0(&v16);
    if (v16) {
      (*(void (**)(void *))(*v16 + 8))(v16);
    }
    uint64_t v6 = v19;
    int v7 = v20;
    llvm::object::MachOObjectFile::getAIRStringTableNote((unint64_t **)a1, (uint64_t)v17);
    if (v18)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      *a2 = v17[0];
    }
    else
    {
      uint64_t v9 = v17[0];
      uint64_t v8 = v17[1];
    }
  }
  else
  {
    uint64_t v6 = (void *)*((void *)&v23 + 1);
    int v7 = v25;
    uint64_t v9 = v26;
    uint64_t v8 = v27;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = v10 + v9;
  if (v7)
  {
    sub_1CCC623E0(&v22, a1, (int8x16_t *)((char *)v6 + v10));
    uint64_t v12 = *(void *)(a1 + 16) + v9;
    uint64_t v13 = (uint64_t)v6 + 36 * (v7 - 1) + 36;
    goto LABEL_14;
  }
LABEL_13:
  int v7 = 0;
  uint64_t v12 = v10 + v9;
  uint64_t v13 = (uint64_t)v6;
LABEL_14:
  long long v14 = v23;
  *(int8x16_t *)(a3 + 24) = v22;
  *(_OWORD *)(a3 + 40) = v14;
  *(_DWORD *)(a3 + 56) = v24;
  *(void *)a3 = a1;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = v6;
  *(_DWORD *)(a3 + ++*(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(a3 + 20) = v7;
  *(void *)(a3 + 64) = v11;
  *(void *)(a3 + 72) = v8;
  *(void *)(a3 + 80) = a1;
  *(void *)(a3 + 8++*(_DWORD *)(this + 8) = v13;
  *(_DWORD *)(a3 + 96) = v7;
  *(_DWORD *)(a3 + 100) = v7;
  *(void *)(a3 + 144) = v12;
  *(void *)(a3 + ++*(_DWORD *)(*(void *)(this + 48) + 152) = v8;
  if (!*a2) {
    *a2 = 0;
  }
}

void llvm::object::MachOObjectFile::AIRObjectIndexTable(uint64_t a1@<X0>, void *a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getAIRObjectIndexNote((unint64_t **)a1, (uint64_t)&v14);
  if (v15)
  {
    int v7 = 0;
    uint64_t v6 = 0;
    *a2 = v14;
  }
  else
  {
    uint64_t v6 = v14;
    int v7 = DWORD2(v14);
  }
  *(void *)&long long v14 = a1;
  *((void *)&v14 + 1) = v6;
  LODWORD(v15) = 0;
  DWORD1(v15) = v7;
  unint64_t v8 = *(void *)(a1 + 16);
  long long v17 = v8;
  if (v7)
  {
    *((void *)&v14 + 1) = v6 - 24;
    LODWORD(v15) = -1;
    llvm::object::AIRBuildTableEntry<llvm::MachO::air_n_object_index>::moveNext();
  }
  *(void *)&long long v11 = a1;
  *((void *)&v11 + 1) = v6;
  *(void *)&long long v12 = 0;
  long long v9 = v15;
  *a3 = v14;
  a3[1] = v9;
  long long v10 = v17;
  a3[2] = v16;
  a3[3] = v10;
  a3[4] = v11;
  a3[5] = v12;
  a3[6] = v13;
  a3[7] = v8;
  if (!*a2) {
    *a2 = 0;
  }
}

uint64_t llvm::object::MachOObjectFile::AIRPipelineTable@<X0>(unint64_t **a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getAIRHeaderExt(a1, (uint64_t)&v15);
  if (v19)
  {
    llvm::object::MachOObjectFile::getAIRPipelineNote(a1, (uint64_t)&v12);
    if (v14)
    {
      long long v10 = v12;
      sub_1CD4515D0(&v10);
      if (v10) {
        (*(void (**)(void *))(*v10 + 8))(v10);
      }
      int v7 = 0;
      uint64_t v6 = 0;
      *a2 = v15;
    }
    else
    {
      long long v11 = (void *)v15;
      sub_1CD4515D0(&v11);
      if (v11) {
        (*(void (**)(void *))(*v11 + 8))(v11);
      }
      int v7 = v13;
      uint64_t v6 = v12;
    }
  }
  else
  {
    uint64_t v6 = v17;
    int v7 = v18;
  }
  *(void *)&long long v15 = a1;
  *((void *)&v15 + 1) = v6;
  LODWORD(v++*(_DWORD *)(this + 16) = 0;
  DWORD1(v++*(_DWORD *)(this + 16) = v7;
  uint64_t result = llvm::object::AIRPipelineEntry::moveToFirst((uint64_t)&v15);
  long long v9 = v16;
  *(_OWORD *)a3 = v15;
  *(_OWORD *)(a3 + ++*(_DWORD *)(this + 16) = v9;
  *(void *)(a3 + 32) = v17;
  *(void *)(a3 + 40) = a1;
  *(void *)(a3 + 4++*(_DWORD *)(this + 8) = v6;
  *(_DWORD *)(a3 + 56) = v7;
  *(_DWORD *)(a3 + 60) = v7;
  if (!*a2) {
    *a2 = 0;
  }
  return result;
}

uint64_t llvm::object::AIRPipelineEntry::moveToFirst(uint64_t this)
{
  *(_DWORD *)(this + ++*(_DWORD *)(this + 16) = 0;
  if (*(_DWORD *)(this + 20))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)this;
    unsigned int v3 = (unsigned int *)(*(void *)(v2 + 16) + *(void *)(v1 + 8));
    this = sub_1CCC5CCA4(v2, v3);
    switch((int)this)
    {
      case 0:
        this = sub_1CCC5312C(*(void *)v1, v3);
        *(void *)(v1 + 24) = this;
        *(_DWORD *)(v1 + 32) = v4;
        break;
      case 1:
      case 2:
        this = sub_1CCC63C84(*(void *)v1, v3);
        *(void *)(v1 + 24) = this;
        break;
      case 3:
        this = sub_1CCC54354(*(void *)v1, v3);
        *(void *)(v1 + 24) = this;
        *(void *)(v1 + 32) = v5;
        break;
      default:
        return this;
    }
  }
  return this;
}

uint64_t llvm::object::AIRPipelineEntry::moveToEnd(uint64_t this)
{
  *(_DWORD *)(this + ++*(_DWORD *)(this + 16) = *(_DWORD *)(this + 20);
  return this;
}

uint64_t *llvm::object::AIRPipelineEntry::moveNext(uint64_t *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((int *)this + 6);
  if (v2 <= 3) {
    this[1] += qword_1CFB2C1D8[v2];
  }
  int v3 = *((_DWORD *)this + 5);
  int v4 = *((_DWORD *)this + 4) + 1;
  *((_DWORD *)this + 4) = v4;
  if (v4 != v3)
  {
    uint64_t v5 = (unsigned int *)(*(void *)(*this + 16) + this[1]);
    this = (uint64_t *)sub_1CCC5CCA4(*this, v5);
    switch((int)this)
    {
      case 0:
        this = (uint64_t *)sub_1CCC5312C(*v1, v5);
        v1[3] = (uint64_t)this;
        *((_DWORD *)v1 + ++*(_DWORD *)(this + 8) = v6;
        break;
      case 1:
      case 2:
        this = (uint64_t *)sub_1CCC63C84(*v1, v5);
        v1[3] = (uint64_t)this;
        break;
      case 3:
        this = (uint64_t *)sub_1CCC54354(*v1, v5);
        v1[3] = (uint64_t)this;
        v1[4] = v7;
        break;
      default:
        return this;
    }
  }
  return this;
}

uint64_t sub_1CCC63C84(uint64_t a1, _DWORD *a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = v2 > (unint64_t)a2 || (unint64_t)(a2 + 2) > v2 + *(void *)(a1 + 24);
  if (v3) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  LODWORD(v4) = *a2;
  LODWORD(v5) = a2[1];
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  BOOL v3 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  BOOL v8 = v3 || v7 == 0;
  unsigned int v9 = bswap32(v4);
  unsigned int v10 = bswap32(v5);
  if (v8) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = v9;
  }
  if (v8) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = v10;
  }
  return v4 | (v5 << 32);
}

void llvm::object::AIRHashEntry::moveNext(llvm::object::AIRHashEntry *this)
{
  BOOL v3 = (char *)this + 24;
  uint64_t v2 = *((void *)this + 3);
  unsigned int v4 = *((_DWORD *)this + 8);
  do
  {
    uint64_t v5 = v2 + 144 * v4;
    uint64_t v6 = *(void *)(v5 - 16) + 128;
    *(void *)(v5 - ++*(_DWORD *)(this + 16) = v6;
    int v7 = *(_DWORD *)(v5 - 4);
    int v8 = *(_DWORD *)(v5 - 8) + 1;
    *(_DWORD *)(v5 - ++*(_DWORD *)(this + 8) = v8;
    if (v8 == v7)
    {
      *((_DWORD *)this + ++*(_DWORD *)(this + 8) = --v4;
    }
    else
    {
      sub_1CCC63F30((uint64_t)&v25, *(void *)this, (_OWORD *)(*(void *)(*(void *)this + 16) + v6));
      uint64_t v9 = *((void *)this + 3) + 144 * *((unsigned int *)this + 8);
      *(_OWORD *)(v9 - 80) = v29;
      *(_OWORD *)(v9 - 64) = v30;
      *(_OWORD *)(v9 - 4++*(_DWORD *)(this + 8) = v31;
      *(_OWORD *)(v9 - 32) = v32;
      *(_OWORD *)(v9 - 144) = v25;
      *(_OWORD *)(v9 - 12++*(_DWORD *)(this + 8) = v26;
      *(_OWORD *)(v9 - 112) = v27;
      *(_OWORD *)(v9 - 96) = v28;
      uint64_t v2 = *((void *)this + 3);
      unsigned int v4 = *((_DWORD *)this + 8);
      uint64_t v10 = v2 + 144 * v4;
      for (int i = *(_DWORD *)(v10 - 36); (i & 0x3FFFFFFF) == 0; int i = *(_DWORD *)(v10 - 36))
      {
        unint64_t v12 = *(void *)(v10 - 16) - ((unint64_t)*(unsigned int *)(v10 - 8) << 7);
        unsigned int v13 = sub_1CCC63C84(*(void *)this, (_DWORD *)(v12 + *(void *)(*(void *)this + 16) - 8));
        uint64_t v24 = *(void *)(*((void *)this + 3) + 144 * *((unsigned int *)this + 8) - 32);
        unint64_t v14 = v12 + ((unint64_t)v13 << 7) + ((unint64_t)v24 << 7) + 8;
        long long v32 = 0u;
        long long v33 = 0u;
        long long v30 = 0u;
        long long v31 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v25 = 0u;
        long long v15 = (_OWORD *)sub_1CCC70068((uint64_t)v3, (unint64_t)&v25);
        long long v16 = (_OWORD *)(*((void *)this + 3) + 144 * *((unsigned int *)this + 8));
        *long long v16 = *v15;
        long long v17 = v15[8];
        long long v19 = v15[5];
        long long v18 = v15[6];
        v16[7] = v15[7];
        v16[8] = v17;
        v16[5] = v19;
        v16[6] = v18;
        long long v20 = v15[4];
        long long v22 = v15[1];
        long long v21 = v15[2];
        v16[3] = v15[3];
        void v16[4] = v20;
        v16[1] = v22;
        _OWORD v16[2] = v21;
        LODWORD(v++*(_DWORD *)(this + 16) = *((_DWORD *)this + 8) + 1;
        *((_DWORD *)this + ++*(_DWORD *)(this + 8) = v16;
        uint64_t v23 = *((void *)this + 3) + 144 * v16;
        sub_1CCC63F30((uint64_t)&v25, *(void *)this, (_OWORD *)(*(void *)(*(void *)this + 16) + v14));
        *(_OWORD *)(v23 - 80) = v29;
        *(_OWORD *)(v23 - 64) = v30;
        *(_OWORD *)(v23 - 4++*(_DWORD *)(this + 8) = v31;
        *(_OWORD *)(v23 - 32) = v32;
        *(_OWORD *)(v23 - 144) = v25;
        *(_OWORD *)(v23 - 12++*(_DWORD *)(this + 8) = v26;
        *(_OWORD *)(v23 - 112) = v27;
        *(_OWORD *)(v23 - 96) = v28;
        *(void *)(v23 - ++*(_DWORD *)(this + 16) = v14;
        *(void *)(v23 - ++*(_DWORD *)(this + 8) = v24;
        uint64_t v2 = *((void *)this + 3);
        unsigned int v4 = *((_DWORD *)this + 8);
        uint64_t v10 = v2 + 144 * v4;
      }
    }
  }
  while (v4 && (*(_DWORD *)(v2 + 144 * v4 - 36) & 0x3FFFFFFF) == 0);
  ++*((_DWORD *)this + 4);
}

double sub_1CCC63F30(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  if (v3 > (unint64_t)a3 || (unint64_t)(a3 + 8) > v3 + *(void *)(a2 + 24)) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v5 = a3[5];
  *(_OWORD *)(a1 + 64) = a3[4];
  *(_OWORD *)(a1 + 80) = v5;
  long long v6 = a3[7];
  *(_OWORD *)(a1 + 96) = a3[6];
  *(_OWORD *)(a1 + 112) = v6;
  long long v7 = a3[1];
  *(_OWORD *)a1 = *a3;
  *(_OWORD *)(a1 + ++*(_DWORD *)(this + 16) = v7;
  long long v8 = a3[2];
  long long v9 = a3[3];
  *(_OWORD *)(a1 + 32) = v8;
  *(_OWORD *)(a1 + 4++*(_DWORD *)(this + 8) = v9;
  unsigned int v10 = *(_DWORD *)(a2 + 8);
  if (v10 <= 0x13 && ((1 << v10) & 0xAAC00) != 0)
  {
    for (uint64_t i = 0; i != 12; i += 4)
      *(_DWORD *)(a1 + 96 + i) = bswap32(*(_DWORD *)(a1 + 96 + i));
    *(int8x8_t *)&long long v8 = vrev32_s8(*(int8x8_t *)(a1 + 108));
    *(void *)(a1 + 10++*(_DWORD *)(this + 8) = v8;
    *(_DWORD *)(a1 + 1++*(_DWORD *)(this + 16) = bswap32(*(_DWORD *)(a1 + 116));
    if ((v8 & 0x3FFFFFFF) != 0)
    {
      *(int8x8_t *)&long long v8 = vrev32_s8(*(int8x8_t *)(a1 + 120));
      *(void *)(a1 + 120) = v8;
    }
  }
  return *(double *)&v8;
}

void llvm::object::AIRHashEntry::moveToFirst(llvm::object::AIRHashEntry *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    uint64_t v3 = v1 - 120;
    int v4 = sub_1CCC63C84(*(void *)this, (_DWORD *)(*(void *)(*(void *)this + 16) + v1));
    memset(v13, 0, sizeof(v13));
    uint64_t v14 = v3;
    int v15 = -1;
    int v16 = v4;
    long long v5 = (_OWORD *)sub_1CCC70068((uint64_t)this + 24, (unint64_t)v13);
    long long v6 = (_OWORD *)(*((void *)this + 3) + 144 * *((unsigned int *)this + 8));
    *long long v6 = *v5;
    long long v7 = v5[8];
    long long v9 = v5[5];
    long long v8 = v5[6];
    _OWORD v6[7] = v5[7];
    v6[8] = v7;
    v6[5] = v9;
    v6[6] = v8;
    long long v10 = v5[4];
    long long v12 = v5[1];
    long long v11 = v5[2];
    v6[3] = v5[3];
    v6[4] = v10;
    v6[1] = v12;
    int8x16_t v6[2] = v11;
    ++*((_DWORD *)this + 8);
    llvm::object::AIRHashEntry::moveNext(this);
  }
}

uint64_t llvm::object::AIRHashEntry::moveToEnd(uint64_t this)
{
  *(_DWORD *)(this + 32) = 0;
  return this;
}

void llvm::object::MachOObjectFile::AIRHashTable(unint64_t **a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOObjectFile::getAIRHeaderExt(a1, (uint64_t)&v36);
  if (v41)
  {
    llvm::object::MachOObjectFile::getAIRHashesNote(a1, (uint64_t)&v31);
    if (v32)
    {
      long long v9 = (void *)v31;
      sub_1CD4515D0(&v9);
      if (v9) {
        (*(void (**)(void *))(*v9 + 8))(v9);
      }
      uint64_t v6 = 0;
      *a2 = v36;
    }
    else
    {
      long long v10 = (void *)v36;
      sub_1CD4515D0(&v10);
      if (v10) {
        (*(void (**)(void *))(*v10 + 8))(v10);
      }
      uint64_t v6 = v31;
    }
  }
  else
  {
    uint64_t v6 = v40[0];
  }
  *(void *)&long long v36 = a1;
  *((void *)&v36 + 1) = v6;
  int v37 = -1;
  long long v38 = v40;
  uint64_t v39 = 0x200000000;
  llvm::object::AIRHashEntry::moveToFirst((llvm::object::AIRHashEntry *)&v36);
  *(void *)&long long v31 = a1;
  *((void *)&v31 + 1) = v6;
  int v32 = -1;
  long long v33 = v35;
  uint64_t v34 = 0x200000000;
  long long v21 = v36;
  int v22 = v37;
  uint64_t v23 = v25;
  uint64_t v24 = 0x200000000;
  if (v39)
  {
    sub_1CCC687A0((uint64_t)&v23, (uint64_t)&v38);
    long long v26 = v21;
    int v27 = v22;
    long long v28 = v30;
    uint64_t v29 = 0x200000000;
    if (v24) {
      sub_1CCC700E4((uint64_t)&v28, (uint64_t)&v23);
    }
  }
  else
  {
    long long v26 = v36;
    int v27 = v37;
    long long v28 = v30;
    uint64_t v29 = 0x200000000;
  }
  long long v11 = v31;
  int v12 = v32;
  unsigned int v13 = v15;
  uint64_t v14 = 0x200000000;
  if (v34)
  {
    sub_1CCC687A0((uint64_t)&v13, (uint64_t)&v33);
    long long v16 = v11;
    int v17 = v12;
    long long v18 = v20;
    uint64_t v19 = 0x200000000;
    if (v14) {
      sub_1CCC700E4((uint64_t)&v18, (uint64_t)&v13);
    }
  }
  else
  {
    long long v16 = v31;
    int v17 = v32;
    long long v18 = v20;
    uint64_t v19 = 0x200000000;
  }
  *(_OWORD *)a3 = v26;
  int v7 = v29;
  *(_DWORD *)(a3 + ++*(_DWORD *)(this + 16) = v27;
  *(void *)(a3 + 24) = a3 + 40;
  *(void *)(a3 + 32) = 0x200000000;
  if (v7) {
    sub_1CCC687A0(a3 + 24, (uint64_t)&v28);
  }
  int v8 = v19;
  *(_DWORD *)(a3 + 344) = v17;
  *(_OWORD *)(a3 + 32++*(_DWORD *)(this + 8) = v16;
  *(void *)(a3 + 352) = a3 + 368;
  *(void *)(a3 + 360) = 0x200000000;
  if (v8) {
    sub_1CCC687A0(a3 + 352, (uint64_t)&v18);
  }
  if (v18 != v20) {
    free(v18);
  }
  if (v13 != v15) {
    free(v13);
  }
  if (v28 != v30) {
    free(v28);
  }
  if (v23 != v25) {
    free(v23);
  }
  if (v33 != v35) {
    free(v33);
  }
  if (v38 != v40) {
    free(v38);
  }
  if (!*a2) {
    *a2 = 0;
  }
}

uint64_t llvm::object::MachOObjectFile::begin_load_commands(llvm::object::MachOObjectFile *this)
{
  return *((void *)this + 16);
}

uint64_t llvm::object::MachOObjectFile::getSectionRawFinalSegmentName(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 80) + 8 * a2) + 16;
}

uint64_t llvm::object::MachOObjectFile::getScatteredRelocationScattered(uint64_t a1, _DWORD *a2)
{
  return *a2 >> 31;
}

uint64_t llvm::object::MachOObjectFile::getScatteredRelocationValue(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 4);
}

uint64_t llvm::object::MachOObjectFile::getScatteredRelocationType(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 3) & 0xF;
}

BOOL llvm::object::MachOObjectFile::getAnyRelocationPCRel(uint64_t a1, _DWORD *a2)
{
  if (*(_DWORD *)(a1 + 52) == 16777223 || (*a2 & 0x80000000) == 0)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 8);
    BOOL v4 = v3 > 0x13;
    int v5 = (1 << v3) & 0xAAC00;
    if (v4 || v5 == 0) {
      int v2 = HIBYTE(a2[1]) & 1;
    }
    else {
      int v2 = a2[1] & 0x80;
    }
  }
  else
  {
    int v2 = *a2 & 0x40000000;
  }
  return v2 != 0;
}

int8x16_t sub_1CCC644F0@<Q0>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 > a2 || a2 + 68 > v3 + *(void *)(a1 + 24)) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a3 + 4++*(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(a3 + 64) = *(_DWORD *)(a2 + 64);
  int8x16_t result = *(int8x16_t *)(a2 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a2;
  *(int8x16_t *)(a3 + ++*(_DWORD *)(this + 16) = result;
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  if (v7 <= 0x13 && ((1 << v7) & 0xAAC00) != 0)
  {
    int8x16_t result = vrev32q_s8(*(int8x16_t *)(a3 + 32));
    int8x16_t v8 = vrev32q_s8(*(int8x16_t *)(a3 + 48));
    *(int8x16_t *)(a3 + 32) = result;
    *(int8x16_t *)(a3 + 4++*(_DWORD *)(this + 8) = v8;
    *(_DWORD *)(a3 + 64) = bswap32(*(_DWORD *)(a3 + 64));
  }
  return result;
}

double sub_1CCC64584@<D0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 > (unint64_t)a2 || (unint64_t)(a2 + 5) > v3 + *(void *)(a1 + 24)) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v5 = a2[3];
  *(_OWORD *)(a3 + 32) = a2[2];
  *(_OWORD *)(a3 + 4++*(_DWORD *)(this + 8) = v5;
  *(_OWORD *)(a3 + 64) = a2[4];
  long long v6 = a2[1];
  *(_OWORD *)a3 = *a2;
  *(_OWORD *)(a3 + ++*(_DWORD *)(this + 16) = v6;
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  if (v7 <= 0x13 && ((1 << v7) & 0xAAC00) != 0)
  {
    int8x16_t v8 = vrev32q_s8(*(int8x16_t *)(a3 + 48));
    *(int8x16_t *)(a3 + 32) = vrev64q_s8(*(int8x16_t *)(a3 + 32));
    *(int8x16_t *)(a3 + 4++*(_DWORD *)(this + 8) = v8;
    *(int8x8_t *)&long long v6 = vrev32_s8(*(int8x8_t *)(a3 + 64));
    *(void *)(a3 + 64) = v6;
    *(_DWORD *)(a3 + 72) = bswap32(*(_DWORD *)(a3 + 72));
  }
  return *(double *)&v6;
}

double llvm::object::MachOObjectFile::getSection@<D0>(uint64_t a1@<X0>, void *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
    int v4 = 80;
  }
  else {
    int v4 = 68;
  }
  uint64_t v5 = 56;
  if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
    uint64_t v5 = 72;
  }
  *(void *)&double result = sub_1CCC644F0(a1, v5 + *a2 + (unint64_t)(v4 * a3), a4).u64[0];
  return result;
}

double llvm::object::MachOObjectFile::getSection64@<D0>(uint64_t a1@<X0>, void *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
    int v4 = 80;
  }
  else {
    int v4 = 68;
  }
  uint64_t v5 = 56;
  if ((*(_DWORD *)(a1 + 8) & 0xFFFFFFFE) == 0x12) {
    uint64_t v5 = 72;
  }
  return sub_1CCC64584(a1, (_OWORD *)(v5 + *a2 + (v4 * a3)), a4);
}

uint64_t llvm::object::MachOObjectFile::getLinkeditDataLoadCommand(uint64_t a1, _DWORD **a2)
{
  return sub_1CCC54354(a1, *a2);
}

uint64_t llvm::object::MachOObjectFile::getLinkerOptionLoadCommand(uint64_t a1, unsigned int **a2)
{
  int v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 16);
  BOOL v4 = (unint64_t)*a2 < v3 || (unint64_t)(*a2 + 3) > v3 + *(void *)(a1 + 24);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  unsigned int v5 = *v2;
  unsigned int v6 = v2[1];
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  BOOL v4 = v7 > 0x13;
  int v8 = (1 << v7) & 0xAAC00;
  BOOL v9 = v4 || v8 == 0;
  unsigned int v10 = bswap32(v5);
  unsigned int v11 = bswap32(v6);
  if (v9) {
    uint64_t v12 = v5;
  }
  else {
    uint64_t v12 = v10;
  }
  if (v9) {
    uint64_t v13 = v6;
  }
  else {
    uint64_t v13 = v11;
  }
  return v12 | (v13 << 32);
}

int8x16_t llvm::object::MachOObjectFile::getNoteLoadCommand@<Q0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *(void *)(a1 + 16);
  BOOL v5 = *a2 < v4 || *a2 + 40 > v4 + *(void *)(a1 + 24);
  if (v5) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  int8x16_t result = *(int8x16_t *)v3;
  long long v7 = *(_OWORD *)(v3 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v3;
  *(_OWORD *)(a3 + ++*(_DWORD *)(this + 16) = v7;
  *(void *)(a3 + 32) = *(void *)(v3 + 32);
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  BOOL v5 = v8 > 0x13;
  int v9 = (1 << v8) & 0xAAC00;
  if (!v5 && v9 != 0)
  {
    *(int8x8_t *)a3 = vrev32_s8(*(int8x8_t *)a3);
    int8x16_t result = vrev64q_s8(*(int8x16_t *)(a3 + 24));
    *(int8x16_t *)(a3 + 24) = result;
  }
  return result;
}

unint64_t llvm::object::MachOObjectFile::getBuildToolVersion(llvm::object::MachOObjectFile *this, unsigned int a2)
{
  unint64_t v2 = *(void *)(*((void *)this + 26) + 8 * a2);
  unint64_t v3 = *((void *)this + 2);
  BOOL v4 = v2 < v3 || v2 + 8 > v3 + *((void *)this + 3);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  LODWORD(v5) = *(_DWORD *)v2;
  LODWORD(v2) = *(_DWORD *)(v2 + 4);
  unsigned int v6 = *((_DWORD *)this + 2);
  BOOL v4 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  BOOL v8 = v4 || v7 == 0;
  unsigned int v9 = bswap32(v5);
  unsigned int v10 = bswap32(v2);
  if (v8) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = v9;
  }
  if (v8) {
    unint64_t v2 = v2;
  }
  else {
    unint64_t v2 = v10;
  }
  return v5 | (v2 << 32);
}

int8x16_t llvm::object::MachOObjectFile::getDyldInfoLoadCommand@<Q0>(uint64_t a1@<X0>, int8x16_t **a2@<X1>, int8x16_t *a3@<X8>)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *(void *)(a1 + 16);
  BOOL v5 = (unint64_t)*a2 < v4 || (unint64_t)&(*a2)[3] > v4 + *(void *)(a1 + 24);
  if (v5) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  int8x16_t v6 = v3[1];
  *a3 = *v3;
  a3[1] = v6;
  int8x16_t result = v3[2];
  a3[2] = result;
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  BOOL v5 = v8 > 0x13;
  int v9 = (1 << v8) & 0xAAC00;
  if (!v5 && v9 != 0)
  {
    int8x16_t v11 = vrev32q_s8(a3[1]);
    *a3 = vrev32q_s8(*a3);
    a3[1] = v11;
    int8x16_t result = vrev32q_s8(a3[2]);
    a3[2] = result;
  }
  return result;
}

uint64_t llvm::object::MachOObjectFile::getDylinkerCommand(uint64_t a1, unsigned int **a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 16);
  BOOL v4 = (unint64_t)*a2 < v3 || (unint64_t)(*a2 + 3) > v3 + *(void *)(a1 + 24);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  unsigned int v5 = *v2;
  unsigned int v6 = v2[1];
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  BOOL v4 = v7 > 0x13;
  int v8 = (1 << v7) & 0xAAC00;
  BOOL v9 = v4 || v8 == 0;
  unsigned int v10 = bswap32(v5);
  unsigned int v11 = bswap32(v6);
  if (v9) {
    uint64_t v12 = v5;
  }
  else {
    uint64_t v12 = v10;
  }
  if (v9) {
    uint64_t v13 = v6;
  }
  else {
    uint64_t v13 = v11;
  }
  return v12 | (v13 << 32);
}

double llvm::object::MachOObjectFile::getUuidCommand@<D0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, int8x8_t *a3@<X8>)
{
  unint64_t v3 = (long long *)*a2;
  unint64_t v4 = *(void *)(a1 + 16);
  BOOL v5 = *a2 < v4 || *a2 + 24 > v4 + *(void *)(a1 + 24);
  if (v5) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v6 = *v3;
  *(_OWORD *)a3->i8 = *v3;
  a3[2] = (int8x8_t)v3[1];
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  BOOL v5 = v7 > 0x13;
  int v8 = (1 << v7) & 0xAAC00;
  if (!v5 && v8 != 0)
  {
    *(int8x8_t *)&long long v6 = vrev32_s8(*a3);
    *a3 = (int8x8_t)v6;
  }
  return *(double *)&v6;
}

uint64_t llvm::object::MachOObjectFile::getRpathCommand(uint64_t a1, unsigned int **a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 16);
  BOOL v4 = (unint64_t)*a2 < v3 || (unint64_t)(*a2 + 3) > v3 + *(void *)(a1 + 24);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  unsigned int v5 = *v2;
  unsigned int v6 = v2[1];
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  BOOL v4 = v7 > 0x13;
  int v8 = (1 << v7) & 0xAAC00;
  BOOL v9 = v4 || v8 == 0;
  unsigned int v10 = bswap32(v5);
  unsigned int v11 = bswap32(v6);
  if (v9) {
    uint64_t v12 = v5;
  }
  else {
    uint64_t v12 = v10;
  }
  if (v9) {
    uint64_t v13 = v6;
  }
  else {
    uint64_t v13 = v11;
  }
  return v12 | (v13 << 32);
}

uint64_t llvm::object::MachOObjectFile::getSourceVersionCommand(uint64_t a1, unsigned int **a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 16);
  BOOL v4 = (unint64_t)*a2 < v3 || (unint64_t)(*a2 + 4) > v3 + *(void *)(a1 + 24);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  unsigned int v5 = *v2;
  unsigned int v6 = v2[1];
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  BOOL v4 = v7 > 0x13;
  int v8 = (1 << v7) & 0xAAC00;
  BOOL v9 = v4 || v8 == 0;
  unsigned int v10 = bswap32(v5);
  unsigned int v11 = bswap32(v6);
  if (v9) {
    uint64_t v12 = v5;
  }
  else {
    uint64_t v12 = v10;
  }
  if (v9) {
    uint64_t v13 = v6;
  }
  else {
    uint64_t v13 = v11;
  }
  return v12 | (v13 << 32);
}

int8x16_t llvm::object::MachOObjectFile::getEntryPointCommand@<Q0>(uint64_t a1@<X0>, int8x16_t **a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *(void *)(a1 + 16);
  BOOL v5 = (unint64_t)*a2 < v4 || (unint64_t)&(*a2)[1].u64[1] > v4 + *(void *)(a1 + 24);
  if (v5) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  int8x16_t result = *v3;
  *(int8x16_t *)a3 = *v3;
  *(void *)(a3 + ++*(_DWORD *)(this + 16) = v3[1].i64[0];
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  BOOL v5 = v7 > 0x13;
  int v8 = (1 << v7) & 0xAAC00;
  if (!v5 && v8 != 0)
  {
    *(int8x8_t *)a3 = vrev32_s8(*(int8x8_t *)a3);
    int8x16_t result = vrev64q_s8(*(int8x16_t *)(a3 + 8));
    *(int8x16_t *)(a3 + ++*(_DWORD *)(this + 8) = result;
  }
  return result;
}

double llvm::object::MachOObjectFile::getEncryptionInfoCommand@<D0>(uint64_t a1@<X0>, int8x16_t **a2@<X1>, int8x16_t *a3@<X8>)
{
  *(void *)&double result = sub_1CCC52F18(a3, a1, *a2).u64[0];
  return result;
}

double llvm::object::MachOObjectFile::getEncryptionInfoCommand64@<D0>(uint64_t a1@<X0>, long long **a2@<X1>, uint64_t a3@<X8>)
{
  return sub_1CCC530A4(a3, a1, *a2);
}

uint64_t llvm::object::MachOObjectFile::getSubFrameworkCommand(uint64_t a1, _DWORD **a2)
{
  return sub_1CCC5312C(a1, *a2);
}

uint64_t llvm::object::MachOObjectFile::getSubUmbrellaCommand(uint64_t a1, _DWORD **a2)
{
  return sub_1CCC5312C(a1, *a2);
}

uint64_t llvm::object::MachOObjectFile::getSubLibraryCommand(uint64_t a1, _DWORD **a2)
{
  return sub_1CCC5312C(a1, *a2);
}

uint64_t llvm::object::MachOObjectFile::getSubClientCommand(uint64_t a1, _DWORD **a2)
{
  return sub_1CCC5312C(a1, *a2);
}

double llvm::object::MachOObjectFile::getRoutinesCommand@<D0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = (long long *)*a2;
  unint64_t v4 = *(void *)(a1 + 16);
  BOOL v5 = *a2 < v4 || *a2 + 40 > v4 + *(void *)(a1 + 24);
  if (v5) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v6 = *v3;
  long long v7 = v3[1];
  *(_OWORD *)a3 = *v3;
  *(_OWORD *)(a3 + ++*(_DWORD *)(this + 16) = v7;
  *(void *)(a3 + 32) = *((void *)v3 + 4);
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  BOOL v5 = v8 > 0x13;
  int v9 = (1 << v8) & 0xAAC00;
  if (!v5 && v9 != 0)
  {
    int8x16_t v11 = vrev32q_s8(*(int8x16_t *)(a3 + 16));
    *(int8x16_t *)a3 = vrev32q_s8(*(int8x16_t *)a3);
    *(int8x16_t *)(a3 + ++*(_DWORD *)(this + 16) = v11;
    *(int8x8_t *)&long long v6 = vrev32_s8(*(int8x8_t *)(a3 + 32));
    *(void *)(a3 + 32) = v6;
  }
  return *(double *)&v6;
}

int8x16_t llvm::object::MachOObjectFile::getRoutinesCommand64@<Q0>(uint64_t a1@<X0>, unint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *(void *)(a1 + 16);
  if (*a2 < v4 || *a2 + 72 > v4 + *(void *)(a1 + 24)) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  long long v6 = *(_OWORD *)(v3 + 48);
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v3 + 32);
  *(_OWORD *)(a3 + 4++*(_DWORD *)(this + 8) = v6;
  *(void *)(a3 + 64) = *(void *)(v3 + 64);
  int8x16_t result = *(int8x16_t *)(v3 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v3;
  *(int8x16_t *)(a3 + ++*(_DWORD *)(this + 16) = result;
  unsigned int v8 = *(_DWORD *)(a1 + 8);
  if (v8 <= 0x13 && ((1 << v8) & 0xAAC00) != 0)
  {
    *(int8x8_t *)a3 = vrev32_s8(*(int8x8_t *)a3);
    *(int8x16_t *)(a3 + ++*(_DWORD *)(this + 8) = vrev64q_s8(*(int8x16_t *)(a3 + 8));
    *(int8x16_t *)(a3 + 24) = vrev64q_s8(*(int8x16_t *)(a3 + 24));
    *(int8x16_t *)(a3 + 40) = vrev64q_s8(*(int8x16_t *)(a3 + 40));
    int8x16_t result = vrev64q_s8(*(int8x16_t *)(a3 + 56));
    *(int8x16_t *)(a3 + 56) = result;
  }
  return result;
}

unint64_t llvm::object::MachOObjectFile::getThreadCommand(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 16);
  BOOL v4 = *a2 < v3 || *a2 + 8 > v3 + *(void *)(a1 + 24);
  if (v4) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  LODWORD(v5) = *(_DWORD *)v2;
  LODWORD(v2) = *(_DWORD *)(v2 + 4);
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  BOOL v4 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  BOOL v8 = v4 || v7 == 0;
  unsigned int v9 = bswap32(v5);
  unsigned int v10 = bswap32(v2);
  if (v8) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = v9;
  }
  if (v8) {
    unint64_t v2 = v2;
  }
  else {
    unint64_t v2 = v10;
  }
  return v5 | (v2 << 32);
}

unint64_t sub_1CCC64DBC(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(void *)(a1 + 16);
  BOOL v3 = v2 > (unint64_t)a2 || (unint64_t)(a2 + 1) > v2 + *(void *)(a1 + 24);
  if (v3) {
    llvm::report_fatal_error((llvm *)"Malformed MachO file.", (const llvm::Twine *)1);
  }
  uint64_t v4 = *a2;
  unint64_t v5 = HIDWORD(*a2);
  unint64_t v6 = HIWORD(*a2);
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  BOOL v3 = v7 > 0x13;
  int v8 = (1 << v7) & 0xAAC00;
  BOOL v9 = v3 || v8 == 0;
  unsigned int v10 = bswap32(v4);
  unsigned int v11 = bswap32(v5) >> 16;
  unsigned int v12 = __rev16(v6);
  if (v9) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = v10;
  }
  if (v9)
  {
    unint64_t v6 = v6;
  }
  else
  {
    LOWORD(v5) = v11;
    unint64_t v6 = v12;
  }
  return ((unint64_t)(unsigned __int16)v5 << 32) | (v6 << 48) | v4;
}

uint64_t llvm::object::MachOObjectFile::getIndirectSymbolTableEntry(llvm::object::MachOObjectFile *this, const dysymtab_command *a2, unsigned int a3)
{
  return sub_1CCC5CCA4((uint64_t)this, (unsigned int *)(*((void *)this + 2) + a2->indirectsymoff + 4 * a3));
}

unint64_t llvm::object::MachOObjectFile::getDataInCodeTableEntry(llvm::object::MachOObjectFile *this, unsigned int a2, unsigned int a3)
{
  return sub_1CCC64DBC((uint64_t)this, (uint64_t *)(*((void *)this + 2) + 8 * a3 + a2));
}

uint64_t llvm::object::MachOObjectFile::getLinkOptHintsLoadCommand(llvm::object::MachOObjectFile *this)
{
  uint64_t v1 = (_DWORD *)*((void *)this + 37);
  if (v1) {
    return sub_1CCC54354((uint64_t)this, v1);
  }
  else {
    return 0x100000002ELL;
  }
}

int8x16_t *sub_1CCC64EA4(int8x16_t *result, uint64_t a2, int8x16_t *a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > (unint64_t)a3 || (unint64_t)&a3[3] > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    unsigned int v11 = "Structure read out-of-range";
    __int16 v12 = 259;
    sub_1CCC51CE4((uint64_t)&v13, (uint64_t *)&v11);
  }
  int8x16_t v5 = *a3;
  int8x16_t v6 = a3[1];
  int8x16_t v7 = a3[2];
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v8 > 0x13;
  int v9 = (1 << v8) & 0xAAC00;
  if (!v4 && v9 != 0)
  {
    int8x16_t v5 = vrev32q_s8(v5);
    int8x16_t v6 = vrev32q_s8(v6);
    int8x16_t v7 = vrev32q_s8(v7);
  }
  result[3].i8[0] &= ~1u;
  *int8x16_t result = v5;
  result[1] = v6;
  result[2] = v7;
  return result;
}

uint64_t llvm::object::MachOObjectFile::getChainedFixupsHeader@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *(int8x16_t **)(this + 328);
  if (!v3) {
    goto LABEL_7;
  }
  uint64_t v4 = this;
  this = (uint64_t)sub_1CCC6517C(&v26, this, v3);
  if (v27)
  {
    uint64_t v9 = v26.i64[0];
LABEL_10:
    *(unsigned char *)(a2 + 32) |= 1u;
    *(void *)a2 = v9;
    return this;
  }
  uint64_t v5 = v26.u32[2];
  if (!v26.i32[2])
  {
LABEL_7:
    *(unsigned char *)(a2 + 32) &= ~1u;
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 2++*(_DWORD *)(this + 8) = 0;
    return this;
  }
  __int32 v6 = v26.i32[3];
  this = sub_1CCC65230((uint64_t)v22, v4, *(void *)(v4 + 16) + v26.u32[2]);
  if (v25)
  {
    uint64_t v9 = v22[0];
    goto LABEL_10;
  }
  unint64_t v7 = LODWORD(v22[0]);
  if (LODWORD(v22[0]))
  {
    unsigned int v8 = "bad chained fixups: unknown version: ";
LABEL_14:
    uint64_t v19 = v8;
    unint64_t v20 = v7;
    __int16 v11 = 2051;
    goto LABEL_15;
  }
  uint64_t v10 = v24;
  unint64_t v7 = v24;
  if ((v24 - 4) <= 0xFFFFFFFC)
  {
    unsigned int v8 = "bad chained fixups: unknown imports format: ";
    goto LABEL_14;
  }
  int v12 = HIDWORD(v22[0]);
  if (HIDWORD(v22[0]) <= 0x1B)
  {
    v16[0] = "bad chained fixups: image starts offset ";
    int v17 = (const char *)HIDWORD(v22[0]);
    __int16 v18 = 2051;
    uint64_t v19 = (const char *)v16;
    unint64_t v20 = (unint64_t)" overlaps with chained fixups header";
    __int16 v11 = 770;
    goto LABEL_15;
  }
  if (v5 + (unint64_t)HIDWORD(v22[0]) + 8 > (v6 + v5))
  {
    uint64_t v13 = v5 + HIDWORD(v22[0]) + 8;
    v14[0] = "bad chained fixups: image starts end ";
    _OWORD v14[2] = &v13;
    __int16 v15 = 3075;
    v16[0] = v14;
    int v17 = " extends past end ";
    __int16 v18 = 770;
    uint64_t v19 = (const char *)v16;
    unint64_t v20 = (v6 + v5);
    __int16 v11 = 2050;
LABEL_15:
    __int16 v21 = v11;
    sub_1CCC51CE4(a2, (uint64_t *)&v19);
  }
  *(unsigned char *)(a2 + 32) &= ~1u;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = v12;
  *(void *)(a2 + ++*(_DWORD *)(this + 8) = v22[1];
  *(_DWORD *)(a2 + ++*(_DWORD *)(this + 16) = v23;
  *(void *)(a2 + 20) = v10;
  *(unsigned char *)(a2 + 2++*(_DWORD *)(this + 8) = 1;
  return this;
}

int8x16_t *sub_1CCC6517C(int8x16_t *result, uint64_t a2, int8x16_t *a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > (unint64_t)a3 || (unint64_t)&a3[1] > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v9 = "Structure read out-of-range";
    __int16 v10 = 259;
    sub_1CCC51CE4((uint64_t)&v11, (uint64_t *)&v9);
  }
  int8x16_t v5 = *a3;
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  if (!v4 && v7 != 0) {
    int8x16_t v5 = vrev32q_s8(v5);
  }
  result[1].i8[0] &= ~1u;
  *int8x16_t result = v5;
  return result;
}

uint64_t sub_1CCC65230(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > a3 || a3 + 28 > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v11 = "Structure read out-of-range";
    __int16 v12 = 259;
    sub_1CCC51CE4((uint64_t)&v13, (uint64_t *)&v11);
  }
  int8x16_t v5 = *(int8x16_t *)a3;
  int8x8_t v6 = *(int8x8_t *)(a3 + 16);
  unsigned int v7 = *(_DWORD *)(a3 + 24);
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v8 > 0x13;
  int v9 = (1 << v8) & 0xAAC00;
  if (!v4 && v9 != 0)
  {
    int8x16_t v5 = vrev32q_s8(v5);
    int8x8_t v6 = vrev32_s8(v6);
    unsigned int v7 = bswap32(v7);
  }
  *(unsigned char *)(result + 32) &= ~1u;
  *(int8x16_t *)int8x16_t result = v5;
  *(int8x8_t *)(result + ++*(_DWORD *)(this + 16) = v6;
  *(_DWORD *)(result + 24) = v7;
  return result;
}

void llvm::object::ChainedFixupsInSegment::walkFixupChain(llvm::object::ChainedFixupsInSegment *this@<X0>, const llvm::object::MachOObjectFile *a2@<X1>, unsigned int a3@<W2>, unsigned int a4@<W3>, unsigned int a5@<W4>, unint64_t *a6@<X8>)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  for (unint64_t i = a5 + a4 * (unint64_t)a3 + *((void *)this + 2); ; i += v14 * (unint64_t)v11)
  {
    int v9 = 1 << *(_WORD *)this;
    if ((v9 & 0x5FC) != 0)
    {
      int v10 = 4;
LABEL_5:
      unsigned int v11 = v10;
      switch(*(_WORD *)this)
      {
        case 1:
        case 7:
        case 9:
        case 0xA:
        case 0xC:
          sub_1CCC6583C((uint64_t)&v37, (uint64_t)a2, (unint64_t *)(*((void *)a2 + 2) + i));
          if (v38) {
            goto LABEL_43;
          }
          unint64_t v12 = v37 & 0xC000000000000000;
          unint64_t v13 = v37 >> 51;
          if (v37 >> 62) {
            unint64_t v13 = 0;
          }
          if (v12 == 0x4000000000000000) {
            unint64_t v13 = (v37 >> 51) & 0x7FF;
          }
          if (v12 == 0x8000000000000000) {
            unint64_t v13 = (v37 >> 51) & 0x7FF;
          }
          if (v37 >> 62 == 3) {
            unint64_t v14 = (v37 >> 51) & 0x7FF;
          }
          else {
            unint64_t v14 = v13;
          }
          break;
        case 2:
        case 6:
        case 8:
        case 0xB:
          goto LABEL_16;
        case 3:
          sub_1CCC658EC((uint64_t)&v37, (uint64_t)a2, (unsigned int *)(*((void *)a2 + 2) + i));
          if (v38) {
            goto LABEL_43;
          }
          unint64_t v14 = ((unint64_t)v37 >> 26) & 0x1F;
          break;
        case 4:
          sub_1CCC658EC((uint64_t)&v37, (uint64_t)a2, (unsigned int *)(*((void *)a2 + 2) + i));
          if (v38) {
            goto LABEL_43;
          }
          unint64_t v14 = (unint64_t)v37 >> 30;
          break;
        case 5:
          sub_1CCC658EC((uint64_t)&v37, (uint64_t)a2, (unsigned int *)(*((void *)a2 + 2) + i));
          if (v38) {
            goto LABEL_43;
          }
          unint64_t v14 = (unint64_t)v37 >> 26;
          break;
        default:
          __int16 v15 = (unint64_t *)*((void *)this + 5);
          goto LABEL_45;
      }
      goto LABEL_18;
    }
    int v10 = 8;
    unsigned int v11 = 1;
    if ((v9 & 0x1202) != 0) {
      goto LABEL_5;
    }
LABEL_16:
    sub_1CCC6583C((uint64_t)&v37, (uint64_t)a2, (unint64_t *)(*((void *)a2 + 2) + i));
    if (v38)
    {
LABEL_43:
      *a6 = v37;
      return;
    }
    unint64_t v14 = (v37 >> 51) & 0xFFF;
LABEL_18:
    __int16 v15 = (unint64_t *)*((void *)this + 5);
    if (!v14) {
      break;
    }
    unint64_t v16 = *((void *)this + 6);
    if ((unint64_t)v15 >= v16)
    {
      __int16 v18 = (unint64_t *)*((void *)this + 4);
      uint64_t v19 = v15 - v18;
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) >> 61) {
        goto LABEL_64;
      }
      uint64_t v21 = v16 - (void)v18;
      if (v21 >> 2 > v20) {
        unint64_t v20 = v21 >> 2;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        if (v22 >> 61) {
          goto LABEL_65;
        }
        int v23 = (char *)operator new(8 * v22);
      }
      else
      {
        int v23 = 0;
      }
      uint64_t v24 = (unint64_t *)&v23[8 * v19];
      *uint64_t v24 = i;
      int v17 = v24 + 1;
      while (v15 != v18)
      {
        unint64_t v25 = *--v15;
        *--uint64_t v24 = v25;
      }
      *((void *)this + 4) = v24;
      *((void *)this + 5) = v17;
      *((void *)this + 6) = &v23[8 * v22];
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      *__int16 v15 = i;
      int v17 = v15 + 1;
    }
    *((void *)this + 5) = v17;
  }
LABEL_45:
  unint64_t v26 = *((void *)this + 6);
  if ((unint64_t)v15 >= v26)
  {
    uint64_t v28 = (unint64_t *)*((void *)this + 4);
    uint64_t v29 = v15 - v28;
    unint64_t v30 = v29 + 1;
    if ((unint64_t)(v29 + 1) >> 61) {
LABEL_64:
    }
      abort();
    uint64_t v31 = v26 - (void)v28;
    if (v31 >> 2 > v30) {
      unint64_t v30 = v31 >> 2;
    }
    if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v32 = v30;
    }
    if (v32)
    {
      if (v32 >> 61) {
LABEL_65:
      }
        sub_1CB833614();
      long long v33 = (char *)operator new(8 * v32);
    }
    else
    {
      long long v33 = 0;
    }
    uint64_t v34 = (unint64_t *)&v33[8 * v29];
    *uint64_t v34 = i;
    char v27 = v34 + 1;
    while (v15 != v28)
    {
      unint64_t v35 = *--v15;
      *--uint64_t v34 = v35;
    }
    *((void *)this + 4) = v34;
    *((void *)this + 5) = v27;
    *((void *)this + 6) = &v33[8 * v32];
    if (v28) {
      operator delete(v28);
    }
  }
  else
  {
    *__int16 v15 = i;
    char v27 = v15 + 1;
  }
  *((void *)this + 5) = v27;
  *a6 = 0;
}

uint64_t sub_1CCC65698(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > a3 || a3 + 80 > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    unint64_t v14 = "Structure read out-of-range";
    __int16 v15 = 259;
    sub_1CCC51CE4((uint64_t)&v16, (uint64_t *)&v14);
  }
  int8x16_t v6 = *(int8x16_t *)(a3 + 32);
  int8x16_t v5 = *(int8x16_t *)(a3 + 48);
  int8x8_t v7 = *(int8x8_t *)(a3 + 64);
  unsigned int v9 = *(_DWORD *)(a3 + 72);
  int v8 = *(_DWORD *)(a3 + 76);
  unsigned int v10 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v10 > 0x13;
  int v11 = (1 << v10) & 0xAAC00;
  if (!v4 && v11 != 0)
  {
    int8x16_t v6 = vrev64q_s8(v6);
    int8x16_t v5 = vrev32q_s8(v5);
    int8x8_t v7 = vrev32_s8(v7);
    unsigned int v9 = bswap32(v9);
  }
  *(unsigned char *)(result + 80) &= ~1u;
  long long v13 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)int8x16_t result = *(_OWORD *)a3;
  *(_OWORD *)(result + ++*(_DWORD *)(this + 16) = v13;
  *(int8x16_t *)(result + 32) = v6;
  *(int8x16_t *)(result + 4++*(_DWORD *)(this + 8) = v5;
  *(int8x8_t *)(result + 64) = v7;
  *(_DWORD *)(result + 72) = v9;
  *(_DWORD *)(result + 76) = v8;
  return result;
}

uint64_t sub_1CCC65770(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > a3 || a3 + 68 > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    unint64_t v12 = "Structure read out-of-range";
    __int16 v13 = 259;
    sub_1CCC51CE4((uint64_t)&v14, (uint64_t *)&v12);
  }
  int8x16_t v5 = *(int8x16_t *)(a3 + 32);
  int8x16_t v6 = *(int8x16_t *)(a3 + 48);
  unsigned int v7 = *(_DWORD *)(a3 + 64);
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v8 > 0x13;
  int v9 = (1 << v8) & 0xAAC00;
  if (!v4 && v9 != 0)
  {
    int8x16_t v5 = vrev32q_s8(v5);
    int8x16_t v6 = vrev32q_s8(v6);
    unsigned int v7 = bswap32(v7);
  }
  *(unsigned char *)(result + 72) &= ~1u;
  long long v11 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)int8x16_t result = *(_OWORD *)a3;
  *(_OWORD *)(result + ++*(_DWORD *)(this + 16) = v11;
  *(int8x16_t *)(result + 32) = v5;
  *(int8x16_t *)(result + 4++*(_DWORD *)(this + 8) = v6;
  *(_DWORD *)(result + 64) = v7;
  return result;
}

uint64_t sub_1CCC6583C(uint64_t result, uint64_t a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > (unint64_t)a3 || (unint64_t)(a3 + 1) > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    unsigned int v10 = "Structure read out-of-range";
    __int16 v11 = 259;
    sub_1CCC51CE4((uint64_t)&v12, (uint64_t *)&v10);
  }
  unint64_t v5 = *a3;
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  BOOL v8 = v4 || v7 == 0;
  unint64_t v9 = bswap64(v5);
  if (!v8) {
    unint64_t v5 = v9;
  }
  *(unsigned char *)(result + 8) &= ~1u;
  *(void *)int8x16_t result = v5;
  return result;
}

uint64_t sub_1CCC658EC(uint64_t result, uint64_t a2, unsigned int *a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > (unint64_t)a3 || (unint64_t)(a3 + 1) > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    unsigned int v10 = "Structure read out-of-range";
    __int16 v11 = 259;
    sub_1CCC51CE4((uint64_t)&v12, (uint64_t *)&v10);
  }
  unsigned int v5 = *a3;
  unsigned int v6 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v6 > 0x13;
  int v7 = (1 << v6) & 0xAAC00;
  BOOL v8 = v4 || v7 == 0;
  unsigned int v9 = bswap32(v5);
  if (!v8) {
    unsigned int v5 = v9;
  }
  *(unsigned char *)(result + 8) &= ~1u;
  *(_DWORD *)int8x16_t result = v5;
  return result;
}

void llvm::object::MachOObjectFile::getFunctionStarts(llvm::object::MachOObjectFile *this@<X0>, void *a2@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (int8x16_t *)*((void *)this + 40);
  if (v3)
  {
    sub_1CCC6517C(&v8, (uint64_t)this, v3);
    if (v9)
    {
      *a2 = a2 + 2;
      a2[1] = 0x600000000;
      if (v8.i64[0]) {
        (*(void (**)(uint64_t))(*(void *)v8.i64[0] + 8))(v8.i64[0]);
      }
    }
    else
    {
      unsigned int v5 = v7;
      uint64_t v6 = 0x800000000;
      llvm::object::MachOObjectFile::ReadULEB128s((uint64_t)this, v8.u32[2], (uint64_t)&v5);
      *a2 = a2 + 2;
      a2[1] = 0x600000000;
      if (v6) {
        sub_1CD41C56C((uint64_t)a2, (uint64_t)&v5);
      }
      if (v5 != v7) {
        free(v5);
      }
    }
  }
  else
  {
    *a2 = a2 + 2;
    a2[1] = 0x600000000;
  }
}

uint64_t llvm::object::MachOObjectFile::ReadULEB128s(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v9 = *(_OWORD *)(a1 + 16);
  __int16 v10 = 1;
  uint64_t v8 = a2;
  uint64_t result = llvm::DataExtractor::getULEB128((uint64_t *)&v9, &v8, 0);
  if (result)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    do
    {
      unint64_t v7 = *(unsigned int *)(a3 + 8);
      if (v7 >= *(unsigned int *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v6 += v5;
      *(void *)(*(void *)a3 + 8 * v7) = v6;
      ++*(_DWORD *)(a3 + 8);
      uint64_t result = llvm::DataExtractor::getULEB128((uint64_t *)&v9, &v8, 0);
      uint64_t v5 = result;
    }
    while (result);
  }
  return result;
}

uint64_t llvm::object::MachOObjectFile::getUuid(llvm::object::MachOObjectFile *this)
{
  uint64_t v1 = *((void *)this + 42);
  BOOL v2 = v1 == 0;
  uint64_t v3 = v1 + 8;
  if (v2) {
    return 0;
  }
  else {
    return v3;
  }
}

void llvm::object::ObjectFile::createMachOObjectFile(uint64_t a1)
{
  if (*(void *)(a1 + 8) >= 4uLL)
  {
    uint64_t v1 = *(_DWORD **)a1;
    if (**(_DWORD **)a1 == -822415874 || *v1 == -17958194 || *v1 == -805638658 || *v1 == -17958193) {
      llvm::object::MachOObjectFile::create();
    }
  }
  sub_1CCC16E40();
}

void llvm::object::MachOObjectFile::getObjcSymbols(llvm::object::MachOObjectFile *this@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, int64x2_t *a4@<X8>)
{
  uint64_t v174 = *MEMORY[0x1E4F143B8];
  if ((*((_DWORD *)this + 2) & 0xFFFFFFFE) != 0x12)
  {
    if (*((_DWORD *)this + 13) == 12 || (uint64_t v13 = sub_1CCC68880(this, "__OBJC", "__module_info"), !(v14 | v13)))
    {
      sub_1CCC66DB4((uint64_t)a4, this, a2, a3);
      return;
    }
    uint64_t v162 = 0;
    unsigned int v161 = 0;
    uint64_t v157 = 0;
    uint64_t v158 = 0;
    int64x2_t v169 = 0uLL;
    uint64_t v170 = 0;
    sub_1CCC68E3C((uint64_t)&v147, (uint64_t)this, a2, a3);
    uint64_t v15 = sub_1CCC68880(this, "__OBJC", "__module_info");
    unint64_t __dst = v15;
    uint64_t v160 = v16;
    if (!(v16 | v15)
      || (unint64_t v17 = v15, v18 = v16, !(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v16 + 160))(v16, v15)))
    {
LABEL_95:
      a4[1].i8[8] &= ~1u;
      *a4 = v169;
      a4[1].i64[0] = v170;
      int64x2_t v169 = 0uLL;
      uint64_t v170 = 0;
      goto LABEL_96;
    }
    unint64_t v19 = 0;
    int v20 = 0;
    while (1)
    {
      int v21 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v18 + 144))(v18, v17);
      uint64_t v22 = sub_1CCC6B2B4((v21 + v20), (_DWORD *)&v162 + 1, &v161, &__dst, &v147, 1);
      if (!v22) {
        goto LABEL_95;
      }
      if (v161 <= 0xF)
      {
        v140[0] = "objc_module_t struct extends past end of ";
        unsigned int v141 = "(__OBJC,__module_info) section at address: 0x";
        __int16 v143 = 771;
        v137[0] = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v160 + 144))(v160, __dst) + v19;
        v144[0] = (uint64_t)v140;
        int v145 = (const char *)v137;
        __int16 v146 = 3586;
        sub_1CCC51CE4((uint64_t)a4, v144);
      }
      unsigned int v23 = *(_DWORD *)(v22 + 12);
      unsigned int v24 = *((_DWORD *)this + 2);
      unsigned int v25 = bswap32(v23);
      if (((1 << v24) & 0xAAC00) == 0) {
        unsigned int v25 = *(_DWORD *)(v22 + 12);
      }
      if (v24 <= 0x13) {
        unint64_t v26 = v25;
      }
      else {
        unint64_t v26 = v23;
      }
      uint64_t v27 = sub_1CCC6B2B4(v26, &v162, &v161, &v157, &v147, 1);
      if (v26) {
        BOOL v28 = v27 == 0;
      }
      else {
        BOOL v28 = 1;
      }
      if (!v28)
      {
        if (v161 <= 0xB)
        {
          unsigned int v116 = v157;
          (*(void (**)(std::string **__return_ptr))(*(void *)v158 + 136))(&v167);
          if ((BYTE8(v168) & 1) == 0)
          {
            uint64_t v117 = *(void *)(*((void *)this + 10) + 8 * v116);
            __int16 v118 = (const char *)(v117 + 16);
            if (*(unsigned char *)(v117 + 31)) {
              size_t v119 = 16;
            }
            else {
              size_t v119 = strlen(v118);
            }
            __int16 v166 = 1283;
            BOOL v163 = (std::string *)"objc_symtab_t struct extends past end of (";
            *((void *)&v164 + 1) = v118;
            size_t v165 = v119;
            v130[0] = &v163;
            unsigned int v131 = ",";
            __int16 v132 = 770;
            v133[0] = v130;
            uint64_t v134 = (const char *)v167;
            size_t v135 = v168;
            __int16 v136 = 1282;
            v137[0] = v133;
            uint64_t v138 = ") section at address: ";
            __int16 v139 = 770;
            v140[0] = v137;
            unsigned int v141 = "0x";
            __int16 v143 = 770;
            uint64_t v120 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v160 + 144))(v160, __dst);
            unint64_t v129 = (std::string *)(v120 + HIDWORD(v162));
            v144[0] = (uint64_t)v140;
            int v145 = (const char *)&v129;
            __int16 v146 = 3586;
            sub_1CCC51CE4((uint64_t)a4, v144);
          }
          uint64_t v121 = (uint64_t)v167;
          uint64_t v167 = 0;
          goto LABEL_189;
        }
        unint64_t v128 = v161 - 12;
        uint64_t v29 = v27 + 12;
        if (v161 == 12) {
          uint64_t v29 = 0;
        }
        int v124 = v19;
        char v126 = (unsigned int *)v29;
        unsigned int v30 = *((_DWORD *)this + 2);
        unsigned int v31 = __rev16(*(unsigned __int16 *)(v27 + 8));
        unsigned int v32 = __rev16(*(unsigned __int16 *)(v27 + 10));
        if (((1 << v30) & 0xAAC00) == 0)
        {
          unsigned int v31 = *(unsigned __int16 *)(v27 + 8);
          unsigned int v32 = *(unsigned __int16 *)(v27 + 10);
        }
        if (v30 <= 0x13) {
          uint64_t v33 = v31;
        }
        else {
          uint64_t v33 = *(unsigned __int16 *)(v27 + 8);
        }
        if (v30 <= 0x13) {
          uint64_t v34 = v32;
        }
        else {
          uint64_t v34 = *(unsigned __int16 *)(v27 + 10);
        }
        if (v33)
        {
          unint64_t v35 = v126;
          uint64_t v36 = v128 >> 2;
          uint64_t v37 = v33;
          while (v36)
          {
            unsigned int v38 = *v35;
            unsigned int v39 = *((_DWORD *)this + 2);
            BOOL v40 = v39 > 0x13;
            int v41 = (1 << v39) & 0xAAC00;
            BOOL v42 = v40 || v41 == 0;
            unsigned int v43 = bswap32(v38);
            if (v42) {
              unint64_t v44 = v38;
            }
            else {
              unint64_t v44 = v43;
            }
            char v153 = 0;
            uint64_t v45 = sub_1CCC6B2B4(v44, &v162, &v161, &v157, &v147, 1);
            if (v45)
            {
              if (v161 <= 0x27)
              {
                unsigned int v108 = v157;
                (*(void (**)(std::string **__return_ptr))(*(void *)v158 + 136))(&v163);
                if (BYTE8(v164)) {
                  goto LABEL_188;
                }
                uint64_t v101 = v163;
                uint64_t v102 = v164;
                uint64_t v109 = *(void *)(*((void *)this + 10) + 8 * v108);
                char v104 = (const char *)(v109 + 16);
                if (*(unsigned char *)(v109 + 31)) {
                  size_t v105 = 16;
                }
                else {
                  size_t v105 = strlen(v104);
                }
                unint64_t v112 = "objc_class_t struct extends past end ";
                unint64_t v115 = "of (";
                goto LABEL_184;
              }
              long long v171 = *(_OWORD *)v45;
              long long v172 = *(_OWORD *)(v45 + 16);
              uint64_t v173 = *(void *)(v45 + 32);
              sub_1CCC6EBD0(v144, v44, (uint64_t)&v171, &v147, &v169);
              uint64_t v46 = v144[0];
              if (v144[0]) {
                goto LABEL_152;
              }
            }
            if (v172)
            {
              char v153 = 1;
              uint64_t v47 = sub_1CCC6B2B4(v171, &v162, &v161, &v157, &v147, 1);
              if (v47)
              {
                if (v161 <= 0x27)
                {
                  unsigned int v113 = v157;
                  (*(void (**)(std::string **__return_ptr))(*(void *)v158 + 136))(&v163);
                  if (BYTE8(v164)) {
                    goto LABEL_188;
                  }
                  uint64_t v101 = v163;
                  uint64_t v102 = v164;
                  uint64_t v114 = *(void *)(*((void *)this + 10) + 8 * v113);
                  char v104 = (const char *)(v114 + 16);
                  if (*(unsigned char *)(v114 + 31)) {
                    size_t v105 = 16;
                  }
                  else {
                    size_t v105 = strlen(v104);
                  }
                  unint64_t v112 = "objc_class_t struct extends past ";
LABEL_183:
                  unint64_t v115 = "end of (";
LABEL_184:
                  v130[0] = v112;
                  unsigned int v131 = v115;
                  __int16 v132 = 771;
                  v133[0] = v130;
                  uint64_t v134 = v104;
                  size_t v135 = v105;
                  __int16 v136 = 1282;
                  v137[0] = v133;
                  uint64_t v138 = ",";
                  __int16 v139 = 770;
                  v140[0] = v137;
                  unsigned int v141 = (const char *)v101;
                  uint64_t v142 = v102;
                  __int16 v143 = 1282;
                  v144[0] = (uint64_t)v140;
                  int v145 = ") section";
                  __int16 v146 = 770;
                  sub_1CCC51CE4((uint64_t)a4, v144);
                }
                long long v171 = *(_OWORD *)v47;
                long long v172 = *(_OWORD *)(v47 + 16);
                uint64_t v173 = *(void *)(v47 + 32);
                sub_1CCC6EBD0(v144, v171, (uint64_t)&v171, &v147, &v169);
                uint64_t v46 = v144[0];
                if (v144[0])
                {
LABEL_152:
                  a4[1].i8[8] |= 1u;
                  a4->i64[0] = v46;
LABEL_96:
                  long long v71 = v156;
                  unsigned __int8 v156 = 0;
                  if (v71)
                  {
                    MEMORY[0x1D25D9CD0](*v71, 8);
                    MEMORY[0x1D25D9CE0](v71, 0x1020C405AF6BDC9);
                  }
                  long long v72 = v155;
                  int v155 = 0;
                  if (v72)
                  {
                    MEMORY[0x1D25D9CD0](*v72, 8);
                    MEMORY[0x1D25D9CE0](v72, 0x1020C405AF6BDC9);
                  }
                  uint64_t v73 = v154;
                  unsigned int v154 = 0;
                  if (v73)
                  {
                    MEMORY[0x1D25D9CD0](*v73, 8);
                    MEMORY[0x1D25D9CE0](v73, 0x1020C405AF6BDC9);
                  }
                  if (__p)
                  {
                    int v149 = __p;
                    operator delete(__p);
                  }
                  char v74 = (void **)&v169;
LABEL_149:
                  uint64_t v147 = v74;
                  sub_1CC658304(&v147);
                  return;
                }
              }
            }
            ++v35;
            --v36;
            if (!--v37) {
              goto LABEL_59;
            }
          }
          unsigned int v100 = v157;
          (*(void (**)(std::string **__return_ptr))(*(void *)v158 + 136))(&v163);
          if (BYTE8(v164)) {
            goto LABEL_188;
          }
          uint64_t v101 = v163;
          uint64_t v102 = v164;
          uint64_t v103 = *(void *)(*((void *)this + 10) + 8 * v100);
          char v104 = (const char *)(v103 + 16);
          if (*(unsigned char *)(v103 + 31)) {
            size_t v105 = 16;
          }
          else {
            size_t v105 = strlen(v104);
          }
          unint64_t v112 = "remaining class defs entries extends ";
LABEL_173:
          unint64_t v115 = "past end of (";
          goto LABEL_184;
        }
LABEL_59:
        LODWORD(v19) = v124;
        if (v34)
        {
          uint64_t v48 = v33;
          while (v48 * 4 + 4 <= v128)
          {
            unsigned int v49 = v126[v48];
            unsigned int v50 = *((_DWORD *)this + 2);
            BOOL v40 = v50 > 0x13;
            int v51 = (1 << v50) & 0xAAC00;
            BOOL v52 = v40 || v51 == 0;
            unsigned int v53 = bswap32(v49);
            if (v52) {
              unint64_t v54 = v49;
            }
            else {
              unint64_t v54 = v53;
            }
            uint64_t v55 = (unsigned int *)sub_1CCC6B2B4(v54, &v162, &v161, &v157, &v147, 1);
            if (v55)
            {
              if (v161 <= 0x14)
              {
                unsigned int v110 = v157;
                (*(void (**)(std::string **__return_ptr))(*(void *)v158 + 136))(&v163);
                if ((BYTE8(v164) & 1) == 0)
                {
                  uint64_t v101 = v163;
                  uint64_t v102 = v164;
                  uint64_t v111 = *(void *)(*((void *)this + 10) + 8 * v110);
                  char v104 = (const char *)(v111 + 16);
                  if (*(unsigned char *)(v111 + 31)) {
                    size_t v105 = 16;
                  }
                  else {
                    size_t v105 = strlen(v104);
                  }
                  unint64_t v112 = "objc_category_t struct extends past ";
                  goto LABEL_183;
                }
LABEL_188:
                uint64_t v121 = (uint64_t)v163;
                BOOL v163 = 0;
LABEL_189:
                v144[0] = v121;
                llvm::report_fatal_error(v144);
              }
              unsigned int v56 = v55[1];
              unsigned int v57 = *((_DWORD *)this + 2);
              unsigned int v58 = bswap32(*v55);
              unsigned int v59 = v55[2];
              unsigned int v60 = v55[3];
              unsigned int v61 = bswap32(v56);
              unsigned int v62 = bswap32(v59);
              unsigned int v63 = bswap32(v60);
              if (((1 << v57) & 0xAAC00) == 0)
              {
                unsigned int v58 = *v55;
                unsigned int v61 = v55[1];
                unsigned int v62 = v55[2];
                unsigned int v63 = v55[3];
              }
              if (v57 <= 0x13) {
                unint64_t v64 = v58;
              }
              else {
                unint64_t v64 = *v55;
              }
              if (v57 <= 0x13) {
                unint64_t v65 = v61;
              }
              else {
                unint64_t v65 = v56;
              }
              if (v57 <= 0x13) {
                unsigned int v66 = v62;
              }
              else {
                unsigned int v66 = v59;
              }
              if (v57 <= 0x13) {
                unsigned int v67 = v63;
              }
              else {
                unsigned int v67 = v60;
              }
              LODWORD(v137[0]) = 0;
              uint64_t v68 = sub_1CCC6B2B4(v64, v137, v133, v144, &v147, 1);
              if (v68)
              {
                uint64_t v152 = v68;
                uint64_t v69 = sub_1CCC6B2B4(v65, v137, v133, v144, &v147, 1);
                if (v69)
                {
                  uint64_t v150 = 0;
                  uint64_t v151 = v69;
                  char v153 = 0;
                  sub_1CCC6EC68(v140, v66, (uint64_t)&v147, &v169);
                  uint64_t v46 = v140[0];
                  if (v140[0]) {
                    goto LABEL_152;
                  }
                  char v153 = 1;
                  sub_1CCC6EC68(v140, v67, (uint64_t)&v147, &v169);
                  uint64_t v46 = v140[0];
                  if (v140[0]) {
                    goto LABEL_152;
                  }
                }
              }
            }
            ++v48;
            if (!--v34) {
              goto LABEL_29;
            }
          }
          unsigned int v106 = v157;
          (*(void (**)(std::string **__return_ptr))(*(void *)v158 + 136))(&v163);
          if (BYTE8(v164)) {
            goto LABEL_188;
          }
          uint64_t v101 = v163;
          uint64_t v102 = v164;
          uint64_t v107 = *(void *)(*((void *)this + 10) + 8 * v106);
          char v104 = (const char *)(v107 + 16);
          if (*(unsigned char *)(v107 + 31)) {
            size_t v105 = 16;
          }
          else {
            size_t v105 = strlen(v104);
          }
          unint64_t v112 = "remaining category defs entries extends ";
          goto LABEL_173;
        }
      }
LABEL_29:
      int v20 = v19 + 16;
      unint64_t v19 = (v19 + 16);
      unint64_t v17 = __dst;
      uint64_t v18 = v160;
      if (v19 >= (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v160 + 160))(v160, __dst)) {
        goto LABEL_95;
      }
    }
  }
  uint64_t v167 = 0;
  long long v168 = 0uLL;
  sub_1CCC68E3C((uint64_t)&v147, (uint64_t)this, a2, a3);
  uint64_t v6 = sub_1CCC68880(this, "__OBJC2", "__class_list");
  if (!(v7 | v6)) {
    uint64_t v6 = sub_1CCC68880(this, "__DATA", "__objc_classlist");
  }
  uint64_t v8 = v6;
  uint64_t v9 = v7;
  if (!(v7 | v6))
  {
    uint64_t v8 = sub_1CCC68880(this, "__DATA_CONST", "__objc_classlist");
    uint64_t v9 = v10;
  }
  if (!(v9 | v8))
  {
    uint64_t v8 = sub_1CCC68880(this, "__DATA_DIRTY", "__objc_classlist");
    uint64_t v9 = v11;
  }
  if (!(v9 | v8)) {
    goto LABEL_130;
  }
  (*(void (**)(int64x2_t *__return_ptr, uint64_t, uint64_t))(*(void *)v9 + 136))(&v169, v9, v8);
  if (v170)
  {
    uint64_t v70 = (std::string *)v169.i64[0];
    v169.i64[0] = 0;
  }
  else
  {
    uint64_t v125 = v169.i64[1];
    uint64_t v127 = v169.i64[0];
    uint64_t v12 = *((void *)v147[10] + v8);
    unint64_t v123 = (const char *)(v12 + 16);
    if (*(unsigned char *)(v12 + 31)) {
      size_t v122 = 16;
    }
    else {
      size_t v122 = strlen((const char *)(v12 + 16));
    }
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v9 + 168))(&v171, v9, v8);
    uint64_t v75 = v171;
    if (v172)
    {
      unint64_t v129 = (std::string *)v171;
      goto LABEL_125;
    }
    if (!(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 160))(v9, v8))
    {
LABEL_123:
      unint64_t v129 = 0;
      goto LABEL_125;
    }
    uint64_t v76 = 0;
    unsigned int v77 = 0;
    while (1)
    {
      unsigned int v78 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 160))(v9, v8) - v77;
      if (v78 >= 8) {
        size_t v79 = 8;
      }
      else {
        size_t v79 = v78;
      }
      unint64_t __dst = 0;
      memcpy(&__dst, (const void *)(v75 + v76), v79);
      unsigned int v80 = v76 + 8;
      if (v76 + 8 > (unint64_t)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 160))(v9, v8))
      {
        v130[0] = "class";
        unsigned int v131 = " list pointer extends past end of (";
        __int16 v132 = 771;
        v133[0] = v130;
        uint64_t v134 = v123;
        size_t v135 = v122;
        __int16 v136 = 1282;
        v137[0] = v133;
        uint64_t v138 = ",";
        __int16 v139 = 770;
        v140[0] = v137;
        unsigned int v141 = (const char *)v127;
        uint64_t v142 = v125;
        __int16 v143 = 1282;
        v144[0] = (uint64_t)v140;
        int v145 = ") section at address: 0x";
        __int16 v146 = 770;
        uint64_t v157 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 144))(v9, v8) + v76;
        *(void *)&long long v171 = v144;
        *(void *)&long long v172 = &v157;
        LOWORD(v173) = 3586;
        sub_1CCC51CE4((uint64_t)&v129, (uint64_t *)&v171);
      }
      unsigned int v81 = *((_DWORD *)v147 + 2);
      BOOL v40 = v81 > 0x13;
      int v82 = (1 << v81) & 0xAAC00;
      BOOL v83 = v40 || v82 == 0;
      uint64_t v84 = v83 ? __dst : bswap64(__dst);
      uint64_t v85 = sub_1CCC6A390((uint64_t)v156, v84);
      v144[0] = 0;
      v140[0] = 0;
      sub_1CCC6A41C((uint64_t)&v171, v77, v8, v9, (uint64_t)&v147, v144, v140, v85);
      if (BYTE8(v171)) {
        break;
      }
      sub_1CCC68AC8(&v129, v140[0] + v144[0], (uint64_t)&v147, (int64x2_t *)&v167);
      if (v129) {
        goto LABEL_125;
      }
      uint64_t v76 = (v76 + 8);
      unsigned int v77 = v80;
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 160))(v9, v8) <= (unint64_t)v80) {
        goto LABEL_123;
      }
    }
    uint64_t v70 = (std::string *)v171;
  }
  unint64_t v129 = v70;
LABEL_125:
  if (v170)
  {
    uint64_t v86 = v169.i64[0];
    v169.i64[0] = 0;
    if (v86) {
      (*(void (**)(uint64_t))(*(void *)v86 + 8))(v86);
    }
  }
  long long v87 = v129;
  if (!v129)
  {
LABEL_130:
    LOBYTE(v165) = 0;
    long long v87 = v167;
    BOOL v163 = v167;
    long long v164 = v168;
    uint64_t v167 = 0;
    long long v168 = 0uLL;
    uint64_t v9 = v164;
    int v88 = 1;
    goto LABEL_131;
  }
  int v88 = 0;
  LOBYTE(v165) = -1;
  BOOL v163 = v129;
LABEL_131:
  long long v89 = v156;
  unsigned __int8 v156 = 0;
  if (v89)
  {
    MEMORY[0x1D25D9CD0](*v89, 8);
    MEMORY[0x1D25D9CE0](v89, 0x1020C405AF6BDC9);
  }
  long long v90 = v155;
  int v155 = 0;
  if (v90)
  {
    MEMORY[0x1D25D9CD0](*v90, 8);
    MEMORY[0x1D25D9CE0](v90, 0x1020C405AF6BDC9);
  }
  long long v91 = v154;
  unsigned int v154 = 0;
  if (v91)
  {
    MEMORY[0x1D25D9CD0](*v91, 8);
    MEMORY[0x1D25D9CE0](v91, 0x1020C405AF6BDC9);
  }
  if (__p)
  {
    int v149 = __p;
    operator delete(__p);
  }
  uint64_t v147 = (void **)&v167;
  sub_1CC658304(&v147);
  __int8 v92 = a4[1].i8[8];
  if (v88)
  {
    a4[1].i8[8] = v92 & 0xFE;
    a4->i64[1] = 0;
    a4[1].i64[0] = 0;
    a4->i64[0] = 0;
    int64_t v93 = v9 - (void)v87;
    if ((std::string *)v9 != v87)
    {
      if (v93 < 0) {
        abort();
      }
      uint64_t v94 = v93 >> 5;
      uint64_t v95 = (char *)operator new(v93);
      unint64_t v96 = 0;
      a4->i64[0] = (uint64_t)v95;
      a4[1].i64[0] = (uint64_t)&v95[32 * v94];
      do
      {
        uint64_t v97 = (uint64_t)&v95[v96];
        BOOL v98 = (char *)v87 + v96;
        if (SHIBYTE(v87->__r_.__value_.__r.__words[v96 / 8 + 2]) < 0)
        {
          sub_1CB8BDF7C(v97, *(const void **)v98, *((void *)v98 + 1));
        }
        else
        {
          long long v99 = *(_OWORD *)v98;
          *(void *)(v97 + ++*(_DWORD *)(this + 16) = *((void *)v98 + 2);
          *(_OWORD *)uint64_t v97 = v99;
        }
        *(void *)&v95[v96 + 24] = *(std::string::pointer *)((char *)&v87[1].__r_.__value_.__l.__data_ + v96);
        v96 += 32;
      }
      while ((std::string *)((char *)v87 + v96) != (std::string *)v9);
      a4->i64[1] = (uint64_t)&v95[v96];
    }
    char v74 = (void **)&v163;
    goto LABEL_149;
  }
  a4[1].i8[8] = v92 | 1;
  a4->i64[0] = (uint64_t)v87;
}

void sub_1CCC66DB4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  long long v42 = 0uLL;
  uint64_t v43 = 0;
  sub_1CCC68E3C((uint64_t)&v36, (uint64_t)a2, a3, a4);
  uint64_t v6 = sub_1CCC68880(a2, "__OBJC2", "__class_list");
  if (!(v7 | v6)) {
    uint64_t v6 = sub_1CCC68880(a2, "__DATA", "__objc_classlist");
  }
  uint64_t v8 = v6;
  uint64_t v9 = v7;
  if (!(v7 | v6))
  {
    uint64_t v8 = sub_1CCC68880(a2, "__DATA_CONST", "__objc_classlist");
    uint64_t v9 = v10;
  }
  if (!(v9 | v8))
  {
    uint64_t v8 = sub_1CCC68880(a2, "__DATA_DIRTY", "__objc_classlist");
    uint64_t v9 = v11;
  }
  if (!(v9 | v8)) {
    goto LABEL_38;
  }
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)v9 + 136))(v60, v9, v8);
  if (v61)
  {
    uint64_t v13 = v60[0];
    v60[0] = 0;
  }
  else
  {
    uint64_t v33 = v60[1];
    uint64_t v34 = v60[0];
    uint64_t v12 = *((void *)v36[10] + v8);
    uint64_t v32 = v12 + 16;
    if (*(unsigned char *)(v12 + 31)) {
      size_t v31 = 16;
    }
    else {
      size_t v31 = strlen((const char *)(v12 + 16));
    }
    (*(void (**)(uint64_t **__return_ptr, uint64_t, uint64_t))(*(void *)v9 + 168))(&v56, v9, v8);
    uint64_t v14 = (uint64_t)v56;
    if (v58)
    {
      uint64_t v35 = (uint64_t)v56;
      goto LABEL_33;
    }
    if (!(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 160))(v9, v8))
    {
LABEL_31:
      uint64_t v35 = 0;
      goto LABEL_33;
    }
    uint64_t v15 = 0;
    unsigned int v16 = 0;
    while (1)
    {
      unsigned int v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 160))(v9, v8) - v16;
      if (v17 >= 4) {
        size_t v18 = 4;
      }
      else {
        size_t v18 = v17;
      }
      unsigned int __dst = 0;
      memcpy(&__dst, (const void *)(v14 + v15), v18);
      unsigned int v19 = v15 + 4;
      if (v15 + 4 > (unint64_t)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 160))(v9, v8))
      {
        v45[0] = "class";
        uint64_t v45[2] = " list pointer extends past end of (";
        __int16 v46 = 771;
        v47[0] = v45;
        void v47[2] = v32;
        v47[3] = v31;
        __int16 v48 = 1282;
        v49[0] = v47;
        void v49[2] = ",";
        __int16 v50 = 770;
        v51[0] = v49;
        void v51[2] = v34;
        v51[3] = v33;
        __int16 v52 = 1282;
        v53[0] = (uint64_t)v51;
        v53[2] = (uint64_t)") section at address: 0x";
        __int16 v54 = 770;
        uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 144))(v9, v8) + v15;
        unsigned int v56 = v53;
        unsigned int v58 = &v44;
        __int16 v59 = 3586;
        sub_1CCC51CE4((uint64_t)&v35, (uint64_t *)&v56);
      }
      unsigned int v20 = *((_DWORD *)v36 + 2);
      BOOL v21 = v20 > 0x13;
      int v22 = (1 << v20) & 0xAAC00;
      BOOL v23 = v21 || v22 == 0;
      unsigned int v24 = v23 ? __dst : bswap32(__dst);
      unsigned int v25 = sub_1CCC6A390((uint64_t)v41, v24);
      sub_1CCC6A41C((uint64_t)&v56, v16, v8, v9, (uint64_t)&v36, v53, v51, v25);
      if (v57) {
        break;
      }
      sub_1CCC6D104(&v35, v25, &v36, (char **)&v42);
      if (v35) {
        goto LABEL_33;
      }
      uint64_t v15 = v19;
      unsigned int v16 = v19;
      if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 160))(v9, v8) <= (unint64_t)v19) {
        goto LABEL_31;
      }
    }
    uint64_t v13 = (uint64_t)v56;
  }
  uint64_t v35 = v13;
LABEL_33:
  if (v61)
  {
    uint64_t v26 = v60[0];
    v60[0] = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    }
  }
  uint64_t v27 = v35;
  if (v35)
  {
    *(unsigned char *)(a1 + 24) |= 1u;
    *(void *)a1 = v27;
    goto LABEL_39;
  }
LABEL_38:
  *(unsigned char *)(a1 + 24) &= ~1u;
  *(_OWORD *)a1 = v42;
  *(void *)(a1 + ++*(_DWORD *)(this + 16) = v43;
  long long v42 = 0uLL;
  uint64_t v43 = 0;
LABEL_39:
  BOOL v28 = v41;
  int v41 = 0;
  if (v28)
  {
    MEMORY[0x1D25D9CD0](*v28, 8);
    MEMORY[0x1D25D9CE0](v28, 0x1020C405AF6BDC9);
  }
  uint64_t v29 = v40;
  BOOL v40 = 0;
  if (v29)
  {
    MEMORY[0x1D25D9CD0](*v29, 8);
    MEMORY[0x1D25D9CE0](v29, 0x1020C405AF6BDC9);
  }
  unsigned int v30 = v39;
  unsigned int v39 = 0;
  if (v30)
  {
    MEMORY[0x1D25D9CD0](*v30, 8);
    MEMORY[0x1D25D9CE0](v30, 0x1020C405AF6BDC9);
  }
  if (__p)
  {
    unsigned int v38 = __p;
    operator delete(__p);
  }
  uint64_t v36 = (void **)&v42;
  sub_1CC658304(&v36);
}

void llvm::object::MachOObjectFile::findDsymObjectMembers(const void *a1@<X0>, size_t a2@<X1>, uint64_t a3@<X8>)
{
  v80[32] = *MEMORY[0x1E4F143B8];
  unsigned int v78 = v80;
  long long v79 = xmmword_1CD96DBF0;
  if (a2 >= 0x101) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  uint64_t v6 = 0;
  if (a2)
  {
    memcpy(v78, a1, a2);
    uint64_t v6 = v79;
  }
  *(void *)&long long v79 = v6 + a2;
  llvm::sys::path::remove_dots((unsigned __int8 **)&v78, 0, 0);
  *(_WORD *)&v58[16] = 261;
  __p[0] = v78;
  __p[1] = (void *)v79;
  LOBYTE(v74) = 0;
  if (llvm::sys::fs::is_directory((llvm::sys::fs *)__p, (const llvm::Twine *)&v74, v7)
    || !(_BYTE)v74
    || (uint64_t v8 = llvm::sys::path::extension((uint64_t)v78, v79, 0), v9 != 5)
    || (*(_DWORD *)v8 == 1498637358 ? (BOOL v10 = v8[4] == 77) : (BOOL v10 = 0), !v10))
  {
    *(unsigned char *)(a3 + 24) &= ~1u;
    *(void *)(a3 + ++*(_DWORD *)(this + 8) = 0;
    *(void *)(a3 + ++*(_DWORD *)(this + 16) = 0;
    *(void *)a3 = 0;
    __p[1] = 0;
    *(void *)unsigned int v58 = 0;
    __p[0] = 0;
    char v74 = __p;
    uint64_t v11 = &v74;
    goto LABEL_12;
  }
  __p[0] = "Contents";
  *(_WORD *)&v58[16] = 259;
  char v74 = (void **)"Resources";
  LOWORD(v77) = 259;
  v71.i64[0] = (uint64_t)"DWARF";
  __int16 v73 = 259;
  __int16 v70 = 257;
  llvm::sys::path::append(&v78, 0, (const char **)__p, &v74, (uint64_t)&v71, (uint64_t)&v68);
  HIBYTE(v67.__cat_) = 0;
  *(_WORD *)&v58[16] = 261;
  __p[0] = v78;
  __p[1] = (void *)v79;
  is_directory = (llvm *)llvm::sys::fs::is_directory((llvm::sys::fs *)__p, (const llvm::Twine *)((char *)&v67.__cat_ + 7), v12);
  *(void *)&v67.__val_ = v13;
  uint64_t v14 = std::generic_category();
  uint64_t v16 = *(void *)&v67.__val_;
  if (*(const std::error_category **)&v67.__val_ == v14 && is_directory == 2
    || !is_directory && !HIBYTE(v67.__cat_))
  {
    unsigned int v17 = is_directory;
    if (!a1)
    {
      __p[0] = 0;
      __p[1] = 0;
      size_t v18 = __p;
      *(void *)unsigned int v58 = 0;
      goto LABEL_84;
    }
    if (a2 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_102;
    }
    if (a2 >= 0x17)
    {
      uint64_t v45 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((a2 | 7) != 0x17) {
        uint64_t v45 = a2 | 7;
      }
      uint64_t v46 = v45 + 1;
      unsigned int v19 = operator new(v45 + 1);
      __p[1] = (void *)a2;
      *(void *)unsigned int v58 = v46 | 0x8000000000000000;
      __p[0] = v19;
    }
    else
    {
      v58[7] = a2;
      unsigned int v19 = __p;
      if (!a2)
      {
LABEL_82:
        *((unsigned char *)v19 + a2) = 0;
        size_t v18 = __p;
        if (v58[7] < 0) {
          size_t v18 = (void **)__p[0];
        }
LABEL_84:
        char v74 = v18;
        sub_1CD5E3960((uint64_t)v17, v16, (uint64_t)"%s: expected directory 'Contents/Resources/DWARF' in dSYM bundle", (uint64_t *)&v74);
      }
    }
    memmove(v19, a1, a2);
    goto LABEL_82;
  }
  if (is_directory)
  {
    *(_WORD *)&v58[16] = 261;
    __p[0] = v78;
    __p[1] = (void *)v79;
    *(void *)&v15.__val_ = *(void *)&v67.__val_;
    llvm::errorCodeToError(is_directory, v15, &v65);
    char v74 = v65;
    sub_1CC226C78((uint64_t)__p, 0, 0, (uint64_t *)&v74);
  }
  int64x2_t v71 = 0uLL;
  long long v72 = 0;
  *(_WORD *)&v58[16] = 261;
  __p[0] = v78;
  __p[1] = (void *)v79;
  sub_1CD501E54((uint64_t)&v68, (void **)__p, (unint64_t *)&is_directory, 1);
  uint64_t v62 = 0;
  unsigned int v63 = 0;
  char v64 = 1;
  if ((sub_1CC22AEBC((uint64_t *)&v68, &v62) & 1) == 0 && !is_directory)
  {
    while (1)
    {
      char v21 = *((unsigned char *)v68 + 31);
      if (v21 >= 0) {
        int v22 = v68 + 1;
      }
      else {
        int v22 = (DIR **)v68[1];
      }
      if (v21 >= 0) {
        size_t v23 = v21 & 0x7F;
      }
      else {
        size_t v23 = (size_t)v68[2];
      }
      *(_OWORD *)std::string __p = 0u;
      memset(v58, 0, sizeof(v58));
      uint64_t v59 = 0xFFFFLL;
      __int16 v60 = 0;
      uint64_t v61 = 0;
      LOWORD(v77) = 261;
      char v74 = (void **)v22;
      v75.i64[0] = v23;
      unsigned int v24 = (llvm *)llvm::sys::fs::status((llvm::sys::fs *)&v74, (const llvm::Twine *)__p, (llvm::sys::fs::file_status *)1);
      if (v24)
      {
        LOWORD(v77) = 261;
        char v74 = (void **)v22;
        v75.i64[0] = v23;
        llvm::errorCodeToError(v24, v25, &v56);
        *(void *)&long long __dst = v56;
        uint64_t v56 = 0;
        sub_1CC226C78((uint64_t)&v74, 0, 0, (uint64_t *)&__dst);
      }
      if (*(_DWORD *)&v58[24] <= 9u && ((1 << v58[24]) & 0x214) != 0) {
        break;
      }
LABEL_68:
      is_directory = (llvm *)llvm::sys::fs::detail::directory_iterator_increment(v68);
      *(void *)&v67.__val_ = v42;
      if ((sub_1CC22AEBC((uint64_t *)&v68, &v62) & 1) != 0 || is_directory) {
        goto LABEL_70;
      }
    }
    if (!v22)
    {
      long long __dst = 0uLL;
      unint64_t v55 = 0;
      goto LABEL_49;
    }
    if (v23 > 0x7FFFFFFFFFFFFFF7) {
      goto LABEL_102;
    }
    if (v23 >= 0x17)
    {
      uint64_t v27 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v23 | 7) != 0x17) {
        uint64_t v27 = v23 | 7;
      }
      uint64_t v28 = v27 + 1;
      p_dst = (long long *)operator new(v27 + 1);
      *((void *)&__dst + 1) = v23;
      unint64_t v55 = v28 | 0x8000000000000000;
      *(void *)&long long __dst = p_dst;
    }
    else
    {
      HIBYTE(v55) = v23;
      p_dst = &__dst;
      if (!v23) {
        goto LABEL_48;
      }
    }
    memmove(p_dst, v22, v23);
LABEL_48:
    *((unsigned char *)p_dst + v23) = 0;
LABEL_49:
    unint64_t v29 = v71.u64[1];
    unsigned int v30 = v72;
    if (v71.i64[1] >= (unint64_t)v72)
    {
      uint64_t v31 = v71.i64[0];
      unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((v71.i64[1] - v71.i64[0]) >> 3);
      unint64_t v33 = v32 + 1;
      if (v32 + 1 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_102;
      }
      if (0x5555555555555556 * ((uint64_t)&v72[-v71.i64[0]] >> 3) > v33) {
        unint64_t v33 = 0x5555555555555556 * ((uint64_t)&v72[-v71.i64[0]] >> 3);
      }
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v72[-v71.i64[0]] >> 3) >= 0x555555555555555) {
        unint64_t v34 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v34 = v33;
      }
      unsigned int v77 = &v72;
      if (v34)
      {
        if (v34 > 0xAAAAAAAAAAAAAAALL) {
          sub_1CB833614();
        }
        uint64_t v35 = (char *)operator new(24 * v34);
      }
      else
      {
        uint64_t v35 = 0;
      }
      uint64_t v36 = &v35[24 * v32];
      *(_OWORD *)uint64_t v36 = __dst;
      *((void *)v36 + 2) = v55;
      unint64_t v55 = 0;
      long long __dst = 0uLL;
      if (v29 == v31)
      {
        char v40 = 0;
        int64x2_t v39 = vdupq_n_s64(v29);
        uint64_t v37 = &v35[24 * v32];
      }
      else
      {
        uint64_t v37 = &v35[24 * v32];
        do
        {
          long long v38 = *(_OWORD *)(v29 - 24);
          *((void *)v37 - 1) = *(void *)(v29 - 8);
          *(_OWORD *)(v37 - 24) = v38;
          v37 -= 24;
          *(void *)(v29 - ++*(_DWORD *)(this + 16) = 0;
          *(void *)(v29 - ++*(_DWORD *)(this + 8) = 0;
          *(void *)(v29 - 24) = 0;
          v29 -= 24;
        }
        while (v29 != v31);
        int64x2_t v39 = v71;
        unsigned int v30 = v72;
        char v40 = HIBYTE(v55);
      }
      int v41 = v36 + 24;
      v71.i64[0] = (uint64_t)v37;
      v71.i64[1] = (uint64_t)(v36 + 24);
      int64x2_t v75 = v39;
      long long v72 = &v35[24 * v34];
      uint64_t v76 = v30;
      char v74 = (void **)v39.i64[0];
      sub_1CBF4EE0C((uint64_t)&v74);
      v71.i64[1] = (uint64_t)v41;
      if (v40 < 0) {
        operator delete((void *)__dst);
      }
    }
    else
    {
      *(_OWORD *)v71.i64[1] = __dst;
      *(void *)(v29 + ++*(_DWORD *)(this + 16) = v55;
      v71.i64[1] = v29 + 24;
    }
    goto LABEL_68;
  }
LABEL_70:
  uint64_t v43 = v63;
  if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
    std::__shared_weak_count::__release_weak(v43);
  }
  uint64_t v44 = v69;
  if (v69 && !atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
    std::__shared_weak_count::__release_weak(v44);
  }
  if (is_directory)
  {
    *(_WORD *)&v58[16] = 261;
    __p[0] = v78;
    __p[1] = (void *)v79;
    *(void *)&v20.__val_ = *(void *)&v67.__val_;
    llvm::errorCodeToError(is_directory, v20, &v53);
    char v74 = v53;
    sub_1CC226C78((uint64_t)__p, 0, 0, (uint64_t *)&v74);
  }
  int64x2_t v47 = v71;
  if (v71.i64[0] == v71.i64[1])
  {
    __int16 v48 = std::system_category();
    if (!a1)
    {
      __p[0] = 0;
      __p[1] = 0;
      unsigned int v49 = __p;
      *(void *)unsigned int v58 = 0;
      goto LABEL_101;
    }
    if (a2 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (a2 >= 0x17)
      {
        uint64_t v51 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((a2 | 7) != 0x17) {
          uint64_t v51 = a2 | 7;
        }
        uint64_t v52 = v51 + 1;
        __int16 v50 = operator new(v51 + 1);
        __p[1] = (void *)a2;
        *(void *)unsigned int v58 = v52 | 0x8000000000000000;
        __p[0] = v50;
      }
      else
      {
        v58[7] = a2;
        __int16 v50 = __p;
        if (!a2)
        {
LABEL_99:
          *((unsigned char *)v50 + a2) = 0;
          unsigned int v49 = __p;
          if (v58[7] < 0) {
            unsigned int v49 = (void **)__p[0];
          }
LABEL_101:
          char v74 = v49;
          sub_1CD5E3960(0, (uint64_t)v48, (uint64_t)"%s: no objects found in dSYM bundle", (uint64_t *)&v74);
        }
      }
      memmove(v50, a1, a2);
      goto LABEL_99;
    }
LABEL_102:
    abort();
  }
  *(unsigned char *)(a3 + 24) &= ~1u;
  *(int64x2_t *)a3 = v47;
  *(void *)(a3 + ++*(_DWORD *)(this + 16) = v72;
  long long v72 = 0;
  int64x2_t v71 = 0uLL;
  __p[0] = &v71;
  uint64_t v11 = (void ***)__p;
LABEL_12:
  sub_1CB8338B8(v11);
  if (v78 != v80) {
    free(v78);
  }
}

uint64_t llvm::object::MachOObjectFile::mapReflectionSectionNameToEnumValue(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3 == 14)
  {
    if (*a2 == 0x3574666977735F5FLL && *(void *)((char *)a2 + 6) == 0x6F746F72705F3574) {
      return 6;
    }
    return 10;
  }
  if (a3 == 15)
  {
    if (*a2 == 0x3574666977735F5FLL && *(void *)((char *)a2 + 7) == 0x736F746F72705F35) {
      return 7;
    }
    if (*a2 == 0x3574666977735F5FLL && *(void *)((char *)a2 + 7) == 0x6D756E65706D5F35) {
      return 9;
    }
    return 10;
  }
  if (a3 != 16) {
    return 10;
  }
  if (*a2 == 0x3574666977735F5FLL && a2[1] == 0x646D646C6569665FLL) {
    return 0;
  }
  if (*a2 == 0x3574666977735F5FLL && a2[1] == 0x7974636F7373615FLL) {
    return 1;
  }
  if (*a2 == 0x3574666977735F5FLL && a2[1] == 0x6E69746C6975625FLL) {
    return 2;
  }
  if (*a2 == 0x3574666977735F5FLL && a2[1] == 0x657275747061635FLL) {
    return 3;
  }
  if (*a2 == 0x3574666977735F5FLL && a2[1] == 0x666572657079745FLL) {
    return 4;
  }
  if (*a2 != 0x3574666977735F5FLL || a2[1] != 0x7274736C6665725FLL)
  {
    if (*a2 == 0x3574666977735F5FLL && a2[1] == 0x73636E756663615FLL) {
      return 8;
    }
    return 10;
  }
  return 5;
}

BOOL llvm::object::MachOObjectFile::isMachOPairedReloc(llvm::object::MachOObjectFile *this, uint64_t a2)
{
  if (a2 <= 38)
  {
    if (a2 != 1) {
      return a2 == 3 && this == (llvm::object::MachOObjectFile *)1;
    }
LABEL_18:
    if ((unint64_t)this >= 0xA) {
      return 0;
    }
    else {
      return (0x30Cu >> (char)this) & 1;
    }
  }
  if (a2 == 39) {
    goto LABEL_18;
  }
  BOOL v3 = this == (llvm::object::MachOObjectFile *)2 || this == (llvm::object::MachOObjectFile *)4;
  if (a2 != 41) {
    BOOL v3 = 0;
  }
  if (a2 == 42) {
    return this == (llvm::object::MachOObjectFile *)5;
  }
  else {
    return v3;
  }
}

void sub_1CCC67F70(uint64_t a1)
{
  *(void *)a1 = &unk_1F26336A0;
  sub_1CCC6FA50((void ***)(a1 + 264));
  BOOL v2 = *(void **)(a1 + 232);
  if (v2 != (void *)(a1 + 248)) {
    free(v2);
  }
  BOOL v3 = *(void **)(a1 + 208);
  if (v3 != (void *)(a1 + 224)) {
    free(v3);
  }
  BOOL v4 = *(void **)(a1 + 128);
  if (v4 != (void *)(a1 + 144)) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 104);
  if (v5 != (void *)(a1 + 120)) {
    free(v5);
  }
  uint64_t v6 = *(void **)(a1 + 80);
  if (v6 != (void *)(a1 + 96)) {
    free(v6);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CCC6803C(uint64_t result, uint64_t a2, _DWORD *a3, unsigned int a4)
{
  unint64_t v4 = *(void *)(a2 + 16);
  if (v4 > (unint64_t)a3 || (unint64_t v5 = v4 + *(void *)(a2 + 24), (unint64_t)(a3 + 2) > v5))
  {
    v20[0] = (uint64_t)"Structure read out-of-range";
    __int16 v22 = 259;
    sub_1CCC51CE4((uint64_t)v16, v20);
  }
  LODWORD(v7) = *a3;
  LODWORD(v6) = a3[1];
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  BOOL v9 = v8 >= 0x13;
  BOOL v11 = v8 == 19;
  int v10 = (1 << v8) & 0xAAC00;
  BOOL v11 = !v11 && v9 || v10 == 0;
  unsigned int v12 = bswap32(v7);
  unsigned int v13 = bswap32(v6);
  if (v11) {
    uint64_t v6 = v6;
  }
  else {
    uint64_t v6 = v13;
  }
  if (v11) {
    uint64_t v7 = v7;
  }
  else {
    uint64_t v7 = v12;
  }
  if ((unint64_t)a3 + v6 > v5)
  {
    v16[0] = "load command ";
    uint64_t v17 = a4;
    __int16 v18 = 2051;
    v20[0] = (uint64_t)v16;
    char v21 = " extends past end of file";
    __int16 v22 = 770;
    sub_1CCC51CE4((uint64_t)&v19, v20);
  }
  unint64_t v14 = v7 | (v6 << 32);
  if (!(v14 >> 35))
  {
    v16[0] = "load command ";
    uint64_t v17 = a4;
    __int16 v18 = 2051;
    v20[0] = (uint64_t)v16;
    char v21 = " with size less than 8 bytes";
    __int16 v22 = 770;
    sub_1CCC51CE4((uint64_t)&v15, v20);
  }
  *(unsigned char *)(result + 16) &= ~1u;
  *(void *)uint64_t result = a3;
  *(void *)(result + ++*(_DWORD *)(this + 8) = v14;
  return result;
}

void *sub_1CCC681C8(void *result, uint64_t *a2, unint64_t a3, uint64_t a4, unsigned char *a5)
{
  unint64_t v5 = result;
  uint64_t v48 = a4;
  unint64_t v49 = a3;
  if (a4)
  {
    int v10 = (uint64_t *)a2[1];
    if (v10 != a2)
    {
      unint64_t v11 = a4 + a3;
      unint64_t v12 = v10[2];
      while ((v12 > a3 || v10[3] + v12 <= a3)
           && (v11 <= v12 || v11 >= v10[3] + v12)
           && (v12 < a3 || v11 < v10[3] + v12))
      {
        int v10 = (uint64_t *)v10[1];
        if (v10 == a2) {
          goto LABEL_13;
        }
        unint64_t v12 = v10[2];
        if (v11 <= v12)
        {
          uint64_t result = operator new(0x28uLL);
          result[2] = a3;
          result[3] = a4;
          result[4] = a5;
          uint64_t v13 = *v10;
          *(void *)(v13 + ++*(_DWORD *)(this + 8) = result;
          *uint64_t result = v13;
          *int v10 = (uint64_t)result;
          result[1] = v10;
          goto LABEL_14;
        }
      }
      uint64_t v15 = " at offset ";
      if (*a5)
      {
        v23[0] = a5;
        v23[2] = " at offset ";
        __int16 v24 = 771;
        uint64_t v16 = (const char *)v23;
        char v17 = 2;
      }
      else
      {
        v23[0] = " at offset ";
        __int16 v24 = 259;
        char v17 = 3;
        uint64_t v16 = " at offset ";
      }
      v25[0] = v16;
      _OWORD v25[2] = &v49;
      char v26 = v17;
      char v27 = 12;
      v28[0] = v25;
      v28[2] = " with a size of ";
      uint64_t v18 = 770;
      __int16 v29 = 770;
      v30[0] = v28;
      void v30[2] = &v48;
      __int16 v31 = 3074;
      *(void *)&long long v32 = v30;
      *(void *)&long long v33 = ", overlaps ";
      LOWORD(v34) = 770;
      uint64_t v19 = (unsigned char *)v10[4];
      if (*v19)
      {
        *(void *)&long long v35 = &v32;
        *(void *)&long long v36 = v19;
        LOWORD(v37) = 770;
        char v20 = 2;
        char v21 = &v35;
      }
      else
      {
        long long v35 = v32;
        long long v36 = v33;
        uint64_t v37 = v34;
        char v20 = v34;
        if (v34 == 1)
        {
          v38[0] = " at offset ";
          __int16 v39 = 259;
          char v22 = 3;
LABEL_22:
          v40[0] = v15;
          uint64_t v40[2] = v10 + 2;
          char v41 = v22;
          char v42 = 12;
          v43[0] = v40;
          _OWORD v43[2] = " with a size of ";
          __int16 v44 = 770;
          v45[0] = (uint64_t)v43;
          uint64_t v45[2] = (uint64_t)(v10 + 3);
          char v46 = 2;
          char v47 = 12;
          sub_1CCC51CE4((uint64_t)result, v45);
        }
        uint64_t v18 = *((void *)&v35 + 1);
        char v21 = &v35;
        if (BYTE1(v37) == 1) {
          char v21 = (long long *)v35;
        }
        else {
          char v20 = 2;
        }
      }
      v38[0] = v21;
      v38[1] = v18;
      void v38[2] = " at offset ";
      LOBYTE(v39) = v20;
      char v22 = 2;
      uint64_t v15 = (const char *)v38;
      HIBYTE(v39) = 3;
      goto LABEL_22;
    }
LABEL_13:
    uint64_t result = operator new(0x28uLL);
    result[2] = a3;
    result[3] = a4;
    result[4] = a5;
    uint64_t v14 = *a2;
    *uint64_t result = *a2;
    result[1] = a2;
    *(void *)(v14 + ++*(_DWORD *)(this + 8) = result;
    *a2 = (uint64_t)result;
LABEL_14:
    ++a2[2];
  }
  void *v5 = 0;
  return result;
}

uint64_t sub_1CCC684A0(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, (v4 << 6) - 3);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, (v5 << 6) - 3);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + (v5 << 6)), (const void *)(*(void *)a2 + (v5 << 6)), *(void *)a2 + (v6 << 6) - (*(void *)a2 + (v5 << 6)));
      }
    }
    *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = v4;
  }
  return a1;
}

void *sub_1CCC68578(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 59) {
      abort();
    }
    uint64_t v7 = result;
    uint64_t result = operator new(32 * a4);
    unsigned int v8 = result;
    *uint64_t v7 = result;
    v7[1] = result;
    void v7[2] = &result[4 * a4];
    uint64_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memcpy(result, a2, v9 - 2);
    }
    v7[1] = (char *)v8 + v9;
  }
  return result;
}

void *sub_1CCC685FC(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x666666666666667) {
      abort();
    }
    uint64_t v6 = result;
    uint64_t v7 = 5 * a4;
    uint64_t result = operator new(40 * a4);
    unsigned int v8 = result;
    *uint64_t v6 = result;
    v6[1] = result;
    int8x16_t v6[2] = &result[v7];
    uint64_t v9 = a3 - (void)a2;
    if (v9) {
      uint64_t result = memcpy(result, a2, v9 - 7);
    }
    v6[1] = (char *)v8 + v9;
  }
  return result;
}

void *sub_1CCC6868C(void *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x492492492492493) {
      abort();
    }
    uint64_t v6 = result;
    uint64_t v7 = 56 * a4;
    unsigned int v8 = (char *)operator new(56 * a4);
    *uint64_t v6 = v8;
    v6[1] = v8;
    int8x16_t v6[2] = &v8[v7];
    return sub_1CCC68724(v6, a2, a3);
  }
  return result;
}

void *sub_1CCC68724(void *result, long long *a2, long long *a3)
{
  BOOL v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      long long v7 = *v6;
      *(_OWORD *)(v4 + 12) = *(long long *)((char *)v6 + 12);
      *(_OWORD *)uint64_t v4 = v7;
      *(void *)(v4 + 40) = 0;
      *(void *)(v4 + 4++*(_DWORD *)(this + 8) = 0;
      *(void *)(v4 + 32) = 0;
      uint64_t result = sub_1CBFCBA2C((void *)(v4 + 32), *((const void **)v6 + 4), *((void *)v6 + 5), (uint64_t)(*((void *)v6 + 5) - *((void *)v6 + 4)) >> 3);
      v4 += 56;
      uint64_t v6 = (long long *)((char *)v6 + 56);
    }
    while (v6 != a3);
  }
  v3[1] = v4;
  return result;
}

uint64_t sub_1CCC687A0(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 144 * v4);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, 144 * v5);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 144 * v5), (const void *)(*(void *)a2 + 144 * v5), *(void *)a2 + 144 * v6 - (*(void *)a2 + 144 * v5));
      }
    }
    *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = v4;
  }
  return a1;
}

uint64_t sub_1CCC68880(void *a1, const char *a2, const char *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(void *))(*a1 + 344))(a1);
  uint64_t v8 = v7;
  uint64_t v9 = (*(uint64_t (**)(void *))(*a1 + 352))(a1);
  uint64_t v24 = v6;
  uint64_t v25 = v8;
  if (v8 != v10 || v6 != v9)
  {
    uint64_t v12 = v9;
    uint64_t v13 = v10;
    while (1)
    {
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)v8 + 136))(v26, v8, v6);
      if (v27)
      {
        uint64_t v22 = v26[0];
        v26[0] = 0;
        uint64_t v23 = v22;
        llvm::report_fatal_error(&v23);
      }
      uint64_t v15 = (const void *)v26[0];
      size_t v14 = v26[1];
      uint64_t v16 = v24;
      uint64_t v17 = *(void *)(a1[10] + 8 * v24);
      uint64_t v18 = (const char *)(v17 + 16);
      if (*(unsigned char *)(v17 + 31)) {
        break;
      }
      size_t v20 = strlen(v18);
      size_t v19 = v20;
      if (!a2)
      {
        if (v20) {
          goto LABEL_23;
        }
        goto LABEL_17;
      }
      if (v20 != strlen(a2)) {
        goto LABEL_23;
      }
      if (v19) {
        goto LABEL_14;
      }
LABEL_17:
      if (a3)
      {
        if (v14 == strlen(a3) && (!v14 || !memcmp(v15, a3, v14))) {
          return v16;
        }
      }
      else if (!v14)
      {
        return v16;
      }
LABEL_23:
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v25 + 128))(v25, &v24);
      uint64_t v6 = v24;
      uint64_t v8 = v25;
      if (v25 == v13 && v24 == v12) {
        return 0;
      }
    }
    if (!a2 || strlen(a2) != 16) {
      goto LABEL_23;
    }
    size_t v19 = 16;
LABEL_14:
    if (memcmp(v18, a2, v19)) {
      goto LABEL_23;
    }
    goto LABEL_17;
  }
  return 0;
}

void sub_1CCC68AC8(std::string **a1, unint64_t a2, uint64_t a3, int64x2_t *a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v39 = 0;
  uint64_t v8 = (unint64_t *)sub_1CCC6B2B4(a2, (_DWORD *)&v41 + 1, &v41, &v39, (void *)a3, 0);
  if (!v8 || v41 <= 0x27)
  {
    uint64_t v22 = v39;
    uint64_t v21 = v40;
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)v40 + 136))(v50, v40, v39);
    if ((v51 & 1) == 0)
    {
      uint64_t v23 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v22);
      uint64_t v24 = (const char *)(v23 + 16);
      if (*(unsigned char *)(v23 + 31)) {
        size_t v25 = 16;
      }
      else {
        size_t v25 = strlen(v24);
      }
      __int16 v33 = 1283;
      v32[0] = "class_t struct extends past end of (";
      v32[2] = v24;
      v32[3] = v25;
      v34[0] = (uint64_t)v32;
      v34[2] = (uint64_t)",";
      __int16 v35 = 770;
      v36[0] = (uint64_t)v34;
      void v36[2] = v50[0];
      v36[3] = v50[1];
      __int16 v37 = 1282;
      char v42 = v36;
      __int16 v44 = ") section at address: 0x";
      __int16 v45 = 770;
      uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v21 + 144))(v21, v22);
      uint64_t v31 = v27 + HIDWORD(v41);
      char v46 = &v42;
      uint64_t v48 = &v31;
      __int16 v49 = 3586;
      sub_1CCC51CE4((uint64_t)a1, (uint64_t *)&v46);
    }
    uint64_t v30 = v50[0];
    v50[0] = 0;
    uint64_t v38 = v30;
    llvm::report_fatal_error(&v38);
  }
  unsigned int v9 = *(_DWORD *)(*(void *)a3 + 8);
  BOOL v10 = v9 > 0x13;
  int v11 = (1 << v9) & 0xAAC00;
  BOOL v12 = v10 || v11 == 0;
  unint64_t v13 = bswap64(*v8);
  unint64_t v14 = bswap64(v8[4]);
  if (v12) {
    uint64_t v15 = *v8;
  }
  else {
    uint64_t v15 = v13;
  }
  if (v12) {
    uint64_t v16 = v8[4];
  }
  else {
    uint64_t v16 = v14;
  }
  v36[0] = 0;
  v32[0] = 0;
  int v17 = HIDWORD(v41);
  uint64_t v18 = v39;
  uint64_t v19 = v40;
  sub_1CCC6A41C((uint64_t)&v46, HIDWORD(v41), v39, v40, a3, v36, v32, v15);
  if (v47)
  {
    uint64_t v26 = (uint64_t)v46;
LABEL_24:
    *a1 = (std::string *)v26;
    return;
  }
  v34[0] = 0;
  v50[0] = 0;
  sub_1CCC6A41C((uint64_t)&v42, v17 + 32, v18, v19, a3, v34, v50, v16);
  if (v43)
  {
    uint64_t v26 = (uint64_t)v42;
    goto LABEL_24;
  }
  char v20 = *(unsigned char *)(a3 + 60);
  *(unsigned char *)(a3 + 60) = 0;
  *(void *)(a3 + 32) = a2;
  sub_1CCC6B540(a1, (v50[0] + v34[0]) & 0xFFFFFFFFFFFFFFF8, a3, a4);
  if (!*a1)
  {
    if (*(unsigned char *)(a3 + 60)
      || (uint64_t v28 = v36[0], v36[0] + v15 == a2)
      || !(v36[0] + v15)
      || (unsigned int v29 = *(_DWORD *)(a3 + 56), v29 > 0x63))
    {
      *(unsigned char *)(a3 + 60) = v20;
      *a1 = 0;
    }
    else
    {
      *(_DWORD *)(a3 + 56) = v29 + 1;
      sub_1CCC68AC8(a1, v32[0] + v28, a3, a4);
    }
  }
}

void *sub_1CCC68E3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = MEMORY[0x1F4188790](a1, a2, a3, a4);
  uint64_t v6 = v5;
  uint64_t v7 = (void *)v4;
  __src[340] = *(void **)MEMORY[0x1E4F143B8];
  *(void *)uint64_t v4 = v5;
  *(_OWORD *)(v4 + ++*(_DWORD *)(this + 8) = 0u;
  uint64_t v8 = (void *)(v4 + 8);
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(void *)(v4 + 54) = 0;
  *(void *)(v4 + 72) = 0;
  *(void *)(v4 + 80) = 0;
  *(void *)(v4 + 64) = 0;
  unsigned int v9 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 344))(v5);
  int v11 = v10;
  uint64_t v30 = v6;
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 352))(v6);
  __src[0] = v9;
  __src[1] = v11;
  if (v11 != v13 || v9 != (void *)v12)
  {
    uint64_t v15 = (void *)v12;
    uint64_t v16 = v13;
    do
    {
      uint64_t v18 = (_OWORD *)v7[2];
      unint64_t v17 = v7[3];
      if ((unint64_t)v18 >= v17)
      {
        char v20 = (_OWORD *)*v8;
        uint64_t v21 = ((uint64_t)v18 - *v8) >> 4;
        unint64_t v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 60) {
          abort();
        }
        uint64_t v23 = v17 - (void)v20;
        if (v23 >> 3 > v22) {
          unint64_t v22 = v23 >> 3;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v22;
        }
        if (v24)
        {
          if (v24 >> 60) {
            sub_1CB833614();
          }
          size_t v25 = (char *)operator new(16 * v24);
        }
        else
        {
          size_t v25 = 0;
        }
        uint64_t v26 = &v25[16 * v21];
        *(_OWORD *)uint64_t v26 = *(_OWORD *)__src;
        uint64_t v27 = v26;
        if (v18 != v20)
        {
          do
          {
            *((_OWORD *)v27 - 1) = *(v18 - 1);
            v27 -= 16;
            --v18;
          }
          while (v18 != v20);
          uint64_t v18 = (_OWORD *)*v8;
        }
        uint64_t v19 = v26 + 16;
        v7[1] = v27;
        void v7[2] = v26 + 16;
        v7[3] = &v25[16 * v24];
        if (v18) {
          operator delete(v18);
        }
      }
      else
      {
        *uint64_t v18 = *(_OWORD *)__src;
        uint64_t v19 = v18 + 1;
      }
      void v7[2] = v19;
      (*(void (**)(void *, void **))(*(void *)__src[1] + 128))(__src[1], __src);
    }
    while (__src[1] != v16 || __src[0] != v15);
  }
  if (*(void *)(v30 + 328)
    || *(void *)(v30 + 352)
    || *(_DWORD *)(v30 + 52) == 16777228 && (*(_DWORD *)(v30 + 56) & 0xFFFFFF) == 2)
  {
    operator new();
  }
  return v7;
}

unsigned __int8 *sub_1CCC69E88(float *a1, uint64_t a2, long long **a3)
{
  uint64_t v5 = (unsigned char *)a2;
  char v7 = *(unsigned char *)(a2 + 23);
  BOOL v8 = v7 < 0;
  unint64_t v9 = *(void *)(a2 + 8);
  if (v7 < 0) {
    a2 = *(void *)a2;
  }
  unint64_t v10 = v7 & 0x7F;
  if (v8) {
    unint64_t v11 = v9;
  }
  else {
    unint64_t v11 = v10;
  }
  unint64_t v12 = sub_1CBF4D6C0((uint64_t)&v52, (uint64_t *)a2, v11);
  unint64_t v13 = v12;
  unint64_t v14 = *((void *)a1 + 1);
  if (v14)
  {
    uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
    v15.i16[0] = vaddlv_u8(v15);
    unint64_t v16 = v15.u32[0];
    if (v15.u32[0] > 1uLL)
    {
      unint64_t v3 = v12;
      if (v12 >= v14) {
        unint64_t v3 = v12 % v14;
      }
    }
    else
    {
      unint64_t v3 = (v14 - 1) & v12;
    }
    unint64_t v17 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v17)
    {
      uint64_t v18 = (unsigned __int8 *)*v17;
      if (*v17)
      {
        char v19 = v5[23];
        int v20 = v19;
        uint64_t v21 = v19 & 0x7F;
        if (v20 >= 0) {
          uint64_t v22 = v21;
        }
        else {
          uint64_t v22 = *((void *)v5 + 1);
        }
        if (v20 < 0) {
          uint64_t v5 = *(unsigned char **)v5;
        }
        do
        {
          unint64_t v23 = *((void *)v18 + 1);
          if (v23 == v13)
          {
            signed __int8 v24 = v18[39];
            uint64_t v25 = v24 & 0x7F;
            if (v24 >= 0) {
              uint64_t v26 = v24 & 0x7F;
            }
            else {
              uint64_t v26 = *((void *)v18 + 3);
            }
            if (v26 == v22)
            {
              if ((v18[39] & 0x80) != 0)
              {
                if (!memcmp(*((const void **)v18 + 2), v5, *((void *)v18 + 3))) {
                  return v18;
                }
              }
              else
              {
                if ((v24 & 0x7F) == 0) {
                  return v18;
                }
                uint64_t v27 = 0;
                while (v18[v27 + 16] == v5[v27])
                {
                  if (v25 == ++v27) {
                    return v18;
                  }
                }
              }
            }
          }
          else
          {
            if (v16 > 1)
            {
              if (v23 >= v14) {
                v23 %= v14;
              }
            }
            else
            {
              v23 &= v14 - 1;
            }
            if (v23 != v3) {
              break;
            }
          }
          uint64_t v18 = *(unsigned __int8 **)v18;
        }
        while (v18);
      }
    }
  }
  uint64_t v18 = (unsigned __int8 *)operator new(0x30uLL);
  *(void *)uint64_t v18 = 0;
  *((void *)v18 + 1) = v13;
  uint64_t v28 = *a3;
  long long v29 = **a3;
  *((void *)v18 + 4) = *((void *)*a3 + 2);
  *((_OWORD *)v18 + 1) = v29;
  *((void *)v28 + 1) = 0;
  *((void *)v28 + 2) = 0;
  *(void *)uint64_t v28 = 0;
  *((void *)v18 + 5) = 0;
  float v30 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v31 = a1[8];
  if (!v14 || (float)(v31 * (float)v14) < v30)
  {
    BOOL v32 = 1;
    if (v14 >= 3) {
      BOOL v32 = (v14 & (v14 - 1)) != 0;
    }
    unint64_t v33 = v32 | (2 * v14);
    unint64_t v34 = vcvtps_u32_f32(v30 / v31);
    if (v33 <= v34) {
      int8x8_t prime = (int8x8_t)v34;
    }
    else {
      int8x8_t prime = (int8x8_t)v33;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v14 = *((void *)a1 + 1);
    if (*(void *)&prime > v14) {
      goto LABEL_51;
    }
    if (*(void *)&prime < v14)
    {
      unint64_t v42 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v14 < 3 || (uint8x8_t v43 = (uint8x8_t)vcnt_s8((int8x8_t)v14), v43.i16[0] = vaddlv_u8(v43), v43.u32[0] > 1uLL))
      {
        unint64_t v42 = std::__next_prime(v42);
      }
      else
      {
        uint64_t v44 = 1 << -(char)__clz(v42 - 1);
        if (v42 >= 2) {
          unint64_t v42 = v44;
        }
      }
      if (*(void *)&prime <= v42) {
        int8x8_t prime = (int8x8_t)v42;
      }
      if (*(void *)&prime >= v14)
      {
        unint64_t v14 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_51:
          if (*(void *)&prime >> 61) {
            sub_1CB833614();
          }
          long long v36 = operator new(8 * *(void *)&prime);
          __int16 v37 = *(void **)a1;
          *(void *)a1 = v36;
          if (v37) {
            operator delete(v37);
          }
          uint64_t v38 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v38++) = 0;
          while (*(void *)&prime != v38);
          uint64_t v39 = (void *)*((void *)a1 + 2);
          if (v39)
          {
            unint64_t v40 = v39[1];
            uint8x8_t v41 = (uint8x8_t)vcnt_s8(prime);
            v41.i16[0] = vaddlv_u8(v41);
            if (v41.u32[0] > 1uLL)
            {
              if (v40 >= *(void *)&prime) {
                v40 %= *(void *)&prime;
              }
            }
            else
            {
              v40 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v40) = a1 + 4;
            __int16 v45 = (void *)*v39;
            if (*v39)
            {
              do
              {
                unint64_t v46 = v45[1];
                if (v41.u32[0] > 1uLL)
                {
                  if (v46 >= *(void *)&prime) {
                    v46 %= *(void *)&prime;
                  }
                }
                else
                {
                  v46 &= *(void *)&prime - 1;
                }
                if (v46 != v40)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v46))
                  {
                    *(void *)(*(void *)a1 + 8 * v46) = v39;
                    goto LABEL_76;
                  }
                  void *v39 = *v45;
                  *__int16 v45 = **(void **)(*(void *)a1 + 8 * v46);
                  **(void **)(*(void *)a1 + 8 * v46) = v45;
                  __int16 v45 = v39;
                }
                unint64_t v46 = v40;
LABEL_76:
                uint64_t v39 = v45;
                __int16 v45 = (void *)*v45;
                unint64_t v40 = v46;
              }
              while (v45);
            }
          }
          unint64_t v14 = (unint64_t)prime;
          goto LABEL_80;
        }
        char v51 = *(void **)a1;
        *(void *)a1 = 0;
        if (v51) {
          operator delete(v51);
        }
        unint64_t v14 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_80:
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v13 >= v14) {
        unint64_t v3 = v13 % v14;
      }
      else {
        unint64_t v3 = v13;
      }
    }
    else
    {
      unint64_t v3 = (v14 - 1) & v13;
    }
  }
  char v47 = *(void **)a1;
  uint64_t v48 = *(void **)(*(void *)a1 + 8 * v3);
  if (v48)
  {
    *(void *)uint64_t v18 = *v48;
LABEL_93:
    *uint64_t v48 = v18;
    goto LABEL_94;
  }
  *(void *)uint64_t v18 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v18;
  v47[v3] = a1 + 4;
  if (*(void *)v18)
  {
    unint64_t v49 = *(void *)(*(void *)v18 + 8);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v49 >= v14) {
        v49 %= v14;
      }
    }
    else
    {
      v49 &= v14 - 1;
    }
    uint64_t v48 = (void *)(*(void *)a1 + 8 * v49);
    goto LABEL_93;
  }
LABEL_94:
  ++*((void *)a1 + 3);
  return v18;
}

uint64_t sub_1CCC6A328(uint64_t a1)
{
  BOOL v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      BOOL v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1CCC6A390(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = a2;
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 16);
    if (v2)
    {
      int v3 = v2 - 1;
      unsigned int v4 = v3 & (37 * a2);
      uint64_t v5 = *(void *)(*(void *)a1 + 16 * v4);
      if (v5 == a2)
      {
        return sub_1CD6814EC(a1, &v9)[1];
      }
      else
      {
        int v7 = 1;
        while (v5 != -1)
        {
          unsigned int v8 = v4 + v7++;
          unsigned int v4 = v8 & v3;
          uint64_t v5 = *(void *)(*(void *)a1 + 16 * (v8 & v3));
          if (v5 == a2) {
            return sub_1CD6814EC(a1, &v9)[1];
          }
        }
      }
    }
  }
  return a2;
}

void *sub_1CCC6A41C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, void *a7, uint64_t a8)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = sub_1CCC6A390(*(void *)(a5 + 80), a8);
  __int16 v60 = a6;
  *a6 = 0;
  uint64_t v59 = v15;
  *a7 = v15;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a4 + 264))(a4, a3);
  uint64_t v18 = v17;
  uint64_t v61 = a3;
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a4 + 272))(a4, a3);
  uint64_t v64 = v16;
  uint64_t v65 = v18;
  uint64_t v20 = a2;
  if (v16 == v19) {
    goto LABEL_2;
  }
  uint64_t v30 = v19;
  while (1)
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v65 + 296))(v65, v16) == v20)
    {
      unint64_t Relocation = llvm::object::MachOObjectFile::getRelocation(*(void *)a5, v64);
      unsigned int v32 = Relocation;
      if (*(_DWORD *)(*(void *)a5 + 52) == 16777223 || (Relocation & 0x80000000) == 0) {
        break;
      }
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v65 + 288))(v65, &v64);
    uint64_t v16 = v64;
    if (v64 == v30) {
      goto LABEL_2;
    }
  }
  unint64_t v33 = HIDWORD(Relocation);
  unsigned int v34 = *(_DWORD *)(*(void *)a5 + 8);
  BOOL v35 = v34 > 0x13;
  int v36 = (1 << v34) & 0xAAC00;
  BOOL v37 = v35 || v36 == 0;
  int v38 = BYTE4(Relocation) & 0x10;
  if (v37) {
    int v38 = (HIDWORD(Relocation) >> 27) & 1;
  }
  if (!v38) {
    goto LABEL_2;
  }
  uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v65 + 304))(v65, v64);
  uint64_t v41 = v39;
  uint64_t v42 = *(void *)a5;
  if (*(_DWORD *)(*(void *)a5 + 52) == 16777228 && (*(_DWORD *)(v42 + 56) & 0xFFFFFF) == 2)
  {
    if ((v32 & 0x80000000) != 0)
    {
      unsigned int v43 = HIBYTE(v32) & 0xF;
    }
    else
    {
      unsigned int v53 = *(_DWORD *)(v42 + 8);
      if (v53 <= 0x13 && ((1 << v53) & 0xAAC00) != 0) {
        unsigned int v43 = v33 & 0xF;
      }
      else {
        unsigned int v43 = v33 >> 28;
      }
    }
    if (v43 == 11)
    {
      *a7 = v59;
      if ((v59 & 0x80000000) != 0) {
        *a7 = v59 | 0xFFFFFFFF00000000;
      }
    }
  }
  uint64_t result = llvm::object::ObjectFile::getSymbolValue(v39, v40, (uint64_t)&v62);
  if (v63)
  {
    unint64_t v54 = v62;
LABEL_49:
    char v55 = *(unsigned char *)(a1 + 8) | 1;
    goto LABEL_50;
  }
  *__int16 v60 = v62;
  uint64_t result = (*(void *(**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v41 + 72))(&v64, v41, v40);
  if (v66)
  {
    unint64_t v54 = v64;
    goto LABEL_49;
  }
  if (v65)
  {
    unint64_t v54 = v64;
    char v55 = *(unsigned char *)(a1 + 8) & 0xFE;
LABEL_50:
    *(unsigned char *)(a1 + ++*(_DWORD *)(this + 8) = v55;
    *(void *)a1 = v54;
    return result;
  }
LABEL_2:
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a4 + 144))(a4, v61);
  uint64_t v22 = *(uint64_t **)(a5 + 64);
  if (!v22) {
    operator new();
  }
  int v23 = *((_DWORD *)v22 + 4);
  if (!v23)
  {
LABEL_30:
    uint64_t v29 = 0;
    goto LABEL_31;
  }
  uint64_t v24 = *v22;
  int v25 = v23 - 1;
  unsigned int v26 = v25 & (37 * (result + v20));
  uint64_t v27 = (void *)(v24 + 24 * v26);
  uint64_t v28 = (void *)*v27;
  if ((void *)*v27 != (void *)((char *)result + v20))
  {
    int v44 = 1;
    while (v28 != (void *)-1)
    {
      unsigned int v45 = v26 + v44++;
      unsigned int v26 = v45 & v25;
      uint64_t v27 = (void *)(v24 + 24 * v26);
      uint64_t v28 = (void *)*v27;
      if ((void *)*v27 == (void *)((char *)result + v20)) {
        goto LABEL_5;
      }
    }
    goto LABEL_30;
  }
LABEL_5:
  if (v27[2]) {
    uint64_t v29 = v27[1];
  }
  else {
    uint64_t v29 = 0;
  }
LABEL_31:
  if (*(unsigned char *)(a5 + 61))
  {
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a4 + 144))(a4, v61);
    unint64_t v46 = *(uint64_t **)(a5 + 72);
    if (!v46) {
      operator new();
    }
    int v47 = *((_DWORD *)v46 + 4);
    if (v47)
    {
      uint64_t v48 = *v46;
      unsigned int v49 = v47 - 1;
      uint64_t v50 = (v47 - 1) & (37 * (result + v20));
      char v51 = *(void **)(v48 + 16 * v50);
      if (v51 == (void *)((char *)result + v20))
      {
LABEL_35:
        uint64_t v52 = *(void *)(v48 + 16 * v50 + 8);
LABEL_56:
        *a7 = v52;
        goto LABEL_57;
      }
      int v56 = 1;
      while (v51 != (void *)-1)
      {
        int v57 = v50 + v56++;
        uint64_t v50 = v57 & v49;
        char v51 = *(void **)(v48 + 16 * v50);
        if (v51 == (void *)((char *)result + v20)) {
          goto LABEL_35;
        }
      }
    }
    uint64_t v52 = 0;
    goto LABEL_56;
  }
LABEL_57:
  if (!v29)
  {
    if (*(unsigned char *)(a5 + 61))
    {
      if (*(_DWORD *)(*(void *)a5 + 52) == 16777228
        && (*(_DWORD *)(*(void *)a5 + 56) & 0xFFFFFF) == 2
        && v59 < 0)
      {
        uint64_t v58 = 0xFFFFFFFFLL;
      }
      else
      {
        uint64_t v58 = 0x7FFFFFFFFFFFFLL;
      }
      *__int16 v60 = v58 & v59;
      *a7 = 0;
    }
    uint64_t v29 = 0;
  }
  *(unsigned char *)(a1 + 8) &= ~1u;
  *(void *)a1 = v29;
  return result;
}

void *sub_1CCC6B128(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + ++*(_DWORD *)(this + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + ++*(_DWORD *)(this + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = 16 * v10;
      unint64_t v12 = result;
      do
      {
        *unint64_t v12 = -1;
        v12 += 2;
        v11 -= 16;
      }
      while (v11);
    }
    if (v3)
    {
      int v13 = 0;
      int v14 = v10 - 1;
      uint64_t v15 = v4;
      do
      {
        uint64_t v16 = *v15;
        if ((unint64_t)*v15 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          unsigned int v17 = (37 * v16) & v14;
          uint64_t v18 = &result[2 * v17];
          uint64_t v19 = *v18;
          if (v16 != *v18)
          {
            uint64_t v20 = 0;
            int v21 = 1;
            while (v19 != -1)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -2;
              }
              if (v22) {
                uint64_t v20 = v18;
              }
              unsigned int v23 = v17 + v21++;
              unsigned int v17 = v23 & v14;
              uint64_t v18 = &result[2 * (v23 & v14)];
              uint64_t v19 = *v18;
              if (v16 == *v18) {
                goto LABEL_12;
              }
            }
            if (v20) {
              uint64_t v18 = v20;
            }
          }
LABEL_12:
          *uint64_t v18 = v16;
          v18[1] = v15[1];
          *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = ++v13;
        }
        v15 += 2;
      }
      while (v15 != &v4[2 * v3]);
    }
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + ++*(_DWORD *)(this + 8) = 0;
  uint64_t v24 = *(unsigned int *)(a1 + 16);
  if (v24)
  {
    uint64_t v25 = 16 * v24;
    do
    {
      *uint64_t result = -1;
      result += 2;
      v25 -= 16;
    }
    while (v25);
  }
  return result;
}

uint64_t sub_1CCC6B2B4(unint64_t a1, _DWORD *a2, _DWORD *a3, void *a4, void *a5, int a6)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  a4[1] = 0;
  uint64_t v6 = a5[1];
  if (a5[2] != v6)
  {
    uint64_t v9 = 0;
    unsigned int v10 = 1;
    do
    {
      unint64_t v11 = (*(uint64_t (**)(void, void))(**(void **)(v6 + 16 * v9 + 8) + 144))(*(void *)(v6 + 16 * v9 + 8), *(void *)(v6 + 16 * v9));
      uint64_t v12 = (*(uint64_t (**)(void, void))(**(void **)(a5[1] + 16 * v9 + 8) + 160))(*(void *)(a5[1] + 16 * v9 + 8), *(void *)(a5[1] + 16 * v9));
      uint64_t v6 = a5[1];
      if (v12)
      {
        uint64_t v13 = v12;
        if (!a6) {
          goto LABEL_18;
        }
        (*(void (**)(void *__return_ptr))(**(void **)(v6 + 16 * v9 + 8) + 136))(v27);
        if (v28)
        {
          uint64_t v26 = v27[0];
          v27[0] = 0;
          uint64_t v20 = &v26;
          goto LABEL_28;
        }
        if ((uint64_t v6 = a5[1],
              uint64_t v14 = *(void *)(*(void *)(*a5 + 80) + 8 * *(unsigned int *)(v6 + 16 * v9)),
              !*(unsigned char *)(v14 + 31))
          && (uint64_t v15 = v14 + 16, strlen((const char *)(v14 + 16)) == 6)
          && (*(_DWORD *)v15 == 1112498015 ? (BOOL v16 = *(unsigned __int16 *)(v15 + 4) == 17226) : (BOOL v16 = 0), v16)
          || v27[1] == 9
          && (*(void *)v27[0] == 0x6E69727473635F5FLL ? (BOOL v17 = *(unsigned char *)(v27[0] + 8) == 103) : (BOOL v17 = 0), v17))
        {
LABEL_18:
          if (a1 >= v11 && v13 + v11 > a1)
          {
            *(_OWORD *)a4 = *(_OWORD *)(v6 + 16 * v9);
            *a2 = a1 - v11;
            *a3 = v13 - (a1 - v11);
            (*(void (**)(void *__return_ptr))(**(void **)(a5[1] + 16 * v9 + 8) + 168))(v27);
            if ((v28 & 1) == 0) {
              return v27[0] + *a2;
            }
            uint64_t v25 = v27[0];
            uint64_t v20 = &v25;
LABEL_28:
            llvm::report_fatal_error(v20);
          }
        }
      }
      uint64_t v9 = v10++;
    }
    while (v9 != (a5[2] - v6) >> 4);
  }
  return 0;
}

void sub_1CCC6B540(std::string **a1, unint64_t a2, uint64_t a3, int64x2_t *a4)
{
  uint64_t v299 = *MEMORY[0x1E4F143B8];
  unsigned int v270 = 0;
  unsigned int v268 = 0;
  uint64_t v266 = 0;
  uint64_t v267 = 0;
  v265[0] = 0;
  v265[1] = 0;
  uint64_t v7 = sub_1CCC6B2B4(a2, &v270, &v268, &v266, (void *)a3, 0);
  if (!v7 || v268 <= 0x47)
  {
    uint64_t v46 = v266;
    uint64_t v45 = v267;
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v267 + 136))(&v294, v267, v266);
    if ((v294.__r_.__value_.__s.__data_[16] & 1) == 0)
    {
      uint64_t v47 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v46);
      uint64_t v48 = (const char *)(v47 + 16);
      if (*(unsigned char *)(v47 + 31)) {
        size_t v49 = 16;
      }
      else {
        size_t v49 = strlen(v48);
      }
      __int16 v289 = 1283;
      v287.__r_.__value_.__r.__words[0] = (std::string::size_type)"class_ro64_t struct extends past end of (";
      v287.__r_.__value_.__r.__words[2] = (std::string::size_type)v48;
      size_t v288 = v49;
      v290.__r_.__value_.__r.__words[0] = (std::string::size_type)&v287;
      v290.__r_.__value_.__r.__words[2] = (std::string::size_type)",";
      __int16 v291 = 770;
      *(void *)uint64_t v292 = &v290;
      *(_OWORD *)&v292[16] = *(_OWORD *)&v294.__r_.__value_.__l.__data_;
      __int16 v293 = 1282;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v292;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)") section at address: 0x";
      __int16 v273 = 770;
      uint64_t v50 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v45 + 144))(v45, v46);
      uint64_t v277 = v50 + v270;
      p_p = &__p;
      v296.i64[1] = (uint64_t)&v277;
      LOWORD(v29++*(_DWORD *)(this + 8) = 3586;
      sub_1CCC51CE4((uint64_t)a1, (uint64_t *)&p_p);
    }
    std::string::size_type v243 = v294.__r_.__value_.__r.__words[0];
    v294.__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v262 = v243;
    p_p_p = (uint64_t *)&v262;
    goto LABEL_306;
  }
  unsigned int v8 = *(_DWORD *)v7;
  unsigned int v9 = *(_DWORD *)(*(void *)a3 + 8);
  BOOL v76 = v9 > 0x13;
  int v10 = (1 << v9) & 0xAAC00;
  BOOL v11 = v76 || v10 == 0;
  char v12 = bswap32(v8);
  unint64_t v13 = bswap64(*(void *)(v7 + 24));
  unint64_t v14 = bswap64(*(void *)(v7 + 32));
  unint64_t v15 = bswap64(*(void *)(v7 + 48));
  if (v11) {
    uint64_t v16 = *(void *)(v7 + 24);
  }
  else {
    uint64_t v16 = v13;
  }
  if (v11)
  {
    unint64_t v17 = *(void *)(v7 + 32);
  }
  else
  {
    LOBYTE(v++*(_DWORD *)(this + 8) = v12;
    unint64_t v17 = v14;
  }
  if (v11) {
    unint64_t v18 = *(void *)(v7 + 48);
  }
  else {
    unint64_t v18 = v15;
  }
  uint64_t v263 = 0;
  uint64_t v264 = 0;
  *(unsigned char *)(a3 + 60) = v8 & 1;
  unsigned int v19 = v270;
  uint64_t v21 = v266;
  uint64_t v20 = v267;
  sub_1CCC6A41C((uint64_t)&v284, v270 + 24, v266, v267, a3, &v264, &v263, v16);
  if (v285)
  {
    *a1 = v284;
    return;
  }
  uint64_t v254 = v17;
  uint64_t v257 = v20;
  unsigned int v259 = v19;
  uint64_t v251 = v18;
  int v269 = 0;
  BOOL v22 = (const char *)sub_1CCC6B2B4(v263 + v264, &v269, &v268, v265, (void *)a3, 0);
  unsigned int v23 = v22;
  *(void *)(a3 + 40) = v22;
  char v261 = a1;
  uint64_t v252 = v21;
  if (*(unsigned char *)(a3 + 60))
  {
    size_t v24 = strlen(v22);
    sub_1CB907098((uint64_t)&__p, v24 + 18);
    uint64_t v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v25 = &__p;
    }
    *(_OWORD *)&v25->__r_.__value_.__l.__data_ = *(_OWORD *)"_OBJC_METACLASS_$_";
    LOWORD(v25->__r_.__value_.__r.__words[2]) = 24356;
    uint64_t v26 = &v25->__r_.__value_.__s.__data_[18];
    if (v24) {
      memmove((char *)&v25->__r_.__value_.__r.__words[2] + 2, v23, v24);
    }
    v26[v24] = 0;
    *(void *)uint64_t v292 = __p.__r_.__value_.__l.__size_;
    std::string::size_type v27 = __p.__r_.__value_.__r.__words[0];
    *(void *)&v292[7] = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
    char v28 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    memset(&__p, 0, sizeof(__p));
    uint64_t v29 = *(void *)(a3 + 32);
    uint64_t v30 = a4 + 1;
    unint64_t v31 = a4[1].u64[0];
    unint64_t v32 = a4->u64[1];
    if (v32 >= v31)
    {
      unint64_t v33 = a4;
      uint64_t v34 = a4->i64[0];
      uint64_t v35 = (uint64_t)(v32 - a4->i64[0]) >> 5;
      unint64_t v36 = v35 + 1;
      if (!((unint64_t)(v35 + 1) >> 59))
      {
        if ((uint64_t)(v31 - v34) >> 4 > v36) {
          unint64_t v36 = (uint64_t)(v31 - v34) >> 4;
        }
        if (v31 - v34 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v37 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v37 = v36;
        }
        unint64_t v297 = 0;
        uint64_t v298 = (uint64_t *)v30;
        if (!(v37 >> 59))
        {
          int v38 = (char *)operator new(32 * v37);
          uint64_t v39 = &v38[32 * v35];
          uint64_t v40 = *(void *)v292;
          *(void *)uint64_t v39 = v27;
          *((void *)v39 + 1) = v40;
          *(void *)(v39 + 15) = *(void *)&v292[7];
          v39[23] = v28;
          *(void *)uint64_t v292 = 0;
          *(void *)&v292[7] = 0;
          *((void *)v39 + 3) = v29;
          if (v32 != v34)
          {
            uint64_t v41 = &v38[32 * v35];
            uint64_t v42 = v261;
            a4 = v33;
            uint64_t v43 = v257;
            do
            {
              long long v44 = *(_OWORD *)(v32 - 32);
              *((void *)v41 - 2) = *(void *)(v32 - 16);
              *((_OWORD *)v41 - 2) = v44;
              *(void *)(v32 - 24) = 0;
              *(void *)(v32 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v32 - 32) = 0;
              *((void *)v41 - 1) = *(void *)(v32 - 8);
              v41 -= 32;
              v32 -= 32;
            }
            while (v32 != v34);
LABEL_55:
            int64x2_t v61 = *a4;
            unint64_t v31 = a4[1].u64[0];
            uint64_t v21 = v252;
LABEL_57:
            unint64_t v55 = (unint64_t)(v39 + 32);
            a4->i64[0] = (uint64_t)v41;
            a4->i64[1] = (uint64_t)(v39 + 32);
            int64x2_t v296 = v61;
            a4[1].i64[0] = (uint64_t)&v38[32 * v37];
            unint64_t v297 = v31;
            p_p = (std::string *)v61.i64[0];
            sub_1CD573B00((uint64_t)&p_p);
            goto LABEL_58;
          }
          goto LABEL_56;
        }
        goto LABEL_308;
      }
      goto LABEL_307;
    }
  }
  else
  {
    size_t v51 = strlen(v22);
    sub_1CB907098((uint64_t)&__p, v51 + 14);
    uint64_t v52 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v52 = &__p;
    }
    qmemcpy(v52, "_OBJC_CLASS_$_", 14);
    unsigned int v53 = &v52->__r_.__value_.__s.__data_[14];
    if (v51) {
      memmove((char *)&v52->__r_.__value_.__r.__words[1] + 6, v23, v51);
    }
    v53[v51] = 0;
    *(void *)uint64_t v292 = __p.__r_.__value_.__l.__size_;
    std::string::size_type v27 = __p.__r_.__value_.__r.__words[0];
    *(void *)&v292[7] = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
    char v28 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    memset(&__p, 0, sizeof(__p));
    uint64_t v29 = *(void *)(a3 + 32);
    unint64_t v54 = a4 + 1;
    unint64_t v31 = a4[1].u64[0];
    unint64_t v32 = a4->u64[1];
    if (v32 >= v31)
    {
      unint64_t v33 = a4;
      uint64_t v56 = a4->i64[0];
      uint64_t v57 = (uint64_t)(v32 - a4->i64[0]) >> 5;
      unint64_t v58 = v57 + 1;
      if (!((unint64_t)(v57 + 1) >> 59))
      {
        if ((uint64_t)(v31 - v56) >> 4 > v58) {
          unint64_t v58 = (uint64_t)(v31 - v56) >> 4;
        }
        if (v31 - v56 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v37 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v37 = v58;
        }
        unint64_t v297 = 0;
        uint64_t v298 = (uint64_t *)v54;
        if (!(v37 >> 59))
        {
          int v38 = (char *)operator new(32 * v37);
          uint64_t v39 = &v38[32 * v57];
          uint64_t v59 = *(void *)v292;
          *(void *)uint64_t v39 = v27;
          *((void *)v39 + 1) = v59;
          *(void *)(v39 + 15) = *(void *)&v292[7];
          v39[23] = v28;
          *(void *)uint64_t v292 = 0;
          *(void *)&v292[7] = 0;
          *((void *)v39 + 3) = v29;
          if (v32 != v56)
          {
            uint64_t v41 = &v38[32 * v57];
            uint64_t v42 = v261;
            a4 = v33;
            uint64_t v43 = v257;
            do
            {
              long long v60 = *(_OWORD *)(v32 - 32);
              *((void *)v41 - 2) = *(void *)(v32 - 16);
              *((_OWORD *)v41 - 2) = v60;
              *(void *)(v32 - 24) = 0;
              *(void *)(v32 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v32 - 32) = 0;
              *((void *)v41 - 1) = *(void *)(v32 - 8);
              v41 -= 32;
              v32 -= 32;
            }
            while (v32 != v56);
            goto LABEL_55;
          }
LABEL_56:
          int64x2_t v61 = vdupq_n_s64(v32);
          uint64_t v41 = v39;
          uint64_t v42 = v261;
          a4 = v33;
          uint64_t v21 = v252;
          uint64_t v43 = v257;
          goto LABEL_57;
        }
LABEL_308:
        sub_1CB833614();
      }
LABEL_307:
      abort();
    }
  }
  *(void *)unint64_t v32 = v27;
  *(void *)(v32 + ++*(_DWORD *)(this + 8) = *(void *)v292;
  *(void *)(v32 + 15) = *(void *)&v292[7];
  *(unsigned char *)(v32 + 23) = v28;
  *(void *)(v32 + 24) = v29;
  unint64_t v55 = v32 + 32;
  uint64_t v42 = v261;
  uint64_t v43 = v257;
LABEL_58:
  unsigned int v62 = v259;
  a4->i64[1] = v55;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1CCC6A41C((uint64_t)&v282, v259 + 32, v21, v43, a3, &v264, &v263, v254);
  if (v283)
  {
    *uint64_t v42 = v282;
    goto LABEL_295;
  }
  uint64_t v63 = v263 + v264;
  if (v263 + v264)
  {
    uint64_t v280 = 0;
    unsigned int v279 = 0;
    uint64_t v277 = 0;
    uint64_t v278 = 0;
    uint64_t v275 = 0;
    uint64_t v276 = 0;
    uint64_t v274 = 0;
    uint64_t v271 = 0;
    uint64_t v64 = (unsigned int *)sub_1CCC6B2B4(v263 + v264, (_DWORD *)&v280 + 1, &v279, &v277, (void *)a3, 0);
    if (v64)
    {
      if (v279 <= 7)
      {
        uint64_t v66 = v277;
        uint64_t v65 = v278;
        (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v278 + 136))(&v294, v278, v277);
        if ((v294.__r_.__value_.__s.__data_[16] & 1) == 0)
        {
          std::string::size_type size = v294.__r_.__value_.__l.__size_;
          std::string::size_type v67 = v294.__r_.__value_.__r.__words[0];
          uint64_t v69 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v66);
          __int16 v70 = (const char *)(v69 + 16);
          if (*(unsigned char *)(v69 + 31)) {
            size_t v71 = 16;
          }
          else {
            size_t v71 = strlen(v70);
          }
          __int16 v289 = 1283;
          int v187 = "method_list64_t struct extends past end of (";
          goto LABEL_205;
        }
        goto LABEL_309;
      }
      unsigned int v72 = v64[1];
      unsigned int v73 = *(_DWORD *)(*(void *)a3 + 8);
      unsigned int v74 = bswap32(*v64);
      unsigned int v75 = bswap32(v72);
      if (((1 << v73) & 0xAAC00) == 0)
      {
        unsigned int v74 = *v64;
        unsigned int v75 = v64[1];
      }
      BOOL v76 = v73 > 0x13;
      if (v73 <= 0x13) {
        unsigned int v77 = v74;
      }
      else {
        unsigned int v77 = *v64;
      }
      if (!v76) {
        unsigned int v72 = v75;
      }
      HIDWORD(v280) += 8;
      unsigned int v247 = v72;
      unsigned int v248 = v77;
      if (v72)
      {
        int v78 = 0;
        int v255 = (unsigned __int16)v77;
        unint64_t v79 = v63 + 8;
        char v246 = a4 + 1;
        do
        {
          uint64_t v80 = sub_1CCC6B2B4(v79, (_DWORD *)&v280 + 1, &v279, &v277, (void *)a3, 0);
          if (!v80) {
            break;
          }
          int v250 = v78;
          if ((v248 & 0x80000000) != 0)
          {
            if (v279 <= 0xB)
            {
              uint64_t v66 = v277;
              uint64_t v65 = v278;
              (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v278 + 136))(&v294, v278, v277);
              if ((v294.__r_.__value_.__s.__data_[16] & 1) == 0)
              {
                std::string::size_type size = v294.__r_.__value_.__l.__size_;
                std::string::size_type v67 = v294.__r_.__value_.__r.__words[0];
                uint64_t v192 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v66);
                __int16 v70 = (const char *)(v192 + 16);
                if (*(unsigned char *)(v192 + 31)) {
                  size_t v71 = 16;
                }
                else {
                  size_t v71 = strlen(v70);
                }
                __int16 v289 = 1283;
                int v187 = "method_rel_t struct extends past end of (";
LABEL_205:
                v287.__r_.__value_.__r.__words[0] = (std::string::size_type)v187;
                v287.__r_.__value_.__r.__words[2] = (std::string::size_type)v70;
                size_t v288 = v71;
                v290.__r_.__value_.__r.__words[0] = (std::string::size_type)&v287;
                v290.__r_.__value_.__r.__words[2] = (std::string::size_type)",";
                __int16 v291 = 770;
                *(void *)uint64_t v292 = &v290;
                *(void *)&v292[16] = v67;
                *(void *)&v292[24] = size;
                __int16 v293 = 1282;
                __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v292;
                __p.__r_.__value_.__r.__words[2] = (std::string::size_type)") section at address: 0x";
                __int16 v273 = 770;
                uint64_t v188 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v65 + 144))(v65, v66);
                v281[0] = v188 + HIDWORD(v280);
                char v189 = v273;
                if (v273 == 1)
                {
                  p_p = (std::string *)v281;
                  v296.i64[1] = 0;
                  LOWORD(v29++*(_DWORD *)(this + 8) = 270;
                }
                else if ((_BYTE)v273)
                {
                  if (HIBYTE(v273) != 1) {
                    char v189 = 2;
                  }
                  int v190 = &__p;
                  if (HIBYTE(v273) == 1) {
                    int v190 = (std::string *)__p.__r_.__value_.__r.__words[0];
                  }
                  p_p = v190;
                  v296.i64[0] = __p.__r_.__value_.__l.__size_;
                  v296.i64[1] = (uint64_t)v281;
                  LOBYTE(v29++*(_DWORD *)(this + 8) = v189;
                  BYTE1(v29++*(_DWORD *)(this + 8) = 14;
                }
                else
                {
                  LOWORD(v29++*(_DWORD *)(this + 8) = 256;
                }
                sub_1CCC51CE4((uint64_t)v42, (uint64_t *)&p_p);
              }
LABEL_309:
              std::string::size_type v245 = v294.__r_.__value_.__r.__words[0];
              v294.__r_.__value_.__r.__words[0] = 0;
              p_p = (std::string *)v245;
              p_p_p = (uint64_t *)&p_p;
LABEL_306:
              llvm::report_fatal_error(p_p_p);
            }
            signed int v90 = *(_DWORD *)v80;
            unsigned int v91 = *(_DWORD *)(*(void *)a3 + 8);
            BOOL v76 = v91 > 0x13;
            int v92 = (1 << v91) & 0xAAC00;
            BOOL v93 = v76 || v92 == 0;
            unsigned int v94 = bswap32(v90);
            unsigned int v95 = bswap32(*(_DWORD *)(v80 + 8));
            if (v93) {
              signed int v96 = *(_DWORD *)(v80 + 8);
            }
            else {
              signed int v96 = v95;
            }
            if (!v93) {
              signed int v90 = v94;
            }
            uint64_t v97 = (uint64_t *)sub_1CCC6B2B4(v79 + v90, &v280, &v279, &v275, (void *)a3, 0);
            sub_1CCC6A41C((uint64_t)&p_p, 0, v277, v278, a3, &v274, &v271, *v97);
            if (v296.i8[0])
            {
              *uint64_t v42 = p_p;
              goto LABEL_223;
            }
            long long v89 = (const std::string::value_type *)sub_1CCC6B2B4(v271 + v274, &v280, &v279, &v275, (void *)a3, 0);
            uint64_t v87 = v79 + v96 + 8;
            int v88 = HIDWORD(v280);
          }
          else
          {
            if (v279 <= 0x17)
            {
              uint64_t v66 = v277;
              uint64_t v65 = v278;
              (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v278 + 136))(&v294, v278, v277);
              if ((v294.__r_.__value_.__s.__data_[16] & 1) == 0)
              {
                std::string::size_type size = v294.__r_.__value_.__l.__size_;
                std::string::size_type v67 = v294.__r_.__value_.__r.__words[0];
                uint64_t v191 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v66);
                __int16 v70 = (const char *)(v191 + 16);
                if (*(unsigned char *)(v191 + 31)) {
                  size_t v71 = 16;
                }
                else {
                  size_t v71 = strlen(v70);
                }
                __int16 v289 = 1283;
                int v187 = "method64_t struct extends past end of (";
                goto LABEL_205;
              }
              goto LABEL_309;
            }
            unsigned int v81 = *(_DWORD *)(*(void *)a3 + 8);
            BOOL v76 = v81 > 0x13;
            int v82 = (1 << v81) & 0xAAC00;
            BOOL v83 = v76 || v82 == 0;
            unint64_t v84 = bswap64(*(void *)v80);
            unint64_t v85 = bswap64(*(void *)(v80 + 16));
            if (v83) {
              uint64_t v86 = *(void *)v80;
            }
            else {
              uint64_t v86 = v84;
            }
            if (v83) {
              uint64_t v87 = *(void *)(v80 + 16);
            }
            else {
              uint64_t v87 = v85;
            }
            int v88 = HIDWORD(v280);
            sub_1CCC6A41C((uint64_t)&p_p, HIDWORD(v280), v277, v278, a3, &v274, &v271, v86);
            if (v296.i8[0])
            {
              *uint64_t v42 = p_p;
              unsigned int v62 = v259;
              goto LABEL_223;
            }
            long long v89 = (const std::string::value_type *)sub_1CCC6B2B4(v271 + v274, &v280, &v279, &v275, (void *)a3, 0);
            if (*(unsigned char *)(a3 + 61))
            {
              if (*(_DWORD *)(*(void *)a3 + 52) == 16777228
                && (*(_DWORD *)(*(void *)a3 + 56) & 0xFFFFFF) == 2
                && v87 < 0)
              {
                uint64_t v87 = v87;
              }
              else
              {
                v87 &= 0x7FFFFFFFFFFFFuLL;
              }
            }
          }
          HIDWORD(v280) = v88 + v255;
          uint64_t v98 = *(void *)(a3 + 48);
          uint64_t v249 = v87;
          if (*(unsigned char *)(a3 + 60))
          {
            if (!v98)
            {
              uint64_t v140 = *(const char **)(a3 + 40);
              size_t v141 = strlen(v140);
              sub_1CB907098((uint64_t)&v290, v141 + 2);
              if ((v290.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                uint64_t v142 = &v290;
              }
              else {
                uint64_t v142 = (std::string *)v290.__r_.__value_.__r.__words[0];
              }
              LOWORD(v142->__r_.__value_.__l.__data_) = 23339;
              __int16 v143 = &v142->__r_.__value_.__s.__data_[2];
              if (v141) {
                memmove(v143, v140, v141);
              }
              v143[v141] = 0;
              unsigned int v144 = std::string::append(&v290, " ");
              std::string::size_type v145 = v144->__r_.__value_.__r.__words[2];
              *(_OWORD *)uint64_t v292 = *(_OWORD *)&v144->__r_.__value_.__l.__data_;
              *(void *)&v292[16] = v145;
              v144->__r_.__value_.__l.__size_ = 0;
              v144->__r_.__value_.__r.__words[2] = 0;
              v144->__r_.__value_.__r.__words[0] = 0;
              __int16 v146 = std::string::append((std::string *)v292, v89);
              std::string::size_type v147 = v146->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v146->__r_.__value_.__l.__data_;
              __p.__r_.__value_.__r.__words[2] = v147;
              v146->__r_.__value_.__l.__size_ = 0;
              v146->__r_.__value_.__r.__words[2] = 0;
              v146->__r_.__value_.__r.__words[0] = 0;
              unsigned int v148 = std::string::append(&__p, "]");
              std::string::size_type v149 = v148->__r_.__value_.__r.__words[0];
              v294.__r_.__value_.__r.__words[0] = v148->__r_.__value_.__l.__size_;
              *(std::string::size_type *)((char *)v294.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v148->__r_.__value_.__r.__words[1] + 7);
              char v150 = HIBYTE(v148->__r_.__value_.__r.__words[2]);
              v148->__r_.__value_.__l.__size_ = 0;
              v148->__r_.__value_.__r.__words[2] = 0;
              v148->__r_.__value_.__r.__words[0] = 0;
              v287.__r_.__value_.__r.__words[0] = v294.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)v294.__r_.__value_.__r.__words + 7);
              unint64_t v151 = a4->u64[1];
              unint64_t v152 = a4[1].u64[0];
              if (v151 < v152) {
                goto LABEL_157;
              }
              char v153 = a4;
              uint64_t v154 = a4->i64[0];
              uint64_t v155 = (uint64_t)(v151 - a4->i64[0]) >> 5;
              unint64_t v156 = v155 + 1;
              if ((unint64_t)(v155 + 1) >> 59) {
                goto LABEL_307;
              }
              if ((uint64_t)(v152 - v154) >> 4 > v156) {
                unint64_t v156 = (uint64_t)(v152 - v154) >> 4;
              }
              if (v152 - v154 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v157 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v157 = v156;
              }
              unint64_t v297 = 0;
              uint64_t v298 = (uint64_t *)v246;
              if (v157 >> 59) {
                goto LABEL_308;
              }
              uint64_t v158 = (char *)operator new(32 * v157);
              uint64_t v159 = &v158[32 * v155];
              std::string::size_type v160 = v287.__r_.__value_.__r.__words[0];
              *(void *)uint64_t v159 = v149;
              *((void *)v159 + 1) = v160;
              *(void *)(v159 + 15) = *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7);
              v159[23] = v150;
              v287.__r_.__value_.__r.__words[0] = 0;
              *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7) = 0;
              *((void *)v159 + 3) = v249;
              if (v151 != v154)
              {
                unsigned int v161 = &v158[32 * v155];
                a4 = v153;
                do
                {
                  long long v162 = *(_OWORD *)(v151 - 32);
                  *((void *)v161 - 2) = *(void *)(v151 - 16);
                  *((_OWORD *)v161 - 2) = v162;
                  *(void *)(v151 - 24) = 0;
                  *(void *)(v151 - ++*(_DWORD *)(this + 16) = 0;
                  *(void *)(v151 - 32) = 0;
                  *((void *)v161 - 1) = *(void *)(v151 - 8);
                  v161 -= 32;
                  v151 -= 32;
                }
                while (v151 != v154);
                goto LABEL_191;
              }
              goto LABEL_192;
            }
            long long v99 = *(const char **)(a3 + 40);
            size_t v100 = strlen(v99);
            sub_1CB907098((uint64_t)&v294, v100 + 2);
            if ((v294.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v101 = &v294;
            }
            else {
              uint64_t v101 = (std::string *)v294.__r_.__value_.__r.__words[0];
            }
            LOWORD(v101->__r_.__value_.__l.__data_) = 23339;
            uint64_t v102 = &v101->__r_.__value_.__s.__data_[2];
            if (v100) {
              memmove(v102, v99, v100);
            }
            v102[v100] = 0;
            uint64_t v103 = std::string::append(&v294, "(");
            std::string::size_type v104 = v103->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v287.__r_.__value_.__l.__data_ = *(_OWORD *)&v103->__r_.__value_.__l.__data_;
            v287.__r_.__value_.__r.__words[2] = v104;
            v103->__r_.__value_.__l.__size_ = 0;
            v103->__r_.__value_.__r.__words[2] = 0;
            v103->__r_.__value_.__r.__words[0] = 0;
            size_t v105 = std::string::append(&v287, *(const std::string::value_type **)(a3 + 48));
            std::string::size_type v106 = v105->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v290.__r_.__value_.__l.__data_ = *(_OWORD *)&v105->__r_.__value_.__l.__data_;
            v290.__r_.__value_.__r.__words[2] = v106;
            v105->__r_.__value_.__l.__size_ = 0;
            v105->__r_.__value_.__r.__words[2] = 0;
            v105->__r_.__value_.__r.__words[0] = 0;
            uint64_t v107 = std::string::append(&v290, ") ");
            std::string::size_type v108 = v107->__r_.__value_.__r.__words[2];
            *(_OWORD *)uint64_t v292 = *(_OWORD *)&v107->__r_.__value_.__l.__data_;
            *(void *)&v292[16] = v108;
            v107->__r_.__value_.__l.__size_ = 0;
            v107->__r_.__value_.__r.__words[2] = 0;
            v107->__r_.__value_.__r.__words[0] = 0;
            uint64_t v109 = std::string::append((std::string *)v292, v89);
            std::string::size_type v110 = v109->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v109->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v110;
            v109->__r_.__value_.__l.__size_ = 0;
            v109->__r_.__value_.__r.__words[2] = 0;
            v109->__r_.__value_.__r.__words[0] = 0;
            uint64_t v111 = std::string::append(&__p, "]");
            std::string::size_type v112 = v111->__r_.__value_.__r.__words[0];
            v286[0] = v111->__r_.__value_.__l.__size_;
            *(uint64_t *)((char *)v286 + 7) = *(std::string::size_type *)((char *)&v111->__r_.__value_.__r.__words[1] + 7);
            char v113 = HIBYTE(v111->__r_.__value_.__r.__words[2]);
            v111->__r_.__value_.__l.__size_ = 0;
            v111->__r_.__value_.__r.__words[2] = 0;
            v111->__r_.__value_.__r.__words[0] = 0;
            v281[0] = v286[0];
            *(void *)((char *)v281 + 7) = *(uint64_t *)((char *)v286 + 7);
            v286[0] = 0;
            *(uint64_t *)((char *)v286 + 7) = 0;
            unint64_t v114 = a4->u64[1];
            unint64_t v115 = a4[1].u64[0];
            if (v114 >= v115)
            {
              unsigned int v116 = a4;
              uint64_t v117 = a4->i64[0];
              uint64_t v118 = (uint64_t)(v114 - a4->i64[0]) >> 5;
              unint64_t v119 = v118 + 1;
              if ((unint64_t)(v118 + 1) >> 59) {
                goto LABEL_307;
              }
              if ((uint64_t)(v115 - v117) >> 4 > v119) {
                unint64_t v119 = (uint64_t)(v115 - v117) >> 4;
              }
              if (v115 - v117 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v120 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v120 = v119;
              }
              unint64_t v297 = 0;
              uint64_t v298 = (uint64_t *)v246;
              if (v120 >> 59) {
                goto LABEL_308;
              }
              uint64_t v121 = (char *)operator new(32 * v120);
              size_t v122 = &v121[32 * v118];
              uint64_t v123 = v281[0];
              *(void *)size_t v122 = v112;
              *((void *)v122 + 1) = v123;
              *(void *)(v122 + 15) = *(void *)((char *)v281 + 7);
              v122[23] = v113;
              memset(v281, 0, 15);
              *((void *)v122 + 3) = v249;
              if (v114 != v117)
              {
                int v124 = &v121[32 * v118];
                a4 = v116;
                do
                {
                  long long v125 = *(_OWORD *)(v114 - 32);
                  *((void *)v124 - 2) = *(void *)(v114 - 16);
                  *((_OWORD *)v124 - 2) = v125;
                  *(void *)(v114 - 24) = 0;
                  *(void *)(v114 - ++*(_DWORD *)(this + 16) = 0;
                  *(void *)(v114 - 32) = 0;
                  *((void *)v124 - 1) = *(void *)(v114 - 8);
                  v124 -= 32;
                  v114 -= 32;
                }
                while (v114 != v117);
                goto LABEL_168;
              }
              goto LABEL_169;
            }
          }
          else
          {
            if (!v98)
            {
              BOOL v163 = *(const char **)(a3 + 40);
              size_t v164 = strlen(v163);
              sub_1CB907098((uint64_t)&v290, v164 + 2);
              if ((v290.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                size_t v165 = &v290;
              }
              else {
                size_t v165 = (std::string *)v290.__r_.__value_.__r.__words[0];
              }
              LOWORD(v165->__r_.__value_.__l.__data_) = 23341;
              __int16 v166 = &v165->__r_.__value_.__s.__data_[2];
              if (v164) {
                memmove(v166, v163, v164);
              }
              v166[v164] = 0;
              uint64_t v167 = std::string::append(&v290, " ");
              std::string::size_type v168 = v167->__r_.__value_.__r.__words[2];
              *(_OWORD *)uint64_t v292 = *(_OWORD *)&v167->__r_.__value_.__l.__data_;
              *(void *)&v292[16] = v168;
              v167->__r_.__value_.__l.__size_ = 0;
              v167->__r_.__value_.__r.__words[2] = 0;
              v167->__r_.__value_.__r.__words[0] = 0;
              int64x2_t v169 = std::string::append((std::string *)v292, v89);
              std::string::size_type v170 = v169->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v169->__r_.__value_.__l.__data_;
              __p.__r_.__value_.__r.__words[2] = v170;
              v169->__r_.__value_.__l.__size_ = 0;
              v169->__r_.__value_.__r.__words[2] = 0;
              v169->__r_.__value_.__r.__words[0] = 0;
              long long v171 = std::string::append(&__p, "]");
              std::string::size_type v149 = v171->__r_.__value_.__r.__words[0];
              v294.__r_.__value_.__r.__words[0] = v171->__r_.__value_.__l.__size_;
              *(std::string::size_type *)((char *)v294.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v171->__r_.__value_.__r.__words[1] + 7);
              char v150 = HIBYTE(v171->__r_.__value_.__r.__words[2]);
              v171->__r_.__value_.__l.__size_ = 0;
              v171->__r_.__value_.__r.__words[2] = 0;
              v171->__r_.__value_.__r.__words[0] = 0;
              v287.__r_.__value_.__r.__words[0] = v294.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)v294.__r_.__value_.__r.__words + 7);
              unint64_t v151 = a4->u64[1];
              unint64_t v152 = a4[1].u64[0];
              if (v151 < v152)
              {
LABEL_157:
                *(void *)unint64_t v151 = v149;
                *(void *)(v151 + ++*(_DWORD *)(this + 8) = v287.__r_.__value_.__r.__words[0];
                *(void *)(v151 + 15) = *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7);
                *(unsigned char *)(v151 + 23) = v150;
                *(void *)(v151 + 24) = v249;
                unint64_t v172 = v151 + 32;
                uint64_t v42 = v261;
LABEL_194:
                unsigned int v62 = v259;
                int v179 = v250;
                a4->i64[1] = v172;
                uint64_t v43 = v257;
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                if ((v292[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v292);
                }
                if ((SHIBYTE(v290.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_201;
                }
                uint64_t v180 = (void *)v290.__r_.__value_.__r.__words[0];
                goto LABEL_200;
              }
              char v153 = a4;
              uint64_t v181 = a4->i64[0];
              uint64_t v182 = (uint64_t)(v151 - a4->i64[0]) >> 5;
              unint64_t v183 = v182 + 1;
              if ((unint64_t)(v182 + 1) >> 59) {
                goto LABEL_307;
              }
              if ((uint64_t)(v152 - v181) >> 4 > v183) {
                unint64_t v183 = (uint64_t)(v152 - v181) >> 4;
              }
              if (v152 - v181 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v157 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v157 = v183;
              }
              unint64_t v297 = 0;
              uint64_t v298 = (uint64_t *)v246;
              if (v157 >> 59) {
                goto LABEL_308;
              }
              uint64_t v158 = (char *)operator new(32 * v157);
              uint64_t v159 = &v158[32 * v182];
              std::string::size_type v184 = v287.__r_.__value_.__r.__words[0];
              *(void *)uint64_t v159 = v149;
              *((void *)v159 + 1) = v184;
              *(void *)(v159 + 15) = *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7);
              v159[23] = v150;
              v287.__r_.__value_.__r.__words[0] = 0;
              *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7) = 0;
              *((void *)v159 + 3) = v249;
              if (v151 != v181)
              {
                unsigned int v161 = &v158[32 * v182];
                a4 = v153;
                do
                {
                  long long v185 = *(_OWORD *)(v151 - 32);
                  *((void *)v161 - 2) = *(void *)(v151 - 16);
                  *((_OWORD *)v161 - 2) = v185;
                  *(void *)(v151 - 24) = 0;
                  *(void *)(v151 - ++*(_DWORD *)(this + 16) = 0;
                  *(void *)(v151 - 32) = 0;
                  *((void *)v161 - 1) = *(void *)(v151 - 8);
                  v161 -= 32;
                  v151 -= 32;
                }
                while (v151 != v181);
LABEL_191:
                int64x2_t v186 = *a4;
                unint64_t v152 = a4[1].u64[0];
LABEL_193:
                unint64_t v172 = (unint64_t)(v159 + 32);
                a4->i64[0] = (uint64_t)v161;
                a4->i64[1] = (uint64_t)(v159 + 32);
                int64x2_t v296 = v186;
                a4[1].i64[0] = (uint64_t)&v158[32 * v157];
                unint64_t v297 = v152;
                p_p = (std::string *)v186.i64[0];
                sub_1CD573B00((uint64_t)&p_p);
                uint64_t v42 = v261;
                goto LABEL_194;
              }
LABEL_192:
              int64x2_t v186 = vdupq_n_s64(v151);
              unsigned int v161 = v159;
              a4 = v153;
              goto LABEL_193;
            }
            char v126 = *(const char **)(a3 + 40);
            size_t v127 = strlen(v126);
            sub_1CB907098((uint64_t)&v294, v127 + 2);
            if ((v294.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v128 = &v294;
            }
            else {
              unint64_t v128 = (std::string *)v294.__r_.__value_.__r.__words[0];
            }
            LOWORD(v128->__r_.__value_.__l.__data_) = 23341;
            unint64_t v129 = &v128->__r_.__value_.__s.__data_[2];
            if (v127) {
              memmove(v129, v126, v127);
            }
            v129[v127] = 0;
            int v130 = std::string::append(&v294, "(");
            std::string::size_type v131 = v130->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v287.__r_.__value_.__l.__data_ = *(_OWORD *)&v130->__r_.__value_.__l.__data_;
            v287.__r_.__value_.__r.__words[2] = v131;
            v130->__r_.__value_.__l.__size_ = 0;
            v130->__r_.__value_.__r.__words[2] = 0;
            v130->__r_.__value_.__r.__words[0] = 0;
            __int16 v132 = std::string::append(&v287, *(const std::string::value_type **)(a3 + 48));
            std::string::size_type v133 = v132->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v290.__r_.__value_.__l.__data_ = *(_OWORD *)&v132->__r_.__value_.__l.__data_;
            v290.__r_.__value_.__r.__words[2] = v133;
            v132->__r_.__value_.__l.__size_ = 0;
            v132->__r_.__value_.__r.__words[2] = 0;
            v132->__r_.__value_.__r.__words[0] = 0;
            uint64_t v134 = std::string::append(&v290, ") ");
            std::string::size_type v135 = v134->__r_.__value_.__r.__words[2];
            *(_OWORD *)uint64_t v292 = *(_OWORD *)&v134->__r_.__value_.__l.__data_;
            *(void *)&v292[16] = v135;
            v134->__r_.__value_.__l.__size_ = 0;
            v134->__r_.__value_.__r.__words[2] = 0;
            v134->__r_.__value_.__r.__words[0] = 0;
            __int16 v136 = std::string::append((std::string *)v292, v89);
            std::string::size_type v137 = v136->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v136->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v137;
            v136->__r_.__value_.__l.__size_ = 0;
            v136->__r_.__value_.__r.__words[2] = 0;
            v136->__r_.__value_.__r.__words[0] = 0;
            uint64_t v138 = std::string::append(&__p, "]");
            std::string::size_type v112 = v138->__r_.__value_.__r.__words[0];
            v286[0] = v138->__r_.__value_.__l.__size_;
            *(uint64_t *)((char *)v286 + 7) = *(std::string::size_type *)((char *)&v138->__r_.__value_.__r.__words[1] + 7);
            char v113 = HIBYTE(v138->__r_.__value_.__r.__words[2]);
            v138->__r_.__value_.__l.__size_ = 0;
            v138->__r_.__value_.__r.__words[2] = 0;
            v138->__r_.__value_.__r.__words[0] = 0;
            v281[0] = v286[0];
            *(void *)((char *)v281 + 7) = *(uint64_t *)((char *)v286 + 7);
            v286[0] = 0;
            *(uint64_t *)((char *)v286 + 7) = 0;
            unint64_t v114 = a4->u64[1];
            unint64_t v115 = a4[1].u64[0];
            if (v114 >= v115)
            {
              unsigned int v116 = a4;
              uint64_t v173 = a4->i64[0];
              uint64_t v174 = (uint64_t)(v114 - a4->i64[0]) >> 5;
              unint64_t v175 = v174 + 1;
              if ((unint64_t)(v174 + 1) >> 59) {
                goto LABEL_307;
              }
              if ((uint64_t)(v115 - v173) >> 4 > v175) {
                unint64_t v175 = (uint64_t)(v115 - v173) >> 4;
              }
              if (v115 - v173 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v120 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v120 = v175;
              }
              unint64_t v297 = 0;
              uint64_t v298 = (uint64_t *)v246;
              if (v120 >> 59) {
                goto LABEL_308;
              }
              uint64_t v121 = (char *)operator new(32 * v120);
              size_t v122 = &v121[32 * v174];
              uint64_t v176 = v281[0];
              *(void *)size_t v122 = v112;
              *((void *)v122 + 1) = v176;
              *(void *)(v122 + 15) = *(void *)((char *)v281 + 7);
              v122[23] = v113;
              memset(v281, 0, 15);
              *((void *)v122 + 3) = v249;
              if (v114 != v173)
              {
                int v124 = &v121[32 * v174];
                a4 = v116;
                do
                {
                  long long v177 = *(_OWORD *)(v114 - 32);
                  *((void *)v124 - 2) = *(void *)(v114 - 16);
                  *((_OWORD *)v124 - 2) = v177;
                  *(void *)(v114 - 24) = 0;
                  *(void *)(v114 - ++*(_DWORD *)(this + 16) = 0;
                  *(void *)(v114 - 32) = 0;
                  *((void *)v124 - 1) = *(void *)(v114 - 8);
                  v124 -= 32;
                  v114 -= 32;
                }
                while (v114 != v173);
LABEL_168:
                int64x2_t v178 = *a4;
                unint64_t v115 = a4[1].u64[0];
LABEL_170:
                unint64_t v139 = (unint64_t)(v122 + 32);
                a4->i64[0] = (uint64_t)v124;
                a4->i64[1] = (uint64_t)(v122 + 32);
                int64x2_t v296 = v178;
                a4[1].i64[0] = (uint64_t)&v121[32 * v120];
                unint64_t v297 = v115;
                p_p = (std::string *)v178.i64[0];
                sub_1CD573B00((uint64_t)&p_p);
                uint64_t v42 = v261;
                goto LABEL_171;
              }
LABEL_169:
              int64x2_t v178 = vdupq_n_s64(v114);
              int v124 = v122;
              a4 = v116;
              goto LABEL_170;
            }
          }
          *(void *)unint64_t v114 = v112;
          *(void *)(v114 + ++*(_DWORD *)(this + 8) = v281[0];
          *(void *)(v114 + 15) = *(void *)((char *)v281 + 7);
          *(unsigned char *)(v114 + 23) = v113;
          memset(v281, 0, 15);
          *(void *)(v114 + 24) = v249;
          unint64_t v139 = v114 + 32;
          uint64_t v42 = v261;
LABEL_171:
          unsigned int v62 = v259;
          int v179 = v250;
          a4->i64[1] = v139;
          uint64_t v43 = v257;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if ((v292[23] & 0x80000000) != 0) {
            operator delete(*(void **)v292);
          }
          if (SHIBYTE(v290.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v290.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v287.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v287.__r_.__value_.__l.__data_);
          }
          if ((SHIBYTE(v294.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_201;
          }
          uint64_t v180 = (void *)v294.__r_.__value_.__r.__words[0];
LABEL_200:
          operator delete(v180);
LABEL_201:
          v79 += (unsigned __int16)v248;
          int v78 = v179 + 1;
        }
        while (v78 != v247);
      }
    }
    *uint64_t v42 = 0;
LABEL_223:
    if (*v42) {
      goto LABEL_295;
    }
  }
  sub_1CCC6A41C((uint64_t)v281, v62 + 48, v252, v43, a3, &v264, &v263, v251);
  if (v281[1])
  {
    int v202 = (std::string *)v281[0];
    goto LABEL_291;
  }
  uint64_t v193 = v263 + v264;
  if (!(v263 + v264))
  {
    int v202 = 0;
    goto LABEL_291;
  }
  uint64_t v280 = 0;
  unsigned int v279 = 0;
  uint64_t v277 = 0;
  uint64_t v278 = 0;
  uint64_t v275 = 0;
  uint64_t v276 = 0;
  v286[0] = 0;
  uint64_t v274 = 0;
  uint64_t v194 = sub_1CCC6B2B4(v263 + v264, (_DWORD *)&v280 + 1, &v279, &v277, (void *)a3, 0);
  if (!v194) {
    goto LABEL_282;
  }
  if (v279 <= 7)
  {
    uint64_t v196 = v277;
    uint64_t v195 = v278;
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v278 + 136))(&v294, v278, v277);
    if (v294.__r_.__value_.__s.__data_[16]) {
      goto LABEL_309;
    }
    std::string::size_type v198 = v294.__r_.__value_.__l.__size_;
    std::string::size_type v197 = v294.__r_.__value_.__r.__words[0];
    uint64_t v199 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v196);
    unint64_t v200 = (const char *)(v199 + 16);
    if (*(unsigned char *)(v199 + 31)) {
      size_t v201 = 16;
    }
    else {
      size_t v201 = strlen(v200);
    }
    __int16 v289 = 1283;
    uint64_t v240 = "ivar_list64_t struct extends past end of (";
    goto LABEL_285;
  }
  unsigned int v203 = *(_DWORD *)(*(void *)a3 + 8);
  unsigned int v204 = bswap32(*(_DWORD *)(v194 + 4));
  if (((1 << v203) & 0xAAC00) == 0) {
    unsigned int v204 = *(_DWORD *)(v194 + 4);
  }
  unsigned int v205 = v203 <= 0x13 ? v204 : *(_DWORD *)(v194 + 4);
  HIDWORD(v280) += 8;
  unsigned int v258 = v205;
  if (!v205)
  {
LABEL_282:
    *uint64_t v42 = 0;
    goto LABEL_290;
  }
  unint64_t v206 = v193 + 8;
  int v207 = 0;
  uint64_t v253 = a4 + 1;
  while (1)
  {
    unsigned int v208 = (unint64_t *)sub_1CCC6B2B4(v206, (_DWORD *)&v280 + 1, &v279, &v277, (void *)a3, 0);
    if (!v208) {
      goto LABEL_282;
    }
    if (v279 <= 0x1F)
    {
      uint64_t v196 = v277;
      uint64_t v195 = v278;
      (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v278 + 136))(&v294, v278, v277);
      if (v294.__r_.__value_.__s.__data_[16]) {
        goto LABEL_309;
      }
      std::string::size_type v198 = v294.__r_.__value_.__l.__size_;
      std::string::size_type v197 = v294.__r_.__value_.__r.__words[0];
      uint64_t v242 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v196);
      unint64_t v200 = (const char *)(v242 + 16);
      if (*(unsigned char *)(v242 + 31)) {
        size_t v201 = 16;
      }
      else {
        size_t v201 = strlen(v200);
      }
      __int16 v289 = 1283;
      uint64_t v240 = "ivar_t struct extends past end of (";
LABEL_285:
      v287.__r_.__value_.__r.__words[0] = (std::string::size_type)v240;
      v287.__r_.__value_.__r.__words[2] = (std::string::size_type)v200;
      size_t v288 = v201;
      v290.__r_.__value_.__r.__words[0] = (std::string::size_type)&v287;
      v290.__r_.__value_.__r.__words[2] = (std::string::size_type)",";
      __int16 v291 = 770;
      *(void *)uint64_t v292 = &v290;
      *(void *)&v292[16] = v197;
      *(void *)&v292[24] = v198;
      __int16 v293 = 1282;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v292;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)") section at address: 0x";
      __int16 v273 = 770;
      uint64_t v241 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v195 + 144))(v195, v196);
      uint64_t v271 = v241 + HIDWORD(v280);
      p_p = &__p;
      v296.i64[1] = (uint64_t)&v271;
      LOWORD(v29++*(_DWORD *)(this + 8) = 3586;
      sub_1CCC51CE4((uint64_t)v42, (uint64_t *)&p_p);
    }
    unsigned int v209 = *(_DWORD *)(*(void *)a3 + 8);
    BOOL v76 = v209 > 0x13;
    int v210 = (1 << v209) & 0xAAC00;
    BOOL v211 = v76 || v210 == 0;
    unint64_t v212 = bswap64(*v208);
    unint64_t v213 = bswap64(v208[1]);
    uint64_t v214 = v211 ? v208[1] : v213;
    unint64_t v215 = v211 ? *v208 : v212;
    sub_1CCC6A41C((uint64_t)&v290, HIDWORD(v280) + 8, v277, v278, a3, v286, &v274, v214);
    if (v290.__r_.__value_.__s.__data_[8]) {
      break;
    }
    uint64_t v216 = (const std::string::value_type *)sub_1CCC6B2B4(v274 + v286[0], &v280, &v279, &v275, (void *)a3, 0);
    if (*(unsigned char *)(a3 + 61))
    {
      if (*(_DWORD *)(*(void *)a3 + 52) == 16777228
        && (*(_DWORD *)(*(void *)a3 + 56) & 0xFFFFFF) == 2
        && (v215 & 0x8000000000000000) != 0)
      {
        unint64_t v215 = v215;
      }
      else
      {
        v215 &= 0x7FFFFFFFFFFFFuLL;
      }
    }
    unint64_t v260 = v206;
    int v217 = *(const char **)(a3 + 40);
    size_t v218 = strlen(v217);
    sub_1CB907098((uint64_t)v292, v218 + 13);
    uint64_t v219 = v292;
    if (v292[23] < 0) {
      uint64_t v219 = *(unsigned char **)v292;
    }
    qmemcpy(v219, "_OBJC_IVAR_$_", 13);
    uint64_t v220 = v219 + 13;
    if (v218) {
      memmove(v219 + 13, v217, v218);
    }
    v220[v218] = 0;
    __int16 v221 = std::string::append((std::string *)v292, ".");
    std::string::size_type v222 = v221->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v221->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v222;
    v221->__r_.__value_.__l.__size_ = 0;
    v221->__r_.__value_.__r.__words[2] = 0;
    v221->__r_.__value_.__r.__words[0] = 0;
    unint64_t v223 = std::string::append(&__p, v216);
    std::string::size_type v224 = v223->__r_.__value_.__r.__words[0];
    v294.__r_.__value_.__r.__words[0] = v223->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v294.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v223->__r_.__value_.__r.__words[1] + 7);
    char v225 = HIBYTE(v223->__r_.__value_.__r.__words[2]);
    v223->__r_.__value_.__l.__size_ = 0;
    v223->__r_.__value_.__r.__words[2] = 0;
    v223->__r_.__value_.__r.__words[0] = 0;
    v287.__r_.__value_.__r.__words[0] = v294.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)v294.__r_.__value_.__r.__words + 7);
    unint64_t v226 = a4->u64[1];
    unint64_t v227 = a4[1].u64[0];
    if (v226 >= v227)
    {
      int v256 = v207;
      int v229 = a4;
      uint64_t v230 = a4->i64[0];
      uint64_t v231 = (uint64_t)(v226 - a4->i64[0]) >> 5;
      unint64_t v232 = v231 + 1;
      if ((unint64_t)(v231 + 1) >> 59) {
        goto LABEL_307;
      }
      if ((uint64_t)(v227 - v230) >> 4 > v232) {
        unint64_t v232 = (uint64_t)(v227 - v230) >> 4;
      }
      if (v227 - v230 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v233 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v233 = v232;
      }
      unint64_t v297 = 0;
      uint64_t v298 = (uint64_t *)v253;
      if (v233 >> 59) {
        goto LABEL_308;
      }
      unsigned int v234 = (char *)operator new(32 * v233);
      size_t v235 = &v234[32 * v231];
      std::string::size_type v236 = v287.__r_.__value_.__r.__words[0];
      *(void *)size_t v235 = v224;
      *((void *)v235 + 1) = v236;
      *(void *)(v235 + 15) = *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7);
      v235[23] = v225;
      v287.__r_.__value_.__r.__words[0] = 0;
      *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7) = 0;
      *((void *)v235 + 3) = v215;
      if (v226 == v230)
      {
        int64x2_t v239 = vdupq_n_s64(v226);
        unint64_t v237 = &v234[32 * v231];
        uint64_t v42 = v261;
        a4 = v229;
      }
      else
      {
        unint64_t v237 = &v234[32 * v231];
        uint64_t v42 = v261;
        a4 = v229;
        do
        {
          long long v238 = *(_OWORD *)(v226 - 32);
          *((void *)v237 - 2) = *(void *)(v226 - 16);
          *((_OWORD *)v237 - 2) = v238;
          *(void *)(v226 - 24) = 0;
          *(void *)(v226 - ++*(_DWORD *)(this + 16) = 0;
          *(void *)(v226 - 32) = 0;
          *((void *)v237 - 1) = *(void *)(v226 - 8);
          v237 -= 32;
          v226 -= 32;
        }
        while (v226 != v230);
        int64x2_t v239 = *v229;
        unint64_t v227 = v229[1].u64[0];
      }
      int v207 = v256;
      unint64_t v228 = (unint64_t)(v235 + 32);
      a4->i64[0] = (uint64_t)v237;
      a4->i64[1] = (uint64_t)(v235 + 32);
      int64x2_t v296 = v239;
      a4[1].i64[0] = (uint64_t)&v234[32 * v233];
      unint64_t v297 = v227;
      p_p = (std::string *)v239.i64[0];
      sub_1CD573B00((uint64_t)&p_p);
    }
    else
    {
      *(void *)unint64_t v226 = v224;
      *(void *)(v226 + ++*(_DWORD *)(this + 8) = v287.__r_.__value_.__r.__words[0];
      *(void *)(v226 + 15) = *(std::string::size_type *)((char *)v287.__r_.__value_.__r.__words + 7);
      *(unsigned char *)(v226 + 23) = v225;
      *(void *)(v226 + 24) = v215;
      unint64_t v228 = v226 + 32;
      uint64_t v42 = v261;
    }
    a4->i64[1] = v228;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if ((v292[23] & 0x80000000) != 0) {
      operator delete(*(void **)v292);
    }
    unint64_t v206 = v260 + 32;
    if (++v207 == v258) {
      goto LABEL_282;
    }
  }
  uint64_t v42 = v261;
  *char v261 = (std::string *)v290.__r_.__value_.__r.__words[0];
LABEL_290:
  int v202 = *v42;
  if (!*v42) {
LABEL_291:
  }
    *uint64_t v42 = v202;
  if ((v283 & 1) != 0 && v282) {
    (*(void (**)(std::string *))(v282->__r_.__value_.__r.__words[0] + 8))(v282);
  }
LABEL_295:
  if ((v285 & 1) != 0 && v284) {
    (*(void (**)(std::string *))(v284->__r_.__value_.__r.__words[0] + 8))(v284);
  }
}

void sub_1CCC6D104(void *a1, unsigned int a2, void *a3, char **a4)
{
  while (1)
  {
    unsigned int v4 = a4;
    uint64_t v5 = (uint64_t)a3;
    uint64_t v6 = a1;
    uint64_t v45 = *MEMORY[0x1E4F143B8];
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v7 = a2;
    uint64_t v40 = 0;
    unsigned int v8 = (unsigned int *)sub_1CCC6B2B4(a2, (_DWORD *)&v42 + 1, &v42, &v40, a3, 0);
    if (v8) {
      BOOL v9 = v42 > 0x13;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v9)
    {
      uint64_t v11 = v40;
      uint64_t v10 = v41;
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)v41 + 136))(v43, v41, v40);
      if ((v44 & 1) == 0)
      {
        uint64_t v12 = *(void *)(*(void *)(*(void *)v5 + 80) + 8 * v11);
        unint64_t v13 = (const char *)(v12 + 16);
        if (*(unsigned char *)(v12 + 31)) {
          size_t v14 = 16;
        }
        else {
          size_t v14 = strlen(v13);
        }
        __int16 v30 = 1283;
        v29[0] = "class_t struct extends past end of (";
        v29[2] = v13;
        v29[3] = v14;
        v31[0] = v29;
        void v31[2] = ",";
        __int16 v32 = 770;
        v33[0] = v31;
        _OWORD v33[2] = v43[0];
        v33[3] = v43[1];
        __int16 v34 = 1282;
        v35[0] = v33;
        v35[2] = ") section at address: 0x";
        __int16 v36 = 770;
        uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 144))(v10, v11);
        uint64_t v28 = v26 + HIDWORD(v42);
        v37[0] = (uint64_t)v35;
        void v37[2] = (uint64_t)&v28;
        __int16 v38 = 3586;
        sub_1CCC51CE4((uint64_t)v6, v37);
      }
      uint64_t v27 = v43[0];
      v43[0] = 0;
      uint64_t v39 = v27;
      llvm::report_fatal_error(&v39);
    }
    unsigned int v15 = *v8;
    unsigned int v16 = v8[4];
    unsigned int v17 = *(_DWORD *)(*(void *)v5 + 8);
    BOOL v9 = v17 > 0x13;
    int v18 = (1 << v17) & 0xAAC00;
    BOOL v19 = v9 || v18 == 0;
    unsigned int v20 = bswap32(v15);
    unsigned int v21 = bswap32(v16);
    uint64_t v22 = v19 ? v15 : v20;
    uint64_t v23 = v19 ? v16 : v21;
    char v24 = *(unsigned char *)(v5 + 60);
    *(unsigned char *)(v5 + 60) = 0;
    *(void *)(v5 + 32) = v7;
    int v25 = sub_1CCC6A390(*(void *)(v5 + 80), v23);
    sub_1CCC6D404((uint64_t)v6, v25 & 0xFFFFFFFC, v5, v4);
    if (*v6) {
      break;
    }
    if (*(unsigned char *)(v5 + 60))
    {
      *(unsigned char *)(v5 + 60) = v24;
      *uint64_t v6 = 0;
      return;
    }
    a2 = sub_1CCC6A390(*(void *)(v5 + 80), v22);
    a1 = v6;
    a3 = (void *)v5;
    a4 = v4;
  }
}

void sub_1CCC6D404(uint64_t a1, unsigned int a2, uint64_t a3, char **a4)
{
  uint64_t v268 = *MEMORY[0x1E4F143B8];
  unsigned int v245 = 0;
  unsigned int v243 = 0;
  uint64_t v241 = 0;
  uint64_t v242 = 0;
  v240[0] = 0;
  v240[1] = 0;
  uint64_t v7 = (unsigned int *)sub_1CCC6B2B4(a2, &v245, &v243, &v241, (void *)a3, 0);
  if (!v7 || v243 <= 0x27)
  {
    uint64_t v45 = v241;
    uint64_t v44 = v242;
    (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v242 + 136))(&v267, v242, v241);
    if ((v267.__r_.__value_.__s.__data_[16] & 1) == 0)
    {
      uint64_t v46 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v45);
      uint64_t v47 = (const char *)(v46 + 16);
      if (*(unsigned char *)(v46 + 31)) {
        size_t v48 = 16;
      }
      else {
        size_t v48 = strlen(v47);
      }
      __int16 v262 = 1283;
      v260.__r_.__value_.__r.__words[0] = (std::string::size_type)"class_ro32_t struct extends past end of (";
      v260.__r_.__value_.__r.__words[2] = (std::string::size_type)v47;
      size_t v261 = v48;
      v263.__r_.__value_.__r.__words[0] = (std::string::size_type)&v260;
      v263.__r_.__value_.__r.__words[2] = (std::string::size_type)",";
      __int16 v264 = 770;
      *(void *)int v265 = &v263;
      *(_OWORD *)&v265[16] = *(_OWORD *)&v267.__r_.__value_.__l.__data_;
      __int16 v266 = 1282;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v265;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)") section at address: 0x";
      __int16 v248 = 770;
      uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v44 + 144))(v44, v45);
      uint64_t v251 = v55 + v245;
      p_p = &__p;
      v255.i64[1] = (uint64_t)&v251;
      LOWORD(v257) = 3586;
      sub_1CCC51CE4(a1, (uint64_t *)&p_p);
    }
    std::string::size_type v227 = v267.__r_.__value_.__r.__words[0];
    v267.__r_.__value_.__r.__words[0] = 0;
    std::string::size_type v239 = v227;
    p_p_p = (uint64_t *)&v239;
    goto LABEL_261;
  }
  unint64_t v237 = (void *)a1;
  unsigned int v8 = *v7;
  unsigned int v9 = v7[4];
  unsigned int v10 = v7[5];
  unsigned int v11 = v7[7];
  unsigned int v12 = *(_DWORD *)(*(void *)a3 + 8);
  BOOL v13 = v12 > 0x13;
  int v14 = (1 << v12) & 0xAAC00;
  BOOL v15 = v13 || v14 == 0;
  char v16 = bswap32(v8);
  unsigned int v17 = bswap32(v9);
  unsigned int v18 = bswap32(v10);
  unsigned int v19 = bswap32(v11);
  if (v15) {
    uint64_t v20 = v9;
  }
  else {
    uint64_t v20 = v17;
  }
  if (v15)
  {
    unint64_t v21 = v10;
  }
  else
  {
    LOBYTE(v++*(_DWORD *)(this + 8) = v16;
    unint64_t v21 = v18;
  }
  if (v15) {
    unint64_t v22 = v11;
  }
  else {
    unint64_t v22 = v19;
  }
  unint64_t v233 = v22;
  int v244 = 0;
  *(unsigned char *)(a3 + 60) = v8 & 1;
  unsigned int v23 = sub_1CCC6A390(*(void *)(a3 + 80), v20);
  char v24 = (const char *)sub_1CCC6B2B4(v23, &v244, &v243, v240, (void *)a3, 0);
  int v25 = v24;
  *(void *)(a3 + 40) = v24;
  long long v238 = a4;
  if (!*(unsigned char *)(a3 + 60))
  {
    size_t v49 = strlen(v24);
    sub_1CB907098((uint64_t)&__p, v49 + 14);
    uint64_t v50 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v50 = &__p;
    }
    qmemcpy(v50, "_OBJC_CLASS_$_", 14);
    size_t v51 = &v50->__r_.__value_.__s.__data_[14];
    if (v49) {
      memmove((char *)&v50->__r_.__value_.__r.__words[1] + 6, v25, v49);
    }
    v51[v49] = 0;
    *(void *)int v265 = __p.__r_.__value_.__l.__size_;
    std::string::size_type v29 = __p.__r_.__value_.__r.__words[0];
    *(void *)&v265[7] = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
    char v30 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    memset(&__p, 0, sizeof(__p));
    uint64_t v31 = *(void *)(a3 + 32);
    uint64_t v52 = a4 + 2;
    unint64_t v33 = (unint64_t)a4[2];
    unint64_t v34 = (unint64_t)a4[1];
    if (v34 >= v33)
    {
      uint64_t v56 = *a4;
      uint64_t v57 = (uint64_t)(v34 - (void)*a4) >> 5;
      unint64_t v58 = v57 + 1;
      if (!((unint64_t)(v57 + 1) >> 59))
      {
        if ((uint64_t)(v33 - (void)v56) >> 4 > v58) {
          unint64_t v58 = (uint64_t)(v33 - (void)v56) >> 4;
        }
        if (v33 - (unint64_t)v56 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v38 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v38 = v58;
        }
        unint64_t v256 = 0;
        uint64_t v257 = v52;
        if (!(v38 >> 59))
        {
          uint64_t v39 = (char *)operator new(32 * v38);
          uint64_t v40 = &v39[32 * v57];
          uint64_t v59 = *(void *)v265;
          *(void *)uint64_t v40 = v29;
          *((void *)v40 + 1) = v59;
          *(void *)(v40 + 15) = *(void *)&v265[7];
          v40[23] = v30;
          *(void *)int v265 = 0;
          *(void *)&v265[7] = 0;
          *((void *)v40 + 3) = v31;
          if ((char *)v34 != v56)
          {
            uint64_t v42 = &v39[32 * v57];
            a4 = v238;
            do
            {
              long long v60 = *(_OWORD *)(v34 - 32);
              *((void *)v42 - 2) = *(void *)(v34 - 16);
              *((_OWORD *)v42 - 2) = v60;
              *(void *)(v34 - 24) = 0;
              *(void *)(v34 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v34 - 32) = 0;
              *((void *)v42 - 1) = *(void *)(v34 - 8);
              v42 -= 32;
              v34 -= 32;
            }
            while ((char *)v34 != v56);
            goto LABEL_53;
          }
LABEL_54:
          int64x2_t v61 = vdupq_n_s64(v34);
          uint64_t v42 = v40;
          a4 = v238;
          goto LABEL_55;
        }
LABEL_258:
        sub_1CB833614();
      }
LABEL_257:
      abort();
    }
LABEL_40:
    *(void *)unint64_t v34 = v29;
    *(void *)(v34 + ++*(_DWORD *)(this + 8) = *(void *)v265;
    *(void *)(v34 + 15) = *(void *)&v265[7];
    *(unsigned char *)(v34 + 23) = v30;
    *(void *)(v34 + 24) = v31;
    unint64_t v53 = v34 + 32;
    unint64_t v54 = v237;
    goto LABEL_56;
  }
  size_t v26 = strlen(v24);
  sub_1CB907098((uint64_t)&__p, v26 + 18);
  uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v27 = &__p;
  }
  *(_OWORD *)&v27->__r_.__value_.__l.__data_ = *(_OWORD *)"_OBJC_METACLASS_$_";
  LOWORD(v27->__r_.__value_.__r.__words[2]) = 24356;
  uint64_t v28 = &v27->__r_.__value_.__s.__data_[18];
  if (v26) {
    memmove((char *)&v27->__r_.__value_.__r.__words[2] + 2, v25, v26);
  }
  v28[v26] = 0;
  *(void *)int v265 = __p.__r_.__value_.__l.__size_;
  std::string::size_type v29 = __p.__r_.__value_.__r.__words[0];
  *(void *)&v265[7] = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
  char v30 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  memset(&__p, 0, sizeof(__p));
  uint64_t v31 = *(void *)(a3 + 32);
  __int16 v32 = a4 + 2;
  unint64_t v33 = (unint64_t)a4[2];
  unint64_t v34 = (unint64_t)a4[1];
  if (v34 < v33) {
    goto LABEL_40;
  }
  uint64_t v35 = *a4;
  uint64_t v36 = (uint64_t)(v34 - (void)*a4) >> 5;
  unint64_t v37 = v36 + 1;
  if ((unint64_t)(v36 + 1) >> 59) {
    goto LABEL_257;
  }
  if ((uint64_t)(v33 - (void)v35) >> 4 > v37) {
    unint64_t v37 = (uint64_t)(v33 - (void)v35) >> 4;
  }
  if (v33 - (unint64_t)v35 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v38 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v38 = v37;
  }
  unint64_t v256 = 0;
  uint64_t v257 = v32;
  if (v38 >> 59) {
    goto LABEL_258;
  }
  uint64_t v39 = (char *)operator new(32 * v38);
  uint64_t v40 = &v39[32 * v36];
  uint64_t v41 = *(void *)v265;
  *(void *)uint64_t v40 = v29;
  *((void *)v40 + 1) = v41;
  *(void *)(v40 + 15) = *(void *)&v265[7];
  v40[23] = v30;
  *(void *)int v265 = 0;
  *(void *)&v265[7] = 0;
  *((void *)v40 + 3) = v31;
  if ((char *)v34 == v35) {
    goto LABEL_54;
  }
  uint64_t v42 = &v39[32 * v36];
  a4 = v238;
  do
  {
    long long v43 = *(_OWORD *)(v34 - 32);
    *((void *)v42 - 2) = *(void *)(v34 - 16);
    *((_OWORD *)v42 - 2) = v43;
    *(void *)(v34 - 24) = 0;
    *(void *)(v34 - ++*(_DWORD *)(this + 16) = 0;
    *(void *)(v34 - 32) = 0;
    *((void *)v42 - 1) = *(void *)(v34 - 8);
    v42 -= 32;
    v34 -= 32;
  }
  while ((char *)v34 != v35);
LABEL_53:
  int64x2_t v61 = *(int64x2_t *)a4;
  unint64_t v33 = (unint64_t)a4[2];
LABEL_55:
  unint64_t v53 = (unint64_t)(v40 + 32);
  *a4 = v42;
  a4[1] = v40 + 32;
  int64x2_t v255 = v61;
  a4[2] = &v39[32 * v38];
  unint64_t v256 = v33;
  p_p = (std::string *)v61.i64[0];
  sub_1CD573B00((uint64_t)&p_p);
  unint64_t v54 = v237;
LABEL_56:
  a4[1] = (char *)v53;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!v21) {
      goto LABEL_191;
    }
LABEL_60:
    uint64_t v252 = 0;
    uint64_t v253 = 0;
    unsigned int v246 = 0;
    uint64_t v250 = 0;
    uint64_t v251 = 0;
    uint64_t v249 = 0;
    uint64_t v62 = sub_1CCC6B2B4(v21, (_DWORD *)&v253 + 1, &v246, &v251, (void *)a3, 0);
    if (v62)
    {
      if (v246 <= 7)
      {
        uint64_t v64 = v251;
        uint64_t v63 = v252;
        (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v252 + 136))(&v267, v252, v251);
        if ((v267.__r_.__value_.__s.__data_[16] & 1) == 0)
        {
          std::string::size_type size = v267.__r_.__value_.__l.__size_;
          std::string::size_type v65 = v267.__r_.__value_.__r.__words[0];
          uint64_t v67 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v64);
          uint64_t v68 = (const char *)(v67 + 16);
          if (*(unsigned char *)(v67 + 31)) {
            size_t v69 = 16;
          }
          else {
            size_t v69 = strlen(v68);
          }
          __int16 v262 = 1283;
          unint64_t v172 = "method_list32_t struct extends past end of (";
          goto LABEL_180;
        }
        goto LABEL_260;
      }
      unsigned int v70 = *(_DWORD *)(v62 + 4);
      unsigned int v71 = *(_DWORD *)(*(void *)a3 + 8);
      if (v71 <= 0x13 && ((1 << v71) & 0xAAC00) != 0) {
        unsigned int v70 = bswap32(v70);
      }
      HIDWORD(v253) += 8;
      if (v70)
      {
        int v72 = 0;
        unsigned int v73 = v21 + 8;
        uint64_t v230 = a4 + 2;
        unsigned int v231 = v70;
        do
        {
          unsigned int v74 = (unsigned int *)sub_1CCC6B2B4(v73, (_DWORD *)&v253 + 1, &v246, &v251, (void *)a3, 0);
          if (!v74) {
            break;
          }
          if (v246 <= 0xB)
          {
            uint64_t v64 = v251;
            uint64_t v63 = v252;
            (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v252 + 136))(&v267, v252, v251);
            if ((v267.__r_.__value_.__s.__data_[16] & 1) == 0)
            {
              std::string::size_type size = v267.__r_.__value_.__l.__size_;
              std::string::size_type v65 = v267.__r_.__value_.__r.__words[0];
              uint64_t v225 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v64);
              uint64_t v68 = (const char *)(v225 + 16);
              unint64_t v54 = v237;
              if (*(unsigned char *)(v225 + 31)) {
                size_t v69 = 16;
              }
              else {
                size_t v69 = strlen(v68);
              }
              __int16 v262 = 1283;
              unint64_t v172 = "method32_t struct extends past end of (";
LABEL_180:
              v260.__r_.__value_.__r.__words[0] = (std::string::size_type)v172;
              v260.__r_.__value_.__r.__words[2] = (std::string::size_type)v68;
              size_t v261 = v69;
              v263.__r_.__value_.__r.__words[0] = (std::string::size_type)&v260;
              v263.__r_.__value_.__r.__words[2] = (std::string::size_type)",";
              __int16 v264 = 770;
              *(void *)int v265 = &v263;
              *(void *)&v265[16] = v65;
              *(void *)&v265[24] = size;
              __int16 v266 = 1282;
              __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v265;
              __p.__r_.__value_.__r.__words[2] = (std::string::size_type)") section at address: 0x";
              __int16 v248 = 770;
              uint64_t v173 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v63 + 144))(v63, v64);
              v259[0] = v173 + HIDWORD(v253);
              char v174 = v248;
              if (v248 == 1)
              {
                p_p = (std::string *)v259;
                v255.i64[1] = 0;
                LOWORD(v257) = 270;
              }
              else if ((_BYTE)v248)
              {
                if (HIBYTE(v248) != 1) {
                  char v174 = 2;
                }
                unint64_t v175 = &__p;
                if (HIBYTE(v248) == 1) {
                  unint64_t v175 = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                p_p = v175;
                v255.i64[0] = __p.__r_.__value_.__l.__size_;
                v255.i64[1] = (uint64_t)v259;
                LOBYTE(v257) = v174;
                BYTE1(v257) = 14;
              }
              else
              {
                LOWORD(v257) = 256;
              }
              sub_1CCC51CE4((uint64_t)v54, (uint64_t *)&p_p);
            }
LABEL_260:
            std::string::size_type v229 = v267.__r_.__value_.__r.__words[0];
            v267.__r_.__value_.__r.__words[0] = 0;
            p_p = (std::string *)v229;
            p_p_p = (uint64_t *)&p_p;
LABEL_261:
            llvm::report_fatal_error(p_p_p);
          }
          unsigned int v75 = *v74;
          unsigned int v76 = v74[2];
          unsigned int v77 = *(_DWORD *)(*(void *)a3 + 8);
          BOOL v13 = v77 > 0x13;
          int v78 = (1 << v77) & 0xAAC00;
          BOOL v79 = v13 || v78 == 0;
          unsigned int v80 = bswap32(v75);
          unsigned int v81 = bswap32(v76);
          if (v79) {
            uint64_t v82 = v76;
          }
          else {
            uint64_t v82 = v81;
          }
          if (v79) {
            unint64_t v83 = v75;
          }
          else {
            unint64_t v83 = v80;
          }
          unint64_t v84 = (const std::string::value_type *)sub_1CCC6B2B4(v83, &v253, &v246, &v249, (void *)a3, 0);
          uint64_t v85 = *(void *)(a3 + 48);
          uint64_t v235 = v82;
          if (*(unsigned char *)(a3 + 60))
          {
            if (!v85)
            {
              char v126 = *(const char **)(a3 + 40);
              size_t v127 = strlen(v126);
              sub_1CB907098((uint64_t)&v263, v127 + 2);
              if ((v263.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                unint64_t v128 = &v263;
              }
              else {
                unint64_t v128 = (std::string *)v263.__r_.__value_.__r.__words[0];
              }
              LOWORD(v128->__r_.__value_.__l.__data_) = 23339;
              unint64_t v129 = &v128->__r_.__value_.__s.__data_[2];
              if (v127) {
                memmove(v129, v126, v127);
              }
              v129[v127] = 0;
              int v130 = std::string::append(&v263, " ");
              std::string::size_type v131 = v130->__r_.__value_.__r.__words[2];
              *(_OWORD *)int v265 = *(_OWORD *)&v130->__r_.__value_.__l.__data_;
              *(void *)&v265[16] = v131;
              v130->__r_.__value_.__l.__size_ = 0;
              v130->__r_.__value_.__r.__words[2] = 0;
              v130->__r_.__value_.__r.__words[0] = 0;
              __int16 v132 = std::string::append((std::string *)v265, v84);
              std::string::size_type v133 = v132->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v132->__r_.__value_.__l.__data_;
              __p.__r_.__value_.__r.__words[2] = v133;
              v132->__r_.__value_.__l.__size_ = 0;
              v132->__r_.__value_.__r.__words[2] = 0;
              v132->__r_.__value_.__r.__words[0] = 0;
              uint64_t v134 = std::string::append(&__p, "]");
              std::string::size_type v135 = v134->__r_.__value_.__r.__words[0];
              v267.__r_.__value_.__r.__words[0] = v134->__r_.__value_.__l.__size_;
              *(std::string::size_type *)((char *)v267.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v134->__r_.__value_.__r.__words[1] + 7);
              char v136 = HIBYTE(v134->__r_.__value_.__r.__words[2]);
              v134->__r_.__value_.__l.__size_ = 0;
              v134->__r_.__value_.__r.__words[2] = 0;
              v134->__r_.__value_.__r.__words[0] = 0;
              v260.__r_.__value_.__r.__words[0] = v267.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)v267.__r_.__value_.__r.__words + 7);
              unint64_t v137 = (unint64_t)a4[1];
              unint64_t v138 = (unint64_t)a4[2];
              if (v137 < v138) {
                goto LABEL_131;
              }
              unint64_t v139 = *a4;
              uint64_t v140 = (uint64_t)(v137 - (void)*a4) >> 5;
              unint64_t v141 = v140 + 1;
              if ((unint64_t)(v140 + 1) >> 59) {
                goto LABEL_257;
              }
              if ((uint64_t)(v138 - (void)v139) >> 4 > v141) {
                unint64_t v141 = (uint64_t)(v138 - (void)v139) >> 4;
              }
              if (v138 - (unint64_t)v139 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v142 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v142 = v141;
              }
              unint64_t v256 = 0;
              uint64_t v257 = v230;
              if (v142 >> 59) {
                goto LABEL_258;
              }
              __int16 v143 = (char *)operator new(32 * v142);
              unsigned int v144 = &v143[32 * v140];
              std::string::size_type v145 = v260.__r_.__value_.__r.__words[0];
              *(void *)unsigned int v144 = v135;
              *((void *)v144 + 1) = v145;
              *(void *)(v144 + 15) = *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7);
              v144[23] = v136;
              v260.__r_.__value_.__r.__words[0] = 0;
              *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7) = 0;
              *((void *)v144 + 3) = v235;
              if ((char *)v137 != v139)
              {
                __int16 v146 = &v143[32 * v140];
                a4 = v238;
                do
                {
                  long long v147 = *(_OWORD *)(v137 - 32);
                  *((void *)v146 - 2) = *(void *)(v137 - 16);
                  *((_OWORD *)v146 - 2) = v147;
                  *(void *)(v137 - 24) = 0;
                  *(void *)(v137 - ++*(_DWORD *)(this + 16) = 0;
                  *(void *)(v137 - 32) = 0;
                  *((void *)v146 - 1) = *(void *)(v137 - 8);
                  v146 -= 32;
                  v137 -= 32;
                }
                while ((char *)v137 != v139);
                goto LABEL_165;
              }
              goto LABEL_166;
            }
            uint64_t v86 = *(const char **)(a3 + 40);
            size_t v87 = strlen(v86);
            sub_1CB907098((uint64_t)&v267, v87 + 2);
            if ((v267.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v88 = &v267;
            }
            else {
              int v88 = (std::string *)v267.__r_.__value_.__r.__words[0];
            }
            LOWORD(v88->__r_.__value_.__l.__data_) = 23339;
            long long v89 = &v88->__r_.__value_.__s.__data_[2];
            if (v87) {
              memmove(v89, v86, v87);
            }
            v89[v87] = 0;
            signed int v90 = std::string::append(&v267, "(");
            std::string::size_type v91 = v90->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v260.__r_.__value_.__l.__data_ = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
            v260.__r_.__value_.__r.__words[2] = v91;
            v90->__r_.__value_.__l.__size_ = 0;
            v90->__r_.__value_.__r.__words[2] = 0;
            v90->__r_.__value_.__r.__words[0] = 0;
            int v92 = std::string::append(&v260, *(const std::string::value_type **)(a3 + 48));
            std::string::size_type v93 = v92->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v263.__r_.__value_.__l.__data_ = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
            v263.__r_.__value_.__r.__words[2] = v93;
            v92->__r_.__value_.__l.__size_ = 0;
            v92->__r_.__value_.__r.__words[2] = 0;
            v92->__r_.__value_.__r.__words[0] = 0;
            unsigned int v94 = std::string::append(&v263, ") ");
            std::string::size_type v95 = v94->__r_.__value_.__r.__words[2];
            *(_OWORD *)int v265 = *(_OWORD *)&v94->__r_.__value_.__l.__data_;
            *(void *)&v265[16] = v95;
            v94->__r_.__value_.__l.__size_ = 0;
            v94->__r_.__value_.__r.__words[2] = 0;
            v94->__r_.__value_.__r.__words[0] = 0;
            signed int v96 = std::string::append((std::string *)v265, v84);
            std::string::size_type v97 = v96->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v96->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v97;
            v96->__r_.__value_.__l.__size_ = 0;
            v96->__r_.__value_.__r.__words[2] = 0;
            v96->__r_.__value_.__r.__words[0] = 0;
            uint64_t v98 = std::string::append(&__p, "]");
            std::string::size_type v99 = v98->__r_.__value_.__r.__words[0];
            *(void *)unsigned int v258 = v98->__r_.__value_.__l.__size_;
            *(void *)((char *)&v258[1] + 3) = *(std::string::size_type *)((char *)&v98->__r_.__value_.__r.__words[1]
                                                                          + 7);
            char v100 = HIBYTE(v98->__r_.__value_.__r.__words[2]);
            v98->__r_.__value_.__l.__size_ = 0;
            v98->__r_.__value_.__r.__words[2] = 0;
            v98->__r_.__value_.__r.__words[0] = 0;
            v259[0] = *(void *)v258;
            *(void *)((char *)v259 + 7) = *(void *)((char *)&v258[1] + 3);
            memset(v258, 0, 15);
            unint64_t v101 = (unint64_t)a4[1];
            unint64_t v102 = (unint64_t)a4[2];
            if (v101 >= v102)
            {
              uint64_t v103 = *a4;
              uint64_t v104 = (uint64_t)(v101 - (void)*a4) >> 5;
              unint64_t v105 = v104 + 1;
              if ((unint64_t)(v104 + 1) >> 59) {
                goto LABEL_257;
              }
              if ((uint64_t)(v102 - (void)v103) >> 4 > v105) {
                unint64_t v105 = (uint64_t)(v102 - (void)v103) >> 4;
              }
              if (v102 - (unint64_t)v103 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v106 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v106 = v105;
              }
              unint64_t v256 = 0;
              uint64_t v257 = v230;
              if (v106 >> 59) {
                goto LABEL_258;
              }
              uint64_t v107 = (char *)operator new(32 * v106);
              std::string::size_type v108 = &v107[32 * v104];
              uint64_t v109 = v259[0];
              *(void *)std::string::size_type v108 = v99;
              *((void *)v108 + 1) = v109;
              *(void *)(v108 + 15) = *(void *)((char *)v259 + 7);
              v108[23] = v100;
              memset(v259, 0, 15);
              *((void *)v108 + 3) = v235;
              if ((char *)v101 != v103)
              {
                std::string::size_type v110 = &v107[32 * v104];
                a4 = v238;
                do
                {
                  long long v111 = *(_OWORD *)(v101 - 32);
                  *((void *)v110 - 2) = *(void *)(v101 - 16);
                  *((_OWORD *)v110 - 2) = v111;
                  *(void *)(v101 - 24) = 0;
                  *(void *)(v101 - ++*(_DWORD *)(this + 16) = 0;
                  *(void *)(v101 - 32) = 0;
                  *((void *)v110 - 1) = *(void *)(v101 - 8);
                  v110 -= 32;
                  v101 -= 32;
                }
                while ((char *)v101 != v103);
                goto LABEL_142;
              }
              goto LABEL_143;
            }
          }
          else
          {
            if (!v85)
            {
              unsigned int v148 = *(const char **)(a3 + 40);
              size_t v149 = strlen(v148);
              sub_1CB907098((uint64_t)&v263, v149 + 2);
              if ((v263.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                char v150 = &v263;
              }
              else {
                char v150 = (std::string *)v263.__r_.__value_.__r.__words[0];
              }
              LOWORD(v150->__r_.__value_.__l.__data_) = 23341;
              unint64_t v151 = &v150->__r_.__value_.__s.__data_[2];
              if (v149) {
                memmove(v151, v148, v149);
              }
              v151[v149] = 0;
              unint64_t v152 = std::string::append(&v263, " ");
              std::string::size_type v153 = v152->__r_.__value_.__r.__words[2];
              *(_OWORD *)int v265 = *(_OWORD *)&v152->__r_.__value_.__l.__data_;
              *(void *)&v265[16] = v153;
              v152->__r_.__value_.__l.__size_ = 0;
              v152->__r_.__value_.__r.__words[2] = 0;
              v152->__r_.__value_.__r.__words[0] = 0;
              uint64_t v154 = std::string::append((std::string *)v265, v84);
              std::string::size_type v155 = v154->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v154->__r_.__value_.__l.__data_;
              __p.__r_.__value_.__r.__words[2] = v155;
              v154->__r_.__value_.__l.__size_ = 0;
              v154->__r_.__value_.__r.__words[2] = 0;
              v154->__r_.__value_.__r.__words[0] = 0;
              unint64_t v156 = std::string::append(&__p, "]");
              std::string::size_type v135 = v156->__r_.__value_.__r.__words[0];
              v267.__r_.__value_.__r.__words[0] = v156->__r_.__value_.__l.__size_;
              *(std::string::size_type *)((char *)v267.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v156->__r_.__value_.__r.__words[1] + 7);
              char v136 = HIBYTE(v156->__r_.__value_.__r.__words[2]);
              v156->__r_.__value_.__l.__size_ = 0;
              v156->__r_.__value_.__r.__words[2] = 0;
              v156->__r_.__value_.__r.__words[0] = 0;
              v260.__r_.__value_.__r.__words[0] = v267.__r_.__value_.__r.__words[0];
              *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)v267.__r_.__value_.__r.__words + 7);
              unint64_t v137 = (unint64_t)a4[1];
              unint64_t v138 = (unint64_t)a4[2];
              if (v137 < v138)
              {
LABEL_131:
                *(void *)unint64_t v137 = v135;
                *(void *)(v137 + ++*(_DWORD *)(this + 8) = v260.__r_.__value_.__r.__words[0];
                *(void *)(v137 + 15) = *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7);
                *(unsigned char *)(v137 + 23) = v136;
                *(void *)(v137 + 24) = v235;
                unint64_t v157 = v137 + 32;
LABEL_168:
                a4[1] = (char *)v157;
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
                unsigned int v164 = v231;
                if ((v265[23] & 0x80000000) != 0) {
                  operator delete(*(void **)v265);
                }
                if ((SHIBYTE(v263.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                  goto LABEL_175;
                }
                size_t v165 = (void *)v263.__r_.__value_.__r.__words[0];
                goto LABEL_174;
              }
              __int16 v166 = *a4;
              uint64_t v167 = (uint64_t)(v137 - (void)*a4) >> 5;
              unint64_t v168 = v167 + 1;
              if ((unint64_t)(v167 + 1) >> 59) {
                goto LABEL_257;
              }
              if ((uint64_t)(v138 - (void)v166) >> 4 > v168) {
                unint64_t v168 = (uint64_t)(v138 - (void)v166) >> 4;
              }
              if (v138 - (unint64_t)v166 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v142 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v142 = v168;
              }
              unint64_t v256 = 0;
              uint64_t v257 = v230;
              if (v142 >> 59) {
                goto LABEL_258;
              }
              __int16 v143 = (char *)operator new(32 * v142);
              unsigned int v144 = &v143[32 * v167];
              std::string::size_type v169 = v260.__r_.__value_.__r.__words[0];
              *(void *)unsigned int v144 = v135;
              *((void *)v144 + 1) = v169;
              *(void *)(v144 + 15) = *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7);
              v144[23] = v136;
              v260.__r_.__value_.__r.__words[0] = 0;
              *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7) = 0;
              *((void *)v144 + 3) = v235;
              if ((char *)v137 != v166)
              {
                __int16 v146 = &v143[32 * v167];
                a4 = v238;
                do
                {
                  long long v170 = *(_OWORD *)(v137 - 32);
                  *((void *)v146 - 2) = *(void *)(v137 - 16);
                  *((_OWORD *)v146 - 2) = v170;
                  *(void *)(v137 - 24) = 0;
                  *(void *)(v137 - ++*(_DWORD *)(this + 16) = 0;
                  *(void *)(v137 - 32) = 0;
                  *((void *)v146 - 1) = *(void *)(v137 - 8);
                  v146 -= 32;
                  v137 -= 32;
                }
                while ((char *)v137 != v166);
LABEL_165:
                int64x2_t v171 = *(int64x2_t *)a4;
                unint64_t v138 = (unint64_t)a4[2];
LABEL_167:
                unint64_t v157 = (unint64_t)(v144 + 32);
                *a4 = v146;
                a4[1] = v144 + 32;
                int64x2_t v255 = v171;
                a4[2] = &v143[32 * v142];
                unint64_t v256 = v138;
                p_p = (std::string *)v171.i64[0];
                sub_1CD573B00((uint64_t)&p_p);
                goto LABEL_168;
              }
LABEL_166:
              int64x2_t v171 = vdupq_n_s64(v137);
              __int16 v146 = v144;
              a4 = v238;
              goto LABEL_167;
            }
            std::string::size_type v112 = *(const char **)(a3 + 40);
            size_t v113 = strlen(v112);
            sub_1CB907098((uint64_t)&v267, v113 + 2);
            if ((v267.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              unint64_t v114 = &v267;
            }
            else {
              unint64_t v114 = (std::string *)v267.__r_.__value_.__r.__words[0];
            }
            LOWORD(v114->__r_.__value_.__l.__data_) = 23341;
            unint64_t v115 = &v114->__r_.__value_.__s.__data_[2];
            if (v113) {
              memmove(v115, v112, v113);
            }
            v115[v113] = 0;
            unsigned int v116 = std::string::append(&v267, "(");
            std::string::size_type v117 = v116->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v260.__r_.__value_.__l.__data_ = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
            v260.__r_.__value_.__r.__words[2] = v117;
            v116->__r_.__value_.__l.__size_ = 0;
            v116->__r_.__value_.__r.__words[2] = 0;
            v116->__r_.__value_.__r.__words[0] = 0;
            uint64_t v118 = std::string::append(&v260, *(const std::string::value_type **)(a3 + 48));
            std::string::size_type v119 = v118->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v263.__r_.__value_.__l.__data_ = *(_OWORD *)&v118->__r_.__value_.__l.__data_;
            v263.__r_.__value_.__r.__words[2] = v119;
            v118->__r_.__value_.__l.__size_ = 0;
            v118->__r_.__value_.__r.__words[2] = 0;
            v118->__r_.__value_.__r.__words[0] = 0;
            unint64_t v120 = std::string::append(&v263, ") ");
            std::string::size_type v121 = v120->__r_.__value_.__r.__words[2];
            *(_OWORD *)int v265 = *(_OWORD *)&v120->__r_.__value_.__l.__data_;
            *(void *)&v265[16] = v121;
            v120->__r_.__value_.__l.__size_ = 0;
            v120->__r_.__value_.__r.__words[2] = 0;
            v120->__r_.__value_.__r.__words[0] = 0;
            size_t v122 = std::string::append((std::string *)v265, v84);
            std::string::size_type v123 = v122->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v122->__r_.__value_.__l.__data_;
            __p.__r_.__value_.__r.__words[2] = v123;
            v122->__r_.__value_.__l.__size_ = 0;
            v122->__r_.__value_.__r.__words[2] = 0;
            v122->__r_.__value_.__r.__words[0] = 0;
            int v124 = std::string::append(&__p, "]");
            std::string::size_type v99 = v124->__r_.__value_.__r.__words[0];
            *(void *)unsigned int v258 = v124->__r_.__value_.__l.__size_;
            *(void *)((char *)&v258[1] + 3) = *(std::string::size_type *)((char *)&v124->__r_.__value_.__r.__words[1]
                                                                          + 7);
            char v100 = HIBYTE(v124->__r_.__value_.__r.__words[2]);
            v124->__r_.__value_.__l.__size_ = 0;
            v124->__r_.__value_.__r.__words[2] = 0;
            v124->__r_.__value_.__r.__words[0] = 0;
            v259[0] = *(void *)v258;
            *(void *)((char *)v259 + 7) = *(void *)((char *)&v258[1] + 3);
            memset(v258, 0, 15);
            unint64_t v101 = (unint64_t)a4[1];
            unint64_t v102 = (unint64_t)a4[2];
            if (v101 >= v102)
            {
              uint64_t v158 = *a4;
              uint64_t v159 = (uint64_t)(v101 - (void)*a4) >> 5;
              unint64_t v160 = v159 + 1;
              if ((unint64_t)(v159 + 1) >> 59) {
                goto LABEL_257;
              }
              if ((uint64_t)(v102 - (void)v158) >> 4 > v160) {
                unint64_t v160 = (uint64_t)(v102 - (void)v158) >> 4;
              }
              if (v102 - (unint64_t)v158 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v106 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v106 = v160;
              }
              unint64_t v256 = 0;
              uint64_t v257 = v230;
              if (v106 >> 59) {
                goto LABEL_258;
              }
              uint64_t v107 = (char *)operator new(32 * v106);
              std::string::size_type v108 = &v107[32 * v159];
              uint64_t v161 = v259[0];
              *(void *)std::string::size_type v108 = v99;
              *((void *)v108 + 1) = v161;
              *(void *)(v108 + 15) = *(void *)((char *)v259 + 7);
              v108[23] = v100;
              memset(v259, 0, 15);
              *((void *)v108 + 3) = v235;
              if ((char *)v101 != v158)
              {
                std::string::size_type v110 = &v107[32 * v159];
                a4 = v238;
                do
                {
                  long long v162 = *(_OWORD *)(v101 - 32);
                  *((void *)v110 - 2) = *(void *)(v101 - 16);
                  *((_OWORD *)v110 - 2) = v162;
                  *(void *)(v101 - 24) = 0;
                  *(void *)(v101 - ++*(_DWORD *)(this + 16) = 0;
                  *(void *)(v101 - 32) = 0;
                  *((void *)v110 - 1) = *(void *)(v101 - 8);
                  v110 -= 32;
                  v101 -= 32;
                }
                while ((char *)v101 != v158);
LABEL_142:
                int64x2_t v163 = *(int64x2_t *)a4;
                unint64_t v102 = (unint64_t)a4[2];
LABEL_144:
                unint64_t v125 = (unint64_t)(v108 + 32);
                *a4 = v110;
                a4[1] = v108 + 32;
                int64x2_t v255 = v163;
                a4[2] = &v107[32 * v106];
                unint64_t v256 = v102;
                p_p = (std::string *)v163.i64[0];
                sub_1CD573B00((uint64_t)&p_p);
                goto LABEL_145;
              }
LABEL_143:
              int64x2_t v163 = vdupq_n_s64(v101);
              std::string::size_type v110 = v108;
              a4 = v238;
              goto LABEL_144;
            }
          }
          *(void *)unint64_t v101 = v99;
          *(void *)(v101 + ++*(_DWORD *)(this + 8) = v259[0];
          *(void *)(v101 + 15) = *(void *)((char *)v259 + 7);
          *(unsigned char *)(v101 + 23) = v100;
          memset(v259, 0, 15);
          *(void *)(v101 + 24) = v235;
          unint64_t v125 = v101 + 32;
LABEL_145:
          a4[1] = (char *)v125;
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          unsigned int v164 = v231;
          if ((v265[23] & 0x80000000) != 0) {
            operator delete(*(void **)v265);
          }
          if (SHIBYTE(v263.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v263.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v260.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v260.__r_.__value_.__l.__data_);
          }
          if ((SHIBYTE(v267.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_175;
          }
          size_t v165 = (void *)v267.__r_.__value_.__r.__words[0];
LABEL_174:
          operator delete(v165);
LABEL_175:
          v73 += 12;
          HIDWORD(v253) += 12;
          ++v72;
        }
        while (v72 != v164);
      }
      unint64_t v54 = v237;
    }
    void *v54 = 0;
    if (*v54) {
      return;
    }
    goto LABEL_191;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (v21) {
    goto LABEL_60;
  }
LABEL_191:
  if (!v233) {
    goto LABEL_245;
  }
  v258[0] = 0;
  uint64_t v252 = 0;
  uint64_t v253 = 0;
  uint64_t v250 = 0;
  uint64_t v251 = 0;
  uint64_t v249 = 0;
  uint64_t v176 = sub_1CCC6B2B4(v233, v258, &v253, &v251, (void *)a3, 0);
  if (v176)
  {
    if (v253 <= 7)
    {
      uint64_t v178 = v251;
      uint64_t v177 = v252;
      (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v252 + 136))(&v267, v252, v251);
      if (v267.__r_.__value_.__s.__data_[16]) {
        goto LABEL_260;
      }
      std::string::size_type v180 = v267.__r_.__value_.__l.__size_;
      std::string::size_type v179 = v267.__r_.__value_.__r.__words[0];
      uint64_t v181 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v178);
      uint64_t v182 = (const char *)(v181 + 16);
      if (*(unsigned char *)(v181 + 31)) {
        size_t v183 = 16;
      }
      else {
        size_t v183 = strlen(v182);
      }
      __int16 v262 = 1283;
      unint64_t v223 = "ivar_list32_t struct extends past end of (";
      goto LABEL_243;
    }
    unsigned int v184 = *(_DWORD *)(*(void *)a3 + 8);
    BOOL v13 = v184 > 0x13;
    int v185 = (1 << v184) & 0xAAC00;
    BOOL v186 = v13 || v185 == 0;
    unsigned int v187 = bswap32(*(_DWORD *)(v176 + 4));
    if (v186) {
      unsigned int v187 = *(_DWORD *)(v176 + 4);
    }
    v258[0] += 8;
    unsigned int v232 = v187;
    if (v187)
    {
      int v188 = 0;
      unsigned int v189 = v233 + 8;
      unsigned int v234 = a4 + 2;
      while (1)
      {
        int v190 = (_DWORD *)sub_1CCC6B2B4(v189, v258, &v253, &v251, (void *)a3, 0);
        if (!v190) {
          goto LABEL_240;
        }
        if (v253 <= 0x13) {
          break;
        }
        LODWORD(v191) = *v190;
        unsigned int v192 = v190[1];
        unsigned int v193 = *(_DWORD *)(*(void *)a3 + 8);
        BOOL v13 = v193 > 0x13;
        int v194 = (1 << v193) & 0xAAC00;
        BOOL v195 = v13 || v194 == 0;
        unsigned int v196 = bswap32(v191);
        unsigned int v197 = bswap32(v192);
        if (v195) {
          unint64_t v198 = v192;
        }
        else {
          unint64_t v198 = v197;
        }
        if (v195) {
          uint64_t v191 = v191;
        }
        else {
          uint64_t v191 = v196;
        }
        uint64_t v236 = v191;
        uint64_t v199 = (const std::string::value_type *)sub_1CCC6B2B4(v198, (_DWORD *)&v253 + 1, &v253, &v249, (void *)a3, 0);
        unint64_t v200 = *(const char **)(a3 + 40);
        size_t v201 = strlen(v200);
        sub_1CB907098((uint64_t)v265, v201 + 13);
        int v202 = v265;
        if (v265[23] < 0) {
          int v202 = *(unsigned char **)v265;
        }
        qmemcpy(v202, "_OBJC_IVAR_$_", 13);
        unsigned int v203 = v202 + 13;
        if (v201) {
          memmove(v202 + 13, v200, v201);
        }
        v203[v201] = 0;
        unsigned int v204 = std::string::append((std::string *)v265, ".");
        std::string::size_type v205 = v204->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v204->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v205;
        v204->__r_.__value_.__l.__size_ = 0;
        v204->__r_.__value_.__r.__words[2] = 0;
        v204->__r_.__value_.__r.__words[0] = 0;
        unint64_t v206 = std::string::append(&__p, v199);
        std::string::size_type v207 = v206->__r_.__value_.__r.__words[0];
        v260.__r_.__value_.__r.__words[0] = v206->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v206->__r_.__value_.__r.__words[1] + 7);
        char v208 = HIBYTE(v206->__r_.__value_.__r.__words[2]);
        v206->__r_.__value_.__l.__size_ = 0;
        v206->__r_.__value_.__r.__words[2] = 0;
        v206->__r_.__value_.__r.__words[0] = 0;
        v263.__r_.__value_.__r.__words[0] = v260.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)v263.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)v260.__r_.__value_.__r.__words + 7);
        unsigned int v209 = v238;
        unint64_t v210 = (unint64_t)v238[1];
        unint64_t v211 = (unint64_t)v238[2];
        if (v210 >= v211)
        {
          unint64_t v213 = *v238;
          uint64_t v214 = (uint64_t)(v210 - (void)*v238) >> 5;
          unint64_t v215 = v214 + 1;
          if ((unint64_t)(v214 + 1) >> 59) {
            goto LABEL_257;
          }
          if ((uint64_t)(v211 - (void)v213) >> 4 > v215) {
            unint64_t v215 = (uint64_t)(v211 - (void)v213) >> 4;
          }
          if (v211 - (unint64_t)v213 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v216 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v216 = v215;
          }
          unint64_t v256 = 0;
          uint64_t v257 = v234;
          if (v216 >> 59) {
            goto LABEL_258;
          }
          int v217 = (char *)operator new(32 * v216);
          size_t v218 = &v217[32 * v214];
          std::string::size_type v219 = v263.__r_.__value_.__r.__words[0];
          *(void *)size_t v218 = v207;
          *((void *)v218 + 1) = v219;
          *(void *)(v218 + 15) = *(std::string::size_type *)((char *)v263.__r_.__value_.__r.__words + 7);
          v218[23] = v208;
          v263.__r_.__value_.__r.__words[0] = 0;
          *(std::string::size_type *)((char *)v263.__r_.__value_.__r.__words + 7) = 0;
          *((void *)v218 + 3) = v236;
          if ((char *)v210 == v213)
          {
            int64x2_t v222 = vdupq_n_s64(v210);
            uint64_t v220 = &v217[32 * v214];
            unsigned int v209 = v238;
          }
          else
          {
            uint64_t v220 = &v217[32 * v214];
            do
            {
              long long v221 = *(_OWORD *)(v210 - 32);
              *((void *)v220 - 2) = *(void *)(v210 - 16);
              *((_OWORD *)v220 - 2) = v221;
              *(void *)(v210 - 24) = 0;
              *(void *)(v210 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v210 - 32) = 0;
              *((void *)v220 - 1) = *(void *)(v210 - 8);
              v220 -= 32;
              v210 -= 32;
            }
            while ((char *)v210 != v213);
            unsigned int v209 = v238;
            int64x2_t v222 = *(int64x2_t *)v238;
            unint64_t v211 = (unint64_t)v238[2];
          }
          unint64_t v212 = (unint64_t)(v218 + 32);
          *unsigned int v209 = v220;
          v209[1] = v218 + 32;
          int64x2_t v255 = v222;
          v209[2] = &v217[32 * v216];
          unint64_t v256 = v211;
          p_p = (std::string *)v222.i64[0];
          sub_1CD573B00((uint64_t)&p_p);
          unint64_t v54 = v237;
        }
        else
        {
          *(void *)unint64_t v210 = v207;
          *(void *)(v210 + ++*(_DWORD *)(this + 8) = v263.__r_.__value_.__r.__words[0];
          *(void *)(v210 + 15) = *(std::string::size_type *)((char *)v263.__r_.__value_.__r.__words + 7);
          *(unsigned char *)(v210 + 23) = v208;
          unint64_t v54 = v237;
          *(void *)(v210 + 24) = v236;
          unint64_t v212 = v210 + 32;
        }
        v209[1] = (char *)v212;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        if ((v265[23] & 0x80000000) != 0) {
          operator delete(*(void **)v265);
        }
        v189 += 20;
        v258[0] += 20;
        if (++v188 == v232) {
          goto LABEL_240;
        }
      }
      uint64_t v178 = v251;
      uint64_t v177 = v252;
      (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v252 + 136))(&v267, v252, v251);
      if (v267.__r_.__value_.__s.__data_[16]) {
        goto LABEL_260;
      }
      std::string::size_type v180 = v267.__r_.__value_.__l.__size_;
      std::string::size_type v179 = v267.__r_.__value_.__r.__words[0];
      uint64_t v226 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v178);
      uint64_t v182 = (const char *)(v226 + 16);
      if (*(unsigned char *)(v226 + 31)) {
        size_t v183 = 16;
      }
      else {
        size_t v183 = strlen(v182);
      }
      __int16 v262 = 1283;
      unint64_t v223 = "ivar_t struct extends past end of (";
LABEL_243:
      v260.__r_.__value_.__r.__words[0] = (std::string::size_type)v223;
      v260.__r_.__value_.__r.__words[2] = (std::string::size_type)v182;
      size_t v261 = v183;
      v263.__r_.__value_.__r.__words[0] = (std::string::size_type)&v260;
      v263.__r_.__value_.__r.__words[2] = (std::string::size_type)",";
      __int16 v264 = 770;
      *(void *)int v265 = &v263;
      *(void *)&v265[16] = v179;
      *(void *)&v265[24] = v180;
      __int16 v266 = 1282;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v265;
      __p.__r_.__value_.__r.__words[2] = (std::string::size_type)") section at address: 0x";
      __int16 v248 = 770;
      uint64_t v224 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v177 + 144))(v177, v178);
      v259[0] = v224 + v258[0];
      p_p = &__p;
      v255.i64[1] = (uint64_t)v259;
      LOWORD(v257) = 3586;
      sub_1CCC51CE4((uint64_t)v54, (uint64_t *)&p_p);
    }
  }
LABEL_240:
  void *v54 = 0;
  if (!*v54) {
LABEL_245:
  }
    void *v54 = 0;
}

void sub_1CCC6EBD0(void *a1, unsigned int a2, uint64_t a3, void *a4, int64x2_t *a5)
{
  int v13 = 0;
  uint64_t v10 = sub_1CCC6B2B4(*(unsigned int *)(a3 + 8), &v13, &v12, &v11, a4, 1);
  if (!v10 || (a4[4] = a2, a4[5] = v10, a4[6] = 0, sub_1CCC6EC68(a1, *(_DWORD *)(a3 + 28), (uint64_t)a4, a5), !*a1)) {
    *a1 = 0;
  }
}

void sub_1CCC6EC68(void *a1, unsigned int a2, uint64_t a3, int64x2_t *a4)
{
  uint64_t v156 = *MEMORY[0x1E4F143B8];
  uint64_t v145 = 0;
  int v144 = 0;
  uint64_t v142 = 0;
  uint64_t v143 = 0;
  uint64_t v7 = sub_1CCC6B2B4(a2, (_DWORD *)&v145 + 1, &v145, &v142, (void *)a3, 1);
  if (v7)
  {
    if (v145 <= 7)
    {
      uint64_t v9 = v142;
      uint64_t v8 = v143;
      (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v143 + 136))(&v155, v143, v142);
      if ((v155.__r_.__value_.__s.__data_[16] & 1) == 0)
      {
        uint64_t v10 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v9);
        uint64_t v11 = (const char *)(v10 + 16);
        if (*(unsigned char *)(v10 + 31)) {
          size_t v12 = 16;
        }
        else {
          size_t v12 = strlen(v11);
        }
        __int16 v154 = 1283;
        v152.__r_.__value_.__r.__words[0] = (std::string::size_type)"objc_method_list struct extends past end of (";
        v152.__r_.__value_.__r.__words[2] = (std::string::size_type)v11;
        size_t v153 = v12;
        v135.__r_.__value_.__r.__words[0] = (std::string::size_type)&v152;
        v135.__r_.__value_.__r.__words[2] = (std::string::size_type)",";
        __int16 v136 = 770;
        *(void *)unint64_t v137 = &v135;
        *(_OWORD *)&v137[16] = *(_OWORD *)&v155.__r_.__value_.__l.__data_;
        __int16 v138 = 1282;
        v139.__r_.__value_.__r.__words[0] = (std::string::size_type)v137;
        v139.__r_.__value_.__r.__words[2] = (std::string::size_type)") section at address: 0x";
        __int16 v140 = 770;
        uint64_t v118 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 144))(v8, v9);
        v151[0] = v118 + HIDWORD(v145);
        __int16 v146 = &v139;
        v147.i64[1] = (uint64_t)v151;
        LOWORD(v149) = 3586;
        uint64_t v119 = (uint64_t)a1;
        goto LABEL_129;
      }
      std::string::size_type v126 = v155.__r_.__value_.__r.__words[0];
      v155.__r_.__value_.__r.__words[0] = 0;
      std::string::size_type v141 = v126;
      size_t v127 = (uint64_t *)&v141;
      goto LABEL_134;
    }
    unint64_t v129 = a1;
    LODWORD(v13) = *(_DWORD *)(v7 + 4);
    unsigned int v14 = *(_DWORD *)(*(void *)a3 + 8);
    BOOL v15 = v14 > 0x13;
    int v16 = (1 << v14) & 0xAAC00;
    BOOL v17 = v15 || v16 == 0;
    unsigned int v18 = bswap32(v13);
    if (v17) {
      uint64_t v13 = v13;
    }
    else {
      uint64_t v13 = v18;
    }
    uint64_t v132 = v13;
    if ((int)v13 >= 1)
    {
      uint64_t v19 = 0;
      uint64_t v130 = v7 + 8;
      unint64_t v131 = v145 / 0xCuLL;
      while (1)
      {
        if (v19 == v131)
        {
          uint64_t v121 = v142;
          uint64_t v120 = v143;
          (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)v143 + 136))(&v155, v143, v142);
          if ((v155.__r_.__value_.__s.__data_[16] & 1) == 0)
          {
            uint64_t v122 = *(void *)(*(void *)(*(void *)a3 + 80) + 8 * v121);
            std::string::size_type v123 = (const char *)(v122 + 16);
            if (*(unsigned char *)(v122 + 31)) {
              size_t v124 = 16;
            }
            else {
              size_t v124 = strlen(v123);
            }
            __int16 v154 = 1283;
            v152.__r_.__value_.__r.__words[0] = (std::string::size_type)"objc_method_t struct extends past end of (";
            v152.__r_.__value_.__r.__words[2] = (std::string::size_type)v123;
            size_t v153 = v124;
            v135.__r_.__value_.__r.__words[0] = (std::string::size_type)&v152;
            v135.__r_.__value_.__r.__words[2] = (std::string::size_type)",";
            __int16 v136 = 770;
            *(void *)unint64_t v137 = &v135;
            *(_OWORD *)&v137[16] = *(_OWORD *)&v155.__r_.__value_.__l.__data_;
            __int16 v138 = 1282;
            v139.__r_.__value_.__r.__words[0] = (std::string::size_type)v137;
            v139.__r_.__value_.__r.__words[2] = (std::string::size_type)") section at address: 0x";
            __int16 v140 = 770;
            uint64_t v125 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v120 + 144))(v120, v121);
            v151[0] = v125 + HIDWORD(v145);
            __int16 v146 = &v139;
            v147.i64[1] = (uint64_t)v151;
            LOWORD(v149) = 3586;
            uint64_t v119 = (uint64_t)v129;
LABEL_129:
            sub_1CCC51CE4(v119, (uint64_t *)&v146);
          }
          std::string::size_type v128 = v155.__r_.__value_.__r.__words[0];
          v155.__r_.__value_.__r.__words[0] = 0;
          std::string::size_type v134 = v128;
          size_t v127 = (uint64_t *)&v134;
LABEL_134:
          llvm::report_fatal_error(v127);
        }
        uint64_t v20 = (unsigned int *)(v130 + 12 * v19);
        unsigned int v21 = *v20;
        unsigned int v22 = v20[2];
        unsigned int v23 = *(_DWORD *)(*(void *)a3 + 8);
        BOOL v15 = v23 > 0x13;
        int v24 = (1 << v23) & 0xAAC00;
        BOOL v25 = v15 || v24 == 0;
        unsigned int v26 = bswap32(v21);
        unsigned int v27 = bswap32(v22);
        unint64_t v28 = v25 ? v21 : v26;
        uint64_t v29 = v25 ? v22 : v27;
        uint64_t v30 = sub_1CCC6B2B4(v28, (_DWORD *)&v145 + 1, &v144, &v142, (void *)a3, 1);
        if (v30) {
          break;
        }
LABEL_120:
        if (++v19 == v132) {
          goto LABEL_121;
        }
      }
      uint64_t v31 = (const std::string::value_type *)v30;
      uint64_t v32 = *(void *)(a3 + 48);
      uint64_t v133 = v29;
      if (*(unsigned char *)(a3 + 60))
      {
        if (v32)
        {
          unint64_t v33 = *(const char **)(a3 + 40);
          size_t v34 = strlen(v33);
          sub_1CB907098((uint64_t)&v155, v34 + 2);
          if ((v155.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v35 = &v155;
          }
          else {
            uint64_t v35 = (std::string *)v155.__r_.__value_.__r.__words[0];
          }
          LOWORD(v35->__r_.__value_.__l.__data_) = 23339;
          uint64_t v36 = &v35->__r_.__value_.__s.__data_[2];
          if (v34) {
            memmove(v36, v33, v34);
          }
          v36[v34] = 0;
          unint64_t v37 = std::string::append(&v155, "(");
          std::string::size_type v38 = v37->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v152.__r_.__value_.__l.__data_ = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
          v152.__r_.__value_.__r.__words[2] = v38;
          v37->__r_.__value_.__l.__size_ = 0;
          v37->__r_.__value_.__r.__words[2] = 0;
          v37->__r_.__value_.__r.__words[0] = 0;
          uint64_t v39 = std::string::append(&v152, *(const std::string::value_type **)(a3 + 48));
          std::string::size_type v40 = v39->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v135.__r_.__value_.__l.__data_ = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
          v135.__r_.__value_.__r.__words[2] = v40;
          v39->__r_.__value_.__l.__size_ = 0;
          v39->__r_.__value_.__r.__words[2] = 0;
          v39->__r_.__value_.__r.__words[0] = 0;
          uint64_t v41 = std::string::append(&v135, ") ");
          std::string::size_type v42 = v41->__r_.__value_.__r.__words[2];
          *(_OWORD *)unint64_t v137 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
          *(void *)&v137[16] = v42;
          v41->__r_.__value_.__l.__size_ = 0;
          v41->__r_.__value_.__r.__words[2] = 0;
          v41->__r_.__value_.__r.__words[0] = 0;
          long long v43 = std::string::append((std::string *)v137, v31);
          std::string::size_type v44 = v43->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v139.__r_.__value_.__l.__data_ = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
          v139.__r_.__value_.__r.__words[2] = v44;
          v43->__r_.__value_.__l.__size_ = 0;
          v43->__r_.__value_.__r.__words[2] = 0;
          v43->__r_.__value_.__r.__words[0] = 0;
          uint64_t v45 = std::string::append(&v139, "]");
          std::string::size_type v46 = v45->__r_.__value_.__r.__words[0];
          v150[0] = v45->__r_.__value_.__l.__size_;
          *(void *)((char *)v150 + 7) = *(std::string::size_type *)((char *)&v45->__r_.__value_.__r.__words[1] + 7);
          char v47 = HIBYTE(v45->__r_.__value_.__r.__words[2]);
          v45->__r_.__value_.__l.__size_ = 0;
          v45->__r_.__value_.__r.__words[2] = 0;
          v45->__r_.__value_.__r.__words[0] = 0;
          v151[0] = v150[0];
          *(void *)((char *)v151 + 7) = *(void *)((char *)v150 + 7);
          v150[0] = 0;
          *(void *)((char *)v150 + 7) = 0;
          unint64_t v48 = a4->u64[1];
          unint64_t v49 = a4[1].u64[0];
          if (v48 >= v49)
          {
            uint64_t v50 = a4->i64[0];
            uint64_t v51 = (uint64_t)(v48 - a4->i64[0]) >> 5;
            unint64_t v52 = v51 + 1;
            if ((unint64_t)(v51 + 1) >> 59) {
              goto LABEL_130;
            }
            if ((uint64_t)(v49 - v50) >> 4 > v52) {
              unint64_t v52 = (uint64_t)(v49 - v50) >> 4;
            }
            if (v49 - v50 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v53 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v53 = v52;
            }
            unint64_t v148 = 0;
            size_t v149 = a4 + 1;
            if (v53 >> 59) {
              goto LABEL_131;
            }
            unint64_t v54 = (char *)operator new(32 * v53);
            uint64_t v55 = &v54[32 * v51];
            uint64_t v56 = v151[0];
            *(void *)uint64_t v55 = v46;
            *((void *)v55 + 1) = v56;
            *(void *)(v55 + 15) = *(void *)((char *)v151 + 7);
            v55[23] = v47;
            memset(v151, 0, 15);
            *((void *)v55 + 3) = v133;
            if (v48 != v50)
            {
              uint64_t v57 = &v54[32 * v51];
              do
              {
                long long v58 = *(_OWORD *)(v48 - 32);
                *((void *)v57 - 2) = *(void *)(v48 - 16);
                *((_OWORD *)v57 - 2) = v58;
                *(void *)(v48 - 24) = 0;
                *(void *)(v48 - ++*(_DWORD *)(this + 16) = 0;
                *(void *)(v48 - 32) = 0;
                *((void *)v57 - 1) = *(void *)(v48 - 8);
                v57 -= 32;
                v48 -= 32;
              }
              while (v48 != v50);
LABEL_87:
              int64x2_t v110 = *a4;
              unint64_t v49 = a4[1].u64[0];
LABEL_89:
              unint64_t v72 = (unint64_t)(v55 + 32);
              a4->i64[0] = (uint64_t)v57;
              a4->i64[1] = (uint64_t)(v55 + 32);
              int64x2_t v147 = v110;
              a4[1].i64[0] = (uint64_t)&v54[32 * v53];
              unint64_t v148 = v49;
              __int16 v146 = (std::string *)v110.i64[0];
              sub_1CD573B00((uint64_t)&v146);
              goto LABEL_90;
            }
            goto LABEL_88;
          }
          goto LABEL_52;
        }
        unsigned int v73 = *(const char **)(a3 + 40);
        size_t v74 = strlen(v73);
        sub_1CB907098((uint64_t)&v135, v74 + 2);
        if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          unsigned int v75 = &v135;
        }
        else {
          unsigned int v75 = (std::string *)v135.__r_.__value_.__r.__words[0];
        }
        LOWORD(v75->__r_.__value_.__l.__data_) = 23339;
        unsigned int v76 = &v75->__r_.__value_.__s.__data_[2];
        if (v74) {
          memmove(v76, v73, v74);
        }
        v76[v74] = 0;
        unsigned int v77 = std::string::append(&v135, " ");
        std::string::size_type v78 = v77->__r_.__value_.__r.__words[2];
        *(_OWORD *)unint64_t v137 = *(_OWORD *)&v77->__r_.__value_.__l.__data_;
        *(void *)&v137[16] = v78;
        v77->__r_.__value_.__l.__size_ = 0;
        v77->__r_.__value_.__r.__words[2] = 0;
        v77->__r_.__value_.__r.__words[0] = 0;
        BOOL v79 = std::string::append((std::string *)v137, v31);
        std::string::size_type v80 = v79->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v139.__r_.__value_.__l.__data_ = *(_OWORD *)&v79->__r_.__value_.__l.__data_;
        v139.__r_.__value_.__r.__words[2] = v80;
        v79->__r_.__value_.__l.__size_ = 0;
        v79->__r_.__value_.__r.__words[2] = 0;
        v79->__r_.__value_.__r.__words[0] = 0;
        unsigned int v81 = std::string::append(&v139, "]");
        std::string::size_type v82 = v81->__r_.__value_.__r.__words[0];
        v155.__r_.__value_.__r.__words[0] = v81->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v155.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v81->__r_.__value_.__r.__words[1] + 7);
        char v83 = HIBYTE(v81->__r_.__value_.__r.__words[2]);
        v81->__r_.__value_.__l.__size_ = 0;
        v81->__r_.__value_.__r.__words[2] = 0;
        v81->__r_.__value_.__r.__words[0] = 0;
        v152.__r_.__value_.__r.__words[0] = v155.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)v152.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)v155.__r_.__value_.__r.__words + 7);
        unint64_t v84 = a4->u64[1];
        unint64_t v85 = a4[1].u64[0];
        if (v84 >= v85)
        {
          uint64_t v86 = a4->i64[0];
          uint64_t v87 = (uint64_t)(v84 - a4->i64[0]) >> 5;
          unint64_t v88 = v87 + 1;
          if ((unint64_t)(v87 + 1) >> 59) {
            goto LABEL_130;
          }
          if ((uint64_t)(v85 - v86) >> 4 > v88) {
            unint64_t v88 = (uint64_t)(v85 - v86) >> 4;
          }
          if (v85 - v86 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v89 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v89 = v88;
          }
          unint64_t v148 = 0;
          size_t v149 = a4 + 1;
          if (v89 >> 59) {
            goto LABEL_131;
          }
          signed int v90 = (char *)operator new(32 * v89);
          std::string::size_type v91 = &v90[32 * v87];
          std::string::size_type v92 = v152.__r_.__value_.__r.__words[0];
          *(void *)std::string::size_type v91 = v82;
          *((void *)v91 + 1) = v92;
          *(void *)(v91 + 15) = *(std::string::size_type *)((char *)v152.__r_.__value_.__r.__words + 7);
          v91[23] = v83;
          v152.__r_.__value_.__r.__words[0] = 0;
          *(std::string::size_type *)((char *)v152.__r_.__value_.__r.__words + 7) = 0;
          *((void *)v91 + 3) = v133;
          if (v84 != v86)
          {
            std::string::size_type v93 = &v90[32 * v87];
            do
            {
              long long v94 = *(_OWORD *)(v84 - 32);
              *((void *)v93 - 2) = *(void *)(v84 - 16);
              *((_OWORD *)v93 - 2) = v94;
              *(void *)(v84 - 24) = 0;
              *(void *)(v84 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v84 - 32) = 0;
              *((void *)v93 - 1) = *(void *)(v84 - 8);
              v93 -= 32;
              v84 -= 32;
            }
            while (v84 != v86);
LABEL_110:
            int64x2_t v117 = *a4;
            unint64_t v85 = a4[1].u64[0];
LABEL_112:
            unint64_t v104 = (unint64_t)(v91 + 32);
            a4->i64[0] = (uint64_t)v93;
            a4->i64[1] = (uint64_t)(v91 + 32);
            int64x2_t v147 = v117;
            a4[1].i64[0] = (uint64_t)&v90[32 * v89];
            unint64_t v148 = v85;
            __int16 v146 = (std::string *)v117.i64[0];
            sub_1CD573B00((uint64_t)&v146);
            goto LABEL_113;
          }
          goto LABEL_111;
        }
      }
      else
      {
        if (v32)
        {
          uint64_t v59 = *(const char **)(a3 + 40);
          size_t v60 = strlen(v59);
          sub_1CB907098((uint64_t)&v155, v60 + 2);
          if ((v155.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            int64x2_t v61 = &v155;
          }
          else {
            int64x2_t v61 = (std::string *)v155.__r_.__value_.__r.__words[0];
          }
          LOWORD(v61->__r_.__value_.__l.__data_) = 23341;
          uint64_t v62 = &v61->__r_.__value_.__s.__data_[2];
          if (v60) {
            memmove(v62, v59, v60);
          }
          v62[v60] = 0;
          uint64_t v63 = std::string::append(&v155, "(");
          std::string::size_type v64 = v63->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v152.__r_.__value_.__l.__data_ = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
          v152.__r_.__value_.__r.__words[2] = v64;
          v63->__r_.__value_.__l.__size_ = 0;
          v63->__r_.__value_.__r.__words[2] = 0;
          v63->__r_.__value_.__r.__words[0] = 0;
          std::string::size_type v65 = std::string::append(&v152, *(const std::string::value_type **)(a3 + 48));
          std::string::size_type v66 = v65->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v135.__r_.__value_.__l.__data_ = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
          v135.__r_.__value_.__r.__words[2] = v66;
          v65->__r_.__value_.__l.__size_ = 0;
          v65->__r_.__value_.__r.__words[2] = 0;
          v65->__r_.__value_.__r.__words[0] = 0;
          uint64_t v67 = std::string::append(&v135, ") ");
          std::string::size_type v68 = v67->__r_.__value_.__r.__words[2];
          *(_OWORD *)unint64_t v137 = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
          *(void *)&v137[16] = v68;
          v67->__r_.__value_.__l.__size_ = 0;
          v67->__r_.__value_.__r.__words[2] = 0;
          v67->__r_.__value_.__r.__words[0] = 0;
          size_t v69 = std::string::append((std::string *)v137, v31);
          std::string::size_type v70 = v69->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v139.__r_.__value_.__l.__data_ = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
          v139.__r_.__value_.__r.__words[2] = v70;
          v69->__r_.__value_.__l.__size_ = 0;
          v69->__r_.__value_.__r.__words[2] = 0;
          v69->__r_.__value_.__r.__words[0] = 0;
          unsigned int v71 = std::string::append(&v139, "]");
          std::string::size_type v46 = v71->__r_.__value_.__r.__words[0];
          v150[0] = v71->__r_.__value_.__l.__size_;
          *(void *)((char *)v150 + 7) = *(std::string::size_type *)((char *)&v71->__r_.__value_.__r.__words[1] + 7);
          char v47 = HIBYTE(v71->__r_.__value_.__r.__words[2]);
          v71->__r_.__value_.__l.__size_ = 0;
          v71->__r_.__value_.__r.__words[2] = 0;
          v71->__r_.__value_.__r.__words[0] = 0;
          v151[0] = v150[0];
          *(void *)((char *)v151 + 7) = *(void *)((char *)v150 + 7);
          v150[0] = 0;
          *(void *)((char *)v150 + 7) = 0;
          unint64_t v48 = a4->u64[1];
          unint64_t v49 = a4[1].u64[0];
          if (v48 >= v49)
          {
            uint64_t v105 = a4->i64[0];
            uint64_t v106 = (uint64_t)(v48 - a4->i64[0]) >> 5;
            unint64_t v107 = v106 + 1;
            if ((unint64_t)(v106 + 1) >> 59) {
              goto LABEL_130;
            }
            if ((uint64_t)(v49 - v105) >> 4 > v107) {
              unint64_t v107 = (uint64_t)(v49 - v105) >> 4;
            }
            if (v49 - v105 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v53 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v53 = v107;
            }
            unint64_t v148 = 0;
            size_t v149 = a4 + 1;
            if (v53 >> 59) {
              goto LABEL_131;
            }
            unint64_t v54 = (char *)operator new(32 * v53);
            uint64_t v55 = &v54[32 * v106];
            uint64_t v108 = v151[0];
            *(void *)uint64_t v55 = v46;
            *((void *)v55 + 1) = v108;
            *(void *)(v55 + 15) = *(void *)((char *)v151 + 7);
            v55[23] = v47;
            memset(v151, 0, 15);
            *((void *)v55 + 3) = v133;
            if (v48 != v105)
            {
              uint64_t v57 = &v54[32 * v106];
              do
              {
                long long v109 = *(_OWORD *)(v48 - 32);
                *((void *)v57 - 2) = *(void *)(v48 - 16);
                *((_OWORD *)v57 - 2) = v109;
                *(void *)(v48 - 24) = 0;
                *(void *)(v48 - ++*(_DWORD *)(this + 16) = 0;
                *(void *)(v48 - 32) = 0;
                *((void *)v57 - 1) = *(void *)(v48 - 8);
                v57 -= 32;
                v48 -= 32;
              }
              while (v48 != v105);
              goto LABEL_87;
            }
LABEL_88:
            int64x2_t v110 = vdupq_n_s64(v48);
            uint64_t v57 = v55;
            goto LABEL_89;
          }
LABEL_52:
          *(void *)unint64_t v48 = v46;
          *(void *)(v48 + ++*(_DWORD *)(this + 8) = v151[0];
          *(void *)(v48 + 15) = *(void *)((char *)v151 + 7);
          *(unsigned char *)(v48 + 23) = v47;
          memset(v151, 0, 15);
          *(void *)(v48 + 24) = v133;
          unint64_t v72 = v48 + 32;
LABEL_90:
          a4->i64[1] = v72;
          if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v139.__r_.__value_.__l.__data_);
          }
          if ((v137[23] & 0x80000000) != 0) {
            operator delete(*(void **)v137);
          }
          if (SHIBYTE(v135.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v135.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v152.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v152.__r_.__value_.__l.__data_);
          }
          if ((SHIBYTE(v155.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            goto LABEL_120;
          }
          long long v111 = (void *)v155.__r_.__value_.__r.__words[0];
          goto LABEL_119;
        }
        std::string::size_type v95 = *(const char **)(a3 + 40);
        size_t v96 = strlen(v95);
        sub_1CB907098((uint64_t)&v135, v96 + 2);
        if ((v135.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v97 = &v135;
        }
        else {
          std::string::size_type v97 = (std::string *)v135.__r_.__value_.__r.__words[0];
        }
        LOWORD(v97->__r_.__value_.__l.__data_) = 23341;
        uint64_t v98 = &v97->__r_.__value_.__s.__data_[2];
        if (v96) {
          memmove(v98, v95, v96);
        }
        v98[v96] = 0;
        std::string::size_type v99 = std::string::append(&v135, " ");
        std::string::size_type v100 = v99->__r_.__value_.__r.__words[2];
        *(_OWORD *)unint64_t v137 = *(_OWORD *)&v99->__r_.__value_.__l.__data_;
        *(void *)&v137[16] = v100;
        v99->__r_.__value_.__l.__size_ = 0;
        v99->__r_.__value_.__r.__words[2] = 0;
        v99->__r_.__value_.__r.__words[0] = 0;
        unint64_t v101 = std::string::append((std::string *)v137, v31);
        std::string::size_type v102 = v101->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v139.__r_.__value_.__l.__data_ = *(_OWORD *)&v101->__r_.__value_.__l.__data_;
        v139.__r_.__value_.__r.__words[2] = v102;
        v101->__r_.__value_.__l.__size_ = 0;
        v101->__r_.__value_.__r.__words[2] = 0;
        v101->__r_.__value_.__r.__words[0] = 0;
        uint64_t v103 = std::string::append(&v139, "]");
        std::string::size_type v82 = v103->__r_.__value_.__r.__words[0];
        v155.__r_.__value_.__r.__words[0] = v103->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v155.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v103->__r_.__value_.__r.__words[1] + 7);
        char v83 = HIBYTE(v103->__r_.__value_.__r.__words[2]);
        v103->__r_.__value_.__l.__size_ = 0;
        v103->__r_.__value_.__r.__words[2] = 0;
        v103->__r_.__value_.__r.__words[0] = 0;
        v152.__r_.__value_.__r.__words[0] = v155.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)v152.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)v155.__r_.__value_.__r.__words + 7);
        unint64_t v84 = a4->u64[1];
        unint64_t v85 = a4[1].u64[0];
        if (v84 >= v85)
        {
          uint64_t v112 = a4->i64[0];
          uint64_t v113 = (uint64_t)(v84 - a4->i64[0]) >> 5;
          unint64_t v114 = v113 + 1;
          if ((unint64_t)(v113 + 1) >> 59) {
LABEL_130:
          }
            abort();
          if ((uint64_t)(v85 - v112) >> 4 > v114) {
            unint64_t v114 = (uint64_t)(v85 - v112) >> 4;
          }
          if (v85 - v112 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v89 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v89 = v114;
          }
          unint64_t v148 = 0;
          size_t v149 = a4 + 1;
          if (v89 >> 59) {
LABEL_131:
          }
            sub_1CB833614();
          signed int v90 = (char *)operator new(32 * v89);
          std::string::size_type v91 = &v90[32 * v113];
          std::string::size_type v115 = v152.__r_.__value_.__r.__words[0];
          *(void *)std::string::size_type v91 = v82;
          *((void *)v91 + 1) = v115;
          *(void *)(v91 + 15) = *(std::string::size_type *)((char *)v152.__r_.__value_.__r.__words + 7);
          v91[23] = v83;
          v152.__r_.__value_.__r.__words[0] = 0;
          *(std::string::size_type *)((char *)v152.__r_.__value_.__r.__words + 7) = 0;
          *((void *)v91 + 3) = v133;
          if (v84 != v112)
          {
            std::string::size_type v93 = &v90[32 * v113];
            do
            {
              long long v116 = *(_OWORD *)(v84 - 32);
              *((void *)v93 - 2) = *(void *)(v84 - 16);
              *((_OWORD *)v93 - 2) = v116;
              *(void *)(v84 - 24) = 0;
              *(void *)(v84 - ++*(_DWORD *)(this + 16) = 0;
              *(void *)(v84 - 32) = 0;
              *((void *)v93 - 1) = *(void *)(v84 - 8);
              v93 -= 32;
              v84 -= 32;
            }
            while (v84 != v112);
            goto LABEL_110;
          }
LABEL_111:
          int64x2_t v117 = vdupq_n_s64(v84);
          std::string::size_type v93 = v91;
          goto LABEL_112;
        }
      }
      *(void *)unint64_t v84 = v82;
      *(void *)(v84 + ++*(_DWORD *)(this + 8) = v152.__r_.__value_.__r.__words[0];
      *(void *)(v84 + 15) = *(std::string::size_type *)((char *)v152.__r_.__value_.__r.__words + 7);
      *(unsigned char *)(v84 + 23) = v83;
      *(void *)(v84 + 24) = v133;
      unint64_t v104 = v84 + 32;
LABEL_113:
      a4->i64[1] = v104;
      if (SHIBYTE(v139.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v139.__r_.__value_.__l.__data_);
      }
      if ((v137[23] & 0x80000000) != 0) {
        operator delete(*(void **)v137);
      }
      if ((SHIBYTE(v135.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_120;
      }
      long long v111 = (void *)v135.__r_.__value_.__r.__words[0];
LABEL_119:
      operator delete(v111);
      goto LABEL_120;
    }
LABEL_121:
    *unint64_t v129 = 0;
  }
  else
  {
    *a1 = 0;
  }
}

uint64_t sub_1CCC6F9A4(uint64_t a1)
{
  *(void *)a1 = &unk_1F26336A0;
  sub_1CCC6FA50((void ***)(a1 + 264));
  int v2 = *(void **)(a1 + 232);
  if (v2 != (void *)(a1 + 248)) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 208);
  if (v3 != (void *)(a1 + 224)) {
    free(v3);
  }
  unsigned int v4 = *(void **)(a1 + 128);
  if (v4 != (void *)(a1 + 144)) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 104);
  if (v5 != (void *)(a1 + 120)) {
    free(v5);
  }
  uint64_t v6 = *(void **)(a1 + 80);
  if (v6 != (void *)(a1 + 96)) {
    free(v6);
  }
  return a1;
}

void ***sub_1CCC6FA50(void ***a1)
{
  int v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*v2 != v2 + 2) {
      free(*v2);
    }
    MEMORY[0x1D25D9CE0](v2, 0x1080C40E09A0471);
  }
  return a1;
}

uint64_t sub_1CCC6FAAC(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > a3 || a3 + 72 > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    size_t v12 = "Structure read out-of-range";
    __int16 v13 = 259;
    sub_1CCC51CE4((uint64_t)&v14, (uint64_t *)&v12);
  }
  int8x8_t v5 = *(int8x8_t *)a3;
  int8x16_t v6 = *(int8x16_t *)(a3 + 24);
  int8x16_t v7 = *(int8x16_t *)(a3 + 40);
  int8x16_t v8 = *(int8x16_t *)(a3 + 56);
  unsigned int v9 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v9 > 0x13;
  int v10 = (1 << v9) & 0xAAC00;
  if (!v4 && v10 != 0)
  {
    int8x8_t v5 = vrev32_s8(v5);
    int8x16_t v6 = vrev64q_s8(v6);
    int8x16_t v7 = vrev64q_s8(v7);
    int8x16_t v8 = vrev32q_s8(v8);
  }
  *(unsigned char *)(result + 72) &= ~1u;
  *(int8x8_t *)uint64_t result = v5;
  *(_OWORD *)(result + ++*(_DWORD *)(this + 8) = *(_OWORD *)(a3 + 8);
  *(int8x16_t *)(result + 24) = v6;
  *(int8x16_t *)(result + 40) = v7;
  *(int8x16_t *)(result + 56) = v8;
  return result;
}

uint64_t sub_1CCC6FB90(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 16);
  BOOL v4 = v3 > a3 || a3 + 56 > v3 + *(void *)(a2 + 24);
  if (v4)
  {
    uint64_t v11 = "Structure read out-of-range";
    __int16 v12 = 259;
    sub_1CCC51CE4((uint64_t)&v13, (uint64_t *)&v11);
  }
  int8x8_t v5 = *(int8x8_t *)a3;
  int8x16_t v6 = *(int8x16_t *)(a3 + 24);
  int8x16_t v7 = *(int8x16_t *)(a3 + 40);
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v8 > 0x13;
  int v9 = (1 << v8) & 0xAAC00;
  if (!v4 && v9 != 0)
  {
    int8x8_t v5 = vrev32_s8(v5);
    int8x16_t v6 = vrev32q_s8(v6);
    int8x16_t v7 = vrev32q_s8(v7);
  }
  *(unsigned char *)(result + 56) &= ~1u;
  *(int8x8_t *)uint64_t result = v5;
  *(_OWORD *)(result + ++*(_DWORD *)(this + 8) = *(_OWORD *)(a3 + 8);
  *(int8x16_t *)(result + 24) = v6;
  *(int8x16_t *)(result + 40) = v7;
  return result;
}

uint64_t sub_1CCC6FC68(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int8x8_t v5 = (const void *)(a2 + 16);
    BOOL v4 = *(const void **)a2;
    if (v4 == v5)
    {
      int8x16_t v7 = (_DWORD *)(a2 + 8);
      uint64_t v8 = *(unsigned int *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 8);
      if (v9 >= v8)
      {
        if (v8) {
          memmove(*(void **)a1, v4, (v8 << 6) - 3);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v8)
        {
          *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9) {
          memmove(*(void **)a1, v4, (v9 << 6) - 3);
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v10 = *v7;
        if (v9 != v10) {
          memcpy((void *)(*(void *)a1 + (v9 << 6)), (const void *)(*(void *)a2 + (v9 << 6)), *(void *)a2 + (v10 << 6) - (*(void *)a2 + (v9 << 6)));
        }
      }
      *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = v8;
    }
    else
    {
      int8x16_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        BOOL v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      int8x16_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + ++*(_DWORD *)(this + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *int8x16_t v7 = 0;
  }
  return a1;
}

void sub_1CCC6FD8C(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    BOOL v4 = (char *)v1[1];
    int8x8_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        int8x16_t v6 = (void *)*((void *)v4 - 3);
        if (v6)
        {
          *((void *)v4 - 2) = v6;
          operator delete(v6);
        }
        v4 -= 56;
      }
      while (v4 != v2);
      int8x8_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC6FE18(uint64_t *a1, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v8 = a1[2];
  uint64_t v9 = *a1;
  if (0x6DB6DB6DB6DB6DB7 * ((v8 - *a1) >> 3) < a4)
  {
    if (v9)
    {
      uint64_t v10 = a1[1];
      uint64_t v11 = (void *)*a1;
      if (v10 != v9)
      {
        do
        {
          __int16 v12 = *(void **)(v10 - 24);
          if (v12)
          {
            *(void *)(v10 - ++*(_DWORD *)(this + 16) = v12;
            operator delete(v12);
          }
          v10 -= 56;
        }
        while (v10 != v9);
        uint64_t v11 = (void *)*a1;
      }
      a1[1] = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x492492492492492) {
      goto LABEL_27;
    }
    unint64_t v13 = 0x6DB6DB6DB6DB6DB7 * (v8 >> 3);
    uint64_t v14 = 2 * v13;
    if (2 * v13 <= a4) {
      uint64_t v14 = a4;
    }
    unint64_t v15 = v13 >= 0x249249249249249 ? 0x492492492492492 : v14;
    if (v15 > 0x492492492492492) {
LABEL_27:
    }
      abort();
    uint64_t v16 = 56 * v15;
    BOOL v17 = operator new(56 * v15);
    *a1 = (uint64_t)v17;
    a1[1] = (uint64_t)v17;
    a1[2] = (uint64_t)v17 + v16;
    unsigned int v18 = a1;
    uint64_t v19 = a2;
    goto LABEL_19;
  }
  if (0x6DB6DB6DB6DB6DB7 * ((a1[1] - v9) >> 3) < a4)
  {
    uint64_t v20 = (long long *)((char *)a2 + 8 * ((a1[1] - v9) >> 3));
    sub_1CCC6FFF0(a2, v20, v9);
    unsigned int v18 = a1;
    uint64_t v19 = v20;
LABEL_19:
    sub_1CCC68724(v18, v19, a3);
    return;
  }
  uint64_t v21 = sub_1CCC6FFF0(a2, a3, v9);
  for (uint64_t i = a1[1]; i != v21; i -= 56)
  {
    unsigned int v23 = *(void **)(i - 24);
    if (v23)
    {
      *(void *)(i - ++*(_DWORD *)(this + 16) = v23;
      operator delete(v23);
    }
  }
  a1[1] = v21;
}

uint64_t sub_1CCC6FFF0(long long *a1, long long *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    int8x8_t v5 = a1;
    do
    {
      long long v6 = *v5;
      *(_OWORD *)(a3 + 12) = *(long long *)((char *)v5 + 12);
      *(_OWORD *)a3 = v6;
      if (v5 != (long long *)a3) {
        sub_1CBFAFDE4((void *)(a3 + 32), *((char **)v5 + 4), *((char **)v5 + 5), (uint64_t)(*((void *)v5 + 5) - *((void *)v5 + 4)) >> 3);
      }
      int8x8_t v5 = (long long *)((char *)v5 + 56);
      a3 += 56;
    }
    while (v5 != a2);
  }
  return a3;
}

unint64_t sub_1CCC70068(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 144 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

uint64_t sub_1CCC700E4(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int8x8_t v5 = (const void *)(a2 + 16);
    unint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      int8x16_t v7 = (_DWORD *)(a2 + 8);
      uint64_t v8 = *(unsigned int *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 8);
      if (v9 >= v8)
      {
        if (v8) {
          memmove(*(void **)a1, v4, 144 * v8);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v8)
        {
          *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v9) {
          memmove(*(void **)a1, v4, 144 * v9);
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v10 = *v7;
        if (v9 != v10) {
          memcpy((void *)(*(void *)a1 + 144 * v9), (const void *)(*(void *)a2 + 144 * v9), *(void *)a2 + 144 * v10 - (*(void *)a2 + 144 * v9));
        }
      }
      *(_DWORD *)(a1 + ++*(_DWORD *)(this + 8) = v8;
    }
    else
    {
      long long v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        unint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      int8x16_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + ++*(_DWORD *)(this + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    *int8x16_t v7 = 0;
  }
  return a1;
}

uint64_t sub_1CCC70210(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + ++*(_DWORD *)(this + 16) = v2 - 56;
    unint64_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - ++*(_DWORD *)(this + 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 56;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *sub_1CCC70274(int64x2_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x6DB6DB6DB6DB6DB7 * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x492492492492492) {
    abort();
  }
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v3) {
    unint64_t v3 = 0xDB6DB6DB6DB6DB6ELL * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((a1[1].i64[0] - a1->i64[0]) >> 3)) >= 0x249249249249249) {
    unint64_t v5 = 0x492492492492492;
  }
  else {
    unint64_t v5 = v3;
  }
  uint64_t v19 = a1 + 1;
  if (v5 > 0x492492492492492) {
    sub_1CB833614();
  }
  int8x16_t v7 = (char *)operator new(56 * v5);
  uint64_t v8 = &v7[56 * v2];
  *(_OWORD *)uint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 12) = *(_OWORD *)(a2 + 12);
  *((void *)v8 + 5) = 0;
  *((void *)v8 + 6) = 0;
  *((void *)v8 + 4) = 0;
  sub_1CBFCBA2C((void *)v8 + 4, *(const void **)(a2 + 32), *(void *)(a2 + 40), (uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3);
  uint64_t v10 = a1->i64[0];
  unint64_t v9 = a1->u64[1];
  if (v9 == a1->i64[0])
  {
    int64x2_t v13 = vdupq_n_s64(v9);
    uint64_t v11 = v8;
  }
  else
  {
    uint64_t v11 = v8;
    do
    {
      long long v12 = *(_OWORD *)(v9 - 56);
      *(_OWORD *)(v11 - 44) = *(_OWORD *)(v9 - 44);
      *(_OWORD *)(v11 - 56) = v12;
      *((void *)v11 - 2) = 0;
      *((void *)v11 - 1) = 0;
      *((void *)v11 - 3) = 0;
      *(_OWORD *)(v11 - 24) = *(_OWORD *)(v9 - 24);
      *((void *)v11 - 1) = *(void *)(v9 - 8);
      v11 -= 56;
      *(void *)(v9 - 24) = 0;
      *(void *)(v9 - ++*(_DWORD *)(this + 16) = 0;
      *(void *)(v9 - ++*(_DWORD *)(this + 8) = 0;
      v9 -= 56;
    }
    while (v9 != v10);
    int64x2_t v13 = *a1;
  }
  a1->i64[0] = (uint64_t)v11;
  a1->i64[1] = (uint64_t)(v8 + 56);
  int64x2_t v17 = v13;
  uint64_t v14 = a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)&v7[56 * v5];
  uint64_t v18 = v14;
  uint64_t v16 = v13.i64[0];
  sub_1CCC70210((uint64_t)&v16);
  return v8 + 56;
}

void llvm::object::MachOUniversalBinary::ObjectForArch::getAsObjectFile(llvm::object::MachOUniversalBinary::ObjectForArch *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this)
  {
    unint64_t v2 = *(void *)(v1 + 24);
    if ((*(_DWORD *)(v1 + 48) | 0x1000000) == 0xCBFEBABE)
    {
      unint64_t v3 = *((unsigned int *)this + 5);
      unint64_t v4 = *((unsigned int *)this + 6);
    }
    else
    {
      unint64_t v3 = *((void *)this + 5);
      unint64_t v4 = *((void *)this + 6);
    }
    if (v2 < v3) {
      unint64_t v3 = *(void *)(v1 + 24);
    }
    unint64_t v5 = v2 - v3;
    if (v5 >= v4) {
      unint64_t v5 = v4;
    }
    v6[0] = *(void *)(v1 + 16) + v3;
    v6[1] = v5;
    long long v7 = *(_OWORD *)(v1 + 32);
    llvm::object::ObjectFile::createMachOObjectFile((uint64_t)v6);
  }
  llvm::report_fatal_error((llvm *)"MachOUniversalBinary::ObjectForArch::getAsObjectFile() called when Parent is a nullptr", (const llvm::Twine *)1);
}

void sub_1CCC704AC(int a1, llvm::Twine *this)
{
  llvm::Twine::str(this, &v6);
  unint64_t v2 = std::string::insert(&v6, 0, "truncated or malformed fat file (");
  std::string::size_type v3 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  unint64_t v4 = std::string::append(&v9, ")");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  std::string::size_type v8 = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v6.__r_.__value_.__l.__data_);
  }
  operator new();
}

double llvm::object::MachOUniversalBinary::getObjectForArch@<D0>(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  LOWORD(v23) = 261;
  *(void *)&v22[0] = a2;
  *((void *)&v22[0] + 1) = a3;
  llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v22);
  int v8 = DWORD2(v26);
  if (SBYTE7(v26) < 0) {
    operator delete(__p[0]);
  }
  if (!v8)
  {
    LOWORD(v27) = 1283;
    std::string v9 = "Unknown architecture named: ";
    goto LABEL_5;
  }
  llvm::object::MachOUniversalBinary::ObjectForArch::ObjectForArch((uint64_t)v22, a1, 0);
  long long v18 = v22[0];
  long long v19 = v22[1];
  long long v20 = v23;
  long long v21 = v24;
  if (!*(void *)&v22[0] && !DWORD2(v18))
  {
LABEL_21:
    LOWORD(v27) = 1283;
    std::string v9 = "fat file does not contain ";
LABEL_5:
    __p[0] = (void *)v9;
    *(void *)&long long v26 = a2;
    *((void *)&v26 + 1) = a3;
    operator new();
  }
  while (1)
  {
    sub_1CD5DF348((unsigned int *)&v18, (std::string *)__p);
    int v10 = SBYTE7(v26);
    uint64_t v11 = __p[0];
    long long v12 = (void *)(BYTE7(v26) & 0x7F);
    if (SBYTE7(v26) < 0) {
      long long v12 = __p[1];
    }
    BOOL v13 = v12 == (void *)a3;
    if (a3 && v12 == (void *)a3)
    {
      if ((SBYTE7(v26) & 0x80u) == 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      BOOL v13 = memcmp(v14, a2, a3) == 0;
    }
    if (v10 < 0) {
      operator delete(v11);
    }
    if (v13) {
      break;
    }
    llvm::object::MachOUniversalBinary::ObjectForArch::ObjectForArch((uint64_t)__p, v18, DWORD2(v18) + 1);
    long long v18 = *(_OWORD *)__p;
    long long v19 = v26;
    long long v20 = v27;
    long long v21 = v28;
    if (!__p[0] && !DWORD2(v18)) {
      goto LABEL_21;
    }
  }
  *(unsigned char *)(a4 + 64) &= ~1u;
  long long v15 = v19;
  *(_OWORD *)a4 = v18;
  *(_OWORD *)(a4 + ++*(_DWORD *)(this + 16) = v15;
  double result = *(double *)&v20;
  long long v17 = v21;
  *(_OWORD *)(a4 + 32) = v20;
  *(_OWORD *)(a4 + 4++*(_DWORD *)(this + 8) = v17;
  return result;
}

void llvm::object::MachOUniversalBinary::getMachOObjectForArch(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  llvm::object::MachOUniversalBinary::getObjectForArch(a1, a2, a3, (uint64_t)v6);
  if ((v7 & 1) == 0) {
    llvm::object::MachOUniversalBinary::ObjectForArch::getAsObjectFile((llvm::object::MachOUniversalBinary::ObjectForArch *)v6);
  }
  uint64_t v5 = v6[0];
  *(unsigned char *)(a4 + 8) |= 1u;
  *(void *)a4 = v5;
}

BOOL llvm::object::MetalLibObjectFile::parseFileSize(uint64_t a1, unint64_t *a2, unint64_t a3)
{
  unint64_t v3 = *a2 + 8;
  if (v3 > a3) {
    operator new();
  }
  uint64_t v4 = *(void *)*a2;
  *a2 = v3;
  *(void *)(a1 + 80) = v4;
  return v3 <= a3;
}

uint64_t llvm::object::MetalLibObjectFile::parseVariableCount(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 200);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    unint64_t v4 = *(void *)(a1 + 24);
    if (v4 < v1) {
      unint64_t v1 = *(void *)(a1 + 24);
    }
    uint64_t v5 = (unsigned int *)(v3 + v1);
    if ((unint64_t)(v5 + 1) > v3 + v4) {
      operator new();
    }
    unint64_t v6 = *v5;
    sub_1CD6EA0A4(a1 + 600, v6);
    sub_1CCC771D0(a1 + 328, v6 + ((uint64_t)(*(void *)(a1 + 336) - *(void *)(a1 + 328)) >> 3));
    if ((*(_WORD *)(a1 + 70) & 1) == 0)
    {
      LODWORD(v10[0]) = -1;
      uint64_t v7 = *(void *)(a1 + 376);
      unint64_t v8 = (*(void *)(a1 + 384) - v7) >> 2;
      if (v6 <= v8)
      {
        if (v6 < v8) {
          *(void *)(a1 + 384) = v7 + 4 * v6;
        }
      }
      else
      {
        sub_1CC2DC07C(a1 + 376, v6 - v8, v10);
      }
    }
  }
  return 1;
}

uint64_t llvm::object::MetalLibObjectFile::parseImportedSymbolCount(void *a1)
{
  unint64_t v1 = a1[27];
  if (v1)
  {
    uint64_t v2 = a1[2];
    unint64_t v3 = a1[3];
    if (v3 < v1) {
      unint64_t v1 = a1[3];
    }
    unint64_t v4 = (unsigned int *)(v2 + v1);
    if ((unint64_t)(v4 + 1) > v2 + v3) {
      operator new();
    }
    sub_1CD6EA144((uint64_t)(a1 + 78), *v4);
  }
  return 1;
}

uint64_t llvm::object::MetalLibObjectFile::parseReflectionCount(void *a1)
{
  unint64_t v1 = a1[29];
  if (v1)
  {
    uint64_t v2 = a1[2];
    unint64_t v3 = a1[3];
    if (v3 < v1) {
      unint64_t v1 = a1[3];
    }
    unint64_t v4 = (unsigned int *)(v2 + v1);
    if ((unint64_t)(v4 + 1) > v2 + v3) {
      operator new();
    }
    sub_1CD6EA144((uint64_t)(a1 + 81), *v4);
  }
  return 1;
}

uint64_t llvm::object::MetalLibObjectFile::parseScriptCount(void *a1)
{
  unint64_t v1 = a1[31];
  if (v1)
  {
    uint64_t v2 = a1[2];
    unint64_t v3 = a1[3];
    if (v3 < v1) {
      unint64_t v1 = a1[3];
    }
    unint64_t v4 = (unsigned int *)(v2 + v1);
    if ((unint64_t)(v4 + 1) > v2 + v3) {
      operator new();
    }
    sub_1CD6EA144((uint64_t)(a1 + 84), *v4);
  }
  return 1;
}

llvm::object::MetalLibObjectFile *llvm::object::MetalLibObjectFile::moveSymbolNext(llvm::object::MetalLibObjectFile *this, _DWORD *a2)
{
  int v3 = a2[1];
  if (v3)
  {
    if (v3 == 1)
    {
      unint64_t v4 = (*a2 + 1);
      *a2 = v4;
      uint64_t v5 = *((void *)this + 35);
      uint64_t v6 = *((void *)this + 36) - v5;
      uint64_t v7 = *((void *)this + 75);
      if (((*((void *)this + 76) - v7) >> 3) + (v6 >> 3) != v4)
      {
        unint64_t v8 = v6 >> 3;
        while (1)
        {
          BOOL v9 = v4 >= v8;
          unint64_t v10 = v4 - v8;
          if (v9) {
            break;
          }
          uint64_t v11 = *(void *)(v5 + 8 * v4);
          if (!v11) {
            llvm::object::MetalLibObjectFile::materializeFunctionNo(this);
          }
          if (*(unsigned char *)(v11 + 24) != 3)
          {
            unint64_t v4 = (*a2 + 1);
            *a2 = v4;
            uint64_t v5 = *((void *)this + 35);
            unint64_t v8 = (*((void *)this + 36) - v5) >> 3;
            uint64_t v7 = *((void *)this + 75);
            if (((*((void *)this + 76) - v7) >> 3) + v8 != v4) {
              continue;
            }
          }
          return this;
        }
        if (!*(void *)(v7 + 8 * v10)) {
          llvm::object::MetalLibObjectFile::materializeVariableNo(this);
        }
      }
    }
  }
  else
  {
    ++*a2;
  }
  return this;
}

uint64_t llvm::object::MetalLibObjectFile::getSymbolValueImpl(llvm::object::MetalLibObjectFile *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 35);
  uint64_t v3 = *((void *)this + 36) - v2;
  if (a2 < (unint64_t)(v3 >> 3))
  {
    uint64_t v4 = *(void *)(v2 + 8 * a2);
    if (!v4) {
      llvm::object::MetalLibObjectFile::materializeFunctionNo(this);
    }
    uint64_t v5 = *(void *)(v4 + 8);
    return v5 - *((void *)this + 2) - 10;
  }
  uint64_t v6 = *((void *)this + 75);
  if (a2 < (unint64_t)((v3 >> 3) + ((*((void *)this + 76) - v6) >> 3)))
  {
    uint64_t v7 = *(void *)(v6 + 8 * (a2 - (v3 >> 3)));
    if (!v7) {
      llvm::object::MetalLibObjectFile::materializeVariableNo(this);
    }
    uint64_t v5 = *(void *)(v7 + 8);
    return v5 - *((void *)this + 2) - 10;
  }
  return 0;
}

__n128 llvm::object::MetalLibObjectFile::getTargetTriple@<Q0>(llvm::object::MetalLibObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)this + 696;
  uint64_t v5 = (char *)this + 720;
  if (*((_DWORD *)this + 180)) {
    goto LABEL_2;
  }
  uint64_t v6 = *((unsigned __int16 *)this + 34);
  v55[0] = (*((unsigned __int16 *)this + 32) >> 1) | ((unint64_t)*((unsigned __int16 *)this + 33) << 32) | 0x8000000000000000;
  v55[1] = v6 | 0x80000000;
  __str.__r_.__value_.__r.__words[0] = 0x8000000200000001;
  __str.__r_.__value_.__l.__size_ = 2147483654;
  if (sub_1CC156834(v55, &__str))
  {
    unint64_t v7 = *((void *)this + 45) - *((void *)this + 44);
    if ((v7 & 0x3FFFFFFFCLL) != 0)
    {
      uint64_t v8 = 0;
      uint64_t v9 = (v7 >> 2);
      do
      {
        if (*(_DWORD *)(*((void *)this + 44) + 4 * v8) == -1)
        {
          sub_1CD6EA36C((char *)&__str, this, v8, (uint64_t *)this + 35, (uint64_t *)this + 75, (_DWORD **)this + 44, (_DWORD **)this + 47, (char **)this + 53, (uint64_t)this + 448);
          if (__str.__r_.__value_.__r.__words[0])
          {
            unint64_t v54 = (void *)__str.__r_.__value_.__r.__words[0];
            sub_1CD4515D0(&v54);
            if (v54) {
              (*(void (**)(void *))(*v54 + 8))(v54);
            }
          }
        }
        ++v8;
      }
      while (v9 != v8);
    }
    unint64_t v16 = *((void *)this + 48) - *((void *)this + 47);
    if ((v16 & 0x3FFFFFFFCLL) != 0)
    {
      uint64_t v17 = 0;
      uint64_t v18 = (v16 >> 2);
      do
      {
        if (*(_DWORD *)(*((void *)this + 47) + 4 * v17) == -1)
        {
          sub_1CD6EA720((char *)&__str, this, v17, (uint64_t *)this + 75, (uint64_t *)this + 35, (_DWORD **)this + 47, (_DWORD **)this + 44, (char **)this + 56, (uint64_t)this + 424);
          if (__str.__r_.__value_.__r.__words[0])
          {
            unint64_t v53 = (void *)__str.__r_.__value_.__r.__words[0];
            sub_1CD4515D0(&v53);
            if (v53) {
              (*(void (**)(void *))(*v53 + 8))(v53);
            }
          }
        }
        ++v17;
      }
      while (v18 != v17);
    }
    uint64_t v19 = *((void *)this + 50);
    uint64_t v20 = *((void *)this + 51);
    if (((v20 - v19) & 0x7FFFFFFF8) != 0)
    {
      uint64_t v21 = 0;
      uint64_t v22 = ((unint64_t)(v20 - v19) >> 3);
      do
      {
        uint64_t v23 = *(void *)(*((void *)this + 50) + 8 * v21);
        if (v23)
        {
          long long v50 = *(_OWORD *)(v23 + 16);
          uint64_t v51 = "";
          uint64_t v52 = 0;
          llvm::getBitcodeTargetTriple((uint64_t)&v50, (uint64_t)&__p);
          if (v59)
          {
            BOOL v25 = __p;
            std::string __p = 0;
            unint64_t v49 = v25;
            sub_1CD4515D0(&v49);
            if (v49) {
              (*(void (**)(void *))(*v49 + 8))(v49);
            }
          }
          else
          {
            WORD4(v47) = 260;
            *(void *)&long long v45 = &__p;
            llvm::Triple::Triple((llvm::Triple *)&__str, (const llvm::Twine *)&v45);
            if (v21)
            {
              if (*(_DWORD *)v5 != v62
                || *(void *)((char *)this + 724) != *(void *)((char *)&v62 + 4)
                || *((_DWORD *)this + 183) != HIDWORD(v62)
                || *((void *)this + 92) != v63)
              {
                if (*((char *)this + 719) < 0) {
                  operator delete(*(void **)v4);
                }
                *((_OWORD *)v4 + 1) = 0u;
                *((_OWORD *)v4 + 2) = 0u;
                *(_OWORD *)uint64_t v4 = 0u;
              }
            }
            else
            {
              std::string::operator=((std::string *)v4, &__str);
              *(_OWORD *)uint64_t v5 = v62;
              *((void *)v5 + 2) = v63;
            }
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
          }
          if (v59)
          {
            long long v24 = __p;
            std::string __p = 0;
            if (v24) {
              (*(void (**)(void *))(*(void *)v24 + 8))(v24);
            }
          }
          else if (v58 < 0)
          {
            operator delete(__p);
          }
        }
        ++v21;
      }
      while (v22 != v21);
      uint64_t v19 = *((void *)this + 50);
      uint64_t v20 = *((void *)this + 51);
    }
    if (v19 == v20)
    {
      switch(*((_WORD *)this + 35) >> 1)
      {
        case 1:
          long long v26 = "air64-apple-macosx10.13.0";
          break;
        case 2:
          long long v26 = "air64-apple-macosx11.0.0";
          break;
        case 3:
          long long v26 = "air64-apple-macosx12.0.0";
          break;
        default:
          long long v26 = "air64-apple-macosx10.11.0";
          break;
      }
      *(void *)&long long v45 = v26;
      WORD4(v47) = 259;
      llvm::Triple::Triple((llvm::Triple *)&__str, (const llvm::Twine *)&v45);
      if (*((char *)this + 719) < 0) {
        operator delete(*(void **)v4);
      }
      *(_OWORD *)uint64_t v4 = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
      uint64_t v44 = v63;
      *((void *)v4 + 2) = *((void *)&__str.__r_.__value_.__l + 2);
      *(_OWORD *)uint64_t v5 = v62;
      *((void *)v5 + 2) = v44;
    }
    goto LABEL_2;
  }
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v62;
  *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = xmmword_1CDC7F9D0;
  if ((*((_WORD *)this + 35) & 0x100) != 0) {
    uint64_t v11 = "air64-apple";
  }
  else {
    uint64_t v11 = "air32-apple";
  }
  if ((*((_WORD *)this + 35) & 0x100) != 0) {
    long long v12 = "";
  }
  else {
    long long v12 = "";
  }
  if ((unint64_t)(v12 - v11) >= 0x21) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  std::string::size_type size = 0;
  if (v11 != v12)
  {
    memcpy(__str.__r_.__value_.__l.__data_, v11, v12 - v11);
    std::string::size_type size = __str.__r_.__value_.__l.__size_;
  }
  std::string::size_type v14 = size + v12 - v11;
  __str.__r_.__value_.__l.__size_ = v14;
  switch(*((unsigned __int16 *)this + 35) >> 9)
  {
    case 2:
    case 6:
    case 7:
      if (__str.__r_.__value_.__r.__words[2] < v14 + 4) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(_DWORD *)(__str.__r_.__value_.__r.__words[0] + v14) = 1936681261;
      uint64_t v15 = 4;
      break;
    case 3:
    case 8:
      if (__str.__r_.__value_.__r.__words[2] < v14 + 5) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      std::string::size_type v27 = __str.__r_.__value_.__r.__words[0] + v14;
      *(unsigned char *)(v27 + 4) = 115;
      int v28 = 1870033965;
      goto LABEL_66;
    case 4:
    case 9:
      if (__str.__r_.__value_.__r.__words[2] < v14 + 8) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *(void *)(__str.__r_.__value_.__r.__words[0] + v14) = 0x736F68637461772DLL;
      uint64_t v15 = 8;
      break;
    case 5:
    case 0xA:
      __break(1u);
      JUMPOUT(0x1CCC7198CLL);
    case 0xB:
    case 0xC:
      if (__str.__r_.__value_.__r.__words[2] < v14 + 5) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      std::string::size_type v27 = __str.__r_.__value_.__r.__words[0] + v14;
      *(unsigned char *)(v27 + 4) = 115;
      int v28 = 1869772845;
LABEL_66:
      *(_DWORD *)std::string::size_type v27 = v28;
      uint64_t v15 = 5;
      break;
    default:
      if (__str.__r_.__value_.__r.__words[2] < v14 + 7) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      uint64_t v29 = (_DWORD *)(__str.__r_.__value_.__r.__words[0] + v14);
      *(_DWORD *)((char *)v29 + 3) = 2020831075;
      _DWORD *v29 = 1667329325;
      uint64_t v15 = 7;
      break;
  }
  __str.__r_.__value_.__l.__size_ += v15;
  *(void *)&long long v45 = *((unsigned __int16 *)this + 36);
  std::string::size_type v46 = ".";
  WORD4(v47) = 776;
  llvm::Twine::str((llvm::Twine *)&v45, &__p);
  if (v58 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if (v58 >= 0) {
    size_t v31 = v58 & 0x7F;
  }
  else {
    size_t v31 = v57;
  }
  std::string::size_type v32 = __str.__r_.__value_.__l.__size_;
  if (__str.__r_.__value_.__r.__words[2] < __str.__r_.__value_.__l.__size_ + v31) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v31)
  {
    memcpy((void *)(__str.__r_.__value_.__r.__words[0] + __str.__r_.__value_.__l.__size_), p_p, v31);
    std::string::size_type v32 = __str.__r_.__value_.__l.__size_;
  }
  __str.__r_.__value_.__l.__size_ = v32 + v31;
  if (v58 < 0) {
    operator delete(__p);
  }
  *(void *)&long long v45 = *((unsigned __int8 *)this + 74);
  std::string::size_type v46 = ".";
  WORD4(v47) = 776;
  llvm::Twine::str((llvm::Twine *)&v45, &__p);
  if (v58 >= 0) {
    unint64_t v33 = &__p;
  }
  else {
    unint64_t v33 = __p;
  }
  if (v58 >= 0) {
    size_t v34 = v58 & 0x7F;
  }
  else {
    size_t v34 = v57;
  }
  std::string::size_type v35 = __str.__r_.__value_.__l.__size_;
  if (__str.__r_.__value_.__r.__words[2] < __str.__r_.__value_.__l.__size_ + v34) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v34)
  {
    memcpy((void *)(__str.__r_.__value_.__r.__words[0] + __str.__r_.__value_.__l.__size_), v33, v34);
    std::string::size_type v35 = __str.__r_.__value_.__l.__size_;
  }
  __str.__r_.__value_.__l.__size_ = v35 + v34;
  if (v58 < 0) {
    operator delete(__p);
  }
  int v36 = *((unsigned __int8 *)this + 75);
  WORD4(v47) = 264;
  LODWORD(v45) = v36;
  llvm::Twine::str((llvm::Twine *)&v45, &__p);
  if (v58 >= 0) {
    unint64_t v37 = &__p;
  }
  else {
    unint64_t v37 = __p;
  }
  if (v58 >= 0) {
    size_t v38 = v58 & 0x7F;
  }
  else {
    size_t v38 = v57;
  }
  std::string::size_type v39 = __str.__r_.__value_.__l.__size_;
  if (__str.__r_.__value_.__r.__words[2] < __str.__r_.__value_.__l.__size_ + v38) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v38)
  {
    memcpy((void *)(__str.__r_.__value_.__r.__words[0] + __str.__r_.__value_.__l.__size_), v37, v38);
    std::string::size_type v39 = __str.__r_.__value_.__l.__size_;
  }
  __str.__r_.__value_.__l.__size_ = v39 + v38;
  if (v58 < 0) {
    operator delete(__p);
  }
  int v40 = *((unsigned __int16 *)this + 35) >> 9;
  if ((v40 - 7) >= 3)
  {
    if (v40 == 6)
    {
      if (__str.__r_.__value_.__r.__words[2] < __str.__r_.__value_.__l.__size_ + 7) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      long long v43 = (_DWORD *)(__str.__r_.__value_.__r.__words[0] + __str.__r_.__value_.__l.__size_);
      *(_DWORD *)((char *)v43 + 3) = 1768055139;
      *long long v43 = 1667329325;
      std::string::size_type v42 = __str.__r_.__value_.__l.__size_ + 7;
      goto LABEL_109;
    }
    if (v40 != 12)
    {
      std::string::size_type v42 = __str.__r_.__value_.__l.__size_;
      goto LABEL_110;
    }
  }
  if (__str.__r_.__value_.__r.__words[2] < __str.__r_.__value_.__l.__size_ + 10) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  std::string::size_type v41 = __str.__r_.__value_.__r.__words[0] + __str.__r_.__value_.__l.__size_;
  *(void *)std::string::size_type v41 = *(void *)"-simulator";
  *(_WORD *)(v41 + ++*(_DWORD *)(this + 8) = 29295;
  std::string::size_type v42 = __str.__r_.__value_.__l.__size_ + 10;
LABEL_109:
  __str.__r_.__value_.__l.__size_ = v42;
LABEL_110:
  __int16 v60 = 261;
  std::string __p = (void *)__str.__r_.__value_.__r.__words[0];
  std::string::size_type v57 = v42;
  llvm::Triple::Triple((llvm::Triple *)&v45, (const llvm::Twine *)&__p);
  if (*((char *)this + 719) < 0) {
    operator delete(*(void **)v4);
  }
  *(_OWORD *)uint64_t v4 = v45;
  *((void *)v4 + 2) = v46;
  *(_OWORD *)uint64_t v5 = v47;
  *((void *)v5 + 2) = v48;
  if ((long long *)__str.__r_.__value_.__l.__data_ != &v62) {
    free(__str.__r_.__value_.__l.__data_);
  }
LABEL_2:
  if (*((char *)this + 719) < 0)
  {
    sub_1CB8BDF7C(a2, *((const void **)this + 87), *((void *)this + 88));
  }
  else
  {
    *(_OWORD *)a2 = *(_OWORD *)v4;
    *(void *)(a2 + ++*(_DWORD *)(this + 16) = *((void *)v4 + 2);
  }
  __n128 result = *(__n128 *)v5;
  *(_OWORD *)(a2 + 24) = *(_OWORD *)v5;
  *(void *)(a2 + 40) = *((void *)v5 + 2);
  return result;
}

char *llvm::object::MetalLibObjectFile::materializeModuleForFunctionNo@<X0>(llvm::object::MetalLibObjectFile *this@<X0>, unsigned int a2@<W1>, char *a3@<X8>)
{
  return sub_1CD6EA36C(a3, this, a2, (uint64_t *)this + 35, (uint64_t *)this + 75, (_DWORD **)this + 44, (_DWORD **)this + 47, (char **)this + 53, (uint64_t)this + 448);
}

char *llvm::object::MetalLibObjectFile::materializeModuleForVariableNo@<X0>(llvm::object::MetalLibObjectFile *this@<X0>, unsigned int a2@<W1>, char *a3@<X8>)
{
  return sub_1CD6EA720(a3, this, a2, (uint64_t *)this + 75, (uint64_t *)this + 35, (_DWORD **)this + 47, (_DWORD **)this + 44, (char **)this + 56, (uint64_t)this + 424);
}

llvm::object::MetalLibObjectFile *llvm::object::MetalLibObjectFile::getSymbolHash@<X0>(llvm::object::MetalLibObjectFile *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((void *)this + 35);
  uint64_t v5 = *((void *)this + 36) - v4;
  if (a2 < (unint64_t)(v5 >> 3))
  {
    uint64_t v6 = *(void *)(v4 + 8 * a2);
    if (!v6) {
      llvm::object::MetalLibObjectFile::materializeFunctionNo(this);
    }
    *(unsigned char *)(a3 + 16) &= ~1u;
    long long v7 = *(_OWORD *)(v6 + 32);
LABEL_7:
    *(_OWORD *)a3 = v7;
    return this;
  }
  uint64_t v8 = *((void *)this + 75);
  if (a2 < (unint64_t)((v5 >> 3) + ((*((void *)this + 76) - v8) >> 3)))
  {
    uint64_t v9 = *(void *)(v8 + 8 * (a2 - (v5 >> 3)));
    if (!v9) {
      llvm::object::MetalLibObjectFile::materializeVariableNo(this);
    }
    *(unsigned char *)(a3 + 16) &= ~1u;
    long long v7 = *(_OWORD *)(v9 + 24);
    goto LABEL_7;
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = 0;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = 0;
  return this;
}

llvm::object::MetalLibObjectFile *llvm::object::MetalLibObjectFile::getSymbolImplName@<X0>(llvm::object::MetalLibObjectFile *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((void *)this + 35);
  uint64_t v5 = *((void *)this + 36) - v4;
  if (a2 < (unint64_t)(v5 >> 3))
  {
    uint64_t v6 = *(void *)(v4 + 8 * a2);
    if (!v6) {
      llvm::object::MetalLibObjectFile::materializeFunctionNo(this);
    }
    *(unsigned char *)(a3 + 16) &= ~1u;
    long long v7 = *(_OWORD *)(v6 + 8);
LABEL_7:
    *(_OWORD *)a3 = v7;
    return this;
  }
  uint64_t v8 = *((void *)this + 75);
  if (a2 < (unint64_t)((v5 >> 3) + ((*((void *)this + 76) - v8) >> 3)))
  {
    uint64_t v9 = *(void *)(v8 + 8 * (a2 - (v5 >> 3)));
    if (!v9) {
      llvm::object::MetalLibObjectFile::materializeVariableNo(this);
    }
    *(unsigned char *)(a3 + 16) &= ~1u;
    long long v7 = *(_OWORD *)(v9 + 8);
    goto LABEL_7;
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = "";
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = 0;
  return this;
}

char *llvm::object::MetalLibObjectFile::getSymbolImplAddress@<X0>(char *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if ((*((_WORD *)this + 35) & 1) == 0)
  {
    uint64_t v4 = this;
    uint64_t v5 = a2;
    uint64_t v6 = (uint64_t *)(this + 280);
    uint64_t v7 = *((void *)this + 36) - *((void *)this + 35);
    if (a2 < (unint64_t)(v7 >> 3))
    {
      unsigned int v8 = *(_DWORD *)(*((void *)this + 44) + 4 * a2);
      if (v8 != -1)
      {
LABEL_4:
        uint64_t v9 = *(void *)(*((void *)v4 + 50) + 8 * v8);
LABEL_8:
        uint64_t v11 = *(void *)(v9 + 16) - *((void *)v4 + 2);
        char v12 = *(unsigned char *)(a3 + 8) & 0xFE;
LABEL_9:
        *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = v12;
        *(void *)a3 = v11;
        return this;
      }
      BOOL v13 = this + 352;
      this = sub_1CD6EA36C((char *)&v14, (llvm::object::MetalLibObjectFile *)this, a2, v6, (uint64_t *)this + 75, (_DWORD **)this + 44, (_DWORD **)this + 47, (char **)this + 53, (uint64_t)(this + 448));
      uint64_t v11 = v14;
      if (!v14)
      {
        unsigned int v8 = *(_DWORD *)(*v13 + 4 * v5);
        goto LABEL_4;
      }
LABEL_15:
      char v12 = *(unsigned char *)(a3 + 8) | 1;
      goto LABEL_9;
    }
    if (a2 < (unint64_t)((v7 >> 3) + ((uint64_t)(*((void *)this + 76) - *((void *)this + 75)) >> 3)))
    {
      unsigned int v10 = *(_DWORD *)(*((void *)this + 47) + 4 * (a2 - (v7 >> 3)));
      if (v10 == -1)
      {
        this = sub_1CD6EA720((char *)&v14, (llvm::object::MetalLibObjectFile *)this, a2 - ((unint64_t)v7 >> 3), (uint64_t *)this + 75, v6, (_DWORD **)this + 47, (_DWORD **)this + 44, (char **)this + 56, (uint64_t)(this + 424));
        uint64_t v11 = v14;
        if (v14) {
          goto LABEL_15;
        }
        unsigned int v10 = *(_DWORD *)(*((void *)v4 + 47) + 4
                                               * (v5 - ((uint64_t)(*((void *)v4 + 36) - *((void *)v4 + 35)) >> 3)));
      }
      uint64_t v9 = *(void *)(*((void *)v4 + 50) + 8 * v10);
      goto LABEL_8;
    }
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = 0;
  return this;
}

char *llvm::object::MetalLibObjectFile::getSymbolImplSize@<X0>(char *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if ((*((_WORD *)this + 35) & 1) == 0)
  {
    uint64_t v4 = this;
    uint64_t v5 = a2;
    uint64_t v6 = (uint64_t *)(this + 280);
    uint64_t v7 = *((void *)this + 36) - *((void *)this + 35);
    if (a2 < (unint64_t)(v7 >> 3))
    {
      unsigned int v8 = *(_DWORD *)(*((void *)this + 44) + 4 * a2);
      if (v8 != -1)
      {
LABEL_4:
        uint64_t v9 = *(void *)(*((void *)v4 + 50) + 8 * v8);
LABEL_8:
        uint64_t v11 = *(void *)(v9 + 24);
        char v12 = *(unsigned char *)(a3 + 8) & 0xFE;
LABEL_9:
        *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = v12;
        *(void *)a3 = v11;
        return this;
      }
      BOOL v13 = this + 352;
      this = sub_1CD6EA36C((char *)&v14, (llvm::object::MetalLibObjectFile *)this, a2, v6, (uint64_t *)this + 75, (_DWORD **)this + 44, (_DWORD **)this + 47, (char **)this + 53, (uint64_t)(this + 448));
      uint64_t v11 = v14;
      if (!v14)
      {
        unsigned int v8 = *(_DWORD *)(*v13 + 4 * v5);
        goto LABEL_4;
      }
LABEL_15:
      char v12 = *(unsigned char *)(a3 + 8) | 1;
      goto LABEL_9;
    }
    if (a2 < (unint64_t)((v7 >> 3) + ((uint64_t)(*((void *)this + 76) - *((void *)this + 75)) >> 3)))
    {
      unsigned int v10 = *(_DWORD *)(*((void *)this + 47) + 4 * (a2 - (v7 >> 3)));
      if (v10 == -1)
      {
        this = sub_1CD6EA720((char *)&v14, (llvm::object::MetalLibObjectFile *)this, a2 - ((unint64_t)v7 >> 3), (uint64_t *)this + 75, v6, (_DWORD **)this + 47, (_DWORD **)this + 44, (char **)this + 56, (uint64_t)(this + 424));
        uint64_t v11 = v14;
        if (v14) {
          goto LABEL_15;
        }
        unsigned int v10 = *(_DWORD *)(*((void *)v4 + 47) + 4
                                               * (v5 - ((uint64_t)(*((void *)v4 + 36) - *((void *)v4 + 35)) >> 3)));
      }
      uint64_t v9 = *(void *)(*((void *)v4 + 50) + 8 * v10);
      goto LABEL_8;
    }
  }
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = 0;
  return this;
}

uint64_t llvm::object::MetalLibObjectFile::getSymbolImplSection@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (*(_WORD *)(result + 70))
  {
    uint64_t v3 = 11;
  }
  else
  {
    uint64_t v3 = 11;
    if (((uint64_t)(*(void *)(result + 608) - *(void *)(result + 600)) >> 3)
       + ((uint64_t)(*(void *)(result + 288) - *(void *)(result + 280)) >> 3) > (unint64_t)a2)
      uint64_t v3 = 3;
  }
  *(unsigned char *)(a3 + 16) &= ~1u;
  *(void *)a3 = v3;
  *(void *)(a3 + ++*(_DWORD *)(this + 8) = result;
  return result;
}

uint64_t llvm::object::MetalLibObjectFile::dynamic_symbol_begin(llvm::object::MetalLibObjectFile *this)
{
  uint64_t v2 = 0x1FFFFFFFFLL;
  (*(void (**)(llvm::object::MetalLibObjectFile *, uint64_t *))(*(void *)this + 24))(this, &v2);
  return v2;
}

uint64_t llvm::object::MetalLibObjectFile::getSectionOffset(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 1:
      uint64_t v2 = a1 + 104;
      break;
    case 2:
      uint64_t v2 = a1 + 120;
      break;
    case 3:
      uint64_t v2 = a1 + 136;
      break;
    case 4:
      uint64_t v2 = a1 + 152;
      break;
    case 5:
      uint64_t v2 = a1 + 168;
      break;
    case 6:
      uint64_t v2 = a1 + 184;
      break;
    case 7:
      uint64_t v2 = a1 + 200;
      break;
    case 8:
      uint64_t v2 = a1 + 216;
      break;
    case 9:
      uint64_t v2 = a1 + 232;
      break;
    case 10:
      uint64_t v2 = a1 + 248;
      break;
    default:
      uint64_t v2 = a1 + 88;
      break;
  }
  return *(void *)v2;
}

void llvm::object::MetalLibObjectFile::getArchTriple(llvm::object::MetalLibObjectFile *this@<X0>, llvm::Triple *a2@<X8>)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  (*(void (**)(void **__return_ptr))(*(void *)this + 432))(__p);
  uint64_t AIRVersion = llvm::Triple::getAIRVersion((llvm::Triple *)__p);
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v23 = v25;
  qmemcpy(v25, "air", 3);
  long long v24 = xmmword_1CFB2C200;
  (*(void (**)(void **__return_ptr, llvm::object::MetalLibObjectFile *))(*(void *)this + 432))(__p, this);
  int v5 = sub_1CD0BDF24(v21);
  if (v5 == 32) {
    uint64_t v6 = "32_v";
  }
  else {
    uint64_t v6 = "64_v";
  }
  if (v5 == 32) {
    uint64_t v7 = "";
  }
  else {
    uint64_t v7 = "";
  }
  uint64_t v8 = v24;
  if (*((void *)&v24 + 1) < (unint64_t)(v7 - v6 + v24)) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v6 != v7)
  {
    memcpy((char *)v23 + v24, v6, v7 - v6);
    uint64_t v8 = v24;
  }
  *(void *)&long long v24 = v8 + v7 - v6;
  if (SHIBYTE(v20) < 0) {
    operator delete(__p[0]);
  }
  __int16 v22 = 264;
  LODWORD(__p[0]) = AIRVersion;
  llvm::Twine::str((llvm::Twine *)__p, &v16);
  if (v18 >= 0) {
    uint64_t v9 = &v16;
  }
  else {
    uint64_t v9 = v16;
  }
  if (v18 >= 0) {
    size_t v10 = v18 & 0x7F;
  }
  else {
    size_t v10 = v17;
  }
  uint64_t v11 = v24;
  if (*((void *)&v24 + 1) < (unint64_t)v24 + v10) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v10)
  {
    memcpy((char *)v23 + v24, v9, v10);
    uint64_t v11 = v24;
  }
  *(void *)&long long v24 = v11 + v10;
  if (v18 < 0) {
    operator delete(v16);
  }
  __int16 v22 = 264;
  LODWORD(__p[0]) = HIDWORD(AIRVersion) & (AIRVersion >> 63) & 0x7FFFFFFF;
  llvm::Twine::str((llvm::Twine *)__p, &v16);
  if (v18 >= 0) {
    char v12 = &v16;
  }
  else {
    char v12 = v16;
  }
  if (v18 >= 0) {
    size_t v13 = v18 & 0x7F;
  }
  else {
    size_t v13 = v17;
  }
  uint64_t v14 = v24;
  if (*((void *)&v24 + 1) < (unint64_t)v24 + v13) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  if (v13)
  {
    memcpy((char *)v23 + v24, v12, v13);
    uint64_t v14 = v24;
  }
  uint64_t v15 = (void *)(v14 + v13);
  *(void *)&long long v24 = v15;
  if (v18 < 0)
  {
    operator delete(v16);
    uint64_t v15 = (void *)v24;
  }
  __int16 v22 = 773;
  __p[0] = v23;
  __p[1] = v15;
  uint64_t v20 = "-apple-darwin";
  llvm::Triple::Triple(a2, (const llvm::Twine *)__p);
  if (v23 != v25) {
    free(v23);
  }
}

__n128 llvm::object::MetalLibObjectFile::functions@<Q0>(llvm::object::MetalLibObjectFile *this@<X0>, __n128 *a2@<X8>)
{
  if (!*((unsigned char *)this + 792))
  {
    unint64_t v3 = *((void *)this + 36) - *((void *)this + 35);
    if ((v3 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v4 = 0;
      do
      {
        if (!*(void *)(*((void *)this + 35) + 8 * v4)) {
          llvm::object::MetalLibObjectFile::materializeFunctionNo(this);
        }
        ++v4;
      }
      while ((v3 >> 3) != v4);
    }
    *((unsigned char *)this + 792) = 1;
  }
  a2[1].n128_u8[0] &= ~1u;
  __n128 result = *(__n128 *)((char *)this + 280);
  *a2 = result;
  return result;
}

__n128 llvm::object::MetalLibObjectFile::publicMetadata@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  if (!this[49].n128_u8[9])
  {
    unint64_t v3 = this[19].n128_u64[1] - this[19].n128_u64[0];
    if ((v3 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v4 = 0;
      do
      {
        if (!*(void *)(this[19].n128_u64[0] + 8 * v4)) {
          llvm::object::MetalLibObjectFile::materializePublicMetadataNo((llvm::object::MetalLibObjectFile *)this, v4);
        }
        ++v4;
      }
      while ((v3 >> 3) != v4);
    }
    this[49].n128_u8[9] = 1;
  }
  a2[1].n128_u8[0] &= ~1u;
  __n128 result = this[19];
  *a2 = result;
  return result;
}

void llvm::object::MetalLibObjectFile::materializePublicMetadataNo(llvm::object::MetalLibObjectFile *this, unsigned int a2)
{
  if (*(void *)(*((void *)this + 35) + 8 * a2)) {
    operator new();
  }
  llvm::object::MetalLibObjectFile::materializeFunctionNo(this);
}

__n128 llvm::object::MetalLibObjectFile::privateMetadata@<Q0>(llvm::object::MetalLibObjectFile *this@<X0>, __n128 *a2@<X8>)
{
  if (!*((unsigned char *)this + 794))
  {
    unint64_t v4 = *((void *)this + 36) - *((void *)this + 35);
    if ((v4 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v5 = 0;
      do
      {
        if (!*(void *)(*((void *)this + 41) + 8 * v5))
        {
          if (*(void *)(*((void *)this + 35) + 8 * v5)) {
            operator new();
          }
          llvm::object::MetalLibObjectFile::materializeFunctionNo(this);
        }
        ++v5;
      }
      while (v5 != (v4 >> 3));
    }
    unint64_t v6 = *((void *)this + 76) - *((void *)this + 75);
    if ((v6 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v7 = 0;
      do
      {
        if (!*(void *)(*((void *)this + 41) + 8 * (v7 + ((*((void *)this + 36) - *((void *)this + 35)) >> 3))))
        {
          if (*(void *)(*((void *)this + 75) + 8 * v7)) {
            operator new();
          }
          llvm::object::MetalLibObjectFile::materializeVariableNo(this);
        }
        ++v7;
      }
      while (v7 != (v6 >> 3));
    }
    *((unsigned char *)this + 794) = 1;
  }
  a2[1].n128_u8[0] &= ~1u;
  __n128 result = *(__n128 *)((char *)this + 328);
  *a2 = result;
  return result;
}

__n128 llvm::object::MetalLibObjectFile::modules@<Q0>(llvm::object::MetalLibObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  if (!*((unsigned char *)this + 795))
  {
    unint64_t v4 = *((void *)this + 45) - *((void *)this + 44);
    if ((v4 & 0x3FFFFFFFCLL) != 0)
    {
      uint64_t v5 = 0;
      uint64_t v6 = (v4 >> 2);
      do
      {
        if (*(_DWORD *)(*((void *)this + 44) + 4 * v5) == -1)
        {
          sub_1CD6EA36C((char *)&v12, this, v5, (uint64_t *)this + 35, (uint64_t *)this + 75, (_DWORD **)this + 44, (_DWORD **)this + 47, (char **)this + 53, (uint64_t)this + 448);
          uint64_t v8 = v12;
          if (v12) {
            goto LABEL_15;
          }
        }
      }
      while (v6 != ++v5);
    }
    unint64_t v9 = *((void *)this + 48) - *((void *)this + 47);
    if ((v9 & 0x3FFFFFFFCLL) != 0)
    {
      uint64_t v10 = 0;
      uint64_t v11 = (v9 >> 2);
      while (1)
      {
        if (*(_DWORD *)(*((void *)this + 47) + 4 * v10) == -1)
        {
          sub_1CD6EA720((char *)&v12, this, v10, (uint64_t *)this + 75, (uint64_t *)this + 35, (_DWORD **)this + 47, (_DWORD **)this + 44, (char **)this + 56, (uint64_t)this + 424);
          uint64_t v8 = v12;
          if (v12) {
            break;
          }
        }
        if (v11 == ++v10) {
          goto LABEL_16;
        }
      }
LABEL_15:
      *(unsigned char *)(a2 + 16) |= 1u;
      *(void *)a2 = v8;
      return result;
    }
LABEL_16:
    *((unsigned char *)this + 795) = 1;
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  __n128 result = *((__n128 *)this + 25);
  *(__n128 *)a2 = result;
  return result;
}

void llvm::object::MetalLibObjectFile::linkerCommandLine(llvm::object::MetalLibObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  if (*((void *)this + 61) || (llvm::object::MetalLibObjectFile::materializeSourcesHeader(this, &v5), (uint64_t v4 = v5) == 0))
  {
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(_OWORD *)a2 = *((_OWORD *)this + 30);
  }
  else
  {
    *(unsigned char *)(a2 + 16) |= 1u;
    *(void *)a2 = v4;
  }
}

void llvm::object::MetalLibObjectFile::materializeSourcesHeader(llvm::object::MetalLibObjectFile *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *((unsigned __int16 *)this + 34);
  v35[0] = (*((unsigned __int16 *)this + 32) >> 1) | ((unint64_t)*((unsigned __int16 *)this + 33) << 32) | 0x8000000000000000;
  v35[1] = v4 | 0x80000000;
  v36[0] = 0x8000000200000001;
  v36[1] = 2147483651;
  if ((sub_1CC156834(v35, v36) & 1) == 0)
  {
    unint64_t v5 = *((void *)this + 19);
    if (v5)
    {
      uint64_t v6 = *((void *)this + 2);
      unint64_t v7 = *((void *)this + 3);
      if (v7 >= v5) {
        uint64_t v8 = *((void *)this + 19);
      }
      else {
        uint64_t v8 = *((void *)this + 3);
      }
      unint64_t v9 = v6 + v7;
      unint64_t v10 = v6 + v8 + 4;
      if (v10 > v6 + v7) {
        operator new();
      }
      unint64_t v11 = *(unsigned int *)(v6 + v8);
      uint64_t v12 = v6 + v8 + 4;
      if (v10 >= v6 + v7)
      {
LABEL_13:
        if (*(unsigned char *)v12) {
          operator new();
        }
      }
      else
      {
        uint64_t v13 = v7 - v8 - 4;
        uint64_t v12 = v10;
        while (*(unsigned char *)v12)
        {
          ++v12;
          if (!--v13)
          {
            uint64_t v12 = v6 + v7;
            goto LABEL_13;
          }
        }
      }
      *((void *)this + 60) = v10;
      *((void *)this + 61) = v12 - v10;
      if (*((unsigned char *)this + 472))
      {
        uint64_t v14 = v12 + 1;
        uint64_t v15 = (unsigned char *)(v12 + 1);
        if (v12 + 1 >= v9)
        {
LABEL_21:
          if (*v15) {
            operator new();
          }
        }
        else
        {
          uint64_t v16 = ~v12 + v7 + v6;
          uint64_t v15 = (unsigned char *)(v12 + 1);
          while (*v15)
          {
            ++v15;
            if (!--v16)
            {
              uint64_t v15 = (unsigned char *)v9;
              goto LABEL_21;
            }
          }
        }
        *((void *)this + 62) = v14;
        *((void *)this + 63) = &v15[-v14];
      }
      size_t v17 = (char *)*((void *)this + 65);
      char v18 = (char *)*((void *)this + 64);
      unint64_t v19 = (v17 - v18) >> 3;
      if (v11 <= v19)
      {
        if (v11 < v19)
        {
          std::string::size_type v32 = &v18[8 * v11];
          while (v17 != v32)
          {
            uint64_t v34 = *((void *)v17 - 1);
            v17 -= 8;
            uint64_t v33 = v34;
            *(void *)size_t v17 = 0;
            if (v34) {
              MEMORY[0x1D25D9CE0](v33, 0x1050C40A8B26598);
            }
          }
          *((void *)this + 65) = v32;
        }
      }
      else
      {
        unint64_t v20 = v11 - v19;
        uint64_t v21 = *((void *)this + 66);
        if (v11 - v19 <= (v21 - (uint64_t)v17) >> 3)
        {
          bzero(*((void **)this + 65), 8 * v20);
          *((void *)this + 65) = &v17[8 * v20];
        }
        else
        {
          uint64_t v22 = v21 - (void)v18;
          if (v22 >> 2 > v11) {
            unint64_t v11 = v22 >> 2;
          }
          if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v23 = v11;
          }
          if (v23 >> 61) {
            sub_1CB833614();
          }
          long long v24 = (char *)operator new(8 * v23);
          BOOL v25 = &v24[8 * v19];
          uint64_t v26 = &v24[8 * v23];
          bzero(v25, 8 * v20);
          std::string::size_type v27 = &v24[8 * v20 + v17 - v18];
          if (v17 == v18)
          {
            *((void *)this + 64) = v25;
            *((void *)this + 65) = v27;
            *((void *)this + 66) = v26;
          }
          else
          {
            do
            {
              uint64_t v28 = *((void *)v17 - 1);
              v17 -= 8;
              *(void *)size_t v17 = 0;
              *((void *)v25 - 1) = v28;
              v25 -= 8;
            }
            while (v17 != v18);
            size_t v17 = (char *)*((void *)this + 64);
            uint64_t v29 = (char *)*((void *)this + 65);
            *((void *)this + 64) = v25;
            *((void *)this + 65) = v27;
            *((void *)this + 66) = v26;
            while (v29 != v17)
            {
              uint64_t v31 = *((void *)v29 - 1);
              v29 -= 8;
              uint64_t v30 = v31;
              *(void *)uint64_t v29 = 0;
              if (v31) {
                MEMORY[0x1D25D9CE0](v30, 0x1050C40A8B26598);
              }
            }
          }
          if (v17) {
            operator delete(v17);
          }
        }
      }
    }
  }
  *a2 = 0;
}

void llvm::object::MetalLibObjectFile::linkerWorkingDir(llvm::object::MetalLibObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  if (*((void *)this + 63) || (llvm::object::MetalLibObjectFile::materializeSourcesHeader(this, &v5), (uint64_t v4 = v5) == 0))
  {
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(_OWORD *)a2 = *((_OWORD *)this + 31);
  }
  else
  {
    *(unsigned char *)(a2 + 16) |= 1u;
    *(void *)a2 = v4;
  }
}

__n128 llvm::object::MetalLibObjectFile::sources@<Q0>(llvm::object::MetalLibObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  if (!*((unsigned char *)this + 796))
  {
    if (!*((void *)this + 61) || !*((void *)this + 63))
    {
      llvm::object::MetalLibObjectFile::materializeSourcesHeader(this, &v8);
      uint64_t v5 = v8;
      if (v8)
      {
        *(unsigned char *)(a2 + 16) |= 1u;
        *(void *)a2 = v5;
        return result;
      }
    }
    unint64_t v6 = *((void *)this + 65) - *((void *)this + 64);
    if ((v6 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v7 = 0;
      do
      {
        if (!*(void *)(*((void *)this + 64) + 8 * v7)) {
          llvm::object::MetalLibObjectFile::materializeSourceNo(this);
        }
        ++v7;
      }
      while ((v6 >> 3) != v7);
    }
    *((unsigned char *)this + 796) = 1;
  }
  *(unsigned char *)(a2 + 16) &= ~1u;
  __n128 result = *((__n128 *)this + 32);
  *(__n128 *)a2 = result;
  return result;
}

void llvm::object::MetalLibObjectFile::materializeSourceNo(llvm::object::MetalLibObjectFile *this)
{
}

uint64_t llvm::object::MetalLibObjectFile::materializeDynamicHeader@<X0>(llvm::object::MetalLibObjectFile *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *((unsigned __int16 *)this + 34);
  v19[0] = (*((unsigned __int16 *)this + 32) >> 1) | ((unint64_t)*((unsigned __int16 *)this + 33) << 32) | 0x8000000000000000;
  v19[1] = v4 | 0x80000000;
  v20[0] = 0x8000000200000001;
  v20[1] = 2147483652;
  uint64_t result = sub_1CC156834(v19, v20);
  if ((result & 1) == 0)
  {
    unint64_t v6 = *((void *)this + 23);
    if (v6)
    {
      uint64_t v7 = *((void *)this + 2);
      unint64_t v8 = *((void *)this + 3);
      if (v8 < v6) {
        unint64_t v6 = *((void *)this + 3);
      }
      unint64_t v9 = (_DWORD *)(v7 + v6);
      unint64_t v10 = v7 + v8;
      unint64_t v11 = (unsigned __int16 *)(v7 + v6 + 4);
      *((_OWORD *)this + 35) = 0u;
      if ((unint64_t)v11 > v7 + v8) {
LABEL_6:
      }
        operator new();
      while (1)
      {
        switch(*v9)
        {
          case 0x454D414E:
            uint64_t v13 = (char *)v9 + 6;
            if ((unint64_t)v9 + 6 > v10) {
              operator new();
            }
            uint64_t v14 = *v11;
            unint64_t v12 = (unint64_t)&v13[v14];
            if ((unint64_t)&v13[v14] > v10) {
              goto LABEL_27;
            }
            unint64_t v15 = v14 - 1;
            do
            {
              unint64_t v16 = v14 - 1;
              if (v14 == 1) {
                break;
              }
            }
            while (!*((unsigned __int8 *)v9 + v14-- + 4));
            uint64_t v18 = v16 >= v15 ? v15 : v16;
            *((void *)this + 70) = v13;
            *((void *)this + 71) = v18;
            if (v13[v15]) {
LABEL_27:
            }
              operator new();
            break;
          case 0x4C4E5944:
            operator new();
          case 0x54444E45:
            goto LABEL_26;
          default:
            if ((unint64_t)v9 + 6 > v10) {
              operator new();
            }
            unint64_t v12 = (unint64_t)v9 + *v11 + 6;
            if (v12 > v10) {
              operator new();
            }
            break;
        }
        unint64_t v11 = (unsigned __int16 *)(v12 + 4);
        unint64_t v9 = (_DWORD *)v12;
        if (v12 + 4 > v10) {
          goto LABEL_6;
        }
      }
    }
  }
LABEL_26:
  *a2 = 0;
  return result;
}

void *llvm::object::MetalLibObjectFile::linkers@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = this[67];
  uint64_t v4 = this[68];
  if (v3 != v4) {
    goto LABEL_2;
  }
  uint64_t v5 = this;
  this = (void *)llvm::object::MetalLibObjectFile::materializePackingHeader((llvm::object::MetalLibObjectFile *)this, &v7);
  uint64_t v6 = v7;
  if (!v7)
  {
    uint64_t v3 = v5[67];
    uint64_t v4 = v5[68];
LABEL_2:
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = v3;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = v4;
    return this;
  }
  *(unsigned char *)(a2 + 16) |= 1u;
  *(void *)a2 = v6;
  return this;
}

uint64_t llvm::object::MetalLibObjectFile::materializePackingHeader@<X0>(llvm::object::MetalLibObjectFile *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = *((unsigned __int16 *)this + 34);
  v12[0] = (*((unsigned __int16 *)this + 32) >> 1) | ((unint64_t)*((unsigned __int16 *)this + 33) << 32) | 0x8000000000000000;
  v12[1] = v4 | 0x80000000;
  v13[0] = 0x8000000200000001;
  v13[1] = 2147483656;
  uint64_t result = sub_1CC156834(v12, v13);
  if ((result & 1) == 0)
  {
    unint64_t v6 = *((void *)this + 21);
    if (v6)
    {
      uint64_t v7 = *((void *)this + 2);
      unint64_t v8 = *((void *)this + 3);
      if (v8 < v6) {
        unint64_t v6 = *((void *)this + 3);
      }
      unint64_t v9 = (_DWORD *)(v7 + v6);
      unint64_t v10 = v7 + v8;
      unint64_t v11 = (unsigned __int16 *)(v7 + v6 + 4);
      if ((unint64_t)v11 > v7 + v8) {
LABEL_6:
      }
        operator new();
      while (1)
      {
        if (*v9 == 1263421772) {
          operator new();
        }
        if (*v9 == 1413762629) {
          break;
        }
        if ((unint64_t)v9 + 6 > v10) {
          operator new();
        }
        unint64_t v9 = (_DWORD *)((char *)v9 + *v11 + 6);
        if ((unint64_t)v9 > v10) {
          operator new();
        }
        unint64_t v11 = (unsigned __int16 *)(v9 + 1);
        if ((unint64_t)(v9 + 1) > v10) {
          goto LABEL_6;
        }
      }
    }
  }
  *a2 = 0;
  return result;
}

void *llvm::object::MetalLibObjectFile::dynamicLibraries@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = this[72];
  uint64_t v4 = this[73];
  if (v3 != v4) {
    goto LABEL_2;
  }
  uint64_t v5 = this;
  this = (void *)llvm::object::MetalLibObjectFile::materializeDynamicHeader((llvm::object::MetalLibObjectFile *)this, &v7);
  uint64_t v6 = v7;
  if (!v7)
  {
    uint64_t v3 = v5[72];
    uint64_t v4 = v5[73];
LABEL_2:
    *(unsigned char *)(a2 + 16) &= ~1u;
    *(void *)a2 = v3;
    *(void *)(a2 + ++*(_DWORD *)(this + 8) = v4;
    return this;
  }
  *(unsigned char *)(a2 + 16) |= 1u;
  *(void *)a2 = v6;
  return this;
}

__n128 llvm::object::MetalLibObjectFile::variables@<Q0>(llvm::object::MetalLibObjectFile *this@<X0>, __n128 *a2@<X8>)
{
  if (!*((unsigned char *)this + 797))
  {
    unint64_t v3 = *((void *)this + 76) - *((void *)this + 75);
    if ((v3 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v4 = 0;
      do
      {
        if (!*(void *)(*((void *)this + 75) + 8 * v4)) {
          llvm::object::MetalLibObjectFile::materializeVariableNo(this);
        }
        ++v4;
      }
      while ((v3 >> 3) != v4);
    }
    *((unsigned char *)this + 797) = 1;
  }
  a2[1].n128_u8[0] &= ~1u;
  __n128 result = *(__n128 *)((char *)this + 600);
  *a2 = result;
  return result;
}

__n128 llvm::object::MetalLibObjectFile::importedSymbols@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  if (!this[49].n128_u8[14])
  {
    unint64_t v3 = this[39].n128_u64[1] - this[39].n128_u64[0];
    if ((v3 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v4 = 0;
      do
      {
        if (!*(void *)(this[39].n128_u64[0] + 8 * v4)) {
          llvm::object::MetalLibObjectFile::materializeImportedSymbolNo((llvm::object::MetalLibObjectFile *)this);
        }
        ++v4;
      }
      while ((v3 >> 3) != v4);
    }
    this[49].n128_u8[14] = 1;
  }
  a2[1].n128_u8[0] &= ~1u;
  __n128 result = this[39];
  *a2 = result;
  return result;
}

__n128 llvm::object::MetalLibObjectFile::reflections@<Q0>(llvm::object::MetalLibObjectFile *this@<X0>, __n128 *a2@<X8>)
{
  if (!*((unsigned char *)this + 799))
  {
    unint64_t v3 = *((void *)this + 82) - *((void *)this + 81);
    if ((v3 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v4 = 0;
      do
      {
        if (!*(void *)(*((void *)this + 81) + 8 * v4)) {
          llvm::object::MetalLibObjectFile::materializeReflectionNo(this);
        }
        ++v4;
      }
      while ((v3 >> 3) != v4);
    }
    *((unsigned char *)this + 799) = 1;
  }
  a2[1].n128_u8[0] &= ~1u;
  __n128 result = *(__n128 *)((char *)this + 648);
  *a2 = result;
  return result;
}

void llvm::object::MetalLibObjectFile::materializeReflectionNo(llvm::object::MetalLibObjectFile *this)
{
}

__n128 llvm::object::MetalLibObjectFile::scripts@<Q0>(__n128 *this@<X0>, __n128 *a2@<X8>)
{
  if (!this[50].n128_u8[0])
  {
    unint64_t v3 = this[42].n128_u64[1] - this[42].n128_u64[0];
    if ((v3 & 0x7FFFFFFF8) != 0)
    {
      uint64_t v4 = 0;
      do
      {
        if (!*(void *)(this[42].n128_u64[0] + 8 * v4)) {
          llvm::object::MetalLibObjectFile::materializeScriptNo((llvm::object::MetalLibObjectFile *)this);
        }
        ++v4;
      }
      while ((v3 >> 3) != v4);
    }
    this[50].n128_u8[0] = 1;
  }
  a2[1].n128_u8[0] &= ~1u;
  __n128 result = this[42];
  *a2 = result;
  return result;
}

void llvm::object::MetalLibObjectFile::materializeScriptNo(llvm::object::MetalLibObjectFile *this)
{
}

void llvm::object::MetalLibObjectFile::functionWithName(llvm::object::MetalLibObjectFile *a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::functions(a1, &v14);
  unint64_t v7 = v14.n128_u64[0];
  if (v15)
  {
    char v13 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    unint64_t v8 = v14.n128_u64[1];
    if (v14.n128_u64[0] == v14.n128_u64[1]) {
LABEL_12:
    }
      operator new();
    while (1)
    {
      uint64_t v9 = *(void *)v7 + 104;
      uint64_t v10 = *(void *)(*(void *)v7 + 112);
      BOOL v11 = v10 == 0;
      uint64_t v12 = v10 ? 104 : 8;
      if (v11) {
        uint64_t v9 = *(void *)v7 + 8;
      }
      if (*(void *)(v9 + 8) == a3 && (!a3 || !memcmp(*(const void **)(*(void *)v7 + v12), a2, a3))) {
        break;
      }
      v7 += 8;
      if (v7 == v8) {
        goto LABEL_12;
      }
    }
    char v13 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v13;
  *(void *)a4 = v7;
}

void llvm::object::MetalLibObjectFile::variableWithName(llvm::object::MetalLibObjectFile *a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::variables(a1, &v14);
  unint64_t v7 = v14.n128_u64[0];
  if (v15)
  {
    char v13 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    unint64_t v8 = v14.n128_u64[1];
    if (v14.n128_u64[0] == v14.n128_u64[1]) {
LABEL_12:
    }
      operator new();
    while (1)
    {
      uint64_t v9 = *(void *)v7 + 88;
      uint64_t v10 = *(void *)(*(void *)v7 + 96);
      BOOL v11 = v10 == 0;
      uint64_t v12 = v10 ? 88 : 8;
      if (v11) {
        uint64_t v9 = *(void *)v7 + 8;
      }
      if (*(void *)(v9 + 8) == a3 && (!a3 || !memcmp(*(const void **)(*(void *)v7 + v12), a2, a3))) {
        break;
      }
      v7 += 8;
      if (v7 == v8) {
        goto LABEL_12;
      }
    }
    char v13 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v13;
  *(void *)a4 = v7;
}

void llvm::object::MetalLibObjectFile::functionWithHash(llvm::object::MetalLibObjectFile *a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::functions(a1, &v10);
  unint64_t v7 = v10.n128_u64[0];
  if (v11)
  {
    char v9 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    unint64_t v8 = v10.n128_u64[1];
    while (1)
    {
      if (v7 == v8) {
        operator new();
      }
      if (*(void *)(*(void *)v7 + 40) == a3 && !memcmp(*(const void **)(*(void *)v7 + 32), a2, a3)) {
        break;
      }
      v7 += 8;
    }
    char v9 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v9;
  *(void *)a4 = v7;
}

void llvm::object::MetalLibObjectFile::variableWithHash(llvm::object::MetalLibObjectFile *a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::variables(a1, &v10);
  unint64_t v7 = v10.n128_u64[0];
  if (v11)
  {
    char v9 = *(unsigned char *)(a4 + 8) | 1;
  }
  else
  {
    unint64_t v8 = v10.n128_u64[1];
    while (1)
    {
      if (v7 == v8) {
        operator new();
      }
      if (*(void *)(*(void *)v7 + 32) == a3 && !memcmp(*(const void **)(*(void *)v7 + 24), a2, a3)) {
        break;
      }
      v7 += 8;
    }
    char v9 = *(unsigned char *)(a4 + 8) & 0xFE;
  }
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v9;
  *(void *)a4 = v7;
}

void llvm::object::MetalLibObjectFile::moduleWithHash(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::functions((llvm::object::MetalLibObjectFile *)a1, &v23);
  unint64_t v8 = v23.n128_u64[0];
  if (v24) {
    goto LABEL_21;
  }
  unint64_t v9 = v23.n128_u64[1];
  if (v23.n128_u64[0] == v23.n128_u64[1]) {
    goto LABEL_14;
  }
  unint64_t v10 = -v23.n128_u64[0];
  while (*(void *)(*(void *)v8 + 40) != a3 || memcmp(*(const void **)(*(void *)v8 + 32), a2, a3))
  {
    v8 += 8;
    v10 -= 8;
    if (v8 == v9) {
      goto LABEL_14;
    }
  }
  if (*(_WORD *)(a1 + 70)) {
    goto LABEL_14;
  }
  uint64_t v11 = -(uint64_t)v10 - *(void *)(a1 + 280);
  unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 352) + (v11 >> 1));
  if (v12 == -1)
  {
    sub_1CD6EA36C(v20, (llvm::object::MetalLibObjectFile *)a1, (unint64_t)v11 >> 3, (uint64_t *)(a1 + 280), (uint64_t *)(a1 + 600), (_DWORD **)(a1 + 352), (_DWORD **)(a1 + 376), (char **)(a1 + 424), a1 + 448);
    if (*(void *)v20)
    {
      (*(void (**)(void))(**(void **)v20 + 8))(*(void *)v20);
      goto LABEL_14;
    }
    unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 352) + 4 * (v11 >> 3));
  }
  uint64_t v13 = *(void *)(a1 + 400) + 8 * v12;
  if (v13 != *(void *)(a1 + 408))
  {
    *(unsigned char *)(a4 + 8) &= ~1u;
    *(void *)a4 = v13;
    return;
  }
LABEL_14:
  llvm::object::MetalLibObjectFile::variables((llvm::object::MetalLibObjectFile *)a1, &v21);
  unint64_t v8 = v21.n128_u64[0];
  if (v22)
  {
LABEL_21:
    *(unsigned char *)(a4 + 8) |= 1u;
    *(void *)a4 = v8;
    return;
  }
  unint64_t v14 = v21.n128_u64[1];
  if (v21.n128_u64[0] == v21.n128_u64[1]) {
    goto LABEL_20;
  }
  unint64_t v15 = -v21.n128_u64[0];
  while (*(void *)(*(void *)v8 + 32) != a3 || memcmp(*(const void **)(*(void *)v8 + 24), a2, a3))
  {
    v8 += 8;
    v15 -= 8;
    if (v8 == v14) {
      goto LABEL_20;
    }
  }
  if (*(_WORD *)(a1 + 70))
  {
    uint64_t v18 = *(void *)(a1 + 408);
  }
  else
  {
    uint64_t v16 = -(uint64_t)v15 - *(void *)(a1 + 600);
    unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 376) + (v16 >> 1));
    if (v17 == -1)
    {
      sub_1CD6EA720(v20, (llvm::object::MetalLibObjectFile *)a1, (unint64_t)v16 >> 3, (uint64_t *)(a1 + 600), (uint64_t *)(a1 + 280), (_DWORD **)(a1 + 376), (_DWORD **)(a1 + 352), (char **)(a1 + 448), a1 + 424);
      uint64_t v19 = *(void *)v20;
      if (*(void *)v20)
      {
        *(unsigned char *)(a4 + 8) |= 1u;
        *(void *)a4 = 0;
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        goto LABEL_20;
      }
      unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 376) + 4 * (v16 >> 3));
    }
    uint64_t v18 = *(void *)(a1 + 400) + 8 * v17;
  }
  *(unsigned char *)(a4 + 8) &= ~1u;
  *(void *)a4 = v18;
  if (v18 == *(void *)(a1 + 408)) {
LABEL_20:
  }
    operator new();
}

void llvm::object::MetalLibObjectFile::privateMetadataWithOffset(llvm::object::MetalLibObjectFile *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::privateMetadata(this, &v10);
  uint64_t v5 = (unsigned int **)v10.n128_u64[0];
  if (v11)
  {
    char v9 = *(unsigned char *)(a3 + 8) | 1;
  }
  else
  {
    if (a2 && v10.n128_u64[0] != v10.n128_u64[1])
    {
      uint64_t v6 = 0;
      do
      {
        unint64_t v7 = *v5++;
        v6 += *v7;
      }
      while (v6 != a2 && v5 != (unsigned int **)v10.n128_u64[1]);
    }
    if (v5 == (unsigned int **)v10.n128_u64[1]) {
      operator new();
    }
    char v9 = *(unsigned char *)(a3 + 8) & 0xFE;
  }
  *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = v9;
  *(void *)a3 = v5;
}

void llvm::object::MetalLibObjectFile::scriptWithOffset(__n128 *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::scripts(this, &v10);
  uint64_t v5 = (unsigned int **)v10.n128_u64[0];
  if (v11)
  {
    char v9 = *(unsigned char *)(a3 + 8) | 1;
  }
  else
  {
    if (a2 != 4 && v10.n128_u64[0] != v10.n128_u64[1])
    {
      uint64_t v6 = 4;
      do
      {
        unint64_t v7 = *v5++;
        v6 += *v7;
      }
      while (v6 != a2 && v5 != (unsigned int **)v10.n128_u64[1]);
    }
    if (v5 == (unsigned int **)v10.n128_u64[1]) {
      operator new();
    }
    char v9 = *(unsigned char *)(a3 + 8) & 0xFE;
  }
  *(unsigned char *)(a3 + ++*(_DWORD *)(this + 8) = v9;
  *(void *)a3 = v5;
}

void llvm::object::MetalLibObjectFile::sourceWithOffset(llvm::object::MetalLibObjectFile *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::sourceWithOffset(this, a2, (uint64_t)this + 1064, (uint64_t)&v11);
  if ((v12 & 1) == 0)
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    uint64_t v6 = v11;
LABEL_3:
    *(void *)a3 = v6;
    return;
  }
  unint64_t v8 = v11;
  sub_1CD4515D0(&v8);
  if (v8) {
    (*(void (**)(void *))(*v8 + 8))(v8);
  }
  llvm::object::MetalLibObjectFile::sourceWithOffset(this, a2, (uint64_t)this + 1128, (uint64_t)&v9);
  if ((v10 & 1) == 0)
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    uint64_t v6 = v9;
    goto LABEL_3;
  }
  unint64_t v7 = v9;
  sub_1CD4515D0(&v7);
  if (v7) {
    (*(void (**)(void *))(*v7 + 8))(v7);
  }
  llvm::object::MetalLibObjectFile::sourceWithOffset(this, a2, 0, a3);
}

void llvm::object::MetalLibObjectFile::sourceWithOffset(llvm::object::MetalLibObjectFile *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8 = *((void *)this + 61);
  if (!v8 || (uint64_t v9 = *((void *)this + 63)) == 0)
  {
    llvm::object::MetalLibObjectFile::materializeSourcesHeader(this, v44);
    uint64_t v10 = v44[0];
    if (v44[0])
    {
      char v11 = *(unsigned char *)(a4 + 8) | 1;
      goto LABEL_5;
    }
    uint64_t v8 = *((void *)this + 61);
    uint64_t v9 = *((void *)this + 63);
  }
  uint64_t v12 = *((void *)this + 2);
  unint64_t v13 = *((void *)this + 3);
  unint64_t v14 = *((void *)this + 19);
  if (v13 < v14) {
    unint64_t v14 = *((void *)this + 3);
  }
  uint64_t v15 = v12 + v14;
  uint64_t v16 = (_DWORD *)(v15 + v8 + *((unsigned __int8 *)this + 472) + *((unsigned __int8 *)this + 472) * v9 + 5);
  uint64_t v17 = *((void *)this + 64);
  unint64_t v18 = (unint64_t)(*((void *)this + 65) - v17) >> 3;
  if (a3)
  {
    uint64_t v19 = 0;
    unsigned int v20 = 0;
    __n128 v21 = (void *)(a3 + 64);
    uint64_t v22 = 4;
    uint64_t v23 = a3;
    uint64_t v24 = 4;
    do
    {
      unsigned int v25 = *(_DWORD *)(v23 + 12);
      if (v25)
      {
        if (*(void *)v23 == a2)
        {
          uint64_t v24 = v19;
        }
        else if (*(void *)v23 < a2 && (v22 == 4 || *v21 < *(void *)v23))
        {
          uint64_t v22 = v19;
        }
        if (v20 <= v25) {
          unsigned int v20 = *(_DWORD *)(v23 + 12);
        }
      }
      ++v19;
      __n128 v21 = (void *)(a3 + 16 * v22);
      v23 += 16;
    }
    while (v19 != 4);
    if (v24 == 4)
    {
      int v26 = 0;
      uint64_t v24 = v22;
    }
    else
    {
      BOOL v27 = __CFADD__(v20, 1);
      int v28 = v20 + 1;
      if (v27)
      {
        for (uint64_t i = 0; i != 64; i += 16)
          *(_DWORD *)(a3 + 12 + i) = *(_DWORD *)(a3 + 12 + i) != 0;
        int v28 = 2;
      }
      *(_DWORD *)(a3 + 16 * v24 + 12) = v28;
      int v26 = 1;
    }
    if (v24 != 4)
    {
      uint64_t v31 = a3 + 16 * v24;
      uint64_t v16 = (_DWORD *)(v15 + *(void *)v31 - 4);
      unsigned int v30 = *(_DWORD *)(v31 + 8);
      goto LABEL_33;
    }
  }
  else
  {
    int v26 = 0;
  }
  unsigned int v30 = 0;
LABEL_33:
  if (v30 == v18) {
LABEL_34:
  }
    operator new();
  unint64_t v32 = v12 + v13;
  while (1)
  {
    unint64_t v33 = (unint64_t)v16 - v15 + 4;
    if (v33 == a2) {
      break;
    }
    if (v33 <= a2)
    {
      if ((unint64_t)(v16 + 1) > v32) {
        operator new();
      }
      uint64_t v16 = (_DWORD *)((char *)v16 + (*v16 + 4));
      if (v18 != ++v30) {
        continue;
      }
    }
    goto LABEL_34;
  }
  if (a3 && !v26)
  {
    uint64_t v34 = 0;
    unsigned int v35 = 0;
    uint64_t v36 = 4;
    uint64_t v37 = a3;
    uint64_t v38 = 4;
    uint64_t v39 = 4;
    do
    {
      unsigned int v40 = *(_DWORD *)(v37 + 12);
      if (v40)
      {
        if (*(void *)v37 == a2)
        {
          uint64_t v39 = v34;
        }
        else if (v36 == 4 || *(_DWORD *)(a3 + 16 * v36 + 12) > v40)
        {
          uint64_t v36 = v34;
        }
        if (v35 <= v40) {
          unsigned int v35 = *(_DWORD *)(v37 + 12);
        }
      }
      else
      {
        uint64_t v38 = v34;
      }
      ++v34;
      v37 += 16;
    }
    while (v34 != 4);
    BOOL v27 = __CFADD__(v35, 1);
    int v41 = v35 + 1;
    if (v27)
    {
      for (uint64_t j = 0; j != 64; j += 16)
        *(_DWORD *)(a3 + 12 + j) = *(_DWORD *)(a3 + 12 + j) != 0;
      int v41 = 2;
    }
    if (v38 != 4) {
      uint64_t v36 = v38;
    }
    if (v39 != 4) {
      uint64_t v36 = v39;
    }
    uint64_t v43 = a3 + 16 * v36;
    *(void *)uint64_t v43 = a2;
    *(_DWORD *)(v43 + ++*(_DWORD *)(this + 8) = v30;
    *(_DWORD *)(v43 + 12) = v41;
  }
  if (!*(void *)(v17 + 8 * v30)) {
    llvm::object::MetalLibObjectFile::materializeSourceNo(this);
  }
  uint64_t v10 = v17 + 8 * v30;
  char v11 = *(unsigned char *)(a4 + 8) & 0xFE;
LABEL_5:
  *(unsigned char *)(a4 + ++*(_DWORD *)(this + 8) = v11;
  *(void *)a4 = v10;
}

void llvm::object::MetalLibObjectFile::sourceOfFunction(llvm::object::MetalLibObjectFile *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *(void *)(*(void *)a2 + 96);
  if (v3)
  {
    llvm::object::MetalLibObjectFile::sourceWithOffset(a1, v3, (uint64_t)a1 + 1064, a3);
  }
  else
  {
    uint64_t v4 = *((void *)a1 + 65);
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v4;
  }
}

void llvm::object::MetalLibObjectFile::sourceOfVariable(llvm::object::MetalLibObjectFile *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = *(void *)(*(void *)a2 + 80);
  if (v3)
  {
    llvm::object::MetalLibObjectFile::sourceWithOffset(a1, v3, (uint64_t)a1 + 1128, a3);
  }
  else
  {
    uint64_t v4 = *((void *)a1 + 65);
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v4;
  }
}

void *llvm::object::MetalLibObjectFile::functionOfModule@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(unsigned int *)(result[53] + ((a2 - result[50]) >> 1));
  if (v4 == -1) {
    operator new();
  }
  uint64_t v5 = result[35] + 8 * v4;
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = v5;
  return result;
}

void *llvm::object::MetalLibObjectFile::variableOfModule@<X0>(void *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(unsigned int *)(result[56] + ((a2 - result[50]) >> 1));
  if (v4 == -1) {
    operator new();
  }
  uint64_t v5 = result[75] + 8 * v4;
  *(unsigned char *)(a3 + 8) &= ~1u;
  *(void *)a3 = v5;
  return result;
}

void *llvm::object::MetalLibObjectFile::hashOfModule@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  __n128 result = llvm::object::MetalLibObjectFile::functionOfModule(a1, a2, (uint64_t)&v11);
  if (v12)
  {
    llvm::object::MetalLibObjectFile::variableOfModule(a1, a2, (uint64_t)&v9);
    if (v10) {
      operator new();
    }
    uint64_t v8 = *v9;
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(_OWORD *)a3 = *(_OWORD *)(v8 + 24);
    __n128 result = v11;
    if (v11) {
      return (void *)(*(uint64_t (**)(void *))(*v11 + 8))(v11);
    }
  }
  else
  {
    uint64_t v7 = *v11;
    *(unsigned char *)(a3 + 16) &= ~1u;
    *(_OWORD *)a3 = *(_OWORD *)(v7 + 32);
  }
  return result;
}

void llvm::object::MetalLibObjectFile::referencesExternalResources(llvm::object::MetalLibObjectFile *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  llvm::object::MetalLibObjectFile::functions(this, &v18);
  unint64_t v4 = v18.n128_u64[0];
  if (v19)
  {
    *(unsigned char *)(a2 + 8) |= 1u;
    *(void *)a2 = v4;
  }
  else
  {
    unint64_t v5 = v18.n128_u64[1];
    while (v4 != v5)
    {
      uint64_t v6 = *(void *)v4;
      if (*(void *)(*(void *)v4 + 128)) {
        goto LABEL_26;
      }
      if (*(unsigned char *)(v6 + 200))
      {
        if (*(void *)(v6 + 152) | *(void *)(v6 + 184)) {
          goto LABEL_26;
        }
      }
      else if (*(unsigned char *)(v6 + 256))
      {
        uint64_t v8 = *(unsigned char **)(v6 + 208);
        uint64_t v7 = *(unsigned char **)(v6 + 216);
        int64_t v9 = v7 - v8;
        if (v7 == v8)
        {
          if (*(void *)(v6 + 240)) {
            goto LABEL_26;
          }
        }
        else
        {
          if (v9 < 0) {
            abort();
          }
          char v10 = (char *)operator new(v7 - v8);
          size_t v11 = v9 & 0xFFFFFFFFFFFFFFE0;
          memcpy(v10, v8, v11);
          uint64_t v12 = *(void *)(v6 + 240);
          if (v11)
          {
            uint64_t v13 = 0;
            while (!*(void *)&v10[v13 + 8])
            {
              v13 += 32;
              if (v11 == v13) {
                goto LABEL_15;
              }
            }
            operator delete(v10);
LABEL_26:
            *(unsigned char *)(a2 + 8) &= ~1u;
            char v15 = 1;
            goto LABEL_30;
          }
LABEL_15:
          operator delete(v10);
          if (v12) {
            goto LABEL_26;
          }
        }
      }
      v4 += 8;
    }
    llvm::object::MetalLibObjectFile::variables(this, &v16);
    unint64_t v14 = v16.n128_u64[0];
    if (v17)
    {
      *(unsigned char *)(a2 + 8) |= 1u;
      *(void *)a2 = v14;
      return;
    }
    while (1)
    {
      if (v14 == v16.n128_u64[1])
      {
        char v15 = 0;
        goto LABEL_29;
      }
      if (*(void *)(*(void *)v14 + 112)) {
        break;
      }
      v14 += 8;
    }
    char v15 = 1;
LABEL_29:
    *(unsigned char *)(a2 + 8) &= ~1u;
LABEL_30:
    *(unsigned char *)a2 = v15;
  }
}

llvm::object::MetalLibObjectFile *llvm::object::MetalLibObjectFile::asFunction@<X0>(llvm::object::MetalLibObjectFile *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((void *)result + 35);
  uint64_t v5 = *((void *)result + 36);
  if (a2 >= (unint64_t)((v5 - v4) >> 3))
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v5;
  }
  else
  {
    if (!*(void *)(v4 + 8 * a2)) {
      llvm::object::MetalLibObjectFile::materializeFunctionNo(result);
    }
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v4 + 8 * a2;
  }
  return result;
}

llvm::object::MetalLibObjectFile *llvm::object::MetalLibObjectFile::asVariable@<X0>(llvm::object::MetalLibObjectFile *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((void *)result + 36) - *((void *)result + 35);
  uint64_t v5 = *((void *)result + 76);
  uint64_t v6 = *((void *)result + 75);
  if (a2 >= (unint64_t)(((v5 - v6) >> 3) + (v4 >> 3)))
  {
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v5;
  }
  else
  {
    uint64_t v7 = a2 - (v4 >> 3);
    if (!*(void *)(v6 + 8 * v7)) {
      llvm::object::MetalLibObjectFile::materializeVariableNo(result);
    }
    *(unsigned char *)(a3 + 8) &= ~1u;
    *(void *)a3 = v6 + 8 * v7;
  }
  return result;
}

void sub_1CCC771A0(void *a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(a1[1] - *a1) >> 3;
  if (a2 > v2)
  {
    sub_1CD6EAE48((uint64_t)a1, a2 - v2);
  }
  else if (a2 < v2)
  {
    sub_1CCC77EF0(a1, (void *)(*a1 + 8 * a2));
  }
}

void sub_1CCC771D0(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  unint64_t v3 = *(void **)(a1 + 8);
  uint64_t v5 = (uint64_t)v3 - *(void *)a1;
  unint64_t v6 = v5 >> 3;
  if (a2 <= v5 >> 3)
  {
    if (a2 < v6)
    {
      uint64_t v20 = &v4[a2];
      while (v3 != v20)
      {
        uint64_t v22 = *--v3;
        uint64_t v21 = v22;
        void *v3 = 0;
        if (v22) {
          sub_1CCC77E0C(v21);
        }
      }
      *(void *)(a1 + ++*(_DWORD *)(this + 8) = v20;
    }
  }
  else
  {
    unint64_t v7 = a2 - v6;
    uint64_t v8 = *(void *)(a1 + 16);
    if (a2 - v6 <= (v8 - (uint64_t)v3) >> 3)
    {
      bzero(*(void **)(a1 + 8), 8 * v7);
      *(void *)(a1 + ++*(_DWORD *)(this + 8) = &v3[v7];
    }
    else
    {
      if (a2 >> 61) {
        abort();
      }
      uint64_t v9 = v8 - (void)v4;
      uint64_t v10 = v9 >> 2;
      if (v9 >> 2 <= a2) {
        uint64_t v10 = a2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v10;
      }
      if (v11 >> 61) {
        sub_1CB833614();
      }
      uint64_t v12 = (char *)operator new(8 * v11);
      uint64_t v13 = &v12[8 * v6];
      unint64_t v14 = &v12[8 * v11];
      bzero(v13, 8 * v7);
      char v15 = &v12[8 * v7 + v5];
      if (v3 == v4)
      {
        *(void *)a1 = v13;
        *(void *)(a1 + ++*(_DWORD *)(this + 8) = v15;
        *(void *)(a1 + ++*(_DWORD *)(this + 16) = v14;
      }
      else
      {
        do
        {
          uint64_t v16 = *--v3;
          void *v3 = 0;
          *((void *)v13 - 1) = v16;
          v13 -= 8;
        }
        while (v3 != v4);
        unint64_t v3 = *(void **)a1;
        char v17 = *(void **)(a1 + 8);
        *(void *)a1 = v13;
        *(void *)(a1 + ++*(_DWORD *)(this + 8) = v15;
        *(void *)(a1 + ++*(_DWORD *)(this + 16) = v14;
        while (v17 != v3)
        {
          uint64_t v19 = *--v17;
          uint64_t v18 = v19;
          *char v17 = 0;
          if (v19) {
            sub_1CCC77E0C(v18);
          }
        }
      }
      if (v3)
      {
        operator delete(v3);
      }
    }
  }
}

void *sub_1CCC77354(void *result, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  unint64_t v4 = *a3;
  unint64_t v5 = *a3 + 2;
  if (v5 > a4) {
    operator new();
  }
  *a3 = v5;
  unint64_t v6 = v4 + 18;
  if (v6 > a4) {
    operator new();
  }
  *a3 = v6;
  *(void *)(a2 + 264) = v5;
  *(void *)(a2 + 272) = 16;
  *__n128 result = 0;
  return result;
}

BOOL llvm::object::MetalLibObjectFile::skipExtensionToken(uint64_t a1, void *a2, unint64_t a3)
{
  unint64_t v3 = *a2 + 2;
  if (v3 > a3) {
    operator new();
  }
  *a2 = v3 + *(unsigned __int16 *)*a2;
  return v3 <= a3;
}

void llvm::object::MetalLibObjectFile::materializeAdditionalData(int a1@<W3>, uint64_t a2@<X8>)
{
  switch(a1)
  {
    case 60:
      operator new();
    case 58:
      operator new();
    case 1:
      operator new();
  }
  *(unsigned char *)(a2 + 8) &= ~1u;
  *(void *)a2 = 0;
}

uint64_t sub_1CCC77E0C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unint64_t v2 = *(void **)(result + 24);
    if (v2)
    {
      *(void *)(v1 + 32) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void sub_1CCC77E68(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          sub_1CCC787A4(v6);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1CCC77EF0(void *result, void *a2)
{
  unint64_t v3 = result;
  unint64_t v4 = (void *)result[1];
  while (v4 != a2)
  {
    unint64_t v5 = (void *)*--v4;
    __n128 result = v5;
    void *v4 = 0;
    if (v5)
    {
      uint64_t v6 = sub_1CD6EB4B0(result);
      __n128 result = (void *)MEMORY[0x1D25D9CE0](v6, 0x1070C40BAAD8800);
    }
  }
  v3[1] = a2;
  return result;
}

void sub_1CCC77F60(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          sub_1CCC77E0C(v6);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC77FE8(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          MEMORY[0x1D25D9CE0](v6, 0x1050C4015692547);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC78080(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          MEMORY[0x1D25D9CE0](v6, 0x1050C40A8B26598);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC78118(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          sub_1CCC78DF0(v6);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC781A0(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          MEMORY[0x1D25D9CE0](v6, 0x1050C40717B85FCLL);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC78238(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          MEMORY[0x1D25D9CE0](v6, 0x1050C40B09E53CALL);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC782D0(void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        void *v4 = 0;
        if (v7) {
          MEMORY[0x1D25D9CE0](v6, 0x1050C40A5B97131);
        }
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1CCC78368()
{
}

void sub_1CCC78428()
{
}

void sub_1CCC784D0()
{
}

void sub_1CCC78590()
{
}

void sub_1CCC78654()
{
}

void sub_1CCC786FC()
{
}

void sub_1CCC787A4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 256))
  {
    unint64_t v2 = *(void **)(a1 + 208);
    if (v2)
    {
      *(void *)(a1 + 2++*(_DWORD *)(this + 16) = v2;
      operator delete(v2);
    }
    *(unsigned char *)(a1 + 256) = 0;
  }

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CCC78804()
{
}

void sub_1CCC788AC()
{
}

void sub_1CCC78954()
{
}

uint64_t *sub_1CCC789FC(uint64_t **a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v5 = *a1;
  unint64_t v6 = (unint64_t)a1[1];
  uint64_t v7 = a2 - (void)*a1;
  uint64_t v8 = v7 >> 3;
  uint64_t v9 = (uint64_t *)((char *)*a1 + (v7 & 0xFFFFFFFFFFFFFFF8));
  unint64_t v10 = (unint64_t)a1[2];
  if (v6 >= v10)
  {
    unint64_t v25 = ((uint64_t)(v6 - (void)v5) >> 3) + 1;
    if (v25 >> 61) {
      abort();
    }
    uint64_t v26 = v10 - (void)v5;
    if (v26 >> 2 > v25) {
      unint64_t v25 = v26 >> 2;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    std::string::size_type v42 = a1 + 2;
    if (v27)
    {
      if (v27 >> 61) {
        sub_1CB833614();
      }
      int v28 = (char *)operator new(8 * v27);
    }
    else
    {
      int v28 = 0;
    }
    uint64_t v38 = v28;
    uint64_t v39 = (uint64_t *)&v28[8 * v8];
    unsigned int v40 = v39;
    int v41 = &v28[8 * v27];
    sub_1CD6EB8A8(&v38, a3);
    uint64_t v23 = v39;
    uint64_t v29 = *a1;
    unsigned int v30 = v39;
    if (v9 != *a1)
    {
      uint64_t v31 = v9;
      unsigned int v30 = v39;
      do
      {
        uint64_t v32 = *--v31;
        *uint64_t v31 = 0;
        *--unsigned int v30 = v32;
      }
      while (v31 != v29);
    }
    unint64_t v33 = a1[1];
    uint64_t v34 = v40;
    if (v9 != v33)
    {
      do
      {
        uint64_t v35 = *v9;
        *v9++ = 0;
        *v34++ = v35;
      }
      while (v9 != v33);
      uint64_t v9 = a1[1];
    }
    uint64_t v36 = *a1;
    *a1 = v30;
    a1[1] = v34;
    uint64_t v37 = (char *)a1[2];
    a1[2] = (uint64_t *)v41;
    unsigned int v40 = v9;
    int v41 = v37;
    uint64_t v38 = (char *)v36;
    uint64_t v39 = v36;
    sub_1CD6EBA28((uint64_t)&v38);
  }
  else
  {
    if (v9 == (uint64_t *)v6)
    {
      uint64_t v16 = *a3;
      *a3 = 0;
      *uint64_t v9 = v16;
      a1[1] = v9 + 1;
    }
    else
    {
      unint64_t v11 = v9 + 1;
      uint64_t v12 = (uint64_t *)(v6 - 8);
      if (v6 < 8)
      {
        unint64_t v14 = a1[1];
      }
      else
      {
        uint64_t v13 = (uint64_t *)(v6 - 8);
        unint64_t v14 = a1[1];
        do
        {
          uint64_t v15 = *v13;
          *v13++ = 0;
          *v14++ = v15;
        }
        while ((unint64_t)v13 < v6);
      }
      a1[1] = v14;
      if ((void *)v6 != v11)
      {
        uint64_t v17 = 8 * ((uint64_t)(v6 - (void)v11) >> 3);
        uint64_t v18 = (uint64_t)&v5[v8 - 1];
        do
        {
          uint64_t v19 = *(void *)(v18 + v17);
          *(void *)(v18 + v17) = 0;
          uint64_t v20 = *v12;
          *uint64_t v12 = v19;
          if (v20) {
            MEMORY[0x1D25D9CE0](v20, 0x1050C4015692547);
          }
          --v12;
          v17 -= 8;
        }
        while (v17);
      }
      uint64_t v21 = *a3;
      *a3 = 0;
      uint64_t v22 = *v9;
      *uint64_t v9 = v21;
      if (v22) {
        MEMORY[0x1D25D9CE0](v22, 0x1050C4015692547);
      }
    }
    return v9;
  }
  return v23;
}