char *llvm::dwarf::GDBIndexEntryKindString(int a1)
{
  return off_1E682E7E0[a1];
}

const char *llvm::dwarf::GDBIndexEntryLinkageString(int a1)
{
  if (a1) {
    return "STATIC";
  }
  else {
    return "EXTERNAL";
  }
}

const char *llvm::dwarf::AttributeValueString(llvm::dwarf *this, llvm::dwarf *a2)
{
  int v2 = (int)this;
  result = 0;
  if (v2 <= 65)
  {
    if (v2 > 31)
    {
      if (v2 <= 49)
      {
        if (v2 != 32) {
          return result;
        }
        if (a2 < 4) {
          return off_1E682E8B0[(int)a2];
        }
        return 0;
      }
      switch(v2)
      {
        case '2':
          if ((a2 - 1) < 3) {
            return off_1E682E820[(int)a2 - 1];
          }
          return 0;
        case '6':
          return llvm::dwarf::ConventionString(a2);
        case '>':
          return llvm::dwarf::AttributeEncodingString(a2);
      }
    }
    else
    {
      if (v2 != 9)
      {
        if (v2 != 19)
        {
          if (v2 != 23) {
            return result;
          }
          if ((a2 - 1) < 3) {
            return off_1E682E878[(int)a2 - 1];
          }
          return 0;
        }
        return llvm::dwarf::LanguageString(a2);
      }
      v4 = "DW_ORD_row_major";
      if (a2) {
        v4 = 0;
      }
      if (a2 == 1) {
        return "DW_ORD_col_major";
      }
      else {
        return v4;
      }
    }
  }
  else
  {
    if (v2 <= 100)
    {
      switch(v2)
      {
        case 'B':
          if (a2 < 4) {
            return off_1E682E890[(int)a2];
          }
          break;
        case 'L':
          if (a2 < 3) {
            return off_1E682E838[(int)a2];
          }
          break;
        case '^':
          if ((a2 - 1) < 5) {
            return off_1E682E850[(int)a2 - 1];
          }
          break;
        default:
          return result;
      }
      return 0;
    }
    if (v2 != 101)
    {
      if (v2 != 139)
      {
        if (v2 != 16358) {
          return result;
        }
        return llvm::dwarf::LanguageString(a2);
      }
      if (a2 < 3) {
        return off_1E682E8D0[(int)a2];
      }
      return 0;
    }
    v5 = "DW_END_little";
    v6 = "DW_END_lo_user";
    v7 = "DW_END_hi_user";
    if (a2 != 255) {
      v7 = 0;
    }
    if (a2 != 64) {
      v6 = v7;
    }
    if (a2 != 2) {
      v5 = v6;
    }
    v8 = "DW_END_default";
    v9 = "DW_END_big";
    if (a2 != 1) {
      v9 = 0;
    }
    if (a2) {
      v8 = v9;
    }
    if ((int)a2 <= 1) {
      return v8;
    }
    else {
      return v5;
    }
  }
  return result;
}

const char *llvm::dwarf::AtomValueString(llvm::dwarf *this, llvm::dwarf *a2)
{
  if (this == 3) {
    return llvm::dwarf::TagString(a2);
  }
  if (this) {
    return 0;
  }
  return "NULL";
}

char *llvm::dwarf::IndexString(llvm::dwarf *this)
{
  if ((this - 1) > 4) {
    return 0;
  }
  else {
    return off_1E682E8E8[(int)this - 1];
  }
}

const char *llvm::dwarf::FormatString(int a1)
{
  v1 = "DWARF32";
  if (a1) {
    v1 = 0;
  }
  if (a1 == 1) {
    return "DWARF64";
  }
  else {
    return v1;
  }
}

char *llvm::dwarf::RLEString(llvm::dwarf *this)
{
  if (this > 7) {
    return 0;
  }
  else {
    return off_1E682E910[(int)this];
  }
}

void sub_1CD4F664C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  memset(__p, 0, sizeof(__p));
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  v15 = __p;
  int v14 = 0;
  v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v5 = *a4;
  uint64_t v6 = *a5;
  v17[0] = &unk_1F26083C0;
  v17[1] = a3;
  v17[2] = v5;
  v17[3] = v6;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v7, (uint64_t)v17);
  operator new();
}

uint64_t sub_1CD4F6758(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t llvm::yaml::ScalarTraits<FlowStringRef,void>::mustQuote(char *a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v3 = a2;
    v4 = a1;
    int v5 = *a1;
    BOOL v6 = 1;
    if ((v5 - 9) >= 5 && v5 != 32)
    {
      int v14 = a1[a2 - 1];
      if ((v14 - 9) >= 5) {
        BOOL v6 = v14 == 32;
      }
    }
    BOOL v7 = sub_1CD4F6900(a1, a2);
    BOOL v8 = sub_1CD4F6968((uint64_t)v4, v3);
    BOOL v9 = sub_1CC1B5AB8(v4, v3);
    LODWORD(v11) = v9 || v8 || v7 || v6;
    if (v10) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = v11;
    }
    while (1)
    {
      unsigned int v12 = *v4;
      if (v12 - 48 < 0xA || (v12 & 0xFFFFFFDF) - 65 < 0x1A) {
        goto LABEL_14;
      }
      uint64_t result = 2;
      if (v12 <= 0x2E)
      {
        if (((1 << v12) & 0x700100000200) != 0) {
          goto LABEL_14;
        }
        if (((1 << v12) & 0x2400) != 0) {
          return result;
        }
      }
      if (v12 - 94 >= 2)
      {
        if (v12 == 127 || v12 < 0x20) {
          return result;
        }
        uint64_t v11 = (v12 & 0x80u) == 0 ? 1 : v11;
        if ((v12 & 0x80) != 0) {
          return result;
        }
      }
LABEL_14:
      ++v4;
      uint64_t result = v11;
      if (!--v3) {
        return result;
      }
    }
  }
  return 1;
}

BOOL sub_1CD4F6900(unsigned char *a1, uint64_t a2)
{
  if (a2 == 1)
  {
    return *a1 == 126;
  }
  else
  {
    if (a2 != 4) {
      return 0;
    }
    if (*(_DWORD *)a1 == 1819047278 || *(_DWORD *)a1 == 1819047246) {
      return 1;
    }
    return *(_DWORD *)a1 == 1280070990;
  }
}

BOOL sub_1CD4F6968(uint64_t a1, uint64_t a2)
{
  if (a2 != 5) {
    return a2 == 4 && (*(_DWORD *)a1 == 1702195828 || *(_DWORD *)a1 == 1702195796 || *(_DWORD *)a1 == 1163219540);
  }
  if (*(_DWORD *)a1 == 1936482662 && *(unsigned char *)(a1 + 4) == 101) {
    return 1;
  }
  if (*(_DWORD *)a1 == 1936482630 && *(unsigned char *)(a1 + 4) == 101) {
    return 1;
  }
  return *(_DWORD *)a1 == 1397506374 && *(unsigned char *)(a1 + 4) == 69;
}

char *llvm::wasm::toString@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  switch((int)result)
  {
    case 1:
      *(unsigned char *)(a2 + 23) = 21;
      strcpy((char *)a2, "WASM_SYMBOL_TYPE_DATA");
      break;
    case 2:
      uint64_t result = (char *)operator new(0x19uLL);
      *(void *)a2 = result;
      *(_OWORD *)(a2 + 8) = xmmword_1CD91A420;
      strcpy(result, "WASM_SYMBOL_TYPE_GLOBAL");
      break;
    case 3:
      uint64_t result = (char *)operator new(0x20uLL);
      *(void *)a2 = result;
      *(_OWORD *)(a2 + 8) = xmmword_1CD91A410;
      strcpy(result, "WASM_SYMBOL_TYPE_SECTION");
      break;
    case 4:
      *(unsigned char *)(a2 + 23) = 20;
      strcpy((char *)a2, "WASM_SYMBOL_TYPE_TAG");
      break;
    case 5:
      strcpy((char *)a2, "WASM_SYMBOL_TYPE_TABLE");
      *(unsigned char *)(a2 + 23) = 22;
      break;
    default:
      uint64_t result = (char *)operator new(0x20uLL);
      *(void *)a2 = result;
      *(_OWORD *)(a2 + 8) = xmmword_1CD91A400;
      strcpy(result, "WASM_SYMBOL_TYPE_FUNCTION");
      break;
  }
  return result;
}

__n128 llvm::wasm::relocTypetoString@<Q0>(llvm::wasm *this@<X0>, uint64_t a2@<X8>, __n128 result@<Q0>)
{
  switch((int)this)
  {
    case 1:
      BOOL v7 = (char *)operator new(0x19uLL);
      *(void *)a2 = v7;
      long long v8 = xmmword_1CD91A420;
      BOOL v9 = "R_WASM_TABLE_INDEX_SLEB";
      goto LABEL_25;
    case 2:
      uint64_t v10 = "R_WASM_TABLE_INDEX_I32";
      goto LABEL_23;
    case 3:
      uint64_t v10 = "R_WASM_MEMORY_ADDR_LEB";
      goto LABEL_23;
    case 4:
      BOOL v7 = (char *)operator new(0x19uLL);
      *(void *)a2 = v7;
      long long v8 = xmmword_1CD91A420;
      BOOL v9 = "R_WASM_MEMORY_ADDR_SLEB";
      goto LABEL_25;
    case 5:
      uint64_t v10 = "R_WASM_MEMORY_ADDR_I32";
      goto LABEL_23;
    case 6:
      *(unsigned char *)(a2 + 23) = 21;
      result.n128_u64[0] = *(void *)"R_WASM_TYPE_INDEX_LEB";
      strcpy((char *)a2, "R_WASM_TYPE_INDEX_LEB");
      return result;
    case 7:
      BOOL v7 = (char *)operator new(0x19uLL);
      *(void *)a2 = v7;
      long long v8 = xmmword_1CD91A420;
      BOOL v9 = "R_WASM_GLOBAL_INDEX_LEB";
      goto LABEL_25;
    case 8:
      uint64_t v11 = (char *)operator new(0x20uLL);
      *(void *)a2 = v11;
      long long v12 = xmmword_1CD96DBE0;
      uint64_t v13 = "R_WASM_FUNCTION_OFFSET_I32";
      goto LABEL_30;
    case 9:
      v4 = (char *)operator new(0x20uLL);
      *(void *)a2 = v4;
      long long v5 = xmmword_1CD91A400;
      BOOL v6 = "R_WASM_SECTION_OFFSET_I32";
      goto LABEL_21;
    case 10:
      *(unsigned char *)(a2 + 23) = 20;
      result.n128_u64[0] = *(void *)"R_WASM_TAG_INDEX_LEB";
      strcpy((char *)a2, "R_WASM_TAG_INDEX_LEB");
      return result;
    case 11:
      int v14 = (char *)operator new(0x20uLL);
      *(void *)a2 = v14;
      long long v15 = xmmword_1CFAC3CD0;
      v16 = "R_WASM_MEMORY_ADDR_REL_SLEB";
      goto LABEL_28;
    case 12:
      int v14 = (char *)operator new(0x20uLL);
      *(void *)a2 = v14;
      long long v15 = xmmword_1CFAC3CD0;
      v16 = "R_WASM_TABLE_INDEX_REL_SLEB";
      goto LABEL_28;
    case 13:
      BOOL v7 = (char *)operator new(0x19uLL);
      *(void *)a2 = v7;
      long long v8 = xmmword_1CD91A420;
      BOOL v9 = "R_WASM_GLOBAL_INDEX_I32";
      goto LABEL_25;
    case 14:
      v17 = (char *)operator new(0x20uLL);
      *(void *)a2 = v17;
      *(_OWORD *)(a2 + 8) = xmmword_1CD91A410;
      result.n128_u64[0] = *(void *)"R_WASM_MEMORY_ADDR_LEB64";
      strcpy(v17, "R_WASM_MEMORY_ADDR_LEB64");
      return result;
    case 15:
      v4 = (char *)operator new(0x20uLL);
      *(void *)a2 = v4;
      long long v5 = xmmword_1CD91A400;
      BOOL v6 = "R_WASM_MEMORY_ADDR_SLEB64";
      goto LABEL_21;
    case 16:
      uint64_t v10 = "R_WASM_MEMORY_ADDR_I64";
      goto LABEL_23;
    case 17:
      v18 = (char *)operator new(0x20uLL);
      *(void *)a2 = v18;
      long long v19 = xmmword_1CD91A430;
      v20 = "R_WASM_MEMORY_ADDR_REL_SLEB64";
      goto LABEL_34;
    case 18:
      v4 = (char *)operator new(0x20uLL);
      *(void *)a2 = v4;
      long long v5 = xmmword_1CD91A400;
      BOOL v6 = "R_WASM_TABLE_INDEX_SLEB64";
      goto LABEL_21;
    case 19:
      uint64_t v10 = "R_WASM_TABLE_INDEX_I64";
LABEL_23:
      uint64_t result = *(__n128 *)v10;
      *(_OWORD *)a2 = *(_OWORD *)v10;
      *(void *)(a2 + 14) = *(void *)(v10 + 14);
      *(_WORD *)(a2 + 22) = 5632;
      return result;
    case 20:
      BOOL v7 = (char *)operator new(0x19uLL);
      *(void *)a2 = v7;
      long long v8 = xmmword_1CD91A420;
      BOOL v9 = "R_WASM_TABLE_NUMBER_LEB";
LABEL_25:
      *(_OWORD *)(a2 + 8) = v8;
      uint64_t result = *(__n128 *)v9;
      *(_OWORD *)BOOL v7 = *(_OWORD *)v9;
      *(void *)(v7 + 15) = *(void *)(v9 + 15);
      v7[23] = 0;
      return result;
    case 21:
      int v14 = (char *)operator new(0x20uLL);
      *(void *)a2 = v14;
      long long v15 = xmmword_1CFAC3CD0;
      v16 = "R_WASM_MEMORY_ADDR_TLS_SLEB";
LABEL_28:
      *(_OWORD *)(a2 + 8) = v15;
      *(_OWORD *)int v14 = *(_OWORD *)v16;
      uint64_t result = *(__n128 *)(v16 + 11);
      *(__n128 *)(v14 + 11) = result;
      v14[27] = 0;
      return result;
    case 22:
      uint64_t v11 = (char *)operator new(0x20uLL);
      *(void *)a2 = v11;
      long long v12 = xmmword_1CD96DBE0;
      uint64_t v13 = "R_WASM_FUNCTION_OFFSET_I64";
LABEL_30:
      *(_OWORD *)(a2 + 8) = v12;
      *(_OWORD *)uint64_t v11 = *(_OWORD *)v13;
      uint64_t result = *(__n128 *)(v13 + 10);
      *(__n128 *)(v11 + 10) = result;
      v11[26] = 0;
      return result;
    case 23:
      v18 = (char *)operator new(0x20uLL);
      *(void *)a2 = v18;
      long long v19 = xmmword_1CD91A430;
      v20 = "R_WASM_MEMORY_ADDR_LOCREL_I32";
      goto LABEL_34;
    case 24:
      v18 = (char *)operator new(0x20uLL);
      *(void *)a2 = v18;
      long long v19 = xmmword_1CD91A430;
      v20 = "R_WASM_TABLE_INDEX_REL_SLEB64";
      goto LABEL_34;
    case 25:
      v18 = (char *)operator new(0x20uLL);
      *(void *)a2 = v18;
      long long v19 = xmmword_1CD91A430;
      v20 = "R_WASM_MEMORY_ADDR_TLS_SLEB64";
LABEL_34:
      *(_OWORD *)(a2 + 8) = v19;
      *(_OWORD *)v18 = *(_OWORD *)v20;
      uint64_t result = *(__n128 *)(v20 + 13);
      *(__n128 *)(v18 + 13) = result;
      v18[29] = 0;
      break;
    default:
      v4 = (char *)operator new(0x20uLL);
      *(void *)a2 = v4;
      long long v5 = xmmword_1CD91A400;
      BOOL v6 = "R_WASM_FUNCTION_INDEX_LEB";
LABEL_21:
      *(_OWORD *)(a2 + 8) = v5;
      *(_OWORD *)v4 = *(_OWORD *)v6;
      uint64_t result = *(__n128 *)(v6 + 9);
      *(__n128 *)(v4 + 9) = result;
      v4[25] = 0;
      break;
  }
  return result;
}

uint64_t llvm::wasm::relocTypeHasAddend(llvm::wasm *this)
{
  return (this < 0x1A) & (0x2E3CB38u >> (char)this);
}

const char *llvm::XCOFF::getMappingClassString(unsigned int a1)
{
  if (a1 > 0x16) {
    return "Unknown";
  }
  else {
    return off_1E682F160[(char)a1];
  }
}

const char *llvm::XCOFF::getRelocationTypeString(unsigned int a1)
{
  if (a1 > 0x31) {
    return "Unknown";
  }
  else {
    return off_1E682F218[(char)a1];
  }
}

void sub_1CD4F6FE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  memset(__p, 0, sizeof(__p));
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  long long v15 = __p;
  int v14 = 0;
  BOOL v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v5 = *a4;
  uint64_t v6 = *a5;
  v17[0] = &unk_1F26088C8;
  v17[1] = a3;
  v17[2] = v5;
  v17[3] = v6;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v7, (uint64_t)v17);
  operator new();
}

uint64_t sub_1CD4F70EC(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24));
}

void sub_1CD4F7124(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int *a5)
{
  memset(__p, 0, sizeof(__p));
  int v7 = 0;
  char v11 = 0;
  uint64_t v12 = 0;
  int v14 = __p;
  int v13 = 0;
  uint64_t v6 = &unk_1F2646F30;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  unint64_t v5 = *a4 | ((unint64_t)*a5 << 32);
  v16[0] = &unk_1F26088E8;
  v16[1] = a3;
  v16[2] = v5;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v6, (uint64_t)v16);
  operator new();
}

uint64_t sub_1CD4F7234(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20));
}

double sub_1CD4F726C(char **a1, char **a2)
{
  v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = v4 - 24;
    uint64_t v7 = 32 * v5;
    do
    {
      uint64_t v8 = *(void *)&v6[v7];
      if (v8)
      {
        sub_1CC1CAA74((uint64_t)&v6[v7], v8);
        operator delete(*(void **)&v6[v7]);
      }
      v7 -= 32;
    }
    while (v7);
    v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

void sub_1CD4F7304()
{
}

void sub_1CD4F7374(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = *a1 + 32 * v2;
    do
    {
      *(_DWORD *)a2 = *(_DWORD *)v3;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + 8) = 0;
      *(_OWORD *)(a2 + 8) = *(_OWORD *)(v3 + 8);
      *(void *)(a2 + 24) = *(void *)(v3 + 24);
      *(void *)(v3 + 8) = 0;
      *(void *)(v3 + 16) = 0;
      *(void *)(v3 + 24) = 0;
      v3 += 32;
      a2 += 32;
    }
    while (v3 != v4);
    uint64_t v5 = *a1 - 24;
    uint64_t v6 = 32 * v2;
    do
    {
      uint64_t v7 = *(void *)(v5 + v6);
      if (v7)
      {
        sub_1CC1CAA74(v5 + v6, v7);
        operator delete(*(void **)(v5 + v6));
      }
      v6 -= 32;
    }
    while (v6);
  }
}

void sub_1CD4F7410(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  memset(__p, 0, sizeof(__p));
  int v8 = 0;
  char v12 = 0;
  uint64_t v13 = 0;
  long long v15 = __p;
  int v14 = 0;
  uint64_t v7 = &unk_1F2646F30;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v5 = *a4;
  uint64_t v6 = *a5;
  v17[0] = &unk_1F2608908;
  v17[1] = a3;
  v17[2] = v5;
  v17[3] = v6;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v7, (uint64_t)v17);
  operator new();
}

uint64_t sub_1CD4F751C(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24));
}

uint64_t sub_1CD4F7554(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    if (*(unsigned char *)(a1 + 24))
    {
      sub_1CC1CB1A4((void **)a1);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
    }
    else
    {
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(unsigned char *)(a1 + 24) = 1;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v5 = (void **)a1;
    sub_1CC1CB314(&v5);
    *(unsigned char *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t sub_1CD4F75F8(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(void *)(a1 + 24));
}

atomic_ullong llvm::BitcodeErrorCategory(llvm *this)
{
  if (!atomic_load_explicit(qword_1EA618B50, memory_order_acquire)) {
    llvm::ManagedStaticBase::RegisterManagedStatic((llvm::ManagedStaticBase *)qword_1EA618B50, (void *(*)(void))sub_1CC1EB960, (void (*)(void *))sub_1CC1EB9A8);
  }
  return qword_1EA618B50[0];
}

void llvm::BitcodeModule::getLazyModule(llvm::BitcodeModule *this@<X0>, uint64_t a2@<X8>)
{
}

uint64_t llvm::BitcodeModule::getSummary@<X0>(llvm::BitcodeModule *this@<X0>, uint64_t a2@<X8>)
{
  v15[33] = *MEMORY[0x1E4F143B8];
  long long v6 = *(_OWORD *)this;
  uint64_t v8 = 0;
  uint64_t v7 = 0;
  uint64_t v9 = 0x200000000;
  uint64_t v10 = 0;
  uint64_t v12 = 0;
  uint64_t v11 = 0;
  uint64_t v13 = v15;
  uint64_t v14 = 0x800000000;
  v15[32] = 0;
  sub_1CC1CE1A8((uint64_t)&v6, *((void *)this + 7), v5);
  uint64_t v3 = v5[0];
  if (!v5[0]) {
    operator new();
  }
  *(unsigned char *)(a2 + 8) |= 1u;
  *(void *)a2 = v3;
  return sub_1CC1EAF44((uint64_t)&v6);
}

uint64_t llvm::BitcodeModule::getLTOInfo@<X0>(llvm::BitcodeModule *this@<X0>, uint64_t a2@<X8>)
{
  v26[33] = *MEMORY[0x1E4F143B8];
  long long v17 = *(_OWORD *)this;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0x200000000;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  v24 = v26;
  uint64_t v25 = 0x800000000;
  v26[32] = 0;
  sub_1CC1CE1A8((uint64_t)&v17, *((void *)this + 7), &v14);
  unint64_t v3 = v14;
  if (v14
    || (llvm::BitstreamCursor::EnterSubBlock((llvm::BitstreamCursor *)&v17, 0, 8, (void **)&v14), (unint64_t v3 = v14) != 0))
  {
    char v4 = *(unsigned char *)(a2 + 8) | 1;
LABEL_3:
    *(unsigned char *)(a2 + 8) = v4;
    *(void *)a2 = v3;
    return sub_1CC1EAF44((uint64_t)&v17);
  }
  char v6 = *(unsigned char *)(a2 + 8);
  sub_1CC1CA5F4((uint64_t)&v17, 0, (uint64_t)&v14);
  unint64_t v3 = v14;
  if ((v15 & 1) != 0 && v14)
  {
LABEL_8:
    char v4 = v6 | 1;
    goto LABEL_3;
  }
  unint64_t v7 = HIDWORD(v14);
  int v8 = v14;
  while (2)
  {
    switch(v8)
    {
      case 0:
        unint64_t v14 = (unint64_t)"Malformed block";
        __int16 v16 = 259;
        sub_1CC1CD704();
      case 1:
        *(unsigned char *)(a2 + 8) = v6 & 0xFE;
        *(_WORD *)a2 = 0;
        *(unsigned char *)(a2 + 2) = 0;
        return sub_1CC1EAF44((uint64_t)&v17);
      case 2:
        if (v7 == 24)
        {
          sub_1CC1D2144((uint64_t)&v14, (llvm::BitstreamCursor *)&v17, 24);
          if ((v15 & 1) == 0)
          {
            char v11 = v14;
            char v12 = v6 & 0xFE;
            __int16 v13 = 256;
            goto LABEL_30;
          }
          goto LABEL_31;
        }
        if (v7 != 20)
        {
          sub_1CC1C6524((uint64_t)&v17, &v14);
          unint64_t v9 = v14;
          if (v14)
          {
LABEL_14:
            v6 |= 1u;
            *(unsigned char *)(a2 + 8) = v6;
            *(void *)a2 = v9;
            int v10 = 1;
          }
          else
          {
LABEL_21:
            int v10 = 2;
          }
          if (v10 != 2) {
            return sub_1CC1EAF44((uint64_t)&v17);
          }
LABEL_16:
          sub_1CC1CA5F4((uint64_t)&v17, 0, (uint64_t)&v14);
          unint64_t v3 = v14;
          if (v15)
          {
            if (v14) {
              goto LABEL_8;
            }
          }
          else
          {
            int v8 = v14;
            LODWORD(v7) = HIDWORD(v14);
          }
          continue;
        }
        sub_1CC1D2144((uint64_t)&v14, (llvm::BitstreamCursor *)&v17, 20);
        if (v15)
        {
LABEL_31:
          char v12 = v6 | 1;
          *(void *)a2 = v14;
          goto LABEL_24;
        }
        char v11 = v14;
        char v12 = v6 & 0xFE;
        __int16 v13 = 257;
LABEL_30:
        *(_WORD *)a2 = v13;
        *(unsigned char *)(a2 + 2) = v11;
LABEL_24:
        *(unsigned char *)(a2 + 8) = v12;
        return sub_1CC1EAF44((uint64_t)&v17);
      case 3:
        llvm::BitstreamCursor::skipRecord((llvm::BitstreamCursor *)&v17, v7, (uint64_t)&v14);
        if ((v15 & 1) == 0) {
          goto LABEL_21;
        }
        unint64_t v9 = v14;
        goto LABEL_14;
      default:
        goto LABEL_16;
    }
  }
}

void llvm::getLazyBitcodeModule(_OWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v3 = a1[1];
  v5[0] = *a1;
  v5[1] = v3;
  sub_1CC1D2378(v5, (uint64_t)v6);
  if (v7)
  {
    uint64_t v4 = *(void *)&v6[0];
    *(unsigned char *)(a2 + 8) |= 1u;
    *(void *)a2 = v4;
  }
  else
  {
    llvm::BitcodeModule::getModuleImpl(v6, a2);
  }
}

void llvm::getOwningLazyBitcodeModule(const llvm::MemoryBuffer **a1@<X0>, uint64_t a2@<X8>)
{
  llvm::MemoryBufferRef::MemoryBufferRef((llvm::MemoryBufferRef *)v8, *a1);
  llvm::getLazyBitcodeModule(v8, a2);
  if ((*(unsigned char *)(a2 + 8) & 1) == 0)
  {
    uint64_t v4 = *(void *)a2;
    uint64_t v5 = *a1;
    *a1 = 0;
    char v7 = v5;
    llvm::Module::setOwnedMemoryBuffer(v4, (uint64_t *)&v7);
    uint64_t v6 = (uint64_t)v7;
    char v7 = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
  }
}

void llvm::BitcodeModule::parseModule(long long *a1@<X0>, uint64_t a2@<X8>)
{
}

uint64_t llvm::getModuleSummaryIndex@<X0>(_OWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  long long v3 = a1[1];
  v6[0] = *a1;
  v6[1] = v3;
  uint64_t result = sub_1CC1D2378(v6, (uint64_t)v7);
  if ((v8 & 1) == 0) {
    return llvm::BitcodeModule::getSummary((llvm::BitcodeModule *)v7, a2);
  }
  uint64_t v5 = v7[0];
  *(unsigned char *)(a2 + 8) |= 1u;
  *(void *)a2 = v5;
  return result;
}

void llvm::getModuleSummaryIndexForFile(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  __int16 v11 = 261;
  v10[0] = a1;
  v10[1] = a2;
  llvm::MemoryBuffer::getFileOrSTDIN((llvm::MemoryBuffer *)v10, 0, 1, (uint64_t)v12);
  if (v13)
  {
    *(llvm **)&v6.__val_ = v12[1];
    llvm::errorCodeToError(v12[0], v6, &v9);
    *(unsigned char *)(a4 + 8) |= 1u;
    *(void *)a4 = v9;
    uint64_t v9 = 0;
  }
  else if (a3 && *((void *)v12[0] + 2) == *((void *)v12[0] + 1))
  {
    *(unsigned char *)(a4 + 8) &= ~1u;
    *(void *)a4 = 0;
  }
  else
  {
    llvm::MemoryBufferRef::MemoryBufferRef((llvm::MemoryBufferRef *)v8, v12[0]);
    llvm::getModuleSummaryIndex(v8, a4);
  }
  if ((v13 & 1) == 0)
  {
    char v7 = v12[0];
    v12[0] = 0;
    if (v7) {
      (*(void (**)(llvm *))(*(void *)v7 + 8))(v7);
    }
  }
}

uint64_t sub_1CD4F7E30(uint64_t *a1, long long *a2, __n128 *a3)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_1CC1E42AC(a1, a2, a3);
  }
  else
  {
    sub_1CC1E43E0(a1[1], a2, a3);
    uint64_t result = v4 + 48;
  }
  a1[1] = result;
  return result;
}

llvm::Value *sub_1CD4F7E78(uint64_t a1, unsigned char *a2, llvm::Type *a3)
{
  uint64_t v5 = llvm::ArrayType::get((llvm::ArrayType *)(a1 + 1912), a3);

  return llvm::ConstantDataSequential::getImpl(a2, a3, v5);
}

llvm::Value *sub_1CD4F7EC4(uint64_t a1, unsigned char *a2, llvm::Type *a3)
{
  unint64_t v4 = (llvm::Type *)(2 * (void)a3);
  uint64_t v5 = llvm::ArrayType::get((llvm::ArrayType *)(a1 + 1936), a3);

  return llvm::ConstantDataSequential::getImpl(a2, v4, v5);
}

llvm::Value *sub_1CD4F7F10(uint64_t a1, unsigned char *a2, llvm::Type *a3)
{
  unint64_t v4 = (llvm::Type *)(8 * a3);
  uint64_t v5 = llvm::ArrayType::get((llvm::ArrayType *)(a1 + 1984), (llvm::Type *)a3);

  return llvm::ConstantDataSequential::getImpl(a2, v4, v5);
}

void *sub_1CD4F7F5C(uint64_t a1, uint64_t *a2)
{
  char v8 = 0;
  char v4 = sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  uint64_t v5 = v8;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4F7FCC(a1, a2, v8);
    uint64_t v7 = *a2;
    _OWORD v5[2] = 0;
    v5[3] = 0;
    void *v5 = v7;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4F7FCC(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4F8080(a1, v6);
  char v8 = 0;
  sub_1CD41F538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD4F8080(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4F814C(a1, v4, v4 + 32 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4F814C(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 32 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD41F538(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      v10[1] = 0;
      v10[2] = 0;
      v10[3] = 0;
      *(_OWORD *)(v10 + 1) = *(_OWORD *)(a2 + 8);
      v10[3] = *(void *)(a2 + 24);
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)(a2 + 24) = 0;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 32;
  }
  return result;
}

uint64_t *sub_1CD4F8218(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 48;
      long long v6 = *(_OWORD *)(v3 - 48);
      *(void *)(v4 - 32) = *(void *)(v3 - 32);
      *(_OWORD *)(v4 - 48) = v6;
      *(void *)(v3 - 40) = 0;
      *(void *)(v3 - 32) = 0;
      *(void *)(v3 - 48) = 0;
      *(void *)(v4 - 24) = 0;
      *(void *)(v4 - 16) = 0;
      *(void *)(v4 - 8) = 0;
      *(_OWORD *)(v4 - 24) = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - 8) = *(void *)(v3 - 8);
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 8) = 0;
      v3 -= 48;
      v4 -= 48;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v7 = *result;
  void *result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void LLVMSetModuleInlineAsm2_0(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3)
{
  std::string::__init(&v7, a2, a3);
  uint64_t v4 = (void **)(a1 + 88);
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*v4);
  }
  *(_OWORD *)uint64_t v4 = *(_OWORD *)&v7.__r_.__value_.__l.__data_;
  *(void *)(a1 + 104) = *((void *)&v7.__r_.__value_.__l + 2);
  if (*(char *)(a1 + 111) < 0)
  {
    uint64_t v5 = *(void *)(a1 + 96);
    if (!v5) {
      return;
    }
    long long v6 = (char *)*v4;
  }
  else
  {
    uint64_t v5 = *(unsigned __int8 *)(a1 + 111);
    if (!*(unsigned char *)(a1 + 111)) {
      return;
    }
    long long v6 = (char *)(a1 + 88);
  }
  if (v6[v5 - 1] != 10) {
    std::string::push_back((std::string *)(a1 + 88), 10);
  }
}

void *sub_1CD4F8350(uint64_t *a1, void *a2)
{
  std::string v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4F83B4((uint64_t)a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4F83B4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD475DD4(a1, v7);
  uint64_t v9 = 0;
  sub_1CD3C8538((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void sub_1CD4F8464(uint64_t a1)
{
  int64x2_t v1 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1CFAC6350);
  *(int64x2_t *)(a1 + 32) = v1;
  if (v1.i64[0] >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
}

_DWORD *sub_1CD4F84C8(uint64_t a1, int *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CD4F8538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4F85D4(a1, a2, v7);
    _DWORD *v5 = *a2;
    *((void *)v5 + 1) = 0;
    *((void *)v5 + 2) = 0;
  }
  return v5;
}

uint64_t sub_1CD4F8538(uint64_t a1, int a2, int a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    int v6 = (_DWORD *)(a1 + 24 * v5);
    int v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -2;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        int v6 = (_DWORD *)(a1 + 24 * (v13 & v4));
        int v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        int v6 = v10;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_DWORD *sub_1CD4F85D4(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4F8688(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4F8538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD4F8688(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4F8760(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      _DWORD *result = -1;
      result += 6;
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4F8760(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      _DWORD *v7 = -1;
      v7 += 6;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    int v9 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD4F8538(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(_DWORD *)a2;
      *(_OWORD *)(v10 + 2) = *(_OWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

void sub_1CD4F8818(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (a2 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    uint64_t v5 = *(unsigned char **)(a1 + 8);
    uint64_t v6 = (char *)operator new(8 * a2);
    int v7 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFF8];
    uint64_t v8 = v7;
    if (v5 != v2)
    {
      uint64_t v8 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFF8];
      do
      {
        uint64_t v9 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v8 - 1) = v9;
        v8 -= 8;
      }
      while (v5 != v2);
    }
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v6[8 * a2];
    if (v2)
    {
      operator delete(v2);
    }
  }
}

void sub_1CD4F88CC(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (a2 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4)
  {
    if (a2 >> 60) {
      abort();
    }
    uint64_t v5 = *(unsigned char **)(a1 + 8);
    uint64_t v6 = (char *)operator new(16 * a2);
    int v7 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFF0];
    uint64_t v8 = v7;
    if (v5 != v2)
    {
      uint64_t v9 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFF0];
      do
      {
        uint64_t v8 = v9 - 16;
        *((_OWORD *)v9 - 1) = *((_OWORD *)v5 - 1);
        v5 -= 16;
        v9 -= 16;
      }
      while (v5 != v2);
    }
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v6[16 * a2];
    if (v2)
    {
      operator delete(v2);
    }
  }
}

void *sub_1CD4F8990(uint64_t *a1, void *a2)
{
  int v7 = 0;
  char v4 = sub_1CD4F89F8(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4F8A9C((uint64_t)a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
    _OWORD v5[2] = 0;
  }
  return v5;
}

uint64_t sub_1CD4F89F8(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = (37 * *a2) & (v3 - 1);
    int v7 = (void *)(*a1 + 24 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -2;
        }
        if (v12) {
          uint64_t v10 = v7;
        }
        unsigned int v13 = v6 + v11++;
        unsigned int v6 = v13 & v5;
        int v7 = (void *)(v4 + 24 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        int v7 = v10;
      }
    }
  }
  else
  {
    int v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

void *sub_1CD4F8A9C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD4F8B4C(a1, v7);
  uint64_t v9 = 0;
  sub_1CD4F89F8((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD4F8B4C(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4F8C24(a1, v4, v4 + 24 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      void *result = -1;
      result += 3;
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4F8C24(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      void *v7 = -1;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if (*(void *)a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CD4F89F8((uint64_t *)v5, (void *)a2, &v10);
      uint64_t v9 = v10;
      *uint64_t v10 = *(void *)a2;
      *(_OWORD *)(v9 + 1) = *(_OWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 24;
  }
  return result;
}

_OWORD *sub_1CD4F8CDC(uint64_t a1, const void **a2, uint64_t a3)
{
  uint64_t v5 = (void **)sub_1CD4F8D98(a1, &v12, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    int v7 = v5;
    uint64_t v6 = operator new(0x38uLL);
    _OWORD v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    uint64_t v8 = v12;
    *(void *)uint64_t v6 = 0;
    *((void *)v6 + 1) = 0;
    *((void *)v6 + 2) = v8;
    void *v7 = v6;
    uint64_t v9 = **(void **)a1;
    uint64_t v10 = (uint64_t *)v6;
    if (v9)
    {
      *(void *)a1 = v9;
      uint64_t v10 = (uint64_t *)*v7;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v10);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void *sub_1CD4F8D98(uint64_t a1, void *a2, const void **a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    uint64_t v18 = a2;
    while (1)
    {
      long long v17 = result;
      uint64_t v20 = v4;
      uint64_t v9 = (const void *)v4[4];
      uint64_t v8 = v4 + 4;
      int v7 = v9;
      char v10 = *((unsigned char *)v8 + 23);
      int v11 = v10;
      if (v10 >= 0) {
        int v7 = v8;
      }
      uint64_t v12 = (const void *)(v10 & 0x7F);
      if (v11 < 0) {
        uint64_t v12 = (const void *)v8[1];
      }
      uint64_t v21 = v7;
      uint64_t v22 = v12;
      if ((sub_1CC0C5278(a3, (uint64_t)&v21) & 0x80000000) != 0)
      {
        uint64_t v6 = v20;
        uint64_t v4 = (void *)*v20;
        uint64_t result = v20;
      }
      else
      {
        unsigned int v13 = a3;
        char v14 = *((unsigned char *)a3 + 23);
        BOOL v15 = v14 < 0;
        if (v14 < 0) {
          unsigned int v13 = *a3;
        }
        __int16 v16 = (const void *)(v14 & 0x7F);
        if (v15) {
          __int16 v16 = a3[1];
        }
        uint64_t v21 = v13;
        uint64_t v22 = v16;
        if ((sub_1CC0C5278((const void **)v8, (uint64_t)&v21) & 0x80000000) == 0)
        {
          uint64_t result = v17;
          a2 = v18;
          uint64_t v6 = v20;
          goto LABEL_3;
        }
        uint64_t v6 = v20;
        uint64_t result = v20 + 1;
        uint64_t v4 = (void *)v20[1];
      }
      a2 = v18;
      if (!v4) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v6 = result;
LABEL_3:
  *a2 = v6;
  return result;
}

void *sub_1CD4F8E74(uint64_t a1, unint64_t **a2, uint64_t *a3)
{
  uint64_t v5 = (uint64_t **)sub_1CD4F30F8(a1, &v13, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v8 = v5;
    uint64_t v6 = operator new(0x50uLL);
    uint64_t v9 = *a3;
    v6[5] = 0;
    v6[6] = 0;
    long long v6[4] = 0;
    *((_OWORD *)v6 + 2) = *(_OWORD *)v9;
    v6[6] = *(void *)(v9 + 16);
    *(void *)uint64_t v9 = 0;
    *(void *)(v9 + 8) = 0;
    *(void *)(v9 + 16) = 0;
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    uint64_t v10 = v13;
    void *v6 = 0;
    v6[1] = 0;
    _OWORD v6[2] = v10;
    void *v8 = v6;
    uint64_t v11 = **(void **)a1;
    uint64_t v12 = v6;
    if (v11)
    {
      *(void *)a1 = v11;
      uint64_t v12 = *v8;
    }
    sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
    ++*(void *)(a1 + 16);
  }
  return v6;
}

void sub_1CD4F8F3C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *(void *)a1) >> 4);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD4F8FDC((void **)a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *(void *)a1 + 48 * a2;
    if (v3 != v7)
    {
      do
      {
        uint64_t v8 = v3 - 48;
        sub_1CC05EB8C(v3 - 32);
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    *(void *)(a1 + 8) = v7;
  }
}

void sub_1CD4F8FDC(void **a1, unint64_t a2)
{
  unint64_t v4 = a1[1];
  BOOL v5 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)v4) >> 4) >= a2)
  {
    if (a2)
    {
      uint64_t v22 = &v4[3 * a2];
      do
      {
        v4[1] = 0uLL;
        v4[2] = 0uLL;
        _OWORD *v4 = 0uLL;
        *((_DWORD *)v4 + 6) = 64;
        *((void *)v4 + 2) = -1;
        *((_DWORD *)v4 + 10) = 64;
        *((void *)v4 + 4) = -1;
        v4 += 3;
      }
      while (v4 != v22);
      unint64_t v4 = v22;
    }
    a1[1] = v4;
  }
  else
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (((char *)v4 - (unsigned char *)*a1) >> 4);
    unint64_t v7 = v6 + a2;
    if (v6 + a2 > 0x555555555555555) {
      abort();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (unsigned char *)*a1) >> 4);
    if (2 * v8 > v7) {
      unint64_t v7 = 2 * v8;
    }
    if (v8 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v9 = 0x555555555555555;
    }
    else {
      unint64_t v9 = v7;
    }
    if (v9)
    {
      if (v9 > 0x555555555555555) {
        sub_1CB833614();
      }
      uint64_t v10 = (char *)operator new(48 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v11 = &v10[48 * v6];
    uint64_t v12 = &v11[48 * a2];
    uint64_t v13 = v11;
    do
    {
      *((_OWORD *)v13 + 1) = 0uLL;
      *((_OWORD *)v13 + 2) = 0uLL;
      *(_OWORD *)uint64_t v13 = 0uLL;
      *((_DWORD *)v13 + 6) = 64;
      *((void *)v13 + 2) = -1;
      *((_DWORD *)v13 + 10) = 64;
      *((void *)v13 + 4) = -1;
      v13 += 48;
    }
    while (v13 != v12);
    char v14 = &v10[48 * v9];
    BOOL v15 = (char *)*a1;
    __int16 v16 = (char *)a1[1];
    if (v16 == *a1)
    {
      *a1 = v11;
      a1[1] = v12;
      a1[2] = v14;
    }
    else
    {
      uint64_t v17 = 0;
      do
      {
        uint64_t v18 = &v11[v17];
        uint64_t v19 = &v16[v17];
        *((_OWORD *)v18 - 3) = *(_OWORD *)&v16[v17 - 48];
        *((_DWORD *)v18 - 6) = *(_DWORD *)&v16[v17 - 24];
        *((void *)v18 - 4) = *(void *)&v16[v17 - 32];
        *((_DWORD *)v19 - 6) = 0;
        *((_DWORD *)v18 - 2) = *(_DWORD *)&v16[v17 - 8];
        *((void *)v18 - 2) = *(void *)&v16[v17 - 16];
        *((_DWORD *)v19 - 2) = 0;
        v17 -= 48;
      }
      while (&v16[v17] != v15);
      __int16 v16 = (char *)*a1;
      uint64_t v20 = (char *)a1[1];
      *a1 = &v11[v17];
      a1[1] = v12;
      a1[2] = v14;
      if (v20 != v16)
      {
        do
        {
          uint64_t v21 = v20 - 48;
          sub_1CC05EB8C((uint64_t)(v20 - 32));
          uint64_t v20 = v21;
        }
        while (v21 != v16);
      }
    }
    if (v16)
    {
      operator delete(v16);
    }
  }
}

_DWORD *sub_1CD4F91E4(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    unint64_t v9 = 0;
LABEL_5:
    unint64_t v6 = sub_1CD4F92A0(a1, a2, v9);
    *(void *)unint64_t v6 = *a2;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  unint64_t v6 = (_DWORD *)(*(void *)a1 + 8 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      unint64_t v6 = (_DWORD *)(*(void *)a1 + 8 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      unint64_t v9 = v10;
    }
    else {
      unint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD4F92A0(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD4F9428(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 8 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 8 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD4F9428(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD4F9428(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(8 * v8, (std::align_val_t)4uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4F94F4(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      _DWORD *result = -1;
      result += 2;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD4F94F4(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(_DWORD **)result;
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 8 * v4;
    unint64_t v6 = *(_DWORD **)result;
    do
    {
      _DWORD *v6 = -1;
      v6 += 2;
      v5 -= 8;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    int v7 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      int v8 = *(_DWORD *)(result + 16) - 1;
      unsigned int v9 = v8 & (37 * v7);
      uint64_t v10 = &v3[2 * v9];
      int v11 = *v10;
      if (v7 != *v10)
      {
        int v13 = 0;
        int v14 = 1;
        while (v11 != -1)
        {
          if (v13) {
            BOOL v15 = 0;
          }
          else {
            BOOL v15 = v11 == -2;
          }
          if (v15) {
            int v13 = v10;
          }
          unsigned int v16 = v9 + v14++;
          unsigned int v9 = v16 & v8;
          uint64_t v10 = &v3[2 * (v16 & v8)];
          int v11 = *v10;
          if (v7 == *v10) {
            goto LABEL_7;
          }
        }
        if (v13) {
          uint64_t v10 = v13;
        }
      }
LABEL_7:
      int v12 = a2[1];
      *uint64_t v10 = v7;
      v10[1] = v12;
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

uint64_t sub_1CD4F95C4(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 9);
  if ((long long *)a1 != a2) {
    sub_1CC1CAFD4((uint64_t *)(a1 + 40), *((uint64_t **)a2 + 5), *((uint64_t **)a2 + 6), (uint64_t)(*((void *)a2 + 6) - *((void *)a2 + 5)) >> 4);
  }
  sub_1CC1CADFC(a1 + 64, (uint64_t)(a2 + 4));
  *(void *)(a1 + 336) = *((void *)a2 + 42);
  return a1;
}

void sub_1CD4F9634(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(unsigned char **)a1;
  if (a2 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4)
  {
    if (a2 >> 60) {
      abort();
    }
    long long v5 = *(unsigned char **)(a1 + 8);
    unint64_t v6 = (char *)operator new(16 * a2);
    int v7 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFF0];
    int v8 = v7;
    if (v5 != v2)
    {
      unsigned int v9 = &v6[(v5 - v2) & 0xFFFFFFFFFFFFFFF0];
      do
      {
        int v8 = v9 - 16;
        *((_OWORD *)v9 - 1) = *((_OWORD *)v5 - 1);
        v5 -= 16;
        v9 -= 16;
      }
      while (v5 != v2);
    }
    *(void *)a1 = v8;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = &v6[16 * a2];
    if (v2)
    {
      operator delete(v2);
    }
  }
}

uint64_t llvm::MetadataLoader::MetadataLoaderImpl::loadGlobalDeclAttachments@<X0>(uint64_t this@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(this + 648))
  {
    a2[8] &= ~1u;
    *a2 = 1;
    return this;
  }
  uint64_t v5 = this;
  sub_1CC1F39E4((uint64_t)v31, *(long long **)(this + 200));
  v28 = v30;
  uint64_t v29 = 0x4000000000;
  sub_1CC1CE1A8((uint64_t)v31, *(void *)(v5 + 648), &v25);
  unint64_t v6 = v25;
  if (!v25)
  {
    int v8 = a2[8];
    while (1)
    {
      sub_1CC1EC5A8((uint64_t)&v25, (uint64_t)v31);
      unint64_t v6 = v25;
      if (v26)
      {
        if (v25)
        {
          char v7 = v8 | 1;
          goto LABEL_4;
        }
      }
      else
      {
        int v3 = (int)v25;
        int v2 = HIDWORD(v25);
      }
      switch(v3)
      {
        case 2:
          goto LABEL_32;
        case 1:
          a2[8] = v8 & 0xFE;
          *a2 = 1;
          goto LABEL_5;
        case 0:
LABEL_32:
          uint64_t v25 = "Malformed block";
          __int16 v27 = 259;
          llvm::BitcodeErrorCategory(v9);
          operator new();
      }
      uint64_t v10 = v32;
      uint64_t v11 = v33;
      llvm::BitstreamCursor::skipRecord((llvm::BitstreamCursor *)v31, v2, (uint64_t)&v23);
      if (v24) {
        break;
      }
      if (v23 == 36)
      {
        sub_1CC1CE1A8((uint64_t)v31, 8 * v10 - v11, &v25);
        int v12 = v25;
        if (v25) {
          goto LABEL_19;
        }
        LODWORD(v29) = 0;
        Record = (llvm *)llvm::BitstreamCursor::readRecord(v31, v2, (uint64_t)&v28, 0, (uint64_t)&v25);
        if (v26)
        {
          char v13 = 0;
          int v12 = v25;
          goto LABEL_21;
        }
        if ((v29 & 1) == 0)
        {
          uint64_t v25 = "Invalid record";
          __int16 v27 = 259;
          llvm::BitcodeErrorCategory(Record);
          operator new();
        }
        uint64_t v16 = **(void **)(v5 + 192);
        if (((unint64_t)(*(void *)(*(void *)(v5 + 192) + 8) - v16) >> 5) <= *(void *)v28)
        {
          uint64_t v25 = "Invalid record";
          __int16 v27 = 259;
          sub_1CC1EC6B0((llvm *)&v22);
        }
        int v17 = *(unsigned __int8 **)(v16 + 32 * *(void *)v28 + 16);
        unsigned int v18 = v17[16];
        if (v18 <= 3 && v18 != 1)
        {
          uint64_t v20 = v32;
          uint64_t v21 = v33;
          llvm::MetadataLoader::MetadataLoaderImpl::parseGlobalObjectAttachment((unsigned __int8 *)v5, (llvm::Value *)v17, (uint64_t)v28 + 8, v29 - 1, &v25);
          int v12 = v25;
          if (v25 || (sub_1CC1CE1A8((uint64_t)v31, 8 * v20 - v21, &v25), (int v12 = v25) != 0))
          {
LABEL_19:
            char v13 = 0;
LABEL_21:
            v8 |= 1u;
            a2[8] = v8;
            *(void *)a2 = v12;
            goto LABEL_22;
          }
        }
        char v13 = 1;
      }
      else
      {
        char v13 = 0;
        v8 &= ~1u;
        a2[8] = v8;
        *a2 = 1;
      }
LABEL_22:
      if (v24)
      {
        int v14 = v23;
        uint64_t v23 = 0;
        if (v14) {
          (*(void (**)(const char *))(*(void *)v14 + 8))(v14);
        }
      }
      if ((v13 & 1) == 0) {
        goto LABEL_5;
      }
    }
    char v13 = 0;
    int v12 = v23;
    uint64_t v23 = 0;
    goto LABEL_21;
  }
  char v7 = a2[8] | 1;
LABEL_4:
  a2[8] = v7;
  *(void *)a2 = v6;
LABEL_5:
  if (v28 != v30) {
    free(v28);
  }
  return sub_1CC1EAF44((uint64_t)v31);
}

unsigned __int8 *llvm::MetadataLoader::MetadataLoaderImpl::lazyLoadOneMDString(llvm::MetadataLoader::MetadataLoaderImpl *this, unsigned int a2)
{
  if (*((_DWORD *)this + 2) <= a2 || (long long v4 = *(unsigned __int8 **)(*(void *)this + 8 * a2)) == 0)
  {
    uint64_t v5 = *((void *)this + 75) + 16 * a2;
    long long v4 = (unsigned __int8 *)llvm::MDString::get(*((uint64_t **)this + 26), *(unsigned __int8 **)v5, *(void *)(v5 + 8));
    sub_1CC1F2468((uint64_t)this, v4, a2);
  }
  return v4;
}

char ***llvm::MetadataLoader::operator=(char ***a1, char ***a2)
{
  int v3 = *a2;
  *a2 = 0;
  long long v4 = *a1;
  *a1 = v3;
  if (v4)
  {
    uint64_t v5 = sub_1CC1F5168(v4);
    MEMORY[0x1D25D9CE0](v5, 0x10F0C4004B5578BLL);
  }
  return a1;
}

uint64_t llvm::MetadataLoader::setStripTBAA(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)this + 968) = a2;
  return this;
}

void sub_1CD4F9BD8()
{
}

_DWORD *sub_1CD4F9C48@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int v14 = 0;
  uint64_t result = (_DWORD *)sub_1CD4F9D04(a1, a2, &v14);
  char v7 = v14;
  if (result)
  {
    uint64_t v8 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v9 = 1;
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v9 = *(unsigned int *)(a1 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 4 * v9;
  }
  else
  {
    uint64_t result = sub_1CD4F9DB4((_DWORD *)a1, (uint64_t)a2, a2, v14);
    char v7 = result;
    _DWORD *result = *a2;
    uint64_t v12 = a1 + 8;
    if (*(unsigned char *)a1)
    {
      uint64_t v13 = 1;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v13 = *(unsigned int *)(a1 + 16);
    }
    uint64_t v11 = v12 + 4 * v13;
    char v10 = 1;
  }
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v11;
  *(unsigned char *)(a3 + 16) = v10;
  return result;
}

uint64_t sub_1CD4F9D04(uint64_t a1, _DWORD *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 1;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      char v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (37 * *a2) & (v4 - 1);
  char v7 = (_DWORD *)(v3 + 4 * v6);
  int v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    char v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -2;
      }
      if (v12) {
        char v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      char v7 = (_DWORD *)(v3 + 4 * (v13 & v5));
      int v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      char v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_DWORD *sub_1CD4F9DB4(_DWORD *a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v6 = *a1 >> 1;
  if (*a1) {
    unsigned int v7 = 1;
  }
  else {
    unsigned int v7 = a1[4];
  }
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - a1[1] > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD4F9E74((uint64_t)a1, v7);
  uint64_t v9 = 0;
  sub_1CD4F9D04((uint64_t)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  *a1 += 2;
  if (*a4 != -1) {
    --a1[1];
  }
  return a4;
}

uint64_t sub_1CD4F9E74(uint64_t a1, unsigned int a2)
{
  if (a2 >= 2)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  int v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v7 = *(_DWORD **)(a1 + 8);
    uint64_t v8 = *(unsigned int *)(a1 + 16);
    if (a2 > 1)
    {
      uint64_t v12 = a2;
      *(void *)(a1 + 8) = operator new(4 * a2, (std::align_val_t)4uLL);
      *(void *)(a1 + 16) = v12;
    }
    else
    {
      *(_DWORD *)a1 = v6 | 1;
    }
    sub_1CD4F9F98(a1, v7, &v7[v8]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = (uint64_t *)&v13;
  if (*(_DWORD *)(a1 + 8) <= 0xFFFFFFFD)
  {
    int v13 = *(_DWORD *)(a1 + 8);
    uint64_t v9 = &v14;
  }
  if (a2 >= 2)
  {
    *(_DWORD *)a1 = v6 & 0xFFFFFFFE;
    uint64_t v10 = a2;
    *(void *)(a1 + 8) = operator new(4 * a2, (std::align_val_t)4uLL);
    *(void *)(a1 + 16) = v10;
  }
  return sub_1CD4F9F98(a1, &v13, v9);
}

uint64_t sub_1CD4F9F98(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    size_t v9 = 4;
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_6;
    }
    uint64_t v8 = *(void **)(result + 8);
    size_t v9 = 4 * v7;
  }
  uint64_t result = (uint64_t)memset(v8, 255, v9);
LABEL_6:
  while (a2 != a3)
  {
    if (*a2 <= 0xFFFFFFFD)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CD4F9D04((uint64_t)v5, a2, &v10);
      *uint64_t v10 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

_DWORD *sub_1CD4FA050(_DWORD *a1)
{
  int v2 = *a1;
  if (*a1 > 1u)
  {
    if (v2)
    {
      uint64_t result = a1 + 2;
      uint64_t v7 = a1 + 3;
LABEL_10:
      while (*result >= 0xFFFFFFFE)
      {
        if (++result == v7) {
          return v7;
        }
      }
    }
    else
    {
      uint64_t result = (_DWORD *)*((void *)a1 + 1);
      uint64_t v6 = a1[4];
      if (v6)
      {
        uint64_t v7 = &result[v6];
        goto LABEL_10;
      }
    }
  }
  else
  {
    if (v2)
    {
      unint64_t v3 = a1 + 2;
      uint64_t v4 = 1;
    }
    else
    {
      unint64_t v3 = (_DWORD *)*((void *)a1 + 1);
      uint64_t v4 = a1[4];
    }
    return &v3[v4];
  }
  return result;
}

void *sub_1CD4FA0C4(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v16 = 0;
  uint64_t result = (void *)sub_1CD4FA190(a2, *a3, &v16);
  size_t v9 = v16;
  if (result)
  {
    uint64_t v10 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v11 = 1;
    }
    else
    {
      uint64_t v10 = *(void *)(a2 + 8);
      uint64_t v11 = *(unsigned int *)(a2 + 16);
    }
    char v12 = 0;
    uint64_t v13 = v10 + 16 * v11;
  }
  else
  {
    uint64_t result = sub_1CD4FA23C((_DWORD *)a2, a3, v16);
    size_t v9 = result;
    void *result = *a3;
    result[1] = *a4;
    uint64_t v14 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v15 = 1;
    }
    else
    {
      uint64_t v14 = *(void *)(a2 + 8);
      uint64_t v15 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v13 = v14 + 16 * v15;
    char v12 = 1;
  }
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v13;
  *(unsigned char *)(a1 + 16) = v12;
  return result;
}

uint64_t sub_1CD4FA190(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 1;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 16 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 16 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD4FA23C(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD4FA2FC((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD4FA190((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD4FA2FC(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 2)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  int v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(uint64_t **)(a1 + 8);
    uint64_t v8 = *(unsigned int *)(a1 + 16);
    if (a2 > 1)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 = v6 | 1;
    }
    sub_1CD4FA46C(a1, v7, &v7[2 * v8]);
    JUMPOUT(0x1D25D9CD0);
  }
  size_t v9 = v14;
  if ((*(void *)(a1 + 8) | 0x1000) != 0xFFFFFFFFFFFFF000)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    v14[0] = *(void *)(a1 + 8);
    v14[1] = v10;
    size_t v9 = &v15;
  }
  if (a2 >= 2)
  {
    *(_DWORD *)a1 = v6 & 0xFFFFFFFE;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD4FA46C(a1, v14, v9);
}

uint64_t sub_1CD4FA46C(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    size_t v9 = (void *)(result + 24);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    size_t v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      BOOL v12 = 0;
      uint64_t result = sub_1CD4FA190((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *BOOL v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

void *sub_1CD4FA538(void *result)
{
  int64x2_t v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  unsigned int v3 = (*(_DWORD *)result >> 1) - 1;
  int v4 = 1 << (33 - __clz(v3));
  if (v3 >= 0x10) {
    int v5 = v4;
  }
  else {
    int v5 = 64;
  }
  if (v2 >= 2) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 0;
  }
  if ((v2 & 1) != 0 && v6 < 2)
  {
    uint64_t v7 = result + 1;
    void *result = 1;
    uint64_t v8 = result + 3;
    do
    {
LABEL_10:
      void *v7 = -4096;
      v7 += 2;
    }
    while (v7 != v8);
    return result;
  }
  if ((v2 & 1) == 0)
  {
    if (v6 == *((_DWORD *)result + 4))
    {
      void *result = 0;
      if (!v6) {
        return result;
      }
      uint64_t v7 = (void *)result[1];
      uint64_t v8 = &v7[2 * v6];
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](result[1], 8);
  }

  return sub_1CC1F41E8(v1, v6);
}

void *sub_1CD4FA610(_DWORD *a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4FA190((uint64_t)a1, *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD4FA674(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4FA674(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD4FA734((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD4FA190((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

void sub_1CD4FA734(uint64_t a1, unsigned int a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a2 >= 2)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  int v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(uint64_t **)(a1 + 8);
    uint64_t v8 = *(unsigned int *)(a1 + 16);
    if (a2 > 1)
    {
      uint64_t v12 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v12;
    }
    else
    {
      *(_DWORD *)a1 = v6 | 1;
    }
    sub_1CD4FA8A8(a1, v7, &v7[2 * v8]);
    JUMPOUT(0x1D25D9CD0);
  }
  size_t v9 = v13;
  if ((*(void *)(a1 + 8) | 0x1000) != 0xFFFFFFFFFFFFF000)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    v13[0] = *(void *)(a1 + 8);
    v13[1] = v10;
    size_t v9 = &v14;
    *(void *)(a1 + 16) = 0;
  }
  if (a2 >= 2)
  {
    *(_DWORD *)a1 = v6 & 0xFFFFFFFE;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  sub_1CD4FA8A8(a1, v13, v9);
}

void sub_1CD4FA8A8(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(a1 + 8);
    size_t v9 = (void *)(a1 + 24);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (!v7) {
      goto LABEL_11;
    }
    uint64_t v8 = *(void **)(a1 + 8);
    size_t v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_11:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v15 = 0;
      sub_1CD4FA190(a1, v10, &v15);
      uint64_t v12 = v15;
      *uint64_t v15 = *a2;
      uint64_t v13 = a2[1];
      a2[1] = 0;
      v12[1] = v13;
      *(_DWORD *)a1 += 2;
      uint64_t v14 = (llvm::MDNode *)a2[1];
      a2[1] = 0;
      if (v14) {
        llvm::MDNode::deleteTemporary(v14, v11);
      }
    }
    a2 += 2;
  }
}

uint64_t sub_1CD4FA988(uint64_t a1, llvm::MDNode *a2)
{
  unint64_t v3 = *(llvm::MDNode **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v3) {
    llvm::MDNode::deleteTemporary(v3, a2);
  }
  if (*(void *)a1) {
    llvm::MetadataTracking::untrack(a1, *(unsigned __int8 **)a1);
  }
  return a1;
}

void sub_1CD4FA9CC(uint64_t a1, llvm::MDNode *a2)
{
  unsigned int v3 = *(_DWORD *)a1;
  sub_1CC1F4310(a1, a2);
  unsigned int v4 = (v3 >> 1) - 1;
  int v5 = 1 << (33 - __clz(v4));
  if (v4 >= 0x10) {
    int v6 = v5;
  }
  else {
    int v6 = 64;
  }
  if (v3 >= 2) {
    unsigned int v7 = v6;
  }
  else {
    unsigned int v7 = 0;
  }
  if ((*(_DWORD *)a1 & 1) != 0 && v7 < 2)
  {
    uint64_t v8 = (void *)(a1 + 8);
    *(void *)a1 = 1;
    size_t v9 = (void *)(a1 + 24);
    do
    {
LABEL_10:
      void *v8 = -4096;
      v8 += 2;
    }
    while (v8 != v9);
    return;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    if (v7 == *(_DWORD *)(a1 + 16))
    {
      *(void *)a1 = 0;
      if (!v7) {
        return;
      }
      uint64_t v8 = *(void **)(a1 + 8);
      size_t v9 = &v8[2 * v7];
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }

  sub_1CC1F41E8((void *)a1, v7);
}

void *sub_1CD4FAAAC(void *result)
{
  int64x2_t v1 = result;
  int v2 = *(_DWORD *)result;
  if (*(_DWORD *)result > 1u || *((_DWORD *)result + 1))
  {
    if (v2)
    {
      int v5 = result + 1;
      size_t v6 = 4;
      goto LABEL_9;
    }
    unsigned int v3 = (2 * v2) & 0xFFFFFFFC;
    uint64_t v4 = *((unsigned int *)result + 4);
    if (v3 >= v4 || v4 < 0x41)
    {
      if (!v4)
      {
LABEL_10:
        _DWORD *v1 = v4;
        v1[1] = 0;
        return result;
      }
      int v5 = (void *)result[1];
      size_t v6 = 4 * v4;
LABEL_9:
      uint64_t result = memset(v5, 255, v6);
      LODWORD(v4) = *v1 & 1;
      goto LABEL_10;
    }
    return sub_1CD4FAB4C(result);
  }
  return result;
}

void *sub_1CD4FAB4C(void *result)
{
  int64x2_t v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  unsigned int v3 = (*(_DWORD *)result >> 1) - 1;
  int v4 = 1 << (33 - __clz(v3));
  if (v3 >= 0x10) {
    int v5 = v4;
  }
  else {
    int v5 = 64;
  }
  if (v2 >= 2) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 0;
  }
  if ((v2 & 1) != 0 && v6 < 2)
  {
    void *result = 1;
    unsigned int v7 = result + 1;
    size_t v8 = 4;
LABEL_10:
    return memset(v7, 255, v8);
  }
  if ((v2 & 1) == 0)
  {
    if (v6 == *((_DWORD *)result + 4))
    {
      void *result = 0;
      if (!v6) {
        return result;
      }
      unsigned int v7 = (void *)result[1];
      size_t v8 = 4 * v6;
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](result[1], 4);
  }

  return sub_1CC1F4390(v1, v6);
}

llvm *sub_1CD4FAC38(llvm *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  if (a3 != 3)
  {
    uint64_t v22 = result;
    unint64_t v6 = *(void *)(a4 + 8);
    if (a3)
    {
      if (a3 != 1)
      {
        if (a3 != 2)
        {
          llvm::BitcodeErrorCategory(result);
          operator new();
        }
        goto LABEL_18;
      }
    }
    else
    {
      unint64_t v7 = v6 - 3;
      if (v6 >= 3)
      {
        size_t v8 = *(void **)a4;
        if (*(void *)(*(void *)a4 + 8 * v7) == 157) {
          v8[v7] = 4096;
        }
        goto LABEL_10;
      }
    }
    if (!v6)
    {
LABEL_17:
      *(unsigned char *)(a2 + 971) = 1;
LABEL_18:
      if (!v6)
      {
LABEL_46:
        uint64_t v21 = a5[2];
        *(void *)a4 = *(void *)a5;
        *(void *)(a4 + 8) = v21;
        uint64_t result = v22;
        goto LABEL_2;
      }
      uint64_t v10 = *(void **)a4;
      while (1)
      {
        uint64_t v11 = *v10;
        if (*v10 > 0x22uLL || ((1 << *v10) & 0x410010000) == 0)
        {
          if (v11 == 4096)
          {
            if (v6 >= 3) {
              uint64_t v14 = 3;
            }
            else {
              uint64_t v14 = v6;
            }
            uint64_t v15 = v10 + 1;
LABEL_37:
            unint64_t v18 = a5[2];
            if (v18 >= a5[3]) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            int v17 = a5;
            *(void *)(*(void *)a5 + 8 * v18) = v11;
            goto LABEL_39;
          }
          unint64_t v13 = 1;
        }
        else
        {
          unint64_t v13 = 2;
        }
        if (v13 >= v6) {
          uint64_t v14 = v6;
        }
        else {
          uint64_t v14 = v13;
        }
        uint64_t v15 = v10 + 1;
        if (v11 == 28)
        {
          unint64_t v19 = a5[2];
          if (v19 >= a5[3]) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a5 + 8 * v19) = 16;
          ++a5[2];
          sub_1CBFCBB74(a5, (unsigned char *)v10 + 8, &v10[v14]);
          unint64_t v20 = a5[2];
          if (v20 >= a5[3]) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a5 + 8 * v20) = 28;
          ++a5[2];
          goto LABEL_40;
        }
        if (v11 != 34) {
          goto LABEL_37;
        }
        unint64_t v16 = a5[2];
        if (v16 >= a5[3]) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        int v17 = a5;
        *(void *)(*(void *)a5 + 8 * v16) = 35;
LABEL_39:
        ++v17[2];
        sub_1CBFCBB74(v17, v15, &v10[v14]);
LABEL_40:
        v10 += v14;
        v6 -= v14;
        if (!v6) {
          goto LABEL_46;
        }
      }
    }
    size_t v8 = *(void **)a4;
LABEL_10:
    if (*v8 == 6)
    {
      size_t v9 = (char *)&v8[v6];
      if (v6 >= 3 && *((void *)v9 - 3) == 4096) {
        v9 -= 24;
      }
      if (v9 != (char *)(v8 + 1))
      {
        memmove(v8, v8 + 1, v9 - (char *)(v8 + 1));
        unint64_t v6 = *(void *)(a4 + 8);
      }
      *((void *)v9 - 1) = 6;
    }
    goto LABEL_17;
  }
LABEL_2:
  *(void *)uint64_t result = 0;
  return result;
}

uint64_t sub_1CD4FAF80(uint64_t result, unsigned __int8 ***a2, unsigned __int8 ***a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 8);
  if (v4 >= *(_DWORD *)(result + 12))
  {
    sub_1CD4FB018();
  }
  int v5 = (unsigned __int8 **)(*(void *)result + 16 * v4);
  unint64_t v6 = *a3;
  unint64_t v7 = **a2;
  void *v5 = v7;
  if (v7)
  {
    uint64_t result = llvm::MetadataTracking::track((uint64_t)v5, v7, 2);
    LODWORD(v4) = *(_DWORD *)(v3 + 8);
  }
  size_t v8 = *v6;
  const char *v6 = 0;
  v5[1] = v8;
  *(_DWORD *)(v3 + 8) = v4 + 1;
  return result;
}

void sub_1CD4FB018()
{
}

uint64_t sub_1CD4FB0E0(uint64_t result, unsigned __int8 **a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  if (v2)
  {
    uint64_t v4 = result;
    int v5 = *(unsigned __int8 ***)result;
    uint64_t v6 = 16 * v2;
    do
    {
      *a2 = *v5;
      unint64_t v7 = *v5;
      if (*v5)
      {
        uint64_t result = llvm::MetadataTracking::retrack((uint64_t)v5, v7, (uint64_t)a2);
        void *v5 = 0;
      }
      size_t v8 = v5[1];
      v5[1] = 0;
      a2[1] = v8;
      v5 += 2;
      a2 += 2;
      v6 -= 16;
    }
    while (v6);
    uint64_t v9 = *(unsigned int *)(v4 + 8);
    if (v9)
    {
      uint64_t v10 = *(void *)v4;
      uint64_t v11 = 16 * v9;
      uint64_t v12 = v10 - 16;
      do
      {
        uint64_t result = sub_1CD4FA988(v12 + v11, (llvm::MDNode *)v7);
        v11 -= 16;
      }
      while (v11);
    }
  }
  return result;
}

void *sub_1CD4FB17C(_DWORD *a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CD46DBEC((uint64_t)a1, *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD4FB1E0(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD4FB1E0(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 16;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD4FB2A0((uint64_t)a1, v6);
  size_t v8 = 0;
  sub_1CD46DBEC((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD4FB2A0(uint64_t a1, unsigned int a2)
{
  v14[32] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x11)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 0x10)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD4FB438(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t *v9 = v10;
      v9[1] = *(void *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 256);
  if (a2 > 0x10)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD4FB438(a1, v14, v9);
}

uint64_t sub_1CD4FB438(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 264);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CD46DBEC((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *uint64_t v12 = *a2;
      v11[1] = a2[1];
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

char **sub_1CD4FB504@<X0>(uint64_t *a1@<X0>, std::string *a2@<X8>)
{
  v8[6] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = 0x200000000;
  uint64_t v5 = *a1;
  int v6 = (std::string *)v8;
  *a1 = 0;
  unint64_t v4 = (char **)&v6;
  sub_1CC1F4A68(&v5, (uint64_t *)&v4);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  sub_1CD4FB688(v6, &v6[v7], "\n", 1uLL, a2);
  return sub_1CBFCD310((char **)&v6);
}

void sub_1CD4FB5E0(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a2 + 24))(__p, a2);
  unint64_t v3 = sub_1CBFCD38C(v2, (unint64_t)__p, 1);
  uint64_t v4 = *(void *)v2 + 24 * *(unsigned int *)(v2 + 8);
  long long v5 = *(_OWORD *)v3;
  *(void *)(v4 + 16) = *(void *)(v3 + 16);
  *(_OWORD *)uint64_t v4 = v5;
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)unint64_t v3 = 0;
  ++*(_DWORD *)(v2 + 8);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

std::string *sub_1CD4FB688@<X0>(std::string *result@<X0>, std::string *a2@<X1>, const std::string::value_type *a3@<X2>, std::string::size_type a4@<X3>, std::string *a5@<X8>)
{
  a5->__r_.__value_.__r.__words[0] = 0;
  a5->__r_.__value_.__l.__size_ = 0;
  a5->__r_.__value_.__r.__words[2] = 0;
  if (result != a2)
  {
    uint64_t v8 = result;
    std::string::size_type v10 = (0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)result) >> 3) - 1) * a4;
    uint64_t v11 = result;
    do
    {
      if (SHIBYTE(v11->__r_.__value_.__r.__words[2]) < 0) {
        std::string::size_type size = v11->__r_.__value_.__l.__size_;
      }
      else {
        std::string::size_type size = HIBYTE(v11->__r_.__value_.__r.__words[2]);
      }
      v10 += size;
      ++v11;
    }
    while (v11 != a2);
    std::string::reserve(a5, v10);
    while (1)
    {
      char v13 = HIBYTE(v8->__r_.__value_.__r.__words[2]);
      BOOL v14 = v13 < 0;
      uint64_t v15 = v13 >= 0
          ? (const std::string::value_type *)v8
          : (const std::string::value_type *)v8->__r_.__value_.__r.__words[0];
      std::string::size_type v16 = v13 & 0x7F;
      std::string::size_type v17 = v14 ? v8->__r_.__value_.__l.__size_ : v16;
      uint64_t result = std::string::append(a5, v15, v17);
      if (++v8 == a2) {
        break;
      }
      std::string::append(a5, a3, a4);
    }
  }
  return result;
}

uint64_t sub_1CD4FB76C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 16);
  uint64_t v4 = (void *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((v3 & 4) != 0) {
    uint64_t v4 = (void *)*v4;
  }
  uint64_t v5 = llvm::MetadataAsValue::get((uint64_t)v4, (unsigned __int8 *)a2);

  return LLVMSetArgOperand_0(a1, 2u, v5);
}

void llvm::BitcodeWriter::BitcodeWriter(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void llvm::BitcodeWriter::~BitcodeWriter(llvm::BitcodeWriter *this)
{
  uint64_t v2 = (void *)*((void *)this + 21);
  if (v2)
  {
    *((void *)this + 22) = v2;
    operator delete(v2);
  }
  sub_1CBFFBA64((uint64_t)this + 64);
  llvm::StringTableBuilder::~StringTableBuilder((llvm::BitcodeWriter *)((char *)this + 16));
  uint64_t v3 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v3)
  {
    uint64_t v4 = sub_1CC20BB44(v3);
    MEMORY[0x1D25D9CE0](v4, 0x1020C40DD110337);
  }
}

void llvm::BitcodeWriter::writeBlob(uint64_t a1, unsigned int a2, unsigned int a3, const char *a4, uint64_t a5)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  sub_1CC1F77A4(*(void *)(a1 + 8), a2, 3u);
  uint64_t v9 = (char *)operator new(0x228uLL);
  *(void *)uint64_t v9 = &unk_1F2608A00;
  *((void *)v9 + 1) = 0;
  *(_OWORD *)(v9 + 72) = 0u;
  *(_OWORD *)(v9 + 88) = 0u;
  *(_OWORD *)(v9 + 104) = 0u;
  *(_OWORD *)(v9 + 120) = 0u;
  *(_OWORD *)(v9 + 136) = 0u;
  *(_OWORD *)(v9 + 152) = 0u;
  *(_OWORD *)(v9 + 168) = 0u;
  *(_OWORD *)(v9 + 184) = 0u;
  *(_OWORD *)(v9 + 200) = 0u;
  *(_OWORD *)(v9 + 216) = 0u;
  *(_OWORD *)(v9 + 232) = 0u;
  *(_OWORD *)(v9 + 248) = 0u;
  *(_OWORD *)(v9 + 264) = 0u;
  *(_OWORD *)(v9 + 280) = 0u;
  *(_OWORD *)(v9 + 296) = 0u;
  *(_OWORD *)(v9 + 312) = 0u;
  *(_OWORD *)(v9 + 328) = 0u;
  *(_OWORD *)(v9 + 344) = 0u;
  *(_OWORD *)(v9 + 360) = 0u;
  *(_OWORD *)(v9 + 376) = 0u;
  *(_OWORD *)(v9 + 392) = 0u;
  *(_OWORD *)(v9 + 408) = 0u;
  *(_OWORD *)(v9 + 424) = 0u;
  *(_OWORD *)(v9 + 440) = 0u;
  *(_OWORD *)(v9 + 456) = 0u;
  *(_OWORD *)(v9 + 472) = 0u;
  *(_OWORD *)(v9 + 488) = 0u;
  *(_OWORD *)(v9 + 504) = 0u;
  *(_OWORD *)(v9 + 520) = 0u;
  *(_OWORD *)(v9 + 536) = 0u;
  uint64_t v10 = a3;
  *((void *)v9 + 5) = a3;
  *((void *)v9 + 2) = 0;
  *((void *)v9 + 3) = v9 + 40;
  *((_OWORD *)v9 + 3) = xmmword_1CFAC6550;
  *((void *)v9 + 8) = 10;
  *((void *)v9 + 4) = 0x2000000002;
  uint64_t v11 = *(void *)(a1 + 8);
  unint64_t v18 = v9 + 24;
  unint64_t v19 = (atomic_ullong *)v9;
  unsigned int v12 = sub_1CC1F7CDC(v11, (uint64_t)&v18);
  char v13 = (std::__shared_weak_count *)v19;
  if (v19 && !atomic_fetch_add(v19 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v17 = v10;
    uint64_t v15 = v13;
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::string::size_type v16 = v15;
    uint64_t v10 = v17;
    std::__shared_weak_count::__release_weak(v16);
  }
  BOOL v14 = *(llvm::raw_ostream **)(a1 + 8);
  v20[0] = v10;
  sub_1CC206E90(v14, v12, (uint64_t)v20, 1, a4, a5, 0);
  sub_1CC1F7D44(*(void *)(a1 + 8));
}

void llvm::BitcodeWriter::writeSymtab(llvm::BitcodeWriter *this)
{
  uint64_t v2 = (char *)*((void *)this + 21);
  uint64_t v3 = (uint64_t *)*((void *)this + 22);
  if (v2 == (char *)v3)
  {
    uint64_t v4 = (llvm::Module **)*((void *)this + 21);
LABEL_8:
    *((unsigned char *)this + 161) = 1;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    __p = v17;
    llvm::irsymtab::build(v4, (v2 - (char *)v4) >> 3, (uint64_t *)&__p, (uint64_t)this + 16, (uint64_t *)this + 8, v12);
    if (v12[0])
    {
      uint64_t v11 = (void *)v12[0];
      v12[0] = 0;
      sub_1CD4515D0(&v11);
      if (v11) {
        (*(void (**)(void *))(*v11 + 8))(v11);
      }
      if (v12[0]) {
        (*(void (**)(uint64_t))(*(void *)v12[0] + 8))(v12[0]);
      }
    }
    else
    {
      llvm::BitcodeWriter::writeBlob((uint64_t)this, 0x19u, 1u, (const char *)__p, v15);
    }
    if (__p != v17) {
      free(__p);
    }
  }
  else
  {
    while (1)
    {
      uint64_t v5 = *(void *)v2;
      if (*(char *)(*(void *)v2 + 111) < 0 ? *(void *)(v5 + 96) : *(unsigned __int8 *)(*(void *)v2 + 111))
      {
        uint64_t v10 = v3;
        char v7 = v2;
        v18[0] = 0;
        v18[1] = 0;
        uint64_t v19 = 0;
        __int16 v13 = 260;
        v12[0] = v5 + 216;
        llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)v12);
        uint64_t v8 = llvm::TargetRegistry::lookupTarget((std::string::size_type)&__p, (uint64_t)v18);
        if (v8) {
          BOOL v9 = v8[14] == 0;
        }
        else {
          BOOL v9 = 1;
        }
        if (SHIBYTE(v16) < 0) {
          operator delete(__p);
        }
        if (SHIBYTE(v19) < 0) {
          operator delete(v18[0]);
        }
        uint64_t v2 = v7;
        uint64_t v3 = v10;
        if (v9) {
          break;
        }
      }
      v2 += 8;
      if (v2 == (char *)v3)
      {
        uint64_t v4 = (llvm::Module **)*((void *)this + 21);
        uint64_t v2 = (char *)*((void *)this + 22);
        goto LABEL_8;
      }
    }
  }
}

uint64_t llvm::BitcodeWriter::writeModule(uint64_t a1, const llvm::Module *a2, int a3, void *a4, char a5, uint64_t a6)
{
  v27[13] = *MEMORY[0x1E4F143B8];
  v22[0] = (uint64_t)a2;
  unsigned int v12 = *(const llvm::Module ***)(a1 + 176);
  if ((unint64_t)v12 < *(void *)(a1 + 184))
  {
    *unsigned int v12 = a2;
    __int16 v13 = v12 + 1;
  }
  else
  {
    __int16 v13 = sub_1CBC13470((void **)(a1 + 168), v22);
  }
  *(void *)(a1 + 176) = v13;
  uint64_t v14 = a1 + 16;
  uint64_t v16 = *(void **)a1;
  uint64_t v15 = *(void *)(a1 + 8);
  sub_1CC203630((uint64_t)v22, a2, v14, v15, a3, a4);
  v24[5] = v16;
  char v25 = a5;
  uint64_t v26 = a6;
  double v17 = llvm::SHA1::init((llvm::SHA1 *)v27);
  unint64_t v18 = *(void **)(v15 + 8);
  uint64_t v19 = *(void *)(*(void *)v15 + 8);
  if (v18) {
    uint64_t v20 = (*(uint64_t (**)(void, double))(*v18 + 80))(*(void *)(v15 + 8), v17) + v18[4] - v18[2];
  }
  else {
    uint64_t v20 = 0;
  }
  v27[12] = *(unsigned int *)(v15 + 24) + 8 * (v20 + v19);
  sub_1CC1F7F40(v22);
  sub_1CD3C5048((uint64_t)v24, v24[1]);
  return sub_1CC215420((uint64_t)&v23);
}

void llvm::WriteBitcodeToFile()
{
  v3[24] = *MEMORY[0x1E4F143B8];
  unint64_t v1 = 0;
  uint64_t v2 = 0;
  v0 = (char *)v3;
  llvm::SmallVectorBase<unsigned long long>::grow_pod();
}

void llvm::writeIndexToFile()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  v0 = &v3;
  llvm::SmallVectorBase<unsigned long long>::grow_pod();
}

uint64_t llvm::BitcodeWriter::writeThinLinkBitcode(uint64_t a1, llvm::raw_ostream *a2, void *a3, void *a4)
{
  v105[32] = *MEMORY[0x1E4F143B8];
  v95 = a2;
  uint64_t v8 = *(llvm::raw_ostream ***)(a1 + 176);
  if ((unint64_t)v8 >= *(void *)(a1 + 184))
  {
    BOOL v9 = sub_1CBC13470((void **)(a1 + 168), &v95);
  }
  else
  {
    uint64_t *v8 = a2;
    BOOL v9 = v8 + 1;
  }
  *(void *)(a1 + 176) = v9;
  sub_1CC203630((uint64_t)&v95, a2, a1 + 16, *(void *)(a1 + 8), 0, a3);
  v100 = a4;
  sub_1CC1F77A4((uint64_t)v95, 8u, 3u);
  uint64_t v101 = 2;
  v103 = &v101;
  uint64_t v104 = 1;
  sub_1CC206B4C(v95, 1u, &v103);
  v103 = v105;
  uint64_t v104 = 0x4000000000;
  uint64_t v10 = *(unsigned __int8 **)(v97 + 192);
  char v11 = *(unsigned char *)(v97 + 215);
  int v12 = v11;
  if (v11 >= 0) {
    uint64_t v10 = (unsigned __int8 *)(v97 + 192);
  }
  uint64_t v13 = *(void *)(v97 + 200);
  uint64_t v14 = v11 & 0x7F;
  if (v12 >= 0) {
    uint64_t v13 = v14;
  }
  if (v13)
  {
    LOBYTE(v39) = 1;
    uint64_t v16 = 2;
    uint64_t v15 = 8;
    while (1)
    {
      int v40 = *v10;
      BOOL v41 = (v40 - 48) >= 0xA && (v40 & 0xFFFFFFDF) - 65 >= 0x1A;
      BOOL v42 = !v41 || v40 == 46;
      BOOL v43 = v42 || v40 == 95;
      BOOL v44 = v43;
      BOOL v39 = v39 && v44;
      if ((v40 & 0x80) != 0) {
        break;
      }
      ++v10;
      if (!--v13)
      {
        if (v39) {
          goto LABEL_9;
        }
        uint64_t v16 = 2;
        uint64_t v15 = 7;
        break;
      }
    }
  }
  else
  {
LABEL_9:
    uint64_t v15 = 0;
    uint64_t v16 = 8;
  }
  double v17 = (char *)operator new(0x228uLL);
  *(void *)double v17 = &unk_1F2608A00;
  *((void *)v17 + 1) = 0;
  *(_OWORD *)(v17 + 88) = 0u;
  *(_OWORD *)(v17 + 104) = 0u;
  *(_OWORD *)(v17 + 120) = 0u;
  *(_OWORD *)(v17 + 136) = 0u;
  *(_OWORD *)(v17 + 152) = 0u;
  *(_OWORD *)(v17 + 168) = 0u;
  *(_OWORD *)(v17 + 184) = 0u;
  *(_OWORD *)(v17 + 200) = 0u;
  *(_OWORD *)(v17 + 216) = 0u;
  *(_OWORD *)(v17 + 232) = 0u;
  *(_OWORD *)(v17 + 248) = 0u;
  *(_OWORD *)(v17 + 264) = 0u;
  *(_OWORD *)(v17 + 280) = 0u;
  *(_OWORD *)(v17 + 296) = 0u;
  *(_OWORD *)(v17 + 312) = 0u;
  *(_OWORD *)(v17 + 328) = 0u;
  *(_OWORD *)(v17 + 344) = 0u;
  *(_OWORD *)(v17 + 360) = 0u;
  *(_OWORD *)(v17 + 376) = 0u;
  *(_OWORD *)(v17 + 392) = 0u;
  *(_OWORD *)(v17 + 408) = 0u;
  *(_OWORD *)(v17 + 424) = 0u;
  *(_OWORD *)(v17 + 440) = 0u;
  *(_OWORD *)(v17 + 456) = 0u;
  *(_OWORD *)(v17 + 472) = 0u;
  *(_OWORD *)(v17 + 488) = 0u;
  *(_OWORD *)(v17 + 504) = 0u;
  *(_OWORD *)(v17 + 520) = 0u;
  *(_OWORD *)(v17 + 536) = 0u;
  *(_OWORD *)(v17 + 40) = xmmword_1CFAC6700;
  *((void *)v17 + 2) = 0;
  *((void *)v17 + 3) = v17 + 40;
  *(_OWORD *)(v17 + 56) = xmmword_1CFAC6570;
  *((void *)v17 + 9) = v15;
  *((void *)v17 + 10) = v16;
  *((void *)v17 + 4) = 0x2000000003;
  uint64_t v101 = (uint64_t)(v17 + 24);
  v102 = (std::__shared_weak_count *)v17;
  unsigned int v18 = sub_1CC1F7CDC((uint64_t)v95, (uint64_t)&v101);
  uint64_t v19 = v102;
  if (v102 && !atomic_fetch_add(&v102->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  if (*(char *)(v97 + 215) < 0)
  {
    uint64_t v20 = *(unsigned __int8 **)(v97 + 192);
    uint64_t v21 = *(void *)(v97 + 200);
  }
  else
  {
    uint64_t v20 = (unsigned __int8 *)(v97 + 192);
    uint64_t v21 = *(unsigned __int8 *)(v97 + 215);
  }
  if (v21)
  {
    unsigned int v45 = v104;
    do
    {
      if (v45 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v45) = *v20;
      unsigned int v45 = v104 + 1;
      LODWORD(v104) = v104 + 1;
      ++v20;
      --v21;
    }
    while (v21);
  }
  sub_1CC2059BC(v95, 0x10u, (uint64_t)&v103, v18);
  LODWORD(v104) = 0;
  uint64_t v22 = (void *)v97;
  uint64_t v23 = v97 + 8;
  uint64_t v24 = *(void *)(v97 + 16);
  if (v24 != v97 + 8)
  {
    do
    {
      if (v24) {
        char v25 = (llvm::Value *)(v24 - 56);
      }
      else {
        char v25 = 0;
      }
      uint64_t v26 = v96;
      Name = llvm::Value::getName(v25);
      unsigned int v29 = v28;
      unsigned int v30 = sub_1CD0B03C8(Name, (uint64_t)&Name[v28]);
      int v31 = llvm::StringTableBuilder::add(v26, (uint64_t)Name, v29 | ((unint64_t)v30 << 32));
      if (v104 >= (unint64_t)HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v104) = v31;
      LODWORD(v104) = v104 + 1;
      unsigned int v32 = v104;
      llvm::Value::getName(v25);
      if (v32 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v32) = v33;
      unsigned int v34 = v104 + 1;
      LODWORD(v104) = v34;
      if (v34 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v34) = 0;
      unsigned int v35 = v104 + 1;
      LODWORD(v104) = v35;
      if (v35 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v35) = 0;
      unsigned int v36 = v104 + 1;
      LODWORD(v104) = v36;
      if (v36 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v36) = 0;
      unsigned int v37 = v104 + 1;
      LODWORD(v104) = v37;
      int v38 = dword_1CFAC680C[*((_DWORD *)v25 + 8) & 0xF];
      if (v37 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v37) = v38;
      LODWORD(v104) = v104 + 1;
      sub_1CC2059BC(v95, 7u, (uint64_t)&v103, 0);
      LODWORD(v104) = 0;
      uint64_t v24 = *(void *)(v24 + 8);
    }
    while (v24 != v23);
    uint64_t v22 = (void *)v97;
  }
  v46 = v22 + 3;
  v47 = (void *)v22[4];
  if (v47 != v22 + 3)
  {
    do
    {
      if (v47) {
        v48 = (llvm::Value *)(v47 - 7);
      }
      else {
        v48 = 0;
      }
      uint64_t v49 = v96;
      v50 = llvm::Value::getName(v48);
      unsigned int v52 = v51;
      unsigned int v53 = sub_1CD0B03C8(v50, (uint64_t)&v50[v51]);
      int v54 = llvm::StringTableBuilder::add(v49, (uint64_t)v50, v52 | ((unint64_t)v53 << 32));
      if (v104 >= (unint64_t)HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v104) = v54;
      LODWORD(v104) = v104 + 1;
      unsigned int v55 = v104;
      llvm::Value::getName(v48);
      if (v55 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v55) = v56;
      unsigned int v57 = v104 + 1;
      LODWORD(v104) = v57;
      if (v57 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v57) = 0;
      unsigned int v58 = v104 + 1;
      LODWORD(v104) = v58;
      if (v58 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v58) = 0;
      unsigned int v59 = v104 + 1;
      LODWORD(v104) = v59;
      if (v59 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v59) = 0;
      unsigned int v60 = v104 + 1;
      LODWORD(v104) = v60;
      int v61 = dword_1CFAC680C[*((_DWORD *)v48 + 8) & 0xF];
      if (v60 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v60) = v61;
      LODWORD(v104) = v104 + 1;
      sub_1CC2059BC(v95, 8u, (uint64_t)&v103, 0);
      LODWORD(v104) = 0;
      v47 = (void *)v47[1];
    }
    while (v47 != v46);
    uint64_t v22 = (void *)v97;
  }
  v62 = v22 + 5;
  v63 = (void *)v22[6];
  if (v63 != v22 + 5)
  {
    do
    {
      if (v63) {
        v64 = (llvm::Value *)(v63 - 6);
      }
      else {
        v64 = 0;
      }
      uint64_t v65 = v96;
      v66 = llvm::Value::getName(v64);
      unsigned int v68 = v67;
      unsigned int v69 = sub_1CD0B03C8(v66, (uint64_t)&v66[v67]);
      int v70 = llvm::StringTableBuilder::add(v65, (uint64_t)v66, v68 | ((unint64_t)v69 << 32));
      if (v104 >= (unint64_t)HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v104) = v70;
      LODWORD(v104) = v104 + 1;
      unsigned int v71 = v104;
      llvm::Value::getName(v64);
      if (v71 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v71) = v72;
      unsigned int v73 = v104 + 1;
      LODWORD(v104) = v73;
      if (v73 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v73) = 0;
      unsigned int v74 = v104 + 1;
      LODWORD(v104) = v74;
      if (v74 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v74) = 0;
      unsigned int v75 = v104 + 1;
      LODWORD(v104) = v75;
      if (v75 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v75) = 0;
      unsigned int v76 = v104 + 1;
      LODWORD(v104) = v76;
      int v77 = dword_1CFAC680C[*((_DWORD *)v64 + 8) & 0xF];
      if (v76 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v76) = v77;
      LODWORD(v104) = v104 + 1;
      sub_1CC2059BC(v95, 0xEu, (uint64_t)&v103, 0);
      LODWORD(v104) = 0;
      v63 = (void *)v63[1];
    }
    while (v63 != v62);
    uint64_t v22 = (void *)v97;
  }
  v78 = v22 + 7;
  v79 = (void *)v22[8];
  if (v79 != v22 + 7)
  {
    do
    {
      if (v79) {
        v81 = (llvm::Value *)(v79 - 7);
      }
      else {
        v81 = 0;
      }
      uint64_t v82 = v96;
      v83 = llvm::Value::getName(v81);
      unsigned int v85 = v84;
      unsigned int v86 = sub_1CD0B03C8(v83, (uint64_t)&v83[v84]);
      int v87 = llvm::StringTableBuilder::add(v82, (uint64_t)v83, v85 | ((unint64_t)v86 << 32));
      if (v104 >= (unint64_t)HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v104) = v87;
      LODWORD(v104) = v104 + 1;
      unsigned int v88 = v104;
      llvm::Value::getName(v81);
      if (v88 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v88) = v89;
      unsigned int v90 = v104 + 1;
      LODWORD(v104) = v90;
      if (v90 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v90) = 0;
      unsigned int v91 = v104 + 1;
      LODWORD(v104) = v91;
      if (v91 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v91) = 0;
      unsigned int v92 = v104 + 1;
      LODWORD(v104) = v92;
      if (v92 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v92) = 0;
      unsigned int v93 = v104 + 1;
      LODWORD(v104) = v93;
      int v94 = dword_1CFAC680C[*((_DWORD *)v81 + 8) & 0xF];
      if (v93 >= HIDWORD(v104)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v103 + v93) = v94;
      LODWORD(v104) = v104 + 1;
      sub_1CC2059BC(v95, 0x12u, (uint64_t)&v103, 0);
      LODWORD(v104) = 0;
      v79 = (void *)v79[1];
    }
    while (v79 != v78);
  }
  if (v103 != v105) {
    free(v103);
  }
  sub_1CC20392C((off_t *)&v95);
  v103 = v100;
  uint64_t v104 = 5;
  sub_1CC216CB4((uint64_t)v95, (uint64_t)&v103);
  sub_1CC1F7D44((off_t)v95);
  sub_1CD3C5048((uint64_t)v99, v99[1]);
  return sub_1CC215420((uint64_t)&v98);
}

void llvm::writeThinLinkBitcodeToFile()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  v0 = &v3;
  llvm::SmallVectorBase<unsigned long long>::grow_pod();
}

void llvm::embedBitcodeInModule(llvm::Type **a1, llvm::LLVMContext *a2, int a3, int a4, uint64_t a5)
{
  v77[2] = *MEMORY[0x1E4F143B8];
  unsigned int v75 = (llvm::Type *)v77;
  uint64_t v76 = 0x200000000;
  int v72 = (llvm::Value **)v74;
  uint64_t v73 = 0x400000000;
  Int8Ty = (llvm::Type *)llvm::Type::getInt8Ty(*a1, a2);
  PointerTo = (llvm::Constant *)llvm::Type::getPointerTo(Int8Ty, 0);
  uint64_t v57 = (uint64_t)a1;
  uint64_t v8 = (llvm::GlobalVariable *)llvm::collectUsedGlobalVariables((uint64_t)a1, (uint64_t)&v72, 1);
  if (v73)
  {
    uint64_t v9 = 8 * v73;
    uint64_t v10 = v72;
    do
    {
      char v11 = *v10;
      Name = llvm::Value::getName(*v10);
      if (v13 == 12)
      {
        if (*(void *)Name != 0x646D632E6D766C6CLL || *((_DWORD *)Name + 2) != 1701734764)
        {
LABEL_18:
          PointerBitCastOrAddrSpaceCast = llvm::ConstantExpr::getPointerBitCastOrAddrSpaceCast(v11, PointerTo, v14);
          if (v76 >= (unint64_t)HIDWORD(v76)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v75 + v76) = PointerBitCastOrAddrSpaceCast;
          LODWORD(v76) = v76 + 1;
        }
      }
      else
      {
        if (v13 != 20) {
          goto LABEL_18;
        }
        BOOL v15 = *(void *)Name == 0x626D652E6D766C6CLL && *((void *)Name + 1) == 0x6F6D2E6465646465;
        if (!v15 || *((_DWORD *)Name + 4) != 1701606756) {
          goto LABEL_18;
        }
      }
      ++v10;
      v9 -= 8;
    }
    while (v9);
  }
  if (v8) {
    llvm::GlobalVariable::eraseFromParent(v8);
  }
  v70[0] = 0;
  v70[1] = 0;
  uint64_t v71 = 0;
  LOWORD(v62) = 260;
  unsigned int v58 = (const char *)(v57 + 216);
  llvm::Triple::Triple((llvm::Triple *)&__p, (const llvm::Twine *)&v58);
  if (a3)
  {
    uint64_t v20 = (llvm::Type *)*((void *)a2 + 1);
    if (!v20
      || (uint64_t v21 = *(unsigned __int8 **)a2, !sub_1CC2021B8(*(unsigned __int8 **)a2, (unsigned __int8 *)v20 + *(void *)a2)))
    {
      int v59 = 0;
      char v63 = 0;
      uint64_t v64 = 0;
      v66 = v70;
      int v65 = 0;
      unsigned int v58 = (const char *)&unk_1F2646F30;
      uint64_t v60 = 0;
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      llvm::WriteBitcodeToFile();
    }
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v20 = 0;
  }
  IntNTy = (llvm::ArrayType *)llvm::Type::getIntNTy(*(llvm::Type **)v57, (llvm::LLVMContext *)8, v19);
  uint64_t v23 = llvm::ArrayType::get(IntNTy, v20);
  Impl = llvm::ConstantDataSequential::getImpl(v21, v20, v23);
  char v25 = llvm::User::operator new((llvm::User *)0x58, 1u);
  uint64_t v26 = *(llvm::PointerType **)Impl;
  LOWORD(v62) = 257;
  __int16 v27 = llvm::GlobalVariable::GlobalVariable(v25, v57, v26, 1, 8, (unint64_t)Impl, &v58, 0, 0, 0, 0);
  if (v69 == 5) {
    size_t v28 = 16;
  }
  else {
    size_t v28 = 7;
  }
  if (v69 == 5) {
    unsigned int v29 = "__LLVM,__bitcode";
  }
  else {
    unsigned int v29 = ".llvmbc";
  }
  llvm::GlobalObject::setSection(v27, v29, v28);
  llvm::GlobalObject::setAlignment((uint64_t)v25, 256);
  int v31 = llvm::ConstantExpr::getPointerBitCastOrAddrSpaceCast((llvm::ConstantExpr *)v25, PointerTo, v30);
  if (v76 >= HIDWORD(v76)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v75 + v76) = v31;
  LODWORD(v76) = v76 + 1;
  GlobalVariable = (llvm::Value *)llvm::Module::getGlobalVariable(v57, "llvm.embedded.module", 0x14uLL, 1);
  if (GlobalVariable)
  {
    int v33 = GlobalVariable;
    llvm::Value::takeName((int32x2_t ****)v25, GlobalVariable);
    llvm::GlobalVariable::eraseFromParent(v33);
  }
  unsigned int v58 = "llvm.embedded.module";
  LOWORD(v62) = 259;
  llvm::Value::setName((llvm::Value *)v25, &v58);
  if (a4)
  {
    unsigned int v34 = *(unsigned char **)a5;
    unsigned int v35 = (llvm::Type *)(*(void *)(a5 + 8) - *(void *)a5);
    unsigned int v36 = (llvm::ArrayType *)llvm::Type::getIntNTy(*(llvm::Type **)v57, (llvm::LLVMContext *)8, v52);
    unsigned int v37 = llvm::ArrayType::get(v36, v35);
    int v38 = llvm::ConstantDataSequential::getImpl(v34, v35, v37);
    BOOL v39 = llvm::User::operator new((llvm::User *)0x58, 1u);
    int v40 = *(llvm::PointerType **)v38;
    LOWORD(v62) = 257;
    BOOL v41 = llvm::GlobalVariable::GlobalVariable(v39, v57, v40, 1, 8, (unint64_t)v38, &v58, 0, 0, 0, 0);
    if (v69 == 5) {
      size_t v42 = 16;
    }
    else {
      size_t v42 = 8;
    }
    if (v69 == 5) {
      BOOL v43 = "__LLVM,__cmdline";
    }
    else {
      BOOL v43 = ".llvmcmd";
    }
    llvm::GlobalObject::setSection(v41, v43, v42);
    llvm::GlobalObject::setAlignment((uint64_t)v39, 256);
    unsigned int v45 = llvm::ConstantExpr::getPointerBitCastOrAddrSpaceCast((llvm::ConstantExpr *)v39, PointerTo, v44);
    if (v76 >= HIDWORD(v76)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v75 + v76) = v45;
    LODWORD(v76) = v76 + 1;
    v46 = (llvm::Value *)llvm::Module::getGlobalVariable(v57, "llvm.cmdline", 0xCuLL, 1);
    if (v46)
    {
      v47 = v46;
      llvm::Value::takeName((int32x2_t ****)v39, v46);
      llvm::GlobalVariable::eraseFromParent(v47);
    }
    unsigned int v58 = "llvm.cmdline";
    LOWORD(v62) = 259;
    llvm::Value::setName((llvm::Value *)v39, &v58);
  }
  if (v76)
  {
    v48 = llvm::ArrayType::get(PointerTo, (llvm::Type *)v76);
    uint64_t v49 = llvm::User::operator new((llvm::User *)0x58, 1u);
    v50 = llvm::ConstantArray::get(v48, v75, v76);
    unsigned int v58 = "llvm.compiler.used";
    LOWORD(v62) = 259;
    uint64_t v51 = llvm::GlobalVariable::GlobalVariable(v49, v57, v48, 0, 6, (unint64_t)v50, &v58, 0, 0, 0, 0);
    llvm::GlobalObject::setSection(v51, "llvm.metadata", 0xDuLL);
  }
  if (v68 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v71) < 0) {
    operator delete(v70[0]);
  }
  if (v72 != (llvm::Value **)v74) {
    free(v72);
  }
  if (v75 != (llvm::Type *)v77) {
    free(v75);
  }
}

uint64_t **sub_1CD4FD4E8(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  int v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        char v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    char v7 = a1 + 1;
LABEL_9:
    uint64_t v9 = (uint64_t *)v7;
    char v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = *a3;
    *((_DWORD *)v7 + 10) = 0;
    char *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    std::string *v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    char v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      char v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t sub_1CD4FD5B8(uint64_t result, char *a2, uint64_t a3, int a4)
{
  uint64_t v6 = result;
  if (a4)
  {
    if (a3 >= 0x20)
    {
      unsigned int v8 = a3;
      do
      {
        sub_1CC202230(v6, v8 & 0x1F | 0x20, 6);
        unsigned int v7 = v8 >> 5;
        BOOL v9 = v8 > 0x3FF;
        v8 >>= 5;
      }
      while (v9);
    }
    else
    {
      unsigned int v7 = a3;
    }
    uint64_t result = sub_1CC202230(v6, v7, 6);
  }
  if (*(_DWORD *)(v6 + 24))
  {
    uint64_t result = (uint64_t)sub_1CC202350((const char ***)v6, *(_DWORD *)(v6 + 28));
    *(void *)(v6 + 24) = 0;
  }
  if (a3)
  {
    uint64_t v10 = 4 * a3;
    do
    {
      char v11 = *a2;
      a2 += 4;
      uint64_t result = (uint64_t)sub_1CC206A94((llvm::raw_ostream **)v6, v11);
      v10 -= 4;
    }
    while (v10);
  }
  while (1)
  {
    uint64_t v13 = *(void **)(v6 + 8);
    uint64_t v14 = *(void *)(*(void *)v6 + 8);
    if (v13)
    {
      uint64_t result = (*(uint64_t (**)(void))(*v13 + 80))(*(void *)(v6 + 8));
      uint64_t v12 = result + v13[4] - v13[2];
    }
    else
    {
      LOBYTE(v12) = 0;
    }
    if ((((_BYTE)v12 + (_BYTE)v14) & 3) == 0) {
      break;
    }
    uint64_t result = (uint64_t)sub_1CC206A94((llvm::raw_ostream **)v6, 0);
  }
  return result;
}

uint64_t sub_1CD4FD6D0(uint64_t result, char *a2, uint64_t a3, int a4)
{
  uint64_t v6 = result;
  if (a4)
  {
    if (a3 >= 0x20)
    {
      unsigned int v8 = a3;
      do
      {
        sub_1CC202230(v6, v8 & 0x1F | 0x20, 6);
        unsigned int v7 = v8 >> 5;
        BOOL v9 = v8 > 0x3FF;
        v8 >>= 5;
      }
      while (v9);
    }
    else
    {
      unsigned int v7 = a3;
    }
    uint64_t result = sub_1CC202230(v6, v7, 6);
  }
  if (*(_DWORD *)(v6 + 24))
  {
    uint64_t result = (uint64_t)sub_1CC202350((const char ***)v6, *(_DWORD *)(v6 + 28));
    *(void *)(v6 + 24) = 0;
  }
  if (a3)
  {
    uint64_t v10 = 8 * a3;
    do
    {
      char v11 = *a2;
      a2 += 8;
      uint64_t result = (uint64_t)sub_1CC206A94((llvm::raw_ostream **)v6, v11);
      v10 -= 8;
    }
    while (v10);
  }
  while (1)
  {
    uint64_t v13 = *(void **)(v6 + 8);
    uint64_t v14 = *(void *)(*(void *)v6 + 8);
    if (v13)
    {
      uint64_t result = (*(uint64_t (**)(void))(*v13 + 80))(*(void *)(v6 + 8));
      uint64_t v12 = result + v13[4] - v13[2];
    }
    else
    {
      LOBYTE(v12) = 0;
    }
    if ((((_BYTE)v12 + (_BYTE)v14) & 3) == 0) {
      break;
    }
    uint64_t result = (uint64_t)sub_1CC206A94((llvm::raw_ostream **)v6, 0);
  }
  return result;
}

uint64_t sub_1CD4FD7E8(uint64_t result, char *a2, char *a3)
{
  char v3 = a2;
  uint64_t v4 = *(unsigned int *)(result + 8);
  if (a3 - a2 + v4 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a3)
  {
    uint64_t v5 = (void *)(*(void *)result + 8 * v4);
    do
    {
      uint64_t v6 = *v3++;
      *v5++ = v6;
    }
    while (v3 != a3);
  }
  *(_DWORD *)(result + 8) = v4 + a3 - a2;
  return result;
}

uint64_t sub_1CD4FD868(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v6 = *(unsigned int *)(a3 + 8);
  sub_1CC202230(a1, 3u, *(_DWORD *)(a1 + 32));
  sub_1CC202230(a1, a2 & 0x1F | 0x20, 6);
  sub_1CC202230(a1, 1u, 6);
  unsigned int v7 = v6;
  if (v6 >= 0x20)
  {
    unsigned int v8 = v6;
    do
    {
      sub_1CC202230(a1, v8 & 0x1F | 0x20, 6);
      unsigned int v7 = v8 >> 5;
      BOOL v9 = v8 > 0x3FF;
      v8 >>= 5;
    }
    while (v9);
  }
  uint64_t result = sub_1CC202230(a1, v7, 6);
  if (v6)
  {
    uint64_t v11 = 0;
    uint64_t v12 = 8 * v6;
    do
    {
      uint64_t result = sub_1CC202E58(a1, *(void *)(*(void *)a3 + v11), 6);
      v11 += 8;
    }
    while (v12 != v11);
  }
  return result;
}

uint64_t sub_1CD4FD938(uint64_t result, char *a2, char *a3)
{
  char v3 = a2;
  uint64_t v4 = *(unsigned int *)(result + 8);
  if (v4 + ((a3 - a2) >> 2) > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a3)
  {
    uint64_t v5 = (void *)(*(void *)result + 8 * v4);
    do
    {
      unsigned int v6 = *(_DWORD *)v3;
      v3 += 4;
      *v5++ = v6;
    }
    while (v3 != a3);
  }
  *(_DWORD *)(result + 8) = v4 + ((unint64_t)(a3 - a2) >> 2);
  return result;
}

unsigned int *sub_1CD4FD9BC(unsigned int *result, uint64_t a2, char *a3, char *a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = *(void *)result;
  uint64_t v7 = result[2];
  if (*(void *)result + 8 * v7 == a2)
  {
    return (unsigned int *)sub_1CD4570C8((uint64_t)result, a3, a4);
  }
  else
  {
    uint64_t v8 = (a2 - v6) >> 3;
    unint64_t v9 = (a4 - a3) >> 3;
    if (v7 + v9 > result[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v10 = (char *)(v6 + 8 * v8);
    uint64_t v11 = (char *)(v6 + 8 * v7);
    unint64_t v12 = (v11 - v10) >> 3;
    if (v12 >= v9)
    {
      uint64_t result = (unsigned int *)sub_1CD4570C8((uint64_t)result, &v11[-8 * v9], (char *)(v6 + 8 * v7));
      if (&v11[-8 * v9] != v10) {
        uint64_t result = (unsigned int *)memmove(&v10[8 * v9], v10, &v11[-8 * v9] - v10);
      }
      if (a4 != v5)
      {
        return (unsigned int *)memmove(v10, v5, a4 - v5);
      }
    }
    else
    {
      unsigned int v13 = v7 + ((unint64_t)(a4 - a3) >> 3);
      result[2] = v13;
      if (v8 != v7)
      {
        uint64_t result = (unsigned int *)memcpy((void *)(v6 + 8 * v13 - 8 * v12), v10, v11 - v10);
        do
        {
          uint64_t v14 = *(void *)v5;
          v5 += 8;
          *(void *)uint64_t v10 = v14;
          v10 += 8;
          --v12;
        }
        while (v12);
      }
      while (v5 != a4)
      {
        uint64_t v15 = *(void *)v5;
        v5 += 8;
        *(void *)uint64_t v11 = v15;
        v11 += 8;
      }
    }
  }
  return result;
}

uint64_t sub_1CD4FDB50(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a2 < *a1;
  }
}

uint64_t sub_1CD4FDB6C(uint64_t a1, uint64_t a2)
{
  sub_1CC202230(a1, 3u, *(_DWORD *)(a1 + 32));
  sub_1CC202230(a1, 0x11u, 6);
  sub_1CC202230(a1, 5u, 6);
  for (uint64_t i = 0; i != 20; i += 4)
    uint64_t result = sub_1CC202E58(a1, *(unsigned int *)(a2 + i), 6);
  return result;
}

uint64_t sub_1CD4FDBE4(uint64_t result, char *a2, char *a3)
{
  char v3 = a2;
  uint64_t v4 = *(unsigned int *)(result + 8);
  if (a3 - a2 + v4 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a2 != a3)
  {
    uint64_t v5 = (_DWORD *)(*(void *)result + 4 * v4);
    do
    {
      int v6 = *v3++;
      *v5++ = v6;
    }
    while (v3 != a3);
    LODWORD(v4) = *(_DWORD *)(result + 8);
  }
  *(_DWORD *)(result + 8) = v4 + a3 - a2;
  return result;
}

void sub_1CD4FDC68(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2608A00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1CD4FDC88(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2608A00;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::BitcodeWriterPass::run(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 9)) {
    llvm::WriteBitcodeToFile();
  }
  llvm::AnalysisManager<llvm::Module>::getResultImpl();
}

void llvm::createBitcodeWriterPass(llvm *this, llvm::raw_ostream *a2)
{
}

BOOL llvm::isBitcodeWriterPass(llvm *this, llvm::Pass *a2)
{
  return *((void *)this + 2) == (void)&unk_1EBCC8CC8;
}

uint64_t llvm::ValueEnumerator::getComdatID(llvm::ValueEnumerator *this, const llvm::Comdat *a2)
{
  uint64_t v4 = (void *)*((void *)this + 16);
  uint64_t v2 = (char *)this + 128;
  char v3 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v2;
  do
  {
    unint64_t v6 = v3[4];
    BOOL v7 = v6 >= (unint64_t)a2;
    if (v6 >= (unint64_t)a2) {
      uint64_t v8 = v3;
    }
    else {
      uint64_t v8 = v3 + 1;
    }
    if (v7) {
      uint64_t v5 = (char *)v3;
    }
    char v3 = (void *)*v8;
  }
  while (*v8);
  if (v5 != v2 && *((void *)v5 + 4) <= (unint64_t)a2) {
    return *((unsigned int *)v5 + 10);
  }
  else {
    return 0;
  }
}

llvm *llvm::ValueEnumerator::dump(llvm::ValueEnumerator *this)
{
  uint64_t v2 = llvm::dbgs(this);
  char v3 = llvm::ValueEnumerator::print((int)v2, v2, (uint64_t)this + 72, "Default");
  uint64_t v4 = llvm::dbgs(v3);
  uint64_t v5 = (unsigned char *)*((void *)v4 + 4);
  if ((unint64_t)v5 >= *((void *)v4 + 3))
  {
    uint64_t v4 = llvm::raw_ostream::write(v4, 10);
  }
  else
  {
    *((void *)v4 + 4) = v5 + 1;
    unsigned char *v5 = 10;
  }
  unint64_t v6 = llvm::dbgs(v4);
  BOOL v7 = llvm::ValueEnumerator::print((int)v6, v6, (uint64_t)this + 216, "MetaData");
  uint64_t result = llvm::dbgs(v7);
  unint64_t v9 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v9 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v9 + 1;
    unsigned char *v9 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::ValueEnumerator::print(int a1, llvm::raw_ostream *a2, uint64_t a3, char *a4)
{
  BOOL v7 = sub_1CB8E509C(a2, "Map Name: ");
  uint64_t v8 = sub_1CB8E509C(v7, a4);
  sub_1CB8E509C(v8, "\n");
  unint64_t v9 = sub_1CB8E509C(a2, "Size: ");
  sub_1CD098D14(v9, *(unsigned int *)(a3 + 8), 0, 0, 0);
  uint64_t result = sub_1CB8E509C(v9, "\n");
  uint64_t v11 = *(void *)a3;
  uint64_t v12 = *(unsigned int *)(a3 + 16);
  uint64_t v13 = *(void *)a3 + 16 * v12;
  if (*(_DWORD *)(a3 + 8))
  {
    if (v12)
    {
      uint64_t v14 = 16 * v12;
      uint64_t v15 = *(void *)a3;
      while ((*(void *)v15 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v15 += 16;
        v14 -= 16;
        if (!v14) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v15 = *(void *)a3;
    }
  }
  else
  {
LABEL_6:
    uint64_t v15 = v13;
  }
  uint64_t v35 = v11 + 16 * v12;
  while (v15 != v35)
  {
    uint64_t v16 = *(llvm::Value **)v15;
    if ((*(unsigned char *)(*(void *)v15 + 23) & 0x10) != 0)
    {
      uint64_t v22 = sub_1CB8E509C(a2, "Value: ");
      Name = llvm::Value::getName(v16);
      size_t v25 = v23;
      double v17 = (void *)*((void *)v22 + 4);
      if (v23 <= *((void *)v22 + 3) - (void)v17)
      {
        if (v23)
        {
          double v17 = memcpy(v17, Name, v23);
          *((void *)v22 + 4) += v25;
        }
      }
      else
      {
        double v17 = llvm::raw_ostream::write(v22, Name, v23);
      }
    }
    else
    {
      double v17 = sub_1CB8E509C(a2, "Value: [null]\n");
    }
    unsigned int v18 = (llvm::raw_ostream *)llvm::errs((llvm *)v17);
    llvm::Value::print(v16, v18, 0);
    uint64_t v20 = (llvm::raw_ostream *)llvm::errs(v19);
    uint64_t v21 = (unsigned char *)*((void *)v20 + 4);
    if ((unint64_t)v21 >= *((void *)v20 + 3))
    {
      llvm::raw_ostream::write(v20, 10);
    }
    else
    {
      *((void *)v20 + 4) = v21 + 1;
      *uint64_t v21 = 10;
    }
    uint64_t v26 = sub_1CB8E509C(a2, " Uses(");
    unsigned int NumUses = llvm::Value::getNumUses(v16);
    sub_1CD098D14(v26, NumUses, 0, 0, 0);
    sub_1CB8E509C(v26, "):");
    for (uint64_t i = *((void *)v16 + 1); i; uint64_t i = *(void *)(i + 8))
    {
      if (i != *((void *)v16 + 1)) {
        sub_1CB8E509C(a2, ",");
      }
      if ((*(unsigned char *)(*(void *)i + 23) & 0x10) != 0)
      {
        unsigned int v29 = sub_1CB8E509C(a2, " ");
        int v31 = llvm::Value::getName(*(llvm::Value **)i);
        size_t v32 = v30;
        int v33 = (void *)*((void *)v29 + 4);
        if (v30 <= *((void *)v29 + 3) - (void)v33)
        {
          if (v30)
          {
            memcpy(v33, v31, v30);
            *((void *)v29 + 4) += v32;
          }
        }
        else
        {
          llvm::raw_ostream::write(v29, v31, v30);
        }
      }
      else
      {
        sub_1CB8E509C(a2, " [null]");
      }
    }
    uint64_t result = sub_1CB8E509C(a2, "\n\n");
    uint64_t v34 = v15 + 16;
    uint64_t v15 = v13;
    if (v34 != v13)
    {
      uint64_t v15 = v34;
      while ((*(void *)v15 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v15 += 16;
        if (v15 == v13)
        {
          uint64_t v15 = v13;
          break;
        }
      }
    }
  }
  return result;
}

{
  llvm::raw_ostream *v7;
  llvm::raw_ostream *v8;
  llvm::raw_ostream *v9;
  llvm::raw_ostream *result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  llvm::Metadata *v14;
  llvm::raw_ostream *v15;
  llvm::raw_ostream *v16;

  BOOL v7 = sub_1CB8E509C(a2, "Map Name: ");
  uint64_t v8 = sub_1CB8E509C(v7, a4);
  sub_1CB8E509C(v8, "\n");
  unint64_t v9 = sub_1CB8E509C(a2, "Size: ");
  sub_1CD098D14(v9, *(unsigned int *)(a3 + 8), 0, 0, 0);
  uint64_t result = sub_1CB8E509C(v9, "\n");
  uint64_t v11 = *(unsigned int *)(a3 + 16);
  if (*(_DWORD *)(a3 + 8))
  {
    if (v11)
    {
      uint64_t v12 = 16 * v11;
      uint64_t v13 = *(void *)a3;
      while ((*(void *)v13 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v13 += 16;
        v12 -= 16;
        if (!v12) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v13 = *(void *)a3;
    }
  }
  else
  {
LABEL_6:
    uint64_t v13 = *(void *)a3 + 16 * v11;
  }
  if (v13 != *(void *)a3 + 16 * v11)
  {
    uint64_t v14 = *(llvm::Metadata **)v13;
    uint64_t v15 = sub_1CB8E509C(a2, "Metadata: slot = ");
    sub_1CD098D14(v15, *(unsigned int *)(v13 + 12), 0, 0, 0);
    sub_1CB8E509C(v15, "\n");
    uint64_t v16 = sub_1CB8E509C(a2, "Metadata: function = ");
    sub_1CD098D14(v16, *(unsigned int *)(v13 + 8), 0, 0, 0);
    sub_1CB8E509C(v16, "\n");
    llvm::Metadata::print(v14, a2, 0);
  }
  return result;
}

void llvm::ValueEnumerator::EnumerateFunctionLocalMetadata(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v11 = a3;
  unint64_t v6 = sub_1CC21DDF8((uint64_t *)(a1 + 216), &v11);
  if (!*((_DWORD *)v6 + 3))
  {
    BOOL v7 = v6;
    uint64_t v8 = *(uint64_t **)(a1 + 176);
    if ((unint64_t)v8 >= *(void *)(a1 + 184))
    {
      unint64_t v9 = sub_1CBF63C18((void **)(a1 + 168), a3);
    }
    else
    {
      uint64_t *v8 = a3;
      unint64_t v9 = v8 + 1;
    }
    *(void *)(a1 + 176) = v9;
    unint64_t v10 = ((unint64_t)v9 - *(void *)(a1 + 168)) >> 3;
    *((_DWORD *)v7 + 2) = a2;
    *((_DWORD *)v7 + 3) = v10;
    llvm::ValueEnumerator::EnumerateValue((llvm::ValueEnumerator *)a1, *(const llvm::Value **)(a3 + 128));
  }
}

void *llvm::ValueEnumerator::EnumerateFunctionLocalListMetadata(llvm::ValueEnumerator *this, unsigned int a2, const llvm::Value ****a3)
{
  uint64_t v13 = (const llvm::DIArgList *)a3;
  uint64_t result = sub_1CC21DDF8((uint64_t *)this + 27, &v13);
  if (!*((_DWORD *)result + 3))
  {
    uint64_t v7 = (uint64_t)result;
    uint64_t v8 = *((unsigned int *)a3 + 8);
    if (v8)
    {
      unint64_t v9 = a3[3];
      uint64_t v10 = 8 * v8;
      do
      {
        if (*(unsigned char *)*v9 != 2) {
          llvm::ValueEnumerator::EnumerateMetadata((uint64_t)this, a2, *v9);
        }
        ++v9;
        v10 -= 8;
      }
      while (v10);
    }
    uint64_t v11 = (const llvm::Value *****)*((void *)this + 22);
    if ((unint64_t)v11 >= *((void *)this + 23))
    {
      uint64_t result = sub_1CBF63C18((void **)this + 21, (uint64_t)a3);
    }
    else
    {
      *uint64_t v11 = a3;
      uint64_t result = v11 + 1;
    }
    *((void *)this + 22) = result;
    unint64_t v12 = ((unint64_t)result - *((void *)this + 21)) >> 3;
    *(_DWORD *)(v7 + 8) = a2;
    *(_DWORD *)(v7 + 12) = v12;
  }
  return result;
}

_DWORD *sub_1CD4FE600(uint64_t a1, unint64_t *a2)
{
  uint64_t result = sub_1CD4FD4E8((uint64_t **)a1, *a2, (uint64_t **)a2);
  if (!result[10])
  {
    uint64_t v5 = result;
    unint64_t v6 = *(uint64_t **)(a1 + 32);
    unint64_t v7 = *(void *)(a1 + 40);
    v5[10] = (((unint64_t)v6 - *(void *)(a1 + 24)) >> 3) + 1;
    uint64_t v8 = *a2;
    if ((unint64_t)v6 >= v7)
    {
      uint64_t result = sub_1CBF63C18((void **)(a1 + 24), v8);
    }
    else
    {
      uint64_t *v6 = v8;
      uint64_t result = v6 + 1;
    }
    *(void *)(a1 + 32) = result;
  }
  return result;
}

uint64_t llvm::ValueEnumerator::getGlobalBasicBlockID(llvm::ValueEnumerator *this, const llvm::BasicBlock *a2)
{
  unint64_t v12 = a2;
  char v3 = (char *)this + 368;
  int v4 = *((_DWORD *)sub_1CC220ACC((uint64_t)this + 368, (uint64_t *)&v12) + 2);
  if (v4) {
    return (v4 - 1);
  }
  unint64_t v6 = v12;
  uint64_t v7 = *((void *)v12 + 7);
  uint64_t v8 = v7 + 72;
  uint64_t v9 = *(void *)(v7 + 80);
  if (v9 != v7 + 72)
  {
    int v10 = 1;
    do
    {
      uint64_t v11 = v9 - 24;
      if (!v9) {
        uint64_t v11 = 0;
      }
      uint64_t v13 = v11;
      *((_DWORD *)sub_1CD4FE87C((uint64_t)v3, &v13) + 2) = v10;
      uint64_t v9 = *(void *)(v9 + 8);
      ++v10;
    }
    while (v9 != v8);
    unint64_t v6 = v12;
  }
  return llvm::ValueEnumerator::getGlobalBasicBlockID(this, v6);
}

uint64_t llvm::ValueEnumerator::computeBitsRequiredForTypeIndicies(llvm::ValueEnumerator *this)
{
  return 32 - __clz((*((void *)this + 7) - *((void *)this + 6)) >> 3);
}

void *sub_1CD4FE74C(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD467E98(a1, a2, v7);
    void *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
    *((unsigned char *)v5 + 12) = 0;
  }
  return v5;
}

uint64_t sub_1CD4FE7C0(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5 = (uint64_t *)a1[1];
  if ((unint64_t)v5 < a1[2])
  {
    uint64_t *v5 = a2;
    v5[1] = a3;
    sub_1CD4FE810(v5 + 2, a4);
    uint64_t result = (uint64_t)(v5 + 5);
  }
  else
  {
    uint64_t result = sub_1CC21C364(a1, a2, a3, a4);
  }
  a1[1] = result;
  return result;
}

void *sub_1CD4FE810(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >> 62) {
      abort();
    }
    size_t v4 = 4 * a2;
    uint64_t v5 = (char *)operator new(4 * a2);
    *a1 = v5;
    unint64_t v6 = &v5[4 * a2];
    a1[2] = v6;
    bzero(v5, v4);
    a1[1] = v6;
  }
  return a1;
}

uint64_t *sub_1CD4FE87C(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBA0E618(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CBF8BBE8(a1, (uint64_t)a2, a2, v7);
    uint64_t *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

void sub_1CD4FE8E0(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    char v3 = (char *)a1[1];
    char v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = (void *)*((void *)v3 - 3);
        if (v5)
        {
          *((void *)v3 - 2) = v5;
          operator delete(v5);
        }
        v3 -= 40;
      }
      while (v3 != v1);
      char v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1CD4FE950(uint64_t a1, unsigned int a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a2 >= 2)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  int v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (a2 <= 1)
    {
      *(_DWORD *)a1 = v6 | 1;
    }
    else
    {
      uint64_t v12 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)4uLL);
      *(void *)(a1 + 16) = v12;
    }
    sub_1CC220464(a1, v10, v10 + 16 * v11);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v7 = (uint64_t *)&v13;
  if (*(_DWORD *)(a1 + 8) <= 0xFFFFFFFD)
  {
    int v13 = *(_DWORD *)(a1 + 8);
    uint64_t v14 = *(void *)(a1 + 12);
    int v15 = *(_DWORD *)(a1 + 20);
    uint64_t v7 = &v16;
  }
  if (a2 >= 2)
  {
    *(_DWORD *)a1 = v6 & 0xFFFFFFFE;
    uint64_t v8 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)4uLL);
    *(void *)(a1 + 16) = v8;
  }
  return sub_1CC220464(a1, (uint64_t)&v13, (uint64_t)v7);
}

void sub_1CD4FEACC(void **a1, unint64_t a2)
{
  int v5 = a1[1];
  unint64_t v4 = a1[2];
  if (a2 <= (v4 - (unsigned char *)v5) >> 4)
  {
    if (a2)
    {
      double v17 = &v5[4 * a2];
      do
      {
        *(void *)int v5 = 0;
        _OWORD v5[2] = 0;
        v5 += 4;
      }
      while (v5 != v17);
      int v5 = v17;
    }
    a1[1] = v5;
  }
  else
  {
    int v6 = *a1;
    uint64_t v7 = (char *)v5 - (unsigned char *)*a1;
    unint64_t v8 = a2 + (v7 >> 4);
    if (v8 >> 60) {
      abort();
    }
    uint64_t v9 = v4 - (unsigned char *)v6;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        sub_1CB833614();
      }
      uint64_t v11 = (char *)operator new(16 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v12 = &v11[16 * (v7 >> 4)];
    int v13 = &v12[16 * a2];
    uint64_t v14 = v12;
    do
    {
      *(void *)uint64_t v14 = 0;
      *((_DWORD *)v14 + 2) = 0;
      v14 += 16;
    }
    while (v14 != v13);
    int v15 = &v11[16 * v10];
    if (v5 == v6)
    {
      uint64_t v16 = &v11[16 * (v7 >> 4)];
    }
    else
    {
      do
      {
        uint64_t v16 = v12 - 16;
        *((_OWORD *)v12 - 1) = *((_OWORD *)v5 - 1);
        v5 -= 4;
        v12 -= 16;
      }
      while (v5 != v6);
    }
    unsigned int v18 = *a1;
    *a1 = v16;
    a1[1] = v13;
    a1[2] = v15;
    if (v18)
    {
      operator delete(v18);
    }
  }
}

void sub_1CD4FEC18(char **a1, unint64_t a2)
{
  int v5 = a1[1];
  unint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(a1[1], 8 * a2);
      v5 += 8 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    int v6 = *a1;
    uint64_t v7 = v5 - *a1;
    unint64_t v8 = a2 + (v7 >> 3);
    if (v8 >> 61) {
      abort();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 2 > v8) {
      unint64_t v8 = v9 >> 2;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 61) {
        sub_1CB833614();
      }
      uint64_t v11 = (char *)operator new(8 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v12 = &v11[8 * (v7 >> 3)];
    int v13 = &v11[8 * v10];
    bzero(v12, 8 * a2);
    if (v5 != v6)
    {
      do
      {
        uint64_t v14 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v12 - 1) = v14;
        v12 -= 8;
      }
      while (v5 != v6);
      int v5 = *a1;
    }
    *a1 = v12;
    a1[1] = &v11[8 * a2 + v7];
    a1[2] = v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

uint64_t llvm::BitstreamCursor::skipRecord@<X0>(llvm::BitstreamCursor *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (a2 == 3)
  {
    uint64_t result = sub_1CC2211F4((uint64_t)&v41, (uint64_t)this);
    if (v42)
    {
      unint64_t v14 = v41;
LABEL_17:
      *(unsigned char *)(a3 + 8) |= 1u;
      *(void *)a3 = v14;
      return result;
    }
    int v6 = v41;
    uint64_t result = sub_1CC2211F4((uint64_t)&v39, (uint64_t)this);
    if ((v40 & 1) == 0)
    {
      int v7 = v39;
      if (!v39)
      {
LABEL_7:
        *(unsigned char *)(a3 + 8) &= ~1u;
        *(_DWORD *)a3 = v6;
        return result;
      }
      while (1)
      {
        uint64_t result = sub_1CC221324((uint64_t)this, 6u, (uint64_t)&v37);
        if (v38) {
          break;
        }
        if (!--v7) {
          goto LABEL_7;
        }
      }
      unint64_t v14 = v37;
      goto LABEL_17;
    }
LABEL_65:
    unint64_t v14 = v39;
    goto LABEL_17;
  }
  uint64_t result = sub_1CC22157C((uint64_t)&v41, *((void *)this + 5), *((void *)this + 6), a2);
  unint64_t v8 = v41;
  if (v42)
  {
    *(unsigned char *)(a3 + 8) |= 1u;
    *(void *)a3 = v8;
    return result;
  }
  uint64_t v9 = *(uint64_t **)v41;
  unsigned int v10 = *(unsigned __int8 *)(*(void *)v41 + 8);
  if (v10)
  {
    uint64_t v15 = *v9;
  }
  else
  {
    int v11 = (v10 >> 1) & 7;
    if (v11 == 5 || v11 == 3)
    {
      *(void *)&v44.__val_ = std::generic_category();
      v44.__cat_ = (const std::error_category *)"Abbreviation starts with an Array or a Blob";
      llvm::createStringError((llvm *)0x5C, v44, v13);
    }
    uint64_t result = sub_1CC2215F8((uint64_t)this, (uint64_t)v9, (uint64_t)&v39);
    if (v40) {
      goto LABEL_65;
    }
    LODWORD(v15) = v39;
  }
  unsigned int v16 = *(_DWORD *)(v8 + 8);
  if (v16 <= 1)
  {
    LOBYTE(v17) = *(unsigned char *)(a3 + 8);
    goto LABEL_62;
  }
  int v17 = *(unsigned __int8 *)(a3 + 8);
  unsigned int v18 = 1;
  while (1)
  {
    uint64_t v19 = *(void *)v8 + 16 * v18;
    unsigned int v20 = *(unsigned __int8 *)(v19 + 8);
    if ((v20 & 1) == 0) {
      break;
    }
LABEL_42:
    if (++v18 >= v16) {
      goto LABEL_62;
    }
  }
  int v21 = (v20 >> 1) & 7;
  if (v21 != 3 && v21 != 5)
  {
    uint64_t result = sub_1CC2215F8((uint64_t)this, v19, (uint64_t)&v39);
    if ((v40 & 1) == 0) {
      goto LABEL_39;
    }
LABEL_48:
    unint64_t v26 = v39;
    goto LABEL_49;
  }
  if ((v20 & 0xE) != 6)
  {
    uint64_t result = sub_1CC2211F4((uint64_t)&v39, (uint64_t)this);
    if ((v40 & 1) == 0)
    {
      unsigned int v27 = *((_DWORD *)this + 8);
      BOOL v28 = v27 >= 0x20;
      char v29 = v27 - 32;
      if (v28)
      {
        *((void *)this + 3) >>= v29;
        uint64_t v31 = 32;
      }
      else
      {
        uint64_t v31 = 0;
      }
      uint64_t v32 = v39;
      *((_DWORD *)this + 8) = v31;
      uint64_t v33 = ((8 * v32 + 24) & 0xFFFFFFFE0) - v31;
      unint64_t v26 = *((void *)this + 1);
      unint64_t v34 = v33 + 8 * *((void *)this + 2);
      if (v26 < v34 >> 3)
      {
        *((void *)this + 2) = v26;
        LODWORD(v26) = 5;
        goto LABEL_40;
      }
      uint64_t result = sub_1CC1CE1A8((uint64_t)this, v34, &v37);
      unint64_t v26 = v37;
      if (!v37) {
        goto LABEL_40;
      }
      goto LABEL_49;
    }
    goto LABEL_48;
  }
  uint64_t result = sub_1CC2211F4((uint64_t)&v39, (uint64_t)this);
  if (v40)
  {
    unint64_t v30 = v39;
    v17 |= 1u;
    *(unsigned char *)(a3 + 8) = v17;
    *(void *)a3 = v30;
    unint64_t v39 = 0;
    goto LABEL_50;
  }
  int v23 = v39;
  uint64_t v24 = *(void *)v8 + 16 * ++v18;
  int v25 = (*(unsigned __int8 *)(v24 + 8) >> 1) & 7;
  switch(v25)
  {
    case 1:
      unint64_t v35 = *(void *)v24 * v39 - *((unsigned int *)this + 8) + 8 * *((void *)this + 2);
      break;
    case 4:
      unint64_t v35 = (6 * v39) + 8 * *((void *)this + 2) - *((unsigned int *)this + 8);
      break;
    case 2:
      if (!v39) {
        goto LABEL_39;
      }
      while (1)
      {
        uint64_t result = sub_1CC221324((uint64_t)this, *(_DWORD *)v24, (uint64_t)&v37);
        if (v38) {
          break;
        }
        if (!--v23) {
          goto LABEL_39;
        }
      }
      unint64_t v26 = v37;
      goto LABEL_49;
    default:
      *(void *)&v45.__val_ = std::generic_category();
      v45.__cat_ = (const std::error_category *)"Array element type can't be an Array or a Blob";
      llvm::createStringError((llvm *)0x5C, v45, v36);
  }
  uint64_t result = sub_1CC1CE1A8((uint64_t)this, v35, &v37);
  unint64_t v26 = v37;
  if (v37)
  {
LABEL_49:
    v17 |= 1u;
    *(unsigned char *)(a3 + 8) = v17;
    *(void *)a3 = v26;
LABEL_50:
    LODWORD(v26) = 1;
    goto LABEL_40;
  }
LABEL_39:
  LODWORD(v26) = 7;
LABEL_40:
  if (!v26 || v26 == 7) {
    goto LABEL_42;
  }
  if (v26 == 5)
  {
LABEL_62:
    *(unsigned char *)(a3 + 8) = v17 & 0xFE;
    *(_DWORD *)a3 = v15;
  }
  return result;
}

void sub_1CD4FF12C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  memset(__p, 0, sizeof(__p));
  int v6 = 0;
  char v10 = 0;
  uint64_t v11 = 0;
  int v13 = __p;
  int v12 = 0;
  int v5 = &unk_1F2646F30;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  v15[0] = &unk_1F2608AD8;
  v15[1] = "can't read more than %zu at a time, trying to read %u";
  v15[2] = a4;
  int v16 = a5;
  llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v5, (uint64_t)v15);
  operator new();
}

uint64_t sub_1CD4FF23C(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(void *)(a1 + 16), *(unsigned int *)(a1 + 24));
}

uint64_t sub_1CD4FF274(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 32;
      *(void *)(a1 + 16) = v2 - 32;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

std::string *llvm::cas::CacheKey::CacheKey(std::string *this, uint64_t a2)
{
  uint64_t v4 = *(const std::string::value_type **)(a2 + 8);
  if (v4)
  {
    std::string::__init(this, v4, *(void *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
    this->__r_.__value_.__r.__words[2] = 0;
  }
  return this;
}

void llvm::cas::getDefaultOnDiskActionCachePath(std::string *a1@<X8>)
{
  v13[16] = *MEMORY[0x1E4F143B8];
  __s = (std::string::value_type *)v13;
  *(_OWORD *)__sz = xmmword_1CFAC3020;
  if ((llvm::sys::path::cache_directory(&__s) & 1) == 0) {
    llvm::report_fatal_error((llvm *)"cannot get default cache directory", (const llvm::Twine *)1);
  }
  __int16 v10 = 261;
  v9[0] = "llvm.cas.builtin.default";
  v9[1] = (const char *)24;
  __int16 v8 = 261;
  v7[0] = "actioncache";
  v7[1] = (void *)11;
  __int16 v6 = 257;
  v4[16] = 257;
  llvm::sys::path::append(&__s, v9, v7, (uint64_t)v5, (uint64_t)v4);
  if (__s)
  {
    std::string::__init(a1, __s, __sz[0]);
    uint64_t v3 = __s;
    if (__s == (std::string::value_type *)v13) {
      return;
    }
  }
  else
  {
    uint64_t v3 = 0;
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
  }
  free(v3);
}

void llvm::cas::createInMemoryActionCache(llvm::cas *this)
{
}

void sub_1CD4FF4BC(uint64_t a1, uint64_t a2, llvm::Twine *this)
{
  llvm::Twine::str(this, __p);
  if (v7 >= 0) {
    int v5 = __p;
  }
  else {
    int v5 = (void **)__p[0];
  }
  uint64_t v9 = a1;
  uint64_t v10 = a2;
  __int16 v8 = v5;
  sub_1CD06481C();
}

void llvm::cas::builtin::BuiltinCAS::parseID(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5 = a3 - 10;
  if (a3 < 0xA
    || (*(void *)a2 == 0x3A7361636D766C6CLL ? (BOOL v6 = *(unsigned __int16 *)(a2 + 8) == 12079) : (BOOL v6 = 0), !v6))
  {
    uint64_t v11 = std::generic_category();
    __int16 v20 = 1283;
    v17[0] = (uint64_t)"invalid cas-id '";
    unsigned int v18 = (unsigned __int8 *)a2;
    uint64_t v19 = a3;
    v15[0] = (uint64_t)"'";
    __int16 v16 = 259;
    sub_1CB8F1E58(v17, v15, (uint64_t)v21);
    sub_1CD4FF4BC(22, (uint64_t)v11, (llvm::Twine *)v21);
  }
  char v7 = (unsigned __int8 *)(a2 + 10);
  if (a3 != 74)
  {
    int v12 = std::generic_category();
    __int16 v20 = 1283;
    v17[0] = (uint64_t)"wrong size for cas-id hash '";
    unsigned int v18 = (unsigned __int8 *)(a2 + 10);
    uint64_t v19 = v5;
    v15[0] = (uint64_t)"'";
    __int16 v16 = 259;
    sub_1CB8F1E58(v17, v15, (uint64_t)v21);
    sub_1CD4FF4BC(22, (uint64_t)v12, (llvm::Twine *)v21);
  }
  memset(&__p, 0, sizeof(__p));
  if (!sub_1CC223A40(v7, 0x40uLL, &__p))
  {
    int v13 = std::generic_category();
    __int16 v20 = 1283;
    v17[0] = (uint64_t)"invalid hash in cas-id '";
    unsigned int v18 = v7;
    uint64_t v19 = 64;
    v15[0] = (uint64_t)"'";
    __int16 v16 = 259;
    sub_1CB8F1E58(v17, v15, (uint64_t)v21);
    sub_1CD4FF4BC(22, (uint64_t)v13, (llvm::Twine *)v21);
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  (*(void (**)(uint64_t, std::string *, std::string::size_type))(*(void *)a1 + 136))(a1, p_p, size);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void llvm::cas::builtin::BuiltinCASContext::printIDImpl(llvm::cas::builtin::BuiltinCASContext *this, llvm::raw_ostream *a2, const llvm::cas::CASID *a3)
{
  void v7[8] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = v7;
  long long v6 = xmmword_1CD96DBD0;
  sub_1CC223B30(*((unsigned __int8 **)a3 + 1), *((void *)a3 + 2), 1, &v5);
  uint64_t v4 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v4) > 9)
  {
    *(_WORD *)(v4 + 8) = 12079;
    *(void *)uint64_t v4 = *(void *)"llvmcas://";
    *((void *)a2 + 4) += 10;
  }
  else
  {
    a2 = llvm::raw_ostream::write(a2, "llvmcas://", 0xAuLL);
  }
  llvm::raw_ostream::write(a2, (const char *)v5, v6);
  if (v5 != v7) {
    free(v5);
  }
}

uint64_t (**llvm::cas::builtin::BuiltinCASContext::getDefaultContext(llvm::cas::builtin::BuiltinCASContext *this))(llvm::cas::builtin::BuiltinCASContext *__hidden this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCC8CD8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCC8CD8))
  {
    __cxa_atexit((void (*)(void *))nullsub_1716, &off_1EC7DF9F0, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCC8CD8);
  }
  return &off_1EC7DF9F0;
}

void llvm::cas::builtin::BuiltinCAS::storeFromOpenFileImpl(llvm::sys::fs::file_status *a1@<X0>, llvm::sys::fs *this@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCC8CE8, memory_order_acquire) & 1) == 0)
  {
    int v17 = (llvm::sys::fs::mapped_file_region *)__cxa_guard_acquire(&qword_1EBCC8CE8);
    if (v17)
    {
      dword_1EBCC8CE0 = llvm::sys::fs::mapped_file_region::alignment(v17);
      __cxa_guard_release(&qword_1EBCC8CE8);
    }
  }
  unint64_t v9 = dword_1EBCC8CE0;
  if (*(unsigned char *)(a3 + 64)) {
    goto LABEL_3;
  }
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 56) = 0;
  *(_OWORD *)a3 = 0u;
  *(_DWORD *)(a3 + 44) = 0xFFFF;
  *(unsigned char *)(a3 + 64) = 1;
  int v12 = (llvm *)llvm::sys::fs::status(this, a3, (llvm::sys::fs::file_status *)a3);
  if (!v12)
  {
LABEL_3:
    int v10 = *(_DWORD *)(a3 + 40);
    BOOL v11 = v10 == 2 || v10 == 5;
    if (v11 && *(void *)(a3 + 32) >> 14)
    {
      LODWORD(v24) = 0;
      int v25 = std::system_category();
      llvm::sys::fs::mapped_file_region::mapped_file_region((uint64_t)&v21, (int)this, 0, *(void *)(a3 + 32), 0, (uint64_t *)&v24);
      if (v24)
      {
        *(void *)&v14.__val_ = v25;
        llvm::errorCodeToError(v24, v14, &v20);
        *(unsigned char *)(a5 + 8) |= 1u;
        *(void *)a5 = v20;
        uint64_t v20 = 0;
      }
      else
      {
        uint64_t v15 = (int *)llvm::sys::fs::mapped_file_region::data((llvm::sys::fs::mapped_file_region *)&v21);
        unint64_t v16 = llvm::sys::fs::mapped_file_region::size((llvm::sys::fs::mapped_file_region *)&v21);
        memset(v28, 0, sizeof(v28));
        sub_1CD4FFBC8((char *)v28, (uint64_t)a1, 0, 0, v15, v16);
        if ((v16 & ~(-1 << (63 - __clz(v9)))) != 0 && !*((unsigned char *)v15 + v16))
        {
          v18[0] = v21;
          v18[1] = v22;
          int v19 = v23;
          memset(v27, 0, sizeof(v27));
          uint64_t v21 = 0;
          uint64_t v22 = 0;
          int v23 = 0;
          llvm::sys::fs::mapped_file_region::unmapImpl((llvm::sys::fs::mapped_file_region *)v27);
          (*(void (**)(llvm::sys::fs::file_status *, _OWORD *, uint64_t, void *))(*(void *)a1 + 152))(a1, v28, 32, v18);
          llvm::sys::fs::mapped_file_region::unmapImpl((llvm::sys::fs::mapped_file_region *)v18);
        }
        else
        {
          (*(void (**)(llvm::sys::fs::file_status *, _OWORD *, uint64_t, void, void, int *, unint64_t))(*(void *)a1 + 144))(a1, v28, 32, 0, 0, v15, v16);
        }
      }
      llvm::sys::fs::mapped_file_region::unmapImpl((llvm::sys::fs::mapped_file_region *)&v21);
    }
    else
    {
      sub_1CC223BC8(a5, (uint64_t)this, (uint64_t)a1, a4);
    }
  }
  else
  {
    llvm::errorCodeToError(v12, v13, &v26);
    *(unsigned char *)(a5 + 8) |= 1u;
    *(void *)a5 = v26;
  }
}

unsigned __int8 *sub_1CD4FFBC8(char *a1, uint64_t a2, uint64_t *a3, unint64_t a4, int *a5, unint64_t a6)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  v12.n128_f64[0] = llvm_blake3_hasher_init((uint64_t)v19);
  unint64_t __src = a4;
  v13.n128_f64[0] = llvm_blake3_hasher_update((uint64_t)v19, (int *)&__src, 8uLL, v12);
  if (a4)
  {
    uint64_t v14 = 8 * a4;
    do
    {
      uint64_t v15 = *a3++;
      sub_1CD500428((uint64_t)v19, a2, v15);
      v14 -= 8;
    }
    while (v14);
  }
  unint64_t __src = a6;
  v16.n128_f64[0] = llvm_blake3_hasher_update((uint64_t)v19, (int *)&__src, 8uLL, v13);
  llvm_blake3_hasher_update((uint64_t)v19, a5, a6, v16);
  return llvm_blake3_hasher_finalize(v19, a1, 0x20uLL);
}

uint64_t llvm::cas::builtin::BuiltinCAS::store(uint64_t a1, uint64_t *a2, unint64_t a3, int *a4, unint64_t a5)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  sub_1CD4FFBC8(v11, a1, a2, a3, a4, a5);
  return (*(uint64_t (**)(uint64_t, char *, uint64_t, uint64_t *, unint64_t, int *, unint64_t))(*(void *)a1 + 144))(a1, v11, 32, a2, a3, a4, a5);
}

void llvm::cas::builtin::BuiltinCAS::validate(llvm::cas::builtin::BuiltinCAS *this@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(llvm::cas::builtin::BuiltinCAS *))(*(void *)this + 32))(this);
  if (!v7)
  {
    sub_1CD500040((uint64_t)a3, (llvm::cas::CASID *)a2);
  }
  (*(void (**)(uint64_t *__return_ptr, llvm::cas::builtin::BuiltinCAS *, uint64_t))(*(void *)this + 48))(&v25, this, v6);
  if (v26)
  {
    *a3 = v25;
  }
  else
  {
    uint64_t v8 = v25;
    uint64_t v22 = v24;
    uint64_t v23 = 0x600000000;
    *(void *)&long long v20 = &v22;
    (*(void (**)(llvm::cas::builtin::BuiltinCAS *, uint64_t, uint64_t *(*)@<X0>(uint64_t *@<X0>, uint64_t@<X1>, void *@<X8>), long long *))(*(void *)this + 64))(this, v25, sub_1CC223DBC, &v20);
    if (!*a3)
    {
      int v10 = (int *)(*(uint64_t (**)(llvm::cas::builtin::BuiltinCAS *, uint64_t, void))(*(void *)this + 88))(this, v8, 0);
      (*(void (**)(llvm::cas::builtin::BuiltinCAS *, uint64_t, void))(*(void *)this + 88))(this, v8, 0);
      long long v20 = 0u;
      long long v21 = 0u;
      sub_1CD4FFBC8((char *)&v20, (uint64_t)this, (uint64_t *)v22, v23, v10, v11);
      if (a2[2] != (uint64_t *)32) {
        goto LABEL_27;
      }
      uint64_t v12 = a2[1];
      uint64_t v13 = *v12;
      uint64_t v14 = v12[1];
      uint64_t v16 = v12[2];
      uint64_t v15 = v12[3];
      BOOL v17 = v13 == (void)v20 && v14 == *((void *)&v20 + 1);
      BOOL v18 = v17 && v16 == (void)v21;
      if (!v18 || v15 != *((void *)&v21 + 1)) {
LABEL_27:
      }
        sub_1CD500130((uint64_t)a3, (llvm::cas::CASID *)a2);
      *a3 = 0;
    }
    if (v22 != v24) {
      free(v22);
    }
    if (v26)
    {
      uint64_t v9 = v25;
      uint64_t v25 = 0;
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
    }
  }
}

void sub_1CD500040(uint64_t a1, llvm::cas::CASID *a2)
{
  uint64_t v3 = std::generic_category();
  llvm::cas::CASID::toString(a2, &v8);
  uint64_t v4 = std::string::insert(&v8, 0, "unknown object '");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = std::string::append(&v9, "'");
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  std::string::size_type v11 = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  __int16 v13 = 260;
  uint64_t v12 = __p;
  sub_1CD4FF4BC(22, (uint64_t)v3, (llvm::Twine *)&v12);
}

void sub_1CD500130(uint64_t a1, llvm::cas::CASID *a2)
{
  uint64_t v3 = std::generic_category();
  llvm::cas::CASID::toString(a2, &v8);
  uint64_t v4 = std::string::insert(&v8, 0, "corrupt object '");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = std::string::append(&v9, "'");
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  std::string::size_type v11 = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  __int16 v13 = 260;
  uint64_t v12 = __p;
  sub_1CD4FF4BC(22, (uint64_t)v3, (llvm::Twine *)&v12);
}

uint64_t sub_1CD500220(uint64_t a1)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
  return v1;
}

uint64_t sub_1CD50025C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 160))();
}

uint64_t sub_1CD500280(uint64_t a1, uint64_t a2, uint64_t a3, llvm::sys::fs::mapped_file_region *this)
{
  uint64_t v8 = llvm::sys::fs::mapped_file_region::data(this);
  uint64_t v9 = llvm::sys::fs::mapped_file_region::size(this);
  int v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void, uint64_t, uint64_t))(*(void *)a1 + 144);

  return v10(a1, a2, a3, 0, 0, v8, v9);
}

void sub_1CD500324()
{
}

uint64_t *sub_1CD500338()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EBCC8CF0, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EBCC8CF0))
  {
    __int16 v4 = 1283;
    v3[0] = (uint64_t)"llvm.cas.builtin.v2[";
    v3[2] = (uint64_t)"BLAKE3";
    v3[3] = 6;
    uint64_t v1 = "]";
    __int16 v2 = 259;
    sub_1CB8F1E58(v3, (uint64_t *)&v1, (uint64_t)v5);
    llvm::Twine::str((llvm::Twine *)v5, &qword_1EBCC8CF8);
    __cxa_atexit(MEMORY[0x1E4FBA210], &qword_1EBCC8CF8, &dword_1CB82C000);
    __cxa_guard_release(&qword_1EBCC8CF0);
  }
  if (byte_1EBCC8D0F >= 0) {
    return &qword_1EBCC8CF8;
  }
  else {
    return (uint64_t *)qword_1EBCC8CF8;
  }
}

void sub_1CD500428(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v8[4] = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 16))(&v5, a2, a3);
  llvm_blake3_hasher_update(a1, (int *)v6, v7, v4);
  if (v6 != v8) {
    free(v6);
  }
}

void llvm::cas::createCASFileSystem()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t sub_1CD500614(uint64_t a1)
{
  if (*(char *)(a1 + 567) < 0) {
    operator delete(*(void **)(a1 + 544));
  }
  sub_1CBFFBB10(a1 + 424);
  sub_1CBFFBA64(a1 + 424);
  sub_1CBFFBB10(a1 + 320);
  sub_1CBFFBA64(a1 + 320);
  sub_1CD5006AC(a1 + 216);
  sub_1CBFFBA64(a1 + 216);
  sub_1CD500800(a1 + 112);
  sub_1CBFFBA64(a1 + 112);
  sub_1CBFFBB10(a1 + 8);
  sub_1CBFFBA64(a1 + 8);
  return a1;
}

uint64_t sub_1CD5006AC(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    __n128 v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      unint64_t v9 = (v6 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v10 = v9 + 112;
      while (v10 <= v8)
      {
        sub_1CD5007C0(v9);
        unint64_t v10 = v11 + 224;
        unint64_t v9 = v11 + 112;
      }
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v12 = *(unsigned int *)(a1 + 72);
  if (v12)
  {
    __int16 v13 = *(void **)(a1 + 64);
    uint64_t v14 = &v13[2 * v12];
    do
    {
      unint64_t v15 = (*v13 + 7) & 0xFFFFFFFFFFFFFFF8;
      unint64_t v16 = *v13 + v13[1];
      unint64_t v17 = v15 + 112;
      while (v17 <= v16)
      {
        sub_1CD5007C0(v15);
        unint64_t v17 = v18 + 224;
        unint64_t v15 = v18 + 112;
      }
      v13 += 2;
    }
    while (v13 != v14);
  }

  return sub_1CBFFBB10(a1);
}

void sub_1CD5007C0(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);

  std::mutex::~mutex((std::mutex *)a1);
}

uint64_t sub_1CD500800(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    __n128 v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      for (unint64_t i = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 40; i <= v8; i += 40)
      {
        if (*(char *)(i - 17) < 0) {
          operator delete(*(void **)(i - 40));
        }
      }
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v10 = *(unsigned int *)(a1 + 72);
  if (v10)
  {
    uint64_t v11 = *(void **)(a1 + 64);
    uint64_t v12 = &v11[2 * v10];
    do
    {
      unint64_t v13 = *v11 + v11[1];
      for (unint64_t j = ((*v11 + 7) & 0xFFFFFFFFFFFFFFF8) + 40; j <= v13; j += 40)
      {
        if (*(char *)(j - 17) < 0) {
          operator delete(*(void **)(j - 40));
        }
      }
      v11 += 2;
    }
    while (v11 != v12);
  }

  return sub_1CBFFBB10(a1);
}

uint64_t sub_1CD50092C@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD5009B4((uint64_t *)a1, (uint64_t)a2, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD500A7C(a1, (uint64_t)a2, (uint64_t)a2, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD5009B4(uint64_t *a1, uint64_t a2, void *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (v4)
  {
    uint64_t v6 = *a1;
    int HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(*(void **)(*(void *)a2 + 16), *(void *)(*(void *)a2 + 24));
    int v8 = v4 - 1;
    unsigned int v9 = HashValue & (v4 - 1);
    uint64_t v10 = (void *)(v6 + 8 * v9);
    uint64_t v11 = *v10;
    if (*(void *)a2 == *v10)
    {
      uint64_t result = 1;
    }
    else
    {
      unint64_t v13 = 0;
      int v14 = 1;
      uint64_t result = 1;
      while (v11 != -4096)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v11 == -8192;
        }
        if (v15) {
          unint64_t v13 = v10;
        }
        unsigned int v16 = v9 + v14++;
        unsigned int v9 = v16 & v8;
        uint64_t v10 = (void *)(v6 + 8 * (v16 & v8));
        uint64_t v11 = *v10;
        if (*(void *)a2 == *v10) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v13) {
        uint64_t v10 = v13;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v10;
  return result;
}

void *sub_1CD500A7C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD500B2C(a1, v7);
  unsigned int v9 = 0;
  sub_1CD5009B4((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD500B2C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(8 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD500BF8(a1, v4, &v4[v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      *result++ = -4096;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD500BF8(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v9 = 0;
      uint64_t result = sub_1CD5009B4((uint64_t *)v5, (uint64_t)a2, &v9);
      void *v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

uint64_t sub_1CD500CA8()
{
  return 0;
}

llvm::raw_ostream *sub_1CD500CB0(int a1, llvm::raw_ostream *a2, uint64_t a3, int a4)
{
  if (a4)
  {
    int v5 = a4;
    do
    {
      sub_1CB8E509C(a2, "  ");
      --v5;
    }
    while (v5);
  }

  return sub_1CB8E509C(a2, "FileSystem\n");
}

void sub_1CD500D18(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_1CD500D24(uint64_t *a1, const void **a2, uint64_t **a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
    goto LABEL_16;
  }
  uint64_t v6 = *a1;
  unsigned int HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(*a2, (uint64_t)a2[1]);
  uint64_t v8 = 0;
  int v9 = v4 - 1;
  for (int i = 1; ; ++i)
  {
    unsigned int v11 = HashValue & v9;
    uint64_t v12 = (uint64_t *)(v6 + 8 * (HashValue & v9));
    uint64_t v13 = *v12;
    if (*v12 == -8192) {
      goto LABEL_8;
    }
    if (v13 == -4096) {
      break;
    }
    size_t v14 = (size_t)a2[1];
    if (v14 == *(void *)(v13 + 24) && (!v14 || !memcmp(*a2, *(const void **)(v13 + 16), v14)))
    {
      uint64_t result = 1;
      goto LABEL_16;
    }
LABEL_8:
    if (v8) {
      BOOL v15 = 0;
    }
    else {
      BOOL v15 = v13 == -8192;
    }
    if (v15) {
      uint64_t v8 = (uint64_t *)(v6 + 8 * v11);
    }
    unsigned int HashValue = v11 + i;
  }
  uint64_t result = 0;
  if (v8) {
    uint64_t v12 = v8;
  }
LABEL_16:
  *a3 = v12;
  return result;
}

void *sub_1CD500E14(void *a1)
{
  uint64_t v1 = a1;
  unint64_t v2 = a1[3];
  if (v2 >= 8)
  {
    if ((v2 & 4) != 0)
    {
      if ((v2 & 2) == 0) {
        a1 = (void *)*a1;
      }
      (*(void (**)(void *))((v2 & 0xFFFFFFFFFFFFFFF8) + 16))(a1);
    }
    if ((v2 & 2) == 0) {
      MEMORY[0x1D25D9CD0](*v1, v1[2]);
    }
  }
  return v1;
}

double llvm::cas::CASOutputBackend::CASOutputBackend(llvm::cas::CASOutputBackend *this, llvm::cas::ObjectStore *a2)
{
  *((_DWORD *)this + 2) = 0;
  *(void *)this = &unk_1F2608DC0;
  *((void *)this + 2) = (char *)this + 32;
  *(void *)&double result = 0x100000000;
  *((void *)this + 3) = 0x100000000;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 8) = a2;
  return result;
}

void llvm::cas::CASOutputBackend::~CASOutputBackend(llvm::cas::CASOutputBackend *this)
{
  *(void *)this = &unk_1F2608DC0;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_1CD5010D8((char **)this + 2);
}

{
  uint64_t vars8;

  llvm::cas::CASOutputBackend::~CASOutputBackend(this);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::cas::CASOutputBackend::createFileImpl()
{
}

uint64_t sub_1CD5010C0@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  if (result) {
    ++*(_DWORD *)(result + 8);
  }
  *a2 = result;
  return result;
}

char **sub_1CD5010D8(char **a1)
{
  unint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 32 * v3;
    do
    {
      if (v2[v4 - 9] < 0) {
        operator delete(*(void **)&v2[v4 - 32]);
      }
      v4 -= 32;
    }
    while (v4);
    unint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

__n128 sub_1CD501148(uint64_t a1, __n128 *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  unint64_t v3 = *(void *)a1;
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v6 = v3 + 32 * v2;
    if (v3 > (unint64_t)a2 || v6 <= (unint64_t)a2) {
      sub_1CD5011EC();
    }
    sub_1CD5011EC();
  }
  uint64_t v4 = (__n128 *)(v3 + 32 * *(unsigned int *)(a1 + 8));
  __n128 result = *a2;
  v4[1].n128_u64[0] = a2[1].n128_u64[0];
  __n128 *v4 = result;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  a2->n128_u64[0] = 0;
  v4[1].n128_u64[1] = a2[1].n128_u64[1];
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void sub_1CD5011EC()
{
}

void sub_1CD50125C(long long **a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    unint64_t v3 = *a1;
    uint64_t v4 = (uint64_t)&(*a1)[2 * v2];
    do
    {
      long long v5 = *v3;
      *(void *)(a2 + 16) = *((void *)v3 + 2);
      *(_OWORD *)a2 = v5;
      *((void *)v3 + 1) = 0;
      *((void *)v3 + 2) = 0;
      *(void *)unint64_t v3 = 0;
      *(void *)(a2 + 24) = *((void *)v3 + 3);
      v3 += 2;
      a2 += 32;
    }
    while (v3 != (long long *)v4);
    uint64_t v6 = *((unsigned int *)a1 + 2);
    if (v6)
    {
      int v7 = *a1;
      uint64_t v8 = 2 * v6;
      do
      {
        if (SBYTE7(v7[v8 - 1]) < 0) {
          operator delete(*(void **)&v7[v8 - 2]);
        }
        v8 -= 2;
      }
      while (v8 * 16);
    }
  }
}

void *sub_1CD5012E4()
{
  return &llvm::vfs::OutputFileImpl::ID;
}

BOOL sub_1CD5012F0(uint64_t a1, void *a2)
{
  return a2 == &llvm::vfs::OutputFileImpl::ID || a2 == &llvm::RTTIRoot::ID;
}

llvm **sub_1CD501310(llvm *a1)
{
  uint64_t v1 = (llvm **)a1;
  unint64_t v2 = *((void *)a1 + 3);
  if (v2 >= 8)
  {
    if ((v2 & 4) != 0)
    {
      if ((v2 & 2) == 0) {
        a1 = *(llvm **)a1;
      }
      (*(void (**)(llvm *))((v2 & 0xFFFFFFFFFFFFFFF8) + 16))(a1);
    }
    if ((v2 & 2) == 0) {
      llvm::deallocate_buffer(*v1, v1[1]);
    }
  }
  return v1;
}

void llvm::cas::createCASProvidingFileSystem()
{
}

uint64_t sub_1CD5013F0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 16))();
}

uint64_t sub_1CD501418(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))();
}

uint64_t sub_1CD501440(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 40))();
}

uint64_t sub_1CD501468(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 48))();
}

uint64_t sub_1CD501490(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 56))();
}

void sub_1CD5014B8(uint64_t a1, uint64_t a2)
{
  *(void *)&v3.__val_ = std::generic_category();
  sub_1CD501664(a2, (llvm *)0x2D, v3);
}

uint64_t sub_1CD501500(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 72))();
}

uint64_t sub_1CD501528(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 80))();
}

void sub_1CD501550(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 16))(&__p);
  char v3 = v12;
  if (v12)
  {
    uint64_t v6 = __p;
    std::string::size_type v7 = v10;
    *(unsigned char *)(a2 + 24) |= 1u;
    *(void *)a2 = v6;
    *(void *)(a2 + 8) = v7;
  }
  else
  {
    if (v11 >= 0) {
      p_p = (const std::string::value_type *)&__p;
    }
    else {
      p_p = (const std::string::value_type *)__p;
    }
    if (p_p)
    {
      if (v11 >= 0) {
        std::string::size_type v5 = v11 & 0x7F;
      }
      else {
        std::string::size_type v5 = v10;
      }
      std::string::__init(&v8, p_p, v5);
    }
    else
    {
      memset(&v8, 0, sizeof(v8));
    }
    *(unsigned char *)(a2 + 24) &= ~1u;
    *(std::string *)a2 = v8;
    char v3 = v12;
  }
  if ((v3 & 1) == 0 && v11 < 0) {
    operator delete(__p);
  }
}

void sub_1CD501664(uint64_t a1, llvm *this, std::error_code a3)
{
  *(void *)&v8.__val_ = v8.__cat_;
  llvm::errorCodeToError(this, v8, &v6);
  uint64_t v5 = v6;
  uint64_t v6 = 0;
  uint64_t v7 = v5;
  sub_1CC226C78(a1, 0, 0, &v7);
}

uint64_t sub_1CD501718@<X0>(uint64_t result@<X0>, uint64_t **a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *(void **)result;
  if (*(void *)result)
  {
    *(void *)__n128 result = 0;
    if ((*(unsigned int (**)(void *, void *))(*v4 + 48))(v4, &llvm::ErrorList::ID))
    {
      *a3 = 0;
      uint64_t v6 = (char **)v4[1];
      uint64_t v7 = (char **)v4[2];
      if (v6 != v7)
      {
        std::error_code v8 = 0;
        do
        {
          char v12 = v8;
          int v9 = *v6;
          void *v6 = 0;
          if ((*(unsigned int (**)(char *, void *))(*(void *)v9 + 48))(v9, &llvm::ErrorInfoBase::ID))
          {
            uint64_t v10 = **a2;
            **a2 = (uint64_t)v9;
            if (v10) {
              (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
            }
            int v9 = 0;
          }
          char v11 = v9;
          sub_1CD451630(&v12, &v11, &v13);
          std::error_code v8 = v13;
          *a3 = v13;
          uint64_t v13 = 0;
          if (v11) {
            (*(void (**)(char *))(*(void *)v11 + 8))(v11);
          }
          if (v12) {
            (*(void (**)(char *))(*(void *)v12 + 8))(v12);
          }
          ++v6;
        }
        while (v6 != v7);
      }
      return (*(uint64_t (**)(void *))(*v4 + 8))(v4);
    }
    else
    {
      __n128 result = (*(uint64_t (**)(void *, void *))(*v4 + 48))(v4, &llvm::ErrorInfoBase::ID);
      if (result)
      {
        __n128 result = **a2;
        **a2 = (uint64_t)v4;
        if (result) {
          __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
        }
        uint64_t v4 = 0;
      }
      *a3 = v4;
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t sub_1CD501954(uint64_t a1, llvm::Twine *this, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v9 = a1 + 8;
  *(void *)a1 = &unk_1F2644990;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  llvm::Twine::str(this, &v13);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)v9);
  }
  *(_OWORD *)uint64_t v9 = v13;
  *(void *)(v9 + 16) = v14;
  uint64_t v10 = *a5;
  *a5 = 0;
  uint64_t v11 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v10;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a4;
  return a1;
}

void llvm::cas::createCachingOnDiskFileSystem(llvm::cas *this, llvm::cas::ObjectStore *a2)
{
}

uint64_t sub_1CD501B1C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 176))();
}

void sub_1CD501B40(llvm::vfs::FileSystem *this)
{
  *(void *)this = &unk_1F2608F20;
  unint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  llvm::vfs::FileSystem::~FileSystem(this);
}

char **sub_1CD501BD8(char **a1)
{
  unint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 24 * v3;
    uint64_t v5 = v2 - 24;
    do
    {
      MEMORY[0x1D25D9CD0](*(void *)&v5[v4], 8);
      v4 -= 24;
    }
    while (v4);
    unint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void *sub_1CD501C44(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  size_t v4 = *((void *)result + 6);
  size_t v5 = v4 - 1;
  if (v4 == 1)
  {
    uint64_t v9 = (unsigned char *)*((void *)result + 5);
    if (*v9 == 47)
    {
      size_t v4 = 0;
      std::error_code v8 = "";
      size_t v5 = 1;
      uint64_t v6 = 1;
      uint64_t v7 = ".";
      goto LABEL_18;
    }
    size_t v5 = 0;
    uint64_t v7 = v9 + 1;
LABEL_9:
    unint64_t v10 = -1;
    goto LABEL_10;
  }
  if (!v4)
  {
    size_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = (char *)*((void *)result + 5);
    std::error_code v8 = "";
    goto LABEL_18;
  }
  uint64_t v7 = (char *)(*((void *)result + 5) + 1);
  __n128 result = memchr(v7, 47, v5);
  if (!result) {
    goto LABEL_9;
  }
  unint64_t v10 = (unsigned char *)result - v7;
LABEL_10:
  if (v5 >= v10) {
    uint64_t v6 = v10;
  }
  else {
    uint64_t v6 = v5;
  }
  std::error_code v8 = &v7[v6];
  BOOL v11 = v10 == -1;
  if (v10 == -1) {
    size_t v4 = 0;
  }
  else {
    size_t v4 = v5 - v6;
  }
  if (v11) {
    std::error_code v8 = "";
  }
LABEL_18:
  *uint64_t v3 = a2;
  v3[1] = v7;
  v3[2] = v5;
  v3[3] = v7;
  uint64_t v3[4] = v6;
  v3[5] = v8;
  v3[6] = v4;
  return result;
}

void *sub_1CD501D2C(uint64_t a1, long long *a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD501FF4();
  }
  __n128 result = (void *)(*(void *)a1 + 24 * v3);
  if (*((char *)a2 + 23) < 0)
  {
    __n128 result = sub_1CB8BDF7C((uint64_t)result, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    result[2] = *((void *)a2 + 2);
    *(_OWORD *)__n128 result = v5;
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD501DB8(uint64_t *a1, uint64_t a2, long long *a3)
{
  sub_1CC22B004(a3, (long long *)(*a1 + 24 * *((unsigned int *)a1 + 2)), a2);
  uint64_t v6 = v5;
  uint64_t v7 = *a1;
  uint64_t v8 = *a1 + 24 * *((unsigned int *)a1 + 2);
  if (v8 != v5)
  {
    do
    {
      if (*(char *)(v8 - 1) < 0) {
        operator delete(*(void **)(v8 - 24));
      }
      v8 -= 24;
    }
    while (v8 != v6);
    uint64_t v7 = *a1;
  }
  *((_DWORD *)a1 + 2) = -1431655765 * ((unint64_t)(v6 - v7) >> 3);
  return a2;
}

uint64_t sub_1CD501E54(uint64_t a1, void **a2, unint64_t *a3, char a4)
{
  v15[16] = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(a1 + 16) = a4;
  uint64_t v7 = (char *)operator new(0x70uLL);
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = 0;
  *(void *)uint64_t v7 = &unk_1F2609200;
  *((void *)v7 + 7) = 0;
  *(_OWORD *)(v7 + 40) = 0u;
  *((_DWORD *)v7 + 14) = 9;
  v7[60] = 1;
  *((_OWORD *)v7 + 4) = 0u;
  *((_OWORD *)v7 + 5) = 0u;
  *(_OWORD *)(v7 + 92) = 0u;
  *((_DWORD *)v7 + 27) = 0xFFFF;
  *(_OWORD *)(v7 + 24) = 0u;
  uint64_t v8 = (uint64_t)(v7 + 24);
  *(void *)a1 = v7 + 24;
  *(void *)(a1 + 8) = v7;
  long long v13 = v15;
  long long v14 = xmmword_1CFAC3020;
  uint64_t v9 = (char *)sub_1CC229614(a2, (uint64_t)&v13);
  *a3 = llvm::sys::fs::detail::directory_iterator_construct(v8, v9, v10, *(unsigned char *)(a1 + 16));
  a3[1] = v11;
  if (v13 != v15) {
    free(v13);
  }
  return a1;
}

void sub_1CD501F80(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2609200;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1CD501FA0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F2609200;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD501FF4()
{
}

void *sub_1CD5020B0(void *a1, std::mutex *this)
{
  *a1 = 0;
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&this[1]);
  if ((v3 & 1) == 0)
  {
    uint64_t v5 = (atomic_uint *)&this[1].__m_.__sig + 1;
    *a1 = (char *)this + 68;
    atomic_fetch_add((atomic_uint *volatile)&this[1].__m_.__sig + 1, 1u);
    unsigned __int8 v6 = atomic_load((unsigned __int8 *)&this[1].__m_.__sig + 1);
    if (v6)
    {
      atomic_fetch_add(v5, 0xFFFFFFFF);
      std::mutex::lock(this);
      atomic_fetch_add(v5, 1u);
      std::mutex::unlock(this);
    }
  }
  return a1;
}

char *sub_1CD502128(uint64_t *a1, uint64_t a2, char *__src, char *a4)
{
  uint64_t v5 = __src;
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  uint64_t v9 = a2 - *a1;
  if (*a1 + v8 == a2)
  {
    sub_1CC22A954(a1, __src, a4);
    return (char *)(*a1 + v9);
  }
  else
  {
    unint64_t v10 = a4 - __src;
    if (a1[2] < (unint64_t)(v8 + a4 - __src)) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    unint64_t v11 = (char *)(v7 + v9);
    char v12 = (char *)(v7 + v8);
    uint64_t v13 = v8 - v9;
    if (v8 - v9 >= v10)
    {
      sub_1CC2171BC(a1, &v12[-v10], (char *)(v7 + v8));
      if (&v12[-v10] != v11) {
        memmove(&v11[v10], v11, &v12[-v10] - v11);
      }
      if (v5 != a4) {
        memmove(v11, v5, a4 - v5);
      }
    }
    else
    {
      a1[1] = v8 + v10;
      if (v9 != v8) {
        memcpy((void *)(v7 + v10 + v9), v11, v8 - v9);
      }
      if (v13)
      {
        long long v14 = v11;
        do
        {
          char v15 = *v5++;
          *v14++ = v15;
          --v13;
        }
        while (v13);
      }
      if (v5 != a4) {
        memcpy(v12, v5, a4 - v5);
      }
    }
  }
  return v11;
}

uint64_t sub_1CD502270(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 64);
  if (*(unsigned char *)(a2 + 64))
  {
    *(void *)a1 = *(void *)a2;
    uint64_t v4 = a1 + 8;
    if (v3)
    {
      sub_1CC1B8518(v4, a2 + 8);
    }
    else
    {
      *(void *)(a1 + 8) = a1 + 32;
      *(_OWORD *)(a1 + 16) = xmmword_1CDC7F9D0;
      if (*(void *)(a2 + 16)) {
        sub_1CC1B8518(v4, a2 + 8);
      }
      *(unsigned char *)(a1 + 64) = 1;
    }
  }
  else if (*(unsigned char *)(a1 + 64))
  {
    unsigned __int8 v6 = *(void **)(a1 + 8);
    if (v6 != (void *)(a1 + 32)) {
      free(v6);
    }
    *(unsigned char *)(a1 + 64) = 0;
  }
  return a1;
}

uint64_t sub_1CD502308(uint64_t a1, void *a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 64);
  *(void *)a1 = *a2;
  uint64_t v4 = a1 + 8;
  if (v3)
  {
    sub_1CC1B8518(v4, (uint64_t)(a2 + 1));
  }
  else
  {
    *(void *)(a1 + 8) = a1 + 32;
    *(_OWORD *)(a1 + 16) = xmmword_1CDC7F9D0;
    if (a2[2]) {
      sub_1CC1B8518(v4, (uint64_t)(a2 + 1));
    }
    *(unsigned char *)(a1 + 64) = 1;
  }
  return a1;
}

std::error_category *sub_1CD502374(std::error_category *result, long long *a2)
{
  unint64_t v2 = result;
  char v3 = (char)result[10].__vftable;
  if (a2[5])
  {
    LOBYTE(result[10].__vftable) = v3 | 1;
    if (a2[5])
    {
      uint64_t v8 = *(std::error_category_vtbl **)a2;
      __n128 result = (std::error_category *)*((void *)a2 + 1);
    }
    else
    {
      __n128 result = (std::error_category *)std::system_category();
      uint64_t v8 = 0;
    }
    v2->__vftable = v8;
    v2[1].__vftable = (std::error_category_vtbl *)result;
  }
  else
  {
    LOBYTE(result[10].__vftable) = v3 & 0xFE;
    long long v4 = *a2;
    result[2].__vftable = (std::error_category_vtbl *)a2[1];
    *(_OWORD *)&result->__vftable = v4;
    *((void *)a2 + 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    long long v5 = *(long long *)((char *)a2 + 24);
    long long v6 = *(long long *)((char *)a2 + 40);
    long long v7 = *(long long *)((char *)a2 + 56);
    LOWORD(result[9].__vftable) = *((_WORD *)a2 + 36);
    *(_OWORD *)&result[7].__vftable = v7;
    *(_OWORD *)&result[5].__vftable = v6;
    *(_OWORD *)&result[3].__vftable = v5;
  }
  return result;
}

uint64_t sub_1CD502408(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 8);
  if (v1 >= *(_DWORD *)(result + 12)) {
    sub_1CD50243C();
  }
  unint64_t v2 = (void *)(*(void *)result + 24 * v1);
  *unint64_t v2 = 0;
  v2[1] = 0;
  v2[2] = 0;
  ++*(_DWORD *)(result + 8);
  return result;
}

void sub_1CD50243C()
{
}

uint64_t sub_1CD5024D4(uint64_t result, uint64_t (*a2)(uint64_t, void), uint64_t a3)
{
  uint64_t v5 = *(void *)(result + 72);
  uint64_t v6 = *(unsigned int *)(result + 88);
  long long v7 = (void *)(v5 + 8 * v6);
  if (*(_DWORD *)(result + 80))
  {
    if (v6)
    {
      uint64_t v8 = 8 * v6;
      uint64_t v9 = *(void **)(result + 72);
      while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v9;
        v8 -= 8;
        if (!v8) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v9 = *(void **)(result + 72);
    }
  }
  else
  {
LABEL_6:
    uint64_t v9 = (void *)(v5 + 8 * v6);
  }
  unint64_t v10 = (void *)(v5 + 8 * v6);
LABEL_8:
  while (v9 != v10)
  {
    unint64_t v11 = v9 + 1;
    __n128 result = a2(a3, *v9);
    uint64_t v9 = v7;
    if (v11 != v7)
    {
      uint64_t v9 = v11;
      while ((*v9 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        if (++v9 == v7)
        {
          uint64_t v9 = v7;
          goto LABEL_8;
        }
      }
    }
  }
  return result;
}

uint64_t llvm::cas::FileSystemCache::FileSystemCache(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 32) = 0x400000000;
  *(void *)(a1 + 72) = a1 + 88;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = a1 + 144;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 136) = 0x400000000;
  *(void *)(a1 + 176) = a1 + 192;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = a1 + 248;
  *(void *)(a1 + 240) = 0x400000000;
  *(void *)(a1 + 296) = 0;
  uint64_t v7 = a1 + 296;
  uint64_t v6 = a1 + 216;
  *(void *)(a1 + 320) = 0;
  uint64_t v8 = (uint64_t *)(a1 + 320);
  *(void *)(v6 + 88) = 0;
  *(void *)(v6 + 64) = v7;
  *(void *)(v6 + 72) = 0;
  *(unsigned char *)(v6 + 96) = 0;
  *(void *)(v6 + 112) = 0;
  *(void *)(v6 + 120) = v6 + 136;
  *(void *)(v6 + 128) = 0x400000000;
  *(void *)(v6 + 184) = 0;
  *(void *)(v6 + 192) = 0;
  *(void *)(v6 + 168) = v6 + 184;
  *(void *)(v6 + 176) = 0;
  *(unsigned char *)(v6 + 200) = 0;
  uint64_t v9 = (atomic_uchar *)(v6 + 200);
  *(void *)(v6 + 208) = 0;
  *(void *)(v6 + 216) = 0;
  *(void *)(v6 + 224) = v6 + 240;
  *(void *)(v6 + 232) = 0x400000000;
  *(unsigned char *)(v6 + 304) = 0;
  *(void *)(v6 + 272) = v6 + 288;
  *(void *)(v6 + 280) = 0;
  *(void *)(v6 + 288) = 0;
  *(void *)(v6 + 296) = 0;
  *(void *)(v6 + 344) = 0;
  *(_OWORD *)(v6 + 328) = 0u;
  *(_OWORD *)(v6 + 312) = 0u;
  while ((atomic_exchange_explicit(v9, 1u, memory_order_acquire) & 1) != 0)
    uint64_t v9 = (atomic_uchar *)(a1 + 416);
  uint64_t v10 = sub_1CB906F34(v8, 96, 3);
  atomic_store(0, (unsigned __int8 *)(a1 + 416));
  *(void *)uint64_t v10 = "/";
  *(void *)(v10 + 8) = 1;
  *(void *)(v10 + 16) = llvm::sys::path::filename((uint64_t)"/", 1, 0);
  *(void *)(v10 + 24) = v11;
  *(void *)(v10 + 32) = 0;
  *(_DWORD *)(v10 + 40) = 3;
  *(unsigned char *)(v10 + 48) = 0;
  *(unsigned char *)(v10 + 64) = 0;
  *(void *)(v10 + 72) = 0;
  *(void *)(v10 + 80) = a2;
  *(void *)(v10 + 88) = a3;
  *(void *)(a1 + 528) = v10;
  while ((atomic_exchange_explicit((atomic_uchar *volatile)(a1 + 312), 1u, memory_order_acquire) & 1) != 0)
    ;
  unint64_t v12 = sub_1CB906F34((uint64_t *)v6, 112, 3);
  uint64_t v13 = 0;
  atomic_store(0, (unsigned __int8 *)(a1 + 312));
  *(void *)unint64_t v12 = 850045863;
  *(_OWORD *)(v12 + 8) = 0u;
  *(_OWORD *)(v12 + 24) = 0u;
  *(_OWORD *)(v12 + 40) = 0u;
  *(_OWORD *)(v12 + 50) = 0u;
  *(void *)(v12 + 68) = 0;
  *(void *)(v12 + 84) = 0;
  *(void *)(v12 + 76) = 0;
  unsigned int add = atomic_fetch_add(&dword_1EA61F09C, 1u);
  *(void *)(v12 + 96) = -1;
  *(void *)(v12 + 104) = add + 1;
  atomic_compare_exchange_strong((atomic_ullong *volatile)(v10 + 72), (unint64_t *)&v13, v12);
  return a1;
}

unsigned char *llvm::cas::FileSystemCache::canonicalizeWorkingDirectory(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4)
{
  v16[16] = *MEMORY[0x1E4F143B8];
  llvm::Twine::toVector(a1, a4);
  if (*(void *)(a4 + 8))
  {
    if (**(unsigned char **)a4 != 47)
    {
      long long v14 = v16;
      long long v15 = xmmword_1CFAC3020;
      sub_1CC22C75C(&v14, a2, &a2[a3]);
      if ((unint64_t)(v15 + 1) > *((void *)&v15 + 1)) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *((unsigned char *)v14 + v15) = 47;
      *(void *)&long long v15 = v15 + 1;
      sub_1CD502128((uint64_t *)a4, *(void *)a4, (char *)v14, (char *)v14 + v15);
      if (v14 != v16) {
        free(v14);
      }
    }
    llvm::sys::path::remove_dots((unsigned __int8 **)a4, 1, 1u);
    uint64_t v7 = *(unsigned int *)(a4 + 8);
    if (*(_DWORD *)(a4 + 8))
    {
      uint64_t v8 = 0;
      BOOL v9 = 0;
      int v10 = 0;
      do
      {
        int v11 = *(unsigned __int8 *)(*(void *)a4 + v8);
        if (v9 && v11 == 47)
        {
          BOOL v9 = 1;
        }
        else
        {
          *(unsigned char *)(*(void *)a4 + v10++) = v11;
          BOOL v9 = v11 == 47;
        }
        ++v8;
      }
      while (v7 != v8);
    }
    else
    {
      int v10 = 0;
    }
    sub_1CC22C7F8((void *)a4, v10);
    a2 = *(unsigned char **)a4;
    unint64_t v12 = *(void *)(a4 + 8);
    if (v12 > 1 && a2[v12 - 1] == 47) {
      *(void *)(a4 + 8) = v12 - 1;
    }
  }
  return a2;
}

uint64_t llvm::cas::FileSystemCache::Directory::Writer::Writer(uint64_t a1, std::mutex *this)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 8) = 0;
  atomic_store(1u, (unsigned __int8 *)&this[1].__m_.__sig + 1);
  if (*(unsigned char *)(a1 + 8))
  {
    std::mutex::unlock(*(std::mutex **)a1);
    *(unsigned char *)(a1 + 8) = 0;
  }
  *(void *)a1 = this;
  std::mutex::lock(this);
  *(unsigned char *)(a1 + 8) = 1;
  do
    int v4 = atomic_load((unsigned int *)&this[1].__m_.__sig + 1);
  while (v4 > 0);
  return a1;
}

unint64_t llvm::cas::FileSystemCache::makeLazySymlinkAlreadyLocked(uint64_t a1, uint64_t a2, unsigned char *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  return sub_1CC22B744(a1 + 424, a1 + 320, a2, atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire), a3, a4, 2, a8, a5, 1);
}

unint64_t llvm::cas::FileSystemCache::makeLazyFileAlreadyLocked(uint64_t a1, uint64_t a2, unsigned char *a3, size_t a4, uint64_t a5, int a6, uint64_t a7, int a8)
{
  return sub_1CC22B744(a1 + 424, a1 + 320, a2, atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire), a3, a4, a6, a8, a5, 1);
}

unint64_t llvm::cas::FileSystemCache::makeDirectoryAlreadyLocked(uint64_t a1, uint64_t a2, unsigned char *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unint64_t v9 = sub_1CC22B744(a1 + 424, a1 + 320, a2, atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire), a3, a4, 3, a8, a5, a6);
  while ((atomic_exchange_explicit((atomic_uchar *volatile)(a1 + 312), 1u, memory_order_acquire) & 1) != 0)
    ;
  unint64_t v10 = sub_1CB906F34((uint64_t *)(a1 + 216), 112, 3);
  uint64_t v11 = 0;
  atomic_store(0, (unsigned __int8 *)(a1 + 312));
  *(void *)unint64_t v10 = 850045863;
  *(_OWORD *)(v10 + 8) = 0u;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 50) = 0u;
  *(void *)(v10 + 68) = 0;
  *(void *)(v10 + 84) = 0;
  *(void *)(v10 + 76) = 0;
  unsigned int add = atomic_fetch_add(&dword_1EA61F09C, 1u);
  *(void *)(v10 + 96) = -1;
  *(void *)(v10 + 104) = add + 1;
  atomic_compare_exchange_strong((atomic_ullong *volatile)(v9 + 72), (unint64_t *)&v11, v10);
  return v9;
}

void llvm::cas::FileSystemCache::finishLazySymlink(uint64_t a1, uint64_t a2, const std::string::value_type *a3, std::string::size_type a4)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*(void *)(a2 + 32) + 72), memory_order_acquire);
  atomic_store(1u, (unsigned __int8 *)(explicit + 65));
  std::mutex::lock((std::mutex *)explicit);
  do
    int v9 = atomic_load((unsigned int *)(explicit + 68));
  while (v9 > 0);
  if (!atomic_load_explicit((atomic_ullong *volatile)(a2 + 72), memory_order_acquire))
  {
    unint64_t v10 = (unsigned __int8 *)(a1 + 208);
    while ((atomic_exchange_explicit((atomic_uchar *volatile)(a1 + 208), 1u, memory_order_acquire) & 1) != 0)
      ;
    uint64_t v11 = (std::string *)sub_1CB906F34((uint64_t *)(a1 + 112), 40, 3);
    atomic_store(0, v10);
    std::string::__init(v11, a3, a4);
    uint64_t v12 = 0;
    unsigned int add = atomic_fetch_add(&dword_1EA61F09C, 1u);
    v11[1].__r_.__value_.__r.__words[0] = -1;
    v11[1].__r_.__value_.__l.__size_ = add + 1;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(a2 + 72), (unint64_t *)&v12, (unint64_t)v11);
  }

  std::mutex::unlock((std::mutex *)explicit);
}

void llvm::cas::FileSystemCache::finishLazyFile(llvm::cas::FileSystemCache *this, llvm::cas::FileSystemCache::DirectoryEntry *a2, uint64_t a3)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(*((void *)a2 + 4) + 72), memory_order_acquire);
  atomic_store(1u, (unsigned __int8 *)(explicit + 65));
  std::mutex::lock((std::mutex *)explicit);
  do
    int v7 = atomic_load((unsigned int *)(explicit + 68));
  while (v7 > 0);
  if (!atomic_load_explicit((atomic_ullong *volatile)a2 + 9, memory_order_acquire))
  {
    while ((atomic_exchange_explicit((atomic_uchar *volatile)this + 104, 1u, memory_order_acquire) & 1) != 0)
      ;
    uint64_t v8 = (void *)sub_1CB906F34((uint64_t *)this + 1, 24, 3);
    uint64_t v9 = 0;
    atomic_store(0, (unsigned __int8 *)this + 104);
    void *v8 = a3;
    unsigned int add = atomic_fetch_add(&dword_1EA61F09C, 1u);
    v8[1] = -1;
    _OWORD v8[2] = add + 1;
    atomic_compare_exchange_strong((atomic_ullong *volatile)a2 + 9, (unint64_t *)&v9, (unint64_t)v8);
  }

  std::mutex::unlock((std::mutex *)explicit);
}

void llvm::cas::FileSystemCache::lookupPath(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned char *a3@<X2>, unint64_t a4@<X3>, unint64_t a5@<X4>, int a6@<W5>, uint64_t a7@<X8>)
{
  unint64_t v9 = a4;
  unint64_t v10 = (unint64_t)a3;
  uint64_t v12 = a1;
  v58[6] = *MEMORY[0x1E4F143B8];
  long long v14 = (char *)v58;
  int v56 = (char *)v58;
  uint64_t v57 = 0x200000000;
  if (a4 && *a3 == 47)
  {
    unint64_t v10 = (unint64_t)(a3 + 1);
    unint64_t v9 = a4 - 1;
    a5 = *(void *)(a1 + 528);
  }
  sub_1CC22BF80((uint64_t)&v56, v10, v9, 0);
  int v15 = v57;
  if (v57)
  {
    int v43 = a6;
    do
    {
      unsigned int v16 = &v56[24 * v15];
      unint64_t v17 = (unsigned char *)*((void *)v16 - 3);
      size_t v18 = *((void *)v16 - 2);
      int v19 = *((_DWORD *)v16 - 2);
      LODWORD(v57) = v15 - 1;
      v48.n128_u64[0] = a5;
      v48.n128_u64[1] = (unint64_t)v17;
      size_t v49 = v18;
      long long v50 = 0u;
      long long v51 = 0u;
      if (v18 && (long long v20 = memchr(v17, 47, v18)) != 0) {
        unint64_t v21 = v20 - v17;
      }
      else {
        unint64_t v21 = -1;
      }
      if (v18 >= v21) {
        unint64_t v22 = v21;
      }
      else {
        unint64_t v22 = v18;
      }
      *(void *)&long long v50 = v17;
      *((void *)&v50 + 1) = v22;
      uint64_t v23 = &v17[v22];
      size_t v24 = v18 - v22;
      BOOL v25 = v21 == -1;
      if (v21 == -1) {
        size_t v26 = 0;
      }
      else {
        size_t v26 = v24;
      }
      uint64_t v27 = "";
      if (!v25) {
        uint64_t v27 = v23;
      }
      *(void *)&long long v51 = v27;
      *((void *)&v51 + 1) = v26;
      llvm::cas::FileSystemCache::lookupRealPathPrefixFrom(a2, &v48, &v53);
      if (v55)
      {
        __int16 v47 = 261;
        unint64_t v45 = v10;
        unint64_t v46 = v9;
        unint64_t v52 = v53.n128_u64[0];
        v53.n128_u64[0] = 0;
        sub_1CC226C78((uint64_t)&v45, 0, 0, (uint64_t *)&v52);
      }
      a5 = v53.n128_u64[0];
      unint64_t v29 = v54;
      if (*(_DWORD *)(v53.n128_u64[0] + 40) == 2)
      {
        uint64_t v42 = v12;
        uint64_t v30 = a2;
        unint64_t v31 = v10;
        uint64_t v32 = v14;
        unint64_t v33 = v53.n128_u64[1];
        uint64_t v34 = v30;
        (*(void (**)(uint64_t, unint64_t))(*(void *)v30 + 40))(v30, v53.n128_u64[0]);
        __n128 v28 = sub_1CC22BF80((uint64_t)&v56, v33, v29, v19 + 1);
        if (v57 || v43)
        {
          long long v14 = v32;
          if ((v19 + 1) >= 0x11)
          {
            __int16 v47 = 261;
            unint64_t v45 = v31;
            unint64_t v46 = v9;
            *(void *)&v60.__val_ = std::generic_category();
            sub_1CD501664((uint64_t)&v45, (llvm *)0x3E, v60);
          }
          unint64_t v10 = v31;
          a2 = v34;
          uint64_t v12 = v42;
          if (!atomic_load_explicit((atomic_ullong *volatile)(a5 + 72), memory_order_acquire))
          {
            (*(void (**)(unint64_t *__return_ptr, uint64_t, unint64_t, __n128))(*(void *)a2 + 24))(&v44, a2, a5, v28);
            unint64_t v41 = v44;
            if (v44)
            {
              __int16 v47 = 261;
              unint64_t v45 = v10;
              unint64_t v46 = v9;
              unint64_t v44 = 0;
              unint64_t v52 = v41;
              sub_1CC226C78((uint64_t)&v45, 0, 0, (uint64_t *)&v52);
            }
          }
          unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)(a5 + 72), memory_order_acquire);
          char v37 = *(unsigned char *)(explicit + 23);
          if (v37 >= 0) {
            char v38 = (unsigned char *)explicit;
          }
          else {
            char v38 = *(unsigned char **)explicit;
          }
          if (v37 >= 0) {
            unint64_t v39 = v37 & 0x7F;
          }
          else {
            unint64_t v39 = *(void *)(explicit + 8);
          }
          if (v39 && *v38 == 47)
          {
            char v40 = (unint64_t *)(v42 + 528);
            ++v38;
            --v39;
          }
          else
          {
            char v40 = (unint64_t *)(a5 + 32);
          }
          a5 = *v40;
          __n128 v28 = sub_1CC22BF80((uint64_t)&v56, (unint64_t)v38, v39, v19 + 1);
          int v35 = 0;
        }
        else
        {
          int v35 = 3;
          long long v14 = v32;
          unint64_t v10 = v31;
          a2 = v34;
          uint64_t v12 = v42;
        }
      }
      else
      {
        if (v54)
        {
          __int16 v47 = 261;
          unint64_t v45 = v10;
          unint64_t v46 = v9;
          *(void *)&v59.__val_ = std::generic_category();
          sub_1CD501664((uint64_t)&v45, (llvm *)2, v59);
        }
        int v35 = 2;
      }
      if ((v55 & 1) != 0 && v53.n128_u64[0]) {
        (*(void (**)(unint64_t, __n128))(*(void *)v53.n128_u64[0] + 8))(v53.n128_u64[0], v28);
      }
      if (v35 && v35 != 2) {
        break;
      }
      int v15 = v57;
    }
    while (v57);
  }
  *(unsigned char *)(a7 + 8) &= ~1u;
  *(void *)a7 = a5;
  if (v56 != v14) {
    free(v56);
  }
}

void llvm::cas::FileSystemCache::lookupRealPathPrefixFrom(uint64_t a1@<X1>, __n128 *a2@<X2>, __n128 *a3@<X8>)
{
  char v6 = 0;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  while (1)
  {
    __n128 v7 = a2[1];
    v15[0] = *a2;
    v15[1] = v7;
    v15[2] = a2[2];
    unint64_t v16 = a2[3].n128_u64[0];
    uint64_t v14 = a1;
    llvm::cas::FileSystemCache::lookupRealPathPrefixFromCached(v15, (void (*)(uint64_t))sub_1CC22C86C, (uint64_t)&v14, v17);
    __n128 v8 = v17[1];
    *a2 = v17[0];
    a2[1] = v8;
    a2[2] = v17[2];
    a2[3].n128_u64[0] = v18;
    if (!a2[1].n128_u64[0]
      || *(_DWORD *)(a2->n128_u64[0] + 40) != 3
      || (unsigned __int8 v9 = atomic_load((unsigned __int8 *)(atomic_load_explicit((atomic_ullong *volatile)(a2->n128_u64[0] + 72), memory_order_acquire)+ 64)), (v9 & 1) != 0))
    {
LABEL_13:
      a3[3].n128_u8[8] &= ~1u;
      __n128 v13 = a2[1];
      *a3 = *a2;
      a3[1] = v13;
      a3[2] = a2[2];
      a3[3].n128_u64[0] = a2[3].n128_u64[0];
      return;
    }
    if ((v6 & 1) == 0) {
      break;
    }
    (*(void (**)(__n128 *__return_ptr, uint64_t, unint64_t, unint64_t, unint64_t))(*(void *)a1 + 16))(v17, a1, a2->n128_u64[0], a2[1].n128_u64[1], a2[2].n128_u64[0]);
    unint64_t v10 = v17[0].n128_u64[0];
    if (v17[0].n128_u8[8])
    {
      a3[3].n128_u8[8] |= 1u;
      a3->n128_u64[0] = v10;
      return;
    }
    if (!v17[0].n128_u64[0]) {
      goto LABEL_13;
    }
    sub_1CD501C44(a2, v17[0].n128_i64[0]);
    if (v17[0].n128_u8[8])
    {
      unint64_t v11 = v17[0].n128_u64[0];
      v17[0].n128_u64[0] = 0;
      if (v11) {
        (*(void (**)(unint64_t))(*(void *)v11 + 8))(v11);
      }
    }
LABEL_12:
    char v6 = 1;
  }
  (*(void (**)(__n128 *__return_ptr, uint64_t, unint64_t, unint64_t, unint64_t))(*(void *)a1 + 32))(v17, a1, a2->n128_u64[0], a2->n128_u64[1], a2[1].n128_u64[0]);
  unint64_t v12 = v17[0].n128_u64[0];
  if (!v17[0].n128_u64[0]) {
    goto LABEL_12;
  }
  a3[3].n128_u8[8] |= 1u;
  a3->n128_u64[0] = v12;
}

void llvm::cas::FileSystemCache::VFSDirIterImpl::create(uint64_t a1@<X0>, const void *a2@<X1>, size_t a3@<X2>, const void *a4@<X3>, unint64_t a5@<X4>, llvm::cas::FileSystemCache::VFSDirIterImpl **a6@<X8>)
{
  size_t v12 = a5;
  __n128 v13 = (uint64_t *)malloc_type_malloc(a3 + 8 * a5 + 113, 0x2A82A2E9uLL);
  uint64_t v14 = (llvm::cas::FileSystemCache::VFSDirIterImpl *)v13;
  int v15 = v13 + 14;
  if (a5) {
    memmove(v13 + 14, a4, v12 * 8);
  }
  unint64_t v16 = 126 - 2 * __clz(a5);
  if (a5) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 0;
  }
  sub_1CC22C894(v15, &v15[a5], v17, 1);
  unint64_t v18 = &v15[v12];
  if (a3) {
    memmove(v18, a2, a3);
  }
  *((unsigned char *)v18 + a3) = 0;
  unint64_t v19 = *(void *)(a1 + 24);
  unint64_t v22 = v19;
  if (v19 >= 8)
  {
    if ((v19 & 2) != 0 && (v19 & 4) != 0)
    {
      (*(void (**)(long long *, uint64_t))((v19 & 0xFFFFFFFFFFFFFFF8) + 8))(&v20, a1);
    }
    else
    {
      long long v20 = *(_OWORD *)a1;
      uint64_t v21 = *(void *)(a1 + 16);
    }
    *(void *)(a1 + 24) = 0;
  }
  sub_1CD503744(v14, &v20, (uint64_t)v18, a3, (uint64_t)v15, a5);
  *a6 = v14;
  operator new();
}

uint64_t llvm::cas::FileSystemCache::VFSDirIterImpl::increment(llvm::cas::FileSystemCache::VFSDirIterImpl *this)
{
  *((void *)this + 13) += 8;
  llvm::cas::FileSystemCache::VFSDirIterImpl::setEntry(this);
  std::system_category();
  return 0;
}

void sub_1CD5035FC(uint64_t a1)
{
  *(void *)a1 = &unk_1F2609238;
  sub_1CD500E14((void *)(a1 + 40));

  llvm::vfs::detail::DirIterImpl::~DirIterImpl((void **)a1);
}

void sub_1CD503650(uint64_t a1)
{
  *(void *)a1 = &unk_1F2609238;
  sub_1CD500E14((void *)(a1 + 40));
  llvm::vfs::detail::DirIterImpl::~DirIterImpl((void **)a1);

  free(v2);
}

uint64_t sub_1CD5036A8(uint64_t result, void *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 16);
  uint64_t v3 = *(void *)result + 8 * v2;
  if (*(_DWORD *)(result + 8))
  {
    if (v2)
    {
      uint64_t v4 = 8 * v2;
      uint64_t v5 = *(void **)result;
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v5;
        v4 -= 8;
        if (!v4) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v5 = *(void **)result;
    }
  }
  else
  {
LABEL_6:
    uint64_t v5 = (void *)(*(void *)result + 8 * v2);
  }
  uint64_t v6 = *(void *)result + 8 * v2;
  while (v5 != (void *)v6)
  {
    __n128 v7 = v5 + 1;
    *a2 = *v5;
    uint64_t v5 = (void *)v3;
    if (v7 != (void *)v3)
    {
      uint64_t v5 = v7;
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        if (++v5 == (void *)v3)
        {
          uint64_t v5 = (void *)v3;
          break;
        }
      }
    }
    ++a2;
  }
  return result;
}

llvm::cas::FileSystemCache::VFSDirIterImpl *sub_1CD503744(llvm::cas::FileSystemCache::VFSDirIterImpl *this, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 9;
  *(void *)this = &unk_1F2609238;
  *((void *)this + 1) = 0;
  *((void *)this + 8) = 0;
  uint64_t v11 = *((void *)a2 + 3);
  *((void *)this + 8) = v11;
  if (*((void *)a2 + 3) >= 8uLL)
  {
    __n128 v13 = (_OWORD *)((char *)this + 40);
    if ((v11 & 2) != 0 && (v11 & 4) != 0)
    {
      (*(void (**)(_OWORD *, long long *))((v11 & 0xFFFFFFFFFFFFFFF8) + 8))(v13, a2);
    }
    else
    {
      long long v14 = *a2;
      *((void *)this + 7) = *((void *)a2 + 2);
      *__n128 v13 = v14;
    }
    *((void *)a2 + 3) = 0;
  }
  *((void *)this + 9) = a3;
  *((void *)this + 10) = a4;
  *((void *)this + 11) = a5;
  *((void *)this + 12) = a6;
  *((void *)this + 13) = a5;
  llvm::cas::FileSystemCache::VFSDirIterImpl::setEntry(this);
  return this;
}

void sub_1CD503818(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD503850(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

unint64_t llvm::cas::ThreadSafeHashMappedTrieBase::getOrCreateImpl(llvm::cas::ThreadSafeHashMappedTrieBase *this)
{
  unsigned int v1 = (atomic_ullong *)((char *)this + 16);
  unint64_t v2 = atomic_load((unint64_t *)this + 2);
  if (!v2)
  {
    uint64_t v4 = sub_1CD5038DC(*((unsigned __int16 *)this + 3));
    unint64_t v5 = 0;
    atomic_compare_exchange_strong(v1, &v5, (unint64_t)v4);
    if (v5) {
      unint64_t v2 = v5;
    }
    else {
      unint64_t v2 = (unint64_t)v4;
    }
    if (v5 && v4)
    {
      uint64_t v6 = (void *)sub_1CBFFBA64((uint64_t)v4);
      free(v6);
    }
  }
  return v2;
}

void *sub_1CD5038DC(unint64_t a1)
{
  size_t v2 = 8 << a1;
  uint64_t v3 = malloc_type_malloc((8 << a1) + 144, 0xD863AA27uLL);
  *uint64_t v3 = 0;
  v3[1] = 0;
  v3[2] = v3 + 4;
  v3[3] = 0x400000000;
  v3[10] = 0;
  v3[8] = v3 + 10;
  v3[9] = 0;
  v3[11] = 1;
  *((unsigned char *)v3 + 96) = 0;
  *((unsigned char *)v3 + 104) = 1;
  *((_DWORD *)v3 + 27) = 0;
  *((_DWORD *)v3 + 28) = a1;
  v3[15] = 0;
  v3[16] = v3 + 18;
  v3[17] = 1 << a1;
  if (a1 <= 0x3C) {
    bzero(v3 + 18, v2);
  }
  return v3;
}

unsigned char *llvm::cas::ThreadSafeHashMappedTrieBase::find(uint64_t a1, const void *a2, size_t a3)
{
  unint64_t v3 = atomic_load((unint64_t *)(a1 + 16));
  if (!v3) {
    return 0;
  }
  unint64_t v4 = v3 + 104;
  uint64_t v8 = *(unsigned __int16 *)(a1 + 8);
  v11[0] = *(unsigned __int16 *)(a1 + 6);
  v11[1] = v8;
  v11[2] = a2;
  v11[3] = a3;
  LOBYTE(v12) = 0;
  char v13 = 0;
  unsigned __int8 v9 = (unsigned char *)atomic_load((unint64_t *)(*(void *)(v3 + 128) + 8 * sub_1CD503AA4((uint64_t)v11)));
  if ((unint64_t)(v9 + 1) >= 2)
  {
    if (*v9)
    {
      unint64_t v10 = v9;
      while (1)
      {
        unsigned __int8 v9 = (unsigned char *)atomic_load((unint64_t *)(*((void *)v10 + 3) + 8 * sub_1CD503AA4((uint64_t)v11)));
        if ((unint64_t)(v9 + 1) < 2) {
          return v10;
        }
        unint64_t v4 = (unint64_t)v10;
        unint64_t v10 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      if (a3 == v9[2] && !memcmp(&v9[v9[3]], a2, a3)) {
        return &v9[v9[1]];
      }
    }
  }
  return (unsigned char *)v4;
}

uint64_t sub_1CD503AA4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40))
  {
    size_t v2 = (unint64_t *)(a1 + 8);
    unint64_t v1 = *(void *)(a1 + 8 * (*(void *)(a1 + 32) != 0)) + *(void *)(a1 + 32);
  }
  else
  {
    unint64_t v1 = 0;
    *(unsigned char *)(a1 + 40) = 1;
    size_t v2 = (unint64_t *)a1;
  }
  *(void *)(a1 + 32) = v1;
  return sub_1CD503FE0(*(void *)(a1 + 16), *(void *)(a1 + 24), v1, *v2);
}

unsigned char *llvm::cas::ThreadSafeHashMappedTrieBase::insert(unsigned __int16 *a1, atomic_ullong *a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v7 = a3;
  *(void *)&long long v45 = a4;
  *((void *)&v45 + 1) = a5;
  int v10 = ~a3;
  v44[0] = a6;
  v44[1] = a7;
  unint64_t Impl = llvm::cas::ThreadSafeHashMappedTrieBase::getOrCreateImpl((llvm::cas::ThreadSafeHashMappedTrieBase *)a1);
  unint64_t v12 = Impl;
  unsigned int v36 = a1;
  unint64_t v13 = a1[4];
  unint64_t v39 = a1[3];
  unint64_t v40 = v13;
  long long v41 = v45;
  LOBYTE(v42) = 0;
  char v43 = 0;
  if ((v10 & 0xFFFFFFFE) != 0)
  {
    unint64_t v42 = HIDWORD(v7);
    char v43 = 1;
    unint64_t v7 = v7;
  }
  else
  {
    a2 = (atomic_ullong *)(Impl + 104);
    unint64_t v7 = sub_1CD503AA4((uint64_t)&v39);
  }
  while (1)
  {
    char v38 = 0;
    atomic_ullong v14 = a2[3];
    int v15 = (unint64_t *)(v14 + 8 * v7);
    v37[0] = &v38;
    v37[1] = v12;
    v37[2] = v36;
    v37[3] = v44;
    v37[4] = &v45;
    unint64_t v16 = (atomic_ullong *)atomic_load(v15);
    if (v16
      || (atomic_compare_exchange_strong((atomic_ullong *volatile)v15, (unint64_t *)&v16, 0xFFFFFFFFFFFFFFFFLL),
          v16))
    {
      while (v16 == (atomic_ullong *)-1)
        unint64_t v16 = (atomic_ullong *)atomic_load((unint64_t *)(v14 + 8 * v7));
    }
    else
    {
      unint64_t v16 = (atomic_ullong *)sub_1CC22E5A0((uint64_t)v37);
      atomic_store((unint64_t)v16, (unint64_t *)(v14 + 8 * v7));
    }
    if (v38) {
      return (char *)v16 + *((unsigned __int8 *)v16 + 1);
    }
    if (*(unsigned char *)v16)
    {
      unint64_t v7 = sub_1CD503AA4((uint64_t)&v39);
      a2 = v16;
    }
    else
    {
      size_t v17 = *((unsigned __int8 *)v16 + 2);
      if (*((void *)&v45 + 1) == v17 && !memcmp((char *)v16 + *((unsigned __int8 *)v16 + 3), (const void *)v45, v17)) {
        return (char *)v16 + *((unsigned __int8 *)v16 + 1);
      }
      do
      {
        unint64_t v18 = v7;
        unint64_t v7 = sub_1CD503AA4((uint64_t)&v39);
        unint64_t v19 = v42;
        unint64_t v20 = v40;
        uint64_t v21 = sub_1CD503FE0((uint64_t)v16 + *((unsigned __int8 *)v16 + 3), *((unsigned __int8 *)v16 + 2), v42, v40);
        unint64_t v22 = v39;
        if (v19) {
          unint64_t v22 = v20;
        }
        if (8 * *((void *)&v41 + 1) - v19 >= v22) {
          unint64_t v23 = v22;
        }
        else {
          unint64_t v23 = 8 * *((void *)&v41 + 1) - v19;
        }
        int v24 = *((_DWORD *)a2 + 2) + *((_DWORD *)a2 + 1);
        BOOL v25 = (atomic_ullong *)malloc_type_malloc((8 << v23) + 40, 0x42725486uLL);
        size_t v26 = v25;
        *(unsigned char *)BOOL v25 = 1;
        *((_DWORD *)v25 + 1) = v24;
        *((_DWORD *)v25 + 2) = v23;
        uint64_t v27 = (char *)(v25 + 5);
        v25[2] = 0;
        v25[3] = (atomic_ullong)(v25 + 5);
        v25[4] = 1 << v23;
        if (v23 <= 0x3C) {
          bzero(v25 + 5, 8 << v23);
        }
        uint64_t v28 = 0;
        do
        {
          uint64_t v29 = v28;
          atomic_compare_exchange_strong((atomic_ullong *volatile)&v27[8 * v21], (unint64_t *)&v29, (unint64_t)v16);
          BOOL v30 = v29 == v28;
          if (v29 == -1) {
            uint64_t v28 = 0;
          }
          else {
            uint64_t v28 = v29;
          }
        }
        while (!v30);
        atomic_ullong v31 = a2[3];
        a2 = v16;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 8 * v18), (unint64_t *)&a2, (unint64_t)v26);
        if (a2 == v16)
        {
LABEL_25:
          unint64_t v32 = 0;
          atomic_compare_exchange_strong((atomic_ullong *volatile)(v12 + 120), &v32, (unint64_t)v26);
          if (v32)
          {
            unint64_t v33 = v32;
            do
            {
              atomic_exchange(v26 + 2, v32);
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v12 + 120), &v33, (unint64_t)v26);
              BOOL v34 = v33 == v32;
              unint64_t v32 = v33;
            }
            while (!v34);
          }
          a2 = v26;
        }
        else
        {
          if (a2 == (atomic_ullong *)-1)
          {
            while (a2 == (atomic_ullong *)-1)
            {
              a2 = v16;
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v31 + 8 * v18), (unint64_t *)&a2, (unint64_t)v26);
              if (a2 == v16) {
                goto LABEL_25;
              }
            }
          }
          free(v26);
        }
      }
      while (v7 == v21);
    }
  }
}

void llvm::cas::ThreadSafeHashMappedTrieBase::print(llvm::cas::ThreadSafeHashMappedTrieBase *this, llvm::raw_ostream *a2)
{
  unint64_t v4 = sub_1CB8E509C(a2, "root-bits=");
  unint64_t v5 = llvm::raw_ostream::operator<<(v4, *((unsigned __int16 *)this + 3));
  uint64_t v6 = sub_1CB8E509C(v5, " subtrie-bits=");
  unint64_t v7 = llvm::raw_ostream::operator<<(v6, *((unsigned __int16 *)this + 4));
  sub_1CB8E509C(v7, "\n");
  unint64_t v8 = atomic_load((unint64_t *)this + 2);
  if (v8)
  {
    LOBYTE(__p) = 0;
    char v11 = 0;
    sub_1CC22DC5C(v8 + 104, a2, (uint64_t)&__p);
    if (v11)
    {
      if (v10 < 0) {
        operator delete(__p);
      }
    }
  }
  else
  {
    sub_1CB8E509C(a2, "[no-root]\n");
  }
}

void llvm::cas::ThreadSafeHashMappedTrieBase::dump(llvm::cas::ThreadSafeHashMappedTrieBase *this)
{
  size_t v2 = llvm::dbgs(this);

  llvm::cas::ThreadSafeHashMappedTrieBase::print(this, v2);
}

void llvm::cas::ThreadSafeHashMappedTrieBase::destroyImpl(uint64_t a1, void (*a2)(uint64_t, unsigned char *), uint64_t a3)
{
  uint64_t v3 = atomic_exchange((atomic_ullong *volatile)(a1 + 16), 0);
  if (v3)
  {
    if (a2)
    {
      uint64_t v6 = (unint64_t *)(v3 + 104);
      do
      {
        unint64_t v7 = v6[4];
        if (v7)
        {
          unint64_t v8 = (unint64_t *)v6[3];
          uint64_t v9 = 8 * v7;
          do
          {
            char v10 = (unsigned char *)atomic_load(v8);
            if ((unint64_t)(v10 + 1) >= 2 && !*v10) {
              a2(a3, &v10[v10[1]]);
            }
            ++v8;
            v9 -= 8;
          }
          while (v9);
        }
        uint64_t v6 = (unint64_t *)atomic_load(v6 + 2);
      }
      while (v6);
    }
    char v11 = (atomic_ullong *)atomic_load((unint64_t *)(v3 + 120));
    if (v11)
    {
      do
      {
        unint64_t v12 = atomic_exchange(v11 + 2, 0);
        free(v11);
        char v11 = (atomic_ullong *)v12;
      }
      while (v12);
    }
    unint64_t v13 = (void *)sub_1CBFFBA64(v3);
    free(v13);
  }
}

uint64_t sub_1CD503FE0(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a3 >> 3;
  if (a3 >> 3 == a2) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v7 = a3 & 7;
  unint64_t v8 = (unsigned __int8 *)(a1 + v4);
  uint64_t v9 = ~v4 + a2;
  do
  {
    int v11 = *v8++;
    int v10 = v11;
    if (v7) {
      int v12 = ~(-1 << (8 - v7));
    }
    else {
      int v12 = -1;
    }
    unsigned int v13 = v12 & v10;
    unint64_t v14 = 8 - v7;
    if (v14 > a4) {
      v13 >>= v14 - a4;
    }
    if (v14 >= a4) {
      unint64_t v14 = a4;
    }
    uint64_t result = (result << v14) | v13 & ~(-1 << v14);
    a4 -= v14;
    if (!a4) {
      break;
    }
    uint64_t v7 = 0;
  }
  while (v9--);
  return result;
}

unint64_t sub_1CD504070(uint64_t a1, unint64_t a2)
{
  unint64_t result = sub_1CBFCD38C(a1, a2, 1);
  uint64_t v4 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 8);
  if (*(char *)(result + 23) < 0)
  {
    unint64_t result = (unint64_t)sub_1CB8BDF7C(*(void *)a1 + 24 * *(unsigned int *)(a1 + 8), *(const void **)result, *(void *)(result + 8));
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(v4 + 16) = *(void *)(result + 16);
    *(_OWORD *)uint64_t v4 = v5;
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

void llvm::cas::HierarchicalTreeBuilder::pushImpl(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  v13[32] = *MEMORY[0x1E4F143B8];
  *(void *)&long long v10 = a2;
  *((void *)&v10 + 1) = a3;
  int v9 = a4;
  int v11 = v13;
  long long v12 = xmmword_1CD96DBF0;
  llvm::Twine::toVector(a5, (uint64_t)&v11);
  v8[0] = sub_1CC22E654(&v11, a4);
  v8[1] = v7;
  sub_1CD50419C(a1, &v10, &v9, (uint64_t)v8);
  if (v11 != v13) {
    free(v11);
  }
}

uint64_t sub_1CD50419C(uint64_t a1, _OWORD *a2, int *a3, uint64_t a4)
{
  unsigned int v5 = *(_DWORD *)(a1 + 8);
  if (v5 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD504C78();
  }
  uint64_t v6 = *(void *)a1 + 48 * v5;
  int v7 = *a3;
  int v9 = *(const std::string::value_type **)a4;
  std::string::size_type v8 = *(void *)(a4 + 8);
  *(_OWORD *)uint64_t v6 = *a2;
  *(_DWORD *)(v6 + 16) = v7;
  long long v10 = (std::string *)(v6 + 24);
  if (v9)
  {
    std::string::__init(v10, v9, v8);
  }
  else
  {
    v10->__r_.__value_.__r.__words[0] = 0;
    *(void *)(v6 + 32) = 0;
    *(void *)(v6 + 40) = 0;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v11;
  return *(void *)a1 + 48 * v11 - 48;
}

void *llvm::cas::HierarchicalTreeBuilder::create@<X0>(llvm::cas::HierarchicalTreeBuilder *this@<X0>, llvm::cas::ObjectStore *a2@<X1>, uint64_t a3@<X8>)
{
  v114[2] = *MEMORY[0x1E4F143B8];
  llvm::cas::TreeSchema::TreeSchema((llvm::cas::TreeSchema *)v96, a2);
  uint64_t v6 = *((unsigned int *)this + 102);
  if (!v6) {
    goto LABEL_14;
  }
  uint64_t v7 = 48 * v6;
  uint64_t v8 = *((void *)this + 50) + 24;
  do
  {
    char v9 = *(unsigned char *)(v8 + 23);
    BOOL v10 = v9 < 0;
    uint64_t v11 = *(void *)v8;
    if (v9 >= 0) {
      uint64_t v11 = v8;
    }
    uint64_t v12 = v9 & 0x7F;
    if (v10) {
      uint64_t v12 = *(void *)(v8 + 8);
    }
    *(void *)&long long v104 = v11;
    *((void *)&v104 + 1) = v12;
    uint64_t v13 = *(void *)(v8 - 24);
    v109 = this;
    v110 = &v104;
    unint64_t result = (void *)llvm::cas::TreeSchema::walkFileTreeRecursively((uint64_t)v96, v13, (void (*)(uint64_t, long long *, const char **))sub_1CC22EAA8, (uint64_t)&v109, v89);
    uint64_t v15 = v89[0];
    if (v89[0])
    {
      *(unsigned char *)(a3 + 24) |= 1u;
      goto LABEL_20;
    }
    v8 += 48;
    v7 -= 48;
  }
  while (v7);
  uint64_t v16 = *((unsigned int *)this + 102);
  if (v16)
  {
    uint64_t v17 = *((void *)this + 50);
    uint64_t v18 = 48 * v16;
    do
    {
      if (*(char *)(v17 + v18 - 1) < 0) {
        operator delete(*(void **)(v17 + v18 - 24));
      }
      v18 -= 48;
    }
    while (v18);
  }
LABEL_14:
  *((_DWORD *)this + 102) = 0;
  unint64_t v19 = *((unsigned int *)this + 2);
  if (!v19)
  {
    unint64_t result = llvm::cas::TreeSchema::create(&v104, v96, 0, 0);
    char v27 = v106;
    *(unsigned char *)(a3 + 24) = *(unsigned char *)(a3 + 24) & 0xFE | v106 & 1;
    if ((v27 & 1) == 0)
    {
      *(_OWORD *)a3 = v104;
      *(void *)(a3 + 16) = v105[0];
      return result;
    }
    uint64_t v15 = v104;
LABEL_20:
    *(void *)a3 = v15;
    return result;
  }
  unsigned int v86 = a2;
  uint64_t v87 = a3;
  unint64_t v20 = *(long long **)this;
  uint64_t v21 = (long long *)(*(void *)this + 48 * v19);
  unint64_t v22 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
  unint64_t v23 = *((unsigned int *)this + 2);
  while (1)
  {
    int v24 = (long long *)operator new(48 * v23, v22);
    if (v24) {
      break;
    }
    BOOL v26 = v23 >= 2;
    v23 >>= 1;
    if (!v26)
    {
      sub_1CC22EB90(v20, v21, v19, 0, 0, v25);
      goto LABEL_24;
    }
  }
  uint64_t v28 = v24;
  sub_1CC22EB90(v20, v21, v19, v24, v23, v25);
  operator delete(v28);
LABEL_24:
  v109 = 0;
  v110 = 0;
  v111 = v113;
  uint64_t v112 = 0x400000000;
  v113[4] = v114;
  v113[5] = 0;
  v114[0] = 0;
  v114[1] = 1;
  char v91 = 0;
  v89[0] = 0;
  v89[1] = 0;
  LOBYTE(v90) = 0;
  uint64_t v93 = 0;
  uint64_t v94 = 0;
  uint64_t v92 = 0;
  char v95 = 0;
  unsigned int v29 = *((_DWORD *)this + 2);
  if (v29)
  {
    uint64_t v30 = 0;
    uint64_t v31 = *(void *)this;
    uint64_t v88 = *(void *)this + 48 * v29;
    while (1)
    {
      if (v30)
      {
        char v32 = *(unsigned char *)(v30 + 47);
        if (v32 >= 0) {
          unint64_t v33 = (const void *)(v30 + 24);
        }
        else {
          unint64_t v33 = *(const void **)(v30 + 24);
        }
        if (v32 >= 0) {
          size_t v34 = v32 & 0x7F;
        }
        else {
          size_t v34 = *(void *)(v30 + 32);
        }
        uint64_t v35 = *(void *)(v31 + 24);
        char v36 = *(unsigned char *)(v31 + 47);
        char v37 = v36;
        if (v36 >= 0) {
          char v38 = (const void *)(v31 + 24);
        }
        else {
          char v38 = *(const void **)(v31 + 24);
        }
        uint64_t v39 = *(void *)(v31 + 32);
        uint64_t v40 = v36 & 0x7F;
        if (v36 >= 0) {
          uint64_t v41 = v36 & 0x7F;
        }
        else {
          uint64_t v41 = *(void *)(v31 + 32);
        }
        if (v34 == v41 && (!v34 || !memcmp(v33, v38, v34)))
        {
          if (*(_DWORD *)(v31 + 16) != *(_DWORD *)(v30 + 16))
          {
            uint64_t v76 = std::generic_category();
            char v77 = *(unsigned char *)(v31 + 47);
            BOOL v78 = v77 < 0;
            v79 = *(uint64_t **)(v31 + 24);
            if (v77 >= 0) {
              v79 = (uint64_t *)(v31 + 24);
            }
            unint64_t v80 = v77 & 0x7F;
            if (v78) {
              unint64_t v80 = *(void *)(v31 + 32);
            }
            __int16 v103 = 1283;
            v99 = "duplicate path '";
            uint64_t v101 = v79;
            unint64_t v102 = v80;
            v107[0] = (uint64_t)"' with different kind";
            __int16 v108 = 259;
            sub_1CB8F1E58((uint64_t *)&v99, v107, (uint64_t)&v104);
            sub_1CD4FF4BC(22, (uint64_t)v76, (llvm::Twine *)&v104);
          }
          if (*(unsigned char *)(v31 + 8) && *(void *)v31 != *(void *)v30)
          {
            v81 = std::generic_category();
            char v82 = *(unsigned char *)(v31 + 47);
            BOOL v83 = v82 < 0;
            uint64_t v84 = *(uint64_t **)(v31 + 24);
            if (v82 >= 0) {
              uint64_t v84 = (uint64_t *)(v31 + 24);
            }
            unint64_t v85 = v82 & 0x7F;
            if (v83) {
              unint64_t v85 = *(void *)(v31 + 32);
            }
            __int16 v103 = 1283;
            v99 = "duplicate path '";
            uint64_t v101 = v84;
            unint64_t v102 = v85;
            v107[0] = (uint64_t)"' with different ID";
            __int16 v108 = 259;
            sub_1CB8F1E58((uint64_t *)&v99, v107, (uint64_t)&v104);
            sub_1CD4FF4BC(22, (uint64_t)v81, (llvm::Twine *)&v104);
          }
          goto LABEL_99;
        }
      }
      else
      {
        char v37 = *(unsigned char *)(v31 + 47);
        uint64_t v35 = *(void *)(v31 + 24);
        uint64_t v39 = *(void *)(v31 + 32);
        uint64_t v40 = v37 & 0x7F;
      }
      int v42 = v37;
      char v43 = (char *)(v37 >= 0 ? v31 + 24 : v35);
      size_t v44 = v42 >= 0 ? v40 : v39;
      uint64_t v30 = v31;
      if (v44) {
        break;
      }
LABEL_99:
      v31 += 48;
      if (v31 == v88) {
        goto LABEL_100;
      }
    }
    if (*v43 == 47)
    {
      uint64_t v30 = v31;
      if (!--v44) {
        goto LABEL_99;
      }
      ++v43;
    }
    long long v45 = memchr(v43, 47, v44);
    unint64_t v46 = v45 - v43;
    if (!v45) {
      unint64_t v46 = -1;
    }
    __int16 v47 = v89;
    while (2)
    {
      if (v44 >= v46) {
        size_t v48 = v46;
      }
      else {
        size_t v48 = v44;
      }
      if (v44 >= v46 + 1) {
        size_t v49 = v46 + 1;
      }
      else {
        size_t v49 = v44;
      }
      long long v50 = &v43[v49];
      size_t v51 = v44 - v49;
      if (v46 == -1) {
        size_t v52 = v44;
      }
      else {
        size_t v52 = v48;
      }
      if (v46 == -1) {
        __n128 v53 = "";
      }
      else {
        __n128 v53 = v50;
      }
      if (v46 == -1) {
        size_t v44 = 0;
      }
      else {
        size_t v44 = v51;
      }
      if (*((unsigned char *)v47 + 24))
      {
        v66 = std::generic_category();
        char v67 = *(unsigned char *)(v31 + 47);
        BOOL v68 = v67 < 0;
        int v69 = *(uint64_t **)(v31 + 24);
        if (v67 >= 0) {
          int v69 = (uint64_t *)(v31 + 24);
        }
        unint64_t v70 = v67 & 0x7F;
        if (v68) {
          unint64_t v70 = *(void *)(v31 + 32);
        }
        __int16 v103 = 1283;
        v99 = "cannot add '";
        uint64_t v101 = v69;
        unint64_t v102 = v70;
        v107[0] = (uint64_t)"' under fixed tree";
        __int16 v108 = 259;
        sub_1CB8F1E58((uint64_t *)&v99, v107, (uint64_t)&v104);
        sub_1CD4FF4BC(22, (uint64_t)v66, (llvm::Twine *)&v104);
      }
      uint64_t v54 = v47[7];
      if (v54 && v52 == *(void *)(v54 + 48) && (!v52 || !memcmp(v43, *(const void **)(v54 + 40), v52)))
      {
        if (!v44 && *(_DWORD *)(v31 + 16) == 3) {
          goto LABEL_98;
        }
        if (*(_DWORD *)(v54 + 32) != 3)
        {
          uint64_t v71 = std::generic_category();
          char v72 = *(unsigned char *)(v31 + 47);
          BOOL v73 = v72 < 0;
          unsigned int v74 = *(uint64_t **)(v31 + 24);
          if (v72 >= 0) {
            unsigned int v74 = (uint64_t *)(v31 + 24);
          }
          unint64_t v75 = v72 & 0x7F;
          if (v73) {
            unint64_t v75 = *(void *)(v31 + 32);
          }
          if (v75 >= &v43[v52] - (char *)v74) {
            unint64_t v75 = &v43[v52] - (char *)v74;
          }
          __int16 v103 = 1283;
          v99 = "duplicate path '";
          uint64_t v101 = v74;
          unint64_t v102 = v75;
          v107[0] = (uint64_t)"'";
          __int16 v108 = 259;
          sub_1CB8F1E58((uint64_t *)&v99, v107, (uint64_t)&v104);
          sub_1CD4FF4BC(22, (uint64_t)v71, (llvm::Twine *)&v104);
        }
      }
      else
      {
        if (!v44 && *(_DWORD *)(v31 + 16) != 3)
        {
          uint64_t v55 = sub_1CB906F34((uint64_t *)&v109, 56, 3);
          uint64_t v54 = 0;
          *(_OWORD *)uint64_t v55 = 0u;
          *(_OWORD *)(v55 + 16) = 0u;
          *(_OWORD *)(v55 + 32) = 0u;
          *(void *)(v55 + 48) = 0;
          *(void *)(v55 + 8) = v47;
          *(void *)uint64_t v55 = v47[7];
          *(void *)(v55 + 40) = v43;
          *(void *)(v55 + 48) = v52;
          goto LABEL_86;
        }
        uint64_t v55 = sub_1CB906F34((uint64_t *)&v109, 72, 3);
        *(_OWORD *)uint64_t v55 = 0u;
        *(_OWORD *)(v55 + 16) = 0u;
        *(void *)(v55 + 64) = 0;
        *(_OWORD *)(v55 + 32) = 0u;
        *(_OWORD *)(v55 + 48) = 0u;
        *(void *)(v55 + 8) = v47;
        *(void *)uint64_t v55 = v47[7];
        *(void *)(v55 + 40) = v43;
        *(void *)(v55 + 48) = v52;
        if (v44)
        {
          *(_DWORD *)(v55 + 32) = 3;
          uint64_t v54 = v55;
        }
        else
        {
          uint64_t v54 = v55;
LABEL_86:
          *(_DWORD *)(v55 + 32) = *(_DWORD *)(v31 + 16);
          *(_OWORD *)(v55 + 16) = *(_OWORD *)v31;
        }
        v47[7] = v55;
      }
      if (v44 && (int v56 = memchr(v53, 47, v44)) != 0) {
        unint64_t v46 = v56 - v53;
      }
      else {
        unint64_t v46 = -1;
      }
      __int16 v47 = (uint64_t *)v54;
      char v43 = v53;
      if (!v44)
      {
LABEL_98:
        uint64_t v30 = v31;
        goto LABEL_99;
      }
      continue;
    }
  }
LABEL_100:
  *(void *)&long long v104 = v105;
  *((void *)&v104 + 1) = 0x800000000;
  v99 = &v101;
  uint64_t v101 = v89;
  uint64_t v100 = 0x600000001;
  char v57 = *(unsigned char *)(v87 + 24);
  unsigned int v58 = 1;
  do
  {
    uint64_t v59 = *((void *)v99 + v58 - 1);
    if (*(unsigned char *)(v59 + 64))
    {
      LODWORD(v100) = v58 - 1;
      for (int i = *(uint64_t **)(v59 + 56); i; int i = (uint64_t *)*i)
        sub_1CD504B58((uint64_t)&v104, i[2], *((_DWORD *)i + 8), i[5], i[6]);
      llvm::cas::TreeSchema::create(v107, v96, v104, DWORD2(v104));
      DWORD2(v104) = 0;
      char v61 = v108;
      if (v108)
      {
        uint64_t v64 = v107[0];
        v107[0] = 0;
        v57 |= 1u;
        *(unsigned char *)(v87 + 24) = v57;
        *(void *)uint64_t v87 = v64;
      }
      else
      {
        int v62 = *(unsigned __int8 *)(v59 + 24);
        *(void *)(v59 + 16) = v107[1];
        if (!v62) {
          *(unsigned char *)(v59 + 24) = 1;
        }
      }
      if (v108)
      {
        uint64_t v65 = v107[0];
        v107[0] = 0;
        if (v65) {
          (*(void (**)(uint64_t))(*(void *)v65 + 8))(v65);
        }
      }
      if (v61) {
        goto LABEL_122;
      }
      unsigned int v58 = v100;
    }
    else
    {
      for (unint64_t j = *(uint64_t **)(v59 + 56); j; unint64_t j = (uint64_t *)*j)
      {
        if (!*((unsigned char *)j + 24))
        {
          if (v58 >= HIDWORD(v100)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v99 + v58) = j;
          unsigned int v58 = v100 + 1;
          LODWORD(v100) = v100 + 1;
        }
      }
      *(unsigned char *)(v59 + 64) = 1;
    }
  }
  while (v58);
  llvm::cas::ObjectStore::getProxy((uint64_t)v86, v90, (uint64_t)&v97);
  *(_OWORD *)uint64_t v87 = v97;
  *(void *)(v87 + 16) = v98;
  *(unsigned char *)(v87 + 24) = v57 & 0xFE;
LABEL_122:
  if (v99 != &v101) {
    free(v99);
  }
  if ((void *)v104 != v105) {
    free((void *)v104);
  }
  return (void *)sub_1CBFFBA64((uint64_t)&v109);
}

uint64_t sub_1CD504B58(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD504DE4(a1, a2, a3, a4, a5);
  }
  uint64_t v6 = *(void *)a1 + 32 * v5;
  *(_DWORD *)uint64_t v6 = a3;
  *(void *)(v6 + 8) = a2;
  *(void *)(v6 + 16) = a4;
  *(void *)(v6 + 24) = a5;
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

void *sub_1CD504B8C(void *result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = result;
  uint64_t v5 = *result;
  uint64_t v6 = result[1];
  if ((unsigned char *)(*result + v6) == a2)
  {
    if ((unint64_t)(v6 + 1) > result[2]) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *(unsigned char *)(v5 + v6) = *a3;
    ++result[1];
  }
  else
  {
    if ((unint64_t)(v6 + 1) > result[2]) {
      llvm::SmallVectorBase<unsigned long long>::grow_pod();
    }
    *(unsigned char *)(v5 + v6) = *(unsigned char *)(v5 + v6 - 1);
    uint64_t v8 = result[1];
    uint64_t v9 = *result + v8 - 1;
    if ((unsigned char *)v9 != a2)
    {
      unint64_t result = memmove(a2 + 1, a2, v9 - (void)a2);
      uint64_t v8 = v4[1];
    }
    v4[1] = v8 + 1;
    *a2 = *a3;
  }
  return result;
}

void sub_1CD504C78()
{
}

void sub_1CD504D4C(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v3 = (long long *)*a1;
    uint64_t v4 = *a1 + 48 * v2;
    do
    {
      long long v5 = *v3;
      *(_DWORD *)(a2 + 16) = *((_DWORD *)v3 + 4);
      *(_OWORD *)a2 = v5;
      long long v6 = *(long long *)((char *)v3 + 24);
      *(void *)(a2 + 40) = *((void *)v3 + 5);
      *(_OWORD *)(a2 + 24) = v6;
      *((void *)v3 + 4) = 0;
      *((void *)v3 + 5) = 0;
      *((void *)v3 + 3) = 0;
      v3 += 3;
      a2 += 48;
    }
    while (v3 != (long long *)v4);
    uint64_t v7 = *((unsigned int *)a1 + 2);
    if (v7)
    {
      uint64_t v8 = (long long *)*a1;
      uint64_t v9 = 3 * v7;
      do
      {
        if (SHIBYTE(v8[v9 - 1]) < 0) {
          operator delete(*((void **)&v8[v9 - 1] - 1));
        }
        v9 -= 3;
      }
      while (v9 * 16);
    }
  }
}

uint64_t sub_1CD504DE4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  int v11 = a3;
  uint64_t v12 = a2;
  uint64_t v13 = a4;
  uint64_t v14 = a5;
  long long v6 = (_OWORD *)sub_1CB8968D4(a1, (unint64_t)&v11, 1);
  uint64_t v7 = (_OWORD *)(*(void *)a1 + 32 * *(unsigned int *)(a1 + 8));
  long long v8 = v6[1];
  _OWORD *v7 = *v6;
  v7[1] = v8;
  uint64_t v9 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v9;
  return *(void *)a1 + 32 * v9 - 32;
}

void llvm::cas::createInMemoryCAS(llvm::cas *this)
{
}

uint64_t sub_1CD504FBC(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(uint64_t **)(a1 + 16);
    uint64_t v4 = &v3[v2];
    do
    {
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v6 = *v3;
      if (*v3 == *(void *)(v5 + 8 * *(unsigned int *)(a1 + 24) - 8))
      {
        unint64_t v8 = *(void *)a1;
      }
      else
      {
        uint64_t v7 = (((unint64_t)v3 - v5) >> 10) & 0x1FFFFFF;
        if (v7 >= 0x1E) {
          LOBYTE(v7) = 30;
        }
        unint64_t v8 = v6 + (4096 << v7);
      }
      for (unint64_t i = ((v6 + 7) & 0xFFFFFFFFFFFFFFF8) + 24; i <= v8; i += 24)
      {
        BOOL v10 = *(void **)(i - 16);
        if (v10) {
          munmap(v10, *(void *)(i - 24));
        }
      }
      ++v3;
    }
    while (v3 != v4);
  }
  uint64_t v11 = *(unsigned int *)(a1 + 72);
  if (v11)
  {
    uint64_t v12 = *(void **)(a1 + 64);
    uint64_t v13 = &v12[2 * v11];
    do
    {
      unint64_t v14 = *v12 + v12[1];
      for (unint64_t j = ((*v12 + 7) & 0xFFFFFFFFFFFFFFF8) + 24; j <= v14; j += 24)
      {
        uint64_t v16 = *(void **)(j - 16);
        if (v16) {
          munmap(v16, *(void *)(j - 24));
        }
      }
      v12 += 2;
    }
    while (v12 != v13);
  }

  return sub_1CBFFBB10(a1);
}

uint64_t llvm::cas::CASID::dump(llvm::cas::CASID *this)
{
  llvm::dbgs(this);
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)this + 32);

  return v2();
}

uint64_t llvm::cas::ObjectStore::dump(llvm::cas::ObjectStore *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = *(uint64_t (**)(llvm::cas::ObjectStore *, llvm *))(*(void *)this + 112);

  return v3(this, v2);
}

void llvm::cas::ObjectRef::dump(llvm::cas::ObjectRef *this)
{
  uint64_t v2 = llvm::dbgs(this);

  llvm::cas::ReferenceBase::print((unint64_t *)this, v2);
}

void llvm::cas::ObjectHandle::dump(llvm::cas::ObjectHandle *this)
{
  uint64_t v2 = llvm::dbgs(this);

  llvm::cas::ReferenceBase::print((unint64_t *)this, v2);
}

void llvm::cas::CASID::toString(llvm::cas::CASID *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  int v3 = 0;
  char v7 = 0;
  uint64_t v8 = 0;
  BOOL v10 = a2;
  int v9 = 0;
  uint64_t v2 = &unk_1F2646F30;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  (*(void (**)(void, void **, llvm::cas::CASID *))(**(void **)this + 32))(*(void *)this, &v2, this);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v2);
}

void llvm::cas::ReferenceBase::print(unint64_t *a1, llvm::raw_ostream *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *a1;
  v3[0] = 0;
  char v6 = 0;
  sub_1CC230EE4(this, "object-handle", 0xDuLL, v2, v3);
  if (v6)
  {
    if (v4 != &v5) {
      free(v4);
    }
  }
}

{
  unint64_t v2;
  unsigned char v3[8];
  void *v4;
  uint64_t v5;
  char v6;
  uint64_t v7;

  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *a1;
  v3[0] = 0;
  char v6 = 0;
  sub_1CC230EE4(this, "object-ref", 0xAuLL, v2, v3);
  if (v6)
  {
    if (v4 != &v5) {
      free(v4);
    }
  }
}

void *llvm::cas::ObjectStore::getProxy@<X0>(llvm::cas::ObjectStore *this@<X0>, const llvm::cas::CASID *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (*(uint64_t (**)(llvm::cas::ObjectStore *))(*(void *)this + 32))(this);
  if (!(_BYTE)v7) {
    llvm::cas::ObjectStore::createUnknownObjectError(a2, v7);
  }

  return llvm::cas::ObjectStore::getProxy((uint64_t)this, v6, a3);
}

void llvm::cas::ObjectStore::createUnknownObjectError(llvm::cas::ObjectStore *this, const llvm::cas::CASID *a2)
{
  int v3 = std::generic_category();
  memset(&v8, 0, sizeof(v8));
  int v13 = 0;
  char v17 = 0;
  uint64_t v18 = 0;
  unint64_t v20 = &v8;
  int v19 = 0;
  uint64_t v12 = (void **)&unk_1F2646F30;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  (*(void (**)(void, void ***, llvm::cas::ObjectStore *))(**(void **)this + 32))(*(void *)this, &v12, this);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v12);
  uint64_t v4 = std::string::insert(&v8, 0, "unknown object '");
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v9.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v9.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  uint64_t v6 = std::string::append(&v9, "'");
  std::string::size_type v7 = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  std::string::size_type v11 = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  LOWORD(v16) = 260;
  uint64_t v12 = __p;
  sub_1CD4FF4BC(22, (uint64_t)v3, (llvm::Twine *)&v12);
}

void *llvm::cas::ObjectStore::getProxy@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = a1;
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unint64_t result = (*(void *(**)(uint64_t *__return_ptr))(*(void *)a1 + 48))(&v10);
  uint64_t v7 = v10;
  char v8 = *(unsigned char *)(a3 + 24);
  if ((v11 & 1) != 0 && v10)
  {
    char v9 = v8 | 1;
    uint64_t v4 = v10;
  }
  else
  {
    if (v11) {
      uint64_t v7 = 0;
    }
    char v9 = v8 & 0xFE;
    *(void *)(a3 + 8) = a2;
    *(void *)(a3 + 16) = v7;
  }
  *(unsigned char *)(a3 + 24) = v9;
  *(void *)a3 = v4;
  return result;
}

void *llvm::cas::ObjectStore::createProxy@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  unint64_t result = (*(void *(**)(void **__return_ptr))(*(void *)a1 + 8))(&v6);
  if (v7)
  {
    uint64_t v5 = (uint64_t)v6;
    *(unsigned char *)(a2 + 24) |= 1u;
    *(void *)a2 = v5;
  }
  else
  {
    unint64_t result = llvm::cas::ObjectStore::getProxy(a1, (uint64_t)v6, a2);
    if (v7)
    {
      unint64_t result = v6;
      uint64_t v6 = 0;
      if (result) {
        return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
      }
    }
  }
  return result;
}

void *llvm::cas::ObjectProxy::getMemoryBuffer@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v8 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)*a1 + 88))(*a1, a1[2], a4);

  return llvm::MemoryBuffer::getMemBuffer(v8, v9, a2, a3, a5);
}

void llvm::cas::getDefaultOnDiskCASStableID(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  if (*(void *)(a1 + 16) <= 0x1CuLL) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  qmemcpy(*(void **)a1, "/^llvm::cas::builtin::default", 29);
  *(void *)(a1 + 8) += 29;
  __int16 v7 = 261;
  v6[0] = "llvm.cas.builtin.default";
  v6[1] = (const char *)24;
  __int16 v5 = 261;
  v4[0] = "cas";
  v4[1] = (void *)3;
  __int16 v3 = 257;
  v1[16] = 257;
  llvm::sys::path::append((void *)a1, v6, v4, (uint64_t)v2, (uint64_t)v1);
}

void llvm::cas::getDefaultOnDiskCASStableID(std::string *a1@<X8>)
{
  v6[16] = *MEMORY[0x1E4F143B8];
  __s = (std::string::value_type *)v6;
  *(_OWORD *)__sz = xmmword_1CFAC3020;
  llvm::cas::getDefaultOnDiskCASStableID((uint64_t)&__s);
  if (!__s)
  {
    __int16 v3 = 0;
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    goto LABEL_5;
  }
  std::string::__init(a1, __s, __sz[0]);
  __int16 v3 = __s;
  if (__s != (std::string::value_type *)v6) {
LABEL_5:
  }
    free(v3);
}

void llvm::cas::getDefaultOnDiskCASPath(void *a1)
{
  if ((llvm::sys::path::cache_directory(a1) & 1) == 0) {
    llvm::report_fatal_error((llvm *)"cannot get default cache directory", (const llvm::Twine *)1);
  }
  __int16 v8 = 261;
  v7[0] = "llvm.cas.builtin.default";
  v7[1] = (const char *)24;
  __int16 v6 = 261;
  v5[0] = "cas";
  v5[1] = (void *)3;
  __int16 v4 = 257;
  v2[16] = 257;
  llvm::sys::path::append(a1, v7, v5, (uint64_t)v3, (uint64_t)v2);
}

void llvm::cas::getDefaultOnDiskCASPath(std::string *a1@<X8>)
{
  v6[16] = *MEMORY[0x1E4F143B8];
  __s = (std::string::value_type *)v6;
  *(_OWORD *)__sz = xmmword_1CFAC3020;
  llvm::cas::getDefaultOnDiskCASPath(&__s);
  if (!__s)
  {
    __int16 v3 = 0;
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    goto LABEL_5;
  }
  std::string::__init(a1, __s, __sz[0]);
  __int16 v3 = __s;
  if (__s != (std::string::value_type *)v6) {
LABEL_5:
  }
    free(v3);
}

uint64_t llvm::cas::TreeSchema::isNode(uint64_t a1, void *a2)
{
  uint64_t result = (*(uint64_t (**)(void, void))(*(void *)*a2 + 80))(*a2, a2[2]);
  if (result) {
    return (*(uint64_t (**)(void, void, void))(*(void *)*a2 + 72))(*a2, a2[2], 0) == *(void *)(a1 + 16);
  }
  return result;
}

llvm::cas::TreeSchema *llvm::cas::TreeSchema::TreeSchema(llvm::cas::TreeSchema *this, llvm::cas::ObjectStore *a2)
{
  _OWORD v5[2] = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1F2609460;
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 16) = 0;
  *((unsigned char *)this + 24) = 0;
  (*(void (**)(void *__return_ptr, llvm::cas::ObjectStore *, void, void, const char *, uint64_t))(*(void *)a2 + 8))(v5, a2, 0, 0, "llvm::cas::schema::tree::v1", 27);
  uint64_t v3 = v5[0];
  if (!*((unsigned char *)this + 24)) {
    *((unsigned char *)this + 24) = 1;
  }
  *((void *)this + 2) = v3;
  return this;
}

uint64_t llvm::cas::TreeSchema::getNumTreeEntries(uint64_t a1, void *a2)
{
  return (*(uint64_t (**)(void, void))(*(void *)*a2 + 80))(*a2, a2[2]) - 1;
}

uint64_t llvm::cas::TreeSchema::forEachTreeEntry@<X0>(void *a1@<X1>, uint64_t (*a2)(uint64_t, unsigned char *)@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void, void))(*(void *)*a1 + 80))(*a1, a1[2]);
  uint64_t v9 = result - 1;
  if (result == 1)
  {
LABEL_5:
    *a4 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    while (1)
    {
      long long v11 = *((_OWORD *)a1 + 1);
      v12[0] = *(_OWORD *)a1;
      v12[1] = v11;
      llvm::cas::TreeSchema::loadTreeEntry((llvm::cas::TreeProxy *)v12, v10, (uint64_t)v13);
      uint64_t result = a2(a3, v13);
      if (*a4) {
        break;
      }
      if (v9 == ++v10) {
        goto LABEL_5;
      }
    }
  }
  return result;
}

uint64_t llvm::cas::TreeSchema::loadTreeEntry@<X0>(llvm::cas::TreeProxy *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = (*(uint64_t (**)(void, void, void))(**(void **)a1 + 88))(*(void *)a1, *((void *)a1 + 2), 0);
  int v7 = *(char *)(v6
               + a2
               + 4
               * (*(uint64_t (**)(void, void))(**(void **)a1 + 80))(*(void *)a1, *((void *)a1 + 2)));
  uint64_t Name = llvm::cas::TreeProxy::getName(a1, a2);
  uint64_t v10 = v9;
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t))(**(void **)a1 + 72))(*(void *)a1, *((void *)a1 + 2), a2 + 1);
  *(_DWORD *)a3 = v7;
  *(void *)(a3 + 8) = result;
  *(void *)(a3 + 16) = Name;
  *(void *)(a3 + 24) = v10;
  return result;
}

uint64_t llvm::cas::TreeSchema::walkFileTreeRecursively@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, void (*a3)(uint64_t, long long *, const char **)@<X3>, uint64_t a4@<X4>, uint64_t *a5@<X8>)
{
  v59[2] = *MEMORY[0x1E4F143B8];
  v57[0] = 0;
  v57[1] = 0;
  v57[2] = v58;
  v57[3] = 0x400000000;
  v58[4] = v59;
  v58[5] = 0;
  v59[0] = 0;
  v59[1] = 1;
  char v43 = v57;
  uint64_t v9 = v56;
  uint64_t v54 = v56;
  long long v55 = xmmword_1CFAC3020;
  uint64_t v10 = v53;
  size_t v51 = v53;
  uint64_t v52 = 0x100000000;
  sub_1CD50619C((uint64_t)&v51, a2, 3);
  while (v52)
  {
    long long v11 = (char *)v51 + 32 * v52;
    int v13 = *((_DWORD *)v11 - 8);
    uint64_t v12 = v11 - 32;
    if (v13 == 3)
    {
      long long v15 = *(_OWORD *)v12;
      long long v42 = *((_OWORD *)v12 + 1);
      long long v41 = v15;
      LODWORD(v52) = v52 - 1;
      llvm::cas::TreeSchema::load(a1, *((uint64_t *)&v15 + 1), (uint64_t)&v48);
      char v34 = v50;
      if (v50)
      {
        uint64_t v24 = v48;
        *a5 = v48;
        if (v24) {
          goto LABEL_20;
        }
        uint64_t v16 = 0;
      }
      else
      {
        *a5 = 0;
        uint64_t v16 = (const char *)v48;
      }
      __n128 v25 = (void *)*((void *)&v48 + 1);
      long long v26 = v49;
      size_t v44 = v16;
      long long v45 = (void *)*((void *)&v48 + 1);
      long long v46 = v49;
      LOBYTE(v47) = 1;
      a3(a4, &v41, &v44);
      uint64_t v33 = *a5;
      if (*a5)
      {
        if ((v34 & 1) == 0 || !v16) {
          goto LABEL_20;
        }
LABEL_15:
        (*(void (**)(const char *))(*(void *)v16 + 8))(v16);
        if (v33) {
          goto LABEL_20;
        }
      }
      else
      {
        uint64_t v31 = v25;
        int v27 = (*(uint64_t (**)(const char *, void))(*(void *)v16 + 80))(v16, v26);
        if (v27 == 1)
        {
          if (v34) {
            goto LABEL_15;
          }
        }
        else
        {
          unsigned int v29 = v10;
          uint64_t v30 = v9;
          uint64_t v23 = v27 - 1 - 1;
          do
          {
            size_t v44 = v16;
            long long v45 = v31;
            long long v46 = v26;
            llvm::cas::TreeSchema::loadTreeEntry((llvm::cas::TreeProxy *)&v44, v23, (uint64_t)v39);
            int v32 = (int)v39[0];
            uint64_t v18 = v39[1];
            char v17 = (const char *)v39[2];
            int v19 = v39[3];
            *(void *)&long long v55 = 0;
            sub_1CC22C75C(&v54, (unsigned char *)v42, (unsigned char *)(v42 + *((void *)&v42 + 1)));
            __int16 v47 = 261;
            size_t v44 = v17;
            long long v45 = v19;
            __int16 v40 = 257;
            __int16 v38 = 257;
            __int16 v36 = 257;
            llvm::sys::path::append(&v54, (llvm::Twine *)1, &v44, v39, (uint64_t)v37, (uint64_t)v35);
            unint64_t v20 = llvm::StringSaver::save(&v43, v54, v55);
            sub_1CD504B58((uint64_t)&v51, (uint64_t)v18, v32, (uint64_t)v20, v21);
          }
          while (v23--);
          uint64_t v10 = v29;
          uint64_t v9 = v30;
          if (v34) {
            goto LABEL_15;
          }
        }
      }
    }
    else
    {
      long long v14 = *((_OWORD *)v12 + 1);
      long long v48 = *(_OWORD *)v12;
      long long v49 = v14;
      LODWORD(v52) = v52 - 1;
      LOBYTE(v44) = 0;
      LOBYTE(v47) = 0;
      a3(a4, &v48, &v44);
      if (*a5) {
        goto LABEL_20;
      }
    }
  }
  *a5 = 0;
LABEL_20:
  if (v51 != v10) {
    free(v51);
  }
  if (v54 != v9) {
    free(v54);
  }
  return sub_1CBFFBA64((uint64_t)v57);
}

uint64_t sub_1CD50619C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12)) {
    return sub_1CD506808(a1, a2, a3);
  }
  uint64_t v4 = *(void *)a1 + 32 * v3;
  *(_DWORD *)uint64_t v4 = a3;
  *(void *)(v4 + 8) = a2;
  *(void *)(v4 + 16) = "/";
  *(void *)(v4 + 24) = 1;
  ++*(_DWORD *)(a1 + 8);
  return a1;
}

uint64_t llvm::cas::TreeSchema::load@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t result = (uint64_t)llvm::cas::ObjectStore::getProxy(*(void *)(a1 + 8), a2, (uint64_t)&v9);
  if (v11)
  {
    uint64_t v6 = v9;
    *(unsigned char *)(a3 + 32) |= 1u;
    *(void *)a3 = v6;
  }
  else
  {
    long long v7 = v9;
    uint64_t v8 = v10;
    uint64_t result = llvm::cas::TreeSchema::load(a1, (uint64_t *)&v7, a3);
    if (v11)
    {
      uint64_t result = v9;
      *(void *)&long long v9 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
  }
  return result;
}

uint64_t llvm::cas::TreeProxy::getName(llvm::cas::TreeProxy *this, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)((*(uint64_t (**)(void, void, void))(**(void **)this + 88))(*(void *)this, *((void *)this + 2), 0)+ 4 * a2);
  (*(void (**)(void, void, void))(**(void **)this + 88))(*(void *)this, *((void *)this + 2), 0);
  return (*(uint64_t (**)(void, void, void))(**(void **)this + 88))(*(void *)this, *((void *)this + 2), 0)+ v3;
}

uint64_t *llvm::cas::TreeProxy::create@<X0>(llvm::cas::TreeProxy::Builder *a1@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  llvm::cas::TreeProxy::Builder::startNode(a1, (uint64_t)v9);
  if (v10)
  {
    uint64_t v7 = v9[0];
    v9[0] = 0;
    *(unsigned char *)(a4 + 32) |= 1u;
    *(void *)a4 = v7;
  }
  else
  {
    llvm::cas::TreeProxy::Builder::build(v9, a2, a3, a4);
  }
  return sub_1CD506880(v9);
}

void llvm::cas::TreeProxy::Builder::startNode(llvm::cas::TreeProxy::Builder *this@<X0>, uint64_t a2@<X8>)
{
  v9[16] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = this;
  uint64_t v4 = v6;
  long long v5 = xmmword_1CD96DBF0;
  uint64_t v7 = v9;
  v9[0] = *((void *)this + 2);
  uint64_t v8 = 0x1000000001;
  *(unsigned char *)(a2 + 432) &= ~1u;
  sub_1CD506908(a2, (uint64_t)&v3);
  if (v7 != v9) {
    free(v7);
  }
  if (v4 != v6) {
    free(v4);
  }
}

void llvm::cas::TreeProxy::Builder::build(uint64_t *a1@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v38[4] = *MEMORY[0x1E4F143B8];
  __int16 v36 = v38;
  uint64_t v37 = 0x100000000;
  sub_1CD506988((unsigned int *)&v36, a2, &a2[32 * a3]);
  sub_1CC231B04((uint64_t)v36, (__n128 *)v36 + 2 * v37, v6);
  uint64_t v7 = sub_1CC2322FC((uint64_t)v36, (_OWORD *)v36 + 2 * v37);
  LODWORD(v37) = (unint64_t)(v7 - (void)v36) >> 5;
  int v24 = 0;
  char v28 = 0;
  uint64_t v29 = 0;
  uint64_t v31 = a1 + 1;
  int v30 = 0;
  uint64_t v23 = &unk_1F2646FA8;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  int v27 = 0;
  int v8 = 5 * v37 + 4;
  if (v37)
  {
    uint64_t v9 = 32 * v37;
    char v10 = (char *)v36 + 24;
    do
    {
      *(_DWORD *)int v32 = v8;
      llvm::raw_ostream::write((llvm::raw_ostream *)&v23, v32, 4uLL);
      uint64_t v11 = *(v10 - 2);
      unint64_t v12 = *((unsigned int *)a1 + 74);
      if (v12 >= *((unsigned int *)a1 + 75)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v8 += *v10;
      v10 += 4;
      *(void *)(a1[36] + 8 * v12) = v11;
      ++*((_DWORD *)a1 + 74);
      v9 -= 32;
    }
    while (v9);
  }
  *(_DWORD *)int v32 = v8;
  llvm::raw_ostream::write((llvm::raw_ostream *)&v23, v32, 4uLL);
  if (v37)
  {
    int v13 = (int *)v36;
    uint64_t v14 = 32 * v37;
    do
    {
      int v15 = *v13;
      v13 += 8;
      v32[0] = v15;
      llvm::raw_ostream::write((llvm::raw_ostream *)&v23, v32, 1uLL);
      v14 -= 32;
    }
    while (v14);
    if (v37)
    {
      uint64_t v16 = 32 * v37;
      char v17 = (size_t *)((char *)v36 + 24);
      do
      {
        uint64_t v18 = (const void *)*(v17 - 1);
        size_t v19 = *v17;
        if (*v17 <= v26 - (uint64_t)v27)
        {
          if (v19)
          {
            memcpy(v27, v18, *v17);
            v27 += v19;
          }
        }
        else
        {
          llvm::raw_ostream::write((llvm::raw_ostream *)&v23, (const char *)v18, *v17);
        }
        v17 += 4;
        v16 -= 32;
      }
      while (v16);
    }
  }
  uint64_t v20 = *a1;
  llvm::cas::ObjectStore::createProxy(*(void *)(*a1 + 8), (uint64_t)&v33);
  if (v35)
  {
    uint64_t v22 = v33;
    *(unsigned char *)(a4 + 32) |= 1u;
    *(void *)a4 = v22;
    *(void *)&long long v33 = 0;
  }
  else
  {
    *(_OWORD *)a4 = v33;
    uint64_t v21 = v34;
    *(unsigned char *)(a4 + 32) &= ~1u;
    *(void *)(a4 + 16) = v21;
    *(void *)(a4 + 24) = v20;
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v23);
  if (v36 != v38) {
    free(v36);
  }
}

void sub_1CD5067AC()
{
}

void *sub_1CD5067C0()
{
  return &llvm::cas::TreeSchema::ID;
}

uint64_t sub_1CD5067CC(uint64_t a1, void *a2)
{
  BOOL v3 = a2 == &llvm::cas::NodeSchema::ID || a2 == &llvm::RTTIRoot::ID;
  return a2 == &llvm::cas::TreeSchema::ID || v3;
}

uint64_t sub_1CD506800()
{
  return 0;
}

uint64_t sub_1CD506808(uint64_t a1, uint64_t a2, int a3)
{
  int v9 = a3;
  uint64_t v10 = a2;
  uint64_t v11 = "/";
  uint64_t v12 = 1;
  uint64_t v4 = (_OWORD *)sub_1CB8968D4(a1, (unint64_t)&v9, 1);
  long long v5 = (_OWORD *)(*(void *)a1 + 32 * *(unsigned int *)(a1 + 8));
  long long v6 = v4[1];
  _OWORD *v5 = *v4;
  v5[1] = v6;
  uint64_t v7 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v7;
  return *(void *)a1 + 32 * v7 - 32;
}

uint64_t *sub_1CD506880(uint64_t *a1)
{
  if (a1[54])
  {
    uint64_t v4 = *a1;
    *a1 = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
  }
  else
  {
    unint64_t v2 = (uint64_t *)a1[36];
    if (v2 != a1 + 38) {
      free(v2);
    }
    BOOL v3 = (uint64_t *)a1[1];
    if (v3 != a1 + 4) {
      free(v3);
    }
  }
  return a1;
}

uint64_t sub_1CD506908(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = a1 + 32;
  uint64_t v4 = a1 + 8;
  *(_OWORD *)(a1 + 16) = xmmword_1CD96DBF0;
  if (*(void *)(a2 + 16)) {
    sub_1CC1B8518(v4, a2 + 8);
  }
  *(void *)(a1 + 288) = a1 + 304;
  *(void *)(a1 + 296) = 0x1000000000;
  if (*(_DWORD *)(a2 + 296)) {
    sub_1CD41C56C(a1 + 288, a2 + 288);
  }
  return a1;
}

unsigned int *sub_1CD506988(unsigned int *result, unsigned char *__src, unsigned char *a3)
{
  BOOL v3 = result;
  size_t v4 = a3 - __src;
  uint64_t v5 = result[2];
  if (v5 + ((a3 - __src) >> 5) > (unint64_t)result[3]) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (__src != a3)
  {
    uint64_t result = (unsigned int *)memcpy((void *)(*(void *)result + 32 * v5), __src, v4);
    LODWORD(v5) = v3[2];
  }
  v3[2] = v5 + (v4 >> 5);
  return result;
}

double sub_1CD506A10(uint64_t a1, __n128 *a2, unint64_t a3, __n128 *a4, uint64_t a5, __n128 a6)
{
  if (a3 >= 2)
  {
    uint64_t v7 = (__n128 *)a1;
    if (a3 == 2)
    {
      if (sub_1CD506DA0((const void *)a2[-1].n128_u64[0], a2[-1].n128_u64[1], *(void **)(a1 + 16), *(void *)(a1 + 24)))
      {
        __n128 v9 = *v7;
        a6 = v7[1];
        __n128 v10 = a2[-1];
        __n128 *v7 = a2[-2];
        v7[1] = v10;
        a2[-2] = v9;
        a2[-1] = a6;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v12 = a4;
      unint64_t v13 = a3 >> 1;
      uint64_t v14 = a1 + 32 * (a3 >> 1);
      unint64_t v15 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        sub_1CD506C08(a1, v14, v15, a4);
        char v17 = &v12[2 * v13];
        sub_1CD506C08((uint64_t)&v7[2 * (a3 >> 1)], (uint64_t)a2, a3 - (a3 >> 1), v17);
        uint64_t v18 = &v12[2 * a3];
        size_t v19 = v17;
        while (v19 != v18)
        {
          if (sub_1CD506DA0((const void *)v19[1].n128_u64[0], v19[1].n128_u64[1], (void *)v12[1].n128_u64[0], v12[1].n128_u64[1]))
          {
            a6 = *v19;
            __n128 v20 = v19[1];
            v19 += 2;
          }
          else
          {
            a6 = *v12;
            __n128 v20 = v12[1];
            v12 += 2;
          }
          __n128 *v7 = a6;
          v7[1] = v20;
          v7 += 2;
          if (v12 == v17)
          {
            if (v19 != v18)
            {
              uint64_t v21 = 0;
              do
              {
                uint64_t v22 = &v7[v21];
                a6 = v19[v21];
                __n128 v23 = v19[v21 + 1];
                *uint64_t v22 = a6;
                v22[1] = v23;
                v21 += 2;
              }
              while (&v19[v21] != v18);
            }
            return a6.n128_f64[0];
          }
        }
        if (v12 != v17)
        {
          uint64_t v24 = 0;
          do
          {
            uint64_t v25 = &v7[v24];
            a6 = v12[v24];
            __n128 v26 = v12[v24 + 1];
            *uint64_t v25 = a6;
            v25[1] = v26;
            v24 += 2;
          }
          while (&v12[v24] != v17);
        }
      }
      else
      {
        sub_1CD506A10(a1, v14, v15, a4, a5);
        sub_1CD506A10(&v7[2 * (a3 >> 1)], a2, a3 - (a3 >> 1), v12, a5);
        a6.n128_u64[0] = sub_1CC231CBC(v7, &v7[2 * (a3 >> 1)], a2, a3 >> 1, a3 - (a3 >> 1), (char *)v12, a5, v16).n128_u64[0];
      }
    }
    else
    {
      sub_1CC231BDC(a1, (long long *)a2);
    }
  }
  return a6.n128_f64[0];
}

void sub_1CD506C08(uint64_t a1, uint64_t a2, unint64_t a3, _OWORD *a4)
{
  if (a3)
  {
    size_t v4 = a4;
    uint64_t v6 = a1;
    if (a3 == 1)
    {
      long long v8 = *(_OWORD *)(a1 + 16);
      *a4 = *(_OWORD *)a1;
      a4[1] = v8;
    }
    else if (a3 == 2)
    {
      __n128 v9 = (_OWORD *)(a2 - 32);
      if (sub_1CD506DA0(*(const void **)(a2 - 16), *(void *)(a2 - 8), *(void **)(a1 + 16), *(void *)(a1 + 24)))
      {
        long long v10 = *(_OWORD *)(a2 - 16);
        _OWORD *v4 = *v9;
        v4[1] = v10;
        long long v11 = *(_OWORD *)v6;
        long long v12 = *(_OWORD *)(v6 + 16);
      }
      else
      {
        long long v23 = *(_OWORD *)(v6 + 16);
        _OWORD *v4 = *(_OWORD *)v6;
        v4[1] = v23;
        long long v11 = *v9;
        long long v12 = *(_OWORD *)(a2 - 16);
      }
      v4[2] = v11;
      v4[3] = v12;
    }
    else if ((uint64_t)a3 > 8)
    {
      unint64_t v13 = a1 + 32 * (a3 >> 1);
      sub_1CD506A10(a1, v13, a3 >> 1, a4, a3 >> 1);
      sub_1CD506A10(v6 + 32 * (a3 >> 1), a2, a3 - (a3 >> 1), &v4[2 * (a3 >> 1)], a3 - (a3 >> 1));
      unint64_t v14 = v6 + 32 * (a3 >> 1);
      while (v14 != a2)
      {
        if (sub_1CD506DA0(*(const void **)(v14 + 16), *(void *)(v14 + 24), *(void **)(v6 + 16), *(void *)(v6 + 24)))
        {
          long long v15 = *(_OWORD *)v14;
          long long v16 = *(_OWORD *)(v14 + 16);
          v14 += 32;
        }
        else
        {
          long long v15 = *(_OWORD *)v6;
          long long v16 = *(_OWORD *)(v6 + 16);
          v6 += 32;
        }
        _OWORD *v4 = v15;
        v4[1] = v16;
        v4 += 2;
        if (v6 == v13)
        {
          if (v14 != a2)
          {
            unint64_t v17 = 0;
            do
            {
              uint64_t v18 = &v4[v17 / 0x10];
              long long v19 = *(_OWORD *)(v14 + v17 + 16);
              _OWORD *v18 = *(_OWORD *)(v14 + v17);
              v18[1] = v19;
              v17 += 32;
            }
            while (v14 + v17 != a2);
          }
          return;
        }
      }
      if (v6 != v13)
      {
        unint64_t v20 = 0;
        do
        {
          uint64_t v21 = &v4[v20 / 0x10];
          long long v22 = *(_OWORD *)(v6 + v20 + 16);
          *uint64_t v21 = *(_OWORD *)(v6 + v20);
          v21[1] = v22;
          v20 += 32;
        }
        while (v6 + v20 != v13);
      }
    }
    else
    {
      sub_1CC232228(a1, a2, a4);
    }
  }
}

BOOL sub_1CD506DA0(const void *a1, size_t a2, void *__s2, size_t a4)
{
  if (a4 >= a2) {
    size_t v6 = a2;
  }
  else {
    size_t v6 = a4;
  }
  if (v6 && (int v7 = memcmp(a1, __s2, v6)) != 0)
  {
    int v8 = (v7 >> 31) | 1;
  }
  else
  {
    if (a2 < a4) {
      int v8 = -1;
    }
    else {
      int v8 = 1;
    }
    if (a2 == a4) {
      int v8 = 0;
    }
  }
  return v8 == -1;
}

BOOL sub_1CD506E04(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2 || *(void *)(a1 + 8) != *(void *)(a2 + 8)) {
    return 0;
  }
  size_t v3 = *(void *)(a1 + 24);
  if (v3 != *(void *)(a2 + 24)) {
    return 0;
  }
  if (v3) {
    return memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), v3) == 0;
  }
  return 1;
}

__n128 sub_1CD506E6C(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD506EE8(a1, a2, 1);
  uint64_t v4 = *(void *)a1 + 48 * *(unsigned int *)(a1 + 8);
  long long v5 = *(_OWORD *)v3;
  *(void *)(v4 + 16) = *(void *)(v3 + 16);
  *(_OWORD *)uint64_t v4 = v5;
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  *(void *)unint64_t v3 = 0;
  *(void *)(v4 + 24) = 0;
  *(void *)(v4 + 32) = 0;
  *(void *)(v4 + 40) = 0;
  __n128 result = *(__n128 *)(v3 + 24);
  *(__n128 *)(v4 + 24) = result;
  *(void *)(v4 + 40) = *(void *)(v3 + 40);
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 40) = 0;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

unint64_t sub_1CD506EE8(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 48 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD506F54();
    }
    sub_1CD506F54();
  }
  return a2;
}

void sub_1CD506F54()
{
}

uint64_t sub_1CD506FC4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  std::string::__init(&v5, (const std::string::value_type *)(*(void *)(a2 + 16) + 16), **(void **)(a2 + 16));
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(std::string *)a1 = v5;
  sub_1CC233E3C((char **)(a1 + 24), *(void *)(a1 + 32), *(uint64_t **)a2, (uint64_t *)(*(void *)a2 + 32 * *(void *)(a2 + 8)), *(void *)(a2 + 8));
  return a1;
}

unsigned int *sub_1CD507044(unsigned int *a1, unsigned int a2, uint64_t a3)
{
  *a1 = a2;
  std::string v5 = (uint64_t *)(a1 + 8);
  unint64_t v6 = a2;
  int v15 = 0;
  sub_1CD5085F8((void *)a1 + 1, a2, &v15);
  int v15 = 0;
  sub_1CD5085F8(v5, v6, &v15);
  *((void *)a1 + 8) = 0;
  *((void *)a1 + 9) = 0;
  *((void *)a1 + 7) = a1 + 16;
  int v15 = 0;
  sub_1CD5085F8((void *)a1 + 10, v6, &v15);
  int v15 = 0;
  int v7 = sub_1CD5085F8((void *)a1 + 13, v6, &v15);
  int v8 = -1;
  uint64_t v9 = a3 + 48;
  do
  {
    uint64_t v9 = *(void *)(v9 + 8);
    ++v8;
  }
  while (v9 != a3 + 48);
  if (*a1)
  {
    unint64_t v10 = 0;
    uint64_t v11 = *v5;
    uint64_t v12 = *((void *)a1 + 10);
    uint64_t v13 = *v7;
    do
    {
      *(_DWORD *)(v11 + 4 * v10) = v10;
      *(_DWORD *)(v12 + 4 * v10) = -1;
      *(_DWORD *)(v13 + 4 * v10++) = v8;
    }
    while (v10 < *a1);
  }
  return a1;
}

void *sub_1CD507144(void *result, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = result[4];
  uint64_t v4 = result[1];
  unint64_t v5 = *(unsigned int *)(v3 + 4 * a2);
  do
  {
    unint64_t v6 = v5;
    unint64_t v5 = *(unsigned int *)(v4 + 4 * v5);
  }
  while (v5 != v6);
  unint64_t v7 = *(unsigned int *)(v3 + 4 * a3);
  do
  {
    unint64_t v8 = v7;
    unint64_t v7 = *(unsigned int *)(v4 + 4 * v7);
  }
  while (v7 != v8);
  if (v6) {
    unint64_t v9 = v8;
  }
  else {
    unint64_t v9 = 0;
  }
  if (v9 == v6) {
    unint64_t v6 = v8;
  }
  if (v6 >= (result[2] - v4) >> 2) {
    abort();
  }
  *(_DWORD *)(v4 + 4 * v6) = v9;
  return result;
}

char *sub_1CD5071B0(void *a1, unsigned int a2)
{
  uint64_t v7 = a1[1];
  unint64_t v5 = (_DWORD *)a1[2];
  unint64_t v6 = (char **)(a1 + 1);
  unint64_t v8 = (unint64_t)v6[2];
  unint64_t v9 = ((unint64_t)v5 - v7) >> 2;
  int v11 = v9;
  if ((unint64_t)v5 >= v8)
  {
    __n128 result = sub_1CBFFBD60(v6, &v11);
    LODWORD(v9) = v11;
  }
  else
  {
    _DWORD *v5 = v9;
    __n128 result = (char *)(v5 + 1);
  }
  a1[2] = result;
  *(_DWORD *)(a1[4] + 4 * a2) = v9;
  return result;
}

uint64_t sub_1CD507220(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  *(void *)a1 = &unk_1F2609548;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 40);
  *(void *)(a1 + 24) = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 104))(*(void *)(a2 + 16));
  uint64_t v7 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 16) + 176))(*(void *)(*(void *)(a1 + 8) + 16));
  *(void *)(a1 + 48) = a1 + 64;
  *(void *)(a1 + 32) = v7;
  *(void *)(a1 + 40) = a3;
  *(void *)(a1 + 56) = 0x600000000;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = *(unsigned int *)(a4 + 8);
  if (v8)
  {
    for (uint64_t i = 0; i != v8; ++i)
    {
      llvm::TargetRegisterInfo::getAllocatableSet(*(void *)(a1 + 32), *(void *)(a1 + 8), *(void **)(*(void *)a4 + 8 * i), (uint64_t)&v18);
      uint64_t v10 = *(unsigned int *)(a1 + 56);
      if (v10)
      {
        int v11 = *(void **)(a1 + 48);
        uint64_t v12 = 8 * v10;
        while (!*v11)
        {
          ++v11;
          v12 -= 8;
          if (!v12) {
            goto LABEL_7;
          }
        }
        if (*(_DWORD *)(a1 + 112) < v21) {
          sub_1CB8F8DF4(a1 + 48, v21, 0);
        }
        uint64_t v13 = (char *)v18;
        if (v19)
        {
          uint64_t v14 = 0;
          uint64_t v15 = *(void *)(a1 + 48);
          uint64_t v16 = 8 * v19;
          do
          {
            *(void *)(v15 + v14) |= *(void *)&v13[v14];
            v14 += 8;
          }
          while (v16 != v14);
        }
      }
      else
      {
LABEL_7:
        sub_1CBAF13E8(a1 + 48, (uint64_t)&v18);
        *(_DWORD *)(a1 + 112) = v21;
        uint64_t v13 = (char *)v18;
      }
      if (v13 != (char *)&v20) {
        free(v13);
      }
    }
  }
  return a1;
}

void sub_1CD507408(llvm::AntiDepBreaker *this)
{
  *(void *)this = &unk_1F2609548;
  uint64_t v2 = *((void *)this + 15);
  if (v2)
  {
    uint64_t v4 = sub_1CD50852C(v2);
    MEMORY[0x1D25D9CE0](v4, 0x1030C403AA5FAB9);
  }
  uint64_t v3 = (char *)*((void *)this + 6);
  if (v3 != (char *)this + 64) {
    free(v3);
  }

  llvm::AntiDepBreaker::~AntiDepBreaker(this);
}

void sub_1CD507494(llvm::AntiDepBreaker *a1)
{
  sub_1CD507408(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5074CC()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t sub_1CD507764(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 120);
  if (result)
  {
    uint64_t v3 = sub_1CD50852C(result);
    uint64_t result = MEMORY[0x1D25D9CE0](v3, 0x1030C403AA5FAB9);
  }
  *(void *)(a1 + 120) = 0;
  return result;
}

void sub_1CD5077AC(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  v17[0] = 0;
  v17[1] = 0;
  uint64_t v16 = (uint64_t *)v17;
  sub_1CD5078B4((uint64_t)a1, a2, &v16);
  sub_1CD5079C8((uint64_t)a1, a2, a3, (uint64_t)&v16);
  sub_1CD507DE4(a1, a2, a3);
  uint64_t v8 = a1[4];
  if (*(_DWORD *)(v8 + 16))
  {
    unsigned int v9 = 0;
    uint64_t v10 = a1[15];
    do
    {
      int v11 = (void *)a1[15];
      uint64_t v12 = v9;
      if (*(_DWORD *)(v11[10] + 4 * v9) != -1 && *(_DWORD *)(v11[13] + 4 * v9) == -1)
      {
        sub_1CD507144(v11, v9, 0);
        uint64_t v8 = a1[4];
      }
      else
      {
        uint64_t v13 = *(void *)(v10 + 104);
        unsigned int v14 = *(_DWORD *)(v13 + 4 * v12);
        if (v14 < a4 && v14 >= a3) {
          *(_DWORD *)(v13 + 4 * v12) = a3;
        }
      }
      unsigned int v9 = v12 + 1;
    }
    while (v12 + 1 != *(_DWORD *)(v8 + 16));
  }
  sub_1CB833A08((uint64_t)&v16, v17[0]);
}

uint64_t sub_1CD5078B4(uint64_t result, uint64_t a2, uint64_t **a3)
{
  uint64_t v3 = *(unsigned int *)(a2 + 40);
  if (v3)
  {
    uint64_t v6 = result;
    for (uint64_t i = 0; i != v3; ++i)
    {
      uint64_t v8 = *(void *)(a2 + 32);
      uint64_t v9 = v8 + 32 * i;
      int v10 = *(_DWORD *)v9;
      if (!*(_DWORD *)v9)
      {
        if ((v10 & 0x1000000) != 0
          && ((v10 & 0x10000FF) == 0x1000000 ? (BOOL v11 = (v10 & 0xF00000) == 0) : (BOOL v11 = 1), !v11)
          || (uint64_t result = sub_1CD50803C(a2, v10, *(_DWORD *)(v9 + 4)), result))
        {
          uint64_t v12 = *(void *)(v6 + 32);
          uint64_t v13 = (void *)(v12 + 8);
          if (!v12) {
            uint64_t v13 = 0;
          }
          uint64_t v14 = v13[6];
          if (v14)
          {
            unsigned int v15 = *(_DWORD *)(v8 + 32 * i + 4);
            uint64_t v16 = (unsigned __int16 *)(v14 + 2 * *(unsigned int *)(*v13 + 24 * v15 + 4));
            do
            {
              unsigned int v18 = (unsigned __int16)v15;
              uint64_t result = (uint64_t)sub_1CD508748(a3, &v18, &v18);
              int v17 = *v16++;
              v15 += v17;
            }
            while (v17);
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1CD5079C8(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int *)(a2 + 40);
  if (!v4) {
    return result;
  }
  uint64_t v7 = result;
  uint64_t v8 = *(void *)(result + 120);
  uint64_t v9 = 32 * v4;
  int v10 = (unsigned int *)(*(void *)(a2 + 32) + 4);
  do
  {
    if ((*(v10 - 1) & 0x10000FF) == 0x1000000 && *v10) {
      uint64_t result = sub_1CD5080D4(v7, *v10, a3 + 1);
    }
    v10 += 8;
    v9 -= 32;
  }
  while (v9);
  uint64_t v11 = *(unsigned int *)(a2 + 40);
  if (!v11) {
    return result;
  }
  for (unint64_t i = 0; i != v11; ++i)
  {
    uint64_t v13 = (_DWORD *)(*(void *)(a2 + 32) + 32 * i);
    if ((*v13 & 0x10000FF) != 0x1000000) {
      continue;
    }
    unsigned int v14 = v13[1];
    if (!v14) {
      continue;
    }
    __int16 v15 = *(_WORD *)(a2 + 44);
    int v16 = v15 & 0xC;
    if ((v15 & 0xC) != 0 && (v15 & 4) == 0)
    {
      if (llvm::MachineInstr::hasPropertyInBundle(a2, 128, 1)) {
        goto LABEL_23;
      }
      __int16 v15 = *(_WORD *)(a2 + 44);
      int v16 = v15 & 0xC;
    }
    else if ((*(unsigned char *)(*(void *)(a2 + 16) + 8) & 0x80) != 0)
    {
      goto LABEL_23;
    }
    if (!v16 || (v15 & 4) != 0)
    {
      if ((*(unsigned char *)(*(void *)(a2 + 16) + 12) & 1) == 0)
      {
LABEL_43:
        if (((*(uint64_t (**)(void, uint64_t))(**(void **)(v7 + 24) + 768))(*(void *)(v7 + 24), a2) & 1) == 0
          && **(unsigned __int16 **)(a2 + 16) - 1 > 1)
        {
          goto LABEL_24;
        }
      }
    }
    else if (!llvm::MachineInstr::hasPropertyInBundle(a2, 0x100000000, 1))
    {
      goto LABEL_43;
    }
LABEL_23:
    sub_1CD507144(*(void **)(v7 + 120), v14, 0);
LABEL_24:
    uint64_t v18 = *(void *)(v7 + 32);
    if (v18) {
      unsigned int v19 = (void *)(v18 + 8);
    }
    else {
      unsigned int v19 = 0;
    }
    sub_1CB8FB608((uint64_t)&v42, v14, v19, 0);
    uint64_t v20 = v45;
    while (v20)
    {
LABEL_29:
      unsigned int v21 = *(void **)(v7 + 120);
      if (*(_DWORD *)(v21[10] + 4 * v46) != -1 && *(_DWORD *)(v21[13] + 4 * v46) == -1) {
        sub_1CD507144(v21, v14, v46);
      }
      while (1)
      {
        sub_1CB8FB704((uint64_t)&v42);
        uint64_t v20 = v45;
        if ((_BYTE)v44 || v45 == 0) {
          break;
        }
        if (v42 != v46) {
          goto LABEL_29;
        }
      }
    }
    if (i >= *(unsigned __int16 *)(*(void *)(a2 + 16) + 2)) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = (*(uint64_t (**)(void))(**(void **)(v7 + 24) + 16))(*(void *)(v7 + 24));
    }
    unsigned int v42 = v14;
    char v43 = v13;
    uint64_t v44 = v23;
    uint64_t result = (uint64_t)sub_1CD50898C((uint64_t **)(v8 + 56), (int *)&v42);
  }
  uint64_t v24 = *(unsigned int *)(a2 + 40);
  if (v24)
  {
    uint64_t v25 = *(_DWORD **)(a2 + 32);
    __n128 v26 = &v25[8 * v24];
    do
    {
      if ((*v25 & 0x10000FF) == 0x1000000)
      {
        unsigned int v27 = v25[1];
        if (v27)
        {
          if (**(_WORD **)(a2 + 16) != 7)
          {
            for (unint64_t j = *(uint64_t **)(a4 + 8); j; unint64_t j = (uint64_t *)*j)
            {
              unsigned int v29 = *((_DWORD *)j + 7);
              if (v27 >= v29)
              {
                if (v29 >= v27) {
                  goto LABEL_51;
                }
                ++j;
              }
            }
            uint64_t v30 = *(void *)(v7 + 32);
            if (v30) {
              uint64_t v31 = (void *)(v30 + 8);
            }
            else {
              uint64_t v31 = 0;
            }
            uint64_t result = sub_1CB8FB608((uint64_t)&v42, v25[1], v31, 1);
            uint64_t v32 = v45;
            while (v32)
            {
LABEL_63:
              long long v33 = (_WORD *)(*(void *)(*(void *)(v7 + 32) + 56)
                            + 2 * *(unsigned int *)(*(void *)(*(void *)(v7 + 32) + 8) + 24 * v27 + 8));
              BOOL v34 = *v33 == 0;
              if (*v33)
              {
                unsigned int v35 = (unsigned __int16)*v33 + v27;
                if (v46 != (unsigned __int16)v35)
                {
                  __int16 v36 = v33 + 1;
                  do
                  {
                    int v38 = *v36++;
                    int v37 = v38;
                    BOOL v34 = v38 == 0;
                    if (!v38) {
                      __int16 v36 = 0;
                    }
                    if (!v37) {
                      break;
                    }
                    v35 += v37;
                  }
                  while (v46 != (unsigned __int16)v35);
                }
              }
              if (v34
                || (uint64_t v40 = *(void *)(v7 + 120), *(_DWORD *)(*(void *)(v40 + 80) + 4 * v46) == -1)
                || *(_DWORD *)(*(void *)(v40 + 104) + 4 * v46) != -1)
              {
                *(_DWORD *)(*(void *)(v8 + 104) + 4 * v46) = a3;
              }
              while (1)
              {
                uint64_t result = sub_1CB8FB704((uint64_t)&v42);
                uint64_t v32 = v45;
                if ((_BYTE)v44 || v45 == 0) {
                  break;
                }
                if (v42 != v46) {
                  goto LABEL_63;
                }
              }
            }
          }
        }
      }
LABEL_51:
      v25 += 8;
    }
    while (v25 != v26);
  }
  return result;
}

uint64_t *sub_1CD507DE4(uint64_t *result, uint64_t a2, int a3)
{
  uint64_t v4 = (uint64_t)result;
  uint64_t v5 = result[15];
  __int16 v6 = *(_WORD *)(a2 + 44);
  int v7 = v6 & 0xC;
  if ((v6 & 0xC) != 0 && (v6 & 4) == 0)
  {
    BOOL v9 = 1;
    uint64_t result = (uint64_t *)llvm::MachineInstr::hasPropertyInBundle(a2, 128, 1);
    if (result) {
      goto LABEL_7;
    }
    __int16 v6 = *(_WORD *)(a2 + 44);
    int v7 = v6 & 0xC;
  }
  else if ((*(unsigned char *)(*(void *)(a2 + 16) + 8) & 0x80) != 0)
  {
LABEL_6:
    BOOL v9 = 1;
    goto LABEL_7;
  }
  int v22 = v6 & 4;
  if (v7) {
    BOOL v23 = v22 == 0;
  }
  else {
    BOOL v23 = 0;
  }
  if (v23)
  {
    BOOL v9 = 1;
    uint64_t result = (uint64_t *)llvm::MachineInstr::hasPropertyInBundle(a2, 0x80000000, 1);
    if (result) {
      goto LABEL_7;
    }
  }
  else if ((*(unsigned char *)(*(void *)(a2 + 16) + 11) & 0x80) != 0)
  {
    goto LABEL_6;
  }
  uint64_t result = (uint64_t *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v4 + 24) + 768))(*(void *)(v4 + 24), a2);
  if (result) {
    goto LABEL_6;
  }
  BOOL v9 = **(unsigned __int16 **)(a2 + 16) - 1 < 2;
LABEL_7:
  uint64_t v10 = *(unsigned int *)(a2 + 40);
  if (v10)
  {
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    uint64_t v13 = (uint64_t **)(v5 + 56);
    do
    {
      unsigned int v14 = (_DWORD *)(*(void *)(a2 + 32) + v11);
      if ((*v14 & 0x10000FF) == 0)
      {
        unsigned int v15 = v14[1];
        if (v15)
        {
          sub_1CD5080D4(v4, v14[1], a3);
          if (v9) {
            sub_1CD507144(*(void **)(v4 + 120), v15, 0);
          }
          if (v12 >= *(unsigned __int16 *)(*(void *)(a2 + 16) + 2)) {
            uint64_t v16 = 0;
          }
          else {
            uint64_t v16 = (*(uint64_t (**)(void))(**(void **)(v4 + 24) + 16))(*(void *)(v4 + 24));
          }
          unsigned int v25 = v15;
          __n128 v26 = v14;
          uint64_t v27 = v16;
          uint64_t result = sub_1CD50898C(v13, (int *)&v25);
        }
      }
      ++v12;
      v11 += 32;
    }
    while (v10 != v12);
  }
  if (**(_WORD **)(a2 + 16) == 7)
  {
    uint64_t v17 = *(unsigned int *)(a2 + 40);
    if (v17)
    {
      unsigned int v18 = 0;
      uint64_t v19 = *(void *)(a2 + 32);
      uint64_t v20 = 32 * v17;
      unsigned int v21 = (unsigned int *)(v19 + 4);
      do
      {
        if (!*((unsigned char *)v21 - 4) && *v21)
        {
          if (v18) {
            uint64_t result = sub_1CD507144(*(void **)(v4 + 120), v18, *v21);
          }
          else {
            unsigned int v18 = *v21;
          }
        }
        v21 += 8;
        v20 -= 32;
      }
      while (v20);
    }
  }
  return result;
}

uint64_t sub_1CD50803C(uint64_t a1, int a2, unsigned int a3)
{
  if ((a2 & 0x20000FF) != 0x2000000 || a3 == 0) {
    return 0;
  }
  if ((a2 & 0x1000000) != 0) {
    unsigned int RegisterUseOperandIdx = llvm::MachineInstr::findRegisterUseOperandIdx(a1, a3, 1, 0);
  }
  else {
    unsigned int RegisterUseOperandIdx = llvm::MachineInstr::findRegisterDefOperandIdx(a1, a3, 0, 0, 0);
  }
  if (RegisterUseOperandIdx == -1) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 32) + 32 * RegisterUseOperandIdx;
  if (!v7) {
    return 0;
  }
  else {
    return (*(unsigned __int8 *)(v7 + 3) >> 1) & 1;
  }
}

uint64_t sub_1CD5080D4(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 120);
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    uint64_t v8 = (void *)(v7 + 8);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = a2;
  uint64_t result = sub_1CB8FB608((uint64_t)v29, a2, v8, 1);
  if (v31)
  {
    while (1)
    {
LABEL_5:
      uint64_t v11 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 56)
                    + 2 * *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24 * v9 + 8));
      BOOL v12 = *v11 == 0;
      if (*v11)
      {
        unsigned int v13 = (unsigned __int16)*v11 + a2;
        if (v32 != (unsigned __int16)v13)
        {
          unsigned int v14 = v11 + 1;
          do
          {
            int v16 = *v14++;
            int v15 = v16;
            BOOL v12 = v16 == 0;
            if (!v16) {
              unsigned int v14 = 0;
            }
            if (!v15) {
              break;
            }
            v13 += v15;
          }
          while (v32 != (unsigned __int16)v13);
        }
      }
      if (!v12)
      {
        uint64_t v17 = *(void *)(a1 + 120);
        if (*(_DWORD *)(*(void *)(v17 + 80) + 4 * v32) != -1
          && *(_DWORD *)(*(void *)(v17 + 104) + 4 * v32) == -1)
        {
          break;
        }
      }
      while (1)
      {
        uint64_t result = sub_1CB8FB704((uint64_t)v29);
        if (v30 || v31 == 0) {
          break;
        }
        if (v29[0] != v32) {
          goto LABEL_5;
        }
      }
      if (!v31) {
        goto LABEL_22;
      }
    }
  }
  else
  {
LABEL_22:
    uint64_t v19 = *(void *)(a1 + 120);
    if (*(_DWORD *)(*(void *)(v19 + 80) + 4 * v9) == -1 || *(_DWORD *)(*(void *)(v19 + 104) + 4 * v9) != -1)
    {
      *(_DWORD *)(*(void *)(v6 + 80) + 4 * v9) = a3;
      *(_DWORD *)(*(void *)(v6 + 104) + 4 * v9) = -1;
      sub_1CD508828((uint64_t **)(v6 + 56), a2);
      uint64_t result = (uint64_t)sub_1CD5071B0(*(void **)(a1 + 120), a2);
      uint64_t v20 = *(void *)(a1 + 32);
      unsigned int v21 = v20 ? (void *)(v20 + 8) : 0;
      uint64_t v22 = v21[6];
      uint64_t v23 = *(unsigned int *)(*v21 + 24 * v9 + 4);
      if (*(_WORD *)(v22 + 2 * v23))
      {
        unsigned __int16 v24 = *(_WORD *)(v22 + 2 * v23) + a2;
        unsigned int v25 = (unsigned __int16 *)(v22 + 2 * v23 + 2);
        do
        {
          unsigned int v26 = v24;
          uint64_t v27 = *(void *)(a1 + 120);
          if (*(_DWORD *)(*(void *)(v27 + 80) + 4 * v24) == -1
            || *(_DWORD *)(*(void *)(v27 + 104) + 4 * v24) != -1)
          {
            *(_DWORD *)(*(void *)(v6 + 80) + 4 * v24) = a3;
            *(_DWORD *)(*(void *)(v6 + 104) + 4 * v24) = -1;
            sub_1CD508828((uint64_t **)(v6 + 56), v24);
            uint64_t result = (uint64_t)sub_1CD5071B0(*(void **)(a1 + 120), v26);
          }
          int v28 = *v25++;
          unsigned __int16 v24 = v28 + v26;
        }
        while (v28);
      }
    }
  }
  return result;
}

void sub_1CD5082FC(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v6 = *(_DWORD *)(a2[4] + 16);
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x600000000;
  sub_1CB90D610(a1, (v6 + 63) >> 6, 0);
  *(_DWORD *)(a1 + 64) = v6;
  uint64_t v7 = sub_1CD508888(a2[15] + 56, a3);
  if (v7 != v8)
  {
    uint64_t v9 = v7;
    uint64_t v10 = v8;
    char v11 = 1;
    do
    {
      BOOL v12 = (void *)v9[6];
      if (v12)
      {
        llvm::TargetRegisterInfo::getAllocatableSet(a2[4], a2[1], v12, (uint64_t)&v28);
        if (v11)
        {
          if (*(_DWORD *)(a1 + 64) < v31) {
            sub_1CB8F8DF4(a1, v31, 0);
          }
          uint64_t v13 = v29;
          if (v29)
          {
            unsigned int v14 = (uint64_t *)v28;
            int v15 = *(void **)a1;
            do
            {
              uint64_t v16 = *v14++;
              *v15++ |= v16;
              --v13;
            }
            while (v13);
          }
        }
        else
        {
          unsigned int v17 = *(_DWORD *)(a1 + 8);
          unsigned int v18 = v29;
          if (v29 >= v17) {
            uint64_t v19 = v17;
          }
          else {
            uint64_t v19 = v29;
          }
          if (v19)
          {
            uint64_t v20 = (uint64_t *)v28;
            unsigned int v21 = *(void **)a1;
            uint64_t v22 = v19;
            do
            {
              uint64_t v23 = *v20++;
              *v21++ &= v23;
              --v22;
            }
            while (v22);
          }
          if (v17 > v18)
          {
            unsigned __int16 v24 = *(void **)a1;
            do
            {
              v24[v19] = 0;
              LODWORD(v19) = v19 + 1;
            }
            while (v17 != v19);
          }
        }
        if (v28 != &v30) {
          free(v28);
        }
        char v11 = 0;
      }
      unsigned int v25 = (uint64_t *)v9[1];
      if (v25)
      {
        do
        {
          unsigned int v26 = v25;
          unsigned int v25 = (uint64_t *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          unsigned int v26 = (uint64_t *)v9[2];
          BOOL v27 = *v26 == (void)v9;
          uint64_t v9 = v26;
        }
        while (!v27);
      }
      uint64_t v9 = v26;
    }
    while (v26 != v10);
  }
}

void llvm::createAggressiveAntiDepBreaker()
{
}

uint64_t sub_1CD50852C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 104);
  if (v2)
  {
    *(void *)(a1 + 112) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 80);
  if (v3)
  {
    *(void *)(a1 + 88) = v3;
    operator delete(v3);
  }
  sub_1CD40B1BC(*(void **)(a1 + 64));
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4)
  {
    *(void *)(a1 + 40) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 8);
  if (v5)
  {
    *(void *)(a1 + 16) = v5;
    operator delete(v5);
  }
  return a1;
}

uint64_t sub_1CD508598(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  int v4 = **(unsigned __int16 **)(a2 + 16);
  if ((v4 - 13) > 1)
  {
    uint64_t result = *(void *)(a2 + 32);
    if (*(unsigned char *)result) {
      return result;
    }
    int v8 = *(_DWORD *)(result + 4);
  }
  else
  {
    uint64_t v5 = v4 == 14;
    uint64_t v6 = *(void *)(a2 + 32);
    uint64_t result = v6 + (v5 << 6);
    if (*(unsigned char *)result) {
      return result;
    }
    int v8 = *(_DWORD *)(v6 + ((unint64_t)v5 << 6) + 4);
  }
  if (v8 == a3) {
    return llvm::MachineOperand::setReg(result, a4);
  }
  return result;
}

void *sub_1CD5085F8(void *a1, unint64_t a2, int *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if (a2 >> 62) {
      abort();
    }
    uint64_t v6 = 4 * a2;
    uint64_t v7 = operator new(4 * a2);
    *a1 = v7;
    int v8 = &v7[a2];
    a1[2] = v8;
    int v9 = *a3;
    do
    {
      *v7++ = v9;
      v6 -= 4;
    }
    while (v6);
    a1[1] = v8;
  }
  return a1;
}

uint64_t *sub_1CD508670(uint64_t a1, unsigned int a2)
{
  int v4 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = v4;
  if (!v4) {
    return v3;
  }
  while (1)
  {
    unsigned int v5 = *((_DWORD *)v3 + 8);
    if (v5 <= a2) {
      break;
    }
    uint64_t v2 = v3;
LABEL_6:
    uint64_t v3 = (uint64_t *)*v3;
    if (!v3) {
      return v3;
    }
  }
  if (v5 < a2)
  {
    ++v3;
    goto LABEL_6;
  }
  uint64_t v7 = *v3;
  int v8 = v3;
  if (*v3)
  {
    int v8 = v3;
    do
    {
      unsigned int v9 = *(_DWORD *)(v7 + 32);
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        char v11 = (uint64_t *)v7;
      }
      else {
        char v11 = (uint64_t *)(v7 + 8);
      }
      if (v10) {
        int v8 = (void *)v7;
      }
      uint64_t v7 = *v11;
    }
    while (*v11);
  }
  uint64_t v12 = v3[1];
  if (v12)
  {
    do
    {
      unsigned int v13 = *(_DWORD *)(v12 + 32);
      BOOL v14 = v13 > a2;
      if (v13 <= a2) {
        int v15 = (uint64_t *)(v12 + 8);
      }
      else {
        int v15 = (uint64_t *)v12;
      }
      if (v14) {
        uint64_t v2 = (void *)v12;
      }
      uint64_t v12 = *v15;
    }
    while (*v15);
  }
  if (v8 == v2) {
    return 0;
  }
  uint64_t v3 = 0;
  do
  {
    uint64_t v16 = (void *)v8[1];
    if (v16)
    {
      do
      {
        unsigned int v17 = v16;
        uint64_t v16 = (void *)*v16;
      }
      while (v16);
    }
    else
    {
      do
      {
        unsigned int v17 = (void *)v8[2];
        BOOL v18 = *v17 == (void)v8;
        int v8 = v17;
      }
      while (!v18);
    }
    uint64_t v3 = (uint64_t *)((char *)v3 + 1);
    int v8 = v17;
  }
  while (v17 != v2);
  return v3;
}

uint64_t **sub_1CD508748(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  unsigned int v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        unsigned int v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      unsigned int v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v8 = a1 + 1;
LABEL_10:
    BOOL v10 = (uint64_t *)v8;
    int v8 = (uint64_t **)operator new(0x20uLL);
    *((_DWORD *)v8 + 7) = *a3;
    void *v8 = 0;
    v8[1] = 0;
    void v8[2] = v10;
    void *v6 = (uint64_t *)v8;
    char v11 = (uint64_t *)**a1;
    uint64_t v12 = (uint64_t *)v8;
    if (v11)
    {
      *a1 = v11;
      uint64_t v12 = *v6;
    }
    sub_1CB8358B8(a1[1], v12);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v8;
}

void sub_1CD508828(uint64_t **a1, unsigned int a2)
{
  uint64_t v3 = sub_1CD508888((uint64_t)a1, a2);
  if (v3 != v4)
  {
    unsigned int v5 = v3;
    uint64_t v6 = v4;
    do
    {
      unsigned int v7 = sub_1CD508918(a1, v5);
      operator delete(v5);
      unsigned int v5 = v7;
    }
    while (v7 != v6);
  }
}

uint64_t *sub_1CD508888(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = (uint64_t *)(a1 + 8);
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  while (1)
  {
    unsigned int v4 = *((_DWORD *)v3 + 8);
    if (v4 <= a2) {
      break;
    }
    uint64_t v2 = v3;
LABEL_6:
    uint64_t v3 = (uint64_t *)*v3;
    if (!v3) {
      return v2;
    }
  }
  if (v4 < a2)
  {
    ++v3;
    goto LABEL_6;
  }
  uint64_t v6 = (uint64_t *)*v3;
  uint64_t result = v3;
  if (*v3)
  {
    uint64_t result = v3;
    do
    {
      unsigned int v7 = *((_DWORD *)v6 + 8);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        unsigned int v9 = (uint64_t **)v6;
      }
      else {
        unsigned int v9 = (uint64_t **)(v6 + 1);
      }
      if (v8) {
        uint64_t result = v6;
      }
      uint64_t v6 = *v9;
    }
    while (*v9);
  }
  uint64_t v10 = v3[1];
  if (v10)
  {
    do
    {
      if (*(_DWORD *)(v10 + 32) <= a2) {
        char v11 = (uint64_t *)(v10 + 8);
      }
      else {
        char v11 = (uint64_t *)v10;
      }
      uint64_t v10 = *v11;
    }
    while (*v11);
  }
  return result;
}

uint64_t *sub_1CD508918(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    unsigned int v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      unsigned int v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  uint64_t v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1CB91F7C8(v6, a2);
  return v3;
}

uint64_t *sub_1CD50898C(uint64_t **a1, int *a2)
{
  unsigned int v4 = (char *)operator new(0x38uLL);
  BOOL v5 = (uint64_t *)v4;
  unsigned int v6 = *a2;
  *((_DWORD *)v4 + 8) = *a2;
  *(_OWORD *)(v4 + 40) = *(_OWORD *)(a2 + 2);
  unsigned int v7 = a1 + 1;
  BOOL v8 = (uint64_t **)a1[1];
  if (v8)
  {
    do
    {
      while (1)
      {
        unsigned int v7 = v8;
        if (v6 >= *((_DWORD *)v8 + 8)) {
          break;
        }
        BOOL v8 = (uint64_t **)*v8;
        unsigned int v9 = v7;
        if (!*v7) {
          goto LABEL_8;
        }
      }
      BOOL v8 = (uint64_t **)v8[1];
    }
    while (v8);
    unsigned int v9 = v7 + 1;
  }
  else
  {
    unsigned int v9 = a1 + 1;
  }
LABEL_8:
  *(void *)unsigned int v4 = 0;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = v7;
  uint64_t *v9 = (uint64_t *)v4;
  uint64_t v10 = (uint64_t *)**a1;
  if (v10)
  {
    *a1 = v10;
    BOOL v5 = *v9;
  }
  uint64_t result = sub_1CB8358B8(a1[1], v5);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t **sub_1CD508A40(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  unsigned int v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        unsigned int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      BOOL v5 = v7[1];
      if (!v5)
      {
        unsigned int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v7 = a1 + 1;
LABEL_9:
    unsigned int v9 = (uint64_t *)v7;
    unsigned int v7 = (uint64_t **)operator new(0x70uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[5] = (uint64_t *)(v7 + 7);
    v7[6] = (uint64_t *)0x600000000;
    *((_DWORD *)v7 + 26) = 0;
    uint64_t *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    uint64_t *v6 = (uint64_t *)v7;
    uint64_t v10 = (uint64_t *)**a1;
    char v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      char v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t *sub_1CD508B24(uint64_t *result, unint64_t a2, _OWORD *a3)
{
  unsigned int v4 = result;
  unsigned int v6 = (uint64_t **)(result + 1);
  BOOL v5 = (uint64_t *)result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        unsigned int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      BOOL v5 = v7[1];
      if (!v5)
      {
        unsigned int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v7 = (uint64_t **)(result + 1);
LABEL_9:
    unsigned int v9 = operator new(0x30uLL);
    v9[2] = *a3;
    *(void *)unsigned int v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    uint64_t *v6 = (uint64_t *)v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      uint64_t *v4 = v10;
      char v11 = *v6;
    }
    else
    {
      char v11 = (uint64_t *)v9;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

uint64_t *sub_1CD508BE0(uint64_t *result, unsigned int a2, int a3, int a4)
{
  unsigned int v6 = result;
  unint64_t v8 = (uint64_t **)(result + 1);
  uint64_t v7 = result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v9 = (void *)v7;
        unsigned int v10 = *(_DWORD *)(v7 + 28);
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        unint64_t v8 = (uint64_t **)v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        unint64_t v8 = (uint64_t **)(v9 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v9 = result + 1;
LABEL_9:
    char v11 = operator new(0x28uLL);
    v11[7] = a3;
    v11[8] = a4;
    *(void *)char v11 = 0;
    *((void *)v11 + 1) = 0;
    *((void *)v11 + 2) = v9;
    void *v8 = (uint64_t *)v11;
    uint64_t v12 = *(void *)*v6;
    if (v12)
    {
      uint64_t *v6 = v12;
      unsigned int v13 = *v8;
    }
    else
    {
      unsigned int v13 = (uint64_t *)v11;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v6[1], v13);
    ++v6[2];
  }
  return result;
}

void sub_1CD508CA4(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (uint64_t *)(a1 + 8);
    do
    {
      unint64_t v4 = v2[4];
      BOOL v5 = v4 >= a2;
      if (v4 >= a2) {
        unsigned int v6 = v2;
      }
      else {
        unsigned int v6 = v2 + 1;
      }
      if (v5) {
        uint64_t v3 = v2;
      }
      uint64_t v2 = (void *)*v6;
    }
    while (*v6);
    if (v3 != (uint64_t *)(a1 + 8) && v3[4] <= a2)
    {
      sub_1CD491B50((uint64_t **)a1, v3);
      operator delete(v3);
    }
  }
}

uint64_t **sub_1CD508D28(uint64_t **a1, unint64_t a2, uint64_t **a3)
{
  unsigned int v6 = a1 + 1;
  BOOL v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        unint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        BOOL v5 = *v7;
        unsigned int v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      BOOL v5 = v7[1];
      if (!v5)
      {
        unsigned int v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    unsigned int v9 = (uint64_t *)v7;
    uint64_t v7 = (uint64_t **)operator new(0x30uLL);
    v7[4] = *a3;
    v7[5] = 0;
    uint64_t *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    void *v6 = (uint64_t *)v7;
    unsigned int v10 = (uint64_t *)**a1;
    char v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      char v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

uint64_t llvm::getFCmpCodeWithoutNaN(uint64_t result)
{
  int v1 = result - 1;
  if (result - 1) <= 0xD && ((0x3F3Fu >> v1)) {
    return dword_1CFAC6B78[v1];
  }
  return result;
}

void llvm::getEHScopeMembership(llvm *this@<X0>, uint64_t a2@<X8>)
{
  v41[16] = *MEMORY[0x1E4F143B8];
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  if (!*((unsigned char *)this + 635)) {
    return;
  }
  BOOL v5 = (char *)this + 320;
  unsigned int v6 = *(_DWORD *)(*((void *)this + 41) + 24);
  PersonalityFn = (llvm::Value *)llvm::Function::getPersonalityFn(*(llvm::Function **)this);
  unsigned int v9 = llvm::classifyEHPersonality(PersonalityFn, v8);
  uint64_t v10 = (*(uint64_t (**)(void))(**((void **)this + 2) + 104))(*((void *)this + 2));
  uint64_t v39 = v41;
  uint64_t v40 = 0x1000000000;
  __int16 v36 = v38;
  uint64_t v37 = 0x1000000000;
  long long v33 = v35;
  uint64_t v34 = 0x1000000000;
  unsigned int v31 = 0;
  uint64_t v11 = *((void *)this + 41);
  if ((char *)v11 == v5) {
    goto LABEL_36;
  }
  uint64_t v12 = v10;
  unsigned int v13 = v9 - 7;
  do
  {
    if (*(unsigned char *)(v11 + 187))
    {
      uint64_t v14 = v40;
      if (v40 >= (unint64_t)HIDWORD(v40)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v15 = (void **)&v39;
    }
    else if (v13 <= 1 && *(unsigned char *)(v11 + 184))
    {
      uint64_t v14 = v34;
      if (v34 >= (unint64_t)HIDWORD(v34)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v15 = &v33;
    }
    else
    {
      if (*(void *)(v11 + 64) != *(void *)(v11 + 72)) {
        goto LABEL_8;
      }
      uint64_t v14 = v37;
      if (v37 >= (unint64_t)HIDWORD(v37)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      int v15 = &v36;
    }
    *((void *)*v15 + v14) = v11;
    ++*((_DWORD *)v15 + 2);
LABEL_8:
    unint64_t FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator((llvm::MachineBasicBlock *)v11);
    if (v11 + 48 != FirstTerminator && *(_DWORD *)(v12 + 72) == **(unsigned __int16 **)(FirstTerminator + 16))
    {
      uint64_t v17 = *(void *)(FirstTerminator + 32);
      unsigned int v18 = v6;
      if (v13 >= 2) {
        unsigned int v18 = *(_DWORD *)(*(void *)(v17 + 48) + 24);
      }
      uint64_t v19 = *(void *)(v17 + 16);
      if (v31 >= 0x10uLL) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      uint64_t v20 = &v32[v31];
      void *v20 = v19;
      v20[1] = v18;
      ++v31;
    }
    uint64_t v11 = *(void *)(v11 + 8);
  }
  while ((char *)v11 != v5);
  if (v40)
  {
    sub_1CC236D58(a2, v6, *((void *)this + 41));
    if (v37)
    {
      unsigned int v21 = (uint64_t *)v36;
      uint64_t v22 = 8 * v37;
      do
      {
        uint64_t v23 = *v21++;
        sub_1CC236D58(a2, v6, v23);
        v22 -= 8;
      }
      while (v22);
    }
    if (v40)
    {
      unsigned __int16 v24 = v39;
      uint64_t v25 = 8 * v40;
      do
      {
        uint64_t v26 = *v24++;
        sub_1CC236D58(a2, *(_DWORD *)(v26 + 24), v26);
        v25 -= 8;
      }
      while (v25);
    }
    if (v34)
    {
      BOOL v27 = (uint64_t *)v33;
      uint64_t v28 = 8 * v34;
      do
      {
        uint64_t v29 = *v27++;
        sub_1CC236D58(a2, v6, v29);
        v28 -= 8;
      }
      while (v28);
    }
    if (v31)
    {
      uint64_t v30 = v32;
      do
      {
        sub_1CC236D58(a2, *((_DWORD *)v30 + 2), *(void *)v30);
        ++v30;
      }
      while (v30 != &v32[v31]);
    }
  }
LABEL_36:
  if (v33 != v35) {
    free(v33);
  }
  if (v36 != v38) {
    free(v36);
  }
  if (v39 != v41) {
    free(v39);
  }
}

uint64_t sub_1CD5091DC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a3;
  uint64_t v6 = *(unsigned int *)(result + 8);
  if (v6 + ((a3 - a5) >> 2) > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (a3 != a5)
  {
    uint64_t v7 = (_DWORD *)(*(void *)result + 4 * v6);
    do
    {
      int v8 = *(_DWORD *)(v5 - 4);
      v5 -= 4;
      *v7++ = v8;
    }
    while (v5 != a5);
    LODWORD(v6) = *(_DWORD *)(result + 8);
  }
  *(_DWORD *)(result + 8) = v6 + ((unint64_t)(a3 - a5) >> 2);
  return result;
}

BOOL sub_1CD509264(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  unint64_t v2 = *(void *)(a1 + 48) & 0xFFFFFFFFFFFFFFF8;
  if (v1 == v2) {
    return 0;
  }
  if (v2 && (*(unsigned char *)v2 & 4) != 0)
  {
    __int16 v3 = *(_WORD *)(v2 + 44);
  }
  else
  {
    while (1)
    {
      __int16 v3 = *(_WORD *)(v2 + 44);
      if ((v3 & 4) == 0) {
        break;
      }
      unint64_t v2 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
    }
  }
  int v4 = v3 & 0xC;
  int v5 = v3 & 4;
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return llvm::MachineInstr::hasPropertyInBundle(v2, 64, 1);
  }
  else {
    return (*(unsigned __int8 *)(*(void *)(v2 + 16) + 8) >> 6) & 1;
  }
}

uint64_t sub_1CD5092D4(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CD3C8538((uint64_t *)a2, a3, &v12);
  unsigned int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD3CDD8C(a2, (uint64_t)a3, a3, v12);
    unsigned int v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD509370(uint64_t result, uint64_t a2, char *a3, char *a4)
{
  int v5 = a3;
  uint64_t v6 = *(void *)result;
  uint64_t v7 = *(unsigned int *)(result + 8);
  if (*(void *)result + 8 * v7 == a2)
  {
    return sub_1CB91FB58(result, a3, a4);
  }
  else
  {
    uint64_t v8 = (a2 - v6) >> 3;
    unint64_t v9 = (a4 - a3) >> 3;
    if (v7 + v9 > *(unsigned int *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    char v10 = (char *)(v6 + 8 * v8);
    uint64_t v11 = (char *)(v6 + 8 * v7);
    unint64_t v12 = (v11 - v10) >> 3;
    if (v12 >= v9)
    {
      uint64_t result = sub_1CD4570C8(result, &v11[-8 * v9], (char *)(v6 + 8 * v7));
      if (&v11[-8 * v9] != v10) {
        uint64_t result = (uint64_t)memmove(&v10[8 * v9], v10, &v11[-8 * v9] - v10);
      }
      while (v5 != a4)
      {
        uint64_t v16 = *(void *)v5;
        v5 += 8;
        *(void *)char v10 = v16;
        v10 += 8;
      }
    }
    else
    {
      unsigned int v13 = v7 + ((unint64_t)(a4 - a3) >> 3);
      *(_DWORD *)(result + 8) = v13;
      if (v8 != v7)
      {
        uint64_t result = (uint64_t)memcpy((void *)(v6 + 8 * v13 - 8 * v12), v10, v11 - v10);
        do
        {
          uint64_t v14 = *(void *)v5;
          v5 += 8;
          *(void *)char v10 = v14;
          v10 += 8;
          --v12;
        }
        while (v12);
      }
      while (v5 != a4)
      {
        uint64_t v15 = *(void *)v5;
        v5 += 8;
        *(void *)uint64_t v11 = v15;
        v11 += 8;
      }
    }
  }
  return result;
}

void llvm::initializeAtomicExpandPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC8EA8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC237434;
    v4[1] = &v2;
    __int16 v3 = v4;
    std::__call_once(&qword_1EBCC8EA8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::expandAtomicRMWToCmpXchg(uint64_t **a1)
{
  v1[17] = *(void **)MEMORY[0x1E4F143B8];
  sub_1CC243A10((uint64_t)v1, a1, 0, 0, 0);
  sub_1CC2375C0((uint64_t)v1);
}

llvm::Instruction *sub_1CD509648(uint64_t *a1, uint64_t a2, uint64_t ***a3, uint64_t *a4, __int16 a5, __int16 a6, __int16 a7, char a8)
{
  LOBYTE(v11) = a5;
  if ((a5 & 0xFF00) == 0)
  {
    unint64_t v17 = (unint64_t)(sub_1CB83544C(*(void *)(*(void *)(a1[6] + 56) + 40) + 272, *a4) + 7) >> 3;
    if (v16 == 1) {
    unint64_t v11 = 63 - __clz(v17);
    }
  }
  unsigned int v18 = operator new(0xA0uLL);
  uint64_t v19 = 0;
  uint64_t v20 = (llvm::Instruction *)(v18 + 24);
  v18[29] = v18[29] & 0x38000000 | 3;
  do
  {
    unsigned int v21 = &v18[v19];
    *unsigned int v21 = 0;
    v21[1] = 0;
    v21[2] = 0;
    v21[3] = v20;
    v19 += 8;
  }
  while (v19 != 24);
  llvm::AtomicCmpXchgInst::AtomicCmpXchgInst((uint64_t)(v18 + 24), a2, a3, (uint64_t)a4, v11, a6, a7, a8, 0);
  __int16 v24 = 257;
  return sub_1CD509770(a1, v20, (uint64_t)v23);
}

llvm::Instruction *sub_1CD509770(uint64_t *a1, llvm::Instruction *a2, uint64_t a3)
{
  (*(void (**)(uint64_t, llvm::Instruction *, uint64_t, uint64_t, uint64_t))(*(void *)a1[10] + 16))(a1[10], a2, a3, a1[6], a1[7]);
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = *a1;
    uint64_t v7 = v6 + 16 * v5;
    do
    {
      llvm::Instruction::setMetadata(a2, *(_DWORD *)v6, *(llvm::MDNode **)(v6 + 8));
      v6 += 16;
    }
    while (v6 != v7);
  }
  return a2;
}

llvm::Instruction *sub_1CD5097F8(uint64_t *a1, __int16 a2, uint64_t a3, uint64_t *a4, __int16 a5, __int16 a6, char a7)
{
  LOBYTE(v9) = a5;
  if ((a5 & 0xFF00) == 0)
  {
    unint64_t v15 = (unint64_t)(sub_1CB83544C(*(void *)(*(void *)(a1[6] + 56) + 40) + 272, *a4) + 7) >> 3;
    if (v14 == 1) {
    unint64_t v9 = 63 - __clz(v15);
    }
  }
  uint64_t v16 = operator new(0x80uLL);
  v16[21] = v16[21] & 0x38000000 | 2;
  unint64_t v17 = (llvm::Instruction *)(v16 + 16);
  *(void *)uint64_t v16 = 0;
  *((void *)v16 + 1) = 0;
  *((void *)v16 + 2) = 0;
  *((void *)v16 + 3) = v16 + 16;
  *((void *)v16 + 4) = 0;
  *((void *)v16 + 5) = 0;
  *((void *)v16 + 6) = 0;
  *((void *)v16 + 7) = v16 + 16;
  llvm::AtomicRMWInst::AtomicRMWInst((llvm::Value *)(v16 + 16), a2, a3, a4, v9, a6, a7, 0);
  __int16 v20 = 257;
  return sub_1CD509770(a1, v17, (uint64_t)v19);
}

uint64_t sub_1CD509904(uint64_t (*a1)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  return a1(a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

llvm::Instruction *LLVMBuildUnreachable_0(uint64_t a1)
{
  unint64_t v2 = (llvm::UnreachableInst *)operator new(0x40uLL);
  *((_DWORD *)v2 + 5) &= 0x38000000u;
  llvm::UnreachableInst::UnreachableInst(v2, *(llvm::LLVMContext **)(a1 + 64), 0);
  __int16 v5 = 257;
  return sub_1CD509770((uint64_t *)a1, v2, (uint64_t)v4);
}

llvm::BasicTTIImpl *llvm::BasicTTIImpl::BasicTTIImpl(llvm::BasicTTIImpl *this, const llvm::TargetMachine *a2, const llvm::Function *a3)
{
  uint64_t v4 = *((void *)a3 + 5) + 272;
  *(void *)this = &unk_1F2609628;
  *((void *)this + 1) = v4;
  uint64_t v5 = (*(uint64_t (**)(const llvm::TargetMachine *, const llvm::Function *))(*(void *)a2 + 16))(a2, a3);
  *((void *)this + 2) = v5;
  *((void *)this + 3) = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 120))(v5);
  return this;
}

void sub_1CD509A40()
{
}

uint64_t sub_1CD509A54(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32))();
}

uint64_t sub_1CD509A7C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 40))(*(void *)(a1 + 16));
  if ((result & 0xFF00000000) == 0) {
    return 0;
  }
  return result;
}

uint64_t sub_1CD509AC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 56))();
}

uint64_t sub_1CD509AE8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 64))();
}

uint64_t sub_1CD509B10(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 88))();
}

uint64_t sub_1CD509B38(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 72))();
}

uint64_t sub_1CD509B60(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 80))();
}

void sub_1CD509B88(int **a1, long long *a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&llvm::PartialUnrollingThreshold, 0, 0);
  dword_1EBD04D78 = 0;
  qword_1EBD04D80 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBD04D88 = 0;
  llvm::PartialUnrollingThreshold = (uint64_t)&unk_1F2643F00;
  qword_1EBD04D90 = (uint64_t)&unk_1F2643DB0;
  qword_1EBD04D98 = (uint64_t)&unk_1F25EA168;
  qword_1EBD04DB0 = (uint64_t)&qword_1EBD04D98;
  llvm::cl::Option::setArgStr(v6, "partial-unrolling-threshold", 0x1BuLL);
  dword_1EBD04D78 = **a1;
  byte_1EBD04D8C = 1;
  dword_1EBD04D88 = dword_1EBD04D78;
  xmmword_1EBD04D18 = *a2;
  word_1EBD04D02 = (32 * (*a3 & 3)) | word_1EBD04D02 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::PartialUnrollingThreshold);
}

void llvm::initializeBranchFolderPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC8EB0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC243D5C;
    v4[1] = &v2;
    __int16 v3 = v4;
    std::__call_once(&qword_1EBCC8EB0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD509D24(uint64_t result, char a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = result + 56;
  *(void *)(result + 32) = result + 56;
  *(void *)(result + 40) = 2;
  *(_DWORD *)(result + 48) = 0;
  *(void *)(result + 72) = 0;
  *(void *)(result + 80) = 0;
  *(_DWORD *)(result + 88) = 0;
  *(void *)(result + 104) = 0;
  *(void *)(result + 112) = 0;
  *(void *)(result + 96) = 0;
  *(unsigned char *)(result + 122) = a3;
  *(_DWORD *)(result + 124) = a7;
  *(void *)(result + 160) = 0;
  *(void *)(result + 168) = result + 192;
  *(_OWORD *)(result + 176) = xmmword_1CD96EEC0;
  *(void *)(result + 208) = 0;
  *(_DWORD *)(result + 216) = 0;
  *(void *)(result + 224) = a4;
  *(void *)(result + 232) = a5;
  *(void *)(result + 240) = a6;
  if (!a7) {
    *(_DWORD *)(result + 124) = dword_1EBCC90B8;
  }
  if (dword_1EBCC8F38)
  {
    if (dword_1EBCC8F38 == 2)
    {
      a2 = 0;
    }
    else
    {
      if (dword_1EBCC8F38 != 1) {
        return result;
      }
      a2 = 1;
    }
  }
  *(unsigned char *)(result + 121) = a2;
  return result;
}

uint64_t sub_1CD509DC0(uint64_t a1, llvm::MachineBasicBlock *a2)
{
  unint64_t v15 = a2;
  uint64_t v4 = (int32x2_t *)*((void *)a2 + 4);
  uint64_t v6 = *((void *)a2 + 11);
  for (uint64_t i = *((void *)a2 + 12); v6 != i; uint64_t i = *((void *)a2 + 12))
  {
    llvm::MachineBasicBlock::removeSuccessor((uint64_t)a2, (char *)(i - 8), 0);
    uint64_t v6 = *((void *)a2 + 11);
  }
  uint64_t v7 = sub_1CB896AE8(a1 + 24, (uint64_t)a2);
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = 40;
  if (v8 == *(void *)(a1 + 24)) {
    uint64_t v9 = 44;
  }
  if (v7 != (void *)(v8 + 8 * *(unsigned int *)(a1 + v9)))
  {
    void *v7 = -2;
    ++*(_DWORD *)(a1 + 48);
  }
  for (uint64_t j = *((void *)a2 + 7);
        (llvm::MachineBasicBlock *)j != (llvm::MachineBasicBlock *)((char *)a2 + 48);
        uint64_t j = *(void *)(j + 8))
  {
    if (llvm::MachineInstr::shouldUpdateCallSiteInfo((llvm::MachineInstr *)j)) {
      llvm::MachineFunction::eraseCallSiteInfo(v4, (const llvm::MachineInstr *)j);
    }
    if (!j || (*(unsigned char *)j & 4) == 0)
    {
      while ((*(_WORD *)(j + 44) & 8) != 0)
        uint64_t j = *(void *)(j + 8);
    }
  }
  uint64_t v11 = (uint64_t)&v4[40];
  llvm::ilist_callback_traits<llvm::MachineBasicBlock>::removeNodeFromList(v11, (uint64_t)a2);
  uint64_t v12 = *(void *)a2;
  unsigned int v13 = (void *)*((void *)a2 + 1);
  *unsigned int v13 = *(void *)a2;
  *(void *)(v12 + 8) = v13;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  llvm::ilist_alloc_traits<llvm::MachineBasicBlock>::deleteNode(v11, a2);
  uint64_t v16 = 0;
  uint64_t result = sub_1CD3C8538((uint64_t *)(a1 + 72), &v15, &v16);
  if (result)
  {
    void *v16 = -8192;
    *(int32x2_t *)(a1 + 80) = vadd_s32(*(int32x2_t *)(a1 + 80), (int32x2_t)0x1FFFFFFFFLL);
  }
  if (*(void *)(a1 + 152)) {
    llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::removeBlock();
  }
  return result;
}

uint64_t sub_1CD509F30(uint64_t a1, llvm *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    char v17 = 0;
    return v17 & 1;
  }
  sub_1CBFF3560((llvm::SmallPtrSetImplBase *)(a1 + 24));
  uint64_t v12 = *((void *)a2 + 5);
  *(unsigned char *)(a1 + 120) = a6;
  *(void *)(a1 + 144) = a4;
  *(void *)(a1 + 152) = a5;
  *(void *)(a1 + 128) = a3;
  *(void *)(a1 + 136) = v12;
  unsigned int v13 = *(unint64_t **)(*(void *)v12 + 360);
  unint64_t v14 = *v13;
  if ((*v13 & 4) != 0)
  {
    char v36 = (*(uint64_t (**)(uint64_t, llvm *))(*(void *)a4 + 424))(a4, a2);
    *(unsigned char *)(a1 + 123) = v36;
    if (v36) {
      goto LABEL_5;
    }
    unsigned int v13 = *(unint64_t **)(*(void *)v12 + 360);
    unint64_t v14 = *v13;
  }
  else
  {
    *(unsigned char *)(a1 + 123) = 0;
  }
  *unsigned int v13 = v14 & 0xFFFFFFFFFFFFFFFBLL;
LABEL_5:
  llvm::getEHScopeMembership(a2, (uint64_t)&v39);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);
  *(void *)(a1 + 72) = v39;
  *(void *)(a1 + 80) = v40;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  *(_DWORD *)(a1 + 88) = v41[0];
  v41[0] = 0;
  MEMORY[0x1D25D9CD0](0, 8);
  char v15 = 0;
  uint64_t v16 = (llvm *)((char *)a2 + 320);
  do
  {
    while (1)
    {
      char v17 = v15;
      int v18 = sub_1CD50A260(a1, (uint64_t)a2);
      if (*(unsigned char *)(a1 + 120) && v18 == 0) {
        break;
      }
      int v37 = v18;
      int v38 = sub_1CD50A8C0(a1, a2);
      int v20 = v37 | v38;
      if (*(unsigned char *)(a1 + 122)) {
        goto LABEL_13;
      }
      char v15 = 1;
      if ((v20 & 1) == 0) {
        goto LABEL_19;
      }
    }
    if (!*(unsigned char *)(a1 + 122)) {
      break;
    }
    int v20 = 0;
LABEL_13:
    unsigned int v21 = (llvm::MachineBasicBlock *)*((void *)a2 + 41);
    if (v21 == v16)
    {
      int v22 = 0;
    }
    else
    {
      int v22 = 0;
      do
      {
        uint64_t v23 = (llvm::MachineBasicBlock *)*((void *)v21 + 1);
        v22 |= sub_1CC246C3C(a1, v21);
        unsigned int v21 = v23;
      }
      while (v23 != v16);
    }
    char v15 = 1;
  }
  while (((v20 | v22) & 1) != 0);
LABEL_19:
  uint64_t v24 = *((void *)a2 + 9);
  if (v24)
  {
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v24 + 16) - *(void *)(v24 + 8)) >> 3);
    uint64_t v39 = v41;
    uint64_t v40 = 0x600000000;
    sub_1CB90D610((uint64_t)&v39, (v25 + 63) >> 6, 0);
    v41[12] = v25;
    for (uint64_t i = (llvm::MachineBasicBlock *)*((void *)a2 + 41); i != v16; uint64_t i = (llvm::MachineBasicBlock *)*((void *)i + 1))
    {
      for (uint64_t j = *((void *)i + 7);
            (llvm::MachineBasicBlock *)j != (llvm::MachineBasicBlock *)((char *)i + 48);
            uint64_t j = *(void *)(j + 8))
      {
        uint64_t v28 = *(unsigned int *)(j + 40);
        if (v28)
        {
          uint64_t v29 = (char *)v39;
          uint64_t v30 = 32 * v28;
          unsigned int v31 = (_DWORD *)(*(void *)(j + 32) + 16);
          do
          {
            if (*((unsigned char *)v31 - 16) == 8) {
              *(void *)&v29[((unint64_t)*v31 >> 3) & 0x1FFFFFF8] |= 1 << *v31;
            }
            v31 += 8;
            v30 -= 32;
          }
          while (v30);
          if (!j) {
            goto LABEL_32;
          }
        }
        if ((*(unsigned char *)j & 4) == 0)
        {
LABEL_32:
          while ((*(_WORD *)(j + 44) & 8) != 0)
            uint64_t j = *(void *)(j + 8);
        }
      }
    }
    uint64_t v32 = v39;
    if (v25)
    {
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      do
      {
        if (((v32[v34 >> 6] >> v34) & 1) == 0)
        {
          *(void *)(*(void *)(v24 + 8) + v33 + 8) = *(void *)(*(void *)(v24 + 8) + v33);
          char v17 = 1;
        }
        ++v34;
        v33 += 24;
      }
      while (v25 != v34);
    }
    if (v32 != (void *)v41) {
      free(v32);
    }
  }
  return v17 & 1;
}

uint64_t sub_1CD50A260(uint64_t a1, uint64_t a2)
{
  v57[16] = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 121))
  {
    LOBYTE(v41) = 0;
    return v41 & 1;
  }
  *(void *)(a1 + 8) = *(void *)a1;
  uint64_t v4 = *(llvm::MachineBasicBlock ***)(a2 + 328);
  uint64_t v44 = (llvm::MachineBasicBlock **)(a2 + 320);
  if (v4 == (llvm::MachineBasicBlock **)(a2 + 320)) {
    goto LABEL_25;
  }
  while (1)
  {
    uint64_t v6 = *(void **)a1;
    uint64_t v5 = *(void **)(a1 + 8);
    uint64_t v7 = (uint64_t)v5 - *(void *)a1;
    uint64_t v8 = v7 >> 4;
    uint64_t v9 = dword_1EBCC8FF8;
    if (v7 >> 4 == dword_1EBCC8FF8) {
      break;
    }
    char v10 = sub_1CB896AE8(a1 + 24, (uint64_t)v4);
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11 == *(void *)(a1 + 24)) {
      uint64_t v12 = 44;
    }
    else {
      uint64_t v12 = 40;
    }
    if (v10 == (void *)(v11 + 8 * *(unsigned int *)(a1 + v12)) && v4[11] == v4[12])
    {
      LODWORD(v56) = sub_1CC244C64((uint64_t)v4);
      *((void *)&v56 + 1) = v4;
      unsigned int v13 = *(_OWORD **)(a1 + 8);
      if ((unint64_t)v13 >= *(void *)(a1 + 16))
      {
        unint64_t v14 = sub_1CC016940((void **)a1, &v56);
      }
      else
      {
        *unsigned int v13 = v56;
        unint64_t v14 = v13 + 1;
      }
      *(void *)(a1 + 8) = v14;
    }
    uint64_t v4 = (llvm::MachineBasicBlock **)v4[1];
    if (v4 == v44)
    {
      uint64_t v6 = *(void **)a1;
      uint64_t v5 = *(void **)(a1 + 8);
      uint64_t v9 = dword_1EBCC8FF8;
      uint64_t v7 = (uint64_t)v5 - *(void *)a1;
      uint64_t v8 = v7 >> 4;
      break;
    }
  }
  if (v6 != v5 && v8 == v9)
  {
    do
    {
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 24), v6[1]);
      v6 += 2;
    }
    while (v6 != v5);
    uint64_t v7 = *(void *)(a1 + 8) - *(void *)a1;
  }
  if ((unint64_t)v7 < 0x11) {
LABEL_25:
  }
    int v41 = 0;
  else {
    int v41 = sub_1CD50B3D8((void *)a1, 0, 0, *(_DWORD *)(a1 + 124));
  }
  char v17 = *(llvm::MachineBasicBlock ***)(*(void *)(a2 + 328) + 8);
  if (v17 == v44) {
    return v41 & 1;
  }
  do
  {
    if (((v17[9] - v17[8]) & 0x7FFFFFFF0) == 0) {
      goto LABEL_82;
    }
    long long v48 = v52;
    long long v49 = v52;
    uint64_t v50 = 8;
    int v51 = 0;
    int v18 = *v17;
    *(void *)(a1 + 8) = *(void *)a1;
    if (*(unsigned char *)(a1 + 120)
      && (uint64_t v19 = *(void *)(a1 + 152)) != 0
      && (*(void *)&v56 = v17, __n128 v53 = 0, (sub_1CB834D78((uint64_t *)(v19 + 248), &v56, &v53) & 1) != 0))
    {
      uint64_t v20 = *((void *)v53 + 1);
      if (v20 && v17 == **(llvm::MachineBasicBlock ****)(v20 + 32)) {
        goto LABEL_80;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
    uint64_t v43 = v20;
    uint64_t v42 = v18;
    unsigned int v21 = (uint64_t *)v17[8];
    int v22 = (uint64_t *)v17[9];
    while (v21 != v22 && dword_1EBCC8FF8 != (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4)
    {
      uint64_t v23 = (llvm::MachineBasicBlock *)*v21;
      uint64_t v24 = sub_1CB896AE8(a1 + 24, *v21);
      uint64_t v25 = *(void *)(a1 + 32);
      if (v25 == *(void *)(a1 + 24)) {
        uint64_t v26 = 44;
      }
      else {
        uint64_t v26 = 40;
      }
      if (v24 == (void *)(v25 + 8 * *(unsigned int *)(a1 + v26)) && v23 != (llvm::MachineBasicBlock *)v17)
      {
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v48, (uint64_t)v23);
        if (v28
          && !llvm::MachineBasicBlock::hasEHPadSuccessor(v23)
          && !llvm::MachineBasicBlock::mayHaveInlineAsmBr(v23))
        {
          if (!*(unsigned char *)(a1 + 120)) {
            goto LABEL_55;
          }
          uint64_t v29 = *(void *)(a1 + 152);
          if (!v29) {
            goto LABEL_55;
          }
          *(void *)&long long v56 = v23;
          __n128 v53 = 0;
          int v30 = sub_1CB834D78((uint64_t *)(v29 + 248), &v56, &v53);
          uint64_t v31 = 0;
          if (v30) {
            uint64_t v31 = *((void *)v53 + 1);
          }
          if (v43 == v31)
          {
LABEL_55:
            unsigned __int16 v46 = 0;
            __int16 v47 = 0;
            *(void *)&long long v56 = v57;
            *((void *)&v56 + 1) = 0x400000000;
            if ((*(uint64_t (**)(void, llvm::MachineBasicBlock *, llvm::MachineBasicBlock ***, llvm::MachineBasicBlock ***, long long *, uint64_t))(**(void **)(a1 + 128) + 248))(*(void *)(a1 + 128), v23, &v47, &v46, &v56, 1))
            {
LABEL_56:
              if ((void *)v56 != v57) {
                free((void *)v56);
              }
              goto LABEL_46;
            }
            __n128 v53 = v55;
            uint64_t v54 = 0x400000000;
            if (!DWORD2(v56)) {
              goto LABEL_98;
            }
            sub_1CC248624((uint64_t)&v53, (uint64_t)&v56);
            uint64_t v32 = v47;
            if (DWORD2(v56) && v47 == v17)
            {
              if ((*(uint64_t (**)(void, void **))(**(void **)(a1 + 128) + 728))(*(void *)(a1 + 128), &v53))
              {
LABEL_65:
                if (v53 != v55) {
                  free(v53);
                }
                goto LABEL_56;
              }
              if (!v46 && *((llvm::MachineBasicBlock ***)v23 + 1) != v44) {
                unsigned __int16 v46 = (llvm::MachineBasicBlock **)*((void *)v23 + 1);
              }
LABEL_98:
              uint64_t v32 = v47;
            }
            if (v32 && (!DWORD2(v56) || v46))
            {
              llvm::MachineBasicBlock::findBranchDebugLoc(v23, (unsigned __int8 **)&v45);
              (*(void (**)(void, llvm::MachineBasicBlock *, void))(**(void **)(a1 + 128) + 264))(*(void *)(a1 + 128), v23, 0);
              if (DWORD2(v56))
              {
                if (v47 == v17) {
                  uint64_t v39 = v46;
                }
                else {
                  uint64_t v39 = v47;
                }
                (*(void (**)(void, llvm::MachineBasicBlock *, llvm::MachineBasicBlock **, void, void *, void, long long *, void))(**(void **)(a1 + 128) + 272))(*(void *)(a1 + 128), v23, v39, 0, v53, v54, &v45, 0);
              }
              if ((void)v45) {
                llvm::MetadataTracking::untrack((uint64_t)&v45, (unsigned __int8 *)v45);
              }
            }
            LODWORD(v45) = sub_1CC244C64((uint64_t)v23);
            *((void *)&v45 + 1) = v23;
            uint64_t v33 = *(_OWORD **)(a1 + 8);
            if ((unint64_t)v33 >= *(void *)(a1 + 16))
            {
              uint64_t v40 = sub_1CC016940((void **)a1, &v45);
            }
            else
            {
              *uint64_t v33 = v45;
              uint64_t v40 = v33 + 1;
            }
            *(void *)(a1 + 8) = v40;
            goto LABEL_65;
          }
        }
      }
LABEL_46:
      ++v21;
    }
    uint64_t v34 = *(void **)a1;
    unsigned int v35 = *(unsigned char **)(a1 + 8);
    uint64_t v36 = (uint64_t)&v35[-*(void *)a1];
    if (v35 != *(unsigned char **)a1 && v36 >> 4 == dword_1EBCC8FF8)
    {
      do
      {
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 24), v34[1]);
        v34 += 2;
      }
      while (v34 != (void *)v35);
      uint64_t v34 = *(void **)a1;
      unsigned int v35 = *(unsigned char **)(a1 + 8);
      uint64_t v36 = (uint64_t)&v35[-*(void *)a1];
    }
    if ((unint64_t)v36 >= 0x11)
    {
      v41 |= sub_1CD50B3D8((void *)a1, (uint64_t)v17, v42, *(_DWORD *)(a1 + 124));
      uint64_t v34 = *(void **)a1;
      unsigned int v35 = *(unsigned char **)(a1 + 8);
    }
    if (v35 - (unsigned char *)v34 == 16)
    {
      int v38 = (llvm::MachineBasicBlock *)v34[1];
      if (v38 != *v17) {
        sub_1CC244744(v38, (uint64_t)v17, *(void *)(a1 + 128));
      }
    }
LABEL_80:
    if (v49 != v48) {
      free(v49);
    }
LABEL_82:
    char v17 = (llvm::MachineBasicBlock **)v17[1];
  }
  while (v17 != v44);
  return v41 & 1;
}

uint64_t sub_1CD50A8C0(uint64_t a1, llvm::MachineFunction *this)
{
  llvm::MachineFunction::RenumberBlocks(this, 0);
  llvm::getEHScopeMembership(this, (uint64_t)&v10);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);
  *(void *)(a1 + 72) = v10;
  *(void *)(a1 + 80) = v11;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  *(_DWORD *)(a1 + 88) = v12;
  int v12 = 0;
  MEMORY[0x1D25D9CD0](0, 8);
  uint64_t v4 = (uint64_t *)((char *)this + 320);
  uint64_t v5 = *(uint64_t **)(*((void *)this + 41) + 8);
  if (v5 == v4)
  {
    char v6 = 0;
  }
  else
  {
    char v6 = 0;
    do
    {
      uint64_t v7 = (uint64_t *)v5[1];
      char v8 = sub_1CC244D70(a1, v5);
      if (v5[8] == v5[9])
      {
        sub_1CD509DC0(a1, (llvm::MachineBasicBlock *)v5);
        char v6 = 1;
      }
      else
      {
        v6 |= v8;
      }
      uint64_t v5 = v7;
    }
    while (v7 != v4);
  }
  return v6 & 1;
}

uint64_t sub_1CD50A9B0(uint64_t a1, unint64_t *a2, llvm::MachineBasicBlock *a3)
{
  if (*(unsigned char *)(a1 + 123))
  {
    char v6 = (const llvm::MachineFunction **)a2[3];
    *(void *)(a1 + 176) = 0;
    llvm::LivePhysRegs::addLiveOuts((llvm::LivePhysRegs *)(a1 + 160), v6);
    uint64_t v7 = (const llvm::MachineInstr *)(v6 + 6);
    do
    {
      uint64_t v7 = (const llvm::MachineInstr *)(*(void *)v7 & 0xFFFFFFFFFFFFFFF8);
      if (!v7 || (*(unsigned char *)v7 & 4) == 0)
      {
        while ((*((_WORD *)v7 + 22) & 4) != 0)
          uint64_t v7 = (const llvm::MachineInstr *)(*(void *)v7 & 0xFFFFFFFFFFFFFFF8);
      }
      llvm::LivePhysRegs::stepBackward((llvm::LivePhysRegs *)(a1 + 160), v7);
    }
    while (v7 != (const llvm::MachineInstr *)a2);
    uint64_t v8 = llvm::MachineBasicBlock::livein_begin(a3);
    uint64_t v9 = (unsigned __int16 *)*((void *)a3 + 20);
    if (v9 != (unsigned __int16 *)v8)
    {
      uint64_t v10 = (unsigned __int16 *)v8;
      do
      {
        unsigned int v11 = *v10;
        if (llvm::LivePhysRegs::available((llvm::LivePhysRegs *)(a1 + 160), *(const llvm::MachineRegisterInfo **)(a1 + 136), v11))
        {
          unsigned int v13 = 0;
          sub_1CB85AA4C((uint64_t)v6, a2, &v13, *(void *)(*(void *)(a1 + 128) + 8) + 480, v11);
          if (v13) {
            llvm::MetadataTracking::untrack((uint64_t)&v13, v13);
          }
        }
        v10 += 8;
      }
      while (v10 != v9);
    }
  }
  return (*(uint64_t (**)(void, unint64_t *, llvm::MachineBasicBlock *))(**(void **)(a1 + 128)
                                                                                          + 304))(*(void *)(a1 + 128), a2, a3);
}

unint64_t sub_1CD50AB00(uint64_t a1, uint64_t a2, unint64_t *a3, const llvm::BasicBlock *a4)
{
  if (!(*(unsigned int (**)(void))(**(void **)(a1 + 128) + 312))(*(void *)(a1 + 128))) {
    return 0;
  }
  unint64_t MachineBasicBlock = llvm::MachineFunction::CreateMachineBasicBlock(*(llvm::MachineFunction **)(a2 + 32), a4);
  unint64_t v22 = MachineBasicBlock;
  uint64_t v10 = *(unint64_t **)(a2 + 8);
  llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList(*(void *)(a2 + 32) + 320, MachineBasicBlock);
  unint64_t v11 = *v10;
  *(void *)unint64_t MachineBasicBlock = *v10;
  *(void *)(MachineBasicBlock + 8) = v10;
  *(void *)(v11 + 8) = MachineBasicBlock;
  *uint64_t v10 = MachineBasicBlock;
  llvm::MachineBasicBlock::transferSuccessors((char *)MachineBasicBlock, (llvm::MachineBasicBlock *)a2);
  llvm::MachineBasicBlock::addSuccessor((void *)a2, (void *)MachineBasicBlock, -1);
  int v12 = (unint64_t *)(a2 + 48);
  if ((unint64_t *)(a2 + 48) != a3 && MachineBasicBlock != a2)
  {
    unint64_t v13 = *(void *)(MachineBasicBlock + 40);
    unint64_t v14 = a3;
    do
    {
      v14[3] = v13;
      unint64_t v14 = (unint64_t *)v14[1];
    }
    while (v14 != v12);
    sub_1CB8F1D6C((unint64_t *)(MachineBasicBlock + 48), a3, v12);
  }
  uint64_t v15 = *(void *)(a1 + 152);
  if (v15)
  {
    uint64_t v23 = 0;
    uint64_t v24 = a2;
    if (sub_1CB834D78((uint64_t *)(v15 + 248), &v24, &v23))
    {
      if (*(void *)(v23 + 8)) {
        llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addBasicBlockToLoop();
      }
    }
  }
  uint64_t v16 = *(llvm::MBFIWrapper **)(a1 + 224);
  uint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(v16, (const llvm::MachineBasicBlock *)a2);
  llvm::MBFIWrapper::setBlockFreq((uint64_t)v16, MachineBasicBlock, BlockFreq);
  if (*(unsigned char *)(a1 + 123))
  {
    llvm::computeLiveIns((llvm *)(a1 + 160), (llvm::LivePhysRegs *)MachineBasicBlock, v18);
    llvm::addLiveIns((llvm *)MachineBasicBlock, (llvm::MachineBasicBlock *)(a1 + 160), v19);
  }
  uint64_t v20 = (uint64_t *)(a1 + 72);
  uint64_t v23 = a2;
  uint64_t v24 = 0;
  if (sub_1CD3C8538((uint64_t *)(a1 + 72), &v23, &v24)
    && v24 != *(void *)(a1 + 72) + 16 * *(unsigned int *)(a1 + 88))
  {
    int v21 = *(_DWORD *)(v24 + 8);
    *((_DWORD *)sub_1CD3CDD24(v20, &v22) + 2) = v21;
    return v22;
  }
  return MachineBasicBlock;
}

void sub_1CD50ACDC(void *a1, int a2, uint64_t a3, llvm::MachineBasicBlock *a4)
{
  uint64_t v8 = (_DWORD *)*a1;
  uint64_t v9 = (_DWORD *)(a1[1] - 16);
  while (1)
  {
    uint64_t v10 = v9;
    int v11 = *v9;
    if (v11 != a2) {
      break;
    }
    if (a3)
    {
      int v12 = (llvm::MachineBasicBlock *)*((void *)v10 + 1);
      if (v12 != a4) {
        sub_1CC244744(v12, a3, a1[16]);
      }
    }
    uint64_t v9 = v10 - 4;
    if (v10 == v8)
    {
      int v11 = *v8;
      goto LABEL_9;
    }
  }
  uint64_t v8 = v10;
LABEL_9:
  if (v11 == a2) {
    unint64_t v13 = v8;
  }
  else {
    unint64_t v13 = v10 + 4;
  }
  if (v13 != (_DWORD *)a1[1]) {
    a1[1] = v13;
  }
}

void sub_1CD50ADA0(uint64_t a1, unsigned int a2, const llvm::MachineBasicBlock *a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(a1 + 104);
  uint64_t v7 = *(llvm **)(*(void *)(v6 + 16 * a2) + 8);
  unint64_t v8 = v5 - v6;
  uint64_t v59 = v7;
  if (v5 == v6)
  {
    char v61 = 0;
    uint64_t v10 = 0;
  }
  else
  {
    if ((v8 & 0x8000000000000000) != 0) {
      abort();
    }
    unint64_t v9 = v8 >> 1;
    uint64_t v10 = (char *)operator new(v8 >> 1);
    uint64_t v60 = v9 & 0x7FFFFFFFFFFFFFF8;
    bzero(v10, v9 & 0x7FFFFFFFFFFFFFF8);
    uint64_t v11 = 0;
    int v12 = 0;
    unint64_t v13 = (void *)((char *)v7 + 48);
    do
    {
      if (v12 != a2)
      {
        uint64_t v14 = v6 + 16 * v11;
        *(void *)&v10[8 * v11] = *(void *)(v14 + 8);
        uint64_t v15 = *(void *)(v14 + 8);
        uint64_t v16 = *(void *)(v15 + 24);
        char v17 = (void *)(v16 + 48);
        if (v15 == v16 + 48)
        {
          int v18 = 0;
        }
        else
        {
          int v18 = 0;
          do
          {
            if (!v15 || (*(unsigned char *)v15 & 4) == 0)
            {
              while ((*(_WORD *)(v15 + 44) & 8) != 0)
                uint64_t v15 = *(void *)(v15 + 8);
            }
            ++v18;
            uint64_t v15 = *(void *)(v15 + 8);
          }
          while ((void *)v15 != v17);
        }
        unint64_t v19 = *v17 & 0xFFFFFFFFFFFFFFF8;
        if (!v19 || (*(unsigned char *)v19 & 4) == 0)
        {
          while ((*(_WORD *)(v19 + 44) & 4) != 0)
            unint64_t v19 = *(void *)v19 & 0xFFFFFFFFFFFFFFF8;
        }
        unint64_t v20 = *v13 & 0xFFFFFFFFFFFFFFF8;
        if (!v20 || (*(unsigned char *)v20 & 4) == 0)
        {
          while ((*(_WORD *)(v20 + 44) & 4) != 0)
            unint64_t v20 = *(void *)v20 & 0xFFFFFFFFFFFFFFF8;
        }
        while (v18)
        {
          --v18;
          int v21 = **(unsigned __int16 **)(v19 + 16);
          if ((v21 - 13) < 5 || v21 == 3)
          {
            unint64_t v19 = *(void *)v19 & 0xFFFFFFFFFFFFFFF8;
            if (!v19 || (*(unsigned char *)v19 & 4) == 0)
            {
              while ((*(_WORD *)(v19 + 44) & 4) != 0)
                unint64_t v19 = *(void *)v19 & 0xFFFFFFFFFFFFFFF8;
            }
          }
          else
          {
            uint64_t v46 = (uint64_t)v13;
            if ((void *)v20 != v13)
            {
              do
              {
                int v26 = **(unsigned __int16 **)(v20 + 16);
                if ((v26 - 13) >= 5 && v26 != 3)
                {
                  uint64_t v46 = v20;
                  goto LABEL_62;
                }
                unint64_t v20 = *(void *)v20 & 0xFFFFFFFFFFFFFFF8;
                if (!v20 || (*(unsigned char *)v20 & 4) == 0)
                {
                  while ((*(_WORD *)(v20 + 44) & 4) != 0)
                    unint64_t v20 = *(void *)v20 & 0xFFFFFFFFFFFFFFF8;
                }
              }
              while ((void *)v20 != v13);
              uint64_t v46 = (uint64_t)v13;
            }
LABEL_62:
            if (sub_1CBA0BB64(v46, 1) || sub_1CB8F9CA0(v46, 1))
            {
              char v28 = *(llvm::MachineFunction **)(v16 + 32);
              uint64_t v64 = (unsigned __int8 *)v46;
              uint64_t v65 = (void *)v19;
              llvm::MachineInstr::cloneMergedMemRefs((llvm::MachineInstr *)v46, v28, (uint64_t)&v64, 2);
            }
            uint64_t v29 = *(unsigned int *)(v46 + 40);
            if (v29)
            {
              uint64_t v25 = 0;
              uint64_t v30 = 32 * v29;
              do
              {
                uint64_t v23 = *(void *)(v46 + 32);
                int v24 = *(_DWORD *)(v23 + v25);
                if ((v24 & 0x100000FF) == 0x10000000 && (*(unsigned char *)(*(void *)(v19 + 32) + v25 + 3) & 0x10) == 0) {
                  *(_DWORD *)(v23 + v25) = v24 & 0xEFFFFFFF;
                }
                v25 += 32;
              }
              while (v30 != v25);
            }
            unint64_t v19 = *(void *)v19 & 0xFFFFFFFFFFFFFFF8;
            if (!v19 || (*(unsigned char *)v19 & 4) == 0)
            {
              while ((*(_WORD *)(v19 + 44) & 4) != 0)
                unint64_t v19 = *(void *)v19 & 0xFFFFFFFFFFFFFFF8;
            }
            unint64_t v20 = *(void *)v46 & 0xFFFFFFFFFFFFFFF8;
            if (!v20 || (*(unsigned char *)v20 & 4) == 0)
            {
              while ((*(_WORD *)(v20 + 44) & 4) != 0)
                unint64_t v20 = *(void *)v20 & 0xFFFFFFFFFFFFFFF8;
            }
          }
        }
      }
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v11 = ++v12;
    }
    while (v12 != (*(void *)(a1 + 104) - v6) >> 4);
    uint64_t v7 = v59;
    char v61 = &v10[v60];
  }
  uint64_t v31 = (char *)v7 + 48;
  uint64_t v32 = *((void *)v7 + 7);
  if ((llvm *)v32 != (llvm *)((char *)v7 + 48))
  {
    do
    {
      int v33 = **(unsigned __int16 **)(v32 + 16);
      if ((v33 - 13) >= 5 && v33 != 3)
      {
        unsigned int v35 = *(unsigned __int8 **)(v32 + 56);
        uint64_t v64 = v35;
        if (v35) {
          llvm::MetadataTracking::track((uint64_t)&v64, v35, 2);
        }
        if (v61 != v10)
        {
          uint64_t v36 = 0;
          unsigned int v37 = 0;
          do
          {
            if (v37 != a2)
            {
              for (uint64_t i = *(void *)&v10[8 * v36]; ; *(void *)&v10[8 * v36] = i)
              {
                int v39 = **(unsigned __int16 **)(i + 16);
                if ((v39 - 13) >= 5 && v39 != 3) {
                  break;
                }
                if ((*(unsigned char *)i & 4) == 0)
                {
                  while ((*(_WORD *)(i + 44) & 8) != 0)
                    uint64_t i = *(void *)(i + 8);
                }
                uint64_t i = *(void *)(i + 8);
              }
              int v41 = (llvm::DILocation *)llvm::DebugLoc::get((llvm::DebugLoc *)&v64);
              uint64_t v42 = (const llvm::DILocation *)llvm::DebugLoc::get((llvm::DebugLoc *)(*(void *)&v10[8 * v36] + 56));
              MergedLocation = llvm::DILocation::getMergedLocation(v41, v42, v43);
              llvm::DebugLoc::DebugLoc((llvm::DebugLoc *)&v63, MergedLocation);
              sub_1CB8F69CC(&v64, &v63);
              if (v63) {
                llvm::MetadataTracking::untrack((uint64_t)&v63, v63);
              }
              uint64_t v45 = *(void *)&v10[8 * v36];
              if (!v45 || (*(unsigned char *)v45 & 4) == 0)
              {
                while ((*(_WORD *)(v45 + 44) & 8) != 0)
                  uint64_t v45 = *(void *)(v45 + 8);
              }
              *(void *)&v10[8 * v36] = *(void *)(v45 + 8);
            }
            uint64_t v36 = ++v37;
          }
          while ((v61 - v10) >> 3 > (unint64_t)v37);
        }
        int v62 = v64;
        if (v64) {
          llvm::MetadataTracking::track((uint64_t)&v62, v64, 2);
        }
        sub_1CB8F69CC((unsigned __int8 **)(v32 + 56), &v62);
        if (v62) {
          llvm::MetadataTracking::untrack((uint64_t)&v62, v62);
        }
        if (v64) {
          llvm::MetadataTracking::untrack((uint64_t)&v64, v64);
        }
        if (!v32) {
          goto LABEL_113;
        }
      }
      if ((*(unsigned char *)v32 & 4) == 0)
      {
LABEL_113:
        while ((*(_WORD *)(v32 + 44) & 8) != 0)
          uint64_t v32 = *(void *)(v32 + 8);
      }
      uint64_t v32 = *(void *)(v32 + 8);
    }
    while ((char *)v32 != v31);
  }
  if (*(unsigned char *)(a1 + 123))
  {
    uint64_t v47 = *(void *)(a1 + 144);
    uint64_t v64 = (unsigned __int8 *)v47;
    uint64_t v65 = v67;
    long long v66 = xmmword_1CD96EEC0;
    BOOL v68 = 0;
    int v69 = 0;
    int v48 = *(_DWORD *)(v47 + 16);
    if (v48)
    {
      BOOL v68 = sub_1CC248524(*(unsigned int *)(v47 + 16), 1uLL);
      int v69 = v48;
    }
    llvm::computeLiveIns((llvm *)&v64, v59, a3);
    uint64_t v49 = *(void *)(a1 + 144);
    *(void *)(a1 + 160) = v49;
    *(void *)(a1 + 176) = 0;
    sub_1CD50BAB8((void *)(a1 + 168), *(_DWORD *)(v49 + 16));
    int v51 = (const llvm::MachineFunction ***)*((void *)v59 + 8);
    uint64_t v52 = (const llvm::MachineFunction ***)*((void *)v59 + 9);
    while (v51 != v52)
    {
      __n128 v53 = *v51;
      *(void *)(a1 + 176) = 0;
      llvm::LivePhysRegs::addLiveOuts((llvm::LivePhysRegs *)(a1 + 160), v53);
      unint64_t FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator((llvm::MachineBasicBlock *)v53);
      if ((void)v66)
      {
        long long v55 = (unint64_t *)FirstTerminator;
        long long v56 = (unsigned __int16 *)v65;
        uint64_t v57 = 2 * v66;
        do
        {
          unsigned int v58 = *v56;
          if (llvm::LivePhysRegs::available((llvm::LivePhysRegs *)(a1 + 160), *(const llvm::MachineRegisterInfo **)(a1 + 136), v58))
          {
            char v63 = 0;
            sub_1CB85AA4C((uint64_t)v53, v55, &v63, *(void *)(*(void *)(a1 + 128) + 8) + 480, v58);
            if (v63) {
              llvm::MetadataTracking::untrack((uint64_t)&v63, v63);
            }
          }
          ++v56;
          v57 -= 2;
        }
        while (v57);
      }
      ++v51;
    }
    *((void *)v59 + 20) = *((void *)v59 + 19);
    llvm::addLiveIns(v59, (llvm::MachineBasicBlock *)&v64, v50);
    free(v68);
    if (v65 != v67) {
      free(v65);
    }
  }
  if (v10) {
    operator delete(v10);
  }
}

uint64_t sub_1CD50B3D8(void *a1, uint64_t a2, llvm::MachineBasicBlock *a3, unsigned int a4)
{
  uint64_t v36 = a3;
  uint64_t v7 = (void *)*a1;
  uint64_t v8 = a1[1];
  unint64_t v9 = v8 - (void)v7;
  if (v8 - (uint64_t)v7 >= 32)
  {
    qsort(v7, v9 >> 4, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1CC2485DC);
    uint64_t v8 = a1[1];
    unint64_t v9 = v8 - *a1;
  }
  if (v9 >= 0x11)
  {
    char v10 = 0;
    while (1)
    {
      int v11 = *(_DWORD *)(v8 - 16);
      int v12 = v36;
      sub_1CC243DF8(a1, v11, a4, a2, v36);
      unint64_t v13 = (char *)a1[12];
      uint64_t v14 = (char *)a1[13];
      if (v13 == v14)
      {
        uint64_t v15 = a1;
        int v16 = v11;
        uint64_t v17 = a2;
        int v18 = v12;
      }
      else
      {
        uint64_t v19 = v14 - v13;
        unint64_t v20 = (unint64_t)v19 >> 4;
        if (v19 != 32)
        {
          if ((v19 & 0xFFFFFFFF0) != 0)
          {
LABEL_18:
            uint64_t v23 = 0;
            int v24 = v13 + 8;
            do
            {
              uint64_t v25 = *(void *)(*(v24 - 1) + 8);
              if (v25 != *(void *)(*(void *)(*(void *)(*a1 + 8) + 32) + 328) && !*(unsigned char *)(v25 + 184)
                || *v24 != *(void *)(v25 + 56))
              {
                if ((llvm::MachineBasicBlock *)v25 == v12)
                {
                  unsigned int v35 = v23;
                  LODWORD(v20) = v23;
                  goto LABEL_27;
                }
                if (*v24 == *(void *)(v25 + 56)) {
                  LODWORD(v20) = v23;
                }
              }
              ++v23;
              v24 += 2;
            }
            while (((unint64_t)v19 >> 4) != v23);
          }
LABEL_26:
          unsigned int v35 = v20;
          goto LABEL_27;
        }
        uint64_t v21 = *(void *)(*(void *)v13 + 8);
        uint64_t v22 = *(void *)(*((void *)v13 + 2) + 8);
        if (*(void *)(v21 + 8) == v22 && *((void *)v13 + 3) == *(void *)(v22 + 56) && !*(unsigned char *)(v22 + 184))
        {
          LODWORD(v20) = 1;
          goto LABEL_26;
        }
        if (*(void *)(v22 + 8) != v21 || *((void *)v13 + 1) != *(void *)(v21 + 56) || *(unsigned char *)(v21 + 184)) {
          goto LABEL_18;
        }
        LODWORD(v20) = 0;
        unsigned int v35 = 0;
LABEL_27:
        uint64_t v26 = v20;
        if (v20 != v19 >> 4)
        {
          if (*(llvm::MachineBasicBlock **)(*(void *)&v13[16 * v20] + 8) != v12)
          {
            int v12 = *(llvm::MachineBasicBlock **)(*(void *)&v13[16 * v20] + 8);
            goto LABEL_30;
          }
          if (*(void *)&v13[16 * v20 + 8] == *((void *)v12 + 7)) {
            goto LABEL_30;
          }
        }
        if (sub_1CC244A18((uint64_t)a1, (unint64_t *)&v36, a2, &v35))
        {
          uint64_t v26 = v35;
          int v12 = *(llvm::MachineBasicBlock **)(*(void *)(a1[12] + 16 * v35) + 8);
          LODWORD(v20) = v35;
LABEL_30:
          sub_1CD50B6EC((uint64_t)a1, v12);
          sub_1CD50ADA0((uint64_t)a1, v20, v27);
          unint64_t v28 = a1[13] - a1[12];
          if ((v28 & 0xFFFFFFFF0) != 0)
          {
            uint64_t v29 = 0;
            uint64_t v30 = (v28 >> 4);
            do
            {
              if (v26)
              {
                sub_1CD50A9B0((uint64_t)a1, *(unint64_t **)(a1[12] + v29 + 8), v12);
                uint64_t v31 = *(void *)(a1[12] + v29);
                uint64_t v32 = a1[1];
                uint64_t v33 = v32 - (v31 + 16);
                if (v32 != v31 + 16) {
                  memmove(*(void **)(a1[12] + v29), (const void *)(v31 + 16), v32 - (v31 + 16));
                }
                a1[1] = v31 + v33;
              }
              v29 += 16;
              --v26;
              --v30;
            }
            while (v30);
          }
          char v10 = 1;
          goto LABEL_8;
        }
        int v18 = v36;
        uint64_t v15 = a1;
        int v16 = v11;
        uint64_t v17 = a2;
      }
      sub_1CD50ACDC(v15, v16, v17, v18);
LABEL_8:
      uint64_t v8 = a1[1];
      if ((unint64_t)(v8 - *a1) <= 0x10) {
        return v10 & 1;
      }
    }
  }
  char v10 = 0;
  return v10 & 1;
}

void sub_1CD50B6EC(uint64_t a1, void *a2)
{
  v30[2] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = ((a2[12] - a2[11]) >> 3);
  unint64_t v28 = v30;
  uint64_t v29 = 0x200000000;
  sub_1CC248708((uint64_t)&v28, v4, 0);
  uint64_t v26 = 0;
  uint64_t v5 = *(void *)(a1 + 96);
  uint64_t v6 = *(void *)(a1 + 104);
  if (v5 == v6)
  {
    uint64_t v15 = 0;
  }
  else
  {
    do
    {
      uint64_t v7 = *(const llvm::MachineBasicBlock **)(*(void *)v5 + 8);
      uint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(*(llvm::MBFIWrapper **)(a1 + 224), v7);
      llvm::BlockFrequency::operator+=(&v26, BlockFreq);
      unint64_t v9 = (const llvm::MachineBasicBlock **)a2[11];
      uint64_t v8 = (const llvm::MachineBasicBlock **)a2[12];
      if (v8 != v9 && (((char *)v8 - (char *)v9) & 0x7FFFFFFF0) != 0)
      {
        int v11 = (uint64_t *)v28;
        do
        {
          int v12 = *v9++;
          unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 232), v7, v12);
          unint64_t v14 = llvm::BlockFrequency::operator*((unint64_t *)&BlockFreq, EdgeProbability);
          llvm::BlockFrequency::operator+=(v11++, v14);
        }
        while (v9 != v8);
      }
      v5 += 16;
    }
    while (v5 != v6);
    uint64_t v15 = v26;
  }
  llvm::MBFIWrapper::setBlockFreq(*(void *)(a1 + 224), (uint64_t)a2, v15);
  int v16 = (uint64_t *)v28;
  if (((a2[12] - a2[11]) & 0x7FFFFFFF0) != 0)
  {
    uint64_t BlockFreq = 0;
    if (v29)
    {
      uint64_t v17 = 8 * v29;
      do
      {
        uint64_t v18 = *v16++;
        uint64_t v19 = llvm::BlockFrequency::operator+(&BlockFreq, v18);
        uint64_t BlockFreq = v19;
        v17 -= 8;
      }
      while (v17);
      unint64_t v20 = v19;
      int v16 = (uint64_t *)v28;
      if (v19)
      {
        uint64_t v21 = a2[11];
        uint64_t v22 = a2[12];
        if (v21 != v22)
        {
          uint64_t v23 = a2[11];
          do
          {
            unint64_t v24 = *v16++;
            int BranchProbability = llvm::BranchProbability::getBranchProbability(v24, v20);
            llvm::MachineBasicBlock::setSuccProbability(a2, v21, BranchProbability);
            v23 += 8;
            v21 += 8;
          }
          while (v23 != v22);
          int v16 = (uint64_t *)v28;
        }
      }
    }
  }
  if (v16 != v30) {
    free(v16);
  }
}

uint64_t sub_1CD50B8D0(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6)
{
  int v11 = 0;
  uint64_t v8 = llvm::cl::parser<llvm::cl::BOOLOrDefault>::parse(a1 + 152, (void *)a1, a3, a4, a5, a6, &v11);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 184);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v11);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD50B964();
}

uint64_t sub_1CD50B964()
{
  return 1;
}

uint64_t sub_1CD50B96C(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 152, a1);
}

llvm::raw_ostream *sub_1CD50B978(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

void sub_1CD50B988(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    int v3 = *(_DWORD *)(a1 + 128);
LABEL_3:
    int v5 = *(_DWORD *)(a1 + 144);
    char v6 = *(unsigned char *)(a1 + 148);
    unint64_t v4 = &unk_1F2643C00;
    llvm::cl::parser<llvm::cl::BOOLOrDefault>::printOptionDiff((llvm::cl::basic_parser_impl *)(a1 + 152), (const llvm::cl::Option *)a1, v3, (uint64_t)&v4, a2);
    return;
  }
  if (*(unsigned char *)(a1 + 148))
  {
    int v3 = *(_DWORD *)(a1 + 128);
    if (*(_DWORD *)(a1 + 144) != v3) {
      goto LABEL_3;
    }
  }
}

BOOL sub_1CD50BA10(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

uint64_t sub_1CD50BA3C(uint64_t a1)
{
  free(*(void **)(a1 + 208));
  unint64_t v2 = *(void **)(a1 + 168);
  if (v2 != (void *)(a1 + 192)) {
    free(v2);
  }
  int v3 = *(void **)(a1 + 96);
  if (v3)
  {
    *(void *)(a1 + 104) = v3;
    operator delete(v3);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);
  unint64_t v4 = *(void **)(a1 + 32);
  if (v4 != *(void **)(a1 + 24)) {
    free(v4);
  }
  int v5 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v5;
    operator delete(v5);
  }
  return a1;
}

void *sub_1CD50BAB8(void *result, unsigned int a2)
{
  unsigned int v2 = *((_DWORD *)result + 12);
  if (v2 < a2 || v2 >> 2 > a2)
  {
    int v5 = result;
    free(*((void **)result + 5));
    uint64_t result = sub_1CC248524(a2, 1uLL);
    v5[5] = result;
    *((_DWORD *)v5 + 12) = a2;
  }
  return result;
}

unint64_t sub_1CD50BB0C(void *a1, uint64_t a2)
{
  unint64_t v2 = *a1 & 0xFFFFFFFFFFFFFFF8;
  if (!v2 || (*(unsigned char *)v2 & 4) == 0)
  {
    while ((*(_WORD *)(v2 + 44) & 4) != 0)
      unint64_t v2 = *(void *)v2 & 0xFFFFFFFFFFFFFFF8;
  }
  return sub_1CC248584(v2, a2);
}

void sub_1CD50BB38(int **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCC8EB8, 0, 0);
  dword_1EBCC8F38 = 0;
  qword_1EBCC8F40 = (uint64_t)&unk_1F2643C00;
  *(void *)&dword_1EBCC8F48 = 0;
  qword_1EBCC8EB8 = (uint64_t)&unk_1F2609740;
  qword_1EBCC8F50 = (uint64_t)&unk_1F2643CF0;
  qword_1EBCC8F58 = (uint64_t)&unk_1F26097A8;
  qword_1EBCC8F70 = (uint64_t)&qword_1EBCC8F58;
  llvm::cl::Option::setArgStr(v4, "enable-tail-merge", 0x11uLL);
  int v5 = *a1;
  dword_1EBCC8F38 = **a1;
  byte_1EBCC8F4C = 1;
  dword_1EBCC8F48 = *v5;
  word_1EBCC8EC2 = (32 * (*a2 & 3)) | word_1EBCC8EC2 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC8EB8);
}

void sub_1CD50BC5C()
{
}

void *sub_1CD50BC70()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F26097A8;
  return result;
}

void sub_1CD50BCA8(uint64_t a1, void *a2)
{
  *a2 = &unk_1F26097A8;
}

uint64_t sub_1CD50BCD4(uint64_t a1, char *a2, _OWORD *a3, int **a4, _WORD *a5)
{
  uint64_t v10 = sub_1CB883A14(a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25EA1B0;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F2643F00;
  *(void *)(v10 + 152) = &unk_1F2643DB0;
  *(void *)(v10 + 160) = &unk_1F25EA168;
  *(void *)(v10 + 184) = v10 + 160;
  size_t v11 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v11);
  *(_OWORD *)(a1 + 32) = *a3;
  int v12 = **a4;
  *(_DWORD *)(a1 + 128) = v12;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v12;
  *(_WORD *)(a1 + 10) = (32 * (*a5 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1CD50BE00(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCC9038, 0, 0);
  dword_1EBCC90B8 = 0;
  qword_1EBCC90C0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC90C8 = 0;
  qword_1EBCC9038 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC90D0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC90D8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC90F0 = (uint64_t)&qword_1EBCC90D8;
  llvm::cl::Option::setArgStr(v6, "tail-merge-size", 0xFuLL);
  xmmword_1EBCC9058 = *a1;
  dword_1EBCC90B8 = **a2;
  byte_1EBCC90CC = 1;
  dword_1EBCC90C8 = dword_1EBCC90B8;
  word_1EBCC9042 = (32 * (*a3 & 3)) | word_1EBCC9042 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC9038);
}

uint64_t sub_1CD50BF28(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    unsigned int v5 = *(_DWORD *)(v2 + 28);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      uint64_t v7 = (uint64_t *)v2;
    }
    else {
      uint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 28)) {
    return 0;
  }
  sub_1CD508918((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

void llvm::initializeBranchRelaxationPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC90F8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2488DC;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCC90F8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD50C018(uint64_t a1, int a2)
{
  if (!a2)
  {
    unint64_t v3 = *(void *)(*(void *)(a1 + 16) + 8);
    if ((~*(_DWORD *)(*(void *)(a1 + 16) + 8) & 0x500) == 0) {
      goto LABEL_10;
    }
    return 0;
  }
  if ((*(_WORD *)(a1 + 44) & 0xC) == 0 || (*(_WORD *)(a1 + 44) & 4) != 0)
  {
    if (*(unsigned char *)(*(void *)(a1 + 16) + 9) & 4) != 0 && (*(unsigned char *)(*(void *)(a1 + 16) + 9))
    {
      unint64_t v3 = *(void *)(*(void *)(a1 + 16) + 8);
LABEL_10:
      uint64_t v4 = (v3 >> 11) & 1;
      return v4 ^ 1;
    }
    return 0;
  }
  LODWORD(v4) = a2 == 2;
  for (uint64_t i = a1; ; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v7 = *(void *)(i + 16);
    if ((*(unsigned char *)(v7 + 9) & 4) != 0)
    {
      if (a2 == 1) {
        break;
      }
      if ((*(_WORD *)(i + 44) & 8) == 0)
      {
        uint64_t v8 = a1;
        if (a2 == 2) {
          goto LABEL_24;
        }
        return 0;
      }
      continue;
    }
    if (a2 != 2)
    {
      if ((*(_WORD *)(i + 44) & 8) == 0) {
        return 0;
      }
      continue;
    }
    if (*(_WORD *)v7 != 20) {
      return 0;
    }
    if ((*(_WORD *)(i + 44) & 8) == 0) {
      break;
    }
  }
  uint64_t v8 = a1;
LABEL_24:
  while (1)
  {
    uint64_t v9 = *(void *)(v8 + 16);
    if (*(unsigned char *)(v9 + 9)) {
      break;
    }
    if (a2 == 2)
    {
      if (*(_WORD *)v9 != 20) {
        return 0;
      }
      if ((*(_WORD *)(v8 + 44) & 8) == 0) {
        goto LABEL_33;
      }
    }
    else if ((*(_WORD *)(v8 + 44) & 8) == 0)
    {
      return 0;
    }
LABEL_27:
    uint64_t v8 = *(void *)(v8 + 8);
  }
  if (a2 != 1 && (*(_WORD *)(v8 + 44) & 8) != 0) {
    goto LABEL_27;
  }
LABEL_33:
  while (1)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    if ((*(unsigned char *)(v10 + 9) & 8) == 0) {
      break;
    }
    if (a2 == 1)
    {
      LODWORD(v4) = 1;
      return v4 ^ 1;
    }
LABEL_35:
    if ((*(_WORD *)(a1 + 44) & 8) == 0) {
      return v4 ^ 1;
    }
    a1 = *(void *)(a1 + 8);
  }
  if (a2 != 2 || *(_WORD *)v10 == 20) {
    goto LABEL_35;
  }
  LODWORD(v4) = 0;
  return v4 ^ 1;
}

uint64_t sub_1CD50C188(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned int *)(a1 + 16), *(unsigned int *)(a1 + 20));
}

uint64_t *sub_1CD50C1C0(uint64_t *a1)
{
  uint64_t v2 = a1[27];
  a1[27] = 0;
  if (v2) {
    MEMORY[0x1D25D9CB0](v2, 0x1000C8052888210);
  }
  unint64_t v3 = (uint64_t *)a1[18];
  if (v3 != a1 + 20) {
    free(v3);
  }
  uint64_t v4 = (uint64_t *)a1[9];
  if (v4 != a1 + 11) {
    free(v4);
  }
  unsigned int v5 = (uint64_t *)a1[5];
  if (v5 != a1 + 8) {
    free(v5);
  }
  uint64_t v6 = *a1;
  *a1 = 0;
  if (v6) {
    sub_1CC24B66C((uint64_t)a1, v6);
  }
  return a1;
}

void llvm::initializeBasicBlockSectionsPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC9108, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC24B6FC;
    v4[1] = &v2;
    unint64_t v3 = v4;
    std::__call_once(&qword_1EBCC9108, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::sortBasicBlocksAndUpdateBranches(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t *, uint64_t *), uint64_t a3)
{
  v21[16] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = ((*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 3);
  v17[0] = v18;
  v17[1] = (void *)0x400000000;
  sub_1CC24CF20((uint64_t)v17, v6);
  uint64_t v7 = a1 + 320;
  for (uint64_t i = *(void *)(a1 + 328); i != v7; uint64_t i = *(void *)(i + 8))
  {
    uint64_t FallThrough = llvm::MachineBasicBlock::getFallThrough((llvm::MachineBasicBlock *)i);
    *((void *)v17[0] + *(int *)(i + 24)) = FallThrough;
  }
  sub_1CD50C90C((uint64_t *)(a1 + 320), a2, a3);
  llvm::MachineFunction::assignBeginEndSections(a1);
  uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 104))(*(void *)(a1 + 16));
  uint64_t v19 = v21;
  uint64_t v20 = 0x400000000;
  uint64_t v11 = *(void *)(a1 + 328);
  if (v11 != v7)
  {
    uint64_t v12 = v10;
    do
    {
      unint64_t v13 = (llvm::MachineBasicBlock *)*((void *)v17[0] + *(int *)(v11 + 24));
      if (v13)
      {
        if (*(unsigned char *)(v11 + 201) || *(void *)(v11 + 8) != (void)v13)
        {
          llvm::MachineBasicBlock::findBranchDebugLoc((llvm::MachineBasicBlock *)v11, &v16);
          (*(void (**)(uint64_t, uint64_t, llvm::MachineBasicBlock *, void, void, void, unsigned __int8 **, void))(*(void *)v12 + 272))(v12, v11, v13, 0, 0, 0, &v16, 0);
          if (v16) {
            llvm::MetadataTracking::untrack((uint64_t)&v16, v16);
          }
        }
      }
      if (!*(unsigned char *)(v11 + 201))
      {
        LODWORD(v20) = 0;
        uint64_t v15 = 0;
        int v16 = 0;
        if (((*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 **, uint64_t *, void **, void))(*(void *)v12 + 248))(v12, v11, &v16, &v15, &v19, 0) & 1) == 0)llvm::MachineBasicBlock::updateTerminator((llvm::MachineBasicBlock *)v11, v13); {
      }
        }
      uint64_t v11 = *(void *)(v11 + 8);
    }
    while (v11 != v7);
    if (v19 != v21) {
      free(v19);
    }
  }
  if (v17[0] != v18) {
    free(v17[0]);
  }
}

void llvm::createBasicBlockSectionsPass(llvm *this, const llvm::MemoryBuffer *a2)
{
}

llvm::StringMapImpl *sub_1CD50C600(llvm::StringMapImpl *this, uint64_t *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0x1800000000;
  if (*((_DWORD *)a2 + 3))
  {
    llvm::StringMapImpl::init(this, *((_DWORD *)a2 + 2));
    uint64_t v4 = *(void *)this;
    uint64_t v5 = *((unsigned int *)this + 2);
    uint64_t v6 = *a2;
    *(void *)((char *)this + 12) = *(uint64_t *)((char *)a2 + 12);
    if (v5)
    {
      uint64_t v7 = 0;
      uint64_t v16 = v4 + 8 * v5 + 8;
      uint64_t v8 = v6 + 8 * v5 + 8;
      do
      {
        uint64_t v9 = *(void *)(*a2 + 8 * v7);
        if (v9) {
          BOOL v10 = v9 == -8;
        }
        else {
          BOOL v10 = 1;
        }
        if (v10)
        {
          *(void *)(*(void *)this + 8 * v7) = v9;
        }
        else
        {
          size_t v11 = *(void *)v9;
          uint64_t v12 = (char *)operator new(*(void *)v9 + 25, (std::align_val_t)8uLL);
          unint64_t v13 = v12;
          unint64_t v14 = v12 + 24;
          if (v11) {
            memcpy(v12 + 24, (const void *)(v9 + 24), v11);
          }
          v14[v11] = 0;
          *(void *)unint64_t v13 = v11;
          *(_OWORD *)(v13 + 8) = *(_OWORD *)(v9 + 8);
          *(void *)(*(void *)this + 8 * v7) = v13;
          *(_DWORD *)(v16 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        }
        ++v7;
      }
      while (v5 != v7);
    }
  }
  return this;
}

void sub_1CD50C724(long long *a1, const char **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&llvm::BBSectionsColdTextPrefix, 0, 0);
  qword_1EBD04E38 = 0;
  qword_1EBD04E40 = 0;
  qword_1EBD04E60 = 0;
  unk_1EBD04E68 = 0;
  byte_1EBD04E70 = 0;
  qword_1EBD04E58 = 0;
  unk_1EBD04E48 = 0;
  unk_1EBD04E50 = &unk_1F2643C20;
  llvm::BBSectionsColdTextPrefix = (uint64_t)&unk_1F2643FD0;
  qword_1EBD04E78 = (uint64_t)&unk_1F2643EA0;
  qword_1EBD04E80 = (uint64_t)&unk_1F25F6428;
  qword_1EBD04E98 = (uint64_t)&qword_1EBD04E80;
  sub_1CD50C820(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::BBSectionsColdTextPrefix);
}

void sub_1CD50C820(long long *a1, const char **a2, _WORD *a3)
{
  xmmword_1EBD04DD8 = *a1;
  sub_1CD50C894(*a2);
  word_1EBD04DC2 = (32 * (*a3 & 3)) | word_1EBD04DC2 & 0xFF9F;
}

void sub_1CD50C894(const char *a1)
{
  std::string::size_type v2 = strlen(a1);
  std::string::__init(&__str, a1, v2);
  std::string::operator=((std::string *)&qword_1EBD04E38, &__str);
  byte_1EBD04E70 = 1;
  std::string::operator=((std::string *)&qword_1EBD04E58, &__str);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

uint64_t *sub_1CD50C90C(uint64_t *result, uint64_t (*a2)(uint64_t, uint64_t *, uint64_t *), uint64_t a3)
{
  uint64_t v3 = *result;
  if ((uint64_t *)*result != result)
  {
    uint64_t v4 = (uint64_t)result;
    uint64_t v5 = (uint64_t *)result[1];
    if ((uint64_t *)v5[1] != result)
    {
      if (v5 == result)
      {
        uint64_t v11 = (uint64_t)&v11;
        uint64_t v12 = &v11;
      }
      else
      {
        uint64_t v8 = (uint64_t *)result[1];
        do
        {
          uint64_t v9 = (uint64_t *)v8[1];
          if (v9 == result) {
            break;
          }
          uint64_t v5 = (uint64_t *)v5[1];
          uint64_t v8 = (uint64_t *)v9[1];
        }
        while (v8 != result);
        uint64_t v11 = (uint64_t)&v11;
        uint64_t v12 = &v11;
        if (&v11 != result && v5 != result)
        {
          uint64_t v10 = *v5;
          *(void *)(v10 + 8) = result;
          void *result = v10;
          *(void *)(v3 + 8) = &v11;
          uint64_t *v5 = (uint64_t)&v11;
          uint64_t v11 = v3;
          uint64_t v12 = v5;
        }
      }
      sub_1CD50C90C(result, a2, a3);
      sub_1CD50C90C(&v11, a2, a3);
      return (uint64_t *)sub_1CD50CA00(v4, &v11, a2, a3);
    }
  }
  return result;
}

uint64_t sub_1CD50CA00(uint64_t result, uint64_t *a2, uint64_t (*a3)(uint64_t, uint64_t *, uint64_t *), uint64_t a4)
{
  if ((uint64_t *)result != a2 && (uint64_t *)*a2 != a2)
  {
    uint64_t v5 = (uint64_t *)result;
    uint64_t v6 = (uint64_t *)a2[1];
    uint64_t v7 = *(uint64_t **)(result + 8);
    if (v7 != (uint64_t *)result)
    {
      while (1)
      {
        uint64_t result = a3(a4, v6, v7);
        if (result)
        {
          uint64_t v10 = v6;
          while (1)
          {
            uint64_t v10 = (uint64_t *)v10[1];
            if (v10 == a2) {
              break;
            }
            uint64_t result = a3(a4, v10, v7);
            uint64_t v11 = v10;
            if ((result & 1) == 0) {
              goto LABEL_11;
            }
          }
          uint64_t v11 = a2;
LABEL_11:
          if (v7 != v11 && v6 != v11)
          {
            uint64_t v12 = *v11;
            uint64_t v13 = *v6;
            *(void *)(v13 + 8) = v11;
            *uint64_t v11 = v13;
            uint64_t v14 = *v7;
            *(void *)(v12 + 8) = v7;
            uint64_t *v6 = v14;
            *(void *)(v14 + 8) = v6;
            uint64_t *v7 = v12;
          }
          if (v10 == a2) {
            return result;
          }
        }
        else
        {
          uint64_t v11 = v6;
        }
        uint64_t v7 = (uint64_t *)v7[1];
        uint64_t v6 = v11;
        if (v7 == v5) {
          goto LABEL_18;
        }
      }
    }
    uint64_t v11 = (uint64_t *)a2[1];
LABEL_18:
    if (v11 != a2)
    {
      uint64_t v15 = *a2;
      uint64_t v16 = *v11;
      *(void *)(v16 + 8) = a2;
      *a2 = v16;
      uint64_t v17 = *v5;
      *(void *)(v15 + 8) = v5;
      *uint64_t v11 = v17;
      *(void *)(v17 + 8) = v11;
      uint64_t *v5 = v15;
    }
  }
  return result;
}

uint64_t llvm::CCState::AnalyzeFormalArguments(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, void, void, void, void, unint64_t, uint64_t))
{
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4)
  {
    uint64_t v7 = result;
    uint64_t v8 = 0;
    for (uint64_t i = 0; i != v4; ++i)
    {
      uint64_t v10 = *(void *)a2 + v8;
      unint64_t v3 = v3 & 0xFFFFFFFF00000000 | *(unsigned int *)(v10 + 8);
      uint64_t result = a3(i, *(unsigned __int8 *)(v10 + 12), *(unsigned __int8 *)(v10 + 12), 0, *(void *)v10, v3, v7);
      if (result)
      {
        uint64_t v13 = "unable to allocate function argument #";
        __int16 v14 = 259;
        __int16 v12 = 264;
        LODWORD(v11[0]) = i;
        sub_1CD3E3950((uint64_t *)&v13, v11, (uint64_t)v15);
        llvm::report_fatal_error((llvm *)v15, (const llvm::Twine *)1);
      }
      v8 += 48;
    }
  }
  return result;
}

uint64_t llvm::CCState::CheckReturn(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, void, void, void, void, unint64_t, uint64_t))
{
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  if (!v4) {
    return 1;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = v4 - 1;
  do
  {
    uint64_t v11 = *(void *)a2 + v8;
    unint64_t v3 = v3 & 0xFFFFFFFF00000000 | *(unsigned int *)(v11 + 8);
    int v12 = a3(v9, *(unsigned __int8 *)(v11 + 12), *(unsigned __int8 *)(v11 + 12), 0, *(void *)v11, v3, a1);
    if (v12) {
      break;
    }
    v8 += 48;
  }
  while (v10 != v9++);
  return v12 ^ 1u;
}

uint64_t llvm::CCState::AnalyzeReturn(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, void, void, void, void, unint64_t, uint64_t))
{
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4)
  {
    uint64_t v7 = result;
    uint64_t v8 = 0;
    for (uint64_t i = 0; i != v4; ++i)
    {
      uint64_t v10 = *(void *)a2 + v8;
      unint64_t v3 = v3 & 0xFFFFFFFF00000000 | *(unsigned int *)(v10 + 8);
      uint64_t result = a3(i, *(unsigned __int8 *)(v10 + 12), *(unsigned __int8 *)(v10 + 12), 0, *(void *)v10, v3, v7);
      if (result)
      {
        uint64_t v13 = "unable to allocate function return #";
        __int16 v14 = 259;
        __int16 v12 = 264;
        LODWORD(v11[0]) = i;
        sub_1CD3E3950((uint64_t *)&v13, v11, (uint64_t)v15);
        llvm::report_fatal_error((llvm *)v15, (const llvm::Twine *)1);
      }
      v8 += 48;
    }
  }
  return result;
}

uint64_t llvm::CCState::AnalyzeCallResult(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, void, void, void, void, unint64_t, uint64_t))
{
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4)
  {
    uint64_t v7 = result;
    uint64_t v8 = 0;
    for (uint64_t i = 0; i != v4; ++i)
    {
      uint64_t v10 = *(void *)a2 + v8;
      unint64_t v3 = v3 & 0xFFFFFFFF00000000 | *(unsigned int *)(v10 + 8);
      uint64_t result = a3(i, *(unsigned __int8 *)(v10 + 12), *(unsigned __int8 *)(v10 + 12), 0, *(void *)v10, v3, v7);
      v8 += 48;
    }
  }
  return result;
}

void llvm::initializeCFGuardLongjmpPass(llvm *this, llvm::PassRegistry *a2)
{
  std::string::size_type v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC9118, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC24FF40;
    v4[1] = &v2;
    unint64_t v3 = v4;
    std::__call_once(&qword_1EBCC9118, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeCFIFixupPass(llvm *this, llvm::PassRegistry *a2)
{
  std::string::size_type v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC9120, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2507D0;
    v4[1] = &v2;
    unint64_t v3 = v4;
    std::__call_once(&qword_1EBCC9120, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createCFIFixup(llvm *this)
{
}

void sub_1CD50CF58(llvm::Pass *a1)
{
  sub_1CBA0E6AC(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD50CF90(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

void llvm::callDefaultCtor<llvm::CFIFixup>()
{
}

uint64_t sub_1CD50CFD8(uint64_t a1)
{
  sub_1CB8483A0(a1, (uint64_t)&llvm::CFIFixup::ID);
  *(void *)std::string::size_type v2 = &unk_1F2609B10;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC9120, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC2507D0;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCC9120, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CD50D084(char **a1, uint64_t *a2)
{
  v13[16] = *MEMORY[0x1E4F143B8];
  sub_1CC252928((uint64_t)&v10, *a2);
  v7[0] = 0;
  memset(v8, 0, sizeof(v8));
  uint64_t v9 = 0;
  memset(v6, 0, sizeof(v6));
  unint64_t v3 = (char *)v6 + 8;
  uint64_t v4 = (char *)v6 + 8;
  uint64_t v5 = 8;
  v7[1] = (char *)v8 + 8;
  DWORD1(v8[0]) = 8;
  sub_1CC25122C((uint64_t)&v10, (uint64_t)&v3, a1);
  if (v7[1] != (char *)v8 + 8) {
    free(v7[1]);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v12 != v13) {
    free(v12);
  }
  if (v11 != v10) {
    free(v11);
  }
}

void llvm::initializeCFIInstrInserterPass(llvm *this, llvm::PassRegistry *a2)
{
  std::string::size_type v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC91F0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC25298C;
    v4[1] = &v2;
    unint64_t v3 = v4;
    std::__call_once(&qword_1EBCC91F0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD50D210(uint64_t a1@<X0>, void *a2@<X8>)
{
  sub_1CD50D2CC((uint64_t)&v11, *(void *)(*(void *)a1 + 328));
  uint64_t v7 = 0;
  std::string __p = 0;
  memset(v6, 0, sizeof(v6));
  unint64_t v3 = (char *)v6 + 8;
  uint64_t v4 = (char *)v6 + 8;
  uint64_t v5 = 8;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  sub_1CD4B8004((uint64_t)&v11, (uint64_t)&v3, a2);
  if (__p)
  {
    uint64_t v9 = __p;
    operator delete(__p);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v13)
  {
    __int16 v14 = v13;
    operator delete(v13);
  }
  if (v12 != v11) {
    free(v12);
  }
}

uint64_t sub_1CD50D2CC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a1 + 32;
  *(void *)(a1 + 8) = a1 + 32;
  *(void *)(a1 + 16) = 8;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 96) = 0;
  uint64_t v4 = (void **)(a1 + 96);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a2);
  *(void *)&long long v9 = a2;
  BYTE8(v9) = 0;
  LOBYTE(v10) = 0;
  unint64_t v5 = *(void *)(a1 + 104);
  if (v5 >= *(void *)(a1 + 112))
  {
    uint64_t v7 = sub_1CBF56DE8(v4, (uint64_t)&v9);
  }
  else
  {
    long long v6 = v9;
    *(void *)(v5 + 16) = v10;
    *(_OWORD *)unint64_t v5 = v6;
    uint64_t v7 = (char *)(v5 + 24);
  }
  *(void *)(a1 + 104) = v7;
  return a1;
}

char *sub_1CD50D36C(char *this)
{
  uint64_t v1 = (llvm::SmallPtrSetImplBase *)this;
  std::string::size_type v2 = (void **)(this + 96);
  uint64_t v3 = *((void *)this + 13);
  while (2)
  {
    uint64_t v4 = *(void *)(v3 - 24);
    if (!*(unsigned char *)(v3 - 8))
    {
      *(void *)(v3 - 16) = *(void *)(v4 + 88);
      *(unsigned char *)(v3 - 8) = 1;
    }
    while (1)
    {
      unint64_t v5 = *(uint64_t **)(v3 - 16);
      if (v5 == *(uint64_t **)(v4 + 96)) {
        break;
      }
      *(void *)(v3 - 16) = v5 + 1;
      uint64_t v6 = *v5;
      this = (char *)sub_1CB89694C(v1, *v5);
      if (v7)
      {
        *(void *)&long long v11 = v6;
        BYTE8(v11) = 0;
        LOBYTE(v12) = 0;
        unint64_t v9 = *((void *)v1 + 13);
        if (v9 >= *((void *)v1 + 14))
        {
          this = sub_1CBF56DE8(v2, (uint64_t)&v11);
        }
        else
        {
          long long v10 = v11;
          *(void *)(v9 + 16) = v12;
          *(_OWORD *)unint64_t v9 = v10;
          this = (char *)(v9 + 24);
        }
        *((void *)v1 + 13) = this;
        return this;
      }
    }
    uint64_t v8 = *((void *)v1 + 12);
    uint64_t v3 = *((void *)v1 + 13) - 24;
    *((void *)v1 + 13) = v3;
    if (v8 != v3) {
      continue;
    }
    break;
  }
  return this;
}

void llvm::initializeCodeGen(llvm *this, llvm::PassRegistry *a2)
{
  llvm::initializeAtomicExpandPass(this, a2);
  llvm::initializeBasicBlockSectionsPass(this, v3);
  llvm::initializeBranchFolderPassPass(this, v4);
  llvm::initializeBranchRelaxationPass(this, v5);
  llvm::initializeCFGuardLongjmpPass(this, v6);
  llvm::initializeCFIFixupPass(this, v7);
  llvm::initializeCFIInstrInserterPass(this, v8);
  llvm::initializeCheckDebugMachineModulePass(this, v9);
  llvm::initializeCodeGenPreparePass(this, v10);
  llvm::initializeDeadMachineInstructionElimPass(this, v11);
  llvm::initializeDebugifyMachineModulePass(this, v12);
  llvm::initializeDetectDeadLanesPass(this, v13);
  llvm::initializeDwarfEHPrepareLegacyPassPass(this, v14);
  llvm::initializeEarlyIfConverterPass(this, v15);
  llvm::initializeEarlyIfPredicatorPass(this, v16);
  llvm::initializeEarlyMachineLICMPass(this, v17);
  llvm::initializeEarlyTailDuplicatePass(this, v18);
  llvm::initializeExpandMemCmpPassPass(this, v19);
  llvm::initializeExpandPostRAPass(this, v20);
  llvm::initializeFEntryInserterPass(this, v21);
  llvm::initializeFinalizeISelPass(this, v22);
  llvm::initializeFinalizeMachineBundlesPass(this, v23);
  llvm::initializeFixupStatepointCallerSavedPass(this, v24);
  llvm::initializeFuncletLayoutPass(this, v25);
  llvm::initializeGCMachineCodeAnalysisPass(this, v26);
  llvm::initializeGCModuleInfoPass(this, v27);
  llvm::initializeHardwareLoopsPass(this, v28);
  llvm::initializeIfConverterPass(this, v29);
  llvm::initializeImplicitNullChecksPass(this, v30);
  llvm::initializeIndirectBrExpandPassPass(this, v31);
  llvm::initializeInterleavedLoadCombinePass(this, v32);
  llvm::initializeInterleavedAccessPass(this, v33);
  llvm::initializeJMCInstrumenterPass(this, v34);
  llvm::initializeLiveDebugValuesPass(this, v35);
  llvm::initializeLiveDebugVariablesPass(this, v36);
  llvm::initializeLiveIntervalsPass((uint64_t)this);
  llvm::initializeLiveRangeShrinkPass(this, v37);
  llvm::initializeLiveStacksPass(this, v38);
  llvm::initializeLiveVariablesPass(this, v39);
  llvm::initializeLocalStackSlotPassPass(this, v40);
  llvm::initializeLowerGlobalDtorsLegacyPassPass(this, v41);
  llvm::initializeLowerIntrinsicsPass(this, v42);
  llvm::initializeMIRAddFSDiscriminatorsPass(this, v43);
  llvm::initializeMIRCanonicalizerPass(this, v44);
  llvm::initializeMIRNamerPass(this, v45);
  llvm::initializeMIRProfileLoaderPassPass(this, v46);
  llvm::initializeMachineBlockFrequencyInfoPass(this, v47);
  llvm::initializeMachineBlockPlacementPass(this, v48);
  llvm::initializeMachineBlockPlacementStatsPass(this, v49);
  llvm::initializeMachineCSEPass(this, v50);
  llvm::initializeMachineCombinerPass(this, v51);
  llvm::initializeMachineCopyPropagationPass(this, v52);
  llvm::initializeMachineCycleInfoPrinterPassPass(this, v53);
  llvm::initializeMachineCycleInfoWrapperPassPass(this, v54);
  llvm::initializeMachineDominatorTreePass((uint64_t)this);
  llvm::initializeMachineFunctionPrinterPassPass(this, v55);
  llvm::initializeMachineLICMPass(this, v56);
  llvm::initializeMachineLoopInfoPass((uint64_t)this);
  llvm::initializeMachineModuleInfoWrapperPassPass(this, v57);
  llvm::initializeMachineOptimizationRemarkEmitterPassPass(this, v58);
  llvm::initializeMachineOutlinerPass(this, v59);
  llvm::initializeMachinePipelinerPass(this, v60);
  llvm::initializeModuloScheduleTestPass(this, v61);
  llvm::initializeMachinePostDominatorTreePass(this, v62);
  llvm::initializeMachineRegionInfoPassPass(this, v63);
  llvm::initializeMachineSchedulerPass(this, v64);
  llvm::initializeMachineSinkingPass(this, v65);
  llvm::initializeMachineVerifierPassPass(this, v66);
  llvm::initializeObfuscateModulePass(this, v67);
  llvm::initializeOptimizePHIsPass(this, v68);
  llvm::initializePEIPass(this, v69);
  llvm::initializePHIEliminationPass(this, v70);
  llvm::initializePatchableFunctionPass(this, v71);
  llvm::initializePeepholeOptimizerPass(this, v72);
  llvm::initializePostMachineSchedulerPass(this, v73);
  llvm::initializePostRAHazardRecognizerPass(this, v74);
  llvm::initializePostRAMachineSinkingPass(this, v75);
  llvm::initializePostRASchedulerPass(this, v76);
  llvm::initializePreISelIntrinsicLoweringLegacyPassPass(this, v77);
  llvm::initializeProcessImplicitDefsPass(this, v78);
  llvm::initializeRABasicPass(this, v79);
  llvm::initializeRAGreedyPass(this, v80);
  llvm::initializeRegAllocFastPass(this, v81);
  llvm::initializeRegUsageInfoCollectorPass(this, v82);
  llvm::initializeRegUsageInfoPropagationPass(this, v83);
  llvm::initializeRegisterCoalescerPass(this, v84);
  llvm::initializeRemoveRedundantDebugValuesPass(this, v85);
  llvm::initializeRenameIndependentSubregsPass(this, v86);
  llvm::initializeSafeStackLegacyPassPass(this, v87);
  llvm::initializeShadowStackGCLoweringPass(this, v88);
  llvm::initializeShrinkWrapPass(this, v89);
  llvm::initializeSjLjEHPreparePass(this, v90);
  llvm::initializeSlotIndexesPass((uint64_t)this);
  llvm::initializeStackColoringPass(this, v91);
  llvm::initializeStackMapLivenessPass(this, v92);
  llvm::initializeStackProtectorPass(this, v93);
  llvm::initializeStackSlotColoringPass(this, v94);
  llvm::initializeStripDebugMachineModulePass(this, v95);
  llvm::initializeTailDuplicatePass(this, v96);
  llvm::initializeTargetPassConfigPass((uint64_t)this);
  llvm::initializeTwoAddressInstructionPassPass(this, v97);
  llvm::initializeTypePromotionPass(this, v98);
  llvm::initializeUnpackMachineBundlesPass(this, v99);
  llvm::initializeUnreachableBlockElimLegacyPassPass(this, v100);
  llvm::initializeUnreachableMachineBlockElimPass(this, v101);
  llvm::initializeVirtRegMapPass(this, v102);
  llvm::initializeVirtRegRewriterPass(this, v103);
  llvm::initializeWasmEHPreparePass(this, v104);
  llvm::initializeWinEHPreparePass(this, v105);

  llvm::initializeXRayInstrumentationPass(this, v106);
}

llvm::MachineBasicBlock *llvm::StackProtectorDescriptor::addSuccessorMBB(llvm::StackProtectorDescriptor *this, const llvm::BasicBlock *a2, llvm::MachineBasicBlock *a3, int a4, llvm::MachineBasicBlock *a5)
{
  unint64_t MachineBasicBlock = a5;
  if (!a5)
  {
    uint64_t v8 = (llvm::MachineFunction *)*((void *)a3 + 4);
    unint64_t MachineBasicBlock = (llvm::MachineBasicBlock *)llvm::MachineFunction::CreateMachineBasicBlock(v8, a2);
    unint64_t v9 = (llvm::MachineBasicBlock **)*((void *)a3 + 1);
    llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList((uint64_t)v8 + 320, (uint64_t)MachineBasicBlock);
    long long v10 = *v9;
    *(void *)unint64_t MachineBasicBlock = *v9;
    *((void *)MachineBasicBlock + 1) = v9;
    *((void *)v10 + 1) = MachineBasicBlock;
    llvm::PassRegistry *v9 = MachineBasicBlock;
  }
  int v11 = sub_1CD50D874(a4);
  llvm::MachineBasicBlock::addSuccessor(a3, MachineBasicBlock, v11);
  return MachineBasicBlock;
}

uint64_t sub_1CD50D874(int a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EA615288, memory_order_acquire) & 1) == 0)
  {
    int v3 = a1;
    int v2 = __cxa_guard_acquire(&qword_1EA615288);
    a1 = v3;
    if (v2)
    {
      llvm::BranchProbability::BranchProbability(&dword_1EA615280, 0xFFFFFuLL, 0x100000u);
      __cxa_guard_release(&qword_1EA615288);
      a1 = v3;
    }
  }
  if (a1) {
    return dword_1EA615280;
  }
  else {
    return 0x80000000 - dword_1EA615280;
  }
}

unint64_t llvm::findSplitPointForStackProtector(llvm *this, llvm::MachineBasicBlock *a2, const llvm::TargetInstrInfo *a3)
{
  unint64_t FirstTerminator = (void *)llvm::MachineBasicBlock::getFirstTerminator(this);
  uint64_t v6 = FirstTerminator;
  char v7 = (void *)*((void *)this + 7);
  if (v7 == FirstTerminator) {
    return (unint64_t)v6;
  }
  unint64_t v8 = *FirstTerminator & 0xFFFFFFFFFFFFFFF8;
  if (!v8 || (*(unsigned char *)v8 & 4) == 0)
  {
    while ((*(_WORD *)(v8 + 44) & 4) != 0)
      unint64_t v8 = *(void *)v8 & 0xFFFFFFFFFFFFFFF8;
  }
  while (1)
  {
    unint64_t v9 = v8;
    int v10 = **(unsigned __int16 **)(v8 + 16);
    if (v10 == 10 || v10 == 19)
    {
      uint64_t v12 = *(void *)(v8 + 32);
      if ((*(_DWORD *)v12 & 0x10000FF) != 0x1000000
        || v10 != 10
        && (*(unsigned char *)(v12 + 32)
         || (*(_DWORD *)(v12 + 4) - 1) >= 0x3FFFFFFF
         && (*(_DWORD *)(v12 + 36) - 1) < 0x3FFFFFFF))
      {
        goto LABEL_32;
      }
    }
    else if ((v10 - 13) >= 5 {
           && ((v10 - 73) > 0x35 || ((1 << (v10 - 73)) & 0x2860000000005BLL) == 0))
    }
    {
      goto LABEL_32;
    }
    if ((void *)v9 == v7) {
      break;
    }
    unint64_t v8 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
    if (v8)
    {
      uint64_t v6 = (void *)v9;
      if ((*(unsigned char *)v8 & 4) != 0) {
        continue;
      }
    }
    uint64_t v6 = (void *)v9;
    if ((*(_WORD *)(v8 + 44) & 4) != 0)
    {
      do
        unint64_t v8 = *(void *)v8 & 0xFFFFFFFFFFFFFFF8;
      while ((*(_WORD *)(v8 + 44) & 4) != 0);
      uint64_t v6 = (void *)v9;
    }
  }
  unint64_t v9 = *((void *)this + 7);
  uint64_t v6 = (void *)v9;
LABEL_32:
  unint64_t v14 = *((void *)this + 6) & 0xFFFFFFFFFFFFFFF8;
  if (!v14 || (*(unsigned char *)v14 & 4) == 0)
  {
    while ((*(_WORD *)(v14 + 44) & 4) != 0)
      unint64_t v14 = *(void *)v14 & 0xFFFFFFFFFFFFFFF8;
  }
  if (!(*(unsigned int (**)(llvm::MachineBasicBlock *))(*(void *)a2 + 1136))(a2)
    || *((_DWORD *)a2 + 17) != **(unsigned __int16 **)(v9 + 16))
  {
    return (unint64_t)v6;
  }
  do
  {
    unint64_t v9 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
    if (v9 && (*(unsigned char *)v9 & 4) != 0)
    {
      __int16 v15 = *(_WORD *)(v9 + 44);
    }
    else
    {
      while (1)
      {
        __int16 v15 = *(_WORD *)(v9 + 44);
        if ((v15 & 4) == 0) {
          break;
        }
        unint64_t v9 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
      }
    }
    int v16 = v15 & 0xC;
    int v17 = v15 & 4;
    if (v16) {
      BOOL v18 = v17 == 0;
    }
    else {
      BOOL v18 = 0;
    }
    if (v18)
    {
      if (llvm::MachineInstr::hasPropertyInBundle(v9, 128, 1)) {
        return (unint64_t)v6;
      }
      uint64_t v19 = *(unsigned __int16 **)(v9 + 16);
    }
    else
    {
      uint64_t v19 = *(unsigned __int16 **)(v9 + 16);
      if ((v19[4] & 0x80) != 0) {
        return (unint64_t)v6;
      }
    }
  }
  while (*((_DWORD *)a2 + 16) != *v19);
  return v9;
}

void llvm::initializeCodeGenPreparePass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCC9200, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC256934;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCC9200, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createCodeGenPreparePass(llvm *this)
{
}

void sub_1CD50DC10(uint64_t a1, uint64_t a2)
{
  sub_1CC008720(v23, (void *)(a1 + 8));
  uint64_t v4 = *(int32x2_t **)(a1 + 32);
  uint64_t v22 = &off_1F2609D30;
  uint64_t v25 = v4;
  __int16 v15 = 0;
  if (sub_1CC2606A0((uint64_t)*v4, v4[2].i32[0], v24, &v15)) {
    unint64_t v5 = v15;
  }
  else {
    unint64_t v5 = (unint64_t *)(*(void *)v4 + ((unint64_t)v4[2].u32[0] << 6));
  }
  uint64_t v6 = v25;
  if ((unint64_t *)(*(void *)v6 + ((unint64_t)v6[2].u32[0] << 6)) != v5)
  {
    uint64_t v19 = 6;
    uint64_t v20 = 0;
    unint64_t v7 = v5[7];
    unint64_t v21 = v7;
    if (v7 != -8192 && v7 != -4096 && v7 != 0)
    {
      unint64_t v12 = v5[5] & 0xFFFFFFFFFFFFFFF8;
      uint64_t v20 = *(unint64_t **)v12;
      uint64_t v13 = v20;
      *(void *)unint64_t v12 = &v19;
      uint64_t v19 = v12 | 6;
      if (v13) {
        *uint64_t v13 = *v13 & 7 | (unint64_t)&v20;
      }
      uint64_t v6 = v25;
    }
    sub_1CD50DE04(v6, v5);
    uint64_t v9 = (uint64_t)v25;
    __int16 v15 = (unint64_t *)a2;
    uint64_t v16 = 6;
    int v17 = 0;
    unint64_t v18 = v21;
    if (v21 != -8192 && v21 != -4096)
    {
      if (v21)
      {
        unint64_t v10 = v19 & 0xFFFFFFFFFFFFFFF8;
        int v17 = *(unint64_t **)(v19 & 0xFFFFFFFFFFFFFFF8);
        int v11 = v17;
        *(void *)unint64_t v10 = &v16;
        uint64_t v16 = v10 | 6;
        if (v11) {
          *int v11 = *v11 & 7 | (unint64_t)&v17;
        }
      }
    }
    sub_1CD50DED0((uint64_t)v14, v9, (uint64_t *)&v15);
    if (v18 != -8192 && v18 != -4096 && v18) {
      llvm::ValueHandleBase::RemoveFromUseList(&v16);
    }
    if (v21 != -8192 && v21 != -4096 && v21) {
      llvm::ValueHandleBase::RemoveFromUseList(&v19);
    }
  }
  if (v24 != -8192 && v24 != -4096)
  {
    if (v24) {
      llvm::ValueHandleBase::RemoveFromUseList(v23);
    }
  }
}

int32x2_t sub_1CD50DE04(int32x2_t *a1, unint64_t *a2)
{
  unint64_t v4 = a2[7];
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(a2 + 5);
  }
  v9[0] = 2;
  v9[1] = 0;
  uint64_t v10 = -8192;
  unint64_t v11 = 0;
  sub_1CBF62D84(a2 + 1, v9);
  uint64_t v6 = v10;
  a2[4] = v11;
  if (v6 != -8192 && v6 != -4096 && v6 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v9);
  }
  int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

double sub_1CD50DED0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  v10[0] = 2;
  v10[1] = 0;
  uint64_t v11 = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0) {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v10);
  }
  uint64_t v9 = &off_1F2609D30;
  uint64_t v12 = a2;
  sub_1CC260C54(v13, &v9, a3 + 1);
  sub_1CD50DFC4((uint64_t)&v15, a2, (uint64_t)v13, v14);
  sub_1CD50E1CC(v13);
  if (v11 != -8192 && v11 != -4096 && v11) {
    llvm::ValueHandleBase::RemoveFromUseList(v10);
  }
  double result = *(double *)&v15;
  *(_OWORD *)a1 = v15;
  *(unsigned char *)(a1 + 16) = v16;
  return result;
}

uint64_t sub_1CD50DFC4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CC2606A0(*(void *)a2, *(_DWORD *)(a2 + 16), *(void *)(a3 + 24), &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD50E054((_DWORD *)a2, v12, a3, a4);
    uint64_t v9 = result;
    char v10 = 1;
  }
  unint64_t v11 = *(void *)a2 + ((unint64_t)*(unsigned int *)(a2 + 16) << 6);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

unint64_t *sub_1CD50E054(_DWORD *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v6 = (unint64_t *)sub_1CC260734(a1, a3, a2);
  sub_1CBF62D84(v6 + 1, (uint64_t *)(a3 + 8));
  _OWORD v6[4] = *(void *)(a3 + 32);
  v6[5] = 6;
  unint64_t v7 = v6 + 5;
  v6[6] = 0;
  unint64_t v8 = (unint64_t)(v6 + 6);
  unint64_t v9 = a4[2];
  v6[7] = v9;
  if (v9 != -8192 && v9 != -4096 && v9 != 0)
  {
    unint64_t v11 = *a4 & 0xFFFFFFFFFFFFFFF8;
    *(void *)unint64_t v8 = *(void *)v11;
    *(void *)unint64_t v11 = v7;
    unint64_t *v7 = v11 | 6;
    if (*(void *)v8) {
      **(void **)unint64_t v8 = **(void **)v8 & 7 | v8;
    }
  }
  return v6;
}

void *sub_1CD50E10C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new((unint64_t)v8 << 6, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CC2607F4(a1, v4, &v4[8 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CC2600F4((void *)a1);
}

void *sub_1CD50E1CC(void *a1)
{
  uint64_t v2 = a1[7];
  if (v2 != -8192 && v2 != -4096 && v2 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 5);
  }
  uint64_t v4 = a1[3];
  if (v4 != -8192 && v4 != -4096 && v4 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 1);
  }
  return a1;
}

void sub_1CD50E230(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 152 * v1;
    uint64_t v3 = *(void *)a1 + 24;
    do
    {
      if ((*(void *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4) {
          free(v4);
        }
      }
      v3 += 152;
      v2 -= 152;
    }
    while (v2);
  }
}

uint64_t sub_1CD50E298(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 24);
  sub_1CC260DE4(&v3);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

BOOL sub_1CD50E2E0(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v2 = a2[16];
  BOOL v3 = v2 < 0x1C || v2 - 81 >= 2;
  if (!v3 || sub_1CC262304(a1 + 1, a2)) {
    return 1;
  }

  return sub_1CB90D2C0(a1 + 3, a2);
}

uint64_t sub_1CD50E34C(int32x2_t *a1, void *a2)
{
  uint64_t v13 = 0;
  if (sub_1CB883B0C((uint64_t)a1, a2, &v13))
  {
    *uint64_t v13 = -8192;
    a1[1] = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  }
  uint64_t result = sub_1CC2737F0(&a1[3], (uint64_t)a2);
  if (*(void *)&a1[4] != result)
  {
    uint64_t v5 = a1[2].u32[0];
    uint64_t v6 = *(void *)a1 + 16 * v5;
    if (a1[1].i32[0])
    {
      if (v5)
      {
        uint64_t v7 = 16 * v5;
        uint64_t v8 = (uint64_t)*a1;
        while ((*(void *)v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v8 += 16;
          v7 -= 16;
          if (!v7) {
            goto LABEL_9;
          }
        }
      }
      else
      {
        uint64_t v8 = (uint64_t)*a1;
      }
    }
    else
    {
LABEL_9:
      uint64_t v8 = *(void *)a1 + 16 * v5;
    }
    uint64_t v9 = *(void *)a1 + 16 * v5;
    if (v8 != v9)
    {
      unint64_t v10 = 0xF0B7672A07A44C6BLL * ((result - *(void *)&a1[3]) >> 3);
      do
      {
        unint64_t v11 = *(unsigned int *)(v8 + 8);
        if (v10 < v11) {
          *(_DWORD *)(v8 + 8) = v11 - 1;
        }
        uint64_t v12 = v8 + 16;
        uint64_t v8 = v6;
        if (v12 != v6)
        {
          uint64_t v8 = v12;
          while ((*(void *)v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v8 += 16;
            if (v8 == v6)
            {
              uint64_t v8 = v6;
              break;
            }
          }
        }
      }
      while (v8 != v9);
    }
  }
  return result;
}

void *sub_1CD50E484(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD50E500(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD50E59C(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    _OWORD v5[2] = 0x1000000000;
  }
  return v5;
}

uint64_t sub_1CD50E500(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 152 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      unint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          unint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 152 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD50E59C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD50E650(a1, v6);
  uint64_t v8 = 0;
  sub_1CD50E500(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD50E650(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(152 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD50E728(a1, v4, v4 + 152 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 152 * v10;
    do
    {
      void *result = -4096;
      result += 19;
      v11 -= 152;
    }
    while (v11);
  }
  return result;
}

void sub_1CD50E728(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 152 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 19;
      v8 -= 152;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CD50E500(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        unsigned int v10 = v13;
        *unsigned int v13 = *(void *)v4;
        void v10[2] = 0x1000000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CBA6E388(v11, (const void **)(v4 + 8));
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 152;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD50E820(uint64_t a1, uint64_t *a2)
{
  v18[64] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  int v11 = 0;
  sub_1CD50E9A8((uint64_t)&v8, a1, &v10, &v11);
  uint64_t v4 = v8;
  if (v9)
  {
    BOOL v12 = v14;
    uint64_t v13 = 0x2000000000;
    uint64_t v15 = *a2;
    char v16 = v18;
    uint64_t v17 = 0x2000000000;
    sub_1CC27AAEC((uint64_t *)(a1 + 24), (uint64_t)&v15);
    if (v16 != v18) {
      free(v16);
    }
    if (v12 != v14) {
      free(v12);
    }
    uint64_t v5 = *(void *)(a1 + 24);
    unsigned int v6 = 128207979 * ((unint64_t)(*(void *)(a1 + 32) - v5) >> 3) - 1;
    *(_DWORD *)(v4 + 8) = v6;
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(v8 + 8);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  return v5 + 536 * v6 + 8;
}

uint64_t sub_1CD50E94C(uint64_t a1)
{
  if (*(char *)(a1 + 103) < 0) {
    operator delete(*(void **)(a1 + 80));
  }
  unsigned int v3 = (void **)(a1 + 48);
  sub_1CC1E4230(&v3);
  unsigned int v3 = (void **)(a1 + 16);
  sub_1CB8338B8(&v3);
  return a1;
}

uint64_t sub_1CD50E9A8(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  BOOL v12 = 0;
  uint64_t result = sub_1CB883B0C(a2, a3, &v12);
  char v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC27AC9C(a2, (uint64_t)a3, a3, v12);
    char v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t *sub_1CD50EA44(uint64_t *result, void *a2)
{
  unsigned int v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      *(void *)(v6 + v7 - 536) = *(void *)(v4 + v7 - 536);
      uint64_t result = (uint64_t *)(v6 + v7 - 528);
      void *result = v6 + v7 - 512;
      *(void *)(v6 + v7 - 520) = 0x2000000000;
      if (*(_DWORD *)(v4 + v7 - 520)) {
        uint64_t result = (uint64_t *)sub_1CD49A6B8((uint64_t)result, v4 + v7 - 528);
      }
      v7 -= 536;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v8 = *v3;
  *unsigned int v3 = v6;
  a2[1] = v8;
  uint64_t v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void *sub_1CD50EB30(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBFF64C0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD50EBA0(a1, a2, v7);
    void *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

void *sub_1CD50EBA0(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD50EC54(a1, v6);
  uint64_t v8 = 0;
  sub_1CBFF64C0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD50EC54(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD50ED20(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD50ED20(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CBFF64C0(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *(void *)a2;
      *((_DWORD *)v10 + 2) = *(_DWORD *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

void *sub_1CD50EDD0(void *a1, unsigned int a2)
{
  if (a2 <= 0x20)
  {
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v3 = a2;
    uint64_t result = operator new(16 * a2, (std::align_val_t)8uLL);
    a1[1] = result;
    a1[2] = v3;
    int v5 = *(_DWORD *)a1;
    *a1 = *(_DWORD *)a1 & 1;
    if ((v5 & 1) == 0)
    {
      uint64_t v6 = &result[2 * v3];
      goto LABEL_6;
    }
  }
  uint64_t result = a1 + 1;
  uint64_t v6 = a1 + 65;
  do
  {
LABEL_6:
    void *result = -4096;
    result += 2;
  }
  while (result != v6);
  return result;
}

uint64_t sub_1CD50EE54(uint64_t a1, unsigned int a2)
{
  v14[64] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x21)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 0x20)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD50EFEC(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    uint64_t v10 = *(void *)(a1 + v8 + 8);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t *v9 = v10;
      v9[1] = *(void *)(a1 + v8 + 16);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 512);
  if (a2 > 0x20)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD50EFEC(a1, v14, v9);
}

uint64_t sub_1CD50EFEC(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 520);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[2 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 2;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v13 = 0;
      uint64_t result = sub_1CC27B2E4((uint64_t)v5, v10, &v13);
      uint64_t v11 = v13;
      uint64_t v12 = a2[1];
      *uint64_t v13 = *a2;
      v11[1] = v12;
      *v5 += 2;
    }
    a2 += 2;
  }
  return result;
}

void *sub_1CD50F0A8(void *result)
{
  unsigned int v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  int v3 = 1 << (33 - __clz((*(_DWORD *)result >> 1) - 1));
  if (*(_DWORD *)result >= 2u) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 0;
  }
  if ((v2 & 1) != 0 && v4 < 0x21)
  {
    int v5 = result + 65;
    void *result = 1;
    int v6 = result + 1;
    do
    {
LABEL_7:
      void *v6 = -4096;
      v6 += 2;
    }
    while (v6 != v5);
    return result;
  }
  if ((v2 & 1) == 0)
  {
    if (v4 == *((_DWORD *)result + 4))
    {
      void *result = 0;
      if (v2 < 2) {
        return result;
      }
      int v6 = (void *)result[1];
      int v5 = &v6[2 * v4];
      goto LABEL_7;
    }
    MEMORY[0x1D25D9CD0](result[1], 8);
  }

  return sub_1CD50EDD0(v1, v4);
}

void sub_1CD50F174(void *a1, unsigned int a2)
{
  if (a2 <= 8)
  {
    *a1 = 1;
    goto LABEL_5;
  }
  *(_DWORD *)a1 &= ~1u;
  uint64_t v3 = a2;
  size_t v4 = 16 * a2;
  int v5 = operator new(v4, (std::align_val_t)8uLL);
  a1[1] = v5;
  a1[2] = v3;
  int v6 = *(_DWORD *)a1;
  *a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
LABEL_5:
    int v5 = a1 + 1;
    size_t v4 = 128;
  }

  memset_pattern16(v5, &unk_1CFAC3070, v4);
}

void sub_1CD50F20C(uint64_t a1, unsigned int a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD50F3AC(a1, v6, &v6[2 * v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    uint64_t v11 = *(void *)(a1 + v8 + 8);
    uint64_t v10 = *(void *)(a1 + v8 + 16);
    if ((v11 != -4096 || v10 != -4096) && (v11 != -8192 || v10 != -8192))
    {
      *(_OWORD *)uint64_t v9 = *(_OWORD *)(a1 + v8 + 8);
      v9 += 2;
    }
    v8 += 16;
  }
  while (v8 != 128);
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v12 = a2;
    *(void *)(a1 + 8) = operator new(16 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v12;
  }
  sub_1CD50F3AC(a1, v14, v9);
}

void sub_1CD50F3AC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(a1 + 8);
    size_t v9 = 128;
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (!v7) {
      goto LABEL_6;
    }
    uint64_t v8 = *(void **)(a1 + 8);
    size_t v9 = 16 * v7;
  }
  memset_pattern16(v8, &unk_1CFAC3070, v9);
LABEL_6:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    uint64_t v11 = a2[1];
    if ((*a2 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
    {
      uint64_t v13 = 0;
      sub_1CC27B728(a1, v10, v11, &v13);
      uint64_t v12 = v13;
      *uint64_t v13 = *a2;
      v12[1] = a2[1];
      *(_DWORD *)a1 += 2;
    }
    a2 += 2;
  }
}

uint64_t sub_1CD50F484(uint64_t a1, unint64_t a2, unint64_t a3, _OWORD *a4)
{
  int v6 = (uint64_t **)sub_1CD50F530(a1, &v13, a2, a3);
  if (*v6) {
    return 0;
  }
  uint64_t v8 = v6;
  size_t v9 = operator new(0x30uLL);
  uint64_t v9[2] = *a4;
  uint64_t v10 = v13;
  *(void *)size_t v9 = 0;
  *((void *)v9 + 1) = 0;
  *((void *)v9 + 2) = v10;
  void *v8 = (uint64_t *)v9;
  uint64_t v11 = **(void **)a1;
  if (v11)
  {
    *(void *)a1 = v11;
    uint64_t v12 = *v8;
  }
  else
  {
    uint64_t v12 = (uint64_t *)v9;
  }
  sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
  ++*(void *)(a1 + 16);
  return 1;
}

void *sub_1CD50F530(uint64_t a1, void *a2, unint64_t a3, unint64_t a4)
{
  int v6 = *(void **)(a1 + 8);
  uint64_t result = (void *)(a1 + 8);
  int v5 = v6;
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = v5;
        unint64_t v8 = v5[4];
        if (v8 <= a3) {
          break;
        }
LABEL_3:
        int v5 = (void *)*v7;
        uint64_t result = v7;
        if (!*v7) {
          goto LABEL_12;
        }
      }
      if (v8 >= a3)
      {
        unint64_t v9 = v7[5];
        if (v9 > a4) {
          goto LABEL_3;
        }
        if (v9 >= a4) {
          goto LABEL_12;
        }
      }
      uint64_t result = v7 + 1;
      int v5 = (void *)v7[1];
      if (!v5) {
        goto LABEL_12;
      }
    }
  }
  uint64_t v7 = result;
LABEL_12:
  *a2 = v7;
  return result;
}

void sub_1CD50F58C(unsigned int *a1)
{
  unsigned int v2 = *a1;
  char v3 = __clz((*a1 >> 1) - 1);
  if ((v3 & 0x3E) == 0x1C) {
    int v4 = 64;
  }
  else {
    int v4 = 1 << (33 - v3);
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((v2 & 1) != 0 && v5 < 9)
  {
    *(void *)a1 = 1;
    int v6 = a1 + 2;
    size_t v7 = 128;
LABEL_10:
    memset_pattern16(v6, &unk_1CFAC3070, v7);
    return;
  }
  if ((v2 & 1) == 0)
  {
    if (v5 == a1[4])
    {
      *(void *)a1 = 0;
      if (!v5) {
        return;
      }
      int v6 = (void *)*((void *)a1 + 1);
      size_t v7 = 16 * v5;
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](*((void *)a1 + 1), 8);
  }

  sub_1CD50F174(a1, v5);
}

uint64_t sub_1CD50F67C@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD50F704((uint64_t *)a1, a2, &v10);
  size_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD50F7A0(a1, (uint64_t)a2, a2, v10);
    size_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD50F704(uint64_t *a1, void *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v3 - 1);
    size_t v7 = (void *)(*a1 + 8 * v6);
    uint64_t v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v9 = 0;
      int v10 = 1;
      uint64_t result = 1;
      while (v8 != -4096)
      {
        if (v9) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -8192;
        }
        if (v12) {
          uint64_t v9 = v7;
        }
        unsigned int v13 = v6 + v10++;
        unsigned int v6 = v13 & v5;
        size_t v7 = (void *)(v4 + 8 * (v13 & v5));
        uint64_t v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_7;
        }
      }
      uint64_t result = 0;
      if (v9) {
        size_t v7 = v9;
      }
    }
  }
  else
  {
    size_t v7 = 0;
    uint64_t result = 0;
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD50F7A0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CC27C25C(a1, v7);
  uint64_t v9 = 0;
  sub_1CD50F704((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_6:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

uint64_t sub_1CD50F854(uint64_t result, void *a2, void *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)result;
    uint64_t v8 = 8 * v6;
    do
    {
      *v7++ = -4096;
      v8 -= 8;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v9 = 0;
      uint64_t result = sub_1CD50F704((uint64_t *)v5, a2, &v9);
      void *v9 = *a2;
      ++*(_DWORD *)(v5 + 8);
    }
    ++a2;
  }
  return result;
}

llvm::Instruction *sub_1CD50F904(uint64_t *a1, llvm::Value *a2, llvm::BasicBlock *a3, llvm::BasicBlock *a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  int v10 = operator new(0xA0uLL);
  uint64_t v11 = 0;
  BOOL v12 = (llvm::Instruction *)(v10 + 24);
  v10[29] = v10[29] & 0x38000000 | 3;
  do
  {
    unsigned int v13 = &v10[v11];
    *unsigned int v13 = 0;
    v13[1] = 0;
    uint64_t v13[2] = 0;
    v13[3] = v12;
    v11 += 8;
  }
  while (v11 != 24);
  llvm::BranchInst::BranchInst((llvm::BranchInst *)(v10 + 24), a3, a4, a2, 0);
  if (a5)
  {
    *(_OWORD *)uint64_t v15 = xmmword_1CFAC6D38;
    llvm::Instruction::copyMetadata((uint64_t)v12, a5, v15, 4);
  }
  __int16 v16 = 257;
  return sub_1CB844E0C(a1, v12, (uint64_t)v15);
}

uint64_t sub_1CD50FA08(uint64_t result, unint64_t *a2)
{
  uint64_t v3 = result;
  if (*(void *)(result + 48))
  {
    uint64_t v8 = (uint64_t **)(result + 32);
    unint64_t v9 = *a2;
  }
  else
  {
    uint64_t v4 = *(unsigned int *)(result + 8);
    unint64_t v5 = *a2;
    if (!v4)
    {
LABEL_7:
      if (v4 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)result + 8 * v4) = v5;
      ++*(_DWORD *)(result + 8);
      return result;
    }
    uint64_t v6 = 8 * v4;
    unsigned int v7 = *(void **)result;
    while (*v7 != v5)
    {
      ++v7;
      v6 -= 8;
      if (!v6) {
        goto LABEL_6;
      }
    }
    if (v6) {
      return result;
    }
LABEL_6:
    if (v4 <= 1) {
      goto LABEL_7;
    }
    do
    {
      unint64_t v10 = *(void *)(*(void *)v3 + 8 * v4 - 8);
      sub_1CD4AB93C((uint64_t **)(v3 + 32), v10, v10);
      LODWORD(v4) = *(_DWORD *)(v3 + 8) - 1;
      *(_DWORD *)(v3 + 8) = v4;
    }
    while (v4);
    unint64_t v9 = *a2;
    uint64_t v8 = (uint64_t **)(v3 + 32);
  }

  return sub_1CD4AB93C(v8, v9, v9);
}

void *sub_1CD50FB1C(uint64_t *a1, void *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CC077838(a1, a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD49F120((uint64_t)a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

unint64_t *sub_1CD50FB80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a2 + 8;
  uint64_t v8 = operator new(0x38uLL);
  *(void *)a1 = v8;
  *(void *)(a1 + 8) = v7;
  unint64_t v9 = v8;
  v8[6] = a4;
  v8[4] = 6;
  uint64_t result = v8 + 4;
  v9[5] = 0;
  unint64_t v11 = (unint64_t)(v9 + 5);
  if (a4 != -8192 && a4 != -4096)
  {
    if (a4)
    {
      *(void *)unint64_t v11 = *(void *)(a3 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(a3 & 0xFFFFFFFFFFFFFFF8) = result;
      unint64_t *result = a3 & 0xFFFFFFFFFFFFFFF8 | 6;
      if (*(void *)v11) {
        **(void **)unint64_t v11 = **(void **)v11 & 7 | v11;
      }
    }
  }
  *(unsigned char *)(a1 + 16) = 1;
  return result;
}

void sub_1CD50FC20(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CD50E230((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      unint64_t v5 = *(void **)a1;
      uint64_t v6 = 152 * v4;
      do
      {
        void *v5 = -4096;
        v5 += 19;
        v6 -= 152;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC260D48(a1, v4);
  }
}

void **sub_1CD50FCD4(void *a1)
{
  int v2 = *((_DWORD *)a1 + 2);
  sub_1CC260E78(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 == *((_DWORD *)a1 + 4))
  {
    return (void **)sub_1CC2600F4(a1);
  }
  else
  {
    MEMORY[0x1D25D9CD0](*a1, 8);
    return sub_1CC260060((void **)a1, v4);
  }
}

uint64_t sub_1CD50FD78(uint64_t a1, uint64_t a2, int *a3, void *a4)
{
  BOOL v12 = 0;
  uint64_t result = sub_1CD50FE20(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v12);
  unint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD50FF04(a2, a3, v12);
    unint64_t v9 = (_DWORD *)result;
    *(_DWORD *)uint64_t result = *a3;
    *(_DWORD *)(result + 4) = a3[1];
    *(void *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD50FE20(uint64_t a1, int a2, int a3, int a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((37 * a4) | ((unint64_t)(37 * a3) << 32))
       + ~((unint64_t)(37 * a4) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    char v10 = (_DWORD *)(a1 + 16 * v9);
    int v11 = *v10;
    int v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      uint64_t v14 = 1;
    }
    else
    {
      __int16 v16 = 0;
      int v17 = 1;
      while (v11 != -1 || v12 != -1)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v12 == -2;
        }
        if (v18 && v11 == -2) {
          __int16 v16 = v10;
        }
        unsigned int v20 = v9 + v17++;
        unsigned int v9 = v20 & v8;
        char v10 = (_DWORD *)(a1 + 16 * (v20 & v8));
        int v11 = *v10;
        int v12 = v10[1];
        uint64_t v14 = 1;
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_8;
        }
      }
      uint64_t v14 = 0;
      if (v16) {
        char v10 = v16;
      }
    }
  }
  else
  {
    char v10 = 0;
    uint64_t v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

_DWORD *sub_1CD50FF04(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD50FFBC(a1, v6);
  unsigned int v9 = 0;
  sub_1CD50FE20(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || a3[1] != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD50FFBC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD510088(a1, v4, v4 + 16 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -1;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD510088(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      void *v7 = -1;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    int v9 = *(_DWORD *)a2;
    int v10 = *(_DWORD *)(a2 + 4);
    if ((*(_DWORD *)a2 != -1 || v10 != -1) && (v9 != -2 || v10 != -2))
    {
      uint64_t v14 = 0;
      uint64_t result = sub_1CD50FE20(*(void *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v14);
      unsigned int v13 = v14;
      *uint64_t v14 = *(_DWORD *)a2;
      v13[1] = *(_DWORD *)(a2 + 4);
      *((void *)v13 + 1) = *(void *)(a2 + 8);
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 16;
  }
  return result;
}

void *sub_1CD510154(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD5101D0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD51026C(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    _OWORD v5[2] = 0x200000000;
  }
  return v5;
}

uint64_t sub_1CD5101D0(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 40 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      int v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          int v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 40 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD51026C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD510320(a1, v6);
  uint64_t v8 = 0;
  sub_1CD5101D0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD510320(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5103F8(a1, v4, v4 + 40 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 40 * v10;
    do
    {
      void *result = -4096;
      result += 5;
      v11 -= 40;
    }
    while (v11);
  }
  return result;
}

void sub_1CD5103F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 40 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 5;
      v8 -= 40;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CD5101D0(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *unsigned int v13 = *(void *)v4;
        void v10[2] = 0x200000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD41C56C(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

void sub_1CD5104F4(uint64_t **a1)
{
  uint64_t v11 = v15;
  BOOL v12 = v15;
  uint64_t v13 = 4;
  int v14 = 0;
  llvm::DbgVariableIntrinsic::location_ops((uint64_t)a1, &v9);
  uint64_t v3 = v9;
  uint64_t v2 = v10;
  if (v9 != v10)
  {
    do
    {
      uint64_t v4 = (unint64_t *)(v3 & 0xFFFFFFFFFFFFFFF8);
      unint64_t v5 = v3 & 0xFFFFFFFFFFFFFFF8;
      if ((v3 & 4) != 0) {
        unint64_t v5 = *v4;
      }
      uint64_t v6 = *(llvm::UndefValue ***)(v5 + 128);
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v11, (uint64_t)v6);
      if ((_BYTE)v7)
      {
        uint64_t v8 = llvm::UndefValue::get(*v6, v7);
        llvm::DbgVariableIntrinsic::replaceVariableLocationOp(a1, (llvm::Value *)v6, v8);
      }
      if ((v3 & 4) != 0) {
        uint64_t v3 = (unint64_t)(v4 + 1) | 4;
      }
      else {
        uint64_t v3 = (uint64_t)(v4 + 17);
      }
    }
    while (v3 != v2);
    if (v12 != v11) {
      free(v12);
    }
  }
}

void sub_1CD5105C8(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC9988, 0, 0);
  byte_1EBCC9A08 = 0;
  qword_1EBCC9A10 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCC9A18 = 0;
  qword_1EBCC9988 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC9A20 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC9A28 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC9A40 = (uint64_t)&qword_1EBCC9A28;
  sub_1CD5106C8(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC9988);
}

__n128 sub_1CD5106C8(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC9988, "profile-guided-section-prefix", 0x1DuLL);
  word_1EBCC9992 = word_1EBCC9992 & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  byte_1EBCC9A08 = **a2;
  byte_1EBCC9A19 = 1;
  byte_1EBCC9A18 = *v8;
  word_1EBCC9992 = word_1EBCC9992 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCC99A8 = (__int128)*a4;
  return result;
}

void sub_1CD510760(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCC9A48, 0, 0);
  byte_1EBCC9AC8 = 0;
  qword_1EBCC9AD0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCC9AD8 = 0;
  qword_1EBCC9A48 = (uint64_t)&unk_1F26440A0;
  qword_1EBCC9AE0 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCC9AE8 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCC9B00 = (uint64_t)&qword_1EBCC9AE8;
  sub_1CD510860(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC9A48);
}

__n128 sub_1CD510860(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCC9A48, "profile-unknown-in-special-section", 0x22uLL);
  word_1EBCC9A52 = word_1EBCC9A52 & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  byte_1EBCC9AC8 = **a2;
  byte_1EBCC9AD9 = 1;
  byte_1EBCC9AD8 = *v8;
  word_1EBCC9A52 = word_1EBCC9A52 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBCC9A68 = (__int128)*a4;
  return result;
}

void sub_1CD5108F8(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCC9B08, 0, 0);
  dword_1EBCC9B88 = 0;
  qword_1EBCC9B90 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCC9B98 = 0;
  qword_1EBCC9B08 = (uint64_t)&unk_1F2643F00;
  qword_1EBCC9BA0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCC9BA8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCC9BC0 = (uint64_t)&qword_1EBCC9BA8;
  llvm::cl::Option::setArgStr(v6, "cgp-freq-ratio-to-skip-merge", 0x1CuLL);
  word_1EBCC9B12 = (32 * (*a1 & 3)) | word_1EBCC9B12 & 0xFF9F;
  dword_1EBCC9B88 = **a2;
  byte_1EBCC9B9C = 1;
  dword_1EBCC9B98 = dword_1EBCC9B88;
  xmmword_1EBCC9B28 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCC9B08);
}

void sub_1CD510A24(uint64_t a1, llvm::raw_ostream *a2)
{
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v14 = 0;
  int v5 = 0;
  char v9 = 0;
  uint64_t v10 = 0;
  BOOL v12 = v13;
  int v11 = 0;
  uint64_t v4 = &unk_1F2646F30;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  sub_1CD510C1C(a2, (llvm::raw_ostream *)&v4);
  if (*((char *)v12 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *v12, (unint64_t)v12[1]);
  }
  else
  {
    long long v3 = *(_OWORD *)v12;
    *(void *)(a1 + 16) = v12[2];
    *(_OWORD *)a1 = v3;
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v4);
  if (SHIBYTE(v14) < 0) {
    operator delete(v13[0]);
  }
}

void *sub_1CD510AE8(uint64_t a1)
{
  *(void *)a1 = &unk_1F260A070;
  uint64_t v2 = a1 + 184;
  uint64_t v3 = *(void *)(a1 + 208);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  uint64_t v4 = *(void **)(a1 + 152);
  if (v4)
  {
    *(void *)(a1 + 160) = v4;
    operator delete(v4);
  }
  uint64_t v6 = (void **)(a1 + 128);
  sub_1CB8338B8(&v6);
  return sub_1CB87DD48((void *)a1);
}

uint64_t sub_1CD510BB8()
{
  return 2;
}

void sub_1CD510BC0(uint64_t a1)
{
  sub_1CD510AE8(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD510BF8(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 176, a1);
}

llvm::raw_ostream *sub_1CD510C04(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::Option *)((char *)a1 + 176), a1, a2);
}

llvm::raw_ostream *sub_1CD510C1C(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  uint64_t v3 = result;
  unint64_t v4 = *(char *)result;
  if (v4 <= 2)
  {
    size_t v5 = qword_1CFAC6D80[v4];
    uint64_t v6 = off_1E682F518[v4];
    uint64_t v7 = (void *)*((void *)this + 4);
    if (v5 <= *((void *)this + 3) - (void)v7)
    {
      __n128 result = (llvm::raw_ostream *)memcpy(v7, v6, v5);
      *((void *)this + 4) += v5;
    }
    else
    {
      __n128 result = llvm::raw_ostream::write(this, v6, v5);
      this = result;
    }
  }
  uint64_t v8 = (unsigned char *)*((void *)this + 4);
  if ((unint64_t)v8 >= *((void *)this + 3))
  {
    __n128 result = llvm::raw_ostream::write(this, 44);
    this = result;
  }
  else
  {
    *((void *)this + 4) = v8 + 1;
    unsigned char *v8 = 44;
  }
  unint64_t v9 = *((char *)v3 + 1);
  if (v9 <= 2)
  {
    size_t v10 = qword_1CFAC6D80[v9];
    int v11 = off_1E682F518[v9];
    BOOL v12 = (void *)*((void *)this + 4);
    if (v10 <= *((void *)this + 3) - (void)v12)
    {
      __n128 result = (llvm::raw_ostream *)memcpy(v12, v11, v10);
      *((void *)this + 4) += v10;
    }
    else
    {
      size_t v13 = qword_1CFAC6D80[v9];
      return llvm::raw_ostream::write(this, v11, v13);
    }
  }
  return result;
}

void sub_1CD510D44()
{
}

void *sub_1CD510D58()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F260AC78;
  return result;
}

void sub_1CD510D90(uint64_t a1, void *a2)
{
  *a2 = &unk_1F260AC78;
}

void sub_1CD510DBC(long long *a1, char **a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCCAA40, 0, 0);
  byte_1EBCCAAC0 = 0;
  qword_1EBCCAAC8 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCCAAD0 = 0;
  qword_1EBCCAA40 = (uint64_t)&unk_1F26440A0;
  qword_1EBCCAAD8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCCAAE0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCCAAF8 = (uint64_t)&qword_1EBCCAAE0;
  llvm::cl::Option::setArgStr(v4, "vec-extabi", 0xAuLL);
  xmmword_1EBCCAA60 = *a1;
  size_t v5 = *a2;
  byte_1EBCCAAC0 = **a2;
  byte_1EBCCAAD1 = 1;
  byte_1EBCCAAD0 = *v5;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCAA40);
}

void sub_1CD510ECC(long long *a1, char **a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCCAE00, 0, 0);
  byte_1EBCCAE80 = 0;
  qword_1EBCCAE88 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCCAE90 = 0;
  qword_1EBCCAE00 = (uint64_t)&unk_1F26440A0;
  qword_1EBCCAE98 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCCAEA0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCCAEB8 = (uint64_t)&qword_1EBCCAEA0;
  llvm::cl::Option::setArgStr(v4, "use-ctors", 9uLL);
  xmmword_1EBCCAE20 = *a1;
  size_t v5 = *a2;
  byte_1EBCCAE80 = **a2;
  byte_1EBCCAE91 = 1;
  byte_1EBCCAE90 = *v5;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCAE00);
}

void sub_1CD510FDC(long long *a1, char **a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EA6196E8, 0, 0);
  byte_1EA619768 = 0;
  qword_1EA619770 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EA619778 = 0;
  qword_1EA6196E8[0] = (uint64_t)&unk_1F26440A0;
  qword_1EA619780 = (uint64_t)&unk_1F2643CC0;
  qword_1EA619788 = (uint64_t)&unk_1F25EDE78;
  qword_1EA6197A0 = (uint64_t)&qword_1EA619788;
  llvm::cl::Option::setArgStr(v4, "addrsig", 7uLL);
  xmmword_1EA619708 = *a1;
  size_t v5 = *a2;
  byte_1EA619768 = **a2;
  byte_1EA619779 = 1;
  byte_1EA619778 = *v5;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EA6196E8);
}

void sub_1CD5110F0(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD511128(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F260B058;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 40);
  *(void *)(a1 + 24) = (*(uint64_t (**)(void))(**(void **)(a2 + 16) + 104))(*(void *)(a2 + 16));
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 16) + 176))(*(void *)(*(void *)(a1 + 8) + 16));
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = a3;
  *(void *)(a1 + 48) = a1 + 64;
  *(void *)(a1 + 56) = 0x600000000;
  *(_DWORD *)(a1 + 112) = 0;
  uint64_t v6 = *(unsigned int *)(v5 + 16);
  uint64_t v10 = 0;
  sub_1CD4CABD8((void *)(a1 + 120), v6, &v10);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 144) = a1 + 152;
  unint64_t v7 = *(unsigned int *)(*(void *)(a1 + 32) + 16);
  LODWORD(v10) = 0;
  sub_1CD5085F8((void *)(a1 + 168), v7, (int *)&v10);
  unint64_t v8 = *(unsigned int *)(*(void *)(a1 + 32) + 16);
  LODWORD(v10) = 0;
  sub_1CD5085F8((void *)(a1 + 192), v8, (int *)&v10);
  LODWORD(a3) = *(_DWORD *)(*(void *)(a1 + 32) + 16);
  *(void *)(a1 + 216) = a1 + 232;
  *(void *)(a1 + 224) = 0x600000000;
  sub_1CB90D610(a1 + 216, (a3 + 63) >> 6, 0);
  *(_DWORD *)(a1 + 280) = a3;
  return a1;
}

void sub_1CD51127C(uint64_t a1)
{
  *(void *)a1 = &unk_1F260B058;
  uint64_t v2 = *(void **)(a1 + 216);
  if (v2 != (void *)(a1 + 232)) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 192);
  if (v3)
  {
    *(void *)(a1 + 200) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 168);
  if (v4)
  {
    *(void *)(a1 + 176) = v4;
    operator delete(v4);
  }
  sub_1CD40B1BC(*(void **)(a1 + 152));
  uint64_t v5 = *(void **)(a1 + 120);
  if (v5)
  {
    *(void *)(a1 + 128) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 48);
  if (v6 != (void *)(a1 + 64)) {
    free(v6);
  }

  llvm::AntiDepBreaker::~AntiDepBreaker((llvm::AntiDepBreaker *)a1);
}

void sub_1CD511330(uint64_t a1)
{
  sub_1CD51127C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD511368(uint64_t a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v4 = -1;
  uint64_t v5 = a2 + 48;
  do
  {
    uint64_t v5 = *(void *)(v5 + 8);
    ++v4;
  }
  while (v5 != a2 + 48);
  uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 32) + 16);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      *(void *)(*(void *)(a1 + 120) + 8 * i) = 0;
      *(_DWORD *)(*(void *)(a1 + 168) + 4 * i) = -1;
      *(_DWORD *)(*(void *)(a1 + 192) + 4 * i) = v4;
    }
  }
  uint64_t v8 = *(unsigned int *)(a1 + 224);
  if (v8) {
    bzero(*(void **)(a1 + 216), 8 * v8);
  }
  BOOL v9 = sub_1CC234048(a2);
  uint64_t v10 = *(llvm::MachineBasicBlock ***)(a2 + 88);
  for (uint64_t j = *(llvm::MachineBasicBlock ***)(a2 + 96); v10 != j; ++v10)
  {
    BOOL v12 = *v10;
    uint64_t v13 = llvm::MachineBasicBlock::livein_begin(*v10);
    uint64_t v14 = (unsigned __int16 *)*((void *)v12 + 20);
    if (v14 != (unsigned __int16 *)v13)
    {
      uint64_t v15 = (unsigned __int16 *)v13;
      do
      {
        uint64_t v16 = *(void *)(a1 + 32);
        if (v16) {
          int v17 = (void *)(v16 + 8);
        }
        else {
          int v17 = 0;
        }
        sub_1CB8FB608((uint64_t)v34, *v15, v17, 1);
        uint64_t v18 = v36;
        while (v18)
        {
LABEL_16:
          uint64_t v19 = v37;
          *(void *)(*(void *)(a1 + 120) + 8 * v37) = -1;
          *(_DWORD *)(*(void *)(a1 + 168) + 4 * v19) = v4;
          *(_DWORD *)(*(void *)(a1 + 192) + 4 * v19) = -1;
          while (1)
          {
            sub_1CB8FB704((uint64_t)v34);
            uint64_t v18 = v36;
            if (v35 || v36 == 0) {
              break;
            }
            if (LODWORD(v34[0]) != v37) {
              goto LABEL_16;
            }
          }
        }
        v15 += 8;
      }
      while (v15 != v14);
    }
  }
  llvm::MachineFrameInfo::getPristineRegs(*(llvm::MachineFrameInfo **)(*(void *)(a1 + 8) + 56), *(const llvm::MachineFunction **)(a1 + 8), (uint64_t)v34);
  CalleeSavedRegs = (_WORD *)llvm::MachineRegisterInfo::getCalleeSavedRegs(*(llvm::MachineRegisterInfo **)(*(void *)(a1 + 8) + 40));
  unsigned int v22 = (unsigned __int16)*CalleeSavedRegs;
  if (*CalleeSavedRegs)
  {
    uint64_t v23 = CalleeSavedRegs;
    do
    {
      if (v9 || ((*((void *)v34[0] + (v22 >> 6)) >> v22) & 1) != 0)
      {
        uint64_t v24 = *(void *)(a1 + 32);
        if (v24) {
          uint64_t v25 = (void *)(v24 + 8);
        }
        else {
          uint64_t v25 = 0;
        }
        sub_1CB8FB608((uint64_t)v30, v22, v25, 1);
        uint64_t v26 = v32;
        while (v26)
        {
LABEL_34:
          uint64_t v27 = v33;
          *(void *)(*(void *)(a1 + 120) + 8 * v33) = -1;
          *(_DWORD *)(*(void *)(a1 + 168) + 4 * v27) = v4;
          *(_DWORD *)(*(void *)(a1 + 192) + 4 * v27) = -1;
          while (1)
          {
            sub_1CB8FB704((uint64_t)v30);
            uint64_t v26 = v32;
            if (v31 || v32 == 0) {
              break;
            }
            if (v30[0] != v33) {
              goto LABEL_34;
            }
          }
        }
      }
      unsigned int v29 = (unsigned __int16)v23[1];
      ++v23;
      unsigned int v22 = v29;
    }
    while (v29);
  }
  if (v34[0] != &v35) {
    free(v34[0]);
  }
}

void sub_1CD5115EC(uint64_t a1)
{
  uint64_t v2 = a1 + 152;
  sub_1CD40B1BC(*(void **)(a1 + 152));
  *(void *)(v2 - 8) = v2;
  *(void *)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  uint64_t v3 = *(unsigned int *)(v2 + 72);
  if (v3)
  {
    int v4 = *(void **)(a1 + 216);
    bzero(v4, 8 * v3);
  }
}

void sub_1CD51164C(void *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  int v4 = **(unsigned __int16 **)(a2 + 16);
  if ((v4 - 13) >= 5 && v4 != 7)
  {
    uint64_t v9 = a1[4];
    if (*(_DWORD *)(v9 + 16))
    {
      unsigned int v10 = 0;
      do
      {
        uint64_t v11 = v10;
        int v12 = *(_DWORD *)(a1[21] + 4 * v10);
        uint64_t v13 = a1 + 21;
        unsigned int v14 = a3;
        if (v12 != -1
          || ((unsigned int v15 = *(_DWORD *)(a1[24] + 4 * v11), v15 < a4) ? (v16 = v15 >= a3) : (v16 = 0),
              uint64_t v13 = a1 + 24,
              unsigned int v14 = a4,
              v16))
        {
          *(void *)(a1[15] + 8 * v11) = -1;
          *(_DWORD *)(*v13 + 4 * v11) = v14;
          uint64_t v9 = a1[4];
        }
        unsigned int v10 = v11 + 1;
      }
      while (v11 + 1 != *(_DWORD *)(v9 + 16));
    }
    sub_1CC28C868((uint64_t)a1, a2);
    sub_1CC28CD00((uint64_t)a1, a2, a3);
  }
}

void llvm::createCriticalAntiDepBreaker(llvm *this, llvm::MachineFunction *a2, const llvm::RegisterClassInfo *a3)
{
}

uint64_t *sub_1CD5117A0(uint64_t **a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = (uint64_t *)operator new(0x30uLL);
  unint64_t v7 = v6;
  *((_DWORD *)v6 + 8) = a2;
  v6[5] = a3;
  uint64_t v8 = a1 + 1;
  uint64_t v9 = (uint64_t **)a1[1];
  if (v9)
  {
    do
    {
      while (1)
      {
        uint64_t v8 = v9;
        if (*((_DWORD *)v9 + 8) <= a2) {
          break;
        }
        uint64_t v9 = (uint64_t **)*v9;
        unsigned int v10 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      uint64_t v9 = (uint64_t **)v9[1];
    }
    while (v9);
    unsigned int v10 = v8 + 1;
  }
  else
  {
    unsigned int v10 = a1 + 1;
  }
LABEL_8:
  uint64_t *v6 = 0;
  v6[1] = 0;
  void v6[2] = (uint64_t)v8;
  *unsigned int v10 = v6;
  uint64_t v11 = (uint64_t *)**a1;
  if (v11)
  {
    *a1 = v11;
    unint64_t v7 = *v10;
  }
  __n128 result = sub_1CB8358B8(a1[1], v7);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void *sub_1CD511858(uint64_t a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD5118C4(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD5118C4(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD511978(a1, v6);
  uint64_t v8 = 0;
  sub_1CD40EA84(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD511978(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD468018(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void llvm::initializeDeadMachineInstructionElimPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB1C0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC28DA54;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB1C0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeDetectDeadLanesPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB1C8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC28E2C0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB1C8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void *sub_1CD511B2C(void *result)
{
  unsigned int v1 = (void **)result[1];
  uint64_t v2 = result[2];
  result[5] = 0;
  unint64_t v3 = v2 - (void)v1;
  if (v3 >= 0x11)
  {
    do
    {
      unint64_t v6 = result;
      operator delete(*v1);
      __n128 result = v6;
      uint64_t v5 = v6[2];
      unsigned int v1 = (void **)(v6[1] + 8);
      v6[1] = v1;
      unint64_t v3 = v5 - (void)v1;
    }
    while (v3 > 0x10);
  }
  if (v3 >> 3 == 2)
  {
    uint64_t v4 = 1024;
LABEL_4:
    result[4] = v4;
    return result;
  }
  if (v3 >> 3 == 1)
  {
    uint64_t v4 = 512;
    goto LABEL_4;
  }
  return result;
}

BOOL llvm::DFAPacketizer::canReserveResources(uint64_t a1, uint64_t a2)
{
  if (*(_WORD *)(a2 + 6)) {
    BOOL v2 = *(_DWORD *)(*(void *)(a1 + 56) + 4 * *(unsigned __int16 *)(a2 + 6)) == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2) {
    return 0;
  }
  unint64_t v4 = *(unsigned int *)(*(void *)(a1 + 56) + 4 * *(unsigned __int16 *)(a2 + 6));
  return sub_1CD511BF8((void *)(a1 + 8), &v4);
}

BOOL sub_1CD511BF8(void *a1, unint64_t *a2)
{
  BOOL v2 = (void *)(*a1 + 8);
  unint64_t v3 = (void *)*v2;
  if (!*v2) {
    goto LABEL_14;
  }
  unint64_t v4 = a1[4];
  unint64_t v5 = *a2;
  uint64_t v6 = *a1 + 8;
  do
  {
    unint64_t v7 = v3[4];
    if (v7 >= v4)
    {
      if (v4 >= v7)
      {
        if (v3[5] < v5) {
          ++v3;
        }
        else {
          uint64_t v6 = (uint64_t)v3;
        }
      }
      else
      {
        uint64_t v6 = (uint64_t)v3;
      }
    }
    else
    {
      ++v3;
    }
    unint64_t v3 = (void *)*v3;
  }
  while (v3);
  if ((void *)v6 == v2 || (unint64_t v8 = *(void *)(v6 + 32), v4 < v8) || v8 >= v4 && v5 < *(void *)(v6 + 40)) {
LABEL_14:
  }
    uint64_t v6 = *a1 + 8;
  return v6 != (void)v2;
}

uint64_t llvm::DFAPacketizer::reserveResources(uint64_t result, uint64_t a2)
{
  if (*(_WORD *)(a2 + 6)) {
    BOOL v2 = *(_DWORD *)(*(void *)(result + 56) + 4 * *(unsigned __int16 *)(a2 + 6)) == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2)
  {
    unint64_t v3 = *(unsigned int *)(*(void *)(result + 56) + 4 * *(unsigned __int16 *)(a2 + 6));
    return sub_1CC28FE04(result + 8, &v3);
  }
  return result;
}

uint64_t sub_1CD511CDC()
{
  return 0;
}

uint64_t sub_1CD511CE4(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void sub_1CD511D98(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 168);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 160);
    uint64_t v4 = 48 * v2;
    do
    {
      unint64_t v5 = *(void **)(v3 + v4 - 48);
      if ((void *)(v3 + v4 - 32) != v5) {
        free(v5);
      }
      v4 -= 48;
    }
    while (v4);
  }
  *(_DWORD *)(a1 + 168) = 0;
  uint64_t v6 = (void *)(a1 + 112);
  sub_1CD3F260C((void *)(a1 + 112));
  unint64_t v7 = (uint64_t *)(a1 + 16);
  sub_1CBFFBB10((uint64_t)v7);
  unint64_t v8 = (void *)sub_1CB906F34(v7, 16, 3);
  void *v8 = 0;
  v8[1] = 0;
  uint64_t v9 = v8;
  sub_1CD3F21B0(v6, &v9);
}

void sub_1CD511E3C(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCCB1D8, 0, 0);
  dword_1EBCCB258 = 0;
  qword_1EBCCB260 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCCB268 = 0;
  qword_1EBCCB1D8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCCB270 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCCB278 = (uint64_t)&unk_1F25EA168;
  qword_1EBCCB290 = (uint64_t)&qword_1EBCCB278;
  llvm::cl::Option::setArgStr(v6, "dfa-instr-limit", 0xFuLL);
  word_1EBCCB1E2 = (32 * (*a1 & 3)) | word_1EBCCB1E2 & 0xFF9F;
  dword_1EBCCB258 = **a2;
  byte_1EBCCB26C = 1;
  dword_1EBCCB268 = dword_1EBCCB258;
  xmmword_1EBCCB1F8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCB1D8);
}

void sub_1CD511F64(uint64_t a1, void *a2, unint64_t a3)
{
  char v31 = (void *)(a1 + 112);
  uint64_t v4 = *(unsigned int *)(a1 + 152);
  if (*(_DWORD *)(a1 + 152))
  {
    uint64_t v7 = 0;
    __sz = (uint64_t *)(a1 + 16);
    do
    {
      if (a3)
      {
        unint64_t v8 = *(unint64_t **)(*(void *)(*(void *)(a1 + 120)
                                              + (((unint64_t)(*(void *)(a1 + 144) + v7) >> 6) & 0x3FFFFFFFFFFFFF8))
                                  + 8 * ((*(void *)(a1 + 144) + v7) & 0x1FF));
        unint64_t v9 = *v8;
        uint64_t v10 = a2;
        unint64_t v11 = a3;
        do
        {
          unint64_t v12 = v11 >> 1;
          uint64_t v13 = &v10[2 * (v11 >> 1)];
          unint64_t v15 = *v13;
          unsigned int v14 = v13 + 2;
          v11 += ~(v11 >> 1);
          if (v15 < v9) {
            uint64_t v10 = v14;
          }
          else {
            unint64_t v11 = v12;
          }
        }
        while (v11);
        unint64_t v16 = a3;
        int v17 = a2;
        do
        {
          unint64_t v18 = v16 >> 1;
          uint64_t v19 = &v17[2 * (v16 >> 1)];
          if (v9 >= *v19 && (*v19 < v9 || (v19[1] & 0x8000000000000000) == 0))
          {
            int v17 = v19 + 2;
            unint64_t v18 = v16 + ~v18;
          }
          unint64_t v16 = v18;
        }
        while (v18);
        while (v10 != v17)
        {
          if (*v10 == *v8)
          {
            uint64_t v20 = v10[1];
            unint64_t v21 = (void *)sub_1CB906F34(__sz, 16, 3);
            *unint64_t v21 = v20;
            v21[1] = v8;
            uint64_t v32 = v21;
            sub_1CD3F21B0(v31, &v32);
          }
          v10 += 2;
        }
      }
      ++v7;
    }
    while (v7 != v4);
  }
  unint64_t v22 = *(void *)(a1 + 144);
  uint64_t v23 = *(void *)(a1 + 120);
  uint64_t v24 = (char *)(v23 + 8 * (v22 >> 9));
  if (*(void *)(a1 + 128) == v23) {
    uint64_t v25 = 0;
  }
  else {
    uint64_t v25 = (char *)(*(void *)v24 + 8 * (*(void *)(a1 + 144) & 0x1FFLL));
  }
  if (v4)
  {
    uint64_t v26 = v4 + ((uint64_t)&v25[-*(void *)v24] >> 3);
    if (v26 < 1)
    {
      unint64_t v29 = 511 - v26;
      uint64_t v27 = &v24[-8 * (v29 >> 9)];
      unint64_t v28 = (char *)(*(void *)v27 + 8 * (~(_WORD)v29 & 0x1FF));
    }
    else
    {
      uint64_t v27 = &v24[8 * ((unint64_t)v26 >> 9)];
      unint64_t v28 = (char *)(*(void *)v27 + 8 * (v26 & 0x1FF));
    }
  }
  else
  {
    unint64_t v28 = v25;
    uint64_t v27 = (char *)(v23 + 8 * (v22 >> 9));
  }
  sub_1CC291440(v31, v24, v25, v27, v28);
}

void llvm::initializeDwarfEHPrepareLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB298, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2919A8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB298, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createDwarfEHPass()
{
}

llvm::Instruction *sub_1CD512234(llvm::Instruction *this, uint64_t **a2, uint64_t **a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, const char **a8, llvm::BasicBlock *a9)
{
  int v17 = (llvm::Type *)*a2[2];
  if (a7)
  {
    LODWORD(v18) = 0;
    uint64_t v19 = 48 * a7;
    uint64_t v20 = (void *)(a6 + 32);
    do
    {
      uint64_t v18 = v18 + ((*v20 - *(v20 - 1)) >> 3);
      v20 += 6;
      v19 -= 48;
    }
    while (v19);
    uint64_t v21 = 48 * a7;
    unint64_t v22 = (void *)(a6 + 32);
    do
    {
      LODWORD(v19) = v19 + ((*v22 - *(v22 - 1)) >> 3);
      v22 += 6;
      v21 -= 48;
    }
    while (v21);
  }
  else
  {
    uint64_t v18 = 0;
    LODWORD(v19) = 0;
  }
  uint64_t v23 = (uint64_t ***)llvm::Instruction::Instruction(this, v17, 56, (llvm::Instruction *)((char *)this + 32 * ~(a5 + v18)), (int)a5 + (int)v19 + 1, a9);
  *((void *)this + 8) = 0;
  llvm::CallInst::init(v23, a2, a3, a4, a5, a6, a7, a8);
  return this;
}

void llvm::initializeEarlyIfConverterPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB2A0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2931B0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB2A0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeEarlyIfPredicatorPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB2A8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC293260;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB2A8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD512428(uint64_t a1, void ***this)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  llvm::MachineDominatorTree::applySplitCriticalEdges(this);
  sub_1CD4BAC98((uint64_t)&v11, (uint64_t)this[165][6]);
  v8[0] = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t v10 = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t v4 = (char *)v7 + 8;
  unint64_t v5 = (char *)v7 + 8;
  uint64_t v6 = 8;
  v8[1] = (char *)v9 + 8;
  DWORD1(v9[0]) = 8;
  sub_1CD4BAA08(a1, (uint64_t)&v11, (uint64_t)&v4);
  if (v8[1] != (char *)v9 + 8) {
    free(v8[1]);
  }
  if (v5 != v4) {
    free(v5);
  }
  if (v13 != v14) {
    free(v13);
  }
  if (v12 != v11) {
    free(v12);
  }
}

void sub_1CD512554(uint64_t a1)
{
  sub_1CC296918(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD51258C(uint64_t a1)
{
  uint64_t v1 = *(void *)(****(void ****)(a1 + 16) + 72);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    size_t v3 = strlen(*(const char **)(a1 + 40));
  }
  else {
    size_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, size_t))(*(void *)v1 + 32);

  return v4(v1, v2, v3);
}

void sub_1CD512614(uint64_t a1)
{
  sub_1CC296918(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD51264C(uint64_t a1)
{
  uint64_t v1 = *(void *)(****(void ****)(a1 + 16) + 72);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    size_t v3 = strlen(*(const char **)(a1 + 40));
  }
  else {
    size_t v3 = 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, size_t))(*(void *)v1 + 40);

  return v4(v1, v2, v3);
}

void llvm::initializeEdgeBundlesPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB4F0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC297AA8;
    v4[1] = &v2;
    size_t v3 = v4;
    std::__call_once(&qword_1EBCCB4F0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::EdgeBundles::getAnalysisUsage(uint64_t this, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

llvm::raw_ostream *llvm::WriteGraph<llvm::EdgeBundles>(llvm::raw_ostream *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 248);
  sub_1CB8E509C(a1, "digraph {\n");
  uint64_t v5 = *(void *)(v4 + 328);
  uint64_t v25 = v4 + 320;
  if (v5 != v4 + 320)
  {
    uint64_t v24 = v2;
    do
    {
      int v6 = *(_DWORD *)(v5 + 24);
      uint64_t v7 = sub_1CB8E509C(a1, "\t\"");
      llvm::printMBBReference(v5, v30);
      if (!v31) {
        goto LABEL_40;
      }
      (*(void (**)(void *, llvm::raw_ostream *))(*v31 + 48))(v31, v7);
      unint64_t v8 = sub_1CB8E509C(v7, "\" [ shape=box ]\n");
      unint64_t v9 = (unsigned char *)*((void *)v8 + 4);
      if ((unint64_t)v9 >= *((void *)v8 + 3))
      {
        unint64_t v8 = llvm::raw_ostream::write(v8, 9);
      }
      else
      {
        *((void *)v8 + 4) = v9 + 1;
        unsigned char *v9 = 9;
      }
      unsigned int v10 = 2 * v6;
      unint64_t v11 = llvm::raw_ostream::operator<<(v8, *(unsigned int *)(*(void *)(v2 + 256) + 4 * v10));
      unint64_t v12 = sub_1CB8E509C(v11, " -> \"");
      llvm::printMBBReference(v5, v28);
      if (!v29
        || ((*(void (**)(void *, llvm::raw_ostream *))(*v29 + 48))(v29, v12),
            uint64_t v13 = sub_1CB8E509C(v12, "\"\n"),
            unsigned int v14 = sub_1CB8E509C(v13, "\t\""),
            llvm::printMBBReference(v5, v26),
            !v27))
      {
LABEL_40:
        sub_1CB920400();
      }
      (*(void (**)(void *, llvm::raw_ostream *))(*v27 + 48))(v27, v14);
      unint64_t v15 = sub_1CB8E509C(v14, "\" -> ");
      unint64_t v16 = llvm::raw_ostream::operator<<(v15, *(unsigned int *)(*(void *)(v2 + 256) + 4 * (v10 | 1)));
      int v17 = (unsigned char *)*((void *)v16 + 4);
      if ((unint64_t)v17 >= *((void *)v16 + 3))
      {
        llvm::raw_ostream::write(v16, 10);
      }
      else
      {
        *((void *)v16 + 4) = v17 + 1;
        unsigned char *v17 = 10;
      }
      if (v27 == v26)
      {
        (*(void (**)(void *))(v26[0] + 32))(v26);
      }
      else if (v27)
      {
        (*(void (**)(void))(*v27 + 40))();
      }
      if (v29 == v28)
      {
        (*(void (**)(void *))(v28[0] + 32))(v28);
      }
      else if (v29)
      {
        (*(void (**)(void))(*v29 + 40))();
      }
      if (v31 == v30)
      {
        (*(void (**)(void *))(v30[0] + 32))(v30);
      }
      else if (v31)
      {
        (*(void (**)(void))(*v31 + 40))();
      }
      uint64_t v18 = *(uint64_t **)(v5 + 88);
      uint64_t v19 = *(uint64_t **)(v5 + 96);
      while (v18 != v19)
      {
        uint64_t v20 = *v18;
        uint64_t v21 = sub_1CB8E509C(a1, "\t\"");
        llvm::printMBBReference(v5, v30);
        if (!v31) {
          goto LABEL_40;
        }
        (*(void (**)(void *, llvm::raw_ostream *))(*v31 + 48))(v31, v21);
        unint64_t v22 = sub_1CB8E509C(v21, "\" -> \"");
        llvm::printMBBReference(v20, v28);
        if (!v29) {
          goto LABEL_40;
        }
        (*(void (**)(void *, llvm::raw_ostream *))(*v29 + 48))(v29, v22);
        sub_1CB8E509C(v22, "\" [ color=lightgray ]\n");
        if (v29 == v28)
        {
          (*(void (**)(void *))(v28[0] + 32))(v28);
        }
        else if (v29)
        {
          (*(void (**)(void))(*v29 + 40))();
        }
        if (v31 == v30)
        {
          (*(void (**)(void *))(v30[0] + 32))(v30);
        }
        else if (v31)
        {
          (*(void (**)(void))(*v31 + 40))();
        }
        ++v18;
      }
      uint64_t v5 = *(void *)(v5 + 8);
      uint64_t v2 = v24;
    }
    while (v5 != v25);
  }
  sub_1CB8E509C(a1, "}\n");
  return a1;
}

void sub_1CD512C5C(uint64_t a1, llvm::Twine *this)
{
  char v6 = 0;
  LOBYTE(__p) = 0;
  sub_1CC297F0C((uint64_t)v7, a1, this, (uint64_t)&__p);
  if (v6 < 0) {
    operator delete(__p);
  }
  char v2 = v8;
  if (v8 >= 0) {
    std::string::size_type v3 = v8 & 0x7F;
  }
  else {
    std::string::size_type v3 = (std::string::size_type)v7[1];
  }
  if (v3)
  {
    if (v8 >= 0) {
      uint64_t v4 = v7;
    }
    else {
      uint64_t v4 = (void **)v7[0];
    }
    llvm::DisplayGraph((std::string::value_type *)v4, v3, 0, 0);
    char v2 = v8;
  }
  if (v2 < 0) {
    operator delete(v7[0]);
  }
}

void sub_1CD512CF0(uint64_t a1)
{
  sub_1CD512DC4(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::EdgeBundles>()
{
}

void sub_1CD512DC4(uint64_t a1)
{
  *(void *)a1 = &unk_1F260B598;
  sub_1CD512E30((char **)(a1 + 312));
  char v2 = *(void **)(a1 + 256);
  if (v2 != (void *)(a1 + 272)) {
    free(v2);
  }

  sub_1CBA0E6AC((llvm::Pass *)a1);
}

char **sub_1CD512E30(char **a1)
{
  char v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 48 * v3;
    do
    {
      uint64_t v5 = *(char **)&v2[v4 - 48];
      if (&v2[v4 - 32] != v5)
      {
        uint64_t v7 = v4;
        char v8 = v2;
        free(v5);
        uint64_t v4 = v7;
        char v2 = v8;
      }
      v4 -= 48;
    }
    while (v4);
    char v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD512EB4()
{
}

void sub_1CD512F24(uint64_t a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)a1;
    uint64_t v4 = 48 * v2;
    do
    {
      *a2 = a2 + 2;
      a2[1] = 0x800000000;
      if (*(_DWORD *)(v3 + 8)) {
        sub_1CC0778D4((uint64_t)a2, v3);
      }
      v3 += 48;
      a2 += 6;
      v4 -= 48;
    }
    while (v4);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5)
    {
      uint64_t v6 = *(void *)a1;
      uint64_t v7 = 48 * v5;
      do
      {
        char v8 = *(void **)(v6 + v7 - 48);
        if ((void *)(v6 + v7 - 32) != v8) {
          free(v8);
        }
        v7 -= 48;
      }
      while (v7);
    }
  }
}

void llvm::initializeExpandMemCmpPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB510, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC29A854;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB510, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createExpandMemCmpPass(llvm *this)
{
}

double sub_1CD513098(uint64_t a1, uint64_t *a2, char *a3)
{
  if (*(unsigned char *)(a1 + 440)) {
    a1 = sub_1CC2930C0(a1);
  }
  uint64_t v5 = *a2;
  char v6 = *a3;
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x1000000000;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = v5;
  *(void *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 304) = v6;
  *(void *)(a1 + 312) = a1 + 344;
  *(void *)(a1 + 320) = a1 + 344;
  *(void *)&double result = 8;
  *(void *)(a1 + 328) = 8;
  *(_DWORD *)(a1 + 336) = 0;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 408) = 0;
  *(_WORD *)(a1 + 432) = 0;
  *(unsigned char *)(a1 + 440) = 1;
  return result;
}

llvm::Instruction *sub_1CD51311C(uint64_t a1, llvm::LLVMContext *a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  Int64Ty = (llvm::ConstantInt *)llvm::Type::getInt64Ty(*(llvm::Type **)(a1 + 64), a2);
  unint64_t v16 = llvm::ConstantInt::get(Int64Ty, a4, 0);
  double result = (llvm::Instruction *)(*(uint64_t (**)(void, llvm::LLVMContext *, uint64_t *, void **, uint64_t, void))(**(void **)(a1 + 72) + 48))(*(void *)(a1 + 72), a2, a3, &v16, 1, 0);
  if (!result)
  {
    __int16 v15 = 257;
    unint64_t v12 = operator new(0x90uLL);
    v12[21] = v12[21] & 0x38000000 | 2;
    uint64_t v13 = (llvm::Instruction *)(v12 + 16);
    *(void *)unint64_t v12 = 0;
    *((void *)v12 + 1) = 0;
    *((void *)v12 + 2) = 0;
    *((void *)v12 + 3) = v12 + 16;
    *((void *)v12 + 4) = 0;
    *((void *)v12 + 5) = 0;
    *((void *)v12 + 6) = 0;
    *((void *)v12 + 7) = v12 + 16;
    sub_1CB845960((uint64_t)(v12 + 16), (uint64_t)a2, a3, (uint64_t *)&v16, 1, 2, &v14, 0);
    return sub_1CB844E0C((uint64_t *)a1, v13, a5);
  }
  return result;
}

uint64_t sub_1CD513224(uint64_t a1, char *a2, _WORD *a3, _OWORD *a4)
{
  uint64_t v8 = sub_1CB883A14(a1, 0, 0);
  *(_DWORD *)(v8 + 128) = 0;
  *(void *)(v8 + 136) = &unk_1F25EA1B0;
  *(void *)(v8 + 144) = 0;
  *(void *)uint64_t v8 = &unk_1F2643F00;
  *(void *)(v8 + 152) = &unk_1F2643DB0;
  *(void *)(v8 + 160) = &unk_1F25EA168;
  *(void *)(v8 + 184) = v8 + 160;
  size_t v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  *(_WORD *)(a1 + 10) = (32 * (*a3 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  *(_OWORD *)(a1 + 32) = *a4;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1CD51332C(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCCB698, 0, 0);
  dword_1EBCCB718 = 0;
  qword_1EBCCB720 = (uint64_t)&unk_1F25EA1B0;
  unk_1EBCCB728 = 0;
  qword_1EBCCB698 = (uint64_t)&unk_1F2643F00;
  qword_1EBCCB730 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCCB738 = (uint64_t)&unk_1F25EA168;
  qword_1EBCCB750 = (uint64_t)&qword_1EBCCB738;
  llvm::cl::Option::setArgStr(v4, "max-loads-per-memcmp-opt-size", 0x1DuLL);
  word_1EBCCB6A2 = (32 * (*a1 & 3)) | word_1EBCCB6A2 & 0xFF9F;
  xmmword_1EBCCB6B8 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCB698);
}

void llvm::initializeExpandPostRAPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB758, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC29F294;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB758, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createExpandReductionsPass(llvm *this)
{
}

void llvm::createExpandVectorPredicationPass(llvm *this)
{
}

void sub_1CD513524(const char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCB780, 0, 0);
  qword_1EBCCB800 = 0;
  qword_1EBCCB808 = 0;
  qword_1EBCCB828 = 0;
  unk_1EBCCB830 = 0;
  byte_1EBCCB838 = 0;
  qword_1EBCCB820 = 0;
  unk_1EBCCB810 = 0;
  unk_1EBCCB818 = &unk_1F2643C20;
  qword_1EBCCB780 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCCB840 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCCB848 = (uint64_t)&unk_1F25F6428;
  qword_1EBCCB860 = (uint64_t)&qword_1EBCCB848;
  sub_1CD513620(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCB780);
}

__n128 sub_1CD513620(const char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCB780, "expandvp-override-evl-transform", 0x1FuLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCCB780);
  word_1EBCCB78A = (32 * (*a2 & 3)) | word_1EBCCB78A & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCCB7A0 = (__int128)*a3;
  return result;
}

void sub_1CD513698(const char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCB868, 0, 0);
  qword_1EBCCB8E8 = 0;
  qword_1EBCCB8F0 = 0;
  qword_1EBCCB910 = 0;
  unk_1EBCCB918 = 0;
  byte_1EBCCB920 = 0;
  qword_1EBCCB908 = 0;
  unk_1EBCCB8F8 = 0;
  unk_1EBCCB900 = &unk_1F2643C20;
  qword_1EBCCB868 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCCB928 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCCB930 = (uint64_t)&unk_1F25F6428;
  qword_1EBCCB948 = (uint64_t)&qword_1EBCCB930;
  sub_1CD513794(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCB868);
}

__n128 sub_1CD513794(const char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCB868, "expandvp-override-mask-transform", 0x20uLL);
  sub_1CBAD7D28(a1, (uint64_t)&qword_1EBCCB868);
  word_1EBCCB872 = (32 * (*a2 & 3)) | word_1EBCCB872 & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCCB888 = (__int128)*a3;
  return result;
}

void llvm::initializeFEntryInserterPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB950, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2A2DF8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB950, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeFinalizeISelPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB958, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2A357C;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB958, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeFixupStatepointCallerSavedPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCB960, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2A3990;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCB960, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t **sub_1CD513968(uint64_t **result, int *a2)
{
  uint64_t v3 = result;
  if (result[8])
  {
    uint64_t v8 = result + 6;
  }
  else
  {
    uint64_t v4 = *((unsigned int *)result + 2);
    int v5 = *a2;
    if (!v4)
    {
LABEL_7:
      if (v4 >= *((_DWORD *)result + 3)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)*result + v4) = v5;
      ++*((_DWORD *)result + 2);
      return result;
    }
    uint64_t v6 = 4 * v4;
    uint64_t v7 = *result;
    while (*(_DWORD *)v7 != v5)
    {
      uint64_t v7 = (uint64_t *)((char *)v7 + 4);
      v6 -= 4;
      if (!v6) {
        goto LABEL_6;
      }
    }
    if (v6) {
      return result;
    }
LABEL_6:
    if (v4 <= 7) {
      goto LABEL_7;
    }
    do
    {
      size_t v9 = (int *)*v3 + v4 - 1;
      sub_1CD41B018(v3 + 6, v9, v9);
      LODWORD(v4) = *((_DWORD *)v3 + 2) - 1;
      *((_DWORD *)v3 + 2) = v4;
    }
    while (v4);
    uint64_t v8 = v3 + 6;
  }

  return sub_1CD41B018(v8, a2, a2);
}

uint64_t sub_1CD513A78(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    uint64_t v6 = (void *)(a1 + 88 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      unsigned int v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          unsigned int v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (void *)(a1 + 88 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD513B14(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD513A78(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD513B90(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    _OWORD v5[2] = 0x800000000;
  }
  return v5;
}

void *sub_1CD513B90(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD513C44(a1, v6);
  uint64_t v8 = 0;
  sub_1CD513A78(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD513C44(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(88 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD513D1C(a1, v4, v4 + 88 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 88 * v10;
    do
    {
      void *result = -4096;
      result += 11;
      v11 -= 88;
    }
    while (v11);
  }
  return result;
}

void sub_1CD513D1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 88 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 11;
      v8 -= 88;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CD513A78(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        unsigned int v10 = v13;
        *unsigned int v13 = *(void *)v4;
        void v10[2] = 0x800000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD513E18(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        BOOL v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD513E18(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = a2 + 16;
    uint64_t v4 = *(_DWORD **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      int v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9)
        {
          BOOL v12 = &v4[2 * v9];
          unsigned int v13 = *(_DWORD **)a1;
          do
          {
            *unsigned int v13 = *v4;
            v13[1] = v4[1];
            v4 += 2;
            v13 += 2;
          }
          while (v4 != v12);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10)
        {
          unsigned int v14 = &v4[2 * v10];
          __int16 v15 = *(_DWORD **)a1;
          do
          {
            *__int16 v15 = *v4;
            v15[1] = v4[1];
            v4 += 2;
            v15 += 2;
          }
          while (v4 != v14);
        }
        else
        {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy((void *)(*(void *)a1 + 8 * v10), (const void *)(*(void *)a2 + 8 * v10), *(void *)a2 + 8 * v11 - (*(void *)a2 + 8 * v10));
        }
      }
      *(_DWORD *)(a1 + 8) = v9;
    }
    else
    {
      unsigned int v6 = *(_DWORD **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(_DWORD **)a2;
      }
      *(void *)a1 = v4;
      int v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    _DWORD *v7 = 0;
  }
  return a1;
}

unint64_t sub_1CD513F60(uint64_t a1, unsigned int *a2)
{
  if (*(void *)(a1 + 64))
  {
    sub_1CB84AEB8((uint64_t **)(a1 + 48), a2, a2);
    return ((unint64_t)v4 << 32) | 1;
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    unsigned int v7 = *a2;
    if (v6)
    {
      uint64_t v8 = 4 * v6;
      uint64_t v9 = *(_DWORD **)a1;
      while (*v9 != v7)
      {
        ++v9;
        v8 -= 4;
        if (!v8) {
          goto LABEL_7;
        }
      }
      if (v8) {
        return 1;
      }
LABEL_7:
      if (v6 <= 7) {
        goto LABEL_8;
      }
      do
      {
        uint64_t v10 = (unsigned int *)(*(void *)a1 + 4 * v6 - 4);
        sub_1CB84AEB8((uint64_t **)(a1 + 48), v10, v10);
        LODWORD(v6) = *(_DWORD *)(a1 + 8) - 1;
        *(_DWORD *)(a1 + 8) = v6;
      }
      while (v6);
      sub_1CB84AEB8((uint64_t **)(a1 + 48), a2, a2);
    }
    else
    {
LABEL_8:
      if (v6 >= *(_DWORD *)(a1 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a1 + 4 * v6) = v7;
      ++*(_DWORD *)(a1 + 8);
    }
    return 0x100000001;
  }
}

_DWORD *sub_1CD514074(uint64_t a1, int *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD514130(a1, a2, v9);
    *(void *)uint64_t v6 = *a2;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 8 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 8 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD514130(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD5142A8(a1, 2 * v6);
    int v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v10 = (37 * *a2) & v9;
    a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
    int v11 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          BOOL v12 = a3;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
        int v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      int v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD5142A8(a1, v6);
    int v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v17 = (37 * *a2) & v16;
    a3 = (_DWORD *)(*(void *)a1 + 8 * v17);
    int v18 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          BOOL v12 = a3;
        }
        unsigned int v21 = v17 + v19++;
        unsigned int v17 = v21 & v16;
        a3 = (_DWORD *)(*(void *)a1 + 8 * v17);
        int v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD5142A8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = operator new(8 * v8, (std::align_val_t)4uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD514374(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 8 * v10;
    do
    {
      _DWORD *result = -1;
      result += 2;
      v11 -= 8;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD514374(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(_DWORD **)result;
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 8 * v4;
    unint64_t v6 = *(_DWORD **)result;
    do
    {
      _DWORD *v6 = -1;
      v6 += 2;
      v5 -= 8;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    int v7 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      int v8 = *(_DWORD *)(result + 16) - 1;
      unsigned int v9 = v8 & (37 * v7);
      uint64_t v10 = &v3[2 * v9];
      int v11 = *v10;
      if (v7 != *v10)
      {
        BOOL v12 = 0;
        int v13 = 1;
        while (v11 != -1)
        {
          if (v12) {
            BOOL v14 = 0;
          }
          else {
            BOOL v14 = v11 == -2;
          }
          if (v14) {
            BOOL v12 = v10;
          }
          unsigned int v15 = v9 + v13++;
          unsigned int v9 = v15 & v8;
          uint64_t v10 = &v3[2 * (v15 & v8)];
          int v11 = *v10;
          if (v7 == *v10) {
            goto LABEL_7;
          }
        }
        if (v12) {
          uint64_t v10 = v12;
        }
      }
LABEL_7:
      *uint64_t v10 = v7;
      v10[1] = a2[1];
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

BOOL sub_1CD514448(uint64_t a1, unsigned int a2, int a3)
{
  if (*(void *)(a1 + 96))
  {
    uint64_t v3 = *(uint64_t **)(a1 + 88);
    if (v3)
    {
      BOOL result = 1;
      do
      {
        unsigned int v5 = *((_DWORD *)v3 + 7);
        if (v5 <= a2)
        {
          if (v5 >= a2)
          {
            int v6 = *((_DWORD *)v3 + 8);
            if (v6 > a3) {
              goto LABEL_5;
            }
            if (v6 >= a3) {
              return result;
            }
          }
          ++v3;
        }
LABEL_5:
        uint64_t v3 = (uint64_t *)*v3;
      }
      while (v3);
    }
    return 0;
  }
  else
  {
    int v7 = *(_DWORD **)a1;
    uint64_t v8 = *(unsigned int *)(a1 + 8);
    uint64_t v9 = *(void *)a1 + 8 * v8;
    if (v8)
    {
      uint64_t v10 = 8 * v8;
      while (*v7 != a2 || v7[1] != a3)
      {
        v7 += 2;
        v10 -= 8;
        if (!v10) {
          goto LABEL_20;
        }
      }
    }
    else
    {
LABEL_20:
      int v7 = (_DWORD *)v9;
    }
    return v7 != (_DWORD *)v9;
  }
}

uint64_t sub_1CD5144DC(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v6 = (void *)(a1 + 112 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          uint64_t v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        int v6 = (void *)(a1 + 112 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        int v6 = v10;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD514578(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  char v4 = sub_1CD5144DC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  unsigned int v5 = v8;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD514618(a1, a2, v8);
    uint64_t v7 = *a2;
    *(_OWORD *)(v5 + 9) = 0u;
    *(_OWORD *)(v5 + 7) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 3) = 0u;
    void *v5 = v7;
    v5[1] = v5 + 3;
    _OWORD v5[2] = 0x800000000;
    v5[13] = 0;
    v5[12] = 0;
    v5[11] = v5 + 12;
  }
  return v5;
}

void *sub_1CD514618(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5146CC(a1, v6);
  uint64_t v8 = 0;
  sub_1CD5144DC(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5146CC(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = operator new(112 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5147A4(a1, v4, v4 + 112 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 112 * v10;
    do
    {
      void *result = -4096;
      result += 14;
      v11 -= 112;
    }
    while (v11);
  }
  return result;
}

void sub_1CD5147A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 112 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 14;
      v8 -= 112;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *(void *)a2;
    if ((*(void *)a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      BOOL v12 = 0;
      sub_1CD5144DC(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      uint64_t v10 = v12;
      *BOOL v12 = *(void *)a2;
      sub_1CD51487C(v10 + 1, a2 + 8);
      ++*(_DWORD *)(a1 + 8);
      sub_1CD40B1BC(*(void **)(a2 + 96));
      uint64_t v11 = *(void **)(a2 + 8);
      if ((void *)(a2 + 24) != v11) {
        free(v11);
      }
    }
    a2 += 112;
  }
}

void *sub_1CD51487C(void *result, uint64_t a2)
{
  void *result = result + 2;
  result[1] = 0x800000000;
  if (*(_DWORD *)(a2 + 8)) {
    BOOL result = (void *)sub_1CD513E18((uint64_t)result, a2);
  }
  result[10] = *(void *)(a2 + 80);
  unsigned int v3 = (void *)(a2 + 88);
  uint64_t v4 = *(void *)(a2 + 88);
  result[11] = v4;
  unint64_t v5 = result + 11;
  uint64_t v6 = *(void *)(a2 + 96);
  result[12] = v6;
  if (v6)
  {
    *(void *)(v4 + 16) = v5;
    *(void *)(a2 + 80) = v3;
    *unsigned int v3 = 0;
    *(void *)(a2 + 96) = 0;
  }
  else
  {
    result[10] = v5;
  }
  return result;
}

uint64_t sub_1CD5148FC(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(result + 96))
  {
    uint64_t v9 = result + 80;
    unsigned int v10 = *(_DWORD *)a2;
    int v11 = *(_DWORD *)(a2 + 4);
  }
  else
  {
    uint64_t v4 = *(void *)result;
    uint64_t v5 = *(unsigned int *)(result + 8);
    if (!v5)
    {
LABEL_10:
      if (v5 >= *(_DWORD *)(result + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(v4 + 8 * v5) = *(void *)a2;
      ++*(_DWORD *)(result + 8);
      return result;
    }
    uint64_t v6 = 8 * v5;
    int v7 = (_DWORD *)(v4 + 4);
    while (*(v7 - 1) != *(_DWORD *)a2 || *v7 != *(_DWORD *)(a2 + 4))
    {
      v7 += 2;
      v6 -= 8;
      if (!v6) {
        goto LABEL_9;
      }
    }
    if (v6) {
      return result;
    }
LABEL_9:
    if (v5 <= 7) {
      goto LABEL_10;
    }
    do
    {
      sub_1CD514A14(v3 + 80, *(_DWORD *)(*(void *)v3 + 8 * v5 - 8), *(_DWORD *)(*(void *)v3 + 8 * v5 - 4), (uint64_t *)(*(void *)v3 + 8 * v5 - 8));
      LODWORD(v5) = *(_DWORD *)(v3 + 8) - 1;
      *(_DWORD *)(v3 + 8) = v5;
    }
    while (v5);
    unsigned int v10 = *(_DWORD *)a2;
    int v11 = *(_DWORD *)(a2 + 4);
    uint64_t v9 = v3 + 80;
  }

  return sub_1CD514A14(v9, v10, v11, (uint64_t *)a2);
}

uint64_t sub_1CD514A14(uint64_t a1, unsigned int a2, int a3, uint64_t *a4)
{
  uint64_t v6 = sub_1CD514AC0(a1, &v13, a2, a3);
  if (*v6) {
    return 0;
  }
  uint64_t v8 = v6;
  uint64_t v9 = (uint64_t *)operator new(0x28uLL);
  *(uint64_t *)((char *)v9 + 28) = *a4;
  uint64_t v10 = v13;
  uint64_t *v9 = 0;
  v9[1] = 0;
  uint64_t v9[2] = v10;
  uint64_t *v8 = (uint64_t)v9;
  uint64_t v11 = **(void **)a1;
  if (v11)
  {
    *(void *)a1 = v11;
    BOOL v12 = (uint64_t *)*v8;
  }
  else
  {
    BOOL v12 = v9;
  }
  sub_1CB8358B8(*(uint64_t **)(a1 + 8), v12);
  ++*(void *)(a1 + 16);
  return 1;
}

uint64_t *sub_1CD514AC0(uint64_t a1, void *a2, unsigned int a3, int a4)
{
  uint64_t v6 = *(uint64_t **)(a1 + 8);
  BOOL result = (uint64_t *)(a1 + 8);
  uint64_t v5 = v6;
  if (v6)
  {
    while (1)
    {
      while (1)
      {
        int v7 = v5;
        unsigned int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a3) {
          break;
        }
LABEL_3:
        uint64_t v5 = (uint64_t *)*v7;
        BOOL result = v7;
        if (!*v7) {
          goto LABEL_12;
        }
      }
      if (v8 >= a3)
      {
        int v9 = *((_DWORD *)v7 + 8);
        if (v9 > a4) {
          goto LABEL_3;
        }
        if (v9 >= a4) {
          goto LABEL_12;
        }
      }
      BOOL result = v7 + 1;
      uint64_t v5 = (uint64_t *)v7[1];
      if (!v5) {
        goto LABEL_12;
      }
    }
  }
  int v7 = result;
LABEL_12:
  *a2 = v7;
  return result;
}

void sub_1CD514B1C(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v3 = 112 * a2;
    do
    {
      if ((*(void *)a1 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        sub_1CD40B1BC(*(void **)(a1 + 96));
        uint64_t v4 = *(void **)(a1 + 8);
        if ((void *)(a1 + 24) != v4) {
          free(v4);
        }
      }
      a1 += 112;
      v3 -= 112;
    }
    while (v3);
  }
}

void sub_1CD514B8C(_WORD *a1, char **a2, __n128 *a3, _WORD *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCB968, 0, 0);
  byte_1EBCCB9E8 = 0;
  qword_1EBCCB9F0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCCB9F8 = 0;
  qword_1EBCCB968 = (uint64_t)&unk_1F26440A0;
  qword_1EBCCBA00 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCCBA08 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCCBA20 = (uint64_t)&qword_1EBCCBA08;
  sub_1CD514C8C(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCB968);
}

__n128 sub_1CD514C8C(_WORD *a1, char **a2, __n128 *a3, _WORD *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCB968, "fixup-scs-extend-slot-size", 0x1AuLL);
  __int16 v8 = word_1EBCCB972;
  word_1EBCCB972 = word_1EBCCB972 & 0xFF9F | (32 * (*a1 & 3));
  int v9 = *a2;
  byte_1EBCCB9E8 = **a2;
  byte_1EBCCB9F9 = 1;
  byte_1EBCCB9F8 = *v9;
  __n128 result = *a3;
  xmmword_1EBCCB988 = (__int128)*a3;
  word_1EBCCB972 = v8 & 0xFF9F | (32 * (*a4 & 3));
  return result;
}

void sub_1CD514D28(_WORD *a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCCBBA8, 0, 0);
  dword_1EBCCBC28 = 0;
  qword_1EBCCBC30 = (uint64_t)&unk_1F25EA1B0;
  unk_1EBCCBC38 = 0;
  qword_1EBCCBBA8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCCBC40 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCCBC48 = (uint64_t)&unk_1F25EA168;
  qword_1EBCCBC60 = (uint64_t)&qword_1EBCCBC48;
  llvm::cl::Option::setArgStr(v4, "fixup-max-csr-statepoints", 0x19uLL);
  word_1EBCCBBB2 = (32 * (*a1 & 3)) | word_1EBCCBBB2 & 0xFF9F;
  xmmword_1EBCCBBC8 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCBBA8);
}

void llvm::initializeFuncletLayoutPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCBC68, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2AA3C8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCBC68, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeGCModuleInfoPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCBC70, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2AA9EC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCBC70, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::GCFunctionInfo::~GCFunctionInfo(llvm::GCFunctionInfo *this)
{
  uint64_t v3 = (void **)((char *)this + 48);
  sub_1CC2AB2E8(&v3);
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
}

llvm::GCModuleInfo *llvm::GCModuleInfo::GCModuleInfo(llvm::GCModuleInfo *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::GCModuleInfo::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F260BD78;
  *((void *)this + 4) = (char *)this + 48;
  *((void *)this + 5) = 0x100000000;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0x1000000000;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 116) = 0u;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCBC70, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC2AA9EC;
    v5[1] = &PassRegistry;
    uint64_t v4 = v5;
    std::__call_once(&qword_1EBCCBC70, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::GCModuleInfo::getFunctionInfo(llvm::GCModuleInfo *this, llvm::LLVMContext ***a2)
{
  uint64_t v11 = a2;
  BOOL v12 = 0;
  if (!sub_1CD3C8538((uint64_t *)this + 14, &v11, &v12)
    || v12 == (llvm::GCFunctionInfo *)(*((void *)this + 14) + 16 * *((unsigned int *)this + 32)))
  {
    GC = llvm::Function::getGC(a2);
    char v6 = *((unsigned char *)GC + 23);
    BOOL v7 = v6 < 0;
    if (v6 >= 0) {
      __int16 v8 = (unsigned __int8 *)GC;
    }
    else {
      __int16 v8 = (unsigned __int8 *)*GC;
    }
    size_t v9 = v6 & 0x7F;
    if (v7) {
      size_t v10 = GC[1];
    }
    else {
      size_t v10 = v9;
    }
    llvm::GCModuleInfo::getGCStrategy((uint64_t)this, v8, v10);
    operator new();
  }
  return *((void *)v12 + 1);
}

uint64_t llvm::GCModuleInfo::getGCStrategy(uint64_t a1, unsigned __int8 *a2, size_t a3)
{
  uint64_t v6 = a1 + 56;
  int Key = llvm::StringMapImpl::FindKey((uint64_t *)(a1 + 56), a2, a3);
  if (Key != -1 && Key != (unint64_t)*(unsigned int *)(a1 + 64)) {
    return *(void *)(*(void *)(*(void *)(a1 + 56) + 8 * Key) + 8);
  }
  llvm::getGCStrategy((const std::string::value_type *)a2, a3);
  std::string::__init(&v14, (const std::string::value_type *)a2, a3);
  size_t v10 = v15;
  size_t v11 = v15 + 8;
  if (*(char *)(v15 + 31) < 0)
  {
    operator delete(*(void **)v11);
    size_t v10 = v15;
  }
  long long v12 = *(_OWORD *)&v14.__r_.__value_.__l.__data_;
  *(void *)(v11 + 16) = *((void *)&v14.__r_.__value_.__l + 2);
  *(_OWORD *)size_t v11 = v12;
  (*sub_1CD3F4C18(v6, a2, a3))[1] = v10;
  sub_1CD515410(a1 + 32, (uint64_t *)&v15);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8 * *(unsigned int *)(a1 + 40) - 8);
  uint64_t v13 = v15;
  size_t v15 = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  return v8;
}

uint64_t llvm::GCModuleInfo::clear(llvm::GCModuleInfo *this)
{
  uint64_t v2 = (char *)this + 88;
  sub_1CC2AB510((llvm::GCModuleInfo *)((char *)this + 88), *((void **)this + 11));
  uint64_t result = sub_1CD515354((uint64_t)(v2 + 24));
  uint64_t v4 = *((unsigned int *)v2 - 12);
  if (v4)
  {
    uint64_t v5 = *((void *)v2 - 7);
    uint64_t v6 = 8 * v4;
    uint64_t v7 = v5 - 8;
    do
    {
      uint64_t result = *(void *)(v7 + v6);
      *(void *)(v7 + v6) = 0;
      if (result) {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
      v6 -= 8;
    }
    while (v6);
  }
  *((_DWORD *)this + 10) = 0;
  return result;
}

uint64_t sub_1CD515354(uint64_t result)
{
  if (*(void *)(result + 8))
  {
    uint64_t v1 = *(unsigned int *)(result + 16);
    if (v1 > 4 * *(_DWORD *)(result + 8) && v1 >= 0x41)
    {
      return sub_1CD5156F4(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void **)result;
        uint64_t v3 = 16 * v1;
        do
        {
          *uint64_t v2 = -4096;
          v2 += 2;
          v3 -= 16;
        }
        while (v3);
      }
      *(void *)(result + 8) = 0;
    }
  }
  return result;
}

void llvm::createGCInfoPrinter(llvm *this, llvm::raw_ostream *a2)
{
}

uint64_t sub_1CD515410(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *(unsigned int *)(result + 8);
  unint64_t v3 = *(void *)result;
  if (v2 >= *(_DWORD *)(result + 12))
  {
    unint64_t v6 = v3 + 8 * v2;
    if (v3 > (unint64_t)a2 || v6 <= (unint64_t)a2) {
      sub_1CD5157A4();
    }
    sub_1CD5157A4();
  }
  uint64_t v4 = *(unsigned int *)(result + 8);
  uint64_t v5 = *a2;
  *a2 = 0;
  *(void *)(v3 + 8 * v4) = v5;
  *(_DWORD *)(result + 8) = v4 + 1;
  return result;
}

void sub_1CD51549C(uint64_t a1)
{
}

void sub_1CD5154AC()
{
  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::GCModuleInfo>()
{
}

void *sub_1CD515510(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD515570((uint64_t)a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD515570(uint64_t a1, void *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD515620(a1, v6);
  uint64_t v8 = 0;
  sub_1CD3C8538((uint64_t *)a1, a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD515620(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD475EA0(a1, v4, (void *)v4 + 2 * v3);
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5156F4(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  int v2 = *(_DWORD *)(result + 8);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 != v1) {
    llvm::deallocate_buffer(*(llvm **)result, (void *)(16 * v1));
  }
  *(void *)(result + 8) = 0;
  if (v1)
  {
    unint64_t v5 = *(llvm **)result;
    uint64_t v6 = 16 * v1;
    do
    {
      *(void *)unint64_t v5 = -4096;
      unint64_t v5 = (llvm *)((char *)v5 + 16);
      v6 -= 16;
    }
    while (v6);
  }
  return result;
}

_DWORD *sub_1CD515780()
{
  return sub_1CB837D60(v0, v1);
}

void sub_1CD5157A4()
{
}

void sub_1CD515874(uint64_t a1)
{
  *(void *)a1 = &unk_1F260BD78;
  llvm::deallocate_buffer(*(llvm **)(a1 + 112), (void *)(16 * *(unsigned int *)(a1 + 128)));
}

void sub_1CD5158B8()
{
  int v1 = v0[11];
  if (v1)
  {
    sub_1CC2AB510((llvm::GCFunctionInfo *)(v0 + 11), v1);
    operator delete(v0[11]);
  }
  sub_1CD515908((uint64_t)(v0 + 7));
  sub_1CD515988(v0 + 4);
  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)v0);
}

uint64_t sub_1CD515908(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12))
  {
    uint64_t v3 = *(unsigned int *)(a1 + 8);
    if (v3)
    {
      uint64_t v4 = 0;
      do
      {
        unint64_t v5 = *(llvm **)(*(void *)a1 + v4);
        if (v5 != (llvm *)-8 && v5 != 0) {
          llvm::deallocate_buffer(v5, (void *)(*(void *)v5 + 17));
        }
        v4 += 8;
      }
      while (8 * v3 != v4);
    }
  }
  free(*(void **)a1);
  return a1;
}

void **sub_1CD515988(void **result)
{
  int v1 = (void **)*result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    int v7 = result;
    uint64_t v3 = 8 * v2;
    uint64_t v4 = (char *)(v1 - 1);
    do
    {
      uint64_t v5 = *(void *)&v4[v3];
      *(void *)&v4[v3] = 0;
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      }
      v3 -= 8;
    }
    while (v3);
    uint64_t result = v7;
    int v1 = (void **)*v7;
  }
  if (v1 != result + 2)
  {
    uint64_t v6 = result;
    free(v1);
    return v6;
  }
  return result;
}

uint64_t llvm::Registry<llvm::GCMetadataPrinter>::begin()
{
  return llvm::Registry<llvm::GCMetadataPrinter>::Head;
}

void llvm::initializeLowerIntrinsicsPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCBC78, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2AB614;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCBC78, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeGCMachineCodeAnalysisPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCBC80, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2AB7A0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCBC80, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD515B20(uint64_t *a1, uint64_t a2, unsigned __int8 *a3)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_1CC2AC904(a1, a2, a3);
  }
  else
  {
    sub_1CC2AC9F0((void *)a1[1], a2, a3);
    uint64_t result = v4 + 16;
  }
  a1[1] = result;
  return result;
}

uint64_t *sub_1CD515B68(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = (unsigned __int8 **)*result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    int v7 = (unsigned __int8 **)(v4 - 8);
    uint64_t v8 = v6 - 8;
    do
    {
      *(_OWORD *)(v8 - 8) = *(_OWORD *)(v7 - 1);
      if (*v7)
      {
        uint64_t result = (uint64_t *)llvm::MetadataTracking::retrack((uint64_t)v7, *v7, v8);
        void *v7 = 0;
      }
      size_t v9 = v7 - 1;
      v7 -= 2;
      v8 -= 16;
    }
    while (v9 != v5);
    uint64_t v6 = v8 + 8;
  }
  a2[1] = v6;
  uint64_t v10 = *v3;
  *uint64_t v3 = v6;
  a2[1] = v10;
  uint64_t v11 = v3[1];
  v3[1] = a2[2];
  a2[2] = v11;
  uint64_t v12 = v3[2];
  v3[2] = a2[3];
  a2[3] = v12;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1CD515C24(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = v2 - 16;
    *(void *)(a1 + 16) = v2 - 16;
    int v7 = *(unsigned __int8 **)(v2 - 8);
    uint64_t v5 = v2 - 8;
    uint64_t v6 = v7;
    if (v7)
    {
      llvm::MetadataTracking::untrack(v5, v6);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      uint64_t v2 = v4;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void llvm::initializeHardwareLoopsPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCC120, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2B41BC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCC120, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createHardwareLoopsPass(llvm *this)
{
}

void sub_1CD515D38()
{
}

void *sub_1CD515D4C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F260C198;
  result[1] = v3;
  return result;
}

void llvm::initializeIfConverterPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCC5B0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2B7514;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCC5B0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD515E0C(uint64_t *a1, _WORD *a2)
{
  uint64_t v2 = (unsigned __int16)*a2;
  uint64_t v3 = a1[5];
  unsigned int v4 = *(unsigned __int8 *)(v3 + v2);
  uint64_t v5 = a1[1];
  if (v4 < v5)
  {
    uint64_t v6 = *a1;
    while (1)
    {
      unsigned int v7 = v4;
      if (*(unsigned __int16 *)(v6 + 2 * v4) == v2) {
        break;
      }
      v4 += 256;
      if (v7 + 256 >= v5) {
        goto LABEL_5;
      }
    }
    if (v5 != v4) {
      return v6 + 2 * v4;
    }
  }
LABEL_5:
  *(unsigned char *)(v3 + v2) = v5;
  uint64_t v8 = a1[1];
  if (v8 + 1 > (unint64_t)a1[2]) {
    llvm::SmallVectorBase<unsigned long long>::grow_pod();
  }
  *(_WORD *)(*a1 + 2 * v8) = *a2;
  uint64_t v9 = *a1;
  uint64_t v10 = a1[1] + 1;
  a1[1] = v10;
  return v9 + 2 * v10 - 2;
}

uint64_t **sub_1CD515EC8(uint64_t **result, unsigned __int16 *a2)
{
  uint64_t v3 = result;
  if (result[6])
  {
    uint64_t v8 = result + 4;
    __int16 v9 = *a2;
  }
  else
  {
    unint64_t v4 = (unint64_t)result[1];
    int v5 = *a2;
    if (!v4)
    {
LABEL_7:
      if (v4 >= (unint64_t)result[2]) {
        llvm::SmallVectorBase<unsigned long long>::grow_pod();
      }
      *((_WORD *)*result + v4) = v5;
      result[1] = (uint64_t *)((char *)result[1] + 1);
      return result;
    }
    uint64_t v6 = 2 * v4;
    unsigned int v7 = (unsigned __int16 *)*result;
    while (*v7 != v5)
    {
      ++v7;
      v6 -= 2;
      if (!v6) {
        goto LABEL_6;
      }
    }
    if (v6) {
      return result;
    }
LABEL_6:
    if (v4 <= 3) {
      goto LABEL_7;
    }
    do
    {
      __int16 v10 = *((_WORD *)*v3 + v4 - 1);
      sub_1CD515FD4(v3 + 4, v10, v10);
      unint64_t v4 = (unint64_t)v3[1] - 1;
      v3[1] = (uint64_t *)v4;
    }
    while (v4);
    __int16 v9 = *a2;
    uint64_t v8 = v3 + 4;
  }

  return (uint64_t **)sub_1CD515FD4(v8, v9, v9);
}

uint64_t sub_1CD515FD4(uint64_t **a1, unsigned __int16 a2, __int16 a3)
{
  uint64_t v6 = a1 + 1;
  int v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        unsigned int v7 = (uint64_t **)v5;
        unsigned int v8 = *((unsigned __int16 *)v5 + 13);
        if (v8 <= a2) {
          break;
        }
        int v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        return 0;
      }
      int v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    unsigned int v7 = a1 + 1;
LABEL_9:
    __int16 v9 = operator new(0x20uLL);
    v9[13] = a3;
    *(void *)__int16 v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v7;
    unsigned __int8 *v6 = (uint64_t *)v9;
    __int16 v10 = (uint64_t *)**a1;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    else
    {
      uint64_t v11 = (uint64_t *)v9;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    return 1;
  }
}

void sub_1CD51609C(int **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCCC5B8, 0, 0);
  dword_1EBCCC638 = 0;
  qword_1EBCCC640 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCCC648 = 0;
  qword_1EBCCC5B8 = (uint64_t)&unk_1F2643F68;
  qword_1EBCCC650 = (uint64_t)&unk_1F2643D20;
  qword_1EBCCC658 = (uint64_t)&unk_1F25F7480;
  qword_1EBCCC670 = (uint64_t)&qword_1EBCCC658;
  llvm::cl::Option::setArgStr(v4, "ifcvt-fn-start", 0xEuLL);
  int v5 = *a1;
  dword_1EBCCC638 = **a1;
  byte_1EBCCC64C = 1;
  dword_1EBCCC648 = *v5;
  word_1EBCCC5C2 = (32 * (*a2 & 3)) | word_1EBCCC5C2 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCC5B8);
}

uint64_t sub_1CD5161BC(uint64_t a1, char *a2, _DWORD **a3, _WORD *a4)
{
  uint64_t v8 = sub_1CB883A14(a1, 0, 0);
  *(_DWORD *)(v8 + 128) = 0;
  *(void *)(v8 + 136) = &unk_1F25F74C8;
  *(void *)(v8 + 144) = 0;
  *(void *)uint64_t v8 = &unk_1F2643F68;
  *(void *)(v8 + 152) = &unk_1F2643D20;
  *(void *)(v8 + 160) = &unk_1F25F7480;
  *(void *)(v8 + 184) = v8 + 160;
  size_t v9 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v9);
  __int16 v10 = *a3;
  *(_DWORD *)(a1 + 128) = **a3;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v10;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void sub_1CD5162D8(int **a1, _WORD *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCCC738, 0, 0);
  dword_1EBCCC7B8 = 0;
  qword_1EBCCC7C0 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCCC7C8 = 0;
  qword_1EBCCC738 = (uint64_t)&unk_1F2643F68;
  qword_1EBCCC7D0 = (uint64_t)&unk_1F2643D20;
  qword_1EBCCC7D8 = (uint64_t)&unk_1F25F7480;
  qword_1EBCCC7F0 = (uint64_t)&qword_1EBCCC7D8;
  llvm::cl::Option::setArgStr(v4, "ifcvt-limit", 0xBuLL);
  int v5 = *a1;
  dword_1EBCCC7B8 = **a1;
  byte_1EBCCC7CC = 1;
  dword_1EBCCC7C8 = *v5;
  word_1EBCCC742 = (32 * (*a2 & 3)) | word_1EBCCC742 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCC738);
}

void llvm::initializeImplicitNullChecksPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCCEB8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2BF384;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCCEB8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD51646C(__n128 *a1, int **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCCEC0, 0, 0);
  dword_1EBCCCF40 = 0;
  qword_1EBCCCF48 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCCCF50 = 0;
  qword_1EBCCCEC0 = (uint64_t)&unk_1F2643F68;
  qword_1EBCCCF58 = (uint64_t)&unk_1F2643D20;
  qword_1EBCCCF60 = (uint64_t)&unk_1F25F7480;
  qword_1EBCCCF78 = (uint64_t)&qword_1EBCCCF60;
  sub_1CD51655C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCCEC0);
}

__n128 sub_1CD51655C(__n128 *a1, int **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCCEC0, "imp-null-check-page-size", 0x18uLL);
  __n128 result = *a1;
  xmmword_1EBCCCEE0 = (__int128)*a1;
  unsigned int v7 = *a2;
  dword_1EBCCCF40 = **a2;
  byte_1EBCCCF54 = 1;
  dword_1EBCCCF50 = *v7;
  word_1EBCCCECA = (32 * (*a3 & 3)) | word_1EBCCCECA & 0xFF9F;
  return result;
}

uint64_t sub_1CD5165E4(uint64_t a1, char *a2, _OWORD *a3, _WORD *a4, int **a5)
{
  uint64_t v10 = sub_1CB883A14(a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25EA1B0;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F2643F00;
  *(void *)(v10 + 152) = &unk_1F2643DB0;
  *(void *)(v10 + 160) = &unk_1F25EA168;
  *(void *)(v10 + 184) = v10 + 160;
  size_t v11 = strlen(a2);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)a2, v11);
  *(_OWORD *)(a1 + 32) = *a3;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  int v12 = **a5;
  *(_DWORD *)(a1 + 128) = v12;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = v12;
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void llvm::initializeIndirectBrExpandPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD048, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2C18E8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCD048, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

double sub_1CD516784(uint64_t a1, uint64_t a2, char *a3)
{
  if (*(unsigned char *)(a1 + 440)) {
    a1 = sub_1CC2930C0(a1);
  }
  char v5 = *a3;
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x1000000000;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = a2;
  *(void *)(a1 + 296) = 0;
  *(unsigned char *)(a1 + 304) = v5;
  *(void *)(a1 + 312) = a1 + 344;
  *(void *)(a1 + 320) = a1 + 344;
  *(void *)&double result = 8;
  *(void *)(a1 + 328) = 8;
  *(_DWORD *)(a1 + 336) = 0;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 408) = 0;
  *(_WORD *)(a1 + 432) = 0;
  *(unsigned char *)(a1 + 440) = 1;
  return result;
}

_DWORD *sub_1CD516808(uint64_t *a1, _DWORD *a2)
{
  unsigned int v7 = 0;
  char v4 = sub_1CD516878(a1, a2, &v7);
  char v5 = v7;
  if ((v4 & 1) == 0)
  {
    char v5 = sub_1CD51691C((uint64_t)a1, (uint64_t)a2, a2, v7);
    _DWORD *v5 = *a2;
    *((void *)v5 + 1) = 0;
    *((void *)v5 + 2) = 0;
    *((void *)v5 + 3) = -1;
    *((void *)v5 + 4) = -1;
  }
  return v5;
}

uint64_t sub_1CD516878(uint64_t *a1, _DWORD *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    int v5 = v3 - 1;
    unsigned int v6 = (37 * *a2) & (v3 - 1);
    unsigned int v7 = (_DWORD *)(*a1 + 40 * v6);
    int v8 = *v7;
    if (*a2 == *v7)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v10 = 0;
      int v11 = 1;
      uint64_t result = 1;
      while (v8 != -1)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v8 == -2;
        }
        if (v12) {
          uint64_t v10 = v7;
        }
        unsigned int v13 = v6 + v11++;
        unsigned int v6 = v13 & v5;
        unsigned int v7 = (_DWORD *)(v4 + 40 * (v13 & v5));
        int v8 = *v7;
        if (*a2 == *v7) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v10) {
        unsigned int v7 = v10;
      }
    }
  }
  else
  {
    unsigned int v7 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v7;
  return result;
}

_DWORD *sub_1CD51691C(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5169CC(a1, v7);
  size_t v9 = 0;
  sub_1CD516878((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

_DWORD *sub_1CD5169CC(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD516AA4(a1, v4, v4 + 40 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 40 * v10;
    do
    {
      _DWORD *result = -1;
      result += 10;
      v11 -= 40;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD516AA4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(_DWORD **)result;
    uint64_t v8 = 40 * v6;
    do
    {
      _DWORD *v7 = -1;
      v7 += 10;
      v8 -= 40;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD516878((uint64_t *)v5, (_DWORD *)a2, &v11);
      size_t v9 = v11;
      *uint64_t v11 = *(_DWORD *)a2;
      long long v10 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)(v9 + 6) = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(v9 + 2) = v10;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 40;
  }
  return result;
}

uint64_t sub_1CD516B64(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(a1 + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)a1 + 8 * v3) = a2 | (unint64_t)(a3 << 32);
  unsigned int v4 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v4;
  return *(void *)a1 + 8 * v4 - 8;
}

void sub_1CD516BE4(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 176 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 22;
      v8 -= 176;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if (*a2 != -8192 && v9 != -4096)
    {
      BOOL v12 = 0;
      sub_1CC2CEAB4(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
      long long v10 = v12;
      *BOOL v12 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v10 + 5, 16, a2 + 1);
      v10[21] = a2[21];
      ++*(_DWORD *)(a1 + 8);
      uint64_t v11 = (void *)a2[2];
      if (v11 != (void *)a2[1]) {
        free(v11);
      }
    }
    a2 += 22;
  }
}

void *sub_1CD516CC4(void *a1)
{
  *a1 = &unk_1F260CAB0;
  *(void *)(a1[3] + 8) = 0;
  uint64_t v2 = (void *)a1[19];
  if (v2 != (void *)a1[18]) {
    free(v2);
  }
  unsigned int v3 = (void *)a1[11];
  if (v3 != (void *)a1[10]) {
    free(v3);
  }
  return a1;
}

void llvm::initializeInterleavedAccessPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD298, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2D07C4;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCCD298, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void *sub_1CD516DA4(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD45B528(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4CB5C0(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
    *((_DWORD *)v5 + 4) = 0;
  }
  return v5;
}

uint64_t sub_1CD516E14(uint64_t result, uint64_t a2, char *a3, char *a4)
{
  uint64_t v5 = a3;
  uint64_t v6 = *(void *)result;
  uint64_t v7 = *(unsigned int *)(result + 8);
  if (*(void *)result + 8 * v7 == a2)
  {
    return sub_1CD4570C8(result, a3, a4);
  }
  else
  {
    uint64_t v8 = (a2 - v6) >> 3;
    unint64_t v9 = (a4 - a3) >> 3;
    if (v7 + v9 > *(unsigned int *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    long long v10 = (char *)(v6 + 8 * v8);
    uint64_t v11 = (char *)(v6 + 8 * v7);
    unint64_t v12 = (v11 - v10) >> 3;
    if (v12 >= v9)
    {
      uint64_t result = sub_1CD4570C8(result, &v11[-8 * v9], (char *)(v6 + 8 * v7));
      if (&v11[-8 * v9] != v10) {
        uint64_t result = (uint64_t)memmove(&v10[8 * v9], v10, &v11[-8 * v9] - v10);
      }
      while (v5 != a4)
      {
        uint64_t v16 = *(void *)v5;
        v5 += 8;
        *(void *)long long v10 = v16;
        v10 += 8;
      }
    }
    else
    {
      unsigned int v13 = v7 + ((unint64_t)(a4 - a3) >> 3);
      *(_DWORD *)(result + 8) = v13;
      if (v8 != v7)
      {
        uint64_t result = (uint64_t)memcpy((void *)(v6 + 8 * v13 - 8 * v12), v10, v11 - v10);
        do
        {
          uint64_t v14 = *(void *)v5;
          v5 += 8;
          *(void *)long long v10 = v14;
          v10 += 8;
          --v12;
        }
        while (v12);
      }
      while (v5 != a4)
      {
        uint64_t v15 = *(void *)v5;
        v5 += 8;
        *(void *)uint64_t v11 = v15;
        v11 += 8;
      }
    }
  }
  return result;
}

void llvm::initializeInterleavedLoadCombinePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD368, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2D21F0;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCCD368, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeJMCInstrumenterPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD378, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2DA458;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCCD378, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createJMCInstrumenterPass(llvm *this)
{
}

char **sub_1CD5170A4(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 8 * v3;
    uint64_t v5 = v2 - 8;
    do
    {
      uint64_t v6 = *(unsigned __int8 **)&v5[v4];
      if (v6) {
        llvm::MetadataTracking::untrack((uint64_t)&v5[v4], v6);
      }
      v4 -= 8;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

BOOL llvm::latency_sort::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(_WORD *)(a2 + 228) & 0x800) != 0)
  {
    if ((*(_WORD *)(a3 + 228) & 0x800) == 0) {
      return 0;
    }
  }
  else if ((*(_WORD *)(a3 + 228) & 0x800) != 0)
  {
    return 1;
  }
  uint64_t v5 = *(unsigned int *)(a2 + 192);
  uint64_t v6 = *(unsigned int *)(a3 + 192);
  uint64_t v7 = **(void **)(*(void *)a1 + 16);
  uint64_t v8 = v7;
  if ((*(unsigned char *)(v7 + 272 * v5 + 236) & 2) == 0)
  {
    llvm::SUnit::ComputeHeight((llvm::SUnit *)(v7 + 272 * v5));
    uint64_t v8 = **(void **)(*(void *)a1 + 16);
  }
  unsigned int v9 = *(_DWORD *)(v7 + 272 * v5 + 244);
  if ((*(unsigned char *)(v8 + 272 * v6 + 236) & 2) == 0) {
    llvm::SUnit::ComputeHeight((llvm::SUnit *)(v8 + 272 * v6));
  }
  unsigned int v10 = *(_DWORD *)(v8 + 272 * v6 + 244);
  if (v9 < v10) {
    return 1;
  }
  if (v9 > v10) {
    return 0;
  }
  uint64_t v11 = *(void *)(*(void *)a1 + 24);
  unsigned int v12 = *(_DWORD *)(v11 + 4 * v5);
  unsigned int v13 = *(_DWORD *)(v11 + 4 * v6);
  if (v12 < v13) {
    return 1;
  }
  return v12 <= v13 && v6 < v5;
}

uint64_t llvm::LatencyPriorityQueue::scheduledNode(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 120);
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(uint64_t **)(a2 + 112);
    uint64_t v5 = 16 * v2;
    do
    {
      uint64_t v6 = *v4;
      v4 += 2;
      uint64_t result = llvm::LatencyPriorityQueue::AdjustPriorityOfUnscheduledPreds(v3, v6 & 0xFFFFFFFFFFFFFFF8);
      v5 -= 16;
    }
    while (v5);
  }
  return result;
}

uint64_t llvm::LatencyPriorityQueue::pop(uint64_t **this)
{
  if (((uint64_t (*)(uint64_t **))(*this)[8])(this)) {
    return 0;
  }
  uint64_t v3 = this[6];
  uint64_t v4 = this[7];
  uint64_t v5 = v3 + 1;
  if (v3 + 1 != v4)
  {
    uint64_t v6 = v3 + 1;
    do
    {
      uint64_t v7 = *v6++;
      if (llvm::latency_sort::operator()((uint64_t)(this + 9), *v3, v7)) {
        uint64_t v3 = v5;
      }
      uint64_t v5 = v6;
    }
    while (v6 != v4);
    uint64_t v4 = this[7];
  }
  uint64_t result = *v3;
  uint64_t v8 = v4 - 1;
  if (v3 != v4 - 1)
  {
    *uint64_t v3 = *v8;
    uint64_t *v8 = result;
    uint64_t v4 = this[7];
  }
  this[7] = v4 - 1;
  return result;
}

uint64_t llvm::LatencyPriorityQueue::remove(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 48);
  uint64_t v3 = *(uint64_t **)(result + 56);
  if (v2 != v3)
  {
    while (*v2 != a2)
    {
      if (++v2 == v3)
      {
        uint64_t v2 = *(uint64_t **)(result + 56);
        break;
      }
    }
  }
  uint64_t v4 = v3 - 1;
  if (v2 != v3 - 1)
  {
    uint64_t v5 = *v2;
    *uint64_t v2 = *v4;
    uint64_t *v4 = v5;
    uint64_t v3 = *(uint64_t **)(result + 56);
  }
  *(void *)(result + 56) = v3 - 1;
  return result;
}

llvm *llvm::LatencyPriorityQueue::dump(uint64_t **this, llvm::ScheduleDAG *a2)
{
  uint64_t v4 = llvm::dbgs((llvm *)this);
  uint64_t v5 = sub_1CB8E509C(v4, "Latency Priority Queue\n");
  uint64_t v6 = llvm::dbgs(v5);
  uint64_t v7 = sub_1CB8E509C(v6, "  Number of Queue Entries: ");
  uint64_t v8 = llvm::raw_ostream::operator<<(v7, this[7] - this[6]);
  uint64_t result = sub_1CB8E509C(v8, "\n");
  unsigned int v10 = this[6];
  for (uint64_t i = this[7];
        v10 != i;
        uint64_t result = (llvm *)(*(uint64_t (**)(llvm::ScheduleDAG *, uint64_t))(*(void *)a2 + 32))(a2, v12))
  {
    uint64_t v12 = *v10++;
    unsigned int v13 = llvm::dbgs(result);
    sub_1CB8E509C(v13, "    ");
  }
  return result;
}

void sub_1CD51743C(void *a1)
{
  sub_1CD51759C(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD517474()
{
  return 0;
}

void sub_1CD51747C(void *a1, void *a2)
{
  a1[2] = a2;
  unint64_t v2 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(a2[1] - *a2) >> 4);
  int v5 = 0;
  uint64_t v3 = a1[3];
  unint64_t v4 = (a1[4] - v3) >> 2;
  if (v2 <= v4)
  {
    if (v2 < v4) {
      a1[4] = v3 + 4 * v2;
    }
  }
  else
  {
    sub_1CC2DC07C((uint64_t)(a1 + 3), v2 - v4, &v5);
  }
}

void sub_1CD5174F4(void *a1)
{
  unint64_t v1 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a1[2] + 8) - *(void *)a1[2]) >> 4);
  int v4 = 0;
  uint64_t v2 = a1[3];
  unint64_t v3 = (a1[4] - v2) >> 2;
  if (v1 <= v3)
  {
    if (v1 < v3) {
      a1[4] = v2 + 4 * v1;
    }
  }
  else
  {
    sub_1CC2DC07C((uint64_t)(a1 + 3), v1 - v3, &v4);
  }
}

uint64_t sub_1CD517570(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

BOOL sub_1CD517578(uint64_t a1)
{
  return *(void *)(a1 + 48) == *(void *)(a1 + 56);
}

uint64_t sub_1CD517588()
{
  return 0;
}

uint64_t sub_1CD517590()
{
  return 1;
}

void *sub_1CD51759C(void *a1)
{
  *a1 = &unk_1F260C6B8;
  uint64_t v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[3];
  if (v3)
  {
    a1[4] = v3;
    operator delete(v3);
  }
  return a1;
}

void llvm::initializeLazyMachineBlockFrequencyInfoPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD380, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2DC1C0;
    v4[1] = &v2;
    unint64_t v3 = v4;
    std::__call_once(&qword_1EBCCD380, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::LazyMachineBlockFrequencyInfoPass *llvm::LazyMachineBlockFrequencyInfoPass::LazyMachineBlockFrequencyInfoPass(llvm::LazyMachineBlockFrequencyInfoPass *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::LazyMachineBlockFrequencyInfoPass::ID);
  *(void *)uint64_t v2 = &unk_1F260C750;
  *(_OWORD *)(v2 + 248) = 0u;
  *(_OWORD *)(v2 + 264) = 0u;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD380, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC2DC1C0;
    v6[1] = &PassRegistry;
    int v5 = v6;
    std::__call_once(&qword_1EBCCD380, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::LazyMachineBlockFrequencyInfoPass::print(llvm::PMDataManager ***this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  unint64_t v3 = *(uint64_t (**)(void))(*(void *)llvm::LazyMachineBlockFrequencyInfoPass::calculateIfNotAvailable(this) + 40);

  return v3();
}

void llvm::LazyMachineBlockFrequencyInfoPass::getAnalysisUsage(llvm::LazyMachineBlockFrequencyInfoPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBranchProbabilityInfo::ID);
  *((unsigned char *)a2 + 160) = 1;

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

uint64_t llvm::LazyMachineBlockFrequencyInfoPass::calculateIfNotAvailable(llvm::PMDataManager ***this)
{
  uint64_t AnalysisIfAvailable = llvm::AnalysisResolver::getAnalysisIfAvailable(this[1], &llvm::MachineBlockFrequencyInfo::ID);
  if (!AnalysisIfAvailable
    || (uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)AnalysisIfAvailable + 96))(AnalysisIfAvailable, &llvm::MachineBlockFrequencyInfo::ID)) == 0)
  {
    int v4 = this[1];
    int v5 = *v4;
    uint64_t v6 = v4[1];
    if (v5 == v6)
    {
LABEL_6:
      uint64_t v7 = 0;
    }
    else
    {
      while (*(_UNKNOWN **)v5 != &llvm::MachineBranchProbabilityInfo::ID)
      {
        int v5 = (llvm::PMDataManager *)((char *)v5 + 16);
        if (v5 == v6) {
          goto LABEL_6;
        }
      }
      uint64_t v7 = *((void *)v5 + 1);
    }
    (*(void (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::MachineBranchProbabilityInfo::ID);
    uint64_t v8 = llvm::AnalysisResolver::getAnalysisIfAvailable(this[1], &llvm::MachineLoopInfo::ID);
    if (v8) {
      uint64_t v9 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 96))(v8, &llvm::MachineLoopInfo::ID);
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v10 = llvm::AnalysisResolver::getAnalysisIfAvailable(this[1], &llvm::MachineDominatorTree::ID);
    if (v10)
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v10 + 96))(v10, &llvm::MachineDominatorTree::ID);
      if (!v9)
      {
        if (v11) {
          operator new();
        }
LABEL_15:
        operator new();
      }
    }
    else if (!v9)
    {
      goto LABEL_15;
    }
    operator new();
  }
  return result;
}

void sub_1CD517AA0(llvm::Pass *a1)
{
  sub_1CD517B14(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::LazyMachineBlockFrequencyInfoPass>()
{
}

void sub_1CD517B14(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260C750;
  uint64_t v1 = *((void *)a1 + 33);
  *((void *)a1 + 33) = 0;
  if (v1)
  {
    int v4 = a1;
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
    a1 = v4;
  }
  uint64_t v2 = *((void *)a1 + 32);
  *((void *)a1 + 32) = 0;
  if (v2)
  {
    int v5 = a1;
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    a1 = v5;
  }
  uint64_t v3 = *((void *)a1 + 31);
  *((void *)a1 + 31) = 0;
  if (v3)
  {
    uint64_t v6 = a1;
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    a1 = v6;
  }

  sub_1CBA0E6AC(a1);
}

uint64_t sub_1CD517C1C(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_1CD517C78(a1, (_DWORD *)a2);
    sub_1CD517C78(a1 + 296, (_DWORD *)(a2 + 296));
  }
  *(unsigned char *)(a1 + 592) = *(unsigned char *)(a2 + 592);
  sub_1CD41F46C(a1 + 600, a2 + 600);
  return a1;
}

uint64_t sub_1CD517C78(uint64_t a1, _DWORD *a2)
{
  sub_1CD517D24(a1);
  int v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
    int v4 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v4 | 1;
  if ((*(unsigned char *)a2 & 1) == 0 && a2[4] >= 5u)
  {
    *(_DWORD *)a1 = v4 & 0xFFFFFFFE;
    if (*a2) {
      uint64_t v5 = 4;
    }
    else {
      uint64_t v5 = a2[4];
    }
    *(void *)(a1 + 8) = operator new(8 * (v5 + 8 * v5), (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v5;
  }

  return sub_1CD517DBC(a1, a2);
}

void sub_1CD517D24(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = (void *)(a1 + 8);
    unsigned int v1 = 4;
  }
  else
  {
    unsigned int v1 = *(_DWORD *)(a1 + 16);
    if (!v1) {
      return;
    }
    uint64_t v2 = *(void **)(a1 + 8);
  }
  uint64_t v3 = &v2[9 * v1];
  do
  {
    if ((*v2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      for (uint64_t i = 0; i != -8; i -= 4)
      {
        uint64_t v5 = (void *)v2[i + 5];
        if (&v2[i + 7] != v5) {
          free(v5);
        }
      }
    }
    v2 += 9;
  }
  while (v2 != v3);
}

uint64_t sub_1CD517DBC(uint64_t result, _DWORD *a2)
{
  uint64_t v3 = (unsigned int *)result;
  unint64_t v4 = 0;
  unsigned int v5 = *a2 & 0xFFFFFFFE | *(_DWORD *)result & 1;
  *(_DWORD *)uint64_t result = v5;
  *(_DWORD *)(result + 4) = a2[1];
  uint64_t v6 = (void *)(result + 8);
  uint64_t v7 = a2 + 2;
  while ((v5 & 1) == 0)
  {
    if (v4 >= v3[4]) {
      return result;
    }
    uint64_t v8 = (void *)*v6;
LABEL_6:
    uint64_t v9 = v7;
    if ((*(unsigned char *)a2 & 1) == 0) {
      uint64_t v9 = (void *)*v7;
    }
    v8[9 * v4] = v9[9 * v4];
    unsigned int v5 = *v3;
    if (*v3)
    {
      uint64_t v11 = v6[9 * v4] | 0x1000;
      uint64_t v10 = v6;
    }
    else
    {
      uint64_t v10 = (void *)*v6;
      uint64_t v11 = *(void *)(*v6 + 72 * v4) | 0x1000;
    }
    if (v11 != -4096)
    {
      uint64_t v12 = v7;
      if ((*(unsigned char *)a2 & 1) == 0) {
        uint64_t v12 = (void *)*v7;
      }
      char v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = (uint64_t)&v10[9 * v4 + 1];
      uint64_t v16 = (uint64_t)&v12[9 * v4 + 1];
      do
      {
        char v17 = v13;
        uint64_t result = v15 + 32 * v14;
        uint64_t v18 = v16 + 32 * v14;
        *(void *)uint64_t result = result + 16;
        *(void *)(result + 8) = 0x200000000;
        if (*(_DWORD *)(v18 + 8)) {
          uint64_t result = sub_1CC2DD104(result, v18);
        }
        char v13 = 1;
        uint64_t v14 = 1;
      }
      while ((v17 & 1) == 0);
      unsigned int v5 = *v3;
    }
    ++v4;
  }
  uint64_t v8 = v6;
  if (v4 < 4) {
    goto LABEL_6;
  }
  return result;
}

unsigned char *sub_1CD517F18@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 88);
  uint64_t v6 = *(void *)(a2 + 96);
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x800000000;
  sub_1CC0579B0(a3, v6, v6, v7, v7);
  uint64_t v8 = *(char **)a3;
  uint64_t v9 = *(unsigned int *)(a3 + 8);
  uint64_t v10 = *(char **)a3;
  if (v9)
  {
    uint64_t v18 = 8 * v9;
    uint64_t v10 = *(char **)a3;
    while (*(void *)v10)
    {
      v10 += 8;
      v18 -= 8;
      if (!v18)
      {
        uint64_t v10 = (char *)(*(void *)a3 + 8 * v9);
        break;
      }
    }
  }
  uint64_t v11 = (v10 - v8) >> 3;
  uint64_t v12 = v10 + 8;
  if (v11 != v9 && v12 != (void *)(*(void *)a3 + 8 * v9))
  {
    uint64_t v14 = 8 * v9 - 8 * v11 - 8;
    do
    {
      if (*v12)
      {
        *(void *)uint64_t v10 = *v12;
        v10 += 8;
      }
      ++v12;
      v14 -= 8;
    }
    while (v14);
    uint64_t v8 = *(char **)a3;
  }
  *(_DWORD *)(a3 + 8) = (unint64_t)(v10 - v8) >> 3;
  uint64_t result = (unsigned char *)sub_1CD51810C(a1, a2);
  uint64_t v16 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    unsigned int v17 = 4;
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 8);
    unsigned int v17 = *(_DWORD *)(a1 + 16);
  }
  if ((unsigned char *)(v16 + 72 * v17) != result)
  {
    uint64_t v19 = *((unsigned int *)result + 4);
    uint64_t v20 = *(unsigned int *)(a3 + 8);
    unsigned int v21 = *(char **)a3;
    if (v19)
    {
      unint64_t v22 = (uint64_t *)*((void *)result + 1);
      uint64_t v23 = &v22[v19];
      do
      {
        uint64_t v24 = *v22;
        uint64_t v25 = 8 * v20;
        uint64_t v26 = v21;
        uint64_t v27 = &v21[8 * v20];
        if (v20)
        {
          uint64_t v28 = 8 * v20;
          uint64_t v26 = v21;
          while (*(void *)v26 != v24)
          {
            v26 += 8;
            v28 -= 8;
            if (!v28)
            {
              uint64_t v26 = &v21[8 * v20];
              break;
            }
          }
        }
        uint64_t v29 = (v26 - v21) >> 3;
        if (v29 != v20)
        {
          uint64_t v30 = v26 + 8;
          if (v26 + 8 != v27)
          {
            uint64_t v31 = v25 - 8 * v29 - 8;
            do
            {
              if (*v30 != v24)
              {
                *(void *)uint64_t v26 = *v30;
                v26 += 8;
              }
              ++v30;
              v31 -= 8;
            }
            while (v31);
            unsigned int v21 = *(char **)a3;
          }
        }
        uint64_t v20 = ((unint64_t)(v26 - v21) >> 3);
        ++v22;
      }
      while (v22 != v23);
      *(_DWORD *)(a3 + 8) = v20;
    }
    uint64_t v32 = (uint64_t *)*((void *)result + 5);
    unsigned __int16 v33 = &v32[*((unsigned int *)result + 12)];
    return sub_1CD4D069C((unsigned int *)a3, (uint64_t)&v21[8 * v20], v32, v33);
  }
  return result;
}

uint64_t sub_1CD51810C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = a2;
  if (sub_1CD51819C(a1, &v7, &v6)) {
    return v6;
  }
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    unsigned int v5 = 4;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    unsigned int v5 = *(_DWORD *)(a1 + 16);
  }
  return v4 + 72 * v5;
}

uint64_t sub_1CD51819C(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v4 - 1);
  uint64_t v7 = (void *)(v3 + 72 * v6);
  uint64_t v8 = *v7;
  if (*a2 == *v7)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 72 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*a2 == *v7) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

uint64_t sub_1CD518254(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, char a5)
{
  int v11 = (uint64_t *)result;
  while (2)
  {
    BOOL v12 = a2 - 1;
LABEL_3:
    for (uint64_t i = 1 - a4; ; ++i)
    {
      uint64_t v14 = (char *)a2 - (char *)v11;
      unint64_t v15 = a2 - v11;
      if (!(!v6 & v5))
      {
        switch(v15)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t result = sub_1CD518604(a3, *v12, *v11);
            if (result)
            {
              uint64_t v23 = *v11;
              *int v11 = *v12;
              *BOOL v12 = v23;
            }
            break;
          case 3uLL:
            uint64_t result = sub_1CC2DDFF4(v11, v11 + 1, a2 - 1, a3);
            break;
          case 4uLL:
            uint64_t result = sub_1CC2DE4DC(v11, v11 + 1, v11 + 2, a2 - 1, a3);
            break;
          case 5uLL:
            uint64_t result = sub_1CC2DE594(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v14 <= 191)
      {
        if (a5)
        {
          return (uint64_t)sub_1CC2DDE90(v11, a2, a3);
        }
        else
        {
          return (uint64_t)sub_1CC2DDF58(v11, a2, a3);
        }
      }
      if (i == 1)
      {
        if (v11 != a2)
        {
          return (uint64_t)sub_1CC2DE674(v11, a2, a2, a3);
        }
        return result;
      }
      unint64_t v16 = v15 >> 1;
      unsigned int v17 = &v11[v15 >> 1];
      if ((unint64_t)v14 >= 0x401)
      {
        sub_1CC2DDFF4(v11, &v11[v15 >> 1], a2 - 1, a3);
        sub_1CC2DDFF4(v11 + 1, v17 - 1, a2 - 2, a3);
        sub_1CC2DDFF4(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
        sub_1CC2DDFF4(v17 - 1, v17, &v11[v16 + 1], a3);
        uint64_t v18 = *v11;
        *int v11 = *v17;
        uint64_t *v17 = v18;
      }
      else
      {
        sub_1CC2DDFF4(&v11[v15 >> 1], v11, a2 - 1, a3);
      }
      if ((a5 & 1) == 0 && !sub_1CD518604(a3, *(v11 - 1), *v11))
      {
        uint64_t result = (uint64_t)sub_1CC2DE0E4(v11, a2, a3);
        unint64_t v22 = (uint64_t *)result;
        goto LABEL_15;
      }
      uint64_t v19 = sub_1CC2DE1F4(v11, a2, a3);
      if ((v20 & 1) == 0) {
        goto LABEL_42;
      }
      BOOL v21 = sub_1CC2DE310(v11, v19, a3);
      unint64_t v22 = v19 + 1;
      uint64_t result = sub_1CC2DE310(v19 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v21)
      {
LABEL_42:
        a4 = -i;
        uint64_t result = sub_1CD518254(v11, v19, a3, -i, a5 & 1);
        a5 = 0;
        int v11 = v19 + 1;
        goto LABEL_3;
      }
LABEL_15:
      int v11 = v22;
    }
    a4 = -i;
    a2 = v19;
    if (!v21) {
      continue;
    }
    return result;
  }
}

BOOL sub_1CD518604(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *a1;
  uint64_t v11 = 0;
  uint64_t v12 = a2;
  if (sub_1CBA0E618(v5, &v12, &v11)) {
    uint64_t v6 = v11;
  }
  else {
    uint64_t v6 = *(void *)v5 + 16 * *(unsigned int *)(v5 + 16);
  }
  unsigned int v7 = *(_DWORD *)(v6 + 8);
  uint64_t v8 = *a1;
  uint64_t v11 = 0;
  uint64_t v12 = a3;
  if (sub_1CBA0E618(v8, &v12, &v11)) {
    uint64_t v9 = v11;
  }
  else {
    uint64_t v9 = *(void *)v8 + 16 * *(unsigned int *)(v8 + 16);
  }
  return v7 < *(_DWORD *)(v9 + 8);
}

void llvm::LexicalScope::dump(llvm::Metadata **this, unsigned int a2)
{
  int v4 = llvm::dbgs((llvm *)this);
  llvm::raw_ostream::indent(v4, a2);
  uint64_t v5 = sub_1CB8E509C(v4, "DFSIn: ");
  uint64_t v6 = llvm::raw_ostream::operator<<(v5, *((unsigned int *)this + 44));
  unsigned int v7 = sub_1CB8E509C(v6, " DFSOut: ");
  uint64_t v8 = llvm::raw_ostream::operator<<(v7, *((unsigned int *)this + 45));
  sub_1CB8E509C(v8, "\n");
  uint64_t v9 = this[1];
  llvm::raw_ostream::indent(v4, a2);
  llvm::Metadata::dump(v9);
}

void ***sub_1CD518834(void ***result)
{
  unsigned int v1 = result;
  uint64_t v2 = *((unsigned int *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  if (v2)
  {
    uint64_t v4 = 16 * v2;
    uint64_t v5 = (void ***)(*result + 1);
    do
    {
      if (((unint64_t)*(v5 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        uint64_t result = sub_1CC2E18C8(v5, 0);
      }
      v5 += 2;
      v4 -= 16;
    }
    while (v4);
  }
  if (v3)
  {
    int v6 = 1 << (33 - __clz(v3 - 1));
    if (v6 <= 64) {
      unsigned int v7 = 64;
    }
    else {
      unsigned int v7 = v6;
    }
    uint64_t result = (void ***)*v1;
    if (v7 == *((_DWORD *)v1 + 4))
    {
      v1[1] = 0;
      uint64_t v8 = 16 * v7;
      do
      {
        unsigned char *result = (void **)-4096;
        result += 2;
        v8 -= 16;
      }
      while (v8);
      return result;
    }
  }
  else
  {
    if (!*((_DWORD *)v1 + 4))
    {
      v1[1] = 0;
      return result;
    }
    unsigned int v7 = 0;
    uint64_t result = (void ***)*v1;
  }
  MEMORY[0x1D25D9CD0](result, 8);

  return (void ***)sub_1CB837D60(v1, v7);
}

void *sub_1CD518934(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5189EC(a1, v6);
  uint64_t v8 = 0;
  sub_1CC152E2C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD5189EC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void ***)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD518AB8((void ***)a1, (void ***)v4, (void ***)&v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

void ***sub_1CD518AB8(void ***result, void ***a2, void ***a3)
{
  uint64_t v4 = result;
  result[1] = 0;
  uint64_t v5 = *((unsigned int *)result + 4);
  if (v5)
  {
    unint64_t v6 = *result;
    uint64_t v7 = 16 * v5;
    do
    {
      llvm::raw_ostream *v6 = (void *)-4096;
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
  }
  if (a2 != a3)
  {
    unsigned int v8 = a2 + 1;
    do
    {
      uint64_t v9 = (uint64_t)*(v8 - 1);
      if ((v9 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v13 = 0;
        sub_1CC152E2C((uint64_t)*v4, *((_DWORD *)v4 + 4), v9, &v13);
        uint64_t v10 = v13;
        *unsigned int v13 = *(v8 - 1);
        uint64_t v11 = *v8;
        void *v8 = 0;
        v10[1] = v11;
        ++*((_DWORD *)v4 + 2);
        uint64_t result = sub_1CC2E18C8(v8, 0);
      }
      uint64_t v12 = v8 + 1;
      v8 += 2;
    }
    while (v12 != a3);
  }
  return result;
}

void llvm::initializeLiveDebugVariablesPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD448, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC2E1930;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCD448, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD518BF4(uint64_t a1, llvm::AnalysisUsage *this)
{
  llvm::AnalysisUsage::addRequiredID(this, (char *)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(this, (char *)&llvm::LiveIntervals::ID);
  *((unsigned char *)this + 160) = 1;

  llvm::MachineFunctionPass::getAnalysisUsage(a1, (uint64_t)this);
}

uint64_t sub_1CD518C58(uint64_t a1)
{
  sub_1CB8483A0(a1, (uint64_t)&unk_1EA61EEDF);
  *(void *)uint64_t v2 = &unk_1F260C810;
  *((void *)v2 + 31) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD448, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC2E1930;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCD448, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CD518D10(llvm::Pass *a1)
{
  sub_1CC2E5130(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD518D48()
{
}

uint64_t sub_1CD518D84(uint64_t a1, unsigned int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(24 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD518F24(a1, v6, v6 + 24 * v7);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = 0;
  uint64_t v9 = v14;
  do
  {
    unsigned int v10 = *(_DWORD *)(a1 + v8 + 8);
    if (v10 <= 0xFFFFFFFD)
    {
      *(_DWORD *)uint64_t v9 = v10;
      *(_OWORD *)(v9 + 8) = *(_OWORD *)(a1 + v8 + 16);
      v9 += 24;
    }
    v8 += 24;
  }
  while (v8 != 96);
  if (a2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(24 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD518F24(a1, (uint64_t)v14, (uint64_t)v9);
}

uint64_t sub_1CD518F24(uint64_t result, uint64_t a2, uint64_t a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (_DWORD *)(result + 8);
    uint64_t v9 = (_DWORD *)(result + 104);
  }
  else
  {
    int v7 = *(_DWORD *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(_DWORD **)(result + 8);
    uint64_t v9 = &v8[6 * v7];
  }
  do
  {
    _DWORD *v8 = -1;
    v8 += 6;
  }
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    int v10 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 <= 0xFFFFFFFD)
    {
      uint64_t v12 = 0;
      uint64_t result = sub_1CC2ED628((uint64_t)v5, v10, &v12);
      uint64_t v11 = v12;
      *uint64_t v12 = *(_DWORD *)a2;
      *(_OWORD *)(v11 + 2) = *(_OWORD *)(a2 + 8);
      *v5 += 2;
    }
    a2 += 24;
  }
  return result;
}

_DWORD *sub_1CD518FE8(_DWORD *a1, int *a2)
{
  int v7 = 0;
  char v4 = sub_1CD519060((uint64_t)a1, *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD519114(a1, a2, v7);
    _DWORD *v5 = *a2;
    *((void *)v5 + 1) = v5 + 6;
    *((void *)v5 + 2) = 0x400000000;
  }
  return v5;
}

uint64_t sub_1CD519060(uint64_t a1, int a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      int v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & (37 * a2);
  int v7 = (_DWORD *)(v3 + 88 * v6);
  int v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    int v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -2;
      }
      if (v12) {
        int v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      int v7 = (_DWORD *)(v3 + 88 * (v13 & v5));
      int v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      int v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

_DWORD *sub_1CD519114(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD5191D4((uint64_t)a1, v6);
  int v8 = 0;
  sub_1CD519060((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -1) {
    --a1[1];
  }
  return a3;
}

void sub_1CD5191D4(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    int v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40) {
      unsigned int v2 = v6 + 1;
    }
    else {
      unsigned int v2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    if (v2 > 4)
    {
      *(void *)(a1 + 8) = operator new(88 * v2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v2;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD5193CC(a1, v7, v7 + 88 * v8);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = 0;
  int v10 = v14;
  do
  {
    uint64_t v11 = a1 + v9;
    unsigned int v12 = *(_DWORD *)(a1 + v9 + 8);
    if (v12 <= 0xFFFFFFFD)
    {
      *(_DWORD *)int v10 = v12;
      *((void *)v10 + 1) = v10 + 24;
      unsigned int v13 = (void **)(v11 + 16);
      *((void *)v10 + 2) = 0x400000000;
      if (*(_DWORD *)(v11 + 24)) {
        sub_1CD4BAB44((uint64_t)(v10 + 8), (uint64_t)v13);
      }
      v10 += 88;
      if ((void *)(a1 + v9 + 32) != *v13) {
        free(*v13);
      }
    }
    v9 += 88;
  }
  while (v9 != 352);
  if (v2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(88 * v2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v2;
  }
  sub_1CD5193CC(a1, (uint64_t)v14, (uint64_t)v10);
}

void sub_1CD5193CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    unsigned int v8 = (_DWORD *)(a1 + 8);
    uint64_t v9 = (_DWORD *)(a1 + 360);
  }
  else
  {
    int v7 = *(_DWORD *)(a1 + 16);
    if (!v7) {
      goto LABEL_6;
    }
    unsigned int v8 = *(_DWORD **)(a1 + 8);
    uint64_t v9 = &v8[22 * v7];
  }
  do
  {
    _DWORD *v8 = -1;
    v8 += 22;
  }
  while (v8 != v9);
LABEL_6:
  if (a2 != a3)
  {
    do
    {
      int v10 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        uint64_t v14 = 0;
        sub_1CD519060(a1, v10, &v14);
        uint64_t v11 = v14;
        *uint64_t v14 = *(_DWORD *)v4;
        *((void *)v11 + 2) = 0x400000000;
        *((void *)v11 + 1) = v11 + 6;
        uint64_t v12 = (uint64_t)(v11 + 2);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD4BAB44(v12, v4 + 8);
        }
        *(_DWORD *)a1 += 2;
        unsigned int v13 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v13) {
          free(v13);
        }
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
}

_DWORD *sub_1CD5194D8(uint64_t a1, int *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    int v6 = sub_1CD51959C(a1, a2, v9);
    _DWORD *v6 = *a2;
    *((void *)v6 + 2) = 0;
    *((void *)v6 + 3) = 0;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  unsigned int v4 = v3 - 1;
  uint64_t v5 = (37 * *a2) & (v3 - 1);
  int v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    int v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        int v10 = v6;
      }
      int v13 = v5 + v11++;
      uint64_t v5 = v13 & v4;
      int v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD51959C(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD519714(a1, 2 * v6);
    int v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v10 = (37 * *a2) & v9;
    a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
    int v11 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          BOOL v12 = a3;
        }
        int v15 = v10 + v13++;
        uint64_t v10 = v15 & v9;
        a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
        int v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      int v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD519714(a1, v6);
    int v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    uint64_t v17 = (37 * *a2) & v16;
    a3 = (_DWORD *)(*(void *)a1 + 32 * v17);
    int v18 = *a3;
    if (*a2 != *a3)
    {
      BOOL v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          BOOL v12 = a3;
        }
        int v21 = v17 + v19++;
        uint64_t v17 = v21 & v16;
        a3 = (_DWORD *)(*(void *)a1 + 32 * v17);
        int v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD519714(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unsigned int v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5197E0(a1, v4, &v4[8 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      _DWORD *result = -1;
      result += 8;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD5197E0(uint64_t result, int *a2, int *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(unsigned int *)(result + 16);
  if (v3)
  {
    unsigned int v4 = *(_DWORD **)result;
    uint64_t v5 = 32 * v3;
    do
    {
      _DWORD *v4 = -1;
      v4 += 8;
      v5 -= 32;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 8)
  {
    int v6 = *a2;
    if (*a2 <= 0xFFFFFFFD)
    {
      int v7 = *(_DWORD *)(result + 16) - 1;
      uint64_t v8 = v7 & (37 * v6);
      uint64_t v9 = *(void *)result + 32 * v8;
      int v10 = *(_DWORD *)v9;
      if (v6 != *(_DWORD *)v9)
      {
        uint64_t v11 = 0;
        int v12 = 1;
        while (v10 != -1)
        {
          if (v11) {
            BOOL v13 = 0;
          }
          else {
            BOOL v13 = v10 == -2;
          }
          if (v13) {
            uint64_t v11 = v9;
          }
          int v14 = v8 + v12++;
          uint64_t v8 = v14 & v7;
          uint64_t v9 = *(void *)result + 32 * v8;
          int v10 = *(_DWORD *)v9;
          if (v6 == *(_DWORD *)v9) {
            goto LABEL_7;
          }
        }
        if (v11) {
          uint64_t v9 = v11;
        }
      }
LABEL_7:
      *(_DWORD *)uint64_t v9 = v6;
      *(void *)(v9 + 16) = 0;
      *(void *)(v9 + 24) = 0;
      *(void *)(v9 + 8) = 0;
      *(_OWORD *)(v9 + 8) = *(_OWORD *)(a2 + 2);
      *(void *)(v9 + 24) = *((void *)a2 + 3);
      *((void *)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
      *((void *)a2 + 3) = 0;
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

void sub_1CD5198CC(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CD519988(a1);
  if (v2)
  {
    int v3 = 1 << (33 - __clz(v2 - 1));
    if (v3 <= 64) {
      unsigned int v4 = 64;
    }
    else {
      unsigned int v4 = v3;
    }
    if (v4 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v5 = 32 * v4;
      int v6 = *(_DWORD **)a1;
      do
      {
        _DWORD *v6 = -1;
        v6 += 8;
        v5 -= 32;
      }
      while (v5);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v4 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  sub_1CBFFB9D0(a1, v4);
}

void sub_1CD519988(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 32 * v1;
    int v3 = (void *)(*(void *)a1 + 16);
    do
    {
      if (*((_DWORD *)v3 - 4) <= 0xFFFFFFFD)
      {
        unsigned int v4 = (void *)*(v3 - 1);
        if (v4)
        {
          *int v3 = v4;
          operator delete(v4);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

_DWORD *sub_1CD5199E4(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      int v6 = *(_DWORD **)result;
      uint64_t v7 = 24 * v2;
      do
      {
        _DWORD *v6 = -1;
        v6 += 6;
        v7 -= 24;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CBF82310(v1, v5);
  }
  return result;
}

uint64_t sub_1CD519A94(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v6 = (void *)(a1 + 16 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      int v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          int v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        int v6 = (void *)(a1 + 16 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        int v6 = v10;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD519B28(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD519B90(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD519C24(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t sub_1CD519B90(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = ((a3 >> 4) ^ (a3 >> 9)) & (a2 - 1);
    int v6 = (void *)(a1 + 16 * v5);
    uint64_t v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      int v10 = 0;
      int v11 = 1;
      while (v7 != -4096)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == -8192;
        }
        if (v12) {
          int v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        int v6 = (void *)(a1 + 16 * (v13 & v4));
        uint64_t v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        int v6 = v10;
      }
    }
  }
  else
  {
    int v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

void *sub_1CD519C24(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD519CDC(a1, v6);
  uint64_t v8 = 0;
  sub_1CD519B90(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD519CDC(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD519DA8(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD519DA8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD519B90(*(void *)v5, *(_DWORD *)(v5 + 16), v9, &v11);
      uint64_t v10 = v11;
      *uint64_t v11 = *a2;
      v10[1] = a2[1];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 2;
  }
  return result;
}

void sub_1CD519E60(char **a1, __n128 *a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCD388, 0, 0);
  byte_1EBCCD408 = 0;
  qword_1EBCCD410 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCCD418 = 0;
  qword_1EBCCD388 = (uint64_t)&unk_1F26440A0;
  qword_1EBCCD420 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCCD428 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCCD440 = (uint64_t)&qword_1EBCCD428;
  sub_1CD519F50(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCD388);
}

__n128 sub_1CD519F50(char **a1, __n128 *a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCD388, "live-debug-variables", 0x14uLL);
  uint64_t v6 = *a1;
  byte_1EBCCD408 = **a1;
  byte_1EBCCD419 = 1;
  byte_1EBCCD418 = *v6;
  __n128 result = *a2;
  xmmword_1EBCCD3A8 = (__int128)*a2;
  word_1EBCCD392 = (32 * (*a3 & 3)) | word_1EBCCD392 & 0xFF9F;
  return result;
}

void llvm::LiveIntervals::getAnalysisUsage(llvm::LiveIntervals *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::setPreservesCFG(a2);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AAResultsWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::LiveVariables::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::MachineLoopInfo::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::MachineDominatorTree::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::MachineDominatorTree::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::SlotIndexes::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::SlotIndexes::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

llvm::LiveIntervals *llvm::LiveIntervals::LiveIntervals(llvm::LiveIntervals *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::LiveIntervals::ID);
  *(void *)uint64_t v2 = &unk_1F260C8D0;
  *(_OWORD *)(v2 + 296) = 0u;
  *(_OWORD *)(v2 + 312) = 0u;
  *(void *)(v2 + 328) = v2 + 344;
  *(void *)(v2 + 336) = 0x400000000;
  *(void *)(v2 + 376) = v2 + 392;
  *(void *)(v2 + 384) = 0;
  *(void *)(v2 + 392) = 0;
  *(void *)(v2 + 400) = 1;
  *(void *)(v2 + 416) = 0;
  *(void *)(v2 + 424) = 0;
  *(void *)(v2 + 408) = v2 + 424;
  *(void *)(v2 + 440) = v2 + 456;
  *(void *)(v2 + 448) = 0x800000000;
  *(void *)(v2 + 520) = v2 + 536;
  *(void *)(v2 + 528) = 0x800000000;
  *(void *)(v2 + 600) = v2 + 616;
  *(void *)(v2 + 608) = 0x800000000;
  *(void *)(v2 + 680) = v2 + 696;
  *(void *)(v2 + 688) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD450, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC2EEE6C;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCD450, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::LiveIntervals::~LiveIntervals(llvm::LiveIntervals *this)
{
  *(void *)this = &unk_1F260C8D0;
  uint64_t v2 = *((void *)this + 38);
  if (v2)
  {
    uint64_t v3 = sub_1CC2F56BC(v2);
    MEMORY[0x1D25D9CE0](v3, 0x10E0C40F11850D9);
  }
  int v4 = (char *)*((void *)this + 85);
  if (v4 != (char *)this + 696) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)this + 75);
  if (v5 != (char *)this + 616) {
    free(v5);
  }
  uint64_t v6 = (char *)*((void *)this + 65);
  if (v6 != (char *)this + 536) {
    free(v6);
  }
  int v7 = (char *)*((void *)this + 55);
  if (v7 != (char *)this + 456) {
    free(v7);
  }
  uint64_t v8 = (char *)*((void *)this + 51);
  if (v8 != (char *)this + 424) {
    free(v8);
  }
  sub_1CBFFBA64((uint64_t)this + 312);

  sub_1CBA0E6AC(this);
}

{
  uint64_t vars8;

  llvm::LiveIntervals::~LiveIntervals(this);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::LiveIntervals::print(llvm::LiveIntervals *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  sub_1CB8E509C(a2, "********** INTERVALS **********\n");
  uint64_t v5 = *((unsigned int *)this + 172);
  if (v5)
  {
    for (uint64_t i = 0; i != v5; ++i)
    {
      int v7 = *(uint64_t ***)(*((void *)this + 85) + 8 * i);
      if (v7)
      {
        llvm::printRegUnit(i, *((void *)this + 33), v22);
        if (!v23) {
          sub_1CB920400();
        }
        (*(void (**)(void *, llvm::raw_ostream *))(*v23 + 48))(v23, a2);
        uint64_t v8 = (unsigned char *)*((void *)a2 + 4);
        if ((unint64_t)v8 >= *((void *)a2 + 3))
        {
          uint64_t v9 = llvm::raw_ostream::write(a2, 32);
        }
        else
        {
          *((void *)a2 + 4) = v8 + 1;
          unsigned char *v8 = 32;
          uint64_t v9 = a2;
        }
        llvm::LiveRange::print(v7, v9);
        uint64_t v10 = (unsigned char *)*((void *)v9 + 4);
        if ((unint64_t)v10 >= *((void *)v9 + 3))
        {
          llvm::raw_ostream::write(v9, 10);
        }
        else
        {
          *((void *)v9 + 4) = v10 + 1;
          *uint64_t v10 = 10;
        }
        if (v23 == v22)
        {
          (*(void (**)(void *))(v22[0] + 32))(v22);
        }
        else if (v23)
        {
          (*(void (**)(void))(*v23 + 40))();
        }
      }
    }
  }
  int v11 = *(_DWORD *)(*((void *)this + 32) + 32);
  if (v11)
  {
    for (int j = 0; j != v11; ++j)
    {
      if ((j & 0x7FFFFFFFu) < (unint64_t)*((unsigned int *)this + 104)
        && *(void *)(*((void *)this + 51) + 8 * (j & 0x7FFFFFFF)))
      {
        unsigned int v13 = (llvm::LiveInterval *)sub_1CC2F12AC((uint64_t)this, j | 0x80000000);
        llvm::LiveInterval::print(v13, a2);
        int v14 = (unsigned char *)*((void *)a2 + 4);
        if ((unint64_t)v14 >= *((void *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, 10);
        }
        else
        {
          *((void *)a2 + 4) = v14 + 1;
          *int v14 = 10;
        }
      }
    }
  }
  sub_1CB8E509C(a2, "RegMasks:");
  uint64_t v15 = *((unsigned int *)this + 112);
  if (v15)
  {
    int v16 = (uint64_t *)*((void *)this + 55);
    uint64_t v17 = 8 * v15;
    do
    {
      uint64_t v18 = *v16;
      int v19 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v19 >= *((void *)a2 + 3))
      {
        BOOL v20 = llvm::raw_ostream::write(a2, 32);
      }
      else
      {
        *((void *)a2 + 4) = v19 + 1;
        *int v19 = 32;
        BOOL v20 = a2;
      }
      v22[0] = v18;
      llvm::SlotIndex::print((llvm::SlotIndex *)v22, v20);
      ++v16;
      v17 -= 8;
    }
    while (v17);
  }
  int v21 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v21 >= *((void *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((void *)a2 + 4) = v21 + 1;
    *int v21 = 10;
  }
  sub_1CB8E509C(a2, "********** MACHINEINSTRS **********\n");
  llvm::MachineFunction::print(*((llvm::Value ***)this + 31), a2, *((const llvm::SlotIndexes **)this + 36));
}

void llvm::LiveIntervals::dumpInstrs(llvm::LiveIntervals *this)
{
  uint64_t v2 = llvm::dbgs(this);
  sub_1CB8E509C(v2, "********** MACHINEINSTRS **********\n");
  uint64_t v3 = (llvm::Value **)*((void *)this + 31);
  int v4 = (const llvm::SlotIndexes *)*((void *)this + 36);

  llvm::MachineFunction::print(v3, v2, v4);
}

float llvm::LiveIntervals::getSpillWeight(llvm::LiveIntervals *this, unsigned int a2, llvm::MachineBlockFrequencyInfo *a3, const llvm::MachineBlockFrequencyInfo *a4, const llvm::MachineBasicBlock *a5, float a6)
{
  unsigned int v9 = this;
  unint64_t BlockFreq = llvm::MachineBlockFrequencyInfo::getBlockFreq(a3, a4);
  uint64_t v11 = *((void *)a3 + 31);
  if (v11) {
    float v12 = (float)*(unint64_t *)(*(void *)(v11 + 8) + 16);
  }
  else {
    float v12 = 0.0;
  }
  return (float)((float)a2 + (float)((float)v9 * a6)) * (float)((float)(1.0 / v12) * (float)BlockFreq);
}

void llvm::LiveIntervals::addSegmentToEndOfBlock(uint64_t a1, int a2)
{
}

uint64_t llvm::LiveIntervals::repairOldRegInRange(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t result = llvm::LiveRange::find((uint64_t *)a5, a4);
  uint64_t v15 = result;
  int v39 = (void *)a5;
  if (result == *(void *)a5 + 24 * *(unsigned int *)(a5 + 8)
    || ((*(void *)result >> 1) & 3 | *(_DWORD *)((*(void *)result & 0xFFFFFFFFFFFFFFF8) + 24)) >= (*(_DWORD *)((a4 & 0xFFFFFFFFFFFFFFF8) + 24) | (a4 >> 1) & 3))
  {
    unint64_t v16 = 0;
    if (result == *(void *)a5) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = -1;
    }
    uint64_t v15 = result + 24 * v17;
  }
  else
  {
    unint64_t v16 = *(void *)(result + 8);
  }
  if (a3 != a2)
  {
    uint64_t v36 = a7;
    uint64_t v37 = a1 + 312;
    while (1)
    {
      a3 = *(void *)a3 & 0xFFFFFFFFFFFFFFF8;
      if (!a3 || (*(unsigned char *)a3 & 4) == 0)
      {
        while ((*(_WORD *)(a3 + 44) & 4) != 0)
          a3 = *(void *)a3 & 0xFFFFFFFFFFFFFFF8;
      }
      int v18 = **(unsigned __int16 **)(a3 + 16);
      if ((v18 - 13) >= 5 && v18 != 23)
      {
        uint64_t result = sub_1CBB24CA0(*(void *)(a1 + 288), a3, 0);
        uint64_t v20 = *(void *)v15 < 8uLL ? 0 : *(void *)((*(void *)v15 & 0xFFFFFFFFFFFFFFF8) + 16);
        unint64_t v21 = *(void *)(v15 + 8);
        uint64_t v22 = v21 < 8 ? 0 : *(void *)((v21 & 0xFFFFFFFFFFFFFFF8) + 16);
        uint64_t v23 = *(unsigned int *)(a3 + 40);
        if (v23) {
          break;
        }
      }
LABEL_20:
      if (a3 == a2) {
        goto LABEL_59;
      }
    }
    uint64_t v24 = *(unsigned int **)(a3 + 32);
    unint64_t v38 = result & 0xFFFFFFFFFFFFFFF8;
    unint64_t v25 = result & 0xFFFFFFFFFFFFFFF8 | 4;
    uint64_t v26 = 32 * v23;
    uint64_t v40 = v22;
    uint64_t v41 = v20;
    while (1)
    {
      unint64_t v27 = *v24;
      if (!*v24
        && v24[1] == a6
        && (*(void *)(*(void *)(*(void *)(a1 + 264) + 232) + 8 * ((v27 >> 8) & 0xFFF)) & a7) != 0)
      {
        if ((v27 & 0x1000000) != 0)
        {
          if (v20) {
            goto LABEL_41;
          }
          if ((~*(_DWORD *)(v15 + 8) & 6) != 0)
          {
            *(void *)uint64_t v15 = v25;
            *(void *)(*(void *)(v15 + 16) + 8) = v25;
          }
          else
          {
            uint64_t result = (uint64_t)llvm::LiveRange::removeSegment((uint64_t)v39, (char *)v15, 1);
            uint64_t v22 = v40;
            uint64_t v20 = v41;
            a7 = v36;
            if (v15 == *v39) {
              uint64_t v33 = 0;
            }
            else {
              uint64_t v33 = -1;
            }
            v15 += 24 * v33;
LABEL_41:
            if (v16 <= 7)
            {
              uint64_t v29 = (uint64_t)v39;
              unint64_t v31 = sub_1CC2F3BF8((uint64_t)v39, v25, v37);
              v43[0] = v25;
              v43[1] = v38 | 6;
              v43[2] = v31;
              uint64_t v30 = v43;
LABEL_45:
              uint64_t result = llvm::LiveRange::addSegment(v29, (uint64_t)v30);
              uint64_t v15 = result;
              uint64_t v22 = v40;
              uint64_t v20 = v41;
            }
            else if (*(void *)v15 != v25)
            {
              unint64_t v28 = sub_1CC2F3BF8((uint64_t)v39, v25, v37);
              v42[0] = v25;
              v42[1] = v16;
              uint64_t v29 = (uint64_t)v39;
              a7 = v36;
              v42[2] = v28;
              uint64_t v30 = v42;
              goto LABEL_45;
            }
          }
          int v32 = (*v24 >> 28) & 1;
          if ((*v24 & 0xFFF00) == 0) {
            int v32 = 1;
          }
          if (v32) {
            unint64_t v16 = 0;
          }
          else {
            unint64_t v16 = v25;
          }
          goto LABEL_31;
        }
        if (!v22 && (*(unsigned char *)(v15 + 8) & 6) != 0) {
          *(void *)(v15 + 8) = v25;
        }
        if (v16 <= 7) {
          unint64_t v16 = v25;
        }
      }
LABEL_31:
      v24 += 8;
      v26 -= 32;
      if (!v26) {
        goto LABEL_20;
      }
    }
  }
LABEL_59:
  uint64_t v34 = *(void *)v15;
  if (*(void *)v15 < 8uLL || !*(void *)((v34 & 0xFFFFFFFFFFFFFFF8) + 16))
  {
    uint64_t v35 = *(void *)(v15 + 8);
    if ((~*(_DWORD *)(v15 + 8) & 6) == 0)
    {
      return (uint64_t)llvm::LiveRange::removeSegment((uint64_t)v39, v34, v35, 1);
    }
  }
  return result;
}

void llvm::LiveIntervals::repairIntervalsInRange(uint64_t a1, uint64_t a2, _WORD *a3, unsigned char *a4, unsigned char *a5, uint64_t a6)
{
  unsigned int v9 = a3;
  v37[6] = *MEMORY[0x1E4F143B8];
  while (v9 != *(_WORD **)(a2 + 56))
  {
    float v12 = (uint64_t *)(*(void *)(a1 + 288) + 368);
    uint64_t v34 = 0;
    uint64_t v35 = v9;
    if (sub_1CB915048(v12, &v35, &v34)) {
      break;
    }
    unsigned int v9 = (_WORD *)(*(void *)v9 & 0xFFFFFFFFFFFFFFF8);
    if (!v9 || (*(unsigned char *)v9 & 4) == 0)
    {
      while ((v9[22] & 4) != 0)
        unsigned int v9 = (_WORD *)(*(void *)v9 & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if ((unsigned char *)(a2 + 48) == a4)
  {
LABEL_18:
    unint64_t v14 = *(void *)(a1 + 288);
    uint64_t v15 = *(void *)(*(void *)(v14 + 392) + 16 * *(unsigned int *)(a2 + 24) + 8);
    unsigned int v16 = (v15 >> 1) & 3;
    unint64_t v17 = v15 & 0xFFFFFFFFFFFFFFF8;
    if (v16) {
      uint64_t v18 = v17 | (2 * (v16 - 1));
    }
    else {
      uint64_t v18 = *(void *)v17 | 6;
    }
  }
  else
  {
    while (1)
    {
      unsigned int v13 = (uint64_t *)(*(void *)(a1 + 288) + 368);
      uint64_t v34 = 0;
      uint64_t v35 = a4;
      if (sub_1CB915048(v13, &v35, &v34)) {
        break;
      }
      if (!a4 || (*a4 & 4) == 0)
      {
        while ((*((_WORD *)a4 + 22) & 8) != 0)
          a4 = (unsigned char *)*((void *)a4 + 1);
      }
      a4 = (unsigned char *)*((void *)a4 + 1);
      if (a4 == (unsigned char *)(a2 + 48))
      {
        a4 = (unsigned char *)(a2 + 48);
        goto LABEL_18;
      }
    }
    uint64_t v18 = sub_1CBB24CA0(*(void *)(a1 + 288), (unint64_t)a4, 0);
    unint64_t v14 = *(void *)(a1 + 288);
  }
  llvm::SlotIndexes::repairIndexesInRange(v14, a2, (unint64_t)v9, (unint64_t)a4);
  uint64_t v35 = v37;
  uint64_t v36 = 0xC00000000;
  sub_1CB925718((unsigned int *)&v35, a5, &a5[4 * a6]);
  if (a4 != (unsigned char *)v9)
  {
    unint64_t v19 = (unint64_t)a4;
    do
    {
      unint64_t v19 = *(void *)v19 & 0xFFFFFFFFFFFFFFF8;
      if (!v19 || (*(unsigned char *)v19 & 4) == 0)
      {
        while ((*(_WORD *)(v19 + 44) & 4) != 0)
          unint64_t v19 = *(void *)v19 & 0xFFFFFFFFFFFFFFF8;
      }
      int v20 = **(unsigned __int16 **)(v19 + 16);
      if ((v20 - 13) >= 5 && v20 != 23)
      {
        uint64_t v22 = *(unsigned int *)(v19 + 40);
        if (v22)
        {
          uint64_t v23 = *(_DWORD **)(v19 + 32);
          uint64_t v24 = &v23[8 * v22];
          do
          {
            if (!*v23)
            {
              int v25 = v23[1];
              if (v25 < 0)
              {
                unint64_t v26 = v25 & 0x7FFFFFFF;
                if ((*v23 & 0xFFF00) != 0 && v26 < *(unsigned int *)(a1 + 416))
                {
                  if (*(void *)(*(void *)(a1 + 408) + 8 * v26))
                  {
                    if (!*(void *)(sub_1CC2F12AC(a1, v23[1]) + 104))
                    {
                      uint64_t v27 = *(void *)(a1 + 256);
                      if (*(unsigned char *)(v27 + 16))
                      {
                        if (*(unsigned char *)((*(void *)(*(void *)(v27 + 24) + 16 * v26) & 0xFFFFFFFFFFFFFFF8) + 34)) {
                          sub_1CBB2C0A8(a1, v25);
                        }
                      }
                    }
                  }
                }
                if (v26 >= *(unsigned int *)(a1 + 416) || !*(void *)(*(void *)(a1 + 408) + 8 * v26)) {
                  sub_1CBB2C8B4(a1, v25);
                }
              }
            }
            v23 += 8;
          }
          while (v23 != v24);
        }
      }
    }
    while ((_WORD *)v19 != v9);
  }
  unint64_t v28 = (int *)v35;
  if (v36)
  {
    uint64_t v29 = (int *)((char *)v35 + 4 * v36);
    do
    {
      int v30 = *v28;
      if (*v28 < 0)
      {
        uint64_t v31 = sub_1CC2F12AC(a1, *v28);
        if (*(_DWORD *)(v31 + 72))
        {
          int v32 = (llvm::LiveInterval *)v31;
          for (uint64_t i = *(void *)(v31 + 104); i; uint64_t i = *(void *)(i + 104))
            llvm::LiveIntervals::repairOldRegInRange(a1, (uint64_t)v9, (unint64_t)a4, v18, i, v30, *(void *)(i + 112));
          llvm::LiveInterval::removeEmptySubRanges(v32);
          llvm::LiveIntervals::repairOldRegInRange(a1, (uint64_t)v9, (unint64_t)a4, v18, (uint64_t)v32, v30, -1);
        }
      }
      ++v28;
    }
    while (v28 != v29);
    unint64_t v28 = (int *)v35;
  }
  if (v28 != (int *)v37) {
    free(v28);
  }
}

void *llvm::LiveIntervals::removePhysRegDefAt(void *result, unsigned int a2, uint64_t a3)
{
  int v4 = result;
  uint64_t v5 = result[33];
  if (v5) {
    uint64_t v6 = (void *)(v5 + 8);
  }
  else {
    uint64_t v6 = 0;
  }
  unint64_t v7 = *(unsigned int *)(*v6 + 24 * a2 + 16);
  uint64_t v8 = (_WORD *)(v6[6] + ((v7 >> 3) & 0x1FFFFFFE));
  __int16 v10 = *v8;
  unsigned int v9 = v8 + 1;
  unsigned __int16 v11 = v10 + (v7 & 0xF) * a2;
  do
  {
    uint64_t v12 = v4[85];
    uint64_t v13 = *(void *)(v12 + 8 * v11);
    if (v13)
    {
      uint64_t result = sub_1CC2F57A4(*(void *)(v12 + 8 * v11), a3);
      if (result != (void *)(*(void *)v13 + 24 * *(unsigned int *)(v13 + 8)))
      {
        uint64_t v14 = result[2];
        if (v14) {
          uint64_t result = llvm::LiveRange::removeValNo((uint64_t *)v13, v14);
        }
      }
    }
    int v15 = *v9++;
    v11 += v15;
  }
  while (v15);
  return result;
}

void llvm::callDefaultCtor<llvm::LiveIntervals>()
{
}

void *sub_1CD51AFF0(void *result)
{
  uint64_t v1 = *(unint64_t **)(*result + 440);
  unint64_t v2 = *(unsigned int *)(*result + 448);
  if (v2)
  {
    do
    {
      unint64_t v3 = v2 >> 1;
      int v4 = &v1[v2 >> 1];
      unint64_t v6 = *v4;
      uint64_t v5 = v4 + 1;
      v2 += ~(v2 >> 1);
      if (((v6 >> 1) & 3 | *(_DWORD *)((v6 & 0xFFFFFFFFFFFFFFF8) + 24)) < ((result[3] >> 1) & 3 | *(_DWORD *)((result[3] & 0xFFFFFFFFFFFFFFF8) + 24))) {
        uint64_t v1 = v5;
      }
      else {
        unint64_t v2 = v3;
      }
    }
    while (v2);
  }
  unint64_t *v1 = result[4] & 0xFFFFFFFFFFFFFFF8 | 4;
  return result;
}

llvm::raw_ostream *llvm::LiveRange::Segment::dump(llvm::LiveRange::Segment *this)
{
  unint64_t v2 = llvm::dbgs(this);
  uint64_t result = llvm::operator<<(v2, (uint64_t *)this);
  int v4 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v4 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 10);
  }
  else
  {
    *((void *)result + 4) = v4 + 1;
    unsigned char *v4 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::LiveRange::print(uint64_t **this, llvm::raw_ostream *a2)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  if (v4)
  {
    uint64_t v5 = *this;
    uint64_t v6 = 24 * v4;
    do
    {
      uint64_t result = llvm::operator<<(a2, v5);
      v5 += 3;
      v6 -= 24;
    }
    while (v6);
  }
  else
  {
    uint64_t result = sub_1CB8E509C(a2, "EMPTY");
  }
  if (*((_DWORD *)this + 18))
  {
    uint64_t v8 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v8 >= *((void *)a2 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(a2, 32);
    }
    else
    {
      *((void *)a2 + 4) = v8 + 1;
      unsigned char *v8 = 32;
    }
    uint64_t v9 = *((unsigned int *)this + 18);
    if (v9)
    {
      unint64_t v10 = 0;
      unsigned __int16 v11 = this[8];
      uint64_t v12 = 8 * v9;
      do
      {
        uint64_t v13 = v11[v10];
        if (v10)
        {
          uint64_t v14 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v14 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 32);
          }
          else
          {
            *((void *)a2 + 4) = v14 + 1;
            *uint64_t v14 = 32;
          }
        }
        uint64_t result = llvm::raw_ostream::operator<<(a2, v10);
        int v15 = (unsigned char *)*((void *)result + 4);
        if ((unint64_t)v15 >= *((void *)result + 3))
        {
          uint64_t result = llvm::raw_ostream::write(result, 64);
        }
        else
        {
          *((void *)result + 4) = v15 + 1;
          *int v15 = 64;
        }
        if (*(void *)(v13 + 8) > 7uLL)
        {
          uint64_t v17 = *(void *)(v13 + 8);
          uint64_t result = llvm::SlotIndex::print((llvm::SlotIndex *)&v17, a2);
          if ((*(unsigned char *)(v13 + 8) & 6) == 0) {
            uint64_t result = sub_1CB8E509C(a2, "-phi");
          }
        }
        else
        {
          unsigned int v16 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v16 >= *((void *)a2 + 3))
          {
            uint64_t result = llvm::raw_ostream::write(a2, 120);
          }
          else
          {
            *((void *)a2 + 4) = v16 + 1;
            unsigned char *v16 = 120;
          }
        }
        ++v10;
        v12 -= 8;
      }
      while (v12);
    }
  }
  return result;
}

void *llvm::LiveInterval::SubRange::print(llvm::LiveInterval::SubRange *this, llvm::raw_ostream *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = sub_1CB8E509C(a2, "  L");
  uint64_t v4 = *((void *)this + 14);
  uint64_t v9 = v8;
  v8[0] = &unk_1F260C990;
  v8[1] = v4;
  v7[0] = &unk_1F25FF808;
  v7[1] = "%016llX";
  v7[2] = v4;
  llvm::raw_ostream::operator<<(v3, (uint64_t)v7);
  uint64_t v5 = (unsigned char *)*((void *)v3 + 4);
  if ((unint64_t)v5 >= *((void *)v3 + 3))
  {
    unint64_t v3 = llvm::raw_ostream::write(v3, 32);
  }
  else
  {
    *((void *)v3 + 4) = v5 + 1;
    unsigned char *v5 = 32;
  }
  llvm::LiveRange::print((uint64_t **)this, v3);
  uint64_t result = v9;
  if (v9 == v8) {
    return (void *)(*(uint64_t (**)(void *))(v8[0] + 32))(v8);
  }
  if (v9) {
    return (void *)(*(uint64_t (**)(void))(*v9 + 40))();
  }
  return result;
}

llvm::raw_ostream *llvm::LiveInterval::print(llvm::LiveInterval *this, llvm::raw_ostream *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  llvm::printReg(*((_DWORD *)this + 28), 0, 0, 0, (uint64_t)v8);
  if (!v9) {
    sub_1CB920400();
  }
  (*(void (**)(void *, llvm::raw_ostream *))(*v9 + 48))(v9, a2);
  uint64_t v4 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v4 >= *((void *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 32);
  }
  else
  {
    *((void *)a2 + 4) = v4 + 1;
    unsigned char *v4 = 32;
  }
  if (v9 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v9)
  {
    (*(void (**)(void))(*v9 + 40))();
  }
  llvm::LiveRange::print((uint64_t **)this, a2);
  for (uint64_t i = (llvm::LiveInterval::SubRange *)*((void *)this + 13);
        i;
        uint64_t i = (llvm::LiveInterval::SubRange *)*((void *)i + 13))
  {
    llvm::LiveInterval::SubRange::print(i, a2);
  }
  uint64_t v6 = sub_1CB8E509C(a2, "  weight:");
  return llvm::raw_ostream::operator<<(v6, *((float *)this + 29));
}

llvm::raw_ostream *llvm::LiveRange::dump(llvm::LiveRange *this)
{
  unint64_t v2 = llvm::dbgs(this);
  uint64_t result = llvm::LiveRange::print((uint64_t **)this, v2);
  uint64_t v4 = (unsigned char *)*((void *)v2 + 4);
  if ((unint64_t)v4 >= *((void *)v2 + 3))
  {
    return llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((void *)v2 + 4) = v4 + 1;
    unsigned char *v4 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::LiveInterval::SubRange::dump(llvm::LiveInterval::SubRange *this)
{
  unint64_t v2 = llvm::dbgs(this);
  uint64_t result = (llvm::raw_ostream *)llvm::LiveInterval::SubRange::print(this, v2);
  uint64_t v4 = (unsigned char *)*((void *)v2 + 4);
  if ((unint64_t)v4 >= *((void *)v2 + 3))
  {
    return llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((void *)v2 + 4) = v4 + 1;
    unsigned char *v4 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::LiveInterval::dump(llvm::LiveInterval *this)
{
  unint64_t v2 = llvm::dbgs(this);
  uint64_t result = llvm::LiveInterval::print(this, v2);
  uint64_t v4 = (unsigned char *)*((void *)v2 + 4);
  if ((unint64_t)v4 >= *((void *)v2 + 3))
  {
    return llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((void *)v2 + 4) = v4 + 1;
    unsigned char *v4 = 10;
  }
  return result;
}

llvm::raw_ostream *llvm::LiveRangeUpdater::print(llvm::LiveRangeUpdater *this, llvm::raw_ostream *a2)
{
  unint64_t v2 = a2;
  if (*((void *)this + 1) > 7uLL)
  {
    uint64_t v4 = sub_1CB8E509C(a2, " updater with gap = ");
    uint64_t v5 = llvm::raw_ostream::operator<<(v4, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3));
    uint64_t v6 = sub_1CB8E509C(v5, ", last start = ");
    uint64_t v22 = *((void *)this + 1);
    llvm::SlotIndex::print((llvm::SlotIndex *)&v22, v6);
    sub_1CB8E509C(v6, ":\n  Area 1:");
    unint64_t v7 = **(uint64_t ***)this;
    for (uint64_t i = (uint64_t *)*((void *)this + 2); v7 != i; v7 += 3)
    {
      uint64_t v9 = (unsigned char *)*((void *)v2 + 4);
      if ((unint64_t)v9 >= *((void *)v2 + 3))
      {
        uint64_t v10 = llvm::raw_ostream::write(v2, 32);
      }
      else
      {
        *((void *)v2 + 4) = v9 + 1;
        unsigned char *v9 = 32;
        uint64_t v10 = v2;
      }
      llvm::operator<<(v10, v7);
    }
    sub_1CB8E509C(v2, "\n  Spills:");
    uint64_t v11 = *((unsigned int *)this + 10);
    if (v11)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 24 * v11;
      do
      {
        uint64_t v14 = (unsigned char *)*((void *)v2 + 4);
        if ((unint64_t)v14 >= *((void *)v2 + 3))
        {
          int v15 = llvm::raw_ostream::write(v2, 32);
        }
        else
        {
          *((void *)v2 + 4) = v14 + 1;
          *uint64_t v14 = 32;
          int v15 = v2;
        }
        llvm::operator<<(v15, (uint64_t *)(*((void *)this + 4) + v12));
        v12 += 24;
      }
      while (v13 != v12);
    }
    uint64_t result = sub_1CB8E509C(v2, "\n  Area 2:");
    uint64_t v17 = (uint64_t *)*((void *)this + 3);
    for (uint64_t j = **(void **)this + 24 * *(unsigned int *)(*(void *)this + 8); v17 != (uint64_t *)j; v17 += 3)
    {
      unint64_t v19 = (unsigned char *)*((void *)v2 + 4);
      if ((unint64_t)v19 >= *((void *)v2 + 3))
      {
        int v20 = llvm::raw_ostream::write(v2, 32);
      }
      else
      {
        *((void *)v2 + 4) = v19 + 1;
        *unint64_t v19 = 32;
        int v20 = v2;
      }
      uint64_t result = llvm::operator<<(v20, v17);
    }
    unint64_t v21 = (unsigned char *)*((void *)v2 + 4);
    if ((unint64_t)v21 >= *((void *)v2 + 3)) {
      return llvm::raw_ostream::write(v2, 10);
    }
    goto LABEL_19;
  }
  if (*(void *)this)
  {
    unint64_t v2 = sub_1CB8E509C(a2, "Clean updater: ");
    uint64_t result = llvm::LiveRange::print(*(uint64_t ***)this, v2);
    unint64_t v21 = (unsigned char *)*((void *)v2 + 4);
    if ((unint64_t)v21 < *((void *)v2 + 3))
    {
LABEL_19:
      *((void *)v2 + 4) = v21 + 1;
      *unint64_t v21 = 10;
      return result;
    }
    return llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    return sub_1CB8E509C(a2, "Null updater.\n");
  }
}

llvm::raw_ostream *llvm::LiveRangeUpdater::dump(llvm::LiveRangeUpdater *this)
{
  unint64_t v2 = (llvm::raw_ostream *)llvm::errs(this);

  return llvm::LiveRangeUpdater::print(this, v2);
}

void sub_1CD51BAC0()
{
}

void *sub_1CD51BAD4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1F260C990;
  result[1] = v3;
  return result;
}

uint64_t sub_1CD51BB1C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F260C990;
  a2[1] = v2;
  return result;
}

llvm::raw_ostream *sub_1CD51BB48(uint64_t a1, llvm::raw_ostream *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  v4[0] = &unk_1F25FF808;
  v4[1] = "%016llX";
  void v4[2] = v2;
  return llvm::raw_ostream::operator<<(a2, (uint64_t)v4);
}

void *sub_1CD51BBA4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    unint64_t v7 = a3 + 1;
    do
    {
      while (1)
      {
        uint64_t v8 = v4;
        uint64_t v9 = v4 + 4;
        uint64_t v14 = a3;
        int v15 = v7;
        uint64_t v10 = v4 + 5;
        uint64_t v12 = v4 + 4;
        uint64_t v13 = v4 + 5;
        if (!sub_1CC2FC17C((uint64_t)&v16, &v14, &v12)) {
          break;
        }
        uint64_t v4 = (void *)*v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      uint64_t v14 = v9;
      int v15 = v10;
      uint64_t v12 = a3;
      uint64_t v13 = v7;
      if (!sub_1CC2FC17C((uint64_t)&v16, &v14, &v12)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      uint64_t v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

void *llvm::LivePhysRegs::removeRegsInMask(void *result, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = result[2];
  if (v3)
  {
    uint64_t v4 = (_WORD *)result[1];
    uint64_t v5 = v4;
    do
    {
      unint64_t v6 = (unsigned __int16)*v5;
      if ((*(_DWORD *)(*(void *)(a2 + 16) + ((v6 >> 3) & 0x1FFC)) >> v6))
      {
        ++v5;
      }
      else
      {
        if (a3)
        {
          unint64_t v7 = *(unsigned int *)(a3 + 8);
          if (v7 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v8 = (unint64_t *)(*(void *)a3 + 16 * v7);
          unint64_t *v8 = v6;
          v8[1] = a2;
          ++*(_DWORD *)(a3 + 8);
          uint64_t v4 = (_WORD *)result[1];
          uint64_t v3 = result[2];
        }
        uint64_t v9 = &v4[v3 - 1];
        if (v9 != v5)
        {
          _WORD *v5 = *v9;
          *(unsigned char *)(result[6] + (unsigned __int16)*v9) = (v5 - v4) >> 1;
          uint64_t v4 = (_WORD *)result[1];
          uint64_t v3 = result[2];
        }
        result[2] = --v3;
      }
    }
    while (v5 != &v4[v3]);
  }
  return result;
}

void *llvm::LivePhysRegs::removeDefs(llvm::LivePhysRegs *this, const llvm::MachineInstr *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  sub_1CC300420((unint64_t)a2, (uint64_t)v19);
  long long v13 = v19[0];
  long long v14 = v19[1];
  long long v15 = v19[2];
  long long v16 = v19[3];
  if (v21)
  {
    if (v21 == &v20)
    {
      uint64_t v18 = v17;
      (*(void (**)(void))(*v21 + 24))();
    }
    else
    {
      uint64_t v18 = (void *)(*(uint64_t (**)(void))(*v21 + 16))();
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  uint64_t v9 = v22;
  long long v10 = v23;
  if (v25)
  {
    if (v25 == &v24)
    {
      uint64_t v12 = v11;
      (*(void (**)(void))(*v25 + 24))();
    }
    else
    {
      uint64_t v12 = (void *)(*(uint64_t (**)(void))(*v25 + 16))();
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  while (1)
  {
    uint64_t v3 = v14;
    if ((void)v13 == v9)
    {
      if ((void)v14 == (void)v10) {
        break;
      }
      if ((void)v14 == *((void *)&v14 + 1) && (void)v10 == *((void *)&v10 + 1)) {
        break;
      }
    }
    if (*(_DWORD *)v14 == 12)
    {
      llvm::LivePhysRegs::removeRegsInMask(this, v14, 0);
    }
    else if ((*(_DWORD *)v14 & 0x1000000) != 0)
    {
      sub_1CD51C088((uint64_t *)this, *(unsigned __int16 *)(v14 + 4));
    }
    *(void *)&long long v14 = v14 + 32;
    if ((void)v14 == *((void *)&v14 + 1))
    {
      uint64_t v5 = v13;
      while (1)
      {
        uint64_t v5 = *(void *)(v5 + 8);
        if (v5 == *((void *)&v13 + 1) || (*(_WORD *)(v5 + 44) & 4) == 0) {
          break;
        }
        uint64_t v6 = *(unsigned int *)(v5 + 40);
        uint64_t v7 = *(void *)(v5 + 32) + 32 * v6;
        *(void *)&long long v14 = *(void *)(v5 + 32);
        *((void *)&v14 + 1) = v7;
        if (v6)
        {
          *(void *)&long long v13 = v5;
          goto LABEL_12;
        }
      }
      *(void *)&long long v13 = *((void *)&v13 + 1);
    }
LABEL_12:
    sub_1CC300E50((uint64_t *)&v13);
  }
  if (v12 == v11)
  {
    (*(void (**)(void *, void))(v11[0] + 32))(v11, v14);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  if (v18 == v17)
  {
    (*(void (**)(void *, uint64_t))(v17[0] + 32))(v17, v3);
  }
  else if (v18)
  {
    (*(void (**)(void))(*v18 + 40))();
  }
  return sub_1CC30104C(v19);
}

uint64_t sub_1CD51C088(uint64_t *a1, unsigned int a2)
{
  if (*a1) {
    uint64_t v3 = (void *)(*a1 + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t result = sub_1CB8FB608((uint64_t)v8, a2, v3, 1);
  if (v10)
  {
    uint64_t v5 = a1 + 1;
    do
    {
LABEL_6:
      unsigned __int16 v7 = v11;
      sub_1CC300FC8(v5, &v7);
      while (1)
      {
        uint64_t result = sub_1CB8FB704((uint64_t)v8);
        if (v9 || v10 == 0) {
          break;
        }
        if (v8[0] != v11) {
          goto LABEL_6;
        }
      }
    }
    while (v10);
  }
  return result;
}

void *llvm::LivePhysRegs::addUses(llvm::LivePhysRegs *this, const llvm::MachineInstr *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  sub_1CC300420((unint64_t)a2, (uint64_t)v20);
  long long v14 = v20[0];
  long long v15 = v20[1];
  long long v16 = v20[2];
  long long v17 = v20[3];
  if (v22)
  {
    if (v22 == &v21)
    {
      unint64_t v19 = v18;
      (*(void (**)(void))(*v22 + 24))();
    }
    else
    {
      unint64_t v19 = (void *)(*(uint64_t (**)(void))(*v22 + 16))();
    }
  }
  else
  {
    unint64_t v19 = 0;
  }
  uint64_t v10 = v23;
  long long v11 = v24;
  if (v26)
  {
    if (v26 == &v25)
    {
      long long v13 = v12;
      (*(void (**)(void))(*v26 + 24))();
    }
    else
    {
      long long v13 = (void *)(*(uint64_t (**)(void))(*v26 + 16))();
    }
  }
  else
  {
    long long v13 = 0;
  }
  while (1)
  {
    uint64_t v3 = v15;
    if ((void)v14 == v10)
    {
      if ((void)v15 == (void)v11) {
        break;
      }
      if ((void)v15 == *((void *)&v15 + 1) && (void)v11 == *((void *)&v11 + 1)) {
        break;
      }
    }
    if ((*(_DWORD *)v15 & 0x300000FF) == 0 && (*(_DWORD *)v15 & 0x10FFF00) != 0x1000000)
    {
      sub_1CD51C45C((uint64_t *)this, *(unsigned __int16 *)(v15 + 4));
      uint64_t v3 = v15;
    }
    *(void *)&long long v15 = v3 + 32;
    if (v3 + 32 == *((void *)&v15 + 1))
    {
      uint64_t v6 = v14;
      while (1)
      {
        uint64_t v6 = *(void *)(v6 + 8);
        if (v6 == *((void *)&v14 + 1) || (*(_WORD *)(v6 + 44) & 4) == 0) {
          break;
        }
        uint64_t v7 = *(unsigned int *)(v6 + 40);
        uint64_t v8 = *(void *)(v6 + 32) + 32 * v7;
        *(void *)&long long v15 = *(void *)(v6 + 32);
        *((void *)&v15 + 1) = v8;
        if (v7)
        {
          *(void *)&long long v14 = v6;
          goto LABEL_14;
        }
      }
      *(void *)&long long v14 = *((void *)&v14 + 1);
    }
LABEL_14:
    sub_1CC300E50((uint64_t *)&v14);
  }
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
  }
  else if (v13)
  {
    (*(void (**)(void))(*v13 + 40))();
  }
  if (v19 == v18)
  {
    (*(void (**)(void *))(v18[0] + 32))(v18);
  }
  else if (v19)
  {
    (*(void (**)(void))(*v19 + 40))();
  }
  return sub_1CC30104C(v20);
}

uint64_t *sub_1CD51C45C(uint64_t *result, unsigned int a2)
{
  uint64_t v2 = (void *)(*result + 8);
  if (!*result) {
    uint64_t v2 = 0;
  }
  uint64_t v3 = v2[6];
  if (v3)
  {
    unsigned int v4 = a2;
    uint64_t v5 = (unsigned __int16 *)(v3 + 2 * *(unsigned int *)(*v2 + 24 * a2 + 4));
    uint64_t v6 = result + 1;
    do
    {
      __int16 v8 = v4;
      uint64_t result = (uint64_t *)sub_1CD515E0C(v6, &v8);
      int v7 = *v5++;
      v4 += v7;
    }
    while (v7);
  }
  return result;
}

void *llvm::LivePhysRegs::stepBackward(llvm::LivePhysRegs *this, const llvm::MachineInstr *a2)
{
  llvm::LivePhysRegs::removeDefs(this, a2);

  return llvm::LivePhysRegs::addUses(this, a2);
}

uint64_t llvm::LivePhysRegs::stepForward(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t result = (uint64_t)sub_1CC301138(&v20, a2);
  uint64_t v6 = v22;
  if (v22 != v23)
  {
    do
    {
      unsigned int v7 = *v6;
      if (*v6)
      {
        if (*v6 == 12) {
          uint64_t result = (uint64_t)llvm::LivePhysRegs::removeRegsInMask(a1, (unint64_t)v6, a3);
        }
      }
      else if ((v7 & 0x80000000) == 0 && v6[1] - 1 <= 0x3FFFFFFE)
      {
        if ((v7 & 0x1000000) != 0)
        {
          unint64_t v12 = *(unsigned int *)(a3 + 8);
          if (v12 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          long long v13 = (void *)(*(void *)a3 + 16 * v12);
          *long long v13 = (unsigned __int16)v6[1];
          v13[1] = v6;
          ++*(_DWORD *)(a3 + 8);
        }
        else if ((v7 >> 26) & ~HIBYTE(v7))
        {
          uint64_t result = sub_1CD51C088(a1, (unsigned __int16)v6[1]);
        }
      }
      __int16 v8 = v23;
      char v9 = v22 + 8;
      uint64_t v22 = v9;
      if (v9 == v23)
      {
        uint64_t v10 = *(void *)(v20 + 8);
        if (v10 == v21)
        {
          uint64_t v6 = v9;
        }
        else
        {
          uint64_t v6 = v9;
          if ((*(_WORD *)(v10 + 44) & 4) != 0)
          {
            while (1)
            {
              uint64_t v6 = *(unsigned int **)(v10 + 32);
              uint64_t v11 = *(unsigned int *)(v10 + 40);
              __int16 v8 = &v6[8 * v11];
              if (v11) {
                break;
              }
              uint64_t v10 = *(void *)(v10 + 8);
              if (v10 == v21 || (*(_WORD *)(v10 + 44) & 4) == 0)
              {
                uint64_t v22 = v6;
                uint64_t v23 = &v6[8 * v11];
                char v9 = v23;
                goto LABEL_21;
              }
            }
            uint64_t v22 = *(unsigned int **)(v10 + 32);
            uint64_t v23 = &v6[8 * v11];
            uint64_t v20 = v10;
            continue;
          }
        }
LABEL_21:
        uint64_t v20 = v21;
        __int16 v8 = v9;
      }
      else
      {
        uint64_t v6 = v9;
      }
    }
    while (v6 != v8);
  }
  uint64_t v14 = *(unsigned int *)(a3 + 8);
  if (v14)
  {
    long long v15 = *(unsigned __int16 **)a3;
    long long v16 = &v15[8 * v14];
    do
    {
      unsigned int v17 = *v15;
      uint64_t v18 = *((void *)v15 + 1);
      if (*(_DWORD *)v18 == 12)
      {
        if (((*(_DWORD *)(*(void *)(v18 + 16) + 4 * (v17 >> 5)) >> v17) & 1) == 0) {
          goto LABEL_34;
        }
      }
      else
      {
        if (*(_DWORD *)v18) {
          BOOL v19 = 0;
        }
        else {
          BOOL v19 = (~*(_DWORD *)v18 & 0x5000000) == 0;
        }
        if (v19) {
          goto LABEL_34;
        }
      }
      uint64_t result = (uint64_t)sub_1CD51C45C(a1, v17);
LABEL_34:
      v15 += 8;
    }
    while (v15 != v16);
  }
  return result;
}

llvm::raw_ostream *llvm::LivePhysRegs::print(llvm::LivePhysRegs *this, llvm::raw_ostream *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  sub_1CB8E509C(a2, "Live Registers:");
  if (*(void *)this)
  {
    uint64_t v4 = *((void *)this + 2);
    if (v4)
    {
      uint64_t v5 = (unsigned __int16 *)*((void *)this + 1);
      uint64_t v6 = 2 * v4;
      do
      {
        int v7 = *v5;
        __int16 v8 = sub_1CB8E509C(a2, " ");
        llvm::printReg(v7, *(void *)this, 0, 0, (uint64_t)v11);
        if (!v12) {
          sub_1CB920400();
        }
        (*(void (**)(void *, llvm::raw_ostream *))(*v12 + 48))(v12, v8);
        if (v12 == v11)
        {
          (*(void (**)(void *))(v11[0] + 32))(v11);
        }
        else if (v12)
        {
          (*(void (**)(void))(*v12 + 40))();
        }
        ++v5;
        v6 -= 2;
      }
      while (v6);
      return sub_1CB8E509C(a2, "\n");
    }
    uint64_t v10 = " (empty)\n";
  }
  else
  {
    uint64_t v10 = " (uninitialized)\n";
  }

  return sub_1CB8E509C(a2, v10);
}

llvm::raw_ostream *llvm::LivePhysRegs::dump(llvm::LivePhysRegs *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = sub_1CB8E509C(v2, "  ");

  return llvm::LivePhysRegs::print(this, v3);
}

uint64_t llvm::LivePhysRegs::available(llvm::LivePhysRegs *this, const llvm::MachineRegisterInfo *a2, unsigned int a3)
{
  unsigned int v6 = *(unsigned __int8 *)(*((void *)this + 6) + a3);
  uint64_t v7 = *((void *)this + 2);
  if (v6 < v7)
  {
    while (1)
    {
      unsigned int v8 = v6;
      if (*(unsigned __int16 *)(*((void *)this + 1) + 2 * v6) == a3) {
        break;
      }
      v6 += 256;
      if (v8 + 256 >= v7) {
        goto LABEL_4;
      }
    }
    if (v7 != v6) {
      return 0;
    }
  }
LABEL_4:
  if ((*(void *)(*((void *)a2 + 44) + (((unint64_t)a3 >> 3) & 0x1FF8)) >> a3)) {
    return 0;
  }
  if (*(void *)this) {
    uint64_t v10 = (void *)(*(void *)this + 8);
  }
  else {
    uint64_t v10 = 0;
  }
  sub_1CB8FB608((uint64_t)v15, a3, v10, 0);
  while (v17)
  {
LABEL_11:
    unsigned int v11 = *(unsigned __int8 *)(*((void *)this + 6) + v18);
    uint64_t v12 = *((void *)this + 2);
    if (v11 >= v12) {
      goto LABEL_16;
    }
    do
    {
      unsigned int v13 = v11;
      if (*(unsigned __int16 *)(*((void *)this + 1) + 2 * v11) == v18)
      {
        if (v12 == v11) {
          break;
        }
        return 0;
      }
      v11 += 256;
    }
    while (v13 + 256 < v12);
LABEL_16:
    while (1)
    {
      sub_1CB8FB704((uint64_t)v15);
      if (v16 || v17 == 0) {
        break;
      }
      if (v15[0] != v18) {
        goto LABEL_11;
      }
    }
  }
  return 1;
}

uint64_t *llvm::LivePhysRegs::addBlockLiveIns(llvm::LivePhysRegs *this, unsigned __int16 **a2)
{
  uint64_t result = (uint64_t *)llvm::MachineBasicBlock::livein_begin((llvm::MachineBasicBlock *)a2);
  uint64_t v5 = a2[20];
  if (v5 != (unsigned __int16 *)result)
  {
    unsigned int v6 = result;
    do
    {
      unsigned int v7 = *(unsigned __int16 *)v6;
      uint64_t v8 = v6[1];
      char v9 = (void *)(*(void *)this + 8);
      if (!*(void *)this) {
        char v9 = 0;
      }
      if (v8 == -1
        || (uint64_t v10 = v9[6], v11 = *(unsigned int *)(*v9 + 24 * *(unsigned __int16 *)v6 + 4), !*(_WORD *)(v10 + 2 * v11)))
      {
        uint64_t result = sub_1CD51C45C((uint64_t *)this, v7);
      }
      else
      {
        unsigned __int16 v12 = *(_WORD *)(v10 + 2 * v11) + v7;
        unsigned int v13 = (unsigned __int16 *)(v9[10] + 2 * *(unsigned int *)(*v9 + 24 * *(unsigned __int16 *)v6 + 12));
        uint64_t v14 = (unsigned __int16 *)(v10 + 2 * v11 + 2);
        do
        {
          if ((*(void *)(*(void *)(*(void *)this + 232) + 8 * *v13) & v8) != 0) {
            uint64_t result = sub_1CD51C45C((uint64_t *)this, v12);
          }
          int v15 = *v14++;
          v12 += v15;
          ++v13;
        }
        while (v15);
      }
      v6 += 2;
    }
    while (v6 != (uint64_t *)v5);
  }
  return result;
}

void llvm::LivePhysRegs::addPristines(llvm::LivePhysRegs *this, const llvm::MachineFunction *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)a2 + 7);
  if (*(unsigned char *)(v2 + 104))
  {
    if (*((void *)this + 2))
    {
      uint64_t v5 = *(void *)this;
      uint64_t v24 = v5;
      uint64_t v25 = v27;
      long long v26 = xmmword_1CD96EEC0;
      unint64_t v28 = 0;
      int v29 = 0;
      int v6 = *(_DWORD *)(v5 + 16);
      if (v6)
      {
        unint64_t v28 = sub_1CC248524(*(unsigned int *)(v5 + 16), 1uLL);
        int v29 = v6;
      }
      CalleeSavedRegs = (unsigned __int16 *)llvm::MachineRegisterInfo::getCalleeSavedRegs(*((llvm::MachineRegisterInfo **)a2
                                                                                          + 5));
      if (CalleeSavedRegs)
      {
        unsigned __int16 v8 = *CalleeSavedRegs;
        if (*CalleeSavedRegs)
        {
          char v9 = CalleeSavedRegs + 1;
          do
          {
            sub_1CD51C45C(&v24, v8);
            int v10 = *v9++;
            unsigned __int16 v8 = v10;
          }
          while (v10);
        }
      }
      uint64_t v11 = *(unsigned __int16 **)(v2 + 80);
      unsigned __int16 v12 = *(unsigned __int16 **)(v2 + 88);
      while (v11 != v12)
      {
        unsigned int v13 = *v11;
        v11 += 6;
        sub_1CD51C088(&v24, v13);
      }
      if ((void)v26)
      {
        uint64_t v14 = (unsigned __int16 *)v25;
        uint64_t v15 = 2 * v26;
        do
        {
          unsigned int v16 = *v14++;
          sub_1CD51C45C((uint64_t *)this, v16);
          v15 -= 2;
        }
        while (v15);
      }
      free(v28);
      if (v25 != v27) {
        free(v25);
      }
    }
    else
    {
      uint64_t v17 = (unsigned __int16 *)llvm::MachineRegisterInfo::getCalleeSavedRegs(*((llvm::MachineRegisterInfo **)a2 + 5));
      if (v17)
      {
        unsigned __int16 v18 = *v17;
        if (*v17)
        {
          BOOL v19 = v17 + 1;
          do
          {
            sub_1CD51C45C((uint64_t *)this, v18);
            int v20 = *v19++;
            unsigned __int16 v18 = v20;
          }
          while (v20);
        }
      }
      uint64_t v21 = *(unsigned __int16 **)(v2 + 80);
      uint64_t v22 = *(unsigned __int16 **)(v2 + 88);
      while (v21 != v22)
      {
        unsigned int v23 = *v21;
        v21 += 6;
        sub_1CD51C088((uint64_t *)this, v23);
      }
    }
  }
}

uint64_t *llvm::LivePhysRegs::addLiveOutsNoPristines(llvm::LivePhysRegs *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v4 = (unsigned __int16 ***)*((void *)a2 + 11);
  uint64_t v5 = (unsigned __int16 ***)*((void *)a2 + 12);
  while (v4 != v5)
  {
    int v6 = *v4++;
    llvm::LivePhysRegs::addBlockLiveIns(this, v6);
  }
  uint64_t result = (uint64_t *)sub_1CC234048((uint64_t)a2);
  if (result)
  {
    uint64_t v8 = *(void *)(*((void *)a2 + 4) + 56);
    if (*(unsigned char *)(v8 + 104))
    {
      char v9 = *(unsigned __int16 **)(v8 + 80);
      int v10 = *(unsigned __int16 **)(v8 + 88);
      while (v9 != v10)
      {
        if (*((unsigned char *)v9 + 8)) {
          uint64_t result = sub_1CD51C45C((uint64_t *)this, *v9);
        }
        v9 += 6;
      }
    }
  }
  return result;
}

uint64_t *llvm::LivePhysRegs::addLiveOuts(llvm::LivePhysRegs *this, const llvm::MachineFunction **a2)
{
  llvm::LivePhysRegs::addPristines(this, a2[4]);

  return llvm::LivePhysRegs::addLiveOutsNoPristines(this, (const llvm::MachineBasicBlock *)a2);
}

uint64_t *llvm::computeLiveIns(llvm *this, llvm::LivePhysRegs *a2, const llvm::MachineBasicBlock *a3)
{
  uint64_t v5 = *(void *)(**(void **)(*((void *)a2 + 4) + 40) + 16);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 176))(v5);
  *(void *)this = v6;
  *((void *)this + 2) = 0;
  sub_1CD50BAB8((char *)this + 8, *(_DWORD *)(v6 + 16));
  uint64_t result = llvm::LivePhysRegs::addLiveOutsNoPristines(this, a2);
  uint64_t v9 = *((void *)a2 + 6);
  uint64_t v8 = (llvm::LivePhysRegs *)((char *)a2 + 48);
  int v10 = (const llvm::MachineInstr *)(v9 & 0xFFFFFFFFFFFFFFF8);
  if ((v9 & 0xFFFFFFFFFFFFFFF8) == 0 || (*(unsigned char *)v10 & 4) == 0)
  {
    while ((*((_WORD *)v10 + 22) & 4) != 0)
      int v10 = (const llvm::MachineInstr *)(*(void *)v10 & 0xFFFFFFFFFFFFFFF8);
  }
  while (v10 != v8)
  {
    llvm::LivePhysRegs::removeDefs(this, v10);
    uint64_t result = llvm::LivePhysRegs::addUses(this, v10);
    int v10 = (const llvm::MachineInstr *)(*(void *)v10 & 0xFFFFFFFFFFFFFFF8);
    if (!v10 || (*(unsigned char *)v10 & 4) == 0)
    {
      while ((*((_WORD *)v10 + 22) & 4) != 0)
        int v10 = (const llvm::MachineInstr *)(*(void *)v10 & 0xFFFFFFFFFFFFFFF8);
    }
  }
  return result;
}

_OWORD *llvm::addLiveIns(llvm *this, llvm::MachineBasicBlock *a2, const llvm::LivePhysRegs *a3)
{
  uint64_t v5 = *(void **)(*((void *)this + 4) + 40);
  uint64_t result = (_OWORD *)(*(uint64_t (**)(void, llvm::MachineBasicBlock *, const llvm::LivePhysRegs *))(**(void **)(*v5 + 16) + 176))(*(void *)(*v5 + 16), a2, a3);
  uint64_t v7 = *((void *)a2 + 2);
  if (v7)
  {
    uint64_t v8 = (_WORD *)*((void *)a2 + 1);
    uint64_t v9 = &v8[v7];
    if (result) {
      int v10 = (void *)result + 1;
    }
    else {
      int v10 = 0;
    }
    do
    {
      unint64_t v11 = (unsigned __int16)*v8;
      uint64_t v12 = v5[44];
      if (((*(void *)(v12 + ((v11 >> 3) & 0x1FF8)) >> v11) & 1) == 0)
      {
        unsigned int v13 = (_WORD *)(v10[6] + 2 * *(unsigned int *)(*v10 + 24 * (unsigned __int16)*v8 + 8));
        if (*v13)
        {
          unsigned __int16 v14 = *v13 + v11;
          uint64_t v15 = *((void *)a2 + 2);
          while (2)
          {
            for (unsigned int i = *(unsigned __int8 *)(*((void *)a2 + 6) + v14); i < v15; i += 256)
            {
              if (*(unsigned __int16 *)(*((void *)a2 + 1) + 2 * i) == v14)
              {
                if (v15 != i && ((*(void *)(v12 + (((unint64_t)v14 >> 3) & 0x1FF8)) >> v14) & 1) == 0) {
                  goto LABEL_6;
                }
                break;
              }
            }
            int v17 = (unsigned __int16)v13[1];
            ++v13;
            v14 += v17;
            if (v17) {
              continue;
            }
            break;
          }
        }
        LOWORD(v19) = *v8;
        *((void *)&v19 + 1) = -1;
        unsigned __int16 v18 = (_OWORD *)*((void *)this + 20);
        if ((unint64_t)v18 >= *((void *)this + 21))
        {
          uint64_t result = sub_1CC016940((void **)this + 19, &v19);
        }
        else
        {
          _OWORD *v18 = v19;
          uint64_t result = v18 + 1;
        }
        *((void *)this + 20) = result;
      }
LABEL_6:
      ++v8;
    }
    while (v8 != v9);
  }
  return result;
}

void llvm::recomputeLivenessFlags(llvm *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 4);
  uint64_t v4 = *(const llvm::MachineRegisterInfo **)(v3 + 40);
  uint64_t v5 = (*(uint64_t (**)(void, llvm::MachineBasicBlock *))(**(void **)(*(void *)v4 + 16) + 176))(*(void *)(*(void *)v4 + 16), a2);
  uint64_t v6 = *(void *)(v3 + 56);
  uint64_t v35 = 0;
  int v36 = 0;
  uint64_t v31 = v5;
  int v32 = v34;
  long long v33 = xmmword_1CD96EEC0;
  int v7 = *(_DWORD *)(v5 + 16);
  if (v7)
  {
    uint64_t v35 = sub_1CC248524(*(unsigned int *)(v5 + 16), 1uLL);
    int v36 = v7;
  }
  llvm::LivePhysRegs::addLiveOutsNoPristines((llvm::LivePhysRegs *)&v31, this);
  uint64_t v9 = *((void *)this + 6);
  uint64_t v8 = (char *)this + 48;
  unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFF8;
  if ((v9 & 0xFFFFFFFFFFFFFFF8) == 0 || (*(unsigned char *)v10 & 4) == 0)
  {
    while ((*(_WORD *)(v10 + 44) & 4) != 0)
      unint64_t v10 = *(void *)v10 & 0xFFFFFFFFFFFFFFF8;
  }
  long long v26 = v8;
  if ((char *)v10 != v8)
  {
LABEL_9:
    sub_1CC2F68F8(&v27, v10);
    uint64_t v12 = v29;
    unint64_t v11 = v30;
    while (v12 != v11)
    {
      if ((*v12 & 0x810000FF) == 0x1000000)
      {
        unsigned int v13 = v12[1];
        if (v13)
        {
          int v16 = llvm::LivePhysRegs::available((llvm::LivePhysRegs *)&v31, v4, (unsigned __int16)v12[1]);
          if ((*(_WORD *)(v10 + 44) & 0xC) != 0 && (*(_WORD *)(v10 + 44) & 4) == 0)
          {
            if (!llvm::MachineInstr::hasPropertyInBundle(v10, 32, 1))
            {
LABEL_37:
              if (v16) {
                int v19 = 0x4000000;
              }
              else {
                int v19 = 0;
              }
              *int v29 = *v29 & 0xFBFFFFFF | v19;
              uint64_t v12 = v29;
              unint64_t v11 = v30;
              goto LABEL_13;
            }
          }
          else if ((*(unsigned char *)(*(void *)(v10 + 16) + 8) & 0x20) == 0)
          {
            goto LABEL_37;
          }
          if (*(unsigned char *)(v6 + 104))
          {
            for (uint64_t i = *(void *)(v6 + 80); i != *(void *)(v6 + 88); i += 12)
            {
              if (*(_DWORD *)i == v13)
              {
                LOBYTE(v16) = *(unsigned char *)(i + 8) ^ 1;
                break;
              }
            }
            v16 &= 1u;
          }
          goto LABEL_37;
        }
      }
LABEL_13:
      v12 += 8;
      int v29 = v12;
      if (v12 == v11)
      {
        uint64_t v14 = *(void *)(v27 + 8);
        if (v14 == v28)
        {
          uint64_t v12 = v11;
LABEL_21:
          uint64_t v27 = v28;
        }
        else
        {
          uint64_t v12 = v11;
          if ((*(_WORD *)(v14 + 44) & 4) == 0) {
            goto LABEL_21;
          }
          while (1)
          {
            uint64_t v12 = *(unsigned int **)(v14 + 32);
            uint64_t v15 = *(unsigned int *)(v14 + 40);
            unint64_t v11 = &v12[8 * v15];
            if (v15) {
              break;
            }
            uint64_t v14 = *(void *)(v14 + 8);
            if (v14 == v28 || (*(_WORD *)(v14 + 44) & 4) == 0)
            {
              int v29 = v12;
              uint64_t v30 = &v12[8 * v15];
              unint64_t v11 = v30;
              goto LABEL_21;
            }
          }
          int v29 = *(unsigned int **)(v14 + 32);
          uint64_t v30 = &v12[8 * v15];
          uint64_t v27 = v14;
        }
      }
    }
    llvm::LivePhysRegs::removeDefs((llvm::LivePhysRegs *)&v31, (const llvm::MachineInstr *)v10);
    sub_1CC2F68F8(&v27, v10);
    uint64_t v21 = v29;
    int v20 = v30;
    while (1)
    {
      while (1)
      {
        do
        {
          if (v21 == v20)
          {
            llvm::LivePhysRegs::addUses((llvm::LivePhysRegs *)&v31, (const llvm::MachineInstr *)v10);
            unint64_t v10 = *(void *)v10 & 0xFFFFFFFFFFFFFFF8;
            if (!v10 || (*(unsigned char *)v10 & 4) == 0)
            {
              while ((*(_WORD *)(v10 + 44) & 4) != 0)
                unint64_t v10 = *(void *)v10 & 0xFFFFFFFFFFFFFFF8;
            }
            if ((char *)v10 == v26) {
              goto LABEL_68;
            }
            goto LABEL_9;
          }
          BOOL v22 = (*v21 & 0xB00000FF) != 0 || (*v21 & 0x10FFF00) == 0x1000000;
          if (!v22 && v21[1])
          {
            if (llvm::LivePhysRegs::available((llvm::LivePhysRegs *)&v31, v4, (unsigned __int16)v21[1])) {
              int v25 = 0x4000000;
            }
            else {
              int v25 = 0;
            }
            *int v29 = *v29 & 0xFBFFFFFF | v25;
            uint64_t v21 = v29;
            int v20 = v30;
          }
          v21 += 8;
          int v29 = v21;
        }
        while (v21 != v20);
        uint64_t v23 = *(void *)(v27 + 8);
        if (v23 != v28) {
          break;
        }
        uint64_t v21 = v20;
LABEL_56:
        uint64_t v27 = v28;
      }
      uint64_t v21 = v20;
      if ((*(_WORD *)(v23 + 44) & 4) == 0) {
        goto LABEL_56;
      }
      while (1)
      {
        uint64_t v21 = *(unsigned int **)(v23 + 32);
        uint64_t v24 = *(unsigned int *)(v23 + 40);
        int v20 = &v21[8 * v24];
        if (v24) {
          break;
        }
        uint64_t v23 = *(void *)(v23 + 8);
        if (v23 == v28 || (*(_WORD *)(v23 + 44) & 4) == 0)
        {
          int v29 = v21;
          uint64_t v30 = &v21[8 * v24];
          int v20 = v30;
          goto LABEL_56;
        }
      }
      int v29 = *(unsigned int **)(v23 + 32);
      uint64_t v30 = &v21[8 * v24];
      uint64_t v27 = v23;
    }
  }
LABEL_68:
  free(v35);
  if (v32 != v34) {
    free(v32);
  }
}

_OWORD *llvm::computeAndAddLiveIns(llvm *this, llvm::LivePhysRegs *a2, llvm::MachineBasicBlock *a3)
{
  llvm::computeLiveIns(this, a2, a3);

  return llvm::addLiveIns(a2, this, v5);
}

void sub_1CD51D474()
{
}

void *sub_1CD51D488()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F260C9D8;
  return result;
}

void sub_1CD51D4C4(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC302FD0((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint64_t v5 = *(void **)a1;
      uint64_t v6 = 152 * v4;
      do
      {
        void *v5 = -4096;
        v5 += 19;
        v6 -= 152;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC260D48(a1, v4);
  }
}

void sub_1CD51D578(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 152 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 19;
      v8 -= 152;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      unsigned int v13 = 0;
      sub_1CC303054(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      unint64_t v10 = v13;
      *unsigned int v13 = *a2;
      sub_1CC302E54((uint64_t)(v10 + 1), (uint64_t)(a2 + 1));
      ++*(_DWORD *)(a1 + 8);
      unint64_t v11 = (uint64_t *)a2[10];
      if (a2 + 12 != v11) {
        free(v11);
      }
      uint64_t v12 = (uint64_t *)a2[1];
      if (a2 + 3 != v12) {
        free(v12);
      }
    }
    a2 += 19;
  }
}

void sub_1CD51D664(void *a1)
{
  sub_1CD516CC4(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::initializeLiveRangeShrinkPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD460, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3075B4;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCCD460, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

_DWORD *sub_1CD51D714(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD5199E4(result);
    }
    else
    {
      if (v1)
      {
        int v2 = *(_DWORD **)result;
        uint64_t v3 = 24 * v1;
        do
        {
          *int v2 = -1;
          v2 += 6;
          v3 -= 24;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

void *sub_1CD51D768(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CBA0E618(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CB9A052C(a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
  }
  return v5;
}

_DWORD *sub_1CD51D7CC(uint64_t a1, int *a2)
{
  int v7 = 0;
  char v4 = sub_1CD4F8538(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4F85D4(a1, a2, v7);
    _DWORD *v5 = *a2;
    void v5[2] = 0;
    *((void *)v5 + 2) = 0;
  }
  return v5;
}

void llvm::initializeLiveRegMatrixPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD468, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC308430;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCD468, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

double llvm::LiveRegMatrix::LiveRegMatrix(llvm::LiveRegMatrix *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::LiveRegMatrix::ID);
  *(void *)uint64_t v1 = &unk_1F260CBA0;
  *(_DWORD *)(v1 + 272) = 0;
  *(void *)(v1 + 280) = 0;
  *(void *)(v1 + 288) = 0;
  *(void *)(v1 + 296) = 0;
  *(void *)(v1 + 304) = v1 + 320;
  *(void *)(v1 + 312) = 0x400000000;
  *(void *)(v1 + 352) = v1 + 368;
  *(void *)(v1 + 360) = 0;
  *(void *)(v1 + 368) = 0;
  *(void *)(v1 + 376) = 1;
  *(_DWORD *)(v1 + 384) = 0;
  *(void *)(v1 + 392) = 0;
  *(void *)(v1 + 400) = 0;
  *(void *)(v1 + 408) = 0;
  *(void *)(v1 + 416) = v1 + 432;
  *(void *)&double result = 0x600000000;
  *(void *)(v1 + 424) = 0x600000000;
  *(_DWORD *)(v1 + 480) = 0;
  return result;
}

void llvm::LiveRegMatrix::getAnalysisUsage(llvm::LiveRegMatrix *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::LiveIntervals::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::VirtRegMap::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

void sub_1CD51D9A0(void *a1)
{
  sub_1CD51DA14(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::LiveRegMatrix>()
{
}

void sub_1CD51DA14(void *a1)
{
  *a1 = &unk_1F260CBA0;
  int v2 = (void *)a1[52];
  if (v2 != a1 + 54) {
    free(v2);
  }
  uint64_t v3 = a1[50];
  a1[50] = 0;
  if (v3) {
    sub_1CBB2333C((uint64_t)(a1 + 50), v3);
  }
  llvm::LiveIntervalUnion::Array::clear((llvm::LiveIntervalUnion::Array *)(a1 + 48));
  a1[35] = 0;
  sub_1CBFFBA64((uint64_t)(a1 + 36));

  sub_1CBA0E6AC((llvm::Pass *)a1);
}

void llvm::initializeLiveStacksPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD470, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC30AB08;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCD470, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::LiveStacks::getAnalysisUsage(llvm::LiveStacks *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)&llvm::SlotIndexes::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, (char *)&llvm::SlotIndexes::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

llvm::raw_ostream *llvm::LiveStacks::print(llvm::LiveStacks *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  double result = sub_1CB8E509C(a2, "********** INTERVALS **********\n");
  unsigned int v6 = (uint64_t *)*((void *)this + 46);
  if (v6)
  {
    int v7 = (char **)((char *)this + 400);
    do
    {
      llvm::LiveInterval::print((llvm::LiveInterval *)(v6 + 3), a2);
      uint64_t v8 = *v7;
      if (!*v7) {
        goto LABEL_13;
      }
      int v9 = *((_DWORD *)v6 + 4);
      unint64_t v10 = (char **)((char *)this + 400);
      do
      {
        int v11 = *((_DWORD *)v8 + 8);
        BOOL v12 = v11 < v9;
        if (v11 >= v9) {
          unsigned int v13 = (char **)v8;
        }
        else {
          unsigned int v13 = (char **)(v8 + 8);
        }
        if (!v12) {
          unint64_t v10 = (char **)v8;
        }
        uint64_t v8 = *v13;
      }
      while (*v13);
      if (v10 == v7 || *((_DWORD *)v10 + 8) > v9) {
LABEL_13:
      }
        unint64_t v10 = (char **)((char *)this + 400);
      uint64_t v14 = v10[5];
      if (v14)
      {
        uint64_t v15 = sub_1CB8E509C(a2, " [");
        int v16 = sub_1CB8E509C(v15, (char *)(*(void *)(*((void *)this + 31) + 80) + *(unsigned int *)(*(void *)v14 + 16)));
        int v17 = "]\n";
      }
      else
      {
        int v16 = a2;
        int v17 = " [Unknown]\n";
      }
      double result = sub_1CB8E509C(v16, v17);
      unsigned int v6 = (uint64_t *)*v6;
    }
    while (v6);
  }
  return result;
}

void sub_1CD51DC94(uint64_t a1)
{
  sub_1CD51DDFC(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::LiveStacks>()
{
}

uint64_t sub_1CD51DD08(uint64_t a1)
{
  sub_1CB8483A0(a1, (uint64_t)&llvm::LiveStacks::ID);
  *(void *)uint64_t v2 = &unk_1F260CC60;
  *(void *)(v2 + 256) = 0;
  *(void *)(v2 + 264) = 0;
  *(void *)(v2 + 272) = v2 + 288;
  *(void *)(v2 + 280) = 0x400000000;
  *(void *)(v2 + 320) = v2 + 336;
  *(void *)(v2 + 328) = 0;
  *(void *)(v2 + 336) = 0;
  *(void *)(v2 + 344) = 1;
  *(_OWORD *)(v2 + 352) = 0u;
  *(_OWORD *)(v2 + 368) = 0u;
  *(_DWORD *)(v2 + 384) = 1065353216;
  *(void *)(v2 + 400) = 0;
  *(void *)(v2 + 408) = 0;
  *(void *)(v2 + 392) = v2 + 400;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD470, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC30AB08;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCD470, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CD51DDFC(uint64_t a1)
{
  *(void *)a1 = &unk_1F260CC60;
  sub_1CD40B1BC(*(void **)(a1 + 400));
  sub_1CC30B700(*(void **)(a1 + 368));
  uint64_t v2 = *(void **)(a1 + 352);
  *(void *)(a1 + 352) = 0;
  if (v2) {
    operator delete(v2);
  }
  sub_1CBFFBA64(a1 + 256);

  sub_1CBA0E6AC((llvm::Pass *)a1);
}

_DWORD *sub_1CD51DE74(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  if (!v6)
  {
    BOOL v12 = 0;
LABEL_6:
    double result = sub_1CD42214C(a2, (uint64_t)a3, a3, v12);
    _DWORD *result = *a3;
    uint64_t v7 = *(void *)a2;
    unsigned int v6 = *(_DWORD *)(a2 + 16);
    char v11 = 1;
    goto LABEL_4;
  }
  uint64_t v7 = *(void *)a2;
  unsigned int v8 = (37 * *a3) & (v6 - 1);
  double result = (_DWORD *)(*(void *)a2 + 4 * v8);
  int v10 = *result;
  if (*a3 != *result)
  {
    unsigned int v13 = 0;
    int v14 = 1;
    while (v10 != 0x7FFFFFFF)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v10 == 0x80000000;
      }
      if (v15) {
        unsigned int v13 = result;
      }
      unsigned int v16 = v8 + v14++;
      unsigned int v8 = v16 & (v6 - 1);
      double result = (_DWORD *)(v7 + 4 * v8);
      int v10 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v13) {
      BOOL v12 = v13;
    }
    else {
      BOOL v12 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v11 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v7 + 4 * v6;
  *(unsigned char *)(a1 + 16) = v11;
  return result;
}

uint64_t **sub_1CD51DF60(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  unsigned int v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        unsigned int v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unsigned int v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v9 = a1 + 1;
LABEL_10:
    char v11 = (uint64_t *)v9;
    int v9 = (uint64_t **)operator new(0x30uLL);
    *((_DWORD *)v9 + 8) = **a4;
    v9[5] = 0;
    _WORD *v9 = 0;
    v9[1] = 0;
    uint64_t v9[2] = v11;
    _DWORD *v7 = (uint64_t *)v9;
    BOOL v12 = (uint64_t *)**a1;
    unsigned int v13 = (uint64_t *)v9;
    if (v12)
    {
      *a1 = v12;
      unsigned int v13 = *v7;
    }
    sub_1CB8358B8(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v9;
}

void llvm::initializeLiveVariablesPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD478, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC30BEDC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCD478, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::LiveVariables::getAnalysisUsage(llvm::LiveVariables *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&unk_1EA61EF57);
  *((unsigned char *)a2 + 160) = 1;

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

uint64_t llvm::LiveVariables::VarInfo::findKill(llvm::LiveVariables::VarInfo *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = *((void *)this + 5);
  while (v2 != v3)
  {
    uint64_t result = *(void *)v2;
    if (*(const llvm::MachineBasicBlock **)(*(void *)v2 + 24) == a2) {
      return result;
    }
    v2 += 8;
  }
  return 0;
}

llvm::raw_ostream *llvm::LiveVariables::VarInfo::dump(llvm::LiveVariables::VarInfo *this)
{
  uint64_t v2 = llvm::dbgs(this);
  sub_1CB8E509C(v2, "  Alive in blocks: ");
  uint64_t v3 = *((void *)this + 1);
  uint64_t v31 = this;
  uint64_t v32 = v3;
  unint64_t v34 = 0;
  unint64_t v33 = 0xFFFFFFFF00000000;
  v30[0] = 0;
  sub_1CC30D2C4((uint64_t)v30);
  uint64_t v4 = *((void *)this + 1);
  long long v26 = this;
  uint64_t v27 = v4;
  uint64_t v29 = 0;
  unint64_t v28 = 0xFFFFFFFF00000000;
  v25[0] = 1;
  uint64_t v5 = (llvm *)sub_1CC30D2C4((uint64_t)v25);
  int v6 = v30[0];
  int v7 = v25[0];
  if (!v30[0] || !v25[0])
  {
    while (1)
    {
      unint64_t v20 = v33;
      if (v6 == v7 && v28 == v33) {
        break;
      }
      uint64_t v21 = llvm::dbgs(v5);
      BOOL v22 = llvm::raw_ostream::operator<<(v21, v20);
      sub_1CB8E509C(v22, ", ");
      LODWORD(v33) = v33 + 1;
      v34 >>= 1;
      uint64_t v5 = (llvm *)sub_1CC30D348((uint64_t)v30);
      int v6 = v30[0];
      int v7 = v25[0];
      if (v30[0])
      {
        if (v25[0]) {
          break;
        }
      }
    }
  }
  int v8 = llvm::dbgs(v5);
  int v9 = sub_1CB8E509C(v8, "\n  Killed by:");
  uint64_t v10 = *((void *)this + 4);
  uint64_t v11 = *((void *)this + 5);
  if (v10 == v11)
  {
    BOOL v15 = " No instructions.\n";
  }
  else
  {
    unint64_t v12 = v11 - v10;
    if ((v12 & 0x7FFFFFFF8) != 0)
    {
      unint64_t v13 = 0;
      uint64_t v14 = (v12 >> 3);
      BOOL v15 = "\n";
      do
      {
        unsigned int v16 = llvm::dbgs(v9);
        int v17 = sub_1CB8E509C(v16, "\n    #");
        unsigned __int16 v18 = llvm::raw_ostream::operator<<(v17, v13);
        int v19 = sub_1CB8E509C(v18, ": ");
        llvm::MachineInstr::print(*(llvm::MachineInstr **)(*((void *)this + 4) + 8 * v13++), v19, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
      }
      while (v14 != v13);
    }
    else
    {
      BOOL v15 = "\n";
    }
  }
  uint64_t v23 = llvm::dbgs(v9);
  return sub_1CB8E509C(v23, v15);
}

uint64_t llvm::LiveVariables::getVarInfo(uint64_t a1, int a2)
{
  uint64_t v2 = (void *)(a1 + 248);
  unint64_t v3 = a2 & 0x7FFFFFFF;
  if (v3 >= *(unsigned int *)(a1 + 256)) {
    sub_1CD520A8C((uint64_t *)(a1 + 248), v3 + 1, a1 + 264);
  }
  return *v2 + 56 * v3;
}

void llvm::LiveVariables::MarkVirtRegAliveInBlock(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v9 = *(_DWORD *)(a4 + 24);
  uint64_t v11 = a2[4];
  uint64_t v10 = a2[5];
  unint64_t v12 = v10 - v11;
  if (((v10 - v11) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v13 = (v12 >> 3);
    size_t v14 = v12 - 8;
    while (*(void *)(*(void *)v11 + 24) != a4)
    {
      v11 += 8;
      v14 -= 8;
      if (!--v13) {
        goto LABEL_9;
      }
    }
    if (v11 + 8 != v10) {
      memmove((void *)v11, (const void *)(v11 + 8), v14);
    }
    a2[5] = v11 + (v14 & 0xFFFFFFFFFFFFFFF8);
  }
LABEL_9:
  if (a4 != a3 && (sub_1CD460634(a2, v9) & 1) == 0)
  {
    sub_1CBF7C6A8(a2, v9);
    uint64_t v15 = *(void *)a5 + 8 * *(unsigned int *)(a5 + 8);
    uint64_t v17 = *(void *)(a4 + 64);
    uint64_t v16 = *(void *)(a4 + 72);
    sub_1CD51E45C(a5, v15, v16, v16, v17, v17);
  }
}

uint64_t sub_1CD51E45C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = a4;
  uint64_t v8 = *(void *)result;
  uint64_t v9 = *(unsigned int *)(result + 8);
  if (*(void *)result + 8 * v9 == a2)
  {
    return sub_1CC0579B0(result, a3, a4, a5, a6);
  }
  else
  {
    uint64_t v10 = (a2 - v8) >> 3;
    unint64_t v11 = (a4 - a6) >> 3;
    if (v9 + v11 > *(unsigned int *)(result + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    unint64_t v12 = (char *)(v8 + 8 * v10);
    uint64_t v13 = (char *)(v8 + 8 * v9);
    unint64_t v14 = (v13 - v12) >> 3;
    if (v14 >= v11)
    {
      uint64_t result = sub_1CD4570C8(result, &v13[-8 * v11], (char *)(v8 + 8 * v9));
      if (&v13[-8 * v11] != v12) {
        uint64_t result = (uint64_t)memmove(&v12[8 * v11], v12, &v13[-8 * v11] - v12);
      }
      while (v7 != a6)
      {
        uint64_t v18 = *(void *)(v7 - 8);
        v7 -= 8;
        *(void *)unint64_t v12 = v18;
        v12 += 8;
      }
    }
    else
    {
      unsigned int v15 = v9 + ((unint64_t)(a4 - a6) >> 3);
      *(_DWORD *)(result + 8) = v15;
      if (v10 != v9)
      {
        uint64_t result = (uint64_t)memcpy((void *)(v8 + 8 * v15 - 8 * v14), v12, v13 - v12);
        do
        {
          uint64_t v16 = *(void *)(v7 - 8);
          v7 -= 8;
          *(void *)unint64_t v12 = v16;
          v12 += 8;
          --v14;
        }
        while (v14);
      }
      while (v7 != a6)
      {
        uint64_t v17 = *(void *)(v7 - 8);
        v7 -= 8;
        *(void *)uint64_t v13 = v17;
        v13 += 8;
      }
    }
  }
  return result;
}

void llvm::LiveVariables::MarkVirtRegAliveInBlock(llvm::LiveVariables *this, llvm::LiveVariables::VarInfo *a2, llvm::MachineBasicBlock *a3, llvm::MachineBasicBlock *a4)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  v8[16] = *MEMORY[0x1E4F143B8];
  int v6 = v8;
  uint64_t v7 = 0x1000000000;
  while (1)
  {
    llvm::LiveVariables::MarkVirtRegAliveInBlock((uint64_t)this, (uint64_t *)a2, (uint64_t)a3, (uint64_t)a4, (uint64_t)&v6);
    if (!v7) {
      break;
    }
    a4 = (llvm::MachineBasicBlock *)*((void *)v6 + v7 - 1);
    LODWORD(v7) = v7 - 1;
    a2 = v5;
    a3 = v4;
  }
  if (v6 != v8) {
    free(v6);
  }
}

void llvm::LiveVariables::HandleVirtRegUse(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8 = *(_DWORD *)(a3 + 24);
  uint64_t v9 = (uint64_t *)(a1 + 248);
  unint64_t v10 = a2 & 0x7FFFFFFF;
  if (v10 >= *(unsigned int *)(a1 + 256)) {
    sub_1CD520A8C((uint64_t *)(a1 + 248), v10 + 1, a1 + 264);
  }
  uint64_t v11 = *v9;
  uint64_t v12 = *v9 + 56 * v10;
  unint64_t v14 = (void **)(v12 + 40);
  uint64_t v13 = *(void *)(v12 + 40);
  if (*(void *)(v12 + 32) != v13 && *(void *)(*(void *)(v13 - 8) + 24) == a3)
  {
    *(void *)(v13 - 8) = a4;
  }
  else if (*(void *)(llvm::MachineRegisterInfo::getVRegDef(*(void *)(a1 + 368), a2) + 24) != a3)
  {
    if ((sub_1CD460634((uint64_t *)v12, v8) & 1) == 0)
    {
      uint64_t v21 = a4;
      unsigned int v15 = *v14;
      if ((unint64_t)*v14 >= *(void *)(v11 + 56 * v10 + 48))
      {
        uint64_t v16 = sub_1CBC13470((void **)(v12 + 32), &v21);
      }
      else
      {
        *unsigned int v15 = a4;
        uint64_t v16 = v15 + 1;
      }
      *unint64_t v14 = v16;
    }
    uint64_t v17 = *(llvm::MachineBasicBlock ***)(a3 + 64);
    uint64_t v18 = *(llvm::MachineBasicBlock ***)(a3 + 72);
    while (v17 != v18)
    {
      int v19 = *v17++;
      VRegDef = (llvm::MachineBasicBlock **)llvm::MachineRegisterInfo::getVRegDef(*(void *)(a1 + 368), a2);
      llvm::LiveVariables::MarkVirtRegAliveInBlock((llvm::LiveVariables *)VRegDef, (llvm::LiveVariables::VarInfo *)v12, VRegDef[3], v19);
    }
  }
}

uint64_t *llvm::LiveVariables::HandleVirtRegDef(uint64_t *result, int a2, uint64_t a3)
{
  uint64_t v4 = result + 31;
  unint64_t v5 = a2 & 0x7FFFFFFF;
  if (v5 >= *((unsigned int *)result + 64)) {
    uint64_t result = sub_1CD520A8C(result + 31, v5 + 1, (unint64_t)(result + 33));
  }
  uint64_t v6 = *v4;
  if (!*(void *)(*v4 + 56 * v5 + 16))
  {
    uint64_t v11 = a3;
    uint64_t v7 = v6 + 56 * v5;
    unsigned int v8 = *(void **)(v7 + 40);
    unint64_t v9 = *(void *)(v7 + 48);
    unint64_t v10 = (uint64_t **)(v7 + 40);
    if ((unint64_t)v8 >= v9)
    {
      uint64_t result = sub_1CBC13470((void **)(v6 + 56 * v5 + 32), &v11);
    }
    else
    {
      void *v8 = a3;
      uint64_t result = v8 + 1;
    }
    *unint64_t v10 = result;
  }
  return result;
}

void llvm::LiveVariables::HandlePhysRegUse(void *a1, unsigned int a2, uint64_t a3)
{
  unsigned int v4 = a2;
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a2;
  uint64_t v7 = *(llvm::MachineInstr **)(a1[48] + 8 * a2);
  uint64_t v8 = *(void *)(a1[51] + 8 * a2);
  if (v7)
  {
    if (!v8
      && (llvm::MachineInstr::findRegisterDefOperandIdx(*(void *)(a1[48] + 8 * a2), a2, 0, 0, 0) == -1
       || !*((void *)v7 + 4)))
    {
      uint64_t v43 = 0;
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      LODWORD(v42) = 50331648;
      HIDWORD(v42) = v4;
      llvm::MachineInstr::addOperand(v7, *(llvm::MachineFunction **)(*((void *)v7 + 3) + 32), (const llvm::MachineOperand *)&v42);
    }
    goto LABEL_3;
  }
  if (v8) {
    goto LABEL_3;
  }
  uint64_t v49 = v51;
  uint64_t v50 = 0x400000000;
  __n128 v53 = 0;
  uint64_t v54 = 0;
  uint64_t v52 = &v53;
  LastPartialDef = (llvm::MachineInstr *)llvm::LiveVariables::FindLastPartialDef((uint64_t)a1, a2, (uint64_t)&v49);
  if (!LastPartialDef) {
    goto LABEL_54;
  }
  unsigned int v15 = LastPartialDef;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  LODWORD(v42) = 50331648;
  HIDWORD(v42) = v4;
  llvm::MachineInstr::addOperand(LastPartialDef, *(llvm::MachineFunction **)(*((void *)LastPartialDef + 3) + 32), (const llvm::MachineOperand *)&v42);
  *(void *)(a1[48] + 8 * v6) = v15;
  uint64_t v42 = &v44;
  uint64_t v43 = 0x800000000;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  uint64_t v46 = &v47;
  uint64_t v16 = a1[47];
  if (v16) {
    uint64_t v17 = (void *)(v16 + 8);
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t v18 = (_WORD *)(v17[6] + 2 * *(unsigned int *)(*v17 + 24 * v6 + 4));
  if (!*v18)
  {
    uint64_t v37 = 0;
    goto LABEL_52;
  }
  unsigned __int16 v19 = *v18 + v4;
  do
  {
    unsigned int v20 = v19;
    if (v48)
    {
      for (uint64_t i = v47; i; uint64_t i = (void *)*i)
      {
        unsigned int v22 = *((_DWORD *)i + 7);
        if (v22 <= v20)
        {
          if (v22 >= v20) {
            goto LABEL_33;
          }
          ++i;
        }
      }
    }
    else if (v43)
    {
      unint64_t v33 = v42;
      uint64_t v34 = 4 * v43;
      while (*v33 != v20)
      {
        ++v33;
        v34 -= 4;
        if (!v34) {
          goto LABEL_22;
        }
      }
      if (v34) {
        goto LABEL_33;
      }
    }
LABEL_22:
    if (v54)
    {
      for (uint64_t j = v53; j; uint64_t j = (void *)*j)
      {
        unsigned int v24 = *((_DWORD *)j + 7);
        if (v24 <= v20)
        {
          if (v24 >= v20) {
            goto LABEL_33;
          }
          ++j;
        }
      }
LABEL_28:
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      v38[0] = 0x2000000;
      v38[1] = v20;
      llvm::MachineInstr::addOperand(v15, *(llvm::MachineFunction **)(*((void *)v15 + 3) + 32), (const llvm::MachineOperand *)v38);
      *(void *)(a1[48] + 8 * v20) = v15;
      uint64_t v25 = a1[47];
      long long v26 = (void *)(v25 + 8);
      if (!v25) {
        long long v26 = 0;
      }
      uint64_t v27 = v26[6];
      uint64_t v28 = *(unsigned int *)(*v26 + 24 * v20 + 4);
      if (*(_WORD *)(v27 + 2 * v28))
      {
        unsigned int v29 = *(unsigned __int16 *)(v27 + 2 * v28) + v20;
        uint64_t v30 = (unsigned __int16 *)(v27 + 2 * v28 + 2);
        do
        {
          v38[0] = (unsigned __int16)v29;
          sub_1CB913D18((uint64_t)&v42, v38);
          int v31 = *v30++;
          v29 += v31;
        }
        while (v31);
      }
      goto LABEL_33;
    }
    if (!v50) {
      goto LABEL_28;
    }
    uint64_t v35 = v49;
    uint64_t v36 = 4 * v50;
    while (*v35 != v20)
    {
      ++v35;
      v36 -= 4;
      if (!v36) {
        goto LABEL_28;
      }
    }
    if (!v36) {
      goto LABEL_28;
    }
LABEL_33:
    int v32 = (unsigned __int16)v18[1];
    ++v18;
    unsigned __int16 v19 = v32 + v20;
  }
  while (v32);
  uint64_t v37 = v47;
LABEL_52:
  sub_1CB833A08((uint64_t)&v46, v37);
  if (v42 != &v44) {
    free(v42);
  }
LABEL_54:
  sub_1CB833A08((uint64_t)&v52, v53);
  if (v49 != v51) {
    free(v49);
  }
LABEL_3:
  uint64_t v9 = a1[47];
  unint64_t v10 = (void *)(v9 + 8);
  if (!v9) {
    unint64_t v10 = 0;
  }
  uint64_t v11 = v10[6];
  if (v11)
  {
    uint64_t v12 = (unsigned __int16 *)(v11 + 2 * *(unsigned int *)(*v10 + 24 * v6 + 4));
    do
    {
      *(void *)(a1[51] + 8 * (unsigned __int16)v4) = a3;
      int v13 = *v12++;
      v4 += v13;
    }
    while (v13);
  }
}

uint64_t llvm::LiveVariables::HandleRegMask(uint64_t this, const llvm::MachineOperand *a2)
{
  int v2 = *(_DWORD *)(*(void *)(this + 376) + 16);
  if (v2 != 1)
  {
    unsigned int v4 = (void *)this;
    unint64_t v5 = 1;
    do
    {
      uint64_t v6 = v4[48];
      if (*(void *)(v6 + 8 * v5) || *(void *)(v4[51] + 8 * v5))
      {
        uint64_t v7 = *((void *)a2 + 2);
        if (((*(_DWORD *)(v7 + ((v5 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) >> v5) & 1) == 0)
        {
          uint64_t v8 = v4[47];
          uint64_t v9 = (void *)(v8 + 8);
          if (!v8) {
            uint64_t v9 = 0;
          }
          uint64_t v10 = v9[6];
          uint64_t v11 = *(unsigned int *)(*v9 + 24 * v5 + 8);
          if (*(_WORD *)(v10 + 2 * v11))
          {
            unsigned __int16 v12 = *(_WORD *)(v10 + 2 * v11) + v5;
            int v13 = (unsigned __int16 *)(v10 + 2 * v11 + 2);
            unsigned int v14 = v5;
            do
            {
              if ((*(void *)(v6 + 8 * v12) || *(void *)(v4[51] + 8 * v12))
                && ((*(_DWORD *)(v7 + (((unint64_t)v12 >> 3) & 0x1FFC)) >> v12) & 1) == 0)
              {
                unsigned int v14 = v12;
              }
              int v15 = *v13++;
              v12 += v15;
            }
            while (v15);
          }
          else
          {
            unsigned int v14 = v5;
          }
          this = llvm::LiveVariables::HandlePhysRegKill(v4, v14, 0);
        }
      }
      ++v5;
    }
    while (v2 != v5);
  }
  return this;
}

void llvm::LiveVariables::HandlePhysRegDef(void *a1, unsigned int a2, llvm::MachineInstr *a3, uint64_t a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v42 = v44;
  uint64_t v43 = 0x2000000000;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v45 = &v46;
  if (*(void *)(a1[48] + 8 * a2) || *(void *)(a1[51] + 8 * a2))
  {
    uint64_t v9 = a1[47];
    uint64_t v10 = (void *)(v9 + 8);
    if (!v9) {
      uint64_t v10 = 0;
    }
    uint64_t v11 = v10[6];
    if (v11)
    {
      unsigned __int16 v12 = (unsigned __int16 *)(v11 + 2 * *(unsigned int *)(*v10 + 24 * a2 + 4));
      unsigned int v13 = a2;
      do
      {
        unsigned int v41 = (unsigned __int16)v13;
        sub_1CB946958((uint64_t)&v42, &v41);
        int v14 = *v12++;
        v13 += v14;
      }
      while (v14);
    }
  }
  else
  {
    uint64_t v26 = a1[47];
    if (v26) {
      uint64_t v27 = (void *)(v26 + 8);
    }
    else {
      uint64_t v27 = 0;
    }
    uint64_t v28 = (unsigned __int16 *)(v27[6] + 2 * *(unsigned int *)(*v27 + 24 * a2 + 4));
    if (*v28)
    {
      unsigned int v29 = *v28 + a2;
      do
      {
        if (v47)
        {
          for (uint64_t i = v46; i; uint64_t i = (void *)*i)
          {
            unsigned int v31 = *((_DWORD *)i + 7);
            if (v31 <= (unsigned __int16)v29)
            {
              if (v31 >= (unsigned __int16)v29) {
                goto LABEL_51;
              }
              ++i;
            }
          }
        }
        else if (v43)
        {
          uint64_t v39 = v42;
          uint64_t v40 = 4 * v43;
          while (*v39 != (unsigned __int16)v29)
          {
            ++v39;
            v40 -= 4;
            if (!v40) {
              goto LABEL_45;
            }
          }
          if (v40) {
            goto LABEL_51;
          }
        }
LABEL_45:
        if (*(void *)(a1[48] + 8 * (unsigned __int16)v29) || *(void *)(a1[51] + 8 * (unsigned __int16)v29))
        {
          uint64_t v32 = a1[47];
          unint64_t v33 = (void *)(v32 + 8);
          if (!v32) {
            unint64_t v33 = 0;
          }
          uint64_t v34 = v33[6];
          if (v34)
          {
            uint64_t v35 = (unsigned __int16 *)(v34 + 2 * *(unsigned int *)(*v33 + 24 * (unsigned __int16)v29 + 4));
            unsigned int v36 = v29;
            do
            {
              unsigned int v41 = (unsigned __int16)v36;
              sub_1CB946958((uint64_t)&v42, &v41);
              int v37 = *v35++;
              v36 += v37;
            }
            while (v37);
          }
        }
LABEL_51:
        int v38 = v28[1];
        ++v28;
        v29 += v38;
      }
      while (v38);
    }
  }
  llvm::LiveVariables::HandlePhysRegKill(a1, a2, a3);
  uint64_t v15 = a1[47];
  if (v15) {
    uint64_t v16 = (void *)(v15 + 8);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v17 = (_WORD *)(v16[6] + 2 * *(unsigned int *)(*v16 + 24 * a2 + 4));
  if (*v17)
  {
    unsigned __int16 v18 = *v17 + a2;
    do
    {
      unsigned int v19 = v18;
      if (v47)
      {
        for (uint64_t j = v46; j; uint64_t j = (void *)*j)
        {
          unsigned int v21 = *((_DWORD *)j + 7);
          if (v21 <= v19)
          {
            if (v21 >= v19) {
              goto LABEL_26;
            }
            ++j;
          }
        }
      }
      else if (v43)
      {
        uint64_t v23 = v42;
        uint64_t v24 = 4 * v43;
        while (*v23 != v19)
        {
          ++v23;
          v24 -= 4;
          if (!v24) {
            goto LABEL_18;
          }
        }
        if (v24) {
LABEL_26:
        }
          llvm::LiveVariables::HandlePhysRegKill(a1, v19, a3);
      }
LABEL_18:
      int v22 = (unsigned __int16)v17[1];
      ++v17;
      unsigned __int16 v18 = v22 + v19;
    }
    while (v22);
  }
  if (a3)
  {
    unsigned int v25 = *(_DWORD *)(a4 + 8);
    if (v25 >= *(_DWORD *)(a4 + 12)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)a4 + 4 * v25) = a2;
    ++*(_DWORD *)(a4 + 8);
  }
  sub_1CB833A08((uint64_t)&v45, v46);
  if (v42 != v44) {
    free(v42);
  }
}

void *llvm::LiveVariables::UpdatePhysRegDefs(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a3 + 8);
  while (v3)
  {
    unsigned int v4 = *(_DWORD *)(*(void *)a3 + 4 * v3-- - 4);
    *(_DWORD *)(a3 + 8) = v3;
    uint64_t v5 = result[47];
    uint64_t v6 = (void *)(v5 + 8);
    if (!v5) {
      uint64_t v6 = 0;
    }
    uint64_t v7 = v6[6];
    if (v7)
    {
      uint64_t v8 = (unsigned __int16 *)(v7 + 2 * *(unsigned int *)(*v6 + 24 * v4 + 4));
      do
      {
        *(void *)(result[48] + 8 * (unsigned __int16)v4) = a2;
        *(void *)(result[51] + 8 * (unsigned __int16)v4) = 0;
        int v9 = *v8++;
        v4 += v9;
      }
      while (v9);
    }
  }
  return result;
}

void llvm::LiveVariables::runOnInstr(llvm::LiveVariables *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  v36[2] = *MEMORY[0x1E4F143B8];
  int v6 = **(unsigned __int16 **)(a2 + 16);
  if (v6 == 69 || v6 == 0) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = *(unsigned int *)(a2 + 40);
  }
  uint64_t v34 = v36;
  uint64_t v35 = 0x400000000;
  unsigned int v31 = v33;
  uint64_t v32 = 0x400000000;
  uint64_t v29 = 0x100000000;
  if (!v8) {
    goto LABEL_8;
  }
  uint64_t v9 = 0;
  for (uint64_t i = 0; i != v8; ++i)
  {
    uint64_t v11 = *(void *)(a2 + 32);
    int v12 = *(_DWORD *)(v11 + v9);
    if ((_BYTE)v12)
    {
      if (*(_DWORD *)(v11 + v9) != 12) {
        goto LABEL_20;
      }
      if (v29 >= (unint64_t)HIDWORD(v29)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v30[v29] = i;
      unsigned int v13 = &v29;
      goto LABEL_19;
    }
    unint64_t v14 = *(unsigned int *)(v11 + v9 + 4);
    if (v14)
    {
      unsigned int v15 = v14 >> 30;
      if ((v12 & 0x1000000) != 0)
      {
        if (!v15
          && ((*(void *)(*(void *)(*((void *)this + 46) + 352) + ((v14 >> 3) & 0x1FFFFFF8)) >> v14) & 1) == 0)
        {
          *(_DWORD *)(v11 + v9) = v12 & 0xFBFFFFFF;
        }
        if (v32 >= (unint64_t)HIDWORD(v32)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v31 + v32) = v14;
        unsigned int v13 = &v32;
        goto LABEL_19;
      }
      if (v15
        || ((*(void *)(*(void *)(*((void *)this + 46) + 352) + ((v14 >> 3) & 0x1FFFFFF8)) >> v14) & 1) == 0)
      {
        v12 &= ~0x4000000u;
        *(_DWORD *)(v11 + v9) = v12;
      }
      int v16 = v12 & 0x30000000;
      int v17 = v12 & 0x10FFF00;
      if (v16) {
        BOOL v18 = 1;
      }
      else {
        BOOL v18 = v17 == 0x1000000;
      }
      if (!v18)
      {
        if (v35 >= (unint64_t)HIDWORD(v35)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((_DWORD *)v34 + v35) = v14;
        unsigned int v13 = &v35;
LABEL_19:
        ++*(_DWORD *)v13;
      }
    }
LABEL_20:
    v9 += 32;
  }
  uint64_t v3 = a3;
  if (v35)
  {
    unsigned int v25 = (unsigned int *)v34;
    uint64_t v26 = *(void *)(a2 + 24);
    uint64_t v27 = 4 * v35;
    do
    {
      unint64_t v28 = *v25;
      if ((v28 & 0x80000000) != 0)
      {
        llvm::LiveVariables::HandleVirtRegUse((uint64_t)this, v28, v26, a2);
      }
      else if (((*(void *)(*(void *)(*((void *)this + 46) + 352) + ((v28 >> 3) & 0x1FFFFFF8)) >> v28) & 1) == 0)
      {
        llvm::LiveVariables::HandlePhysRegUse(this, v28, a2);
      }
      ++v25;
      v27 -= 4;
    }
    while (v27);
  }
  if (v29)
  {
    int v22 = v30;
    uint64_t v23 = 4 * v29;
    do
    {
      unsigned int v24 = *v22++;
      llvm::LiveVariables::HandleRegMask((uint64_t)this, (const llvm::MachineOperand *)(*(void *)(a2 + 32) + 32 * v24));
      v23 -= 4;
    }
    while (v23);
  }
LABEL_8:
  if (v32)
  {
    unsigned int v19 = (unsigned int *)v31;
    uint64_t v20 = 4 * v32;
    do
    {
      unint64_t v21 = *v19;
      if ((v21 & 0x80000000) != 0)
      {
        llvm::LiveVariables::HandleVirtRegDef((uint64_t *)this, v21, a2);
      }
      else if (((*(void *)(*(void *)(*((void *)this + 46) + 352) + ((v21 >> 3) & 0x1FFFFFF8)) >> v21) & 1) == 0)
      {
        llvm::LiveVariables::HandlePhysRegDef(this, v21, (llvm::MachineInstr *)a2, v3);
      }
      ++v19;
      v20 -= 4;
    }
    while (v20);
  }
  llvm::LiveVariables::UpdatePhysRegDefs(this, a2, v3);
  if (v31 != v33) {
    free(v31);
  }
  if (v34 != v36) {
    free(v34);
  }
}

void llvm::LiveVariables::runOnBlock(llvm::LiveVariables *this, llvm::MachineBasicBlock *a2, int a3)
{
  v43[2] = *MEMORY[0x1E4F143B8];
  v42[0] = v43;
  v42[1] = (void *)0x400000000;
  uint64_t v6 = llvm::MachineBasicBlock::livein_begin(a2);
  uint64_t v7 = (unsigned __int16 *)*((void *)a2 + 20);
  if (v7 != (unsigned __int16 *)v6)
  {
    uint64_t v8 = (unsigned __int16 *)v6;
    do
    {
      unsigned int v9 = *v8;
      v8 += 8;
      llvm::LiveVariables::HandlePhysRegDef(this, v9, 0, (uint64_t)v42);
    }
    while (v8 != v7);
  }
  sub_1CC30C86C((_DWORD *)this + 114);
  uint64_t v10 = *((void *)a2 + 7);
  if ((llvm::MachineBasicBlock *)v10 != (llvm::MachineBasicBlock *)((char *)a2 + 48))
  {
    unsigned int v11 = 0;
    do
    {
      int v12 = **(unsigned __int16 **)(v10 + 16);
      if ((v12 - 13) >= 5 && v12 != 23)
      {
        unsigned int v14 = v11 + 1;
        uint64_t v34 = v10;
        uint64_t v35 = v11;
        sub_1CC30D5F8((uint64_t)&v36, (uint64_t)this + 456, &v34, &v35);
        llvm::LiveVariables::runOnInstr(this, v10, (uint64_t)v42);
        unsigned int v11 = v14;
      }
      if ((*(unsigned char *)v10 & 4) == 0)
      {
        while ((*(_WORD *)(v10 + 44) & 8) != 0)
          uint64_t v10 = *(void *)(v10 + 8);
      }
      uint64_t v10 = *(void *)(v10 + 8);
    }
    while ((llvm::MachineBasicBlock *)v10 != (llvm::MachineBasicBlock *)((char *)a2 + 48));
  }
  uint64_t v15 = *((void *)this + 54) + 32 * *((int *)a2 + 6);
  uint64_t v16 = *(unsigned int *)(v15 + 8);
  if (v16)
  {
    int v17 = *(unsigned int **)v15;
    uint64_t v18 = 4 * v16;
    do
    {
      unsigned int v19 = *v17;
      unint64_t v20 = *v17 & 0x7FFFFFFF;
      if (v20 >= *((unsigned int *)this + 64)) {
        sub_1CD520A8C((uint64_t *)this + 31, v20 + 1, (unint64_t)this + 264);
      }
      unint64_t v21 = (llvm::LiveVariables::VarInfo *)(*((void *)this + 31) + 56 * v20);
      VRegDef = (llvm::MachineBasicBlock **)llvm::MachineRegisterInfo::getVRegDef(*((void *)this + 46), v19);
      llvm::LiveVariables::MarkVirtRegAliveInBlock((llvm::LiveVariables *)VRegDef, v21, VRegDef[3], a2);
      ++v17;
      v18 -= 4;
    }
    while (v18);
  }
  unsigned int v36 = v38;
  uint64_t v37 = 0x400000000;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v39 = &v40;
  uint64_t v23 = (llvm::MachineBasicBlock **)*((void *)a2 + 11);
  unsigned int v24 = (llvm::MachineBasicBlock **)*((void *)a2 + 12);
  while (v23 != v24)
  {
    unsigned int v25 = *v23;
    if (!*((unsigned char *)*v23 + 184))
    {
      uint64_t v26 = llvm::MachineBasicBlock::livein_begin(*v23);
      uint64_t v27 = (unsigned __int16 *)*((void *)v25 + 20);
      if (v27 != (unsigned __int16 *)v26)
      {
        unint64_t v28 = (unsigned __int16 *)v26;
        do
        {
          if (!*(unsigned char *)(*(void *)(*(void *)(*((void *)this + 47) + 216) + 16) + *v28))
          {
            LODWORD(v34) = *v28;
            sub_1CB918828((uint64_t)&v36, (unsigned int *)&v34);
          }
          v28 += 8;
        }
        while (v28 != v27);
      }
    }
    ++v23;
  }
  if (a3)
  {
    for (unint64_t i = 0; i != a3; ++i)
    {
      if (*(void *)(*((void *)this + 48) + 8 * i) || *(void *)(*((void *)this + 51) + 8 * i))
      {
        if (v41)
        {
          for (uint64_t j = v40; j; uint64_t j = (void *)*j)
          {
            unint64_t v31 = *((unsigned int *)j + 7);
            if (i >= v31)
            {
              if (i <= v31) {
                goto LABEL_48;
              }
              ++j;
            }
          }
        }
        else if (v37)
        {
          uint64_t v32 = v36;
          uint64_t v33 = 4 * v37;
          while (i != *v32)
          {
            ++v32;
            v33 -= 4;
            if (!v33) {
              goto LABEL_39;
            }
          }
          if (v33) {
            continue;
          }
        }
LABEL_39:
        llvm::LiveVariables::HandlePhysRegDef(this, i, 0, (uint64_t)v42);
      }
LABEL_48:
      ;
    }
  }
  sub_1CB833A08((uint64_t)&v39, v40);
  if (v36 != v38) {
    free(v36);
  }
  if (v42[0] != v43) {
    free(v42[0]);
  }
}

uint64_t llvm::LiveVariables::runOnMachineFunction(llvm::LiveVariables *this, llvm::MachineFunction *a2)
{
  *((void *)this + 45) = a2;
  *((void *)this + 46) = *((void *)a2 + 5);
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
  *((void *)this + 47) = v4;
  unint64_t v5 = *(unsigned int *)(v4 + 16);
  int v38 = 0;
  sub_1CD51FB48((uint64_t)this + 384, v5, (uint64_t *)&v38);
  int v38 = 0;
  sub_1CD51FB48((uint64_t)this + 408, v5, (uint64_t *)&v38);
  sub_1CD51FC60((uint64_t *)this + 54, ((*(void *)(*((void *)this + 45) + 112) - *(void *)(*((void *)this + 45) + 104)) >> 3));
  if (*((void *)this + 43))
  {
    uint64_t v7 = *((void *)this + 41);
    uint64_t v6 = (llvm::LiveVariables *)*((void *)this + 42);
    uint64_t v8 = *(void *)v6;
    *(void *)(v8 + 8) = *(void *)(v7 + 8);
    **(void **)(v7 + 8) = v8;
    *((void *)this + 43) = 0;
    if (v6 != (llvm::LiveVariables *)((char *)this + 328))
    {
      do
      {
        unsigned int v9 = (llvm::LiveVariables *)*((void *)v6 + 1);
        operator delete(v6);
        uint64_t v6 = v9;
      }
      while (v9 != (llvm::LiveVariables *)((char *)this + 328));
    }
  }
  if ((**(unsigned char **)(**((void **)this + 46) + 360) & 1) == 0) {
    llvm::report_fatal_error((llvm *)"regalloc=... not currently supported with -O0", (const llvm::Twine *)1);
  }
  llvm::LiveVariables::analyzePHINodes((uint64_t)this, a2);
  uint64_t v10 = *(void *)(*((void *)this + 45) + 328);
  int v38 = v42;
  uint64_t v39 = v42;
  uint64_t v40 = 16;
  int v41 = 0;
  sub_1CD520EA4(&v43, v10, (llvm::SmallPtrSetImplBase *)&v38);
  unsigned int v11 = v44;
  long long v33 = v45;
  int v12 = (unsigned char *)v45;
  unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v45 - (void)v44) >> 3);
  v32[0] = v43;
  v32[1] = v44;
  uint64_t v34 = (uint64_t *)&v38;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v44 = 0;
  long long v45 = 0uLL;
  sub_1CBF340A8(&v44, v11, v12, v13);
  while ((unsigned char *)v45 != v44)
  {
    llvm::LiveVariables::runOnBlock(this, *(llvm::MachineBasicBlock **)(v45 - 24), v5);
    uint64_t v31 = 0;
    sub_1CD51FB48((uint64_t)this + 384, v5, &v31);
    uint64_t v31 = 0;
    sub_1CD51FB48((uint64_t)this + 408, v5, &v31);
    sub_1CD520FAC((char *)&v43);
  }
  if ((void)v45) {
    operator delete((void *)v45);
  }
  sub_1CD481D8C(v32);
  int v14 = *((_DWORD *)this + 64);
  if (v14)
  {
    for (int i = 0; i != v14; ++i)
    {
      uint64_t v16 = i & 0x7FFFFFFF;
      unint64_t v17 = *(void *)(*((void *)this + 31) + 56 * v16 + 40) - *(void *)(*((void *)this + 31) + 56 * v16 + 32);
      if ((v17 & 0x7FFFFFFF8) != 0)
      {
        uint64_t v18 = 0;
        uint64_t v19 = (v17 >> 3);
        do
        {
          uint64_t v20 = *(void *)(*(void *)(*((void *)this + 31) + 56 * v16 + 32) + 8 * v18);
          uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(*((void *)this + 46), i | 0x80000000);
          int v22 = *(llvm::MachineInstr **)(*(void *)(*((void *)this + 31) + 56 * v16 + 32) + 8 * v18);
          uint64_t v23 = *((void *)this + 47);
          unsigned int v24 = i | 0x80000000;
          if (v20 == VRegDef) {
            llvm::MachineInstr::addRegisterDead(v22, v24, v23, 0);
          }
          else {
            llvm::MachineInstr::addRegisterKilled(v22, v24, v23, 0);
          }
          ++v18;
        }
        while (v19 != v18);
      }
    }
  }
  *((void *)this + 49) = *((void *)this + 48);
  *((void *)this + 52) = *((void *)this + 51);
  uint64_t v26 = (char *)*((void *)this + 54);
  unsigned int v25 = (char *)*((void *)this + 55);
  if (v25 != v26)
  {
    uint64_t v27 = v25 - 16;
    do
    {
      unint64_t v28 = (char *)*((void *)v27 - 2);
      if (v27 != v28) {
        free(v28);
      }
      uint64_t v29 = v27 - 16;
      v27 -= 32;
    }
    while (v29 != v26);
  }
  *((void *)this + 55) = v26;
  if (v39 != v38) {
    free(v39);
  }
  return 0;
}

uint64_t *sub_1CD51FB48(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t result = *(uint64_t **)a1;
  if (a2 > (v6 - (uint64_t)result) >> 3)
  {
    if (result)
    {
      *(void *)(a1 + 8) = result;
      operator delete(result);
      uint64_t v6 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    uint64_t v8 = v6 >> 2;
    if (v6 >> 2 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 >> 61) {
      abort();
    }
    uint64_t result = (uint64_t *)operator new(8 * v9);
    *(void *)a1 = result;
    *(void *)(a1 + 8) = result;
    *(void *)(a1 + 16) = &result[v9];
    uint64_t v10 = (uint64_t)&result[a2];
    uint64_t v11 = 8 * a2;
    uint64_t v12 = *a3;
    do
    {
      *result++ = v12;
      v11 -= 8;
    }
    while (v11);
    goto LABEL_23;
  }
  unint64_t v13 = (uint64_t)(*(void *)(a1 + 8) - (void)result) >> 3;
  if (v13 >= a2) {
    uint64_t v14 = a2;
  }
  else {
    uint64_t v14 = (uint64_t)(*(void *)(a1 + 8) - (void)result) >> 3;
  }
  for (; v14; --v14)
    *result++ = *a3;
  if (a2 <= v13)
  {
    uint64_t v10 = *(void *)a1 + 8 * a2;
LABEL_23:
    *(void *)(a1 + 8) = v10;
    return result;
  }
  uint64_t v15 = *(uint64_t **)(a1 + 8);
  uint64_t v16 = &v15[a2 - v13];
  uint64_t v17 = 8 * a2 - 8 * v13;
  do
  {
    *v15++ = *a3;
    v17 -= 8;
  }
  while (v17);
  *(void *)(a1 + 8) = v16;
  return result;
}

void sub_1CD51FC60(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 5;
  if (a2 > v4)
  {
    unint64_t v9 = a2 - v4;
    sub_1CD520C70(a1, v9);
  }
  else if (a2 < v4)
  {
    uint64_t v5 = *a1 + 32 * a2;
    if (v3 != v5)
    {
      uint64_t v6 = (char *)(v3 - 16);
      do
      {
        uint64_t v7 = (char *)*((void *)v6 - 2);
        if (v6 != v7) {
          free(v7);
        }
        uint64_t v8 = v6 - 16;
        v6 -= 32;
      }
      while (v8 != (char *)v5);
    }
    a1[1] = v5;
  }
}

uint64_t llvm::LiveVariables::analyzePHINodes(uint64_t this, const llvm::MachineFunction *a2)
{
  for (int i = (void *)*((void *)a2 + 41); i != (void *)((char *)a2 + 320); int i = (void *)i[1])
  {
    for (uint64_t j = i[7]; (void *)j != i + 6; uint64_t j = *(void *)(j + 8))
    {
      int v4 = **(unsigned __int16 **)(j + 16);
      if (v4 != 69 && v4 != 0) {
        break;
      }
      int v6 = *(_DWORD *)(j + 40);
      if (v6 != 1)
      {
        unsigned int v7 = 1;
        do
        {
          uint64_t v8 = *(void *)(j + 32);
          uint64_t v9 = v7;
          int v10 = *(_DWORD *)(v8 + 32 * v7);
          int v11 = v10 & 0x30000000;
          int v12 = v10 & 0x10FFF00;
          if (v11) {
            BOOL v13 = 1;
          }
          else {
            BOOL v13 = v12 == 0x1000000;
          }
          if (!v13)
          {
            uint64_t v14 = *(void *)(this + 432) + 32 * *(int *)(*(void *)(v8 + 32 * (v9 + 1) + 16) + 24);
            int v15 = *(_DWORD *)(v8 + 32 * v9 + 4);
            unint64_t v16 = *(unsigned int *)(v14 + 8);
            if (v16 >= *(unsigned int *)(v14 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(_DWORD *)(*(void *)v14 + 4 * v16) = v15;
            ++*(_DWORD *)(v14 + 8);
          }
          unsigned int v7 = v9 + 2;
        }
        while (v6 != v9 + 2);
      }
      if ((*(unsigned char *)j & 4) == 0)
      {
        while ((*(_WORD *)(j + 44) & 8) != 0)
          uint64_t j = *(void *)(j + 8);
      }
    }
  }
  return this;
}

uint64_t *llvm::LiveVariables::replaceKillInstruction(uint64_t *result, int a2, uint64_t a3, uint64_t a4)
{
  int v6 = result + 31;
  unint64_t v7 = a2 & 0x7FFFFFFF;
  if (v7 >= *((unsigned int *)result + 64)) {
    uint64_t result = sub_1CD520A8C(result + 31, v7 + 1, (unint64_t)(result + 33));
  }
  uint64_t v8 = *v6 + 56 * v7;
  uint64_t v9 = *(void **)(v8 + 32);
  int v10 = *(void **)(v8 + 40);
  while (v9 != v10)
  {
    if (*v9 == a3) {
      void *v9 = a4;
    }
    ++v9;
  }
  return result;
}

BOOL llvm::LiveVariables::removeVirtualRegistersKilled(BOOL this, llvm::MachineInstr *a2)
{
  uint64_t v2 = *((unsigned int *)a2 + 10);
  if (v2)
  {
    uint64_t v4 = this;
    uint64_t v5 = 0;
    int v6 = (uint64_t *)(this + 248);
    uint64_t v7 = 32 * v2;
    do
    {
      uint64_t v8 = *((void *)a2 + 4);
      unsigned int v9 = *(_DWORD *)(v8 + v5);
      if (!(_BYTE)v9 && ((v9 >> 26) & ~HIBYTE(v9) & 1) != 0)
      {
        int v10 = (unsigned int *)(v8 + v5);
        *int v10 = v9 & 0xFBFFFFFF;
        unsigned int v11 = v10[1];
        if ((v11 & 0x80000000) != 0)
        {
          uint64_t v12 = v11 & 0x7FFFFFFF;
          if ((v11 & 0x7FFFFFFF) >= *(_DWORD *)(v4 + 256)) {
            sub_1CD520A8C(v6, v12 + 1, v4 + 264);
          }
          this = sub_1CC30D1B0(*v6 + 56 * v12, (uint64_t)a2);
        }
      }
      v5 += 32;
    }
    while (v7 != v5);
  }
  return this;
}

uint64_t llvm::LiveVariables::VarInfo::isLiveIn(uint64_t *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (sub_1CD460634(a1, *(_DWORD *)(a2 + 24))) {
    return 1;
  }
  uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(a4, a3);
  if (VRegDef && *(void *)(VRegDef + 24) == a2) {
    return 0;
  }
  for (uint64_t i = a1[4]; i != a1[5]; i += 8)
  {
    uint64_t v11 = *(void *)i;
    if (*(void *)(*(void *)i + 24) == a2) {
      return v11 != 0;
    }
  }
  uint64_t v11 = 0;
  return v11 != 0;
}

BOOL llvm::LiveVariables::isLiveOut(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v4 = (void *)(a1 + 248);
  unint64_t v5 = a2 & 0x7FFFFFFF;
  if (v5 >= *(unsigned int *)(a1 + 256)) {
    sub_1CD520A8C((uint64_t *)(a1 + 248), v5 + 1, a1 + 264);
  }
  int v6 = (uint64_t *)(*v4 + 56 * v5);
  uint64_t v7 = v26;
  int v22 = v26;
  uint64_t v23 = v26;
  uint64_t v24 = 8;
  int v25 = 0;
  uint64_t v8 = (uint64_t *)v6[4];
  unsigned int v9 = (uint64_t *)v6[5];
  if (v8 == v9)
  {
    uint64_t v11 = v26;
  }
  else
  {
    do
    {
      uint64_t v10 = *v8++;
      sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v22, *(void *)(v10 + 24));
    }
    while (v8 != v9);
    uint64_t v7 = v22;
    uint64_t v11 = v23;
  }
  uint64_t v12 = *(void *)(a3 + 88);
  uint64_t v13 = *(void *)(a3 + 96);
  if (v12 == v13)
  {
    BOOL v19 = 0;
  }
  else
  {
    uint64_t v14 = v12 + 8;
    while (1)
    {
      uint64_t v15 = *(void *)(v14 - 8);
      if (sub_1CD460634(v6, *(_DWORD *)(v15 + 24))) {
        break;
      }
      unint64_t v16 = sub_1CB896AE8((uint64_t)&v22, v15);
      uint64_t v7 = v22;
      uint64_t v11 = v23;
      uint64_t v17 = (uint64_t *)((char *)&v24 + 4);
      if (v23 != v22) {
        uint64_t v17 = &v24;
      }
      uint64_t v18 = &v23[8 * *(unsigned int *)v17];
      BOOL v19 = v16 != v18;
      BOOL v20 = v16 != v18 || v14 == v13;
      v14 += 8;
      if (v20) {
        goto LABEL_16;
      }
    }
    BOOL v19 = 1;
    uint64_t v7 = v22;
    uint64_t v11 = v23;
  }
LABEL_16:
  if (v11 != v7) {
    free(v11);
  }
  return v19;
}

uint64_t llvm::LiveVariables::addNewBlock(llvm::LiveVariables *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3, llvm::MachineBasicBlock *a4)
{
  unsigned int v5 = *((_DWORD *)a2 + 6);
  v41[0] = 0;
  v41[1] = 0;
  int v42 = 0;
  int v6 = (char *)a4 + 48;
  v39[0] = 0;
  v39[1] = 0;
  int v40 = 0;
  uint64_t v7 = *((void *)a4 + 7);
  if ((llvm::MachineBasicBlock *)v7 == (llvm::MachineBasicBlock *)((char *)a4 + 48)) {
    goto LABEL_38;
  }
  unsigned int v9 = (void *)((char *)this + 248);
  uint64_t v36 = (char *)this + 264;
  do
  {
    int v10 = **(unsigned __int16 **)(v7 + 16);
    if (v10 != 69 && v10 != 0)
    {
      while (1)
      {
LABEL_38:
        if ((char *)v7 == v6) {
          goto LABEL_39;
        }
        uint64_t v16 = *(unsigned int *)(v7 + 40);
        if (!v16) {
          goto LABEL_33;
        }
        uint64_t v17 = 32 * v16;
        uint64_t v18 = (int *)(*(void *)(v7 + 32) + 4);
        do
        {
          unsigned int v19 = *(v18 - 1);
          if (!(_BYTE)v19 && *v18 < 0)
          {
            if ((v19 & 0x1000000) != 0)
            {
              int v38 = *v18;
              BOOL v20 = v41;
            }
            else
            {
              if (((v19 >> 26) & ~HIBYTE(v19) & 1) == 0) {
                goto LABEL_24;
              }
              int v38 = *v18;
              BOOL v20 = v39;
            }
            sub_1CD521094((uint64_t)v20, &v38, (uint64_t)v43);
          }
LABEL_24:
          v18 += 8;
          v17 -= 32;
        }
        while (v17);
        if (v7)
        {
LABEL_33:
          if ((*(unsigned char *)v7 & 4) != 0) {
            goto LABEL_37;
          }
        }
        while ((*(_WORD *)(v7 + 44) & 8) != 0)
          uint64_t v7 = *(void *)(v7 + 8);
LABEL_37:
        uint64_t v7 = *(void *)(v7 + 8);
      }
    }
    int v38 = *(_DWORD *)(*(void *)(v7 + 32) + 4);
    sub_1CD521094((uint64_t)v41, &v38, (uint64_t)v43);
    int v12 = *(_DWORD *)(v7 + 40);
    if (v12 != 1)
    {
      for (unsigned int i = 1; i != v12; i += 2)
      {
        uint64_t v14 = *(void *)(v7 + 32);
        if (*(llvm::MachineBasicBlock **)(v14 + 32 * (i + 1) + 16) == a2)
        {
          uint64_t v15 = *(_DWORD *)(v14 + 32 * i + 4) & 0x7FFFFFFF;
          if (v15 >= *((_DWORD *)this + 64)) {
            sub_1CD520A8C((uint64_t *)this + 31, v15 + 1, (unint64_t)v36);
          }
          sub_1CBF7C6A8((uint64_t *)(*v9 + 56 * v15), v5);
        }
      }
    }
    if ((*(unsigned char *)v7 & 4) == 0)
    {
      while ((*(_WORD *)(v7 + 44) & 8) != 0)
        uint64_t v7 = *(void *)(v7 + 8);
    }
    uint64_t v7 = *(void *)(v7 + 8);
  }
  while ((char *)v7 != v6);
LABEL_39:
  int v21 = *(_DWORD *)(*((void *)this + 46) + 32);
  if (v21)
  {
    int v22 = 0;
    uint64_t v23 = (void *)((char *)this + 248);
    while (1)
    {
      unsigned int v24 = v22 | 0x80000000;
      if (!v42) {
        goto LABEL_45;
      }
      unsigned int v25 = (v42 - 1) & (37 * v24);
      int v26 = *(_DWORD *)(v41[0] + 4 * v25);
      if (v24 != v26) {
        break;
      }
LABEL_43:
      if (++v22 == v21) {
        goto LABEL_52;
      }
    }
    int v32 = 1;
    while (v26 != -1)
    {
      unsigned int v33 = v25 + v32++;
      unsigned int v25 = v33 & (v42 - 1);
      int v26 = *(_DWORD *)(v41[0] + 4 * v25);
      if (v24 == v26) {
        goto LABEL_43;
      }
    }
LABEL_45:
    uint64_t v27 = v22 & 0x7FFFFFFF;
    if (v27 >= *((_DWORD *)this + 64)) {
      sub_1CD520A8C((uint64_t *)this + 31, v27 + 1, (unint64_t)this + 264);
    }
    unint64_t v28 = (uint64_t *)(*v23 + 56 * v27);
    if (v40)
    {
      unsigned int v29 = (v40 - 1) & (37 * v24);
      int v30 = *(_DWORD *)(v39[0] + 4 * v29);
      if (v24 == v30)
      {
LABEL_49:
        sub_1CBF7C6A8(v28, v5);
        goto LABEL_43;
      }
      int v34 = 1;
      while (v30 != -1)
      {
        unsigned int v35 = v29 + v34++;
        unsigned int v29 = v35 & (v40 - 1);
        int v30 = *(_DWORD *)(v39[0] + 4 * v29);
        if (v24 == v30) {
          goto LABEL_49;
        }
      }
    }
    if (!sub_1CD460634((uint64_t *)(*v23 + 56 * v27), *((_DWORD *)a4 + 6))) {
      goto LABEL_43;
    }
    goto LABEL_49;
  }
LABEL_52:
  MEMORY[0x1D25D9CD0](v39[0], 4);
  return MEMORY[0x1D25D9CD0](v41[0], 4);
}

uint64_t llvm::LiveVariables::addNewBlock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  unsigned int v8 = *(_DWORD *)(a2 + 24);
  uint64_t v9 = *a5 + 32 * *(int *)(a4 + 24);
  uint64_t v29 = v9;
  uint64_t v30 = *(void *)(v9 + 8);
  unint64_t v32 = 0;
  unint64_t v31 = 0xFFFFFFFF00000000;
  v28[0] = 0;
  sub_1CC30D2C4((uint64_t)v28);
  uint64_t v24 = v9;
  uint64_t v25 = *(void *)(v9 + 8);
  uint64_t v27 = 0;
  unint64_t v26 = 0xFFFFFFFF00000000;
  v23[0] = 1;
  uint64_t result = sub_1CC30D2C4((uint64_t)v23);
  int v11 = v28[0];
  int v12 = v23[0];
  if (!v28[0] || !v23[0])
  {
    while (v11 != v12 || v26 != v31)
    {
      unint64_t v22 = v31 & 0x7FFFFFFF;
      if ((v31 & 0x7FFFFFFF) >= *(_DWORD *)(a1 + 256)) {
        sub_1CD520A8C((uint64_t *)(a1 + 248), v22 + 1, a1 + 264);
      }
      sub_1CBF7C6A8((uint64_t *)(*(void *)(a1 + 248) + 56 * v22), v8);
      LODWORD(v31) = v31 + 1;
      v32 >>= 1;
      uint64_t result = sub_1CC30D348((uint64_t)v28);
      int v11 = v28[0];
      int v12 = v23[0];
      if (v28[0])
      {
        if (v23[0]) {
          break;
        }
      }
    }
  }
  for (uint64_t i = *(void *)(a4 + 56); i != a4 + 48; uint64_t i = *(void *)(i + 8))
  {
    if (**(_WORD **)(i + 16) && **(_WORD **)(i + 16) != 69) {
      break;
    }
    int v14 = *(_DWORD *)(i + 40);
    if (v14 != 1)
    {
      for (unsigned int j = 1; j != v14; j += 2)
      {
        uint64_t v16 = *(void *)(i + 32);
        if (*(void *)(v16 + 32 * (j + 1) + 16) == a2)
        {
          int v17 = *(_DWORD *)(v16 + 32 * j);
          int v18 = v17 & 0x30000000;
          int v19 = v17 & 0x10FFF00;
          if (!v18 && v19 != 0x1000000)
          {
            uint64_t v21 = *(_DWORD *)(v16 + 32 * j + 4) & 0x7FFFFFFF;
            if (v21 >= *(_DWORD *)(a1 + 256)) {
              sub_1CD520A8C((uint64_t *)(a1 + 248), v21 + 1, a1 + 264);
            }
            uint64_t result = (uint64_t)sub_1CBF7C6A8((uint64_t *)(*(void *)(a1 + 248) + 56 * v21), v8);
          }
        }
      }
    }
    if ((*(unsigned char *)i & 4) == 0)
    {
      while ((*(_WORD *)(i + 44) & 8) != 0)
        uint64_t i = *(void *)(i + 8);
    }
  }
  return result;
}

void sub_1CD52070C(uint64_t a1)
{
  sub_1CD5208BC(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t *sub_1CD520744(uint64_t *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((unsigned int *)result + 64);
  if (v2)
  {
    uint64_t v3 = 56 * v2;
    uint64_t v4 = result[31] - 56;
    do
    {
      uint64_t result = sub_1CD5209B0((uint64_t *)(v4 + v3));
      v3 -= 56;
    }
    while (v3);
  }
  *((_DWORD *)v1 + 64) = 0;
  return result;
}

void llvm::callDefaultCtor<llvm::LiveVariables>()
{
}

uint64_t sub_1CD5207D4(uint64_t a1)
{
  sub_1CB8483A0(a1, (uint64_t)&llvm::LiveVariables::ID);
  *(void *)uint64_t v2 = &unk_1F260CD20;
  *(void *)(v2 + 248) = v2 + 264;
  *(void *)(v2 + 256) = 0;
  *(void *)(v2 + 264) = v2 + 264;
  *(void *)(v2 + 272) = v2 + 264;
  *(void *)(v2 + 280) = 0;
  *(void *)(v2 + 288) = v2 + 264;
  *(void *)(v2 + 304) = 0;
  *(void *)(v2 + 312) = 0;
  *(void *)(v2 + 296) = 0;
  *(void *)(v2 + 328) = v2 + 328;
  *(void *)(v2 + 336) = v2 + 328;
  *(void *)(v2 + 344) = 0;
  *(void *)(v2 + 352) = v2 + 328;
  *(_OWORD *)(v2 + 384) = 0u;
  *(_OWORD *)(v2 + 400) = 0u;
  *(_OWORD *)(v2 + 416) = 0u;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_OWORD *)(v2 + 460) = 0u;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD478, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC30BEDC;
    v6[1] = &PassRegistry;
    unsigned int v5 = v6;
    std::__call_once(&qword_1EBCCD478, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void sub_1CD5208BC(uint64_t a1)
{
  *(void *)a1 = &unk_1F260CD20;
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 456), 8);
  unsigned int v8 = (void **)(a1 + 432);
  sub_1CC30D230(&v8);
  uint64_t v2 = *(void **)(a1 + 408);
  if (v2)
  {
    *(void *)(a1 + 416) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 384);
  if (v3)
  {
    *(void *)(a1 + 392) = v3;
    operator delete(v3);
  }
  if (*(void *)(a1 + 344))
  {
    uint64_t v5 = *(void *)(a1 + 328);
    uint64_t v4 = *(uint64_t **)(a1 + 336);
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    *(void *)(a1 + 344) = 0;
    if (v4 != (uint64_t *)(a1 + 328))
    {
      do
      {
        uint64_t v7 = (uint64_t *)v4[1];
        operator delete(v4);
        uint64_t v4 = v7;
      }
      while (v7 != (uint64_t *)(a1 + 328));
    }
  }
  sub_1CD5209B0((uint64_t *)(a1 + 264));
  sub_1CD520A24((char **)(a1 + 248));

  sub_1CBA0E6AC((llvm::Pass *)a1);
}

uint64_t *sub_1CD5209B0(uint64_t *a1)
{
  uint64_t v2 = (void *)a1[4];
  if (v2)
  {
    a1[5] = (uint64_t)v2;
    operator delete(v2);
  }
  if (a1[2])
  {
    uint64_t v4 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v5 = *v3;
    *(void *)(v5 + 8) = *(void *)(*a1 + 8);
    **(void **)(v4 + 8) = v5;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        uint64_t v6 = (uint64_t *)v3[1];
        operator delete(v3);
        uint64_t v3 = v6;
      }
      while (v6 != a1);
    }
  }
  return a1;
}

char **sub_1CD520A24(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 56 * v3;
    uint64_t v5 = v2 - 56;
    do
    {
      sub_1CD5209B0((uint64_t *)&v5[v4]);
      v4 -= 56;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t *sub_1CD520A8C(uint64_t *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = *((unsigned int *)result + 2);
  uint64_t v4 = a2 - v3;
  if (a2 != v3)
  {
    uint64_t v5 = result;
    if (a2 >= v3)
    {
      unint64_t v9 = sub_1CD520B34((uint64_t)result, a3, v4);
      uint64_t result = sub_1CC30D528((void *)(*v5 + 56 * *((unsigned int *)v5 + 2)), v4, v9);
      int v6 = *((_DWORD *)v5 + 2) + v4;
    }
    else
    {
      int v6 = a2;
      uint64_t v7 = 56 * v3;
      uint64_t v8 = 56 * a2 - v7;
      uint64_t result = (uint64_t *)(v7 + *result - 56);
      do
      {
        uint64_t result = sub_1CD5209B0(result) - 7;
        v8 += 56;
      }
      while (v8);
    }
    *((_DWORD *)v5 + 2) = v6;
  }
  return result;
}

unint64_t sub_1CD520B34(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 56 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      sub_1CD520BA0();
    }
    sub_1CD520BA0();
  }
  return a2;
}

void sub_1CD520BA0()
{
}

void sub_1CD520C10(uint64_t a1, uint64_t *a2)
{
  sub_1CC30D4A8(*(__n128 **)a1, (__n128 *)(*(void *)a1 + 56 * *(unsigned int *)(a1 + 8)), a2);
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3)
  {
    uint64_t v4 = *(__n128 **)a1;
    uint64_t v5 = 56 * v3;
    int v6 = &v4[-4].n128_i8[8];
    do
    {
      sub_1CD5209B0((uint64_t *)&v6[v5]);
      v5 -= 56;
    }
    while (v5);
  }
}

void sub_1CD520C70(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (a2 > (v4 - v5) >> 5)
  {
    uint64_t v9 = v5 - *a1;
    unint64_t v10 = a2 + (v9 >> 5);
    if (v10 >> 59) {
      abort();
    }
    uint64_t v11 = v4 - *a1;
    if (v11 >> 4 > v10) {
      unint64_t v10 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    uint64_t v25 = a1 + 2;
    if (v12)
    {
      if (v12 >> 59) {
        sub_1CB833614();
      }
      uint64_t v13 = (char *)operator new(32 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::string __p = v13;
    unint64_t v22 = &v13[32 * (v9 >> 5)];
    uint64_t v24 = &v13[32 * v12];
    int v14 = &v22[32 * a2];
    uint64_t v15 = 32 * a2;
    uint64_t v16 = v22 + 16;
    do
    {
      *((void *)v16 - 2) = v16;
      *((void *)v16 - 1) = 0x400000000;
      v16 += 32;
      v15 -= 32;
    }
    while (v15);
    uint64_t v23 = v14;
    sub_1CD520DDC(a1, &__p);
    int v17 = v22;
    if (v23 != v22)
    {
      int v18 = v23 - 16;
      do
      {
        int v19 = (char *)*((void *)v18 - 2);
        if (v18 != v19) {
          free(v19);
        }
        BOOL v20 = v18 - 16;
        v18 -= 32;
      }
      while (v20 != v17);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    if (a2)
    {
      uint64_t v6 = v5 + 32 * a2;
      uint64_t v7 = 32 * a2;
      uint64_t v8 = v5 + 16;
      do
      {
        *(void *)(v8 - 16) = v8;
        *(void *)(v8 - 8) = 0x400000000;
        v8 += 32;
        v7 -= 32;
      }
      while (v7);
    }
    else
    {
      uint64_t v6 = a1[1];
    }
    a1[1] = v6;
  }
}

uint64_t *sub_1CD520DDC(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      *(void *)(v6 + v7 - 32) = v6 + v7 - 16;
      uint64_t result = (uint64_t *)(v6 + v7 - 32);
      *(void *)(v6 + v7 - 24) = 0x400000000;
      if (*(_DWORD *)(v4 + v7 - 24)) {
        uint64_t result = (uint64_t *)sub_1CC0778D4((uint64_t)result, v4 + v7 - 32);
      }
      v7 -= 32;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v8 = *v3;
  *uint64_t v3 = v6;
  a2[1] = v8;
  uint64_t v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void sub_1CD520EA4(void *a1, uint64_t a2, llvm::SmallPtrSetImplBase *a3)
{
  sub_1CD520F14(&v5, a2, a3);
  uint64_t v4 = __p;
  *a1 = v5;
  a1[2] = 0;
  a1[3] = 0;
  a1[1] = 0;
  sub_1CBF340A8(a1 + 1, v4, v7, 0xAAAAAAAAAAAAAAABLL * ((v7 - v4) >> 3));
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
}

void *sub_1CD520F14(void *a1, uint64_t a2, llvm::SmallPtrSetImplBase *this)
{
  *a1 = this;
  a1[1] = 0;
  uint64_t v5 = (void **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  sub_1CB89694C(this, a2);
  if (v6)
  {
    *(void *)&long long v11 = a2;
    BYTE8(v11) = 0;
    LOBYTE(v12) = 0;
    unint64_t v7 = a1[2];
    if (v7 >= a1[3])
    {
      uint64_t v9 = sub_1CBF56DE8(v5, (uint64_t)&v11);
    }
    else
    {
      long long v8 = v11;
      *(void *)(v7 + 16) = v12;
      *(_OWORD *)unint64_t v7 = v8;
      uint64_t v9 = (char *)(v7 + 24);
    }
    a1[2] = v9;
  }
  return a1;
}

char *sub_1CD520FAC(char *result)
{
  uint64_t v1 = result;
  uint64_t v2 = (void **)(result + 8);
  uint64_t v3 = *((void *)result + 2);
  while (2)
  {
    uint64_t v4 = *(void *)(v3 - 24);
    if (!*(unsigned char *)(v3 - 8))
    {
      *(void *)(v3 - 16) = *(void *)(v4 + 88);
      *(unsigned char *)(v3 - 8) = 1;
    }
    while (1)
    {
      uint64_t v5 = *(uint64_t **)(v3 - 16);
      if (v5 == *(uint64_t **)(v4 + 96)) {
        break;
      }
      *(void *)(v3 - 16) = v5 + 1;
      uint64_t v6 = *v5;
      uint64_t result = (char *)sub_1CB89694C(*(llvm::SmallPtrSetImplBase **)v1, *v5);
      if (v7)
      {
        *(void *)&long long v11 = v6;
        BYTE8(v11) = 0;
        LOBYTE(v12) = 0;
        unint64_t v9 = *((void *)v1 + 2);
        if (v9 >= *((void *)v1 + 3))
        {
          uint64_t result = sub_1CBF56DE8(v2, (uint64_t)&v11);
        }
        else
        {
          long long v10 = v11;
          *(void *)(v9 + 16) = v12;
          *(_OWORD *)unint64_t v9 = v10;
          uint64_t result = (char *)(v9 + 24);
        }
        *((void *)v1 + 2) = result;
        return result;
      }
    }
    uint64_t v8 = *((void *)v1 + 1);
    uint64_t v3 = *((void *)v1 + 2) - 24;
    *((void *)v1 + 2) = v3;
    if (v8 != v3) {
      continue;
    }
    break;
  }
  return result;
}

int *sub_1CD521094@<X0>(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (!v6)
  {
    uint64_t v12 = 0;
LABEL_6:
    uint64_t result = sub_1CBB29C30(a1, (uint64_t)a2, a2, v12);
    int *result = *a2;
    uint64_t v7 = *(void *)a1;
    unsigned int v6 = *(_DWORD *)(a1 + 16);
    char v11 = 1;
    goto LABEL_4;
  }
  uint64_t v7 = *(void *)a1;
  unsigned int v8 = (37 * *a2) & (v6 - 1);
  uint64_t result = (int *)(*(void *)a1 + 4 * v8);
  int v10 = *result;
  if (*a2 != *result)
  {
    uint64_t v13 = 0;
    int v14 = 1;
    while (v10 != -1)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v10 == -2;
      }
      if (v15) {
        uint64_t v13 = result;
      }
      unsigned int v16 = v8 + v14++;
      unsigned int v8 = v16 & (v6 - 1);
      uint64_t result = (int *)(v7 + 4 * v8);
      int v10 = *result;
      if (*a2 == *result) {
        goto LABEL_3;
      }
    }
    if (v13) {
      uint64_t v12 = v13;
    }
    else {
      uint64_t v12 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v11 = 0;
LABEL_4:
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v7 + 4 * v6;
  *(unsigned char *)(a3 + 16) = v11;
  return result;
}

uint64_t llvm::LLVMTargetMachine::initAsmInfo(llvm::LLVMTargetMachine *this)
{
  uint64_t v2 = *((void *)this + 1);
  char v3 = *((unsigned char *)this + 471);
  BOOL v4 = v3 < 0;
  if (v3 >= 0) {
    uint64_t v5 = (char *)this + 448;
  }
  else {
    uint64_t v5 = (char *)*((void *)this + 56);
  }
  uint64_t v6 = v3 & 0x7F;
  if (v4) {
    uint64_t v7 = *((void *)this + 57);
  }
  else {
    uint64_t v7 = v6;
  }
  uint64_t v8 = sub_1CD52142C(v2, (uint64_t)v5, v7);
  uint64_t v9 = *((void *)this + 71);
  *((void *)this + 71) = v8;
  if (v9) {
    sub_1CD521E44(v9);
  }
  int v10 = *(uint64_t (**)(void))(*((void *)this + 1) + 64);
  if (v10) {
    int v10 = (uint64_t (*)(void))v10();
  }
  uint64_t v11 = *((void *)this + 72);
  *((void *)this + 72) = v10;
  if (v11) {
    MEMORY[0x1D25D9CE0](v11, 0x10F0C40CB53E019);
  }
  char v12 = *((unsigned char *)this + 471);
  BOOL v13 = v12 < 0;
  if (v12 >= 0) {
    int v14 = (char *)this + 448;
  }
  else {
    int v14 = (char *)*((void *)this + 56);
  }
  uint64_t v15 = v12 & 0x7F;
  if (v13) {
    uint64_t v16 = *((void *)this + 57);
  }
  else {
    uint64_t v16 = v15;
  }
  char v17 = *((unsigned char *)this + 519);
  if (v17 >= 0) {
    int v18 = (char *)this + 496;
  }
  else {
    int v18 = (char *)*((void *)this + 62);
  }
  if (v17 >= 0) {
    uint64_t v19 = v17 & 0x7F;
  }
  else {
    uint64_t v19 = *((void *)this + 63);
  }
  char v20 = *((unsigned char *)this + 543);
  int v21 = v20;
  if (v20 >= 0) {
    unint64_t v22 = (char *)this + 520;
  }
  else {
    unint64_t v22 = (char *)*((void *)this + 65);
  }
  uint64_t v23 = v20 & 0x7F;
  if (v21 >= 0) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = *((void *)this + 66);
  }
  uint64_t v25 = sub_1CD452D6C(*((void *)this + 1), (uint64_t)v14, v16, (uint64_t)v18, v19, (uint64_t)v22, v24);
  uint64_t v26 = *((void *)this + 73);
  *((void *)this + 73) = v25;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  char v27 = *((unsigned char *)this + 471);
  BOOL v28 = v27 < 0;
  if (v27 >= 0) {
    uint64_t v29 = (char *)this + 448;
  }
  else {
    uint64_t v29 = (char *)*((void *)this + 56);
  }
  uint64_t v30 = v27 & 0x7F;
  if (v28) {
    uint64_t v31 = *((void *)this + 57);
  }
  else {
    uint64_t v31 = v30;
  }
  unint64_t v32 = (void *)sub_1CD5214A0(*((void *)this + 1), *((void *)this + 71), (uint64_t)v29, v31, (uint64_t)this + 1128);
  unsigned int v33 = v32;
  if (*((int *)this + 253) >= 1) {
    v32[57] = *(void *)((char *)this + 1012);
  }
  if ((*((unsigned char *)this + 1032) & 4) != 0)
  {
    (*(void (**)(void *, void))(*v32 + 80))(v32, 0);
    (*(void (**)(void *, void))(*v33 + 88))(v33, 0);
  }
  (*(void (**)(void *, void))(*v33 + 96))(v33, (*((unsigned __int16 *)this + 564) >> 12) & 1);
  *((_DWORD *)v33 + 117) = *((_DWORD *)this + 259);
  *((unsigned char *)v33 + 473) = *((unsigned char *)this + 1040) & 1;
  int v34 = *((_DWORD *)this + 281);
  if (v34) {
    *((_DWORD *)v33 + 103) = v34;
  }
  uint64_t result = *((void *)this + 70);
  *((void *)this + 70) = v33;
  if (result)
  {
    uint64_t v36 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v36();
  }
  return result;
}

uint64_t sub_1CD52142C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v3 = *(uint64_t (**)(void **))(a1 + 80);
  if (!v3) {
    return 0;
  }
  __int16 v7 = 261;
  v6[0] = a2;
  v6[1] = a3;
  llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v6);
  uint64_t result = v3(__p);
  if (v9 < 0)
  {
    uint64_t v5 = result;
    operator delete(__p[0]);
    return v5;
  }
  return result;
}

uint64_t sub_1CD5214A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(uint64_t (**)(uint64_t, void **, uint64_t))(a1 + 48);
  if (!v5) {
    return 0;
  }
  __int16 v11 = 261;
  v10[0] = a3;
  v10[1] = a4;
  llvm::Triple::Triple((llvm::Triple *)__p, (const llvm::Twine *)v10);
  uint64_t v8 = v5(a2, __p, a5);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  return v8;
}

void llvm::LLVMTargetMachine::getTargetTransformInfo(llvm::LLVMTargetMachine *this, const llvm::Function *a2)
{
  llvm::BasicTTIImpl::BasicTTIImpl((llvm::BasicTTIImpl *)&v2, this, a2);
  operator new();
}

uint64_t llvm::LLVMTargetMachine::addAsmPrinter(uint64_t a1, uint64_t a2, llvm::raw_pwrite_stream *a3, llvm::raw_pwrite_stream *a4, int a5, llvm *this)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  llvm::LLVMTargetMachine::createMCStreamer(this, a1, a3, a4, a5, (uint64_t)&v14);
  if ((v15 & 1) != 0 && (uint64_t v12 = v14, v14 = 0, v12))
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  else
  {
    uint64_t v8 = *(uint64_t (**)(uint64_t, uint64_t *))(*(void *)(a1 + 8) + 120);
    if (v8)
    {
      uint64_t v9 = v8(a1, &v14);
      if (v9)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v9);
        uint64_t result = 0;
        goto LABEL_5;
      }
    }
  }
  uint64_t result = 1;
LABEL_5:
  uint64_t v11 = v14;
  uint64_t v14 = 0;
  if ((v15 & 1) == 0)
  {
    if (!v11) {
      return result;
    }
    uint64_t v13 = result;
    (*(void (**)(uint64_t))(*(void *)v11 + 48))(v11);
    return v13;
  }
  if (v11)
  {
    uint64_t v13 = result;
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    return v13;
  }
  return result;
}

void sub_1CD5217B8(uint64_t a1, uint64_t a2, void *a3)
{
  *a3 = 0;
  llvm::createAsmStreamer();
}

void llvm::LLVMTargetMachine::addPassesToEmitFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  if (!a7) {
    operator new();
  }
  sub_1CC30DC14(a1, a2, a6, a7);
}

void llvm::LLVMTargetMachine::addPassesToEmitMC(llvm::LLVMTargetMachine *this, llvm::legacy::PassManagerBase *a2, llvm::MCContext **a3, llvm::raw_pwrite_stream *a4)
{
}

void sub_1CD521C74(llvm::TargetMachine *a1)
{
  llvm::TargetMachine::~TargetMachine(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD521CAC(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBD05020, 0, 0);
  byte_1EBD050A0 = 0;
  qword_1EBD050A8 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD050B0 = 0;
  qword_1EBD05020 = (uint64_t)&unk_1F26440A0;
  qword_1EBD050B8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD050C0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD050D8 = (uint64_t)&qword_1EBD050C0;
  sub_1CD521DAC(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBD05020);
}

__n128 sub_1CD521DAC(_WORD *a1, _WORD *a2, char **a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBD05020, "trap-unreachable", 0x10uLL);
  word_1EBD0502A = word_1EBD0502A & 0xFF9F | (32 * (*a1 & 3));
  word_1EBD0502A = word_1EBD0502A & 0xFFF8 | *a2 & 7;
  uint64_t v8 = *a3;
  byte_1EBD050A0 = **a3;
  byte_1EBD050B1 = 1;
  byte_1EBD050B0 = *v8;
  __n128 result = *a4;
  xmmword_1EBD05040 = (__int128)*a4;
  return result;
}

void sub_1CD521E44(uint64_t a1)
{
}

void sub_1CD521E6C()
{
  llvm::deallocate_buffer(*(llvm **)(v0 + 160), (void *)(8 * *(unsigned int *)(v0 + 176)));
}

uint64_t sub_1CD521E80()
{
  return v0;
}

void sub_1CD521E94(llvm::TargetTransformInfo::Concept *a1)
{
  llvm::TargetTransformInfo::Concept::~Concept(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD521ECC(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_1CD521ED4(uint64_t a1, uint64_t a2, llvm::Value *a3, llvm::Constant **a4, uint64_t a5)
{
  return sub_1CC30DF50((llvm::DataLayout **)(a1 + 16), a2, a3, a4, a5);
}

uint64_t sub_1CD521EDC()
{
  return 1;
}

uint64_t sub_1CD521EE4()
{
  return 0;
}

uint64_t sub_1CD521EEC()
{
  return 150;
}

uint64_t sub_1CD521EF4()
{
  return 4;
}

uint64_t sub_1CD521F00(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  return sub_1CB907A3C(*(void *)(a1 + 16), *(void *)(a1 + 32), a2, a3, a4, a5);
}

uint64_t sub_1CD521F20(uint64_t a1, int **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return sub_1CC30E504(a1 + 16, a2, a3, a4, a5);
}

uint64_t sub_1CD521F28()
{
  llvm::BranchProbability::BranchProbability(&v1, 0x63uLL, 0x64u);
  return v1;
}

uint64_t sub_1CD521F58()
{
  return 0;
}

uint64_t sub_1CD521F60()
{
  return 0;
}

uint64_t sub_1CD521F68()
{
  return 0;
}

uint64_t sub_1CD521F70()
{
  return 0;
}

uint64_t sub_1CD521F78()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_1CD521F80()
{
  return 0;
}

uint64_t sub_1CD521F88(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 8) + 64))();
}

BOOL sub_1CD521FB4(uint64_t a1, int a2)
{
  return a2 == 0;
}

uint64_t sub_1CD521FC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 8) + 72))();
}

uint64_t sub_1CD521FEC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 8) + 80))();
}

uint64_t sub_1CD522018()
{
  return 0;
}

uint64_t sub_1CD522020(uint64_t a1, uint64_t ***a2)
{
  return sub_1CB9091FC(a1 + 16, a2);
}

uint64_t sub_1CD522028(uint64_t a1, llvm::Loop *a2, uint64_t a3, uint64_t a4, uint64_t ****a5)
{
  return sub_1CD524560(a1 + 8, a2, a4, a5);
}

void sub_1CD522038(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)a4 = 0;
  *(_WORD *)(a4 + 4) = 1;
  *(unsigned char *)(a4 + 6) = 1;
}

uint64_t sub_1CD52204C()
{
  return 0;
}

uint64_t sub_1CD522054()
{
  return 0;
}

uint64_t sub_1CD52205C()
{
  return 0;
}

uint64_t sub_1CD522064()
{
  return 0;
}

uint64_t sub_1CD522070(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v6 = *((_DWORD *)a4 + 2);
  if (v6 > 0x40) {
    operator new[]();
  }
  uint64_t v5 = *a4;
  sub_1CD3F707C((uint64_t)&v5);
  return 0;
}

uint64_t sub_1CD522124(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 1088))();
}

uint64_t sub_1CD522154(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 1080))();
}

uint64_t sub_1CD522184(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v9[0] = a3;
  v9[1] = a4;
  char v10 = a5;
  uint64_t v11 = a6;
  return (*(uint64_t (**)(void, void, void *, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 32) + 1064))(*(void *)(a1 + 32), *(void *)(a1 + 16), v9, a2, a7, a8);
}

BOOL sub_1CD5221F8(uint64_t a1, _OWORD *a2, _OWORD *a3)
{
  long long v3 = a2[1];
  v7[0] = *a2;
  v7[1] = v3;
  long long v4 = a3[1];
  v6[0] = *a3;
  v6[1] = v4;
  return sub_1CD3F7118(a1 + 16, v7, v6);
}

uint64_t sub_1CD522234()
{
  return 1;
}

uint64_t sub_1CD52223C()
{
  return 0;
}

uint64_t sub_1CD522244()
{
  return 0;
}

uint64_t sub_1CD52224C()
{
  return 0;
}

uint64_t sub_1CD522254()
{
  return 2;
}

uint64_t sub_1CD52225C()
{
  return 0;
}

uint64_t sub_1CD522264()
{
  return 0;
}

BOOL sub_1CD52226C(uint64_t a1, uint64_t a2, char a3)
{
  return sub_1CD3F71C0((uint64_t *)(a1 + 16), a2, a3);
}

BOOL sub_1CD522278(uint64_t a1, uint64_t a2, char a3)
{
  return sub_1CD3F71C0((uint64_t *)(a1 + 16), a2, a3);
}

uint64_t sub_1CD522284()
{
  return 0;
}

uint64_t sub_1CD52228C()
{
  return 0;
}

uint64_t sub_1CD522294()
{
  return 0;
}

uint64_t sub_1CD52229C()
{
  return 0;
}

uint64_t sub_1CD5222A4()
{
  return 0;
}

uint64_t sub_1CD5222AC()
{
  return 0;
}

uint64_t sub_1CD5222B4()
{
  return 0;
}

uint64_t sub_1CD5222BC()
{
  return 0;
}

uint64_t sub_1CD5222C4()
{
  return 0;
}

uint64_t sub_1CD5222CC()
{
  return 0;
}

uint64_t sub_1CD5222D4()
{
  return 1;
}

uint64_t sub_1CD5222DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7)
{
  v8[0] = a3;
  v8[1] = a4;
  char v9 = a5;
  uint64_t v10 = a6;
  return (*(uint64_t (**)(void, void, void *, uint64_t, uint64_t))(**(void **)(a1 + 32) + 1072))(*(void *)(a1 + 32), *(void *)(a1 + 16), v8, a2, a7);
}

uint64_t sub_1CD52234C()
{
  return 0;
}

uint64_t sub_1CD522354(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 1144))();
}

uint64_t sub_1CD522384(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 1176))();
}

uint64_t sub_1CD5223B4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 368))();
}

BOOL sub_1CD5223E4(uint64_t a1, llvm::EVT *this)
{
  unsigned __int8 v3 = sub_1CB87DC14(*(void *)(a1 + 32), *(void *)(a1 + 16), this, 0);
  return v3 && *(void *)(*(void *)(a1 + 32) + 8 * v3 + 96) != 0;
}

uint64_t sub_1CD52243C(uint64_t a1, llvm::LLVMContext **a2)
{
  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 32), *(const llvm::DataLayout **)(a1 + 16), a2, (uint64_t)&v3);
  return v3;
}

BOOL sub_1CD522474(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(void *)(a1 + 32) + 4510) | 4) == 4
      || (*(unsigned char *)(*(void *)(a1 + 32) + 4509) & 0xFB) == 0;
}

uint64_t sub_1CD5224AC()
{
  return 1;
}

unint64_t sub_1CD5224B4(uint64_t a1)
{
  return sub_1CD3F7240(*(void *)(*(void *)(a1 + 32) + 8));
}

uint64_t sub_1CD5224C0()
{
  return 0;
}

unint64_t sub_1CD5224C8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  return sub_1CD523F68(a1 + 8, a2, a3, a4, a5);
}

unint64_t sub_1CD5224D0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  return sub_1CC3121A4(a1 + 8, a2, a3, a4);
}

uint64_t sub_1CD5224D8()
{
  return 0;
}

uint64_t sub_1CD5224E0()
{
  return 0;
}

double sub_1CD5224E8@<D0>(uint64_t a1@<X8>)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = a1 + 24;
  *(void *)&double result = 0x800000000;
  *(void *)(a1 + 16) = 0x800000000;
  *(_DWORD *)(a1 + 56) = 1;
  *(unsigned char *)(a1 + 60) = 0;
  return result;
}

uint64_t sub_1CD522510()
{
  return 0;
}

uint64_t sub_1CD522518()
{
  return 0;
}

uint64_t sub_1CD522520()
{
  return 0;
}

uint64_t sub_1CD522528()
{
  return 0;
}

uint64_t sub_1CD522530(uint64_t a1, llvm::IntegerType *a2, llvm::LLVMContext *a3)
{
  sub_1CB8E40FC(a2, a3);
  long long v4 = *(uint64_t (**)(void))(**(void **)(a1 + 32) + 648);

  return v4();
}

uint64_t sub_1CD5225CC()
{
  return 0;
}

BOOL sub_1CD5225D4(uint64_t a1, llvm::EVT *a2)
{
  return sub_1CB90D5AC(*(void *)(a1 + 16), *(void *)(a1 + 32), a2);
}

uint64_t sub_1CD5225E8()
{
  return 1;
}

uint64_t sub_1CD5225F0(uint64_t a1, llvm::EVT *this)
{
  uint64_t v2 = *(void *)(a1 + 32);
  unsigned __int8 v3 = sub_1CB87DC14(v2, *(void *)(a1 + 16), this, 0);
  if (v3 && (v3 == 1 || *(void *)(v2 + 8 * v3 + 96)) && (unint64_t v4 = *(char *)(v2 + 390 * v3 + 3958), v4 <= 4)) {
    return qword_1CFAC6EC0[v4];
  }
  else {
    return 4;
  }
}

uint64_t sub_1CD522670()
{
  return 0;
}

uint64_t sub_1CD52267C()
{
  return 1;
}

uint64_t sub_1CD522688()
{
  return 0;
}

uint64_t sub_1CD522694()
{
  return 0;
}

uint64_t sub_1CD5226A0()
{
  return 8;
}

uint64_t sub_1CD5226A8(uint64_t a1, uint64_t a2)
{
  return a2;
}

const char *sub_1CD5226B0(uint64_t a1, int a2)
{
  uint64_t v2 = "Generic::Unknown Register Class";
  if (a2 == 1) {
    uint64_t v2 = "Generic::VectorRC";
  }
  if (a2) {
    return v2;
  }
  else {
    return "Generic::ScalarRC";
  }
}

uint64_t sub_1CD5226DC()
{
  return 32;
}

uint64_t sub_1CD5226E8()
{
  return 128;
}

uint64_t sub_1CD5226F0()
{
  return 0;
}

uint64_t sub_1CD5226F8()
{
  return 0;
}

uint64_t sub_1CD522700()
{
  return 0;
}

uint64_t sub_1CD522708(uint64_t a1, uint64_t a2, int a3)
{
  if (a3) {
    return 0x100000000;
  }
  else {
    return 0;
  }
}

uint64_t sub_1CD522718()
{
  return 0;
}

uint64_t sub_1CD522720(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *a3 = 0;
  return 0;
}

uint64_t sub_1CD52272C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 56))();
}

uint64_t sub_1CD522754(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 32))();
}

uint64_t sub_1CD52277C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
  if ((result & 0xFF00000000) == 0) {
    return 0;
  }
  return result;
}

uint64_t sub_1CD5227C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 64))();
}

uint64_t sub_1CD5227E8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 88))();
}

uint64_t sub_1CD522810(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 72))();
}

uint64_t sub_1CD522838(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 80))();
}

uint64_t sub_1CD522860()
{
  return 1;
}

unint64_t sub_1CD522868(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t a10)
{
  return sub_1CD522C04(a1 + 8, a2, a3, a4, a9, a10);
}

unint64_t sub_1CD522874(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return sub_1CD52331C(a1 + 8, a2, a3, a4, a5, a7);
}

uint64_t sub_1CD522880(uint64_t a1, uint64_t a2, llvm::Type ***a3, llvm::Type ***a4, unsigned int a5, unsigned int a6, uint64_t a7)
{
  return sub_1CC30FB74(a1 + 8, a2, a3, a4, a5, a6, a7);
}

unint64_t sub_1CD522888(uint64_t a1, uint64_t a2, llvm::Type ***a3, uint64_t a4)
{
  return sub_1CD524694(a1 + 8, a2, a3, a4);
}

BOOL sub_1CD522890(uint64_t a1, int a2, int a3)
{
  return a2 != 55 || a3 == 0;
}

unint64_t sub_1CD5228A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  return sub_1CD523148(a1 + 8, a2, a3, a4, a6);
}

uint64_t sub_1CD5228B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(llvm::TargetLoweringBase **)(a1 + 32);
  if ((*(_DWORD *)(a3 + 8) & 0xFE) == 0x12) {
    a3 = **(void **)(a3 + 16);
  }
  llvm::TargetLoweringBase::getTypeLegalizationCost(v4, *(const llvm::DataLayout **)(a1 + 16), (llvm::LLVMContext **)a3, (uint64_t)&v6);
  return v6;
}

unint64_t sub_1CD5228FC(uint64_t a1, llvm::FixedVectorType *a2, int a3, llvm::Type *a4, llvm::APIntOps *a5)
{
  return sub_1CD5233F8(a1 + 8, a2, a3, a4, a5);
}

unint64_t sub_1CD522904(uint64_t a1, int a2, llvm::EVT *a3, uint64_t a4, uint64_t a5, int a6)
{
  return sub_1CD522FB8(a1 + 8, a2, a3, a6);
}

uint64_t sub_1CD522910()
{
  return 1;
}

unint64_t sub_1CD52291C(uint64_t a1, int a2, uint64_t a3, unsigned __int8 a4, uint64_t a5, int a6)
{
  return sub_1CD523948(a1 + 8, a2, a3, a4, 1, 0, a6);
}

unint64_t sub_1CD522934(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, unsigned __int8 a6, int a7)
{
  return sub_1CD523948(a1 + 8, a2, a3, a6, a5, 1, a7);
}

unint64_t sub_1CD522944(uint64_t a1, int a2, uint64_t a3, unsigned int a4, unsigned int *a5, unint64_t a6, unsigned __int8 a7, uint64_t a8, int a9, char a10, char a11)
{
  return sub_1CD524748(a1 + 8, a2, a3, a4, a5, a6, a7, a9, a10, a11);
}

unint64_t sub_1CD522964(uint64_t a1, uint64_t a2, llvm::FixedVectorType **a3, uint64_t a4, unsigned int a5)
{
  return sub_1CD523594(a1 + 8, a2, a3, a4, a5);
}

unint64_t sub_1CD52296C(uint64_t a1, llvm::FixedVectorType **a2, uint64_t a3, uint64_t a4, int a5)
{
  return sub_1CD5235B0(a1 + 8, a2, a3, a5);
}

unint64_t sub_1CD522978(uint64_t a1, int a2, int a3, llvm::FixedVectorType *a4, uint64_t a5, unsigned int a6)
{
  return sub_1CD524CA8(a1 + 8, a2, a3, a4, a5, a6);
}

uint64_t sub_1CD522980(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1CC30F1CC(a1 + 8, a2, a3);
}

uint64_t sub_1CD522988()
{
  return 10;
}

uint64_t sub_1CD522994(uint64_t a1, llvm::LLVMContext **a2)
{
  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 32), *(const llvm::DataLayout **)(a1 + 16), a2, (uint64_t)v3);
  if (v3[2]) {
    return 0;
  }
  else {
    return v3[0];
  }
}

uint64_t sub_1CD5229D8()
{
  return 0;
}

uint64_t sub_1CD5229E4()
{
  return 0;
}

uint64_t sub_1CD5229F0()
{
  return 0;
}

uint64_t sub_1CD5229F8()
{
  return 0;
}

uint64_t sub_1CD522A00()
{
  return 0;
}

uint64_t sub_1CD522A08(int a1, llvm::IntegerType *this, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a8 & 0xFF00000000) != 0) {
    return llvm::IntegerType::get(this, (llvm::LLVMContext *)(8 * a8));
  }
  else {
    return llvm::Type::getInt8Ty(this, this);
  }
}

uint64_t sub_1CD522A20(int a1, uint64_t a2, llvm::IntegerType *a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  return sub_1CD3F7AB0(a1 + 16, a2, a3, a4, a5, a6, a7, a8, a9);
}

BOOL sub_1CD522A30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1CB90D6C8(a1 + 16, a2, a3);
}

BOOL sub_1CD522A38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1CB90D6C8(a1 + 16, a2, a3);
}

BOOL sub_1CD522A40(uint64_t a1, unsigned int a2, llvm::EVT *a3)
{
  unsigned __int8 v5 = sub_1CB87DC14(*(void *)(a1 + 32), *(void *)(a1 + 16), a3, 0);
  if (!v5) {
    return 0;
  }
  return *(_WORD *)(*(void *)(a1 + 32) + 10 * v5 + 2 * a2 + 169796) < 0x10u
      || (*(_WORD *)(*(void *)(a1 + 32) + 10 * v5 + 2 * a2 + 169796) & 0xF0) == 64;
}

BOOL sub_1CD522AB8(uint64_t a1, unsigned int a2, llvm::EVT *a3)
{
  unsigned __int8 v5 = sub_1CB87DC14(*(void *)(a1 + 32), *(void *)(a1 + 16), a3, 0);
  return v5 && (*(_WORD *)(*(void *)(a1 + 32) + 10 * v5 + 2 * a2 + 169796) & 0xB) == 0;
}

uint64_t sub_1CD522B24()
{
  return 128;
}

uint64_t sub_1CD522B2C()
{
  return 1;
}

uint64_t sub_1CD522B34()
{
  return 1;
}

uint64_t sub_1CD522B3C()
{
  return 1;
}

uint64_t sub_1CD522B44()
{
  return 1;
}

uint64_t sub_1CD522B4C()
{
  return 1;
}

uint64_t sub_1CD522B54()
{
  return 1;
}

uint64_t sub_1CD522B5C(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_1CD522B64(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_1CD522B6C()
{
  return 0;
}

uint64_t sub_1CD522B74()
{
  return 0;
}

uint64_t sub_1CD522B7C()
{
  return 1;
}

uint64_t sub_1CD522B84()
{
  return 1;
}

uint64_t sub_1CD522B8C()
{
  return 0;
}

uint64_t sub_1CD522B94()
{
  return 0;
}

uint64_t sub_1CD522B9C()
{
  return 0;
}

uint64_t sub_1CD522BA4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 16) == 60) {
    return 4;
  }
  else {
    return sub_1CD524DF4(a1 + 16, a2);
  }
}

uint64_t sub_1CD522BD8()
{
  return 0x200000001;
}

uint64_t sub_1CD522BE4()
{
  return 0;
}

uint64_t sub_1CD522BEC()
{
  return 1;
}

uint64_t sub_1CD522BF4()
{
  return 1;
}

uint64_t sub_1CD522BFC()
{
  return 1;
}

unint64_t sub_1CD522C04(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unint64_t a6)
{
  v41[7] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(llvm::TargetLoweringBase **)(a1 + 24);
  unsigned int v13 = llvm::TargetLoweringBase::InstructionOpcodeToISD(v12, a2);
  if (a4)
  {
    if ((a2 - 19) >= 6) {
      return 1;
    }
    else {
      return 4;
    }
  }
  unsigned int v16 = v13;
  llvm::TargetLoweringBase::getTypeLegalizationCost(v12, *(const llvm::DataLayout **)(a1 + 8), (llvm::LLVMContext **)a3, (uint64_t)&v36);
  int v17 = *(_DWORD *)(a3 + 8);
  int v18 = *(_DWORD *)(a3 + 8) & 0xFE;
  unsigned int v19 = v17;
  if (v18 == 18) {
    unsigned int v19 = *(unsigned __int8 *)(**(void **)(a3 + 16) + 8);
  }
  if (v19 >= 7) {
    unint64_t v14 = 1;
  }
  else {
    unint64_t v14 = 2;
  }
  unint64_t v34 = v14;
  LODWORD(v35) = 0;
  if (!v37) {
    goto LABEL_22;
  }
  if (v37 == 1)
  {
    if (v16 <= 0x185) {
      goto LABEL_15;
    }
  }
  else if (v16 <= 0x185 && *((void *)v12 + v37 + 12))
  {
LABEL_15:
    if (*((unsigned __int8 *)v12 + 390 * v37 + v16 + 3862) <= 1u)
    {
      long long v20 = v36;
LABEL_17:
      *(_OWORD *)int v40 = v20;
      sub_1CB90C9D4((uint64_t)v40, (uint64_t)&v34);
      return (unint64_t)v40[0];
    }
  }
  if (*((void *)v12 + v37 + 12) && (v16 > 0x185 || *((unsigned char *)v12 + 390 * v37 + v16 + 3862) != 2))
  {
    uint64_t v38 = 2;
    int v39 = 0;
    *(_OWORD *)int v40 = v36;
    sub_1CB90C9D4((uint64_t)v40, (uint64_t)&v38);
    long long v20 = *(_OWORD *)v40;
    goto LABEL_17;
  }
  if (v16 - 61 > 1) {
    goto LABEL_32;
  }
LABEL_22:
  uint64_t v21 = 65;
  if (v16 != 61) {
    uint64_t v21 = 66;
  }
  if (!v37 || v37 != 1 && !*((void *)v12 + v37 + 12)) {
    goto LABEL_32;
  }
  if ((*((unsigned char *)v12 + 390 * v37 + v21 + 3862) & 0xFB) == 0) {
    goto LABEL_37;
  }
  uint64_t v22 = 59;
  if (v16 != 61) {
    uint64_t v22 = 60;
  }
  if ((*((unsigned char *)v12 + 390 * v37 + v22 + 3862) & 0xFB) == 0)
  {
LABEL_37:
    if (v16 == 61) {
      uint64_t v23 = 20;
    }
    else {
      uint64_t v23 = 19;
    }
    uint64_t v24 = sub_1CD522C04(a1, v23, a3, 0, 0, 0);
    uint64_t v25 = sub_1CD522C04(a1, 17, a3, 0, 0, 0);
    uint64_t v26 = sub_1CD522C04(a1, 15, a3, 0, 0, 0);
    unint64_t v27 = v24 + v25;
    if (__OFADD__(v24, v25)) {
      unint64_t v27 = ((v24 + v25) >> 63) ^ 0x8000000000000000;
    }
    BOOL v28 = __OFADD__(v27, v26);
    uint64_t v29 = v27 + v26;
    if (v28) {
      return (v29 >> 63) ^ 0x8000000000000000;
    }
    else {
      return v29;
    }
  }
  else
  {
LABEL_32:
    if (v17 == 19)
    {
      return 0;
    }
    else if (v17 == 18)
    {
      uint64_t v30 = a3;
      if (v18 == 18) {
        uint64_t v30 = **(void **)(a3 + 16);
      }
      v33[0] = sub_1CD522C04(a1, a2, v30, 0, a5, a6);
      v33[1] = v31;
      v40[0] = v41;
      v40[1] = (void *)0x600000000;
      sub_1CB90CB08((uint64_t)v40, a6, a3);
      unint64_t v32 = sub_1CD5240BC(a1, a3, a5, a6, (uint64_t)v40[0]);
      uint64_t v38 = *(unsigned int *)(a3 + 32);
      int v39 = 0;
      sub_1CB90C9D4((uint64_t)&v38, (uint64_t)v33);
      if (__OFADD__(v32, v38)) {
        unint64_t v14 = ((uint64_t)(v32 + v38) >> 63) ^ 0x8000000000000000;
      }
      else {
        unint64_t v14 = v32 + v38;
      }
      if (v40[0] != v41) {
        free(v40[0]);
      }
    }
  }
  return v14;
}

unint64_t sub_1CD522FB8(uint64_t a1, int a2, llvm::EVT *a3, int a4)
{
  if (sub_1CB87DC14(*(void *)(a1 + 24), *(void *)(a1 + 8), a3, (llvm::Type *)1) == 1) {
    return 4;
  }
  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), (llvm::LLVMContext **)a3, (uint64_t)&v20);
  uint64_t v8 = v20;
  if (!a4 && (*((_DWORD *)a3 + 2) & 0xFE) == 0x12)
  {
    unint64_t PrimitiveSizeInBits = llvm::Type::getPrimitiveSizeInBits(a3);
    int v12 = v11;
    unint64_t v13 = sub_1CB87E200(v21);
    BOOL v15 = v14 != 1 && v12 == 1;
    if (!v15 && PrimitiveSizeInBits < v13)
    {
      unsigned __int8 v16 = sub_1CB87DC14(*(void *)(a1 + 24), *(void *)(a1 + 8), a3, 0);
      BOOL v17 = v21[0] == 0;
      if (!v16) {
        BOOL v17 = 1;
      }
      if (a2 == 33)
      {
        if (!v17)
        {
          int v18 = *(unsigned __int8 *)(*(void *)(a1 + 24) + 179 * v21[0] + v16 + 137754);
          goto LABEL_18;
        }
      }
      else if (!v17)
      {
        int v18 = *(_WORD *)(*(void *)(a1 + 24) + 358 * v21[0] + 2 * v16 + 73672) >> 4;
LABEL_18:
        if ((v18 & 0xFFFFFFFB) == 0) {
          return v8;
        }
      }
      unint64_t v19 = sub_1CD5234F4(a1, (uint64_t)a3, a2 != 33, a2 == 33);
      if (__OFADD__(v8, v19)) {
        return ((uint64_t)(v8 + v19) >> 63) ^ 0x8000000000000000;
      }
      else {
        v8 += v19;
      }
    }
  }
  return v8;
}

unint64_t sub_1CD523148(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (a5) {
    return 1;
  }
  uint64_t v22 = v5;
  uint64_t v23 = v6;
  int v12 = *(llvm::TargetLoweringBase **)(a1 + 24);
  unsigned int v13 = llvm::TargetLoweringBase::InstructionOpcodeToISD(v12, a2);
  if (v13 == 190)
  {
    if ((*(_DWORD *)(a4 + 8) & 0xFE) == 0x12) {
      unsigned int v13 = 191;
    }
    else {
      unsigned int v13 = 190;
    }
  }
  llvm::TargetLoweringBase::getTypeLegalizationCost(v12, *(const llvm::DataLayout **)(a1 + 8), (llvm::LLVMContext **)a3, (uint64_t)&v19);
  if ((*(_DWORD *)(a3 + 8) & 0xFE) == 0x12)
  {
    if (v20 - 15 >= 0x9C) {
      goto LABEL_17;
    }
  }
  else if (!v20)
  {
    return 1;
  }
  if (*((void *)v12 + v20 + 12) && (v13 > 0x185 || *((unsigned char *)v12 + 390 * v20 + v13 + 3862) != 2))
  {
    uint64_t v17 = 1;
    LODWORD(v18) = 0;
    long long v21 = v19;
    sub_1CB90C9D4((uint64_t)&v21, (uint64_t)&v17);
    return v21;
  }
  if ((*(_DWORD *)(a3 + 8) & 0xFE) != 0x12) {
    return 1;
  }
LABEL_17:
  uint64_t v14 = *(unsigned int *)(a3 + 32);
  if (a4 && (*(_DWORD *)(a4 + 8) & 0xFE) == 0x12) {
    a4 = **(void **)(a4 + 16);
  }
  uint64_t v17 = sub_1CD523148(a1, a2, **(void **)(a3 + 16), a4, 0);
  uint64_t v18 = v15;
  unint64_t v16 = sub_1CD5234F4(a1, a3, 1, 0);
  *(void *)&long long v21 = v14;
  DWORD2(v21) = 0;
  sub_1CB90C9D4((uint64_t)&v21, (uint64_t)&v17);
  if (__OFADD__(v16, (void)v21)) {
    return ((uint64_t)(v16 + v21) >> 63) ^ 0x8000000000000000;
  }
  else {
    return v16 + v21;
  }
}

unint64_t sub_1CD52331C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  switch(sub_1CB90D34C(a2, a4, a5))
  {
    case 1u:
    case 2u:
    case 3u:
    case 6u:
    case 7u:
    case 8u:
      unint64_t result = 0;
      if (a3)
      {
        if (*(unsigned char *)(a3 + 8) == 18) {
          unint64_t result = sub_1CD524250(a1, a3);
        }
      }
      break;
    case 4u:
      unint64_t result = sub_1CD524458(a1, a3, a6);
      break;
    case 5u:
      unint64_t result = sub_1CD524350(a1, a3, a6);
      break;
    default:
      unint64_t result = 0;
      if (a3 && *(unsigned char *)(a3 + 8) == 18) {
        unint64_t result = sub_1CD524170(a1, a3);
      }
      break;
  }
  return result;
}

unint64_t sub_1CD5233F8(uint64_t a1, llvm::FixedVectorType *this, int a3, llvm::Type *a4, llvm::APIntOps *a5)
{
  llvm::FixedVectorType::get(this, a4);
  uint64_t v11 = v10;
  llvm::FixedVectorType::get(this, (llvm::Type *)(a4 * a3));
  uint64_t v13 = v12;
  llvm::APIntOps::ScaleBitMask(a5, a4, (uint64_t)&v17);
  unint64_t v14 = sub_1CD523F68(a1, v11, (uint64_t)&v17, 0, 1);
  unint64_t v15 = sub_1CD523F68(a1, v13, (uint64_t)a5, 1, 0);
  if (v18 >= 0x41 && v17) {
    MEMORY[0x1D25D9CB0](v17, 0x1000C8000313F17);
  }
  if (__OFADD__(v14, v15)) {
    return ((uint64_t)(v14 + v15) >> 63) ^ 0x8000000000000000;
  }
  else {
    return v14 + v15;
  }
}

unint64_t sub_1CD5234F4(uint64_t a1, uint64_t a2, int a3, int a4)
{
  sub_1CB8F1EEC((uint64_t)&v10, *(_DWORD *)(a2 + 32), -1);
  unint64_t v8 = sub_1CD523F68(a1, a2, (uint64_t)&v10, a3, a4);
  if (v11 >= 0x41 && v10) {
    MEMORY[0x1D25D9CB0](v10, 0x1000C8000313F17);
  }
  return v8;
}

unint64_t sub_1CD523594(uint64_t a1, uint64_t a2, llvm::FixedVectorType **a3, uint64_t a4, unsigned int a5)
{
  if (a4 & 0xFF00000000) == 0 || (a4) {
    return sub_1CD523C08(a1, a2, a3, a5);
  }
  else {
    return sub_1CD523B34(a1, a2, (uint64_t)a3, a5);
  }
}

unint64_t sub_1CD5235B0(uint64_t a1, llvm::FixedVectorType **a2, uint64_t a3, int a4)
{
  uint64_t v4 = a3;
  uint64_t v5 = (llvm::Type *)a2;
  uint64_t v6 = a1;
  if ((a2[1] & 0xFE) == 0x12) {
    unsigned int v7 = *(unsigned __int8 *)(*(void *)a2[2] + 8);
  }
  else {
    unsigned int v7 = *((_DWORD *)a2 + 2);
  }
  unint64_t v8 = a2[3];
  char v9 = *(llvm::FixedVectorType **)(a3 + 24);
  LODWORD(v10) = *((_DWORD *)a2 + 8);
  if (v7 >= 7) {
    uint64_t v11 = 53;
  }
  else {
    uint64_t v11 = 54;
  }
  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), a2, (uint64_t)v65);
  if (v66[0] - 15 > 0x9B)
  {
    unsigned int v13 = 1;
  }
  else
  {
    if (v66[0] - 120 <= 0x32) {
      llvm::reportInvalidSizeRequest((llvm *)"Possible incorrect use of MVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped, use MVT::getVectorElementCount() instead", v12);
    }
    unsigned int v13 = sub_1CB8C32B0(v66);
  }
  unsigned int v14 = __clz(v10);
  if (v10 <= v13)
  {
    unint64_t v55 = 0;
    int64_t v62 = 0;
    int v15 = 0;
  }
  else
  {
    unsigned int v51 = v14;
    int v15 = 0;
    int v16 = 0;
    uint64_t v52 = v9;
    __n128 v53 = v8;
    int64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v56 = v6;
    uint64_t v19 = (uint64_t)v5;
    unint64_t v20 = 0;
    unsigned int v57 = v11;
    unsigned int v54 = v13;
    uint64_t v21 = v6;
    do
    {
      int64_t v61 = v17;
      int v59 = v15;
      uint64_t v22 = v19;
      uint64_t v10 = (llvm::Type *)(v10 >> 1);
      llvm::FixedVectorType::get(v53, v10);
      uint64_t v19 = v23;
      llvm::FixedVectorType::get(v52, v10);
      uint64_t v4 = v24;
      unint64_t v25 = sub_1CD52331C(v21, 5, v22, 0, 0, v19);
      if (v26 == 1) {
        uint64_t v18 = 1;
      }
      if (__OFADD__(v20, v25)) {
        unint64_t v20 = ((uint64_t)(v20 + v25) >> 63) ^ 0x8000000000000000;
      }
      else {
        v20 += v25;
      }
      int v27 = v16;
      uint64_t v28 = v18;
      unint64_t v29 = sub_1CD523148(v21, v57, v19, v4, a4);
      int v31 = v30;
      unint64_t v32 = sub_1CD523148(v21, 57, v19, v4, a4);
      BOOL v34 = __OFADD__(v29, v32);
      int64_t v35 = v29 + v32;
      uint64_t v18 = v28;
      if (v34) {
        int64_t v35 = (v35 >> 63) ^ 0x8000000000000000;
      }
      if (v31 == 1 || v33 == 1) {
        int v16 = 1;
      }
      else {
        int v16 = v27;
      }
      BOOL v34 = __OFADD__(v61, v35);
      int64_t v17 = v61 + v35;
      if (v34) {
        int64_t v17 = (v17 >> 63) ^ 0x8000000000000000;
      }
      int v15 = v59 - 1;
    }
    while (v10 > v54);
    unint64_t v55 = v20;
    int64_t v62 = v17;
    uint64_t v6 = v56;
    uint64_t v11 = v57;
    uint64_t v5 = (llvm::Type *)v19;
    unsigned int v14 = v51;
  }
  uint64_t v37 = v15 - v14 + 31;
  unint64_t v63 = sub_1CD52331C(v6, 7, (uint64_t)v5, 0, 0, (uint64_t)v5);
  unint64_t v64 = v38;
  uint64_t v67 = v37;
  int v68 = 0;
  sub_1CB90C9D4((uint64_t)&v67, (uint64_t)&v63);
  uint64_t v60 = v67;
  unint64_t v39 = sub_1CD523148(v6, v11, (uint64_t)v5, v4, a4);
  unint64_t v41 = v40;
  unint64_t v42 = sub_1CD523148(v6, 57, (uint64_t)v5, v4, a4);
  unint64_t v43 = v41 & 0xFFFFFFFF00000000 | 1;
  if (v44 != 1) {
    unint64_t v43 = v41;
  }
  unint64_t v45 = v39 + v42;
  if (__OFADD__(v39, v42)) {
    unint64_t v45 = ((uint64_t)(v39 + v42) >> 63) ^ 0x8000000000000000;
  }
  unint64_t v63 = v45;
  unint64_t v64 = v43;
  uint64_t v67 = v37;
  int v68 = 0;
  sub_1CB90C9D4((uint64_t)&v67, (uint64_t)&v63);
  if ((*((_DWORD *)v5 + 2) & 0xFE) == 0x12) {
    uint64_t v5 = (llvm::Type *)**((void **)v5 + 2);
  }
  unint64_t v46 = v55 + v60;
  if (__OFADD__(v55, v60)) {
    unint64_t v46 = ((uint64_t)(v55 + v60) >> 63) ^ 0x8000000000000000;
  }
  int64_t v47 = v62 + v67;
  if (__OFADD__(v62, v67)) {
    int64_t v47 = (v47 >> 63) ^ 0x8000000000000000;
  }
  BOOL v34 = __OFADD__(v46, v47);
  uint64_t v48 = v46 + v47;
  if (v34) {
    unint64_t v49 = (v48 >> 63) ^ 0x8000000000000000;
  }
  else {
    unint64_t v49 = v48;
  }
  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(v6 + 24), *(const llvm::DataLayout **)(v6 + 8), (llvm::LLVMContext **)v5, (uint64_t)&v67);
  if (__OFADD__(v49, v67)) {
    return ((uint64_t)(v49 + v67) >> 63) ^ 0x8000000000000000;
  }
  else {
    return v49 + v67;
  }
}

unint64_t sub_1CD523948(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (a6)
  {
    uint64_t v12 = (llvm::FixedVectorType *)llvm::PointerType::get(*(llvm::PointerType **)(a3 + 24), 0);
    llvm::FixedVectorType::get(v12, (llvm::Type *)*(unsigned int *)(a3 + 32));
    unsigned int v14 = (llvm::LLVMContext **)v13;
    if ((*(_DWORD *)(v13 + 8) & 0xFE) == 0x12) {
      unsigned int v14 = **(llvm::LLVMContext ****)(v13 + 16);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v14, (uint64_t)&v37);
    int v15 = v37;
    unint64_t v16 = v38;
  }
  else
  {
    int v15 = 0;
    unint64_t v16 = 0;
  }
  int64_t v17 = (llvm::Type *)*(unsigned int *)(a3 + 32);
  unint64_t v18 = sub_1CD522FB8(a1, a2, *(llvm::EVT **)(a3 + 24), a7);
  unint64_t v19 = v16 & 0xFFFFFFFF00000000 | 1;
  if (v20 != 1) {
    unint64_t v19 = v16;
  }
  unint64_t v21 = (unint64_t)v15 + v18;
  if (__OFADD__(v15, v18)) {
    unint64_t v21 = ((uint64_t)((uint64_t)v15 + v18) >> 63) ^ 0x8000000000000000;
  }
  unint64_t v35 = v21;
  unint64_t v36 = v19;
  uint64_t v37 = v17;
  LODWORD(v38) = 0;
  sub_1CB90C9D4((uint64_t)&v37, (uint64_t)&v35);
  uint64_t v22 = v37;
  unint64_t v23 = sub_1CD5234F4(a1, a3, a2 != 33, a2 == 33);
  if (a5)
  {
    uint64_t v24 = (llvm::Type *)*(unsigned int *)(a3 + 32);
    llvm::FixedVectorType::get((llvm::FixedVectorType *)(**(void **)a3 + 1888), v24);
    int v26 = (llvm::LLVMContext **)v25;
    if ((*(_DWORD *)(v25 + 8) & 0xFE) == 0x12) {
      int v26 = **(llvm::LLVMContext ****)(v25 + 16);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v26, (uint64_t)&v37);
    uint64_t v27 = (uint64_t)v37 + 1;
    if (__OFADD__(v37, 1)) {
      uint64_t v27 = 0x7FFFFFFFFFFFFFFFLL;
    }
    BOOL v28 = a7 == 0;
    BOOL v29 = __OFADD__(v27, v28);
    uint64_t v30 = v27 + v28;
    if (v29) {
      uint64_t v30 = 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v35 = v30;
    unint64_t v36 = v38;
    uint64_t v37 = v24;
    LODWORD(v38) = 0;
    sub_1CB90C9D4((uint64_t)&v37, (uint64_t)&v35);
    int v31 = v37;
  }
  else
  {
    int v31 = 0;
  }
  unint64_t v32 = (unint64_t)v22 + v23;
  if (__OFADD__(v22, v23)) {
    unint64_t v32 = ((uint64_t)((uint64_t)v22 + v23) >> 63) ^ 0x8000000000000000;
  }
  BOOL v29 = __OFADD__(v32, v31);
  uint64_t v33 = (uint64_t)v31 + v32;
  if (v29) {
    return (v33 >> 63) ^ 0x8000000000000000;
  }
  else {
    return v33;
  }
}

unint64_t sub_1CD523B34(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(unsigned char *)(a3 + 8) == 19) {
    return 0;
  }
  unint64_t v9 = sub_1CD5234F4(a1, a3, 0, 1);
  v11[0] = sub_1CD522C04(a1, a2, *(void *)(a3 + 24), a4, 0, 0);
  v11[1] = v10;
  uint64_t v12 = *(unsigned int *)(a3 + 32);
  int v13 = 0;
  sub_1CB90C9D4((uint64_t)v11, (uint64_t)&v12);
  if (__OFADD__(v9, v11[0])) {
    return ((uint64_t)(v9 + v11[0]) >> 63) ^ 0x8000000000000000;
  }
  else {
    return v9 + v11[0];
  }
}

unint64_t sub_1CD523C08(uint64_t a1, uint64_t a2, llvm::FixedVectorType **a3, unsigned int a4)
{
  uint64_t v5 = (llvm::Type *)a3;
  unint64_t v8 = a3[3];
  LODWORD(v9) = *((_DWORD *)a3 + 8);
  if ((a2 & 0xFFFFFFFE) == 0x1C
    && (v8 == (llvm::FixedVectorType *)(*(void *)*a3 + 1888) ? (BOOL v10 = v9 >= 2) : (BOOL v10 = 0), v10))
  {
    uint64_t v33 = (llvm::Type ***)llvm::IntegerType::get(*a3, (llvm::LLVMContext *)*((unsigned int *)a3 + 8));
    uint64_t v34 = sub_1CC30FB74(a1, 49, v33, (llvm::Type ***)v5, 0, a4, 0);
    sub_1CB90C994(v33);
    unint64_t v36 = sub_1CD523148(a1, 53, (uint64_t)v33, v35, a4);
    BOOL v30 = __OFADD__(v34, v36);
    uint64_t v31 = v34 + v36;
  }
  else
  {
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), a3, (uint64_t)v42);
    if (v43[0] - 15 > 0x9B)
    {
      unsigned int v12 = 1;
    }
    else
    {
      if (v43[0] - 120 <= 0x32) {
        llvm::reportInvalidSizeRequest((llvm *)"Possible incorrect use of MVT::getVectorNumElements() for scalable vector. Scalable flag may be dropped, use MVT::getVectorElementCount() instead", v11);
      }
      unsigned int v12 = sub_1CB8C32B0(v43);
    }
    unsigned int v13 = __clz(v9);
    if (v9 <= v12)
    {
      uint64_t v22 = a2;
      unint64_t v16 = 0;
      unint64_t v15 = 0;
      int v14 = 0;
    }
    else
    {
      unsigned int v37 = v13;
      unsigned int v39 = a2;
      int v14 = 0;
      unint64_t v15 = 0;
      unint64_t v16 = 0;
      unsigned int v38 = v12;
      do
      {
        unint64_t v9 = (llvm::Type *)(v9 >> 1);
        llvm::FixedVectorType::get(v8, v9);
        unint64_t v17 = v15;
        uint64_t v19 = v18;
        unint64_t v20 = sub_1CD52331C(a1, 5, (uint64_t)v5, 0, 0, v18);
        if (__OFADD__(v16, v20)) {
          unint64_t v16 = ((uint64_t)(v16 + v20) >> 63) ^ 0x8000000000000000;
        }
        else {
          v16 += v20;
        }
        uint64_t v5 = (llvm::Type *)v19;
        unint64_t v21 = sub_1CD522C04(a1, v39, v19, a4, 0, 0);
        if (__OFADD__(v17, v21)) {
          unint64_t v15 = ((uint64_t)(v17 + v21) >> 63) ^ 0x8000000000000000;
        }
        else {
          unint64_t v15 = v17 + v21;
        }
        --v14;
      }
      while (v9 > v38);
      uint64_t v22 = v39;
      unsigned int v13 = v37;
    }
    uint64_t v23 = v14 - v13 + 31;
    unint64_t v40 = sub_1CD52331C(a1, 7, (uint64_t)v5, 0, 0, (uint64_t)v5);
    uint64_t v41 = v24;
    uint64_t v44 = v23;
    int v45 = 0;
    sub_1CB90C9D4((uint64_t)&v44, (uint64_t)&v40);
    if (__OFADD__(v16, v44)) {
      unint64_t v25 = ((uint64_t)(v16 + v44) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v25 = v16 + v44;
    }
    unint64_t v40 = sub_1CD522C04(a1, v22, (uint64_t)v5, a4, 0, 0);
    uint64_t v41 = v26;
    uint64_t v44 = v23;
    int v45 = 0;
    sub_1CB90C9D4((uint64_t)&v44, (uint64_t)&v40);
    unint64_t v27 = v15 + v44;
    if (__OFADD__(v15, v44)) {
      unint64_t v27 = ((uint64_t)(v15 + v44) >> 63) ^ 0x8000000000000000;
    }
    BOOL v30 = __OFADD__(v25, v27);
    uint64_t v28 = v25 + v27;
    if (v30) {
      unint64_t v29 = (v28 >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v29 = v28;
    }
    if ((*((_DWORD *)v5 + 2) & 0xFE) == 0x12) {
      uint64_t v5 = (llvm::Type *)**((void **)v5 + 2);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), (llvm::LLVMContext **)v5, (uint64_t)&v44);
    BOOL v30 = __OFADD__(v29, v44);
    uint64_t v31 = v29 + v44;
  }
  if (v30) {
    return (v31 >> 63) ^ 0x8000000000000000;
  }
  else {
    return v31;
  }
}

unint64_t sub_1CD523F68(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  int v5 = *(_DWORD *)(a2 + 32);
  if (v5 < 1) {
    return 0;
  }
  unsigned int v11 = 0;
  unint64_t v12 = 0;
  do
  {
    if (*(_DWORD *)(a3 + 8) >= 0x41u) {
      unsigned int v13 = (void *)(*(void *)a3 + 8 * (v11 >> 6));
    }
    else {
      unsigned int v13 = (void *)a3;
    }
    if ((*v13 >> v11))
    {
      if (a4)
      {
        int v14 = (llvm::LLVMContext **)a2;
        if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12) {
          int v14 = **(llvm::LLVMContext ****)(a2 + 16);
        }
        llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v14, (uint64_t)&v17);
        if (__OFADD__(v12, v17)) {
          unint64_t v12 = ((uint64_t)(v12 + v17) >> 63) ^ 0x8000000000000000;
        }
        else {
          v12 += v17;
        }
      }
      if (a5)
      {
        unint64_t v15 = (llvm::LLVMContext **)a2;
        if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12) {
          unint64_t v15 = **(llvm::LLVMContext ****)(a2 + 16);
        }
        llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v15, (uint64_t)&v17);
        if (__OFADD__(v12, v17)) {
          unint64_t v12 = ((uint64_t)(v12 + v17) >> 63) ^ 0x8000000000000000;
        }
        else {
          v12 += v17;
        }
      }
    }
    ++v11;
  }
  while (v5 != v11);
  return v12;
}

unint64_t sub_1CD5240BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = sub_1CD5234F4(a1, a2, 1, 0);
  if (a4) {
    unint64_t v11 = sub_1CC3121A4(a1, a3, a4, a5);
  }
  else {
    unint64_t v11 = sub_1CD5234F4(a1, a2, 0, 1);
  }
  if (__OFADD__(v10, v11)) {
    return ((uint64_t)(v10 + v11) >> 63) ^ 0x8000000000000000;
  }
  else {
    return v10 + v11;
  }
}

unint64_t sub_1CD524170(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(llvm::TargetLoweringBase **)(a1 + 24);
  int v5 = (llvm::LLVMContext **)a2;
  if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12) {
    int v5 = **(llvm::LLVMContext ****)(a2 + 16);
  }
  llvm::TargetLoweringBase::getTypeLegalizationCost(v4, *(const llvm::DataLayout **)(a1 + 8), v5, (uint64_t)&v10);
  unint64_t v6 = v10;
  int v7 = *(_DWORD *)(a2 + 32);
  if (v7 >= 1)
  {
    do
    {
      unint64_t v8 = (llvm::LLVMContext **)a2;
      if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12) {
        unint64_t v8 = **(llvm::LLVMContext ****)(a2 + 16);
      }
      llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v8, (uint64_t)&v10);
      if (__OFADD__(v6, v10)) {
        unint64_t v6 = ((uint64_t)(v6 + v10) >> 63) ^ 0x8000000000000000;
      }
      else {
        v6 += v10;
      }
      --v7;
    }
    while (v7);
  }
  return v6;
}

unint64_t sub_1CD524250(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 32);
  if (v2 < 1) {
    return 0;
  }
  unint64_t v5 = 0;
  do
  {
    unint64_t v6 = (llvm::LLVMContext **)a2;
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12) {
      unint64_t v6 = **(llvm::LLVMContext ****)(a2 + 16);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v6, (uint64_t)&v10);
    if (__OFADD__(v5, v10)) {
      unint64_t v7 = ((uint64_t)(v5 + v10) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v7 = v5 + v10;
    }
    unint64_t v8 = (llvm::LLVMContext **)a2;
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12) {
      unint64_t v8 = **(llvm::LLVMContext ****)(a2 + 16);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v8, (uint64_t)&v10);
    if (__OFADD__(v7, v10)) {
      unint64_t v5 = ((uint64_t)(v7 + v10) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v5 = v7 + v10;
    }
    --v2;
  }
  while (v2);
  return v5;
}

unint64_t sub_1CD524350(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a3 + 32);
  if (!v3) {
    return 0;
  }
  unint64_t v7 = 0;
  do
  {
    unint64_t v8 = (llvm::LLVMContext **)a2;
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12) {
      unint64_t v8 = **(llvm::LLVMContext ****)(a2 + 16);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v8, (uint64_t)&v12);
    if (__OFADD__(v7, v12)) {
      unint64_t v9 = ((uint64_t)(v7 + v12) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v9 = v7 + v12;
    }
    uint64_t v10 = (llvm::LLVMContext **)a3;
    if ((*(_DWORD *)(a3 + 8) & 0xFE) == 0x12) {
      uint64_t v10 = **(llvm::LLVMContext ****)(a3 + 16);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v10, (uint64_t)&v12);
    if (__OFADD__(v9, v12)) {
      unint64_t v7 = ((uint64_t)(v9 + v12) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v7 = v9 + v12;
    }
    --v3;
  }
  while (v3);
  return v7;
}

unint64_t sub_1CD524458(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a3 + 32);
  if (!v3) {
    return 0;
  }
  unint64_t v7 = 0;
  do
  {
    unint64_t v8 = (llvm::LLVMContext **)a3;
    if ((*(_DWORD *)(a3 + 8) & 0xFE) == 0x12) {
      unint64_t v8 = **(llvm::LLVMContext ****)(a3 + 16);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v8, (uint64_t)&v12);
    if (__OFADD__(v7, v12)) {
      unint64_t v9 = ((uint64_t)(v7 + v12) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v9 = v7 + v12;
    }
    uint64_t v10 = (llvm::LLVMContext **)a2;
    if ((*(_DWORD *)(a2 + 8) & 0xFE) == 0x12) {
      uint64_t v10 = **(llvm::LLVMContext ****)(a2 + 16);
    }
    llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(a1 + 24), *(const llvm::DataLayout **)(a1 + 8), v10, (uint64_t)&v12);
    if (__OFADD__(v9, v12)) {
      unint64_t v7 = ((uint64_t)(v9 + v12) >> 63) ^ 0x8000000000000000;
    }
    else {
      unint64_t v7 = v9 + v12;
    }
    --v3;
  }
  while (v3);
  return v7;
}

uint64_t sub_1CD524560(uint64_t result, llvm::Loop *a2, uint64_t a3, uint64_t ****a4)
{
  unint64_t v15 = a2;
  if (word_1EBD04D00)
  {
    int v6 = dword_1EBD04D78;
  }
  else
  {
    int v6 = *(_DWORD *)(*(void *)(*(void *)(result + 16) + 160) + 8);
    if (!v6) {
      return result;
    }
  }
  uint64_t v7 = *((void *)a2 + 4);
  uint64_t v8 = *((void *)a2 + 5);
  if (v8 != v7)
  {
    uint64_t v9 = result + 8;
    while (2)
    {
      uint64_t v10 = *(void *)v7 + 40;
      for (uint64_t i = *(void *)(*(void *)v7 + 48); i != v10; uint64_t i = *(void *)(i + 8))
      {
        if (i) {
          uint64_t v12 = i - 24;
        }
        else {
          uint64_t v12 = 0;
        }
        int v13 = *(unsigned __int8 *)(v12 + 16);
        if (v13 == 84 || v13 == 33)
        {
          uint64_t v14 = *(void *)(v12 - 32);
          if (!v14
            || *(unsigned char *)(v14 + 16)
            || *(void *)(v14 + 24) != *(void *)(v12 + 72)
            || (unint64_t result = sub_1CB9091FC(v9, (uint64_t ***)v14), result))
          {
            if (a4) {
              return sub_1CC312450(a4, &v15);
            }
            return result;
          }
        }
      }
      v7 += 8;
      if (v7 != v8) {
        continue;
      }
      break;
    }
  }
  *(unsigned char *)(a3 + 45) = 1;
  *(_WORD *)(a3 + 40) = 257;
  *(_DWORD *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = v6;
  *(_DWORD *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 36) = 2;
  return result;
}

unint64_t sub_1CD524694(uint64_t a1, uint64_t a2, llvm::Type ***a3, uint64_t a4)
{
  uint64_t v8 = *(llvm::TargetLoweringBase **)(a1 + 24);
  uint64_t v9 = (llvm::LLVMContext **)a4;
  if ((*(_DWORD *)(a4 + 8) & 0xFE) == 0x12) {
    uint64_t v9 = **(llvm::LLVMContext ****)(a4 + 16);
  }
  llvm::TargetLoweringBase::getTypeLegalizationCost(v8, *(const llvm::DataLayout **)(a1 + 8), v9, (uint64_t)&v13);
  uint64_t v10 = v13;
  uint64_t v11 = sub_1CC30FB74(a1, a2, a3, *(llvm::Type ****)(a4 + 24), 0, 0, 0);
  if (__OFADD__(v10, v11)) {
    return ((v10 + v11) >> 63) ^ 0x8000000000000000;
  }
  else {
    return v10 + v11;
  }
}

unint64_t sub_1CD524748(uint64_t a1, int a2, uint64_t a3, unsigned int a4, unsigned int *a5, unint64_t a6, unsigned __int8 a7, int a8, char a9, char a10)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  unint64_t v16 = (llvm::Type *)*(unsigned int *)(a3 + 32);
  uint64_t v17 = (llvm::Type *)(v16 / a4);
  llvm::FixedVectorType::get(*(llvm::FixedVectorType **)(a3 + 24), v17);
  uint64_t v63 = v18;
  int v64 = a8;
  if ((a9 & 1) != 0 || a10)
  {
    uint64_t v19 = a1;
    unint64_t v20 = sub_1CD523948(a1, a2, a3, a7, 1, 0, a8);
  }
  else
  {
    uint64_t v19 = a1;
    unint64_t v20 = sub_1CD522FB8(a1, a2, (llvm::EVT *)a3, a8);
  }
  unint64_t v66 = v20;
  int v22 = v21;
  llvm::TargetLoweringBase::getTypeLegalizationCost(*(llvm::TargetLoweringBase **)(v19 + 24), *(const llvm::DataLayout **)(v19 + 8), (llvm::LLVMContext **)a3, (uint64_t)&v77);
  unsigned __int8 v76 = v79[0];
  uint64_t v24 = sub_1CB83544C(*(void *)(v19 + 8), a3);
  unint64_t v25 = v17;
  if (v23 == 1) {
  uint64_t v27 = sub_1CB87E200(&v76);
  }
  if (v26 == 1) {
  if (!v22)
  }
  {
    unint64_t v28 = (unint64_t)(v27 + 7) >> 3;
    if (((unint64_t)(v24 + 7) >> 3) > v28)
    {
      unint64_t v29 = (((unint64_t)(v24 + 7) >> 3) + (unint64_t)v28 - 1)
          / ((unint64_t)(v27 + 7) >> 3);
      uint64_t v30 = v29 - 1;
      char v77 = v79;
      uint64_t v78 = 0x600000000;
      sub_1CB90D610((uint64_t)&v77, (v29 + 63) >> 6, 0);
      int v80 = v29;
      uint64_t v31 = (int8x8_t *)v77;
      if (a6)
      {
        if (v25 <= 1) {
          int v32 = 1;
        }
        else {
          int v32 = (int)v25;
        }
        uint64_t v33 = a5;
        do
        {
          if (v16 >= a4)
          {
            unsigned int v34 = *v33;
            int v35 = v32;
            do
            {
              *(void *)&v31[(v34 / (((unint64_t)v16 + v30) / v29)) >> 6] |= 1 << (v34 / (((unint64_t)v16 + v30) / v29));
              v34 += a4;
              --v35;
            }
            while (v35);
          }
          ++v33;
        }
        while (v33 != &a5[a6]);
      }
      if (v78)
      {
        LODWORD(v36) = 0;
        uint64_t v37 = 8 * v78;
        unsigned int v38 = v31;
        do
        {
          int8x8_t v39 = *v38++;
          uint8x8_t v40 = (uint8x8_t)vcnt_s8(v39);
          v40.i16[0] = vaddlv_u8(v40);
          uint64_t v36 = (v36 + v40.i32[0]);
          v37 -= 8;
        }
        while (v37);
      }
      else
      {
        uint64_t v36 = 0;
      }
      unint64_t v66 = (v30 + v36 * v66) / v29;
      if (v31 != (int8x8_t *)v79) {
        free(v31);
      }
    }
  }
  sub_1CB8F1EEC((uint64_t)&v74, v25, -1);
  sub_1CB8F1EEC((uint64_t)&v72, v16, -1);
  sub_1CB8F1EEC((uint64_t)&v70, v16, 0);
  if (a6)
  {
    uint64_t v41 = &a5[a6];
    unsigned int v42 = v71;
    if (v25 <= 1) {
      int v43 = 1;
    }
    else {
      int v43 = (int)v25;
    }
    do
    {
      if (v16 >= a4)
      {
        unsigned int v44 = *a5;
        int v45 = v43;
        do
        {
          uint64_t v46 = 1 << v44;
          if (v42 > 0x40) {
            *(void *)(v70 + 8 * (v44 >> 6)) |= v46;
          }
          else {
            v70 |= v46;
          }
          v44 += a4;
          --v45;
        }
        while (v45);
      }
      ++a5;
    }
    while (a5 != v41);
  }
  if (a2 == 32)
  {
    unint64_t v68 = sub_1CD523F68(a1, v63, (uint64_t)&v74, 1, 0);
    uint64_t v69 = v47;
    char v77 = (void *)a6;
    LODWORD(v78) = 0;
    sub_1CB90C9D4((uint64_t)&v77, (uint64_t)&v68);
    if (__OFADD__(v66, v77)) {
      uint64_t v48 = (char *)(((uint64_t)((uint64_t)v77 + v66) >> 63) ^ 0x8000000000000000);
    }
    else {
      uint64_t v48 = (char *)v77 + v66;
    }
    uint64_t v49 = a1;
    uint64_t v50 = a3;
    int v51 = 0;
    int v52 = 1;
  }
  else
  {
    unint64_t v68 = a6;
    LODWORD(v69) = 0;
    char v77 = (void *)sub_1CD523F68(a1, v63, (uint64_t)&v74, 0, 1);
    uint64_t v78 = v53;
    sub_1CB90C9D4((uint64_t)&v77, (uint64_t)&v68);
    if (__OFADD__(v66, v77)) {
      uint64_t v48 = (char *)(((uint64_t)((uint64_t)v77 + v66) >> 63) ^ 0x8000000000000000);
    }
    else {
      uint64_t v48 = (char *)v77 + v66;
    }
    uint64_t v49 = a1;
    uint64_t v50 = a3;
    int v51 = 1;
    int v52 = 0;
  }
  unint64_t v54 = sub_1CD523F68(v49, v50, (uint64_t)&v70, v51, v52);
  if (__OFADD__(v48, v54)) {
    unint64_t v56 = ((uint64_t)&v48[v54] >> 63) ^ 0x8000000000000000;
  }
  else {
    unint64_t v56 = (unint64_t)&v48[v54];
  }
  if (a9)
  {
    Int8Ty = (llvm::FixedVectorType *)llvm::Type::getInt8Ty(*(llvm::Type **)a3, v55);
    int v59 = (llvm::APIntOps *)(a10 ? &v70 : &v72);
    unint64_t v60 = sub_1CD5233F8(a1, Int8Ty, a4, v25, v59);
    if (__OFADD__(v56, v60)) {
      unint64_t v56 = ((uint64_t)(v56 + v60) >> 63) ^ 0x8000000000000000;
    }
    else {
      v56 += v60;
    }
    if (a10)
    {
      llvm::FixedVectorType::get(Int8Ty, v16);
      unint64_t v62 = sub_1CD522C04(a1, 28, v61, v64, 0, 0);
      if (__OFADD__(v56, v62)) {
        unint64_t v56 = ((uint64_t)(v56 + v62) >> 63) ^ 0x8000000000000000;
      }
      else {
        v56 += v62;
      }
    }
  }
  if (v71 >= 0x41 && v70) {
    MEMORY[0x1D25D9CB0](v70, 0x1000C8000313F17);
  }
  if (v73 >= 0x41 && v72) {
    MEMORY[0x1D25D9CB0](v72, 0x1000C8000313F17);
  }
  if (v75 >= 0x41 && v74) {
    MEMORY[0x1D25D9CB0](v74, 0x1000C8000313F17);
  }
  return v56;
}

unint64_t sub_1CD524CA8(uint64_t a1, int a2, int a3, llvm::FixedVectorType *a4, uint64_t a5, unsigned int a6)
{
  llvm::VectorType::get(a4, (llvm::Type *)(*(unsigned int *)(a5 + 32) | ((unint64_t)(*(unsigned char *)(a5 + 8) == 19) << 32)));
  uint64_t v12 = (llvm::Type ***)v11;
  unint64_t v13 = sub_1CD523C08(a1, 13, v11, a6);
  if (a3) {
    uint64_t v14 = 39;
  }
  else {
    uint64_t v14 = 40;
  }
  uint64_t v15 = sub_1CC30FB74(a1, v14, v12, (llvm::Type ***)a5, 0, a6, 0);
  v20[0] = v15;
  v20[1] = v16;
  if (a2)
  {
    unint64_t v17 = sub_1CD522C04(a1, 17, (uint64_t)v12, a6, 0, 0);
    uint64_t v21 = 2;
    int v22 = 0;
    sub_1CB90C9D4((uint64_t)v20, (uint64_t)&v21);
    uint64_t v15 = v20[0];
  }
  else
  {
    unint64_t v17 = 0;
  }
  unint64_t v18 = v13 + v17;
  if (__OFADD__(v13, v17)) {
    unint64_t v18 = ((uint64_t)(v13 + v17) >> 63) ^ 0x8000000000000000;
  }
  if (__OFADD__(v18, v15)) {
    return ((uint64_t)(v18 + v15) >> 63) ^ 0x8000000000000000;
  }
  else {
    return v18 + v15;
  }
}

uint64_t sub_1CD524DF4(uint64_t a1, uint64_t a2)
{
  _OWORD v20[4] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a2 + 20);
  if ((v4 & 0x40000000) != 0)
  {
    int v6 = *(char **)(a2 - 8);
    uint64_t v5 = v4 & 0x7FFFFFF;
  }
  else
  {
    uint64_t v5 = v4 & 0x7FFFFFF;
    int v6 = (char *)(a2 - 32 * v5);
  }
  unint64_t v18 = v20;
  uint64_t v19 = 0x400000000;
  sub_1CB90CA80((uint64_t)&v18, v6, &v6[32 * v5]);
  uint64_t v7 = sub_1CC30E504(a1, (int **)a2, (uint64_t)v18, v19, 1);
  BOOL v9 = v7 < 0;
  if (v8) {
    BOOL v9 = v8 < 0;
  }
  if (!v9)
  {
    BOOL v10 = v8 < 1;
    if (!v8) {
      BOOL v10 = v7 < 1;
    }
    if (v10)
    {
      uint64_t v11 = 0;
      goto LABEL_13;
    }
  }
  int v12 = *(unsigned __int8 *)(a2 + 16);
  if (v12 == 60)
  {
    uint64_t v11 = 4;
    goto LABEL_13;
  }
  uint64_t v14 = *(int **)a2;
  if (v12 == 84)
  {
    uint64_t v15 = *(void *)(a2 - 32);
    if (!v15
      || *(unsigned char *)(v15 + 16)
      || *(void *)(v15 + 24) != *(void *)(a2 + 72)
      || (sub_1CB9091FC(a1, (uint64_t ***)v15) & 1) != 0)
    {
      uint64_t v11 = 40;
      goto LABEL_13;
    }
    if (*((unsigned char *)v14 + 8) == 16 && v14) {
      uint64_t v14 = (int *)**((void **)v14 + 2);
    }
  }
  int v16 = v14[2];
  unsigned int v17 = v16;
  if (v14 && (v16 & 0xFE) == 0x12) {
    unsigned int v17 = *(unsigned __int8 *)(*((void *)v14 + 3) + 8);
  }
  if (v17 >= 7) {
    uint64_t v11 = 1;
  }
  else {
    uint64_t v11 = 3;
  }
LABEL_13:
  if (v18 != v20) {
    free(v18);
  }
  return v11;
}

void llvm::initializeLocalStackSlotPassPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD480, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC312840;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCCD480, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

BOOL sub_1CD52500C(uint64_t a1, int *a2)
{
  sub_1CBAE0240(a1, a2, (uint64_t)&v8);
  int v4 = v9;
  if (v9)
  {
    int v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 48);
    if (v6 >= *(_DWORD *)(a1 + 52)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(_DWORD *)(*(void *)(a1 + 40) + 4 * v6) = v5;
    ++*(_DWORD *)(a1 + 48);
  }
  return v4 != 0;
}

uint64_t sub_1CD52509C(uint64_t result, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(result + 120);
  if (v3 >= *(_DWORD *)(result + 124)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  int v4 = (void *)(*(void *)(result + 112) + 16 * v3);
  void *v4 = a2;
  v4[1] = a3;
  ++*(_DWORD *)(result + 120);
  *(unsigned char *)(*(void *)(result + 8) + 40 * (*(_DWORD *)(result + 32) + a2) + 32) = 1;
  return result;
}

void llvm::LoopTraversal::traverse(llvm::LoopTraversal *this@<X0>, llvm::MachineFunction *a2@<X1>, uint64_t a3@<X8>)
{
  v44[4] = *MEMORY[0x1E4F143B8];
  sub_1CD525504((uint64_t)this, ((*((void *)a2 + 14) - *((void *)a2 + 13)) >> 3));
  uint64_t v6 = *((void *)a2 + 41);
  uint64_t v40 = 0;
  uint64_t v41 = v6;
  std::string __p = 0;
  int8x8_t v39 = 0;
  sub_1CD50D084((char **)&__p, &v41);
  unsigned int v42 = v44;
  uint64_t v43 = 0x400000000;
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x400000000;
  uint64_t v8 = (char *)__p;
  uint64_t v7 = v39;
  if (v39 != __p)
  {
    do
    {
      uint64_t v10 = *((void *)v7 - 1);
      v7 -= 8;
      uint64_t v9 = v10;
      uint64_t v11 = *(void *)this + 16 * *(unsigned int *)(v10 + 24);
      *(unsigned char *)uint64_t v11 = 1;
      *(_DWORD *)(v11 + 8) = *(_DWORD *)(v11 + 4);
      if (!HIDWORD(v43)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)unsigned int v42 = v9;
      BOOL v12 = __CFADD__(v43, 1);
      unsigned int v13 = v43 + 1;
      LODWORD(v43) = v43 + 1;
      if (!v12)
      {
        char v14 = 1;
        do
        {
          uint64_t v15 = *((void *)v42 + v13 - 1);
          LODWORD(v43) = v13 - 1;
          uint64_t v16 = *(unsigned int *)(v15 + 24);
          if (*(unsigned char *)(*(void *)this + 16 * v16)
            && (unsigned int v17 = (_DWORD *)(*(void *)this + 16 * v16), v17[3] == v17[2]))
          {
            BOOL v18 = v17[1] == ((*(void *)(v15 + 72) - *(void *)(v15 + 64)) >> 3);
            if (v17[1] == ((*(void *)(v15 + 72) - *(void *)(v15 + 64)) >> 3)) {
              uint64_t v19 = 256;
            }
            else {
              uint64_t v19 = 0;
            }
          }
          else
          {
            BOOL v18 = 0;
            uint64_t v19 = 0;
          }
          unint64_t v20 = *(unsigned int *)(a3 + 8);
          if (v20 >= *(unsigned int *)(a3 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v21 = (void *)(*(void *)a3 + 16 * v20);
          *uint64_t v21 = v15;
          v21[1] = v19 | v14 & 1;
          ++*(_DWORD *)(a3 + 8);
          uint64_t v23 = *(uint64_t **)(v15 + 88);
          int v22 = *(uint64_t **)(v15 + 96);
          while (v23 != v22)
          {
            uint64_t v24 = *v23;
            uint64_t v25 = *(unsigned int *)(*v23 + 24);
            uint64_t v26 = *(void *)this;
            int v27 = *(unsigned __int8 *)(*(void *)this + 16 * v25);
            if (!*(unsigned char *)(*(void *)this + 16 * v25)
              || (unint64_t v28 = (_DWORD *)(v26 + 16 * v25), v28[3] != v28[2])
              || v28[1] != ((*(void *)(v24 + 72) - *(void *)(v24 + 64)) >> 3))
            {
              if (v14) {
                ++*(_DWORD *)(v26 + 16 * v25 + 4);
              }
              if (v18) {
                ++*(_DWORD *)(v26 + 16 * v25 + 12);
              }
              if (v27)
              {
                unint64_t v29 = (_DWORD *)(v26 + 16 * v25);
                if (v29[3] == v29[2] && v29[1] == ((*(void *)(v24 + 72) - *(void *)(v24 + 64)) >> 3))
                {
                  if (v43 >= (unint64_t)HIDWORD(v43)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *((void *)v42 + v43) = v24;
                  LODWORD(v43) = v43 + 1;
                }
              }
            }
            ++v23;
          }
          char v14 = 0;
          unsigned int v13 = v43;
        }
        while (v43);
      }
    }
    while (v7 != v8);
    uint64_t v31 = (char *)__p;
    uint64_t v30 = v39;
    if (v39 != __p)
    {
      do
      {
        uint64_t v33 = *((void *)v30 - 1);
        v30 -= 8;
        uint64_t v32 = v33;
        uint64_t v34 = *(unsigned int *)(v33 + 24);
        if (*(unsigned char *)(*(void *)this + 16 * v34))
        {
          int v35 = (_DWORD *)(*(void *)this + 16 * v34);
          if (v35[3] == v35[2] && v35[1] == ((*(void *)(v32 + 72) - *(void *)(v32 + 64)) >> 3)) {
            continue;
          }
        }
        unint64_t v36 = *(unsigned int *)(a3 + 8);
        if (v36 >= *(unsigned int *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v37 = (void *)(*(void *)a3 + 16 * v36);
        *uint64_t v37 = v32;
        v37[1] = 256;
        ++*(_DWORD *)(a3 + 8);
      }
      while (v30 != v31);
    }
  }
  *((_DWORD *)this + 2) = 0;
  if (v42 != v44) {
    free(v42);
  }
  if (__p)
  {
    int8x8_t v39 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1CD525504(uint64_t a1, unint64_t a2)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  unint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4 >= a2) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = *(unsigned int *)(a1 + 8);
  }
  if (v5)
  {
    bzero(*(void **)a1, 16 * v5);
    unint64_t v4 = *(unsigned int *)(a1 + 8);
  }
  if (a2 > v4) {
    bzero((void *)(*(void *)a1 + 16 * v4), 16 * (a2 - v4));
  }
  *(_DWORD *)(a1 + 8) = a2;
}

uint64_t llvm::getMVTForLLT(unint64_t a1)
{
  unint64_t v18 = a1;
  if ((a1 & 0xFFFFFFFFFFFFFFF9) != 0 && (a1 & 4) != 0)
  {
    uint64_t v17 = sub_1CBA15978(&v18);
    int v2 = sub_1CB8F1DC4((unint64_t *)&v17);
    if (v1 == 1) {
    if (v2 > 31)
    }
    {
      char v13 = 6;
      char v14 = 7;
      if (v2 != 128) {
        char v14 = 0;
      }
      if (v2 != 64) {
        char v13 = v14;
      }
      if (v2 == 32) {
        char v3 = 5;
      }
      else {
        char v3 = v13;
      }
    }
    else
    {
      switch(v2)
      {
        case 1:
          char v3 = 2;
          break;
        case 8:
          char v3 = 3;
          break;
        case 16:
          char v3 = 4;
          break;
        default:
          char v3 = 0;
          break;
      }
    }
    unsigned int v15 = v18;
    uint64_t v16 = 0x800000000000000;
    if ((v18 & 2) == 0) {
      uint64_t v16 = 0x8000000000000;
    }
    if ((v16 & v18) != 0)
    {
      llvm::reportInvalidSizeRequest((llvm *)"Possible incorrect use of LLT::getNumElements() for scalable vector. Scalable flag may be dropped, use LLT::getElementCount() instead", v1);
      unsigned int v15 = v18;
    }
    return sub_1CB883124(v3, (unsigned __int16)(v15 >> 3));
  }
  else
  {
    int v5 = sub_1CB8F1DC4(&v18);
    if (v4 == 1) {
    if (v5 == 128)
    }
      int v6 = 7;
    else {
      int v6 = 0;
    }
    if (v5 == 64) {
      int v7 = 6;
    }
    else {
      int v7 = v6;
    }
    if (v5 == 32) {
      unsigned int v8 = 5;
    }
    else {
      unsigned int v8 = v7;
    }
    if (v5 == 16) {
      int v9 = 4;
    }
    else {
      int v9 = 0;
    }
    if (v5 == 8) {
      int v10 = 3;
    }
    else {
      int v10 = v9;
    }
    if (v5 == 1) {
      unsigned int v11 = 2;
    }
    else {
      unsigned int v11 = v10;
    }
    if (v5 <= 31) {
      return v11;
    }
    else {
      return v8;
    }
  }
}

unint64_t llvm::getApproximateEVTForLLT(unint64_t a1, uint64_t a2, llvm::LLVMContext *a3)
{
  unint64_t v12 = a1;
  if ((a1 & 0xFFFFFFFFFFFFFFF9) != 0 && (a1 & 4) != 0)
  {
    uint64_t v8 = sub_1CBA15978(&v12);
    uint64_t ApproximateEVTForLLT = llvm::getApproximateEVTForLLT(v8, a2, a3);
    uint64_t v11 = 0x800000000000000;
    if ((v12 & 2) == 0) {
      uint64_t v11 = 0x8000000000000;
    }
    return sub_1CB882C1C(a3, ApproximateEVTForLLT, v9, (llvm::Type *)((unsigned __int16)(v12 >> 3) | ((unint64_t)((v11 & v12) != 0) << 32)));
  }
  else
  {
    int v5 = (llvm::LLVMContext *)sub_1CB8F1DC4(&v12);
    if (v4 == 1) {
    return sub_1CB8E40FC(a3, v5);
    }
  }
}

void *llvm::getFltSemanticForLLT(unint64_t a1)
{
  unint64_t v7 = a1;
  unsigned int v1 = (llvm::APFloatBase *)sub_1CB8F1DC4(&v7);
  if (v2 == 1)
  {
    int v6 = v1;
    unsigned int v1 = v6;
  }
  *((void *)&v4 + 1) = v1;
  *(void *)&long long v4 = (char *)v1 - 16;
  uint64_t v3 = v4 >> 4;
  switch(v3)
  {
    case 1:
      return llvm::APFloatBase::IEEEsingle(v1);
    case 7:
      return llvm::APFloatBase::IEEEquad(v1);
    case 3:
      return llvm::APFloatBase::IEEEdouble(v1);
    default:
      return llvm::APFloatBase::IEEEhalf(v1);
  }
}

void llvm::createLowerEmuTLSPass(llvm *this)
{
}

uint64_t llvm::MachineBasicBlock::getEHCatchretSymbol(llvm::MachineBasicBlock *this)
{
  v17[16] = *MEMORY[0x1E4F143B8];
  uint64_t result = *((void *)this + 27);
  if (!result)
  {
    uint64_t v3 = *((void *)this + 4);
    char v14 = &v15;
    unsigned int v15 = v17;
    long long v16 = xmmword_1CFAC3020;
    LODWORD(v7) = 0;
    char v11 = 0;
    uint64_t v12 = 0;
    int v13 = 0;
    int v6 = (unsigned __int8 **)&unk_1F2646FA8;
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    int v10 = 0;
    sub_1CB8E509C((llvm::raw_ostream *)&v6, "$ehgcr_");
    sub_1CD098D14((llvm::raw_ostream *)&v6, *(unsigned int *)(v3 + 336), 0, 0, 0);
    long long v4 = v10;
    if ((unint64_t)v10 >= v9)
    {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v6, 95);
    }
    else
    {
      ++v10;
      unsigned char *v4 = 95;
    }
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v6, *((int *)this + 6));
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v6);
    int v5 = *(llvm::MCContext **)(v3 + 24);
    LOWORD(v10) = 261;
    int v6 = (unsigned __int8 **)v15;
    uint64_t v7 = v16;
    uint64_t result = llvm::MCContext::getOrCreateSymbol(v5, &v6);
    *((void *)this + 27) = result;
    if (v15 != v17)
    {
      free(v15);
      return *((void *)this + 27);
    }
  }
  return result;
}

uint64_t llvm::MachineBasicBlock::getEndSymbol(llvm::MachineBasicBlock *this)
{
  uint64_t result = *((void *)this + 28);
  if (!result)
  {
    uint64_t v3 = *((void *)this + 4);
    long long v4 = *(llvm::MCContext **)(v3 + 24);
    uint64_t v5 = *((void *)v4 + 19);
    uint64_t v7 = *(void *)(v5 + 104);
    uint64_t v6 = *(void *)(v5 + 112);
    __int16 v19 = 261;
    v18[0] = v7;
    v18[1] = v6;
    long long v16 = "BB_END";
    __int16 v17 = 259;
    sub_1CB8F1E58(v18, (uint64_t *)&v16, (uint64_t)v20);
    int v8 = *(_DWORD *)(v3 + 336);
    __int16 v15 = 264;
    LODWORD(v14[0]) = v8;
    sub_1CB8F1E58(v20, v14, (uint64_t)v21);
    uint64_t v12 = "_";
    __int16 v13 = 259;
    sub_1CB8F1E58(v21, (uint64_t *)&v12, (uint64_t)v22);
    int v9 = *((_DWORD *)this + 6);
    __int16 v11 = 265;
    LODWORD(v10[0]) = v9;
    sub_1CB8F1E58(v22, v10, (uint64_t)v23);
    uint64_t result = llvm::MCContext::getOrCreateSymbol(v4, v23);
    *((void *)this + 28) = result;
  }
  return result;
}

void llvm::MachineBasicBlock::print(llvm::MachineBasicBlock *this, llvm::raw_ostream *a2, const llvm::SlotIndexes *a3, const llvm::TargetRegisterInfo *a4)
{
  v11[14] = *(llvm::SlotTracker **)MEMORY[0x1E4F143B8];
  uint64_t v5 = (const llvm::Function **)*((void *)this + 4);
  if (v5)
  {
    int v9 = *v5;
    llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)v11, *((void *)*v5 + 5), 1);
    llvm::ModuleSlotTracker::incorporateFunction(v11, v9);
    llvm::MachineBasicBlock::print(this, a2, v11, a3, a4);
    llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v11);
  }
  else
  {
    int v10 = sub_1CB8E509C(a2, "Can't print out MachineBasicBlock because parent MachineFunction");
    sub_1CB8E509C(v10, " is null\n");
  }
}

BOOL llvm::MachineBasicBlock::isEntryBlock(llvm::MachineBasicBlock *this)
{
  return *(void *)(*((void *)this + 4) + 328) == (void)this;
}

void llvm::MachineBasicBlock::dump(llvm::MachineBasicBlock *this)
{
  int v2 = llvm::dbgs(this);

  llvm::MachineBasicBlock::print(this, v2, 0, (const llvm::TargetRegisterInfo *)1);
}

char *llvm::MachineBasicBlock::getName(llvm::MachineBasicBlock *this)
{
  unsigned int v1 = (llvm::Value *)*((void *)this + 2);
  if (v1) {
    return llvm::Value::getName(v1);
  }
  else {
    return (char *)&unk_1CFB6806A;
  }
}

void llvm::MachineBasicBlock::getFullName(llvm::MachineBasicBlock *this@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  long long v4 = (llvm::Value **)*((void *)this + 4);
  if (v4)
  {
    __int16 v19 = 773;
    v18[0] = llvm::MachineFunction::getName(v4);
    v18[1] = v5;
    void v18[2] = ":";
    llvm::Twine::str((llvm::Twine *)v18, a2);
  }
  uint64_t v6 = (llvm::Value *)*((void *)this + 2);
  if (v6)
  {
    uint64_t Name = llvm::Value::getName(v6);
    std::string::append(a2, Name, v8);
  }
  else
  {
    char v14 = "BB";
    __int16 v15 = 259;
    int v9 = *((_DWORD *)this + 6);
    __int16 v13 = 265;
    LODWORD(v12[0]) = v9;
    sub_1CB8F1E58((uint64_t *)&v14, v12, (uint64_t)v18);
    llvm::Twine::str((llvm::Twine *)v18, __p);
    if (v17 >= 0) {
      int v10 = __p;
    }
    else {
      int v10 = (void **)__p[0];
    }
    if (v17 >= 0) {
      std::string::size_type v11 = v17 & 0x7F;
    }
    else {
      std::string::size_type v11 = (std::string::size_type)__p[1];
    }
    std::string::append(a2, (const std::string::value_type *)v10, v11);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
  }
}

void llvm::MachineBasicBlock::printName(llvm::MachineBasicBlock *this, llvm::raw_ostream *a2, char a3, llvm::SlotTracker **a4)
{
  v36[14] = *(llvm::SlotTracker **)MEMORY[0x1E4F143B8];
  std::string::size_type v8 = sub_1CB8E509C(a2, "bb.");
  llvm::raw_ostream::operator<<(v8, *((int *)this + 6));
  if (a3)
  {
    uint64_t v11 = *((void *)this + 2);
    if (v11)
    {
      if ((*(unsigned char *)(v11 + 23) & 0x10) == 0)
      {
        sub_1CB8E509C(a2, " (");
        if (a4)
        {
          int LocalSlot = llvm::ModuleSlotTracker::getLocalSlot(a4, (const llvm::Value *)v11);
        }
        else
        {
          if (!*(void *)(v11 + 56)) {
            goto LABEL_66;
          }
          uint64_t Module = llvm::BasicBlock::getModule((llvm::BasicBlock *)v11);
          llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)v36, Module, 0);
          llvm::ModuleSlotTracker::incorporateFunction(v36, *(const llvm::Function **)(v11 + 56));
          int LocalSlot = llvm::ModuleSlotTracker::getLocalSlot(v36, (const llvm::Value *)v11);
          llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v36);
        }
        if (LocalSlot != -1)
        {
          uint64_t v32 = "%ir-block.";
          __int16 v33 = 259;
          __int16 v31 = 265;
          LODWORD(v30[0]) = LocalSlot;
          sub_1CB8F1E58((uint64_t *)&v32, v30, (uint64_t)v36);
          llvm::Twine::str((llvm::Twine *)v36, __p);
          if (v35 >= 0) {
            __int16 v13 = __p;
          }
          else {
            __int16 v13 = (void **)__p[0];
          }
          if (v35 >= 0) {
            size_t v14 = v35 & 0x7F;
          }
          else {
            size_t v14 = (size_t)__p[1];
          }
          llvm::raw_ostream::write(a2, (const char *)v13, v14);
          if (v35 < 0) {
            operator delete(__p[0]);
          }
          goto LABEL_67;
        }
LABEL_66:
        sub_1CB8E509C(a2, "<ir-block badref>");
LABEL_67:
        int v9 = 1;
        goto LABEL_3;
      }
      uint64_t v24 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v24 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 46);
      }
      else
      {
        *((void *)a2 + 4) = v24 + 1;
        unsigned char *v24 = 46;
      }
      uint64_t Name = llvm::Value::getName((llvm::Value *)v11);
      size_t v27 = v25;
      unint64_t v28 = (void *)*((void *)a2 + 4);
      if (v25 <= *((void *)a2 + 3) - (void)v28)
      {
        if (v25)
        {
          memcpy(v28, Name, v25);
          int v9 = 0;
          *((void *)a2 + 4) += v27;
          goto LABEL_3;
        }
      }
      else
      {
        llvm::raw_ostream::write(a2, Name, v25);
      }
    }
  }
  int v9 = 0;
LABEL_3:
  if ((a3 & 2) == 0) {
    goto LABEL_4;
  }
  if (*((unsigned char *)this + 185))
  {
    if (v9) {
      __int16 v15 = ", ";
    }
    else {
      __int16 v15 = " (";
    }
    sub_1CB8E509C(a2, v15);
    sub_1CB8E509C(a2, "address-taken");
    int v9 = 1;
  }
  if (*((unsigned char *)this + 184))
  {
    if (v9) {
      long long v16 = ", ";
    }
    else {
      long long v16 = " (";
    }
    sub_1CB8E509C(a2, v16);
    sub_1CB8E509C(a2, "landing-pad");
    int v9 = 1;
  }
  if (*((unsigned char *)this + 202))
  {
    if (v9) {
      char v17 = ", ";
    }
    else {
      char v17 = " (";
    }
    sub_1CB8E509C(a2, v17);
    sub_1CB8E509C(a2, "inlineasm-br-indirect-target");
    int v9 = 1;
  }
  if (*((unsigned char *)this + 189))
  {
    if (v9) {
      unint64_t v18 = ", ";
    }
    else {
      unint64_t v18 = " (";
    }
    sub_1CB8E509C(a2, v18);
    sub_1CB8E509C(a2, "ehfunclet-entry");
    int v9 = 1;
  }
  if (*((unsigned char *)this + 176))
  {
    if (v9) {
      __int16 v19 = ", ";
    }
    else {
      __int16 v19 = " (";
    }
    sub_1CB8E509C(a2, v19);
    unint64_t v20 = sub_1CB8E509C(a2, "align ");
    int v9 = 1;
    sub_1CD098D14(v20, 1 << *((unsigned char *)this + 176), 0, 0, 0);
  }
  if (!*((void *)this + 24))
  {
LABEL_4:
    if (!v9) {
      return;
    }
    goto LABEL_5;
  }
  if (v9) {
    uint64_t v21 = ", ";
  }
  else {
    uint64_t v21 = " (";
  }
  sub_1CB8E509C(a2, v21);
  sub_1CB8E509C(a2, "bbsections ");
  unint64_t v22 = *((void *)this + 24);
  if (v22 == 2)
  {
    uint64_t v23 = "Cold";
    goto LABEL_57;
  }
  if (v22 == 1)
  {
    uint64_t v23 = "Exception";
LABEL_57:
    sub_1CB8E509C(a2, v23);
    goto LABEL_5;
  }
  sub_1CD098D14(a2, HIDWORD(v22), 0, 0, 0);
LABEL_5:
  int v10 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v10 >= *((void *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 41);
  }
  else
  {
    *((void *)a2 + 4) = v10 + 1;
    *int v10 = 41;
  }
}

llvm::raw_ostream *llvm::MachineBasicBlock::printAsOperand(llvm::MachineBasicBlock *this, llvm::raw_ostream *a2)
{
  long long v4 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v4 >= *((void *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 37);
  }
  else
  {
    *((void *)a2 + 4) = v4 + 1;
    unsigned char *v4 = 37;
  }
  uint64_t v5 = sub_1CB8E509C(a2, "bb.");
  unint64_t v6 = *((int *)this + 6);

  return llvm::raw_ostream::operator<<(v5, v6);
}

uint64_t llvm::MachineBasicBlock::addLiveIn(void *a1, int a2, uint64_t a3)
{
  __int16 v6 = a2;
  uint64_t v7 = (unsigned __int16 *)a1[19];
  std::string::size_type v8 = (void **)(a1 + 19);
  while (1)
  {
    if (v7 == (unsigned __int16 *)a1[20])
    {
      BOOL v9 = 0;
      goto LABEL_6;
    }
    if (*v7 == (unsigned __int16)a2) {
      break;
    }
    v7 += 8;
  }
  BOOL v9 = *((void *)v7 + 1) != 0;
LABEL_6:
  uint64_t v10 = llvm::MachineBasicBlock::SkipPHIsAndLabels((uint64_t)a1, a1[7]);
  uint64_t v11 = a1[4];
  uint64_t v12 = *(void **)(v11 + 40);
  uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(v11 + 16) + 104))(*(void *)(v11 + 16));
  if (v9 && a1 + 6 != (void *)v10)
  {
    while (**(_WORD **)(v10 + 16) == 19)
    {
      uint64_t v14 = *(void *)(v10 + 32);
      if (*(_DWORD *)(v14 + 36) == a2)
      {
        uint64_t VirtualRegister = *(unsigned int *)(v14 + 4);
        llvm::MachineRegisterInfo::constrainRegClass(v12, *(_DWORD *)(v14 + 4), a3, 0);
        return VirtualRegister;
      }
      if ((*(unsigned char *)v10 & 4) == 0)
      {
        while ((*(_WORD *)(v10 + 44) & 8) != 0)
          uint64_t v10 = *(void *)(v10 + 8);
      }
      uint64_t v10 = *(void *)(v10 + 8);
      if ((void *)v10 == a1 + 6)
      {
        uint64_t v10 = (uint64_t)(a1 + 6);
        break;
      }
    }
  }
  uint64_t VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister((uint64_t)v12, a3, (unsigned __int8 *)&unk_1CFB6806A, 0);
  uint64_t v21 = 0;
  long long v16 = sub_1CB85AA4C((uint64_t)a1, (unint64_t *)v10, &v21, *(void *)(v13 + 8) + 912, VirtualRegister);
  *((void *)&v22 + 1) = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  LODWORD(v22) = 0x4000000;
  DWORD1(v22) = a2;
  llvm::MachineInstr::addOperand(v17, v16, (const llvm::MachineOperand *)&v22);
  if (v21) {
    llvm::MetadataTracking::untrack((uint64_t)&v21, v21);
  }
  if (!v9)
  {
    LOWORD(v22) = v6;
    *((void *)&v22 + 1) = -1;
    unint64_t v18 = (_OWORD *)a1[20];
    if ((unint64_t)v18 >= a1[21])
    {
      __int16 v19 = sub_1CC016940(v8, &v22);
    }
    else
    {
      _OWORD *v18 = v22;
      __int16 v19 = v18 + 1;
    }
    a1[20] = v19;
  }
  return VirtualRegister;
}

llvm::MachineBasicBlock *llvm::MachineBasicBlock::moveBefore(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2)
{
  if (a2 != this)
  {
    int v2 = (llvm::MachineBasicBlock *)*((void *)this + 1);
    if (v2 != a2 && v2 != this)
    {
      uint64_t v4 = *(void *)v2;
      uint64_t v5 = *(void *)this;
      *(void *)(v5 + 8) = v2;
      *(void *)int v2 = v5;
      uint64_t v6 = *(void *)a2;
      *(void *)(v4 + 8) = a2;
      *(void *)this = v6;
      *(void *)(v6 + 8) = this;
      *(void *)a2 = v4;
    }
  }
  return this;
}

uint64_t *llvm::MachineBasicBlock::moveAfter(uint64_t *this, llvm::MachineBasicBlock *a2)
{
  int v2 = (uint64_t *)*((void *)a2 + 1);
  uint64_t v3 = (uint64_t *)this[1];
  if (v2 != this && v3 != v2 && v3 != this)
  {
    uint64_t v6 = *v3;
    uint64_t v7 = *this;
    *(void *)(v7 + 8) = v3;
    *uint64_t v3 = v7;
    uint64_t v8 = *v2;
    *(void *)(v6 + 8) = v2;
    *this = v8;
    *(void *)(v8 + 8) = this;
    *int v2 = v6;
  }
  return this;
}

void llvm::MachineBasicBlock::updateTerminator(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2)
{
  v21[16] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(*((void *)this + 4) + 16) + 104))(*(void *)(*((void *)this + 4) + 16));
  if (*((void *)this + 11) == *((void *)this + 12)) {
    return;
  }
  uint64_t v5 = v4;
  char v17 = 0;
  unint64_t v18 = 0;
  __int16 v19 = v21;
  uint64_t v20 = 0x400000000;
  llvm::MachineBasicBlock::findBranchDebugLoc(this, &v16);
  (*(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock **, llvm::MachineBasicBlock **, void **, void))(*(void *)v5 + 248))(v5, this, &v18, &v17, &v19, 0);
  if (!v20)
  {
    if (v18)
    {
      if (*((llvm::MachineBasicBlock **)this + 1) == v18) {
        (*(void (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)v5 + 264))(v5, this, 0);
      }
      goto LABEL_10;
    }
    if (!a2) {
      goto LABEL_10;
    }
    uint64_t v14 = (llvm::MachineBasicBlock **)*((void *)this + 11);
    __int16 v15 = (llvm::MachineBasicBlock **)*((void *)this + 12);
    if (v14 != v15)
    {
      while (*v14 != a2)
      {
        if (++v14 == v15)
        {
          uint64_t v14 = (llvm::MachineBasicBlock **)*((void *)this + 12);
          break;
        }
      }
    }
    if (v14 == v15 || *((unsigned char *)a2 + 184) || *((llvm::MachineBasicBlock **)this + 1) == a2) {
      goto LABEL_10;
    }
    goto LABEL_37;
  }
  if (!v17)
  {
    if (v18 == a2)
    {
      (*(void (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)v5 + 264))(v5, this, 0);
      if (*((llvm::MachineBasicBlock **)this + 1) != v18)
      {
        LODWORD(v20) = 0;
        (*(void (**)(uint64_t, llvm::MachineBasicBlock *))(*(void *)v5 + 272))(v5, this);
      }
      goto LABEL_10;
    }
    uint64_t v13 = (llvm::MachineBasicBlock *)*((void *)this + 1);
    if (v13 != v18)
    {
      if (v13 != a2)
      {
        (*(void (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)v5 + 264))(v5, this, 0);
        (*(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void *, void, unsigned __int8 **, void))(*(void *)v5 + 272))(v5, this, v18, a2, v19, v20, &v16, 0);
      }
      goto LABEL_10;
    }
    if (!(*(unsigned int (**)(uint64_t, void **))(*(void *)v5 + 728))(v5, &v19))
    {
      (*(void (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)v5 + 264))(v5, this, 0);
      uint64_t v8 = v19;
      uint64_t v9 = v20;
      uint64_t v10 = *(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void, void *, uint64_t, unsigned __int8 **, void))(*(void *)v5 + 272);
      uint64_t v11 = v5;
      uint64_t v12 = this;
      uint64_t v7 = a2;
      goto LABEL_9;
    }
    LODWORD(v20) = 0;
LABEL_37:
    (*(void (**)(uint64_t, llvm::MachineBasicBlock *))(*(void *)v5 + 272))(v5, this);
    goto LABEL_10;
  }
  uint64_t v6 = (llvm::MachineBasicBlock *)*((void *)this + 1);
  if (v6 == v18)
  {
    if ((*(uint64_t (**)(uint64_t, void **))(*(void *)v5 + 728))(v5, &v19)) {
      goto LABEL_10;
    }
    (*(void (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)v5 + 264))(v5, this, 0);
    uint64_t v7 = v17;
    goto LABEL_8;
  }
  if (v6 == v17)
  {
    (*(void (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)v5 + 264))(v5, this, 0);
    uint64_t v7 = v18;
LABEL_8:
    uint64_t v8 = v19;
    uint64_t v9 = v20;
    uint64_t v10 = *(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void, void *, uint64_t, unsigned __int8 **, void))(*(void *)v5 + 272);
    uint64_t v11 = v5;
    uint64_t v12 = this;
LABEL_9:
    v10(v11, v12, v7, 0, v8, v9, &v16, 0);
  }
LABEL_10:
  if (v16) {
    llvm::MetadataTracking::untrack((uint64_t)&v16, v16);
  }
  if (v19 != v21) {
    free(v19);
  }
}

char *llvm::MachineBasicBlock::findBranchDebugLoc@<X0>(llvm::MachineBasicBlock *this@<X0>, unsigned __int8 **a2@<X8>)
{
  *a2 = 0;
  uint64_t result = (char *)llvm::MachineBasicBlock::getFirstTerminator(this);
  uint64_t v5 = (char *)this + 48;
  if (v5 != result)
  {
    uint64_t v6 = (uint64_t)result;
    do
    {
      __int16 v7 = *(_WORD *)(v6 + 44);
      uint64_t v8 = *(void *)(*(void *)(v6 + 16) + 8);
      if ((v7 & 0xC) != 0 && (v7 & 4) == 0)
      {
        uint64_t v10 = v6;
        if ((v8 & 0x400) != 0)
        {
LABEL_16:
          uint64_t result = (char *)sub_1CB896804(a2, (unsigned __int8 **)(v6 + 56));
          if ((*(unsigned char *)v6 & 4) == 0)
          {
            while ((*(_WORD *)(v6 + 44) & 8) != 0)
              uint64_t v6 = *(void *)(v6 + 8);
          }
          uint64_t v11 = *(void *)(v6 + 8);
          while (2)
          {
            if ((char *)v11 == v5) {
              return result;
            }
            uint64_t v12 = *(void *)(*(void *)(v11 + 16) + 8);
            if ((*(_WORD *)(v11 + 44) & 0xC) != 0 && (*(_WORD *)(v11 + 44) & 4) == 0)
            {
              uint64_t v18 = v11;
              if ((v12 & 0x400) != 0) {
                goto LABEL_26;
              }
              while ((*(_WORD *)(v18 + 44) & 8) != 0)
              {
                uint64_t v18 = *(void *)(v18 + 8);
                if ((*(unsigned char *)(*(void *)(v18 + 16) + 9) & 4) != 0) {
                  goto LABEL_26;
                }
              }
            }
            else if ((v12 & 0x400) != 0)
            {
LABEL_26:
              uint64_t v14 = (llvm::DILocation *)llvm::DebugLoc::get((llvm::DebugLoc *)a2);
              __int16 v15 = (const llvm::DILocation *)llvm::DebugLoc::get((llvm::DebugLoc *)(v11 + 56));
              MergedLocation = llvm::DILocation::getMergedLocation(v14, v15, v16);
              llvm::DebugLoc::DebugLoc((llvm::DebugLoc *)&v19, MergedLocation);
              uint64_t result = (char *)sub_1CB8F69CC(a2, &v19);
              if (v19) {
                uint64_t result = (char *)llvm::MetadataTracking::untrack((uint64_t)&v19, v19);
              }
            }
            if ((*(unsigned char *)v11 & 4) == 0)
            {
              while ((*(_WORD *)(v11 + 44) & 8) != 0)
                uint64_t v11 = *(void *)(v11 + 8);
            }
            uint64_t v11 = *(void *)(v11 + 8);
            continue;
          }
        }
        while ((*(_WORD *)(v10 + 44) & 8) != 0)
        {
          uint64_t v10 = *(void *)(v10 + 8);
          if ((*(unsigned char *)(*(void *)(v10 + 16) + 9) & 4) != 0) {
            goto LABEL_16;
          }
        }
      }
      else if ((v8 & 0x400) != 0)
      {
        goto LABEL_16;
      }
      if ((v7 & 8) != 0 && (*(void *)v6 & 4) == 0)
      {
        do
          uint64_t v6 = *(void *)(v6 + 8);
        while ((*(_WORD *)(v6 + 44) & 8) != 0);
      }
      uint64_t v6 = *(void *)(v6 + 8);
    }
    while ((char *)v6 != v5);
  }
  return result;
}

char *llvm::MachineBasicBlock::transferSuccessors(char *this, llvm::MachineBasicBlock *a2)
{
  if (this != (char *)a2)
  {
    uint64_t v3 = (llvm::MachineBasicBlock **)*((void *)a2 + 11);
    if (v3 != *((llvm::MachineBasicBlock ***)a2 + 12))
    {
      uint64_t v4 = this;
      do
      {
        uint64_t v5 = *v3;
        uint64_t v6 = (int *)*((void *)a2 + 14);
        if (v6 == *((int **)a2 + 15)) {
          llvm::MachineBasicBlock::addSuccessorWithoutProb(v4, v5);
        }
        else {
          llvm::MachineBasicBlock::addSuccessor(v4, v5, *v6);
        }
        __int16 v7 = (char *)*((void *)a2 + 11);
        uint64_t v8 = (char *)*((void *)a2 + 12);
        if (v7 != v8)
        {
          while (*(llvm::MachineBasicBlock **)v7 != v5)
          {
            v7 += 8;
            if (v7 == v8)
            {
              __int16 v7 = (char *)*((void *)a2 + 12);
              break;
            }
          }
        }
        this = llvm::MachineBasicBlock::removeSuccessor((uint64_t)a2, v7, 0);
        uint64_t v3 = (llvm::MachineBasicBlock **)*((void *)a2 + 11);
      }
      while (v3 != *((llvm::MachineBasicBlock ***)a2 + 12));
    }
  }
  return this;
}

BOOL llvm::MachineBasicBlock::canFallThrough(llvm::MachineBasicBlock *this)
{
  return llvm::MachineBasicBlock::getFallThrough(this) != 0;
}

uint64_t sub_1CD526C2C(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1CD526C98(*(void *)(a1 + 288), a2);
  unsigned int v4 = *(_DWORD *)(a1 + 608);
  if (v4 >= *(_DWORD *)(a1 + 612)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(a1 + 600) + 8 * v4) = *(unsigned int *)(a1 + 448);
  ++*(_DWORD *)(a1 + 608);
  return result;
}

uint64_t sub_1CD526C98(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = sub_1CB906F34((uint64_t *)(a1 + 248), 32, 3);
  *(void *)(v5 + 8) = 0;
  *(void *)(v5 + 16) = 0;
  *(void *)uint64_t v5 = 0;
  *(_DWORD *)(v5 + 24) = 0;
  uint64_t v6 = *(unsigned int *)(v4 + 24);
  uint64_t v7 = *(void *)(a1 + 392);
  unint64_t v8 = *(void *)(v7 + 16 * v6 + 8) & 0xFFFFFFFFFFFFFFF8;
  if (a2 + 6 == (uint64_t *)(a2[6] & 0xFFFFFFFFFFFFFFF8))
  {
    uint64_t v9 = (uint64_t *)(*(void *)(v7 + 16 * v6 + 8) & 0xFFFFFFFFFFFFFFF8);
  }
  else
  {
    uint64_t v9 = (uint64_t *)(sub_1CBB24CA0(a1, a2[7], 0) & 0xFFFFFFFFFFFFFFF8);
    LODWORD(v6) = *(_DWORD *)(v4 + 24);
    uint64_t v7 = *(void *)(a1 + 392);
  }
  uint64_t v10 = *v9;
  *(void *)uint64_t v5 = *v9;
  *(void *)(v5 + 8) = v9;
  *(void *)(v10 + 8) = v5;
  uint64_t *v9 = v5;
  unint64_t v11 = v5 & 0xFFFFFFFFFFFFFFF9;
  *(void *)(v7 + 16 * (int)v6 + 8) = v5 & 0xFFFFFFFFFFFFFFF9;
  unsigned int v12 = *(_DWORD *)(a1 + 400);
  if (v12 >= *(_DWORD *)(a1 + 404)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  uint64_t v13 = (unint64_t *)(v7 + 16 * v12);
  *uint64_t v13 = v11;
  v13[1] = v8;
  ++*(_DWORD *)(a1 + 400);
  unsigned int v14 = *(_DWORD *)(a1 + 544);
  if (v14 >= *(_DWORD *)(a1 + 548)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  __int16 v15 = (unint64_t *)(*(void *)(a1 + 536) + 16 * v14);
  *__int16 v15 = v11;
  v15[1] = (unint64_t)a2;
  unint64_t v16 = (*(_DWORD *)(a1 + 544) + 1);
  *(_DWORD *)(a1 + 544) = v16;
  unsigned int v17 = *(_DWORD *)(*(void *)v5 + 24);
  do
  {
    v17 += 8;
    *(_DWORD *)(v5 + 24) = v17;
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5 != a1 + 344 && *(_DWORD *)(v5 + 24) <= v17);
  unint64_t v18 = 126 - 2 * __clz(v16);
  if (v16) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0;
  }
  return sub_1CC319DC8(*(void *)(a1 + 536), (uint64_t *)(*(void *)(a1 + 536) + 16 * v16), (uint64_t)&v21, v19, 1);
}

void llvm::MachineBasicBlock::ReplaceUsesOfBlockWith(llvm::MachineBasicBlock *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3)
{
  uint64_t v3 = (llvm::MachineBasicBlock *)((char *)this + 48);
  uint64_t v4 = (llvm::MachineBasicBlock *)*((void *)this + 7);
  if ((llvm::MachineBasicBlock *)((char *)this + 48) == v4) {
    goto LABEL_21;
  }
  while (1)
  {
    uint64_t v3 = (llvm::MachineBasicBlock *)(*(void *)v3 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v5 = *(void *)(*((void *)v3 + 2) + 8);
    if ((*((_WORD *)v3 + 22) & 0xC) == 0 || (*((_WORD *)v3 + 22) & 4) != 0)
    {
      if ((v5 & 0x200) == 0) {
        goto LABEL_21;
      }
      goto LABEL_7;
    }
    if ((v5 & 0x200) == 0) {
      break;
    }
LABEL_7:
    uint64_t v7 = *((unsigned int *)v3 + 10);
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = 32 * v7;
      do
      {
        uint64_t v10 = *((void *)v3 + 4);
        if (*(unsigned char *)(v10 + v8) == 4)
        {
          uint64_t v11 = v10 + v8;
          if (*(llvm::MachineBasicBlock **)(v11 + 16) == a2) {
            *(void *)(v11 + 16) = a3;
          }
        }
        v8 += 32;
      }
      while (v9 != v8);
      uint64_t v4 = (llvm::MachineBasicBlock *)*((void *)this + 7);
    }
    if (v4 == v3) {
      goto LABEL_21;
    }
  }
  unsigned int v12 = v3;
  while ((*((_WORD *)v12 + 22) & 8) != 0)
  {
    unsigned int v12 = (llvm::MachineBasicBlock *)*((void *)v12 + 1);
    if ((*(unsigned char *)(*((void *)v12 + 2) + 9) & 2) != 0) {
      goto LABEL_7;
    }
  }
LABEL_21:
  llvm::MachineBasicBlock::replaceSuccessor(this, a2, a3);
}

__n128 sub_1CD526EF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 1032), a4);
  v11[0] = a2;
  v11[1] = a3;
  void v11[2] = a4;
  uint64_t v8 = (__n128 *)sub_1CD483108(a1 + 248, (unint64_t)v11);
  uint64_t v9 = (__n128 *)(*(void *)(a1 + 248) + 24 * *(unsigned int *)(a1 + 256));
  __n128 result = *v8;
  v9[1].n128_u64[0] = v8[1].n128_u64[0];
  __n128 *v9 = result;
  ++*(_DWORD *)(a1 + 256);
  return result;
}

llvm::MachineInstr *llvm::MachineBasicBlock::remove_instr(llvm::MachineBasicBlock *this, llvm::MachineInstr *a2)
{
  uint64_t v3 = sub_1CC319554((uint64_t)a2);
  *((_WORD *)a2 + 22) &= 0xFFF3u;
  llvm::ilist_traits<llvm::MachineInstr>::removeNodeFromList(v3, (uint64_t)a2);
  uint64_t v4 = (unint64_t *)*((void *)a2 + 1);
  unint64_t v5 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
  unint64_t *v4 = v5 | *v4 & 7;
  *(void *)(v5 + 8) = v4;
  *(void *)a2 &= 7uLL;
  *((void *)a2 + 1) = 0;
  return a2;
}

void *llvm::MachineBasicBlock::setSuccProbability(void *result, uint64_t a2, int a3)
{
  uint64_t v3 = result[14];
  if (v3 != result[15]) {
    *(_DWORD *)(v3 + ((a2 - result[11]) >> 1)) = a3;
  }
  return result;
}

uint64_t llvm::MachineBasicBlock::clearLiveIns(uint64_t this)
{
  *(void *)(this + 160) = *(void *)(this + 152);
  return this;
}

uint64_t llvm::MachineBasicBlock::liveout_begin@<X0>(llvm::MachineBasicBlock *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *((void *)this + 4);
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(v4 + 16) + 120))(*(void *)(v4 + 16));
  if ((*(_WORD *)(*(void *)v4 + 18) & 8) != 0)
  {
    uint64_t PersonalityFn = llvm::Function::getPersonalityFn(*(llvm::Function **)v4);
    unsigned __int16 v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 712))(v5, PersonalityFn);
    unsigned __int16 v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 720))(v5, PersonalityFn);
  }
  else
  {
    unsigned __int16 v6 = 0;
    unsigned __int16 v7 = 0;
  }

  return sub_1CD52712C(a2, (uint64_t)this, v7, v6, 0);
}

uint64_t sub_1CD52712C(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  *(_WORD *)a1 = a3;
  *(_WORD *)(a1 + 2) = a4;
  uint64_t v6 = *(void *)(a2 + 88);
  *(void *)(a1 + 8) = v6;
  uint64_t v7 = *(void *)(a2 + 96);
  *(void *)(a1 + 16) = v7;
  *(void *)(a1 + 24) = 0;
  if (a5)
  {
    *(void *)(a1 + 8) = v7;
  }
  else if (v6 != v7)
  {
    *(void *)(a1 + 24) = *(void *)(*(void *)v6 + 152);
    if (sub_1CD5271C0((void *)a1))
    {
      int v11 = **(unsigned __int16 **)(a1 + 24);
      if (v11 == a3 || v11 == a4) {
        sub_1CD527214((unsigned __int16 *)a1);
      }
    }
  }
  return a1;
}

uint64_t sub_1CD5271C0(void *a1)
{
  unsigned int v1 = (uint64_t *)a1[1];
  if (a1[3] != *(void *)(*v1 + 160)) {
    return 1;
  }
  uint64_t v3 = (uint64_t *)a1[2];
  for (uint64_t i = v1 + 1; ; ++i)
  {
    a1[1] = i;
    if (i == v3) {
      break;
    }
    uint64_t v5 = *i;
    uint64_t v6 = *(void *)(v5 + 152);
    if (v6 != *(void *)(v5 + 160))
    {
      a1[3] = v6;
      return 1;
    }
  }
  return 0;
}

unsigned __int16 *sub_1CD527214(unsigned __int16 *a1)
{
  *((void *)a1 + 3) += 16;
  if (sub_1CD5271C0(a1))
  {
    do
    {
      if (!*(unsigned char *)(**((void **)a1 + 1) + 184)) {
        break;
      }
      int v2 = (unsigned __int16 *)*((void *)a1 + 3);
      int v3 = *v2;
      if (v3 != *a1 && v3 != a1[1]) {
        break;
      }
      *((void *)a1 + 3) = v2 + 8;
    }
    while ((sub_1CD5271C0(a1) & 1) != 0);
  }
  return a1;
}

void llvm::initializeMachineBlockFrequencyInfoPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD558, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC31BC34;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCCD558, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::MachineBlockFrequencyInfo *llvm::MachineBlockFrequencyInfo::MachineBlockFrequencyInfo(llvm::MachineBlockFrequencyInfo *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  *(void *)int v2 = &unk_1F260D550;
  *((void *)v2 + 31) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD558, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC31BC34;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCD558, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::MachineBlockFrequencyInfo::getAnalysisUsage(llvm::MachineBlockFrequencyInfo *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBranchProbabilityInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineLoopInfo::ID);
  *((unsigned char *)a2 + 160) = 1;

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

void llvm::MachineBlockFrequencyInfo::view(llvm::MachineBlockFrequencyInfo *this, const llvm::Twine *a2, char a3)
{
  uint64_t v4 = this;
  v3[16] = 257;
  sub_1CD52756C((uint64_t)&v4, a2, a3, (llvm::Twine *)v3);
}

void sub_1CD52756C(uint64_t a1, llvm::Twine *this, char a3, llvm::Twine *a4)
{
  char v8 = 0;
  LOBYTE(__p) = 0;
  sub_1CC320674((uint64_t)v9, a1, this, a3, a4, (uint64_t)&__p);
  if (v8 < 0) {
    operator delete(__p);
  }
  char v4 = v10;
  if (v10 >= 0) {
    std::string::size_type v5 = v10 & 0x7F;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v9[1];
  }
  if (v5)
  {
    if (v10 >= 0) {
      uint64_t v6 = v9;
    }
    else {
      uint64_t v6 = (void **)v9[0];
    }
    llvm::DisplayGraph((std::string::value_type *)v6, v5, 0, 0);
    char v4 = v10;
  }
  if (v4 < 0) {
    operator delete(v9[0]);
  }
}

uint64_t llvm::MachineBlockFrequencyInfo::getBlockProfileCount(llvm::MachineBlockFrequencyInfo *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t result = *((void *)this + 31);
  if (result) {
    return sub_1CD52763C(result, **(uint64_t *****)(result + 128), (uint64_t)a2, 0);
  }
  return result;
}

uint64_t sub_1CD52763C(uint64_t a1, uint64_t ***a2, uint64_t a3, int a4)
{
  uint64_t v10 = 0;
  if (sub_1CC152E2C(*(void *)(a1 + 160), *(_DWORD *)(a1 + 176), a3, &v10)) {
    int v7 = *(_DWORD *)(v10 + 8);
  }
  else {
    int v7 = -1;
  }
  int v9 = v7;
  return llvm::BlockFrequencyInfoImplBase::getBlockProfileCount((llvm::BlockFrequencyInfoImplBase *)a1, a2, &v9, a4);
}

uint64_t *****llvm::MachineBlockFrequencyInfo::getProfileCountFromFreq(llvm::MachineBlockFrequencyInfo *this, unint64_t a2)
{
  uint64_t result = (uint64_t *****)*((void *)this + 31);
  if (result) {
    return (uint64_t *****)llvm::BlockFrequencyInfoImplBase::getProfileCountFromFreq((llvm::BlockFrequencyInfoImplBase *)result, *result[16], a2, 0);
  }
  return result;
}

uint64_t llvm::MachineBlockFrequencyInfo::onEdgeSplit(llvm::MachineBlockFrequencyInfo *this, const llvm::MachineBasicBlock *a2, const llvm::MachineBasicBlock *a3, const llvm::MachineBranchProbabilityInfo *a4)
{
  uint64_t v11 = sub_1CC31E95C(*((void *)this + 31), (uint64_t)a2);
  unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(a4, a2, a3);
  unint64_t v9 = llvm::BlockFrequency::operator*((unint64_t *)&v11, EdgeProbability);
  return sub_1CD527760(*((void *)this + 31), (uint64_t)a3, v9);
}

uint64_t sub_1CD527760(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a2;
  uint64_t v6 = a1 + 160;
  if (sub_1CC152E2C(*(void *)(a1 + 160), *(_DWORD *)(a1 + 176), a2, &v13))
  {
    uint64_t v13 = 0;
    if (sub_1CC152E2C(*(void *)(a1 + 160), *(_DWORD *)(a1 + 176), a2, &v13)) {
      int v7 = *(_DWORD *)(v13 + 8);
    }
    else {
      int v7 = -1;
    }
    LODWORD(v13) = v7;
  }
  else
  {
    LODWORD(v13) = -1431655765 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3);
    int v8 = v13;
    *((_DWORD *)sub_1CC31EE54(v6, &v12) + 2) = v8;
    unint64_t v9 = *(void **)(a1 + 16);
    if ((unint64_t)v9 >= *(void *)(a1 + 24))
    {
      uint64_t v10 = sub_1CC3211BC((void **)(a1 + 8));
    }
    else
    {
      uint64_t v10 = v9 + 3;
      void *v9 = 0;
      v9[1] = 0;
      void v9[2] = 0;
    }
    *(void *)(a1 + 16) = v10;
  }
  return llvm::BlockFrequencyInfoImplBase::setBlockFreq(a1, (unsigned int *)&v13, a3);
}

uint64_t llvm::MachineBlockFrequencyInfo::getMBPI(llvm::MachineBlockFrequencyInfo *this)
{
  uint64_t v1 = *((void *)this + 31);
  if (v1) {
    return *(void *)(v1 + 112);
  }
  else {
    return 0;
  }
}

llvm::ScaledNumberBase *sub_1CD527874(uint64_t a1, llvm::ScaledNumberBase *a2, uint64_t a3)
{
  uint64_t v8 = 0;
  if (sub_1CC152E2C(*(void *)(a1 + 160), *(_DWORD *)(a1 + 176), a3, &v8)) {
    int v5 = *(_DWORD *)(v8 + 8);
  }
  else {
    int v5 = -1;
  }
  int v7 = v5;
  return llvm::BlockFrequencyInfoImplBase::printBlockFreq(a1, a2, &v7);
}

void llvm::callDefaultCtor<llvm::MachineBlockFrequencyInfo>()
{
}

void sub_1CD52791C(uint64_t a1@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
}

llvm::raw_ostream *sub_1CD527930(uint64_t a1, llvm::raw_ostream *a2)
{
  if (*(void *)(a1 + 128))
  {
    char v4 = sub_1CB8E509C(a2, "block-frequency-info: ");
    uint64_t Name = llvm::MachineFunction::getName(*(llvm::Value ***)(a1 + 128));
    size_t v7 = v5;
    uint64_t v8 = (void *)*((void *)v4 + 4);
    if (v5 <= *((void *)v4 + 3) - (void)v8)
    {
      if (v5)
      {
        memcpy(v8, Name, v5);
        *((void *)v4 + 4) += v7;
      }
    }
    else
    {
      llvm::raw_ostream::write(v4, Name, v5);
    }
    sub_1CB8E509C(v4, "\n");
    uint64_t v9 = *(void *)(a1 + 128);
    uint64_t v10 = v9 + 320;
    uint64_t v11 = *(void *)(v9 + 328);
    if (v11 != v9 + 320)
    {
      do
      {
        uint64_t v12 = sub_1CB8E509C(a2, " - ");
        sub_1CD527B94(__p, v11);
        if (v31 >= 0) {
          uint64_t v13 = __p;
        }
        else {
          uint64_t v13 = (void **)__p[0];
        }
        if (v31 >= 0) {
          size_t v14 = v31 & 0x7F;
        }
        else {
          size_t v14 = (size_t)__p[1];
        }
        __int16 v15 = llvm::raw_ostream::write(v12, (const char *)v13, v14);
        sub_1CB8E509C(v15, ": float = ");
        if (v31 < 0) {
          operator delete(__p[0]);
        }
        unint64_t v16 = (llvm::raw_ostream *)sub_1CD527C7C(a1, v11);
        unint64_t v18 = llvm::ScaledNumberBase::print(a2, v16, v17, 64, 5u);
        uint64_t v19 = sub_1CB8E509C(v18, ", int = ");
        unint64_t v20 = sub_1CC31E95C(a1, v11);
        llvm::raw_ostream::operator<<(v19, v20);
        char v21 = **(uint64_t *****)(a1 + 128);
        __p[0] = 0;
        if (sub_1CC152E2C(*(void *)(a1 + 160), *(_DWORD *)(a1 + 176), v11, __p)) {
          int v22 = *((_DWORD *)__p[0] + 2);
        }
        else {
          int v22 = -1;
        }
        LODWORD(__p[0]) = v22;
        uint64_t BlockProfileCount = llvm::BlockFrequencyInfoImplBase::getBlockProfileCount((llvm::BlockFrequencyInfoImplBase *)a1, v21, __p, 0);
        if (v24)
        {
          unint64_t v25 = BlockProfileCount;
          uint64_t v26 = sub_1CB8E509C(a2, ", count = ");
          llvm::raw_ostream::operator<<(v26, v25);
        }
        if (*(unsigned char *)(v11 + 144))
        {
          unint64_t v27 = *(void *)(v11 + 136);
          unint64_t v28 = sub_1CB8E509C(a2, ", irr_loop_header_weight = ");
          llvm::raw_ostream::operator<<(v28, v27);
        }
        sub_1CB8E509C(a2, "\n");
        uint64_t v11 = *(void *)(v11 + 8);
      }
      while (v11 != v10);
    }
    sub_1CB8E509C(a2, "\n");
  }
  return a2;
}

void sub_1CD527B94(void *a1, uint64_t a2)
{
  v16[0] = (uint64_t)"BB";
  __int16 v17 = 259;
  int v4 = *(_DWORD *)(a2 + 24);
  __int16 v15 = 265;
  LODWORD(v14[0]) = v4;
  sub_1CB8F1E58(v16, v14, (uint64_t)v18);
  if (*(void *)(a2 + 16))
  {
    uint64_t v11 = "[";
    __int16 v12 = 259;
    sub_1CB8F1E58(v18, (uint64_t *)&v11, (uint64_t)v13);
    __int16 v10 = 261;
    v9[0] = (uint64_t)llvm::MachineBasicBlock::getName((llvm::MachineBasicBlock *)a2);
    v9[1] = v5;
    sub_1CB8F1E58(v13, v9, (uint64_t)v14);
    size_t v7 = "]";
    __int16 v8 = 259;
    sub_1CB8F1E58(v14, (uint64_t *)&v7, (uint64_t)v16);
    uint64_t v6 = v16;
  }
  else
  {
    uint64_t v6 = v18;
  }
  llvm::Twine::str((llvm::Twine *)v6, a1);
}

uint64_t sub_1CD527C7C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (sub_1CC152E2C(*(void *)(a1 + 160), *(_DWORD *)(a1 + 176), a2, &v6)) {
    int v3 = *(_DWORD *)(v6 + 8);
  }
  else {
    int v3 = -1;
  }
  int v5 = v3;
  return llvm::BlockFrequencyInfoImplBase::getFloatingBlockFreq(a1, &v5);
}

void sub_1CD527CE0(_WORD *a1, long long *a2, uint64_t *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCD620, 0, 0);
  dword_1EBCCD6A0 = 0;
  qword_1EBCCD6A8 = (uint64_t)&unk_1F2600F38;
  unk_1EBCCD6B0 = 0;
  qword_1EBCCD620 = (uint64_t)&unk_1F2600E80;
  qword_1EBCCD6B8 = (uint64_t)&unk_1F2600EE8;
  unk_1EBCCD6C0 = &qword_1EBCCD620;
  qword_1EBCCD6C8 = (uint64_t)&unk_1EBCCD6D8;
  qword_1EBCCD6D0 = 0x800000000;
  qword_1EBCCD858 = (uint64_t)&unk_1F26010D8;
  qword_1EBCCD870 = (uint64_t)&qword_1EBCCD858;
  sub_1CD527DE4(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCD620);
}

void sub_1CD527DE4(_WORD *a1, long long *a2, uint64_t *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCD620, "view-machine-block-freq-propagation-dags", 0x28uLL);
  word_1EBCCD62A = (32 * (*a1 & 3)) | word_1EBCCD62A & 0xFF9F;
  xmmword_1EBCCD640 = *a2;

  sub_1CBF7A820(a3, (uint64_t)&qword_1EBCCD620);
}

void sub_1CD527E68(_WORD *a1, long long *a2, uint64_t *a3)
{
  sub_1CB883A14((uint64_t)&llvm::ViewBlockLayoutWithBFI, 0, 0);
  dword_1EBD05170 = 0;
  qword_1EBD05178 = (uint64_t)&unk_1F2600F38;
  unk_1EBD05180 = 0;
  llvm::ViewBlockLayoutWithBFI = (uint64_t)&unk_1F2600E80;
  qword_1EBD05188 = (uint64_t)&unk_1F2600EE8;
  unk_1EBD05190 = &llvm::ViewBlockLayoutWithBFI;
  qword_1EBD05198 = (uint64_t)&unk_1EBD051A8;
  qword_1EBD051A0 = 0x800000000;
  qword_1EBD05328 = (uint64_t)&unk_1F26010D8;
  qword_1EBD05340 = (uint64_t)&qword_1EBD05328;
  sub_1CD527F6C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::ViewBlockLayoutWithBFI);
}

void sub_1CD527F6C(_WORD *a1, long long *a2, uint64_t *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&llvm::ViewBlockLayoutWithBFI, "view-block-layout-with-bfi", 0x1AuLL);
  word_1EBD050FA = (32 * (*a1 & 3)) | word_1EBD050FA & 0xFF9F;
  xmmword_1EBD05110 = *a2;

  sub_1CBF7A820(a3, (uint64_t)&llvm::ViewBlockLayoutWithBFI);
}

void sub_1CD527FF0(uint64_t a1)
{
  char v35 = 0;
  unint64_t v36 = 0;
  uint64_t v37 = 0;
  sub_1CC31FAAC(a1, &v35);
  int v2 = v35;
  if (v35 == v36) {
    goto LABEL_2;
  }
  v33[0] = 0;
  v33[1] = 0;
  int v34 = 0;
  sub_1CD45F30C(&__p, (v36 - v35) >> 3);
  uint64_t v29 = 0;
  __int16 v30 = 0;
  int v3 = v35;
  if (v36 != v35)
  {
    uint64_t v4 = 0;
    __int16 v5 = 0;
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    do
    {
      v28[0] = 0;
      v28[0] = *(void *)&v3[8 * v7];
      sub_1CD4D7004(v33, v28)[1] = v7;
      uint64_t v8 = sub_1CD527C7C(a1, v28[0]);
      uint64_t v9 = (char *)__p + v4;
      *(void *)uint64_t v9 = v8;
      *((_WORD *)v9 + 4) = v10;
      unint64_t v11 = sub_1CD45F614(v6, v5, *(void *)((char *)__p + v4), *(_WORD *)((char *)__p + v4 + 8));
      uint64_t v29 = v11;
      __int16 v5 = v12;
      __int16 v30 = v12;
      if (v12 < 0x4000)
      {
        unint64_t v6 = v11;
      }
      else
      {
        unint64_t v6 = -1;
        uint64_t v29 = -1;
        __int16 v5 = 0x3FFF;
        __int16 v30 = 0x3FFF;
      }
      ++v7;
      int v3 = v35;
      v4 += 16;
    }
    while (v7 < (v36 - v35) >> 3);
  }
  uint64_t v13 = (char *)__p;
  size_t v14 = v32;
  while (v13 != v14)
  {
    sub_1CBF7DF38((uint64_t)v13, (uint64_t)&v29);
    v13 += 16;
  }
  memset(v28, 0, sizeof(v28));
  sub_1CD528660(a1, (uint64_t *)&v35, (uint64_t)v33, (uint64_t)v28);
  sub_1CBF7E058(v28, (uint64_t *)&__p);
  uint64_t v15 = *(void *)(a1 + 128);
  uint64_t v16 = v15 + 320;
  uint64_t v17 = *(void *)(v15 + 328);
  if (v17 != v15 + 320)
  {
    while (1)
    {
      unsigned int v38 = 0;
      if ((sub_1CC152E2C(*(void *)(a1 + 160), *(_DWORD *)(a1 + 176), v17, &v38) & 1) == 0) {
        goto LABEL_17;
      }
      uint64_t v18 = *((unsigned int *)v38 + 2);
      if (v18 == 0xFFFFFFFFLL) {
        goto LABEL_17;
      }
      if (!v34) {
        goto LABEL_22;
      }
      unsigned int v19 = (v34 - 1) & ((v17 >> 4) ^ (v17 >> 9));
      uint64_t v20 = *(void *)(v33[0] + 16 * v19);
      if (v17 != v20) {
        break;
      }
LABEL_21:
      unsigned int v38 = (void **)v17;
      char v21 = sub_1CD4D7004(v33, &v38);
      int v22 = (char *)__p + 16 * v21[1];
      uint64_t v23 = *(void *)(a1 + 8) + 24 * v18;
      __int16 v24 = *((_WORD *)v22 + 4);
      *(void *)uint64_t v23 = *(void *)v22;
      *(_WORD *)(v23 + 8) = v24;
LABEL_17:
      uint64_t v17 = *(void *)(v17 + 8);
      if (v17 == v16) {
        goto LABEL_23;
      }
    }
    int v26 = 1;
    while (v20 != -4096)
    {
      unsigned int v27 = v19 + v26++;
      unsigned int v19 = v27 & (v34 - 1);
      uint64_t v20 = *(void *)(v33[0] + 16 * v19);
      if (v17 == v20) {
        goto LABEL_21;
      }
    }
LABEL_22:
    uint64_t v25 = *(void *)(a1 + 8) + 24 * v18;
    *(void *)uint64_t v25 = 0;
    *(_WORD *)(v25 + 8) = 0;
    goto LABEL_17;
  }
LABEL_23:
  unsigned int v38 = (void **)v28;
  sub_1CBF7EDF0(&v38);
  if (__p)
  {
    uint64_t v32 = (char *)__p;
    operator delete(__p);
  }
  MEMORY[0x1D25D9CD0](v33[0], 8);
  int v2 = v35;
LABEL_2:
  if (v2)
  {
    unint64_t v36 = v2;
    operator delete(v2);
  }
}

void sub_1CD5282A4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  int v8 = -1;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v11 = 1;
  for (uint64_t i = 56; i != 120; i += 16)
    *(_DWORD *)((char *)&v7 + i) = -1;
  sub_1CD5283C4((llvm::bfi_detail::IrreducibleGraph *)&v7, a2, a1);
  llvm::BlockFrequencyInfoImplBase::analyzeIrreducible(a1, (uint64_t)&v7, a2, a3);
}

_DWORD *sub_1CD5283C4(llvm::bfi_detail::IrreducibleGraph *this, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    llvm::bfi_detail::IrreducibleGraph::addNodesInLoop((uint64_t)this, a2);
    uint64_t v8 = *(unsigned int *)(a2 + 104);
    if (v8)
    {
      long long v9 = *(unsigned int **)(a2 + 96);
      uint64_t v10 = 4 * v8;
      do
      {
        unsigned int v11 = *v9++;
        unsigned int v14 = v11;
        sub_1CD5284BC((uint64_t)this, &v14, a2, a3);
        v10 -= 4;
      }
      while (v10);
    }
  }
  else
  {
    llvm::bfi_detail::IrreducibleGraph::addNodesInFunction((uint64_t *)this);
    if (*(void *)(*(void *)this + 72) != *(void *)(*(void *)this + 64))
    {
      unsigned int v5 = 1;
      do
      {
        unsigned int v13 = v5 - 1;
        sub_1CD5284BC((uint64_t)this, &v13, 0, a3);
      }
      while (0xAAAAAAAAAAAAAAABLL
            * ((uint64_t)(*(void *)(*(void *)this + 72) - *(void *)(*(void *)this + 64)) >> 3) > v5++);
    }
  }
  uint64_t result = sub_1CD45E940((_DWORD *)this + 12, (_DWORD *)this + 2);
  *((void *)this + 2) = *((void *)result + 1);
  return result;
}

void sub_1CD5284BC(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = a4;
  uint64_t v7 = sub_1CD45E740(a1 + 48, a2);
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v8 = a1 + 56;
    uint64_t v9 = 4;
  }
  else
  {
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(unsigned int *)(a1 + 64);
  }
  if (v8 + 16 * v9 != v7)
  {
    uint64_t v10 = *(unsigned int **)(v7 + 8);
    unsigned int v11 = *a2;
    uint64_t v12 = *(void *)(*(void *)a1 + 64);
    if (sub_1CBF7BDF0((int *)(v12 + 24 * v11)) && (uint64_t v13 = *(void *)(v12 + 24 * v11 + 8), *(unsigned char *)(v13 + 8)))
    {
      uint64_t v14 = *(unsigned int *)(v13 + 24);
      if (v14)
      {
        uint64_t v15 = *(unsigned int **)(v13 + 16);
        uint64_t v16 = 16 * v14;
        do
        {
          llvm::bfi_detail::IrreducibleGraph::addEdge(a1, (uint64_t)v10, v15, a3);
          v15 += 4;
          v16 -= 16;
        }
        while (v16);
      }
    }
    else
    {
      sub_1CD5285AC(&v17, a1, v10, a3);
    }
  }
}

void sub_1CD5285AC(uint64_t *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(*(void *)(*a1 + 136) + 8 * *a3);
  unsigned int v5 = *(uint64_t **)(v4 + 88);
  for (uint64_t i = *(uint64_t **)(v4 + 96); v5 != i; ++v5)
  {
    uint64_t v11 = *v5;
    uint64_t v12 = *a1;
    uint64_t v15 = 0;
    if (sub_1CC152E2C(*(void *)(v12 + 160), *(_DWORD *)(v12 + 176), v11, &v15)) {
      unsigned int v13 = *(_DWORD *)(v15 + 8);
    }
    else {
      unsigned int v13 = -1;
    }
    unsigned int v14 = v13;
    llvm::bfi_detail::IrreducibleGraph::addEdge(a2, (uint64_t)a3, &v14, a4);
  }
}

void sub_1CD528660(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  unint64_t v9 = (v7 - *a2) >> 3;
  sub_1CD45F678(v71, v9);
  unint64_t v60 = v9;
  sub_1CD45F30C(__p, v9);
  uint64_t v58 = v8;
  uint64_t v59 = v7;
  if (v7 != v8)
  {
    uint64_t v38 = 0;
    if (v9 <= 1) {
      uint64_t v39 = 1;
    }
    else {
      uint64_t v39 = v9;
    }
    do
    {
      uint64_t v40 = *(const llvm::MachineBasicBlock **)(*a2 + 8 * v38);
      *(void *)uint64_t v67 = v69;
      *(void *)&v67[8] = v69;
      *(void *)&unsigned char v67[16] = 2;
      int v68 = 0;
      unsigned int v42 = (const llvm::MachineBasicBlock **)*((void *)v40 + 11);
      uint64_t v41 = (const llvm::MachineBasicBlock **)*((void *)v40 + 12);
      if (v42 != v41)
      {
        do
        {
          uint64_t v43 = *v42;
          *(void *)&long long v65 = *v42;
          v72[0] = 0;
          if (sub_1CD3C8538((uint64_t *)a3, &v65, v72))
          {
            if (v72[0] != *(void *)a3 + 16 * *(unsigned int *)(a3 + 16))
            {
              sub_1CB89694C((llvm::SmallPtrSetImplBase *)v67, (uint64_t)v43);
              if (v44)
              {
                unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(*(llvm::MachineBranchProbabilityInfo **)(a1 + 112), v40, v43);
                if (EdgeProbability)
                {
                  unint64_t v46 = llvm::ScaledNumbers::divide64(EdgeProbability, 0x80000000uLL);
                  __int16 v62 = v47;
                  unint64_t v63 = v46;
                  uint64_t v61 = v47;
                  *(void *)&long long v65 = v43;
                  v72[0] = 0;
                  int v48 = sub_1CD3C8538((uint64_t *)a3, &v65, v72);
                  uint64_t v49 = v72[0];
                  if (!v48) {
                    uint64_t v49 = *(void *)a3 + 16 * *(unsigned int *)(a3 + 16);
                  }
                  *(void *)&long long v65 = *(void *)(v49 + 8);
                  *((void *)&v65 + 1) = v63;
                  uint64_t v66 = v61;
                  uint64_t v50 = v71[0] + 24 * v38;
                  unint64_t v51 = *(void *)(v50 + 8);
                  unint64_t v52 = *(void *)(v50 + 16);
                  uint64_t v53 = (char **)(v50 + 8);
                  if (v51 >= v52)
                  {
                    unint64_t v55 = sub_1CBF56DE8((void **)(v71[0] + 24 * v38), (uint64_t)&v65);
                  }
                  else
                  {
                    long long v54 = v65;
                    *(void *)(v51 + 16) = v66;
                    *(_OWORD *)unint64_t v51 = v54;
                    unint64_t v55 = (char *)(v51 + 24);
                  }
                  *uint64_t v53 = v55;
                  unint64_t v56 = (char *)__p[0] + 16 * v38;
                  *(void *)unint64_t v56 = sub_1CD45F614(*(void *)v56, *((_WORD *)v56 + 4), v63, v62);
                  *((_WORD *)v56 + 4) = v57;
                  if (v57 >= 0x4000)
                  {
                    *(void *)unint64_t v56 = -1;
                    *((_WORD *)v56 + 4) = 0x3FFF;
                  }
                }
              }
            }
          }
          ++v42;
        }
        while (v42 != v41);
        if (*(void *)&v67[8] != *(void *)v67) {
          free(*(void **)&v67[8]);
        }
      }
      ++v38;
    }
    while (v38 != v39);
  }
  sub_1CD45F678(v67, v9);
  sub_1CD45F718((void **)a4);
  *(_OWORD *)a4 = *(_OWORD *)v67;
  *(void *)(a4 + 16) = *(void *)&v67[16];
  memset(v67, 0, sizeof(v67));
  *(void *)&long long v65 = v67;
  sub_1CBF7EDF0((void ***)&v65);
  if (v59 != v58)
  {
    uint64_t v10 = 0;
    if (v60 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = v60;
    }
    do
    {
      uint64_t v12 = (uint64_t **)(v71[0] + 24 * v10);
      unsigned int v13 = *v12;
      unsigned int v14 = v12[1];
      while (v13 != v14)
      {
        uint64_t v15 = *v13;
        long long v65 = *(_OWORD *)(v13 + 1);
        uint64_t v16 = *(void ***)a4;
        *(void *)uint64_t v67 = v65;
        *(_WORD *)&v67[8] = WORD4(v65);
        long long v17 = *(_OWORD *)sub_1CBF7DF38((uint64_t)v67, (uint64_t)__p[0] + 16 * v10);
        *(void *)uint64_t v67 = v10;
        *(_OWORD *)&v67[8] = v17;
        uint64_t v18 = &v16[3 * v15];
        unsigned int v19 = (char *)v18[1];
        uint64_t v20 = (char *)v18[2];
        char v21 = (char **)(v18 + 1);
        if (v19 >= v20)
        {
          uint64_t v23 = sub_1CBF56DE8(&v16[3 * v15], (uint64_t)v67);
        }
        else
        {
          long long v22 = *(_OWORD *)v67;
          *((void *)v19 + 2) = *(void *)&v67[16];
          *(_OWORD *)unsigned int v19 = v22;
          uint64_t v23 = v19 + 24;
        }
        *char v21 = v23;
        v13 += 3;
      }
      ++v10;
    }
    while (v10 != v11);
  }
  *(void *)uint64_t v67 = *(void *)(*(void *)(a1 + 128) + 328);
  *(void *)&long long v65 = 0;
  int v24 = sub_1CD3C8538((uint64_t *)a3, v67, &v65);
  uint64_t v25 = v65;
  if (!v24) {
    uint64_t v25 = *(void *)a3 + 16 * *(unsigned int *)(a3 + 16);
  }
  if (v59 != v58)
  {
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = *(void *)(v25 + 8);
    if (v60 <= 1) {
      uint64_t v29 = 1;
    }
    else {
      uint64_t v29 = v60;
    }
    long long v30 = xmmword_1CD91D2E0;
    do
    {
      if (*(void *)(v71[0] + v26) == *(void *)(v71[0] + v26 + 8))
      {
        char v31 = *(void ***)a4;
        *(void *)uint64_t v67 = v27;
        *(_OWORD *)&v67[8] = v30;
        uint64_t v32 = &v31[3 * v28];
        __int16 v33 = (char *)v32[1];
        int v34 = (char *)v32[2];
        char v35 = (char **)(v32 + 1);
        if (v33 >= v34)
        {
          uint64_t v37 = sub_1CBF56DE8(&v31[3 * v28], (uint64_t)v67);
          long long v30 = xmmword_1CD91D2E0;
        }
        else
        {
          long long v36 = *(_OWORD *)v67;
          *((void *)v33 + 2) = *(void *)&v67[16];
          *(_OWORD *)__int16 v33 = v36;
          uint64_t v37 = v33 + 24;
        }
        *char v35 = v37;
      }
      ++v27;
      v26 += 24;
    }
    while (v29 != v27);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(void *)uint64_t v67 = v71;
  sub_1CBF7EDF0((void ***)v67);
}

uint64_t sub_1CD528A9C(uint64_t a1, uint64_t a2, char a3, llvm::Twine *a4)
{
  sub_1CD528B90((uint64_t)v9, a1, a2, a3);
  llvm::Twine::str(a4, __p);
  sub_1CD528B14(v9, (uint64_t)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  MEMORY[0x1D25D9CD0](v9[6], 8);
  return a1;
}

llvm::raw_ostream *sub_1CD528B14(uint64_t **a1, uint64_t a2)
{
  sub_1CD528C30((uint64_t)a1, a2);
  uint64_t v3 = *(void *)(*(void *)(*a1[1] + 248) + 128);
  uint64_t v4 = (llvm::MachineBasicBlock *)(v3 + 320);
  for (uint64_t i = *(llvm::MachineBasicBlock **)(v3 + 328); i != v4; uint64_t i = (llvm::MachineBasicBlock *)*((void *)i + 1))
    sub_1CC320AC8(a1, i);
  unint64_t v6 = *a1;

  return sub_1CB8E509C((llvm::raw_ostream *)v6, "}\n");
}

uint64_t sub_1CD528B90(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  HIBYTE(v6) = 0;
  *(unsigned char *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 25) = v6;
  MEMORY[0x1D25D9CD0](0, 8);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  MEMORY[0x1D25D9CD0](0, 8);
  *(unsigned char *)(a1 + 16) = 0;
  return a1;
}

void sub_1CD528C30(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(**(void **)(a1 + 8) + 248);
  if (v4) {
    unsigned int v5 = *(llvm::Value ***)(v4 + 128);
  }
  else {
    unsigned int v5 = 0;
  }
  uint64_t Name = llvm::MachineFunction::getName(v5);
  std::string::__init(&v32, Name, v7);
  char v8 = *(unsigned char *)(a2 + 23);
  int v9 = v8;
  uint64_t v10 = v8 & 0x7F;
  if (v9 < 0) {
    uint64_t v10 = *(void *)(a2 + 8);
  }
  if (v10)
  {
    uint64_t v11 = sub_1CB8E509C(*(llvm::raw_ostream **)a1, "digraph \"");
    uint64_t v12 = (std::string *)a2;
  }
  else
  {
    std::string::size_type size = *((unsigned char *)&v32.__r_.__value_.__s + 23) & 0x7F;
    if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v32.__r_.__value_.__l.__size_;
    }
    uint64_t v26 = *(llvm::raw_ostream **)a1;
    if (!size)
    {
      sub_1CB8E509C(v26, "digraph unnamed {\n");
      goto LABEL_15;
    }
    uint64_t v11 = sub_1CB8E509C(v26, "digraph \"");
    uint64_t v12 = &v32;
  }
  llvm::DOT::EscapeString((char *)v12, (uint64_t)&__p);
  if (v31 >= 0) {
    p_p = (const char *)&__p;
  }
  else {
    p_p = (const char *)__p;
  }
  if (v31 >= 0) {
    size_t v14 = v31 & 0x7F;
  }
  else {
    size_t v14 = v30;
  }
  uint64_t v15 = llvm::raw_ostream::write(v11, p_p, v14);
  sub_1CB8E509C(v15, "\" {\n");
  if (v31 < 0) {
    operator delete(__p);
  }
LABEL_15:
  char v16 = *(unsigned char *)(a2 + 23);
  int v17 = v16;
  uint64_t v18 = v16 & 0x7F;
  if (v17 < 0) {
    uint64_t v18 = *(void *)(a2 + 8);
  }
  if (v18)
  {
    unsigned int v19 = sub_1CB8E509C(*(llvm::raw_ostream **)a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)a2, (uint64_t)&__p);
    if (v31 >= 0) {
      uint64_t v20 = (const char *)&__p;
    }
    else {
      uint64_t v20 = (const char *)__p;
    }
    if (v31 >= 0) {
      size_t v21 = v31 & 0x7F;
    }
    else {
      size_t v21 = v30;
    }
    long long v22 = v19;
    goto LABEL_25;
  }
  std::string::size_type v27 = *((unsigned char *)&v32.__r_.__value_.__s + 23) & 0x7F;
  if ((v32.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v27 = v32.__r_.__value_.__l.__size_;
  }
  if (v27)
  {
    uint64_t v28 = sub_1CB8E509C(*(llvm::raw_ostream **)a1, "\tlabel=\"");
    llvm::DOT::EscapeString((char *)&v32, (uint64_t)&__p);
    if (v31 >= 0) {
      uint64_t v20 = (const char *)&__p;
    }
    else {
      uint64_t v20 = (const char *)__p;
    }
    if (v31 >= 0) {
      size_t v21 = v31 & 0x7F;
    }
    else {
      size_t v21 = v30;
    }
    long long v22 = v28;
LABEL_25:
    uint64_t v23 = llvm::raw_ostream::write(v22, v20, v21);
    sub_1CB8E509C(v23, "\";\n");
    if (v31 < 0) {
      operator delete(__p);
    }
  }
  int v24 = *(llvm::raw_ostream **)a1;
  char v31 = 0;
  LOBYTE(__p) = 0;
  llvm::raw_ostream::write(v24, (const char *)&__p, 0);
  if (v31 < 0) {
    operator delete(__p);
  }
  sub_1CB8E509C(*(llvm::raw_ostream **)a1, "\n");
  if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v32.__r_.__value_.__l.__data_);
  }
}

void sub_1CD528E98(void *a1, uint64_t a2, llvm::MachineBasicBlock *a3, uint64_t a4)
{
  uint64_t v15 = a3;
  if (*(unsigned char *)a2)
  {
    int v12 = -1;
  }
  else
  {
    uint64_t v7 = *((void *)a3 + 4);
    uint64_t v8 = *(void *)(a2 + 16);
    if (v8) {
      BOOL v9 = v7 == v8;
    }
    else {
      BOOL v9 = 0;
    }
    if (!v9)
    {
      if (v8) {
        sub_1CD3C7F68((_DWORD *)(a2 + 24));
      }
      *(void *)(a2 + 16) = v7;
      uint64_t v10 = *(void *)(v7 + 328);
      if (v10 != v7 + 320)
      {
        int v11 = 0;
        do
        {
          uint64_t v14 = v10;
          *((_DWORD *)sub_1CD3CDD24((uint64_t *)(a2 + 24), &v14) + 2) = v11++;
          uint64_t v10 = *(void *)(v10 + 8);
        }
        while (v10 != v7 + 320);
      }
    }
    int v12 = *((_DWORD *)sub_1CD3CDD24((uint64_t *)(a2 + 24), &v15) + 2);
    a3 = v15;
  }
  if (dword_1EBD05170) {
    int v13 = dword_1EBD05170;
  }
  else {
    int v13 = dword_1EBCCD6A0;
  }
  sub_1CD529198(a1, a3, a4, v13, v12);
}

void sub_1CD528F90(uint64_t a1, void *a2, unint64_t *a3)
{
  unint64_t v3 = *a3;
  if (*a3)
  {
    uint64_t v6 = **(void **)(a1 + 8);
    uint64_t v7 = *(void *)(v6 + 248);
    if (v7) {
      uint64_t v8 = *(void *)(v7 + 112);
    }
    else {
      uint64_t v8 = 0;
    }
    sub_1CD529388(__p, a1 + 24, a2, (uint64_t)a3, v6, v8, dword_1EBD02958);
    sub_1CD460084((llvm::raw_ostream **)a1, (unint64_t)a2, v3, (uint64_t)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1CD529030(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a5)
  {
    char v10 = *(void **)(a2 + 8);
    if (!v10)
    {
      uint64_t v14 = *(void *)(*(void *)(a4 + 248) + 128);
      uint64_t v15 = v14 + 320;
      uint64_t v16 = *(void *)(v14 + 328);
      if (v16 == v14 + 320)
      {
        char v10 = 0;
      }
      else
      {
        char v10 = 0;
        do
        {
          unint64_t v17 = *(void *)(a4 + 248);
          if (v17)
          {
            unint64_t v17 = sub_1CC31E95C(v17, v16);
            char v10 = *(void **)(a2 + 8);
          }
          if ((unint64_t)v10 <= v17) {
            char v10 = (void *)v17;
          }
          *(void *)(a2 + 8) = v10;
          uint64_t v16 = *(void *)(v16 + 8);
        }
        while (v16 != v15);
      }
    }
    uint64_t v11 = *(void *)(a4 + 248);
    if (v11)
    {
      unint64_t v12 = sub_1CC31E95C(v11, a3);
      char v10 = *(void **)(a2 + 8);
    }
    else
    {
      unint64_t v12 = 0;
    }
    uint64_t v18 = v10;
    unsigned int BranchProbability = llvm::BranchProbability::getBranchProbability(a5, 0x64uLL);
    if (v12 >= llvm::BlockFrequency::operator*((unint64_t *)&v18, BranchProbability))
    {
      int v19 = 0;
      char v23 = 0;
      uint64_t v24 = 0;
      uint64_t v26 = a1;
      int v25 = 0;
      uint64_t v18 = &unk_1F2646F30;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      sub_1CB8E509C((llvm::raw_ostream *)&v18, "color=\"red\"");
      if (v22 != v20) {
        llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v18);
      }
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v18);
    }
  }
}

void sub_1CD529198(void *a1, llvm::MachineBasicBlock *this, uint64_t a3, int a4, int a5)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v21 = 0;
  char v25 = 0;
  uint64_t v26 = 0;
  uint64_t v28 = a1;
  int v27 = 0;
  uint64_t v20 = &unk_1F2646F30;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t Name = llvm::MachineBasicBlock::getName(this);
  if (a5 == -1)
  {
    if (v9) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v20, Name, v9);
    }
    int v13 = " : ";
    unint64_t v12 = (llvm::raw_ostream *)&v20;
  }
  else
  {
    if (v9) {
      llvm::raw_ostream::write((llvm::raw_ostream *)&v20, Name, v9);
    }
    uint64_t v11 = sub_1CB8E509C((llvm::raw_ostream *)&v20, "[");
    unint64_t v12 = llvm::raw_ostream::operator<<(v11, a5);
    int v13 = "] : ";
  }
  sub_1CB8E509C(v12, v13);
  switch(a4)
  {
    case 3:
      uint64_t v15 = *(void *)(a3 + 248);
      if (!v15 || (uint64_t v18 = sub_1CD52763C(v15, **(uint64_t *****)(v15 + 128), (uint64_t)this, 0), !v19))
      {
        sub_1CB8E509C((llvm::raw_ostream *)&v20, "Unknown");
        break;
      }
      unint64_t v17 = v18;
LABEL_18:
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v20, v17);
      break;
    case 2:
      uint64_t v16 = *(void *)(a3 + 248);
      if (v16) {
        unint64_t v17 = sub_1CC31E95C(v16, (uint64_t)this);
      }
      else {
        unint64_t v17 = 0;
      }
      goto LABEL_18;
    case 1:
      uint64_t v14 = *(void *)(a3 + 248);
      if (v14) {
        sub_1CD527874(v14, (llvm::ScaledNumberBase *)&v20, (uint64_t)this);
      }
      break;
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v20);
}

void sub_1CD529388(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a6)
  {
    unsigned int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(a6, a3, a4);
    int v17 = 0;
    char v21 = 0;
    uint64_t v22 = 0;
    uint64_t v24 = a1;
    int v23 = 0;
    uint64_t v16 = &unk_1F2646F30;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    v15[0] = (unint64_t)&unk_1F25F6490;
    v15[1] = (unint64_t)"label=\"%.1f%%\"";
    *(double *)&v15[2] = (double)EdgeProbability * 100.0 * 4.65661287e-10;
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v16, (uint64_t)v15);
    if (a7)
    {
      unint64_t v13 = *(void *)(a5 + 248);
      if (v13) {
        unint64_t v13 = sub_1CC31E95C(v13, (uint64_t)a3);
      }
      v15[0] = v13;
      unint64_t v14 = llvm::BlockFrequency::operator*(v15, EdgeProbability);
      v15[0] = *(void *)(a2 + 8);
      if (v14 >= llvm::BlockFrequency::operator*(v15, (unint64_t)(((((unint64_t)a7 << 31) | 0x30) * (unsigned __int128)0xA3D70A3D70A3D70BLL) >> 64) >> 6))sub_1CB8E509C((llvm::raw_ostream *)&v16, ",color=\"red\""); {
    }
      }
    if (v20 != v18) {
      llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v16);
    }
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v16);
  }
}

void llvm::initializeMachineBlockPlacementPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD878, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC321574;
    v4[1] = &v2;
    unint64_t v3 = v4;
    std::__call_once(&qword_1EBCCD878, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeMachineBlockPlacementStatsPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCD880, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC321634;
    v4[1] = &v2;
    unint64_t v3 = v4;
    std::__call_once(&qword_1EBCCD880, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD5295FC(uint64_t a1)
{
  sub_1CD529648((unsigned int *)(a1 + 152));
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 152), 8);
  int v2 = *(void **)(a1 + 72);
  if (v2 != (void *)(a1 + 88)) {
    free(v2);
  }
  return a1;
}

void sub_1CD529648(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 32 * v1;
    unint64_t v3 = (void *)(*(void *)a1 + 16);
    do
    {
      if (*((_DWORD *)v3 - 4) <= 0xFFFFFFFD)
      {
        uint64_t v4 = (void *)*(v3 - 1);
        if (v4)
        {
          *unint64_t v3 = v4;
          operator delete(v4);
        }
      }
      v3 += 4;
      v2 -= 32;
    }
    while (v2);
  }
}

void *sub_1CD5296A0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1CD529884((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 144);
    if (v6 >= *(_DWORD *)(a1 + 148)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 136) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 144);
  }
  return result;
}

void *sub_1CD529724(void *result, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v10 = v3;
    uint64_t v11 = v4;
    unsigned int v6 = a2;
    uint64_t v7 = (uint64_t)result;
    do
    {
      uint64_t result = sub_1CD529884((uint64_t)v9, v7, v6);
      if (v9[16])
      {
        unint64_t v8 = *(unsigned int *)(v7 + 144);
        if (v8 >= *(unsigned int *)(v7 + 148)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v7 + 136) + 8 * v8) = *v6;
        ++*(_DWORD *)(v7 + 144);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

uint64_t sub_1CD5297D8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 16;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD529884(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v14 = 0;
  uint64_t result = (void *)sub_1CD5297D8(a2, *a3, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v8 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v9 = 16;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 8 * v9;
  }
  else
  {
    uint64_t result = sub_1CD529944((_DWORD *)a2, a3, v14);
    uint64_t v7 = result;
    void *result = *a3;
    uint64_t v12 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v13 = 16;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v13 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v11 = v12 + 8 * v13;
    char v10 = 1;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void *sub_1CD529944(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 16;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD529A04((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD5297D8((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD529A04(uint64_t a1, unsigned int a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  if (a2 >= 0x11)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 0x10)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD529B80(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = v14;
  for (uint64_t i = 8; i != 136; i += 8)
  {
    uint64_t v10 = *(void *)(a1 + i);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v8++ = v10;
    }
  }
  if (a2 > 0x10)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD529B80(a1, v14, v8);
}

uint64_t sub_1CD529B80(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 136);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD5297D8((uint64_t)v5, v10, &v11);
      *uint64_t v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

llvm::SmallPtrSetImplBase *sub_1CD529C44(llvm::SmallPtrSetImplBase *this, uint64_t *a2, uint64_t *a3)
{
  *(void *)this = (char *)this + 32;
  *((void *)this + 1) = (char *)this + 32;
  *((void *)this + 2) = 2;
  *((_DWORD *)this + 6) = 0;
  if (a2 != a3)
  {
    int v5 = a2;
    do
    {
      uint64_t v6 = *v5++;
      sub_1CB89694C(this, v6);
    }
    while (v5 != a3);
  }
  return this;
}

void *sub_1CD529CAC(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (void *)sub_1CC32A664((_DWORD *)a1, *a2);
  if (result)
  {
    uint64_t result = *(void **)(a1 + 136);
    uint64_t v5 = *(unsigned int *)(a1 + 144);
    uint64_t v6 = &result[v5];
    if (v5)
    {
      uint64_t v7 = 8 * v5;
      while (*result != *a2)
      {
        ++result;
        v7 -= 8;
        if (!v7)
        {
          uint64_t result = v6;
          break;
        }
      }
    }
    if (v6 != result + 1)
    {
      uint64_t result = memmove(result, result + 1, (char *)v6 - (char *)(result + 1));
      LODWORD(v5) = *(_DWORD *)(a1 + 144);
    }
    *(_DWORD *)(a1 + 144) = v5 - 1;
  }
  return result;
}

void *sub_1CD529D2C(void *result, int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    unsigned int v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (*((_DWORD *)result + 4) <= v4) {
      return sub_1CD4D7118((uint64_t)result, v4 + 1);
    }
  }
  return result;
}

void *sub_1CD529D78(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD529DE8(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD529ED8(a1, a2, v7);
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
    void v5[2] = 0;
  }
  return v5;
}

uint64_t sub_1CD529DE8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((37 * a4) | (unint64_t)(0x2500000000 * a3))
       + ~((unint64_t)(37 * a4) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (void *)(a1 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      uint64_t v14 = 1;
    }
    else
    {
      uint64_t v16 = 0;
      int v17 = 1;
      while (v11 != -1 || v12 != -1)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v12 == -2;
        }
        if (v18 && v11 == -2) {
          uint64_t v16 = v10;
        }
        unsigned int v20 = v9 + v17++;
        unsigned int v9 = v20 & v8;
        uint64_t v10 = (void *)(a1 + 24 * (v20 & v8));
        uint64_t v11 = *v10;
        uint64_t v12 = v10[1];
        uint64_t v14 = 1;
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_8;
        }
      }
      uint64_t v14 = 0;
      if (v16) {
        uint64_t v10 = v16;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

void *sub_1CD529ED8(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD529F90(a1, v6);
  unsigned int v9 = 0;
  sub_1CD529DE8(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || a3[1] != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD529F90(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD52A068(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    do
    {
      void *result = -1;
      result[1] = -1;
      result += 3;
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD52A068(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 24 * v6;
    do
    {
      void *v7 = -1;
      v7[1] = -1;
      v7 += 3;
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    uint64_t v10 = a2[1];
    if ((*a2 != -1 || v10 != -1) && (v9 != -2 || v10 != -2))
    {
      uint64_t v14 = 0;
      uint64_t result = sub_1CD529DE8(*(void *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v14);
      uint64_t v13 = v14;
      *uint64_t v14 = *a2;
      v13[1] = a2[1];
      uint64_t v13[2] = a2[2];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

void sub_1CD52A138(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCCD948, 0, 0);
  dword_1EBCCD9C8 = 0;
  qword_1EBCCD9D0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCCD9D8 = 0;
  qword_1EBCCD948 = (uint64_t)&unk_1F2643F00;
  qword_1EBCCD9E0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCCD9E8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCCDA00 = (uint64_t)&qword_1EBCCD9E8;
  llvm::cl::Option::setArgStr(v6, "align-all-nofallthru-blocks", 0x1BuLL);
  xmmword_1EBCCD968 = *a1;
  dword_1EBCCD9C8 = **a2;
  byte_1EBCCD9DC = 1;
  dword_1EBCCD9D8 = dword_1EBCCD9C8;
  word_1EBCCD952 = (32 * (*a3 & 3)) | word_1EBCCD952 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCD948);
}

void sub_1CD52A260(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCCDAC8, 0, 0);
  dword_1EBCCDB48 = 0;
  qword_1EBCCDB50 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCCDB58 = 0;
  qword_1EBCCDAC8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCCDB60 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCCDB68 = (uint64_t)&unk_1F25EA168;
  qword_1EBCCDB80 = (uint64_t)&qword_1EBCCDB68;
  llvm::cl::Option::setArgStr(v6, "block-placement-exit-block-bias", 0x1FuLL);
  xmmword_1EBCCDAE8 = *a1;
  dword_1EBCCDB48 = **a2;
  byte_1EBCCDB5C = 1;
  dword_1EBCCDB58 = dword_1EBCCDB48;
  word_1EBCCDAD2 = (32 * (*a3 & 3)) | word_1EBCCDAD2 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCDAC8);
}

void sub_1CD52A388(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCCE248, 0, 0);
  dword_1EBCCE2C8 = 0;
  qword_1EBCCE2D0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCCE2D8 = 0;
  qword_1EBCCE248 = (uint64_t)&unk_1F2643F00;
  qword_1EBCCE2E0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCCE2E8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCCE300 = (uint64_t)&qword_1EBCCE2E8;
  llvm::cl::Option::setArgStr(v6, "tail-dup-placement-aggressive-threshold", 0x27uLL);
  xmmword_1EBCCE268 = *a1;
  dword_1EBCCE2C8 = **a2;
  byte_1EBCCE2DC = 1;
  dword_1EBCCE2D8 = dword_1EBCCE2C8;
  word_1EBCCE252 = (32 * (*a3 & 3)) | word_1EBCCE252 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCE248);
}

void llvm::initializeMachineBranchProbabilityInfoPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE548, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC32C958;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCCE548, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::MachineBranchProbabilityInfo *llvm::MachineBranchProbabilityInfo::MachineBranchProbabilityInfo(llvm::MachineBranchProbabilityInfo *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::MachineBranchProbabilityInfo::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F260D7C0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(this);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE548, memory_order_acquire) != -1)
  {
    v5[0] = sub_1CC32C958;
    v5[1] = &PassRegistry;
    char v4 = v5;
    std::__call_once(&qword_1EBCCE548, &v4, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void sub_1CD52A5E0(llvm::ImmutablePass *a1)
{
  llvm::ImmutablePass::~ImmutablePass(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD52A618(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void llvm::callDefaultCtor<llvm::MachineBranchProbabilityInfo>()
{
}

void sub_1CD52A660(long long *a1, int **a2, _WORD *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&llvm::StaticLikelyProb, 0, 0);
  dword_1EBD053C8 = 0;
  qword_1EBD053D0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBD053D8 = 0;
  llvm::StaticLikelyProb = (uint64_t)&unk_1F2643F00;
  qword_1EBD053E0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBD053E8 = (uint64_t)&unk_1F25EA168;
  qword_1EBD05400 = (uint64_t)&qword_1EBD053E8;
  llvm::cl::Option::setArgStr(v6, "static-likely-prob", 0x12uLL);
  xmmword_1EBD05368 = *a1;
  dword_1EBD053C8 = **a2;
  byte_1EBD053DC = 1;
  dword_1EBD053D8 = dword_1EBD053C8;
  word_1EBD05352 = (32 * (*a3 & 3)) | word_1EBD05352 & 0xFF9F;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::StaticLikelyProb);
}

void llvm::initializeMachineCombinerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE558, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC32D114;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCCE558, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD52A7FC(_WORD *a1, __n128 *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCE6E0, 0, 0);
  byte_1EBCCE760 = 0;
  qword_1EBCCE768 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCCE770 = 0;
  qword_1EBCCE6E0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCCE778 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCCE780 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCCE798 = (uint64_t)&qword_1EBCCE780;
  sub_1CD52A8EC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCE6E0);
}

__n128 sub_1CD52A8EC(_WORD *a1, __n128 *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCE6E0, "machine-combiner-verify-pattern-order", 0x25uLL);
  word_1EBCCE6EA = (32 * (*a1 & 3)) | word_1EBCCE6EA & 0xFF9F;
  __n128 result = *a2;
  xmmword_1EBCCE700 = (__int128)*a2;
  int v7 = *a3;
  byte_1EBCCE760 = **a3;
  byte_1EBCCE771 = 1;
  byte_1EBCCE770 = *v7;
  return result;
}

void llvm::initializeMachineCopyPropagationPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7A8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC32F048;
    v4[1] = &v2;
    unsigned int v3 = v4;
    std::__call_once(&qword_1EBCCE7A8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t **sub_1CD52A9E8(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    do
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= v7) {
        return v8;
      }
      uint64_t v5 = v8[1];
    }
    while (v5);
    uint64_t v6 = v8 + 1;
  }
  else
  {
    uint64_t v8 = a1 + 1;
  }
LABEL_8:
  uint64_t v10 = (uint64_t *)v8;
  uint64_t v8 = (uint64_t **)operator new(0x20uLL);
  *((_DWORD *)v8 + 7) = *a3;
  void *v8 = 0;
  v8[1] = 0;
  void v8[2] = v10;
  void *v6 = (uint64_t *)v8;
  uint64_t v11 = (uint64_t *)**a1;
  uint64_t v12 = (uint64_t *)v8;
  if (v11)
  {
    *a1 = v11;
    uint64_t v12 = *v6;
  }
  sub_1CB8358B8(a1[1], v12);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v8;
}

void sub_1CD52AACC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    unsigned int v7 = *(void **)a1;
    uint64_t v8 = 56 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 7;
      v8 -= 56;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v9 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v13 = 0;
      sub_1CC331B70(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
      uint64_t v10 = v13;
      uint64_t v11 = v13 + 5;
      *uint64_t v13 = *a2;
      llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v10 + 1), v11, 2, a2 + 1);
      ++*(_DWORD *)(a1 + 8);
      uint64_t v12 = (void *)a2[2];
      if (v12 != (void *)a2[1]) {
        free(v12);
      }
    }
    a2 += 7;
  }
}

void sub_1CD52ABA0(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CC330830(a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint64_t v5 = *(void **)a1;
      uint64_t v6 = 56 * v4;
      do
      {
        void *v5 = -4096;
        v5 += 7;
        v6 -= 56;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CBF7A0E8(a1, v4);
  }
}

void llvm::initializeMachineCSEPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7B0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC332CB8;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCCE7B0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

_DWORD *sub_1CD52ACC8(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      uint64_t v6 = *(void **)result;
      uint64_t v7 = 16 * v2;
      do
      {
        void *v6 = 0;
        v6 += 2;
        v7 -= 16;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CC3359D4(v1, v5);
  }
  return result;
}

uint64_t sub_1CD52AD70(uint64_t a1, const llvm::MachineInstr *const *a2, llvm::MachineInstrExpressionTrait *this, uint64_t **a4)
{
  if (a2)
  {
    int v7 = a2 - 1;
    unsigned int v8 = llvm::MachineInstrExpressionTrait::getHashValue(this, a2) & (a2 - 1);
    uint64_t v9 = (uint64_t *)(a1 + 16 * v8);
    if (sub_1CC335AA0(*(void *)this, *v9))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      while (*v9)
      {
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = *v9 == -1;
        }
        if (v13) {
          uint64_t v11 = v9;
        }
        int v17 = v11;
        int v14 = v12 + 1;
        unsigned int v8 = (v8 + v12) & v7;
        uint64_t v9 = (uint64_t *)(a1 + 16 * v8);
        BOOL v15 = sub_1CC335AA0(*(void *)this, *v9);
        uint64_t v11 = v17;
        BOOL v16 = v15;
        uint64_t result = 1;
        int v12 = v14;
        if (v16) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v11) {
        uint64_t v9 = v11;
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a4 = v9;
  return result;
}

uint64_t *sub_1CD52AE60(uint64_t a1, llvm::MachineInstrExpressionTrait *this)
{
  int v7 = 0;
  char v4 = sub_1CD52AD70(*(void *)a1, (const llvm::MachineInstr *const *)*(unsigned int *)(a1 + 16), this, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD52AECC(a1, this, v7);
    uint64_t *v5 = *(void *)this;
    v5[1] = 0;
  }
  return v5;
}

uint64_t *sub_1CD52AECC(uint64_t a1, llvm::MachineInstrExpressionTrait *a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD52AF7C(a1, v6);
  unsigned int v8 = 0;
  sub_1CD52AD70(*(void *)a1, (const llvm::MachineInstr *const *)*(unsigned int *)(a1 + 16), a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD52AF7C(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(llvm::MachineInstrExpressionTrait **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD52B044(a1, v4, (llvm::MachineInstrExpressionTrait *)((char *)v4 + 16 * v3));
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = 0;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD52B044(uint64_t result, llvm::MachineInstrExpressionTrait *this, llvm::MachineInstrExpressionTrait *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 16 * v6;
    do
    {
      void *v7 = 0;
      v7 += 2;
      v8 -= 16;
    }
    while (v8);
  }
  while (this != a3)
  {
    if ((unint64_t)(*(void *)this + 1) >= 2)
    {
      uint64_t v10 = 0;
      uint64_t result = sub_1CD52AD70(*(void *)v5, (const llvm::MachineInstr *const *)*(unsigned int *)(v5 + 16), this, &v10);
      uint64_t v9 = v10;
      *uint64_t v10 = *(void *)this;
      v9[1] = *((void *)this + 1);
      ++*(_DWORD *)(v5 + 8);
    }
    this = (llvm::MachineInstrExpressionTrait *)((char *)this + 16);
  }
  return result;
}

void llvm::initializeCheckDebugMachineModulePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7B8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC337250;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCE7B8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createCheckDebugMachineModulePass(llvm *this)
{
}

void llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(uint64_t **)(a1 + 64);
  uint64_t v3 = *(uint64_t **)(a1 + 72);
  if (v2 == v3) {
    return;
  }
  uint64_t v5 = (const void **)&v28;
  uint64_t v6 = (const llvm::SmallPtrSetImplBase *)&v36;
  int v7 = (const void **)&v22;
  do
  {
    sub_1CD4C01BC(&v32, *v2);
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v26, v5, (const llvm::SmallPtrSetImplBase *)&v32);
    std::string __p = 0;
    size_t v30 = 0;
    uint64_t v31 = 0;
    sub_1CBF340A8(&__p, v34, v35, 0xAAAAAAAAAAAAAAABLL * ((v35 - (unsigned char *)v34) >> 3));
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v20, v7, v6);
    int v23 = 0;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    sub_1CBF340A8(&v23, v38, v39, 0xAAAAAAAAAAAAAAABLL * ((v39 - (unsigned char *)v38) >> 3));
    while (1)
    {
      if (v30 - (unsigned char *)__p != v24 - v23) {
        goto LABEL_23;
      }
      if (__p == v30) {
        break;
      }
      uint64_t v8 = v23 + 8;
      uint64_t v9 = (char *)__p + 8;
      while (1)
      {
        uint64_t v10 = v9 - 8;
        if (*((void *)v9 - 1) != *((void *)v8 - 1)) {
          break;
        }
        int v11 = v8[8];
        if (v9[8]) {
          BOOL v12 = v11 == 0;
        }
        else {
          BOOL v12 = 1;
        }
        if (v12)
        {
          if ((v9[8] == 0) == (v11 != 0)) {
            break;
          }
        }
        else if (*(void *)v9 != *(void *)v8)
        {
          break;
        }
        v8 += 24;
        v9 += 24;
        if (v10 + 24 == v30) {
          goto LABEL_26;
        }
      }
LABEL_23:
      int v17 = v7;
      BOOL v18 = v6;
      int v14 = v5;
      uint64_t v15 = *((void *)v30 - 3);
      if (*(_DWORD *)(v15 + 80))
      {
        unsigned int v13 = 0;
        do
        {
          sub_1CB8E509C(a2, "    ");
          ++v13;
        }
        while (v13 < *(_DWORD *)(v15 + 80));
      }
      uint64_t v40 = (void (**)(void **))&unk_1F260DD18;
      v41[0] = v15;
      v41[1] = a1;
      unsigned int v42 = (void **)&v40;
      sub_1CD52BEB8(v41, a2);
      BOOL v16 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v16 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 10);
      }
      else
      {
        *((void *)a2 + 4) = v16 + 1;
        unsigned char *v16 = 10;
      }
      uint64_t v5 = v14;
      int v7 = v17;
      uint64_t v6 = v18;
      if (v42 == (void **)&v40)
      {
        v40[4]((void **)&v40);
      }
      else if (v42)
      {
        (*((void (**)(void **))*v42 + 5))(v42);
      }
      sub_1CD47384C((char *)&v26);
    }
LABEL_26:
    if (v23)
    {
      uint64_t v24 = v23;
      operator delete(v23);
    }
    if (v21 != v20) {
      free(v21);
    }
    if (__p)
    {
      size_t v30 = (char *)__p;
      operator delete(__p);
    }
    if (v27 != v26) {
      free(v27);
    }
    if (v38)
    {
      uint64_t v39 = v38;
      operator delete(v38);
    }
    if (v37 != v36) {
      free(v37);
    }
    if (v34)
    {
      char v35 = v34;
      operator delete(v34);
    }
    if (v33 != v32) {
      free(v33);
    }
    ++v2;
  }
  while (v2 != v3);
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::print@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  a3[2] = a2;
  a3[3] = a3;
  *a3 = &unk_1F260DD18;
  a3[1] = result;
  return result;
}

void llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getCyclePreheader()
{
}

{
  while (1)
    ;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::getCyclePredecessor(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 16) == 1)
  {
    uint64_t v1 = **(void **)(a1 + 8);
    uint64_t v2 = *(uint64_t **)(v1 + 64);
    uint64_t v3 = *(uint64_t **)(v1 + 72);
    if (v2 != v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = *(void **)(a1 + 56);
      uint64_t v6 = *(void **)(a1 + 64);
      while (1)
      {
        uint64_t result = *v2;
        uint64_t v8 = v5;
        if (v5 != v6)
        {
          while (*v8 != result)
          {
            if (++v8 == v6)
            {
              uint64_t v8 = v6;
              break;
            }
          }
        }
        if (v8 == v6)
        {
          if (v4 && v4 != result) {
            return 0;
          }
        }
        else
        {
          uint64_t result = v4;
        }
        ++v2;
        uint64_t v4 = result;
        if (v2 == v3) {
          return result;
        }
      }
    }
  }
  return 0;
}

uint64_t llvm::GenericCycle<llvm::GenericSSAContext<llvm::MachineFunction>>::printEntries@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  a3[2] = a2;
  a3[3] = a3;
  *a3 = &unk_1F260DCD0;
  a3[1] = result;
  return result;
}

llvm::MachineCycleInfoWrapperPass *llvm::MachineCycleInfoWrapperPass::MachineCycleInfoWrapperPass(llvm::MachineCycleInfoWrapperPass *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::MachineCycleInfoWrapperPass::ID);
  *(void *)uint64_t v2 = &unk_1F260DB50;
  *(void *)(v2 + 248) = 0;
  *(void *)(v2 + 256) = 0;
  *(void *)(v2 + 272) = 0;
  *(void *)(v2 + 280) = 0;
  *(_DWORD *)(v2 + 288) = 0;
  *(void *)(v2 + 296) = 0;
  *(void *)(v2 + 304) = 0;
  *(_DWORD *)(v2 + 312) = 0;
  *(void *)(v2 + 328) = 0;
  *(void *)(v2 + 336) = 0;
  *(void *)(v2 + 320) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7C0, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC33A3C4;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCE7C0, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeMachineCycleInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7C0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC33A3C4;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCE7C0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::MachineCycleInfoWrapperPass::getAnalysisUsage(uint64_t this, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

void llvm::MachineCycleInfoWrapperPass::print(llvm::Value ***this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t v4 = sub_1CB8E509C(a2, "MachineCycleInfo for function: ");
  uint64_t Name = llvm::MachineFunction::getName(this[31]);
  size_t v7 = v5;
  uint64_t v8 = (void *)*((void *)v4 + 4);
  if (v5 <= *((void *)v4 + 3) - (void)v8)
  {
    if (v5)
    {
      memcpy(v8, Name, v5);
      *((void *)v4 + 4) += v7;
    }
  }
  else
  {
    llvm::raw_ostream::write(v4, Name, v5);
  }
  sub_1CB8E509C(v4, "\n");

  llvm::GenericCycleInfo<llvm::GenericSSAContext<llvm::MachineFunction>>::print();
}

void MachineCycleInfoPrinterPass::MachineCycleInfoPrinterPass(MachineCycleInfoPrinterPass *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&MachineCycleInfoPrinterPass::ID);
  *(void *)uint64_t v1 = &unk_1F260DC10;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v1);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7C8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC33A508;
    v4[1] = &PassRegistry;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCE7C8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeMachineCycleInfoPrinterPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7C8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC33A508;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCE7C8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void MachineCycleInfoPrinterPass::getAnalysisUsage(MachineCycleInfoPrinterPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineCycleInfoWrapperPass::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

uint64_t MachineCycleInfoPrinterPass::runOnMachineFunction(MachineCycleInfoPrinterPass *this, llvm::MachineFunction *a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  if (v3 == v4)
  {
LABEL_4:
    uint64_t v5 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v3 != &llvm::MachineCycleInfoWrapperPass::ID)
    {
      v3 += 16;
      if (v3 == v4) {
        goto LABEL_4;
      }
    }
    uint64_t v5 = *(void *)(v3 + 8);
  }
  uint64_t v6 = (llvm *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v5 + 96))(v5, &llvm::MachineCycleInfoWrapperPass::ID);
  size_t v7 = llvm::errs(v6);
  (*(void (**)(llvm *, void *, void))(*(void *)v6 + 40))(v6, v7, 0);
  return 0;
}

void sub_1CD52BA8C(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260DB50;
  sub_1CC33A844((uint64_t)a1 + 256);

  sub_1CBA0E6AC(a1);
}

void sub_1CD52BAE4(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260DB50;
  sub_1CC33A844((uint64_t)a1 + 256);
  sub_1CBA0E6AC(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD52BB54(llvm::Pass *a1)
{
  sub_1CBA0E6AC(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::MachineCycleInfoWrapperPass>()
{
}

void llvm::callDefaultCtor<MachineCycleInfoPrinterPass>()
{
}

void sub_1CD52BC08()
{
}

__n128 sub_1CD52BC1C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F260DCD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD52BC68(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F260DCD0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *sub_1CD52BC98(uint64_t a1, llvm::raw_ostream *a2)
{
  return sub_1CD52BCA0((void *)(a1 + 8), a2);
}

void *sub_1CD52BCA0(void *result, llvm::raw_ostream *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned int *)(*result + 16);
  if (v2)
  {
    uint64_t v4 = *(uint64_t **)(*result + 8);
    uint64_t v5 = 8 * v2;
    char v6 = 1;
    do
    {
      uint64_t v7 = *v4;
      if ((v6 & 1) == 0)
      {
        uint64_t v8 = (unsigned char *)*((void *)this + 4);
        if ((unint64_t)v8 >= *((void *)this + 3))
        {
          llvm::raw_ostream::write(this, 32);
        }
        else
        {
          *((void *)this + 4) = v8 + 1;
          unsigned char *v8 = 32;
        }
      }
      llvm::GenericSSAContext<llvm::MachineFunction>::print(v7, v9);
      if (!v10) {
        sub_1CB920400();
      }
      (*(void (**)(void *, llvm::raw_ostream *))(*v10 + 48))(v10, this);
      __n128 result = v10;
      if (v10 == v9)
      {
        __n128 result = (void *)(*(uint64_t (**)(void *))(v9[0] + 32))(v9);
      }
      else if (v10)
      {
        __n128 result = (void *)(*(uint64_t (**)(void))(*v10 + 40))();
      }
      char v6 = 0;
      ++v4;
      v5 -= 8;
    }
    while (v5);
  }
  return result;
}

void sub_1CD52BE20()
{
}

__n128 sub_1CD52BE34(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F260DD18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_1CD52BE80(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F260DD18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void **sub_1CD52BEB0(uint64_t a1, llvm::raw_ostream *a2)
{
  return sub_1CD52BEB8((uint64_t *)(a1 + 8), a2);
}

void **sub_1CD52BEB8(uint64_t *a1, llvm::raw_ostream *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  uint64_t v5 = sub_1CB8E509C(a2, "depth=");
  char v6 = llvm::raw_ostream::operator<<(v5, *(unsigned int *)(v4 + 80));
  uint64_t v7 = sub_1CB8E509C(v6, ": entries(");
  v19[1] = a1[1];
  unsigned int v20 = (void **)&v18;
  BOOL v18 = (uint64_t (**)(void **))&unk_1F260DCD0;
  v19[0] = v4;
  sub_1CD52BCA0(v19, v7);
  uint64_t v8 = (unsigned char *)*((void *)v7 + 4);
  if ((unint64_t)v8 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 41);
  }
  else
  {
    *((void *)v7 + 4) = v8 + 1;
    unsigned char *v8 = 41;
  }
  __n128 result = v20;
  if (v20 == (void **)&v18)
  {
    __n128 result = (void **)v18[4]((void **)&v18);
  }
  else if (v20)
  {
    __n128 result = (void **)(*((uint64_t (**)(void))*v20 + 5))();
  }
  uint64_t v10 = *(uint64_t **)(v4 + 56);
  for (uint64_t i = *(uint64_t **)(v4 + 64); v10 != i; ++v10)
  {
    uint64_t v12 = *v10;
    uint64_t v13 = *(void *)(v4 + 8);
    uint64_t v14 = *(unsigned int *)(v4 + 16);
    if (v14)
    {
      uint64_t v15 = 8 * v14;
      BOOL v16 = *(void **)(v4 + 8);
      while (*v16 != v12)
      {
        ++v16;
        v15 -= 8;
        if (!v15)
        {
          BOOL v16 = (void *)(v13 + 8 * v14);
          break;
        }
      }
    }
    else
    {
      BOOL v16 = *(void **)(v4 + 8);
    }
    if (v14 == ((uint64_t)v16 - v13) >> 3)
    {
      int v17 = (unsigned char *)*((void *)a2 + 4);
      if ((unint64_t)v17 >= *((void *)a2 + 3))
      {
        llvm::raw_ostream::write(a2, 32);
      }
      else
      {
        *((void *)a2 + 4) = v17 + 1;
        unsigned char *v17 = 32;
      }
      llvm::GenericSSAContext<llvm::MachineFunction>::print(v12, &v18);
      if (!v20) {
        sub_1CB920400();
      }
      (*((void (**)(void **, llvm::raw_ostream *))*v20 + 6))(v20, a2);
      __n128 result = v20;
      if (v20 == (void **)&v18)
      {
        __n128 result = (void **)v18[4]((void **)&v18);
      }
      else if (v20)
      {
        __n128 result = (void **)(*((uint64_t (**)(void))*v20 + 5))();
      }
    }
  }
  return result;
}

void llvm::initializeDebugifyMachineModulePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7D0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC33B1EC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCE7D0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createDebugifyMachineModulePass(llvm *this)
{
}

_DWORD *sub_1CD52C224(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    char v6 = sub_1CD48BE5C(a1, a2, v9);
    _DWORD *v6 = *a2;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  char v6 = (_DWORD *)(*(void *)a1 + 16 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      char v6 = (_DWORD *)(*(void *)a1 + 16 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

void llvm::ForwardDominanceFrontierBase<llvm::MachineBasicBlock>::analyze(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)*a2;
  *(_DWORD *)(a1 + 32) = 0;
  if (!*(_DWORD *)(a1 + 36)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  **(void **)(a1 + 24) = v2;
  ++*(_DWORD *)(a1 + 32);
  uint64_t v3 = **(void **)(a1 + 24);
  uint64_t v4 = 0;
  uint64_t v5 = v3;
  sub_1CBFA3AF4(a2 + 3, &v5, &v4);
  llvm::ForwardDominanceFrontierBase<llvm::MachineBasicBlock>::calculate();
}

uint64_t **llvm::ForwardDominanceFrontierBase<llvm::MachineBasicBlock>::calculate(uint64_t **a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v4 = *a3;
  int v45 = 0;
  unint64_t v46 = 0;
  unint64_t v47 = 0;
  uint64_t v40 = v44;
  uint64_t v41 = v44;
  uint64_t v42 = 32;
  int v43 = 0;
  long long v38 = v4;
  long long v39 = (unint64_t)a3;
  uint64_t v5 = sub_1CBFF08A8((void **)&v45, &v38);
  unint64_t v46 = v5;
  do
  {
    uint64_t v37 = 0;
    uint64_t v6 = *((void *)v5 - 4);
    unint64_t v36 = 0;
    uint64_t v37 = v6;
    unint64_t v36 = *((void *)v5 - 3);
    uint64_t v7 = *((void *)v5 - 2);
    uint64_t v8 = *((void *)v5 - 1);
    *(void *)&long long v38 = &v37;
    std::string v32 = sub_1CD52CA74(a1, (unint64_t *)&v37, (uint64_t)&std::piecewise_construct, (uint64_t ***)&v38);
    uint64_t v9 = v32 + 5;
    sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v40, v37);
    if (v10)
    {
      int v11 = *(uint64_t ***)(v37 + 88);
      BOOL v12 = *(uint64_t ***)(v37 + 96);
      while (v11 != v12)
      {
        char v35 = 0;
        char v35 = *v11;
        *(void *)&long long v38 = v35;
        v48[0] = 0;
        int v13 = sub_1CBFA3AF4((uint64_t *)(a2 + 24), &v38, v48);
        uint64_t v14 = v48[0];
        if (!v13) {
          uint64_t v14 = *(void *)(a2 + 24) + 16 * *(unsigned int *)(a2 + 40);
        }
        if (*(void *)(*(void *)(v14 + 8) + 8) != v7) {
          sub_1CD3CFB98(v9, (unint64_t *)&v35, &v35);
        }
        ++v11;
      }
    }
    uint64_t v15 = *(unsigned int *)(v7 + 32);
    if (!v15) {
      goto LABEL_24;
    }
    char v33 = 0;
    BOOL v16 = *(uint64_t ***)(v7 + 24);
    int v17 = &v16[v15];
    do
    {
      while (1)
      {
        BOOL v18 = *v16;
        uint64_t v19 = **v16;
        unsigned int v20 = (char *)sub_1CB896AE8((uint64_t)&v40, v19);
        uint64_t v21 = v41 == v40 ? (uint64_t *)((char *)&v42 + 4) : &v42;
        if (v20 != &v41[8 * *(unsigned int *)v21]) {
          break;
        }
        *(void *)&long long v38 = v19;
        *((void *)&v38 + 1) = v37;
        *(void *)&long long v39 = v18;
        *((void *)&v39 + 1) = v7;
        if ((unint64_t)v5 >= v47)
        {
          uint64_t v5 = sub_1CBFF08A8((void **)&v45, &v38);
        }
        else
        {
          long long v22 = v39;
          _OWORD *v5 = v38;
          v5[1] = v22;
          v5 += 2;
        }
        unint64_t v46 = v5;
        ++v16;
        char v33 = 1;
        if (v16 == v17) {
          goto LABEL_46;
        }
      }
      ++v16;
    }
    while (v16 != v17);
    uint64_t v9 = v32 + 5;
    if ((v33 & 1) == 0)
    {
LABEL_24:
      if (!v36) {
        goto LABEL_48;
      }
      int v23 = (uint64_t **)v32[5];
      *(void *)&long long v38 = &v36;
      uint64_t v24 = sub_1CD52CA74(a1, &v36, (uint64_t)&std::piecewise_construct, (uint64_t ***)&v38);
      if (v23 != v32 + 6)
      {
        uint64_t v25 = v24 + 5;
        do
        {
          *(void *)&long long v38 = v23[4];
          v48[0] = 0;
          if (sub_1CBFA3AF4((uint64_t *)(a2 + 24), &v38, v48)
            && v48[0] != *(void *)(a2 + 24) + 16 * *(unsigned int *)(a2 + 40))
          {
            uint64_t v26 = *(void *)(v48[0] + 8);
            BOOL v27 = v8 == v26 || v8 == 0;
            if (!v27 && v26 != 0) {
              llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
            }
          }
          sub_1CD3CFB98(v25, (unint64_t *)v23 + 4, v23 + 4);
          uint64_t v29 = v23[1];
          if (v29)
          {
            do
            {
              size_t v30 = (uint64_t **)v29;
              uint64_t v29 = (uint64_t *)*v29;
            }
            while (v29);
          }
          else
          {
            do
            {
              size_t v30 = (uint64_t **)v23[2];
              BOOL v27 = *v30 == (uint64_t *)v23;
              int v23 = v30;
            }
            while (!v27);
          }
          int v23 = v30;
        }
        while (v30 != v32 + 6);
        uint64_t v5 = v46;
      }
      v5 -= 2;
      unint64_t v46 = v5;
    }
LABEL_46:
    ;
  }
  while (v45 != v5);
  uint64_t v9 = 0;
LABEL_48:
  if (v41 != v40) {
    free(v41);
  }
  if (v45) {
    operator delete(v45);
  }
  return v9;
}

void llvm::initializeMachineDominanceFrontierPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7D8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC33D3D4;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCE7D8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::MachineDominanceFrontier *llvm::MachineDominanceFrontier::MachineDominanceFrontier(llvm::MachineDominanceFrontier *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::MachineDominanceFrontier::ID);
  *(void *)uint64_t v2 = &unk_1F260DE48;
  *((void *)v2 + 31) = (char *)v2 + 256;
  *((void *)v2 + 32) = 0;
  *((void *)v2 + 33) = 0;
  *((void *)v2 + 34) = (char *)v2 + 288;
  *((void *)v2 + 35) = 0x100000000;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE7D8, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC33D3D4;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCE7D8, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::MachineDominanceFrontier::runOnMachineFunction(uint64_t **this, llvm::MachineFunction *a2)
{
  ((void (*)(uint64_t **, llvm::MachineFunction *))(*this)[11])(this, a2);
  uint64_t v3 = this[1];
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (v4 == v5)
  {
LABEL_2:
    uint64_t v6 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v4 != &llvm::MachineDominatorTree::ID)
    {
      v4 += 16;
      if (v4 == v5) {
        goto LABEL_2;
      }
    }
    uint64_t v6 = *(void *)(v4 + 8);
  }
  uint64_t v7 = (llvm::MachineDominatorTree *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 96))(v6, &llvm::MachineDominatorTree::ID);
  sub_1CC2DC358(v7);
  llvm::ForwardDominanceFrontierBase<llvm::MachineBasicBlock>::analyze();
}

void llvm::MachineDominanceFrontier::releaseMemory(llvm::MachineDominanceFrontier *this)
{
  *((void *)this + 32) = 0;
  *((void *)this + 33) = 0;
  *((void *)this + 31) = (char *)this + 256;
}

void llvm::MachineDominanceFrontier::getAnalysisUsage(llvm::MachineDominanceFrontier *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

void sub_1CD52C990(uint64_t a1)
{
  sub_1CD52CA04(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::MachineDominanceFrontier>()
{
}

void sub_1CD52CA04(uint64_t a1)
{
  *(void *)a1 = &unk_1F260DE48;
  uint64_t v2 = *(void **)(a1 + 272);
  if (v2 != (void *)(a1 + 288)) {
    free(v2);
  }
  sub_1CD486DF0(a1 + 248, *(void **)(a1 + 256));

  sub_1CBA0E6AC((llvm::Pass *)a1);
}

uint64_t **sub_1CD52CA74(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t ***a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    int v11 = (uint64_t *)v9;
    uint64_t v9 = (uint64_t **)operator new(0x40uLL);
    BOOL v12 = **a4;
    v9[7] = 0;
    v9[6] = 0;
    uint64_t v9[4] = v12;
    v9[5] = (uint64_t *)(v9 + 6);
    _DWORD *v9 = 0;
    v9[1] = 0;
    void v9[2] = v11;
    llvm::MachineDominatorTree *v7 = (uint64_t *)v9;
    int v13 = (uint64_t *)**a1;
    uint64_t v14 = (uint64_t *)v9;
    if (v13)
    {
      *a1 = v13;
      uint64_t v14 = *v7;
    }
    sub_1CB8358B8(a1[1], v14);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v9;
}

uint64_t llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::setIDom(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (v2 != a2)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void **)(v2 + 24);
    uint64_t v6 = *(unsigned int *)(v2 + 32);
    uint64_t v7 = &v5[v6];
    if (v6)
    {
      uint64_t v9 = 8 * v6;
      do
      {
        if (*v5 == v4) {
          goto LABEL_3;
        }
        ++v5;
        v9 -= 8;
      }
      while (v9);
      uint64_t v5 = v7;
    }
LABEL_3:
    if (v7 != v5 + 1)
    {
      memmove(v5, v5 + 1, (char *)v7 - (char *)(v5 + 1));
      LODWORD(v6) = *(_DWORD *)(v2 + 32);
    }
    *(_DWORD *)(v2 + 32) = v6 - 1;
    *(void *)(v4 + 8) = a2;
    unsigned int v8 = *(_DWORD *)(a2 + 32);
    if (v8 < *(_DWORD *)(a2 + 36))
    {
      *(void *)(*(void *)(a2 + 24) + 8 * v8) = v4;
      ++*(_DWORD *)(a2 + 32);
      llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::UpdateLevel();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return result;
}

void llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::UpdateLevel(uint64_t a1)
{
  v8[64] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(*(void *)(a1 + 8) + 16) + 1)
  {
    unsigned int v7 = 64;
    v8[0] = a1;
    unsigned int v1 = 1;
    do
    {
      uint64_t v2 = v8[--v1];
      unsigned int v6 = v1;
      *(_DWORD *)(v2 + 16) = *(_DWORD *)(*(void *)(v2 + 8) + 16) + 1;
      uint64_t v3 = *(unsigned int *)(v2 + 32);
      if (v3)
      {
        uint64_t v4 = *(void *)(v2 + 24);
        uint64_t v5 = 8 * v3;
        do
        {
          if (*(_DWORD *)(*(void *)v4 + 16) != *(_DWORD *)(*(void *)(*(void *)v4 + 8) + 16) + 1)
          {
            if (v1 >= v7) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            v8[v1] = *(void *)v4;
            unsigned int v1 = ++v6;
          }
          v4 += 8;
          v5 -= 8;
        }
        while (v5);
      }
    }
    while (v1);
  }
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::compare(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 56) != *(void *)(a2 + 56)) {
    return 1;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 != *(_DWORD *)(a2 + 8)) {
    return 1;
  }
  if (!sub_1CC33FBEC(*(char **)a1, (char *)(*(void *)a1 + 8 * v5), *(void **)a2)) {
    return 1;
  }
  int v6 = *(_DWORD *)(a1 + 32);
  if (v6 != *(_DWORD *)(a2 + 32)) {
    return 1;
  }
  uint64_t v7 = *(void *)(a1 + 24);
  uint64_t v8 = *(unsigned int *)(a1 + 40);
  if (v6)
  {
    if (v8)
    {
      uint64_t v9 = 16 * v8;
      unint64_t v10 = *(uint64_t **)(a1 + 24);
      while ((*v10 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v10 += 2;
        v9 -= 16;
        if (!v9) {
          goto LABEL_12;
        }
      }
    }
    else
    {
      unint64_t v10 = *(uint64_t **)(a1 + 24);
    }
  }
  else
  {
LABEL_12:
    unint64_t v10 = (uint64_t *)(v7 + 16 * v8);
  }
  if (v10 == (uint64_t *)(v7 + 16 * v8)) {
    return 0;
  }
  uint64_t v11 = *v10;
  uint64_t v13 = 0;
  uint64_t v14 = v11;
  int v12 = sub_1CBFA3AF4((uint64_t *)(a2 + 24), &v14, &v13);
  uint64_t result = 1;
  if (v12)
  {
    if (v13 != *(void *)(a2 + 24) + 16 * *(unsigned int *)(a2 + 40)) {
      llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::compare();
    }
  }
  return result;
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::getDescendants(uint64_t a1, void *a2, uint64_t a3)
{
  v16[8] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t v12 = 0;
  uint64_t v13 = a2;
  if (sub_1CBFA3AF4((uint64_t *)(a1 + 24), &v13, &v12))
  {
    uint64_t v5 = v12;
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = *(unsigned int *)(a1 + 40);
    uint64_t v5 = v6 + 16 * v7;
  }
  if (v5 != v6 + 16 * v7)
  {
    uint64_t v8 = *(void *)(v5 + 8);
    if (v8)
    {
      uint64_t v13 = v16;
      int v15 = 8;
      v16[0] = v8;
      unsigned int v9 = 1;
      do
      {
        uint64_t v10 = *((void *)v13 + v9 - 1);
        unsigned int v14 = v9 - 1;
        unint64_t v11 = *(unsigned int *)(a3 + 8);
        if (v11 >= *(unsigned int *)(a3 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)a3 + 8 * v11) = *(void *)v10;
        ++*(_DWORD *)(a3 + 8);
        sub_1CD4570C8((uint64_t)&v13, *(char **)(v10 + 24), (char *)(*(void *)(v10 + 24) + 8 * *(unsigned int *)(v10 + 32)));
        unsigned int v9 = v14;
      }
      while (v14);
      if (v13 != v16) {
        free(v13);
      }
    }
  }
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::addNewBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = 0;
  uint64_t v5 = a3;
  sub_1CBFA3AF4((uint64_t *)(a1 + 24), &v5, &v4);
  *(unsigned char *)(a1 + 64) = 0;
  llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::createChild();
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::eraseNode(int32x2_t *a1, uint64_t a2)
{
  uint64_t v14 = a2;
  uint64_t v15 = 0;
  uint64_t v3 = a1 + 3;
  uint64_t v16 = a2;
  if (sub_1CBFA3AF4((uint64_t *)&a1[3], &v16, &v15))
  {
    uint64_t v4 = v15;
    int32x2_t v5 = a1[3];
    uint64_t v6 = a1[5].u32[0];
  }
  else
  {
    int32x2_t v5 = a1[3];
    uint64_t v6 = a1[5].u32[0];
    uint64_t v4 = *(void *)&v5 + 16 * v6;
  }
  if (v4 == *(void *)&v5 + 16 * v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *(void *)(v4 + 8);
  }
  a1[8].i8[0] = 0;
  uint64_t v8 = *(void *)(v7 + 8);
  if (v8)
  {
    unsigned int v9 = *(void **)(v8 + 24);
    uint64_t v10 = *(unsigned int *)(v8 + 32);
    unint64_t v11 = &v9[v10];
    if (v10)
    {
      uint64_t v12 = 8 * v10;
      while (*v9 != v7)
      {
        ++v9;
        v12 -= 8;
        if (!v12)
        {
          unsigned int v9 = v11;
          break;
        }
      }
    }
    if (v11 != v9 + 1)
    {
      memmove(v9, v9 + 1, (char *)v11 - (char *)(v9 + 1));
      LODWORD(v10) = *(_DWORD *)(v8 + 32);
    }
    *(_DWORD *)(v8 + 32) = v10 - 1;
  }
  return sub_1CB931314(v3, &v14);
}

llvm::raw_ostream *llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  sub_1CB8E509C(a2, "=============================--------------------------------\n");
  sub_1CB8E509C(a2, "Inorder Dominator Tree: ");
  if (!*(unsigned char *)(a1 + 64))
  {
    uint64_t v4 = sub_1CB8E509C(a2, "DFSNumbers invalid: ");
    int32x2_t v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)(a1 + 68));
    sub_1CB8E509C(v5, " slow queries.");
  }
  sub_1CB8E509C(a2, "\n");
  uint64_t v6 = *(void *)(a1 + 48);
  if (v6) {
    sub_1CD52D3B4(v6, a2, 1u);
  }
  sub_1CB8E509C(a2, "Roots: ");
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = *(llvm::MachineBasicBlock ***)a1;
    uint64_t v9 = 8 * v7;
    do
    {
      uint64_t v10 = *v8++;
      llvm::MachineBasicBlock::printAsOperand(v10, a2);
      sub_1CB8E509C(a2, " ");
      v9 -= 8;
    }
    while (v9);
  }

  return sub_1CB8E509C(a2, "\n");
}

llvm::raw_ostream *sub_1CD52D3B4(uint64_t a1, llvm::raw_ostream *a2, unsigned int a3)
{
  uint64_t v6 = llvm::raw_ostream::indent(a2, 2 * a3);
  uint64_t v7 = sub_1CB8E509C(v6, "[");
  uint64_t v8 = llvm::raw_ostream::operator<<(v7, a3);
  uint64_t v9 = sub_1CB8E509C(v8, "] ");
  uint64_t result = sub_1CD52DA90(v9, a1);
  uint64_t v11 = *(unsigned int *)(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(uint64_t **)(a1 + 24);
    uint64_t v13 = a3 + 1;
    uint64_t v14 = 8 * v11;
    do
    {
      uint64_t v15 = *v12++;
      uint64_t result = (llvm::raw_ostream *)sub_1CD52D3B4(v15, a2, v13);
      v14 -= 8;
    }
    while (v14);
  }
  return result;
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::verify(uint64_t a1)
{
  uint64_t v2 = operator new(8uLL);
  uint64_t v3 = v2;
  *uint64_t v2 = 0;
  uint64_t v4 = v2 + 1;
  int32x2_t v5 = v2 + 1;
  uint64_t v9 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  sub_1CC3461B4(a1);
}

void llvm::MachineDominatorTree::getAnalysisUsage(uint64_t this, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

llvm::MachineDominatorTree *llvm::MachineDominatorTree::MachineDominatorTree(llvm::MachineDominatorTree *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::MachineDominatorTree::ID);
  *(void *)uint64_t v2 = &unk_1F260DF08;
  *(void *)(v2 + 248) = v2 + 264;
  *(void *)(v2 + 256) = 0x2000000000;
  *(void *)(v2 + 1032) = v2 + 1064;
  *(void *)(v2 + 1040) = v2 + 1064;
  *(void *)(v2 + 1048) = 32;
  *(_DWORD *)(v2 + 1056) = 0;
  *(void *)(v2 + 1320) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE8A0, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC33F5E8;
    v6[1] = &PassRegistry;
    int32x2_t v5 = v6;
    std::__call_once(&qword_1EBCCE8A0, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

uint64_t llvm::MachineDominatorTree::verifyAnalysis(llvm::MachineDominatorTree *this)
{
  uint64_t result = *((void *)this + 165);
  if (result) {
    BOOL v2 = llvm::VerifyMachineDomInfo == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2) {
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::verify(result);
  }
  return result;
}

uint64_t llvm::MachineDominatorTree::print(llvm::MachineDominatorTree *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
  uint64_t result = *((void *)this + 165);
  if (result) {
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::print();
  }
  return result;
}

void sub_1CD52D684(llvm::Pass *a1)
{
  sub_1CD52D6F8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::MachineDominatorTree>()
{
}

void sub_1CD52D6F8(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260DF08;
  uint64_t v1 = *((void *)a1 + 165);
  *((void *)a1 + 165) = 0;
  if (v1)
  {
    uint64_t v4 = a1;
    sub_1CBF8FF20((uint64_t)a1 + 1320, v1);
    a1 = v4;
  }
  BOOL v2 = (void *)*((void *)a1 + 130);
  if (v2 != *((void **)a1 + 129))
  {
    int32x2_t v5 = a1;
    free(v2);
    a1 = v5;
  }
  uint64_t v3 = (void *)*((void *)a1 + 31);
  if (v3 != (void *)((char *)a1 + 264))
  {
    uint64_t v6 = a1;
    free(v3);
    a1 = v6;
  }

  sub_1CBA0E6AC(a1);
}

void sub_1CD52D7AC(unsigned char **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCE7E0, 0, 0);
  byte_1EBCCE871 = 0;
  qword_1EBCCE860 = 0;
  unk_1EBCCE868 = &unk_1F25EDE58;
  qword_1EBCCE7E0 = (uint64_t)&unk_1F2605290;
  qword_1EBCCE878 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCCE880 = (uint64_t)&unk_1F26052F8;
  qword_1EBCCE898 = (uint64_t)&qword_1EBCCE880;
  sub_1CD52D89C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCE7E0);
}

__n128 sub_1CD52D89C(unsigned char **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCE7E0, "verify-machine-dom-info", 0x17uLL);
  sub_1CC08D588((llvm *)&qword_1EBCCE860, &qword_1EBCCE7E0, *a1);
  word_1EBCCE7EA = (32 * (*a2 & 3)) | word_1EBCCE7EA & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCCE800 = (__int128)*a3;
  return result;
}

void sub_1CD52D918(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 72 * v3;
    uint64_t v5 = *(void *)a1 + 56;
    while (1)
    {
      uint64_t v6 = *(void *)(v5 - 56);
      if (v6 == -8192) {
        goto LABEL_10;
      }
      if (v6 != -4096) {
        break;
      }
LABEL_11:
      v5 += 72;
      v4 -= 72;
      if (!v4) {
        goto LABEL_12;
      }
    }
    uint64_t v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7) {
      free(v7);
    }
LABEL_10:
    *(void *)(v5 - 56) = -4096;
    goto LABEL_11;
  }

  sub_1CD52D9DC(a1);
}

void sub_1CD52D9DC(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC34587C((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint64_t v5 = *(void **)a1;
      uint64_t v6 = 72 * v4;
      do
      {
        void *v5 = -4096;
        v5 += 9;
        v6 -= 72;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC13D214(a1, v4);
  }
}

llvm::raw_ostream *sub_1CD52DA90(llvm::raw_ostream *a1, uint64_t a2)
{
  if (*(void *)a2) {
    llvm::MachineBasicBlock::printAsOperand(*(llvm::MachineBasicBlock **)a2, a1);
  }
  else {
    sub_1CB8E509C(a1, " <<exit node>>");
  }
  uint64_t v4 = sub_1CB8E509C(a1, " {");
  uint64_t v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)(a2 + 72));
  uint64_t v6 = sub_1CB8E509C(v5, ",");
  uint64_t v7 = llvm::raw_ostream::operator<<(v6, *(unsigned int *)(a2 + 76));
  int v8 = sub_1CB8E509C(v7, "} [");
  uint64_t v9 = llvm::raw_ostream::operator<<(v8, *(unsigned int *)(a2 + 16));
  sub_1CB8E509C(v9, "]\n");
  return a1;
}

BOOL sub_1CD52DB2C(uint64_t a1)
{
  v38[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 56);
  int v2 = *(_DWORD *)(a1 + 8);
  if (v1) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = v2 == 0;
  }
  if (!v3)
  {
    uint64_t v7 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
    int v8 = "Tree has no parent but has roots!\n";
LABEL_9:
    uint64_t v9 = sub_1CB8E509C(v7, v8);
    uint64_t v10 = (llvm::raw_ostream *)llvm::errs(v9);
    uint64_t v11 = (const char *)*((void *)v10 + 2);
    if (*((const char **)v10 + 4) != v11)
    {
      *((void *)v10 + 4) = v11;
      llvm::raw_ostream::flush_tied_then_write(v10, v11);
    }
    return 0;
  }
  if (!v2)
  {
    uint64_t v7 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
    int v8 = "Tree doesn't have a root!\n";
    goto LABEL_9;
  }
  uint64_t v5 = *(llvm **)a1;
  uint64_t v6 = *(void *)v5;
  if (*(void *)v5 != *(void *)(v1 + 328))
  {
    uint64_t v7 = (llvm::raw_ostream *)llvm::errs(v5);
    int v8 = "Tree's root is not its parent's entry node!\n";
    goto LABEL_9;
  }
  unint64_t v36 = v38;
  v38[0] = v6;
  uint64_t v37 = 0x100000001;
  BOOL v14 = sub_1CD52E948((uint64_t *)v5, v2, (uint64_t)&v36);
  BOOL v12 = v14;
  if (!v14)
  {
    uint64_t v15 = (llvm::raw_ostream *)llvm::errs((llvm *)v14);
    uint64_t v16 = sub_1CB8E509C(v15, "Tree has different roots than freshly computed ones!\n");
    int v17 = (llvm::raw_ostream *)llvm::errs(v16);
    BOOL v18 = sub_1CB8E509C(v17, "\tPDT roots: ");
    uint64_t v19 = *(unsigned int *)(a1 + 8);
    if (v19)
    {
      unsigned int v20 = *(llvm::MachineBasicBlock ***)a1;
      uint64_t v21 = 8 * v19;
      do
      {
        long long v22 = *v20;
        int v23 = (llvm::raw_ostream *)llvm::errs(v18);
        uint64_t v24 = v23;
        if (v22) {
          llvm::MachineBasicBlock::printAsOperand(v22, v23);
        }
        else {
          sub_1CB8E509C(v23, "nullptr");
        }
        BOOL v18 = sub_1CB8E509C(v24, ", ");
        ++v20;
        v21 -= 8;
      }
      while (v21);
    }
    uint64_t v25 = (llvm::raw_ostream *)llvm::errs(v18);
    uint64_t v26 = sub_1CB8E509C(v25, "\n\tComputed roots: ");
    if (v37)
    {
      BOOL v27 = (llvm::MachineBasicBlock **)v36;
      uint64_t v28 = 8 * v37;
      do
      {
        uint64_t v29 = *v27;
        size_t v30 = (llvm::raw_ostream *)llvm::errs(v26);
        uint64_t v31 = v30;
        if (v29) {
          llvm::MachineBasicBlock::printAsOperand(v29, v30);
        }
        else {
          sub_1CB8E509C(v30, "nullptr");
        }
        uint64_t v26 = sub_1CB8E509C(v31, ", ");
        ++v27;
        v28 -= 8;
      }
      while (v28);
    }
    std::string v32 = (llvm::raw_ostream *)llvm::errs(v26);
    char v33 = sub_1CB8E509C(v32, "\n");
    int v34 = (llvm::raw_ostream *)llvm::errs(v33);
    char v35 = (const char *)*((void *)v34 + 2);
    if (*((const char **)v34 + 4) != v35)
    {
      *((void *)v34 + 4) = v35;
      llvm::raw_ostream::flush_tied_then_write(v34, v35);
    }
  }
  if (v36 != v38) {
    free(v36);
  }
  return v12;
}

uint64_t sub_1CD52DD8C(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  unint64_t __src = 0;
  sub_1CBFAFDE4((void *)a1, (char *)&__src, (char *)&v28, 1uLL);
  sub_1CD52D918((_DWORD *)(a1 + 24));
  sub_1CC2DD1E8(a1, **(void **)a2, 0, (unsigned int (*)(uint64_t, uint64_t))sub_1CC2DC6BC, 0, 0);
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(unsigned int *)(a2 + 40);
  uint64_t v6 = (void *)(v4 + 16 * v5);
  if (*(_DWORD *)(a2 + 32))
  {
    if (v5)
    {
      uint64_t v7 = 16 * v5;
      int v8 = *(void **)(a2 + 24);
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        v7 -= 16;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      int v8 = *(void **)(a2 + 24);
    }
  }
  else
  {
LABEL_6:
    int v8 = (void *)(v4 + 16 * v5);
  }
  uint64_t v9 = (void *)(v4 + 16 * v5);
LABEL_8:
  while (v8 != v9)
  {
    uint64_t v10 = *(llvm::MachineBasicBlock **)v8[1];
    uint64_t v11 = (llvm *)sub_1CC34574C(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), (uint64_t)v10, &__src);
    if (!v11)
    {
      BOOL v18 = (llvm::raw_ostream *)llvm::errs(v11);
      uint64_t v19 = sub_1CB8E509C(v18, "DomTree node ");
      unsigned int v20 = v19;
      if (v10) {
        llvm::MachineBasicBlock::printAsOperand(v10, v19);
      }
      else {
        sub_1CB8E509C(v19, "nullptr");
      }
      uint64_t v21 = " not found by DFS walk!\n";
      goto LABEL_26;
    }
    BOOL v12 = v8 + 2;
    int v8 = v6;
    if (v12 != v6)
    {
      while ((*v12 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v12 += 2;
        if (v12 == v6)
        {
          int v8 = v6;
          goto LABEL_8;
        }
      }
      int v8 = v12;
    }
  }
  uint64_t v13 = *(llvm::MachineBasicBlock ***)a1;
  BOOL v14 = *(llvm::MachineBasicBlock ***)(a1 + 8);
  while (1)
  {
    if (v13 == v14) {
      return 1;
    }
    uint64_t v15 = *v13;
    if (*v13)
    {
      uint64_t v26 = 0;
      unint64_t __src = v15;
      uint64_t v16 = (llvm *)sub_1CBFA3AF4((uint64_t *)(a2 + 24), &__src, &v26);
      if (!v16 || v26 == *(void *)(a2 + 24) + 16 * *(unsigned int *)(a2 + 40) || !*(void *)(v26 + 8)) {
        break;
      }
    }
    ++v13;
  }
  uint64_t v25 = (llvm::raw_ostream *)llvm::errs(v16);
  unsigned int v20 = sub_1CB8E509C(v25, "CFG node ");
  llvm::MachineBasicBlock::printAsOperand(v15, v20);
  uint64_t v21 = " not found in the DomTree!\n";
LABEL_26:
  long long v22 = sub_1CB8E509C(v20, v21);
  int v23 = (llvm::raw_ostream *)llvm::errs(v22);
  uint64_t v24 = (const char *)*((void *)v23 + 2);
  if (*((const char **)v23 + 4) != v24)
  {
    *((void *)v23 + 4) = v24;
    llvm::raw_ostream::flush_tied_then_write(v23, v24);
  }
  return 0;
}

uint64_t sub_1CD52DFF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(unsigned int *)(a1 + 40);
  BOOL v3 = (void *)(v1 + 16 * v2);
  if (*(_DWORD *)(a1 + 32))
  {
    if (v2)
    {
      uint64_t v4 = 16 * v2;
      uint64_t v5 = *(void **)(a1 + 24);
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v5 += 2;
        v4 -= 16;
        if (!v4) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v5 = *(void **)(a1 + 24);
    }
  }
  else
  {
LABEL_6:
    uint64_t v5 = (void *)(v1 + 16 * v2);
  }
  uint64_t v6 = (void *)(v1 + 16 * v2);
  while (1)
  {
LABEL_8:
    if (v5 == v6) {
      return 1;
    }
    uint64_t v7 = v5[1];
    int v8 = *(llvm::MachineBasicBlock **)v7;
    if (!*(void *)v7) {
      goto LABEL_12;
    }
    uint64_t v9 = *(void *)(v7 + 8);
    int v10 = *(_DWORD *)(v7 + 16);
    if (v9) {
      break;
    }
    if (v10)
    {
      BOOL v12 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
      uint64_t v13 = sub_1CB8E509C(v12, "Node without an IDom ");
      llvm::MachineBasicBlock::printAsOperand(v8, v13);
      BOOL v14 = sub_1CB8E509C(v13, " has a nonzero level ");
      unint64_t v15 = *(unsigned int *)(v7 + 16);
      goto LABEL_24;
    }
LABEL_12:
    uint64_t v11 = v5 + 2;
    uint64_t v5 = v3;
    if (v11 != v3)
    {
      uint64_t v5 = v11;
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v5 += 2;
        if (v5 == v3)
        {
          uint64_t v5 = v3;
          goto LABEL_8;
        }
      }
    }
  }
  if (v10 == *(_DWORD *)(v9 + 16) + 1) {
    goto LABEL_12;
  }
  int v17 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  BOOL v18 = sub_1CB8E509C(v17, "Node ");
  llvm::MachineBasicBlock::printAsOperand(v8, v18);
  uint64_t v19 = sub_1CB8E509C(v18, " has level ");
  unsigned int v20 = llvm::raw_ostream::operator<<(v19, *(unsigned int *)(v7 + 16));
  uint64_t v21 = sub_1CB8E509C(v20, " while its IDom ");
  if (*(void *)v9) {
    llvm::MachineBasicBlock::printAsOperand(*(llvm::MachineBasicBlock **)v9, v21);
  }
  else {
    sub_1CB8E509C(v21, "nullptr");
  }
  BOOL v14 = sub_1CB8E509C(v21, " has level ");
  unint64_t v15 = *(unsigned int *)(v9 + 16);
LABEL_24:
  long long v22 = llvm::raw_ostream::operator<<(v14, v15);
  int v23 = sub_1CB8E509C(v22, "!\n");
  uint64_t v24 = (llvm::raw_ostream *)llvm::errs(v23);
  uint64_t v25 = (const char *)*((void *)v24 + 2);
  if (*((const char **)v24 + 4) != v25)
  {
    *((void *)v24 + 4) = v25;
    llvm::raw_ostream::flush_tied_then_write(v24, v25);
  }
  return 0;
}

uint64_t sub_1CD52E1D4(uint64_t a1)
{
  v33[8] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 64)) {
    BOOL v1 = *(void *)(a1 + 56) == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 1;
  }
  uint64_t v31 = **(void ***)a1;
  v30[0] = 0;
  uint64_t result = sub_1CBFA3AF4((uint64_t *)(a1 + 24), &v31, v30);
  uint64_t v4 = (void *)v30[0];
  uint64_t v5 = *(void **)(a1 + 24);
  uint64_t v6 = *(unsigned int *)(a1 + 40);
  uint64_t v7 = &v5[2 * v6];
  if (!result) {
    uint64_t v4 = &v5[2 * v6];
  }
  int v8 = (unsigned int *)v4[1];
  if (!v8[18])
  {
    if (!*(_DWORD *)(a1 + 32)) {
      return 1;
    }
    if (v6)
    {
      uint64_t v9 = 16 * v6;
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v5 += 2;
        v9 -= 16;
        if (!v9) {
          return 1;
        }
      }
    }
    if (v5 == v7) {
      return 1;
    }
LABEL_17:
    uint64_t v10 = v5[1];
    uint64_t v11 = *(unsigned int *)(v10 + 32);
    if (!v11)
    {
      if (*(_DWORD *)(v10 + 72) + 1 == *(_DWORD *)(v10 + 76)) {
        goto LABEL_19;
      }
      uint64_t v29 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
      sub_1CB8E509C(v29, "Tree leaf should have DFSOut = DFSIn + 1:\n\t");
      uint64_t v19 = (unsigned int *)v10;
      goto LABEL_27;
    }
    uint64_t v25 = *(unsigned char **)(v10 + 24);
    uint64_t v31 = v33;
    uint64_t v32 = 0x800000000;
    sub_1CB935BDC((unsigned int *)&v31, v25, &v25[8 * v11]);
    unint64_t v26 = 126 - 2 * __clz(v32);
    if (v32) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = 0;
    }
    sub_1CD52EBFC((uint64_t *)v31, (uint64_t *)v31 + v32, v27, 1);
    v30[0] = v10;
    v30[1] = &v31;
    BOOL v14 = *(unsigned int **)v31;
    if (*(_DWORD *)(*(void *)v31 + 72) == *(_DWORD *)(v10 + 72) + 1)
    {
      BOOL v12 = (unsigned int *)*((void *)v31 + v32 - 1);
      if (v12[19] + 1 == *(_DWORD *)(v10 + 76))
      {
        uint64_t v17 = v32 - 1;
        unint64_t v15 = (unsigned int **)((char *)v31 + 8);
        while (v17)
        {
          BOOL v12 = v14;
          int v13 = v14[19] + 1;
          uint64_t v16 = *v15++;
          BOOL v14 = v16;
          --v17;
          if (v13 != v16[18]) {
            goto LABEL_46;
          }
        }
        int v28 = 1;
LABEL_40:
        if (v31 != v33) {
          free(v31);
        }
        if (!v28) {
          return 0;
        }
LABEL_19:
        while (1)
        {
          v5 += 2;
          if (v5 == v7) {
            return 1;
          }
          if ((*v5 | 0x1000) != 0xFFFFFFFFFFFFF000)
          {
            uint64_t result = 1;
            if (v5 != v7) {
              goto LABEL_17;
            }
            return result;
          }
        }
      }
    }
    else
    {
      BOOL v12 = *(unsigned int **)v31;
    }
    BOOL v14 = 0;
LABEL_46:
    sub_1CD52EAD0((llvm *)v30, v12, v14);
    int v28 = 0;
    goto LABEL_40;
  }
  BOOL v18 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
  sub_1CB8E509C(v18, "DFSIn number for the tree root is not:\n\t");
  uint64_t v19 = v8;
LABEL_27:
  unsigned int v20 = sub_1CD52EA14(v19);
  uint64_t v21 = (llvm::raw_ostream *)llvm::errs(v20);
  long long v22 = (unsigned char *)*((void *)v21 + 4);
  if ((unint64_t)v22 >= *((void *)v21 + 3))
  {
    uint64_t v21 = llvm::raw_ostream::write(v21, 10);
  }
  else
  {
    *((void *)v21 + 4) = v22 + 1;
    *long long v22 = 10;
  }
  int v23 = (llvm::raw_ostream *)llvm::errs(v21);
  uint64_t v24 = (const char *)*((void *)v23 + 2);
  if (*((const char **)v23 + 4) != v24)
  {
    *((void *)v23 + 4) = v24;
    llvm::raw_ostream::flush_tied_then_write(v23, v24);
  }
  return 0;
}

uint64_t sub_1CD52E4A0(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(unsigned int *)(a2 + 40);
  uint64_t v6 = (void *)(v4 + 16 * v5);
  if (*(_DWORD *)(a2 + 32))
  {
    if (v5)
    {
      uint64_t v7 = 16 * v5;
      int v8 = *(void **)(a2 + 24);
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        v7 -= 16;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      int v8 = *(void **)(a2 + 24);
    }
  }
  else
  {
LABEL_6:
    int v8 = (void *)(v4 + 16 * v5);
  }
  uint64_t v9 = (void *)(v4 + 16 * v5);
  if (v8 == v9) {
    return 1;
  }
  while (1)
  {
    uint64_t v10 = v8[1];
    uint64_t v11 = *(llvm::MachineBasicBlock **)v10;
    if (*(void *)v10)
    {
      if (*(_DWORD *)(v10 + 32))
      {
        uint64_t v25 = 0;
        sub_1CBFAFDE4((void *)a1, (char *)&v25, (char *)&v26, 1uLL);
        sub_1CD52D918((_DWORD *)(a1 + 24));
        sub_1CC346B80(a1, **(void **)a2, (uint64_t)v11);
        uint64_t v13 = *(unsigned int *)(v10 + 32);
        if (v13) {
          break;
        }
      }
    }
LABEL_10:
    BOOL v12 = v8 + 2;
    int v8 = v6;
    if (v12 != v6)
    {
      int v8 = v12;
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        if (v8 == v6)
        {
          int v8 = v6;
          break;
        }
      }
    }
    if (v8 == v9) {
      return 1;
    }
  }
  BOOL v14 = *(uint64_t ***)(v10 + 24);
  uint64_t v15 = 8 * v13;
  while (1)
  {
    uint64_t v16 = *v14;
    uint64_t v17 = (llvm *)sub_1CC34574C(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), **v14, &v25);
    if (v17) {
      break;
    }
    ++v14;
    v15 -= 8;
    if (!v15) {
      goto LABEL_10;
    }
  }
  uint64_t v19 = (llvm::raw_ostream *)llvm::errs(v17);
  unsigned int v20 = sub_1CB8E509C(v19, "Child ");
  if (*v16) {
    llvm::MachineBasicBlock::printAsOperand((llvm::MachineBasicBlock *)*v16, v20);
  }
  else {
    sub_1CB8E509C(v20, "nullptr");
  }
  uint64_t v21 = sub_1CB8E509C(v20, " reachable after its parent ");
  llvm::MachineBasicBlock::printAsOperand(v11, v21);
  long long v22 = sub_1CB8E509C(v21, " is removed!\n");
  int v23 = (llvm::raw_ostream *)llvm::errs(v22);
  uint64_t v24 = (const char *)*((void *)v23 + 2);
  if (*((const char **)v23 + 4) != v24)
  {
    *((void *)v23 + 4) = v24;
    llvm::raw_ostream::flush_tied_then_write(v23, v24);
  }
  return 0;
}

uint64_t sub_1CD52E6D0(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 24);
  uint64_t v5 = *(unsigned int *)(a2 + 40);
  uint64_t v6 = (void *)(v4 + 16 * v5);
  if (*(_DWORD *)(a2 + 32))
  {
    if (v5)
    {
      uint64_t v7 = 16 * v5;
      int v8 = *(void **)(a2 + 24);
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        v7 -= 16;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      int v8 = *(void **)(a2 + 24);
    }
  }
  else
  {
LABEL_6:
    int v8 = (void *)(v4 + 16 * v5);
  }
  int v28 = (void *)(v4 + 16 * v5);
  if (v8 == v28) {
    return 1;
  }
  uint64_t v27 = (_DWORD *)(a1 + 24);
  while (1)
  {
    uint64_t v9 = v8[1];
    if (*(void *)v9)
    {
      uint64_t v10 = *(unsigned int *)(v9 + 32);
      if (v10) {
        break;
      }
    }
LABEL_18:
    BOOL v18 = v8 + 2;
    int v8 = v6;
    if (v18 != v6)
    {
      int v8 = v18;
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        if (v8 == v6)
        {
          int v8 = v6;
          break;
        }
      }
    }
    if (v8 == v28) {
      return 1;
    }
  }
  uint64_t v11 = *(uint64_t ***)(v9 + 24);
  uint64_t v26 = &v11[v10];
  while (1)
  {
    BOOL v12 = *v11;
    uint64_t __src = 0;
    sub_1CBFAFDE4((void *)a1, (char *)&__src, (char *)&v30, 1uLL);
    sub_1CD52D918(v27);
    sub_1CC346B80(a1, **(void **)a2, *v12);
    uint64_t v13 = *(unsigned int *)(v9 + 32);
    if (v13) {
      break;
    }
LABEL_17:
    if (++v11 == v26) {
      goto LABEL_18;
    }
  }
  BOOL v14 = *(uint64_t ***)(v9 + 24);
  uint64_t v15 = 8 * v13;
  while (1)
  {
    uint64_t v16 = *v14;
    if (*v14 != v12)
    {
      uint64_t v17 = sub_1CC34574C(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), *v16, &__src);
      if ((v17 & 1) == 0) {
        break;
      }
    }
    ++v14;
    v15 -= 8;
    if (!v15) {
      goto LABEL_17;
    }
  }
  unsigned int v20 = (llvm::raw_ostream *)llvm::errs((llvm *)v17);
  uint64_t v21 = sub_1CB8E509C(v20, "Node ");
  if (*v16) {
    llvm::MachineBasicBlock::printAsOperand((llvm::MachineBasicBlock *)*v16, v21);
  }
  else {
    sub_1CB8E509C(v21, "nullptr");
  }
  long long v22 = sub_1CB8E509C(v21, " not reachable when its sibling ");
  if (*v12) {
    llvm::MachineBasicBlock::printAsOperand((llvm::MachineBasicBlock *)*v12, v22);
  }
  else {
    sub_1CB8E509C(v22, "nullptr");
  }
  int v23 = sub_1CB8E509C(v22, " is removed!\n");
  uint64_t v24 = (llvm::raw_ostream *)llvm::errs(v23);
  uint64_t v25 = (const char *)*((void *)v24 + 2);
  if (*((const char **)v24 + 4) != v25)
  {
    *((void *)v24 + 4) = v25;
    llvm::raw_ostream::flush_tied_then_write(v24, v25);
  }
  return 0;
}

BOOL sub_1CD52E948(uint64_t *a1, int a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 8) != a2) {
    return 0;
  }
  sub_1CD482B64((llvm::SmallPtrSetImplBase *)&v16, a1, &a1[a2]);
  uint64_t v6 = *(unsigned int *)(a3 + 8);
  if (v6)
  {
    uint64_t v7 = *(uint64_t **)a3;
    uint64_t v8 = 8 * v6 - 8;
    do
    {
      uint64_t v9 = *v7++;
      uint64_t v10 = (char *)sub_1CB896AE8((uint64_t)&v16, v9);
      BOOL v12 = v16;
      uint64_t v11 = v17;
      uint64_t v13 = (unsigned int *)&v18 + 1;
      if (v17 != v16) {
        uint64_t v13 = (unsigned int *)&v18;
      }
      BOOL v14 = &v17[8 * *v13];
      BOOL v3 = v10 != v14;
      BOOL v15 = v10 == v14 || v8 == 0;
      v8 -= 8;
    }
    while (!v15);
  }
  else
  {
    BOOL v3 = 1;
    BOOL v12 = v16;
    uint64_t v11 = v17;
  }
  if (v11 != v12) {
    free(v11);
  }
  return v3;
}

llvm::raw_ostream *sub_1CD52EA14(unsigned int *a1)
{
  uint64_t v2 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  if (a1 && *(void *)a1) {
    llvm::MachineBasicBlock::printAsOperand(*(llvm::MachineBasicBlock **)a1, v2);
  }
  else {
    sub_1CB8E509C(v2, "nullptr");
  }
  BOOL v3 = sub_1CB8E509C(v2, " {");
  uint64_t v4 = llvm::raw_ostream::operator<<(v3, a1[18]);
  uint64_t v5 = sub_1CB8E509C(v4, ", ");
  uint64_t result = llvm::raw_ostream::operator<<(v5, a1[19]);
  uint64_t v7 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v7 >= *((void *)result + 3))
  {
    return llvm::raw_ostream::write(result, 125);
  }
  else
  {
    *((void *)result + 4) = v7 + 1;
    unsigned char *v7 = 125;
  }
  return result;
}

llvm::raw_ostream *sub_1CD52EAD0(llvm *a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v6 = (llvm::raw_ostream *)llvm::errs(a1);
  sub_1CB8E509C(v6, "Incorrect DFS numbers for:\n\tParent ");
  uint64_t v7 = sub_1CD52EA14(*(unsigned int **)a1);
  uint64_t v8 = (llvm::raw_ostream *)llvm::errs(v7);
  sub_1CB8E509C(v8, "\n\tChild ");
  uint64_t v9 = sub_1CD52EA14(a2);
  if (a3)
  {
    int v23 = (llvm::raw_ostream *)llvm::errs(v9);
    sub_1CB8E509C(v23, "\n\tSecond child ");
    uint64_t v9 = sub_1CD52EA14(a3);
  }
  uint64_t v10 = (llvm::raw_ostream *)llvm::errs(v9);
  uint64_t v11 = sub_1CB8E509C(v10, "\nAll children: ");
  uint64_t v12 = *((void *)a1 + 1);
  uint64_t v13 = *(unsigned int *)(v12 + 8);
  if (v13)
  {
    BOOL v14 = *(unsigned int ***)v12;
    uint64_t v15 = 8 * v13;
    do
    {
      uint64_t v16 = *v14++;
      uint64_t v17 = sub_1CD52EA14(v16);
      uint64_t v18 = (llvm::raw_ostream *)llvm::errs(v17);
      uint64_t v11 = sub_1CB8E509C(v18, ", ");
      v15 -= 8;
    }
    while (v15);
  }
  uint64_t v19 = (llvm::raw_ostream *)llvm::errs(v11);
  unsigned int v20 = (unsigned char *)*((void *)v19 + 4);
  if ((unint64_t)v20 >= *((void *)v19 + 3))
  {
    uint64_t v19 = llvm::raw_ostream::write(v19, 10);
  }
  else
  {
    *((void *)v19 + 4) = v20 + 1;
    unsigned char *v20 = 10;
  }
  uint64_t result = (llvm::raw_ostream *)llvm::errs(v19);
  long long v22 = (const char *)*((void *)result + 2);
  if (*((const char **)result + 4) != v22)
  {
    *((void *)result + 4) = v22;
    return (llvm::raw_ostream *)llvm::raw_ostream::flush_tied_then_write(result, v22);
  }
  return result;
}

uint64_t *sub_1CD52EBFC(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = a2 - 1;
LABEL_3:
    for (uint64_t i = 1 - a3; ; ++i)
    {
      uint64_t v12 = (char *)a2 - (char *)v9;
      unint64_t v13 = a2 - v9;
      if (!(!v5 & v4))
      {
        switch(v13)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t v21 = *v9;
            if (*(_DWORD *)(*v10 + 72) < *(_DWORD *)(*v9 + 72))
            {
              uint64_t *v9 = *v10;
              *uint64_t v10 = v21;
            }
            break;
          case 3uLL:
            uint64_t result = sub_1CC3463C4(v9, v9 + 1, a2 - 1);
            break;
          case 4uLL:
            uint64_t result = sub_1CC346778(v9, v9 + 1, v9 + 2, a2 - 1);
            break;
          case 5uLL:
            uint64_t result = sub_1CC346810(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v12 <= 191)
      {
        long long v22 = v9 + 1;
        BOOL v24 = v9 == a2 || v22 == a2;
        if (a4)
        {
          if (!v24)
          {
            uint64_t v25 = 8;
            uint64_t v26 = v9;
            do
            {
              uint64_t v28 = *v26;
              uint64_t v27 = v26[1];
              uint64_t v26 = v22;
              unsigned int v29 = *(_DWORD *)(v27 + 72);
              if (v29 < *(_DWORD *)(v28 + 72))
              {
                uint64_t v30 = v25;
                do
                {
                  *(uint64_t *)((char *)v9 + v30) = v28;
                  uint64_t v31 = v30 - 8;
                  if (v30 == 8)
                  {
                    uint64_t v32 = v9;
                    goto LABEL_46;
                  }
                  uint64_t v28 = *(uint64_t *)((char *)v9 + v30 - 16);
                  v30 -= 8;
                }
                while (v29 < *(_DWORD *)(v28 + 72));
                uint64_t v32 = (uint64_t *)((char *)v9 + v31);
LABEL_46:
                *uint64_t v32 = v27;
              }
              long long v22 = v26 + 1;
              v25 += 8;
            }
            while (v26 + 1 != a2);
          }
        }
        else if (!v24)
        {
          do
          {
            uint64_t v34 = *v9;
            uint64_t v33 = v9[1];
            uint64_t v9 = v22;
            unsigned int v35 = *(_DWORD *)(v33 + 72);
            if (v35 < *(_DWORD *)(v34 + 72))
            {
              do
              {
                *long long v22 = v34;
                uint64_t v34 = *(v22 - 2);
                --v22;
              }
              while (v35 < *(_DWORD *)(v34 + 72));
              *long long v22 = v33;
            }
            long long v22 = v9 + 1;
          }
          while (v9 + 1 != a2);
        }
        return result;
      }
      if (i == 1)
      {
        if (v9 != a2)
        {
          return (uint64_t *)sub_1CC3468D4((uint64_t)v9, a2, a2);
        }
        return result;
      }
      unint64_t v14 = v13 >> 1;
      uint64_t v15 = &v9[v13 >> 1];
      if ((unint64_t)v12 >= 0x401)
      {
        sub_1CC3463C4(v9, &v9[v13 >> 1], a2 - 1);
        sub_1CC3463C4(v9 + 1, v15 - 1, a2 - 2);
        sub_1CC3463C4(v9 + 2, &v9[v14 + 1], a2 - 3);
        sub_1CC3463C4(v15 - 1, v15, &v9[v14 + 1]);
        uint64_t v16 = *v9;
        uint64_t *v9 = *v15;
        *uint64_t v15 = v16;
      }
      else
      {
        sub_1CC3463C4(&v9[v13 >> 1], v9, a2 - 1);
      }
      if ((a4 & 1) == 0 && *(_DWORD *)(*(v9 - 1) + 72) >= *(_DWORD *)(*v9 + 72))
      {
        uint64_t result = sub_1CC34644C(v9, a2);
        unsigned int v20 = result;
        goto LABEL_16;
      }
      uint64_t v17 = sub_1CC346518(v9, a2);
      if ((v18 & 1) == 0) {
        goto LABEL_61;
      }
      BOOL v19 = sub_1CC3465E4(v9, v17);
      unsigned int v20 = v17 + 1;
      uint64_t result = (uint64_t *)sub_1CC3465E4(v17 + 1, a2);
      if (result) {
        break;
      }
      if (!v19)
      {
LABEL_61:
        a3 = -i;
        uint64_t result = (uint64_t *)sub_1CD52EBFC(v9, v17, -i, a4 & 1);
        a4 = 0;
        uint64_t v9 = v17 + 1;
        goto LABEL_3;
      }
LABEL_16:
      uint64_t v9 = v20;
    }
    a3 = -i;
    a2 = v17;
    if (!v19) {
      continue;
    }
    return result;
  }
}

uint64_t llvm::MachineFrameInfo::CreateVariableSizedObject(unsigned __int8 *a1, unsigned __int8 a2, uint64_t a3)
{
  a1[36] = 1;
  if (a2 > *a1 && a1[1] == 0) {
    unsigned __int8 v5 = *a1;
  }
  else {
    unsigned __int8 v5 = a2;
  }
  long long v11 = 0uLL;
  LOBYTE(v12) = v5;
  *(_DWORD *)((char *)&v12 + 1) = 0;
  *((void *)&v12 + 1) = a3;
  LODWORD(v13) = 256;
  BYTE4(v13) = 0;
  unint64_t v6 = *((void *)a1 + 2);
  if (v6 >= *((void *)a1 + 3))
  {
    uint64_t v9 = sub_1CC347C74((void **)a1 + 1, (uint64_t)&v11);
  }
  else
  {
    long long v7 = v11;
    long long v8 = v12;
    *(void *)(v6 + 32) = v13;
    *(_OWORD *)unint64_t v6 = v7;
    *(_OWORD *)(v6 + 16) = v8;
    uint64_t v9 = (char *)(v6 + 40);
  }
  *((void *)a1 + 2) = v9;
  if (a1[60] < v5) {
    a1[60] = v5;
  }
  return ~*((_DWORD *)a1 + 8) - 858993459 * ((unint64_t)&v9[-*((void *)a1 + 1)] >> 3);
}

uint64_t llvm::MachineFrameInfo::getPristineRegs@<X0>(llvm::MachineFrameInfo *this@<X0>, const llvm::MachineFunction *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
  int v7 = *(_DWORD *)(v6 + 16);
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x600000000;
  uint64_t result = sub_1CB90D610(a3, (v7 + 63) >> 6, 0);
  *(_DWORD *)(a3 + 64) = v7;
  if (*((unsigned char *)this + 104))
  {
    uint64_t result = llvm::MachineRegisterInfo::getCalleeSavedRegs(*((llvm::MachineRegisterInfo **)a2 + 5));
    if (result)
    {
      unsigned int v9 = *(unsigned __int16 *)result;
      if (*(_WORD *)result)
      {
        uint64_t v10 = *(void *)a3;
        long long v11 = (unsigned __int16 *)(result + 2);
        do
        {
          *(void *)(v10 + 8 * (v9 >> 6)) |= 1 << v9;
          unsigned int v12 = *v11++;
          unsigned int v9 = v12;
        }
        while (v12);
      }
    }
    uint64_t v13 = (unsigned int *)*((void *)this + 10);
    unint64_t v14 = (unsigned int *)*((void *)this + 11);
    if (v13 != v14)
    {
      if (v6) {
        uint64_t v15 = (uint64_t *)(v6 + 8);
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v16 = v15[6];
      uint64_t v17 = *v15;
      uint64_t v18 = *(void *)a3;
      do
      {
        if (v16)
        {
          unsigned int v19 = *v13;
          unsigned int v20 = (unsigned __int16 *)(v16 + 2 * *(unsigned int *)(v17 + 24 * *v13 + 4));
          do
          {
            uint64_t result = (unsigned __int16)v19 >> 6;
            *(void *)(v18 + 8 * result) &= ~(1 << v19);
            int v21 = *v20++;
            v19 += v21;
          }
          while (v21);
        }
        v13 += 3;
      }
      while (v13 != v14);
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MachineFrameInfo::print(llvm::raw_ostream *this, const llvm::MachineFunction *a2, llvm::raw_ostream *a3)
{
  if (*((void *)this + 1) != *((void *)this + 2))
  {
    char v4 = this;
    uint64_t v5 = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 112))(*((void *)a2 + 2));
    uint64_t v24 = v5 ? *(int *)(v5 + 16) : 0;
    this = sub_1CB8E509C(a3, "Frame Objects:\n");
    uint64_t v6 = -858993459 * ((*((void *)v4 + 2) - *((void *)v4 + 1)) >> 3);
    if (v6)
    {
      uint64_t v7 = 0;
      unint64_t v8 = 0;
      while (1)
      {
        uint64_t v9 = *((void *)v4 + 1);
        uint64_t v10 = sub_1CB8E509C(a3, "  fi#");
        long long v11 = llvm::raw_ostream::operator<<(v10, (int)v8 - *((_DWORD *)v4 + 8));
        sub_1CB8E509C(v11, ": ");
        uint64_t v12 = v9 + v7;
        if (*(unsigned char *)(v9 + v7 + 20))
        {
          uint64_t v13 = sub_1CB8E509C(a3, "id=");
          unint64_t v14 = llvm::raw_ostream::operator<<(v13, *(unsigned __int8 *)(v12 + 20));
          uint64_t v15 = (unsigned char *)*((void *)v14 + 4);
          if ((unint64_t)v15 >= *((void *)v14 + 3))
          {
            llvm::raw_ostream::write(v14, 32);
          }
          else
          {
            *((void *)v14 + 4) = v15 + 1;
            *uint64_t v15 = 32;
          }
        }
        uint64_t v16 = *(void *)(v12 + 8);
        if (v16 != -1) {
          break;
        }
        uint64_t v17 = "dead\n";
LABEL_23:
        this = sub_1CB8E509C(a3, v17);
        ++v8;
        v7 += 40;
        if (v6 == v8) {
          return this;
        }
      }
      if (v16)
      {
        uint64_t v18 = sub_1CB8E509C(a3, "size=");
        llvm::raw_ostream::operator<<(v18, *(void *)(v12 + 8));
      }
      else
      {
        sub_1CB8E509C(a3, "variable sized");
      }
      unsigned int v19 = sub_1CB8E509C(a3, ", align=");
      llvm::raw_ostream::operator<<(v19, 1 << *(unsigned char *)(v9 + v7 + 16));
      unint64_t v20 = *((unsigned int *)v4 + 8);
      if (v8 < v20)
      {
        sub_1CB8E509C(a3, ", fixed");
        unint64_t v20 = *((unsigned int *)v4 + 8);
      }
      uint64_t v21 = *(void *)(v9 + v7);
      if (v8 >= v20)
      {
        uint64_t v17 = "\n";
        if (v21 == -1) {
          goto LABEL_23;
        }
      }
      int64_t v22 = v21 - v24;
      sub_1CB8E509C(a3, ", at location [SP");
      int v23 = a3;
      if (v22 < 1)
      {
        if ((v22 & 0x8000000000000000) == 0) {
          goto LABEL_22;
        }
      }
      else
      {
        int v23 = sub_1CB8E509C(a3, "+");
      }
      llvm::raw_ostream::operator<<(v23, v22);
LABEL_22:
      sub_1CB8E509C(a3, "]");
      uint64_t v17 = "\n";
      goto LABEL_23;
    }
  }
  return this;
}

llvm::raw_ostream *llvm::MachineFrameInfo::dump(llvm::MachineFrameInfo *this, const llvm::MachineFunction *a2)
{
  char v4 = llvm::dbgs(this);

  return llvm::MachineFrameInfo::print(this, a2, v4);
}

llvm::raw_ostream *llvm::MachineFunctionProperties::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  unsigned int v2 = *((_DWORD *)this + 16);
  if (v2)
  {
    uint64_t v4 = (uint64_t)this;
    unsigned int v5 = 0;
    uint64_t v6 = "";
    do
    {
      if ((*(void *)(*(void *)v4 + 8 * (v5 >> 6)) >> v5))
      {
        uint64_t v7 = sub_1CB8E509C(a2, v6);
        this = sub_1CB8E509C(v7, off_1E682F618[v5]);
        unsigned int v2 = *(_DWORD *)(v4 + 64);
        uint64_t v6 = ", ";
      }
      ++v5;
    }
    while (v5 < v2);
  }
  return this;
}

uint64_t llvm::MachineFunction::getOrCreateJumpTableInfo(llvm::MachineFunction *this, int a2)
{
  uint64_t result = *((void *)this + 9);
  if (!result)
  {
    uint64_t result = sub_1CB906F34((uint64_t *)this + 16, 32, 3);
    *(_DWORD *)uint64_t result = a2;
    *(void *)(result + 16) = 0;
    *(void *)(result + 24) = 0;
    *(void *)(result + 8) = 0;
    *((void *)this + 9) = result;
  }
  return result;
}

uint64_t llvm::MachineFunction::getDenormalMode(uint64_t **a1, void *a2)
{
  return llvm::Function::getDenormalMode(*a1, a2);
}

uint64_t llvm::MachineFunction::addFrameInst(uint64_t *a1, long long *a2)
{
  unint64_t v3 = a1[56];
  if (v3 < a1[57]) {
    uint64_t v4 = sub_1CC34C598(v3, a2) + 80;
  }
  else {
    uint64_t v4 = sub_1CC34C40C(a1 + 55, (uint64_t)a2);
  }
  a1[56] = v4;
  return -858993459 * ((unint64_t)(v4 - a1[55]) >> 4) - 1;
}

uint64_t llvm::MachineFunction::assignBeginEndSections(uint64_t this)
{
  uint64_t v1 = this + 320;
  uint64_t v2 = *(void *)(this + 328);
  *(unsigned char *)(v2 + 200) = 1;
  uint64_t v3 = *(void *)(v2 + 8);
  if (v3 != this + 320)
  {
    uint64_t v6 = v2 + 192;
    int v4 = *(_DWORD *)(v2 + 192);
    int v5 = *(_DWORD *)(v6 + 4);
    do
    {
      if (v4 != *(_DWORD *)(v3 + 192) || v5 != *(_DWORD *)(v3 + 196))
      {
        *(unsigned char *)(v3 + 200) = 1;
        *(unsigned char *)(*(void *)v3 + 201) = 1;
        int v4 = *(_DWORD *)(v3 + 192);
        int v5 = *(_DWORD *)(v3 + 196);
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v1);
  }
  *(unsigned char *)(*(void *)v1 + 201) = 1;
  return this;
}

void llvm::MachineFunction::copyCallSiteInfo(llvm::MachineFunction *this, const llvm::MachineInstr *a2, const llvm::MachineInstr *a3)
{
  v15[1] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a3;
  int v4 = (unsigned __int16 *)*((void *)a3 + 2);
  if ((v4[4] & 0x80) != 0
    && ((unsigned int v5 = *v4, v6 = v5 > 0x1F, v7 = (1 << v5) & 0x8E000000, !v6) ? (v8 = v7 == 0) : (v8 = 1), v8))
  {
    uint64_t v9 = (const llvm::MachineInstr *)sub_1CC34AF10((unint64_t)a2);
    uint64_t v10 = llvm::MachineFunction::getCallSiteInfo(this, v9);
    if (*((void *)this + 93) + 32 * *((unsigned int *)this + 190) != v10)
    {
      long long v11 = (uint64_t *)((char *)this + 744);
      v14[0] = v15;
      v14[1] = (void *)0x100000000;
      if (*(_DWORD *)(v10 + 16)) {
        sub_1CD532C28((uint64_t)v14, v10 + 8);
      }
      uint64_t v12 = sub_1CD532CFC(v11, &v13);
      sub_1CD532C28((uint64_t)(v12 + 1), (uint64_t)v14);
      if (v14[0] != v15) {
        free(v14[0]);
      }
    }
  }
  else
  {
    llvm::MachineFunction::eraseCallSiteInfo((int32x2_t *)this, a2);
  }
}

uint64_t llvm::MachineJumpTableInfo::RemoveMBBFromJumpTables(llvm::MachineJumpTableInfo *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v2 = (llvm::MachineBasicBlock ***)*((void *)this + 1);
  uint64_t v3 = (llvm::MachineBasicBlock ***)*((void *)this + 2);
  if (v2 == v3)
  {
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    do
    {
      unsigned int v5 = v2[1];
      BOOL v6 = *v2;
      if (*v2 != v5)
      {
        while (*v6 != a2)
        {
          if (++v6 == v5)
          {
            BOOL v6 = v2[1];
            break;
          }
        }
      }
      unsigned int v7 = v6 + 1;
      if (v6 != v5 && v7 != v5)
      {
        do
        {
          if (*v7 != a2) {
            *v6++ = *v7;
          }
          ++v7;
        }
        while (v7 != v5);
        unsigned int v5 = v2[1];
      }
      if (v6 != v5) {
        v2[1] = v6;
      }
      v4 |= v6 != v5;
      v2 += 3;
    }
    while (v2 != v3);
  }
  return v4 & 1;
}

double llvm::MachineFunction::getMachineMemOperand(llvm::MachineFunction *this, const llvm::MachineMemOperand *a2, const llvm::MachinePointerInfo *a3, uint64_t a4)
{
  uint64_t v7 = sub_1CB906F34((uint64_t *)this + 16, 80, 3);
  __int16 v8 = *((_WORD *)a2 + 16);
  char v9 = *((unsigned char *)a2 + 34);
  __int16 v10 = *((_WORD *)a2 + 18);
  uint64_t v11 = ((unint64_t)(a4 & 0x1FFFFFFF) << 6) | 1;
  if (a4 == -1) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *((void *)a3 + 2);
  *(_OWORD *)uint64_t v7 = *(_OWORD *)a3;
  *(void *)(v7 + 16) = v12;
  *(void *)(v7 + 24) = v11;
  *(_WORD *)(v7 + 32) = v8;
  *(unsigned char *)(v7 + 34) = v9;
  *(void *)(v7 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_WORD *)(v7 + 36) = v10;
  return result;
}

double llvm::MachineFunction::getMachineMemOperand(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1CB906F34((uint64_t *)(a1 + 128), 80, 3);
  __int16 v8 = *(_WORD *)(a2 + 32);
  char v9 = *(unsigned char *)(a2 + 34);
  __int16 v10 = *(_WORD *)(a2 + 36);
  uint64_t v11 = *(void *)(a3 + 16);
  *(_OWORD *)uint64_t v7 = *(_OWORD *)a3;
  *(void *)(v7 + 16) = v11;
  *(void *)(v7 + 24) = a4;
  *(_WORD *)(v7 + 32) = v8;
  *(unsigned char *)(v7 + 34) = v9;
  *(void *)(v7 + 72) = 0;
  double result = 0.0;
  *(_OWORD *)(v7 + 56) = 0u;
  *(_OWORD *)(v7 + 40) = 0u;
  *(_WORD *)(v7 + 36) = v10;
  return result;
}

void llvm::MachineFunction::dump(llvm::MachineFunction *this)
{
  uint64_t v2 = llvm::dbgs(this);

  llvm::MachineFunction::print((llvm::Value **)this, v2, 0);
}

void llvm::MachineFunction::print(llvm::Value **this, llvm::raw_ostream *a2, const llvm::SlotIndexes *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  BOOL v6 = sub_1CB8E509C(a2, "# Machine code for function ");
  uint64_t Name = llvm::Value::getName(*this);
  size_t v9 = v7;
  __int16 v10 = (void *)*((void *)v6 + 4);
  if (v7 <= *((void *)v6 + 3) - (void)v10)
  {
    if (v7)
    {
      memcpy(v10, Name, v7);
      *((void *)v6 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v6, Name, v7);
  }
  sub_1CB8E509C(v6, ": ");
  llvm::MachineFunctionProperties::print((llvm::raw_ostream *)(this + 45), a2);
  uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
  if ((unint64_t)v11 >= *((void *)a2 + 3))
  {
    llvm::raw_ostream::write(a2, 10);
  }
  else
  {
    *((void *)a2 + 4) = v11 + 1;
    *uint64_t v11 = 10;
  }
  llvm::MachineFrameInfo::print(this[7], (const llvm::MachineFunction *)this, a2);
  uint64_t v12 = this[9];
  if (v12) {
    llvm::MachineJumpTableInfo::print(v12, a2);
  }
  llvm::MachineConstantPool::print(this[8], a2);
  uint64_t v13 = (*(uint64_t (**)(llvm::Value *))(*(void *)this[2] + 176))(this[2]);
  unint64_t v14 = this[5];
  if (v14 && *((void *)v14 + 57) != *((void *)v14 + 58))
  {
    uint64_t v15 = v13;
    sub_1CB8E509C(a2, "Function Live Ins: ");
    uint64_t v16 = this[5];
    uint64_t v17 = (int *)*((void *)v16 + 57);
    uint64_t v18 = (int *)*((void *)v16 + 58);
    if (v17 != v18)
    {
      llvm::printReg(*v17, v15, 0, 0, (uint64_t)v31);
      unsigned int v19 = v32;
      if (!v32) {
LABEL_41:
      }
        sub_1CB920400();
      unint64_t v20 = v17 + 2;
      while (1)
      {
        (*((void (**)(llvm::SlotTracker **, llvm::raw_ostream *))*v19 + 6))(v19, a2);
        if (v32 == v31)
        {
          (*((void (**)(llvm::SlotTracker **))v31[0] + 4))(v31);
        }
        else if (v32)
        {
          (*((void (**)(void))*v32 + 5))();
        }
        if (*(v20 - 1))
        {
          uint64_t v21 = sub_1CB8E509C(a2, " in ");
          llvm::printReg(*(v20 - 1), v15, 0, 0, (uint64_t)v31);
          if (!v32) {
            goto LABEL_41;
          }
          (*((void (**)(llvm::SlotTracker **, llvm::raw_ostream *))*v32 + 6))(v32, v21);
          if (v32 == v31)
          {
            (*((void (**)(llvm::SlotTracker **))v31[0] + 4))(v31);
          }
          else if (v32)
          {
            (*((void (**)(void))*v32 + 5))();
          }
        }
        if (v20 == v18) {
          break;
        }
        sub_1CB8E509C(a2, ", ");
        int v22 = *v20;
        v20 += 2;
        llvm::printReg(v22, v15, 0, 0, (uint64_t)v31);
        unsigned int v19 = v32;
        if (!v32) {
          goto LABEL_41;
        }
      }
    }
    int v23 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v23 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v23 + 1;
      *int v23 = 10;
    }
  }
  llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)v31, *((void *)*this + 5), 1);
  llvm::ModuleSlotTracker::incorporateFunction(v31, *this);
  for (uint64_t i = this[41]; i != (llvm::MachineBasicBlock *)(this + 40); uint64_t i = (llvm::MachineBasicBlock *)*((void *)i + 1))
  {
    uint64_t v25 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v25 >= *((void *)a2 + 3))
    {
      llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v25 + 1;
      *uint64_t v25 = 10;
    }
    llvm::MachineBasicBlock::print(i, a2, v31, a3, (const llvm::TargetRegisterInfo *)1);
  }
  uint64_t v26 = sub_1CB8E509C(a2, "\n# End machine code for function ");
  uint64_t v28 = llvm::Value::getName(*this);
  size_t v29 = v27;
  uint64_t v30 = (void *)*((void *)v26 + 4);
  if (v27 <= *((void *)v26 + 3) - (void)v30)
  {
    if (v27)
    {
      memcpy(v30, v28, v27);
      *((void *)v26 + 4) += v29;
    }
  }
  else
  {
    llvm::raw_ostream::write(v26, v28, v27);
  }
  sub_1CB8E509C(v26, ".\n\n");
  llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v31);
}

char *llvm::MachineFunction::getName(llvm::Value **this)
{
  return llvm::Value::getName(*this);
}

llvm::raw_ostream *llvm::MachineJumpTableInfo::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 1) != *((void *)this + 2))
  {
    uint64_t v3 = this;
    this = sub_1CB8E509C(a2, "Jump Tables:\n");
    uint64_t v4 = -1431655765 * ((*((void *)v3 + 2) - *((void *)v3 + 1)) >> 3);
    if (v4)
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        uint64_t v16 = (void **)&v14;
        unint64_t v14 = (uint64_t (**)(void **))&unk_1F260E068;
        int v15 = i;
        sub_1CC34C90C((uint64_t)&v14, a2);
        BOOL v6 = (unsigned char *)*((void *)a2 + 4);
        if ((unint64_t)v6 >= *((void *)a2 + 3))
        {
          llvm::raw_ostream::write(a2, 58);
        }
        else
        {
          *((void *)a2 + 4) = v6 + 1;
          unsigned char *v6 = 58;
        }
        this = (llvm::raw_ostream *)v16;
        if (v16 == (void **)&v14)
        {
          this = (llvm::raw_ostream *)v14[4]((void **)&v14);
        }
        else if (v16)
        {
          this = (llvm::raw_ostream *)(*((uint64_t (**)(void))*v16 + 5))();
        }
        uint64_t v7 = *((void *)v3 + 1) + 24 * i;
        size_t v9 = *(uint64_t **)v7;
        __int16 v8 = *(uint64_t **)(v7 + 8);
        while (v9 != v8)
        {
          uint64_t v10 = *v9;
          uint64_t v11 = (unsigned char *)*((void *)a2 + 4);
          if ((unint64_t)v11 >= *((void *)a2 + 3))
          {
            llvm::raw_ostream::write(a2, 32);
          }
          else
          {
            *((void *)a2 + 4) = v11 + 1;
            *uint64_t v11 = 32;
          }
          llvm::printMBBReference(v10, &v14);
          if (!v16) {
            sub_1CB920400();
          }
          (*((void (**)(void **, llvm::raw_ostream *))*v16 + 6))(v16, a2);
          this = (llvm::raw_ostream *)v16;
          if (v16 == (void **)&v14)
          {
            this = (llvm::raw_ostream *)v14[4]((void **)&v14);
          }
          else if (v16)
          {
            this = (llvm::raw_ostream *)(*((uint64_t (**)(void))*v16 + 5))();
          }
          ++v9;
        }
        uint64_t v12 = (unsigned char *)*((void *)a2 + 4);
        if ((unint64_t)v12 >= *((void *)a2 + 3))
        {
          this = llvm::raw_ostream::write(a2, 10);
        }
        else
        {
          *((void *)a2 + 4) = v12 + 1;
          *uint64_t v12 = 10;
        }
      }
    }
    uint64_t v13 = (unsigned char *)*((void *)a2 + 4);
    if ((unint64_t)v13 >= *((void *)a2 + 3))
    {
      return llvm::raw_ostream::write(a2, 10);
    }
    else
    {
      *((void *)a2 + 4) = v13 + 1;
      *uint64_t v13 = 10;
    }
  }
  return this;
}

llvm::raw_ostream *llvm::MachineConstantPool::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  if (*((void *)this + 1) != *((void *)this + 2))
  {
    uint64_t v3 = this;
    this = sub_1CB8E509C(a2, "Constant Pool:\n");
    unint64_t v4 = *((void *)v3 + 2) - *((void *)v3 + 1);
    if ((v4 & 0xFFFFFFFF0) != 0)
    {
      uint64_t v5 = 0;
      unint64_t v6 = 0;
      uint64_t v7 = (v4 >> 4);
      do
      {
        __int16 v8 = sub_1CB8E509C(a2, "  cp#");
        sub_1CD098D14(v8, v6, 0, 0, 0);
        sub_1CB8E509C(v8, ": ");
        uint64_t v9 = *((void *)v3 + 1) + v5;
        uint64_t v10 = *(llvm::Value **)v9;
        if (*(unsigned char *)(v9 + 9)) {
          (*(void (**)(llvm::Value *, llvm::raw_ostream *))(*(void *)v10 + 48))(v10, a2);
        }
        else {
          llvm::Value::printAsOperand(v10, a2, 0, 0);
        }
        uint64_t v11 = sub_1CB8E509C(a2, ", align=");
        sub_1CD098D14(v11, 1 << *(unsigned char *)(*((void *)v3 + 1) + v5 + 8), 0, 0, 0);
        this = sub_1CB8E509C(a2, "\n");
        ++v6;
        v5 += 16;
      }
      while (v7 != v6);
    }
  }
  return this;
}

uint64_t llvm::MachineFunction::needsFrameMoves(llvm::MachineFunction *this)
{
  if (*(unsigned char *)(*((void *)this + 4) + 2108)) {
    return 1;
  }
  if ((*(_WORD *)(*((void *)this + 1) + 1064) & 0x10) != 0) {
    return 1;
  }
  uint64_t v2 = *(void *)this;
  uint64_t v3 = (llvm::AttributeList *)(*(void *)this + 112);
  if (llvm::AttributeList::getUWTableKind(v3)
    || !*(void *)v3
    || (*(unsigned char *)(*(void *)v3 + 16) & 0x20) == 0)
  {
    return 1;
  }
  else
  {
    return (*(unsigned __int16 *)(v2 + 18) >> 3) & 1;
  }
}

uint64_t llvm::MachineFunction::getJTISymbol(llvm::MachineFunction *this, unsigned int a2, llvm::MCContext *a3, int a4)
{
  v24[8] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(int *)(*(void *)(*(void *)this + 40) + 300);
  if (a4)
  {
    size_t v8 = v7 == 2;
    if (v7 == 2) {
      uint64_t v9 = "l";
    }
    else {
      uint64_t v9 = "";
    }
  }
  else
  {
    uint64_t v9 = (const char *)*((void *)&off_1E682F670 + v7);
    size_t v8 = qword_1CFAC7138[v7];
  }
  uint64_t v21 = &v22;
  int v22 = v24;
  long long v23 = xmmword_1CFAC7120;
  LODWORD(v14) = 0;
  char v18 = 0;
  uint64_t v19 = 0;
  int v20 = 0;
  uint64_t v13 = (unsigned __int8 **)&unk_1F2646FA8;
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  uint64_t v17 = 0;
  if (v8) {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v13, v9, v8);
  }
  sub_1CB8E509C((llvm::raw_ostream *)&v13, "JTI");
  sub_1CD098D14((llvm::raw_ostream *)&v13, *((unsigned int *)this + 84), 0, 0, 0);
  uint64_t v10 = v17;
  if ((unint64_t)v17 >= v16)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v13, 95);
  }
  else
  {
    ++v17;
    *uint64_t v10 = 95;
  }
  sub_1CD098D14((llvm::raw_ostream *)&v13, a2, 0, 0, 0);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v13);
  LOWORD(v17) = 261;
  uint64_t v13 = (unsigned __int8 **)v22;
  uint64_t v14 = v23;
  uint64_t v11 = llvm::MCContext::getOrCreateSymbol(a3, &v13);
  if (v22 != v24) {
    free(v22);
  }
  return v11;
}

llvm::MachineBasicBlock **llvm::MachineFunction::getOrCreateLandingPadInfo(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (char *)*((void *)this + 65);
  unint64_t v4 = (llvm::MachineBasicBlock **)*((void *)this + 64);
  unsigned int v5 = -286331153 * ((unint64_t)(v3 - (char *)v4) >> 3);
  if (v5)
  {
    uint64_t v6 = -286331153 * ((unint64_t)(v3 - (char *)v4) >> 3);
    while (*v4 != a2)
    {
      v4 += 15;
      if (!--v6) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    v9[0] = a2;
    v9[1] = v10;
    void v9[2] = 0x100000000;
    v10[1] = v11;
    void v10[2] = 0x100000000;
    v11[1] = v12;
    void v11[2] = 0x100000000;
    memset(&v12[16], 0, 32);
    if ((unint64_t)v3 >= *((void *)this + 66)) {
      uint64_t v7 = sub_1CC34C748((void **)this + 64, (uint64_t)v9);
    }
    else {
      uint64_t v7 = sub_1CD532AFC(v3, (uint64_t)v9) + 15;
    }
    *((void *)this + 65) = v7;
    sub_1CD531C78(v9);
    return (llvm::MachineBasicBlock **)(*((void *)this + 64) + 120 * v5);
  }
  return v4;
}

llvm::MachineBasicBlock **llvm::MachineFunction::addInvoke(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2, llvm::MCSymbol *a3, llvm::MCSymbol *a4)
{
  double result = llvm::MachineFunction::getOrCreateLandingPadInfo(this, a2);
  unsigned int v7 = *((_DWORD *)result + 4);
  if (v7 >= *((_DWORD *)result + 5)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)result[1] + v7) = a3;
  ++*((_DWORD *)result + 4);
  unsigned int v8 = *((_DWORD *)result + 10);
  if (v8 >= *((_DWORD *)result + 11)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)result[4] + v8) = a4;
  ++*((_DWORD *)result + 10);
  return result;
}

char *llvm::MachineFunction::addCleanup(llvm::MachineFunction *this, llvm::MachineBasicBlock *a2)
{
  LandingPadInfo = llvm::MachineFunction::getOrCreateLandingPadInfo(this, a2);
  int v5 = 0;
  uint64_t v3 = LandingPadInfo[13];
  if (v3 >= LandingPadInfo[14])
  {
    double result = sub_1CBFFBD60((char **)LandingPadInfo + 12, &v5);
  }
  else
  {
    *(_DWORD *)uint64_t v3 = 0;
    double result = (char *)v3 + 4;
  }
  LandingPadInfo[13] = (llvm::MachineBasicBlock *)result;
  return result;
}

char *llvm::MachineFunction::addCatchTypeInfo(llvm::MachineFunction *a1, llvm::MachineBasicBlock *a2, uint64_t a3, uint64_t a4)
{
  double result = (char *)llvm::MachineFunction::getOrCreateLandingPadInfo(a1, a2);
  if (a4)
  {
    unsigned int v8 = result;
    uint64_t v9 = (char **)(result + 96);
    uint64_t v10 = 8 * a4;
    uint64_t v11 = a3 - 8;
    do
    {
      int TypeIDFor = llvm::MachineFunction::getTypeIDFor(a1, *(const llvm::GlobalValue **)(v11 + v10));
      int v14 = TypeIDFor;
      uint64_t v13 = (_DWORD *)*((void *)v8 + 13);
      if ((unint64_t)v13 >= *((void *)v8 + 14))
      {
        double result = sub_1CBFFBD60(v9, &v14);
      }
      else
      {
        *uint64_t v13 = TypeIDFor;
        double result = (char *)(v13 + 1);
      }
      *((void *)v8 + 13) = result;
      v10 -= 8;
    }
    while (v10);
  }
  return result;
}

void llvm::MachineFunction::addFilterTypeInfo(llvm::MachineFunction *a1, llvm::MachineBasicBlock *a2, uint64_t a3, unint64_t a4)
{
  LandingPadInfo = llvm::MachineFunction::getOrCreateLandingPadInfo(a1, a2);
  unsigned int v8 = 0;
  int v14 = 0;
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  if (a4)
  {
    if (a4 >> 62) {
      abort();
    }
    unsigned int v8 = (char *)operator new(4 * a4);
    int v14 = v8;
    unint64_t v16 = &v8[4 * a4];
    bzero(v8, 4 * a4);
    uint64_t v15 = v16;
    if (a4)
    {
      uint64_t v12 = 0;
      do
      {
        *(_DWORD *)&v8[4 * v12] = llvm::MachineFunction::getTypeIDFor(a1, *(const llvm::GlobalValue **)(a3 + 8 * v12));
        ++v12;
      }
      while (a4 != v12);
    }
  }
  int FilterIDFor = llvm::MachineFunction::getFilterIDFor((uint64_t)a1, &v14);
  int v13 = FilterIDFor;
  uint64_t v10 = LandingPadInfo[13];
  if (v10 >= LandingPadInfo[14])
  {
    uint64_t v11 = sub_1CBFFBD60((char **)LandingPadInfo + 12, &v13);
  }
  else
  {
    *(_DWORD *)uint64_t v10 = FilterIDFor;
    uint64_t v11 = (char *)v10 + 4;
  }
  LandingPadInfo[13] = (llvm::MachineBasicBlock *)v11;
  if (v8) {
    operator delete(v8);
  }
}

unint64_t llvm::MachineFunction::getTypeIDFor(llvm::MachineFunction *this, const llvm::GlobalValue *a2)
{
  unsigned int v8 = a2;
  uint64_t v3 = (void *)*((void *)this + 82);
  uint64_t v4 = *((void *)this + 81);
  if ((((unint64_t)v3 - v4) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v5 = 0;
    while (*(const llvm::GlobalValue **)(v4 + 8 * v5) != a2)
    {
      if ((((unint64_t)v3 - v4) >> 3) == ++v5) {
        goto LABEL_5;
      }
    }
    return (v5 + 1);
  }
  else
  {
LABEL_5:
    if ((unint64_t)v3 >= *((void *)this + 83))
    {
      uint64_t v6 = sub_1CBC13470((void **)this + 81, &v8);
    }
    else
    {
      *uint64_t v3 = a2;
      uint64_t v6 = v3 + 1;
    }
    *((void *)this + 82) = v6;
    return ((unint64_t)v6 - *((void *)this + 81)) >> 3;
  }
}

uint64_t llvm::MachineFunction::getFilterIDFor(uint64_t a1, char **a2)
{
  uint64_t v4 = *(unsigned int **)(a1 + 696);
  uint64_t v5 = *(unsigned int **)(a1 + 704);
  for (uint64_t i = a2[1] - *a2; v4 != v5; ++v4)
  {
    uint64_t v7 = *v4;
    uint64_t v8 = i & 0x3FFFFFFFCLL;
    while (v7 && v8)
    {
      int v9 = *(_DWORD *)(*(void *)(a1 + 672) + 4 * v7 - 4);
      int v10 = *(_DWORD *)&(*a2)[v8 - 4];
      v8 -= 4;
      --v7;
      if (v9 != v10) {
        goto LABEL_8;
      }
    }
    if (!v8) {
      return ~v7;
    }
LABEL_8:
    ;
  }
  uint64_t v11 = *(void *)(a1 + 680) - *(void *)(a1 + 672);
  sub_1CC34AE58(a1 + 672, (i >> 2) + (v11 >> 2) + 1);
  sub_1CBFFBF40((char **)(a1 + 672), *(char **)(a1 + 680), *a2, a2[1], (a2[1] - *a2) >> 2);
  uint64_t v12 = *(_DWORD **)(a1 + 680);
  unint64_t v13 = ((unint64_t)v12 - *(void *)(a1 + 672)) >> 2;
  int v19 = v13;
  int v14 = *(_DWORD **)(a1 + 704);
  if ((unint64_t)v14 >= *(void *)(a1 + 712))
  {
    uint64_t v15 = sub_1CBFFBD60((char **)(a1 + 696), &v19);
    uint64_t v12 = *(_DWORD **)(a1 + 680);
  }
  else
  {
    *int v14 = v13;
    uint64_t v15 = (char *)(v14 + 1);
  }
  uint64_t v7 = v11 >> 2;
  *(void *)(a1 + 704) = v15;
  int v18 = 0;
  if ((unint64_t)v12 >= *(void *)(a1 + 688))
  {
    unint64_t v16 = sub_1CBFFBD60((char **)(a1 + 672), &v18);
  }
  else
  {
    *uint64_t v12 = 0;
    unint64_t v16 = (char *)(v12 + 1);
  }
  *(void *)(a1 + 680) = v16;
  return ~v7;
}

void *llvm::MachineFunction::tidyLandingPads(void *result, uint64_t a2, int a3)
{
  uint64_t v3 = result[64];
  if (result[65] == v3) {
    return result;
  }
  int v4 = a3;
  uint64_t v6 = result;
  uint64_t v7 = 0;
  unsigned int v8 = 0;
  int v9 = result + 64;
  size_t v29 = result + 64;
  uint64_t v30 = result;
  do
  {
    int v10 = (uint64_t *)(v3 + 120 * v7);
    uint64_t v11 = v10 + 11;
    double result = (void *)v10[11];
    if (result)
    {
      double result = (void *)sub_1CC34BE58((uint64_t)result, 1);
      if (!result)
      {
        if (!a2 || (double result = sub_1CD45F378(a2, v11), !result[1])) {
          *uint64_t v11 = 0;
        }
      }
    }
    uint64_t v12 = *v10;
    if (*v11) {
      BOOL v13 = 1;
    }
    else {
      BOOL v13 = v12 == 0;
    }
    if (!v13)
    {
      uint64_t v26 = *v9;
LABEL_29:
      double result = sub_1CC34AD04(v9, (__n128 *)(v26 + 120 * v7));
      goto LABEL_30;
    }
    if (!v4) {
      goto LABEL_36;
    }
    uint64_t v26 = *v9;
    int v14 = *(_DWORD *)(*v9 + 120 * v7 + 16);
    if (!v14) {
      goto LABEL_29;
    }
    unsigned int v15 = 0;
    uint64_t v16 = v3 + 120 * v7;
    uint64_t v17 = v16 + 8;
    uint64_t v18 = v16 + 32;
    do
    {
      uint64_t v19 = *(void *)(*(void *)v17 + 8 * v15);
      uint64_t v20 = *(void *)(*(void *)v18 + 8 * v15);
      uint64_t v32 = v20;
      uint64_t v33 = v19;
      if (sub_1CC34BE58(v19, 1))
      {
        double result = (void *)sub_1CC34BE58(v20, 1);
        if (result) {
          goto LABEL_24;
        }
        if (a2) {
          goto LABEL_16;
        }
      }
      else if (a2 && sub_1CD45F378(a2, &v33)[1])
      {
        double result = (void *)sub_1CC34BE58(v20, 1);
        if (result) {
          goto LABEL_24;
        }
LABEL_16:
        double result = sub_1CD45F378(a2, &v32);
        if (result[1]) {
          goto LABEL_24;
        }
      }
      uint64_t v21 = *(void *)v17 + 8 * v15;
      uint64_t v22 = *(unsigned int *)(v17 + 8);
      uint64_t v23 = *(void *)v17 + 8 * v22;
      if (v23 != v21 + 8)
      {
        memmove((void *)v21, (const void *)(v21 + 8), v23 - (v21 + 8));
        LODWORD(v22) = *(_DWORD *)(v17 + 8);
      }
      *(_DWORD *)(v17 + 8) = v22 - 1;
      double result = (void *)(*(void *)v18 + 8 * v15);
      uint64_t v24 = *(unsigned int *)(v18 + 8);
      uint64_t v25 = *(void *)v18 + 8 * v24;
      if ((void *)v25 != result + 1)
      {
        double result = memmove(result, result + 1, v25 - (void)(result + 1));
        LODWORD(v24) = *(_DWORD *)(v18 + 8);
      }
      *(_DWORD *)(v18 + 8) = v24 - 1;
      --v15;
      --v14;
LABEL_24:
      ++v15;
    }
    while (v15 != v14);
    int v9 = v29;
    uint64_t v6 = v30;
    uint64_t v26 = *v29;
    int v4 = a3;
    if (!*(_DWORD *)(*v29 + 120 * v7 + 16)) {
      goto LABEL_29;
    }
    uint64_t v12 = *v10;
LABEL_36:
    size_t v27 = (_DWORD **)(v3 + 120 * v7 + 96);
    if (!v12)
    {
      uint64_t v28 = *v27;
      goto LABEL_41;
    }
    uint64_t v28 = *v27;
    if (*(void *)(v3 + 120 * v7 + 104) - (void)*v27 == 4 && !*v28) {
LABEL_41:
    }
      *(void *)(v3 + 120 * v7 + 104) = v28;
    ++v8;
LABEL_30:
    uint64_t v7 = v8;
    uint64_t v3 = v6[64];
  }
  while (0xEEEEEEEEEEEEEEEFLL * ((v6[65] - v3) >> 3) != v8);
  return result;
}

unsigned int *llvm::MachineFunction::setCallSiteLandingPad(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  uint64_t v8 = a2;
  uint64_t v6 = (unsigned int *)sub_1CD531CE8(a1 + 536, &v8);
  return sub_1CB925718(v6 + 2, a3, &a3[4 * a4]);
}

uint64_t llvm::MachineFunction::getCallSiteInfo(llvm::MachineFunction *this, const llvm::MachineInstr *a2)
{
  if ((*(_WORD *)(*((void *)this + 1) + 1064) & 1) == 0) {
    return *((void *)this + 93) + 32 * *((unsigned int *)this + 190);
  }
  int v4 = a2;
  uint64_t v5 = 0;
  if (sub_1CD4678E0((uint64_t *)this + 93, &v4, &v5)) {
    return v5;
  }
  else {
    return *((void *)this + 93) + 32 * *((unsigned int *)this + 190);
  }
}

int32x2_t llvm::MachineFunction::eraseCallSiteInfo(int32x2_t *this, const llvm::MachineInstr *a2)
{
  uint64_t v3 = (const llvm::MachineInstr *)sub_1CC34AF10((unint64_t)a2);
  uint64_t v4 = llvm::MachineFunction::getCallSiteInfo((llvm::MachineFunction *)this, v3);
  if (*(void *)&this[93] + 32 * this[95].u32[0] != v4)
  {
    uint64_t v6 = (void *)v4;
    uint64_t v7 = *(void **)(v4 + 8);
    if (v7 != v6 + 3) {
      free(v7);
    }
    void *v6 = -8192;
    int32x2_t result = vadd_s32(this[94], (int32x2_t)0x1FFFFFFFFLL);
    this[94] = result;
  }
  return result;
}

void llvm::MachineFunction::moveCallSiteInfo(llvm::MachineFunction *this, const llvm::MachineInstr *a2, const llvm::MachineInstr *a3)
{
  v16[1] = *MEMORY[0x1E4F143B8];
  int v14 = a3;
  uint64_t v4 = (unsigned __int16 *)*((void *)a3 + 2);
  if ((v4[4] & 0x80) != 0
    && ((unsigned int v5 = *v4, v6 = v5 > 0x1F, v7 = (1 << v5) & 0x8E000000, !v6) ? (v8 = v7 == 0) : (v8 = 1), v8))
  {
    int v9 = (const llvm::MachineInstr *)sub_1CC34AF10((unint64_t)a2);
    uint64_t v10 = llvm::MachineFunction::getCallSiteInfo(this, v9);
    if (*((void *)this + 93) + 32 * *((unsigned int *)this + 190) != v10)
    {
      uint64_t v11 = (void *)v10;
      v15[0] = v16;
      v15[1] = (void *)0x100000000;
      if (*(_DWORD *)(v10 + 16)) {
        sub_1CD531FE8((uint64_t)v15, v10 + 8);
      }
      uint64_t v12 = (void *)v11[1];
      if (v12 != v11 + 3) {
        free(v12);
      }
      *uint64_t v11 = -8192;
      *((int32x2_t *)this + 94) = vadd_s32(*(int32x2_t *)((char *)this + 752), (int32x2_t)0x1FFFFFFFFLL);
      BOOL v13 = sub_1CD532CFC((uint64_t *)this + 93, &v14);
      sub_1CD532C28((uint64_t)(v13 + 1), (uint64_t)v15);
      if (v15[0] != v16) {
        free(v15[0]);
      }
    }
  }
  else
  {
    llvm::MachineFunction::eraseCallSiteInfo((int32x2_t *)this, a2);
  }
}

__n128 llvm::MachineFunction::makeDebugValueSubstitution(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  v8[0] = a2;
  v8[1] = a3;
  int v9 = a4;
  unsigned int v5 = (__n128 *)sub_1CD532FE4(a1 + 920, (unint64_t)v8, 1);
  BOOL v6 = (__n128 *)(*(void *)(a1 + 920) + 20 * *(unsigned int *)(a1 + 928));
  __n128 result = *v5;
  v6[1].n128_u32[0] = v5[1].n128_u32[0];
  __n128 *v6 = result;
  ++*(_DWORD *)(a1 + 928);
  return result;
}

unint64_t llvm::MachineFunction::substituteDebugValuesForInst(unint64_t this, const llvm::MachineInstr *a2, llvm::MachineInstr *a3, unsigned int a4)
{
  uint64_t v4 = *((unsigned int *)a2 + 16);
  if (v4)
  {
    unsigned int v6 = *((_DWORD *)a2 + 10);
    if (v6 >= a4) {
      unsigned int v6 = a4;
    }
    if (v6)
    {
      unint64_t v8 = this;
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      uint64_t v16 = this + 920;
      uint64_t v11 = 32 * v6;
      do
      {
        if ((*(_DWORD *)(*((void *)a2 + 4) + v10) & 0x10000FF) == 0x1000000)
        {
          unsigned int v12 = *((_DWORD *)a3 + 16);
          if (!v12)
          {
            uint64_t v13 = *(void *)(*((void *)a3 + 3) + 32);
            unsigned int v12 = *(_DWORD *)(v13 + 912) + 1;
            *(_DWORD *)(v13 + 912) = v12;
            *((_DWORD *)a3 + 16) = v12;
          }
          v17[0] = v4 + v9;
          v17[1] = v9 + v12;
          int v18 = 0;
          this = sub_1CD532FE4(v16, (unint64_t)v17, 1);
          uint64_t v14 = *(void *)(v8 + 920) + 20 * *(unsigned int *)(v8 + 928);
          long long v15 = *(_OWORD *)this;
          *(_DWORD *)(v14 + 16) = *(_DWORD *)(this + 16);
          *(_OWORD *)uint64_t v14 = v15;
          ++*(_DWORD *)(v8 + 928);
        }
        v10 += 32;
        v9 += 0x100000000;
      }
      while (v11 != v10);
    }
  }
  return this;
}

void *llvm::MachineFunction::finalizeDebugInstrRefs(llvm::MachineFunction *this)
{
  __n128 result = (void *)(*(uint64_t (**)(void))(**((void **)this + 2) + 104))(*((void *)this + 2));
  uint64_t v3 = (void *)*((void *)this + 41);
  if (v3 != (void *)((char *)this + 320))
  {
    uint64_t v4 = result;
    do
    {
      for (uint64_t i = v3[7]; (void *)i != v3 + 6; uint64_t i = *(void *)(i + 8))
      {
        if (**(_WORD **)(i + 16) == 15)
        {
          uint64_t v6 = *(void *)(i + 32);
          if (!*(unsigned char *)v6)
          {
            uint64_t v7 = *(unsigned int *)(v6 + 4);
            if (!v7) {
              goto LABEL_17;
            }
            uint64_t v8 = sub_1CC34BED0(*((void *)this + 5), *(_DWORD *)(v6 + 4));
            if (v8 == v9) {
              goto LABEL_17;
            }
            uint64_t v10 = *(void *)(v8 + 24);
            if (v10 && (*(unsigned char *)(v10 + 3) & 1) == 0) {
              uint64_t v10 = 0;
            }
            if (v10 == v9)
            {
              uint64_t v14 = *((void *)this + 5);
              if ((v7 & 0x80000000) != 0) {
                long long v15 = (uint64_t *)(*(void *)(v14 + 24) + 16 * (v7 & 0x7FFFFFFF) + 8);
              }
              else {
                long long v15 = (uint64_t *)(*(void *)(v14 + 272) + 8 * v7);
              }
              uint64_t v16 = *v15;
              if ((*(unsigned char *)(v16 + 3) & 1) == 0)
              {
                uint64_t v16 = *(void *)(v16 + 24);
                if ((*(unsigned char *)(v16 + 3) & 1) == 0) {
                  uint64_t v16 = 0;
                }
              }
              uint64_t v17 = *(void *)(v16 + 8);
              int v18 = **(unsigned __int16 **)(v17 + 16);
              BOOL v19 = v18 == 11 || v18 == 19;
              if (v19
                || ((*(void (**)(uint64_t *__return_ptr, void *, uint64_t))(*v4 + 416))(&v25, v4, v17), v26))
              {
                unint64_t v20 = llvm::MachineFunction::salvageCopySSA(this, (llvm::MachineInstr *)v17);
                unint64_t v21 = HIDWORD(v20);
                __n128 result = llvm::MachineOperand::ChangeToImmediate(*(unsigned int **)(i + 32), v20, 0);
                *(void *)(*(void *)(i + 32) + 48) = v21;
              }
              else
              {
                uint64_t v22 = *(unsigned int *)(v17 + 40);
                if (v22)
                {
                  uint64_t v11 = 0;
                  uint64_t v13 = 32 * v22;
                  unsigned int v12 = (_DWORD *)(*(void *)(v17 + 32) + 4);
                  while ((*(v12 - 1) & 0x10000FF) != 0x1000000 || *v12 != v7)
                  {
                    ++v11;
                    v12 += 8;
                    v13 -= 32;
                    if (!v13)
                    {
                      uint64_t v11 = *(unsigned int *)(v17 + 40);
                      break;
                    }
                  }
                }
                else
                {
                  uint64_t v11 = 0;
                }
                unsigned int v23 = *(_DWORD *)(v17 + 64);
                if (!v23)
                {
                  uint64_t v24 = *(void *)(*(void *)(v17 + 24) + 32);
                  unsigned int v23 = *(_DWORD *)(v24 + 912) + 1;
                  *(_DWORD *)(v24 + 912) = v23;
                  *(_DWORD *)(v17 + 64) = v23;
                }
                __n128 result = llvm::MachineOperand::ChangeToImmediate(*(unsigned int **)(i + 32), v23, 0);
                *(void *)(*(void *)(i + 32) + 48) = v11;
              }
            }
            else
            {
LABEL_17:
              *(void *)(i + 16) = v4[1] + 624;
              llvm::MachineOperand::setReg(*(void *)(i + 32), 0);
              __n128 result = (void *)llvm::MachineOperand::ChangeToRegister(*(void *)(i + 32) + 32, 0, 0, 0, 0, 0, 0, 0);
            }
          }
        }
        if ((*(unsigned char *)i & 4) == 0)
        {
          while ((*(_WORD *)(i + 44) & 8) != 0)
            uint64_t i = *(void *)(i + 8);
        }
      }
      uint64_t v3 = (void *)v3[1];
    }
    while (v3 != (void *)((char *)this + 320));
  }
  return result;
}

unint64_t llvm::MachineJumpTableInfo::getEntrySize(llvm::MachineJumpTableInfo *this, const llvm::DataLayout *a2)
{
  uint64_t v2 = *(unsigned int *)this;
  unint64_t result = 8;
  switch(v2)
  {
    case 1:
      return result;
    case 2:
    case 3:
    case 5:
      unint64_t result = 4;
      break;
    case 4:
      unint64_t result = 0;
      break;
    default:
      unint64_t result = llvm::DataLayout::getPointerSize(a2, 0);
      break;
  }
  return result;
}

uint64_t llvm::MachineJumpTableInfo::getEntryAlignment(llvm::MachineJumpTableInfo *this, const llvm::DataLayout *a2)
{
  uint64_t v2 = *(unsigned int *)this;
  uint64_t result = 1;
  switch(v2)
  {
    case 1:
      uint64_t v4 = a2;
      unsigned int v5 = 64;
      goto LABEL_3;
    case 2:
    case 3:
    case 5:
      uint64_t v4 = a2;
      unsigned int v5 = 32;
LABEL_3:
      uint64_t result = 1 << llvm::DataLayout::getIntegerAlignment(v4, v5, 1);
      break;
    case 4:
      return result;
    default:
      uint64_t result = 1 << llvm::DataLayout::getPointerABIAlignment(a2, 0);
      break;
  }
  return result;
}

uint64_t llvm::MachineJumpTableInfo::createJumpTableIndex(uint64_t a1, uint64_t a2)
{
  std::string __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    if (v5 < 0) {
      abort();
    }
    uint64_t v6 = (char *)operator new(v3 - *(void *)a2);
    uint64_t v7 = &v6[8 * (v5 >> 3)];
    std::string __p = v6;
    uint64_t v11 = v7;
    memmove(v6, v4, v5);
    uint64_t v10 = v7;
  }
  sub_1CC34B910((void *)(a1 + 8), (uint64_t)&__p);
  if (__p) {
    operator delete(__p);
  }
  return -1431655765 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3) - 1;
}

uint64_t llvm::MachineJumpTableInfo::ReplaceMBBInJumpTables(llvm::MachineJumpTableInfo *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3)
{
  uint64_t v3 = *((void *)this + 2) - *((void *)this + 1);
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * (v3 >> 3);
    do
    {
      uint64_t v6 = *((void *)this + 1) + 24 * v4;
      uint64_t v7 = *(llvm::MachineBasicBlock ***)v6;
      uint64_t v8 = *(llvm::MachineBasicBlock ***)(v6 + 8);
      while (v7 != v8)
      {
        if (*v7 == a2) {
          char *v7 = a3;
        }
        ++v7;
      }
      ++v4;
    }
    while (v4 != v5);
  }
  return 0;
}

llvm::raw_ostream *llvm::MachineJumpTableInfo::dump(llvm::MachineJumpTableInfo *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::MachineJumpTableInfo::print(this, v2);
}

uint64_t llvm::MachineConstantPoolEntry::getSizeInBytes(llvm::Type ***this, const llvm::DataLayout *a2)
{
  uint64_t v3 = **this;
  if (*((unsigned char *)this + 9))
  {
    uint64_t v4 = (uint64_t (*)(void))*((void *)v3 + 3);
    return v4();
  }
  else
  {
    unint64_t v6 = (unint64_t)(sub_1CB83544C((uint64_t)a2, (uint64_t)v3) + 7) >> 3;
    BOOL v8 = v7 == 1;
    char Alignment = llvm::DataLayout::getAlignment(a2, v3, 1);
    uint64_t v11 = ((1 << Alignment) + 0xFFFFFFFFLL + v6) & -(1 << Alignment);
    if (v8) {
    return v11;
    }
  }
}

uint64_t llvm::MachineConstantPoolEntry::getSectionKind(llvm::MachineConstantPoolEntry *this, const llvm::DataLayout *a2)
{
  if (*((unsigned char *)this + 9) || llvm::Constant::getRelocationInfo(*(llvm::Constant **)this) == 2) {
    return 20;
  }
  HIDWORD(v6) = llvm::MachineConstantPoolEntry::getSizeInBytes((llvm::Type ***)this, a2);
  LODWORD(v6) = HIDWORD(v6) - 4;
  unsigned int v5 = v6 >> 2;
  if (v5 > 7) {
    return 4;
  }
  else {
    return dword_1CFAC7178[v5];
  }
}

uint64_t llvm::MachineConstantPool::getConstantPoolIndex(unsigned __int8 *a1, uint64_t *a2, unsigned __int8 a3)
{
  if (a3 > *a1) {
    *a1 = a3;
  }
  unint64_t v6 = (_OWORD *)*((void *)a1 + 2);
  int v7 = (uint64_t *)(a1 + 8);
  unint64_t v8 = (unint64_t)v6 - *((void *)a1 + 1);
  if ((v8 & 0xFFFFFFFF0) == 0)
  {
LABEL_33:
    WORD4(v32) = a3;
    *(void *)&long long v32 = a2;
    if ((unint64_t)v6 >= *((void *)a1 + 3))
    {
      size_t v27 = sub_1CC34C9A4((char **)a1 + 1, &v32);
    }
    else
    {
      _OWORD *v6 = v32;
      size_t v27 = (char *)(v6 + 1);
    }
    *((void *)a1 + 2) = v27;
    return ((unint64_t)&v27[-*((void *)a1 + 1)] >> 4) - 1;
  }
  unsigned int v31 = a3;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = (v8 >> 4);
  while (1)
  {
    uint64_t v12 = *v7;
    if (!*(unsigned char *)(*v7 + v9 + 9))
    {
      uint64_t v13 = *(llvm::IntegerType ****)(v12 + v9);
      if (v13 == (llvm::IntegerType ***)a2) {
        goto LABEL_38;
      }
      uint64_t v14 = *v13;
      if (*v13 != (llvm::IntegerType **)*a2 && (v14[1] & 0xFE) != 0x10 && (*(_DWORD *)(*a2 + 8) & 0xFE) != 0x10)
      {
        long long v15 = (llvm::Type *)*((void *)a1 + 7);
        uint64_t v17 = sub_1CB83544C((uint64_t)v15, (uint64_t)v14);
        if (v16 == 1) {
        uint64_t v18 = sub_1CB83544C((uint64_t)v15, *a2);
        }
        if (v19 == 1)
        {
          uint64_t v30 = v18;
          uint64_t v18 = v30;
        }
        if ((unint64_t)(v17 + 7) <= 0x407
          && (unint64_t)(v17 + 7) >> 3 == (unint64_t)(v18 + 7) >> 3)
        {
          break;
        }
      }
    }
LABEL_6:
    ++v10;
    v9 += 16;
    if (v11 == v10)
    {
      unint64_t v6 = (_OWORD *)*((void *)a1 + 2);
      goto LABEL_33;
    }
  }
  uint64_t v21 = llvm::IntegerType::get(**v13, (llvm::LLVMContext *)((v17 + 7) & 0xFFFFFFF8));
  unsigned int v23 = (llvm::Constant *)v21;
  if (*((unsigned char *)*v13 + 8) == 15)
  {
    uint64_t v24 = 47;
LABEL_23:
    uint64_t v13 = (llvm::IntegerType ***)llvm::ConstantFoldCastOperand((llvm *)v24, (uint64_t)v13, v23, v15, v22);
    goto LABEL_24;
  }
  if (*v13 != (llvm::IntegerType **)v21)
  {
    uint64_t v24 = 49;
    goto LABEL_23;
  }
LABEL_24:
  if (*(unsigned char *)(*a2 + 8) == 15)
  {
    uint64_t v25 = 47;
LABEL_26:
    char v26 = llvm::ConstantFoldCastOperand((llvm *)v25, (uint64_t)a2, v23, v15, v22);
    goto LABEL_27;
  }
  char v26 = (llvm::ConstantExpr *)a2;
  if ((llvm::Constant *)*a2 != v23)
  {
    uint64_t v25 = 49;
    goto LABEL_26;
  }
LABEL_27:
  if (v13 != (llvm::IntegerType ***)v26) {
    goto LABEL_6;
  }
  uint64_t v12 = *v7;
LABEL_38:
  uint64_t v29 = v12 + v9;
  if (v31 > *(unsigned __int8 *)(v29 + 8)) {
    *(unsigned char *)(v29 + 8) = a3;
  }
  return v10;
}

uint64_t llvm::MachineConstantPool::getConstantPoolIndex(unsigned __int8 *a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v11 = a2;
  if (*a1 < a3) {
    *a1 = a3;
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, void))(*(void *)a2 + 32))(a2, a1, a3);
  if (v6 == -1)
  {
    BYTE8(v12) = a3;
    BYTE9(v12) = 1;
    *(void *)&long long v12 = a2;
    int v7 = (_OWORD *)*((void *)a1 + 2);
    if ((unint64_t)v7 >= *((void *)a1 + 3))
    {
      unint64_t v8 = sub_1CC34C9A4((char **)a1 + 1, &v12);
    }
    else
    {
      _OWORD *v7 = v12;
      unint64_t v8 = (char *)(v7 + 1);
    }
    *((void *)a1 + 2) = v8;
    return ((unint64_t)&v8[-*((void *)a1 + 1)] >> 4) - 1;
  }
  else
  {
    uint64_t v9 = v6;
    sub_1CD533060((uint64_t)(a1 + 32), &v11, (uint64_t)&v12);
  }
  return v9;
}

llvm::raw_ostream *llvm::MachineConstantPool::dump(llvm::MachineConstantPool *this)
{
  uint64_t v2 = llvm::dbgs(this);

  return llvm::MachineConstantPool::print(this, v2);
}

uint64_t sub_1CD531AC0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 560);
  if (v2 != (void *)(a1 + 576)) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 448);
  if (v3 != (void *)(a1 + 464)) {
    free(v3);
  }
  sub_1CD531B58((char **)(a1 + 176));
  uint64_t v4 = *(void **)(a1 + 96);
  if (v4 != (void *)(a1 + 112)) {
    free(v4);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 72), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 48), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 24), 8);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

char **sub_1CD531B58(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = v3 << 6;
    do
    {
      unsigned int v5 = *(char **)&v2[v4 - 48];
      if (&v2[v4 - 32] != v5) {
        free(v5);
      }
      v4 -= 64;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD531BCC(uint64_t a1)
{
  return a1;
}

void sub_1CD531C10(unsigned int *a1)
{
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = 72 * v1;
    uint64_t v3 = (void **)(*(void *)a1 + 16);
    do
    {
      if (((unint64_t)*(v3 - 2) | 0x1000) != 0xFFFFFFFFFFFFF000 && *v3 != *(v3 - 1)) {
        free(*v3);
      }
      v3 += 9;
      v2 -= 72;
    }
    while (v2);
  }
}

void *sub_1CD531C78(void *a1)
{
  uint64_t v2 = (void *)a1[12];
  if (v2)
  {
    a1[13] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[7];
  if (v3 != a1 + 9) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[4];
  if (v4 != a1 + 6) {
    free(v4);
  }
  unsigned int v5 = (void *)a1[1];
  if (v5 != a1 + 3) {
    free(v5);
  }
  return a1;
}

void *sub_1CD531CE8(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD5101D0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD531D64(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x400000000;
  }
  return v5;
}

void *sub_1CD531D64(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD531E18(a1, v6);
  unint64_t v8 = 0;
  sub_1CD5101D0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD531E18(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD531EF0(a1, v4, v4 + 40 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 40 * v10;
    do
    {
      void *result = -4096;
      result += 5;
      v11 -= 40;
    }
    while (v11);
  }
  return result;
}

void sub_1CD531EF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 40 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 5;
      v8 -= 40;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v13 = 0;
        sub_1CD5101D0(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        uint64_t v10 = v13;
        *uint64_t v13 = *(void *)v4;
        void v10[2] = 0x400000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CC0778D4(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        long long v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 40;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD531FE8(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 == v5)
    {
      int v7 = (_DWORD *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      if (v10 >= v9)
      {
        if (v9) {
          memmove(*(void **)a1, v4, 8 * v9 - 2);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v9)
        {
          *(_DWORD *)(a1 + 8) = 0;
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        if (v10) {
          memmove(*(void **)a1, v4, 8 * v10 - 2);
        }
        else {
          uint64_t v10 = 0;
        }
        uint64_t v11 = *v7;
        if (v10 != v11) {
          memcpy((void *)(*(void *)a1 + 8 * v10), (const void *)(*(void *)a2 + 8 * v10), *(void *)a2 + 8 * v11 - (*(void *)a2 + 8 * v10));
        }
      }
      *(_DWORD *)(a1 + 8) = v9;
    }
    else
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      int v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
    }
    _DWORD *v7 = 0;
  }
  return a1;
}

void *sub_1CD532108(uint64_t a1)
{
  sub_1CC008720(v6, (void *)(a1 + 8));
  uint64_t v2 = *(void *)(a1 + 32);
  unint64_t v5 = &unk_1F260E0B0;
  uint64_t v8 = v2;
  uint64_t result = (void *)sub_1CD5322C0(v2, (uint64_t)&v5);
  if (v7 != -8192 && v7 != -4096 && v7 != 0) {
    return llvm::ValueHandleBase::RemoveFromUseList(v6);
  }
  return result;
}

int32x2_t *sub_1CD532198(uint64_t a1, uint64_t a2)
{
  sub_1CC008720(v13, (void *)(a1 + 8));
  uint64_t v4 = *(void *)(a1 + 32);
  long long v12 = &unk_1F260E0B0;
  long long v15 = (int32x2_t *)v4;
  v9[0] = 0;
  if (sub_1CD5323B4((uint64_t *)v4, (uint64_t)&v12, v9)) {
    unint64_t v5 = (unint64_t *)v9[0];
  }
  else {
    unint64_t v5 = (unint64_t *)(*(void *)v4 + 48 * *(unsigned int *)(v4 + 16));
  }
  uint64_t result = v15;
  if ((unint64_t *)(*(void *)v15 + 48 * v15[2].u32[0]) != v5)
  {
    unint64_t v7 = v5[5];
    v5[5] = 0;
    sub_1CD532458(result, v5);
    uint64_t v10 = a2;
    uint64_t v11 = (int32x2_t *)v7;
    double v8 = sub_1CD532534((uint64_t)v15, &v10, (uint64_t)v9);
    uint64_t result = v11;
    uint64_t v11 = 0;
    if (result) {
      uint64_t result = (int32x2_t *)(*(uint64_t (**)(int32x2_t *, double))(*(void *)result + 16))(result, v8);
    }
  }
  if (v14 != -8192 && v14 != -4096)
  {
    if (v14) {
      return (int32x2_t *)llvm::ValueHandleBase::RemoveFromUseList(v13);
    }
  }
  return result;
}

uint64_t sub_1CD5322C0(uint64_t a1, uint64_t a2)
{
  double v8 = 0;
  uint64_t v3 = sub_1CD5323B4((uint64_t *)a1, a2, (uint64_t *)&v8);
  if (v3)
  {
    uint64_t v4 = (uint64_t)v8;
    uint64_t v5 = v8[5];
    void v8[5] = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
    }
    v9[0] = 2;
    v9[1] = 0;
    uint64_t v10 = -8192;
    uint64_t v11 = 0;
    double v8 = &unk_1F260E0B0;
    sub_1CBF62D84((unint64_t *)(v4 + 8), v9);
    uint64_t v6 = v10;
    *(void *)(v4 + 32) = v11;
    if (v6 != -8192 && v6 != -4096 && v6) {
      llvm::ValueHandleBase::RemoveFromUseList(v9);
    }
    *(int32x2_t *)(a1 + 8) = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
  }
  return v3;
}

uint64_t sub_1CD5323B4(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *(void *)(a2 + 24);
    int v6 = v3 - 1;
    unsigned int v7 = ((v5 >> 4) ^ (v5 >> 9)) & (v3 - 1);
    uint64_t v8 = *a1 + 48 * v7;
    uint64_t v9 = *(void *)(v8 + 24);
    if (v5 == v9)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      uint64_t result = 1;
      while (v9 != -4096)
      {
        if (v11) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v9 == -8192;
        }
        if (v13) {
          uint64_t v11 = v8;
        }
        unsigned int v14 = v7 + v12++;
        unsigned int v7 = v14 & v6;
        uint64_t v8 = v4 + 48 * (v14 & v6);
        uint64_t v9 = *(void *)(v8 + 24);
        if (v5 == v9) {
          goto LABEL_4;
        }
      }
      uint64_t result = 0;
      if (v11) {
        uint64_t v8 = v11;
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t result = 0;
  }
LABEL_4:
  *a3 = v8;
  return result;
}

int32x2_t sub_1CD532458(int32x2_t *a1, unint64_t *a2)
{
  unint64_t v4 = a2[5];
  a2[5] = 0;
  if (v4) {
    (*(void (**)(unint64_t))(*(void *)v4 + 16))(v4);
  }
  v8[0] = 2;
  v8[1] = 0;
  uint64_t v9 = -8192;
  unint64_t v10 = 0;
  sub_1CBF62D84(a2 + 1, v8);
  uint64_t v5 = v9;
  a2[4] = v10;
  if (v5 != -8192 && v5 != -4096 && v5 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(v8);
  }
  int32x2_t result = vadd_s32(a1[1], (int32x2_t)0x1FFFFFFFFLL);
  a1[1] = result;
  return result;
}

double sub_1CD532534@<D0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *a2;
  uint64_t v7 = 2;
  v13[0] = 2;
  v13[1] = 0;
  uint64_t v14 = v6;
  if (v6 != -8192 && v6 != -4096 && v6 != 0)
  {
    llvm::ValueHandleBase::AddToUseList((llvm::ValueHandleBase *)v13);
    uint64_t v7 = v13[0];
    uint64_t v6 = v14;
  }
  uint64_t v15 = a1;
  unint64_t v17 = v7 & 6;
  v18[0] = 0;
  v18[1] = v6;
  uint64_t v9 = a1;
  if (v6 != -8192)
  {
    BOOL v10 = v6 == -4096 || v6 == 0;
    uint64_t v9 = a1;
    if (!v10)
    {
      v18[0] = *(void *)(v7 & 0xFFFFFFFFFFFFFFF8);
      *(void *)(v7 & 0xFFFFFFFFFFFFFFF8) = &v17;
      unint64_t v17 = v7 & 0xFFFFFFFFFFFFFFFELL;
      if (v18[0]) {
        *(void *)v18[0] = *(void *)v18[0] & 7 | (unint64_t)v18;
      }
      uint64_t v9 = v15;
    }
  }
  uint64_t v16 = &unk_1F260E0B0;
  unint64_t v11 = a2[1];
  a2[1] = 0;
  void v18[2] = v9;
  unint64_t v19 = v11;
  sub_1CD5326B0(a1, (uint64_t)&v16, &v19, (uint64_t)&v20);
  sub_1CD532A88(&v16);
  if (v14 != -8192 && v14 != -4096 && v14) {
    llvm::ValueHandleBase::RemoveFromUseList(v13);
  }
  double result = *(double *)&v20;
  *(_OWORD *)a3 = v20;
  *(unsigned char *)(a3 + 16) = v21;
  return result;
}

unint64_t sub_1CD5326B0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  BOOL v13 = 0;
  unint64_t result = sub_1CD5323B4((uint64_t *)a1, a2, (uint64_t *)&v13);
  uint64_t v9 = v13;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t v9 = (unint64_t *)sub_1CD532764(a1, a2, a2, (uint64_t)v13);
    unint64_t result = sub_1CBF62D84(v9 + 1, (uint64_t *)(a2 + 8));
    uint64_t v9[4] = *(void *)(a2 + 32);
    unint64_t v12 = *a3;
    *a3 = 0;
    v9[5] = v12;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a1 + 48 * *(unsigned int *)(a1 + 16);
  *(void *)a4 = v9;
  *(void *)(a4 + 8) = v11;
  *(unsigned char *)(a4 + 16) = v10;
  return result;
}

uint64_t sub_1CD532764(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD532814(a1, v7);
  uint64_t v9 = 0;
  sub_1CD5323B4((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(void *)(a4 + 24) != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD532814(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(void *)a1 = operator new(48 * v8, (std::align_val_t)8uLL);
  if (v4)
  {
    sub_1CD5328DC(a1, v4, &v4[6 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }

  return sub_1CC34C188((void *)a1);
}

void *sub_1CD5328DC(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t result = sub_1CC34C188((void *)a1);
  v17[0] = 2;
  v17[1] = 0;
  uint64_t v18 = -4096;
  uint64_t v19 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = &unk_1F260E0B0;
  v13[0] = 2;
  v13[1] = 0;
  uint64_t v14 = -8192;
  if (a2 != a3)
  {
    do
    {
      uint64_t v7 = a2[3];
      if (v7 != v18 && v7 != v14)
      {
        uint64_t v20 = 0;
        sub_1CD5323B4((uint64_t *)a1, (uint64_t)a2, &v20);
        uint64_t v11 = v20;
        sub_1CBF62D84((unint64_t *)(v20 + 8), a2 + 1);
        *(void *)(v11 + 32) = a2[4];
        uint64_t v12 = a2[5];
        a2[5] = 0;
        *(void *)(v11 + 40) = v12;
        ++*(_DWORD *)(a1 + 8);
        unint64_t result = (void *)a2[5];
        a2[5] = 0;
        if (result) {
          unint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 16))(result);
        }
      }
      uint64_t v9 = a2[3];
      if (v9 != -8192 && v9 != -4096 && v9 != 0) {
        unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(a2 + 1);
      }
      a2 += 6;
    }
    while (a2 != a3);
    if (v14 != -8192 && v14 != -4096 && v14) {
      unint64_t result = llvm::ValueHandleBase::RemoveFromUseList(v13);
    }
  }
  if (v18 != -8192 && v18 != -4096)
  {
    if (v18) {
      return llvm::ValueHandleBase::RemoveFromUseList(v17);
    }
  }
  return result;
}

void *sub_1CD532A88(void *a1)
{
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
  }
  uint64_t v3 = a1[3];
  if (v3 != -8192 && v3 != -4096 && v3 != 0) {
    llvm::ValueHandleBase::RemoveFromUseList(a1 + 1);
  }
  return a1;
}

void *sub_1CD532AFC(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  a1[1] = a1 + 3;
  uint64_t v4 = (uint64_t)(a1 + 1);
  a1[2] = 0x100000000;
  if (*(_DWORD *)(a2 + 16)) {
    sub_1CD41C56C(v4, a2 + 8);
  }
  a1[4] = a1 + 6;
  a1[5] = 0x100000000;
  if (*(_DWORD *)(a2 + 40)) {
    sub_1CD41C56C((uint64_t)(a1 + 4), a2 + 32);
  }
  a1[7] = a1 + 9;
  a1[8] = 0x100000000;
  if (*(_DWORD *)(a2 + 64)) {
    sub_1CD4684F0((uint64_t)(a1 + 7), a2 + 56);
  }
  a1[11] = *(void *)(a2 + 88);
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  *((_OWORD *)a1 + 6) = *(_OWORD *)(a2 + 96);
  a1[14] = *(void *)(a2 + 112);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  return a1;
}

void *sub_1CD532BC8(void *a1, __n128 *a2)
{
  *a1 = a2->n128_u64[0];
  sub_1CD41C56C((uint64_t)(a1 + 1), (uint64_t)&a2->n128_i64[1]);
  sub_1CD41C56C((uint64_t)(a1 + 4), (uint64_t)&a2[2]);
  sub_1CD4684F0((uint64_t)(a1 + 7), (uint64_t)&a2[3].n128_i64[1]);
  a1[11] = a2[5].n128_u64[1];
  sub_1CD46D2D8((uint64_t)(a1 + 12), a2 + 6);
  return a1;
}

uint64_t sub_1CD532C28(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4) {
        memmove(*(void **)a1, *(const void **)a2, 8 * v4 - 2);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v5) {
        memmove(*(void **)a1, *(const void **)a2, 8 * v5 - 2);
      }
      else {
        uint64_t v5 = 0;
      }
      uint64_t v6 = *(unsigned int *)(a2 + 8);
      if (v5 != v6) {
        memcpy((void *)(*(void *)a1 + 8 * v5), (const void *)(*(void *)a2 + 8 * v5), *(void *)a2 + 8 * v6 - (*(void *)a2 + 8 * v5));
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

void *sub_1CD532CFC(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD4678E0(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD532D70((uint64_t)a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x100000000;
  }
  return v5;
}

void *sub_1CD532D70(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD532E20(a1, v7);
  uint64_t v9 = 0;
  sub_1CD4678E0((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD532E20(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  unint64_t result = operator new(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD532EEC(a1, v4, v4 + 32 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 32 * v10;
    do
    {
      void *result = -4096;
      result += 4;
      v11 -= 32;
    }
    while (v11);
  }
  return result;
}

void sub_1CD532EEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 32 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 4;
      v8 -= 32;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v12 = 0;
        sub_1CD4678E0((uint64_t *)a1, (void *)v4, &v12);
        uint64_t v9 = v12;
        *uint64_t v12 = *(void *)v4;
        uint64_t v9[2] = 0x100000000;
        v9[1] = v9 + 3;
        uint64_t v10 = (uint64_t)(v9 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD531FE8(v10, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        uint64_t v11 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v11) {
          free(v11);
        }
      }
      v4 += 32;
    }
    while (v4 != a3);
  }
}

unint64_t sub_1CD532FE4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (v3 + a3 > (unint64_t)*(unsigned int *)(a1 + 12))
  {
    unint64_t v5 = *(void *)a1 + 20 * v3;
    if (*(void *)a1 > a2 || v5 <= a2) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  return a2;
}

uint64_t sub_1CD533060@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD4C9788(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v10);
  int v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4C981C(a1, a2, v10);
    int v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 8 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

void llvm::MachineFunctionPass::createPrinterPass()
{
}

void sub_1CD533108(uint64_t a1)
{
  sub_1CC296918(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::initializeMachineFunctionPrinterPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCE968, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC34D634;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCE968, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createMachineFunctionPrinterPass()
{
}

void llvm::createMachineFunctionSplitterPass(llvm *this)
{
}

void llvm::initializeUnpackMachineBundlesPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCEB08, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC34E548;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCEB08, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeFinalizeMachineBundlesPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCEB10, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC34E874;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCEB10, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::finalizeBundle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  v112[16] = *MEMORY[0x1E4F143B8];
  sub_1CD533F38(v65, a1, a2, a3);
  uint64_t v6 = *(llvm::MachineFunction **)(a1 + 32);
  uint64_t v7 = (*(uint64_t (**)(void *))(**((void **)v6 + 2) + 104))(*((void **)v6 + 2));
  uint64_t v8 = (*(uint64_t (**)(void *))(**((void **)v6 + 2) + 176))(*((void **)v6 + 2));
  if (v4 == a3)
  {
LABEL_2:
    long long v104 = 0;
  }
  else
  {
    uint64_t v60 = v4;
    while (1)
    {
      uint64_t v61 = *(unsigned __int8 **)(v60 + 56);
      if (v61) {
        break;
      }
      uint64_t v60 = *(void *)(v60 + 8);
      if (v60 == a3) {
        goto LABEL_2;
      }
    }
    long long v104 = *(unsigned __int8 **)(v60 + 56);
    llvm::MetadataTracking::track((uint64_t)&v104, v61, 2);
  }
  uint64_t v9 = sub_1CC34E910(v6, &v104, *(void *)(v7 + 8) + 960);
  uint64_t v11 = v10;
  unint64_t v63 = v9;
  uint64_t v64 = v10;
  if (v104)
  {
    llvm::MetadataTracking::untrack((uint64_t)&v104, v104);
    uint64_t v11 = v64;
  }
  sub_1CD533FD8(v65, v65[1], v11);
  v110 = v112;
  uint64_t v111 = 0x2000000000;
  long long v104 = v106;
  uint64_t v105 = 0x2000000000;
  uint64_t v109 = 0;
  __int16 v108 = 0;
  v107 = &v108;
  uint64_t v98 = (int *)v100;
  uint64_t v99 = 0x800000000;
  uint64_t v103 = 0;
  unint64_t v102 = 0;
  uint64_t v101 = &v102;
  uint64_t v92 = v94;
  uint64_t v93 = 0x1000000000;
  uint64_t v97 = 0;
  uint64_t v96 = 0;
  char v95 = &v96;
  uint64_t v90 = 0x800000000;
  v85[1] = (void *)0x800000000;
  v88[1] = 0;
  int v89 = v91;
  uint64_t v87 = v88;
  v88[0] = 0;
  uint64_t v80 = 0x800000000;
  uint64_t v84 = 0;
  v85[0] = v86;
  char v82 = &v83;
  BOOL v83 = 0;
  unsigned int v73 = v75;
  uint64_t v74 = 0x800000000;
  uint64_t v78 = 0;
  v79 = v81;
  unsigned __int8 v76 = &v77;
  char v77 = 0;
  uint64_t v70 = v72;
  uint64_t v71 = 0x400000000;
  if (v4 != a3)
  {
    if (v8) {
      uint64_t v12 = (void *)(v8 + 8);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = v4;
    while (1)
    {
      if (**(unsigned __int16 **)(v13 + 16) - 13 < 5) {
        goto LABEL_59;
      }
      uint64_t v14 = *(unsigned int *)(v13 + 40);
      if (!v14) {
        goto LABEL_58;
      }
      for (uint64_t i = 0; i != v14; ++i)
      {
        uint64_t v16 = *(void *)(v13 + 32);
        unint64_t v17 = (int *)(v16 + 32 * i);
        if (*v17) {
          continue;
        }
        if ((*v17 & 0x1000000) != 0)
        {
          if (v71 >= (unint64_t)HIDWORD(v71)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          v70[v71] = v17;
          LODWORD(v71) = v71 + 1;
        }
        else
        {
          unsigned int v18 = *(_DWORD *)(v16 + 32 * i + 4);
          LODWORD(v66[0]) = v18;
          if (!v18) {
            continue;
          }
          if (v109)
          {
            for (unsigned int j = v108; j; unsigned int j = (void *)*j)
            {
              unsigned int v20 = *((_DWORD *)j + 7);
              if (v18 >= v20)
              {
                if (v20 >= v18) {
                  goto LABEL_35;
                }
                ++j;
              }
            }
LABEL_24:
            if ((sub_1CD513F60((uint64_t)v85, (unsigned int *)v66) & 0x100000000) != 0)
            {
              if (v90 >= (unint64_t)HIDWORD(v90)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v89[v90] = v66[0];
              LODWORD(v90) = v90 + 1;
              if ((*((unsigned char *)v17 + 3) & 0x10) != 0) {
                sub_1CD513F60((uint64_t)&v73, (unsigned int *)v66);
              }
            }
            if ((*v17 >> 26) & ~HIBYTE(*v17)) {
              sub_1CD513F60((uint64_t)&v79, (unsigned int *)v66);
            }
            continue;
          }
          if (!v105) {
            goto LABEL_24;
          }
          char v21 = v104;
          uint64_t v22 = 4 * v105;
          while (*(_DWORD *)v21 != v18)
          {
            v21 += 4;
            v22 -= 4;
            if (!v22) {
              goto LABEL_24;
            }
          }
          if (!v22) {
            goto LABEL_24;
          }
LABEL_35:
          unsigned int v23 = *v17;
          *v17 |= 0x20000000u;
          if ((v23 >> 26) & ~HIBYTE(v23)) {
            sub_1CD533D58((uint64_t)&v92, (unsigned int *)v66);
          }
        }
      }
      uint64_t v24 = v71;
      if (v71)
      {
        uint64_t v25 = 0;
        do
        {
          char v26 = (_DWORD *)v70[v25];
          LODWORD(v66[0]) = v26[1];
          if (LODWORD(v66[0]))
          {
            if ((sub_1CC34E98C((uint64_t)&v104, (unsigned int *)v66) & 0x100000000) != 0)
            {
              if (v111 >= (unint64_t)HIDWORD(v111)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              v110[v111] = v66[0];
              LODWORD(v111) = v111 + 1;
              if ((~*v26 & 0x5000000) == 0) {
                sub_1CD513F60((uint64_t)&v98, (unsigned int *)v66);
              }
            }
            else
            {
              sub_1CC34EC20((uint64_t)&v92, (unsigned int *)v66);
              if ((~*v26 & 0x5000000) != 0) {
                sub_1CC34ECB8(&v98, (unsigned int *)v66);
              }
            }
            if ((~*v26 & 0x5000000) != 0 && (LODWORD(v66[0]) - 1) <= 0x3FFFFFFE)
            {
              uint64_t v27 = v12[6];
              uint64_t v28 = *(unsigned int *)(*v12 + 24 * LODWORD(v66[0]) + 4);
              if (*(_WORD *)(v27 + 2 * v28))
              {
                unsigned __int16 v29 = *(_WORD *)(v27 + 2 * v28) + LOWORD(v66[0]);
                uint64_t v30 = (unsigned __int16 *)(v27 + 2 * v28 + 2);
                do
                {
                  int v31 = v29;
                  int v62 = v29;
                  if ((sub_1CC34E98C((uint64_t)&v104, (unsigned int *)&v62) & 0x100000000) != 0)
                  {
                    if (v111 >= (unint64_t)HIDWORD(v111)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    v110[v111] = v31;
                    LODWORD(v111) = v111 + 1;
                  }
                  int v32 = *v30++;
                  unsigned __int16 v29 = v32 + v31;
                }
                while (v32);
              }
            }
          }
          ++v25;
        }
        while (v25 != v24);
      }
LABEL_58:
      LODWORD(v71) = 0;
LABEL_59:
      uint64_t v13 = *(void *)(v13 + 8);
      if (v13 == a3)
      {
        unsigned int v33 = v111;
        goto LABEL_61;
      }
    }
  }
  unsigned int v33 = 0;
LABEL_61:
  v66[0] = v67;
  v66[1] = (void *)0x2000000000;
  v69[0] = 0;
  v69[1] = 0;
  int v68 = v69;
  if (v33)
  {
    uint64_t v34 = 0;
    uint64_t v35 = v33;
    while (1)
    {
      int v62 = v110[v34];
      if ((sub_1CC34E98C((uint64_t)v66, (unsigned int *)&v62) & 0x100000000) != 0) {
        break;
      }
LABEL_79:
      if (++v34 == v35) {
        goto LABEL_95;
      }
    }
    if (v103)
    {
      unint64_t v36 = v102;
      if (v102)
      {
        int k = v62;
        do
        {
          unint64_t v38 = *((unsigned int *)v36 + 7);
          if (v62 >= v38)
          {
            if (v38 >= v62) {
              goto LABEL_92;
            }
            ++v36;
          }
          unint64_t v36 = (void *)*v36;
        }
        while (v36);
      }
    }
    else if (v99)
    {
      uint64_t v42 = v98;
      int k = v62;
      uint64_t v43 = 4 * v99;
      while (*v42 != (unint64_t)v62)
      {
        ++v42;
        v43 -= 4;
        if (!v43) {
          goto LABEL_71;
        }
      }
      if (v43) {
        goto LABEL_92;
      }
    }
LABEL_71:
    if (v97)
    {
      long long v39 = v96;
      for (k = v62; v39; long long v39 = (void *)*v39)
      {
        unint64_t v40 = *((unsigned int *)v39 + 7);
        if (v62 >= v40)
        {
          if (v40 >= v62) {
            goto LABEL_92;
          }
          ++v39;
        }
      }
LABEL_77:
      unsigned int v41 = 6;
LABEL_78:
      sub_1CB89517C(&v63, k, v41, 0);
      goto LABEL_79;
    }
    int k = v62;
    if (!v93) {
      goto LABEL_77;
    }
    char v44 = v92;
    int v45 = &v92[4 * v93];
    while (*(_DWORD *)v44 != (unint64_t)v62)
    {
      v44 += 4;
      if (v44 == v45) {
        goto LABEL_77;
      }
    }
    if (v44 == v45) {
      goto LABEL_77;
    }
LABEL_92:
    unsigned int v41 = 22;
    goto LABEL_78;
  }
LABEL_95:
  uint64_t v46 = v90;
  if (!v90) {
    goto LABEL_130;
  }
  uint64_t v47 = 0;
  do
  {
    unsigned int v48 = v89[v47];
    if (!v84)
    {
      uint64_t v49 = v79;
      if (v80)
      {
        uint64_t v51 = 4 * v80;
        while (*(_DWORD *)v49 != v48)
        {
          v49 += 4;
          v51 -= 4;
          if (!v51) {
            goto LABEL_108;
          }
        }
      }
      else
      {
LABEL_108:
        uint64_t v49 = &v79[4 * v80];
      }
      LODWORD(v49) = v49 != &v79[4 * v80];
      goto LABEL_110;
    }
    uint64_t v49 = v83;
    if (!v83) {
      goto LABEL_110;
    }
    while (1)
    {
      unsigned int v50 = *((_DWORD *)v49 + 7);
      if (v48 >= v50) {
        break;
      }
LABEL_102:
      uint64_t v49 = *(char **)v49;
      if (!v49) {
        goto LABEL_110;
      }
    }
    if (v50 < v48)
    {
      v49 += 8;
      goto LABEL_102;
    }
    LODWORD(v49) = 1;
LABEL_110:
    if (v78)
    {
      for (m = v77; m; m = (void *)*m)
      {
        unsigned int v53 = *((_DWORD *)m + 7);
        if (v48 >= v53)
        {
          if (v53 >= v48)
          {
            int v54 = 8 * v49;
            goto LABEL_127;
          }
          ++m;
        }
      }
LABEL_116:
      int v54 = 8 * v49;
      goto LABEL_117;
    }
    if (!v74) {
      goto LABEL_116;
    }
    unint64_t v56 = v73;
    __int16 v57 = &v73[4 * v74];
    while (*(_DWORD *)v56 != v48)
    {
      v56 += 4;
      if (v56 == v57) {
        goto LABEL_116;
      }
    }
    int v54 = 8 * v49;
    if (v56 == v57) {
LABEL_117:
    }
      int v55 = 0;
    else {
LABEL_127:
    }
      int v55 = 32;
    sub_1CB89517C(&v63, v48, v54 | v55 | 4, 0);
    ++v47;
  }
  while (v47 != v46);
LABEL_130:
  if (v4 != a3)
  {
    uint64_t v58 = v64;
    do
    {
      __int16 v59 = *(_WORD *)(v4 + 44);
      if (v59)
      {
        *(_WORD *)(v58 + 44) |= 1u;
        __int16 v59 = *(_WORD *)(v4 + 44);
      }
      if ((v59 & 2) != 0) {
        *(_WORD *)(v58 + 44) |= 2u;
      }
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4 != a3);
  }
  sub_1CB833A08((uint64_t)&v68, v69[0]);
  if (v66[0] != v67) {
    free(v66[0]);
  }
  if (v70 != (void *)v72) {
    free(v70);
  }
  sub_1CB833A08((uint64_t)&v76, v77);
  if (v73 != v75) {
    free(v73);
  }
  sub_1CB833A08((uint64_t)&v82, v83);
  if (v79 != v81) {
    free(v79);
  }
  sub_1CB833A08((uint64_t)&v87, v88[0]);
  if (v85[0] != v86) {
    free(v85[0]);
  }
  if (v89 != (_DWORD *)v91) {
    free(v89);
  }
  sub_1CB833A08((uint64_t)&v95, v96);
  if (v92 != v94) {
    free(v92);
  }
  sub_1CB833A08((uint64_t)&v101, v102);
  if (v98 != (int *)v100) {
    free(v98);
  }
  sub_1CB833A08((uint64_t)&v107, v108);
  if (v104 != v106) {
    free(v104);
  }
  if (v110 != (_DWORD *)v112) {
    free(v110);
  }
}

unint64_t sub_1CD533D58(uint64_t a1, unsigned int *a2)
{
  if (*(void *)(a1 + 96))
  {
    sub_1CB84AEB8((uint64_t **)(a1 + 80), a2, a2);
    return ((unint64_t)v4 << 32) | 1;
  }
  else
  {
    uint64_t v6 = *(unsigned int *)(a1 + 8);
    unsigned int v7 = *a2;
    if (v6)
    {
      uint64_t v8 = 4 * v6;
      uint64_t v9 = *(_DWORD **)a1;
      while (*v9 != v7)
      {
        ++v9;
        v8 -= 4;
        if (!v8) {
          goto LABEL_7;
        }
      }
      if (v8) {
        return 1;
      }
LABEL_7:
      if (v6 <= 0xF) {
        goto LABEL_8;
      }
      do
      {
        uint64_t v10 = (unsigned int *)(*(void *)a1 + 4 * v6 - 4);
        sub_1CB84AEB8((uint64_t **)(a1 + 80), v10, v10);
        LODWORD(v6) = *(_DWORD *)(a1 + 8) - 1;
        *(_DWORD *)(a1 + 8) = v6;
      }
      while (v6);
      sub_1CB84AEB8((uint64_t **)(a1 + 80), a2, a2);
    }
    else
    {
LABEL_8:
      if (v6 >= *(_DWORD *)(a1 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(_DWORD *)(*(void *)a1 + 4 * v6) = v7;
      ++*(_DWORD *)(a1 + 8);
    }
    return 0x100000001;
  }
}

uint64_t llvm::finalizeBundles(llvm *this, llvm::MachineFunction *a2)
{
  uint64_t v2 = (char *)this + 320;
  uint64_t v3 = (char *)*((void *)this + 41);
  if (v3 == (char *)this + 320)
  {
    char v4 = 0;
  }
  else
  {
    char v4 = 0;
    do
    {
      unint64_t v5 = v3 + 48;
      uint64_t v6 = (char *)*((void *)v3 + 7);
      if (v6 != v3 + 48)
      {
        uint64_t v7 = *((void *)v6 + 1);
        while ((void *)v7 != v5)
        {
          if ((*(_WORD *)(v7 + 44) & 4) != 0)
          {
            unint64_t v8 = *(void *)v7 & 0xFFFFFFFFFFFFFFF8;
            uint64_t v9 = *(void *)(v8 + 8);
            uint64_t v7 = (uint64_t)(v3 + 48);
            if ((void *)v9 != v5)
            {
              while ((*(_WORD *)(v9 + 44) & 4) != 0)
              {
                uint64_t v9 = *(void *)(v9 + 8);
                if ((void *)v9 == v5)
                {
                  uint64_t v7 = (uint64_t)(v3 + 48);
                  goto LABEL_9;
                }
              }
              uint64_t v7 = v9;
            }
LABEL_9:
            llvm::finalizeBundle((uint64_t)v3, v8, v7);
            char v4 = 1;
          }
          else
          {
            uint64_t v7 = *(void *)(v7 + 8);
          }
        }
      }
      uint64_t v3 = (char *)*((void *)v3 + 1);
    }
    while (v3 != v2);
  }
  return v4 & 1;
}

void *sub_1CD533F38(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  if (!a3 || (*(unsigned char *)a3 & 4) == 0)
  {
    while ((*(_WORD *)(a3 + 44) & 8) != 0)
      a3 = *(void *)(a3 + 8);
  }
  uint64_t v6 = *(void *)(a3 + 8);
  if (v6 != a4)
  {
    do
    {
      if (!v6 || (uint64_t v7 = v6, (*(unsigned char *)v6 & 4) == 0))
      {
        uint64_t v7 = v6;
        if ((*(_WORD *)(v6 + 44) & 8) != 0)
        {
          uint64_t v7 = v6;
          do
            uint64_t v7 = *(void *)(v7 + 8);
          while ((*(_WORD *)(v7 + 44) & 8) != 0);
        }
      }
      uint64_t v8 = *(void *)(v7 + 8);
      llvm::MachineInstr::bundleWithPred(v6);
      uint64_t v6 = v8;
    }
    while (v8 != a4);
  }
  return a1;
}

uint64_t *sub_1CD533FD8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  llvm::MachineBasicBlock::insert(*a1, a2, a3);
  uint64_t v6 = a1[2];
  if (a1[1] == a2)
  {
    if (v6 != a2) {
      llvm::MachineInstr::bundleWithSucc(a3);
    }
    a1[1] = a3;
  }
  else if (v6 == a2)
  {
    llvm::MachineInstr::bundleWithPred(a3);
  }
  else
  {
    *(_WORD *)(a3 + 44) |= 0xCu;
  }
  return a1;
}

uint64_t llvm::MachineInstr::moveBefore(llvm::MachineInstr *this, llvm::MachineInstr *a2)
{
  return sub_1CB9173F0(*((void *)a2 + 3), (unint64_t *)a2, *((void *)this + 3), (unint64_t *)this);
}

uint64_t llvm::MachineInstr::tieOperands(uint64_t this, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *(void *)(this + 32);
  char v4 = (unsigned int *)(v3 + 32 * a3);
  unsigned int v5 = *v4 & 0xFF0FFFFF | (((((a2 << 20) + 0x100000) >> 20) & 0xF) << 20);
  if (a2 > 0xE) {
    unsigned int v5 = *v4 | 0xF00000;
  }
  unsigned int *v4 = v5;
  if (a3 + 1 < 0xF) {
    int v6 = a3 + 1;
  }
  else {
    int v6 = 15;
  }
  *(_DWORD *)(v3 + 32 * a2) = *(_DWORD *)(v3 + 32 * a2) & 0xFF0FFFFF | (v6 << 20);
  return this;
}

const llvm::MachineInstr *llvm::MachineInstr::cloneMemRefs(const llvm::MachineInstr *this, llvm::MachineFunction *a2, const llvm::MachineInstr *a3)
{
  if (this == a3) {
    return this;
  }
  unint64_t v3 = *((void *)this + 6);
  if (v3 < 8) {
    goto LABEL_13;
  }
  char v4 = (int *)(v3 & 0xFFFFFFFFFFFFFFF8);
  if ((*((void *)this + 6) & 7) != 1 || v4 == 0)
  {
    BOOL v6 = (*((void *)this + 6) & 7) != 3 || v4 == 0;
    if (!v6 && *((unsigned char *)v4 + 4))
    {
      char v4 = *(int **)&v4[2 * *v4 + 2];
      goto LABEL_14;
    }
LABEL_13:
    char v4 = 0;
  }
LABEL_14:
  unint64_t v9 = *((void *)a3 + 6);
  uint64_t v7 = (unint64_t *)((char *)a3 + 48);
  unint64_t v8 = v9;
  if (v9 < 8) {
    goto LABEL_25;
  }
  uint64_t v10 = (int *)(v8 & 0xFFFFFFFFFFFFFFF8);
  if ((v8 & 7) != 1 || v10 == 0)
  {
    BOOL v12 = (v8 & 7) != 3 || v10 == 0;
    if (!v12 && *((unsigned char *)v10 + 4))
    {
      uint64_t v10 = *(int **)&v10[2 * *v10 + 2];
      goto LABEL_26;
    }
LABEL_25:
    uint64_t v10 = 0;
  }
LABEL_26:
  if (v4 == v10)
  {
    if (v3 >= 8)
    {
      uint64_t v15 = (int *)(v3 & 0xFFFFFFFFFFFFFFF8);
      if ((*((void *)this + 6) & 7) == 2 && (unint64_t v16 = v3 & 0xFFFFFFFFFFFFFFF8, v15)
        || (unint64_t v16 = 0, (*((void *)this + 6) & 7) != 3)
        || !v15)
      {
LABEL_42:
        if (v8 >= 8)
        {
          unint64_t v17 = (int *)(v8 & 0xFFFFFFFFFFFFFFF8);
          if ((v8 & 7) == 2 && (unint64_t v18 = v8 & 0xFFFFFFFFFFFFFFF8, v17) || (unint64_t v18 = 0, (v8 & 7) != 3) || !v17)
          {
LABEL_50:
            if (v16 != v18) {
              goto LABEL_27;
            }
            if (v3 >= 8)
            {
              uint64_t v19 = 0;
              if ((*((void *)this + 6) & 7) != 3 || (unsigned int v20 = (unsigned char *)(v3 & 0xFFFFFFFFFFFFFFF8)) == 0)
              {
LABEL_62:
                if (v8 >= 8)
                {
                  uint64_t v21 = 0;
                  if ((v8 & 7) != 3 || (uint64_t v22 = (unsigned char *)(v8 & 0xFFFFFFFFFFFFFFF8), (v8 & 0xFFFFFFFFFFFFFFF8) == 0))
                  {
LABEL_68:
                    if (v19 == v21)
                    {
                      *((void *)this + 6) = v8;
                      return this;
                    }
                    goto LABEL_27;
                  }
                  if (v22[6])
                  {
                    uint64_t v21 = *(void *)&v22[8 * *(int *)v22 + 8 + 8 * (v22[5] + v22[4])];
                    goto LABEL_68;
                  }
                }
                uint64_t v21 = 0;
                goto LABEL_68;
              }
              if (v20[6])
              {
                uint64_t v19 = *(void *)&v20[8 * *(int *)v20 + 8 + 8 * (v20[5] + v20[4])];
                goto LABEL_62;
              }
            }
            uint64_t v19 = 0;
            goto LABEL_62;
          }
          if (*((unsigned char *)v17 + 5))
          {
            unint64_t v18 = *(void *)&v17[2 * *v17 + 2 + 2 * *((unsigned __int8 *)v17 + 4)];
            goto LABEL_50;
          }
        }
        unint64_t v18 = 0;
        goto LABEL_50;
      }
      if (*((unsigned char *)v15 + 5))
      {
        unint64_t v16 = *(void *)&v15[2 * *v15 + 2 + 2 * *((unsigned __int8 *)v15 + 4)];
        goto LABEL_42;
      }
    }
    unint64_t v16 = 0;
    goto LABEL_42;
  }
LABEL_27:
  if (v8 < 8)
  {
    uint64_t v7 = 0;
    uint64_t v13 = 0;
  }
  else if ((v8 & 7) != 0)
  {
    uint64_t v7 = 0;
    uint64_t v13 = 0;
    if ((v8 & 7) == 3)
    {
      uint64_t v14 = (int *)(v8 & 0xFFFFFFFFFFFFFFF8);
      if (v14)
      {
        uint64_t v13 = *v14;
        uint64_t v7 = (unint64_t *)(v14 + 2);
      }
    }
  }
  else
  {
    unint64_t *v7 = v8 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v13 = 1;
  }
  return (const llvm::MachineInstr *)llvm::MachineInstr::setMemRefs((uint64_t)this, (uint64_t *)a2, v7, v13);
}

void llvm::MachineInstr::cloneMergedMemRefs(llvm::MachineInstr *this, llvm::MachineFunction *a2, uint64_t a3, uint64_t a4)
{
  v47[2] = *MEMORY[0x1E4F143B8];
  if (!a4) {
    goto LABEL_10;
  }
  if (a4 == 1)
  {
    char v44 = *(const llvm::MachineInstr **)a3;
    llvm::MachineInstr::cloneMemRefs(this, a2, v44);
    return;
  }
  unint64_t v8 = *(const llvm::MachineInstr **)a3;
  unint64_t v9 = *(void *)(*(void *)a3 + 48);
  if (v9 < 8) {
    goto LABEL_10;
  }
  if ((v9 & 7) != 0)
  {
    uint64_t v10 = (_DWORD *)(v9 & 0xFFFFFFFFFFFFFFF8);
    BOOL v11 = (*(void *)(*(void *)a3 + 48) & 7) != 3 || v10 == 0;
    if (!v11 && *v10)
    {
      int v45 = v47;
      uint64_t v46 = 0x200000000;
      goto LABEL_72;
    }
LABEL_10:
    llvm::MachineInstr::dropMemRefs((uint64_t)this, a2);
    return;
  }
  *((void *)v8 + 6) = v9 & 0xFFFFFFFFFFFFFFF8;
  unint64_t v8 = *(const llvm::MachineInstr **)a3;
  unint64_t v9 = *(void *)(*(void *)a3 + 48);
  int v45 = v47;
  uint64_t v46 = 0x200000000;
  if (v9 < 8)
  {
    BOOL v12 = 0;
    goto LABEL_15;
  }
LABEL_72:
  unint64_t v38 = v9 & 0xFFFFFFFFFFFFFFF8;
  if ((v9 & 7) != 0)
  {
    if (v38) {
      BOOL v39 = (v9 & 7) == 3;
    }
    else {
      BOOL v39 = 0;
    }
    unint64_t v40 = (unsigned char *)(v38 + 8);
    if (v39) {
      BOOL v12 = v40;
    }
    else {
      BOOL v12 = 0;
    }
  }
  else
  {
    *((void *)v8 + 6) = v38;
    BOOL v12 = (char *)v8 + 48;
    unint64_t v8 = *(const llvm::MachineInstr **)a3;
    unint64_t v9 = *(void *)(*(void *)a3 + 48);
    if (v9 < 8) {
      goto LABEL_15;
    }
  }
  unsigned int v41 = (int *)(v9 & 0xFFFFFFFFFFFFFFF8);
  unint64_t v42 = v9 & 7;
  if (!v42)
  {
    *((void *)v8 + 6) = v41;
    uint64_t v13 = (int *)((char *)v8 + 48);
    uint64_t v14 = 1;
    goto LABEL_16;
  }
  if (v42 == 3 && v41 != 0)
  {
    uint64_t v14 = *v41;
    uint64_t v13 = v41 + 2;
    goto LABEL_16;
  }
LABEL_15:
  uint64_t v13 = 0;
  uint64_t v14 = 0;
LABEL_16:
  sub_1CC188254((unsigned int *)&v45, v12, &v13[2 * v14]);
  uint64_t v15 = (uint64_t *)(a3 + 8 * a4);
  unint64_t v16 = (uint64_t *)(a3 + 8);
  while (1)
  {
    uint64_t v17 = *v16;
    uint64_t v19 = (uint64_t *)(*(void *)a3 + 48);
    uint64_t v18 = *v19;
    if ((unint64_t)*v19 < 8) {
      goto LABEL_24;
    }
    if ((v18 & 7) != 0)
    {
      unsigned int v20 = (int *)(v18 & 0xFFFFFFFFFFFFFFF8);
      if ((v18 & 7) == 3 && v20 != 0)
      {
        uint64_t v29 = *v20;
        uint64_t v19 = (uint64_t *)(v20 + 2);
        uint64_t v28 = v29;
        goto LABEL_25;
      }
LABEL_24:
      uint64_t v19 = 0;
      uint64_t v28 = 0;
      goto LABEL_25;
    }
    *uint64_t v19 = v18 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v28 = 1;
LABEL_25:
    unint64_t v24 = *(void *)(v17 + 48);
    unsigned int v23 = (uint64_t *)(v17 + 48);
    unint64_t v22 = v24;
    if (v24 < 8) {
      goto LABEL_32;
    }
    if ((v22 & 7) != 0)
    {
      uint64_t v25 = (int *)(v22 & 0xFFFFFFFFFFFFFFF8);
      if ((v22 & 7) == 3 && v25 != 0)
      {
        uint64_t v32 = *v25;
        int v31 = (uint64_t *)(v25 + 2);
        uint64_t v30 = v32;
        goto LABEL_33;
      }
LABEL_32:
      int v31 = 0;
      uint64_t v30 = 0;
      goto LABEL_33;
    }
    v22 &= 0xFFFFFFFFFFFFFFF8;
    *unsigned int v23 = v22;
    int v31 = v23;
    uint64_t v30 = 1;
LABEL_33:
    if (v28 != v30) {
      goto LABEL_42;
    }
    if (v28) {
      break;
    }
LABEL_67:
    if (++v16 == v15)
    {
      llvm::MachineInstr::setMemRefs((uint64_t)this, (uint64_t *)a2, v45, v46);
      goto LABEL_86;
    }
  }
  uint64_t v27 = 8 * v28;
  while (sub_1CD535C24(*v19, *v31))
  {
    ++v19;
    ++v31;
    v27 -= 8;
    if (!v27) {
      goto LABEL_67;
    }
  }
  unint64_t v22 = *v23;
LABEL_42:
  if (v22 < 8) {
    goto LABEL_85;
  }
  if ((v22 & 7) == 0)
  {
    v22 &= 0xFFFFFFFFFFFFFFF8;
    *unsigned int v23 = v22;
    if (v22) {
      goto LABEL_49;
    }
    unint64_t v36 = 0;
    goto LABEL_62;
  }
  unsigned int v33 = (_DWORD *)(v22 & 0xFFFFFFFFFFFFFFF8);
  BOOL v34 = (v22 & 7) != 3 || v33 == 0;
  if (!v34 && *v33)
  {
LABEL_49:
    if ((v22 & 7) != 0)
    {
      if ((v22 & 0xFFFFFFFFFFFFFFF8) != 0) {
        unint64_t v35 = (v22 & 0xFFFFFFFFFFFFFFF8) + 8;
      }
      else {
        unint64_t v35 = 0;
      }
      if ((v22 & 7) == 3) {
        unint64_t v36 = (unsigned char *)v35;
      }
      else {
        unint64_t v36 = 0;
      }
LABEL_56:
      if ((v22 & 7) != 0)
      {
        unsigned int v23 = 0;
        if ((v22 & 7) == 3 && (uint64_t v37 = (int *)(v22 & 0xFFFFFFFFFFFFFFF8), (v22 & 0xFFFFFFFFFFFFFFF8) != 0))
        {
          unint64_t v22 = *v37;
          unsigned int v23 = (uint64_t *)(v37 + 2);
        }
        else
        {
          unint64_t v22 = 0;
        }
      }
      else
      {
        *unsigned int v23 = v22 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v22 = 1;
      }
LABEL_66:
      sub_1CC188254((unsigned int *)&v45, v36, &v23[v22]);
      goto LABEL_67;
    }
    unint64_t v36 = v23;
    v22 &= 0xFFFFFFFFFFFFFFF8;
    *unsigned int v23 = v22;
    if (v22) {
      goto LABEL_56;
    }
    unint64_t v36 = v23;
LABEL_62:
    unsigned int v23 = 0;
    goto LABEL_66;
  }
LABEL_85:
  llvm::MachineInstr::dropMemRefs((uint64_t)this, a2);
LABEL_86:
  if (v45 != v47) {
    free(v45);
  }
}

uint64_t llvm::MachineInstr::setPreInstrSymbol(uint64_t this, llvm::MachineFunction *a2, llvm::MCSymbol *a3)
{
  char v4 = (unint64_t *)(this + 48);
  unint64_t v5 = *(void *)(this + 48);
  if (v5 < 8) {
    goto LABEL_12;
  }
  BOOL v6 = (llvm::MCSymbol *)(v5 & 0xFFFFFFFFFFFFFFF8);
  if ((*(void *)(this + 48) & 7) != 1 || v6 == 0)
  {
    BOOL v8 = (*(void *)(this + 48) & 7) != 3 || v6 == 0;
    if (!v8 && *((unsigned char *)v6 + 4))
    {
      BOOL v6 = (llvm::MCSymbol *)*((void *)v6 + *(int *)v6 + 1);
      goto LABEL_13;
    }
LABEL_12:
    BOOL v6 = 0;
  }
LABEL_13:
  if (v6 == a3) {
    return this;
  }
  uint64_t v9 = *(void *)(this + 48) & 7;
  if (a3 || v9 != 1)
  {
    if (v5 < 8)
    {
      char v4 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
    }
    else
    {
      if ((v5 & 7) == 0)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        unint64_t *v4 = v5 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v12 = 1;
        return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, (uint64_t)a3, v13, v14);
      }
      BOOL v10 = v9 != 3;
      BOOL v11 = (unsigned __int8 *)(v5 & 0xFFFFFFFFFFFFFFF8);
      if (!v11) {
        BOOL v10 = 1;
      }
      if (v10)
      {
        char v4 = 0;
        uint64_t v12 = 0;
      }
      else
      {
        char v4 = (unint64_t *)(v11 + 8);
        uint64_t v12 = *(int *)v11;
      }
      BOOL v15 = v9 != 2 || v11 == 0;
      char v16 = v15;
      char v17 = v10 | v16 ^ 1;
      if (v15) {
        uint64_t v13 = 0;
      }
      else {
        uint64_t v13 = (uint64_t)v11;
      }
      if ((v17 & 1) == 0)
      {
        uint64_t v13 = v11[5] ? *(void *)&v11[8 * *(int *)v11 + 8 + 8 * v11[4]] : 0;
        if (v11[6])
        {
          uint64_t v14 = *(void *)&v11[8 * *(int *)v11 + 8 + 8 * v11[5] + 8 * v11[4]];
          return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, (uint64_t)a3, v13, v14);
        }
      }
    }
    uint64_t v14 = 0;
    return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, (uint64_t)a3, v13, v14);
  }
  unint64_t *v4 = 0;
  return this;
}

uint64_t llvm::MachineInstr::setPostInstrSymbol(uint64_t this, llvm::MachineFunction *a2, llvm::MCSymbol *a3)
{
  char v4 = (unint64_t *)(this + 48);
  unint64_t v5 = *(void *)(this + 48);
  if (v5 < 8) {
    goto LABEL_12;
  }
  BOOL v6 = (unsigned __int8 *)(v5 & 0xFFFFFFFFFFFFFFF8);
  if ((*(void *)(this + 48) & 7) != 2 || v6 == 0)
  {
    BOOL v8 = (*(void *)(this + 48) & 7) != 3 || v6 == 0;
    if (!v8 && v6[5])
    {
      BOOL v6 = *(unsigned __int8 **)&v6[8 * *(int *)v6 + 8 + 8 * v6[4]];
      goto LABEL_13;
    }
LABEL_12:
    BOOL v6 = 0;
  }
LABEL_13:
  if (v6 == (unsigned __int8 *)a3) {
    return this;
  }
  uint64_t v9 = *(void *)(this + 48) & 7;
  if (a3 || v9 != 2)
  {
    if (v5 < 8)
    {
      char v4 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 0;
    }
    else
    {
      if ((v5 & 7) == 0)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        unint64_t *v4 = v5 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v12 = 1;
        return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, v13, (uint64_t)a3, v14);
      }
      BOOL v10 = v9 != 3;
      BOOL v11 = (unsigned char *)(v5 & 0xFFFFFFFFFFFFFFF8);
      if (!v11) {
        BOOL v10 = 1;
      }
      if (v10)
      {
        char v4 = 0;
        uint64_t v12 = 0;
      }
      else
      {
        char v4 = (unint64_t *)(v11 + 8);
        uint64_t v12 = *(int *)v11;
      }
      BOOL v15 = v9 != 1 || v11 == 0;
      char v16 = v15;
      char v17 = v10 | v16 ^ 1;
      if (v15) {
        uint64_t v13 = 0;
      }
      else {
        uint64_t v13 = (uint64_t)v11;
      }
      if ((v17 & 1) == 0)
      {
        uint64_t v13 = v11[4] ? *(void *)&v11[8 * *(int *)v11 + 8] : 0;
        if (v11[6])
        {
          uint64_t v14 = *(void *)&v11[8 * *(int *)v11 + 8 + 8 * v11[5] + 8 * v11[4]];
          return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, v13, (uint64_t)a3, v14);
        }
      }
    }
    uint64_t v14 = 0;
    return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v12, v13, (uint64_t)a3, v14);
  }
  unint64_t *v4 = 0;
  return this;
}

uint64_t llvm::MachineInstr::setHeapAllocMarker(uint64_t this, llvm::MachineFunction *a2, llvm::MDNode *a3)
{
  char v4 = (void *)(this + 48);
  unint64_t v5 = *(void *)(this + 48);
  if (v5 < 8)
  {
    if (a3)
    {
      uint64_t v12 = 0;
      char v4 = 0;
      uint64_t v11 = 0;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v6 = *(void *)(this + 48) & 7;
    BOOL v7 = v6 != 3;
    BOOL v8 = (unsigned char *)(v5 & 0xFFFFFFFFFFFFFFF8);
    BOOL v9 = v8 == 0;
    if (!v8) {
      BOOL v7 = 1;
    }
    if (v7 || !v8[6]) {
      BOOL v10 = 0;
    }
    else {
      BOOL v10 = *(llvm::MDNode **)&v8[8 * *(int *)v8 + 8 + 8 * (v8[5] + v8[4])];
    }
    if (v10 != a3)
    {
      if (v6)
      {
        if (v7)
        {
          char v4 = 0;
          uint64_t v11 = 0;
        }
        else
        {
          char v4 = v8 + 8;
          uint64_t v11 = *(int *)v8;
        }
        if (v6 == 1 && v8)
        {
          uint64_t v13 = 0;
          uint64_t v12 = (uint64_t)v8;
          return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v11, v12, v13, (uint64_t)a3);
        }
        if (!v7)
        {
          if (v8[4]) {
            uint64_t v12 = *(void *)&v8[8 * *(int *)v8 + 8];
          }
          else {
            uint64_t v12 = 0;
          }
          if (v8[5])
          {
            uint64_t v13 = *(void *)&v8[8 * *(int *)v8 + 8 + 8 * v8[4]];
            return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v11, v12, v13, (uint64_t)a3);
          }
          goto LABEL_12;
        }
LABEL_19:
        uint64_t v12 = 0;
        if (v6 != 2 || v9) {
          uint64_t v13 = 0;
        }
        else {
          uint64_t v13 = (uint64_t)v8;
        }
        return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v11, v12, v13, (uint64_t)a3);
      }
      void *v4 = v8;
      uint64_t v11 = 1;
      if (v8)
      {
        uint64_t v6 = 0;
        BOOL v9 = 0;
        goto LABEL_19;
      }
      uint64_t v12 = 0;
LABEL_12:
      uint64_t v13 = 0;
      return llvm::MachineInstr::setExtraInfo(this, (uint64_t)a2, v4, v11, v12, v13, (uint64_t)a3);
    }
  }
  return this;
}

const llvm::MachineInstr *llvm::MachineInstr::cloneInstrSymbols(const llvm::MachineInstr *this, llvm::MachineFunction *a2, const llvm::MachineInstr *a3)
{
  if (this == a3) {
    return this;
  }
  uint64_t v6 = this;
  unint64_t v7 = *((void *)a3 + 6);
  if (v7 < 8) {
    goto LABEL_13;
  }
  BOOL v8 = (llvm::MCSymbol *)(v7 & 0xFFFFFFFFFFFFFFF8);
  if ((v7 & 7) != 1 || v8 == 0)
  {
    BOOL v10 = (v7 & 7) != 3 || v8 == 0;
    if (!v10 && *((unsigned char *)v8 + 4))
    {
      BOOL v8 = (llvm::MCSymbol *)*((void *)v8 + *(int *)v8 + 1);
      goto LABEL_14;
    }
LABEL_13:
    BOOL v8 = 0;
  }
LABEL_14:
  llvm::MachineInstr::setPreInstrSymbol((uint64_t)this, a2, v8);
  unint64_t v11 = *((void *)a3 + 6);
  if (v11 < 8)
  {
LABEL_23:
    BOOL v15 = 0;
    goto LABEL_24;
  }
  uint64_t v12 = *((void *)a3 + 6) & 7;
  uint64_t v13 = (llvm::MCSymbol *)(v11 & 0xFFFFFFFFFFFFFFF8);
  BOOL v14 = v12 != 2 || v13 == 0;
  BOOL v15 = v13;
  if (v14)
  {
    BOOL v15 = 0;
    if (v12 == 3)
    {
      if (v13)
      {
        if (!*((unsigned char *)v13 + 5)) {
          goto LABEL_23;
        }
        BOOL v15 = (llvm::MCSymbol *)*((void *)v13 + *(int *)v13 + *((unsigned __int8 *)v13 + 4) + 1);
      }
    }
  }
LABEL_24:
  llvm::MachineInstr::setPostInstrSymbol((uint64_t)v6, a2, v15);
  unint64_t v16 = *((void *)a3 + 6);
  if (v16 < 8)
  {
LABEL_28:
    char v17 = 0;
    goto LABEL_29;
  }
  char v17 = 0;
  if ((*((void *)a3 + 6) & 7) == 3)
  {
    uint64_t v18 = (unsigned char *)(v16 & 0xFFFFFFFFFFFFFFF8);
    if (v18)
    {
      if (v18[6])
      {
        char v17 = *(llvm::MDNode **)&v18[8 * *(int *)v18 + 8 + 8 * (v18[5] + v18[4])];
        goto LABEL_29;
      }
      goto LABEL_28;
    }
  }
LABEL_29:
  return (const llvm::MachineInstr *)llvm::MachineInstr::setHeapAllocMarker((uint64_t)v6, a2, v17);
}

llvm::MachineInstr *llvm::MachineInstr::removeFromBundle(llvm::MachineBasicBlock **this)
{
  return llvm::MachineBasicBlock::remove_instr(this[3], (llvm::MachineInstr *)this);
}

uint64_t llvm::MachineInstr::bundleWithSucc(uint64_t this)
{
  *(_WORD *)(this + 44) |= 8u;
  *(_WORD *)(*(void *)(this + 8) + 44) |= 4u;
  return this;
}

uint64_t llvm::MachineInstr::unbundleFromPred(uint64_t this)
{
  *(_WORD *)(this + 44) &= ~4u;
  *(_WORD *)((*(void *)this & 0xFFFFFFFFFFFFFFF8) + 44) &= ~8u;
  return this;
}

uint64_t llvm::MachineInstr::getInlineAsmDialect(llvm::MachineInstr *this)
{
  return (*(_DWORD *)(*((void *)this + 4) + 48) >> 2) & 1;
}

uint64_t llvm::MachineInstr::findInlineAsmFlagIdx(llvm::MachineInstr *this, unsigned int a2, unsigned int *a3)
{
  if (a2 >= 2)
  {
    unsigned int v3 = *((_DWORD *)this + 10);
    if (v3 >= 3)
    {
      unsigned int v4 = 0;
      uint64_t v5 = *((void *)this + 4);
      uint64_t result = 2;
      while (*(unsigned char *)(v5 + 32 * result) == 1)
      {
        unsigned int v7 = result + ((unsigned __int16)*(_DWORD *)(v5 + 32 * result + 16) >> 3) + 1;
        if (v7 > a2)
        {
          if (a3) {
            *a3 = v4;
          }
          return result;
        }
        ++v4;
        uint64_t result = result + ((unsigned __int16)*(_DWORD *)(v5 + 32 * result + 16) >> 3) + 1;
        if (v7 >= v3) {
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t llvm::MachineInstr::getDebugLabel(llvm::MachineInstr *this)
{
  return *(void *)(*((void *)this + 4) + 16);
}

uint64_t llvm::MachineInstr::getRegClassConstraintEffectForVReg(unint64_t a1, int a2, uint64_t a3, llvm::TargetInstrInfo *a4, llvm::TargetRegisterInfo *a5, int a6)
{
  uint64_t RegClassConstraintEffect = a3;
  if (a6)
  {
    sub_1CC301138(&v25, a1);
    if (RegClassConstraintEffect)
    {
      uint64_t v12 = v27;
      uint64_t v11 = v28;
      if (v27 != v28)
      {
        do
        {
          uint64_t v13 = *(llvm::MachineInstr **)(v12 + 8);
          unint64_t v14 = v12 - *(void *)(v25 + 32);
          uint64_t v15 = *((void *)v13 + 4);
          uint64_t v16 = (v14 >> 5);
          if (!*(unsigned char *)(v15 + 32 * v16) && *(_DWORD *)(v15 + 32 * v16 + 4) == a2)
          {
            uint64_t RegClassConstraintEffect = llvm::MachineInstr::getRegClassConstraintEffect(v13, v14 >> 5, RegClassConstraintEffect, a4, a5);
            uint64_t v12 = v27;
            uint64_t v11 = v28;
          }
          v12 += 32;
          uint64_t v27 = v12;
          if (v12 == v11)
          {
            uint64_t v18 = *(void *)(v25 + 8);
            if (v18 == v26)
            {
              uint64_t v12 = v11;
            }
            else
            {
              uint64_t v12 = v11;
              if ((*(_WORD *)(v18 + 44) & 4) != 0)
              {
                while (1)
                {
                  uint64_t v12 = *(void *)(v18 + 32);
                  uint64_t v19 = *(unsigned int *)(v18 + 40);
                  uint64_t v11 = v12 + 32 * v19;
                  if (v19) {
                    break;
                  }
                  uint64_t v18 = *(void *)(v18 + 8);
                  if (v18 == v26 || (*(_WORD *)(v18 + 44) & 4) == 0)
                  {
                    uint64_t v27 = v12;
                    uint64_t v28 = v12 + 32 * v19;
                    uint64_t v11 = v28;
                    goto LABEL_21;
                  }
                }
                uint64_t v27 = *(void *)(v18 + 32);
                uint64_t v28 = v12 + 32 * v19;
                uint64_t v25 = v18;
                continue;
              }
            }
LABEL_21:
            uint64_t v25 = v26;
          }
        }
        while (v12 != v11 && RegClassConstraintEffect != 0);
      }
    }
  }
  else if (a3)
  {
    unint64_t v20 = *(unsigned int *)(a1 + 40);
    if (v20)
    {
      uint64_t v21 = 0;
      unint64_t v22 = 1;
      do
      {
        uint64_t v23 = *(void *)(a1 + 32);
        if (!*(unsigned char *)(v23 + v21) && *(_DWORD *)(v23 + v21 + 4) == a2) {
          uint64_t RegClassConstraintEffect = llvm::MachineInstr::getRegClassConstraintEffect((llvm::MachineInstr *)a1, (v22 - 1), RegClassConstraintEffect, a4, a5);
        }
        if (v22 >= v20) {
          break;
        }
        ++v22;
        v21 += 32;
      }
      while (RegClassConstraintEffect);
    }
  }
  return RegClassConstraintEffect;
}

uint64_t llvm::MachineInstr::getRegClassConstraintEffect(llvm::MachineInstr *a1, uint64_t a2, uint64_t a3, llvm::TargetInstrInfo *a4, llvm::TargetRegisterInfo *a5)
{
  unsigned int v7 = a2;
  uint64_t RegClassConstraint = llvm::MachineInstr::getRegClassConstraint(a1, a2, a4, a5);
  uint64_t v10 = RegClassConstraint;
  unsigned int v11 = *(_DWORD *)(*((void *)a1 + 4) + 32 * v7);
  if (((v11 >> 8) & 0xFFF) != 0)
  {
    uint64_t v12 = *(void *)a5;
    if (RegClassConstraint)
    {
      uint64_t v13 = *(uint64_t (**)(llvm::TargetRegisterInfo *, uint64_t, uint64_t))(v12 + 184);
      unint64_t v14 = a5;
      uint64_t v15 = a3;
    }
    else
    {
      uint64_t v13 = *(uint64_t (**)(llvm::TargetRegisterInfo *, uint64_t, uint64_t))(v12 + 200);
      unint64_t v14 = a5;
      uint64_t v15 = a3;
      uint64_t v10 = (v11 >> 8) & 0xFFF;
    }
    return v13(v14, v15, v10);
  }
  else if (RegClassConstraint)
  {
    return llvm::TargetRegisterInfo::getCommonSubClass((uint64_t)a5, a3, RegClassConstraint);
  }
  else
  {
    return a3;
  }
}

uint64_t llvm::MachineInstr::getBundleSize(llvm::MachineInstr *this)
{
  if ((*((_WORD *)this + 22) & 8) == 0) {
    return 0;
  }
  LODWORD(v1) = 0;
  do
  {
    uint64_t v1 = (v1 + 1);
    this = (llvm::MachineInstr *)*((void *)this + 1);
  }
  while ((*((_WORD *)this + 22) & 8) != 0);
  return v1;
}

uint64_t llvm::MachineInstr::findFirstPredOperandIdx(llvm::MachineInstr *this)
{
  uint64_t v1 = *((void *)this + 2);
  if ((*(unsigned char *)(v1 + 10) & 0x40) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *((unsigned int *)this + 10);
  if (!v3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  unsigned int v4 = (char *)(*(void *)(v1 + 40) + 2);
  while (1)
  {
    char v5 = *v4;
    v4 += 6;
    if ((v5 & 2) != 0) {
      break;
    }
    if (v3 == ++result) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t llvm::MachineInstr::isConstantValuePHI(llvm::MachineInstr *this)
{
  int v1 = **((unsigned __int16 **)this + 2);
  if (v1 != 69 && v1 != 0) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 4);
  uint64_t result = *(unsigned int *)(v4 + 36);
  unsigned int v6 = *((_DWORD *)this + 10);
  if (v6 >= 4)
  {
    unsigned int v7 = 3;
    while (*(_DWORD *)(v4 + 32 * v7 + 4) == result)
    {
      v7 += 2;
      if (v7 >= v6) {
        return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t llvm::MachineInstr::hasComplexRegisterTies(llvm::MachineInstr *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (*(_WORD *)v1 == 31) {
    return 1;
  }
  uint64_t v4 = *((unsigned int *)this + 10);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    for (uint64_t i = 4; ; i += 6)
    {
      int v8 = *(_DWORD *)(*((void *)this + 4) + v5);
      if ((v8 & 0x10000FF) == 0)
      {
        if (v6 >= *(unsigned __int16 *)(v1 + 2))
        {
          int v10 = -1;
        }
        else
        {
          __int16 v9 = *(_WORD *)(*(void *)(v1 + 40) + i);
          int v10 = (v9 & 1) != 0 ? v9 >> 4 : -1;
        }
        int v11 = (v8 & 0xF00000) != 0 ? llvm::MachineInstr::findTiedOperandIdx(this, v6) : -1;
        if (v10 != v11) {
          break;
        }
      }
      ++v6;
      v5 += 32;
      if (v4 == v6) {
        return 0;
      }
    }
    return 1;
  }
  return 0;
}

uint64_t llvm::MachineInstr::getTypeToPrint(uint64_t a1, unsigned int a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v4 + 32 * a2)) {
    return 0;
  }
  uint64_t v7 = a2;
  uint64_t v8 = *(void *)(a1 + 16);
  if ((*(unsigned char *)(v8 + 8) & 2) != 0
    || *(unsigned __int16 *)(v8 + 2) <= a2
    || (unsigned int v9 = *(unsigned __int8 *)(*(void *)(v8 + 40) + 6 * a2 + 3) - 6, v9 >= 6))
  {
    int v12 = *(_DWORD *)(v4 + 32 * v7 + 4);
    if (v12 < 0)
    {
      uint64_t v13 = v12 & 0x7FFFFFFF;
      if (v13 < *(_DWORD *)(a4 + 432)) {
        return *(void *)(*(void *)(a4 + 424) + 8 * v13);
      }
    }
    return 0;
  }
  unint64_t v10 = *a3;
  if ((*a3 & 1) != 0
     ? (1 << v9) & (v10 >> 1) & ~(-1 << (v10 >> 58))
     : *(void *)(*(void *)v10 + 8 * (v9 >> 6)) & (1 << v9))
  {
    return 0;
  }
  int v14 = *(_DWORD *)(v4 + 32 * v7 + 4);
  if ((v14 & 0x80000000) == 0) {
    return 0;
  }
  uint64_t v15 = v14 & 0x7FFFFFFF;
  if (v15 >= *(_DWORD *)(a4 + 432)) {
    return 0;
  }
  uint64_t v5 = *(void *)(*(void *)(a4 + 424) + 8 * v15);
  if ((v5 & 0xFFFFFFFFFFFFFFF9) != 0) {
    sub_1CBFD7E40(a3, v9);
  }
  return v5;
}

void llvm::MachineInstr::dump(llvm::MachineInstr *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = sub_1CB8E509C(v2, "  ");
  uint64_t v4 = llvm::dbgs(v3);

  llvm::MachineInstr::print(this, v4, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
}

void llvm::MachineInstr::print(llvm::MachineInstr *this, llvm::raw_ostream *a2, const llvm::TargetRegisterInfo *a3, char a4, char a5, int a6, const llvm::TargetInstrInfo *a7)
{
  uint64_t v7 = a7;
  v18[14] = *(const llvm::Function **)MEMORY[0x1E4F143B8];
  uint64_t v14 = *((void *)this + 3);
  if (v14 && (uint64_t v15 = *(const llvm::Function ***)(v14 + 32)) != 0)
  {
    uint64_t v16 = *v15;
    uint64_t v17 = *((void *)*v15 + 5);
    if (!a7) {
      uint64_t v7 = (const llvm::TargetInstrInfo *)(*(uint64_t (**)(const llvm::Function *))(*(void *)v15[2] + 104))(v15[2]);
    }
    llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)v18, v17, 1);
    llvm::ModuleSlotTracker::incorporateFunction(v18, v16);
  }
  else
  {
    llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)v18, 0, 1);
  }
  llvm::MachineInstr::print(this, a2, (llvm::ModuleSlotTracker *)v18, a3, a4, a5, a6, v7);
  llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v18);
}

void llvm::MachineInstr::dumprImpl(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, llvm::SmallPtrSetImplBase *a5)
{
  if (a3 < a4)
  {
    unint64_t v10 = (llvm *)sub_1CB89694C(a5, a1);
    if (v11)
    {
      if (a3)
      {
        int v12 = (llvm::formatted_raw_ostream *)llvm::fdbgs(v10);
        unint64_t v10 = llvm::formatted_raw_ostream::PadToColumn(v12, 2 * a3);
      }
      uint64_t v13 = (llvm::raw_ostream *)llvm::fdbgs(v10);
      llvm::MachineInstr::print((llvm::MachineInstr *)a1, v13, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
      uint64_t v14 = *(unsigned int *)(a1 + 40);
      if (v14)
      {
        uint64_t v15 = *(void *)(a1 + 32);
        uint64_t v16 = 32 * v14;
        uint64_t v17 = (unsigned int *)(v15 + 4);
        do
        {
          if ((*(v17 - 1) & 0x10000FF) == 0 && *v17 - 1 >= 0x3FFFFFFF)
          {
            Uniqueuint64_t VRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(a2, *v17);
            if (UniqueVRegDef) {
              llvm::MachineInstr::dumprImpl(UniqueVRegDef, a2, a3 + 1, a4, a5);
            }
          }
          v17 += 8;
          v16 -= 32;
        }
        while (v16);
      }
    }
  }
}

void llvm::MachineInstr::dumpr(llvm::MachineInstr *this, const llvm::MachineRegisterInfo *a2, uint64_t a3)
{
  uint64_t v3 = v7;
  uint64_t v4 = v7;
  uint64_t v5 = 16;
  int v6 = 0;
  llvm::MachineInstr::dumprImpl((uint64_t)this, (uint64_t)a2, 0, a3, (llvm::SmallPtrSetImplBase *)&v3);
  if (v4 != v3) {
    free(v4);
  }
}

char *sub_1CD535588(int a1)
{
  return off_1E682F6F8[a1 - 1];
}

uint64_t llvm::MachineInstr::emitError(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    unsigned int v5 = v3 - 1;
    while (1)
    {
      uint64_t v6 = v5;
      if (*(unsigned char *)(v4 + 32 * v5) == 14)
      {
        uint64_t v7 = *(void *)(v4 + 32 * v5 + 16);
        if (v7)
        {
          uint64_t v8 = *(unsigned int *)(v7 + 8);
          if (v8)
          {
            uint64_t v9 = *(void *)(v7 - 8 * v8);
            if (*(unsigned char *)v9 == 1)
            {
              uint64_t v10 = *(void *)(v9 + 128);
              if (*(unsigned char *)(v10 + 16) == 16) {
                break;
              }
            }
          }
        }
      }
      --v5;
      if (!v6) {
        goto LABEL_9;
      }
    }
    uint64_t v16 = (uint64_t *)(v10 + 24);
    if (*(_DWORD *)(v10 + 32) >= 0x41u) {
      uint64_t v16 = (uint64_t *)*v16;
    }
    uint64_t v11 = *v16;
  }
  else
  {
LABEL_9:
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(void *)(a1 + 24);
  if (!v12 || (uint64_t v13 = *(void *)(v12 + 32)) == 0) {
    llvm::report_fatal_error(a2, a3, (const llvm::Twine *)1);
  }
  uint64_t v14 = **(void **)(*(void *)(v13 + 32) + 2064);
  __int16 v18 = 261;
  v17[0] = a2;
  v17[1] = a3;
  return llvm::LLVMContext::emitError(v14, v11, (uint64_t)v17);
}

llvm::MachineFunction *llvm::BuildMI(uint64_t a1, unint64_t *a2, unsigned __int8 **a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(llvm::MachineFunction **)(a1 + 32);
  llvm::BuildMI(v10, a3, a4, a5, a6, a7, a8);
  unint64_t v12 = v11;
  llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)(a1 + 40), v11);
  unint64_t v13 = *a2 & 0xFFFFFFFFFFFFFFF8;
  *(void *)unint64_t v12 = v13 | *(void *)v12 & 7;
  *(void *)(v12 + 8) = a2;
  *(void *)(v13 + 8) = v12;
  *a2 = *a2 & 7 | v12;
  return v10;
}

llvm::MachineFunction *llvm::BuildMI(uint64_t a1, unint64_t *a2, unsigned __int8 **a3, uint64_t a4, int a5, const llvm::MachineOperand *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(llvm::MachineFunction **)(a1 + 32);
  llvm::BuildMI(v10, a3, a4, a5, a6, a7, a8);
  unint64_t v12 = v11;
  llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)(a1 + 40), v11);
  unint64_t v13 = *a2 & 0xFFFFFFFFFFFFFFF8;
  *(void *)unint64_t v12 = v13 | *(void *)v12 & 7;
  *(void *)(v12 + 8) = a2;
  *(void *)(v13 + 8) = v12;
  *a2 = *a2 & 7 | v12;
  return v10;
}

llvm::MachineInstr *llvm::buildDbgValueForSpill(uint64_t a1, unint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v10 = sub_1CC3560C4(a3, a5);
  unint64_t v12 = sub_1CB84B588(a1, a2, (unsigned __int8 **)(a3 + 56), *(void *)(a3 + 16));
  unint64_t v13 = v11;
  int v14 = **(unsigned __int16 **)(a3 + 16);
  if (v14 == 13)
  {
    LODWORD(v21) = 5;
    *((void *)&v21 + 1) = 0;
    LODWORD(v22) = a4;
    llvm::MachineInstr::addOperand(v11, v12, (const llvm::MachineOperand *)&v21);
    LODWORD(v21) = 1;
    *((void *)&v21 + 1) = 0;
    *(void *)&long long v22 = 0;
    llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v21);
    int v14 = **(unsigned __int16 **)(a3 + 16);
  }
  uint64_t v15 = *(void *)(*(void *)(a3 + 32) + ((unint64_t)(v14 != 14) << 6) + 16);
  LODWORD(v21) = 14;
  *((void *)&v21 + 1) = 0;
  *(void *)&long long v22 = v15;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v21);
  LODWORD(v21) = 14;
  *((void *)&v21 + 1) = 0;
  *(void *)&long long v22 = v10;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v21);
  if (**(_WORD **)(a3 + 16) == 14)
  {
    uint64_t v16 = *(unsigned int *)(a3 + 40);
    if (v16 != 2)
    {
      uint64_t v18 = *(void *)(a3 + 32) + 64;
      uint64_t v19 = 32 * v16 - 64;
      do
      {
        if (*(unsigned char *)v18 || *(_DWORD *)(v18 + 4) != a5)
        {
          long long v20 = *(_OWORD *)(v18 + 16);
          long long v21 = *(_OWORD *)v18;
          long long v22 = v20;
        }
        else
        {
          LODWORD(v21) = 5;
          *((void *)&v21 + 1) = 0;
          LODWORD(v22) = a4;
        }
        llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v21);
        v18 += 32;
        v19 -= 32;
      }
      while (v19);
    }
  }
  return v13;
}

llvm::MachineInstr *llvm::buildDbgValueForSpill(uint64_t a1, unint64_t *a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v10 = sub_1CC3563EC(a3, *(uint64_t **)a5, *(_DWORD *)(a5 + 8));
  unint64_t v12 = sub_1CB84B588(a1, a2, (unsigned __int8 **)(a3 + 56), *(void *)(a3 + 16));
  unint64_t v13 = v11;
  int v14 = **(unsigned __int16 **)(a3 + 16);
  if (v14 == 13)
  {
    LODWORD(v26) = 5;
    *((void *)&v26 + 1) = 0;
    LODWORD(v27) = a4;
    llvm::MachineInstr::addOperand(v11, v12, (const llvm::MachineOperand *)&v26);
    LODWORD(v26) = 1;
    *((void *)&v26 + 1) = 0;
    *(void *)&long long v27 = 0;
    llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v26);
    int v14 = **(unsigned __int16 **)(a3 + 16);
  }
  uint64_t v15 = *(void *)(*(void *)(a3 + 32) + ((unint64_t)(v14 != 14) << 6) + 16);
  LODWORD(v26) = 14;
  *((void *)&v26 + 1) = 0;
  *(void *)&long long v27 = v15;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v26);
  LODWORD(v26) = 14;
  *((void *)&v26 + 1) = 0;
  *(void *)&long long v27 = v10;
  llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v26);
  if (**(_WORD **)(a3 + 16) == 14)
  {
    uint64_t v16 = *(unsigned int *)(a3 + 40);
    if (v16 != 2)
    {
      uint64_t v17 = *(void *)(a3 + 32);
      uint64_t v18 = (long long *)(v17 + 32 * v16);
      uint64_t v19 = (long long *)(v17 + 64);
      do
      {
        long long v20 = *(uint64_t **)a5;
        uint64_t v21 = *(unsigned int *)(a5 + 8);
        if (v21)
        {
          uint64_t v22 = 8 * v21;
          uint64_t v23 = *(uint64_t **)a5;
          while ((long long *)*v23 != v19)
          {
            ++v23;
            v22 -= 8;
            if (!v22)
            {
              uint64_t v23 = &v20[v21];
              break;
            }
          }
        }
        else
        {
          uint64_t v23 = *(uint64_t **)a5;
        }
        if (v21 == v23 - v20)
        {
          long long v24 = v19[1];
          long long v26 = *v19;
          long long v27 = v24;
        }
        else
        {
          LODWORD(v26) = 5;
          *((void *)&v26 + 1) = 0;
          LODWORD(v27) = a4;
        }
        llvm::MachineInstr::addOperand(v13, v12, (const llvm::MachineOperand *)&v26);
        v19 += 2;
      }
      while (v19 != v18);
    }
  }
  return v13;
}

uint64_t llvm::MachineInstr::getFoldedRestoreSize(llvm::MachineInstr *this, const llvm::TargetInstrInfo *a2)
{
  uint64_t v9[2] = *MEMORY[0x1E4F143B8];
  v8[0] = v9;
  v8[1] = (void *)0x200000000;
  if ((*(unsigned int (**)(const llvm::TargetInstrInfo *, llvm::MachineInstr *, void **))(*(void *)a2 + 88))(a2, this, v8))
  {
    int v3 = sub_1CC356F78((uint64_t)v8, *(void *)(*(void *)(*((void *)this + 3) + 32) + 56));
    unsigned int v4 = v3 & 0xFFFFFF00;
    int v5 = v3;
    uint64_t v6 = 0x100000000;
  }
  else
  {
    int v5 = 0;
    uint64_t v6 = 0;
    unsigned int v4 = 0;
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
  return v6 | v4 | v5;
}

uint64_t llvm::MachineInstr::getDebugInstrNum(llvm::MachineInstr *this)
{
  uint64_t v1 = *((unsigned int *)this + 16);
  if (!v1)
  {
    uint64_t v2 = *(void *)(*((void *)this + 3) + 32);
    uint64_t v1 = (*(_DWORD *)(v2 + 912) + 1);
    *(_DWORD *)(v2 + 912) = v1;
    *((_DWORD *)this + 16) = v1;
  }
  return v1;
}

BOOL sub_1CD535C24(uint64_t a1, uint64_t a2)
{
  if ((*(void *)a1 & 4) != 0) {
    unint64_t v2 = 0;
  }
  else {
    unint64_t v2 = *(void *)a1 & 0xFFFFFFFFFFFFFFF8;
  }
  if ((*(void *)a2 & 4) != 0) {
    unint64_t v3 = 0;
  }
  else {
    unint64_t v3 = *(void *)a2 & 0xFFFFFFFFFFFFFFF8;
  }
  if (v2 != v3) {
    return 0;
  }
  if ((*(void *)a1 & 0xFFFFFFFFFFFFFFF8 & ((uint64_t)(*(void *)a1 << 61) >> 63)) != (*(void *)a2 & 0xFFFFFFFFFFFFFFF8 & ((uint64_t)(*(void *)a2 << 61) >> 63))) {
    return 0;
  }
  unint64_t v7 = sub_1CB8F20C0(a1);
  if (v7 != sub_1CB8F20C0(a2)) {
    return 0;
  }
  if (*(void *)(a1 + 8) != *(void *)(a2 + 8)) {
    return 0;
  }
  if (*(unsigned __int16 *)(a1 + 32) != *(unsigned __int16 *)(a2 + 32)) {
    return 0;
  }
  if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_s64(*(int64x2_t *)(a1 + 40), *(int64x2_t *)(a2 + 40)), (int32x4_t)vceqq_s64(*(int64x2_t *)(a1 + 56), *(int64x2_t *)(a2 + 56)))), 0xFuLL))) & 1) == 0)return 0; {
  if (*(void *)(a1 + 72) != *(void *)(a2 + 72))
  }
    return 0;
  int Align = llvm::MachineMemOperand::getAlign((llvm::MachineMemOperand *)a1);
  if (Align != llvm::MachineMemOperand::getAlign((llvm::MachineMemOperand *)a2)) {
    return 0;
  }
  int AddrSpace = llvm::MachinePointerInfo::getAddrSpace((llvm::MachinePointerInfo *)a1);
  return AddrSpace == llvm::MachinePointerInfo::getAddrSpace((llvm::MachinePointerInfo *)a2);
}

uint64_t sub_1CD535D4C(void *a1, uint64_t a2, int a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (uint64_t (**)(void **))&unk_1F260E4D0;
  int v12 = a3;
  unint64_t v13 = (void **)&v11;
  uint64_t v3 = *(void *)(a2 + 32);
  if (**(_WORD **)(a2 + 16) == 14)
  {
    uint64_t v4 = v3 + 64;
    uint64_t v5 = *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v5 = 1;
    uint64_t v4 = *(void *)(a2 + 32);
  }
  v7[0] = v4;
  v7[1] = v3 + 32 * v5;
  uint64_t v10 = (void **)&v8;
  uint64_t v8 = (void (**)(void **))&unk_1F260E4D0;
  int v9 = a3;
  sub_1CC35718C(a1, v7, (uint64_t)&v8);
  if (v10 == (void **)&v8)
  {
    v8[4]((void **)&v8);
  }
  else if (v10)
  {
    (*((void (**)(void))*v10 + 5))();
  }
  uint64_t result = (uint64_t)v13;
  if (v13 == (void **)&v11) {
    return v11[4]((void **)&v11);
  }
  if (v13) {
    return (*((uint64_t (**)(void))*v13 + 5))();
  }
  return result;
}

void sub_1CD535EF0()
{
}

_DWORD *sub_1CD535F04(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1F260E4D0;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD535F50(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1F260E4D0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

BOOL sub_1CD535F80(uint64_t a1, uint64_t a2)
{
  return !*(unsigned char *)a2 && *(_DWORD *)(a2 + 4) == *(_DWORD *)(a1 + 8);
}

uint64_t sub_1CD535F9C(void *a1, void *a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2[1];
  v13[0] = *a2;
  v13[1] = v5;
  uint64_t v6 = (void *)a2[5];
  if (v6)
  {
    if (v6 == a2 + 2)
    {
      uint64_t v15 = v14;
      (*(void (**)(void *, void *))(*v6 + 24))(v6, v14);
    }
    else
    {
      uint64_t v15 = (void *)a2[5];
      a2[5] = 0;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v7 = a3[1];
  v10[0] = *a3;
  v10[1] = v7;
  uint64_t v8 = (void *)a3[5];
  if (v8)
  {
    if (v8 == a3 + 2)
    {
      int v12 = v11;
      (*(void (**)(void *, void *))(*v8 + 24))(v8, v11);
    }
    else
    {
      int v12 = (void *)a3[5];
      a3[5] = 0;
    }
  }
  else
  {
    int v12 = 0;
  }
  sub_1CD536194(a1, v13, v10);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
  if (v15) {
    return (*(uint64_t (**)(void))(*v15 + 40))();
  }
  return result;
}

void *sub_1CD536194(void *a1, void *a2, void *a3)
{
  *a1 = *a2;
  a1[1] = a2[1];
  uint64_t v5 = (void *)a2[5];
  if (v5)
  {
    if (v5 == a2 + 2)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void, void *))(*(void *)a2[5] + 24))(a2[5], a1 + 2);
    }
    else
    {
      a1[5] = v5;
      a2[5] = 0;
    }
  }
  else
  {
    a1[5] = 0;
  }
  a1[6] = *a3;
  a1[7] = a3[1];
  uint64_t v6 = (void *)a3[5];
  if (v6)
  {
    if (v6 == a3 + 2)
    {
      a1[11] = a1 + 8;
      (*(void (**)(void))(*(void *)a3[5] + 24))(a3[5]);
    }
    else
    {
      a1[11] = v6;
      a3[5] = 0;
    }
  }
  else
  {
    a1[11] = 0;
  }
  return a1;
}

void *sub_1CD536290(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  sub_1CC300F30((uint64_t)v8, a4);
  *a1 = a2;
  a1[1] = a3;
  if (v9)
  {
    if (v9 == v8)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void *))(v8[0] + 24))(v8);
    }
    else
    {
      a1[5] = (*(uint64_t (**)(void))(*v9 + 16))();
    }
  }
  else
  {
    a1[5] = 0;
  }
  sub_1CC3573E8((uint64_t)a1);
  if (v9 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v9)
  {
    (*(void (**)(void))(*v9 + 40))();
  }
  return a1;
}

void *sub_1CD5363F0(void *a1)
{
  unint64_t v2 = a1 + 8;
  uint64_t v3 = (void *)a1[11];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = (void *)a1[5];
  if (v4 == a1 + 2)
  {
    (*(void (**)(void *))(a1[2] + 32))(a1 + 2);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  return a1;
}

uint64_t sub_1CD5364DC@<X0>(uint64_t a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (uint64_t (**)(void **))&unk_1F260E518;
  int v12 = a2;
  unint64_t v13 = (void **)&v11;
  uint64_t v3 = *(void *)(a1 + 32);
  if (**(_WORD **)(a1 + 16) == 14)
  {
    uint64_t v4 = v3 + 64;
    uint64_t v5 = *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v5 = 1;
    uint64_t v4 = *(void *)(a1 + 32);
  }
  v7[0] = v4;
  v7[1] = v3 + 32 * v5;
  uint64_t v10 = (void **)&v8;
  uint64_t v8 = (void (**)(void **))&unk_1F260E518;
  int v9 = a2;
  sub_1CC35745C(v7, (uint64_t)&v8, a3);
  if (v10 == (void **)&v8)
  {
    v8[4]((void **)&v8);
  }
  else if (v10)
  {
    (*((void (**)(void))*v10 + 5))();
  }
  uint64_t result = (uint64_t)v13;
  if (v13 == (void **)&v11) {
    return v11[4]((void **)&v11);
  }
  if (v13) {
    return (*((uint64_t (**)(void))*v13 + 5))();
  }
  return result;
}

void sub_1CD536680()
{
}

_DWORD *sub_1CD536694(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_1F260E518;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD5366E0(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1F260E518;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

BOOL sub_1CD536710(uint64_t a1, uint64_t a2)
{
  return !*(unsigned char *)a2 && *(_DWORD *)(a2 + 4) == *(_DWORD *)(a1 + 8);
}

uint64_t sub_1CD53672C@<X0>(void *a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1[1];
  v13[0] = *a1;
  v13[1] = v5;
  uint64_t v6 = (void *)a1[5];
  if (v6)
  {
    if (v6 == a1 + 2)
    {
      uint64_t v15 = v14;
      (*(void (**)(void *, void *))(*v6 + 24))(v6, v14);
    }
    else
    {
      uint64_t v15 = (void *)a1[5];
      a1[5] = 0;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  uint64_t v7 = a2[1];
  v10[0] = *a2;
  v10[1] = v7;
  uint64_t v8 = (void *)a2[5];
  if (v8)
  {
    if (v8 == a2 + 2)
    {
      int v12 = v11;
      (*(void (**)(void *, void *))(*v8 + 24))(v8, v11);
    }
    else
    {
      int v12 = (void *)a2[5];
      a2[5] = 0;
    }
  }
  else
  {
    int v12 = 0;
  }
  sub_1CD536928(a3, v13, v10);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  uint64_t result = (uint64_t)v15;
  if (v15 == v14) {
    return (*(uint64_t (**)(void *))(v14[0] + 32))(v14);
  }
  if (v15) {
    return (*(uint64_t (**)(void))(*v15 + 40))();
  }
  return result;
}

void *sub_1CD536928(void *a1, void *a2, void *a3)
{
  *a1 = *a2;
  a1[1] = a2[1];
  uint64_t v5 = (void *)a2[5];
  if (v5)
  {
    if (v5 == a2 + 2)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void, void *))(*(void *)a2[5] + 24))(a2[5], a1 + 2);
    }
    else
    {
      a1[5] = v5;
      a2[5] = 0;
    }
  }
  else
  {
    a1[5] = 0;
  }
  a1[6] = *a3;
  a1[7] = a3[1];
  uint64_t v6 = (void *)a3[5];
  if (v6)
  {
    if (v6 == a3 + 2)
    {
      a1[11] = a1 + 8;
      (*(void (**)(void))(*(void *)a3[5] + 24))(a3[5]);
    }
    else
    {
      a1[11] = v6;
      a3[5] = 0;
    }
  }
  else
  {
    a1[11] = 0;
  }
  return a1;
}

void *sub_1CD536A24(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  sub_1CC357728((uint64_t)v8, a4);
  *a1 = a2;
  a1[1] = a3;
  if (v9)
  {
    if (v9 == v8)
    {
      a1[5] = a1 + 2;
      (*(void (**)(void *))(v8[0] + 24))(v8);
    }
    else
    {
      a1[5] = (*(uint64_t (**)(void))(*v9 + 16))();
    }
  }
  else
  {
    a1[5] = 0;
  }
  sub_1CC3576B4((uint64_t)a1);
  if (v9 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v9)
  {
    (*(void (**)(void))(*v9 + 40))();
  }
  return a1;
}

void *sub_1CD536B84(void *a1)
{
  unint64_t v2 = a1 + 8;
  uint64_t v3 = (void *)a1[11];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = (void *)a1[5];
  if (v4 == a1 + 2)
  {
    (*(void (**)(void *))(a1[2] + 32))(a1 + 2);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  return a1;
}

void llvm::initializeMachineLICMPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCEB18, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3577C0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCEB18, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializeEarlyMachineLICMPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCEB20, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC357878;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCEB20, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void *sub_1CD536D5C(void *a1)
{
  *a1 = &unk_1F260E560;
  unint64_t v2 = a1 + 71;
  uint64_t v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F260E5C8;
  uint64_t v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD536E44(void *a1)
{
  *a1 = &unk_1F260E5C8;
  unint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD536E98(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD536F2C(v11);
}

uint64_t sub_1CD536F2C(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD536F44(void *a1)
{
  sub_1CD536D5C(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD536F7C(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD536F88(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD536F98(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    uint64_t v4 = &unk_1F260E618;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD53701C(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD537030(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD537038(void *a1)
{
  *a1 = &unk_1F260E5C8;
  unint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD5370AC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD5370B4(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2);
}

uint64_t sub_1CD5370C8(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 48 * a2 + 16);
}

uint64_t sub_1CD5370DC(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 48 * a2 + 32;
}

BOOL sub_1CD5370F0(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 12) && *(unsigned char *)(a1 + 12) && *(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8);
}

void sub_1CD53711C(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = *(void *)a1;
    uint64_t v5 = 32 * v3;
    while (1)
    {
      if (*(_DWORD *)v4 == -2) {
        goto LABEL_10;
      }
      if (*(_DWORD *)v4 != -1) {
        break;
      }
LABEL_11:
      v4 += 32;
      v5 -= 32;
      if (!v5) {
        goto LABEL_12;
      }
    }
    char v6 = *(void **)(v4 + 8);
    if (v6)
    {
      *(void *)(v4 + 16) = v6;
      operator delete(v6);
    }
LABEL_10:
    *(_DWORD *)uint64_t v4 = -1;
    goto LABEL_11;
  }

  sub_1CD5371D8(a1);
}

void sub_1CD5371D8(unsigned int *a1)
{
  unsigned int v2 = a1[2];
  sub_1CD529648(a1);
  if (v2)
  {
    int v3 = 1 << (33 - __clz(v2 - 1));
    if (v3 <= 64) {
      unsigned int v4 = 64;
    }
    else {
      unsigned int v4 = v3;
    }
    if (v4 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v5 = 32 * v4;
      char v6 = *(_DWORD **)a1;
      do
      {
        _DWORD *v6 = -1;
        v6 += 8;
        v5 -= 32;
      }
      while (v5);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v4 = 0;
  }
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);

  sub_1CBFFB9D0(a1, v4);
}

uint64_t **sub_1CD537294(uint64_t **result, int *a2)
{
  int v3 = result;
  if (result[20])
  {
    uint64_t v8 = result + 18;
  }
  else
  {
    uint64_t v4 = *((unsigned int *)result + 2);
    int v5 = *a2;
    if (!v4)
    {
LABEL_7:
      if (v4 >= *((_DWORD *)result + 3)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)*result + v4) = v5;
      ++*((_DWORD *)result + 2);
      return result;
    }
    uint64_t v6 = 4 * v4;
    uint64_t v7 = *result;
    while (*(_DWORD *)v7 != v5)
    {
      uint64_t v7 = (uint64_t *)((char *)v7 + 4);
      v6 -= 4;
      if (!v6) {
        goto LABEL_6;
      }
    }
    if (v6) {
      return result;
    }
LABEL_6:
    if (v4 <= 0x1F) {
      goto LABEL_7;
    }
    do
    {
      uint64_t v9 = (int *)*v3 + v4 - 1;
      sub_1CD41B018(v3 + 18, v9, v9);
      LODWORD(v4) = *((_DWORD *)v3 + 2) - 1;
      *((_DWORD *)v3 + 2) = v4;
    }
    while (v4);
    uint64_t v8 = v3 + 18;
  }

  return sub_1CD41B018(v8, a2, a2);
}

void *sub_1CD5373A4(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD537408(a1, a2);
  uint64_t result = (void *)(*(void *)a1 + 48 * *(unsigned int *)(a1 + 8));
  void *result = result + 2;
  result[1] = 0x800000000;
  if (*(_DWORD *)(v3 + 8)) {
    uint64_t result = (void *)sub_1CC077ABC((uint64_t)result, v3);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

unint64_t sub_1CD537408(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 48 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD512EB4();
    }
    sub_1CD512EB4();
  }
  return a2;
}

_DWORD *sub_1CD537474(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    uint64_t v6 = sub_1CD537530(a1, a2, v9);
    *(void *)uint64_t v6 = *a2;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  uint64_t v6 = (_DWORD *)(*(void *)a1 + 8 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    uint64_t v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        uint64_t v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      uint64_t v6 = (_DWORD *)(*(void *)a1 + 8 * (v13 & v4));
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD537530(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD5142A8(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      int v17 = v16 - 1;
      unsigned int v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 8 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 8 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD5142A8(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  int v9 = v8 - 1;
  unsigned int v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    unsigned int v15 = v10 + v13++;
    unsigned int v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 8 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD5376B8(uint64_t a1, _DWORD *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    int v9 = 0;
LABEL_5:
    unsigned int v6 = sub_1CD53777C(a1, a2, v9);
    _DWORD *v6 = *a2;
    *((void *)v6 + 2) = 0;
    *((void *)v6 + 3) = 0;
    *((void *)v6 + 1) = 0;
    return v6;
  }
  unsigned int v4 = v3 - 1;
  uint64_t v5 = (37 * *a2) & (v3 - 1);
  unsigned int v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
  int v7 = *v6;
  if (*a2 != *v6)
  {
    unsigned int v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        unsigned int v10 = v6;
      }
      int v13 = v5 + v11++;
      uint64_t v5 = v13 & v4;
      unsigned int v6 = (_DWORD *)(*(void *)a1 + 32 * v5);
      int v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      int v9 = v10;
    }
    else {
      int v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

_DWORD *sub_1CD53777C(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 < 3 * v6)
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3) {
      goto LABEL_3;
    }
    sub_1CD519714(a1, v6);
    int v16 = *(_DWORD *)(a1 + 16);
    if (v16)
    {
      unsigned int v17 = v16 - 1;
      uint64_t v18 = (37 * *a2) & v17;
      a3 = (_DWORD *)(*(void *)a1 + 32 * v18);
      int v19 = *a3;
      if (*a2 == *a3) {
        goto LABEL_3;
      }
      BOOL v12 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v12) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          BOOL v12 = a3;
        }
        int v22 = v18 + v20++;
        uint64_t v18 = v22 & v17;
        a3 = (_DWORD *)(*(void *)a1 + 32 * v18);
        int v19 = *a3;
        if (*a2 == *a3) {
          goto LABEL_3;
        }
      }
      goto LABEL_21;
    }
LABEL_24:
    a3 = 0;
    goto LABEL_3;
  }
  sub_1CD519714(a1, 2 * v6);
  int v8 = *(_DWORD *)(a1 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  unsigned int v9 = v8 - 1;
  uint64_t v10 = (37 * *a2) & v9;
  a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
  int v11 = *a3;
  if (*a2 == *a3) {
    goto LABEL_3;
  }
  BOOL v12 = 0;
  int v13 = 1;
  while (v11 != -1)
  {
    if (v12) {
      BOOL v14 = 0;
    }
    else {
      BOOL v14 = v11 == -2;
    }
    if (v14) {
      BOOL v12 = a3;
    }
    int v15 = v10 + v13++;
    uint64_t v10 = v15 & v9;
    a3 = (_DWORD *)(*(void *)a1 + 32 * v10);
    int v11 = *a3;
    if (*a2 == *a3) {
      goto LABEL_3;
    }
  }
LABEL_21:
  if (v12) {
    a3 = v12;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void sub_1CD537904(long long *a1, int **a2, _WORD *a3, uint64_t a4)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCEE28, 0, 0);
  dword_1EBCCEEA8 = 0;
  qword_1EBCCEEB0 = (uint64_t)&unk_1F260E618;
  *(void *)&dword_1EBCCEEB8 = 0;
  qword_1EBCCEE28 = (uint64_t)&unk_1F260E560;
  qword_1EBCCEEC0 = (uint64_t)&unk_1F260E5C8;
  qword_1EBCCEEC8 = (uint64_t)&qword_1EBCCEE28;
  qword_1EBCCEED0 = (uint64_t)&unk_1EBCCEEE0;
  qword_1EBCCEED8 = 0x800000000;
  qword_1EBCCF060 = (uint64_t)&unk_1F260E898;
  qword_1EBCCF078 = (uint64_t)&qword_1EBCCF060;
  sub_1CD537A18(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCEE28);
}

void sub_1CD537A18(long long *a1, int **a2, _WORD *a3, uint64_t a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCEE28, "disable-hoisting-to-hotter-blocks", 0x21uLL);
  xmmword_1EBCCEE48 = *a1;
  int v8 = *a2;
  dword_1EBCCEEA8 = **a2;
  byte_1EBCCEEBC = 1;
  dword_1EBCCEEB8 = *v8;
  word_1EBCCEE32 = (32 * (*a3 & 3)) | word_1EBCCEE32 & 0xFF9F;
  uint64_t v9 = *(void *)a4;
  unsigned int v10 = *(_DWORD *)(a4 + 8);

  sub_1CD537B40(v9, v10);
}

void sub_1CD537AC8()
{
}

void *sub_1CD537ADC()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1F260E898;
  return result;
}

void sub_1CD537B14(uint64_t a1, void *a2)
{
  *a2 = &unk_1F260E898;
}

void sub_1CD537B40(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a1;
    uint64_t v3 = a1 + 40 * a2;
    do
    {
      sub_1CD537B8C(*(unsigned __int8 **)v2, *(void *)(v2 + 8), *(_DWORD *)(v2 + 16), *(void *)(v2 + 24), *(void *)(v2 + 32));
      v2 += 40;
    }
    while (v2 != v3);
  }
}

void sub_1CD537B8C(unsigned __int8 *a1, size_t a2, int a3, uint64_t a4, uint64_t a5)
{
  v11[0] = a1;
  v11[1] = a2;
  void v11[2] = a4;
  void v11[3] = a5;
  uint64_t v11[4] = &unk_1F260E618;
  char v13 = 1;
  int v12 = a3;
  unint64_t v7 = sub_1CD537C80((unint64_t)v11);
  uint64_t v8 = qword_1EBCCEED0 + 48 * qword_1EBCCEED8;
  long long v9 = *(_OWORD *)(v7 + 16);
  *(_OWORD *)uint64_t v8 = *(_OWORD *)v7;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 32) = &unk_1F260E638;
  char v10 = *(unsigned char *)(v7 + 44);
  *(_DWORD *)(v8 + 40) = *(_DWORD *)(v7 + 40);
  *(unsigned char *)(v8 + 44) = v10;
  *(void *)(v8 + 32) = &unk_1F260E618;
  LODWORD(qword_1EBCCEED8) = qword_1EBCCEED8 + 1;
  llvm::cl::AddLiteralOption(qword_1EBCCEEC8, a1, a2);
}

unint64_t sub_1CD537C80(unint64_t result)
{
  if (qword_1EBCCEED8 >= HIDWORD(qword_1EBCCEED8))
  {
    if (qword_1EBCCEED0 > result || qword_1EBCCEED0 + 48 * (unint64_t)qword_1EBCCEED8 <= result) {
      sub_1CD537CFC();
    }
    sub_1CD537CFC();
  }
  return result;
}

void sub_1CD537CFC()
{
}

void *llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getExitingBlocks(void *result, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)result[4];
  uint64_t v3 = (uint64_t *)result[5];
  if (v3 != v2)
  {
    int v5 = result;
    uint64_t v6 = (uint64_t)(result + 7);
    do
    {
      uint64_t v7 = *v2;
      uint64_t v8 = *(uint64_t **)(*v2 + 88);
      long long v9 = *(uint64_t **)(*v2 + 96);
      while (v8 != v9)
      {
        uint64_t result = sub_1CB896AE8(v6, *v8);
        uint64_t v10 = v5[8];
        if (v10 == v5[7]) {
          uint64_t v11 = 76;
        }
        else {
          uint64_t v11 = 72;
        }
        if (result == (void *)(v10 + 8 * *(unsigned int *)((char *)v5 + v11)))
        {
          unint64_t v12 = *(unsigned int *)(a2 + 8);
          if (v12 >= *(unsigned int *)(a2 + 12)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(*(void *)a2 + 8 * v12) = v7;
          ++*(_DWORD *)(a2 + 8);
          break;
        }
        ++v8;
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return result;
}

void *llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addBasicBlockToLoop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2;
  uint64_t result = sub_1CC361A48(a3, &v5);
  result[1] = a1;
  if (a1) {
    llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::addBlockEntry();
  }
  return result;
}

llvm::MachineLoopInfo *llvm::MachineLoopInfo::MachineLoopInfo(llvm::MachineLoopInfo *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::MachineLoopInfo::ID);
  *(void *)uint64_t v2 = &unk_1F260E8E0;
  *(void *)(v2 + 248) = 0;
  *(void *)(v2 + 256) = 0;
  *(_DWORD *)(v2 + 264) = 0;
  *(_OWORD *)(v2 + 272) = 0u;
  *(_OWORD *)(v2 + 288) = 0u;
  *(void *)(v2 + 304) = 0;
  *(void *)(v2 + 312) = v2 + 328;
  *(void *)(v2 + 320) = 0x400000000;
  *(void *)(v2 + 360) = v2 + 376;
  *(void *)(v2 + 368) = 0;
  *(void *)(v2 + 376) = 0;
  *(void *)(v2 + 384) = 1;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF080, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC361480;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCF080, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::MachineLoopInfo::getAnalysisUsage(llvm::MachineLoopInfo *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

uint64_t *llvm::MachineLoop::getTopBlock(llvm::MachineLoop *this)
{
  int v1 = (uint64_t *)**((void **)this + 4);
  uint64_t v2 = *(uint64_t **)(v1[4] + 328);
  if (v1 != v2)
  {
    unsigned int v4 = (char *)this + 56;
    while (1)
    {
      uint64_t v5 = *v1;
      uint64_t v6 = sub_1CB896AE8((uint64_t)v4, *v1);
      uint64_t v7 = *((void *)this + 8);
      uint64_t v8 = v7 == *((void *)this + 7) ? 76 : 72;
      if (v6 == (void *)(v7 + 8 * *(unsigned int *)((char *)this + v8))) {
        break;
      }
      int v1 = (uint64_t *)v5;
      if ((uint64_t *)v5 == v2) {
        return v2;
      }
    }
  }
  return v1;
}

uint64_t llvm::MachineLoop::getBottomBlock(llvm::MachineLoop *this)
{
  uint64_t v1 = **((void **)this + 4);
  if (v1 != *(void *)(*(void *)(v1 + 32) + 320))
  {
    uint64_t v3 = *(void *)(v1 + 8);
    unsigned int v4 = (char *)this + 56;
    uint64_t v5 = sub_1CB896AE8((uint64_t)this + 56, v3);
    uint64_t v6 = *((void *)this + 8);
    uint64_t v7 = 72;
    if (v6 == *((void *)this + 7)) {
      uint64_t v7 = 76;
    }
    if (v5 != (void *)(v6 + 8 * *(unsigned int *)((char *)this + v7)))
    {
      do
      {
        uint64_t v1 = v3;
        uint64_t v3 = *(void *)(v3 + 8);
        if (v1 == v3) {
          break;
        }
        uint64_t v8 = sub_1CB896AE8((uint64_t)v4, v3);
        uint64_t v9 = *((void *)this + 8);
        uint64_t v10 = v9 == *((void *)this + 7) ? 76 : 72;
      }
      while (v8 != (void *)(v9 + 8 * *(unsigned int *)((char *)this + v10)));
    }
  }
  return v1;
}

void llvm::MachineLoop::getStartLoc(llvm::MachineLoop *this)
{
}

uint64_t llvm::MachineLoop::isLoopInvariant(llvm::MachineLoop *this, llvm::MachineInstr *a2)
{
  uint64_t v4 = *(void *)(*((void *)a2 + 3) + 32);
  uint64_t v5 = *(void **)(v4 + 40);
  uint64_t v6 = *(void *)(v4 + 16);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 176))(v6);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 104))(v6);
  uint64_t v9 = *((unsigned int *)a2 + 10);
  if (v9)
  {
    uint64_t v10 = v8;
    uint64_t v11 = (int *)*((void *)a2 + 4);
    for (uint64_t i = 32 * v9; i; i -= 32)
    {
      int v13 = *v11;
      if (*v11) {
        goto LABEL_4;
      }
      uint64_t v14 = v11[1];
      if (!v14) {
        goto LABEL_4;
      }
      if (!(v14 >> 30))
      {
        if ((v13 & 0x1000000) == 0)
        {
          if ((llvm::MachineRegisterInfo::isConstantPhysReg(v5, v11[1]) & 1) == 0)
          {
            uint64_t MF = llvm::MachineInstr::getMF(a2);
            if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 128))(v7, v14, MF) & 1) == 0
              && ((*(uint64_t (**)(uint64_t, int *))(*(void *)v10 + 24))(v10, v11) & 1) == 0)
            {
              return 0;
            }
          }
          goto LABEL_4;
        }
        if ((~v13 & 0x5000000) != 0
          || llvm::MachineBasicBlock::isLiveIn(**((void **)this + 4), (unsigned __int16)v11[1], -1))
        {
          return 0;
        }
        int v13 = *v11;
      }
      if ((v13 & 0x1000000) == 0)
      {
        uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef((uint64_t)v5, v14);
        unsigned int v17 = sub_1CB896AE8((uint64_t)this + 56, *(void *)(VRegDef + 24));
        uint64_t v18 = *((void *)this + 8);
        uint64_t v19 = 72;
        if (v18 == *((void *)this + 7)) {
          uint64_t v19 = 76;
        }
        if (v17 != (void *)(v18 + 8 * *(unsigned int *)((char *)this + v19))) {
          return 0;
        }
      }
LABEL_4:
      v11 += 8;
    }
  }
  return 1;
}

void llvm::MachineLoop::dump(llvm::MachineLoop *this)
{
  llvm::dbgs(this);

  llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::print();
}

void sub_1CD5384FC(void *a1)
{
  *a1 = &unk_1F260E8E0;
  llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopInfoBase();
}

void sub_1CD538550(void *a1)
{
  *a1 = &unk_1F260E8E0;
  llvm::LoopInfoBase<llvm::MachineBasicBlock,llvm::MachineLoop>::~LoopInfoBase();
}

void llvm::callDefaultCtor<llvm::MachineLoopInfo>()
{
}

void llvm::PeelSingleBlockLoop(int a1, uint64_t a2, void *a3, uint64_t a4)
{
  v77[16] = *MEMORY[0x1E4F143B8];
  uint64_t v69 = *(llvm::MachineFunction **)(a2 + 32);
  uint64_t v7 = *(llvm::MachineBasicBlock ***)(a2 + 64);
  uint64_t v8 = *v7;
  if (*v7 == (llvm::MachineBasicBlock *)a2) {
    uint64_t v8 = v7[1];
  }
  uint64_t v9 = *(llvm::MachineBasicBlock ***)(a2 + 88);
  unint64_t v63 = *v9;
  if (*v9 == (llvm::MachineBasicBlock *)a2) {
    unint64_t v63 = v9[1];
  }
  int v62 = v8;
  unint64_t MachineBasicBlock = (uint64_t *)llvm::MachineFunction::CreateMachineBasicBlock(v69, *(const llvm::BasicBlock **)(a2 + 16));
  uint64_t v11 = (uint64_t *)a2;
  if (a1) {
    uint64_t v11 = *(uint64_t **)(a2 + 8);
  }
  llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList((uint64_t)v69 + 320, (uint64_t)MachineBasicBlock);
  uint64_t v12 = *v11;
  *unint64_t MachineBasicBlock = *v11;
  MachineBasicBlock[1] = (uint64_t)v11;
  *(void *)(v12 + 8) = MachineBasicBlock;
  *uint64_t v11 = (uint64_t)MachineBasicBlock;
  long long v65 = (llvm::MachineBasicBlock *)MachineBasicBlock;
  int v13 = (unint64_t *)(MachineBasicBlock + 6);
  v73[0] = 0;
  v73[1] = 0;
  unsigned int v74 = 0;
  uint64_t v14 = *(void *)(a2 + 56);
  if (v14 != a2 + 48)
  {
    int v68 = MachineBasicBlock + 5;
    int v67 = a1;
    uint64_t v66 = (unint64_t *)(MachineBasicBlock + 6);
    do
    {
      unint64_t v15 = llvm::MachineFunction::CloneMachineInstr(v69, (const llvm::MachineInstr *)v14);
      llvm::ilist_traits<llvm::MachineInstr>::addNodeToList(v68, v15);
      unint64_t v16 = *v13 & 0xFFFFFFFFFFFFFFF8;
      *(void *)unint64_t v15 = v16 | *(void *)v15 & 7;
      *(void *)(v15 + 8) = v13;
      *(void *)(v16 + 8) = v15;
      *int v13 = *v13 & 7 | v15;
      uint64_t v17 = *(void *)(v15 + 32);
      unsigned int NumExplicitDefs = llvm::MachineInstr::getNumExplicitDefs((llvm::MachineInstr *)v15);
      if (NumExplicitDefs)
      {
        uint64_t v19 = v17 + 32 * NumExplicitDefs;
        do
        {
          LODWORD(v72) = *(_DWORD *)(v17 + 4);
          if ((v72 - 1) >= 0x3FFFFFFF)
          {
            int v20 = sub_1CD4145B8((uint64_t)v73, (int *)&v72);
            unsigned int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister((uint64_t)a3, *(void *)(a3[3] + 16 * (v72 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
            v20[1] = VirtualRegister;
            llvm::MachineOperand::setReg(v17, VirtualRegister);
            if (a1 == 1)
            {
              unsigned int v75 = v77;
              uint64_t v76 = 0x400000000;
              uint64_t v22 = sub_1CBA02BCC((uint64_t)a3, v72);
              if (v22 != v23)
              {
                uint64_t v24 = v22;
                do
                {
                  if (*(void *)(*(void *)(v24 + 8) + 24) != a2)
                  {
                    if (v76 >= (unint64_t)HIDWORD(v76)) {
                      llvm::SmallVectorBase<unsigned int>::grow_pod();
                    }
                    *((void *)v75 + v76) = v24;
                    LODWORD(v76) = v76 + 1;
                  }
                  do
                    uint64_t v24 = *(void *)(v24 + 24);
                  while (v24 && (*(unsigned char *)(v24 + 3) & 1) != 0);
                }
                while (v24 != v23);
              }
              uint64_t v25 = (uint64_t *)v75;
              if (v76)
              {
                uint64_t v26 = 8 * v76;
                do
                {
                  uint64_t v27 = *v25++;
                  llvm::MachineRegisterInfo::constrainRegClass(a3, v20[1], *(void *)(a3[3] + 16 * (*(_DWORD *)(v27 + 4) & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, 0);
                  llvm::MachineOperand::setReg(v27, v20[1]);
                  v26 -= 8;
                }
                while (v26);
                uint64_t v25 = (uint64_t *)v75;
                int v13 = v66;
              }
              a1 = v67;
              if (v25 != v77) {
                free(v25);
              }
            }
          }
          v17 += 32;
        }
        while (v17 != v19);
      }
      if (!v14 || (*(unsigned char *)v14 & 4) == 0)
      {
        while ((*(_WORD *)(v14 + 44) & 8) != 0)
          uint64_t v14 = *(void *)(v14 + 8);
      }
      uint64_t v14 = *(void *)(v14 + 8);
    }
    while (v14 != a2 + 48);
  }
  uint64_t FirstNonPHI = llvm::MachineBasicBlock::getFirstNonPHI(v65);
  if (v13 != (unint64_t *)FirstNonPHI)
  {
    uint64_t v29 = FirstNonPHI;
    do
    {
      uint64_t v30 = *(void *)(v29 + 32);
      uint64_t v31 = v30 + 32 * llvm::MachineInstr::getNumExplicitDefs((llvm::MachineInstr *)v29);
      uint64_t v32 = *(void *)(v29 + 32) + 32 * *(unsigned int *)(v29 + 40);
      if (v31 != v32)
      {
        do
        {
          if (!*(unsigned char *)v31 && v74)
          {
            int v33 = *(_DWORD *)(v31 + 4);
            unsigned int v34 = (v74 - 1) & (37 * v33);
            int v35 = *((_DWORD *)v73[0] + 2 * v34);
            if (v33 == v35)
            {
LABEL_44:
              LODWORD(v75) = *(_DWORD *)(v31 + 4);
              unint64_t v36 = sub_1CD4145B8((uint64_t)v73, (int *)&v75);
              llvm::MachineOperand::setReg(v31, v36[1]);
            }
            else
            {
              int v58 = 1;
              while (v35 != -1)
              {
                unsigned int v59 = v34 + v58++;
                unsigned int v34 = v59 & (v74 - 1);
                int v35 = *((_DWORD *)v73[0] + 2 * v34);
                if (v33 == v35) {
                  goto LABEL_44;
                }
              }
            }
          }
          v31 += 32;
        }
        while (v31 != v32);
        if (!v29) {
          goto LABEL_49;
        }
      }
      if ((*(unsigned char *)v29 & 4) == 0)
      {
LABEL_49:
        while ((*(_WORD *)(v29 + 44) & 8) != 0)
          uint64_t v29 = *(void *)(v29 + 8);
      }
      uint64_t v29 = *(void *)(v29 + 8);
    }
    while ((unint64_t *)v29 != v13);
  }
  for (uint64_t i = (char *)v65 + 56; ; uint64_t i = (char *)(v38 + 8))
  {
    uint64_t v38 = *(void *)i;
    int v39 = **(unsigned __int16 **)(*(void *)i + 16);
    if (v39 && v39 != 69)
    {
      uint64_t v72 = 0;
      if (a1)
      {
        llvm::MachineBasicBlock::replaceSuccessor((llvm::MachineBasicBlock *)a2, v63, v65);
        llvm::MachineBasicBlock::replacePhiUsesWith((uint64_t)v63, (llvm::MachineBasicBlock *)a2, v65);
        llvm::MachineBasicBlock::addSuccessor(v65, v63, -1);
        uint64_t v70 = 0;
        uint64_t v71 = 0;
        unsigned int v75 = v77;
        uint64_t v76 = 0x400000000;
        (*(void (**)(uint64_t, uint64_t, llvm::MachineBasicBlock **, llvm::MachineBasicBlock **, void **, void))(*(void *)a4 + 248))(a4, a2, &v71, &v70, &v75, 0);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)a4 + 264))(a4, a2, 0);
        if (v71 == v63) {
          unint64_t v56 = v65;
        }
        else {
          unint64_t v56 = v71;
        }
        if (v70 == v63) {
          __int16 v57 = v65;
        }
        else {
          __int16 v57 = v70;
        }
        (*(void (**)(uint64_t, uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void *, void, unsigned __int8 **, void))(*(void *)a4 + 272))(a4, a2, v56, v57, v75, v76, &v72, 0);
        if ((*(unsigned int (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)a4 + 264))(a4, v65, 0))
        {
          (*(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void, void, void, unsigned __int8 **, void))(*(void *)a4 + 272))(a4, v65, v63, 0, 0, 0, &v72, 0);
        }
        if (v75 != v77) {
          free(v75);
        }
      }
      else
      {
        llvm::MachineBasicBlock::replaceSuccessor(v62, (llvm::MachineBasicBlock *)a2, v65);
        llvm::MachineBasicBlock::addSuccessor(v65, (void *)a2, -1);
        llvm::MachineBasicBlock::replacePhiUsesWith(a2, v62, v65);
        if ((*(unsigned int (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)a4 + 264))(a4, v62, 0))
        {
          (*(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void, void, void, unsigned __int8 **, void))(*(void *)a4 + 272))(a4, v62, v65, 0, 0, 0, &v72, 0);
        }
        (*(void (**)(uint64_t, llvm::MachineBasicBlock *, void))(*(void *)a4 + 264))(a4, v65, 0);
        (*(void (**)(uint64_t, llvm::MachineBasicBlock *, uint64_t, void, void, void, unsigned __int8 **, void))(*(void *)a4 + 272))(a4, v65, a2, 0, 0, 0, &v72, 0);
      }
      if (v72) {
        llvm::MetadataTracking::untrack((uint64_t)&v72, v72);
      }
      llvm::deallocate_buffer(v73[0], (void *)(8 * v74));
    }
    uint64_t v40 = *(void *)(v38 + 32);
    unsigned int v41 = *(llvm::MachineBasicBlock **)(v40 + 80);
    if (v41 == v62) {
      uint64_t v42 = 3;
    }
    else {
      uint64_t v42 = 1;
    }
    if (v41 == v62) {
      uint64_t v43 = 1;
    }
    else {
      uint64_t v43 = 3;
    }
    uint64_t v44 = *(void *)(*(void *)(v38 + 24) + 56);
    if (v44 == v38)
    {
      uint64_t v48 = *(void *)(a2 + 56);
    }
    else
    {
      int v45 = 0;
      int v46 = 1;
      do
      {
        unsigned int v47 = v46;
        ++v45;
        uint64_t v44 = *(void *)(v44 + 8);
        ++v46;
      }
      while (v44 != v38);
      uint64_t v48 = *(void *)(a2 + 56);
      if (v45)
      {
        unint64_t v49 = v47 + 1;
        do
        {
          uint64_t v48 = *(void *)(v48 + 8);
          --v49;
        }
        while (v49 > 1);
      }
    }
    if (a1)
    {
      llvm::MachineOperand::setReg(v40 + 32 * v42, *(_DWORD *)(*(void *)(v48 + 32) + 32 * v42 + 4));
      llvm::MachineInstr::removeOperand((char *)v38, v43 + 1);
      unsigned int v50 = (char *)v38;
      unsigned int v51 = v43;
    }
    else
    {
      unsigned int v52 = *(_DWORD *)(v40 + 32 * v42 + 4);
      LODWORD(v75) = v52;
      if (v74)
      {
        unsigned int v53 = v74 - 1;
        unsigned int v54 = (v74 - 1) & (37 * v52);
        int v55 = *((_DWORD *)v73[0] + 2 * v54);
        if (v52 == v55)
        {
LABEL_77:
          unsigned int v52 = sub_1CD4145B8((uint64_t)v73, (int *)&v75)[1];
          LODWORD(v75) = v52;
        }
        else
        {
          int v60 = 1;
          while (v55 != -1)
          {
            unsigned int v61 = v54 + v60++;
            unsigned int v54 = v61 & v53;
            int v55 = *((_DWORD *)v73[0] + 2 * (v61 & v53));
            if (v52 == v55) {
              goto LABEL_77;
            }
          }
        }
      }
      llvm::MachineOperand::setReg(*(void *)(v48 + 32) + 32 * v43, v52);
      llvm::MachineInstr::removeOperand((char *)v38, v42 + 1);
      unsigned int v50 = (char *)v38;
      unsigned int v51 = v42;
    }
    llvm::MachineInstr::removeOperand(v50, v51);
    if (!v38 || (*(unsigned char *)v38 & 4) == 0)
    {
      while ((*(_WORD *)(v38 + 44) & 8) != 0)
        uint64_t v38 = *(void *)(v38 + 8);
    }
  }
}

llvm::MachineModuleInfo *llvm::MachineModuleInfo::MachineModuleInfo(llvm::MachineModuleInfo *this, const llvm::LLVMTargetMachine *a2)
{
  *(void *)this = a2;
  llvm::MCContext::MCContext((uint64_t)this + 8, (long long *)a2 + 28, *((void *)a2 + 70), *((void *)a2 + 71), *((void *)a2 + 73), 0, (uint64_t)a2 + 1128, 0, 0, 0);
  *((void *)this + 257) = 0;
  *((_DWORD *)this + 534) = 0;
  *((void *)this + 274) = 0;
  *((void *)this + 260) = 0;
  *(_OWORD *)((char *)this + 2088) = 0u;
  *((_OWORD *)this + 132) = 0u;
  *((_DWORD *)this + 532) = 0;
  *((void *)this + 268) = 0;
  *((void *)this + 270) = 0;
  *((void *)this + 269) = 0;
  *((void *)this + 22) = (*(uint64_t (**)(const llvm::LLVMTargetMachine *))(*(void *)a2 + 24))(a2);
  *((void *)this + 259) = 0;
  *((_DWORD *)this + 526) = 0;
  *((_DWORD *)this + 534) = 0;
  *((_WORD *)this + 1054) = 0;
  return this;
}

void llvm::createFreeMachineFunctionPass(llvm *this)
{
}

llvm::MachineModuleInfoWrapperPass *llvm::MachineModuleInfoWrapperPass::MachineModuleInfoWrapperPass(llvm::MachineModuleInfoWrapperPass *this, const llvm::LLVMTargetMachine *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &llvm::MachineModuleInfoWrapperPass::ID;
  *((_DWORD *)this + 6) = 4;
  *(void *)this = &unk_1F260E9A0;
  llvm::MachineModuleInfo::MachineModuleInfo((llvm::MachineModuleInfoWrapperPass *)((char *)this + 32), a2);
  uint64_t v3 = sub_1CC3624E0(*((void *)this + 4));
  if (v3)
  {
    v8[0] = &unk_1F260EB08;
    v8[1] = this;
    uint64_t v9 = v8;
    sub_1CC362B58((void *)this + 275, v8);
    uint64_t v3 = (uint64_t)v9;
    if (v9 == v8)
    {
      uint64_t v3 = (*(uint64_t (**)(void *))(v8[0] + 32))(v8);
    }
    else if (v9)
    {
      uint64_t v3 = (*(uint64_t (**)(void))(*v9 + 40))();
    }
  }
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v3);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF148, memory_order_acquire) != -1)
  {
    v7[0] = sub_1CC362624;
    v7[1] = &PassRegistry;
    uint64_t v6 = v7;
    std::__call_once(&qword_1EBCCF148, &v6, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeMachineModuleInfoWrapperPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF148, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC362624;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCF148, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t llvm::MachineModuleInfoWrapperPass::getAnalysisUsage(llvm::MachineModuleInfoWrapperPass *this, llvm::AnalysisUsage *a2)
{
  if (*((void *)this + 278) || *((void *)this + 274)) {
    sub_1CB843600((uint64_t)a2, (uint64_t)a2, (uint64_t)&llvm::FunctionGroupInfoWrapperPass::ID);
  }

  return llvm::Pass::getAnalysisUsage(this, a2);
}

void sub_1CD5392B8(uint64_t a1)
{
  *(void *)a1 = &unk_1F260E9A0;
  llvm::MachineModuleInfo::~MachineModuleInfo((llvm::MachineModuleInfo *)(a1 + 32));

  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);
}

void sub_1CD53930C(uint64_t a1)
{
  *(void *)a1 = &unk_1F260E9A0;
  llvm::MachineModuleInfo::~MachineModuleInfo((llvm::MachineModuleInfo *)(a1 + 32));
  llvm::ImmutablePass::~ImmutablePass((llvm::ImmutablePass *)a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::MachineModuleInfoWrapperPass>()
{
}

_DWORD *llvm::MachineModuleInfoImpl::getSortedStubs@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(_OWORD **)a1;
  uint64_t v5 = a1[4];
  uint64_t v6 = (_OWORD *)(*(void *)a1 + 16 * v5);
  if (a1[2])
  {
    if (v5)
    {
      uint64_t v10 = 16 * v5;
      while ((*(void *)v4 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        ++v4;
        v10 -= 16;
        if (!v10) {
          goto LABEL_2;
        }
      }
    }
  }
  else
  {
LABEL_2:
    uint64_t v4 = v6;
  }
  uint64_t v7 = sub_1CD539684(a2, v4, v6, v6, (uint64_t)v6);
  uint64_t v8 = *(void *)(v7 + 8) - *(void *)v7;
  if (v8 >= 32) {
    qsort(*(void **)v7, (unint64_t)v8 >> 4, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1CC36360C);
  }

  return sub_1CD3C7F68(a1);
}

void sub_1CD539478(void *a1)
{
  sub_1CD539620(a1);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD5394B0(void *a1)
{
  *a1 = &unk_1F260EC08;
  MEMORY[0x1D25D9CD0](a1[1], 8);
  return a1;
}

void sub_1CD5394FC(void *a1)
{
  *a1 = &unk_1F260EC08;
  MEMORY[0x1D25D9CD0](a1[1], 8);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD539568(void *a1)
{
  *a1 = &unk_1F260EC30;
  MEMORY[0x1D25D9CD0](a1[1], 8);
  return a1;
}

void sub_1CD5395B4(void *a1)
{
  *a1 = &unk_1F260EC30;
  MEMORY[0x1D25D9CD0](a1[1], 8);

  JUMPOUT(0x1D25D9CE0);
}

void *sub_1CD539620(void *a1)
{
  *a1 = &unk_1F260EBE0;
  MEMORY[0x1D25D9CD0](a1[7], 8);
  MEMORY[0x1D25D9CD0](a1[4], 8);
  MEMORY[0x1D25D9CD0](a1[1], 8);
  return a1;
}

uint64_t sub_1CD539684(uint64_t a1, _OWORD *a2, _OWORD *a3, _OWORD *a4, uint64_t a5)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (a2 != a4)
  {
    unint64_t v6 = 0;
    uint64_t v7 = a2;
    while (1)
    {
      v7 += 2;
      if (v7 == (void *)a3)
      {
        uint64_t v7 = a3;
LABEL_7:
        ++v6;
        if (v7 == (void *)a4) {
          goto LABEL_8;
        }
      }
      else if ((*v7 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        goto LABEL_7;
      }
    }
  }
  unint64_t v6 = 0;
LABEL_8:
  sub_1CC3639C0((_OWORD *)a1, a2, a3, a4, a5, v6);
  return a1;
}

uint64_t llvm::MachineModuleSlotTracker::processMachineFunctionMetadata(llvm::MachineModuleSlotTracker *this, llvm::AbstractSlotTrackerStorage *a2, const llvm::MachineFunction *a3)
{
  uint64_t v3 = (char *)a3 + 320;
  uint64_t v4 = (char *)*((void *)a3 + 41);
  if (v4 != (char *)a3 + 320)
  {
    do
    {
      for (uint64_t i = (char *)*((void *)v4 + 7); i != v4 + 48; uint64_t i = (char *)*((void *)i + 1))
      {
        uint64_t v8 = (int *)(i + 48);
        unint64_t v7 = *((void *)i + 6);
        if (v7 < 8) {
          continue;
        }
        if ((v7 & 7) != 0)
        {
          uint64_t v9 = (int *)(v7 & 0xFFFFFFFFFFFFFFF8);
          if ((*((void *)i + 6) & 7) != 3 || v9 == 0) {
            continue;
          }
          uint64_t v12 = *v9;
          uint64_t v8 = v9 + 2;
          uint64_t v11 = v12;
          if (!v12) {
            continue;
          }
          int v13 = &v8[2 * v11];
        }
        else
        {
          *((void *)i + 6) = v7 & 0xFFFFFFFFFFFFFFF8;
          int v13 = (int *)(i + 56);
        }
        do
        {
          uint64_t v14 = *(void *)(*(void *)v8 + 48);
          uint64_t v16 = *(void *)(*(void *)v8 + 56);
          uint64_t v15 = *(void *)(*(void *)v8 + 64);
          if (*(void *)(*(void *)v8 + 40)) {
            uint64_t result = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(void *)a2 + 24))(a2);
          }
          if (v14) {
            uint64_t result = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *, uint64_t))(*(void *)a2 + 24))(a2, v14);
          }
          if (v16) {
            uint64_t result = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *, uint64_t))(*(void *)a2 + 24))(a2, v16);
          }
          if (v15) {
            uint64_t result = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *, uint64_t))(*(void *)a2 + 24))(a2, v15);
          }
          v8 += 2;
        }
        while (v8 != v13);
      }
      uint64_t v4 = (char *)*((void *)v4 + 1);
    }
    while (v4 != v3);
  }
  return result;
}

uint64_t llvm::MachineModuleSlotTracker::processMachineModule(uint64_t this, llvm::AbstractSlotTrackerStorage *a2, const llvm::Module *a3, int a4)
{
  if (a4)
  {
    uint64_t v4 = (void *)*((void *)a3 + 4);
    if (v4 != (void *)((char *)a3 + 24))
    {
      uint64_t v6 = this;
      unint64_t v7 = *(const Function **)(this + 112);
      while (1)
      {
        uint64_t v8 = (const Function *)(v4 - 7);
        if (!v4) {
          uint64_t v8 = 0;
        }
        if (v8 == v7) {
          break;
        }
        uint64_t v4 = (void *)v4[1];
        if (v4 == (void *)((char *)a3 + 24)) {
          return this;
        }
      }
      *(_DWORD *)(this + 128) = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(void *)a2 + 16))(a2);
      MachineFunction = (llvm::MachineModuleSlotTracker *)llvm::MachineModuleInfo::getMachineFunction(*(llvm::MachineModuleInfo **)(v6 + 120), v7);
      if (MachineFunction) {
        llvm::MachineModuleSlotTracker::processMachineFunctionMetadata(MachineFunction, a2, MachineFunction);
      }
      this = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(void *)a2 + 16))(a2);
      *(_DWORD *)(v6 + 132) = this;
    }
  }
  return this;
}

uint64_t llvm::MachineModuleSlotTracker::processMachineFunction(uint64_t this, llvm::AbstractSlotTrackerStorage *a2, const Function *a3, char a4)
{
  if ((a4 & 1) == 0)
  {
    uint64_t v5 = this;
    if (*(const Function **)(this + 112) == a3)
    {
      *(_DWORD *)(this + 128) = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(void *)a2 + 16))(a2);
      MachineFunction = (llvm::MachineModuleSlotTracker *)llvm::MachineModuleInfo::getMachineFunction(*(llvm::MachineModuleInfo **)(v5 + 120), a3);
      if (MachineFunction) {
        llvm::MachineModuleSlotTracker::processMachineFunctionMetadata(MachineFunction, a2, MachineFunction);
      }
      this = (*(uint64_t (**)(llvm::AbstractSlotTrackerStorage *))(*(void *)a2 + 16))(a2);
      *(_DWORD *)(v5 + 132) = this;
    }
  }
  return this;
}

_OWORD *llvm::MachineModuleSlotTracker::collectMachineMDNodes(uint64_t a1, uint64_t a2)
{
  return llvm::ModuleSlotTracker::collectMDNodes((_OWORD *)a1, a2, *(_DWORD *)(a1 + 128), *(_DWORD *)(a1 + 132));
}

llvm::MachineModuleSlotTracker *llvm::MachineModuleSlotTracker::MachineModuleSlotTracker(llvm::MachineModuleSlotTracker *this, const llvm::MachineFunction *a2, char a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)llvm::ModuleSlotTracker::ModuleSlotTracker((uint64_t)this, *(const llvm::Module **)(*(void *)a2 + 40), a3);
  void *v5 = &unk_1F260EC80;
  v5[14] = *(void *)a2;
  v5[15] = *((void *)a2 + 4);
  v5[16] = 0;
  v9[0] = &unk_1F260ECA0;
  v9[1] = v5;
  uint64_t v10 = v9;
  llvm::ModuleSlotTracker::setProcessHook((uint64_t)v5, (uint64_t)v9);
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  v7[0] = &unk_1F260ECE8;
  v7[1] = this;
  uint64_t v8 = v7;
  llvm::ModuleSlotTracker::setProcessHook((uint64_t)this, (uint64_t)v7);
  if (v8 == v7)
  {
    (*(void (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  return this;
}

void llvm::MachineModuleSlotTracker::~MachineModuleSlotTracker(llvm::MachineModuleSlotTracker *this)
{
  llvm::ModuleSlotTracker::~ModuleSlotTracker(this);

  JUMPOUT(0x1D25D9CE0);
}

llvm::MachineOperand *llvm::MachineOperand::ChangeToFrameIndex(llvm::MachineOperand *this, int a2, __int16 a3)
{
  uint64_t result = llvm::MachineOperand::removeRegFromUses(this);
  int v7 = *(_DWORD *)this;
  *((_DWORD *)this + 4) = a2;
  *(_DWORD *)this = v7 & 0xFFF00000 | ((a3 & 0xFFF) << 8) | 5;
  return result;
}

unint64_t sub_1CD539C78(unsigned char *a1, int *a2, uint64_t *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  LOBYTE(v7[0]) = *a1;
  return sub_1CD53AAF0(v7, (_OWORD *)((char *)v7 + 1), (char *)v8, *a2, a3);
}

unint64_t sub_1CD539D2C(unsigned char *a1, int *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  uint64_t v12 = sub_1CBF65470();
  LOBYTE(v9[0]) = *a1;
  return sub_1CD53AB74(v9, (_OWORD *)((char *)v9 + 1), (char *)v10, *a2, a3, a4);
}

unint64_t sub_1CD539DE8(char *a1, int *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  memset(v9, 0, sizeof(v9));
  uint64_t v12 = sub_1CBF65470();
  return sub_1CD53AC70(v9, v9, (char *)v10, *a1, a2, a3, a4);
}

unint64_t sub_1CD539EA0(unsigned char *a1, int *a2, uint64_t *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  LOBYTE(v7[0]) = *a1;
  return sub_1CD53AD84(v7, 0, (_OWORD *)((char *)v7 + 1), (char *)v8, a2, a3);
}

unint64_t sub_1CD539F58(unsigned char *a1, int *a2, int *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  LOBYTE(v7[0]) = *a1;
  return sub_1CC36B194((char *)v7, 0, (_OWORD *)((char *)v7 + 1), (char *)v8, a2, a3);
}

unint64_t sub_1CD53A010(char *a1, int *a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  memset(v7, 0, sizeof(v7));
  uint64_t v10 = sub_1CBF65470();
  return sub_1CD53AE00(v7, v7, (char *)v8, *a1, a2, a3);
}

llvm::raw_ostream *llvm::MachineOperand::printSubRegIdx(llvm::MachineOperand *this, llvm::raw_ostream *a2, uint64_t a3, const llvm::TargetRegisterInfo *a4)
{
  sub_1CB8E509C(this, "%subreg.");
  if (a3)
  {
    int v7 = *(char **)(*(void *)(a3 + 224) + 8 * (a2 - 1));
    return sub_1CB8E509C(this, v7);
  }
  else
  {
    return sub_1CD098D14(this, (unint64_t)a2, 0, 0, 0);
  }
}

llvm::raw_ostream *llvm::MachineOperand::printTargetFlags(llvm::raw_ostream *this, llvm::raw_ostream *a2, const llvm::MachineOperand *a3)
{
  if (*(_DWORD *)a2) {
    BOOL v3 = (*(_DWORD *)a2 & 0xFFF00) == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3) {
    return this;
  }
  uint64_t v4 = *((void *)a2 + 1);
  if (!v4) {
    return this;
  }
  uint64_t v5 = *(void *)(v4 + 24);
  if (!v5) {
    return this;
  }
  uint64_t v6 = *(void *)(v5 + 32);
  if (!v6) {
    return this;
  }
  int v7 = this;
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(v6 + 16) + 104))(*(void *)(v6 + 16));
  unint64_t v9 = (*(uint64_t (**)(void))(*(void *)v8 + 1104))();
  int v10 = v9;
  unint64_t v11 = HIDWORD(v9);
  sub_1CB8E509C(v7, "target-flags(");
  BOOL v12 = v10 != 0;
  if (v10 | v11)
  {
    if (v10)
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 1112))(v8);
      if (!v14) {
        goto LABEL_16;
      }
      uint64_t v15 = (char **)(v13 + 8);
      uint64_t v16 = 16 * v14;
      while (*((_DWORD *)v15 - 2) != v10)
      {
        v15 += 2;
        v16 -= 16;
        if (!v16) {
          goto LABEL_16;
        }
      }
      uint64_t v17 = *v15;
      if (!*v15) {
LABEL_16:
      }
        uint64_t v17 = "<unknown target flag>";
      sub_1CB8E509C(v7, v17);
    }
    if (!v11) {
      goto LABEL_33;
    }
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 1120))(v8);
    if (v19)
    {
      uint64_t v20 = v18;
      uint64_t v21 = 16 * v19;
      do
      {
        if ((*(_DWORD *)v20 & ~v11) == 0)
        {
          if (v12) {
            sub_1CB8E509C(v7, ", ");
          }
          sub_1CB8E509C(v7, *(char **)(v20 + 8));
          LODWORD(v11) = v11 & ~*(_DWORD *)v20;
          BOOL v12 = 1;
        }
        v20 += 16;
        v21 -= 16;
      }
      while (v21);
      if (!v11) {
        goto LABEL_33;
      }
      if (!v12)
      {
LABEL_32:
        sub_1CB8E509C(v7, "<unknown bitmask target flag>");
LABEL_33:
        uint64_t v22 = ") ";
        goto LABEL_34;
      }
    }
    else if (!v10)
    {
      goto LABEL_32;
    }
    sub_1CB8E509C(v7, ", ");
    goto LABEL_32;
  }
  uint64_t v22 = "<unknown>) ";
LABEL_34:

  return sub_1CB8E509C(v7, v22);
}

llvm::raw_ostream *llvm::MachineOperand::printSymbol(llvm::MachineOperand *this, llvm::raw_ostream *a2, llvm::MCSymbol *a3)
{
  uint64_t v4 = sub_1CB8E509C(this, "<mcsymbol ");
  llvm::MCSymbol::print(a2, v4, 0);

  return sub_1CB8E509C(v4, ">");
}

llvm::raw_ostream *llvm::MachineOperand::printStackObjectReference(llvm::raw_ostream *a1, unsigned int a2, int a3, const void *a4, size_t a5)
{
  unint64_t v6 = a2;
  if (a3)
  {
    int v7 = sub_1CB8E509C(a1, "%fixed-stack.");
    return sub_1CD098D14(v7, v6, 0, 0, 0);
  }
  else
  {
    unint64_t v11 = sub_1CB8E509C(a1, "%stack.");
    uint64_t result = sub_1CD098D14(v11, v6, 0, 0, 0);
    if (a5)
    {
      BOOL v12 = (unsigned char *)*((void *)a1 + 4);
      if ((unint64_t)v12 >= *((void *)a1 + 3))
      {
        llvm::raw_ostream::write(a1, 46);
      }
      else
      {
        *((void *)a1 + 4) = v12 + 1;
        *BOOL v12 = 46;
      }
      uint64_t v13 = (void *)*((void *)a1 + 4);
      if (a5 <= *((void *)a1 + 3) - (void)v13)
      {
        uint64_t result = (llvm::raw_ostream *)memcpy(v13, a4, a5);
        *((void *)a1 + 4) += a5;
      }
      else
      {
        return llvm::raw_ostream::write(a1, (const char *)a4, a5);
      }
    }
  }
  return result;
}

llvm::raw_ostream *llvm::MachineOperand::printOperandOffset(llvm::raw_ostream *this, uint64_t a2)
{
  if (a2)
  {
    if (a2 < 0)
    {
      BOOL v3 = sub_1CB8E509C(this, " - ");
      unint64_t v4 = -a2;
    }
    else
    {
      BOOL v3 = sub_1CB8E509C(this, " + ");
      unint64_t v4 = a2;
    }
    return llvm::raw_ostream::operator<<(v3, v4);
  }
  return this;
}

llvm::raw_ostream *llvm::MachineOperand::printIRSlotNumber(llvm::MachineOperand *this, llvm::raw_ostream *a2)
{
  if (a2 == -1) {
    return sub_1CB8E509C(this, "<badref>");
  }
  else {
    return llvm::raw_ostream::operator<<(this, (int)a2);
  }
}

void llvm::MachineOperand::print(llvm::MachineOperand *this, llvm::raw_ostream *a2, const llvm::TargetRegisterInfo *a3, const llvm::TargetIntrinsicInfo *a4)
{
}

void llvm::MachineOperand::print(llvm::raw_ostream *a1, llvm::MachineOperand *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint64_t v10 = *(void *)(v9 + 24);
    if (v10)
    {
      uint64_t v11 = *(void *)(v10 + 32);
      if (v11)
      {
        a4 = (*(uint64_t (**)(void))(**(void **)(v11 + 16) + 176))(*(void *)(v11 + 16));
        a5 = (*(uint64_t (**)(void))(**(void **)(v11 + 8) + 56))(*(void *)(v11 + 8));
      }
    }
  }
  v12[0] = (const llvm::Function *)&unk_1F26160C0;
  v12[1] = 0;
  __int16 v13 = 256;
  uint64_t v18 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v14 = 0;
  llvm::MachineOperand::print(a1, a2, v12, a3, 0, 0, 1, 1, 0, a4, a5);
  llvm::ModuleSlotTracker::~ModuleSlotTracker((llvm::ModuleSlotTracker *)v12);
}

void llvm::MachineOperand::dump(llvm::MachineOperand *this)
{
  uint64_t v2 = llvm::dbgs(this);
  llvm::MachineOperand::print(this, v2, 0, 0, 0);
  BOOL v3 = (unsigned char *)*((void *)v2 + 4);
  if ((unint64_t)v3 >= *((void *)v2 + 3))
  {
    llvm::raw_ostream::write(v2, 10);
  }
  else
  {
    *((void *)v2 + 4) = v3 + 1;
    *BOOL v3 = 10;
  }
}

uint64_t llvm::MachinePointerInfo::isDereferenceable(llvm::MachinePointerInfo *this, unsigned int a2, llvm::LLVMContext *a3, const llvm::DataLayout *a4)
{
  uint64_t v4 = *(void *)this;
  if ((*(void *)this & 4) != 0) {
    return 0;
  }
  unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFF8;
  if ((v4 & 0xFFFFFFFFFFFFFFF8) == 0) {
    return 0;
  }
  uint64_t PointerAlignElem = llvm::DataLayout::getPointerAlignElem(a4, 0);
  sub_1CB8F1EEC((uint64_t)&v12, *(_DWORD *)(PointerAlignElem + 4), *((void *)this + 1) + a2);
  uint64_t isDereferenceableAndAlignedPointer = llvm::isDereferenceableAndAlignedPointer(v5, 0, (uint64_t)&v12, (uint64_t)a4, 0, 0, 0);
  if (v13 >= 0x41 && v12) {
    MEMORY[0x1D25D9CB0](v12, 0x1000C8000313F17);
  }
  return isDereferenceableAndAlignedPointer;
}

uint64_t llvm::MachinePointerInfo::getConstantPool@<X0>(llvm::PseudoSourceValueManager **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = llvm::PseudoSourceValueManager::getConstantPool(this[54]);
  *(void *)a2 = result | 4;
  *(void *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 20) = 0;
  if (result) {
    int v5 = *(_DWORD *)(result + 12);
  }
  else {
    int v5 = 0;
  }
  *(_DWORD *)(a2 + 16) = v5;
  return result;
}

uint64_t llvm::MachinePointerInfo::getJumpTable@<X0>(llvm::PseudoSourceValueManager **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = llvm::PseudoSourceValueManager::getJumpTable(this[54]);
  *(void *)a2 = result | 4;
  *(void *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 20) = 0;
  if (result) {
    int v5 = *(_DWORD *)(result + 12);
  }
  else {
    int v5 = 0;
  }
  *(_DWORD *)(a2 + 16) = v5;
  return result;
}

uint64_t llvm::MachinePointerInfo::getUnknownStack@<X0>(llvm::MachinePointerInfo *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = llvm::MachineFunction::getDataLayout(this);
  int v5 = *(_DWORD *)(result + 4);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = v5;
  *(unsigned char *)(a2 + 20) = 0;
  return result;
}

__n128 llvm::MachineMemOperand::refineAlignment(llvm::MachineMemOperand *this, const llvm::MachineMemOperand *a2)
{
  unsigned int v2 = *((unsigned __int8 *)a2 + 34);
  if (v2 >= *((unsigned __int8 *)this + 34))
  {
    *((unsigned char *)this + 34) = v2;
    __n128 result = *(__n128 *)a2;
    *(void *)((char *)this + 13) = *(void *)((char *)a2 + 13);
    *(__n128 *)this = result;
  }
  return result;
}

uint64_t sub_1CD53A940(uint64_t a1, char *__str, size_t __size)
{
  return snprintf(__str, __size, *(const char **)(a1 + 8), *(unsigned __int8 *)(a1 + 16));
}

void sub_1CD53A978(__n128 *a1, int **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCF150, 0, 0);
  dword_1EBCCF1D0 = 0;
  qword_1EBCCF1D8 = (uint64_t)&unk_1F25F74C8;
  *(void *)&dword_1EBCCF1E0 = 0;
  qword_1EBCCF150 = (uint64_t)&unk_1F2643F68;
  qword_1EBCCF1E8 = (uint64_t)&unk_1F2643D20;
  qword_1EBCCF1F0 = (uint64_t)&unk_1F25F7480;
  qword_1EBCCF208 = (uint64_t)&qword_1EBCCF1F0;
  sub_1CD53AA68(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCF150);
}

__n128 sub_1CD53AA68(__n128 *a1, int **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCF150, "print-regmask-num-regs", 0x16uLL);
  __n128 result = *a1;
  xmmword_1EBCCF170 = (__int128)*a1;
  int v7 = *a2;
  dword_1EBCCF1D0 = **a2;
  byte_1EBCCF1E4 = 1;
  dword_1EBCCF1E0 = *v7;
  word_1EBCCF15A = (32 * (*a3 & 3)) | word_1EBCCF15A & 0xFF9F;
  return result;
}

unint64_t sub_1CD53AAF0(void *a1, _DWORD *__dst, char *a3, int a4, uint64_t *a5)
{
  uint64_t v11 = 0;
  uint64_t v8 = sub_1CC0AC9D0(a1, &v11, __dst, (unint64_t)a3, a4);
  uint64_t v12 = v11;
  uint64_t v9 = (char *)sub_1CC2E96A4(a1, &v12, v8, (unint64_t)a3, *a5);
  return sub_1CC36B0E4((uint64_t)a1, v12, v9, a3);
}

unint64_t sub_1CD53AB74(void *a1, _DWORD *__dst, char *a3, int a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v13 = 0;
  uint64_t v10 = sub_1CC0AC9D0(a1, &v13, __dst, (unint64_t)a3, a4);
  uint64_t v14 = v13;
  uint64_t v11 = sub_1CC2E96A4(a1, &v14, v10, (unint64_t)a3, *a5);
  return sub_1CD53AC00(a1, v14, v11, a3, a6);
}

unint64_t sub_1CD53AC00(void *a1, uint64_t a2, void *a3, char *a4, uint64_t a5)
{
  uint64_t v11 = a2;
  unint64_t v8 = llvm::hash_value(*(void **)a5, *(void *)(a5 + 8));
  uint64_t v9 = (char *)sub_1CBFFCBA0(a1, &v11, a3, (unint64_t)a4, v8);
  return sub_1CC36B0E4((uint64_t)a1, v11, v9, a4);
}

unint64_t sub_1CD53AC70(void *a1, unsigned char *__dst, char *a3, char a4, int *a5, uint64_t *a6, uint64_t *a7)
{
  uint64_t v15 = 0;
  uint64_t v12 = sub_1CC0AC730(a1, &v15, __dst, (unint64_t)a3, a4);
  uint64_t v16 = v15;
  uint64_t v13 = sub_1CC0AC9D0(a1, &v16, v12, (unint64_t)a3, *a5);
  return sub_1CD53AD0C(a1, v16, v13, a3, *a6, a7);
}

unint64_t sub_1CD53AD0C(void *a1, uint64_t a2, void *a3, char *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v12 = a2;
  uint64_t v9 = sub_1CC2E96A4(a1, &v12, a3, (unint64_t)a4, a5);
  uint64_t v13 = v12;
  uint64_t v10 = (char *)sub_1CC2E96A4(a1, &v13, v9, (unint64_t)a4, *a6);
  return sub_1CC36B0E4((uint64_t)a1, v13, v10, a4);
}

unint64_t sub_1CD53AD84(void *a1, uint64_t a2, _DWORD *a3, char *a4, int *a5, uint64_t *a6)
{
  uint64_t v12 = a2;
  uint64_t v9 = sub_1CC0AC9D0(a1, &v12, a3, (unint64_t)a4, *a5);
  uint64_t v13 = v12;
  uint64_t v10 = (char *)sub_1CC2E96A4(a1, &v13, v9, (unint64_t)a4, *a6);
  return sub_1CC36B0E4((uint64_t)a1, v13, v10, a4);
}

unint64_t sub_1CD53AE00(void *a1, unsigned char *__dst, char *a3, char a4, int *a5, uint64_t a6)
{
  uint64_t v13 = 0;
  uint64_t v10 = sub_1CC0AC730(a1, &v13, __dst, (unint64_t)a3, a4);
  uint64_t v14 = v13;
  uint64_t v11 = sub_1CC0AC9D0(a1, &v14, v10, (unint64_t)a3, *a5);
  return sub_1CD53AE8C(a1, v14, v11, a3, a6);
}

unint64_t sub_1CD53AE8C(void *a1, uint64_t a2, void *a3, char *a4, uint64_t a5)
{
  uint64_t v11 = a2;
  unint64_t v8 = sub_1CC36B4D0(*(void **)a5, *(void *)a5 + 4 * *(void *)(a5 + 8));
  uint64_t v9 = (char *)sub_1CBFFCBA0(a1, &v11, a3, (unint64_t)a4, v8);
  return sub_1CC36B0E4((uint64_t)a1, v11, v9, a4);
}

uint64_t llvm::DiagnosticInfoMIROptimization::MachineArgument::MachineArgument(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3, llvm::MachineInstr *a4)
{
  *(_WORD *)(a1 + 23) = 6;
  strcpy((char *)a1, "String");
  uint64_t v6 = a1 + 24;
  *(void *)(a1 + 55) = 0;
  *(void *)(a1 + 47) = 0;
  *(unsigned char *)(a1 + 63) = 0;
  std::string::__init(&v8, a2, a3);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(std::string *)a1 = v8;
  LODWORD(v8.__r_.__value_.__r.__words[1]) = 0;
  char v11 = 0;
  uint64_t v12 = 0;
  uint64_t v14 = v6;
  int v13 = 0;
  v8.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
  v8.__r_.__value_.__r.__words[2] = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  llvm::MachineInstr::print(a4, (llvm::raw_ostream *)&v8, (const llvm::TargetRegisterInfo *)1, 0, 1, 1, 0);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v8);
  return a1;
}

llvm::MachineOptimizationRemarkEmitterPass *llvm::MachineOptimizationRemarkEmitterPass::MachineOptimizationRemarkEmitterPass(llvm::MachineOptimizationRemarkEmitterPass *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)llvm::MachineOptimizationRemarkEmitterPass::ID);
  *(void *)unsigned int v2 = &unk_1F260ED50;
  *((void *)v2 + 31) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF210, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC36B89C;
    v6[1] = &PassRegistry;
    int v5 = v6;
    std::__call_once(&qword_1EBCCF210, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeMachineOptimizationRemarkEmitterPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF210, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC36B89C;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCCF210, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::MachineOptimizationRemarkEmitterPass::getAnalysisUsage(llvm::MachineOptimizationRemarkEmitterPass *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::LazyMachineBlockFrequencyInfoPass::ID);
  *((unsigned char *)a2 + 160) = 1;

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

void llvm::callDefaultCtor<llvm::MachineOptimizationRemarkEmitterPass>()
{
}

void llvm::createMachineOutlinerPass(llvm *this)
{
}

void llvm::initializeMachineOutlinerPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF220, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC36BBBC;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCCF220, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD53B264(uint64_t a1, uint64_t a2, llvm::MachineInstrExpressionTrait *this, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CC370130((uint64_t *)a2, this, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CC370220(a2, (uint64_t)this, this, v12);
    uint64_t v9 = (uint64_t *)result;
    *(void *)uint64_t result = *(void *)this;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD53B300(uint64_t a1, int a2, int a3, uint64_t *a4, uint64_t *a5, uint64_t a6, int a7, unsigned int a8)
{
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9 >= *(void *)(a1 + 16))
  {
    uint64_t result = sub_1CC370600((long long **)a1, a2, a3, *a4, *a5, a6, a7, a8);
  }
  else
  {
    *(_DWORD *)unint64_t v9 = a2;
    *(_DWORD *)(v9 + 4) = a3;
    *(void *)(v9 + 8) = *a4;
    *(void *)(v9 + 16) = *a5;
    *(void *)(v9 + 24) = a6;
    *(_DWORD *)(v9 + 32) = 0;
    *(void *)(v9 + 40) = 0;
    *(void *)(v9 + 48) = v9 + 64;
    *(void *)(v9 + 56) = 0x600000000;
    *(_DWORD *)(v9 + 112) = 0;
    *(void *)(v9 + 120) = 0;
    *(void *)(v9 + 128) = v9 + 144;
    *(void *)(v9 + 136) = 0x600000000;
    *(_DWORD *)(v9 + 192) = 0;
    *(_WORD *)(v9 + 200) = 0;
    *(_DWORD *)(v9 + 204) = a7;
    *(_DWORD *)(v9 + 208) = 0;
    *(_DWORD *)(v9 + 212) = a8;
    *(_DWORD *)(v9 + 216) = 0;
    uint64_t result = v9 + 224;
  }
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t sub_1CD53B394(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(void *)(a1 + 48) = a1 + 64;
  uint64_t v6 = a1 + 48;
  *(void *)(a1 + 56) = 0x600000000;
  if (*((_DWORD *)a2 + 14)) {
    sub_1CB837F14(v6, (uint64_t)(a2 + 3));
  }
  *(void *)(a1 + 128) = a1 + 144;
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a2 + 28);
  *(void *)(a1 + 120) = *((void *)a2 + 15);
  *(void *)(a1 + 136) = 0x600000000;
  if (*((_DWORD *)a2 + 34)) {
    sub_1CB837F14(a1 + 128, (uint64_t)(a2 + 8));
  }
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a2 + 48);
  long long v7 = *(long long *)((char *)a2 + 200);
  *(_DWORD *)(a1 + 216) = *((_DWORD *)a2 + 54);
  *(_OWORD *)(a1 + 200) = v7;
  return a1;
}

uint64_t sub_1CD53B448(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(void *)(a1 + 48) = a1 + 64;
  uint64_t v6 = a1 + 48;
  *(void *)(a1 + 56) = 0x600000000;
  if (*((_DWORD *)a2 + 14)) {
    sub_1CBAF13E8(v6, (uint64_t)(a2 + 3));
  }
  *(void *)(a1 + 128) = a1 + 144;
  *(_DWORD *)(a1 + 112) = *((_DWORD *)a2 + 28);
  *(void *)(a1 + 120) = *((void *)a2 + 15);
  *(void *)(a1 + 136) = 0x600000000;
  if (*((_DWORD *)a2 + 34)) {
    sub_1CBAF13E8(a1 + 128, (uint64_t)(a2 + 8));
  }
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a2 + 48);
  long long v7 = *(long long *)((char *)a2 + 200);
  *(_DWORD *)(a1 + 216) = *((_DWORD *)a2 + 54);
  *(_OWORD *)(a1 + 200) = v7;
  return a1;
}

void sub_1CD53B4FC(uint64_t a1)
{
  if (*(void *)a1)
  {
    sub_1CC37058C(a1, *(char **)a1);
    operator delete(*(void **)a1);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
}

void sub_1CD53B538(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    long long v5 = (char *)sub_1CC372194(a3, *(void *)(a1 + 8), a2);
    sub_1CC37058C(a1, v5);
  }
}

void llvm::initializeMachinePipelinerPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF3A8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC375454;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCF3A8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::MachinePipeliner::swingModuloScheduler(llvm::MachinePipeliner *this, llvm::MachineLoop *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  long long v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_2:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::LiveIntervals::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_2;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::LiveIntervals::ID);
  sub_1CD540C50((uint64_t)v16, (uint64_t)this, (uint64_t)a2, v8, (uint64_t)this + 296, *((_DWORD *)this + 135));
  unint64_t v9 = (llvm::MachineBasicBlock *)**((void **)a2 + 4);
  llvm::ScheduleDAGInstrs::startBlock((uint64_t)v16, v9);
  char v10 = (void *)((char *)v9 + 48);
  int v11 = -1;
  uint64_t v12 = (void *)((char *)v9 + 48);
  do
  {
    uint64_t v12 = (void *)v12[1];
    ++v11;
  }
  while (v12 != v10);
  for (unint64_t i = llvm::MachineBasicBlock::getFirstTerminator(v9); (void *)i != v10; --v11)
  {
    if (!i || (*(unsigned char *)i & 4) == 0)
    {
      while ((*(_WORD *)(i + 44) & 8) != 0)
        unint64_t i = *(void *)(i + 8);
    }
    unint64_t i = *(void *)(i + 8);
  }
  uint64_t v14 = *((void *)v9 + 7);
  unint64_t FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator(v9);
  llvm::ScheduleDAGInstrs::enterRegion((uint64_t)v16, (uint64_t)v9, v14, FirstTerminator, v11);
  llvm::SwingSchedulerDAG::schedule((llvm::SwingSchedulerDAG *)v16);
}

uint64_t llvm::MachinePipeliner::preprocessPhiNodes(llvm::MachinePipeliner *this, llvm::MachineBasicBlock *a2)
{
  uint64_t v3 = *((void *)this + 31);
  long long v4 = (uint64_t *)*((void *)this + 1);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_4:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::LiveIntervals::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_4;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = *(void *)(v3 + 40);
  uint64_t v23 = *(void *)((*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::LiveIntervals::ID)
                  + 288);
  uint64_t v9 = *((void *)a2 + 7);
  uint64_t result = llvm::MachineBasicBlock::getFirstNonPHI(a2);
  if (v9 != result)
  {
    uint64_t v11 = result;
    do
    {
      int v12 = *(_DWORD *)(v9 + 40);
      if (v12 != 1)
      {
        unint64_t v13 = *(void *)(*(void *)(v8 + 24) + 16 * (*(_DWORD *)(*(void *)(v9 + 32) + 4) & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v14 = 1;
        do
        {
          unsigned int v15 = v14;
          uint64_t v16 = (llvm::MachineOperand *)(*(void *)(v9 + 32) + 32 * v14);
          if ((*(_DWORD *)v16 & 0xFFF00) != 0)
          {
            unsigned int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(v8, v13, "", 0);
            uint64_t v18 = *(llvm::MachineBasicBlock **)(*(void *)(v9 + 32) + 32 * (v15 + 1) + 16);
            unint64_t FirstTerminator = (unint64_t *)llvm::MachineBasicBlock::getFirstTerminator(v18);
            llvm::MachineBasicBlock::findDebugLoc((uint64_t)v18, (uint64_t)FirstTerminator, &v26);
            v25[0] = sub_1CB85AA4C((uint64_t)v18, FirstTerminator, &v26, *(void *)(*((void *)this + 36) + 8) + 912, VirtualRegister);
            v25[1] = v20;
            LODWORD(v18) = *((_DWORD *)v16 + 1);
            unsigned int v21 = sub_1CD53B9D0(v16);
            uint64_t v22 = sub_1CB89517C(v25, (int)v18, v21, (*(_DWORD *)v16 >> 8) & 0xFFF);
            sub_1CB914C88(v23, (uint64_t)v22[1], 0);
            uint64_t result = llvm::MachineOperand::setReg((uint64_t)v16, VirtualRegister);
            *(_DWORD *)v16 &= 0xFFF000FF;
            if (v26) {
              uint64_t result = llvm::MetadataTracking::untrack((uint64_t)&v26, v26);
            }
          }
          unsigned int v14 = v15 + 2;
        }
        while (v12 != v15 + 2);
      }
      if ((*(unsigned char *)v9 & 4) == 0)
      {
        while ((*(_WORD *)(v9 + 44) & 8) != 0)
          uint64_t v9 = *(void *)(v9 + 8);
      }
      uint64_t v9 = *(void *)(v9 + 8);
    }
    while (v9 != v11);
  }
  return result;
}

uint64_t sub_1CD53B9D0(llvm::MachineOperand *a1)
{
  unsigned int v1 = *(_DWORD *)a1;
  if ((*((_DWORD *)a1 + 1) - 1) <= 0x3FFFFFFE)
  {
    unsigned int v5 = *(_DWORD *)a1;
    BOOL isRenamable = llvm::MachineOperand::isRenamable(a1);
    unsigned int v1 = v5;
    if (isRenamable) {
      int v2 = 512;
    }
    else {
      int v2 = 0;
    }
  }
  else
  {
    int v2 = 0;
  }
  return (v1 >> 23) & 0x26 | (v1 >> 21) & 0x100 | HIBYTE(v1) & 0x80 | (16 * (HIBYTE(v1) & 1 & (v1 >> 26))) | (8 * (!(v1 & 0x1000000) & (v1 >> 26))) | v2;
}

uint64_t llvm::SwingSchedulerDAG::finishBlock(llvm::SwingSchedulerDAG *this)
{
  int v2 = (_DWORD *)((char *)this + 3200);
  uint64_t v3 = *((void *)this + 400);
  uint64_t v4 = *((unsigned int *)this + 804);
  uint64_t v5 = v3 + 16 * v4;
  if (*((_DWORD *)this + 802))
  {
    if (v4)
    {
      uint64_t v10 = 16 * v4;
      uint64_t v6 = *((void *)this + 400);
      while ((*(void *)v6 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v6 += 16;
        v10 -= 16;
        if (!v10) {
          goto LABEL_2;
        }
      }
    }
    else
    {
      uint64_t v6 = *((void *)this + 400);
    }
  }
  else
  {
LABEL_2:
    uint64_t v6 = v3 + 16 * v4;
  }
  uint64_t v7 = v3 + 16 * v4;
LABEL_4:
  while (v6 != v7)
  {
    llvm::MachineFunction::deleteMachineInstr(*((llvm::MachineFunction **)this + 4), *(llvm::MachineInstr **)(v6 + 8));
    uint64_t v8 = v6 + 16;
    uint64_t v6 = v5;
    if (v8 != v5)
    {
      uint64_t v6 = v8;
      while ((*(void *)v6 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v6 += 16;
        if (v6 == v5)
        {
          uint64_t v6 = v5;
          goto LABEL_4;
        }
      }
    }
  }
  sub_1CD3C7F68(v2);

  return llvm::ScheduleDAGInstrs::finishBlock((uint64_t)this);
}

void llvm::MachinePipeliner::getAnalysisUsage(llvm::MachinePipeliner *this, llvm::AnalysisUsage *a2)
{
  llvm::AnalysisUsage::addRequiredID(a2, llvm::AAResultsWrapperPass::ID);
  sub_1CB843600((uint64_t)a2, (uint64_t)a2 + 112, (uint64_t)llvm::AAResultsWrapperPass::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineLoopInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::LiveIntervals::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineOptimizationRemarkEmitterPass::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

uint64_t llvm::SwingSchedulerDAG::addLoopCarriedDependences(llvm::SwingSchedulerDAG *this, llvm::AAResults *a2)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  v57[0] = 0;
  v57[1] = 0;
  int v58 = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  uint64_t v59 = 0;
  VoidTy = (llvm::UndefValue *)llvm::Type::getVoidTy(****((llvm::Type *****)this + 4), a2);
  int v45 = llvm::UndefValue::get(VoidTy, v4);
  uint64_t v6 = *((void *)this + 6);
  uint64_t v5 = *((void *)this + 7);
  if (v6 != v5)
  {
    uint64_t v47 = *((void *)this + 7);
    while (1)
    {
      uint64_t v8 = *(void *)(v6 + 8);
      if ((*(_WORD *)(v8 + 44) & 0xC) != 0 && (*(_WORD *)(v8 + 44) & 4) == 0)
      {
        if (llvm::MachineInstr::hasPropertyInBundle(*(void *)(v6 + 8), 128, 1)) {
          goto LABEL_79;
        }
      }
      else if ((*(unsigned char *)(*(void *)(v8 + 16) + 8) & 0x80) != 0)
      {
        goto LABEL_79;
      }
      if (sub_1CC3526CC(v8)
        || llvm::MachineInstr::hasUnmodeledSideEffects((llvm::MachineInstr *)v8)
        || llvm::MachineInstr::hasOrderedMemoryRef((llvm::MachineInstr *)v8)
        && (!sub_1CBA0BB64(v8, 1)
         || (llvm::MachineInstr::isDereferenceableInvariantLoad((llvm::MachineInstr *)v8, a2) & 1) == 0))
      {
LABEL_79:
        sub_1CD53DE60((uint64_t)v57);
        goto LABEL_25;
      }
      if (!sub_1CBA0BB64(v8, 1))
      {
        if (sub_1CB8F9CA0(v8, 1))
        {
          int v62 = (uint64_t *)v64;
          uint64_t v63 = 0x400000000;
          sub_1CC37ADE8(v8, (uint64_t)&v62);
          int v46 = (llvm::MachineInstr *)v8;
          if (v63)
          {
            unsigned int v14 = v62;
            unsigned int v15 = &v62[v63];
            goto LABEL_30;
          }
          if (!HIDWORD(v63)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t *v62 = (uint64_t)v45;
          unsigned int v14 = v62;
          BOOL v42 = __CFADD__(v63, 1);
          int v44 = v63 + 1;
          LODWORD(v63) = v63 + 1;
          if (!v42)
          {
            unsigned int v15 = &v62[v44];
LABEL_30:
            uint64_t v48 = v15;
LABEL_31:
            unsigned int v50 = v14;
            uint64_t v16 = sub_1CD53DFD4((uint64_t)v57, *v14);
            if (v60 == v16) {
              goto LABEL_75;
            }
            uint64_t v17 = *(unsigned int *)(v16 + 16);
            if (!v17) {
              goto LABEL_75;
            }
            uint64_t v18 = *(uint64_t **)(v16 + 8);
            unsigned int v51 = &v18[v17];
LABEL_34:
            uint64_t v19 = *v18;
            int v68 = v71;
            uint64_t v69 = (uint64_t)v71;
            *(void *)&long long v70 = 8;
            DWORD2(v70) = 0;
            long long v65 = v67;
            HIDWORD(v66) = 8;
            *(void *)&v67[0] = v19;
            unsigned int v20 = 1;
            unsigned int v21 = v71;
            uint64_t v22 = v71;
            while (1)
            {
              uint64_t v23 = v65[--v20];
              LODWORD(v66) = v20;
              uint64_t v24 = *(unsigned int *)(v23 + 120);
              if (v24) {
                break;
              }
LABEL_46:
              if (!v20)
              {
                int v31 = 1;
                goto LABEL_49;
              }
            }
            uint64_t v25 = *(uint64_t **)(v23 + 112);
            uint64_t v26 = 16 * v24;
            while (1)
            {
              uint64_t v27 = *v25;
              if ((~*(_DWORD *)v25 & 6) == 0)
              {
                unint64_t v28 = v27 & 0xFFFFFFFFFFFFFFF8;
                uint64_t v29 = sub_1CB896AE8((uint64_t)&v68, v27 & 0xFFFFFFFFFFFFFFF8);
                unsigned int v21 = v68;
                uint64_t v22 = (long long *)v69;
                uint64_t v30 = (unsigned int *)&v70 + 1;
                if ((long long *)v69 != v68) {
                  uint64_t v30 = (unsigned int *)&v70;
                }
                if (v29 == (void *)(v69 + 8 * *v30))
                {
                  if (v6 == v28)
                  {
                    int v31 = 0;
LABEL_49:
                    if (v65 != (void *)v67)
                    {
                      free(v65);
                      unsigned int v21 = v68;
                      uint64_t v22 = (long long *)v69;
                    }
                    if (v22 != v21) {
                      free(v22);
                    }
                    if (v31)
                    {
                      uint64_t v32 = *(const llvm::MachineInstr **)(v19 + 8);
                      int v55 = 0;
                      unint64_t v56 = 0;
                      uint64_t v53 = 0;
                      uint64_t v54 = 0;
                      *(_WORD *)unsigned int v52 = 0;
                      if (llvm::TargetInstrInfo::getMemOperandWithOffset(*((llvm::TargetInstrInfo **)this + 2), v32, &v56, &v54, &v52[1], *((const llvm::TargetRegisterInfo **)this + 3)))
                      {
                        if (llvm::TargetInstrInfo::getMemOperandWithOffset(*((llvm::TargetInstrInfo **)this + 2), v46, &v55, &v53, v52, *((const llvm::TargetRegisterInfo **)this + 3))&& llvm::MachineOperand::isIdenticalTo(v56, v55)&& v52[1] == v52[0]&& (int)v54 < (int)v53)
                        {
                          goto LABEL_71;
                        }
                      }
                      if (!a2) {
                        goto LABEL_71;
                      }
                      uint64_t v33 = *((void *)v32 + 6);
                      if ((v33 & 7) != 0)
                      {
                        unint64_t v34 = *(void *)((v33 & 0xFFFFFFFFFFFFFFF8) + 8);
                      }
                      else
                      {
                        unint64_t v34 = v33 & 0xFFFFFFFFFFFFFFF8;
                        *((void *)v32 + 6) = v34;
                      }
                      uint64_t v35 = *((void *)v46 + 6);
                      if ((v35 & 7) != 0)
                      {
                        unint64_t v36 = *(void *)((v35 & 0xFFFFFFFFFFFFFFF8) + 8);
                      }
                      else
                      {
                        unint64_t v36 = v35 & 0xFFFFFFFFFFFFFFF8;
                        *((void *)v46 + 6) = v36;
                      }
                      if ((*(void *)v34 & 4) != 0) {
                        goto LABEL_71;
                      }
                      unint64_t v37 = *(void *)v34 & 0xFFFFFFFFFFFFFFF8;
                      if (!v37) {
                        goto LABEL_71;
                      }
                      if ((*(void *)v36 & 4) != 0) {
                        goto LABEL_71;
                      }
                      unint64_t v38 = *(void *)v36 & 0xFFFFFFFFFFFFFFF8;
                      if (!v38 || v37 == v38 && *(void *)(v34 + 8) <= *(void *)(v36 + 8)) {
                        goto LABEL_71;
                      }
                      int v68 = (long long *)(*(void *)v34 & 0xFFFFFFFFFFFFFFF8);
                      uint64_t v69 = -2;
                      long long v39 = *(_OWORD *)(v34 + 56);
                      long long v70 = *(_OWORD *)(v34 + 40);
                      v71[0] = v39;
                      uint64_t v40 = (*(void *)v36 & 4) != 0 ? 0 : (void *)(*(void *)v36 & 0xFFFFFFFFFFFFFFF8);
                      long long v65 = v40;
                      uint64_t v66 = -2;
                      long long v41 = *(_OWORD *)(v36 + 56);
                      v67[0] = *(_OWORD *)(v36 + 40);
                      v67[1] = v41;
                      if (llvm::AAResults::alias((uint64_t)a2, (uint64_t)&v68, (uint64_t)&v65))
                      {
LABEL_71:
                        int v68 = (long long *)(v19 | 6);
                        uint64_t v69 = 0x100000000;
                        llvm::SUnit::addPred(v6, (uint64_t *)&v68, 1);
                      }
                    }
                    if (++v18 == v51)
                    {
LABEL_75:
                      unsigned int v14 = v50 + 1;
                      if (v50 + 1 == v48)
                      {
                        unsigned int v14 = v62;
                        uint64_t v5 = v47;
                        break;
                      }
                      goto LABEL_31;
                    }
                    goto LABEL_34;
                  }
                  if (v66 >= (unint64_t)HIDWORD(v66)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  v65[v66] = v28;
                  LODWORD(v66) = v66 + 1;
                  sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v68, v28);
                  unsigned int v21 = v68;
                  uint64_t v22 = (long long *)v69;
                }
              }
              v25 += 2;
              v26 -= 16;
              if (!v26)
              {
                unsigned int v20 = v66;
                goto LABEL_46;
              }
            }
          }
          if (v14 != (uint64_t *)v64) {
            goto LABEL_24;
          }
        }
        goto LABEL_25;
      }
      int v68 = &v70;
      uint64_t v69 = 0x400000000;
      sub_1CC37ADE8(v8, (uint64_t)&v68);
      if (v69) {
        break;
      }
      if (!HIDWORD(v69)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)int v68 = v45;
      uint64_t v10 = (char *)v68;
      BOOL v42 = __CFADD__(v69, 1);
      unsigned int v43 = v69 + 1;
      LODWORD(v69) = v69 + 1;
      if (!v42)
      {
        uint64_t v11 = (char *)v68 + 8 * v43;
        goto LABEL_19;
      }
LABEL_22:
      if (v10 != (char *)&v70)
      {
        unsigned int v14 = (uint64_t *)v10;
LABEL_24:
        free(v14);
      }
LABEL_25:
      v6 += 272;
      if (v6 == v5) {
        return sub_1CD5412B8((uint64_t)v57);
      }
    }
    uint64_t v10 = (char *)v68;
    uint64_t v11 = (char *)v68 + 8 * v69;
    do
    {
LABEL_19:
      long long v65 = *(void **)v10;
      uint64_t v12 = sub_1CD53DEB8((uint64_t)v57, (uint64_t *)&v65);
      unint64_t v13 = *(unsigned int *)(v12 + 8);
      if (v13 >= *(unsigned int *)(v12 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v12 + 8 * v13) = v6;
      ++*(_DWORD *)(v12 + 8);
      v10 += 8;
    }
    while (v10 != v11);
    uint64_t v10 = (char *)v68;
    uint64_t v5 = v47;
    goto LABEL_22;
  }
  return sub_1CD5412B8((uint64_t)v57);
}

void llvm::SwingSchedulerDAG::changeDependences(llvm::SwingSchedulerDAG *this)
{
  v40[8] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)this + 6);
  for (uint64_t i = *((void *)this + 7); v1 != i; v1 += 272)
  {
    unsigned int v37 = 0;
    unsigned int v35 = 0;
    uint64_t v34 = 0;
    if (llvm::SwingSchedulerDAG::canUseLastOffsetValue(this, *(llvm::MachineInstr **)(v1 + 8), &v37, &v36, &v35, &v34))
    {
      Uniqueuint64_t VRegDef = (void *)llvm::MachineRegisterInfo::getUniqueVRegDef(*((void *)this + 5), *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 32) + 32 * v37 + 4));
      if (UniqueVRegDef)
      {
        unint64_t v38 = UniqueVRegDef;
        unint64_t v31 = 0;
        if (sub_1CD3C8538((uint64_t *)this + 119, &v38, &v31))
        {
          uint64_t v5 = *(void *)(v31 + 8);
          if (v5)
          {
            unsigned int v6 = v35;
            uint64_t v7 = (void *)llvm::MachineRegisterInfo::getUniqueVRegDef(*((void *)this + 5), v35);
            if (v7)
            {
              unint64_t v38 = v7;
              unint64_t v31 = 0;
              if (sub_1CD3C8538((uint64_t *)this + 119, &v38, &v31))
              {
                uint64_t v8 = *(void *)(v31 + 8);
                if (v8)
                {
                  if (!llvm::ScheduleDAGTopologicalSort::IsReachable((llvm::SwingSchedulerDAG *)((char *)this + 2688), (const llvm::SUnit *)v1, *(const llvm::SUnit **)(v31 + 8)))
                  {
                    unint64_t v38 = v40;
                    uint64_t v39 = 0x400000000;
                    uint64_t v9 = *(unsigned int *)(v1 + 40);
                    if (v9)
                    {
                      unsigned int v13 = 0;
                      uint64_t v14 = 16 * v9;
                      unsigned int v15 = (uint64_t *)(*(void *)(v1 + 32) + 8);
                      do
                      {
                        uint64_t v16 = *(v15 - 1);
                        if (v5 == (v16 & 0xFFFFFFFFFFFFFFF8))
                        {
                          uint64_t v17 = *v15;
                          if (v13 >= HIDWORD(v39)) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          uint64_t v18 = (char *)v38 + 16 * v13;
                          void *v18 = v16;
                          v18[1] = v17;
                          unsigned int v13 = v39 + 1;
                          LODWORD(v39) = v39 + 1;
                        }
                        v15 += 2;
                        v14 -= 16;
                      }
                      while (v14);
                      if (v13)
                      {
                        uint64_t v28 = 0;
                        uint64_t v29 = 16 * v13;
                        do
                        {
                          llvm::ScheduleDAGTopologicalSort::RemovePred((llvm::SwingSchedulerDAG *)((char *)this + 2688), (llvm::SUnit *)v1, (llvm::SUnit *)(*(void *)((unsigned char *)v38 + v28) & 0xFFFFFFFFFFFFFFF8));
                          llvm::SUnit::removePred(v1, (uint64_t)v38 + v28);
                          v28 += 16;
                        }
                        while (v29 != v28);
                      }
                    }
                    LODWORD(v39) = 0;
                    uint64_t v10 = *(unsigned int *)(v8 + 40);
                    if (v10)
                    {
                      unsigned int v19 = 0;
                      uint64_t v20 = 16 * v10;
                      unsigned int v21 = (uint64_t *)(*(void *)(v8 + 32) + 8);
                      do
                      {
                        uint64_t v22 = *(v21 - 1);
                        if ((~(_BYTE)v22 & 6) == 0 && v1 == (v22 & 0xFFFFFFFFFFFFFFF8))
                        {
                          uint64_t v24 = *v21;
                          if (v19 >= HIDWORD(v39)) {
                            llvm::SmallVectorBase<unsigned int>::grow_pod();
                          }
                          uint64_t v25 = (char *)v38 + 16 * v19;
                          *uint64_t v25 = v22;
                          v25[1] = v24;
                          unsigned int v19 = v39 + 1;
                          LODWORD(v39) = v39 + 1;
                        }
                        v21 += 2;
                        v20 -= 16;
                      }
                      while (v20);
                      if (v19)
                      {
                        uint64_t v26 = 0;
                        uint64_t v27 = 16 * v19;
                        do
                        {
                          llvm::ScheduleDAGTopologicalSort::RemovePred((llvm::SwingSchedulerDAG *)((char *)this + 2688), (llvm::SUnit *)v8, (llvm::SUnit *)(*(void *)((unsigned char *)v38 + v26) & 0xFFFFFFFFFFFFFFF8));
                          llvm::SUnit::removePred(v8, (uint64_t)v38 + v26);
                          v26 += 16;
                        }
                        while (v27 != v26);
                      }
                    }
                    unint64_t v31 = v1 & 0xFFFFFFFFFFFFFFF9 | 2;
                    unsigned int v32 = v6;
                    int v33 = 0;
                    llvm::ScheduleDAGTopologicalSort::AddPred((llvm::SwingSchedulerDAG *)((char *)this + 2688), (llvm::SUnit *)v8, (llvm::SUnit *)v1);
                    llvm::SUnit::addPred(v8, (uint64_t *)&v31, 1);
                    uint64_t v11 = v34;
                    uint64_t v30 = v1;
                    uint64_t v12 = sub_1CD542CF8((uint64_t)this + 3176, &v30);
                    *((_DWORD *)v12 + 2) = v6;
                    _OWORD v12[2] = v11;
                    if (v38 != v40) {
                      free(v38);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void llvm::SwingSchedulerDAG::findCircuits(uint64_t a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (void *)(a1 + 48);
  sub_1CC37B028(*(void *)(a1 + 48), *(void *)(a1 + 56));
  sub_1CD541AFC((uint64_t)v2, v1);
}

void llvm::SwingSchedulerDAG::calculateResMII(llvm::SwingSchedulerDAG *this)
{
}

void *llvm::SwingSchedulerDAG::fuseRecs(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 8);
  if (v2)
  {
    uint64_t v4 = *(void *)a2;
    uint64_t v5 = *(void *)a2 + 88 * v2;
    uint64_t v6 = *(void *)a2;
    do
    {
      uint64_t v7 = v6;
      v6 += 88;
      if (v6 == v5)
      {
        uint64_t v8 = v5;
      }
      else
      {
        uint64_t v8 = v6;
        do
        {
          uint64_t v9 = *(uint64_t **)(v8 + 24);
          if (*(_DWORD *)(**(void **)(v7 + 24) + 192) == *(_DWORD *)(*v9 + 192))
          {
            int v10 = *(_DWORD *)(v8 + 52);
            if (v10 - *(_DWORD *)(v7 + 52) >= 1) {
              *(_DWORD *)(v7 + 52) = v10;
            }
            uint64_t v11 = *(uint64_t **)(v8 + 32);
            if (v9 != v11)
            {
              do
              {
                uint64_t v12 = *v9++;
                uint64_t v15 = v12;
                sub_1CC37AF14((void *)v7, &v15);
              }
              while (v9 != v11);
              uint64_t v4 = *(void *)a2;
              uint64_t v2 = *(unsigned int *)(a2 + 8);
            }
            sub_1CC37F3B0(v8 + 88, v4 + 88 * v2, v8);
            unsigned int v13 = *(_DWORD *)(a2 + 8) - 1;
            *(_DWORD *)(a2 + 8) = v13;
            uint64_t result = sub_1CD456CB4((void *)(*(void *)a2 + 88 * v13));
            uint64_t v4 = *(void *)a2;
            uint64_t v2 = *(unsigned int *)(a2 + 8);
            uint64_t v5 = *(void *)a2 + 88 * v2;
          }
          else
          {
            v8 += 88;
          }
        }
        while (v8 != v5);
      }
      uint64_t v5 = v8;
    }
    while (v6 != v8);
  }
  return result;
}

void llvm::SwingSchedulerDAG::computeNodeFunctions(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 4);
  uint64_t v5 = *(void *)(a1 + 3104);
  unint64_t v6 = (*(void *)(a1 + 3112) - v5) >> 4;
  if (v4 > v6)
  {
    sub_1CD54316C((char **)(a1 + 3104), v4 - v6);
  }
  else if (v4 < v6)
  {
    *(void *)(a1 + 3112) = v5 + 0xF0F0F0F0F0F0F10 * ((uint64_t)(*(void *)(a1 + 56) - *(void *)(a1 + 48)) >> 4);
  }
  uint64_t v7 = *(int **)(a1 + 2984);
  uint64_t v8 = *(int **)(a1 + 2992);
  if (v7 != v8)
  {
    int v9 = 0;
    uint64_t v10 = *(void *)(a1 + 48);
    uint64_t v11 = *(void *)(a1 + 3104);
    uint64_t v12 = *(int **)(a1 + 2984);
    do
    {
      uint64_t v13 = *v12;
      uint64_t v14 = v10 + 272 * (int)v13;
      uint64_t v15 = *(unsigned int *)(v14 + 40);
      if (v15)
      {
        int v16 = 0;
        int v17 = 0;
        uint64_t v18 = *(void *)(v14 + 32);
        uint64_t v19 = v18 + 16 * v15;
        do
        {
          unint64_t v20 = *(void *)v18 & 0xFFFFFFFFFFFFFFF8;
          int v21 = *(_DWORD *)(v18 + 12);
          if (!v21)
          {
            int v22 = *(_DWORD *)(v11 + 16 * *(unsigned int *)(v20 + 192) + 8);
            if (v17 <= v22 + 1) {
              int v17 = v22 + 1;
            }
          }
          uint64_t v23 = *(void *)v18 & 6;
          BOOL v25 = v23 == 6 && *(_DWORD *)(v18 + 8) == 3;
          if (v23 != 2 && !v25)
          {
            int v26 = *(_DWORD *)(v11 + 16 * *(unsigned int *)(v20 + 192)) + v21;
            if (v16 <= v26) {
              int v16 = v26;
            }
          }
          v18 += 16;
        }
        while (v18 != v19);
      }
      else
      {
        int v17 = 0;
        int v16 = 0;
      }
      if (v9 <= v16) {
        int v9 = v16;
      }
      uint64_t v27 = (_DWORD *)(v11 + 16 * v13);
      *uint64_t v27 = v16;
      v27[2] = v17;
      ++v12;
    }
    while (v12 != v8);
    do
    {
      uint64_t v29 = *--v8;
      uint64_t v28 = v29;
      uint64_t v30 = v10 + 272 * (int)v29;
      uint64_t v31 = *(unsigned int *)(v30 + 120);
      if (v31)
      {
        int v32 = 0;
        uint64_t v33 = *(void *)(v30 + 112);
        uint64_t v34 = v33 + 16 * v31;
        int v35 = v9;
        do
        {
          unint64_t v36 = *(void *)v33 & 0xFFFFFFFFFFFFFFF8;
          int v37 = *(_DWORD *)(v33 + 12);
          if (!v37)
          {
            int v38 = *(_DWORD *)(v11 + 16 * *(unsigned int *)(v36 + 192) + 12);
            if (v32 <= v38 + 1) {
              int v32 = v38 + 1;
            }
          }
          uint64_t v39 = *(void *)v33 & 6;
          BOOL v41 = v39 == 6 && *(_DWORD *)(v33 + 8) == 3;
          if (v39 != 2 && !v41)
          {
            int v42 = *(_DWORD *)(v11 + 16 * *(unsigned int *)(v36 + 192) + 4) - v37;
            if (v42 < v35) {
              int v35 = v42;
            }
          }
          v33 += 16;
        }
        while (v33 != v34);
      }
      else
      {
        int v32 = 0;
        int v35 = v9;
      }
      uint64_t v43 = v11 + 16 * v28;
      *(_DWORD *)(v43 + 4) = v35;
      *(_DWORD *)(v43 + 12) = v32;
    }
    while (v8 != v7);
  }
  unsigned int v44 = *(_DWORD *)(a2 + 8);
  if (v44)
  {
    uint64_t v45 = *(void *)a2;
    uint64_t v46 = 88 * v44;
    do
    {
      sub_1CD53F35C(v45, a1);
      v45 += 88;
      v46 -= 88;
    }
    while (v46);
  }
}

void llvm::SwingSchedulerDAG::colocateNodeSets(uint64_t a1, uint64_t *a2)
{
  v37[8] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((unsigned int *)a2 + 2);
  if ((int)v2 >= 1)
  {
    uint64_t v4 = 0;
    int v18 = 0;
    int64x2_t v20 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    uint64_t v5 = 1;
    while (1)
    {
      uint64_t v6 = *a2;
      uint64_t v30 = 1;
      int64x2_t v31 = v20;
      int64x2_t v32 = v20;
      int64x2_t v33 = v20;
      int64x2_t v34 = v20;
      uint64_t v7 = v6 + 88 * v4;
      int v35 = v37;
      uint64_t v36 = 0x800000000;
      uint64_t v19 = v5;
      if (*(void *)(v7 + 24) != *(void *)(v7 + 32) && sub_1CC37B1BC(v7, (uint64_t)&v30, 0) && v4 < v2 - 1) {
        break;
      }
LABEL_8:
      if (v35 != v37) {
        free(v35);
      }
      if ((v30 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v31.i64[0], 8);
      }
      ++v4;
      uint64_t v5 = v19 + 1;
      if (v4 == v2) {
        return;
      }
    }
    uint64_t v17 = v6;
    int v9 = (_DWORD *)(v6 + 88 * v4 + 52);
    while (1)
    {
      uint64_t v10 = *a2;
      uint64_t v11 = *a2 + 88 * v5;
      if (*v9 != *(_DWORD *)(v11 + 52)) {
        goto LABEL_27;
      }
      uint64_t v22 = 1;
      int64x2_t v23 = v20;
      int64x2_t v24 = v20;
      int64x2_t v25 = v20;
      int64x2_t v26 = v20;
      uint64_t v27 = v29;
      uint64_t v28 = 0x800000000;
      if (*(void *)(v11 + 24) == *(void *)(v11 + 32) || !sub_1CC37B1BC(v11, (uint64_t)&v22, 0))
      {
        int v14 = 7;
      }
      else
      {
        int v12 = v36;
        int v13 = v28;
        if (v36 > v28) {
          goto LABEL_19;
        }
        if (v36)
        {
          uint64_t v15 = (uint64_t *)v35;
          uint64_t v16 = 8 * v36;
          while ((sub_1CD5434AC((uint64_t)&v22, *v15, &v21) & 1) != 0)
          {
            ++v15;
            v16 -= 8;
            if (!v16)
            {
              int v12 = v36;
              int v13 = v28;
              goto LABEL_34;
            }
          }
          int v14 = 0;
        }
        else
        {
LABEL_34:
          if (v12 != v13)
          {
LABEL_19:
            int v14 = 0;
            goto LABEL_21;
          }
          *(_DWORD *)(v17 + 88 * v4 + 64) = ++v18;
          *(_DWORD *)(v10 + 88 * v5 + 64) = v18;
          int v14 = 5;
        }
      }
LABEL_21:
      if (v27 != v29) {
        free(v27);
      }
      if ((v22 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v23.i64[0], 8);
      }
      if (v14 != 7 && v14) {
        goto LABEL_8;
      }
LABEL_27:
      if (++v5 == v2) {
        goto LABEL_8;
      }
    }
  }
}

void *llvm::SwingSchedulerDAG::checkNodeSets(void *result, _DWORD *a2)
{
  unsigned int v2 = *((_DWORD *)result + 660);
  if (v2 >= 0x11)
  {
    unsigned int v4 = a2[2];
    if (v4)
    {
      uint64_t v5 = (unsigned int *)(*(void *)a2 + 60);
      uint64_t v6 = 88 * v4;
      while ((int)*(v5 - 2) <= 2 && *v5 <= v2)
      {
        v5 += 22;
        v6 -= 88;
        if (!v6)
        {
          uint64_t v7 = 88 * v4;
          uint64_t v8 = *(void *)a2 - 88;
          do
          {
            uint64_t result = sub_1CD456CB4((void *)(v8 + v7));
            v7 -= 88;
          }
          while (v7);
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_10:
      a2[2] = 0;
    }
  }
  return result;
}

void *llvm::SwingSchedulerDAG::groupRemainingNodes(uint64_t a1, uint64_t a2)
{
  v55[8] = *MEMORY[0x1E4F143B8];
  v43[0] = 0;
  v43[1] = 0;
  int v44 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v45 = 0;
  int v38 = v42;
  uint64_t v39 = v42;
  uint64_t v40 = 8;
  int v41 = 0;
  unsigned int v4 = *(_DWORD *)(a2 + 8);
  if (v4)
  {
    uint64_t v16 = *(void *)a2;
    uint64_t v17 = *(void *)a2 + 88 * v4;
    int64x2_t v26 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      uint64_t v48 = 1;
      int64x2_t v49 = v26;
      int64x2_t v50 = v26;
      int64x2_t v51 = v26;
      int64x2_t v52 = v26;
      uint64_t v53 = v55;
      uint64_t v54 = 0x800000000;
      if (sub_1CC37B1BC(v16, (uint64_t)&v48, 0))
      {
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        int v29 = 0;
        int64x2_t v31 = 0;
        uint64_t v32 = 0;
        uint64_t v30 = 0;
        if (v54)
        {
          int v18 = (uint64_t *)v53;
          uint64_t v19 = 8 * v54;
          do
          {
            uint64_t v20 = *v18++;
            sub_1CBFF3560((llvm::SmallPtrSetImplBase *)&v38);
            sub_1CC37B35C(v20, (uint64_t)&v27, (uint64_t)v43, v16, (uint64_t)&v38);
            v19 -= 8;
          }
          while (v19);
          if (v30 != v31) {
            sub_1CC37B65C((void *)v16, v30, v31);
          }
        }
        sub_1CD456CB4(&v27);
      }
      sub_1CD54329C(&v48);
      LODWORD(v54) = 0;
      if (sub_1CC37B1BC((uint64_t)v43, (uint64_t)&v48, 0))
      {
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        int v29 = 0;
        int64x2_t v31 = 0;
        uint64_t v32 = 0;
        uint64_t v30 = 0;
        if (v54)
        {
          uint64_t v21 = (uint64_t *)v53;
          uint64_t v22 = 8 * v54;
          do
          {
            uint64_t v23 = *v21++;
            sub_1CBFF3560((llvm::SmallPtrSetImplBase *)&v38);
            sub_1CC37B35C(v23, (uint64_t)&v27, v16, (uint64_t)v43, (uint64_t)&v38);
            v22 -= 8;
          }
          while (v22);
          if (v30 != v31) {
            sub_1CC37B65C((void *)v16, v30, v31);
          }
        }
        sub_1CD456CB4(&v27);
      }
      sub_1CC37B65C(v43, *(uint64_t **)(v16 + 24), *(uint64_t **)(v16 + 32));
      if (v53 != v55) {
        free(v53);
      }
      if ((v48 & 1) == 0) {
        MEMORY[0x1D25D9CD0](v49.i64[0], 8);
      }
      v16 += 88;
    }
    while (v16 != v17);
  }
  uint64_t v36 = 0;
  int v37 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  int v29 = 0;
  int64x2_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v30 = 0;
  char v33 = 0;
  uint64_t v35 = 0;
  uint64_t v34 = 0;
  uint64_t v48 = 1;
  int64x2_t v49 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
  int64x2_t v50 = v49;
  int64x2_t v51 = v49;
  int64x2_t v52 = v49;
  uint64_t v53 = v55;
  uint64_t v54 = 0x800000000;
  if (sub_1CC37B1BC((uint64_t)v43, (uint64_t)&v48, 0) && v54)
  {
    uint64_t v5 = (uint64_t *)v53;
    uint64_t v6 = 8 * v54;
    do
    {
      uint64_t v7 = *v5++;
      llvm::SwingSchedulerDAG::addConnectedNodes(a1, v7, &v27, (uint64_t)v43);
      v6 -= 8;
    }
    while (v6);
  }
  if (v30 != v31) {
    sub_1CD53F544(a2, (unint64_t)&v27);
  }
  sub_1CD47558C(&v27);
  int64x2_t v31 = v30;
  char v33 = 0;
  uint64_t v36 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  if (sub_1CC37B798((uint64_t)v43, (uint64_t)&v48, 0) && v54)
  {
    uint64_t v8 = (uint64_t *)v53;
    uint64_t v9 = 8 * v54;
    do
    {
      uint64_t v10 = *v8++;
      llvm::SwingSchedulerDAG::addConnectedNodes(a1, v10, &v27, (uint64_t)v43);
      v9 -= 8;
    }
    while (v9);
  }
  if (v30 != v31) {
    sub_1CD53F544(a2, (unint64_t)&v27);
  }
  uint64_t v11 = *(void *)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 56);
  while (v11 != v12)
  {
    if (v44)
    {
      unsigned int v13 = ((v11 >> 4) ^ (v11 >> 9)) & (v44 - 1);
      uint64_t v14 = *(void *)(v43[0] + 8 * v13);
      if (v11 == v14) {
        goto LABEL_18;
      }
      int v24 = 1;
      while (v14 != -4096)
      {
        unsigned int v25 = v13 + v24++;
        unsigned int v13 = v25 & (v44 - 1);
        uint64_t v14 = *(void *)(v43[0] + 8 * v13);
        if (v11 == v14) {
          goto LABEL_18;
        }
      }
    }
    sub_1CD47558C(&v27);
    int64x2_t v31 = v30;
    char v33 = 0;
    uint64_t v36 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    llvm::SwingSchedulerDAG::addConnectedNodes(a1, v11, &v27, (uint64_t)v43);
    if (v30 != v31) {
      sub_1CD53F544(a2, (unint64_t)&v27);
    }
LABEL_18:
    v11 += 272;
  }
  if (v53 != v55) {
    free(v53);
  }
  if ((v48 & 1) == 0) {
    MEMORY[0x1D25D9CD0](v49.i64[0], 8);
  }
  sub_1CD456CB4(&v27);
  if (v39 != v38) {
    free(v39);
  }
  return sub_1CD456CB4(v43);
}

void llvm::SwingSchedulerDAG::removeDuplicateNodes(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v12 = *a2;
  unsigned int v3 = *((_DWORD *)a2 + 2);
  if (v3)
  {
    uint64_t v5 = v2 + 88 * v3;
    do
    {
      uint64_t v6 = v2 + 88;
      if (v2 + 88 != v5)
      {
        do
        {
          uint64_t v7 = *(uint64_t **)(v6 + 24);
          uint64_t v8 = *(uint64_t **)(v6 + 32);
          v13[0] = &v12;
          v13[1] = v6;
          if (v7 != v8)
          {
            while (1)
            {
              uint64_t v9 = v7 + 1;
              if (sub_1CC380378((uint64_t)v13, v7)) {
                break;
              }
              ++v7;
              if (v9 == v8)
              {
                uint64_t v7 = v8;
                goto LABEL_12;
              }
            }
            while (v9 != v8)
            {
              if ((sub_1CC380378((uint64_t)v13, v9) & 1) == 0) {
                *v7++ = *v9;
              }
              ++v9;
            }
          }
LABEL_12:
          uint64_t v10 = *(uint64_t **)(v6 + 24);
          if (v7 != *(uint64_t **)(v6 + 32)) {
            *(void *)(v6 + 32) = v7;
          }
          if (v10 == v7)
          {
            sub_1CC37F3B0(v6 + 88, *a2 + 88 * *((unsigned int *)a2 + 2), v6);
            unsigned int v11 = *((_DWORD *)a2 + 2) - 1;
            *((_DWORD *)a2 + 2) = v11;
            sub_1CD456CB4((void *)(*a2 + 88 * v11));
            uint64_t v5 = *a2 + 88 * *((unsigned int *)a2 + 2);
          }
          else
          {
            v6 += 88;
          }
        }
        while (v6 != v5);
        uint64_t v2 = v12;
        uint64_t v5 = v6;
      }
      v2 += 88;
      uint64_t v12 = v2;
    }
    while (v2 != v5);
  }
}

void llvm::SwingSchedulerDAG::checkValidNodeOrder(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 3160);
  uint64_t v4 = *(void *)(a1 + 3152);
  int64x2_t v49 = 0;
  int64x2_t v50 = 0;
  uint64_t v48 = 0;
  uint64_t v5 = v3 - v4;
  if (v3 == v4)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
  }
  else
  {
    if ((unint64_t)v5 >= 0x7FFFFFFFFFFFFFF9) {
      abort();
    }
    uint64_t v6 = (unint64_t *)operator new(2 * v5);
    uint64_t v7 = v6;
    uint64_t v8 = &v6[2 * (v5 >> 3)];
    uint64_t v48 = v6;
    int64x2_t v50 = v8;
    uint64_t v9 = v6;
    do
    {
      unint64_t *v9 = 0;
      *((_DWORD *)v9 + 2) = 0;
      v9 += 2;
    }
    while (v9 != v8);
    int64x2_t v49 = &v6[2 * (v5 >> 3)];
  }
  if ((v5 & 0x7FFFFFFF8) != 0)
  {
    uint64_t v10 = 0;
    uint64_t v11 = ((unint64_t)v5 >> 3);
    do
    {
      *(void *)&long long v47 = *(void *)(*(void *)(a1 + 3152) + 8 * v10);
      *((void *)&v47 + 1) = v10;
      if (v8 >= v50)
      {
        uint64_t v8 = (unint64_t *)sub_1CC00319C((void **)&v48, &v47);
      }
      else
      {
        *(_OWORD *)uint64_t v8 = v47;
        v8 += 2;
      }
      int64x2_t v49 = v8;
      ++v10;
    }
    while (v11 != v10);
    uint64_t v7 = v48;
  }
  unint64_t v12 = 126 - 2 * __clz(((char *)v8 - (char *)v7) >> 4);
  if (v8 == v7) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = v12;
  }
  sub_1CC380764(v7, v8, v13, 1);
  unint64_t v14 = *(void *)(a1 + 3160) - *(void *)(a1 + 3152);
  if ((v14 & 0x7FFFFFFF8) != 0)
  {
    unint64_t v15 = 0;
    uint64_t v16 = (v14 >> 3);
    do
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 3152) + 8 * v15);
      uint64_t v18 = *(unsigned int *)(v17 + 40);
      if (v18)
      {
        uint64_t v19 = *(void **)(v17 + 32);
        uint64_t v20 = &v19[2 * v18];
        while (1)
        {
          unint64_t v21 = *v19 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v22 = v8;
          if (v8 != v7)
          {
            uint64_t v22 = v7;
            unint64_t v23 = ((char *)v8 - (char *)v7) >> 4;
            do
            {
              unint64_t v24 = v23 >> 1;
              unsigned int v25 = &v22[2 * (v23 >> 1)];
              unint64_t v27 = *v25;
              int64x2_t v26 = v25 + 2;
              v23 += ~(v23 >> 1);
              if (v21 > v27) {
                uint64_t v22 = v26;
              }
              else {
                unint64_t v23 = v24;
              }
            }
            while (v23);
          }
          if (v15 > *((unsigned int *)v22 + 2))
          {
            int v28 = **(unsigned __int16 **)(*(void *)(v21 + 8) + 16);
            if (v28 != 69 && v28 != 0) {
              break;
            }
          }
          v19 += 2;
          if (v19 == v20) {
            goto LABEL_33;
          }
        }
        int v42 = 1;
      }
      else
      {
LABEL_33:
        int v42 = 0;
      }
      uint64_t v30 = *(unsigned int *)(v17 + 120);
      if (v30)
      {
        int64x2_t v31 = *(void **)(v17 + 112);
        uint64_t v32 = &v31[2 * v30];
        while (1)
        {
          unint64_t v33 = *v31 & 0xFFFFFFFFFFFFFFF8;
          if (*(_DWORD *)(v33 + 192) != -1)
          {
            uint64_t v34 = v8;
            if (v8 != v7)
            {
              uint64_t v34 = v7;
              unint64_t v35 = ((char *)v8 - (char *)v7) >> 4;
              do
              {
                unint64_t v36 = v35 >> 1;
                int v37 = &v34[2 * (v35 >> 1)];
                unint64_t v39 = *v37;
                int v38 = v37 + 2;
                v35 += ~(v35 >> 1);
                if (v33 > v39) {
                  uint64_t v34 = v38;
                }
                else {
                  unint64_t v35 = v36;
                }
              }
              while (v35);
            }
            if (v15 > *((unsigned int *)v34 + 2))
            {
              int v40 = **(unsigned __int16 **)(*(void *)(v33 + 8) + 16);
              if (v40 != 69 && v40 != 0) {
                break;
              }
            }
          }
          v31 += 2;
          if (v31 == v32) {
            goto LABEL_50;
          }
        }
        if (v42)
        {
          if (**(_WORD **)(*(void *)(v17 + 8) + 16))
          {
            if (**(_WORD **)(*(void *)(v17 + 8) + 16) != 69)
            {
              unsigned int v43 = *((_DWORD *)a2 + 2);
              if (v43)
              {
                uint64_t v44 = *a2;
                uint64_t v45 = *a2 + 88 * v43;
                do
                {
                  if (sub_1CD4C9788(*(void *)v44, *(_DWORD *)(v44 + 16), v17, &v47)) {
                    break;
                  }
                  v44 += 88;
                }
                while (v44 != v45);
              }
            }
          }
        }
      }
LABEL_50:
      ++v15;
    }
    while (v15 != v16);
  }
  if (v7)
  {
    operator delete(v7);
  }
}

void sub_1CD53DE60(uint64_t a1)
{
  sub_1CC0A1FD4((_DWORD *)a1);
  uint64_t v2 = *(void *)(a1 + 24);
  for (uint64_t i = *(void *)(a1 + 32); i != v2; i -= 56)
  {
    uint64_t v4 = *(void **)(i - 48);
    if ((void *)(i - 32) != v4) {
      free(v4);
    }
  }
  *(void *)(a1 + 32) = v2;
}

uint64_t sub_1CD53DEB8(uint64_t a1, uint64_t *a2)
{
  void v18[4] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  int v11 = 0;
  sub_1CC37F5D8(a1, &v10, &v11, (uint64_t)&v8);
  uint64_t v4 = v8;
  if (v9)
  {
    unint64_t v12 = v14;
    uint64_t v13 = 0x400000000;
    uint64_t v15 = *a2;
    uint64_t v16 = v18;
    uint64_t v17 = 0x400000000;
    sub_1CC37F430((uint64_t *)(a1 + 24), (uint64_t)&v15);
    if (v16 != v18) {
      free(v16);
    }
    if (v12 != v14) {
      free(v12);
    }
    uint64_t v5 = *(void *)(a1 + 24);
    unsigned int v6 = -1227133513 * ((unint64_t)(*(void *)(a1 + 32) - v5) >> 3) - 1;
    *(_DWORD *)(v4 + 8) = v6;
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(v8 + 8);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  return v5 + 56 * v6 + 8;
}

uint64_t sub_1CD53DFD4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v5 = 0;
  if (!sub_1CB883B0C(a1, &v4, &v5) || v5 == *(void *)a1 + 16 * *(unsigned int *)(a1 + 16)) {
    return *(void *)(a1 + 32);
  }
  else {
    return *(void *)(a1 + 24) + 56 * *(unsigned int *)(v5 + 8);
  }
}

uint64_t llvm::SwingSchedulerDAG::canUseLastOffsetValue(llvm::SwingSchedulerDAG *this, llvm::MachineInstr *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, uint64_t *a6)
{
  if ((*(uint64_t (**)(void))(**((void **)this + 2) + 760))(*((void *)this + 2))) {
    return 0;
  }
  uint64_t v32 = 0;
  int v13 = (*(uint64_t (**)(void, llvm::MachineInstr *, char *, uint64_t *))(**((void **)this + 2) + 688))(*((void *)this + 2), a2, (char *)&v32 + 4, &v32);
  uint64_t result = 0;
  if (v13)
  {
    unsigned int v14 = *(_DWORD *)(*((void *)a2 + 4) + 32 * HIDWORD(v32) + 4);
    uint64_t v15 = *(void *)(llvm::MachineInstr::getMF(a2) + 40);
    uint64_t result = llvm::MachineRegisterInfo::getVRegDef(v15, v14);
    if (result)
    {
      int v16 = **(unsigned __int16 **)(result + 16);
      if (v16 != 69 && v16 != 0) {
        return 0;
      }
      int v18 = *(_DWORD *)(result + 40);
      if (v18 == 1) {
        return 0;
      }
      uint64_t v19 = *(void *)(result + 32);
      unsigned int v20 = 1;
      while (*(void *)(v19 + 32 * (v20 + 1) + 16) != *((void *)a2 + 3))
      {
        v20 += 2;
        if (v18 == v20) {
          return 0;
        }
      }
      uint64_t v21 = v19 + 32 * v20;
      unsigned int v22 = *(_DWORD *)(v21 + 4);
      if (!v22) {
        return 0;
      }
      uint64_t VRegDef = (llvm::MachineInstr *)llvm::MachineRegisterInfo::getVRegDef(v15, *(_DWORD *)(v21 + 4));
      if (!VRegDef || VRegDef == a2) {
        return 0;
      }
      unsigned int v25 = VRegDef;
      uint64_t result = (*(uint64_t (**)(void, llvm::MachineInstr *))(**((void **)this + 2) + 760))(*((void *)this + 2), VRegDef);
      if (result)
      {
        uint64_t v31 = 0;
        int v26 = (*(uint64_t (**)(void, llvm::MachineInstr *, char *, uint64_t *))(**((void **)this + 2)
                                                                                         + 688))(*((void *)this + 2), v25, (char *)&v31 + 4, &v31);
        uint64_t result = 0;
        if (v26)
        {
          uint64_t v27 = *(void *)(*((void *)a2 + 4) + 32 * v32 + 16);
          uint64_t v28 = *(void *)(*((void *)v25 + 4) + 32 * v31 + 16);
          int v29 = (llvm::MachineInstr *)llvm::MachineFunction::CloneMachineInstr(*((llvm::MachineFunction **)this + 4), a2);
          *(void *)(*((void *)v29 + 4) + 32 * v32 + 16) = v28 + v27;
          int v30 = (*(uint64_t (**)(void))(**((void **)this + 2) + 1064))();
          llvm::MachineFunction::deleteMachineInstr(*((llvm::MachineFunction **)this + 4), v29);
          if (v30)
          {
            *a3 = HIDWORD(v32);
            *a4 = v32;
            *a5 = v22;
            *a6 = v28;
            return 1;
          }
          return 0;
        }
      }
    }
  }
  return result;
}

void llvm::SwingSchedulerDAG::Circuits::createAdjacencyStructure(uint64_t **this, llvm::TargetInstrInfo **a2)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = 0xF0F0F0F0F0F0F0F1 * (((*this)[1] - **this) >> 4);
  long long v47 = v49;
  uint64_t v48 = 0x600000000;
  sub_1CB90D610((uint64_t)&v47, (v3 + 63) >> 6, 0);
  v49[12] = v3;
  unsigned int v46 = 0;
  uint64_t v44 = 0;
  int32x2_t v45 = 0;
  uint64_t v4 = -252645135 * ((unint64_t)((*this)[1] - **this) >> 4);
  uint64_t v40 = v4;
  if (!v4)
  {
    uint64_t v29 = 0;
    goto LABEL_45;
  }
  uint64_t v5 = 0;
  do
  {
    if (v48) {
      bzero(v47, 8 * v48);
    }
    uint64_t v6 = **this;
    uint64_t v7 = v6 + 272 * v5;
    uint64_t v8 = *(unsigned int *)(v7 + 120);
    if (v8)
    {
      char v9 = *(uint64_t **)(v7 + 112);
      uint64_t v10 = 16 * v8;
      while (1)
      {
        uint64_t v11 = *v9;
        if ((*v9 & 6) == 4)
        {
          int v19 = *(_DWORD *)((v11 & 0xFFFFFFFFFFFFFFF8) + 192);
          int v42 = v5;
          int v43 = v19;
          unsigned int v20 = sub_1CD53E7FC((uint64_t *)&v44, &v42);
          if (&v44[2 * v46] != v20)
          {
            int v42 = v20[1];
            int *v20 = 0x80000000;
            int32x2_t v45 = vadd_s32(v45, (int32x2_t)0x1FFFFFFFFLL);
          }
          int v21 = v42;
          sub_1CD542EA8((uint64_t)&v44, &v43)[1] = v21;
          uint64_t v11 = *v9;
        }
        unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFF8;
        unint64_t v13 = *(unsigned int *)((v11 & 0xFFFFFFFFFFFFFFF8) + 192);
        if (v13 == -1) {
          goto LABEL_19;
        }
        uint64_t v14 = v11 & 6;
        if (v14 == 2)
        {
          int v15 = **(unsigned __int16 **)(*(void *)(v12 + 8) + 16);
          if (v15 == 69 || v15 == 0)
          {
LABEL_18:
            if ((*((void *)v47 + (v13 >> 6)) & (1 << v13)) == 0)
            {
              uint64_t v17 = (uint64_t)&this[98][4 * v5];
              unint64_t v18 = *(unsigned int *)(v17 + 8);
              if (v18 >= *(unsigned int *)(v17 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(_DWORD *)(*(void *)v17 + 4 * v18) = v13;
              ++*(_DWORD *)(v17 + 8);
              *((void *)v47 + (v13 >> 6)) |= 1 << v13;
            }
          }
        }
        else if (v14 != 6 || *((_DWORD *)v9 + 2) != 3)
        {
          goto LABEL_18;
        }
LABEL_19:
        v9 += 2;
        v10 -= 16;
        if (!v10)
        {
          uint64_t v6 = **this;
          break;
        }
      }
    }
    uint64_t v22 = v6 + 272 * v5;
    uint64_t v23 = *(unsigned int *)(v22 + 40);
    if (v23)
    {
      unint64_t v24 = *(const llvm::SDep **)(v22 + 32);
      uint64_t v25 = 16 * v23;
      do
      {
        if (sub_1CB8F9CA0(*(void *)(**this + 272 * v5 + 8), 1)
          && llvm::SwingSchedulerDAG::isLoopCarriedDep(a2, (llvm::SUnit *)(**this + 272 * v5), v24, 0)
          && (~*(_DWORD *)v24 & 6) == 0
          && sub_1CBA0BB64(*(void *)((*(void *)v24 & 0xFFFFFFFFFFFFFFF8) + 8), 1))
        {
          unint64_t v26 = *(unsigned int *)((*(void *)v24 & 0xFFFFFFFFFFFFFFF8) + 192);
          if (((1 << v26) & *((void *)v47 + (v26 >> 6))) == 0)
          {
            uint64_t v27 = (uint64_t)&this[98][4 * v5];
            unint64_t v28 = *(unsigned int *)(v27 + 8);
            if (v28 >= *(unsigned int *)(v27 + 12)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *(_DWORD *)(*(void *)v27 + 4 * v28) = v26;
            ++*(_DWORD *)(v27 + 8);
            *((void *)v47 + (v26 >> 6)) |= 1 << v26;
          }
        }
        unint64_t v24 = (const llvm::SDep *)((char *)v24 + 16);
        v25 -= 16;
      }
      while (v25);
    }
    ++v5;
  }
  while (v5 != v40);
  uint64_t v29 = (uint64_t)v44;
  LODWORD(v4) = v46;
  if (!v45.i32[0])
  {
LABEL_45:
    uint64_t v32 = (int *)(v29 + 8 * v4);
    int v30 = v32;
    goto LABEL_46;
  }
  int v30 = &v44[2 * v46];
  if (v46)
  {
    uint64_t v31 = 0;
    while ((v44[v31] - 0x7FFFFFFF) <= 1)
    {
      v31 += 2;
      if (2 * v46 == v31)
      {
        uint64_t v32 = &v44[2 * v46];
        goto LABEL_46;
      }
    }
    uint64_t v32 = &v44[v31];
  }
  else
  {
    uint64_t v32 = v44;
  }
LABEL_46:
  unint64_t v33 = (int *)(v29 + 8 * v4);
  if (v32 != v33)
  {
    uint64_t v34 = (char *)v47;
    do
    {
      unint64_t v35 = v32[1];
      if (((*(void *)&v34[(v35 >> 3) & 0x1FFFFFF8] >> v35) & 1) == 0)
      {
        uint64_t v38 = (uint64_t)&this[98][4 * *v32];
        unint64_t v39 = *(unsigned int *)(v38 + 8);
        if (v39 >= *(unsigned int *)(v38 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(_DWORD *)(*(void *)v38 + 4 * v39) = v35;
        ++*(_DWORD *)(v38 + 8);
        uint64_t v34 = (char *)v47;
        *(void *)((char *)v47 + (((unint64_t)v32[1] >> 3) & 0x1FFFFFF8)) |= 1 << v32[1];
      }
      unint64_t v36 = v32 + 2;
      while (v36 != v30)
      {
        int v37 = *v36;
        v36 += 2;
        if ((v37 - 0x7FFFFFFF) >= 2)
        {
          uint64_t v32 = v36 - 2;
          goto LABEL_54;
        }
      }
      uint64_t v32 = v30;
LABEL_54:
      ;
    }
    while (v32 != v33);
    uint64_t v29 = (uint64_t)v44;
  }
  MEMORY[0x1D25D9CD0](v29, 4);
  if (v47 != v49) {
    free(v47);
  }
}

int *sub_1CD53E7FC(uint64_t *a1, _DWORD *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 4);
  if (v3)
  {
    LODWORD(v4) = (37 * *a2) & (v3 - 1);
    uint64_t result = (int *)(v2 + 8 * v4);
    int v6 = *result;
    if (*a2 == *result) {
      return result;
    }
    int v7 = 1;
    while (v6 != 0x7FFFFFFF)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      int v6 = *(_DWORD *)(v2 + 8 * v4);
      if (*a2 == v6) {
        return (int *)(v2 + 8 * v4);
      }
    }
  }
  return (int *)(v2 + 8 * v3);
}

BOOL llvm::SwingSchedulerDAG::isLoopCarriedDep(llvm::TargetInstrInfo **this, llvm::SUnit *a2, const llvm::SDep *a3, int a4)
{
  if ((*(void *)a3 & 4) == 0) {
    return 0;
  }
  if ((*(void *)a3 & 6) == 6 && *((_DWORD *)a3 + 2) == 3) {
    return 0;
  }
  if ((*(void *)a3 & 6) == 4 || byte_1EBCCF7F0 == 0) {
    return 1;
  }
  int v7 = a4
     ? *(llvm::MachineInstr **)((*(void *)a3 & 0xFFFFFFFFFFFFFFF8) + 8)
     : (llvm::MachineInstr *)*((void *)a2 + 1);
  int v8 = a4
     ? (llvm::MachineInstr *)*((void *)a2 + 1)
     : *(llvm::MachineInstr **)((*(void *)a3 & 0xFFFFFFFFFFFFFFF8) + 8);
  if (llvm::MachineInstr::hasUnmodeledSideEffects(v8)
    || llvm::MachineInstr::hasUnmodeledSideEffects(v7)
    || sub_1CC3526CC((uint64_t)v8)
    || sub_1CC3526CC((uint64_t)v7)
    || (llvm::MachineInstr::hasOrderedMemoryRef(v8) & 1) != 0
    || (llvm::MachineInstr::hasOrderedMemoryRef(v7) & 1) != 0)
  {
    return 1;
  }
  BOOL result = sub_1CB8F9CA0((uint64_t)v7, 1);
  if (result)
  {
    BOOL result = sub_1CBA0BB64((uint64_t)v8, 1);
    if (result)
    {
      *(void *)unint64_t v35 = 0;
      if (!llvm::SwingSchedulerDAG::computeDelta((llvm::SwingSchedulerDAG *)this, v8, &v35[1])) {
        return 1;
      }
      if (!llvm::SwingSchedulerDAG::computeDelta((llvm::SwingSchedulerDAG *)this, v7, v35)) {
        return 1;
      }
      unint64_t v33 = 0;
      uint64_t v34 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      *(_WORD *)int v30 = 0;
      uint64_t v10 = (const llvm::TargetRegisterInfo *)(*(uint64_t (**)(void))(**((void **)this[4] + 2) + 176))(*((void *)this[4] + 2));
      if (!llvm::TargetInstrInfo::getMemOperandWithOffset(this[2], v8, &v34, &v32, &v30[1], v10)) {
        return 1;
      }
      if (!llvm::TargetInstrInfo::getMemOperandWithOffset(this[2], v7, &v33, &v31, v30, v10)) {
        return 1;
      }
      uint64_t v11 = v34;
      if (!llvm::MachineOperand::isIdenticalTo(v34, v33)) {
        return 1;
      }
      uint64_t v12 = (uint64_t)this[5];
      uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(v12, *((_DWORD *)v11 + 1));
      if (!VRegDef || **(_WORD **)(VRegDef + 16) != 69 && **(_WORD **)(VRegDef + 16)) {
        return 1;
      }
      int v14 = *(_DWORD *)(VRegDef + 40);
      int v15 = v14 - 1;
      if (v14 == 1)
      {
        unsigned int v16 = 0;
      }
      else
      {
        int v17 = 0;
        unsigned int v16 = 0;
        uint64_t v18 = *(void *)(VRegDef + 32);
        int v19 = (unsigned int *)(v18 + 36);
        do
        {
          if (*(llvm::TargetInstrInfo **)(v18 + 32 * (v17 + 2) + 16) == this[115]) {
            unsigned int v16 = *v19;
          }
          v17 += 2;
          v19 += 16;
        }
        while (v15 != v17);
      }
      uint64_t v20 = llvm::MachineRegisterInfo::getVRegDef(v12, v16);
      int v29 = 0;
      if (!v20
        || !(*(unsigned int (**)(llvm::TargetInstrInfo *, uint64_t, int *))(*(void *)this[2] + 712))(this[2], v20, &v29))
      {
        return 1;
      }
      uint64_t v21 = *((void *)v8 + 6);
      if ((v21 & 7) != 0)
      {
        unint64_t v22 = *(void *)((v21 & 0xFFFFFFFFFFFFFFF8) + 8);
      }
      else
      {
        unint64_t v22 = v21 & 0xFFFFFFFFFFFFFFF8;
        *((void *)v8 + 6) = v21 & 0xFFFFFFFFFFFFFFF8;
      }
      unint64_t v23 = sub_1CB8F20C0(v22);
      uint64_t v24 = *((void *)v7 + 6);
      if ((v24 & 7) != 0)
      {
        unint64_t v25 = *(void *)((v24 & 0xFFFFFFFFFFFFFFF8) + 8);
      }
      else
      {
        unint64_t v25 = v24 & 0xFFFFFFFFFFFFFFF8;
        *((void *)v7 + 6) = v24 & 0xFFFFFFFFFFFFFFF8;
      }
      unint64_t v26 = sub_1CB8F20C0(v25);
      if (v23 == -1 || v26 == -1) {
        return 1;
      }
      unint64_t v28 = v26;
      BOOL result = 1;
      if (v35[1] == v35[0] && v23 <= v35[1] && v28 <= v35[0]) {
        return (uint64_t)(v32 + v23) < (uint64_t)(v31 + v28);
      }
    }
  }
  return result;
}

uint64_t llvm::SwingSchedulerDAG::Circuits::circuit(uint64_t a1, signed int a2, int a3, uint64_t a4, char a5)
{
  unint64_t v10 = a2;
  uint64_t v11 = **(void **)a1 + 272 * a2;
  uint64_t v39 = v11;
  uint64_t v12 = a1 + 8;
  sub_1CC37AF14((void *)(a1 + 8), &v39);
  *(void *)(*(void *)(a1 + 56) + 8 * (a2 >> 6)) |= 1 << a2;
  uint64_t v13 = *(void *)(a1 + 784) + 32 * v10;
  uint64_t v14 = *(unsigned int *)(v13 + 8);
  if (v14)
  {
    uint64_t v37 = v12;
    int v26 = 0;
    uint64_t v27 = *(int **)v13;
    unsigned int v28 = llvm::SwingSchedulerDAG::Circuits::MaxPaths;
    uint64_t v29 = 4 * v14;
    do
    {
      unsigned int v30 = *(_DWORD *)(a1 + 1320);
      if (v30 > v28) {
        break;
      }
      int v31 = *v27;
      if (*v27 >= a3)
      {
        if (v31 == a3)
        {
          if ((a5 & 1) == 0)
          {
            sub_1CD5418B4((uint64_t)v38, *(uint64_t **)(a1 + 32), *(uint64_t **)(a1 + 40));
            unint64_t v33 = sub_1CD543100(a4, (unint64_t)v38);
            sub_1CD46AEB4(*(void *)a4 + 88 * *(unsigned int *)(a4 + 8), v33);
            long long v34 = *(_OWORD *)(v33 + 48);
            long long v35 = *(_OWORD *)(v33 + 64);
            *(_DWORD *)(v36 + 80) = *(_DWORD *)(v33 + 80);
            *(_OWORD *)(v36 + 48) = v34;
            *(_OWORD *)(v36 + 64) = v35;
            ++*(_DWORD *)(a4 + 8);
            sub_1CD456CB4(v38);
            unsigned int v30 = *(_DWORD *)(a1 + 1320);
          }
          *(_DWORD *)(a1 + 1320) = v30 + 1;
          uint64_t v12 = v37;
          goto LABEL_24;
        }
        if (((*(void *)(*(void *)(a1 + 56) + 8 * (v31 >> 6)) >> v31) & 1) == 0)
        {
          unint64_t v32 = (uint64_t)(*(void *)(*(void *)(a1 + 1312) + 8) - **(void **)(a1 + 1312)) >> 2;
          if (v32 <= v31 || v32 <= v10) {
            abort();
          }
          v26 |= llvm::SwingSchedulerDAG::Circuits::circuit(a1);
          unsigned int v28 = llvm::SwingSchedulerDAG::Circuits::MaxPaths;
        }
      }
      ++v27;
      v29 -= 4;
    }
    while (v29);
    uint64_t v12 = v37;
    if ((v26 & 1) == 0) {
      goto LABEL_2;
    }
LABEL_24:
    llvm::SwingSchedulerDAG::Circuits::unblock((llvm::SwingSchedulerDAG::Circuits *)a1, a2);
    uint64_t v24 = 1;
  }
  else
  {
LABEL_2:
    uint64_t v15 = *(void *)(a1 + 784) + 32 * v10;
    uint64_t v16 = *(unsigned int *)(v15 + 8);
    if (v16)
    {
      int v17 = *(int **)v15;
      uint64_t v18 = 4 * v16;
      do
      {
        uint64_t v19 = *v17;
        if ((int)v19 >= a3)
        {
          uint64_t v20 = (void *)(*(void *)(a1 + 128) + (v19 << 6));
          uint64_t v21 = sub_1CB896AE8((uint64_t)v20, v11);
          uint64_t v22 = v20[1];
          if (v22 == *v20) {
            uint64_t v23 = 20;
          }
          else {
            uint64_t v23 = 16;
          }
          if (v21 == (void *)(v22 + 8 * *(unsigned int *)((char *)v20 + v23))) {
            sub_1CB89694C((llvm::SmallPtrSetImplBase *)(*(void *)(a1 + 128) + (v19 << 6)), v11);
          }
        }
        ++v17;
        v18 -= 4;
      }
      while (v18);
    }
    uint64_t v24 = 0;
  }
  sub_1CD4C9A4C(v12);
  return v24;
}

llvm::SwingSchedulerDAG::Circuits *llvm::SwingSchedulerDAG::Circuits::unblock(llvm::SwingSchedulerDAG::Circuits *this, unsigned int a2)
{
  *(void *)(*((void *)this + 7) + 8 * (a2 >> 6)) &= ~(1 << a2);
  uint64_t v2 = *((void *)this + 16) + ((uint64_t)(int)a2 << 6);
  if (*(_DWORD *)(v2 + 20) != *(_DWORD *)(v2 + 24))
  {
    uint64_t v3 = this;
    do
    {
      uint64_t v4 = *(uint64_t **)(v2 + 8);
      if (v4 == *(uint64_t **)v2) {
        uint64_t v5 = 20;
      }
      else {
        uint64_t v5 = 16;
      }
      uint64_t v6 = *(unsigned int *)(v2 + v5);
      if (v6)
      {
        uint64_t v7 = 8 * v6;
        int v8 = &v4[v6];
        while ((unint64_t)*v4 >= 0xFFFFFFFFFFFFFFFELL)
        {
          ++v4;
          v7 -= 8;
          if (!v7)
          {
            uint64_t v4 = v8;
            break;
          }
        }
      }
      uint64_t v9 = *v4;
      this = (llvm::SwingSchedulerDAG::Circuits *)sub_1CB896AE8(v2, *v4);
      uint64_t v10 = *(void *)(v2 + 8);
      if (v10 == *(void *)v2) {
        uint64_t v11 = 20;
      }
      else {
        uint64_t v11 = 16;
      }
      if (this != (llvm::SwingSchedulerDAG::Circuits *)(v10 + 8 * *(unsigned int *)(v2 + v11)))
      {
        *(void *)this = -2;
        ++*(_DWORD *)(v2 + 24);
      }
      unint64_t v12 = *(unsigned int *)(v9 + 192);
      if ((*(void *)(*((void *)v3 + 7) + ((v12 >> 3) & 0x1FFFFFF8)) >> v12)) {
        this = (llvm::SwingSchedulerDAG::Circuits *)llvm::SwingSchedulerDAG::Circuits::unblock(v3, v12);
      }
    }
    while (*(_DWORD *)(v2 + 20) != *(_DWORD *)(v2 + 24));
  }
  return this;
}

void sub_1CD53EF10(uint64_t a1)
{
  sub_1CD47558C((_DWORD *)(a1 + 8));
  *(void *)(a1 + 40) = *(void *)(a1 + 32);
  uint64_t v2 = *(unsigned int *)(a1 + 64);
  if (v2) {
    bzero(*(void **)(a1 + 56), 8 * v2);
  }
  unint64_t v3 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(*(void *)a1 + 8) - **(void **)a1) >> 4);
  uint64_t v4 = v8;
  uint64_t v5 = v8;
  uint64_t v6 = 4;
  int v7 = 0;
  sub_1CD541CE8(a1 + 128, v3, (llvm::SmallPtrSetImplBase *)&v4);
  if (v5 != v4) {
    free(v5);
  }
  *(_DWORD *)(a1 + 1320) = 0;
}

void llvm::SwingSchedulerDAG::CopyToPhiMutation::apply(llvm::SwingSchedulerDAG::CopyToPhiMutation *this, llvm::ScheduleDAGInstrs *a2)
{
  v44[4] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)a2 + 6);
  uint64_t v3 = *((void *)a2 + 7);
  if (v2 == v3) {
    return;
  }
  uint64_t v4 = (llvm::ScheduleDAGInstrs *)((char *)a2 + 2688);
  do
  {
    if ((**(_WORD **)(*(void *)(v2 + 8) + 16) & 0xFFFE) != 0x12) {
      goto LABEL_59;
    }
    int v42 = v44;
    uint64_t v43 = 0x400000000;
    uint64_t v39 = v41;
    uint64_t v40 = 0x400000000;
    uint64_t v5 = *(unsigned int *)(v2 + 40);
    if (!v5) {
      goto LABEL_55;
    }
    uint64_t v6 = *(void **)(v2 + 32);
    uint64_t v7 = 16 * v5;
    do
    {
      unint64_t v8 = *v6 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v9 = *(void *)(v8 + 8);
      unsigned int v10 = (*v6 >> 1) & 3;
      if (v10)
      {
        if (v10 == 1)
        {
          int v11 = **(unsigned __int16 **)(v9 + 16);
          if (v11 == 69 || v11 == 0)
          {
            uint64_t v13 = v43;
            if (v43 >= (unint64_t)HIDWORD(v43)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            uint64_t v14 = &v42;
LABEL_15:
            *((void *)*v14 + v13) = v8;
            ++*((_DWORD *)v14 + 2);
          }
        }
      }
      else
      {
        int v15 = **(unsigned __int16 **)(v9 + 16);
        if (v15 && v15 != 69 && *(_DWORD *)(v8 + 200))
        {
          uint64_t v13 = v40;
          if (v40 >= (unint64_t)HIDWORD(v40)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          uint64_t v14 = &v39;
          goto LABEL_15;
        }
      }
      v6 += 2;
      v7 -= 16;
    }
    while (v7);
    unint64_t v16 = v43;
    if (v43 && v40)
    {
      unint64_t v17 = 0;
      uint64_t v36 = v38;
      uint64_t v37 = 0x800000000;
      do
      {
        uint64_t v18 = *((void *)v42 + v17);
        uint64_t v19 = *(unsigned int *)(v18 + 120);
        if (v19)
        {
          uint64_t v20 = *(uint64_t **)(v18 + 112);
          uint64_t v21 = 16 * v19;
          do
          {
            uint64_t v22 = *v20;
            if ((*v20 & 6) == 0)
            {
              unint64_t v23 = v22 & 0xFFFFFFFFFFFFFFF8;
              int v24 = **(unsigned __int16 **)(*(void *)((v22 & 0xFFFFFFFFFFFFFFF8) + 8) + 16);
              if (!v24 || (v24 != 69 ? (BOOL v25 = v24 == 18) : (BOOL v25 = 1), v25))
              {
                uint64_t v26 = v43;
                if (v43 >= (unint64_t)HIDWORD(v43)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                uint64_t v27 = &v42;
              }
              else
              {
                uint64_t v26 = v37;
                if (v37 >= (unint64_t)HIDWORD(v37)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                uint64_t v27 = &v36;
              }
              *((void *)*v27 + v26) = v23;
              ++*((_DWORD *)v27 + 2);
            }
            v20 += 2;
            v21 -= 16;
          }
          while (v21);
          unint64_t v16 = v43;
        }
        ++v17;
      }
      while (v17 < v16);
      unsigned int v28 = (char *)v36;
      if (v37)
      {
        uint64_t v29 = (char *)v36 + 8 * v37;
        do
        {
          if (v40)
          {
            unsigned int v30 = *(llvm::SUnit **)v28;
            int v31 = (const llvm::SUnit **)v39;
            uint64_t v32 = *(void *)v28 | 6;
            uint64_t v33 = 8 * v40;
            do
            {
              long long v34 = *v31;
              if (!llvm::ScheduleDAGTopologicalSort::IsReachable(v4, v30, *v31) && v34 != v30)
              {
                v35[0] = v32;
                v35[1] = 3;
                llvm::SUnit::addPred((uint64_t)v34, v35, 1);
                llvm::ScheduleDAGTopologicalSort::AddPred(v4, v34, v30);
              }
              ++v31;
              v33 -= 8;
            }
            while (v33);
          }
          v28 += 8;
        }
        while (v28 != v29);
        unsigned int v28 = (char *)v36;
      }
      if (v28 != v38) {
        free(v28);
      }
    }
LABEL_55:
    if (v39 != v41) {
      free(v39);
    }
    if (v42 != v44) {
      free(v42);
    }
LABEL_59:
    v2 += 272;
  }
  while (v2 != v3);
}

void sub_1CD53F35C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 24);
  for (uint64_t i = *(uint64_t **)(a1 + 32); v2 != i; ++v2)
  {
    uint64_t v6 = *v2;
    int v7 = *(_DWORD *)(*(void *)(a2 + 3104) + 16 * *(unsigned int *)(*v2 + 192) + 4)
       - *(_DWORD *)(*(void *)(a2 + 3104) + 16 * *(unsigned int *)(*v2 + 192));
    if (*(_DWORD *)(a1 + 56) > v7) {
      int v7 = *(_DWORD *)(a1 + 56);
    }
    *(_DWORD *)(a1 + 56) = v7;
    if ((*(unsigned char *)(v6 + 236) & 1) == 0) {
      llvm::SUnit::ComputeDepth((llvm::SUnit *)v6);
    }
    unsigned int v8 = *(_DWORD *)(v6 + 240);
    if (*(_DWORD *)(a1 + 60) > v8) {
      unsigned int v8 = *(_DWORD *)(a1 + 60);
    }
    *(_DWORD *)(a1 + 60) = v8;
  }
}

void llvm::SwingSchedulerDAG::addConnectedNodes(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v18 = a2;
  uint64_t v19 = a2;
  sub_1CC37AF14(a3, &v19);
  sub_1CC37AF14((void *)a4, &v18);
  uint64_t v8 = *(unsigned int *)(a2 + 120);
  if (v8)
  {
    uint64_t v9 = 16 * v8;
    unsigned int v10 = (_DWORD *)(*(void *)(a2 + 112) + 8);
    do
    {
      uint64_t v11 = *((void *)v10 - 1);
      if ((~*(v10 - 2) & 6) != 0 || *v10 != 3)
      {
        unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFF8;
        if ((sub_1CD4C9788(*(void *)a4, *(_DWORD *)(a4 + 16), v11 & 0xFFFFFFFFFFFFFFF8, &v19) & 1) == 0) {
          llvm::SwingSchedulerDAG::addConnectedNodes(a1, v12, a3, a4);
        }
      }
      v10 += 4;
      v9 -= 16;
    }
    while (v9);
  }
  uint64_t v13 = *(unsigned int *)(a2 + 40);
  if (v13)
  {
    uint64_t v14 = 16 * v13;
    int v15 = (_DWORD *)(*(void *)(a2 + 32) + 8);
    do
    {
      uint64_t v16 = *((void *)v15 - 1);
      if ((~*(v15 - 2) & 6) != 0 || *v15 != 3)
      {
        unint64_t v17 = v16 & 0xFFFFFFFFFFFFFFF8;
        if ((sub_1CD4C9788(*(void *)a4, *(_DWORD *)(a4 + 16), v16 & 0xFFFFFFFFFFFFFFF8, &v19) & 1) == 0) {
          llvm::SwingSchedulerDAG::addConnectedNodes(a1, v17, a3, a4);
        }
      }
      v15 += 4;
      v14 -= 16;
    }
    while (v14);
  }
}

__n128 sub_1CD53F544(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = sub_1CD543100(a1, a2);
  uint64_t v4 = *(void *)a1 + 88 * *(unsigned int *)(a1 + 8);
  *(void *)uint64_t v4 = 0;
  *(void *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  sub_1CBFCB9AC(v4, v3);
  *(void *)(v4 + 24) = 0;
  *(void *)(v4 + 32) = 0;
  v4 += 24;
  *(void *)(v4 + 16) = 0;
  sub_1CBFCBA2C((void *)v4, *(const void **)(v3 + 24), *(void *)(v3 + 32), (uint64_t)(*(void *)(v3 + 32) - *(void *)(v3 + 24)) >> 3);
  __n128 result = *(__n128 *)(v3 + 48);
  long long v6 = *(_OWORD *)(v3 + 64);
  *(_DWORD *)(v4 + 56) = *(_DWORD *)(v3 + 80);
  *(_OWORD *)(v4 + 40) = v6;
  *(__n128 *)(v4 + 24) = result;
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD53F5D4(uint64_t *a1, unsigned int a2, uint64_t a3)
{
  if (a2 > (unint64_t)((*(void *)(a3 + 32) - *(void *)(a3 + 24)) >> 3)) {
    return 0;
  }
  if (!a2) {
    return 1;
  }
  uint64_t v6 = 8 * a2 - 8;
  do
  {
    uint64_t v7 = *a1++;
    uint64_t result = sub_1CD4C9788(*(void *)a3, *(_DWORD *)(a3 + 16), v7, &v9);
    if (result) {
      BOOL v8 = v6 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    v6 -= 8;
  }
  while (!v8);
  return result;
}

void *sub_1CD53F660(void *result, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v10 = v3;
    uint64_t v11 = v4;
    uint64_t v6 = a2;
    uint64_t v7 = (uint64_t)result;
    do
    {
      uint64_t result = sub_1CD5433EC((uint64_t)v9, v7, v6);
      if (v9[16])
      {
        unint64_t v8 = *(unsigned int *)(v7 + 80);
        if (v8 >= *(unsigned int *)(v7 + 84)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *(void *)(*(void *)(v7 + 72) + 8 * v8) = *v6;
        ++*(_DWORD *)(v7 + 80);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

void *sub_1CD53F714(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1CD5433EC((uint64_t)v7, a1, a2);
  if (v7[16])
  {
    uint64_t v5 = *a2;
    unsigned int v6 = *(_DWORD *)(a1 + 80);
    if (v6 >= *(_DWORD *)(a1 + 84)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)(*(void *)(a1 + 72) + 8 * v6) = v5;
    ++*(_DWORD *)(a1 + 80);
  }
  return result;
}

void *sub_1CD53F798(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (void *)sub_1CC380418((_DWORD *)a1, *a2);
  if (result)
  {
    uint64_t result = *(void **)(a1 + 72);
    uint64_t v5 = *(unsigned int *)(a1 + 80);
    unsigned int v6 = &result[v5];
    if (v5)
    {
      uint64_t v7 = 8 * v5;
      while (*result != *a2)
      {
        ++result;
        v7 -= 8;
        if (!v7)
        {
          uint64_t result = v6;
          break;
        }
      }
    }
    if (v6 != result + 1)
    {
      uint64_t result = memmove(result, result + 1, (char *)v6 - (char *)(result + 1));
      LODWORD(v5) = *(_DWORD *)(a1 + 80);
    }
    *(_DWORD *)(a1 + 80) = v5 - 1;
  }
  return result;
}

uint64_t llvm::SMSchedule::isValidSchedule(llvm::SMSchedule *this, llvm::SwingSchedulerDAG *a2)
{
  unint64_t v2 = *((void *)a2 + 6);
  uint64_t v3 = *((void *)a2 + 7);
  if (v2 == v3) {
    return 1;
  }
  uint64_t v4 = (char *)this + 32;
  while (1)
  {
    if ((*(_WORD *)(v2 + 228) & 0x40) != 0)
    {
      if (!*(void *)v4) {
        goto LABEL_17;
      }
      uint64_t v5 = *(void **)v4;
      unsigned int v6 = (char *)this + 32;
      do
      {
        unint64_t v7 = v5[4];
        BOOL v8 = v7 >= v2;
        if (v7 >= v2) {
          uint64_t v9 = v5;
        }
        else {
          uint64_t v9 = v5 + 1;
        }
        if (v8) {
          unsigned int v6 = (char *)v5;
        }
        uint64_t v5 = (void *)*v9;
      }
      while (*v9);
      if (v6 != v4 && *((void *)v6 + 4) <= v2) {
        int v10 = (*((_DWORD *)v6 + 10) - *((_DWORD *)this + 12)) / *((_DWORD *)this + 14);
      }
      else {
LABEL_17:
      }
        int v10 = -1;
      uint64_t v11 = *(unsigned int *)(v2 + 120);
      if (v11) {
        break;
      }
    }
LABEL_4:
    v2 += 272;
    if (v2 == v3) {
      return 1;
    }
  }
  uint64_t v12 = *(void *)(v2 + 112);
  uint64_t v13 = v12 + 16 * v11;
  while (1)
  {
    if ((*(void *)v12 & 6) == 0 && (*(_DWORD *)(v12 + 8) - 1) <= 0x3FFFFFFE)
    {
      if (!*(void *)v4) {
        goto LABEL_35;
      }
      unint64_t v14 = *(void *)v12 & 0xFFFFFFFFFFFFFFF8;
      int v15 = *(void **)v4;
      uint64_t v16 = (char *)this + 32;
      do
      {
        unint64_t v17 = v15[4];
        BOOL v18 = v17 >= v14;
        if (v17 >= v14) {
          uint64_t v19 = v15;
        }
        else {
          uint64_t v19 = v15 + 1;
        }
        if (v18) {
          uint64_t v16 = (char *)v15;
        }
        int v15 = (void *)*v19;
      }
      while (*v19);
      if (v16 != v4 && *((void *)v16 + 4) <= v14) {
        int v20 = (*((_DWORD *)v16 + 10) - *((_DWORD *)this + 12)) / *((_DWORD *)this + 14);
      }
      else {
LABEL_35:
      }
        int v20 = -1;
      if (v20 != v10) {
        return 0;
      }
    }
    v12 += 16;
    if (v12 == v13) {
      goto LABEL_4;
    }
  }
}

uint64_t llvm::SwingSchedulerDAG::findDefInLoop(uint64_t a1, unsigned int a2)
{
  uint64_t v12 = v16;
  uint64_t v13 = v16;
  uint64_t v14 = 8;
  int v15 = 0;
  uint64_t v3 = *(void *)(a1 + 40);
LABEL_2:
  uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(v3, a2);
LABEL_3:
  while (1)
  {
    int v5 = **(unsigned __int16 **)(VRegDef + 16);
    if (v5 != 69 && v5 != 0) {
      break;
    }
    sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v12, VRegDef);
    if (!v7) {
      break;
    }
    unsigned int v8 = *(_DWORD *)(VRegDef + 40);
    if (v8 >= 2)
    {
      uint64_t v9 = *(void *)(VRegDef + 32);
      unsigned int v10 = 1;
      while (*(void *)(v9 + 32 * (v10 + 1) + 16) != *(void *)(a1 + 920))
      {
        v10 += 2;
        if (v10 >= v8) {
          goto LABEL_3;
        }
      }
      uint64_t v3 = *(void *)(a1 + 40);
      a2 = *(_DWORD *)(v9 + 32 * v10 + 4);
      goto LABEL_2;
    }
  }
  if (v13 != v12) {
    free(v13);
  }
  return VRegDef;
}

uint64_t llvm::SMSchedule::earliestCycleInChain(uint64_t a1, _OWORD *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v24 = v28;
  BOOL v25 = v28;
  uint64_t v26 = 8;
  int v27 = 0;
  uint64_t v29 = v32;
  unsigned int v31 = 8;
  v32[0] = *a2;
  unint64_t v2 = (void *)(a1 + 32);
  unsigned int v3 = 1;
  uint64_t v4 = 0x7FFFFFFFLL;
  do
  {
    uint64_t v5 = *((void *)v29 + 2 * v3 - 2);
    unsigned int v30 = v3 - 1;
    unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFF8;
    char v7 = sub_1CB896AE8((uint64_t)&v24, v5 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v9 = v24;
    unsigned int v8 = v25;
    unsigned int v10 = (uint64_t *)((char *)&v26 + 4);
    if (v25 != v24) {
      unsigned int v10 = &v26;
    }
    if (v7 == (void *)&v25[8 * *(unsigned int *)v10])
    {
      uint64_t v11 = (void *)*v2;
      if (*v2)
      {
        uint64_t v12 = v2;
        do
        {
          unint64_t v13 = v11[4];
          BOOL v14 = v13 >= v6;
          if (v13 >= v6) {
            int v15 = v11;
          }
          else {
            int v15 = v11 + 1;
          }
          if (v14) {
            uint64_t v12 = v11;
          }
          uint64_t v11 = (void *)*v15;
        }
        while (*v15);
        if (v12 != v2 && v12[4] <= v6)
        {
          int v16 = *((_DWORD *)v12 + 10);
          if (v16 >= (int)v4) {
            uint64_t v4 = v4;
          }
          else {
            uint64_t v4 = v16;
          }
          uint64_t v17 = *(unsigned int *)(v6 + 40);
          if (v17)
          {
            uint64_t v18 = 16 * v17;
            uint64_t v19 = (uint64_t *)(*(void *)(v6 + 32) + 8);
            do
            {
              uint64_t v20 = *(v19 - 1);
              if ((v20 & 4) != 0)
              {
                uint64_t v21 = *v19;
                if (v30 >= (unint64_t)v31) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                uint64_t v22 = (char *)v29 + 16 * v30;
                *uint64_t v22 = v20;
                v22[1] = v21;
                ++v30;
              }
              v19 += 2;
              v18 -= 16;
            }
            while (v18);
          }
          sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v24, v6);
          uint64_t v9 = v24;
          unsigned int v8 = v25;
        }
      }
    }
    unsigned int v3 = v30;
  }
  while (v30);
  if (v29 != v32)
  {
    free(v29);
    uint64_t v9 = v24;
    unsigned int v8 = v25;
  }
  if (v8 != v9) {
    free(v8);
  }
  return v4;
}

uint64_t llvm::SMSchedule::latestCycleInChain(uint64_t a1, _OWORD *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v24 = v28;
  BOOL v25 = v28;
  uint64_t v26 = 8;
  int v27 = 0;
  uint64_t v29 = v32;
  unsigned int v31 = 8;
  v32[0] = *a2;
  unint64_t v2 = (void *)(a1 + 32);
  unsigned int v3 = 1;
  uint64_t v4 = 0x80000000;
  do
  {
    uint64_t v5 = *((void *)v29 + 2 * v3 - 2);
    unsigned int v30 = v3 - 1;
    unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFF8;
    char v7 = sub_1CB896AE8((uint64_t)&v24, v5 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v9 = v24;
    unsigned int v8 = v25;
    unsigned int v10 = (uint64_t *)((char *)&v26 + 4);
    if (v25 != v24) {
      unsigned int v10 = &v26;
    }
    if (v7 == (void *)&v25[8 * *(unsigned int *)v10])
    {
      uint64_t v11 = (void *)*v2;
      if (*v2)
      {
        uint64_t v12 = v2;
        do
        {
          unint64_t v13 = v11[4];
          BOOL v14 = v13 >= v6;
          if (v13 >= v6) {
            int v15 = v11;
          }
          else {
            int v15 = v11 + 1;
          }
          if (v14) {
            uint64_t v12 = v11;
          }
          uint64_t v11 = (void *)*v15;
        }
        while (*v15);
        if (v12 != v2 && v12[4] <= v6)
        {
          int v16 = *((_DWORD *)v12 + 10);
          if ((int)v4 <= v16) {
            uint64_t v4 = v16;
          }
          else {
            uint64_t v4 = v4;
          }
          uint64_t v17 = *(unsigned int *)(v6 + 120);
          if (v17)
          {
            uint64_t v18 = 16 * v17;
            uint64_t v19 = (uint64_t *)(*(void *)(v6 + 112) + 8);
            do
            {
              uint64_t v20 = *(v19 - 1);
              if ((v20 & 4) != 0)
              {
                uint64_t v21 = *v19;
                if (v30 >= (unint64_t)v31) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                uint64_t v22 = (char *)v29 + 16 * v30;
                *uint64_t v22 = v20;
                v22[1] = v21;
                ++v30;
              }
              v19 += 2;
              v18 -= 16;
            }
            while (v18);
          }
          sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v24, v6);
          uint64_t v9 = v24;
          unsigned int v8 = v25;
        }
      }
    }
    unsigned int v3 = v30;
  }
  while (v30);
  if (v29 != v32)
  {
    free(v29);
    uint64_t v9 = v24;
    unsigned int v8 = v25;
  }
  if (v8 != v9) {
    free(v8);
  }
  return v4;
}

void sub_1CD53FE2C(uint64_t a1, char *a2, char *a3)
{
  unint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = (char **)(v7 + 8 * (v6 >> 9));
  if (v8 == v7) {
    unsigned int v10 = 0;
  }
  else {
    unsigned int v10 = &(*v9)[8 * (*(void *)(a1 + 32) & 0x1FFLL)];
  }
  if (a3 == v10)
  {
    uint64_t v12 = *v9;
    goto LABEL_12;
  }
  uint64_t v11 = ((uint64_t)&a3[-*(void *)a2] >> 3) + ((a2 - (char *)v9) << 6);
  uint64_t v12 = *v9;
  unint64_t v13 = v11 - ((v10 - *v9) >> 3);
  if (v11 == (v10 - *v9) >> 3)
  {
LABEL_12:
    BOOL v14 = (void **)(v7 + 8 * (v6 >> 9));
    int v15 = (void **)v10;
    goto LABEL_13;
  }
  if (v11 < 1)
  {
    unint64_t v36 = 511 - v11;
    LOWORD(v11) = ~(511 - v11);
    BOOL v14 = (void **)&v9[-(v36 >> 9)];
  }
  else
  {
    BOOL v14 = (void **)&v9[(unint64_t)v11 >> 9];
  }
  uint64_t v12 = *v14;
  int v15 = (void **)((char *)*v14 + 8 * (v11 & 0x1FF));
  uint64_t v16 = *(void *)(a1 + 40);
  if (v13 > (unint64_t)(v16 - 1) >> 1)
  {
    uint64_t v17 = (char *)v15 - v12;
    uint64_t v18 = ((char *)v15 - v12) >> 3;
    if (v17 < -7)
    {
      BOOL v27 = v18 > 510;
      uint64_t v37 = 510 - v18;
      uint64_t v38 = 1021 - v18;
      if (!v27) {
        uint64_t v38 = v37;
      }
      uint64_t v20 = &v14[-(v38 >> 9)];
      uint64_t v39 = v37 & 0x1FF;
      uint64_t v40 = -v37;
      BOOL v31 = v40 < 0;
      uint64_t v41 = v40 & 0x1FF;
      if (v31) {
        uint64_t v42 = v39;
      }
      else {
        uint64_t v42 = -v41;
      }
      uint64_t v21 = (char *)*v20 + 8 * (511 - v42);
    }
    else
    {
      unint64_t v19 = v18 + 1;
      uint64_t v20 = &v14[v19 >> 9];
      uint64_t v21 = (char *)*v20 + 8 * (v19 & 0x1FF);
    }
    uint64_t v43 = (unsigned char **)(v7 + 8 * ((v16 + v6) >> 9));
    if (v8 == v7) {
      uint64_t v44 = 0;
    }
    else {
      uint64_t v44 = &(*v43)[8 * (((_WORD)v16 + (_WORD)v6) & 0x1FF)];
    }
    v45[0] = v14;
    v45[1] = v15;
    sub_1CC3806EC(v20, v21, v43, v44, v45);
    --*(void *)(a1 + 40);
    sub_1CC0D41E4((void *)a1);
    return;
  }
LABEL_13:
  uint64_t v22 = (char *)v15 - v12;
  uint64_t v23 = ((char *)v15 - v12) >> 3;
  if (v22 < -7)
  {
    BOOL v27 = v23 > 510;
    uint64_t v28 = 510 - v23;
    uint64_t v29 = 1021 - v23;
    if (!v27) {
      uint64_t v29 = v28;
    }
    BOOL v25 = &v14[-(v29 >> 9)];
    uint64_t v30 = v28 & 0x1FF;
    uint64_t v32 = -v28;
    BOOL v31 = v32 < 0;
    uint64_t v33 = v32 & 0x1FF;
    if (v31) {
      uint64_t v34 = v30;
    }
    else {
      uint64_t v34 = -v33;
    }
    uint64_t v26 = (char *)*v25 + 8 * (511 - v34);
  }
  else
  {
    unint64_t v24 = v23 + 1;
    BOOL v25 = &v14[v24 >> 9];
    uint64_t v26 = (char *)*v25 + 8 * (v24 & 0x1FF);
  }
  sub_1CC3805A0((uint64_t)v45, v9, v10, (char **)v14, (char *)v15, v25, v26);
  int64x2_t v35 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1CFAC6350);
  *(int64x2_t *)(a1 + 32) = v35;
  if (v35.i64[0] >= 0x400uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8;
    *(void *)(a1 + 32) -= 512;
  }
}

void sub_1CD540070(void *a1, void *a2)
{
  unint64_t v4 = a1[4];
  if (!v4)
  {
    sub_1CD543980((uint64_t)a1);
    unint64_t v4 = a1[4];
  }
  uint64_t v5 = a1[1];
  unint64_t v6 = (void *)(v5 + 8 * (v4 >> 9));
  if (a1[2] == v5) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = *v6 + 8 * (v4 & 0x1FF);
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096;
  }
  *(void *)(v7 - 8) = *a2;
  uint64_t v8 = a1[5] + 1;
  a1[4] = v4 - 1;
  a1[5] = v8;
}

BOOL llvm::SMSchedule::isLoopCarried(llvm::SMSchedule *this, llvm::SwingSchedulerDAG *a2, llvm::MachineInstr *a3)
{
  int v3 = **((unsigned __int16 **)a3 + 2);
  if (v3 != 69 && v3 != 0) {
    return 0;
  }
  uint64_t v8 = (uint64_t *)((char *)a2 + 952);
  uint64_t v50 = 0;
  int64x2_t v51 = a3;
  int v9 = sub_1CD3C8538((uint64_t *)a2 + 119, &v51, &v50);
  unint64_t v10 = 0;
  if (v9) {
    unint64_t v10 = *(void *)(v50 + 8);
  }
  uint64_t v12 = (char *)this + 32;
  uint64_t v11 = (void *)*((void *)this + 4);
  if (!v11) {
    goto LABEL_10;
  }
  uint64_t v20 = (void *)*((void *)this + 4);
  unint64_t v13 = (char *)this + 32;
  do
  {
    unint64_t v21 = v20[4];
    BOOL v22 = v21 >= v10;
    if (v21 >= v10) {
      uint64_t v23 = v20;
    }
    else {
      uint64_t v23 = v20 + 1;
    }
    if (v22) {
      unint64_t v13 = (char *)v20;
    }
    uint64_t v20 = (void *)*v23;
  }
  while (*v23);
  if (v13 == v12 || *((void *)v13 + 4) > v10) {
LABEL_10:
  }
    unint64_t v13 = (char *)this + 32;
  int v14 = *((_DWORD *)this + 12);
  int v15 = *((_DWORD *)this + 14);
  if (!v11) {
    goto LABEL_12;
  }
  unint64_t v24 = (char *)this + 32;
  do
  {
    unint64_t v25 = v11[4];
    BOOL v26 = v25 >= v10;
    if (v25 >= v10) {
      BOOL v27 = v11;
    }
    else {
      BOOL v27 = v11 + 1;
    }
    if (v26) {
      unint64_t v24 = (char *)v11;
    }
    uint64_t v11 = (void *)*v27;
  }
  while (*v27);
  if (v24 == v12 || *((void *)v24 + 4) > v10) {
LABEL_12:
  }
    int v16 = -1;
  else {
    int v16 = (*((_DWORD *)v24 + 10) - v14) / v15;
  }
  int v17 = *((_DWORD *)a3 + 10);
  int v18 = v17 - 1;
  if (v17 == 1)
  {
    unsigned int v19 = 0;
  }
  else
  {
    int v28 = 0;
    unsigned int v19 = 0;
    uint64_t v29 = *((void *)a3 + 4);
    uint64_t v30 = (unsigned int *)(v29 + 36);
    do
    {
      if (*(void *)(v29 + 32 * (v28 + 2) + 16) == *((void *)a3 + 3)) {
        unsigned int v19 = *v30;
      }
      v28 += 2;
      v30 += 16;
    }
    while (v18 != v28);
  }
  int v31 = *((_DWORD *)v13 + 10);
  uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(*((void *)this + 9), v19);
  uint64_t v50 = 0;
  int64x2_t v51 = (llvm::MachineInstr *)VRegDef;
  if ((sub_1CD3C8538(v8, &v51, &v50) & 1) == 0) {
    return 1;
  }
  unint64_t v33 = *(void *)(v50 + 8);
  if (!v33) {
    return 1;
  }
  BOOL result = 1;
  if (**(_WORD **)(*(void *)(v33 + 8) + 16) && **(_WORD **)(*(void *)(v33 + 8) + 16) != 69)
  {
    uint64_t v34 = *(void **)v12;
    if (!*(void *)v12) {
      goto LABEL_56;
    }
    int64x2_t v35 = *(void **)v12;
    unint64_t v36 = (char *)this + 32;
    do
    {
      unint64_t v37 = v35[4];
      BOOL v38 = v37 >= v33;
      if (v37 >= v33) {
        uint64_t v39 = v35;
      }
      else {
        uint64_t v39 = v35 + 1;
      }
      if (v38) {
        unint64_t v36 = (char *)v35;
      }
      int64x2_t v35 = (void *)*v39;
    }
    while (*v39);
    if (v36 == v12 || *((void *)v36 + 4) > v33) {
LABEL_56:
    }
      unint64_t v36 = (char *)this + 32;
    int v40 = *((_DWORD *)v36 + 10);
    int v41 = *((_DWORD *)this + 12);
    int v42 = *((_DWORD *)this + 14);
    unsigned int v43 = (v40 - v41) % v42;
    if (!v34) {
      goto LABEL_68;
    }
    uint64_t v44 = (char *)this + 32;
    do
    {
      unint64_t v45 = v34[4];
      BOOL v46 = v45 >= v33;
      if (v45 >= v33) {
        long long v47 = v34;
      }
      else {
        long long v47 = v34 + 1;
      }
      if (v46) {
        uint64_t v44 = (char *)v34;
      }
      uint64_t v34 = (void *)*v47;
    }
    while (*v47);
    if (v44 != v12 && *((void *)v44 + 4) <= v33) {
      int v48 = (*((_DWORD *)v44 + 10) - v41) / v42;
    }
    else {
LABEL_68:
    }
      int v48 = -1;
    return v43 > (v31 - v14) % v15 || v48 <= v16;
  }
  return result;
}

int32x2_t sub_1CD540380(uint64_t a1, int a2)
{
  uint64_t v5 = 0;
  if (sub_1CD5422D0(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v5))
  {
    unint64_t v4 = (_DWORD *)v5;
    sub_1CB904DFC((void **)(v5 + 8));
    _DWORD *v4 = 0x80000000;
    int32x2_t result = vadd_s32(*(int32x2_t *)(a1 + 8), (int32x2_t)0x1FFFFFFFFLL);
    *(int32x2_t *)(a1 + 8) = result;
  }
  return result;
}

void sub_1CD5403EC(void *a1, void *a2)
{
  unint64_t v3 = a1[4] + a1[5];
  uint64_t v4 = a1[1];
  uint64_t v5 = (char *)(v4 + 8 * (v3 >> 9));
  if (a1[2] == v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)v5 + 8 * (v3 & 0x1FF);
  }
  unint64_t v7 = a2[4];
  uint64_t v8 = a2[1];
  int v9 = (char *)(v8 + 8 * (v7 >> 9));
  if (a2[2] == v8)
  {
    unint64_t v10 = 0;
    unint64_t v13 = 0;
    uint64_t v12 = (char *)(v8 + 8 * ((a2[5] + v7) >> 9));
  }
  else
  {
    unint64_t v10 = (char *)(*(void *)v9 + 8 * (a2[4] & 0x1FFLL));
    unint64_t v11 = a2[5] + v7;
    uint64_t v12 = (char *)(v8 + 8 * (v11 >> 9));
    unint64_t v13 = (char *)(*(void *)v12 + 8 * (v11 & 0x1FF));
  }
  if (v13 == v10) {
    unint64_t v14 = 0;
  }
  else {
    unint64_t v14 = ((uint64_t)&v13[-*(void *)v12] >> 3) + ((v12 - v9) << 6) - ((uint64_t)&v10[-*(void *)v9] >> 3);
  }
  sub_1CC3812A4(a1, v5, v6, v9, v10, v12, v13, v14);
}

llvm::raw_ostream *llvm::NodeSet::print(llvm::NodeSet *this, llvm::raw_ostream *a2)
{
  uint64_t v4 = sub_1CB8E509C(a2, "Num nodes ");
  uint64_t v5 = llvm::raw_ostream::operator<<(v4, ((*((void *)this + 4) - *((void *)this + 3)) >> 3));
  uint64_t v6 = sub_1CB8E509C(v5, " rec ");
  unint64_t v7 = llvm::raw_ostream::operator<<(v6, *((unsigned int *)this + 13));
  uint64_t v8 = sub_1CB8E509C(v7, " mov ");
  int v9 = llvm::raw_ostream::operator<<(v8, *((int *)this + 14));
  unint64_t v10 = sub_1CB8E509C(v9, " depth ");
  unint64_t v11 = llvm::raw_ostream::operator<<(v10, *((unsigned int *)this + 15));
  uint64_t v12 = sub_1CB8E509C(v11, " col ");
  unint64_t v13 = llvm::raw_ostream::operator<<(v12, *((unsigned int *)this + 16));
  sub_1CB8E509C(v13, "\n");
  unint64_t v14 = (uint64_t *)*((void *)this + 3);
  int v15 = (uint64_t *)*((void *)this + 4);
  while (v14 != v15)
  {
    int v16 = sub_1CB8E509C(a2, "   SU(");
    int v17 = llvm::raw_ostream::operator<<(v16, *(unsigned int *)(*v14 + 192));
    int v18 = sub_1CB8E509C(v17, ") ");
    uint64_t v19 = *v14++;
    llvm::MachineInstr::print(*(llvm::MachineInstr **)(v19 + 8), v18, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
  }

  return sub_1CB8E509C(a2, "\n");
}

llvm::raw_ostream *llvm::SMSchedule::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  int v2 = *((_DWORD *)this + 14);
  if (v2 >= 1)
  {
    uint64_t v4 = (uint64_t)this;
    uint64_t v5 = (void *)((char *)this + 32);
    int v6 = *((_DWORD *)this + 12);
    for (int64_t i = v6; i < v6 + v2; ++i)
    {
      uint64_t v8 = *(void *)v4;
      unsigned int v9 = *(_DWORD *)(v4 + 16);
      if (v9)
      {
        unsigned int v10 = (v9 - 1) & (37 * i);
        unint64_t v11 = (int *)(v8 + 56 * v10);
        int v12 = *v11;
        if (*v11 == i) {
          goto LABEL_5;
        }
        int v32 = 1;
        while (v12 != 0x7FFFFFFF)
        {
          unsigned int v33 = v10 + v32++;
          unsigned int v10 = v33 & (v9 - 1);
          unint64_t v11 = (int *)(v8 + 56 * v10);
          int v12 = *v11;
          if (*v11 == i) {
            goto LABEL_5;
          }
        }
      }
      unint64_t v11 = (int *)(v8 + 56 * v9);
LABEL_5:
      uint64_t v13 = *((void *)v11 + 2);
      if (*((void *)v11 + 3) != v13)
      {
        unint64_t v14 = *((void *)v11 + 5);
        int v15 = (void *)(v13 + 8 * (v14 >> 9));
        int v16 = (unint64_t *)(*v15 + 8 * (v14 & 0x1FF));
        uint64_t v17 = *(void *)(v13 + (((*((void *)v11 + 6) + v14) >> 6) & 0x3FFFFFFFFFFFFF8))
            + 8 * ((*((void *)v11 + 6) + v14) & 0x1FF);
        if (v16 != (unint64_t *)v17)
        {
          do
          {
            unint64_t v18 = *v16;
            uint64_t v19 = sub_1CB8E509C(a2, "cycle ");
            uint64_t v20 = llvm::raw_ostream::operator<<(v19, i);
            unint64_t v21 = sub_1CB8E509C(v20, " (");
            BOOL v22 = (void *)*v5;
            if (!*v5) {
              goto LABEL_18;
            }
            uint64_t v23 = v5;
            do
            {
              unint64_t v24 = v22[4];
              BOOL v25 = v24 >= v18;
              if (v24 >= v18) {
                BOOL v26 = v22;
              }
              else {
                BOOL v26 = v22 + 1;
              }
              if (v25) {
                uint64_t v23 = v22;
              }
              BOOL v22 = (void *)*v26;
            }
            while (*v26);
            if (v23 != v5 && v23[4] <= v18) {
              int v27 = (*((_DWORD *)v23 + 10) - *(_DWORD *)(v4 + 48)) / *(_DWORD *)(v4 + 56);
            }
            else {
LABEL_18:
            }
              int v27 = -1;
            int v28 = llvm::raw_ostream::operator<<(v21, v27);
            sub_1CB8E509C(v28, ") ");
            uint64_t v29 = sub_1CB8E509C(a2, "(");
            uint64_t v30 = llvm::raw_ostream::operator<<(v29, *(unsigned int *)(v18 + 192));
            sub_1CB8E509C(v30, ") ");
            llvm::MachineInstr::print(*(llvm::MachineInstr **)(v18 + 8), a2, (const llvm::TargetRegisterInfo *)1, 0, 0, 1, 0);
            this = sub_1CB8E509C(a2, "\n");
            if ((unint64_t *)((char *)++v16 - *v15) == (unint64_t *)4096)
            {
              int v31 = (unint64_t *)v15[1];
              ++v15;
              int v16 = v31;
            }
          }
          while (v16 != (unint64_t *)v17);
          int v6 = *(_DWORD *)(v4 + 48);
          int v2 = *(_DWORD *)(v4 + 56);
        }
      }
    }
  }
  return this;
}

llvm::raw_ostream *llvm::SMSchedule::dump(llvm::SMSchedule *this)
{
  int v2 = llvm::dbgs(this);

  return llvm::SMSchedule::print(this, v2);
}

llvm::raw_ostream *llvm::NodeSet::dump(llvm::NodeSet *this)
{
  int v2 = llvm::dbgs(this);

  return llvm::NodeSet::print(this, v2);
}

void llvm::ResourceManager::initProcResourceVectors(uint64_t a1, uint64_t a2, void *a3)
{
  sub_1CD42769C((uint64_t)a3, *(unsigned int *)(a2 + 48));
  uint64_t v5 = *(unsigned int *)(a2 + 48);
  if (v5 >= 2)
  {
    char v6 = 0;
    uint64_t v7 = *(void *)(a2 + 32);
    uint64_t v8 = v5 - 1;
    unsigned int v9 = (void *)(*a3 + 8);
    unsigned int v10 = (void *)(v7 + 56);
    do
    {
      if (!*v10) {
        void *v9 = 1 << v6++;
      }
      ++v9;
      v10 += 4;
      --v8;
    }
    while (v8);
    uint64_t v11 = *a3;
    for (uint64_t i = 1; i != v5; ++i)
    {
      uint64_t v13 = v7 + 32 * i;
      unint64_t v14 = *(unsigned int **)(v13 + 24);
      if (v14)
      {
        uint64_t v15 = 1 << v6;
        *(void *)(v11 + 8 * i) = 1 << v6;
        uint64_t v16 = *(unsigned int *)(v13 + 8);
        if (v16)
        {
          do
          {
            unsigned int v17 = *v14++;
            v15 |= *(void *)(v11 + 8 * v17);
            *(void *)(v11 + 8 * i) = v15;
            --v16;
          }
          while (v16);
        }
        ++v6;
      }
    }
  }
}

BOOL llvm::ResourceManager::canReserveResources(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    return llvm::DFAPacketizer::canReserveResources(*(void *)(a1 + 24), a2);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  if ((~*(unsigned __int16 *)(v4 + 24 * *(unsigned __int16 *)(a2 + 6) + 8) & 0x1FFF) == 0) {
    return 1;
  }
  uint64_t v5 = v4 + 24 * *(unsigned __int16 *)(a2 + 6);
  if (!*(_WORD *)(v5 + 12)) {
    return 1;
  }
  uint64_t v6 = 4 * *(unsigned __int16 *)(v5 + 12);
  for (uint64_t i = (_WORD *)(*(void *)(*(void *)a1 + 136) + 4 * *(unsigned __int16 *)(v5 + 10) + 2);
        !*i
     || *(void *)(*(void *)(a1 + 176) + 8 * (unsigned __int16)*(i - 1)) < (unint64_t)*(unsigned int *)(*(void *)(v3 + 32) + 32 * (unsigned __int16)*(i - 1) + 8);
        i += 2)
  {
    v6 -= 4;
    if (!v6) {
      return 1;
    }
  }
  return 0;
}

uint64_t llvm::ResourceManager::reserveResources(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 16)) {
    return llvm::DFAPacketizer::reserveResources(*(void *)(result + 24), a2);
  }
  uint64_t v2 = *(void *)(*(void *)(result + 8) + 40);
  if ((~*(unsigned __int16 *)(v2 + 24 * *(unsigned __int16 *)(a2 + 6) + 8) & 0x1FFF) != 0)
  {
    uint64_t v3 = v2 + 24 * *(unsigned __int16 *)(a2 + 6);
    if (*(_WORD *)(v3 + 12))
    {
      uint64_t v4 = 4 * *(unsigned __int16 *)(v3 + 12);
      uint64_t v5 = (_WORD *)(*(void *)(*(void *)result + 136) + 4 * *(unsigned __int16 *)(v3 + 10) + 2);
      do
      {
        if (*v5) {
          ++*(void *)(*(void *)(result + 176) + 8 * (unsigned __int16)*(v5 - 1));
        }
        v5 += 2;
        v4 -= 4;
      }
      while (v4);
    }
  }
  return result;
}

void sub_1CD540A94(uint64_t *a1)
{
  sub_1CD542264(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD540ACC(uint64_t a1)
{
  sub_1CD540E1C(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD540B08()
{
}

void llvm::callDefaultCtor<llvm::MachinePipeliner>()
{
}

uint64_t sub_1CD540B58(uint64_t a1)
{
  sub_1CB8483A0(a1, (uint64_t)&llvm::MachinePipeliner::ID);
  *uint64_t v2 = &unk_1F260EEE0;
  v2[36] = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  llvm::RegisterClassInfo::RegisterClassInfo((llvm::RegisterClassInfo *)(v2 + 37));
  *(unsigned char *)(a1 + 536) = 0;
  *(_OWORD *)(a1 + 540) = 0u;
  *(_DWORD *)(a1 + 556) = 0;
  *(void *)(a1 + 560) = a1 + 576;
  *(void *)(a1 + 568) = 0x400000000;
  *(void *)(a1 + 712) = 0;
  *(void *)(a1 + 704) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v3);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCF3A8, memory_order_acquire) != -1)
  {
    v7[0] = sub_1CC375454;
    v7[1] = &PassRegistry;
    uint64_t v6 = v7;
    std::__call_once(&qword_1EBCCF3A8, &v6, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

uint64_t sub_1CD540C50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  int v12 = llvm::ScheduleDAGInstrs::ScheduleDAGInstrs((llvm::ScheduleDAGInstrs *)a1, *(const llvm::TargetSubtargetInfo ***)(a2 + 248), *(const llvm::MachineLoopInfo **)(a2 + 264), 0);
  *(void *)int v12 = &unk_1F260EFA0;
  *((void *)v12 + 329) = a2;
  *((void *)v12 + 330) = 0;
  *((unsigned char *)v12 + 2648) = 0;
  *((void *)v12 + 332) = a3;
  *((void *)v12 + 333) = a4;
  *((void *)v12 + 334) = a5;
  *(_DWORD *)(a1 + 2680) = a6;
  llvm::ScheduleDAGTopologicalSort::ScheduleDAGTopologicalSort((uint64_t)v12 + 2688, a1 + 48, a1 + 344);
  *(_OWORD *)(a1 + 3132) = 0u;
  *(_OWORD *)(a1 + 3120) = 0u;
  *(_OWORD *)(a1 + 3104) = 0u;
  *(_OWORD *)(a1 + 3152) = 0u;
  *(_OWORD *)(a1 + 3168) = 0u;
  *(_OWORD *)(a1 + 3180) = 0u;
  *(_OWORD *)(a1 + 3200) = 0u;
  *(_DWORD *)(a1 + 3216) = 0;
  *(void *)(a1 + 3224) = 0;
  *(void *)(a1 + 3240) = 0;
  *(void *)(a1 + 3232) = 0;
  (*(void (**)(void))(**(void **)(*(void *)(a2 + 248) + 16) + 336))();
  if (byte_1EBD05548) {
    operator new();
  }
  return a1;
}

void sub_1CD540E1C(uint64_t a1)
{
  *(void *)a1 = &unk_1F260EFA0;
  uint64_t v3 = (void **)(a1 + 3224);
  sub_1CC291398(&v3);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 3200), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 3176), 8);
  sub_1CD456CB4((void *)(a1 + 3128));
  uint64_t v2 = *(void **)(a1 + 3104);
  if (v2)
  {
    *(void *)(a1 + 3112) = v2;
    operator delete(v2);
  }
  sub_1CC37D90C((void *)(a1 + 2688));
  sub_1CC29121C(a1);
}

uint64_t sub_1CD540EB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = a3;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  sub_1CBFCBA2C((void *)(a1 + 8), *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = *(void *)a5;
  *(void *)a5 = 0;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a5 + 8);
  *(_DWORD *)(a5 + 8) = 0;
  int v9 = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a5 + 12);
  *(_DWORD *)(a5 + 12) = v9;
  int v10 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a5 + 16);
  *(_DWORD *)(a5 + 16) = v10;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 56) = *(void *)a6;
  *(void *)a6 = 0;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a6 + 8);
  *(_DWORD *)(a6 + 8) = 0;
  int v11 = *(_DWORD *)(a1 + 68);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a6 + 12);
  *(_DWORD *)(a6 + 12) = v11;
  int v12 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a6 + 16);
  *(_DWORD *)(a6 + 16) = v12;
  *(_DWORD *)(a1 + 80) = 0;
  uint64_t v13 = *(void *)(a1 + 56);
  uint64_t v14 = *(unsigned int *)(a1 + 72);
  uint64_t v15 = v13 + 16 * v14;
  if (*(_DWORD *)(a1 + 64))
  {
    if (v14)
    {
      uint64_t v16 = 16 * v14;
      uint64_t v17 = *(void *)(a1 + 56);
      while ((*(void *)v17 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v17 += 16;
        v16 -= 16;
        if (!v16) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v17 = *(void *)(a1 + 56);
    }
  }
  else
  {
LABEL_6:
    uint64_t v17 = v13 + 16 * v14;
  }
  uint64_t v18 = v13 + 16 * v14;
  if (v17 == v18)
  {
    int v21 = 1;
  }
  else
  {
    int v19 = 0;
    do
    {
      if (v19 <= *(_DWORD *)(v17 + 8)) {
        int v19 = *(_DWORD *)(v17 + 8);
      }
      *(_DWORD *)(a1 + 80) = v19;
      uint64_t v20 = v17 + 16;
      uint64_t v17 = v15;
      if (v20 != v15)
      {
        uint64_t v17 = v20;
        while ((*(void *)v17 | 0x1000) == 0xFFFFFFFFFFFFF000)
        {
          v17 += 16;
          if (v17 == v15)
          {
            uint64_t v17 = v15;
            break;
          }
        }
      }
    }
    while (v17 != v18);
    int v21 = v19 + 1;
  }
  *(_DWORD *)(a1 + 80) = v21;
  return a1;
}

uint64_t sub_1CD541038(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 424);
  *(void *)(a1 + 424) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void **)(a1 + 376);
  if (v3 != (void *)(a1 + 392)) {
    free(v3);
  }
  sub_1CB904DFC((void **)(a1 + 328));
  sub_1CB904DFC((void **)(a1 + 280));
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 256), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 232), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 208), 8);
  sub_1CD541124(a1 + 184);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 184), 8);
  sub_1CD541124(a1 + 160);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 160), 8);
  uint64_t v4 = *(void **)(a1 + 112);
  if (v4 != (void *)(a1 + 128)) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 64);
  if (v5 != (void *)(a1 + 80)) {
    free(v5);
  }
  return a1;
}

void sub_1CD541124(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 80 * v1;
    uint64_t v3 = *(void *)a1 + 24;
    do
    {
      if ((*(void *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4) {
          free(v4);
        }
      }
      v3 += 80;
      v2 -= 80;
    }
    while (v2);
  }
}

uint64_t sub_1CD54118C(uint64_t a1)
{
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 104), 8);
  sub_1CB833A08(a1 + 80, *(void **)(a1 + 88));
  uint64_t v2 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void *sub_1CD5411F8(void *a1)
{
  MEMORY[0x1D25D9CD0](a1[7], 8);
  MEMORY[0x1D25D9CD0](a1[4], 8);
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    a1[2] = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t *sub_1CD541244(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 56 * v2;
    uint64_t v5 = (void **)(v3 + 8);
    do
    {
      if ((*((_DWORD *)v5 - 2) - 0x7FFFFFFF) >= 2) {
        uint64_t v5 = sub_1CB904DFC(v5);
      }
      v5 += 7;
      v4 -= 56;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

uint64_t sub_1CD5412B8(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 24);
  sub_1CC37DA24(&v3);
  MEMORY[0x1D25D9CD0](*(void *)a1, 8);
  return a1;
}

uint64_t sub_1CD541300(uint64_t a1, void *a2)
{
  uint64_t v4 = a2[20];
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = v4;
  *(unsigned char *)(a1 + 16) = (*(uint64_t (**)(void *))(*a2 + 344))(a2);
  *(void *)(a1 + 32) = a1 + 48;
  *(void *)(a1 + 24) = 0;
  unint64_t v5 = *(unsigned int *)(*(void *)(a1 + 8) + 48);
  *(void *)(a1 + 40) = 0x1000000000;
  sub_1CBF7C198(a1 + 32, v5, 0);
  unint64_t v6 = *(unsigned int *)(*(void *)(a1 + 8) + 48);
  *(void *)(a1 + 176) = a1 + 192;
  *(void *)(a1 + 184) = 0x1000000000;
  uint64_t v7 = sub_1CBF7C198(a1 + 176, v6, 0);
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v8 = (*(uint64_t (**)(void *))(*a2 + 104))(a2);
    uint64_t v7 = (_DWORD *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v8 + 1056))(v8, a2);
    uint64_t v9 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v7;
    if (v9)
    {
      sub_1CD511CE4(v9 + 8);
      uint64_t v7 = (_DWORD *)MEMORY[0x1D25D9CE0](v9, 0x1070C405C112D20);
    }
  }
  llvm::ResourceManager::initProcResourceVectors((uint64_t)v7, *(void *)(a1 + 8), (void *)(a1 + 32));
  return a1;
}

void *sub_1CD54145C(uint64_t a1, uint64_t *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (!v3)
  {
    uint64_t v9 = 0;
LABEL_5:
    unint64_t v6 = sub_1CD541520(a1, (uint64_t)a2, a2, v9);
    void *v6 = *a2;
    *((_DWORD *)v6 + 2) = 0;
    return v6;
  }
  int v4 = v3 - 1;
  unsigned int v5 = (37 * *a2) & (v3 - 1);
  unint64_t v6 = (void *)(*(void *)a1 + 16 * v5);
  uint64_t v7 = *v6;
  if (*a2 != *v6)
  {
    int v10 = 0;
    int v11 = 1;
    while (v7 != -1)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v7 == -2;
      }
      if (v12) {
        int v10 = v6;
      }
      unsigned int v13 = v5 + v11++;
      unsigned int v5 = v13 & v4;
      unint64_t v6 = (void *)(*(void *)a1 + 16 * (v13 & v4));
      uint64_t v7 = *v6;
      if (*a2 == *v6) {
        return v6;
      }
    }
    if (v10) {
      uint64_t v9 = v10;
    }
    else {
      uint64_t v9 = v6;
    }
    goto LABEL_5;
  }
  return v6;
}

void *sub_1CD541520(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    sub_1CD541698(a1, 2 * v7);
    uint64_t v8 = *a3;
    int v10 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v11 = (37 * *a3) & v10;
    a4 = (void *)(*(void *)a1 + 16 * v11);
    uint64_t v12 = *a4;
    if (*a3 != *a4)
    {
      unsigned int v13 = 0;
      int v14 = 1;
      while (v12 != -1)
      {
        if (v13) {
          BOOL v15 = 0;
        }
        else {
          BOOL v15 = v12 == -2;
        }
        if (v15) {
          unsigned int v13 = a4;
        }
        unsigned int v16 = v11 + v14++;
        unsigned int v11 = v16 & v10;
        a4 = (void *)(*(void *)a1 + 16 * v11);
        uint64_t v12 = *a4;
        if (v8 == *a4) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
    {
LABEL_3:
      uint64_t v8 = *a4;
      goto LABEL_4;
    }
    sub_1CD541698(a1, v7);
    uint64_t v8 = *a3;
    int v17 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v18 = (37 * *a3) & v17;
    a4 = (void *)(*(void *)a1 + 16 * v18);
    uint64_t v19 = *a4;
    if (*a3 != *a4)
    {
      unsigned int v13 = 0;
      int v20 = 1;
      while (v19 != -1)
      {
        if (v13) {
          BOOL v21 = 0;
        }
        else {
          BOOL v21 = v19 == -2;
        }
        if (v21) {
          unsigned int v13 = a4;
        }
        unsigned int v22 = v18 + v20++;
        unsigned int v18 = v22 & v17;
        a4 = (void *)(*(void *)a1 + 16 * v18);
        uint64_t v19 = *a4;
        if (v8 == *a4) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v13) {
        a4 = v13;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *sub_1CD541698(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  int32x2_t result = operator new(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD541764(a1, v4, &v4[2 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -1;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD541764(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  *(void *)(result + 8) = 0;
  uint64_t v3 = *(void **)result;
  uint64_t v4 = *(unsigned int *)(result + 16);
  if (v4)
  {
    uint64_t v5 = 16 * v4;
    unint64_t v6 = *(void **)result;
    do
    {
      void *v6 = -1;
      v6 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  for (; a2 != a3; a2 += 2)
  {
    uint64_t v7 = *a2;
    if ((unint64_t)*a2 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      int v8 = *(_DWORD *)(result + 16) - 1;
      unsigned int v9 = v8 & (37 * v7);
      uint64_t v10 = &v3[2 * v9];
      uint64_t v11 = *v10;
      if (v7 != *v10)
      {
        uint64_t v12 = 0;
        int v13 = 1;
        while (v11 != -1)
        {
          if (v12) {
            BOOL v14 = 0;
          }
          else {
            BOOL v14 = v11 == -2;
          }
          if (v14) {
            uint64_t v12 = v10;
          }
          unsigned int v15 = v9 + v13++;
          unsigned int v9 = v15 & v8;
          uint64_t v10 = &v3[2 * (v15 & v8)];
          uint64_t v11 = *v10;
          if (v7 == *v10) {
            goto LABEL_7;
          }
        }
        if (v12) {
          uint64_t v10 = v12;
        }
      }
LABEL_7:
      *uint64_t v10 = v7;
      *((_DWORD *)v10 + 2) = *((_DWORD *)a2 + 2);
      ++*(_DWORD *)(result + 8);
    }
  }
  return result;
}

void *sub_1CD541838(void *a1)
{
  uint64_t v2 = (void *)a1[22];
  if (v2 != a1 + 24) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  uint64_t v4 = a1[3];
  a1[3] = 0;
  if (v4)
  {
    sub_1CD511CE4(v4 + 8);
    MEMORY[0x1D25D9CE0](v4, 0x1070C405C112D20);
  }
  return a1;
}

uint64_t sub_1CD5418B4(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 24) = 0;
  uint64_t v4 = (void *)(a1 + 24);
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  sub_1CC37B65C((void *)a1, a2, a3);
  *(unsigned char *)(a1 + 48) = 1;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 60) = 0;
  *(void *)(a1 + 52) = 0;
  unint64_t v5 = *(void *)(a1 + 32) - *v4;
  if ((v5 & 0x7FFFFFFF8) == 0) {
    return a1;
  }
  uint64_t v6 = 0;
  uint64_t v7 = (v5 >> 3);
  do
  {
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    unsigned int v31 = 0;
    uint64_t v8 = *(void *)(*v4 + 8 * v6);
    uint64_t v9 = *(unsigned int *)(v8 + 120);
    if (!v9)
    {
      uint64_t v18 = 0;
      uint64_t v17 = 0;
LABEL_21:
      uint64_t v21 = v17 + 16 * v18;
      uint64_t v19 = v21;
      goto LABEL_22;
    }
    uint64_t v10 = *(void *)(v8 + 112);
    uint64_t v11 = v10 + 16 * v9;
    do
    {
      unint64_t v28 = 0;
      unint64_t v28 = *(void *)v10 & 0xFFFFFFFFFFFFFFF8;
      if (!sub_1CD4C9788(*(void *)a1, *(_DWORD *)(a1 + 16), v28, &v32)) {
        goto LABEL_11;
      }
      unsigned int v12 = *(_DWORD *)(v10 + 12);
      if (v31)
      {
        unsigned int v13 = v31 - 1;
        unsigned int v14 = ((v28 >> 4) ^ (v28 >> 9)) & (v31 - 1);
        uint64_t v15 = *(void *)(v29 + 16 * v14);
        if (v28 == v15)
        {
LABEL_8:
          unsigned int v16 = *((_DWORD *)sub_1CBA7B7CC(&v29, &v28) + 2);
          goto LABEL_9;
        }
        int v26 = 1;
        while (v15 != -4096)
        {
          unsigned int v27 = v14 + v26++;
          unsigned int v14 = v27 & v13;
          uint64_t v15 = *(void *)(v29 + 16 * (v27 & v13));
          if (v28 == v15) {
            goto LABEL_8;
          }
        }
      }
      unsigned int v16 = 0;
LABEL_9:
      if (v12 > v16) {
        *((_DWORD *)sub_1CBA7B7CC(&v29, &v28) + 2) = v12;
      }
LABEL_11:
      v10 += 16;
    }
    while (v10 != v11);
    uint64_t v17 = v29;
    uint64_t v18 = v31;
    if (!v30) {
      goto LABEL_21;
    }
    uint64_t v19 = v29 + 16 * v31;
    if (v31)
    {
      uint64_t v20 = 0;
      while ((*(void *)(v29 + v20) | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v20 += 16;
        if (16 * v31 == v20)
        {
          uint64_t v21 = v29 + 16 * v31;
          goto LABEL_22;
        }
      }
      uint64_t v21 = v29 + v20;
    }
    else
    {
      uint64_t v21 = v29;
    }
LABEL_22:
    uint64_t v22 = v17 + 16 * v18;
    if (v21 != v22)
    {
      int v23 = *(_DWORD *)(a1 + 80);
      do
      {
        v23 += *(_DWORD *)(v21 + 8);
        *(_DWORD *)(a1 + 80) = v23;
        uint64_t v24 = v21 + 16;
        uint64_t v21 = v19;
        if (v24 != v19)
        {
          uint64_t v21 = v24;
          while ((*(void *)v21 | 0x1000) == 0xFFFFFFFFFFFFF000)
          {
            v21 += 16;
            if (v21 == v19)
            {
              uint64_t v21 = v19;
              break;
            }
          }
        }
      }
      while (v21 != v22);
    }
    MEMORY[0x1D25D9CD0]();
    ++v6;
  }
  while (v6 != v7);
  return a1;
}

void sub_1CD541AFC(uint64_t a1, void *a2)
{
  uint64_t v11[4] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  unint64_t v4 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(a2[1] - *a2) >> 4);
  *(void *)(a1 + 56) = a1 + 72;
  *(void *)(a1 + 64) = 0x600000000;
  sub_1CB90D610(a1 + 56, (v4 + 63) >> 6, 0);
  *(_DWORD *)(a1 + 120) = v4;
  unint64_t v5 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(a2[1] - *a2) >> 4);
  uint64_t v7 = v11;
  uint64_t v8 = (uint64_t)v11;
  uint64_t v9 = 4;
  int v10 = 0;
  *(void *)(a1 + 128) = a1 + 144;
  *(void *)(a1 + 136) = 0xA00000000;
  sub_1CD541CE8(a1 + 128, v5, (llvm::SmallPtrSetImplBase *)&v7);
  if ((void *)v8 != v7) {
    free((void *)v8);
  }
  unint64_t v6 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(a2[1] - *a2) >> 4);
  uint64_t v7 = &v9;
  uint64_t v8 = 0x400000000;
  *(void *)(a1 + 784) = a1 + 800;
  *(void *)(a1 + 792) = 0x1000000000;
  sub_1CC37DAB4((char **)(a1 + 784), v6, (uint64_t)&v7);
  if (v7 != &v9) {
    free(v7);
  }
  operator new();
}

void sub_1CD541CE8(uint64_t a1, unint64_t a2, llvm::SmallPtrSetImplBase *a3)
{
  if (*(unsigned int *)(a1 + 12) < a2)
  {
    sub_1CD541E00();
  }
  unint64_t v6 = *(unsigned int *)(a1 + 8);
  if (v6 >= a2) {
    unint64_t v7 = a2;
  }
  else {
    unint64_t v7 = *(unsigned int *)(a1 + 8);
  }
  if (v7)
  {
    uint64_t v8 = *(llvm::SmallPtrSetImplBase **)a1;
    do
    {
      if (v8 != a3) {
        llvm::SmallPtrSetImplBase::CopyFrom(v8, a3);
      }
      uint64_t v8 = (llvm::SmallPtrSetImplBase *)((char *)v8 + 64);
      --v7;
    }
    while (v7);
    unint64_t v6 = *(unsigned int *)(a1 + 8);
  }
  unint64_t v9 = v6 - a2;
  if (v6 >= a2)
  {
    if (v6 > a2)
    {
      unsigned int v12 = (void **)(*(void *)a1 + (v6 << 6) - 64);
      unint64_t v13 = (a2 << 6) - (v6 << 6);
      do
      {
        unsigned int v14 = v12[1];
        if (v14 != *v12) {
          free(v14);
        }
        v12 -= 8;
        v13 += 64;
      }
      while (v13);
    }
  }
  else
  {
    int v10 = (const void **)(*(void *)a1 + (v6 << 6));
    do
      int v10 = (const void **)((char *)llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)v10, v10 + 4, a3)+ 64);
    while (!__CFADD__(v9++, 1));
  }
  *(_DWORD *)(a1 + 8) = a2;
}

void sub_1CD541E00()
{
}

uint64_t sub_1CD541EC8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 1312);
  if (v2)
  {
    uint64_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x1D25D9CE0](v2, 0x10C402FEFCB83);
  }
  sub_1CD541F48((char **)(a1 + 784));
  sub_1CD541FBC((char **)(a1 + 128));
  unint64_t v4 = *(void **)(a1 + 56);
  if (v4 != (void *)(a1 + 72)) {
    free(v4);
  }
  sub_1CD456CB4((void *)(a1 + 8));
  return a1;
}

char **sub_1CD541F48(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 32 * v3;
    do
    {
      unint64_t v5 = *(char **)&v2[v4 - 32];
      if (&v2[v4 - 16] != v5) {
        free(v5);
      }
      v4 -= 32;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

char **sub_1CD541FBC(char **a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = v3 << 6;
    do
    {
      unint64_t v5 = *(void **)&v2[v4 - 56];
      if (v5 != *(void **)&v2[v4 - 64]) {
        free(v5);
      }
      v4 -= 64;
    }
    while (v4);
    uint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void *sub_1CD54202C(void *a1, unsigned int a2)
{
  if (a2 <= 8)
  {
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v3 = a2;
    int32x2_t result = operator new(8 * a2, (std::align_val_t)8uLL);
    a1[1] = result;
    a1[2] = v3;
    int v5 = *(_DWORD *)a1;
    *a1 = *(_DWORD *)a1 & 1;
    if ((v5 & 1) == 0)
    {
      unint64_t v6 = &result[v3];
      goto LABEL_6;
    }
  }
  int32x2_t result = a1 + 1;
  unint64_t v6 = a1 + 9;
  do
LABEL_6:
    *result++ = -4096;
  while (result != v6);
  return result;
}

void **sub_1CD5420B0(void **result)
{
  uint64_t v1 = result;
  int v2 = *((_DWORD *)result + 2);
  if (!v2 && !*((_DWORD *)result + 3)) {
    return result;
  }
  uint64_t v3 = *((unsigned int *)result + 4);
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_11:
      v1[1] = 0;
      return result;
    }
    uint64_t v4 = 56 * v3;
    int32x2_t result = (void **)((char *)*result + 8);
    while (1)
    {
      int v5 = *((_DWORD *)result - 2);
      if (v5 == 0x80000000) {
        goto LABEL_9;
      }
      if (v5 != 0x7FFFFFFF) {
        break;
      }
LABEL_10:
      result += 7;
      v4 -= 56;
      if (!v4) {
        goto LABEL_11;
      }
    }
    int32x2_t result = sub_1CB904DFC(result);
LABEL_9:
    *((_DWORD *)result - 2) = 0x7FFFFFFF;
    goto LABEL_10;
  }

  return sub_1CD54216C(result);
}

void **sub_1CD54216C(void **result)
{
  uint64_t v1 = result;
  uint64_t v2 = *((unsigned int *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  if (v2)
  {
    uint64_t v4 = 56 * v2;
    int32x2_t result = (void **)((char *)*result + 8);
    do
    {
      if ((*((_DWORD *)result - 2) - 0x7FFFFFFF) >= 2) {
        int32x2_t result = sub_1CB904DFC(result);
      }
      result += 7;
      v4 -= 56;
    }
    while (v4);
  }
  int v5 = 1 << (33 - __clz(v3 - 1));
  if (v5 <= 64) {
    int v5 = 64;
  }
  if (v3) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v6 == *((_DWORD *)v1 + 4))
  {
    v1[1] = 0;
    if (v6)
    {
      unint64_t v7 = *v1;
      uint64_t v8 = 56 * v6;
      do
      {
        _DWORD *v7 = 0x7FFFFFFF;
        v7 += 14;
        v8 -= 56;
      }
      while (v8);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*v1, 8);
    return (void **)sub_1CC37D988(v1, v6);
  }
  return result;
}

void sub_1CD542264(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F260EEE0;
  uint64_t v2 = (uint64_t *)a1[70];
  if (v2 != a1 + 72) {
    free(v2);
  }
  sub_1CD50C1C0(a1 + 37);

  sub_1CBA0E6AC((llvm::Pass *)a1);
}

uint64_t sub_1CD5422D0(uint64_t a1, int a2, int a3, void *a4)
{
  if (a2)
  {
    int v4 = a2 - 1;
    unsigned int v5 = (37 * a3) & (a2 - 1);
    uint64_t v6 = (_DWORD *)(a1 + 56 * v5);
    int v7 = *v6;
    if (*v6 == a3)
    {
      uint64_t v8 = 1;
    }
    else
    {
      int v10 = 0;
      int v11 = 1;
      while (v7 != 0x7FFFFFFF)
      {
        if (v10) {
          BOOL v12 = 0;
        }
        else {
          BOOL v12 = v7 == 0x80000000;
        }
        if (v12) {
          int v10 = v6;
        }
        unsigned int v13 = v5 + v11++;
        unsigned int v5 = v13 & v4;
        uint64_t v6 = (_DWORD *)(a1 + 56 * (v13 & v4));
        int v7 = *v6;
        uint64_t v8 = 1;
        if (*v6 == a3) {
          goto LABEL_4;
        }
      }
      uint64_t v8 = 0;
      if (v10) {
        uint64_t v6 = v10;
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
  }
LABEL_4:
  *a4 = v6;
  return v8;
}

_DWORD *sub_1CD542370(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD542428(a1, v6);
  uint64_t v8 = 0;
  sub_1CD5422D0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != 0x7FFFFFFF) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD542428(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v4 = *(void **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  int32x2_t result = operator new(56 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD542500((void **)a1, (uint64_t)v4, (uint64_t)v4 + 56 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 56 * v10;
    do
    {
      _DWORD *result = 0x7FFFFFFF;
      result += 14;
      v11 -= 56;
    }
    while (v11);
  }
  return result;
}

void **sub_1CD542500(void **result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  unint64_t v5 = result;
  result[1] = 0;
  uint64_t v6 = *((unsigned int *)result + 4);
  if (v6)
  {
    int v7 = *result;
    uint64_t v8 = 56 * v6;
    do
    {
      _DWORD *v7 = 0x7FFFFFFF;
      v7 += 14;
      v8 -= 56;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *(_DWORD *)v4;
      if ((*(_DWORD *)v4 - 0x7FFFFFFF) >= 2)
      {
        uint64_t v11 = 0;
        sub_1CD5422D0((uint64_t)*v5, *((_DWORD *)v5 + 4), v9, &v11);
        uint64_t v10 = v11;
        *uint64_t v11 = *(_DWORD *)v4;
        v10[1] = *(void *)(v4 + 8);
        void v10[2] = *(void *)(v4 + 16);
        _OWORD v10[3] = *(void *)(v4 + 24);
        uint64_t v10[4] = *(void *)(v4 + 32);
        *(_OWORD *)(v4 + 24) = 0u;
        *(_OWORD *)(v4 + 8) = 0u;
        v10[5] = *(void *)(v4 + 40);
        v10[6] = *(void *)(v4 + 48);
        *(void *)(v4 + 40) = 0;
        *(void *)(v4 + 48) = 0;
        ++*((_DWORD *)v5 + 2);
        int32x2_t result = sub_1CB904DFC((void **)(v4 + 8));
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
  return result;
}

llvm::cl::Option *sub_1CD542604(llvm::cl::Option *a1, char *a2, __n128 *a3, _WORD *a4, _DWORD **a5)
{
  uint64_t v10 = sub_1CB883A14((uint64_t)a1, 0, 0);
  *(_DWORD *)(v10 + 128) = 0;
  *(void *)(v10 + 136) = &unk_1F25F74C8;
  *(void *)(v10 + 144) = 0;
  *(void *)uint64_t v10 = &unk_1F2643F68;
  *(void *)(v10 + 152) = &unk_1F2643D20;
  *(void *)(v10 + 160) = &unk_1F25F7480;
  *(void *)(v10 + 184) = v10 + 160;
  sub_1CD5426F4(v10, a2, a3, a4, a5);
  llvm::cl::Option::addArgument(a1);
  return a1;
}

__n128 sub_1CD5426F4(uint64_t a1, char *__s, __n128 *a3, _WORD *a4, _DWORD **a5)
{
  size_t v10 = strlen(__s);
  llvm::cl::Option::setArgStr(a1, (unsigned __int8 *)__s, v10);
  __n128 result = *a3;
  *(__n128 *)(a1 + 32) = *a3;
  *(_WORD *)(a1 + 10) = (32 * (*a4 & 3)) | *(_WORD *)(a1 + 10) & 0xFF9F;
  BOOL v12 = *a5;
  *(_DWORD *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 148) = 1;
  *(_DWORD *)(a1 + 144) = *v12;
  return result;
}

void sub_1CD542788(_WORD *a1, char **a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)&qword_1EBCCF8F0, 0, 0);
  byte_1EBCCF970 = 0;
  qword_1EBCCF978 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCCF980 = 0;
  qword_1EBCCF8F0 = (uint64_t)&unk_1F26440A0;
  qword_1EBCCF988 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCCF990 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCCF9A8 = (uint64_t)&qword_1EBCCF990;
  llvm::cl::Option::setArgStr(v4, "pipeliner-show-mask", 0x13uLL);
  word_1EBCCF8FA = (32 * (*a1 & 3)) | word_1EBCCF8FA & 0xFF9F;
  unint64_t v5 = *a2;
  byte_1EBCCF970 = **a2;
  byte_1EBCCF981 = 1;
  byte_1EBCCF980 = *v5;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCF8F0);
}

void sub_1CD5428A8(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  sub_1CB883A14((uint64_t)&llvm::SwpEnableCopyToPhi, 0, 0);
  byte_1EBD05548 = 0;
  qword_1EBD05550 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBD05558 = 0;
  llvm::SwpEnableCopyToPhuint64_t i = (uint64_t)&unk_1F26440A0;
  qword_1EBD05560 = (uint64_t)&unk_1F2643CC0;
  qword_1EBD05568 = (uint64_t)&unk_1F25EDE78;
  qword_1EBD05580 = (uint64_t)&qword_1EBD05568;
  sub_1CD5429A8(a1, a2, a3, a4);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&llvm::SwpEnableCopyToPhi);
}

__n128 sub_1CD5429A8(_WORD *a1, char **a2, _WORD *a3, __n128 *a4)
{
  llvm::cl::Option::setArgStr((uint64_t)&llvm::SwpEnableCopyToPhi, "pipeliner-enable-copytophi", 0x1AuLL);
  word_1EBD054D2 = word_1EBD054D2 & 0xFF9F | (32 * (*a1 & 3));
  uint64_t v8 = *a2;
  byte_1EBD05548 = **a2;
  byte_1EBD05559 = 1;
  byte_1EBD05558 = *v8;
  word_1EBD054D2 = word_1EBD054D2 & 0xFFF8 | *a3 & 7;
  __n128 result = *a4;
  xmmword_1EBD054E8 = (__int128)*a4;
  return result;
}

uint64_t sub_1CD542A40(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(_DWORD *)(a2 + 8);
    unsigned int v5 = *(_DWORD *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4)
      {
        uint64_t v12 = *(void *)a2;
        uint64_t v13 = *(void *)a1;
        uint64_t v14 = 88 * v4;
        do
        {
          sub_1CD542C18(v13, v12);
          long long v15 = *(_OWORD *)(v12 + 48);
          long long v16 = *(_OWORD *)(v12 + 64);
          *(_DWORD *)(v13 + 80) = *(_DWORD *)(v12 + 80);
          *(_OWORD *)(v13 + 48) = v15;
          *(_OWORD *)(v13 + 64) = v16;
          v12 += 88;
          v13 += 88;
          v14 -= 88;
        }
        while (v14);
        unsigned int v5 = *(_DWORD *)(a1 + 8);
        uint64_t v17 = *(void *)a1;
      }
      else
      {
        uint64_t v17 = *(void *)a1;
        uint64_t v13 = *(void *)a1;
      }
      for (uint64_t i = (void *)(v17 + 88 * v5); i != (void *)v13; uint64_t i = sub_1CD456CB4(i - 11))
        ;
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        if (v5)
        {
          uint64_t v19 = 88 * v5;
          uint64_t v20 = *(void *)a1 - 88;
          do
          {
            sub_1CD456CB4((void *)(v20 + v19));
            v19 -= 88;
          }
          while (v19);
        }
        *(_DWORD *)(a1 + 8) = 0;
        sub_1CD542BA8();
      }
      if (v5)
      {
        uint64_t v6 = *(void *)a2;
        uint64_t v7 = *(void *)a1;
        uint64_t v8 = 88 * v5;
        do
        {
          uint64_t v9 = sub_1CD542C18(v7, v6);
          long long v10 = *(_OWORD *)(v6 + 48);
          long long v11 = *(_OWORD *)(v6 + 64);
          *(_DWORD *)(v9 + 80) = *(_DWORD *)(v6 + 80);
          *(_OWORD *)(v9 + 48) = v10;
          *(_OWORD *)(v9 + 64) = v11;
          v6 += 88;
          uint64_t v7 = v9 + 88;
          v8 -= 88;
        }
        while (v8);
      }
      else
      {
        unsigned int v5 = 0;
      }
      sub_1CC37DDD0(*(void *)a2 + 88 * v5, *(void *)a2 + 88 * *(unsigned int *)(a2 + 8), *(void *)a1 + 88 * v5);
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

void sub_1CD542BA8()
{
}

uint64_t sub_1CD542C18(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_1CBFCB9AC(a1, a2);
    sub_1CBFAFDE4((void *)(a1 + 24), *(char **)(a2 + 24), *(char **)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3);
  }
  return a1;
}

void sub_1CD542C64(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = 88 * v2;
    do
    {
      sub_1CD46AEB4(a2, v5);
      long long v7 = *(_OWORD *)(v5 + 48);
      long long v8 = *(_OWORD *)(v5 + 64);
      *(_DWORD *)(a2 + 80) = *(_DWORD *)(v5 + 80);
      *(_OWORD *)(a2 + 48) = v7;
      *(_OWORD *)(a2 + 64) = v8;
      v5 += 88;
      a2 += 88;
      v6 -= 88;
    }
    while (v6);
    unsigned int v9 = *(_DWORD *)(a1 + 8);
    if (v9)
    {
      uint64_t v10 = *(void *)a1;
      uint64_t v11 = 88 * v9;
      uint64_t v12 = v10 - 88;
      do
      {
        sub_1CD456CB4((void *)(v12 + v11));
        v11 -= 88;
      }
      while (v11);
    }
  }
}

void *sub_1CD542CF8(uint64_t a1, uint64_t *a2)
{
  long long v7 = 0;
  char v4 = sub_1CD45B528(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD4CB5C0(a1, a2, v7);
    void *v5 = *a2;
    *((_DWORD *)v5 + 2) = 0;
    void v5[2] = 0;
  }
  return v5;
}

uint64_t *sub_1CD542D6C(uint64_t *result, void *a2)
{
  unsigned int v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = *(void *)(v4 + v7 - 56);
      *(void *)(v6 + v7 - 48) = v6 + v7 - 32;
      __n128 result = (uint64_t *)(v6 + v7 - 48);
      *(result - 1) = v8;
      result[1] = 0x400000000;
      if (*(_DWORD *)(v4 + v7 - 40)) {
        __n128 result = (uint64_t *)sub_1CD41C56C((uint64_t)result, v4 + v7 - 48);
      }
      v7 -= 56;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v9 = *v3;
  *unsigned int v3 = v6;
  a2[1] = v9;
  uint64_t v10 = v3[1];
  v3[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = v3[2];
  v3[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1CD542E44(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v3 = (37 * a3) & (a2 - 1);
    uint64_t v4 = *(void *)(a1 + 16 * v3);
    if (v4 == a3) {
      return *(unsigned int *)(a1 + 16 * v3 + 8);
    }
    int v6 = 1;
    while (v4 != -1)
    {
      int v7 = v3 + v6++;
      uint64_t v3 = v7 & (a2 - 1);
      uint64_t v4 = *(void *)(a1 + 16 * v3);
      if (v4 == a3) {
        return *(unsigned int *)(a1 + 16 * v3 + 8);
      }
    }
  }
  return 0;
}

_DWORD *sub_1CD542EA8(uint64_t a1, _DWORD *a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if (!v2)
  {
    uint64_t v8 = 0;
LABEL_10:
    uint64_t v5 = sub_1CD542F68(a1, (uint64_t)a2, a2, v8);
    *(void *)uint64_t v5 = *a2;
    return v5;
  }
  int v3 = v2 - 1;
  unsigned int v4 = (37 * *a2) & (v2 - 1);
  uint64_t v5 = (_DWORD *)(*(void *)a1 + 8 * v4);
  int v6 = *v5;
  if (*a2 != *v5)
  {
    uint64_t v9 = 0;
    int v10 = 1;
    while (v6 != 0x7FFFFFFF)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v6 == 0x80000000;
      }
      if (v12) {
        uint64_t v9 = v5;
      }
      unsigned int v13 = v4 + v10++;
      unsigned int v4 = v13 & v3;
      uint64_t v5 = (_DWORD *)(*(void *)a1 + 8 * (v13 & v3));
      int v6 = *v5;
      if (*a2 == *v5) {
        return v5;
      }
    }
    if (v9) {
      uint64_t v8 = v9;
    }
    else {
      uint64_t v8 = v5;
    }
    goto LABEL_10;
  }
  return v5;
}

_DWORD *sub_1CD542F68(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 < 3 * v7)
  {
    if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3) {
      goto LABEL_3;
    }
    sub_1CBB16BC8(a1, v7);
    int v15 = *(_DWORD *)(a1 + 16);
    if (v15)
    {
      int v16 = v15 - 1;
      unsigned int v17 = (37 * *a3) & v16;
      a4 = (_DWORD *)(*(void *)a1 + 8 * v17);
      int v18 = *a4;
      if (*a3 == *a4) {
        goto LABEL_3;
      }
      unsigned int v13 = 0;
      int v19 = 1;
      while (v18 != 0x7FFFFFFF)
      {
        if (v13) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == 0x80000000;
        }
        if (v20) {
          unsigned int v13 = a4;
        }
        unsigned int v21 = v17 + v19++;
        unsigned int v17 = v21 & v16;
        a4 = (_DWORD *)(*(void *)a1 + 8 * v17);
        int v18 = *a4;
        if (*a3 == *a4) {
          goto LABEL_3;
        }
      }
      goto LABEL_10;
    }
LABEL_24:
    a4 = 0;
    goto LABEL_3;
  }
  sub_1CBB16BC8(a1, 2 * v7);
  int v9 = *(_DWORD *)(a1 + 16);
  if (!v9) {
    goto LABEL_24;
  }
  int v10 = v9 - 1;
  unsigned int v11 = (37 * *a3) & v10;
  a4 = (_DWORD *)(*(void *)a1 + 8 * v11);
  int v12 = *a4;
  if (*a3 == *a4) {
    goto LABEL_3;
  }
  unsigned int v13 = 0;
  int v14 = 1;
  while (v12 != 0x7FFFFFFF)
  {
    if (v13) {
      BOOL v22 = 0;
    }
    else {
      BOOL v22 = v12 == 0x80000000;
    }
    if (v22) {
      unsigned int v13 = a4;
    }
    unsigned int v23 = v11 + v14++;
    unsigned int v11 = v23 & v10;
    a4 = (_DWORD *)(*(void *)a1 + 8 * v11);
    int v12 = *a4;
    if (*a3 == *a4) {
      goto LABEL_3;
    }
  }
LABEL_10:
  if (v13) {
    a4 = v13;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != 0x7FFFFFFF) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

unint64_t sub_1CD543100(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 88 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD542BA8();
    }
    sub_1CD542BA8();
  }
  return a2;
}

void sub_1CD54316C(char **a1, unint64_t a2)
{
  uint64_t v5 = a1[1];
  unint64_t v4 = a1[2];
  if (a2 <= (v4 - v5) >> 4)
  {
    if (a2)
    {
      bzero(a1[1], 16 * a2);
      v5 += 16 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    int v6 = *a1;
    uint64_t v7 = v5 - *a1;
    unint64_t v8 = a2 + (v7 >> 4);
    if (v8 >> 60) {
      abort();
    }
    uint64_t v9 = v4 - v6;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        sub_1CB833614();
      }
      unsigned int v11 = (char *)operator new(16 * v10);
    }
    else
    {
      unsigned int v11 = 0;
    }
    int v12 = &v11[16 * (v7 >> 4)];
    unsigned int v13 = &v11[16 * v10];
    bzero(v12, 16 * a2);
    int v14 = &v12[16 * a2];
    if (v5 != v6)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v5 - 1);
        v12 -= 16;
        v5 -= 16;
      }
      while (v5 != v6);
      uint64_t v5 = *a1;
    }
    *a1 = v12;
    a1[1] = v14;
    a1[2] = v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void *sub_1CD54329C(void *result)
{
  int v1 = *(_DWORD *)result;
  if (*(_DWORD *)result > 1u || *((_DWORD *)result + 1))
  {
    if (v1)
    {
      int v3 = result + 1;
      unint64_t v4 = result + 9;
    }
    else
    {
      uint64_t v2 = *((unsigned int *)result + 4);
      if (((2 * v1) & 0xFFFFFFFC) < v2 && v2 >= 0x41) {
        return sub_1CD543314(result);
      }
      if (!v2)
      {
        int v5 = 0;
LABEL_11:
        *(_DWORD *)__n128 result = v5;
        *((_DWORD *)result + 1) = 0;
        return result;
      }
      int v3 = (void *)result[1];
      unint64_t v4 = &v3[v2];
    }
    do
      *v3++ = -4096;
    while (v3 != v4);
    int v5 = *(_DWORD *)result & 1;
    goto LABEL_11;
  }
  return result;
}

void *sub_1CD543314(void *result)
{
  int v1 = result;
  unsigned int v2 = *(_DWORD *)result;
  char v3 = __clz((*(_DWORD *)result >> 1) - 1);
  if ((v3 & 0x3E) == 0x1C) {
    int v4 = 64;
  }
  else {
    int v4 = 1 << (33 - v3);
  }
  if (v2 >= 2) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if ((v2 & 1) != 0 && v5 < 9)
  {
    int v6 = result + 1;
    _DWORD *result = 1;
    uint64_t v7 = result + 9;
    do
LABEL_10:
      *v6++ = -4096;
    while (v6 != v7);
    return result;
  }
  if ((v2 & 1) == 0)
  {
    if (v5 == *((_DWORD *)result + 4))
    {
      _DWORD *result = 0;
      if (!v5) {
        return result;
      }
      int v6 = (void *)result[1];
      uint64_t v7 = &v6[v5];
      goto LABEL_10;
    }
    MEMORY[0x1D25D9CD0](result[1], 8);
  }

  return sub_1CD54202C(v1, v5);
}

void *sub_1CD5433EC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v14 = 0;
  __n128 result = (void *)sub_1CD5434AC(a2, *a3, &v14);
  uint64_t v7 = v14;
  if (result)
  {
    uint64_t v8 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v9 = 8;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(unsigned int *)(a2 + 16);
    }
    char v10 = 0;
    uint64_t v11 = v8 + 8 * v9;
  }
  else
  {
    __n128 result = sub_1CD543558((_DWORD *)a2, a3, v14);
    uint64_t v7 = result;
    void *result = *a3;
    uint64_t v12 = a2 + 8;
    if (*(unsigned char *)a2)
    {
      uint64_t v13 = 8;
    }
    else
    {
      uint64_t v12 = *(void *)(a2 + 8);
      uint64_t v13 = *(unsigned int *)(a2 + 16);
    }
    uint64_t v11 = v12 + 8 * v13;
    char v10 = 1;
  }
  *(void *)a1 = v7;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t sub_1CD5434AC(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 8;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 8 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    char v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        char v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 8 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD543558(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 8;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD543618((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD5434AC((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

uint64_t sub_1CD543618(uint64_t a1, unsigned int a2)
{
  v14[8] = *MEMORY[0x1E4F143B8];
  if (a2 >= 9)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    unsigned int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 8)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD543794(a1, v6, &v6[v7]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v8 = v14;
  for (uint64_t i = 8; i != 72; i += 8)
  {
    uint64_t v10 = *(void *)(a1 + i);
    if ((v10 | 0x1000) != 0xFFFFFFFFFFFFF000) {
      *v8++ = v10;
    }
  }
  if (a2 > 8)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v11 = a2;
    *(void *)(a1 + 8) = operator new(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v11;
  }
  return sub_1CD543794(a1, v14, v8);
}

uint64_t sub_1CD543794(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  int v5 = (_DWORD *)result;
  int v6 = *(_DWORD *)result;
  *(void *)uint64_t result = *(_DWORD *)result & 1;
  if (v6)
  {
    uint64_t v8 = (void *)(result + 8);
    uint64_t v9 = (void *)(result + 72);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(result + 16);
    if (!v7) {
      goto LABEL_10;
    }
    uint64_t v8 = *(void **)(result + 8);
    uint64_t v9 = &v8[v7];
  }
  do
    *v8++ = -4096;
  while (v8 != v9);
LABEL_10:
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    if ((*a2 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      uint64_t v11 = 0;
      uint64_t result = sub_1CD5434AC((uint64_t)v5, v10, &v11);
      *uint64_t v11 = *a2;
      *v5 += 2;
    }
    ++a2;
  }
  return result;
}

void *sub_1CD543858(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CBA0E618(a1, a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CC38046C(a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t *sub_1CD5438B8(uint64_t *result, unint64_t a2, uint64_t a3, int a4)
{
  int v6 = result;
  uint64_t v8 = (uint64_t **)(result + 1);
  uint64_t v7 = (uint64_t *)result[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v7;
        unint64_t v10 = v7[4];
        if (v10 <= a2) {
          break;
        }
        uint64_t v7 = *v9;
        uint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_9;
        }
      }
      if (v10 >= a2) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        uint64_t v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v9 = (uint64_t **)(result + 1);
LABEL_9:
    uint64_t v11 = operator new(0x30uLL);
    uint64_t v11[4] = a3;
    *((_DWORD *)v11 + 10) = a4;
    *uint64_t v11 = 0;
    v11[1] = 0;
    void v11[2] = v9;
    void *v8 = v11;
    uint64_t v12 = *(void *)*v6;
    if (v12)
    {
      uint64_t *v6 = v12;
      uint64_t v13 = *v8;
    }
    else
    {
      uint64_t v13 = v11;
    }
    uint64_t result = sub_1CB8358B8((uint64_t *)v6[1], v13);
    ++v6[2];
  }
  return result;
}

void sub_1CD543980(uint64_t a1)
{
  unsigned int v2 = *(char **)(a1 + 8);
  unint64_t v3 = *(unsigned char **)(a1 + 16);
  if (v3 == v2) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = ((v3 - v2) << 6) - 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if ((unint64_t)(v4 - (*(void *)(a1 + 40) + v5)) < 0x200)
  {
    int v6 = *(char **)(a1 + 24);
    uint64_t v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v6[-*(void *)a1];
    if (v3 - v2 >= (unint64_t)v8)
    {
      if (v6 == v7) {
        unint64_t v10 = 1;
      }
      else {
        unint64_t v10 = v8 >> 2;
      }
      uint64_t v23 = a1 + 24;
      if (v10 >> 61) {
        sub_1CB833614();
      }
      BOOL v20 = (char *)operator new(8 * v10);
      unsigned int v21 = v20;
      *(void *)&long long v22 = v20;
      *((void *)&v22 + 1) = &v20[8 * v10];
      int v19 = operator new(0x1000uLL);
      sub_1CD3F23B4((uint64_t)&v20, &v19);
      uint64_t v11 = *(char **)(a1 + 8);
      if (v11 == *(char **)(a1 + 16))
      {
        uint64_t v12 = *(char **)(a1 + 8);
      }
      else
      {
        do
        {
          sub_1CB904CD8((uint64_t)&v20, v11);
          v11 += 8;
        }
        while (v11 != *(char **)(a1 + 16));
        uint64_t v12 = *(char **)(a1 + 8);
      }
      uint64_t v13 = *(char **)a1;
      int v14 = v21;
      *(void *)a1 = v20;
      *(void *)(a1 + 8) = v14;
      BOOL v20 = v13;
      unsigned int v21 = v12;
      uint64_t v15 = *(void *)(a1 + 24);
      uint64_t v16 = v22;
      *(_OWORD *)(a1 + 16) = v22;
      *(void *)&long long v22 = v11;
      *((void *)&v22 + 1) = v15;
      if (v16 - (void)v14 == 8) {
        uint64_t v17 = 256;
      }
      else {
        uint64_t v17 = *(void *)(a1 + 32) + 512;
      }
      *(void *)(a1 + 32) = v17;
      if (v11 != v12) {
        *(void *)&long long v22 = &v11[(v12 - v11 + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v13) {
        operator delete(v13);
      }
    }
    else
    {
      if (v2 == v7)
      {
        BOOL v20 = (char *)operator new(0x1000uLL);
        sub_1CD3F23B4(a1, &v20);
        uint64_t v9 = *(void *)(a1 + 16);
        BOOL v20 = *(char **)(v9 - 8);
        *(void *)(a1 + 16) = v9 - 8;
      }
      else
      {
        BOOL v20 = (char *)operator new(0x1000uLL);
      }
      sub_1CD3F24DC((void **)a1, &v20);
      if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
        uint64_t v18 = 256;
      }
      else {
        uint64_t v18 = *(void *)(a1 + 32) + 512;
      }
      *(void *)(a1 + 32) = v18;
    }
  }
  else
  {
    *(void *)(a1 + 32) = v5 + 512;
    BOOL v20 = (char *)*((void *)v3 - 1);
    *(void *)(a1 + 16) = v3 - 8;
    sub_1CD3F24DC((void **)a1, &v20);
  }
}

void sub_1CD543B70(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = v4 - v3;
  if (v4 == v3) {
    unint64_t v6 = a2 + 1;
  }
  else {
    unint64_t v6 = a2;
  }
  if (v4 == v3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = ((v4 - v3) << 6) - 1;
  }
  if ((v6 & 0x1FF) != 0) {
    unint64_t v8 = (v6 >> 9) + 1;
  }
  else {
    unint64_t v8 = v6 >> 9;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  unint64_t v10 = v7 - (*(void *)(a1 + 40) + v9);
  if (v8 >= v10 >> 9) {
    unint64_t v11 = v10 >> 9;
  }
  else {
    unint64_t v11 = v8;
  }
  if (v8 <= v10 >> 9)
  {
    for (*(void *)(a1 + 32) = v9 + (v11 << 9); v11; --v11)
    {
      uint64_t v25 = *(void *)(a1 + 16);
      *(void *)&long long v31 = *(void *)(v25 - 8);
      *(void *)(a1 + 16) = v25 - 8;
      sub_1CD3F24DC((void **)a1, &v31);
    }
  }
  else
  {
    unint64_t v12 = v8 - v11;
    uint64_t v13 = *(void *)(a1 + 24) - *(void *)a1;
    if (v8 - v11 <= (v13 >> 3) - (v5 >> 3))
    {
      if (v12)
      {
        if (v3 == *(void *)a1)
        {
LABEL_43:
          unint64_t v28 = v12;
          do
          {
            *(void *)&long long v31 = operator new(0x1000uLL);
            sub_1CD3F23B4(a1, &v31);
            --v28;
          }
          while (v28);
          v11 += v12;
          uint64_t v9 = *(void *)(a1 + 32);
        }
        else
        {
          while (1)
          {
            *(void *)&long long v31 = operator new(0x1000uLL);
            sub_1CD3F24DC((void **)a1, &v31);
            uint64_t v26 = *(void *)(a1 + 8);
            uint64_t v27 = *(void *)(a1 + 16) - v26 == 8 ? 511 : 512;
            uint64_t v9 = v27 + *(void *)(a1 + 32);
            *(void *)(a1 + 32) = v9;
            if (!--v12) {
              break;
            }
            if (v26 == *(void *)a1) {
              goto LABEL_43;
            }
          }
        }
      }
      for (*(void *)(a1 + 32) = v9 + (v11 << 9); v11; --v11)
      {
        uint64_t v29 = *(void *)(a1 + 16);
        *(void *)&long long v31 = *(void *)(v29 - 8);
        *(void *)(a1 + 16) = v29 - 8;
        sub_1CD3F24DC((void **)a1, &v31);
      }
    }
    else
    {
      BOOL v14 = v4 == v3;
      if (v13 >> 2 <= v12 + (v5 >> 3)) {
        unint64_t v15 = v12 + (v5 >> 3);
      }
      else {
        unint64_t v15 = v13 >> 2;
      }
      uint64_t v33 = a1 + 24;
      if (v15)
      {
        if (v15 >> 61) {
          sub_1CB833614();
        }
        uint64_t v16 = (char *)operator new(8 * v15);
      }
      else
      {
        uint64_t v16 = 0;
      }
      unint64_t v17 = (v8 << 9) - v14;
      *(void *)&long long v31 = v16;
      *((void *)&v31 + 1) = v16;
      *(void *)&long long v32 = v16;
      *((void *)&v32 + 1) = &v16[8 * v15];
      do
      {
        uint64_t v30 = operator new(0x1000uLL);
        sub_1CD3F23B4((uint64_t)&v31, &v30);
        --v12;
      }
      while (v12);
      for (uint64_t i = *(void *)(a1 + 16); v11; --v11)
      {
        sub_1CB904CD8((uint64_t)&v31, (void *)(i - 8));
        uint64_t i = *(void *)(a1 + 16) - 8;
        *(void *)(a1 + 16) = i;
      }
      int v19 = (void *)i;
      if (*(void *)(a1 + 8) != i)
      {
        int v19 = *(void **)(a1 + 8);
        do
          sub_1CB904CD8((uint64_t)&v31, v19++);
        while (v19 != *(void **)(a1 + 16));
        uint64_t i = *(void *)(a1 + 8);
      }
      BOOL v20 = *(void **)a1;
      long long v21 = v31;
      long long v22 = v32;
      *(void *)&long long v31 = *(void *)a1;
      *((void *)&v31 + 1) = i;
      uint64_t v23 = *(void *)(a1 + 24);
      uint64_t v24 = *(void *)(a1 + 32);
      *(_OWORD *)a1 = v21;
      *(_OWORD *)(a1 + 16) = v22;
      *(void *)&long long v32 = v19;
      *((void *)&v32 + 1) = v23;
      *(void *)(a1 + 32) = v17 + v24;
      if (v19 != (void *)i) {
        *(void *)&long long v32 = (char *)v19 + ((i - (void)v19 + 7) & 0xFFFFFFFFFFFFFFF8);
      }
      if (v20) {
        operator delete(v20);
      }
    }
  }
}

void sub_1CD543E14(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16) - *(void *)(a1 + 8);
  if (v3) {
    unint64_t v4 = a2;
  }
  else {
    unint64_t v4 = a2 + 1;
  }
  if ((v4 & 0x1FF) != 0) {
    unint64_t v5 = (v4 >> 9) + 1;
  }
  else {
    unint64_t v5 = v4 >> 9;
  }
  unint64_t v6 = *(void *)(a1 + 32);
  if (v5 >= v6 >> 9) {
    unint64_t v7 = v6 >> 9;
  }
  else {
    unint64_t v7 = v5;
  }
  if (v5 <= v6 >> 9)
  {
    for (*(void *)(a1 + 32) = v6 - (v7 << 9); v7; --v7)
    {
      long long v21 = *(void **)(a1 + 8);
      *(void *)&long long v27 = *v21;
      *(void *)(a1 + 8) = v21 + 1;
      sub_1CB904CD8(a1, &v27);
    }
  }
  else
  {
    unint64_t v8 = v5 - v7;
    uint64_t v9 = *(void *)(a1 + 24) - *(void *)a1;
    if (v5 - v7 <= (v9 >> 3) - (v3 >> 3))
    {
      if (v8)
      {
        while (*(void *)(a1 + 24) != *(void *)(a1 + 16))
        {
          *(void *)&long long v27 = operator new(0x1000uLL);
          sub_1CD3F23B4(a1, &v27);
          --v5;
          if (!--v8) {
            goto LABEL_43;
          }
        }
        for (uint64_t i = 0; i != v8; ++i)
        {
          *(void *)&long long v27 = operator new(0x1000uLL);
          sub_1CD3F24DC((void **)a1, &v27);
          if (*(void *)(a1 + 16) - *(void *)(a1 + 8) == 8) {
            uint64_t v23 = 511;
          }
          else {
            uint64_t v23 = 512;
          }
          uint64_t v24 = v23 + *(void *)(a1 + 32);
          *(void *)(a1 + 32) = v24;
        }
        unint64_t v7 = v5;
      }
      else
      {
LABEL_43:
        uint64_t v24 = *(void *)(a1 + 32);
      }
      for (*(void *)(a1 + 32) = v24 - (v7 << 9); v7; --v7)
      {
        uint64_t v25 = *(void **)(a1 + 8);
        *(void *)&long long v27 = *v25;
        *(void *)(a1 + 8) = v25 + 1;
        sub_1CB904CD8(a1, &v27);
      }
    }
    else
    {
      uint64_t v10 = v3 >> 3;
      if (v9 >> 2 <= v8 + (v3 >> 3)) {
        unint64_t v11 = v8 + v10;
      }
      else {
        unint64_t v11 = v9 >> 2;
      }
      uint64_t v29 = a1 + 24;
      if (v11)
      {
        if (v11 >> 61) {
          sub_1CB833614();
        }
        unint64_t v12 = (char *)operator new(8 * v11);
      }
      else
      {
        unint64_t v12 = 0;
      }
      uint64_t v13 = v7 << 9;
      *(void *)&long long v27 = v12;
      *((void *)&v27 + 1) = &v12[8 * (v10 - v7)];
      *(void *)&long long v28 = *((void *)&v27 + 1);
      *((void *)&v28 + 1) = &v12[8 * v11];
      do
      {
        uint64_t v26 = operator new(0x1000uLL);
        sub_1CD3F23B4((uint64_t)&v27, &v26);
        --v8;
      }
      while (v8);
      for (unsigned int j = *(char **)(a1 + 8); v7; --v7)
      {
        sub_1CB904CD8((uint64_t)&v27, j);
        unsigned int j = (char *)(*(void *)(a1 + 8) + 8);
        *(void *)(a1 + 8) = j;
      }
      unint64_t v15 = j;
      if (*(char **)(a1 + 16) != j)
      {
        unint64_t v15 = *(char **)(a1 + 16);
        do
        {
          v15 -= 8;
          sub_1CD3F24DC((void **)&v27, v15);
        }
        while (v15 != *(char **)(a1 + 8));
        unsigned int j = *(char **)(a1 + 16);
      }
      uint64_t v16 = *(void **)a1;
      long long v17 = v27;
      long long v18 = v28;
      *(void *)&long long v27 = *(void *)a1;
      *((void *)&v27 + 1) = v15;
      uint64_t v19 = *(void *)(a1 + 24);
      uint64_t v20 = *(void *)(a1 + 32);
      *(_OWORD *)a1 = v17;
      *(_OWORD *)(a1 + 16) = v18;
      *(void *)&long long v28 = j;
      *((void *)&v28 + 1) = v19;
      *(void *)(a1 + 32) = v20 - v13;
      if (j != v15) {
        *(void *)&long long v28 = &j[(v15 - j + 7) & 0xFFFFFFFFFFFFFFF8];
      }
      if (v16) {
        operator delete(v16);
      }
    }
  }
}

uint64_t llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::compare(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 80) != *(void *)(a2 + 80)) {
    return 1;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 8);
  if (v5 != *(_DWORD *)(a2 + 8)) {
    return 1;
  }
  if (!sub_1CC33FBEC(*(char **)a1, (char *)(*(void *)a1 + 8 * v5), *(void **)a2)) {
    return 1;
  }
  int v6 = *(_DWORD *)(a1 + 56);
  if (v6 != *(_DWORD *)(a2 + 56)) {
    return 1;
  }
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = *(unsigned int *)(a1 + 64);
  if (v6)
  {
    if (v8)
    {
      uint64_t v9 = 16 * v8;
      uint64_t v10 = *(uint64_t **)(a1 + 48);
      while ((*v10 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v10 += 2;
        v9 -= 16;
        if (!v9) {
          goto LABEL_12;
        }
      }
    }
    else
    {
      uint64_t v10 = *(uint64_t **)(a1 + 48);
    }
  }
  else
  {
LABEL_12:
    uint64_t v10 = (uint64_t *)(v7 + 16 * v8);
  }
  if (v10 == (uint64_t *)(v7 + 16 * v8)) {
    return 0;
  }
  uint64_t v11 = *v10;
  uint64_t v13 = 0;
  uint64_t v14 = v11;
  int v12 = sub_1CBFA3AF4((uint64_t *)(a2 + 48), &v14, &v13);
  uint64_t result = 1;
  if (v12)
  {
    if (v13 != *(void *)(a2 + 48) + 16 * *(unsigned int *)(a2 + 64)) {
      llvm::DomTreeNodeBase<llvm::MachineBasicBlock>::compare();
    }
  }
  return result;
}

llvm::raw_ostream *llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  sub_1CB8E509C(a2, "=============================--------------------------------\n");
  sub_1CB8E509C(a2, "Inorder PostDominator Tree: ");
  if (!*(unsigned char *)(a1 + 88))
  {
    unint64_t v4 = sub_1CB8E509C(a2, "DFSNumbers invalid: ");
    uint64_t v5 = llvm::raw_ostream::operator<<(v4, *(unsigned int *)(a1 + 92));
    sub_1CB8E509C(v5, " slow queries.");
  }
  sub_1CB8E509C(a2, "\n");
  uint64_t v6 = *(void *)(a1 + 72);
  if (v6) {
    sub_1CD52D3B4(v6, a2, 1u);
  }
  sub_1CB8E509C(a2, "Roots: ");
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = *(llvm::MachineBasicBlock ***)a1;
    uint64_t v9 = 8 * v7;
    do
    {
      uint64_t v10 = *v8++;
      llvm::MachineBasicBlock::printAsOperand(v10, a2);
      sub_1CB8E509C(a2, " ");
      v9 -= 8;
    }
    while (v9);
  }

  return sub_1CB8E509C(a2, "\n");
}

void llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::verify(uint64_t a1)
{
  unsigned int v2 = operator new(8uLL);
  uint64_t v3 = v2;
  *unsigned int v2 = 0;
  unint64_t v4 = v2 + 1;
  uint64_t v5 = v2 + 1;
  uint64_t v9 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  sub_1CC389910(a1);
}

void llvm::initializeMachinePostDominatorTreePass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCFBF0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC383944;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCFBF0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::MachinePostDominatorTree *llvm::MachinePostDominatorTree::MachinePostDominatorTree(llvm::MachinePostDominatorTree *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::MachinePostDominatorTree::ID);
  *(void *)unsigned int v2 = &unk_1F260F060;
  *((void *)v2 + 31) = 0;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCFBF0, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC383944;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCFBF0, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::MachinePostDominatorTree::getAnalysisUsage(uint64_t this, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  llvm::MachineFunctionPass::getAnalysisUsage(this, a2);
}

uint64_t llvm::MachinePostDominatorTree::verifyAnalysis(llvm::MachinePostDominatorTree *this)
{
  uint64_t result = *((void *)this + 31);
  if (result) {
    BOOL v2 = llvm::VerifyMachineDomInfo == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2) {
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::verify(result);
  }
  return result;
}

void llvm::MachinePostDominatorTree::print(llvm::MachinePostDominatorTree *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
}

void sub_1CD54468C(llvm::Pass *a1)
{
  sub_1CD544700(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::MachinePostDominatorTree>()
{
}

void sub_1CD544700(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260F060;
  uint64_t v1 = *((void *)a1 + 31);
  *((void *)a1 + 31) = 0;
  if (v1)
  {
    BOOL v2 = a1;
    sub_1CC383B9C(v1);
    a1 = v2;
  }

  sub_1CBA0E6AC(a1);
}

unsigned char *sub_1CD544768(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(char **)(a3 + 64);
  uint64_t v7 = *(char **)(a3 + 72);
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x800000000;
  sub_1CB91FB58(a1, v6, v7);
  int v8 = *(char **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  uint64_t v10 = *(char **)a1;
  if (v9)
  {
    uint64_t v20 = 8 * v9;
    uint64_t v10 = *(char **)a1;
    while (*(void *)v10)
    {
      v10 += 8;
      v20 -= 8;
      if (!v20)
      {
        uint64_t v10 = (char *)(*(void *)a1 + 8 * v9);
        break;
      }
    }
  }
  uint64_t v11 = (v10 - v8) >> 3;
  int v12 = v10 + 8;
  if (v11 != v9 && v12 != (void *)(*(void *)a1 + 8 * v9))
  {
    uint64_t v14 = 8 * v9 - 8 * v11 - 8;
    do
    {
      if (*v12)
      {
        *(void *)uint64_t v10 = *v12;
        v10 += 8;
      }
      ++v12;
      v14 -= 8;
    }
    while (v14);
    int v8 = *(char **)a1;
  }
  unint64_t v15 = v10 - v8;
  unint64_t v16 = (unint64_t)(v10 - v8) >> 3;
  *(_DWORD *)(a1 + 8) = v16;
  uint64_t result = (unsigned char *)sub_1CD54495C(a2, a3);
  uint64_t v18 = a2 + 8;
  if (*(unsigned char *)a2)
  {
    unsigned int v19 = 4;
  }
  else
  {
    uint64_t v18 = *(void *)(a2 + 8);
    unsigned int v19 = *(_DWORD *)(a2 + 16);
  }
  if ((unsigned char *)(v18 + 72 * v19) != result)
  {
    uint64_t v21 = *((unsigned int *)result + 4);
    if (v21)
    {
      uint64_t v22 = (v15 >> 3);
      uint64_t v23 = (uint64_t *)*((void *)result + 1);
      uint64_t v24 = &v23[v21];
      do
      {
        uint64_t v25 = *v23;
        uint64_t v26 = 8 * v22;
        long long v27 = v8;
        long long v28 = &v8[8 * v22];
        if (v22)
        {
          uint64_t v29 = 8 * v22;
          long long v27 = v8;
          while (*(void *)v27 != v25)
          {
            v27 += 8;
            v29 -= 8;
            if (!v29)
            {
              long long v27 = &v8[8 * v22];
              break;
            }
          }
        }
        uint64_t v30 = (v27 - v8) >> 3;
        if (v30 != v22)
        {
          long long v31 = v27 + 8;
          if (v27 + 8 != v28)
          {
            uint64_t v32 = v26 - 8 * v30 - 8;
            do
            {
              if (*v31 != v25)
              {
                *(void *)long long v27 = *v31;
                v27 += 8;
              }
              ++v31;
              v32 -= 8;
            }
            while (v32);
            int v8 = *(char **)a1;
          }
        }
        unint64_t v33 = v27 - v8;
        uint64_t v22 = (v33 >> 3);
        ++v23;
      }
      while (v23 != v24);
      unint64_t v16 = v33 >> 3;
      *(_DWORD *)(a1 + 8) = v22;
    }
    uint64_t v34 = (uint64_t *)*((void *)result + 5);
    int64x2_t v35 = &v34[*((unsigned int *)result + 12)];
    return sub_1CD4D069C((unsigned int *)a1, (uint64_t)&v8[8 * v16], v34, v35);
  }
  return result;
}

uint64_t sub_1CD54495C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if (sub_1CD5449C0(a1, a2, &v6)) {
    return v6;
  }
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    unsigned int v5 = 4;
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 8);
    unsigned int v5 = *(_DWORD *)(a1 + 16);
  }
  return v4 + 72 * v5;
}

uint64_t sub_1CD5449C0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = (void *)(v3 + 72 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        uint64_t v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      uint64_t v7 = (void *)(v3 + 72 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      uint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

unsigned char *sub_1CD544A74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *(void *)(a3 + 88);
  uint64_t v6 = *(void *)(a3 + 96);
  *(void *)a1 = a1 + 16;
  *(void *)(a1 + 8) = 0x800000000;
  sub_1CC0579B0(a1, v6, v6, v7, v7);
  uint64_t v8 = *(char **)a1;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  uint64_t v10 = *(char **)a1;
  if (v9)
  {
    uint64_t v20 = 8 * v9;
    uint64_t v10 = *(char **)a1;
    while (*(void *)v10)
    {
      v10 += 8;
      v20 -= 8;
      if (!v20)
      {
        uint64_t v10 = (char *)(*(void *)a1 + 8 * v9);
        break;
      }
    }
  }
  uint64_t v11 = (v10 - v8) >> 3;
  BOOL v12 = v10 + 8;
  if (v11 != v9 && v12 != (void *)(*(void *)a1 + 8 * v9))
  {
    uint64_t v14 = 8 * v9 - 8 * v11 - 8;
    do
    {
      if (*v12)
      {
        *(void *)uint64_t v10 = *v12;
        v10 += 8;
      }
      ++v12;
      v14 -= 8;
    }
    while (v14);
    uint64_t v8 = *(char **)a1;
  }
  unint64_t v15 = v10 - v8;
  unint64_t v16 = (unint64_t)(v10 - v8) >> 3;
  *(_DWORD *)(a1 + 8) = v16;
  uint64_t result = (unsigned char *)sub_1CD54495C(a2 + 296, a3);
  if (*(unsigned char *)(a2 + 296))
  {
    uint64_t v18 = a2 + 304;
    unsigned int v19 = 4;
  }
  else
  {
    uint64_t v18 = *(void *)(a2 + 304);
    unsigned int v19 = *(_DWORD *)(a2 + 312);
  }
  if ((unsigned char *)(v18 + 72 * v19) != result)
  {
    uint64_t v21 = *((unsigned int *)result + 4);
    if (v21)
    {
      uint64_t v22 = (v15 >> 3);
      uint64_t v23 = (uint64_t *)*((void *)result + 1);
      uint64_t v24 = &v23[v21];
      do
      {
        uint64_t v25 = *v23;
        uint64_t v26 = 8 * v22;
        long long v27 = v8;
        long long v28 = &v8[8 * v22];
        if (v22)
        {
          uint64_t v29 = 8 * v22;
          long long v27 = v8;
          while (*(void *)v27 != v25)
          {
            v27 += 8;
            v29 -= 8;
            if (!v29)
            {
              long long v27 = &v8[8 * v22];
              break;
            }
          }
        }
        uint64_t v30 = (v27 - v8) >> 3;
        if (v30 != v22)
        {
          long long v31 = v27 + 8;
          if (v27 + 8 != v28)
          {
            uint64_t v32 = v26 - 8 * v30 - 8;
            do
            {
              if (*v31 != v25)
              {
                *(void *)long long v27 = *v31;
                v27 += 8;
              }
              ++v31;
              v32 -= 8;
            }
            while (v32);
            uint64_t v8 = *(char **)a1;
          }
        }
        unint64_t v33 = v27 - v8;
        uint64_t v22 = (v33 >> 3);
        ++v23;
      }
      while (v23 != v24);
      unint64_t v16 = v33 >> 3;
      *(_DWORD *)(a1 + 8) = v22;
    }
    uint64_t v34 = (uint64_t *)*((void *)result + 5);
    int64x2_t v35 = &v34[*((unsigned int *)result + 12)];
    return sub_1CD4D069C((unsigned int *)a1, (uint64_t)&v8[8 * v16], v34, v35);
  }
  return result;
}

uint64_t sub_1CD544C70(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 24)) {
    return sub_1CD46A1B4(result, a2);
  }
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)uint64_t result = *(void *)a2;
  *(void *)a2 = 0;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = 0;
  int v2 = *(_DWORD *)(result + 12);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v2;
  int v3 = *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v3;
  *(unsigned char *)(result + 24) = 1;
  return result;
}

uint64_t *sub_1CD544CDC(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v11 = result;
  while (2)
  {
    BOOL v12 = a2 - 1;
LABEL_3:
    for (uint64_t i = 1 - a4; ; ++i)
    {
      uint64_t v14 = (char *)a2 - (char *)v11;
      unint64_t v15 = a2 - v11;
      if (!(!v6 & v5))
      {
        switch(v15)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t result = (uint64_t *)sub_1CD518604(a3, *v12, *v11);
            if (result)
            {
              uint64_t v23 = *v11;
              *uint64_t v11 = *v12;
              *BOOL v12 = v23;
            }
            break;
          case 3uLL:
            uint64_t result = (uint64_t *)sub_1CC389174(v11, v11 + 1, a2 - 1, a3);
            break;
          case 4uLL:
            uint64_t result = (uint64_t *)sub_1CC389428(v11, v11 + 1, v11 + 2, a2 - 1, a3);
            break;
          case 5uLL:
            uint64_t result = (uint64_t *)sub_1CC3894E0(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v14 <= 191)
      {
        if (a5)
        {
          return sub_1CC2DDE90(v11, a2, a3);
        }
        else
        {
          return sub_1CC2DDF58(v11, a2, a3);
        }
      }
      if (i == 1)
      {
        if (v11 != a2)
        {
          return sub_1CC3895C0(v11, a2, a2, a3);
        }
        return result;
      }
      unint64_t v16 = v15 >> 1;
      long long v17 = &v11[v15 >> 1];
      if ((unint64_t)v14 >= 0x401)
      {
        sub_1CC389174(v11, &v11[v15 >> 1], a2 - 1, a3);
        sub_1CC389174(v11 + 1, v17 - 1, a2 - 2, a3);
        sub_1CC389174(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
        sub_1CC389174(v17 - 1, v17, &v11[v16 + 1], a3);
        uint64_t v18 = *v11;
        *uint64_t v11 = *v17;
        uint64_t *v17 = v18;
      }
      else
      {
        sub_1CC389174(&v11[v15 >> 1], v11, a2 - 1, a3);
      }
      if ((a5 & 1) == 0 && !sub_1CD518604(a3, *(v11 - 1), *v11))
      {
        uint64_t result = sub_1CC2DE0E4(v11, a2, a3);
        uint64_t v22 = result;
        goto LABEL_15;
      }
      unsigned int v19 = sub_1CC2DE1F4(v11, a2, a3);
      if ((v20 & 1) == 0) {
        goto LABEL_42;
      }
      BOOL v21 = sub_1CC38925C(v11, v19, a3);
      uint64_t v22 = v19 + 1;
      uint64_t result = (uint64_t *)sub_1CC38925C(v19 + 1, a2, a3);
      if (result) {
        break;
      }
      if (!v21)
      {
LABEL_42:
        a4 = -i;
        uint64_t result = (uint64_t *)sub_1CD544CDC(v11, v19, a3, -i, a5 & 1);
        a5 = 0;
        uint64_t v11 = v19 + 1;
        goto LABEL_3;
      }
LABEL_15:
      uint64_t v11 = v22;
    }
    a4 = -i;
    a2 = v19;
    if (!v21) {
      continue;
    }
    return result;
  }
}

void sub_1CD54508C(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CC3876D0((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      char v5 = *(void **)a1;
      uint64_t v6 = 72 * v4;
      do
      {
        void *v5 = -4096;
        v5 += 9;
        v6 -= 72;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC13D214(a1, v4);
  }
}

BOOL sub_1CD545140(uint64_t a1)
{
  v33[4] = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 80)) {
    BOOL v1 = 1;
  }
  else {
    BOOL v1 = *(_DWORD *)(a1 + 8) == 0;
  }
  if (v1)
  {
    sub_1CC38781C((uint64_t)&v31, a1, 0);
    BOOL v9 = sub_1CD52E948(*(uint64_t **)a1, *(_DWORD *)(a1 + 8), (uint64_t)&v31);
    BOOL v6 = v9;
    if (!v9)
    {
      uint64_t v10 = (llvm::raw_ostream *)llvm::errs((llvm *)v9);
      uint64_t v11 = sub_1CB8E509C(v10, "Tree has different roots than freshly computed ones!\n");
      BOOL v12 = (llvm::raw_ostream *)llvm::errs(v11);
      unsigned int v13 = sub_1CB8E509C(v12, "\tPDT roots: ");
      uint64_t v14 = *(unsigned int *)(a1 + 8);
      if (v14)
      {
        unint64_t v15 = *(uint64_t **)a1;
        uint64_t v16 = 8 * v14;
        do
        {
          long long v17 = (llvm::MachineBasicBlock *)*v15;
          uint64_t v18 = (llvm::raw_ostream *)llvm::errs(v13);
          unsigned int v19 = v18;
          if (v17) {
            llvm::MachineBasicBlock::printAsOperand(v17, v18);
          }
          else {
            sub_1CB8E509C(v18, "nullptr");
          }
          unsigned int v13 = sub_1CB8E509C(v19, ", ");
          ++v15;
          v16 -= 8;
        }
        while (v16);
      }
      char v20 = (llvm::raw_ostream *)llvm::errs(v13);
      BOOL v21 = sub_1CB8E509C(v20, "\n\tComputed roots: ");
      if (v32)
      {
        uint64_t v22 = (llvm::MachineBasicBlock **)v31;
        uint64_t v23 = 8 * v32;
        do
        {
          uint64_t v24 = *v22;
          uint64_t v25 = (llvm::raw_ostream *)llvm::errs(v21);
          uint64_t v26 = v25;
          if (v24) {
            llvm::MachineBasicBlock::printAsOperand(v24, v25);
          }
          else {
            sub_1CB8E509C(v25, "nullptr");
          }
          BOOL v21 = sub_1CB8E509C(v26, ", ");
          ++v22;
          v23 -= 8;
        }
        while (v23);
      }
      long long v27 = (llvm::raw_ostream *)llvm::errs(v21);
      long long v28 = sub_1CB8E509C(v27, "\n");
      uint64_t v29 = (llvm::raw_ostream *)llvm::errs(v28);
      uint64_t v30 = (const char *)*((void *)v29 + 2);
      if (*((const char **)v29 + 4) != v30)
      {
        *((void *)v29 + 4) = v30;
        llvm::raw_ostream::flush_tied_then_write(v29, v30);
      }
    }
    if (v31 != v33) {
      free(v31);
    }
  }
  else
  {
    int v2 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
    int v3 = sub_1CB8E509C(v2, "Tree has no parent but has roots!\n");
    uint64_t v4 = (llvm::raw_ostream *)llvm::errs(v3);
    char v5 = (const char *)*((void *)v4 + 2);
    if (*((const char **)v4 + 4) != v5)
    {
      *((void *)v4 + 4) = v5;
      llvm::raw_ostream::flush_tied_then_write(v4, v5);
    }
    return 0;
  }
  return v6;
}

uint64_t sub_1CD545370(uint64_t a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t __src = 0;
  sub_1CBFAFDE4((void *)a1, (char *)&__src, (char *)&v28, 1uLL);
  sub_1CC3897DC((_DWORD *)(a1 + 24));
  sub_1CC3898B0((char **)a1, a2);
  uint64_t v4 = *(void *)(a2 + 48);
  uint64_t v5 = *(unsigned int *)(a2 + 64);
  BOOL v6 = (void *)(v4 + 16 * v5);
  if (*(_DWORD *)(a2 + 56))
  {
    if (v5)
    {
      uint64_t v7 = 16 * v5;
      uint64_t v8 = *(void **)(a2 + 48);
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        v7 -= 16;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v8 = *(void **)(a2 + 48);
    }
  }
  else
  {
LABEL_6:
    uint64_t v8 = (void *)(v4 + 16 * v5);
  }
  BOOL v9 = (void *)(v4 + 16 * v5);
LABEL_8:
  while (v8 != v9)
  {
    uint64_t v10 = (uint64_t *)v8[1];
    uint64_t v11 = (llvm::MachineBasicBlock *)*v10;
    if (*v10)
    {
      uint64_t v12 = sub_1CC386F74(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), *v10, &__src);
      if ((v12 & 1) == 0)
      {
        uint64_t v25 = (llvm::raw_ostream *)llvm::errs((llvm *)v12);
        char v20 = sub_1CB8E509C(v25, "DomTree node ");
        llvm::MachineBasicBlock::printAsOperand(v11, v20);
        BOOL v21 = " not found by DFS walk!\n";
        goto LABEL_25;
      }
    }
    unsigned int v13 = v8 + 2;
    uint64_t v8 = v6;
    if (v13 != v6)
    {
      uint64_t v8 = v13;
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        if (v8 == v6)
        {
          uint64_t v8 = v6;
          goto LABEL_8;
        }
      }
    }
  }
  uint64_t v14 = *(llvm::MachineBasicBlock ***)a1;
  unint64_t v15 = *(llvm::MachineBasicBlock ***)(a1 + 8);
  while (1)
  {
    if (v14 == v15) {
      return 1;
    }
    uint64_t v16 = *v14;
    if (*v14)
    {
      uint64_t v26 = 0;
      uint64_t __src = v16;
      long long v17 = (llvm *)sub_1CBFA3AF4((uint64_t *)(a2 + 48), &__src, &v26);
      if (!v17 || v26 == *(void *)(a2 + 48) + 16 * *(unsigned int *)(a2 + 64) || !*(void *)(v26 + 8)) {
        break;
      }
    }
    ++v14;
  }
  unsigned int v19 = (llvm::raw_ostream *)llvm::errs(v17);
  char v20 = sub_1CB8E509C(v19, "CFG node ");
  llvm::MachineBasicBlock::printAsOperand(v16, v20);
  BOOL v21 = " not found in the DomTree!\n";
LABEL_25:
  uint64_t v22 = sub_1CB8E509C(v20, v21);
  uint64_t v23 = (llvm::raw_ostream *)llvm::errs(v22);
  uint64_t v24 = (const char *)*((void *)v23 + 2);
  if (*((const char **)v23 + 4) != v24)
  {
    *((void *)v23 + 4) = v24;
    llvm::raw_ostream::flush_tied_then_write(v23, v24);
  }
  return 0;
}

uint64_t sub_1CD5455A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  uint64_t v2 = *(unsigned int *)(a1 + 64);
  int v3 = (void *)(v1 + 16 * v2);
  if (*(_DWORD *)(a1 + 56))
  {
    if (v2)
    {
      uint64_t v4 = 16 * v2;
      uint64_t v5 = *(void **)(a1 + 48);
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v5 += 2;
        v4 -= 16;
        if (!v4) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v5 = *(void **)(a1 + 48);
    }
  }
  else
  {
LABEL_6:
    uint64_t v5 = (void *)(v1 + 16 * v2);
  }
  BOOL v6 = (void *)(v1 + 16 * v2);
  while (1)
  {
LABEL_8:
    if (v5 == v6) {
      return 1;
    }
    uint64_t v7 = v5[1];
    uint64_t v8 = *(llvm::MachineBasicBlock **)v7;
    if (!*(void *)v7) {
      goto LABEL_12;
    }
    uint64_t v9 = *(void *)(v7 + 8);
    int v10 = *(_DWORD *)(v7 + 16);
    if (v9) {
      break;
    }
    if (v10)
    {
      uint64_t v12 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
      unsigned int v13 = sub_1CB8E509C(v12, "Node without an IDom ");
      llvm::MachineBasicBlock::printAsOperand(v8, v13);
      uint64_t v14 = sub_1CB8E509C(v13, " has a nonzero level ");
      unint64_t v15 = *(unsigned int *)(v7 + 16);
      goto LABEL_24;
    }
LABEL_12:
    uint64_t v11 = v5 + 2;
    uint64_t v5 = v3;
    if (v11 != v3)
    {
      uint64_t v5 = v11;
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v5 += 2;
        if (v5 == v3)
        {
          uint64_t v5 = v3;
          goto LABEL_8;
        }
      }
    }
  }
  if (v10 == *(_DWORD *)(v9 + 16) + 1) {
    goto LABEL_12;
  }
  long long v17 = (llvm::raw_ostream *)llvm::errs((llvm *)a1);
  uint64_t v18 = sub_1CB8E509C(v17, "Node ");
  llvm::MachineBasicBlock::printAsOperand(v8, v18);
  unsigned int v19 = sub_1CB8E509C(v18, " has level ");
  char v20 = llvm::raw_ostream::operator<<(v19, *(unsigned int *)(v7 + 16));
  BOOL v21 = sub_1CB8E509C(v20, " while its IDom ");
  if (*(void *)v9) {
    llvm::MachineBasicBlock::printAsOperand(*(llvm::MachineBasicBlock **)v9, v21);
  }
  else {
    sub_1CB8E509C(v21, "nullptr");
  }
  uint64_t v14 = sub_1CB8E509C(v21, " has level ");
  unint64_t v15 = *(unsigned int *)(v9 + 16);
LABEL_24:
  uint64_t v22 = llvm::raw_ostream::operator<<(v14, v15);
  uint64_t v23 = sub_1CB8E509C(v22, "!\n");
  uint64_t v24 = (llvm::raw_ostream *)llvm::errs(v23);
  uint64_t v25 = (const char *)*((void *)v24 + 2);
  if (*((const char **)v24 + 4) != v25)
  {
    *((void *)v24 + 4) = v25;
    llvm::raw_ostream::flush_tied_then_write(v24, v25);
  }
  return 0;
}

uint64_t sub_1CD545780(uint64_t a1)
{
  v33[8] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 88)) {
    BOOL v1 = *(void *)(a1 + 80) == 0;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 1;
  }
  long long v31 = 0;
  v30[0] = 0;
  uint64_t result = sub_1CBFA3AF4((uint64_t *)(a1 + 48), &v31, v30);
  uint64_t v4 = (void *)v30[0];
  uint64_t v5 = *(void **)(a1 + 48);
  uint64_t v6 = *(unsigned int *)(a1 + 64);
  uint64_t v7 = &v5[2 * v6];
  if (!result) {
    uint64_t v4 = &v5[2 * v6];
  }
  uint64_t v8 = (unsigned int *)v4[1];
  if (!v8[18])
  {
    if (!*(_DWORD *)(a1 + 56)) {
      return 1;
    }
    if (v6)
    {
      uint64_t v9 = 16 * v6;
      while ((*v5 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v5 += 2;
        v9 -= 16;
        if (!v9) {
          return 1;
        }
      }
    }
    if (v5 == v7) {
      return 1;
    }
LABEL_17:
    uint64_t v10 = v5[1];
    uint64_t v11 = *(unsigned int *)(v10 + 32);
    if (!v11)
    {
      if (*(_DWORD *)(v10 + 72) + 1 == *(_DWORD *)(v10 + 76)) {
        goto LABEL_19;
      }
      uint64_t v29 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
      sub_1CB8E509C(v29, "Tree leaf should have DFSOut = DFSIn + 1:\n\t");
      unsigned int v19 = (unsigned int *)v10;
      goto LABEL_27;
    }
    uint64_t v25 = *(unsigned char **)(v10 + 24);
    long long v31 = v33;
    uint64_t v32 = 0x800000000;
    sub_1CB935BDC((unsigned int *)&v31, v25, &v25[8 * v11]);
    unint64_t v26 = 126 - 2 * __clz(v32);
    if (v32) {
      uint64_t v27 = v26;
    }
    else {
      uint64_t v27 = 0;
    }
    sub_1CD545EE8((uint64_t *)v31, (uint64_t *)v31 + v32, v27, 1);
    v30[0] = v10;
    v30[1] = &v31;
    uint64_t v14 = *(unsigned int **)v31;
    if (*(_DWORD *)(*(void *)v31 + 72) == *(_DWORD *)(v10 + 72) + 1)
    {
      uint64_t v12 = (unsigned int *)*((void *)v31 + v32 - 1);
      if (v12[19] + 1 == *(_DWORD *)(v10 + 76))
      {
        uint64_t v17 = v32 - 1;
        unint64_t v15 = (unsigned int **)((char *)v31 + 8);
        while (v17)
        {
          uint64_t v12 = v14;
          int v13 = v14[19] + 1;
          uint64_t v16 = *v15++;
          uint64_t v14 = v16;
          --v17;
          if (v13 != v16[18]) {
            goto LABEL_46;
          }
        }
        int v28 = 1;
LABEL_40:
        if (v31 != v33) {
          free(v31);
        }
        if (!v28) {
          return 0;
        }
LABEL_19:
        while (1)
        {
          v5 += 2;
          if (v5 == v7) {
            return 1;
          }
          if ((*v5 | 0x1000) != 0xFFFFFFFFFFFFF000)
          {
            uint64_t result = 1;
            if (v5 != v7) {
              goto LABEL_17;
            }
            return result;
          }
        }
      }
    }
    else
    {
      uint64_t v12 = *(unsigned int **)v31;
    }
    uint64_t v14 = 0;
LABEL_46:
    sub_1CD52EAD0((llvm *)v30, v12, v14);
    int v28 = 0;
    goto LABEL_40;
  }
  uint64_t v18 = (llvm::raw_ostream *)llvm::errs((llvm *)result);
  sub_1CB8E509C(v18, "DFSIn number for the tree root is not:\n\t");
  unsigned int v19 = v8;
LABEL_27:
  char v20 = sub_1CD52EA14(v19);
  BOOL v21 = (llvm::raw_ostream *)llvm::errs(v20);
  uint64_t v22 = (unsigned char *)*((void *)v21 + 4);
  if ((unint64_t)v22 >= *((void *)v21 + 3))
  {
    BOOL v21 = llvm::raw_ostream::write(v21, 10);
  }
  else
  {
    *((void *)v21 + 4) = v22 + 1;
    *uint64_t v22 = 10;
  }
  uint64_t v23 = (llvm::raw_ostream *)llvm::errs(v21);
  uint64_t v24 = (const char *)*((void *)v23 + 2);
  if (*((const char **)v23 + 4) != v24)
  {
    *((void *)v23 + 4) = v24;
    llvm::raw_ostream::flush_tied_then_write(v23, v24);
  }
  return 0;
}

uint64_t sub_1CD545A48(uint64_t a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 48);
  uint64_t v5 = *(unsigned int *)(a2 + 64);
  uint64_t v6 = (void *)(v4 + 16 * v5);
  if (*(_DWORD *)(a2 + 56))
  {
    if (v5)
    {
      uint64_t v7 = 16 * v5;
      uint64_t v8 = *(void **)(a2 + 48);
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        v7 -= 16;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v8 = *(void **)(a2 + 48);
    }
  }
  else
  {
LABEL_6:
    uint64_t v8 = (void *)(v4 + 16 * v5);
  }
  uint64_t v9 = (void *)(v4 + 16 * v5);
  if (v8 == v9) {
    return 1;
  }
  while (1)
  {
    uint64_t v10 = v8[1];
    uint64_t v11 = *(llvm::MachineBasicBlock **)v10;
    if (*(void *)v10)
    {
      if (*(_DWORD *)(v10 + 32))
      {
        uint64_t v25 = 0;
        sub_1CBFAFDE4((void *)a1, (char *)&v25, (char *)&v26, 1uLL);
        sub_1CC3897DC((_DWORD *)(a1 + 24));
        sub_1CD5462BC((char **)a1, a2, (uint64_t)v11);
        uint64_t v13 = *(unsigned int *)(v10 + 32);
        if (v13) {
          break;
        }
      }
    }
LABEL_10:
    uint64_t v12 = v8 + 2;
    uint64_t v8 = v6;
    if (v12 != v6)
    {
      uint64_t v8 = v12;
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        if (v8 == v6)
        {
          uint64_t v8 = v6;
          break;
        }
      }
    }
    if (v8 == v9) {
      return 1;
    }
  }
  uint64_t v14 = *(uint64_t ***)(v10 + 24);
  uint64_t v15 = 8 * v13;
  while (1)
  {
    uint64_t v16 = *v14;
    uint64_t v17 = (llvm *)sub_1CC386F74(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), **v14, &v25);
    if (v17) {
      break;
    }
    ++v14;
    v15 -= 8;
    if (!v15) {
      goto LABEL_10;
    }
  }
  unsigned int v19 = (llvm::raw_ostream *)llvm::errs(v17);
  char v20 = sub_1CB8E509C(v19, "Child ");
  if (*v16) {
    llvm::MachineBasicBlock::printAsOperand((llvm::MachineBasicBlock *)*v16, v20);
  }
  else {
    sub_1CB8E509C(v20, "nullptr");
  }
  BOOL v21 = sub_1CB8E509C(v20, " reachable after its parent ");
  llvm::MachineBasicBlock::printAsOperand(v11, v21);
  uint64_t v22 = sub_1CB8E509C(v21, " is removed!\n");
  uint64_t v23 = (llvm::raw_ostream *)llvm::errs(v22);
  uint64_t v24 = (const char *)*((void *)v23 + 2);
  if (*((const char **)v23 + 4) != v24)
  {
    *((void *)v23 + 4) = v24;
    llvm::raw_ostream::flush_tied_then_write(v23, v24);
  }
  return 0;
}

uint64_t sub_1CD545C74(uint64_t a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 48);
  uint64_t v5 = *(unsigned int *)(a2 + 64);
  uint64_t v6 = (void *)(v4 + 16 * v5);
  if (*(_DWORD *)(a2 + 56))
  {
    if (v5)
    {
      uint64_t v7 = 16 * v5;
      uint64_t v8 = *(void **)(a2 + 48);
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        v7 -= 16;
        if (!v7) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v8 = *(void **)(a2 + 48);
    }
  }
  else
  {
LABEL_6:
    uint64_t v8 = (void *)(v4 + 16 * v5);
  }
  int v28 = (void *)(v4 + 16 * v5);
  if (v8 == v28) {
    return 1;
  }
  uint64_t v27 = (_DWORD *)(a1 + 24);
  while (1)
  {
    uint64_t v9 = v8[1];
    if (*(void *)v9)
    {
      uint64_t v10 = *(unsigned int *)(v9 + 32);
      if (v10) {
        break;
      }
    }
LABEL_18:
    uint64_t v18 = v8 + 2;
    uint64_t v8 = v6;
    if (v18 != v6)
    {
      uint64_t v8 = v18;
      while ((*v8 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v8 += 2;
        if (v8 == v6)
        {
          uint64_t v8 = v6;
          break;
        }
      }
    }
    if (v8 == v28) {
      return 1;
    }
  }
  uint64_t v11 = *(uint64_t ***)(v9 + 24);
  uint64_t v26 = &v11[v10];
  while (1)
  {
    uint64_t v12 = *v11;
    uint64_t __src = 0;
    sub_1CBFAFDE4((void *)a1, (char *)&__src, (char *)&v30, 1uLL);
    sub_1CC3897DC(v27);
    sub_1CD5462BC((char **)a1, a2, *v12);
    uint64_t v13 = *(unsigned int *)(v9 + 32);
    if (v13) {
      break;
    }
LABEL_17:
    if (++v11 == v26) {
      goto LABEL_18;
    }
  }
  uint64_t v14 = *(uint64_t ***)(v9 + 24);
  uint64_t v15 = 8 * v13;
  while (1)
  {
    uint64_t v16 = *v14;
    if (*v14 != v12)
    {
      uint64_t v17 = sub_1CC386F74(*(void *)(a1 + 24), *(_DWORD *)(a1 + 40), *v16, &__src);
      if ((v17 & 1) == 0) {
        break;
      }
    }
    ++v14;
    v15 -= 8;
    if (!v15) {
      goto LABEL_17;
    }
  }
  char v20 = (llvm::raw_ostream *)llvm::errs((llvm *)v17);
  BOOL v21 = sub_1CB8E509C(v20, "Node ");
  if (*v16) {
    llvm::MachineBasicBlock::printAsOperand((llvm::MachineBasicBlock *)*v16, v21);
  }
  else {
    sub_1CB8E509C(v21, "nullptr");
  }
  uint64_t v22 = sub_1CB8E509C(v21, " not reachable when its sibling ");
  if (*v12) {
    llvm::MachineBasicBlock::printAsOperand((llvm::MachineBasicBlock *)*v12, v22);
  }
  else {
    sub_1CB8E509C(v22, "nullptr");
  }
  uint64_t v23 = sub_1CB8E509C(v22, " is removed!\n");
  uint64_t v24 = (llvm::raw_ostream *)llvm::errs(v23);
  uint64_t v25 = (const char *)*((void *)v24 + 2);
  if (*((const char **)v24 + 4) != v25)
  {
    *((void *)v24 + 4) = v25;
    llvm::raw_ostream::flush_tied_then_write(v24, v25);
  }
  return 0;
}

uint64_t *sub_1CD545EE8(uint64_t *result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = result;
  while (2)
  {
    uint64_t v10 = a2 - 1;
LABEL_3:
    for (uint64_t i = 1 - a3; ; ++i)
    {
      uint64_t v12 = (char *)a2 - (char *)v9;
      unint64_t v13 = a2 - v9;
      if (!(!v5 & v4))
      {
        switch(v13)
        {
          case 0uLL:
          case 1uLL:
            return result;
          case 2uLL:
            uint64_t v21 = *v9;
            if (*(_DWORD *)(*v10 + 72) < *(_DWORD *)(*v9 + 72))
            {
              uint64_t *v9 = *v10;
              *uint64_t v10 = v21;
            }
            break;
          case 3uLL:
            uint64_t result = sub_1CC3463C4(v9, v9 + 1, a2 - 1);
            break;
          case 4uLL:
            uint64_t result = sub_1CC346778(v9, v9 + 1, v9 + 2, a2 - 1);
            break;
          case 5uLL:
            uint64_t result = sub_1CC346810(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
            break;
          default:
            JUMPOUT(0);
        }
        return result;
      }
      if (v12 <= 191)
      {
        uint64_t v22 = v9 + 1;
        BOOL v24 = v9 == a2 || v22 == a2;
        if (a4)
        {
          if (!v24)
          {
            uint64_t v25 = 8;
            uint64_t v26 = v9;
            do
            {
              uint64_t v28 = *v26;
              uint64_t v27 = v26[1];
              uint64_t v26 = v22;
              unsigned int v29 = *(_DWORD *)(v27 + 72);
              if (v29 < *(_DWORD *)(v28 + 72))
              {
                uint64_t v30 = v25;
                do
                {
                  *(uint64_t *)((char *)v9 + v30) = v28;
                  uint64_t v31 = v30 - 8;
                  if (v30 == 8)
                  {
                    uint64_t v32 = v9;
                    goto LABEL_46;
                  }
                  uint64_t v28 = *(uint64_t *)((char *)v9 + v30 - 16);
                  v30 -= 8;
                }
                while (v29 < *(_DWORD *)(v28 + 72));
                uint64_t v32 = (uint64_t *)((char *)v9 + v31);
LABEL_46:
                *uint64_t v32 = v27;
              }
              uint64_t v22 = v26 + 1;
              v25 += 8;
            }
            while (v26 + 1 != a2);
          }
        }
        else if (!v24)
        {
          do
          {
            uint64_t v34 = *v9;
            uint64_t v33 = v9[1];
            uint64_t v9 = v22;
            unsigned int v35 = *(_DWORD *)(v33 + 72);
            if (v35 < *(_DWORD *)(v34 + 72))
            {
              do
              {
                *uint64_t v22 = v34;
                uint64_t v34 = *(v22 - 2);
                --v22;
              }
              while (v35 < *(_DWORD *)(v34 + 72));
              *uint64_t v22 = v33;
            }
            uint64_t v22 = v9 + 1;
          }
          while (v9 + 1 != a2);
        }
        return result;
      }
      if (i == 1)
      {
        if (v9 != a2)
        {
          return (uint64_t *)sub_1CC3468D4((uint64_t)v9, a2, a2);
        }
        return result;
      }
      unint64_t v14 = v13 >> 1;
      uint64_t v15 = &v9[v13 >> 1];
      if ((unint64_t)v12 >= 0x401)
      {
        sub_1CC3463C4(v9, &v9[v13 >> 1], a2 - 1);
        sub_1CC3463C4(v9 + 1, v15 - 1, a2 - 2);
        sub_1CC3463C4(v9 + 2, &v9[v14 + 1], a2 - 3);
        sub_1CC3463C4(v15 - 1, v15, &v9[v14 + 1]);
        uint64_t v16 = *v9;
        uint64_t *v9 = *v15;
        *uint64_t v15 = v16;
      }
      else
      {
        sub_1CC3463C4(&v9[v13 >> 1], v9, a2 - 1);
      }
      if ((a4 & 1) == 0 && *(_DWORD *)(*(v9 - 1) + 72) >= *(_DWORD *)(*v9 + 72))
      {
        uint64_t result = sub_1CC34644C(v9, a2);
        char v20 = result;
        goto LABEL_16;
      }
      uint64_t v17 = sub_1CC346518(v9, a2);
      if ((v18 & 1) == 0) {
        goto LABEL_61;
      }
      BOOL v19 = sub_1CC389B60(v9, v17);
      char v20 = v17 + 1;
      uint64_t result = (uint64_t *)sub_1CC389B60(v17 + 1, a2);
      if (result) {
        break;
      }
      if (!v19)
      {
LABEL_61:
        a3 = -i;
        uint64_t result = (uint64_t *)sub_1CD545EE8(v9, v17, -i, a4 & 1);
        a4 = 0;
        uint64_t v9 = v17 + 1;
        goto LABEL_3;
      }
LABEL_16:
      uint64_t v9 = v20;
    }
    a3 = -i;
    a2 = v17;
    if (!v19) {
      continue;
    }
    return result;
  }
}

void sub_1CD5462BC(char **a1, uint64_t a2, uint64_t a3)
{
  sub_1CC387D6C(a1);
  uint64_t v6 = *(unsigned int *)(a2 + 8);
  if (v6)
  {
    uint64_t v7 = *(uint64_t **)a2;
    uint64_t v8 = 8 * v6;
    unsigned int v9 = 1;
    do
    {
      uint64_t v10 = *v7++;
      unsigned int v9 = sub_1CC389CF4((uint64_t)a1, v10, v9, a3);
      v8 -= 8;
    }
    while (v8);
  }
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyBBInRegion()
{
}

{
  while (1)
    ;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_1CBB36158(*(void *)(a1 + 24), a2);
  if (result)
  {
    if (*(void *)(a1 + 32))
    {
      llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 24));
      llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
    }
    return 1;
  }
  return result;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyWalk(uint64_t a1, uint64_t *a2, uint64_t **a3)
{
  int v3 = a2;
  sub_1CD3CFB98(a3, (unint64_t *)&v3, &v3);
  llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyBBInRegion();
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegionNest(uint64_t a1)
{
  BOOL v1 = *(uint64_t **)(a1 + 40);
  uint64_t v2 = *(uint64_t **)(a1 + 48);
  while (v1 != v2)
  {
    uint64_t v3 = *v1++;
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegionNest(v3);
  }

  llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegion();
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegion()
{
  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::VerifyRegionInfo)
  {
    v1[0] = 0;
    v1[1] = 0;
    uint64_t v0 = v1;
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyWalk();
  }
}

{
  while (1)
    ;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getEnteringBlock(void *a1)
{
  unint64_t v1 = *a1 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v2 = *(uint64_t **)(v1 + 64);
  for (uint64_t i = *(uint64_t **)(v1 + 72); v2 != i; ++v2)
  {
    if (sub_1CBB36158(a1[3], *v2)) {
      llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains();
    }
  }
  return 0;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::isSimple(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getEnteringBlock();
  }
  return 0;
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getNameStr(uint64_t *a1@<X0>, std::string *a2@<X8>)
{
  memset(&v28, 0, sizeof(v28));
  memset(&__p, 0, sizeof(__p));
  char v4 = (llvm::Value **)(*a1 & 0xFFFFFFFFFFFFFFF8);
  if (!v4[2]) {
    goto LABEL_9;
  }
  llvm::Value::getName(v4[2]);
  uint64_t v5 = *a1;
  if (!v6)
  {
    char v4 = (llvm::Value **)(v5 & 0xFFFFFFFFFFFFFFF8);
LABEL_9:
    LODWORD(v20.__r_.__value_.__r.__words[1]) = 0;
    char v23 = 0;
    uint64_t v24 = 0;
    p_p = &__p;
    int v25 = 0;
    v20.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
    v20.__r_.__value_.__r.__words[2] = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    llvm::MachineBasicBlock::printAsOperand((llvm::MachineBasicBlock *)v4, (llvm::raw_ostream *)&v20);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v20);
    goto LABEL_10;
  }
  uint64_t v7 = *(llvm::Value **)((v5 & 0xFFFFFFFFFFFFFFF8) + 16);
  if (v7)
  {
    uint64_t Name = llvm::Value::getName(v7);
    std::string::size_type v10 = v9;
  }
  else
  {
    std::string::size_type v10 = 0;
    uint64_t Name = (char *)&unk_1CFB6806A;
  }
  std::string::__init(&v20, Name, v10);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  std::string __p = v20;
LABEL_10:
  uint64_t v11 = (llvm::Value **)a1[4];
  if (v11)
  {
    if (v11[2] && (llvm::Value::getName(v11[2]), uint64_t v11 = (llvm::Value **)a1[4], v12))
    {
      unint64_t v13 = v11[2];
      if (v13)
      {
        unint64_t v14 = llvm::Value::getName(v13);
        std::string::size_type v16 = v15;
      }
      else
      {
        std::string::size_type v16 = 0;
        unint64_t v14 = (char *)&unk_1CFB6806A;
      }
      std::string::__init(&v20, v14, v16);
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
      std::string v28 = v20;
    }
    else
    {
      LODWORD(v20.__r_.__value_.__r.__words[1]) = 0;
      char v23 = 0;
      uint64_t v24 = 0;
      p_p = &v28;
      int v25 = 0;
      v20.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2646F30;
      v20.__r_.__value_.__r.__words[2] = 0;
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      llvm::MachineBasicBlock::printAsOperand((llvm::MachineBasicBlock *)v11, (llvm::raw_ostream *)&v20);
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v20);
    }
  }
  else
  {
    MEMORY[0x1D25D9630](&v28, "<Function Return>");
  }
  sub_1CBAD7600(" => ", (const void **)&__p.__r_.__value_.__l.__data_, (void **)&v20.__r_.__value_.__l.__data_);
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v17 = &v28;
  }
  else {
    uint64_t v17 = (std::string *)v28.__r_.__value_.__r.__words[0];
  }
  if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = *((unsigned char *)&v28.__r_.__value_.__s + 23) & 0x7F;
  }
  else {
    std::string::size_type size = v28.__r_.__value_.__l.__size_;
  }
  BOOL v19 = std::string::append(&v20, (const std::string::value_type *)v17, size);
  *a2 = *v19;
  v19->__r_.__value_.__r.__words[0] = 0;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v20.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v28.__r_.__value_.__l.__data_);
  }
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::blocks(void *a1@<X0>, void *a2@<X8>)
{
  sub_1CD54818C((uint64_t)&v11, *a1 & 0xFFFFFFFFFFFFFFF8, a1[4]);
  uint64_t v3 = v7;
  char v4 = v7;
  uint64_t v5 = 8;
  int v6 = 0;
  std::string::size_type v9 = 0;
  uint64_t v10 = 0;
  std::string __p = 0;
  sub_1CD473714(a2, (uint64_t)&v11, (uint64_t)&v3);
  if (__p)
  {
    std::string::size_type v9 = __p;
    operator delete(__p);
  }
  if (v4 != v3) {
    free(v4);
  }
  if (v13)
  {
    unint64_t v14 = v13;
    operator delete(v13);
  }
  if (v12 != v11) {
    free(v12);
  }
}

void llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::elements()
{
}

{
  sub_1CD546F04();
}

{
  while (1)
    ;
}

{
  while (1)
    ;
}

llvm::raw_ostream *sub_1CD546B70(llvm::raw_ostream *a1, void *a2)
{
  if ((*a2 & 4) != 0) {
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getNameStr();
  }
  uint64_t v3 = *(llvm::Value **)((*a2 & 0xFFFFFFFFFFFFFFF8) + 16);
  if (v3)
  {
    uint64_t Name = llvm::Value::getName(v3);
    size_t v6 = v4;
    uint64_t v7 = (void *)*((void *)a1 + 4);
    if (v4 <= *((void *)a1 + 3) - (void)v7)
    {
      if (v4)
      {
        memcpy(v7, Name, v4);
        *((void *)a1 + 4) += v6;
      }
    }
    else
    {
      llvm::raw_ostream::write(a1, Name, v4);
    }
  }
  return a1;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains();
  }
  return 1;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getSubRegionNode(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v7 = 0;
  if (sub_1CD40EA84(*(void *)(v3 + 40), *(_DWORD *)(v3 + 56), a2, &v7))
  {
    uint64_t v4 = *(void *)(v7 + 8);
    if (v4) {
      BOOL v5 = v4 == a1;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5) {
      llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::contains();
    }
  }
  return 0;
}

uint64_t llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::getBBNode(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (!v2) {
    goto LABEL_13;
  }
  uint64_t v3 = (void *)(a1 + 72);
  do
  {
    unint64_t v4 = v2[4];
    BOOL v5 = v4 >= a2;
    if (v4 >= a2) {
      size_t v6 = v2;
    }
    else {
      size_t v6 = v2 + 1;
    }
    if (v5) {
      uint64_t v3 = v2;
    }
    uint64_t v2 = (void *)*v6;
  }
  while (*v6);
  if (v3 == (void *)(a1 + 72) || v3[4] > a2) {
LABEL_13:
  }
    operator new();
  return v3[5];
}

void sub_1CD546F04()
{
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::~RegionInfoBase(void *a1)
{
  *a1 = &unk_1F260F120;
  llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::releaseMemory();
}

_DWORD *llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::releaseMemory(uint64_t a1)
{
  uint64_t result = sub_1CD3C7F68((_DWORD *)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    sub_1CD4B9F64(*(void **)(v3 + 72));
    *(void *)(v3 + 64) = v3 + 72;
    *(void *)(v3 + 80) = 0;
    *(void *)(v3 + 72) = 0;
    unint64_t v4 = (void **)(v3 + 40);
    sub_1CC0D3220(&v4);
    uint64_t result = (_DWORD *)MEMORY[0x1D25D9CE0](v3, 0x1020C406A19994FLL);
  }
  *(void *)(a1 + 32) = 0;
  return result;
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::isCommonDomFrontier(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 64) != *(void *)(a2 + 72))
  {
    llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 8));
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
  }
  return 1;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::isRegion(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 24) + 256);
  if (v2)
  {
    do
    {
      if (v2[4] >= a2) {
        uint64_t v3 = v2;
      }
      else {
        uint64_t v3 = v2 + 1;
      }
      uint64_t v2 = (void *)*v3;
    }
    while (*v3);
  }
  llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 8));
  llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::dominates();
}

void *llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::insertShortCut(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  uint64_t v8 = a2;
  uint64_t v9 = 0;
  if (sub_1CD40EA84(*(void *)a4, *(_DWORD *)(a4 + 16), a3, &v9)) {
    BOOL v6 = v9 == *(void *)a4 + 16 * *(unsigned int *)(a4 + 16);
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    uint64_t v5 = *(void *)(v9 + 8);
  }
  uint64_t result = sub_1CD548268((_DWORD *)a4, &v8);
  result[1] = v5;
  return result;
}

uint64_t llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::createRegion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a2 + 88);
  if (((*(void *)(a2 + 96) - (void)v3) & 0x7FFFFFFF0) != 0 || *v3 != a3) {
    operator new();
  }
  return 0;
}

void **llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::scanForRegions(uint64_t a1, uint64_t a2)
{
  v18[30] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = sub_1CBB36158(*(void *)(a1 + 8), *(void *)(a2 + 328));
  sub_1CD4B8CB4((uint64_t)v17, v2);
  sub_1CD4BAE30((const void **)&v12, (llvm::SmallPtrSetImplBase *)v17);
  sub_1CD4BAE30((const void **)&v7, (llvm::SmallPtrSetImplBase *)v18);
  if (v15 != v10) {
    goto LABEL_11;
  }
  if (v15)
  {
    uint64_t v3 = v9;
    unint64_t v4 = v14;
    while (*v4 == *v3 && v4[1] == v3[1])
    {
      v4 += 2;
      v3 += 2;
      if (v4 == (void *)((char *)v14 + 16 * v15)) {
        goto LABEL_12;
      }
    }
LABEL_11:
    llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::findRegionsWithEntry();
  }
LABEL_12:
  if (v9 != &v11) {
    free(v9);
  }
  if (v8 != v7) {
    free(v8);
  }
  if (v14 != &v16) {
    free(v14);
  }
  if (v13 != v12) {
    free(v13);
  }
  return sub_1CD4B9AEC(v17);
}

void *llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::buildRegionsTree(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)a2;
  uint64_t v17 = *(void *)a2;
  while (v6 == *(void *)(a3 + 32))
    a3 = *(void *)(a3 + 8);
  uint64_t v8 = (void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v18 = 0;
  if (sub_1CD40EA84(v7, *(_DWORD *)(a1 + 56), v6, &v18)) {
    BOOL v9 = v18 == *v8 + 16 * *(unsigned int *)(a1 + 56);
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    uint64_t v10 = *(void *)(v18 + 8);
    do
      uint64_t v10 = *(void *)(v10 + 8);
    while (v10);
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::addSubRegion();
  }
  uint64_t result = sub_1CD467E2C(a1 + 40, &v17);
  result[1] = a3;
  uint64_t v16 = a3;
  uint64_t v11 = *(unsigned int *)(a2 + 32);
  if (v11)
  {
    uint64_t v12 = *(uint64_t **)(a2 + 24);
    uint64_t v13 = 8 * v11;
    do
    {
      uint64_t v14 = *v12++;
      uint64_t result = (void *)llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::buildRegionsTree(a1, v14, v16);
      v13 -= 8;
    }
    while (v13);
  }
  return result;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::calculate()
{
}

{
  while (1)
    ;
}

void llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::dump(llvm *a1)
{
  unint64_t v1 = llvm::dbgs(a1);
  sub_1CB8E509C(v1, "Region tree:\n");
  llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::print();
}

void llvm::MachineRegionInfo::~MachineRegionInfo(llvm::MachineRegionInfo *this)
{
}

void llvm::MachineRegionInfo::updateStatistics(llvm::MachineRegionInfo *this, llvm::MachineRegion *a2)
{
}

void llvm::MachineRegionInfo::recalculate(llvm::MachineRegionInfo *this, llvm::MachineFunction *a2, llvm::MachineDominatorTree *a3, llvm::MachinePostDominatorTree *a4, llvm::MachineDominanceFrontier *a5)
{
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = a5;
  operator new();
}

llvm::MachineRegionInfoPass *llvm::MachineRegionInfoPass::MachineRegionInfoPass(llvm::MachineRegionInfoPass *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::MachineRegionInfoPass::ID);
  *(void *)uint64_t v2 = &unk_1F260F170;
  *(void *)(v2 + 288) = 0;
  *(void *)(v2 + 296) = 0;
  *(void *)(v2 + 280) = 0;
  *(_DWORD *)(v2 + 304) = 0;
  *(void *)(v2 + 248) = &unk_1F260F148;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry((llvm::PassRegistry *)v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCFBF8, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC38D164;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCCFBF8, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return this;
}

void llvm::initializeMachineRegionInfoPassPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCFBF8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC38D164;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCFBF8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::MachineRegionInfoPass::runOnMachineFunction(uint64_t **this, llvm::MachineFunction *a2)
{
  ((void (*)(uint64_t **))(*this)[11])(this);
  unint64_t v4 = this[1];
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6)
  {
LABEL_2:
    uint64_t v7 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v5 != &llvm::MachineDominatorTree::ID)
    {
      v5 += 16;
      if (v5 == v6) {
        goto LABEL_2;
      }
    }
    uint64_t v7 = *(void *)(v5 + 8);
  }
  uint64_t v8 = (llvm::MachineDominatorTree *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v7 + 96))(v7, &llvm::MachineDominatorTree::ID);
  BOOL v9 = this[1];
  uint64_t v10 = *v9;
  uint64_t v11 = v9[1];
  if (v10 == v11)
  {
LABEL_4:
    uint64_t v12 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v10 != &llvm::MachinePostDominatorTree::ID)
    {
      v10 += 16;
      if (v10 == v11) {
        goto LABEL_4;
      }
    }
    uint64_t v12 = *(void *)(v10 + 8);
  }
  uint64_t v13 = (llvm::MachinePostDominatorTree *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v12 + 96))(v12, &llvm::MachinePostDominatorTree::ID);
  uint64_t v14 = this[1];
  uint64_t v15 = *v14;
  uint64_t v16 = v14[1];
  if (v15 == v16)
  {
LABEL_6:
    uint64_t v17 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v15 != &llvm::MachineDominanceFrontier::ID)
    {
      v15 += 16;
      if (v15 == v16) {
        goto LABEL_6;
      }
    }
    uint64_t v17 = *(void *)(v15 + 8);
  }
  uint64_t v18 = (llvm::MachineDominanceFrontier *)(*(uint64_t (**)(uint64_t, void *))(*(void *)v17 + 96))(v17, &llvm::MachineDominanceFrontier::ID);
  llvm::MachineRegionInfo::recalculate((llvm::MachineRegionInfo *)(this + 31), a2, v8, v13, v18);
}

void llvm::MachineRegionInfoPass::releaseMemory(llvm::MachineRegionInfoPass *this)
{
}

void llvm::MachineRegionInfoPass::verifyAnalysis(llvm::MachineRegionInfoPass *this)
{
  if (llvm::RegionInfoBase<llvm::RegionTraits<llvm::MachineFunction>>::VerifyRegionInfo) {
    llvm::RegionBase<llvm::RegionTraits<llvm::MachineFunction>>::verifyRegionNest();
  }
}

void llvm::MachineRegionInfoPass::getAnalysisUsage(llvm::MachineRegionInfoPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachinePostDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominanceFrontier::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

void llvm::MachineRegionInfoPass::print(llvm::MachineRegionInfoPass *this, llvm::raw_ostream *a2, const llvm::Module *a3)
{
}

void llvm::MachineRegionInfoPass::dump(llvm::MachineRegionInfoPass *this)
{
}

void llvm::callDefaultCtor<llvm::MachineRegionInfoPass>()
{
}

unint64_t *sub_1CD547E2C(unint64_t *result)
{
  unint64_t v1 = result;
  uint64_t v2 = result[13];
  do
  {
    uint64_t v3 = *(void **)(v2 - 32);
    if (!*(unsigned char *)(v2 - 8))
    {
      uint64_t result = sub_1CD548014((unint64_t *)&v7, *(void *)(v2 - 32));
      *(_OWORD *)(v2 - 24) = v7;
      *(unsigned char *)(v2 - 8) = 1;
    }
    uint64_t v4 = *(void *)(v2 - 24) & 6;
    if (v4)
    {
      uint64_t v5 = *v3 & 4;
    }
    else
    {
      uint64_t v5 = *(void *)((*v3 & 0xFFFFFFFFFFFFFFF8) + 96);
      uint64_t v4 = *(void *)(v2 - 16);
    }
    if (v4 != v5)
    {
      sub_1CD547F50((unint64_t *)(v2 - 24));
      sub_1CD547FAC();
    }
    unint64_t v6 = v1[12];
    uint64_t v2 = v1[13] - 32;
    v1[13] = v2;
  }
  while (v6 != v2);
  return result;
}

unint64_t sub_1CD547F50(unint64_t *a1)
{
  unint64_t result = *a1;
  if ((result & 6) != 0)
  {
    *a1 = result & 0xFFFFFFFFFFFFFFF9 | 4;
  }
  else
  {
    uint64_t v3 = *(uint64_t **)((*(void *)(result & 0xFFFFFFFFFFFFFFF8) & 0xFFFFFFFFFFFFFFF8) + 96);
    uint64_t v4 = (uint64_t *)(a1[1] + 8);
    do
    {
      a1[1] = (unint64_t)v4;
      if (v4 == v3) {
        break;
      }
      uint64_t v5 = *v4++;
    }
    while (*(void *)(*(void *)((result & 0xFFFFFFFFFFFFFFF8) + 8) + 32) == v5);
  }
  return result;
}

void sub_1CD547FAC()
{
}

unint64_t *sub_1CD548014(unint64_t *result, unint64_t a2)
{
  uint64_t v2 = *(void *)a2 >> 1;
  uint64_t v3 = *(void **)((*(void *)a2 & 0xFFFFFFFFFFFFFFF8) + 88);
  void *result = v2 & 2 | a2 & 0xFFFFFFFFFFFFFFF9;
  result[1] = (unint64_t)v3;
  if ((v2 & 2) != 0)
  {
    if (*(void *)(*(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 8) + 32) == *(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 32)) {
      void *result = a2 & 0xFFFFFFFFFFFFFFF9 | 4;
    }
  }
  else
  {
    uint64_t v4 = *(void **)((*(void *)a2 & 0xFFFFFFFFFFFFFFF8) + 96);
    if (v4 != v3)
    {
      uint64_t v5 = *(void *)(*(void *)((a2 & 0xFFFFFFFFFFFFFFF8) + 8) + 32);
      do
      {
        if (v5 != *v3) {
          break;
        }
        result[1] = (unint64_t)++v3;
      }
      while (v3 != v4);
    }
  }
  return result;
}

uint64_t **sub_1CD54809C(uint64_t **a1, unint64_t a2, long long *a3)
{
  unint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  long long v7 = a1 + 1;
  uint64_t v8 = a1 + 1;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v9 <= a2) {
          break;
        }
        uint64_t v5 = *v8;
        long long v7 = v8;
        if (!*v8) {
          goto LABEL_8;
        }
      }
      if (v9 >= a2) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        long long v7 = v8 + 1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint64_t v10 = operator new(0x30uLL);
    v15[0] = v10;
    v15[1] = v6;
    long long v11 = *a3;
    *((void *)a3 + 1) = 0;
    void v10[2] = v11;
    char v16 = 1;
    *(void *)uint64_t v10 = 0;
    *((void *)v10 + 1) = 0;
    *((void *)v10 + 2) = v8;
    void *v7 = (uint64_t *)v10;
    uint64_t v12 = (uint64_t *)**a1;
    if (v12)
    {
      *a1 = v12;
      uint64_t v13 = *v7;
    }
    else
    {
      uint64_t v13 = (uint64_t *)v10;
    }
    sub_1CB8358B8(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    uint64_t v8 = (uint64_t **)v15[0];
    v15[0] = 0;
    sub_1CC0D342C((uint64_t)v15);
  }
  return v8;
}

uint64_t sub_1CD54818C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1CD50D2CC((uint64_t)&v11, a2);
  uint64_t v5 = (void *)(a1 + 32);
  *(void *)a1 = a1 + 32;
  long long v7 = v11;
  unint64_t v6 = v12;
  if (v12 == v11)
  {
    *(void *)(a1 + 8) = v5;
    int v8 = HIDWORD(v13);
    if (HIDWORD(v13)) {
      memmove(v5, v6, 8 * HIDWORD(v13));
    }
  }
  else
  {
    *(void *)(a1 + 8) = v12;
    uint64_t v12 = v7;
    unint64_t v6 = v7;
    int v8 = HIDWORD(v13);
  }
  int v9 = v14;
  *(_DWORD *)(a1 + 16) = v13;
  *(_DWORD *)(a1 + 20) = v8;
  *(_DWORD *)(a1 + 24) = v9;
  uint64_t v13 = 8;
  int v14 = 0;
  *(_OWORD *)(a1 + 96) = v15;
  *(void *)(a1 + 112) = v16;
  long long v15 = 0uLL;
  uint64_t v16 = 0;
  if (v6 != v7) {
    free(v6);
  }
  sub_1CB89694C((llvm::SmallPtrSetImplBase *)a1, a3);
  return a1;
}

void *sub_1CD548268(_DWORD *a1, void *a2)
{
  long long v7 = 0;
  char v4 = sub_1CBA0E618((uint64_t)a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD40E608(a1, (uint64_t)a2, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

uint64_t llvm::MachineRegisterInfo::setType(uint64_t result, int a2, uint64_t a3)
{
  char v4 = (void *)(result + 424);
  unint64_t v5 = a2 & 0x7FFFFFFF;
  unint64_t v6 = *(unsigned int *)(result + 432);
  BOOL v7 = v5 >= v6;
  unint64_t v8 = v5 - v6;
  if (v7) {
    unint64_t result = sub_1CC38F7B8(result + 424, v8 + 1, *(void *)(result + 440));
  }
  *(void *)(*v4 + 8 * v5) = a3;
  return result;
}

BOOL llvm::MachineRegisterInfo::hasOneNonDBGUser(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = sub_1CBB36200(a1, a2);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v4 = *(void *)(v2 + 8);
  do
    uint64_t v2 = *(void *)(v2 + 24);
  while (v2 && ((*(unsigned char *)(v2 + 3) & 0x81) != 0 || *(void *)(v2 + 8) == v4));
  return v2 == v3;
}

uint64_t llvm::MachineRegisterInfo::getLiveInPhysReg(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 456);
  uint64_t v3 = *(void *)(a1 + 464) - v2;
  if (!v3) {
    return 0;
  }
  uint64_t v4 = (_DWORD *)(v2 + 4);
  uint64_t v5 = 8 * (v3 >> 3);
  while (*v4 != a2)
  {
    v4 += 2;
    v5 -= 8;
    if (!v5) {
      return 0;
    }
  }
  return *(v4 - 1);
}

uint64_t llvm::MachineRegisterInfo::EmitLiveInCopies(uint64_t this, llvm::MachineBasicBlock *a2, const llvm::TargetRegisterInfo *a3, const llvm::TargetInstrInfo *a4)
{
  uint64_t v4 = (*(void *)(this + 464) - *(void *)(this + 456)) >> 3;
  if (v4)
  {
    uint64_t v6 = this;
    unsigned int v7 = 0;
    unint64_t v8 = (void **)((char *)a2 + 152);
    while (1)
    {
      uint64_t v9 = *(void *)(v6 + 456);
      uint64_t v10 = v9 + 8 * v7;
      int v11 = *(_DWORD *)(v10 + 4);
      if (!v11) {
        break;
      }
      this = sub_1CC38E61C(v6, *(_DWORD *)(v10 + 4));
      if (!this)
      {
        uint64_t v17 = (unint64_t *)*((void *)a2 + 7);
        uint64_t v22 = 0;
        uint64_t v18 = sub_1CB85AA4C((uint64_t)a2, v17, &v22, *((void *)a4 + 1) + 912, v11);
        int v19 = *(_DWORD *)(*(void *)(v6 + 456) + 8 * v7);
        *((void *)&v23 + 1) = 0;
        LODWORD(v23) = 0;
        DWORD1(v23) = v19;
        uint64_t v24 = 0;
        uint64_t v25 = 0;
        llvm::MachineInstr::addOperand(v20, v18, (const llvm::MachineOperand *)&v23);
        if (v22) {
          llvm::MetadataTracking::untrack((uint64_t)&v22, v22);
        }
        int v15 = *(_DWORD *)(*(void *)(v6 + 456) + 8 * v7);
        goto LABEL_9;
      }
      uint64_t v12 = v9 + 8 * v7;
      uint64_t v13 = *(void **)(v6 + 464);
      for (uint64_t i = (void *)(v12 + 8); i != v13; ++i)
      {
        *(i - 1) = *i;
        v12 += 8;
      }
      *(void *)(v6 + 464) = v12;
      --v7;
      LODWORD(v4) = v4 - 1;
LABEL_13:
      if (++v7 == v4) {
        return this;
      }
    }
    int v15 = *(_DWORD *)(v9 + 8 * v7);
LABEL_9:
    LOWORD(v23) = v15;
    *((void *)&v23 + 1) = -1;
    uint64_t v16 = (_OWORD *)*((void *)a2 + 20);
    if ((unint64_t)v16 >= *((void *)a2 + 21))
    {
      this = (uint64_t)sub_1CC016940(v8, &v23);
    }
    else
    {
      _OWORD *v16 = v23;
      this = (uint64_t)(v16 + 1);
    }
    *((void *)a2 + 20) = this;
    goto LABEL_13;
  }
  return this;
}

void llvm::MachineRegisterInfo::dumpUses(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = sub_1CBA02BCC(a1, a2);
  if (v2 != v3)
  {
    uint64_t v4 = v2;
    uint64_t v5 = v3;
    do
    {
      llvm::MachineInstr::dump(*(llvm::MachineInstr **)(v4 + 8));
      uint64_t v6 = *(void *)(v4 + 8);
      do
        uint64_t v4 = *(void *)(v4 + 24);
      while (v4 && ((*(unsigned char *)(v4 + 3) & 1) != 0 || *(void *)(v4 + 8) == v6));
    }
    while (v4 != v5);
  }
}

uint64_t sub_1CD5485A8(uint64_t result)
{
  unint64_t v1 = *(_DWORD **)(result + 32);
  if (**(_WORD **)(result + 16) == 14)
  {
    uint64_t v3 = *(unsigned int *)(result + 40);
    if (v3 == 2) {
      return result;
    }
    uint64_t v2 = &v1[8 * v3];
    v1 += 16;
  }
  else
  {
    uint64_t v2 = v1 + 8;
  }
  do
  {
    if (!*(unsigned char *)v1)
    {
      unint64_t result = llvm::MachineOperand::setReg((uint64_t)v1, 0);
      *v1 &= 0xFFF000FF;
    }
    v1 += 8;
  }
  while (v1 != v2);
  return result;
}

void sub_1CD548620(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = *(unsigned int *)(a1 + 8);
  BOOL v5 = a2 >= v4;
  uint64_t v6 = a2 - v4;
  if (v6)
  {
    if (v5)
    {
      sub_1CD5486C4(a1, v6, a3);
    }
    else
    {
      uint64_t v8 = 3 * v4;
      uint64_t v9 = *(void *)a1 + 24 * v4 - 1;
      uint64_t v10 = 24 * a2 - 8 * v8;
      int v11 = (char *)v9;
      do
      {
        int v12 = *v11;
        v11 -= 24;
        if (v12 < 0) {
          operator delete(*(void **)(v9 - 23));
        }
        uint64_t v9 = (uint64_t)v11;
        v10 += 24;
      }
      while (v10);
      *(_DWORD *)(a1 + 8) = a2;
    }
  }
}

unint64_t sub_1CD5486C4(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t result = sub_1CBFCD38C(a1, a3, a2);
  if (a2)
  {
    unint64_t v6 = result;
    uint64_t v7 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 8);
    uint64_t v8 = a2;
    do
    {
      if (*(char *)(v6 + 23) < 0)
      {
        unint64_t result = (unint64_t)sub_1CB8BDF7C(v7, *(const void **)v6, *(void *)(v6 + 8));
      }
      else
      {
        long long v9 = *(_OWORD *)v6;
        *(void *)(v7 + 16) = *(void *)(v6 + 16);
        *(_OWORD *)uint64_t v7 = v9;
      }
      v7 += 24;
      --v8;
    }
    while (v8);
  }
  *(_DWORD *)(a1 + 8) += a2;
  return result;
}

void llvm::initializeMachineSchedulerPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCFCC0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC38FAA0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCFCC0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializePostMachineSchedulerPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCCFCC8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC38FB60;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCCFCC8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

llvm::raw_ostream *llvm::ReadyQueue::dump(const char **this)
{
  uint64_t v2 = llvm::dbgs((llvm *)this);
  uint64_t v3 = sub_1CB8E509C(v2, "Queue ");
  unint64_t v6 = this[1];
  BOOL v5 = (char *)(this + 1);
  unint64_t v4 = v6;
  char v7 = v5[23];
  int v8 = v7;
  if (v7 >= 0) {
    long long v9 = v5;
  }
  else {
    long long v9 = v4;
  }
  size_t v10 = v7 & 0x7F;
  if (v8 >= 0) {
    size_t v11 = v10;
  }
  else {
    size_t v11 = *((void *)v5 + 1);
  }
  int v12 = llvm::raw_ostream::write(v3, v9, v11);
  uint64_t v13 = sub_1CB8E509C(v12, ": ");
  int v14 = (uint64_t *)*((void *)v5 + 3);
  for (i = (uint64_t *)*((void *)v5 + 4); v14 != i; uint64_t v13 = sub_1CB8E509C(v18, " "))
  {
    uint64_t v16 = *v14++;
    uint64_t v17 = llvm::dbgs(v13);
    uint64_t v18 = llvm::raw_ostream::operator<<(v17, *(unsigned int *)(v16 + 192));
  }
  int v19 = llvm::dbgs(v13);

  return sub_1CB8E509C(v19, "\n");
}

uint64_t llvm::ScheduleDAGMI::releaseSucc(uint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = (_DWORD *)(*(void *)a3 & 0xFFFFFFFFFFFFFFF8);
  if ((~*(_DWORD *)a3 & 6) != 0 || *(_DWORD *)(a3 + 8) < 4u)
  {
    unsigned int v5 = *(_DWORD *)(a3 + 12) + *(_DWORD *)(a2 + 248);
    if (v4[62] < v5) {
      v4[62] = v5;
    }
    int v6 = v4[52] - 1;
    v4[52] = v6;
    if (v6) {
      BOOL v7 = 1;
    }
    else {
      BOOL v7 = result + 344 == (void)v4;
    }
    if (!v7) {
      return (*(uint64_t (**)(void))(**(void **)(result + 2648) + 120))();
    }
  }
  else
  {
    --v4[54];
    if (*(_DWORD *)(a3 + 8) == 5) {
      *(void *)(result + 2704) = v4;
    }
  }
  return result;
}

uint64_t llvm::ScheduleDAGMI::enterRegion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a1 + 928) = a3;
  *(void *)(a1 + 936) = a4;
  *(_DWORD *)(a1 + 944) = a5;
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 2648) + 24))(*(void *)(a1 + 2648), a3, a4, a5);
}

void llvm::ScheduleDAGMI::schedule(llvm::AAResults **this)
{
  v27[8] = *MEMORY[0x1E4F143B8];
  llvm::ScheduleDAGInstrs::buildSchedGraph((llvm::ScheduleDAGInstrs *)this, this[329], 0, 0, 0, 0);
  uint64_t v2 = this[332];
  uint64_t v3 = this[333];
  while (v2 != v3)
  {
    uint64_t v4 = *(void *)v2;
    uint64_t v2 = (llvm::AAResults *)((char *)v2 + 8);
    (*(void (**)(uint64_t, llvm::AAResults **))(*(void *)v4 + 24))(v4, this);
  }
  uint64_t v25 = v27;
  uint64_t v26 = 0x800000000;
  uint64_t v22 = v24;
  uint64_t v23 = 0x800000000;
  double RootsAndBiasEdges = llvm::ScheduleDAGMI::findRootsAndBiasEdges(this, (uint64_t)&v25, (uint64_t)&v22);
  (*(void (**)(llvm::AAResults *, llvm::AAResults **, double))(*(void *)this[331] + 64))(this[331], this, RootsAndBiasEdges);
  llvm::ScheduleDAGMI::initQueues((uint64_t)this, (uint64_t *)v25, v26, (uint64_t)v22, v23);
  unsigned __int8 v21 = 0;
  uint64_t v6 = (*(uint64_t (**)(llvm::AAResults *, unsigned __int8 *))(*(void *)this[331] + 96))(this[331], &v21);
  if (v6)
  {
    uint64_t v7 = v6;
    do
    {
      uint64_t v8 = *(void *)(v7 + 8);
      if (v21)
      {
        long long v9 = (unint64_t *)this[335];
        if (v9 == (unint64_t *)v8)
        {
          if (!v8 || (*(unsigned char *)v8 & 4) == 0)
          {
            while ((*(_WORD *)(v8 + 44) & 8) != 0)
              uint64_t v8 = *(void *)(v8 + 8);
          }
          uint64_t v13 = *(llvm::AAResults **)(v8 + 8);
          this[335] = v13;
          int v14 = this[336];
          if (v13 != v14)
          {
            while (1)
            {
              int v15 = **((unsigned __int16 **)v13 + 2);
              if ((v15 - 13) >= 5 && v15 != 23) {
                break;
              }
              if ((*(unsigned char *)v13 & 4) == 0)
              {
                while ((*((_WORD *)v13 + 22) & 8) != 0)
                  uint64_t v13 = (llvm::AAResults *)*((void *)v13 + 1);
              }
              uint64_t v13 = (llvm::AAResults *)*((void *)v13 + 1);
              if (v13 == v14)
              {
                uint64_t v13 = this[336];
                break;
              }
            }
          }
          this[335] = v13;
        }
        else
        {
          llvm::ScheduleDAGMI::moveInstruction((uint64_t *)this, *(void *)(v7 + 8), v9);
        }
      }
      else
      {
        size_t v10 = (unint64_t *)this[336];
        uint64_t v11 = (uint64_t)this[335];
        unint64_t v12 = sub_1CC3902EC((unint64_t)v10, v11);
        if (v8 == v12)
        {
          this[336] = (llvm::AAResults *)v12;
        }
        else
        {
          if (v11 == v8)
          {
            if (!v8 || (uint64_t v17 = v8, (*(unsigned char *)v8 & 4) == 0))
            {
              uint64_t v17 = v8;
              if ((*(_WORD *)(v8 + 44) & 8) != 0)
              {
                uint64_t v17 = v8;
                do
                  uint64_t v17 = *(void *)(v17 + 8);
                while ((*(_WORD *)(v17 + 44) & 8) != 0);
              }
            }
            unint64_t v18 = *(void *)(v17 + 8);
            this[335] = (llvm::AAResults *)v18;
            while (v18 != v12)
            {
              int v19 = **(unsigned __int16 **)(v18 + 16);
              if ((v19 - 13) >= 5 && v19 != 23) {
                goto LABEL_49;
              }
              if ((*(unsigned char *)v18 & 4) == 0)
              {
                while ((*(_WORD *)(v18 + 44) & 8) != 0)
                  unint64_t v18 = *(void *)(v18 + 8);
              }
              unint64_t v18 = *(void *)(v18 + 8);
            }
            unint64_t v18 = v12;
LABEL_49:
            this[335] = (llvm::AAResults *)v18;
          }
          llvm::ScheduleDAGMI::moveInstruction((uint64_t *)this, v8, v10);
          this[336] = (llvm::AAResults *)v8;
        }
      }
      (*(void (**)(llvm::AAResults *, uint64_t, void))(*(void *)this[331] + 112))(this[331], v7, v21);
      llvm::ScheduleDAGMI::updateQueues((uint64_t)this, v7, v21);
      uint64_t v7 = (*(uint64_t (**)(llvm::AAResults *, unsigned __int8 *))(*(void *)this[331] + 96))(this[331], &v21);
    }
    while (v7);
  }
  llvm::ScheduleDAGMI::placeDebugValues((uint64_t)this);
  if (v22 != v24) {
    free(v22);
  }
  if (v25 != v27) {
    free(v25);
  }
}

llvm::raw_ostream *llvm::ScheduleDAGMI::dumpSchedule(llvm::raw_ostream *this)
{
  uint64_t v1 = *((void *)this + 116);
  uint64_t v2 = *((void *)this + 117);
  if (v1 != v2)
  {
    uint64_t v3 = (uint64_t)this;
    uint64_t v4 = (uint64_t *)((char *)this + 952);
    do
    {
      uint64_t v7 = 0;
      uint64_t v8 = v1;
      uint64_t v5 = sub_1CD3C8538(v4, &v8, &v7);
      if ((v5 & 1) != 0 && *(void *)(v7 + 8))
      {
        this = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 32))(v3);
      }
      else
      {
        uint64_t v6 = llvm::dbgs((llvm *)v5);
        this = sub_1CB8E509C(v6, "Missing SUnit\n");
      }
      if (!v1 || (*(unsigned char *)v1 & 4) == 0)
      {
        while ((*(_WORD *)(v1 + 44) & 8) != 0)
          uint64_t v1 = *(void *)(v1 + 8);
      }
      uint64_t v1 = *(void *)(v1 + 8);
    }
    while (v1 != v2);
  }
  return this;
}

llvm::raw_ostream *llvm::ScheduleDAGMILive::dump(llvm::raw_ostream *this)
{
  uint64_t v1 = (uint64_t)this;
  if (*((void *)this + 10)) {
    this = llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)this, (llvm::SDep **)this + 9);
  }
  uint64_t v2 = *(void *)(v1 + 48);
  for (uint64_t i = *(void *)(v1 + 56); v2 != i; v2 += 272)
  {
    uint64_t v4 = llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)v1, (llvm::SDep **)v2);
    if (*(unsigned char *)(v1 + 3120))
    {
      uint64_t v5 = llvm::dbgs(v4);
      sub_1CB8E509C(v5, "  Pressure Diff      : ");
      uint64_t v4 = llvm::PressureDiff::dump((llvm::PressureDiff *)(*(void *)(v1 + 3104) + ((unint64_t)*(unsigned int *)(v2 + 192) << 6)), *(const llvm::TargetRegisterInfo **)(v1 + 24));
    }
    uint64_t v6 = llvm::dbgs(v4);
    sub_1CB8E509C(v6, "  Single Issue       : ");
    uint64_t mustBeginGroup = llvm::TargetSchedModel::mustBeginGroup(v1 + 632, *(void *)(v2 + 8), 0);
    if (!mustBeginGroup
      || (mustBeginGroup = llvm::TargetSchedModel::mustEndGroup((llvm::TargetSchedModel *)(v1 + 632), *(const llvm::MachineInstr **)(v2 + 8), 0), uint64_t v8 = "true;",
          (mustBeginGroup & 1) == 0))
    {
      uint64_t v8 = "false;";
    }
    long long v9 = llvm::dbgs((llvm *)mustBeginGroup);
    size_t v10 = sub_1CB8E509C(v9, v8);
    this = llvm::dbgs(v10);
    uint64_t v11 = (unsigned char *)*((void *)this + 4);
    if ((unint64_t)v11 >= *((void *)this + 3))
    {
      this = llvm::raw_ostream::write(this, 10);
    }
    else
    {
      *((void *)this + 4) = v11 + 1;
      *uint64_t v11 = 10;
    }
  }
  if (*(void *)(v1 + 352))
  {
    return llvm::ScheduleDAG::dumpNodeAll((const llvm::TargetRegisterInfo **)v1, (llvm::SDep **)(v1 + 344));
  }
  return this;
}

uint64_t llvm::ScheduleDAGMILive::computeCyclicCriticalPath(llvm::ScheduleDAGMILive *this)
{
  if (!llvm::MachineBasicBlock::isSuccessor(*((llvm::MachineBasicBlock **)this + 115), *((const llvm::MachineBasicBlock **)this + 115)))return 0; {
  uint64_t v2 = *((void *)this + 438);
  }
  uint64_t v3 = *(unsigned int *)(v2 + 176);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = *(int **)(v2 + 168);
  uint64_t v6 = &v5[4 * v3];
  do
  {
    int v7 = *v5;
    if (*v5 < 0)
    {
      uint64_t v8 = sub_1CC2F12AC(*((void *)this + 330), *v5);
      uint64_t v9 = sub_1CC39166C(v8, *(void *)(*(void *)(*(void *)(*((void *)this + 330) + 288) + 392)+ 16 * *(unsigned int *)(*((void *)this + 115) + 24)+ 8));
      if (v9)
      {
        unint64_t v21 = *(void *)(v9 + 8);
        uint64_t v22 = v21 < 8 ? 0 : *(void *)((v21 & 0xFFFFFFFFFFFFFFF8) + 16);
        v34[0] = v22;
        uint64_t v35 = 0;
        if (sub_1CD3C8538((uint64_t *)this + 119, v34, &v35))
        {
          uint64_t v23 = *(void *)(v35 + 8);
          if (v23)
          {
            char v24 = *(unsigned char *)(v23 + 236);
            if ((v24 & 2) == 0)
            {
              llvm::SUnit::ComputeHeight(*(llvm::SUnit **)(v35 + 8));
              char v24 = *(unsigned char *)(v23 + 236);
            }
            unsigned int v31 = *(_DWORD *)(v23 + 244);
            if ((v24 & 1) == 0) {
              llvm::SUnit::ComputeDepth((llvm::SUnit *)v23);
            }
            int v25 = *(_DWORD *)(v23 + 240);
            uint64_t v32 = v23;
            int v26 = *(unsigned __int16 *)(v23 + 226);
            uint64_t v27 = (llvm::ScheduleDAGMILive *)sub_1CC397C20((uint64_t *)this + 351, v7 & 0x7FFFFFFF);
            unsigned int v29 = v27;
            uint64_t v13 = v28;
            if ((llvm::ScheduleDAGMILive *)((char *)this + 2808) != v27 || v28 != 0xFFFFFFFFLL)
            {
              unsigned int v33 = v25 + v26;
              std::string v20 = (char *)this + 344;
              uint64_t v12 = *(void *)v27;
              do
              {
                uint64_t v10 = *(void *)(v12 + 32 * v13 + 16);
                if ((char *)v10 != v20)
                {
                  uint64_t v11 = sub_1CBB24CA0(*(void *)(*((void *)this + 330) + 288), *(void *)(v10 + 8), 0);
                  sub_1CC2FC02C(v8, v11, (uint64_t)v34);
                  if ((*(unsigned char *)(v34[0] + 8) & 6) == 0)
                  {
                    char v14 = *(unsigned char *)(v10 + 236);
                    if ((v14 & 1) == 0)
                    {
                      llvm::SUnit::ComputeDepth((llvm::SUnit *)v10);
                      char v14 = *(unsigned char *)(v10 + 236);
                    }
                    unsigned int v15 = *(_DWORD *)(v10 + 240);
                    if (v33 <= v15)
                    {
                      unsigned int v16 = 0;
                    }
                    else
                    {
                      if ((v14 & 1) == 0)
                      {
                        llvm::SUnit::ComputeDepth((llvm::SUnit *)v10);
                        unsigned int v15 = *(_DWORD *)(v10 + 240);
                        char v14 = *(unsigned char *)(v10 + 236);
                      }
                      unsigned int v16 = v33 - v15;
                    }
                    if ((v14 & 2) == 0) {
                      llvm::SUnit::ComputeHeight((llvm::SUnit *)v10);
                    }
                    unsigned int v17 = *(_DWORD *)(v10 + 244) + *(unsigned __int16 *)(v32 + 226);
                    unsigned int v18 = v17 - v31;
                    if (v17 - v31 >= v16) {
                      unsigned int v18 = v16;
                    }
                    if (v17 <= v31) {
                      unsigned int v19 = 0;
                    }
                    else {
                      unsigned int v19 = v18;
                    }
                    if (v19 <= v4) {
                      uint64_t v4 = v4;
                    }
                    else {
                      uint64_t v4 = v19;
                    }
                    std::string v20 = (char *)this + 344;
                  }
                  uint64_t v12 = *(void *)v29;
                }
                uint64_t v13 = *(unsigned int *)(v12 + 32 * v13 + 28);
              }
              while ((llvm::ScheduleDAGMILive *)((char *)this + 2808) != v29 || v13 != -1);
            }
          }
        }
      }
    }
    v5 += 4;
  }
  while (v5 != v6);
  return v4;
}

uint64_t sub_1CD549360(int a1, llvm::SUnit *this)
{
  if (a1 == 1)
  {
    if ((*((unsigned char *)this + 236) & 2) == 0) {
      llvm::SUnit::ComputeHeight(this);
    }
    uint64_t v3 = (char *)this + 244;
  }
  else
  {
    if ((*((unsigned char *)this + 236) & 1) == 0) {
      llvm::SUnit::ComputeDepth(this);
    }
    uint64_t v3 = (char *)this + 240;
  }
  return *(unsigned int *)v3;
}

uint64_t llvm::SchedBoundary::getOtherResourceCount(llvm::SchedBoundary *this, unsigned int *a2)
{
  *a2 = 0;
  if (!byte_1EBD06248) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 1);
  if (!*(void *)(v3 + 40)) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 2);
  uint64_t result = (*(_DWORD *)(v4 + 8) + *(_DWORD *)(v3 + 272) * *((_DWORD *)this + 42));
  int v6 = *(_DWORD *)(v3 + 48);
  if (v6 != 1)
  {
    uint64_t v7 = *((void *)this + 22);
    uint64_t v8 = *(void *)(v4 + 16);
    uint64_t v9 = 1;
    do
    {
      uint64_t v10 = (*(_DWORD *)(v8 + 4 * v9) + *(_DWORD *)(v7 + 4 * v9));
      if (v10 > result)
      {
        *a2 = v9;
        uint64_t result = v10;
      }
      ++v9;
    }
    while (v6 != v9);
  }
  return result;
}

llvm::raw_ostream *llvm::SchedBoundary::dumpScheduledState(llvm::SchedBoundary *this)
{
  uint64_t v2 = *((unsigned int *)this + 65);
  uint64_t v3 = *((void *)this + 1);
  if (v2)
  {
    unsigned int v4 = *(_DWORD *)(*(void *)(v3 + 192) + 4 * v2);
    unsigned int v5 = *(_DWORD *)(*((void *)this + 22) + 4 * v2);
  }
  else
  {
    unsigned int v4 = *(_DWORD *)(v3 + 272);
    unsigned int v5 = *((_DWORD *)this + 42) * v4;
  }
  unsigned int v6 = *(_DWORD *)(v3 + 276);
  uint64_t v7 = llvm::dbgs(this);
  uint64_t v8 = v7;
  char v9 = *((unsigned char *)this + 55);
  if (v9 >= 0) {
    uint64_t v10 = (char *)this + 32;
  }
  else {
    uint64_t v10 = (char *)*((void *)this + 4);
  }
  if (v9 >= 0) {
    size_t v11 = v9 & 0x7F;
  }
  else {
    size_t v11 = *((void *)this + 5);
  }
  uint64_t v13 = *((void *)v7 + 3);
  uint64_t v12 = (void *)*((void *)v7 + 4);
  if (v11 <= v13 - (uint64_t)v12)
  {
    if (v11)
    {
      memcpy(v12, v10, v11);
      *((void *)v8 + 4) += v11;
    }
  }
  else
  {
    llvm::raw_ostream::write(v8, v10, v11);
  }
  char v14 = sub_1CB8E509C(v8, " @");
  unsigned int v15 = llvm::raw_ostream::operator<<(v14, *((unsigned int *)this + 37));
  unsigned int v16 = sub_1CB8E509C(v15, "c\n");
  unsigned int v17 = sub_1CB8E509C(v16, "  Retired: ");
  unsigned int v18 = llvm::raw_ostream::operator<<(v17, *((unsigned int *)this + 42));
  unsigned int v19 = llvm::dbgs(v18);
  std::string v20 = sub_1CB8E509C(v19, "\n  Executed: ");
  unsigned int v21 = *(_DWORD *)(*((void *)this + 1) + 276) * *((_DWORD *)this + 37);
  if (v21 <= *((_DWORD *)this + 64)) {
    unsigned int v21 = *((_DWORD *)this + 64);
  }
  uint64_t v22 = llvm::raw_ostream::operator<<(v20, v21 / v6);
  uint64_t v23 = sub_1CB8E509C(v22, "c");
  char v24 = llvm::dbgs(v23);
  int v25 = sub_1CB8E509C(v24, "\n  Critical: ");
  int v26 = llvm::raw_ostream::operator<<(v25, v5 / v6);
  uint64_t v27 = sub_1CB8E509C(v26, "c, ");
  unsigned int v28 = llvm::raw_ostream::operator<<(v27, v5 / v4);
  unsigned int v29 = sub_1CB8E509C(v28, " ");
  uint64_t v30 = *((unsigned int *)this + 65);
  if (v30) {
    unsigned int v31 = *(char **)(*(void *)(*((void *)this + 1) + 32) + 32 * v30);
  }
  else {
    unsigned int v31 = "MOps";
  }
  uint64_t v32 = sub_1CB8E509C(v29, v31);
  unsigned int v33 = sub_1CB8E509C(v32, "\n  ExpectedLatency: ");
  uint64_t v34 = llvm::raw_ostream::operator<<(v33, *((unsigned int *)this + 40));
  uint64_t v35 = sub_1CB8E509C(v34, "c\n");
  if (*((unsigned char *)this + 264)) {
    unint64_t v36 = "  - Resource";
  }
  else {
    unint64_t v36 = "  - Latency";
  }
  unint64_t v37 = sub_1CB8E509C(v35, v36);

  return sub_1CB8E509C(v37, " limited.\n");
}

uint64_t llvm::GenericSchedulerBase::SchedCandidate::initResourceDelta(uint64_t this, const llvm::ScheduleDAGMI *a2, const llvm::TargetSchedModel *a3)
{
  unsigned int v4 = (_DWORD *)this;
  if (*(void *)(this + 4))
  {
    uint64_t v5 = *(void *)(this + 16);
    this = *(void *)(v5 + 24);
    if (!this)
    {
      this = llvm::TargetSchedModel::resolveSchedClass((const llvm::ScheduleDAGMI *)((char *)a2 + 632), *(const llvm::MachineInstr **)(v5 + 8));
      *(void *)(v5 + 24) = this;
    }
    if (*(_WORD *)(this + 12))
    {
      int v6 = v4[1];
      int v7 = v4[2];
      uint64_t v8 = 4 * *(unsigned __int16 *)(this + 12);
      char v9 = (unsigned __int16 *)(*(void *)(*((void *)a3 + 22) + 136) + 4 * *(unsigned __int16 *)(this + 10) + 2);
      do
      {
        int v10 = *(v9 - 1);
        if (v6 == v10) {
          v4[10] += *v9;
        }
        if (v7 == v10) {
          v4[11] += *v9;
        }
        v9 += 2;
        v8 -= 4;
      }
      while (v8);
    }
  }
  return this;
}

uint64_t llvm::GenericSchedulerBase::setPolicy(uint64_t a1, uint64_t a2, char a3, uint64_t a4, llvm::SchedBoundary *this)
{
  int OtherResourceCount = 0;
  unsigned int v17 = 0;
  if (this) {
    int OtherResourceCount = llvm::SchedBoundary::getOtherResourceCount(this, &v17);
  }
  LOBYTE(v10) = byte_1EBD06248;
  if (byte_1EBD06248)
  {
    if (*(void *)(*(void *)(a1 + 16) + 40)) {
      BOOL v11 = OtherResourceCount == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      uint64_t result = sub_1CC394774(a4);
      int v10 = 1;
      if (OtherResourceCount - *(_DWORD *)(*(void *)(a1 + 16) + 276) * (int)result > *(_DWORD *)(*(void *)(a1 + 16) + 276)) {
        goto LABEL_14;
      }
      goto LABEL_11;
    }
    LOBYTE(v10) = 0;
  }
  uint64_t result = 0;
LABEL_11:
  if (a3) {
    goto LABEL_13;
  }
  unsigned int v12 = *(_DWORD *)(a4 + 148);
  unsigned int v13 = *(_DWORD *)(a1 + 32);
  if (v12 > v13) {
    goto LABEL_13;
  }
  if (!v12) {
    goto LABEL_27;
  }
  if ((v10 & 1) == 0)
  {
    uint64_t result = sub_1CC394774(a4);
    unsigned int v12 = *(_DWORD *)(a4 + 148);
    unsigned int v13 = *(_DWORD *)(a1 + 32);
  }
  if (result + v12 > v13)
  {
LABEL_13:
    int v10 = 0;
    *(unsigned char *)a2 = 1;
  }
  else
  {
LABEL_27:
    int v10 = 0;
  }
LABEL_14:
  int v14 = *(_DWORD *)(a4 + 260);
  unsigned int v15 = v17;
  if (v14 != v17)
  {
    if (*(unsigned char *)(a4 + 264) && !*(_DWORD *)(a2 + 4)) {
      *(_DWORD *)(a2 + 4) = v14;
    }
    if (v10) {
      *(_DWORD *)(a2 + 8) = v15;
    }
  }
  return result;
}

uint64_t llvm::tryLatency(llvm *this, llvm::GenericSchedulerBase::SchedCandidate *a2, llvm::GenericSchedulerBase::SchedCandidate *a3, llvm::SchedBoundary *a4)
{
  uint64_t v7 = *((void *)this + 2);
  if (*((_DWORD *)a3 + 6) == 1)
  {
    if ((*(unsigned char *)(v7 + 236) & 1) == 0) {
      llvm::SUnit::ComputeDepth(*((llvm::SUnit **)this + 2));
    }
    unsigned int v8 = *(_DWORD *)(v7 + 240);
    uint64_t v9 = *((void *)a2 + 2);
    if ((*(unsigned char *)(v9 + 236) & 1) == 0) {
      llvm::SUnit::ComputeDepth(*((llvm::SUnit **)a2 + 2));
    }
    unsigned int v10 = *(_DWORD *)(v9 + 240);
    if (v8 > v10) {
      unsigned int v10 = v8;
    }
    unsigned int v11 = *((_DWORD *)a3 + 40);
    if (v11 <= *((_DWORD *)a3 + 37)) {
      unsigned int v11 = *((_DWORD *)a3 + 37);
    }
    uint64_t v12 = *((void *)this + 2);
    if (v10 > v11)
    {
      if ((*(unsigned char *)(v12 + 236) & 1) == 0) {
        llvm::SUnit::ComputeDepth(*((llvm::SUnit **)this + 2));
      }
      int v13 = *(_DWORD *)(v12 + 240);
      uint64_t v14 = *((void *)a2 + 2);
      if ((*(unsigned char *)(v14 + 236) & 1) == 0) {
        llvm::SUnit::ComputeDepth(*((llvm::SUnit **)a2 + 2));
      }
      int v15 = *(_DWORD *)(v14 + 240);
      if (v13 < v15)
      {
        char v16 = 13;
LABEL_55:
        *((unsigned char *)this + 24) = v16;
        return 1;
      }
      if (v13 > v15)
      {
        if (*((unsigned __int8 *)a2 + 24) >= 0xEu)
        {
          char v25 = 13;
          goto LABEL_60;
        }
        return 1;
      }
      uint64_t v12 = *((void *)this + 2);
    }
    if ((*(unsigned char *)(v12 + 236) & 2) == 0) {
      llvm::SUnit::ComputeHeight((llvm::SUnit *)v12);
    }
    int v26 = *(_DWORD *)(v12 + 244);
    uint64_t v27 = *((void *)a2 + 2);
    if ((*(unsigned char *)(v27 + 236) & 2) == 0) {
      llvm::SUnit::ComputeHeight(*((llvm::SUnit **)a2 + 2));
    }
    int v28 = *(_DWORD *)(v27 + 244);
    if (v26 > v28)
    {
      char v16 = 14;
      goto LABEL_55;
    }
    if (v26 < v28)
    {
      if (*((unsigned __int8 *)a2 + 24) >= 0xFu)
      {
        char v25 = 14;
        goto LABEL_60;
      }
      return 1;
    }
  }
  else
  {
    if ((*(unsigned char *)(v7 + 236) & 2) == 0) {
      llvm::SUnit::ComputeHeight(*((llvm::SUnit **)this + 2));
    }
    unsigned int v17 = *(_DWORD *)(v7 + 244);
    uint64_t v18 = *((void *)a2 + 2);
    if ((*(unsigned char *)(v18 + 236) & 2) == 0) {
      llvm::SUnit::ComputeHeight(*((llvm::SUnit **)a2 + 2));
    }
    unsigned int v19 = *(_DWORD *)(v18 + 244);
    if (v17 > v19) {
      unsigned int v19 = v17;
    }
    unsigned int v20 = *((_DWORD *)a3 + 40);
    if (v20 <= *((_DWORD *)a3 + 37)) {
      unsigned int v20 = *((_DWORD *)a3 + 37);
    }
    uint64_t v21 = *((void *)this + 2);
    if (v19 > v20)
    {
      if ((*(unsigned char *)(v21 + 236) & 2) == 0) {
        llvm::SUnit::ComputeHeight(*((llvm::SUnit **)this + 2));
      }
      int v22 = *(_DWORD *)(v21 + 244);
      uint64_t v23 = *((void *)a2 + 2);
      if ((*(unsigned char *)(v23 + 236) & 2) == 0) {
        llvm::SUnit::ComputeHeight(*((llvm::SUnit **)a2 + 2));
      }
      int v24 = *(_DWORD *)(v23 + 244);
      if (v22 < v24)
      {
        char v16 = 11;
        goto LABEL_55;
      }
      if (v22 > v24)
      {
        if (*((unsigned __int8 *)a2 + 24) >= 0xCu)
        {
          char v25 = 11;
          goto LABEL_60;
        }
        return 1;
      }
      uint64_t v21 = *((void *)this + 2);
    }
    if ((*(unsigned char *)(v21 + 236) & 1) == 0) {
      llvm::SUnit::ComputeDepth((llvm::SUnit *)v21);
    }
    int v29 = *(_DWORD *)(v21 + 240);
    uint64_t v30 = *((void *)a2 + 2);
    if ((*(unsigned char *)(v30 + 236) & 1) == 0) {
      llvm::SUnit::ComputeDepth(*((llvm::SUnit **)a2 + 2));
    }
    int v31 = *(_DWORD *)(v30 + 240);
    if (v29 > v31)
    {
      char v16 = 12;
      goto LABEL_55;
    }
    if (v29 < v31)
    {
      if (*((unsigned __int8 *)a2 + 24) < 0xDu) {
        return 1;
      }
      char v25 = 12;
LABEL_60:
      *((unsigned char *)a2 + 24) = v25;
      return 1;
    }
  }
  return 0;
}

llvm::raw_ostream *llvm::GenericScheduler::dumpPolicy(llvm::GenericScheduler *this)
{
  uint64_t v2 = llvm::dbgs(this);
  uint64_t v3 = sub_1CB8E509C(v2, "GenericScheduler RegionPolicy: ");
  unsigned int v4 = sub_1CB8E509C(v3, " ShouldTrackPressure=");
  uint64_t v5 = llvm::raw_ostream::operator<<(v4, *((unsigned __int8 *)this + 136));
  int v6 = sub_1CB8E509C(v5, " OnlyTopDown=");
  uint64_t v7 = llvm::raw_ostream::operator<<(v6, *((unsigned __int8 *)this + 138));
  unsigned int v8 = sub_1CB8E509C(v7, " OnlyBottomUp=");
  uint64_t v9 = llvm::raw_ostream::operator<<(v8, *((unsigned __int8 *)this + 139));

  return sub_1CB8E509C(v9, "\n");
}

uint64_t llvm::GenericScheduler::checkAcyclicLatency(uint64_t this)
{
  unsigned int v1 = *(_DWORD *)(this + 36);
  if (v1)
  {
    unsigned int v2 = *(_DWORD *)(this + 32);
    if (v1 < v2)
    {
      uint64_t v3 = *(_DWORD **)(this + 16);
      int v4 = v3[69];
      unsigned int v5 = v4 * v1;
      unsigned int v6 = *(_DWORD *)(this + 40);
      if (v5 <= v6) {
        unsigned int v5 = *(_DWORD *)(this + 40);
      }
      *(unsigned char *)(this + 44) = (v5 + v4 * v2 * v6 - 1) / v5 > v3[68] * v3[1];
    }
  }
  return this;
}

uint64_t llvm::tryPressure(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  unsigned int v9 = a1[1];
  unsigned int v10 = a2[1];
  if (v9 >> 15 > v10 >> 15) {
    goto LABEL_2;
  }
  if (v9 >> 15 < v10 >> 15) {
    goto LABEL_6;
  }
  if (*(unsigned __int8 *)(a4 + 25) == *(unsigned __int8 *)(a3 + 25))
  {
    int v17 = *a1;
    int v18 = *a2;
    if (v17 == v18)
    {
      if ((__int16)v9 < (__int16)v10)
      {
LABEL_2:
        unsigned int v11 = (unsigned char *)(a3 + 24);
LABEL_3:
        *unsigned int v11 = a5;
        return 1;
      }
      if ((__int16)v9 > (__int16)v10)
      {
LABEL_6:
        unsigned int v14 = *(unsigned __int8 *)(a4 + 24);
        unsigned int v11 = (unsigned char *)(a4 + 24);
        if (v14 <= a5) {
          return 1;
        }
        goto LABEL_3;
      }
    }
    else
    {
      if (*a1)
      {
        int v21 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a6 + 272))(a6, a7, (unsigned __int16)(v17 - 1));
        int v22 = *a2;
      }
      else
      {
        int v21 = 0x7FFFFFFF;
        int v22 = *a2;
      }
      if (v22) {
        int v23 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a6 + 272))(a6, a7, (unsigned __int16)(v18 - 1));
      }
      else {
        int v23 = 0x7FFFFFFF;
      }
      int v24 = (__int16)a1[1];
      BOOL v25 = v24 < 0;
      if (v24 >= 0) {
        int v26 = v21;
      }
      else {
        int v26 = v23;
      }
      if (v25) {
        int v27 = v21;
      }
      else {
        int v27 = v23;
      }
      if (v26 > v27) {
        goto LABEL_2;
      }
      if (v26 < v27) {
        goto LABEL_6;
      }
    }
  }
  return 0;
}

void llvm::GenericScheduler::initCandidate(llvm::GenericScheduler *this, llvm::GenericSchedulerBase::SchedCandidate *a2, const llvm::MachineInstr **a3, int a4, const llvm::RegPressureTracker *a5, llvm::RegPressureTracker *a6)
{
  *((void *)a2 + 2) = a3;
  *((unsigned char *)a2 + 25) = a4;
  uint64_t v6 = *((void *)this + 16);
  if (*(unsigned char *)(v6 + 3120))
  {
    if (a4)
    {
      llvm::RegPressureTracker::getMaxDownwardPressureDelta((uint64_t)a6, a3[1], (uint64_t)a2 + 26, *(void *)(v6 + 3808), (uint64_t)(*(void *)(v6 + 3816) - *(void *)(v6 + 3808)) >> 2, *(void *)(v6 + 3128), (uint64_t)(*(void *)(v6 + 3136) - *(void *)(v6 + 3128)) >> 2);
    }
    else
    {
      unsigned int v8 = a3[1];
      unsigned int v9 = (unsigned __int16 *)(*(void *)(v6 + 3104) + ((unint64_t)*((unsigned int *)a3 + 48) << 6));
      unsigned int v10 = (char *)a2 + 26;
      uint64_t v11 = *(void *)(v6 + 3808);
      uint64_t v12 = (*(void *)(v6 + 3816) - v11) >> 2;
      uint64_t v13 = *(void *)(v6 + 3128);
      if (byte_1EBD05848) {
        llvm::RegPressureTracker::getMaxUpwardPressureDelta((uint64_t)a6, v8, (uint64_t)v9, (uint64_t)v10, v11, v12, v13, (*(void *)(v6 + 3136) - v13) >> 2);
      }
      else {
        llvm::RegPressureTracker::getUpwardPressureDelta((uint64_t)a5, (uint64_t)v8, v9, (uint64_t)v10, v11, v12, v13);
      }
    }
  }
}

BOOL llvm::GenericScheduler::tryCandidate(llvm::GenericScheduler *this, llvm::GenericSchedulerBase::SchedCandidate *a2, llvm::GenericSchedulerBase::SchedCandidate *a3, llvm::SchedBoundary *a4)
{
  uint64_t v5 = *((void *)a2 + 2);
  if (!v5) {
    goto LABEL_94;
  }
  int v9 = llvm::biasPhysReg(*((void *)a3 + 2), *((unsigned __int8 *)a3 + 25));
  int v10 = llvm::biasPhysReg(v5, *((unsigned __int8 *)a2 + 25));
  if (v9 > v10)
  {
    uint64_t v12 = (char *)a3 + 24;
LABEL_4:
    char v13 = 2;
LABEL_5:
    *uint64_t v12 = v13;
    return *((unsigned char *)a3 + 24) != 0;
  }
  if (v9 < v10)
  {
    unsigned int v15 = *((unsigned __int8 *)a2 + 24);
    uint64_t v12 = (char *)a2 + 24;
    if (v15 < 3) {
      return *((unsigned char *)a3 + 24) != 0;
    }
    goto LABEL_4;
  }
  uint64_t v16 = *((void *)this + 16);
  if (*(unsigned char *)(v16 + 3120))
  {
    if (llvm::tryPressure((unsigned __int16 *)a3 + 13, (unsigned __int16 *)a2 + 13, (uint64_t)a3, (uint64_t)a2, 3u, *((void *)this + 3), *(void *)(v16 + 32)))return *((unsigned char *)a3 + 24) != 0; {
    uint64_t v42 = *((void *)this + 16);
    }
    if (*(unsigned char *)(v42 + 3120))
    {
      if (llvm::tryPressure((unsigned __int16 *)a3 + 15, (unsigned __int16 *)a2 + 15, (uint64_t)a3, (uint64_t)a2, 4u, *((void *)this + 3), *(void *)(v42 + 32)))return *((unsigned char *)a3 + 24) != 0; {
    }
      }
  }
  if (a4)
  {
    if (*((unsigned char *)this + 44) && !*((_DWORD *)a4 + 38) && llvm::tryLatency(a3, a2, a4, v11)) {
      return *((unsigned char *)a3 + 24) != 0;
    }
    uint64_t v17 = *((void *)a3 + 2);
    if ((*(_WORD *)(v17 + 228) & 0x4000) != 0)
    {
      uint64_t v31 = 252;
      if (*((_DWORD *)a4 + 6) == 1) {
        uint64_t v31 = 248;
      }
      unsigned int v32 = *(_DWORD *)(v17 + v31);
      unsigned int v33 = *((_DWORD *)a4 + 37);
      BOOL v34 = v32 >= v33;
      unsigned int v35 = v32 - v33;
      if (v34) {
        int v18 = v35;
      }
      else {
        int v18 = 0;
      }
    }
    else
    {
      int v18 = 0;
    }
    uint64_t v19 = *((void *)a2 + 2);
    if ((*(_WORD *)(v19 + 228) & 0x4000) != 0)
    {
      uint64_t v37 = 252;
      if (*((_DWORD *)a4 + 6) == 1) {
        uint64_t v37 = 248;
      }
      unsigned int v38 = *(_DWORD *)(v19 + v37);
      unsigned int v39 = *((_DWORD *)a4 + 37);
      BOOL v34 = v38 >= v39;
      int v36 = v38 - v39;
      if (!v34) {
        int v36 = 0;
      }
    }
    else
    {
      int v36 = 0;
    }
    if (v18 < v36)
    {
      uint64_t v12 = (char *)a3 + 24;
LABEL_54:
      char v13 = 5;
      goto LABEL_5;
    }
    if (v18 > v36)
    {
      unsigned int v40 = *((unsigned __int8 *)a2 + 24);
      uint64_t v12 = (char *)a2 + 24;
      if (v40 < 6) {
        return *((unsigned char *)a3 + 24) != 0;
      }
      goto LABEL_54;
    }
  }
  else
  {
    uint64_t v17 = *((void *)a3 + 2);
    uint64_t v19 = *((void *)a2 + 2);
  }
  uint64_t v20 = *((void *)this + 16);
  uint64_t v21 = 2704;
  if (*((unsigned char *)a2 + 25)) {
    uint64_t v22 = 2704;
  }
  else {
    uint64_t v22 = 2696;
  }
  uint64_t v23 = *(void *)(v20 + v22);
  if (!*((unsigned char *)a3 + 25)) {
    uint64_t v21 = 2696;
  }
  uint64_t v24 = *(void *)(v20 + v21);
  if (v17 == v24 && v19 != v23)
  {
    uint64_t v12 = (char *)a3 + 24;
LABEL_58:
    char v13 = 6;
    goto LABEL_5;
  }
  if (v17 != v24 && v19 == v23)
  {
    unsigned int v41 = *((unsigned __int8 *)a2 + 24);
    uint64_t v12 = (char *)a2 + 24;
    if (v41 < 7) {
      return *((unsigned char *)a3 + 24) != 0;
    }
    goto LABEL_58;
  }
  if (a4)
  {
    if (*((unsigned char *)a3 + 25)) {
      uint64_t v27 = 216;
    }
    else {
      uint64_t v27 = 220;
    }
    int v28 = *(_DWORD *)(v17 + v27);
    if (*((unsigned char *)a2 + 25)) {
      uint64_t v29 = 216;
    }
    else {
      uint64_t v29 = 220;
    }
    int v30 = *(_DWORD *)(v19 + v29);
    if (v28 < v30)
    {
      uint64_t v12 = (char *)a3 + 24;
LABEL_40:
      char v13 = 7;
      goto LABEL_5;
    }
    if (v28 > v30)
    {
      unsigned int v43 = *((unsigned __int8 *)a2 + 24);
      uint64_t v12 = (char *)a2 + 24;
      if (v43 < 8) {
        return *((unsigned char *)a3 + 24) != 0;
      }
      goto LABEL_40;
    }
  }
  if (*(unsigned char *)(v20 + 3120)
    && llvm::tryPressure((unsigned __int16 *)a3 + 17, (unsigned __int16 *)a2 + 17, (uint64_t)a3, (uint64_t)a2, 8u, *((void *)this + 3), *(void *)(v20 + 32)))
  {
    return *((unsigned char *)a3 + 24) != 0;
  }
  if (!a4) {
    return 0;
  }
  llvm::GenericSchedulerBase::SchedCandidate::initResourceDelta((uint64_t)a3, *((const llvm::ScheduleDAGMI **)this + 16), *((const llvm::TargetSchedModel **)this + 2));
  int v45 = *((_DWORD *)a3 + 10);
  int v46 = *((_DWORD *)a2 + 10);
  if (v45 < v46)
  {
    uint64_t v12 = (char *)a3 + 24;
LABEL_77:
    char v13 = 9;
    goto LABEL_5;
  }
  if (v45 > v46)
  {
    unsigned int v47 = *((unsigned __int8 *)a2 + 24);
    uint64_t v12 = (char *)a2 + 24;
    if (v47 < 0xA) {
      return *((unsigned char *)a3 + 24) != 0;
    }
    goto LABEL_77;
  }
  int v48 = *((_DWORD *)a3 + 11);
  int v49 = *((_DWORD *)a2 + 11);
  if (v48 > v49)
  {
    uint64_t v12 = (char *)a3 + 24;
LABEL_83:
    char v13 = 10;
    goto LABEL_5;
  }
  if (v48 < v49)
  {
    unsigned int v50 = *((unsigned __int8 *)a2 + 24);
    uint64_t v12 = (char *)a2 + 24;
    if (v50 < 0xB) {
      return *((unsigned char *)a3 + 24) != 0;
    }
    goto LABEL_83;
  }
  if (!*((unsigned char *)this + 140)
    && *(unsigned char *)a3
    && !*((unsigned char *)this + 44)
    && llvm::tryLatency(a3, a2, a4, v44))
  {
    return *((unsigned char *)a3 + 24) != 0;
  }
  unsigned int v51 = *(_DWORD *)(*((void *)a3 + 2) + 192);
  unsigned int v52 = *(_DWORD *)(*((void *)a2 + 2) + 192);
  if (*((_DWORD *)a4 + 6) == 1)
  {
    if (v51 < v52) {
      goto LABEL_94;
    }
    return 0;
  }
  if (v51 <= v52) {
    return 0;
  }
LABEL_94:
  *((unsigned char *)a3 + 24) = 16;
  return 1;
}

const llvm::TargetSchedModel **llvm::GenericScheduler::pickNodeFromQueue(const llvm::TargetSchedModel **this, uint64_t a2, uint64_t *a3, llvm::RegPressureTracker *a4, uint64_t a5)
{
  uint64_t v5 = *(const llvm::MachineInstr ****)(a2 + 56);
  uint64_t v6 = *(const llvm::MachineInstr ****)(a2 + 64);
  if (v5 != v6)
  {
    uint64_t v11 = this;
    uint64_t v12 = a5 + 26;
    do
    {
      char v13 = *v5;
      uint64_t v15 = *a3;
      int v16 = *((_DWORD *)a3 + 2);
      uint64_t v19 = 0;
      uint64_t v17 = 0;
      memset(v18, 0, sizeof(v18));
      llvm::GenericScheduler::initCandidate((llvm::GenericScheduler *)v11, (llvm::GenericSchedulerBase::SchedCandidate *)&v15, v13, *(_DWORD *)(a2 + 24) == 1, a4, a4);
      if (*(unsigned __int8 *)(a5 + 25) == HIBYTE(v18[0])) {
        uint64_t v14 = a2;
      }
      else {
        uint64_t v14 = 0;
      }
      this = (const llvm::TargetSchedModel **)(*((uint64_t (**)(const llvm::TargetSchedModel **, uint64_t, uint64_t *, uint64_t))*v11
                                               + 17))(v11, a5, &v15, v14);
      if (this)
      {
        if (!v19) {
          this = (const llvm::TargetSchedModel **)llvm::GenericSchedulerBase::SchedCandidate::initResourceDelta((uint64_t)&v15, v11[16], v11[2]);
        }
        *(void *)(a5 + 16) = v17;
        *(_WORD *)(a5 + 24) = v18[0];
        *(void *)uint64_t v12 = *(void *)&v18[1];
        *(_DWORD *)(v12 + 8) = *(_DWORD *)&v18[5];
        *(void *)(a5 + 40) = v19;
      }
      ++v5;
    }
    while (v5 != v6);
  }
  return this;
}

uint64_t llvm::GenericScheduler::pickNode(llvm::GenericScheduler *this, BOOL *a2)
{
  if (*(void *)(*((void *)this + 16) + 2680) == *(void *)(*((void *)this + 16) + 2688)) {
    return 0;
  }
  int v4 = (llvm::GenericScheduler *)((char *)this + 144);
  uint64_t v5 = (char *)this + 1552;
  uint64_t v6 = (void *)((char *)this + 1568);
  uint64_t v7 = (llvm::GenericScheduler *)((char *)this + 848);
  do
  {
    if (*((unsigned char *)this + 138))
    {
      uint64_t v8 = llvm::SchedBoundary::pickOnlyChoice(v4);
      if (!v8)
      {
        v10[0] = 0;
        *(void *)&uint64_t v10[4] = 0;
        *((_DWORD *)v5 + 2) = 0;
        *(void *)uint64_t v5 = *(void *)v10;
        *((void *)this + 199) = 0;
        void *v6 = 0;
        v6[1] = 0;
        *(void *)((char *)v6 + 14) = 0;
        llvm::GenericScheduler::pickNodeFromQueue((const llvm::TargetSchedModel **)this, (uint64_t)v4, (uint64_t *)v10, (llvm::RegPressureTracker *)(*((void *)this + 16) + 4160), (uint64_t)v5);
        uint64_t v8 = *((void *)this + 196);
      }
      *a2 = 1;
    }
    else if (*((unsigned char *)this + 139))
    {
      uint64_t v8 = llvm::SchedBoundary::pickOnlyChoice(v7);
      if (!v8)
      {
        v10[0] = 0;
        *(void *)&uint64_t v10[4] = 0;
        *((_DWORD *)this + 402) = 0;
        *((void *)this + 200) = *(void *)v10;
        *((void *)this + 205) = 0;
        *((void *)this + 203) = 0;
        *((void *)this + 202) = 0;
        *(void *)((char *)this + 1630) = 0;
        llvm::GenericScheduler::pickNodeFromQueue((const llvm::TargetSchedModel **)this, (uint64_t)v7, (uint64_t *)v10, (llvm::RegPressureTracker *)(*((void *)this + 16) + 4840), (uint64_t)this + 1600);
        uint64_t v8 = *((void *)this + 202);
      }
      *a2 = 0;
    }
    else
    {
      uint64_t v8 = llvm::GenericScheduler::pickNodeBidirectional(this, a2);
    }
  }
  while ((*(_WORD *)(v8 + 228) & 0x400) != 0);
  if (!*(_DWORD *)(v8 + 208)) {
    llvm::SchedBoundary::removeReady((uint64_t)v4, v8);
  }
  if (!*(_DWORD *)(v8 + 212)) {
    llvm::SchedBoundary::removeReady((uint64_t)v7, v8);
  }
  return v8;
}

void llvm::createGenericSchedLive(llvm *this, llvm::MachineSchedContext *a2)
{
}

void llvm::PostGenericScheduler::initialize(llvm::PostGenericScheduler *this, llvm::ScheduleDAGMI *a2)
{
  *((void *)this + 16) = a2;
  uint64_t v3 = *((void *)a2 + 3);
  *((void *)this + 2) = (char *)a2 + 632;
  *((void *)this + 3) = v3;
  int v4 = (llvm::PostGenericScheduler *)((char *)this + 32);
  llvm::SchedRemainder::init((llvm::PostGenericScheduler *)((char *)this + 32), a2, (llvm::ScheduleDAGMI *)((char *)a2 + 632));
  llvm::SchedBoundary::init((llvm::PostGenericScheduler *)((char *)this + 136), *((llvm::ScheduleDAGMI **)this + 16), *((const llvm::TargetSchedModel **)this + 2), v4);
  *((_DWORD *)this + 212) = 0;
  if (!*((void *)this + 34))
  {
    uint64_t v5 = *(void *)(*(void *)(*((void *)this + 16) + 32) + 16);
    uint64_t v6 = *(void *)(*(uint64_t (**)(uint64_t))(*(void *)v5 + 104))(v5);
    *((void *)this + 34) = (*(uint64_t (**)(void))(v6 + 872))();
  }
}

void llvm::PostGenericScheduler::registerRoots(llvm::PostGenericScheduler *this)
{
  uint64_t v2 = *((void *)this + 16);
  if ((*(unsigned char *)(v2 + 580) & 1) == 0) {
    llvm::SUnit::ComputeDepth((llvm::SUnit *)(v2 + 344));
  }
  unsigned int v3 = *(_DWORD *)(v2 + 584);
  *((_DWORD *)this + 8) = v3;
  uint64_t v4 = *((unsigned int *)this + 212);
  if (v4)
  {
    uint64_t v5 = (llvm::SUnit **)*((void *)this + 105);
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *v5;
      if ((*((unsigned char *)*v5 + 236) & 1) == 0)
      {
        llvm::SUnit::ComputeDepth(*v5);
        unsigned int v3 = *((_DWORD *)this + 8);
      }
      unsigned int v8 = *((_DWORD *)v7 + 60);
      if (v8 > v3)
      {
        if ((*((unsigned char *)v7 + 236) & 1) == 0)
        {
          llvm::SUnit::ComputeDepth(v7);
          unsigned int v8 = *((_DWORD *)v7 + 60);
        }
        *((_DWORD *)this + 8) = v8;
        unsigned int v3 = v8;
      }
      ++v5;
      v6 -= 8;
    }
    while (v6);
  }
  if (byte_1EBD05788)
  {
    int v9 = (llvm::raw_ostream *)llvm::errs(this);
    int v10 = sub_1CB8E509C(v9, "Critical Path(PGS-RR): ");
    uint64_t v11 = llvm::raw_ostream::operator<<(v10, *((unsigned int *)this + 8));
    sub_1CB8E509C(v11, " \n");
  }
}

BOOL llvm::PostGenericScheduler::tryCandidate(llvm::PostGenericScheduler *this, llvm::GenericSchedulerBase::SchedCandidate *a2, llvm::GenericSchedulerBase::SchedCandidate *a3, llvm::SchedBoundary *a4)
{
  uint64_t v4 = *((void *)a2 + 2);
  if (!v4) {
    goto LABEL_50;
  }
  uint64_t v5 = *((void *)a3 + 2);
  if ((*(_WORD *)(v5 + 228) & 0x4000) != 0)
  {
    uint64_t v7 = 252;
    if (*((_DWORD *)this + 40) == 1) {
      uint64_t v7 = 248;
    }
    unsigned int v8 = *(_DWORD *)(v5 + v7);
    unsigned int v9 = *((_DWORD *)this + 71);
    BOOL v10 = v8 >= v9;
    int v6 = v8 - v9;
    if (!v10) {
      int v6 = 0;
    }
  }
  else
  {
    int v6 = 0;
  }
  if ((*(_WORD *)(v4 + 228) & 0x4000) != 0)
  {
    uint64_t v12 = 252;
    if (*((_DWORD *)this + 40) == 1) {
      uint64_t v12 = 248;
    }
    unsigned int v13 = *(_DWORD *)(v4 + v12);
    unsigned int v14 = *((_DWORD *)this + 71);
    BOOL v10 = v13 >= v14;
    int v11 = v13 - v14;
    if (!v10) {
      int v11 = 0;
    }
  }
  else
  {
    int v11 = 0;
  }
  if (v6 < v11)
  {
    uint64_t v15 = (char *)a3 + 24;
LABEL_16:
    char v16 = 5;
LABEL_17:
    *uint64_t v15 = v16;
LABEL_18:
    int v17 = *((unsigned __int8 *)a3 + 24);
    return v17 != 0;
  }
  if (v6 > v11)
  {
    unsigned int v19 = *((unsigned __int8 *)a2 + 24);
    uint64_t v15 = (char *)a2 + 24;
    if (v19 < 6) {
      goto LABEL_18;
    }
    goto LABEL_16;
  }
  uint64_t v20 = *(void *)(*((void *)this + 16) + 2704);
  if (v5 == v20 && v4 != v20)
  {
    uint64_t v15 = (char *)a3 + 24;
LABEL_36:
    char v16 = 6;
    goto LABEL_17;
  }
  if (v4 == v20 && v5 != v20)
  {
    unsigned int v25 = *((unsigned __int8 *)a2 + 24);
    uint64_t v15 = (char *)a2 + 24;
    if (v25 < 7) {
      goto LABEL_18;
    }
    goto LABEL_36;
  }
  int v23 = *((_DWORD *)a3 + 10);
  int v24 = *((_DWORD *)a2 + 10);
  if (v23 < v24)
  {
    uint64_t v15 = (char *)a3 + 24;
LABEL_35:
    char v16 = 9;
    goto LABEL_17;
  }
  if (v23 > v24)
  {
    unsigned int v26 = *((unsigned __int8 *)a2 + 24);
    uint64_t v15 = (char *)a2 + 24;
    if (v26 < 0xA) {
      goto LABEL_18;
    }
    goto LABEL_35;
  }
  int v27 = *((_DWORD *)a3 + 11);
  int v28 = *((_DWORD *)a2 + 11);
  if (v27 > v28)
  {
    uint64_t v15 = (char *)a3 + 24;
LABEL_44:
    char v16 = 10;
    goto LABEL_17;
  }
  if (v27 < v28)
  {
    unsigned int v29 = *((unsigned __int8 *)a2 + 24);
    uint64_t v15 = (char *)a2 + 24;
    if (v29 < 0xB) {
      goto LABEL_18;
    }
    goto LABEL_44;
  }
  if (*(unsigned char *)a2)
  {
    uint64_t v31 = a3;
    if (llvm::tryLatency(a3, a2, (llvm::PostGenericScheduler *)((char *)this + 136), a4))
    {
      int v17 = *((unsigned __int8 *)v31 + 24);
      return v17 != 0;
    }
    a3 = v31;
    uint64_t v5 = *((void *)v31 + 2);
    uint64_t v4 = *((void *)a2 + 2);
  }
  if (*(_DWORD *)(v5 + 192) >= *(_DWORD *)(v4 + 192)) {
    return 0;
  }
LABEL_50:
  *((unsigned char *)a3 + 24) = 16;
  return 1;
}

uint64_t llvm::PostGenericScheduler::pickNodeFromQueue(uint64_t this, llvm::GenericSchedulerBase::SchedCandidate *a2)
{
  uint64_t v2 = *(uint64_t **)(this + 192);
  unsigned int v3 = *(uint64_t **)(this + 200);
  if (v2 != v3)
  {
    uint64_t v5 = (const llvm::TargetSchedModel **)this;
    int v6 = (char *)a2 + 26;
    do
    {
      uint64_t v7 = *v2;
      uint64_t v8 = *(void *)a2;
      int v9 = *((_DWORD *)a2 + 2);
      uint64_t v12 = 0;
      *(void *)int v11 = 256;
      *(void *)&v11[6] = 0;
      uint64_t v10 = v7;
      llvm::GenericSchedulerBase::SchedCandidate::initResourceDelta((uint64_t)&v8, v5[16], v5[2]);
      this = (*((uint64_t (**)(const llvm::TargetSchedModel **, llvm::GenericSchedulerBase::SchedCandidate *, uint64_t *))*v5
              + 17))(v5, a2, &v8);
      if (this)
      {
        *((void *)a2 + 2) = v10;
        *((_WORD *)a2 + 12) = *(_WORD *)v11;
        *(void *)int v6 = *(void *)&v11[2];
        *((_DWORD *)v6 + 2) = *(_DWORD *)&v11[10];
        *((void *)a2 + 5) = v12;
      }
      ++v2;
    }
    while (v2 != v3);
  }
  return this;
}

uint64_t llvm::PostGenericScheduler::pickNode(llvm::PostGenericScheduler *this, BOOL *a2)
{
  if (*(void *)(*((void *)this + 16) + 2680) == *(void *)(*((void *)this + 16) + 2688)) {
    return 0;
  }
  uint64_t v4 = (llvm::PostGenericScheduler *)((char *)this + 136);
  do
  {
    uint64_t v5 = llvm::SchedBoundary::pickOnlyChoice(v4);
    if (!v5)
    {
      uint64_t v9 = 0;
      v10[0] = 0;
      *(void *)((char *)v10 + 6) = 0;
      uint64_t v8 = 0;
      void v10[2] = 0;
      v7[0] = 1;
      if (*((_DWORD *)this + 99) && *((unsigned char *)this + 400)) {
        LODWORD(v8) = *((_DWORD *)this + 99);
      }
      llvm::PostGenericScheduler::pickNodeFromQueue((uint64_t)this, (llvm::GenericSchedulerBase::SchedCandidate *)v7);
      uint64_t v5 = v9;
    }
  }
  while ((*(_WORD *)(v5 + 228) & 0x400) != 0);
  *a2 = 1;
  llvm::SchedBoundary::removeReady((uint64_t)v4, v5);
  return v5;
}

void llvm::PostGenericScheduler::schedNode(llvm::PostGenericScheduler *this, llvm::SUnit *a2)
{
  unsigned int v2 = *((_DWORD *)this + 71);
  if (*((_DWORD *)a2 + 62) > v2) {
    unsigned int v2 = *((_DWORD *)a2 + 62);
  }
  *((_DWORD *)a2 + 62) = v2;
  llvm::SchedBoundary::bumpNode((llvm::PostGenericScheduler *)((char *)this + 136), a2);
}

void llvm::createGenericSchedPostRA(llvm *this, llvm::MachineSchedContext *a2)
{
}

llvm::raw_ostream *llvm::ScheduleDAGMI::viewGraph(llvm *a1)
{
  unsigned int v1 = (llvm::raw_ostream *)llvm::errs(a1);
  unsigned int v2 = sub_1CB8E509C(v1, "ScheduleDAGMI::viewGraph is only available in debug builds on ");

  return sub_1CB8E509C(v2, "systems with Graphviz or gv!\n");
}

void llvm::ScheduleDAGMI::viewGraph(llvm::ScheduleDAGMI *this)
{
  (*(void (**)(void **__return_ptr))(*(void *)this + 56))(v9);
  __int16 v12 = 260;
  int v11 = v9;
  (*(void (**)(std::string *__return_ptr, llvm::ScheduleDAGMI *))(*(void *)this + 56))(&v4, this);
  unsigned int v2 = std::string::insert(&v4, 0, "Scheduling-Units Graph for ");
  std::string::size_type v3 = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  std::string::size_type v6 = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  __int16 v8 = 260;
  uint64_t v7 = __p;
  (*(void (**)(llvm::ScheduleDAGMI *, void ***, void ***))(*(void *)this + 16))(this, &v11, &v7);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
  if (v10 < 0) {
    operator delete(v9[0]);
  }
}

uint64_t sub_1CD54ACFC()
{
  return 0;
}

void sub_1CD54AD08(void *a1)
{
  sub_1CBACB4A0(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD54AD44(void *a1)
{
  sub_1CD54B2B8(a1);

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD54AD80()
{
  return 0;
}

void sub_1CD54AD8C(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 228) & 0x400) == 0) {
    llvm::SchedBoundary::releaseNode(a1 + 136, a2, *(_DWORD *)(a2 + 248), 0, 0);
  }
}

uint64_t sub_1CD54ADAC(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 848);
  if (v2 >= *(_DWORD *)(result + 852)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)(result + 840) + 8 * v2) = a2;
  ++*(_DWORD *)(result + 848);
  return result;
}

uint64_t sub_1CD54AE10(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  uint64_t v12 = 0;
  uint64_t v8 = sub_1CD54B1C4(a1 + 168, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(void *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 672);
  if (v9)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD54AEA4(v11);
}

uint64_t sub_1CD54AEA4(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 176) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD54AEBC(void *a1)
{
  sub_1CC397068(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD54AEF4(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 168), a1);
}

uint64_t sub_1CD54AF00(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 168), a1, a2);
}

llvm::raw_ostream *sub_1CD54AF10(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = *((void *)result + 16);
LABEL_3:
    char v5 = 1;
    v4[0] = &unk_1F260F800;
    v4[1] = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 168), result, (const llvm::cl::GenericOptionValue *)v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 152))
  {
    uint64_t v3 = *((void *)result + 16);
    if (*((void *)result + 18) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD54AF90(uint64_t result)
{
  if (*(unsigned char *)(result + 152)) {
    uint64_t v1 = *(void *)(result + 144);
  }
  else {
    uint64_t v1 = 0;
  }
  *(void *)(result + 128) = v1;
  return result;
}

void *sub_1CD54AFAC(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 168), a2);
}

void sub_1CD54AFB8(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
}

uint64_t sub_1CD54AFC0(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t result = llvm::cl::generic_parser_base::findOption(a1 + 8, a2, a3);
  uint64_t v5 = *(void *)(a1 + 24);
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  uint64_t v7 = v5 + 56 * v6;
  uint64_t v8 = v5 + 56 * result + 56;
  if (v8 != v7)
  {
    uint64_t v9 = 56 * v6 - 56 * result - 56;
    do
    {
      long long v10 = *(_OWORD *)(v8 + 16);
      *(_OWORD *)(v8 - 56) = *(_OWORD *)v8;
      *(_OWORD *)(v8 - 40) = v10;
      *(void *)(v8 - 16) = *(void *)(v8 + 40);
      *(unsigned char *)(v8 - 8) = *(unsigned char *)(v8 + 48);
      v8 += 56;
      v9 -= 56;
    }
    while (v9);
    unsigned int v6 = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 32) = v6 - 1;
  return result;
}

void sub_1CD54B050(uint64_t a1)
{
  sub_1CC397128((void *)(a1 - 8));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD54B08C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1CD54B094(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 56 * a2);
}

uint64_t sub_1CD54B0A8(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 16) + 56 * a2 + 16);
}

uint64_t sub_1CD54B0BC(uint64_t a1, unsigned int a2)
{
  return *(void *)(a1 + 16) + 56 * a2 + 32;
}

void *sub_1CD54B0D0(void *a1)
{
  *a1 = &unk_1F260F7B0;
  unsigned int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

void sub_1CD54B124(void *a1)
{
  *a1 = &unk_1F260F7B0;
  unsigned int v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}

BOOL sub_1CD54B198(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 16) && *(unsigned char *)(a1 + 16) && *(void *)(a1 + 8) != *(void *)(a2 + 8);
}

uint64_t sub_1CD54B1C4(uint64_t a1, void *a2, const void *a3, size_t a4, const void *a5, size_t a6, void *a7)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 8) + 24);
  if (v8) {
    a4 = a6;
  }
  if (v8) {
    a3 = a5;
  }
  uint64_t v11 = *(unsigned int *)(a1 + 24);
  if (v11)
  {
    uint64_t v13 = *(void *)(a1 + 16);
    while (*(void *)(v13 + 8) != a4 || a4 && memcmp(*(const void **)v13, a3, a4))
    {
      v13 += 56;
      if (!--v11) {
        goto LABEL_13;
      }
    }
    uint64_t result = 0;
    *a7 = *(void *)(v13 + 40);
  }
  else
  {
LABEL_13:
    __int16 v20 = 1283;
    v19[0] = (uint64_t)"Cannot find option named '";
    void v19[2] = (uint64_t)a3;
    v19[3] = a4;
    int v17 = "'!";
    __int16 v18 = 259;
    unsigned int v14 = sub_1CB8F1E58(v19, (uint64_t *)&v17, (uint64_t)v21);
    uint64_t v15 = (llvm::raw_ostream *)llvm::errs((llvm *)v14);
    return llvm::cl::Option::error(a2, (llvm::Twine *)v21, 0, 0, v15);
  }
  return result;
}

void *sub_1CD54B2B8(void *a1)
{
  *a1 = &unk_1F260F318;
  unsigned int v2 = (void *)a1[105];
  if (v2 != a1 + 107) {
    free(v2);
  }
  llvm::SchedBoundary::~SchedBoundary((llvm::SchedBoundary *)(a1 + 17));
  *a1 = &unk_1F25F5C98;
  uint64_t v3 = (void *)a1[6];
  if (v3 != a1 + 8) {
    free(v3);
  }
  return a1;
}

void sub_1CD54B344(_WORD *a1, __n128 *a2, char **a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCCFF10, 0, 0);
  byte_1EBCCFF90 = 0;
  qword_1EBCCFF98 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCCFFA0 = 0;
  qword_1EBCCFF10 = (uint64_t)&unk_1F26440A0;
  qword_1EBCCFFA8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCCFFB0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCCFFC8 = (uint64_t)&qword_1EBCCFFB0;
  sub_1CD54B434(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCCFF10);
}

__n128 sub_1CD54B434(_WORD *a1, __n128 *a2, char **a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCCFF10, "misched-cluster", 0xFuLL);
  word_1EBCCFF1A = (32 * (*a1 & 3)) | word_1EBCCFF1A & 0xFF9F;
  __n128 result = *a2;
  xmmword_1EBCCFF30 = (__int128)*a2;
  uint64_t v7 = *a3;
  byte_1EBCCFF90 = **a3;
  byte_1EBCCFFA1 = 1;
  byte_1EBCCFFA0 = *v7;
  return result;
}

void sub_1CD54B4BC(uint64_t **a1, _WORD *a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD02D0, 0, 0);
  *(_OWORD *)&xmmword_1EBCD0350 = 0u;
  *(_OWORD *)&qword_1EBCD0360 = 0u;
  *(&xmmword_1EBCD0350 + 1) = (uint64_t (*)(void))&unk_1F260F800;
  qword_1EBCD02D0 = (uint64_t)&unk_1F260F6C0;
  qword_1EBCD0380 = (uint64_t)&qword_1EBCD02D0;
  unk_1EBCD0388 = &unk_1EBCD0398;
  qword_1EBCD0390 = 0x800000000;
  qword_1EBCD0370 = (uint64_t)&unk_1F260F728;
  qword_1EBCD0378 = (uint64_t)&unk_1F260F760;
  qword_1EBCD0558 = (uint64_t)&unk_1F260F8D8;
  qword_1EBCD0570 = (uint64_t)&qword_1EBCD0558;
  sub_1CD54B5E8(a1, a2, a3);
  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD02D0);

  sub_1CC397BC4();
}

__n128 sub_1CD54B5E8(uint64_t **a1, _WORD *a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD02D0, "misched", 7uLL);
  unsigned int v6 = *a1;
  xmmword_1EBCD0350 = (uint64_t (*)(void))**a1;
  byte_1EBCD0368 = 1;
  qword_1EBCD0360 = *v6;
  word_1EBCD02DA = (32 * (*a2 & 3)) | word_1EBCD02DA & 0xFF9F;
  __n128 result = *a3;
  xmmword_1EBCD02F0 = (__int128)*a3;
  return result;
}

void sub_1CD54B674()
{
}

void *sub_1CD54B688()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1F260F8D8;
  return result;
}

void sub_1CD54B6C0(uint64_t a1, void *a2)
{
  *a2 = &unk_1F260F8D8;
}

void sub_1CD54B6EC(__n128 *a1, char **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD0150, 0, 0);
  byte_1EBCD01D0 = 0;
  qword_1EBCD01D8 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD01E0 = 0;
  qword_1EBCD0150 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD01E8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD01F0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD0208 = (uint64_t)&qword_1EBCD01F0;
  sub_1CD54B7DC(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD0150);
}

__n128 sub_1CD54B7DC(__n128 *a1, char **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD0150, "enable-misched", 0xEuLL);
  __n128 result = *a1;
  xmmword_1EBCD0170 = (__int128)*a1;
  uint64_t v7 = *a2;
  byte_1EBCD01D0 = **a2;
  byte_1EBCD01E1 = 1;
  byte_1EBCD01E0 = *v7;
  word_1EBCD015A = (32 * (*a3 & 3)) | word_1EBCD015A & 0xFF9F;
  return result;
}

void sub_1CD54B864(__n128 *a1, char **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD0210, 0, 0);
  byte_1EBCD0290 = 0;
  qword_1EBCD0298 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD02A0 = 0;
  qword_1EBCD0210 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD02A8 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD02B0 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD02C8 = (uint64_t)&qword_1EBCD02B0;
  sub_1CD54B954(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD0210);
}

__n128 sub_1CD54B954(__n128 *a1, char **a2, _WORD *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD0210, "enable-post-misched", 0x13uLL);
  __n128 result = *a1;
  xmmword_1EBCD0230 = (__int128)*a1;
  uint64_t v7 = *a2;
  byte_1EBCD0290 = **a2;
  byte_1EBCD02A1 = 1;
  byte_1EBCD02A0 = *v7;
  word_1EBCD021A = (32 * (*a3 & 3)) | word_1EBCD021A & 0xFF9F;
  return result;
}

_DWORD *sub_1CD54B9DC(uint64_t *a1, _DWORD *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CC39AB68(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CC39AC08((uint64_t)a1, (uint64_t)a2, a2, v7);
    *(void *)uint64_t v5 = *a2;
    void v5[2] = 0;
  }
  return v5;
}

void *sub_1CD54BA40(void *a1, uint64_t a2)
{
  a1[1] = a2;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 0;
  a1[6] = a1 + 8;
  a1[7] = 0x1000000000;
  *(void *)((char *)a1 + 37) = 0;
  *a1 = &unk_1F260F318;
  a1[16] = 0;
  char v4 = "TopQ";
  __int16 v5 = 259;
  sub_1CBACB320((uint64_t)(a1 + 17), 1, (uint64_t)&v4);
  a1[105] = a1 + 107;
  a1[106] = 0x800000000;
  return a1;
}

void llvm::initializeMachineSinkingPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD0578, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC39C0D0;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD0578, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializePostRAMachineSinkingPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD0580, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC39C188;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD0580, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

_DWORD *sub_1CD54BBCC(void *a1, unsigned int a2)
{
  if (a2 <= 4)
  {
    *a1 = 1;
LABEL_3:
    __n128 result = a1 + 1;
    char v4 = a1 + 9;
    goto LABEL_4;
  }
  *(_DWORD *)a1 &= ~1u;
  uint64_t v5 = a2;
  __n128 result = operator new(16 * a2, (std::align_val_t)8uLL);
  a1[1] = result;
  a1[2] = v5;
  int v6 = *(_DWORD *)a1;
  *a1 = *(_DWORD *)a1 & 1;
  if (v6) {
    goto LABEL_3;
  }
  char v4 = &result[4 * v5];
  do
  {
LABEL_4:
    _DWORD *result = -1;
    result += 4;
  }
  while (result != v4);
  return result;
}

uint64_t *sub_1CD54BC50(uint64_t *a1)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](a1[1], 8);
  }
  return a1;
}

uint64_t *sub_1CD54BC90(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    int v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40) {
      unsigned int v2 = v6 + 1;
    }
    else {
      unsigned int v2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(int **)(a1 + 8);
    uint64_t v8 = *(unsigned int *)(a1 + 16);
    if (v2 <= 4)
    {
      *(_DWORD *)a1 |= 1u;
    }
    else
    {
      *(void *)(a1 + 8) = operator new(16 * v2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v2;
    }
    sub_1CC3A0034((uint64_t *)a1, v7, &v7[4 * v8]);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = 0;
  long long v10 = v16;
  do
  {
    uint64_t v11 = a1 + v9;
    unsigned int v12 = *(_DWORD *)(a1 + v9 + 8);
    if (v12 <= 0xFFFFFFFD)
    {
      *long long v10 = v12;
      uint64_t v14 = *(void *)(v11 + 16);
      uint64_t v13 = (uint64_t *)(v11 + 16);
      *((void *)v10 + 1) = v14;
      *uint64_t v13 = 0;
      v10 += 4;
      sub_1CC39FCBC(v13);
    }
    v9 += 16;
  }
  while (v9 != 64);
  if (v2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(16 * v2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v2;
  }
  return sub_1CC3A0034((uint64_t *)a1, v16, v10);
}

char *sub_1CD54BE30(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  unint64_t v4 = *(long long **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  __n128 result = (char *)operator new(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CC3A02CC(a1, v4, (long long *)((char *)v4 + 40 * v3));
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = &result[40 * v10];
    do
    {
      *(void *)__n128 result = 0;
      result[8] = 0;
      result[24] = 0;
      *((void *)result + 4) = 0;
      result += 40;
    }
    while (result != v11);
  }
  return result;
}

uint64_t sub_1CD54BF14(unint64_t *a1, unint64_t a2)
{
  uint64_t v3 = *((unsigned int *)a1 + 2);
  unint64_t v4 = *a1;
  if (v3 >= *((_DWORD *)a1 + 3))
  {
    unint64_t v7 = v4 + 32 * v3;
    if (v4 > a2 || v7 <= a2) {
      sub_1CD54BFDC();
    }
    sub_1CD54BFDC();
  }
  unint64_t v5 = (void *)(v4 + 32 * *((unsigned int *)a1 + 2));
  void *v5 = *(void *)a2;
  void v5[2] = 0x200000000;
  v5[1] = v5 + 3;
  uint64_t result = (uint64_t)(v5 + 1);
  if (*(_DWORD *)(a2 + 16)) {
    uint64_t result = sub_1CC0778D4(result, a2 + 8);
  }
  ++*((_DWORD *)a1 + 2);
  return result;
}

void sub_1CD54BFDC()
{
}

void sub_1CD54C04C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1 + 32 * v2;
    uint64_t v5 = a2 + 24;
    uint64_t v6 = *a1 + 8;
    do
    {
      uint64_t v7 = v6 - 8;
      *(void *)(v5 - 24) = *(void *)(v6 - 8);
      *(void *)(v5 - 16) = v5;
      *(void *)(v5 - 8) = 0x200000000;
      if (*(_DWORD *)(v6 + 8)) {
        sub_1CC0778D4(v5 - 16, v6);
      }
      v5 += 32;
      v6 += 32;
    }
    while (v7 + 32 != v4);
    uint64_t v8 = *((unsigned int *)a1 + 2);
    if (v8)
    {
      uint64_t v9 = *a1;
      uint64_t v10 = 32 * v8;
      do
      {
        uint64_t v11 = *(void **)(v9 + v10 - 24);
        if ((void *)(v9 + v10 - 8) != v11) {
          free(v11);
        }
        v10 -= 32;
      }
      while (v10);
    }
  }
}

uint64_t *sub_1CD54C10C(unsigned int *a1)
{
  unsigned int v2 = *a1;
  uint64_t result = sub_1CC39FC54((uint64_t *)a1);
  unsigned int v4 = __clz((v2 >> 1) - 1);
  if (v4 - 28 >= 3) {
    int v5 = 1 << (33 - v4);
  }
  else {
    int v5 = 64;
  }
  if (v2 >= 2) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 0;
  }
  if ((*a1 & 1) != 0 && v6 < 5)
  {
    uint64_t v7 = a1 + 2;
    *(void *)a1 = 1;
    uint64_t v8 = a1 + 18;
    goto LABEL_18;
  }
  if ((*a1 & 1) == 0)
  {
    if (v6 != a1[4])
    {
      MEMORY[0x1D25D9CD0](*((void *)a1 + 1), 8);
      goto LABEL_12;
    }
    *(void *)a1 = 0;
    if (!v6) {
      return result;
    }
    uint64_t v7 = (_DWORD *)*((void *)a1 + 1);
    uint64_t v8 = &v7[4 * v6];
    do
    {
LABEL_18:
      _DWORD *v7 = -1;
      v7 += 4;
    }
    while (v7 != v8);
    return result;
  }
LABEL_12:

  return (uint64_t *)sub_1CD54BBCC(a1, v6);
}

uint64_t *sub_1CD54C1EC(uint64_t *a1)
{
  unsigned int v2 = *((_DWORD *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v5 = 88 * v2;
    unsigned int v6 = (char **)(v3 + 8);
    do
    {
      if (*((_DWORD *)v6 - 2) <= 0xFFFFFFFD)
      {
        uint64_t v7 = v5;
        unsigned int v6 = sub_1CD54C268(v6);
        uint64_t v5 = v7;
      }
      v6 += 11;
      v5 -= 88;
    }
    while (v5);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

char **sub_1CD54C268(char **result)
{
  uint64_t v1 = *result;
  uint64_t v2 = *((unsigned int *)result + 2);
  if (v2)
  {
    uint64_t v3 = 32 * v2;
    do
    {
      unsigned int v4 = *(char **)&v1[v3 - 24];
      if (&v1[v3 - 8] != v4)
      {
        uint64_t v7 = result;
        uint64_t v5 = v3;
        unsigned int v6 = v1;
        free(v4);
        uint64_t v3 = v5;
        uint64_t v1 = v6;
        uint64_t result = v7;
      }
      v3 -= 32;
    }
    while (v3);
    uint64_t v1 = *result;
  }
  if (v1 != (char *)(result + 2))
  {
    uint64_t v8 = result;
    free(v1);
    return v8;
  }
  return result;
}

_DWORD *sub_1CD54C2F0(_DWORD *a1)
{
  int v2 = *a1;
  if (*a1 > 1u)
  {
    if (v2)
    {
      uint64_t result = a1 + 2;
      unsigned int v6 = a1 + 34;
      goto LABEL_8;
    }
    uint64_t result = (_DWORD *)*((void *)a1 + 1);
    uint64_t v7 = a1[4];
    if (v7)
    {
      unsigned int v6 = &result[8 * v7];
LABEL_8:
      while (*result >= 0xFFFFFFFE)
      {
        result += 8;
        if (result == v6) {
          return v6;
        }
      }
    }
  }
  else
  {
    if (v2)
    {
      uint64_t v3 = a1 + 2;
      uint64_t v4 = 4;
    }
    else
    {
      uint64_t v3 = (_DWORD *)*((void *)a1 + 1);
      uint64_t v4 = a1[4];
    }
    return &v3[8 * v4];
  }
  return result;
}

uint64_t sub_1CD54C364(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    sub_1CD54D08C();
  }
  uint64_t v5 = (void *)(*(void *)a1 + 32 * v4);
  void *v5 = *a2;
  void v5[2] = 0x200000000;
  v5[1] = v5 + 3;
  uint64_t result = (uint64_t)(v5 + 1);
  if (*(_DWORD *)(a3 + 8)) {
    uint64_t result = sub_1CC0778D4(result, a3);
  }
  ++*(_DWORD *)(a1 + 8);
  return result;
}

uint64_t sub_1CD54C3F0(uint64_t a1, uint64_t *a2)
{
  v18[1] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a2;
  int v11 = 0;
  sub_1CD54D354((uint64_t)&v8, a1, &v10, &v11);
  uint64_t v4 = v8;
  if (v9)
  {
    unsigned int v12 = &v14;
    uint64_t v13 = 0x200000000;
    uint64_t v15 = *a2;
    char v16 = v18;
    uint64_t v17 = 0x200000000;
    sub_1CC3A7168((uint64_t *)(a1 + 24), (uint64_t)&v15);
    if (v16 != v18) {
      free(v16);
    }
    if (v12 != &v14) {
      free(v12);
    }
    uint64_t v5 = *(void *)(a1 + 24);
    unsigned int v6 = ((unint64_t)(*(void *)(a1 + 32) - v5) >> 5) - 1;
    *(_DWORD *)(v4 + 8) = v6;
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(v8 + 8);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  return v5 + 32 * v6 + 8;
}

char **sub_1CD54C504(char **result)
{
  uint64_t v1 = result;
  unsigned int v2 = *((_DWORD *)result + 4);
  int v3 = *((_DWORD *)result + 2);
  if (v2)
  {
    uint64_t v4 = 88 * v2;
    uint64_t result = (char **)(*result + 8);
    do
    {
      if (*((_DWORD *)result - 2) <= 0xFFFFFFFD) {
        uint64_t result = sub_1CD54C268(result);
      }
      result += 11;
      v4 -= 88;
    }
    while (v4);
  }
  int v5 = 1 << (33 - __clz(v3 - 1));
  if (v5 <= 64) {
    int v5 = 64;
  }
  if (v3) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 0;
  }
  if (v6 == *((_DWORD *)v1 + 4))
  {
    v1[1] = 0;
    if (v6)
    {
      uint64_t v7 = *v1;
      uint64_t v8 = 88 * v6;
      do
      {
        *(_DWORD *)uint64_t v7 = -1;
        v7 += 88;
        v8 -= 88;
      }
      while (v8);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*v1, 8);
    return (char **)sub_1CC3A6BC8(v1, v6);
  }
  return result;
}

_DWORD *sub_1CD54C5FC(_DWORD *a1, int *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD54C670((uint64_t)a1, *a2, &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD54C714(a1, a2, v7);
    _DWORD *v5 = *a2;
    *((void *)v5 + 1) = v5 + 6;
    *((void *)v5 + 2) = 0x200000000;
  }
  return v5;
}

uint64_t sub_1CD54C670(uint64_t a1, int a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      uint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_8;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  uint64_t v6 = (v4 - 1) & (37 * a2);
  uint64_t v7 = (_DWORD *)(v3 + 32 * v6);
  int v8 = *v7;
  if (*v7 == a2)
  {
LABEL_17:
    uint64_t result = 1;
  }
  else
  {
    char v9 = 0;
    int v10 = 1;
    while (v8 != -1)
    {
      if (v9) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -2;
      }
      if (v12) {
        char v9 = v7;
      }
      int v13 = v6 + v10++;
      uint64_t v6 = v13 & v5;
      uint64_t v7 = (_DWORD *)(v3 + 32 * v6);
      int v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_17;
      }
    }
    uint64_t result = 0;
    if (v9) {
      uint64_t v7 = v9;
    }
  }
LABEL_8:
  *a3 = v7;
  return result;
}

_DWORD *sub_1CD54C714(_DWORD *a1, int *a2, _DWORD *a3)
{
  int v3 = *a1 >> 1;
  if (*a1) {
    unsigned int v4 = 4;
  }
  else {
    unsigned int v4 = a1[4];
  }
  if (4 * v3 + 4 >= 3 * v4)
  {
    v4 *= 2;
  }
  else if (v4 + ~v3 - a1[1] > v4 >> 3)
  {
    goto LABEL_5;
  }
  uint64_t v7 = (uint64_t)a1;
  sub_1CD54C7D8((uint64_t)a1, v4);
  int v8 = 0;
  sub_1CD54C670(v7, *a2, &v8);
  a1 = (_DWORD *)v7;
  a3 = v8;
LABEL_5:
  *a1 += 2;
  if (*a3 != -1) {
    --a1[1];
  }
  return a3;
}

void sub_1CD54C7D8(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    int v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40) {
      unsigned int v2 = v6 + 1;
    }
    else {
      unsigned int v2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    uint64_t v8 = *(unsigned int *)(a1 + 16);
    if (v2 > 4)
    {
      *(void *)(a1 + 8) = operator new(32 * v2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v2;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD54C9C0(a1, v7, v7 + 32 * v8);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = 0;
  int v10 = v14;
  do
  {
    uint64_t v11 = a1 + v9;
    unsigned int v12 = *(_DWORD *)(a1 + v9 + 8);
    if (v12 <= 0xFFFFFFFD)
    {
      *(_DWORD *)int v10 = v12;
      *((void *)v10 + 1) = v10 + 24;
      int v13 = (void **)(v11 + 16);
      *((void *)v10 + 2) = 0x200000000;
      if (*(_DWORD *)(v11 + 24)) {
        sub_1CC0778D4((uint64_t)(v10 + 8), (uint64_t)v13);
      }
      v10 += 32;
      if ((void *)(a1 + v9 + 32) != *v13) {
        free(*v13);
      }
    }
    v9 += 32;
  }
  while (v9 != 128);
  if (v2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(32 * v2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v2;
  }
  sub_1CD54C9C0(a1, (uint64_t)v14, (uint64_t)v10);
}

void sub_1CD54C9C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    uint64_t v8 = (_DWORD *)(a1 + 8);
    uint64_t v9 = (_DWORD *)(a1 + 136);
  }
  else
  {
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (!v7) {
      goto LABEL_6;
    }
    uint64_t v8 = *(_DWORD **)(a1 + 8);
    uint64_t v9 = &v8[8 * v7];
  }
  do
  {
    _DWORD *v8 = -1;
    v8 += 8;
  }
  while (v8 != v9);
LABEL_6:
  if (a2 != a3)
  {
    do
    {
      int v10 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        uint64_t v14 = 0;
        sub_1CD54C670(a1, v10, &v14);
        uint64_t v11 = v14;
        *uint64_t v14 = *(_DWORD *)v4;
        *((void *)v11 + 2) = 0x200000000;
        *((void *)v11 + 1) = v11 + 6;
        uint64_t v12 = (uint64_t)(v11 + 2);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CC0778D4(v12, v4 + 8);
        }
        *(_DWORD *)a1 += 2;
        int v13 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v13) {
          free(v13);
        }
      }
      v4 += 32;
    }
    while (v4 != a3);
  }
}

_DWORD *sub_1CD54CAC4(uint64_t a1, int *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CC3A6EB0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  unint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    unint64_t v5 = sub_1CD54CB40(a1, a2, v7);
    _DWORD *v5 = *a2;
    *((void *)v5 + 1) = v5 + 6;
    *((void *)v5 + 2) = 0x200000000;
  }
  return v5;
}

_DWORD *sub_1CD54CB40(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD54CBF8(a1, v6);
  uint64_t v8 = 0;
  sub_1CC3A6EB0(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_DWORD *sub_1CD54CBF8(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(char **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(88 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD54CCD0((char **)a1, (uint64_t)v4, (uint64_t)&v4[88 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 88 * v10;
    do
    {
      _DWORD *result = -1;
      result += 22;
      v11 -= 88;
    }
    while (v11);
  }
  return result;
}

char **sub_1CD54CCD0(char **result, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  unint64_t v5 = result;
  result[1] = 0;
  unsigned int v6 = *((_DWORD *)result + 4);
  if (v6)
  {
    int v7 = *result;
    uint64_t v8 = 88 * v6;
    do
    {
      *(_DWORD *)int v7 = -1;
      v7 += 88;
      v8 -= 88;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      int v9 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 <= 0xFFFFFFFD)
      {
        uint64_t v12 = 0;
        sub_1CC3A6EB0((uint64_t)*v5, *((_DWORD *)v5 + 4), v9, &v12);
        unsigned int v10 = v12;
        *uint64_t v12 = *(_DWORD *)v4;
        *((void *)v10 + 2) = 0x200000000;
        *((void *)v10 + 1) = v10 + 6;
        uint64_t v11 = (uint64_t)(v10 + 2);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD54CDBC(v11, v4 + 8);
        }
        ++*((_DWORD *)v5 + 2);
        uint64_t result = sub_1CD54C268((char **)(v4 + 8));
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t sub_1CD54CDBC(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        uint64_t v12 = *(char **)a1;
        if (v5)
        {
          uint64_t v13 = 0;
          do
          {
            uint64_t v14 = (uint64_t)&v4[v13 + 32];
            *(void *)&v12[v13] = *(void *)&v4[v13];
            sub_1CC0778D4((uint64_t)&v12[v13 + 8], (uint64_t)&v4[v13 + 8]);
            v13 += 32;
          }
          while ((char *)v14 != &v4[32 * v5]);
          uint64_t v6 = *(unsigned int *)(a1 + 8);
          uint64_t v15 = &v12[v13];
          uint64_t v12 = *(char **)a1;
        }
        else
        {
          uint64_t v15 = *(char **)a1;
        }
        char v16 = &v12[32 * v6];
        if (v16 != v15)
        {
          uint64_t v17 = v16 - 8;
          do
          {
            __int16 v18 = (char *)*((void *)v17 - 2);
            if (v17 != v18) {
              free(v18);
            }
            unsigned int v19 = v17 - 24;
            v17 -= 32;
          }
          while (v19 != v15);
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v20 = *(unsigned int *)(a2 + 8);
        if (v20)
        {
          uint64_t v21 = *(char **)a2;
          uint64_t v22 = 32 * v20;
          do
          {
            int v23 = *(char **)&v21[v22 - 24];
            if (&v21[v22 - 8] != v23) {
              free(v23);
            }
            v22 -= 32;
          }
          while (v22);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          if (v6)
          {
            int v24 = *(char **)a1;
            uint64_t v25 = 32 * v6;
            do
            {
              unsigned int v26 = *(char **)&v24[v25 - 24];
              if (&v24[v25 - 8] != v26) {
                free(v26);
              }
              v25 -= 32;
            }
            while (v25);
          }
          *(_DWORD *)(a1 + 8) = 0;
          sub_1CD54BFDC();
        }
        if (v6)
        {
          int v7 = &v4[32 * v6];
          uint64_t v8 = *(char **)a1;
          do
          {
            uint64_t v9 = (uint64_t)(v4 + 8);
            uint64_t v10 = *(void *)v4;
            v4 += 32;
            uint64_t v11 = (uint64_t)(v8 + 8);
            *(void *)uint64_t v8 = v10;
            v8 += 32;
            sub_1CC0778D4(v11, v9);
          }
          while (v4 != v7);
        }
        else
        {
          uint64_t v6 = 0;
        }
        int v27 = *(char **)a2;
        uint64_t v28 = *(unsigned int *)(a2 + 8);
        if (v6 != v28)
        {
          unsigned int v29 = &v27[32 * v28];
          int v30 = *(char **)a1;
          uint64_t v31 = 32 * v6;
          do
          {
            unsigned int v32 = &v27[v31];
            unsigned int v33 = &v30[v31];
            *(void *)unsigned int v33 = *(void *)&v27[v31];
            *((void *)v33 + 2) = 0x200000000;
            *((void *)v33 + 1) = &v30[v31 + 24];
            if (*(_DWORD *)&v27[v31 + 16]) {
              sub_1CC0778D4((uint64_t)&v30[v31 + 8], (uint64_t)(v32 + 8));
            }
            v30 += 32;
            v27 += 32;
          }
          while (v32 + 32 != v29);
          int v27 = *(char **)a2;
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v34 = *(unsigned int *)(a2 + 8);
        if (v34)
        {
          uint64_t v35 = 32 * v34;
          do
          {
            int v36 = *(char **)&v27[v35 - 24];
            if (&v27[v35 - 8] != v36) {
              free(v36);
            }
            v35 -= 32;
          }
          while (v35);
        }
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      sub_1CD54D000((char **)a1, (char **)a2);
    }
  }
  return a1;
}

double sub_1CD54D000(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = 32 * v5;
    do
    {
      int v7 = *(char **)&v4[v6 - 24];
      if (&v4[v6 - 8] != v7) {
        free(v7);
      }
      v6 -= 32;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

void sub_1CD54D08C()
{
}

uint64_t sub_1CD54D14C(uint64_t a1)
{
  if ((*(unsigned char *)a1 & 1) == 0) {
    MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  }
  return a1;
}

uint64_t sub_1CD54D18C(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(unsigned int *)(a2 + 8);
    uint64_t v5 = *(unsigned int *)(a1 + 8);
    if (v5 >= v4)
    {
      if (v4)
      {
        uint64_t v12 = 0;
        uint64_t v13 = *(uint64_t **)a2;
        uint64_t v14 = *(void *)a2 + 32 * v4;
        uint64_t v15 = *(char **)a1;
        do
        {
          uint64_t v16 = (uint64_t)&v13[v12 + 4];
          *(void *)&v15[v12 * 8] = v13[v12];
          sub_1CC077ABC((uint64_t)&v15[v12 * 8 + 8], (uint64_t)&v13[v12 + 1]);
          v12 += 4;
        }
        while (v16 != v14);
        uint64_t v5 = *(unsigned int *)(a1 + 8);
        uint64_t v17 = *(char **)a1;
        __int16 v18 = &v15[v12 * 8];
      }
      else
      {
        uint64_t v17 = *(char **)a1;
        __int16 v18 = *(char **)a1;
      }
      unsigned int v19 = &v17[32 * v5];
      if (v19 != v18)
      {
        uint64_t v20 = v19 - 8;
        do
        {
          uint64_t v21 = (char *)*((void *)v20 - 2);
          if (v20 != v21) {
            free(v21);
          }
          uint64_t v22 = v20 - 24;
          v20 -= 32;
        }
        while (v22 != v18);
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 12) < v4)
      {
        if (v5)
        {
          int v24 = *(char **)a1;
          uint64_t v25 = 32 * v5;
          do
          {
            unsigned int v26 = *(char **)&v24[v25 - 24];
            if (&v24[v25 - 8] != v26) {
              free(v26);
            }
            v25 -= 32;
          }
          while (v25);
        }
        *(_DWORD *)(a1 + 8) = 0;
        sub_1CD54BFDC();
      }
      if (v5)
      {
        uint64_t v6 = *(uint64_t **)a2;
        uint64_t v7 = *(void *)a2 + 32 * v5;
        uint64_t v8 = *(char **)a1;
        do
        {
          uint64_t v9 = (uint64_t)(v6 + 1);
          uint64_t v10 = *v6;
          v6 += 4;
          uint64_t v11 = (uint64_t)(v8 + 8);
          *(void *)uint64_t v8 = v10;
          v8 += 32;
          sub_1CC077ABC(v11, v9);
        }
        while (v6 != (uint64_t *)v7);
      }
      else
      {
        uint64_t v5 = 0;
      }
      uint64_t v27 = *(unsigned int *)(a2 + 8);
      if (v5 != v27)
      {
        uint64_t v28 = *(uint64_t **)a2;
        unsigned int v29 = &v28[4 * v27];
        int v30 = *(char **)a1;
        uint64_t v31 = 4 * v5;
        do
        {
          unsigned int v32 = &v28[v31];
          unsigned int v33 = &v30[v31 * 8];
          *(void *)unsigned int v33 = v28[v31];
          *((void *)v33 + 2) = 0x200000000;
          *((void *)v33 + 1) = &v30[v31 * 8 + 24];
          if (LODWORD(v28[v31 + 2])) {
            sub_1CC077ABC((uint64_t)&v30[v31 * 8 + 8], (uint64_t)(v32 + 1));
          }
          v30 += 32;
          v28 += 4;
        }
        while (v32 + 4 != v29);
      }
    }
    *(_DWORD *)(a1 + 8) = v4;
  }
  return a1;
}

uint64_t sub_1CD54D354(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CBA0E618(a2, a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CB9A052C(a2, (uint64_t)a3, a3, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

uint64_t *sub_1CD54D3F0(uint64_t *result, void *a2)
{
  int v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  if (v4 != *result)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = *(void *)(v4 + v7 - 32);
      *(void *)(v6 + v7 - 24) = v6 + v7 - 8;
      uint64_t result = (uint64_t *)(v6 + v7 - 24);
      *(result - 1) = v8;
      result[1] = 0x200000000;
      if (*(_DWORD *)(v4 + v7 - 16)) {
        uint64_t result = (uint64_t *)sub_1CC0778D4((uint64_t)result, v4 + v7 - 24);
      }
      v7 -= 32;
    }
    while (v4 + v7 != v5);
    v6 += v7;
  }
  a2[1] = v6;
  uint64_t v9 = *v3;
  *int v3 = v6;
  a2[1] = v9;
  uint64_t v10 = v3[1];
  v3[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = v3[2];
  v3[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t llvm::shouldOptimizeForSize(const llvm::MachineBasicBlock *a1, uint64_t a2, llvm::MachineBlockFrequencyInfo *a3)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    uint64_t v7 = *(_DWORD **)(a2 + 8);
    if (!v7) {
      return 0;
    }
    if (byte_1EBD0D258) {
      return 1;
    }
    if (!byte_1EBD0CDD8) {
      return 0;
    }
    if (sub_1CC3A79F4(a2))
    {
      unint64_t BlockProfileCount = llvm::MachineBlockFrequencyInfo::getBlockProfileCount(a3, a1);
      if (v9 && *(unsigned char *)(a2 + 40)) {
        return *(void *)(a2 + 32) >= BlockProfileCount;
      }
      return 0;
    }
    if (*v7 == 2)
    {
      int v11 = dword_1EBD0D3D8;
      uint64_t v12 = llvm::MachineBlockFrequencyInfo::getBlockProfileCount(a3, a1);
      if (v13)
      {
        unint64_t v14 = v12;
        unint64_t v15 = llvm::ProfileSummaryInfo::computeThreshold((llvm::ProfileSummaryInfo *)a2, v11);
        return v16 && v15 >= v14;
      }
      return 0;
    }
    int v17 = dword_1EBD0D318;
    uint64_t v18 = llvm::MachineBlockFrequencyInfo::getBlockProfileCount(a3, a1);
    if (!v19) {
      return 1;
    }
    unint64_t v20 = v18;
    unint64_t v21 = llvm::ProfileSummaryInfo::computeThreshold((llvm::ProfileSummaryInfo *)a2, v17);
    return !v22 || v21 > v20;
  }
  return result;
}

BOOL llvm::shouldOptimizeForSize(llvm::MachineBasicBlock *a1, uint64_t a2, llvm::MBFIWrapper *this)
{
  BOOL result = 0;
  if (a2 && this)
  {
    uint64_t BlockFreq = llvm::MBFIWrapper::getBlockFreq(this, a1);
    uint64_t v8 = *(llvm::MachineBlockFrequencyInfo **)this;
    if (!v8) {
      return 0;
    }
    char v9 = *(_DWORD **)(a2 + 8);
    if (!v9) {
      return 0;
    }
    if (byte_1EBD0D258) {
      return 1;
    }
    if (!byte_1EBD0CDD8) {
      return 0;
    }
    unint64_t v10 = BlockFreq;
    if (sub_1CC3A79F4(a2))
    {
      ProfileCountFromFreq = llvm::MachineBlockFrequencyInfo::getProfileCountFromFreq(v8, v10);
      if (v12 && *(unsigned char *)(a2 + 40)) {
        return *(void *)(a2 + 32) >= (unint64_t)ProfileCountFromFreq;
      }
      return 0;
    }
    if (*v9 == 2)
    {
      int v14 = dword_1EBD0D3D8;
      unint64_t v15 = llvm::MachineBlockFrequencyInfo::getProfileCountFromFreq(v8, v10);
      if (v16)
      {
        int v24 = v15;
        unint64_t v25 = llvm::ProfileSummaryInfo::computeThreshold((llvm::ProfileSummaryInfo *)a2, v14);
        return v26 && v25 >= (unint64_t)v24;
      }
      return 0;
    }
    int v17 = dword_1EBD0D318;
    uint64_t v18 = llvm::MachineBlockFrequencyInfo::getProfileCountFromFreq(v8, v10);
    if (!v19) {
      return 1;
    }
    unint64_t v20 = v18;
    unint64_t v21 = llvm::ProfileSummaryInfo::computeThreshold((llvm::ProfileSummaryInfo *)a2, v17);
    return !v22 || v21 > (unint64_t)v20;
  }
  return result;
}

void llvm::MachineSSAUpdater::~MachineSSAUpdater(llvm::MachineSSAUpdater *this)
{
  uint64_t v1 = *(void **)this;
  if (*(void *)this)
  {
    MEMORY[0x1D25D9CD0](*v1, 8);
    MEMORY[0x1D25D9CE0](v1, 0x1020C405AF6BDC9);
  }
}

_DWORD *llvm::MachineSSAUpdater::Initialize(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(_DWORD **)a1;
  if (!v4) {
    operator new();
  }
  BOOL result = sub_1CD3C7F68(v4);
  *(void *)(a1 + 8) = a2;
  return result;
}

_DWORD *llvm::MachineSSAUpdater::Initialize(uint64_t a1, int a2)
{
  return llvm::MachineSSAUpdater::Initialize(a1, *(void *)(*(void *)(*(void *)(a1 + 32) + 24) + 16 * (a2 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8);
}

void *llvm::MachineSSAUpdater::AddAvailableValue(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v5 = a2;
  BOOL result = sub_1CD40EB18(*a1, &v5);
  *((_DWORD *)result + 2) = a3;
  return result;
}

uint64_t llvm::MachineSSAUpdater::GetValueAtEndOfBlockInternal(llvm::MachineSSAUpdater *this, llvm::MachineBasicBlock *a2, char a3)
{
  void v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)this;
  v10[0] = 0;
  if (sub_1CD40EA84(*(void *)v6, *(_DWORD *)(v6 + 16), (uint64_t)a2, v10)) {
    uint64_t v7 = *(unsigned int *)(v10[0] + 8);
  }
  else {
    uint64_t v7 = 0;
  }
  if (!v7 && (a3 & 1) == 0)
  {
    uint64_t v9 = *((void *)this + 2);
    v10[0] = this;
    v10[1] = v6;
    void v10[3] = 0;
    uint64_t v10[4] = 0;
    void v10[2] = v9;
    int v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    int v14 = v16;
    uint64_t v15 = 0x400000000;
    uint64_t v16[4] = v17;
    v16[5] = 0;
    v17[0] = 0;
    v17[1] = 1;
    uint64_t v7 = sub_1CD54DE58((uint64_t)v10, a2);
    sub_1CD54DF7C((uint64_t)v10);
  }
  return v7;
}

uint64_t llvm::MachineSSAUpdater::GetValueInMiddleOfBlock(llvm::MachineSSAUpdater *this, llvm::MachineBasicBlock *a2, char a3)
{
  v49[16] = *MEMORY[0x1E4F143B8];
  if (sub_1CD40EA84(**(void **)this, *(_DWORD *)(*(void *)this + 16), (uint64_t)a2, &v47))
  {
    uint64_t v6 = (llvm::MachineBasicBlock **)*((void *)a2 + 8);
    uint64_t v7 = (llvm::MachineBasicBlock **)*((void *)a2 + 9);
    if (v6 == v7)
    {
      if (a3)
      {
        return 0;
      }
      else
      {
        unint64_t FirstTerminator = (unint64_t *)llvm::MachineBasicBlock::getFirstTerminator(a2);
        sub_1CC3A7FD8(0xAu, (uint64_t)a2, FirstTerminator, *((void *)this + 1), *((void *)this + 4), *((void *)this + 3));
        return *(unsigned int *)(*(void *)(v30 + 32) + 4);
      }
    }
    else
    {
      LODWORD(v8) = 0;
      unsigned int v47 = v49;
      uint64_t v48 = 0x800000000;
      char v9 = 1;
      do
      {
        unint64_t v10 = *v6;
        unsigned int ValueAtEndOfBlockInternal = llvm::MachineSSAUpdater::GetValueAtEndOfBlockInternal(this, *v6, a3);
        if (v48 >= (unint64_t)HIDWORD(v48)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        uint64_t v12 = (llvm::MachineBasicBlock **)((char *)v47 + 16 * v48);
        *uint64_t v12 = v10;
        v12[1] = (llvm::MachineBasicBlock *)ValueAtEndOfBlockInternal;
        unsigned int v13 = v48 + 1;
        LODWORD(v48) = v48 + 1;
        if (ValueAtEndOfBlockInternal == v8) {
          unsigned int v14 = v8;
        }
        else {
          unsigned int v14 = 0;
        }
        if (v9) {
          uint64_t v8 = ValueAtEndOfBlockInternal;
        }
        else {
          uint64_t v8 = v14;
        }
        ++v6;
        char v9 = 0;
      }
      while (v6 != v7);
      if (!v8)
      {
        char v16 = (unint64_t *)((char *)a2 + 48);
        if ((llvm::MachineBasicBlock *)((char *)a2 + 48) != (llvm::MachineBasicBlock *)(*((void *)a2 + 6) & 0xFFFFFFFFFFFFFFF8)
          && ((uint64_t v17 = *((void *)a2 + 7), v18 = **(unsigned __int16 **)(v17 + 16), v18 != 69)
            ? (BOOL v19 = v18 == 0)
            : (BOOL v19 = 1),
              v19))
        {
          uint64_t v43 = 0;
          uint64_t v44 = 0;
          LODWORD(v45) = 0;
          if (v13)
          {
            uint64_t v20 = 0;
            uint64_t v21 = 16 * v13;
            do
            {
              char v22 = (char *)v47 + v20;
              *((_DWORD *)sub_1CD40EB18((uint64_t)&v43, (uint64_t *)((char *)v47 + v20)) + 2) = *((_DWORD *)v22 + 2);
              v20 += 16;
            }
            while (v21 != v20);
          }
          if ((unint64_t *)v17 != v16)
          {
            while (1)
            {
              int v23 = **(unsigned __int16 **)(v17 + 16);
              if (v23 != 69 && v23 != 0) {
                break;
              }
              int v25 = *(_DWORD *)(v17 + 40);
              if (v25 == 1)
              {
LABEL_54:
                uint64_t v8 = *(unsigned int *)(*(void *)(v17 + 32) + 4);
                goto LABEL_55;
              }
              unsigned int v26 = 1;
              while (1)
              {
                uint64_t v27 = *(void *)(v17 + 32);
                int v28 = *(_DWORD *)(v27 + 32 * v26 + 4);
                uint64_t v42 = *(void *)(v27 + 32 * (v26 + 1) + 16);
                if (*((_DWORD *)sub_1CD40EB18((uint64_t)&v43, &v42) + 2) != v28) {
                  break;
                }
                v26 += 2;
                if (v25 == v26) {
                  goto LABEL_54;
                }
              }
              if ((*(unsigned char *)v17 & 4) == 0)
              {
                while ((*(_WORD *)(v17 + 44) & 8) != 0)
                  uint64_t v17 = *(void *)(v17 + 8);
              }
              uint64_t v8 = 0;
              uint64_t v17 = *(void *)(v17 + 8);
              if ((unint64_t *)v17 == v16) {
                goto LABEL_55;
              }
            }
          }
          uint64_t v8 = 0;
LABEL_55:
          MEMORY[0x1D25D9CD0](v43, 8);
        }
        else
        {
          uint64_t v8 = 0;
        }
        if (!v8 && (a3 & 1) == 0)
        {
          if (v16 != (unint64_t *)(*v16 & 0xFFFFFFFFFFFFFFF8)) {
            char v16 = (unint64_t *)*((void *)a2 + 7);
          }
          uint64_t v31 = sub_1CC3A7FD8(0, (uint64_t)a2, v16, *((void *)this + 1), *((void *)this + 4), *((void *)this + 3));
          unsigned int v33 = v32;
          if (v48)
          {
            uint64_t v34 = v31;
            uint64_t v35 = 0;
            uint64_t v36 = 16 * v48;
            do
            {
              int v37 = *(_DWORD *)((char *)v47 + v35 + 8);
              uint64_t v44 = 0;
              LODWORD(v43) = 0;
              HIDWORD(v43) = v37;
              uint64_t v45 = 0;
              uint64_t v46 = 0;
              llvm::MachineInstr::addOperand(v33, v34, (const llvm::MachineOperand *)&v43);
              uint64_t v38 = *(void *)((char *)v47 + v35);
              uint64_t v44 = 0;
              uint64_t v45 = v38;
              LODWORD(v43) = 4;
              llvm::MachineInstr::addOperand(v33, v34, (const llvm::MachineOperand *)&v43);
              v35 += 16;
            }
            while (v36 != v35);
          }
          uint64_t isConstantValuePHI = llvm::MachineInstr::isConstantValuePHI(v33);
          if (isConstantValuePHI)
          {
            uint64_t v8 = isConstantValuePHI;
            llvm::MachineInstr::eraseFromParent(v33);
          }
          else
          {
            uint64_t v40 = *((void *)this + 2);
            if (v40)
            {
              unsigned int v41 = *(_DWORD *)(v40 + 8);
              if (v41 >= *(_DWORD *)(v40 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)v40 + 8 * v41) = v33;
              ++*(_DWORD *)(v40 + 8);
            }
            uint64_t v8 = *(unsigned int *)(*((void *)v33 + 4) + 4);
          }
        }
      }
      if (v47 != v49) {
        free(v47);
      }
    }
    return v8;
  }
  else
  {
    return llvm::MachineSSAUpdater::GetValueAtEndOfBlockInternal(this, a2, a3);
  }
}

uint64_t llvm::MachineSSAUpdater::RewriteUse(llvm::MachineSSAUpdater *this, llvm::MachineOperand *a2)
{
  uint64_t v3 = *((void *)a2 + 1);
  int v4 = **(unsigned __int16 **)(v3 + 16);
  if (v4 == 69 || v4 == 0)
  {
    uint64_t v6 = *(void *)(v3 + 32);
    unsigned int v7 = 1;
    do
    {
      uint64_t v8 = (llvm::MachineOperand *)(v6 + 32 * v7);
      v7 += 2;
    }
    while (v8 != a2);
    unsigned int ValueAtEndOfBlockInternal = llvm::MachineSSAUpdater::GetValueAtEndOfBlockInternal(this, *(llvm::MachineBasicBlock **)(v6 + 32 * (v7 - 1) + 16), 0);
  }
  else
  {
    unsigned int ValueAtEndOfBlockInternal = llvm::MachineSSAUpdater::GetValueInMiddleOfBlock(this, *(llvm::MachineBasicBlock **)(v3 + 24), 0);
  }

  return llvm::MachineOperand::setReg((uint64_t)a2, ValueAtEndOfBlockInternal);
}

uint64_t sub_1CD54DE58(uint64_t a1, llvm::MachineBasicBlock *a2)
{
  v13[100] = *MEMORY[0x1E4F143B8];
  unint64_t v10 = a2;
  int v11 = v13;
  uint64_t v12 = 0x6400000000;
  uint64_t v4 = sub_1CD54DFB4(a1, (uint64_t)a2, (uint64_t)&v11);
  if (v12)
  {
    sub_1CD54E4C4((uint64_t **)a1, (uint64_t *)&v11, v4);
    sub_1CC3A8248((uint64_t)v11, v12);
    sub_1CD54E644((void *)a1, (uint64_t)&v11);
    uint64_t v8 = *(unsigned int *)(*(void *)(sub_1CD467E2C(a1 + 24, (uint64_t *)&v10)[1] + 16) + 8);
  }
  else
  {
    uint64_t v5 = *(uint64_t **)a1;
    uint64_t FirstNonPHI = (unint64_t *)llvm::MachineBasicBlock::getFirstNonPHI(a2);
    sub_1CC3A7FD8(0xAu, (uint64_t)a2, FirstNonPHI, v5[1], v5[4], v5[3]);
    uint64_t v8 = *(unsigned int *)(*(void *)(v7 + 32) + 4);
    *((_DWORD *)sub_1CD40EB18(*(void *)(a1 + 8), (uint64_t *)&v10) + 2) = v8;
  }
  if (v11 != v13) {
    free(v11);
  }
  return v8;
}

uint64_t sub_1CD54DF7C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1CD54DFB4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v47[10] = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a2;
  uint64_t v45 = v47;
  uint64_t v46 = 0xA00000000;
  uint64_t v42 = v44;
  uint64_t v43 = 0x4000000000;
  uint64_t v5 = (uint64_t *)(a1 + 48);
  uint64_t v6 = sub_1CB906F34((uint64_t *)(a1 + 48), 64, 3);
  *(void *)uint64_t v6 = a2;
  *(_DWORD *)(v6 + 8) = 0;
  *(void *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  *(void *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 40) = 0;
  uint64_t v7 = a1 + 24;
  *(void *)(v6 + 48) = 0;
  *(void *)(v6 + 56) = 0;
  sub_1CD467E2C(a1 + 24, &v37)[1] = v6;
  if (v43 >= HIDWORD(v43)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v42 + v43) = v6;
  unsigned int v39 = v41;
  uint64_t v40 = 0xA00000000;
  BOOL v8 = __CFADD__(v43, 1);
  unsigned int v9 = v43 + 1;
  LODWORD(v43) = v43 + 1;
  if (!v8)
  {
    do
    {
      uint64_t v21 = *((void *)v42 + v9 - 1);
      LODWORD(v43) = v9 - 1;
      LODWORD(v40) = 0;
      sub_1CC33AD70((uint64_t)&v39, (uint64_t)v39, *(char **)(*(void *)v21 + 64), *(char **)(*(void *)v21 + 72));
      uint64_t v22 = v40;
      *(_DWORD *)(v21 + 40) = v40;
      if (v22)
      {
        uint64_t v23 = sub_1CB906F34(v5, 8 * v22, 3);
        int v24 = *(_DWORD *)(v21 + 40);
        *(void *)(v21 + 48) = v23;
        if (v24)
        {
          unsigned int v25 = 0;
          do
          {
            uint64_t v26 = v25;
            uint64_t v27 = *((void *)v39 + v25);
            uint64_t v36 = v27;
            int v28 = sub_1CD467E2C(a1 + 24, &v36);
            uint64_t v29 = v28[1];
            if (v29)
            {
              *(void *)(*(void *)(v21 + 48) + 8 * v26) = v29;
            }
            else
            {
              unsigned int v32 = v28;
              uint64_t v33 = *(void *)(a1 + 8);
              uint64_t v38 = 0;
              if (sub_1CD40EA84(*(void *)v33, *(_DWORD *)(v33 + 16), v27, &v38)) {
                int v34 = *(_DWORD *)(v38 + 8);
              }
              else {
                int v34 = 0;
              }
              uint64_t v30 = sub_1CB906F34(v5, 64, 3);
              *(void *)uint64_t v30 = v27;
              *(_DWORD *)(v30 + 8) = v34;
              if (v34) {
                uint64_t v31 = v30;
              }
              else {
                uint64_t v31 = 0;
              }
              *(void *)(v30 + 16) = v31;
              *(_DWORD *)(v30 + 24) = 0;
              *(void *)(v30 + 32) = 0;
              *(_DWORD *)(v30 + 40) = 0;
              *(void *)(v30 + 48) = 0;
              *(void *)(v30 + 56) = 0;
              v32[1] = v30;
              *(void *)(*(void *)(v21 + 48) + 8 * v26) = v30;
              if (v34)
              {
                if (v46 >= (unint64_t)HIDWORD(v46)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                v45[v46] = v30;
                LODWORD(v46) = v46 + 1;
              }
              else
              {
                if (v43 >= (unint64_t)HIDWORD(v43)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v42 + v43) = v30;
                LODWORD(v43) = v43 + 1;
              }
            }
            unsigned int v25 = v26 + 1;
          }
          while (v26 + 1 != *(_DWORD *)(v21 + 40));
        }
      }
      else
      {
        *(void *)(v21 + 48) = 0;
      }
      unsigned int v9 = v43;
    }
    while (v43);
  }
  uint64_t v10 = sub_1CB906F34(v5, 64, 3);
  *(void *)uint64_t v10 = 0;
  *(_DWORD *)(v10 + 8) = 0;
  *(void *)(v10 + 16) = 0;
  *(_DWORD *)(v10 + 24) = 0;
  *(void *)(v10 + 32) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(void *)(v10 + 48) = 0;
  *(void *)(v10 + 56) = 0;
  unsigned int v11 = v46;
  for (i = v43; v46; unsigned int v11 = v46)
  {
    uint64_t v13 = v45[v11 - 1];
    LODWORD(v46) = v11 - 1;
    *(void *)(v13 + 32) = v10;
    *(_DWORD *)(v13 + 24) = -1;
    if (i >= HIDWORD(v43)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *((void *)v42 + i) = v13;
    unsigned int i = v43 + 1;
    LODWORD(v43) = v43 + 1;
  }
  for (int j = 1; i; LODWORD(v43) = i)
  {
    while (1)
    {
      uint64_t v15 = (_DWORD *)*((void *)v42 + i - 1);
      if (v15[6] == -2) {
        break;
      }
      v15[6] = -2;
      uint64_t v17 = *(uint64_t **)(*(void *)v15 + 88);
      char v16 = *(uint64_t **)(*(void *)v15 + 96);
      if (v17 != v16)
      {
        do
        {
          uint64_t v18 = sub_1CD467E2C(v7, v17)[1];
          if (v18 && !*(_DWORD *)(v18 + 24))
          {
            *(_DWORD *)(v18 + 24) = -1;
            if (v43 >= (unint64_t)HIDWORD(v43)) {
              llvm::SmallVectorBase<unsigned int>::grow_pod();
            }
            *((void *)v42 + v43) = v18;
            LODWORD(v43) = v43 + 1;
          }
          ++v17;
        }
        while (v17 != v16);
        unsigned int i = v43;
      }
      if (!i) {
        goto LABEL_23;
      }
    }
    v15[6] = j;
    if (!v15[2])
    {
      unint64_t v19 = *(unsigned int *)(a3 + 8);
      if (v19 >= *(unsigned int *)(a3 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)a3 + 8 * v19) = v15;
      ++*(_DWORD *)(a3 + 8);
      unsigned int i = v43;
    }
    ++j;
    --i;
  }
LABEL_23:
  *(_DWORD *)(v10 + 24) = j;
  if (v39 != v41) {
    free(v39);
  }
  if (v42 != v44) {
    free(v42);
  }
  if (v45 != v47) {
    free(v45);
  }
  return v10;
}

uint64_t **sub_1CD54E4C4(uint64_t **result, uint64_t *a2, uint64_t a3)
{
  uint64_t v4 = result;
  unint64_t v19 = a2;
  do
  {
    uint64_t v5 = *((unsigned int *)a2 + 2);
    if (!v5) {
      break;
    }
    char v20 = 0;
    uint64_t v6 = *a2;
    uint64_t v7 = *a2 + 8 * v5;
    do
    {
      uint64_t v9 = *(void *)(v7 - 8);
      v7 -= 8;
      uint64_t v8 = v9;
      if (*(_DWORD *)(v9 + 40))
      {
        unsigned int v10 = 0;
        uint64_t v11 = 0;
        do
        {
          uint64_t v12 = *(void *)(*(void *)(v8 + 48) + 8 * v10);
          if (!*(_DWORD *)(v12 + 24))
          {
            uint64_t v15 = *(llvm::MachineBasicBlock **)v12;
            char v16 = *v4;
            uint64_t FirstNonPHI = (unint64_t *)llvm::MachineBasicBlock::getFirstNonPHI(*(llvm::MachineBasicBlock **)v12);
            sub_1CC3A7FD8(0xAu, (uint64_t)v15, FirstNonPHI, v16[1], v16[4], v16[3]);
            *(_DWORD *)(v12 + 8) = *(_DWORD *)(*(void *)(v18 + 32) + 4);
            BOOL result = (uint64_t **)sub_1CD40EB18((uint64_t)v4[1], (uint64_t *)v12);
            *((_DWORD *)result + 2) = *(_DWORD *)(v12 + 8);
            *(void *)(v12 + 16) = v12;
            *(_DWORD *)(v12 + 24) = (*(_DWORD *)(a3 + 24))++;
          }
          if (v11)
          {
            if (v11 != v12)
            {
              int v13 = *(_DWORD *)(v12 + 24);
              do
              {
                while (1)
                {
                  int v14 = *(_DWORD *)(v11 + 24);
                  if (v14 >= v13) {
                    break;
                  }
                  uint64_t v11 = *(void *)(v11 + 32);
                  if (!v11) {
                    goto LABEL_19;
                  }
                }
                while (1)
                {
                  int v13 = *(_DWORD *)(v12 + 24);
                  if (v13 >= v14) {
                    break;
                  }
                  uint64_t v12 = *(void *)(v12 + 32);
                  if (!v12) {
                    goto LABEL_20;
                  }
                }
              }
              while (v11 != v12);
            }
          }
          else
          {
LABEL_19:
            uint64_t v11 = v12;
          }
LABEL_20:
          ++v10;
        }
        while (v10 != *(_DWORD *)(v8 + 40));
        if (v11)
        {
          if (v11 != *(void *)(v8 + 32))
          {
            *(void *)(v8 + 32) = v11;
            char v20 = 1;
          }
        }
      }
    }
    while (v7 != v6);
    a2 = v19;
  }
  while ((v20 & 1) != 0);
  return result;
}

void sub_1CD54E644(void *a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 8);
  if (v2)
  {
    uint64_t v5 = *(uint64_t **)a2;
    uint64_t v6 = 8 * v2;
    do
    {
      uint64_t v7 = *v5;
      if (*(void *)(*v5 + 16) == *v5)
      {
        sub_1CD54E7E4(a1, *(llvm::MachineBasicBlock **)v7, a2);
        if (!*(_DWORD *)(v7 + 8))
        {
          uint64_t v8 = *(llvm::MachineBasicBlock **)v7;
          uint64_t v9 = (unint64_t *)(*(void *)v7 + 48);
          if (v9 != (unint64_t *)(*v9 & 0xFFFFFFFFFFFFFFF8)) {
            uint64_t v9 = (unint64_t *)*((void *)v8 + 7);
          }
          sub_1CC3A7FD8(0, (uint64_t)v8, v9, *(void *)(*a1 + 8), *(void *)(*a1 + 32), *(void *)(*a1 + 24));
          int v11 = *(_DWORD *)(*(void *)(v10 + 32) + 4);
          *(_DWORD *)(v7 + 8) = v11;
          *((_DWORD *)sub_1CD40EB18(a1[1], (uint64_t *)v7) + 2) = v11;
        }
      }
      ++v5;
      v6 -= 8;
    }
    while (v6);
    uint64_t v12 = *(unsigned int *)(a2 + 8);
    if (v12)
    {
      int v13 = *(uint64_t **)a2;
      uint64_t v14 = *(void *)a2 + 8 * v12;
      do
      {
        uint64_t v16 = *(void *)(v14 - 8);
        v14 -= 8;
        uint64_t v15 = v16;
        uint64_t v17 = *(void *)(v16 + 16);
        if (v17 == v16)
        {
          uint64_t v18 = sub_1CD54E8A4(*(_DWORD *)(v15 + 8), *(void *)(*a1 + 32));
          if (v18)
          {
            unint64_t v19 = (llvm::MachineInstr *)v18;
            if (*(_DWORD *)(v15 + 40))
            {
              unsigned int v20 = 0;
              do
              {
                uint64_t v21 = *(uint64_t **)(*(void *)(v15 + 48) + 8 * v20);
                sub_1CD54E8F0(v19, *(_DWORD *)(v21[2] + 8), *v21);
                ++v20;
              }
              while (v20 != *(_DWORD *)(v15 + 40));
            }
            uint64_t v22 = a1[2];
            if (v22)
            {
              unint64_t v23 = *(unsigned int *)(v22 + 8);
              if (v23 >= *(unsigned int *)(v22 + 12)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *(void *)(*(void *)v22 + 8 * v23) = v19;
              ++*(_DWORD *)(v22 + 8);
            }
          }
        }
        else
        {
          *((_DWORD *)sub_1CD40EB18(a1[1], (uint64_t *)v15) + 2) = *(_DWORD *)(v17 + 8);
        }
      }
      while ((uint64_t *)v14 != v13);
    }
  }
}

void *sub_1CD54E7E4(void *a1, llvm::MachineBasicBlock *this, uint64_t a3)
{
  uint64_t v5 = *((void *)this + 7);
  BOOL result = (void *)llvm::MachineBasicBlock::getFirstNonPHI(this);
  if ((void *)v5 != result)
  {
    uint64_t v7 = result;
    while (1)
    {
      BOOL result = (void *)sub_1CD54E95C((uint64_t)a1, v5);
      uint64_t v8 = *(uint64_t **)a3;
      uint64_t v9 = *(unsigned int *)(a3 + 8);
      if (result) {
        break;
      }
      if (v9)
      {
        uint64_t v10 = 8 * v9;
        do
        {
          uint64_t v11 = *v8++;
          *(void *)(v11 + 56) = 0;
          v10 -= 8;
        }
        while (v10);
      }
      if (!v5 || (*(unsigned char *)v5 & 4) == 0)
      {
        while ((*(_WORD *)(v5 + 44) & 8) != 0)
          uint64_t v5 = *(void *)(v5 + 8);
      }
      uint64_t v5 = *(void *)(v5 + 8);
      if ((void *)v5 == v7) {
        return result;
      }
    }
    return sub_1CD54EB50(a1, (uint64_t)v8, v9);
  }
  return result;
}

uint64_t sub_1CD54E8A4(unsigned int a1, uint64_t a2)
{
  uint64_t result = llvm::MachineRegisterInfo::getVRegDef(a2, a1);
  if (!result) {
    return 0;
  }
  int v3 = **(unsigned __int16 **)(result + 16);
  BOOL v4 = v3 == 69 || v3 == 0;
  if (!v4 || *(_DWORD *)(result + 40) >= 2u) {
    return 0;
  }
  return result;
}

void sub_1CD54E8F0(llvm::MachineInstr *a1, int a2, uint64_t a3)
{
  uint64_t v5 = *(llvm::MachineFunction **)(a3 + 32);
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  v6[0] = 0;
  v6[1] = a2;
  uint64_t v9 = 0;
  llvm::MachineInstr::addOperand(a1, v5, (const llvm::MachineOperand *)v6);
  uint64_t v7 = 0;
  uint64_t v8 = a3;
  v6[0] = 4;
  llvm::MachineInstr::addOperand(a1, v5, (const llvm::MachineOperand *)v6);
}

uint64_t sub_1CD54E95C(uint64_t a1, uint64_t a2)
{
  v22[20] = *MEMORY[0x1E4F143B8];
  v22[0] = a2;
  uint64_t v21 = 0x1400000001;
  uint64_t v3 = a1 + 24;
  uint64_t v19 = *(void *)(a2 + 24);
  unsigned int v20 = v22;
  *(void *)(sub_1CD467E2C(a1 + 24, &v19)[1] + 56) = a2;
  unsigned int v4 = v21;
  if (!v21)
  {
LABEL_22:
    uint64_t v17 = 1;
    goto LABEL_23;
  }
  while (1)
  {
    uint64_t v5 = *((void *)v20 + --v4);
    LODWORD(v21) = v4;
    int v6 = *(_DWORD *)(v5 + 40);
    if (v6 != 1) {
      break;
    }
LABEL_3:
    if (!v4) {
      goto LABEL_22;
    }
  }
  uint64_t v7 = 1;
  while (1)
  {
    uint64_t v8 = *(void *)(v5 + 32);
    unsigned int v9 = *(_DWORD *)(v8 + 32 * v7 + 4);
    uint64_t v19 = *(void *)(v8 + 32 * (v7 + 1) + 16);
    uint64_t v10 = *(void *)(sub_1CD467E2C(v3, &v19)[1] + 16);
    int v11 = *(_DWORD *)(v10 + 8);
    if (v11)
    {
      if (v9 != v11) {
        break;
      }
      goto LABEL_8;
    }
    uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(*(void *)(*(void *)a1 + 32), v9);
    if (!VRegDef) {
      break;
    }
    int v14 = **(unsigned __int16 **)(VRegDef + 16);
    BOOL v15 = v14 == 69 || v14 == 0;
    if (!v15 || *(void *)(VRegDef + 24) != *(void *)v10) {
      break;
    }
    uint64_t v16 = *(void *)(v10 + 56);
    if (v16)
    {
      if (VRegDef != v16) {
        break;
      }
    }
    else
    {
      *(void *)(v10 + 56) = VRegDef;
      if (v21 >= (unint64_t)HIDWORD(v21)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((void *)v20 + v21) = VRegDef;
      LODWORD(v21) = v21 + 1;
    }
LABEL_8:
    int v12 = v7 + 2;
    uint64_t v7 = (v7 + 2);
    if (v6 == v12)
    {
      unsigned int v4 = v21;
      goto LABEL_3;
    }
  }
  uint64_t v17 = 0;
LABEL_23:
  if (v20 != v22) {
    free(v20);
  }
  return v17;
}

void *sub_1CD54EB50(void *result, uint64_t a2, unsigned int a3)
{
  if (a3)
  {
    unsigned int v4 = result;
    uint64_t v5 = (uint64_t)(result + 3);
    uint64_t v6 = 8 * a3;
    do
    {
      uint64_t v7 = *(void *)(*(void *)a2 + 56);
      if (v7)
      {
        uint64_t v9 = *(void *)(v7 + 24);
        uint64_t v8 = *(void *)(v7 + 32);
        uint64_t v11 = v9;
        int v10 = *(_DWORD *)(v8 + 4);
        *((_DWORD *)sub_1CD40EB18(v4[1], &v11) + 2) = v10;
        uint64_t result = sub_1CD467E2C(v5, &v11);
        *(_DWORD *)(result[1] + 8) = v10;
      }
      a2 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  return result;
}

void llvm::initializeStripDebugMachineModulePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD0B88, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3A82EC;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD0B88, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createStripDebugMachineModulePass(llvm *this)
{
}

void llvm::initializeMachineTraceMetricsPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD0B90, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3A8958;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD0B90, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

double llvm::MachineTraceMetrics::MachineTraceMetrics(llvm::MachineTraceMetrics *this)
{
  sub_1CB8483A0((uint64_t)this, (uint64_t)&llvm::MachineTraceMetrics::ID);
  *(void *)uint64_t v1 = &unk_1F260FE78;
  *(void *)(v1 + 280) = 0;
  *(_OWORD *)(v1 + 248) = 0u;
  *(_OWORD *)(v1 + 264) = 0u;
  *(_OWORD *)(v1 + 320) = xmmword_1CFB28DF0;
  *(_OWORD *)(v1 + 336) = unk_1CFB28E00;
  *(void *)(v1 + 352) = 0;
  *(_OWORD *)(v1 + 288) = llvm::MCSchedModel::Default;
  *(_OWORD *)(v1 + 304) = unk_1CFB28DE0;
  *(_OWORD *)(v1 + 376) = unk_1CFB28DE0;
  *(_OWORD *)(v1 + 392) = xmmword_1CFB28DF0;
  *(_OWORD *)(v1 + 408) = unk_1CFB28E00;
  *(void *)(v1 + 424) = 0;
  *(_OWORD *)(v1 + 360) = llvm::MCSchedModel::Default;
  *(_OWORD *)(v1 + 448) = 0u;
  *(_OWORD *)(v1 + 464) = 0u;
  *(_OWORD *)(v1 + 432) = 0u;
  *(void *)(v1 + 480) = v1 + 496;
  *(void *)(v1 + 488) = 0x1000000000;
  *(void *)(v1 + 560) = 0;
  *(void *)(v1 + 568) = v1 + 584;
  *(void *)&double result = 0x400000000;
  *(void *)(v1 + 576) = 0x400000000;
  *(void *)(v1 + 616) = v1 + 632;
  *(void *)(v1 + 632) = 0;
  *(void *)(v1 + 624) = 0;
  return result;
}

void llvm::MachineTraceMetrics::getAnalysisUsage(llvm::MachineTraceMetrics *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBranchProbabilityInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineLoopInfo::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

uint64_t llvm::MachineTraceMetrics::runOnMachineFunction(llvm::MachineTraceMetrics *this, llvm::MachineFunction *a2)
{
  *((void *)this + 31) = a2;
  uint64_t v3 = (const llvm::TargetSubtargetInfo *)*((void *)a2 + 2);
  *((void *)this + 32) = (*(uint64_t (**)(const llvm::TargetSubtargetInfo *))(*(void *)v3 + 104))(v3);
  uint64_t v4 = (*(uint64_t (**)(const llvm::TargetSubtargetInfo *))(*(void *)v3 + 176))(v3);
  uint64_t v5 = *(void *)(*((void *)this + 31) + 40);
  *((void *)this + 33) = v4;
  *((void *)this + 34) = v5;
  uint64_t v6 = (uint64_t *)*((void *)this + 1);
  uint64_t v7 = *v6;
  uint64_t v8 = v6[1];
  if (v7 == v8)
  {
LABEL_2:
    uint64_t v9 = 0;
  }
  else
  {
    while (*(char **)v7 != llvm::MachineLoopInfo::ID)
    {
      v7 += 16;
      if (v7 == v8) {
        goto LABEL_2;
      }
    }
    uint64_t v9 = *(void *)(v7 + 8);
  }
  *((void *)this + 35) = (*(uint64_t (**)(uint64_t, char *))(*(void *)v9 + 96))(v9, llvm::MachineLoopInfo::ID);
  llvm::TargetSchedModel::init((llvm::MachineTraceMetrics *)((char *)this + 288), v3);
  sub_1CD550754((uint64_t)this + 568, ((*(void *)(*((void *)this + 31) + 112) - *(void *)(*((void *)this + 31) + 104)) >> 3));
  sub_1CBB1173C((uint64_t)this + 616, *((_DWORD *)this + 84)* ((*(void *)(*((void *)this + 31) + 112) - *(void *)(*((void *)this + 31) + 104)) >> 3));
  return 0;
}

uint64_t llvm::MachineTraceMetrics::releaseMemory(llvm::MachineTraceMetrics *this)
{
  *((void *)this + 31) = 0;
  *((_DWORD *)this + 144) = 0;
  uint64_t result = *((void *)this + 79);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
  }
  *((void *)this + 79) = 0;
  return result;
}

_DWORD *llvm::MachineTraceMetrics::getResources(llvm::MachineTraceMetrics *this, const llvm::MachineBasicBlock *a2)
{
  unsigned char v27[16] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 71) + 8 * *((int *)a2 + 6);
  uint64_t v3 = (_DWORD *)v2;
  if (*(_DWORD *)v2 != -1) {
    return v3;
  }
  *(unsigned char *)(v2 + 4) = 0;
  uint64_t v7 = (unsigned char *)(v2 + 4);
  unint64_t v8 = *((unsigned int *)this + 84);
  v26[0] = v27;
  v26[1] = (void *)0x2000000000;
  sub_1CB9CDA9C((uint64_t)v26, v8, 0);
  uint64_t v9 = *((void *)a2 + 7);
  if ((const llvm::MachineBasicBlock *)v9 != (const llvm::MachineBasicBlock *)((char *)a2 + 48))
  {
    int v10 = 0;
    while (1)
    {
      if (sub_1CB834754(v9)) {
        goto LABEL_6;
      }
      if ((*(_WORD *)(v9 + 44) & 0xC) != 0 && (*(_WORD *)(v9 + 44) & 4) == 0) {
        break;
      }
      if ((*(unsigned char *)(*(void *)(v9 + 16) + 8) & 0x80) != 0) {
        goto LABEL_15;
      }
LABEL_16:
      ++v10;
      if (!llvm::TargetSchedModel::hasInstrSchedModel((llvm::MachineTraceMetrics *)((char *)this + 288))) {
        goto LABEL_18;
      }
      int v12 = (unsigned __int16 *)llvm::TargetSchedModel::resolveSchedClass((llvm::MachineTraceMetrics *)((char *)this + 288), (const llvm::MachineInstr *)v9);
      if ((~v12[4] & 0x1FFF) == 0 || !v12[6]) {
        goto LABEL_18;
      }
      int v13 = v26[0];
      uint64_t v14 = 4 * v12[6];
      BOOL v15 = (unsigned __int16 *)(*(void *)(*((void *)this + 58) + 136) + 4 * v12[5] + 2);
      do
      {
        uint64_t v16 = *(v15 - 1);
        int v17 = *v15;
        v15 += 2;
        v13[v16] += v17;
        v14 -= 4;
      }
      while (v14);
LABEL_6:
      if (!v9) {
        goto LABEL_21;
      }
LABEL_18:
      if ((*(unsigned char *)v9 & 4) == 0)
      {
LABEL_21:
        while ((*(_WORD *)(v9 + 44) & 8) != 0)
          uint64_t v9 = *(void *)(v9 + 8);
      }
      uint64_t v9 = *(void *)(v9 + 8);
      if ((const llvm::MachineBasicBlock *)v9 == (const llvm::MachineBasicBlock *)((char *)a2 + 48)) {
        goto LABEL_29;
      }
    }
    if (!llvm::MachineInstr::hasPropertyInBundle(v9, 128, 1)) {
      goto LABEL_16;
    }
LABEL_15:
    unsigned char *v7 = 1;
    goto LABEL_16;
  }
  int v10 = 0;
LABEL_29:
  *uint64_t v3 = v10;
  uint64_t v18 = v26[0];
  if (v8)
  {
    unsigned int v19 = *((_DWORD *)a2 + 6) * v8;
    unsigned int v20 = (int *)*((void *)this + 60);
    uint64_t v21 = *((void *)this + 77);
    uint64_t v22 = (int *)v26[0];
    do
    {
      int v24 = *v22++;
      int v23 = v24;
      int v25 = *v20++;
      *(_DWORD *)(v21 + 4 * v19++) = v25 * v23;
      --v8;
    }
    while (v8);
  }
  if (v18 != v27) {
    free(v18);
  }
  return v3;
}

llvm::MachineTraceMetrics::Ensemble *llvm::MachineTraceMetrics::Ensemble::Ensemble(llvm::MachineTraceMetrics::Ensemble *this, llvm::MachineTraceMetrics *a2)
{
  *(void *)this = &unk_1F260FF38;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 2) = 0x400000000;
  *((void *)this + 47) = 0;
  *((void *)this + 48) = 0;
  *((_DWORD *)this + 98) = 0;
  *((void *)this + 50) = (char *)this + 416;
  *((void *)this + 51) = 0;
  *((void *)this + 52) = (char *)this + 432;
  *((void *)this + 53) = 0;
  *((void *)this + 54) = a2;
  sub_1CD550850((uint64_t)this + 8, *((unsigned int *)a2 + 144));
  uint64_t v3 = *((void *)this + 54);
  unsigned int v4 = *(_DWORD *)(v3 + 336);
  sub_1CBB1173C((uint64_t)this + 400, *(unsigned int *)(v3 + 576) * (unint64_t)v4);
  sub_1CBB1173C((uint64_t)this + 416, *(unsigned int *)(*((void *)this + 54) + 576) * (unint64_t)v4);
  return this;
}

void llvm::MachineTraceMetrics::Ensemble::~Ensemble(llvm::MachineTraceMetrics::Ensemble *this)
{
  *(void *)this = &unk_1F260FF38;
  uint64_t v2 = (char *)this + 416;
  uint64_t v3 = (char *)*((void *)this + 52);
  if (v3 != (char *)this + 432) {
    free(v3);
  }
  unsigned int v4 = (char *)*((void *)this + 50);
  if (v4 != v2) {
    free(v4);
  }
  MEMORY[0x1D25D9CD0](*((void *)this + 47), 8);
  sub_1CD5507D8((char **)this + 1);
}

void llvm::MachineTraceMetrics::Ensemble::computeDepthResources(llvm::MachineTraceMetrics::Ensemble *this, const llvm::MachineBasicBlock *a2)
{
  int v3 = *((_DWORD *)a2 + 6);
  int v4 = v3;
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = (unsigned int *)*((void *)this + 54);
  uint64_t v7 = v6[84];
  unsigned int v8 = v7 * v3;
  uint64_t v9 = *(const llvm::MachineBasicBlock **)(v5 + 88 * v3);
  if (v9)
  {
    unsigned int v12 = *((_DWORD *)v9 + 6);
    Resources = llvm::MachineTraceMetrics::getResources((llvm::MachineTraceMetrics *)v6, v9);
    uint64_t v14 = v5 + 88 * v12;
    uint64_t v15 = v5 + 88 * v4;
    *(_DWORD *)(v15 + 24) = *Resources + *(_DWORD *)(v14 + 24);
    *(_DWORD *)(v15 + 16) = *(_DWORD *)(v14 + 16);
    if (v7)
    {
      uint64_t v16 = *((void *)this + 54);
      uint64_t v17 = *((void *)this + 50);
      unsigned int v18 = *(_DWORD *)(v16 + 336) * v12;
      unsigned int v19 = (int *)(v17 + 4 * v18);
      unsigned int v20 = (int *)(*(void *)(v16 + 616) + 4 * v18);
      do
      {
        int v22 = *v19++;
        int v21 = v22;
        int v23 = *v20++;
        *(_DWORD *)(v17 + 4 * v8++) = v23 + v21;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    uint64_t v10 = v5 + 88 * v3;
    *(_DWORD *)(v10 + 24) = 0;
    *(_DWORD *)(v10 + 16) = v3;
    if (v7)
    {
      uint64_t v11 = (void *)(*((void *)this + 50) + 4 * v8);
      bzero(v11, 4 * v7);
    }
  }
}

int *llvm::MachineTraceMetrics::Ensemble::computeHeightResources(llvm::MachineTraceMetrics::Ensemble *this, const llvm::MachineBasicBlock *a2)
{
  int v4 = *((_DWORD *)a2 + 6);
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = (unsigned int *)*((void *)this + 54);
  uint64_t v7 = v6[84];
  unsigned int v8 = v7 * v4;
  uint64_t result = llvm::MachineTraceMetrics::getResources((llvm::MachineTraceMetrics *)v6, a2);
  int v10 = *result;
  uint64_t v11 = v5 + 88 * v4;
  *(_DWORD *)(v11 + 28) = *result;
  unsigned int v12 = (_DWORD *)(v11 + 28);
  uint64_t v13 = *((void *)this + 54);
  int v14 = *((_DWORD *)a2 + 6);
  uint64_t v15 = *(unsigned int *)(v13 + 336);
  uint64_t v16 = (int *)(*(void *)(v13 + 616) + 4 * (v15 * v14));
  uint64_t v17 = *(void *)(v12 - 5);
  if (v17)
  {
    unsigned int v18 = *(_DWORD *)(v17 + 24);
    uint64_t v19 = *((void *)this + 1) + 88 * v18;
    *unsigned int v12 = *(_DWORD *)(v19 + 28) + v10;
    *(_DWORD *)(v5 + 88 * v4 + 20) = *(_DWORD *)(v19 + 20);
    if (v7)
    {
      uint64_t v20 = *((void *)this + 52);
      int v21 = (int *)(v20 + 4 * v18 * v15);
      do
      {
        int v23 = *v21++;
        int v22 = v23;
        int v24 = *v16++;
        *(_DWORD *)(v20 + 4 * v8++) = v24 + v22;
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    *(_DWORD *)(v5 + 88 * v4 + 20) = v14;
    if (v15)
    {
      int v25 = (void *)(*((void *)this + 52) + 4 * v8);
      return (int *)memmove(v25, v16, 4 * v15);
    }
  }
  return result;
}

uint64_t llvm::MachineTraceMetrics::getEnsemble(uint64_t a1, unsigned int a2)
{
  uint64_t result = *(void *)(a1 + 8 * a2 + 632);
  if (!result) {
    operator new();
  }
  return result;
}

void llvm::MachineTraceMetrics::invalidate(llvm::MachineTraceMetrics *this, const llvm::MachineBasicBlock *a2)
{
  *(_DWORD *)(*((void *)this + 71) + 8 * *((int *)a2 + 6)) = -1;
  uint64_t v2 = (llvm::MachineTraceMetrics::Ensemble *)*((void *)this + 79);
  if (v2) {
    llvm::MachineTraceMetrics::Ensemble::invalidate(v2, a2);
  }
}

void llvm::MachineTraceMetrics::Ensemble::invalidate(llvm::MachineTraceMetrics::Ensemble *this, const llvm::MachineBasicBlock *a2)
{
  v39[16] = *MEMORY[0x1E4F143B8];
  uint64_t v37 = v39;
  uint64_t v38 = 0x1000000000;
  int v3 = *((_DWORD *)a2 + 6);
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = v4 + 88 * v3;
  int v7 = *(_DWORD *)(v5 + 28);
  uint64_t v6 = (_DWORD *)(v5 + 28);
  if (v7 != -1)
  {
    _DWORD *v6 = -1;
    *(unsigned char *)(v4 + 88 * v3 + 33) = 0;
    v39[0] = a2;
    unsigned int v8 = 1;
    do
    {
      uint64_t v9 = *((void *)v37 + --v8);
      LODWORD(v38) = v8;
      int v10 = *(uint64_t **)(v9 + 64);
      uint64_t v11 = *(uint64_t **)(v9 + 72);
      while (v10 != v11)
      {
        uint64_t v12 = *v10;
        int v13 = *(_DWORD *)(*v10 + 24);
        uint64_t v14 = *((void *)this + 1);
        uint64_t v15 = v14 + 88 * v13;
        int v17 = *(_DWORD *)(v15 + 28);
        uint64_t v16 = (_DWORD *)(v15 + 28);
        if (v17 != -1 && *(void *)(v16 - 5) == v9)
        {
          _DWORD *v16 = -1;
          *(unsigned char *)(v14 + 88 * v13 + 33) = 0;
          if (v8 >= HIDWORD(v38)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v37 + v8) = v12;
          unsigned int v8 = v38 + 1;
          LODWORD(v38) = v38 + 1;
        }
        ++v10;
      }
    }
    while (v8);
  }
  uint64_t v19 = v4 + 88 * v3;
  int v21 = *(_DWORD *)(v19 + 24);
  uint64_t v20 = (_DWORD *)(v19 + 24);
  if (v21 != -1)
  {
    _DWORD *v20 = -1;
    *(unsigned char *)(v4 + 88 * v3 + 32) = 0;
    if (!HIDWORD(v38)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    *(void *)uint64_t v37 = a2;
    unsigned int v22 = v38 + 1;
    do
    {
      uint64_t v23 = *((void *)v37 + --v22);
      LODWORD(v38) = v22;
      int v24 = *(uint64_t **)(v23 + 88);
      int v25 = *(uint64_t **)(v23 + 96);
      while (v24 != v25)
      {
        uint64_t v26 = *v24;
        int v27 = *(_DWORD *)(*v24 + 24);
        uint64_t v28 = *((void *)this + 1);
        uint64_t v29 = v28 + 88 * v27;
        int v31 = *(_DWORD *)(v29 + 24);
        uint64_t v30 = (_DWORD *)(v29 + 24);
        if (v31 != -1 && *(void *)(v28 + 88 * v27) == v23)
        {
          *uint64_t v30 = -1;
          *(unsigned char *)(v28 + 88 * v27 + 32) = 0;
          if (v22 >= HIDWORD(v38)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *((void *)v37 + v22) = v26;
          unsigned int v22 = v38 + 1;
          LODWORD(v38) = v38 + 1;
        }
        ++v24;
      }
    }
    while (v22);
  }
  uint64_t v33 = (char *)a2 + 48;
  uint64_t v34 = *((void *)a2 + 7);
  if ((const llvm::MachineBasicBlock *)v34 != (const llvm::MachineBasicBlock *)((char *)a2 + 48))
  {
    do
    {
      uint64_t v35 = v34;
      uint64_t v36 = 0;
      if (sub_1CD3C8538((uint64_t *)this + 47, &v35, &v36))
      {
        *uint64_t v36 = -8192;
        *((int32x2_t *)this + 48) = vadd_s32(*(int32x2_t *)((char *)this + 384), (int32x2_t)0x1FFFFFFFFLL);
      }
      if (!v34 || (*(unsigned char *)v34 & 4) == 0)
      {
        while ((*(_WORD *)(v34 + 44) & 8) != 0)
          uint64_t v34 = *(void *)(v34 + 8);
      }
      uint64_t v34 = *(void *)(v34 + 8);
    }
    while ((char *)v34 != v33);
  }
  if (v37 != v39) {
    free(v37);
  }
}

void llvm::MachineTraceMetrics::Ensemble::computeTrace(llvm::MachineTraceMetrics::Ensemble *this, const llvm::MachineBasicBlock *a2)
{
  v54[16] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((unsigned int *)this + 4);
  uint64_t v4 = *(void *)(*((void *)this + 54) + 280);
  v24[0] = *((void *)this + 1);
  v24[1] = v3;
  int v25 = v29;
  uint64_t v26 = v29;
  uint64_t v27 = 8;
  int v28 = 0;
  v29[8] = v4;
  char v30 = 0;
  sub_1CBFF3560((llvm::SmallPtrSetImplBase *)&v25);
  int v31 = v24;
  unsigned int v32 = v34;
  uint64_t v33 = 0x800000000;
  if (sub_1CC3AB990(v24, 0, 0, (uint64_t)a2))
  {
    uint64_t v5 = *((void *)a2 + 8);
    if (v33 >= HIDWORD(v33)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v6 = (char *)v32 + 16 * v33;
    void *v6 = a2;
    v6[1] = v5;
    LODWORD(v33) = v33 + 1;
    sub_1CC3ABC40((uint64_t)&v31);
  }
  uint64_t v43 = v31;
  uint64_t v44 = v46;
  uint64_t v45 = 0x800000000;
  if (v33) {
    sub_1CC3ABD20((uint64_t)&v44, (uint64_t)&v32);
  }
  if (v32 != v34) {
    free(v32);
  }
  unsigned int v39 = v24;
  uint64_t v40 = v42;
  uint64_t v41 = 0x800000000;
  unsigned int v51 = v43;
  unsigned int v52 = v54;
  uint64_t v53 = 0x800000000;
  if (v45)
  {
    sub_1CC3AB820((uint64_t)&v52, (void **)&v44);
    unsigned int v47 = v39;
    uint64_t v48 = v50;
    uint64_t v49 = 0x800000000;
    if (v41) {
      sub_1CC3AB820((uint64_t)&v48, (void **)&v40);
    }
  }
  else
  {
    unsigned int v47 = v24;
    uint64_t v48 = v50;
    uint64_t v49 = 0x800000000;
  }
  int v31 = v51;
  unsigned int v32 = v34;
  uint64_t v33 = 0x800000000;
  if (v53) {
    sub_1CC3AB820((uint64_t)&v32, (void **)&v52);
  }
  uint64_t v35 = v47;
  uint64_t v36 = v38;
  uint64_t v37 = 0x800000000;
  if (v49) {
    sub_1CC3AB820((uint64_t)&v36, (void **)&v48);
  }
  if (v48 != v50) {
    free(v48);
  }
  if (v52 != v54) {
    free(v52);
  }
  if (v40 != v42) {
    free(v40);
  }
  if (v44 != v46) {
    free(v44);
  }
  unsigned int v51 = v31;
  unsigned int v52 = v54;
  uint64_t v53 = 0x800000000;
  if (v33) {
    sub_1CC3ABD20((uint64_t)&v52, (uint64_t)&v32);
  }
  unsigned int v47 = v35;
  uint64_t v48 = v50;
  uint64_t v49 = 0x800000000;
  if (v37) {
    sub_1CC3ABD20((uint64_t)&v48, (uint64_t)&v36);
  }
  while (1)
  {
    int v7 = v52;
    if (v53 != v49) {
      goto LABEL_92;
    }
    if (!v53) {
      break;
    }
    unsigned int v8 = v48;
    uint64_t v9 = v52;
    while (*v9 == *v8 && v9[1] == v8[1])
    {
      v9 += 2;
      v8 += 2;
      if (v9 == (void *)((char *)v52 + 16 * v53)) {
        goto LABEL_36;
      }
    }
LABEL_92:
    int v17 = (int *)*((void *)v52 + 2 * v53 - 2);
    uint64_t v18 = 88 * v17[6];
    uint64_t v19 = *((void *)this + 1);
    *(void *)(v19 + v18) = (**(uint64_t (***)(llvm::MachineTraceMetrics::Ensemble *, int *))this)(this, v17);
    llvm::MachineTraceMetrics::Ensemble::computeDepthResources(this, (const llvm::MachineBasicBlock *)v17);
    LODWORD(v53) = v53 - 1;
    if (v53) {
      sub_1CC3ABC40((uint64_t)&v51);
    }
  }
LABEL_36:
  if (v48 != v50)
  {
    free(v48);
    int v7 = v52;
  }
  if (v7 != v54) {
    free(v7);
  }
  if (v36 != v38) {
    free(v36);
  }
  if (v32 != v34) {
    free(v32);
  }
  char v30 = 1;
  sub_1CBFF3560((llvm::SmallPtrSetImplBase *)&v25);
  int v31 = v24;
  unsigned int v32 = v34;
  uint64_t v33 = 0x800000000;
  if (sub_1CC3AB990(v24, 0, 0, (uint64_t)a2))
  {
    uint64_t v11 = *((void *)a2 + 11);
    if (v33 >= HIDWORD(v33)) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v12 = (char *)v32 + 16 * v33;
    *uint64_t v12 = a2;
    v12[1] = v11;
    LODWORD(v33) = v33 + 1;
    sub_1CC3ABE30((uint64_t)&v31);
  }
  uint64_t v43 = v31;
  uint64_t v44 = v46;
  uint64_t v45 = 0x800000000;
  if (v33) {
    sub_1CC3ABD20((uint64_t)&v44, (uint64_t)&v32);
  }
  if (v32 != v34) {
    free(v32);
  }
  unsigned int v39 = v24;
  uint64_t v40 = v42;
  uint64_t v41 = 0x800000000;
  unsigned int v51 = v43;
  unsigned int v52 = v54;
  uint64_t v53 = 0x800000000;
  if (v45)
  {
    sub_1CC3AB820((uint64_t)&v52, (void **)&v44);
    unsigned int v47 = v39;
    uint64_t v48 = v50;
    uint64_t v49 = 0x800000000;
    if (v41) {
      sub_1CC3AB820((uint64_t)&v48, (void **)&v40);
    }
  }
  else
  {
    unsigned int v47 = v24;
    uint64_t v48 = v50;
    uint64_t v49 = 0x800000000;
  }
  int v31 = v51;
  unsigned int v32 = v34;
  uint64_t v33 = 0x800000000;
  if (v53) {
    sub_1CC3AB820((uint64_t)&v32, (void **)&v52);
  }
  uint64_t v35 = v47;
  uint64_t v36 = v38;
  uint64_t v37 = 0x800000000;
  if (v49) {
    sub_1CC3AB820((uint64_t)&v36, (void **)&v48);
  }
  if (v48 != v50) {
    free(v48);
  }
  if (v52 != v54) {
    free(v52);
  }
  if (v40 != v42) {
    free(v40);
  }
  if (v44 != v46) {
    free(v44);
  }
  unsigned int v51 = v31;
  unsigned int v52 = v54;
  uint64_t v53 = 0x800000000;
  if (v33) {
    sub_1CC3ABD20((uint64_t)&v52, (uint64_t)&v32);
  }
  unsigned int v47 = v35;
  uint64_t v48 = v50;
  uint64_t v49 = 0x800000000;
  if (v37) {
    sub_1CC3ABD20((uint64_t)&v48, (uint64_t)&v36);
  }
  while (2)
  {
    int v13 = v52;
    if (v53 != v49)
    {
LABEL_94:
      uint64_t v20 = (const llvm::MachineBasicBlock *)*((void *)v52 + 2 * v53 - 2);
      int v21 = *((_DWORD *)v20 + 6);
      uint64_t v22 = *((void *)this + 1);
      *(void *)(v22 + 88 * v21 + 8) = (*(uint64_t (**)(llvm::MachineTraceMetrics::Ensemble *, const llvm::MachineBasicBlock *))(*(void *)this + 8))(this, v20);
      llvm::MachineTraceMetrics::Ensemble::computeHeightResources(this, v20);
      LODWORD(v53) = v53 - 1;
      if (v53) {
        sub_1CC3ABE30((uint64_t)&v51);
      }
      continue;
    }
    break;
  }
  if (v53)
  {
    uint64_t v14 = v48;
    uint64_t v15 = v52;
    while (*v15 == *v14 && v15[1] == v14[1])
    {
      v15 += 2;
      v14 += 2;
      if (v15 == (void *)((char *)v52 + 16 * v53)) {
        goto LABEL_79;
      }
    }
    goto LABEL_94;
  }
LABEL_79:
  if (v48 != v50)
  {
    free(v48);
    int v13 = v52;
  }
  if (v13 != v54) {
    free(v13);
  }
  if (v36 != v38) {
    free(v36);
  }
  if (v32 != v34) {
    free(v32);
  }
  if (v26 != v25) {
    free(v26);
  }
}

void llvm::MachineTraceMetrics::Ensemble::updateDepths(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      llvm::MachineTraceMetrics::Ensemble::updateDepth(a1, a1[1] + 88 * *(int *)(*(void *)(v6 + 24) + 24), v6, a4);
      if ((*(unsigned char *)v6 & 4) == 0)
      {
        while ((*(_WORD *)(v6 + 44) & 8) != 0)
          uint64_t v6 = *(void *)(v6 + 8);
      }
      uint64_t v6 = *(void *)(v6 + 8);
    }
    while (v6 != a3);
  }
}

uint64_t llvm::MachineTraceMetrics::Ensemble::addLiveIns(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  if (a5)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    uint64_t v6 = *(unsigned int *)(*(void *)(a2 + 32) + 32 * a3 + 4);
    uint64_t v7 = 8 * a5;
    do
    {
      uint64_t v8 = *(void *)(a4 - 8 + v7);
      if (v8 == v5) {
        break;
      }
      uint64_t v9 = *(void *)(result + 8) + 88 * *(int *)(v8 + 24);
      unint64_t v10 = *(unsigned int *)(v9 + 48);
      if (v10 >= *(unsigned int *)(v9 + 52)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)(v9 + 40) + 8 * v10) = v6;
      ++*(_DWORD *)(v9 + 48);
      v7 -= 8;
    }
    while (v7);
  }
  return result;
}

llvm::MachineTraceMetrics::Ensemble *llvm::MachineTraceMetrics::Ensemble::getTrace(llvm::MachineTraceMetrics::Ensemble *this, const llvm::MachineBasicBlock *a2)
{
  int v4 = *((_DWORD *)a2 + 6);
  uint64_t v5 = *((void *)this + 1);
  if (*(_DWORD *)(v5 + 88 * v4 + 24) == -1 || *(_DWORD *)(v5 + 88 * v4 + 28) == -1) {
    llvm::MachineTraceMetrics::Ensemble::computeTrace(this, a2);
  }
  if (!*(unsigned char *)(v5 + 88 * v4 + 32)) {
    llvm::MachineTraceMetrics::Ensemble::computeInstrDepths(this, a2);
  }
  if (!*(unsigned char *)(v5 + 88 * v4 + 33)) {
    llvm::MachineTraceMetrics::Ensemble::computeInstrHeights(this, a2);
  }
  return this;
}

uint64_t llvm::MachineTraceMetrics::Trace::getInstrSlack(llvm::MachineTraceMetrics::Trace *this, const llvm::MachineInstr *a2)
{
  uint64_t v3 = (uint64_t *)(*(void *)this + 376);
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  int v4 = sub_1CD3C8538(v3, &v8, &v7);
  uint64_t v5 = 0;
  if (v4) {
    uint64_t v5 = *(void *)(v7 + 8);
  }
  return (*(_DWORD *)(*((void *)this + 1) + 36) - (HIDWORD(v5) + v5));
}

uint64_t llvm::MachineTraceMetrics::Trace::getPHIDepth(llvm::MachineTraceMetrics::Trace *this, const llvm::MachineInstr *a2)
{
  uint64_t v14[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*(void *)this + 432);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(v4 + 248) + 104)
                 + 0xFFFFFFFDD1745D18
                 * ((*((void *)this + 1) - *(void *)(*(void *)this + 8)) >> 3));
  v13[0] = v14;
  v13[1] = (void *)0x100000000;
  sub_1CC3A9324((uint64_t)a2, (uint64_t)v13, v5, *(void *)(v4 + 272));
  uint64_t v6 = (const llvm::MachineInstr **)v13[0];
  uint64_t v7 = *(void *)v13[0];
  uint64_t v8 = (uint64_t *)(*(void *)this + 376);
  uint64_t v11 = 0;
  uint64_t v12 = v7;
  if (sub_1CD3C8538(v8, &v12, &v11)) {
    uint64_t v9 = *(unsigned int *)(v11 + 8);
  }
  else {
    uint64_t v9 = 0;
  }
  if ((sub_1CB834754((uint64_t)*v6) & 1) == 0) {
    uint64_t v9 = llvm::TargetSchedModel::computeOperandLatency((llvm::TargetSchedModel *)(*(void *)(*(void *)this + 432) + 288), *v6, *((unsigned int *)v6 + 2), a2, *((unsigned int *)v6 + 3))+ v9;
  }
  if (v13[0] != v14) {
    free(v13[0]);
  }
  return v9;
}

uint64_t llvm::MachineTraceMetrics::Trace::getResourceLength(void *a1, const llvm::MachineBasicBlock **a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v8 = a2;
  unint64_t v10 = (void *)*a1;
  uint64_t v11 = a1[1];
  uint64_t v39 = *(void *)(*a1 + 432);
  uint64_t v12 = *(unsigned int *)(v39 + 336);
  uint64_t v13 = 8 * a3;
  if (v12)
  {
    uint64_t v37 = 8 * a3;
    uint64_t v16 = 0;
    unsigned int v17 = 0;
    uint64_t v36 = a1[1];
    unsigned int v18 = -1171354717 * ((unint64_t)(v11 - v10[1]) >> 3) * v12;
    uint64_t v19 = v10[50] + 4 * v18;
    uint64_t v20 = v10[52] + 4 * v18;
    do
    {
      int v21 = *(_DWORD *)(v20 + 4 * v16) + *(_DWORD *)(v19 + 4 * v16);
      if (a3)
      {
        uint64_t v22 = a2;
        uint64_t v23 = v37;
        do
        {
          uint64_t v24 = (uint64_t)*v22++;
          v21 += *(_DWORD *)(*(void *)(v39 + 616) + 4 * v16 + 4 * (*(_DWORD *)(v24 + 24) * v12));
          v23 -= 8;
        }
        while (v23);
      }
      int v25 = sub_1CC3AA4F0((uint64_t)a1, a4, a5, v16) + v21;
      unsigned int v26 = v25 - sub_1CC3AA4F0((uint64_t)a1, a6, a7, v16);
      if (v17 <= v26) {
        unsigned int v17 = v26;
      }
      ++v16;
    }
    while (v16 != v12);
    int v27 = v17 - 1;
    uint64_t v13 = v37;
    uint64_t v8 = a2;
    uint64_t v11 = v36;
  }
  else
  {
    int v27 = -1;
  }
  uint64_t v28 = v39;
  unsigned int v29 = *(_DWORD *)(v39 + 564);
  int v30 = *(_DWORD *)(v11 + 28) + *(_DWORD *)(v11 + 24);
  if (a3)
  {
    do
    {
      int v31 = *v8++;
      v30 += *llvm::MachineTraceMetrics::getResources(*(llvm::MachineTraceMetrics **)(*a1 + 432), v31);
      v13 -= 8;
    }
    while (v13);
    uint64_t v28 = *(void *)(*a1 + 432);
  }
  unsigned int v32 = v30 + a5 - a7;
  unsigned int v33 = *(_DWORD *)(v28 + 288);
  if (v33) {
    v32 /= v33;
  }
  unsigned int v34 = (v29 + v27) / v29;
  if (v32 <= v34) {
    return v34;
  }
  else {
    return v32;
  }
}

void sub_1CD5505B8(llvm::Pass *a1)
{
  sub_1CD5506C8(a1);

  JUMPOUT(0x1D25D9CE0);
}

void llvm::callDefaultCtor<llvm::MachineTraceMetrics>()
{
}

uint64_t sub_1CD55062C(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v12 = 0;
  uint64_t result = sub_1CBA0E618(a2, a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CBB268D8(a2, (uint64_t)a3, a3, v12);
    uint64_t v9 = (void *)result;
    *(void *)uint64_t result = *a3;
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 16 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void sub_1CD5506C8(llvm::Pass *a1)
{
  *(void *)a1 = &unk_1F260FE78;
  uint64_t v2 = (void *)*((void *)a1 + 77);
  if (v2 != (void *)((char *)a1 + 632)) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)a1 + 71);
  if (v3 != (void *)((char *)a1 + 584)) {
    free(v3);
  }
  uint64_t v4 = (void *)*((void *)a1 + 60);
  if (v4 != (void *)((char *)a1 + 496)) {
    free(v4);
  }

  sub_1CBA0E6AC(a1);
}

void sub_1CD550754(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      if (v2 != a2) {
        memset_pattern16((void *)(*(void *)a1 + 8 * v2), &unk_1CFAC7300, 8 * a2 - 8 * v2);
      }
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
}

char **sub_1CD5507D8(char **a1)
{
  unint64_t v2 = *a1;
  unsigned int v3 = *((_DWORD *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 88 * v3;
    do
    {
      uint64_t v5 = *(char **)&v2[v4 - 48];
      if (&v2[v4 - 32] != v5) {
        free(v5);
      }
      v4 -= 88;
    }
    while (v4);
    unint64_t v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD550850(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2 != a2)
  {
    int v3 = a2;
    if (v2 <= a2)
    {
      if (*(unsigned int *)(a1 + 12) < a2) {
        sub_1CD550940();
      }
      if (v2 != a2)
      {
        uint64_t v7 = *(void *)a1 + 88 * a2;
        uint64_t v8 = *(void *)a1 + 88 * v2;
        do
        {
          *(_OWORD *)(v8 + 32) = 0uLL;
          *(_OWORD *)(v8 + 48) = 0uLL;
          *(void *)(v8 + 80) = 0;
          *(_OWORD *)(v8 + 64) = 0uLL;
          *(_OWORD *)uint64_t v8 = 0uLL;
          *(_OWORD *)(v8 + 16) = 0uLL;
          *(void *)(v8 + 24) = -1;
          *(void *)(v8 + 40) = v8 + 56;
          *(_DWORD *)(v8 + 52) = 4;
          v8 += 88;
        }
        while (v8 != v7);
      }
    }
    else
    {
      uint64_t v5 = (void **)(*(void *)a1 + 88 * v2 - 48);
      uint64_t v6 = 88 * a2 - 88 * v2;
      do
      {
        if (v5 + 2 != *v5) {
          free(*v5);
        }
        v5 -= 11;
        v6 += 88;
      }
      while (v6);
    }
    *(_DWORD *)(a1 + 8) = v3;
  }
}

void sub_1CD550940()
{
}

void sub_1CD5509B0(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a1 + 88 * v2;
    uint64_t v6 = (void *)(a2 + 40);
    uint64_t v7 = v4 + 40;
    do
    {
      long long v8 = *(_OWORD *)(v7 - 40);
      uint64_t v9 = *(void *)(v7 - 8);
      *(_OWORD *)(v6 - 3) = *(_OWORD *)(v7 - 24);
      *(_OWORD *)(v6 - 5) = v8;
      *(v6 - 1) = v9;
      void *v6 = v6 + 2;
      v6[1] = 0x400000000;
      if (*(_DWORD *)(v7 + 8)) {
        uint64_t v6 = (void *)sub_1CD41C56C((uint64_t)v6, v7);
      }
      uint64_t v10 = v7 - 40;
      v6 += 11;
      v7 += 88;
    }
    while (v10 + 88 != v5);
    unsigned int v11 = *((_DWORD *)a1 + 2);
    if (v11)
    {
      uint64_t v12 = *a1;
      uint64_t v13 = 88 * v11;
      do
      {
        uint64_t v14 = *(void **)(v12 + v13 - 48);
        if ((void *)(v12 + v13 - 32) != v14) {
          free(v14);
        }
        v13 -= 88;
      }
      while (v13);
    }
  }
}

_DWORD *sub_1CD550A88(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 208);
  unsigned int v5 = *(unsigned __int8 *)(v4 + v3);
  unsigned int v6 = *(_DWORD *)(a1 + 8);
  uint64_t v7 = *(void *)a1;
  if (v6 <= v5)
  {
LABEL_4:
    uint64_t result = (_DWORD *)(v7 + 24 * v6);
  }
  else
  {
    while (1)
    {
      uint64_t result = (_DWORD *)(v7 + 24 * v5);
      if (*result == v3) {
        break;
      }
      v5 += 256;
      if (v5 >= v6) {
        goto LABEL_4;
      }
    }
  }
  if (result == (_DWORD *)(v7 + 24 * v6))
  {
    *(unsigned char *)(v4 + v3) = v6;
    unint64_t v9 = sub_1CD483108(a1, (unint64_t)a2);
    uint64_t v10 = *(void *)a1 + 24 * *(unsigned int *)(a1 + 8);
    long long v11 = *(_OWORD *)v9;
    *(void *)(v10 + 16) = *(void *)(v9 + 16);
    *(_OWORD *)uint64_t v10 = v11;
    LODWORD(v10) = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v10;
    return (_DWORD *)(*(void *)a1 + 24 * v10 - 24);
  }
  return result;
}

void *sub_1CD550B40(uint64_t *a1, void *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  unsigned int v5 = v7;
  if ((v4 & 1) == 0)
  {
    unsigned int v5 = sub_1CD475D24((uint64_t)a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void llvm::initializeMachineVerifierPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD0BA0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3ABF10;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD0BA0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createMachineVerifierPass()
{
}

BOOL llvm::MachineFunction::verify(llvm::MachineFunction *this, llvm::Pass *a2, const char *a3, int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  v14[0] = a2;
  v14[1] = a3;
  v14[10] = v16;
  v14[11] = v16;
  v14[12] = 8;
  int v15 = 0;
  v16[8] = v17;
  void v16[9] = 0x600000000;
  v17[12] = 0;
  long long v18 = 0u;
  int v19 = 0;
  uint64_t v20 = v22;
  uint64_t v21 = 0x1000000000;
  v22[8] = v23;
  v22[9] = 0x1000000000;
  unsigned __int8 v23[8] = v24;
  v23[9] = 0x1000000000;
  v24[8] = v25;
  void v24[9] = 0x400000000;
  int v27 = 0;
  uint64_t v26 = 0;
  v25[2] = 0u;
  int v5 = sub_1CC3AC234((uint64_t)v14, (uint64_t)this);
  sub_1CC3B58BC((uint64_t)v14);
  if (a4 && v5)
  {
    long long v11 = "Found ";
    __int16 v12 = 259;
    __int16 v10 = 264;
    LODWORD(v9[0]) = v5;
    sub_1CD3E3950((uint64_t *)&v11, v9, (uint64_t)v13);
    uint64_t v7 = " machine code errors.";
    __int16 v8 = 259;
    sub_1CD3E3950(v13, (uint64_t *)&v7, (uint64_t)v14);
    llvm::report_fatal_error((llvm *)v14, (const llvm::Twine *)1);
  }
  return v5 == 0;
}

void sub_1CD550E1C(llvm::SmallPtrSetImplBase *this@<X1>, uint64_t a2@<X0>, void *a3@<X8>)
{
  sub_1CD520F14(&v5, *(void *)(*(void *)a2 + 328), this);
  char v4 = __p;
  *a3 = v5;
  a3[2] = 0;
  a3[3] = 0;
  a3[1] = 0;
  sub_1CBF340A8(a3 + 1, v4, v7, 0xAAAAAAAAAAAAAAABLL * ((v7 - v4) >> 3));
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
}

unsigned int *sub_1CD550E98(unsigned int *result, uint64_t a2, unsigned __int16 *a3, long long *a4)
{
  uint64_t v6 = *(void *)result;
  uint64_t v7 = result[2];
  if (*(void *)result + 4 * v7 == a2)
  {
    long long v26 = *(_OWORD *)a3;
    uint64_t v27 = *((void *)a3 + 2);
    long long v24 = *a4;
    uint64_t v25 = *((void *)a4 + 2);
    return (unsigned int *)sub_1CD55108C((uint64_t)result, (unsigned __int16 *)&v26, (uint64_t)&v24);
  }
  else
  {
    __int16 v8 = (unsigned __int16 *)*((void *)a3 + 1);
    unint64_t v9 = (unsigned __int16 *)*((void *)a4 + 1);
    if (v8 == v9)
    {
      unint64_t v10 = 0;
    }
    else
    {
      unint64_t v10 = 0;
      do
      {
        ++v10;
        if (!*v8++) {
          __int16 v8 = 0;
        }
      }
      while (v8 != v9);
    }
    uint64_t v12 = (a2 - v6) >> 2;
    if (v10 + v7 > result[3]) {
      llvm::SmallVectorBase<unsigned int>::grow_pod();
    }
    uint64_t v13 = (char *)(v6 + 4 * v12);
    uint64_t v14 = (char *)(v6 + 4 * v7);
    unint64_t v15 = (v14 - v13) >> 2;
    if (v15 >= v10)
    {
      uint64_t v23 = &v14[-4 * v10];
      sub_1CD462190((uint64_t)result, v23, (char *)(v6 + 4 * v7));
      if (v23 != v13) {
        memmove(&v14[-(v23 - v13)], v13, v23 - v13);
      }
      long long v29 = *(_OWORD *)a3;
      uint64_t v30 = *((void *)a3 + 2);
      return (unsigned int *)sub_1CC3BA81C((uint64_t)v28, (unsigned __int16 *)&v29, *((unsigned __int16 **)a4 + 1), v13);
    }
    else
    {
      result[2] = v7 + v10;
      if (v12 == v7)
      {
        int v16 = *a3;
        unsigned int v17 = (unsigned __int16 *)*((void *)a3 + 1);
        LOWORD(v18) = a3[8];
      }
      else
      {
        uint64_t result = (unsigned int *)memcpy((void *)(v6 + 4 * (v7 + v10) - 4 * v15), v13, v14 - v13);
        int v19 = *a3;
        unsigned int v17 = (unsigned __int16 *)*((void *)a3 + 1);
        LOWORD(v18) = a3[8];
        do
        {
          *(_DWORD *)uint64_t v13 = (unsigned __int16)v18;
          v13 += 4;
          int v20 = *v17++;
          int v18 = v20 + v19;
          *a3 = v20 + v19;
          if (!v20) {
            unsigned int v17 = 0;
          }
          a3[8] = v18;
          int v19 = v18;
          --v15;
        }
        while (v15);
        *((void *)a3 + 1) = v17;
        int v16 = v18;
      }
      uint64_t v21 = (unsigned __int16 *)*((void *)a4 + 1);
      while (v17 != v21)
      {
        *(_DWORD *)uint64_t v14 = (unsigned __int16)v18;
        v14 += 4;
        int v22 = *v17++;
        int v18 = v22 + v16;
        if (!v22) {
          unsigned int v17 = 0;
        }
        int v16 = v18;
      }
    }
  }
  return result;
}

uint64_t sub_1CD55108C(uint64_t result, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3 = (unsigned __int16 *)*((void *)a2 + 1);
  char v4 = *(unsigned __int16 **)(a3 + 8);
  if (v3 == v4)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = (unsigned __int16 *)*((void *)a2 + 1);
    do
    {
      ++v5;
      if (!*v6++) {
        uint64_t v6 = 0;
      }
    }
    while (v6 != v4);
  }
  uint64_t v8 = *(unsigned int *)(result + 8);
  if (v5 + v8 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (v3 != v4)
  {
    unint64_t v9 = (_DWORD *)(*(void *)result + 4 * v8);
    LOWORD(v10) = a2[8];
    int v11 = *a2;
    do
    {
      *v9++ = (unsigned __int16)v10;
      int v12 = *v3++;
      int v10 = v12 + v11;
      if (!v12) {
        uint64_t v3 = 0;
      }
      int v11 = v10;
    }
    while (v3 != v4);
  }
  *(_DWORD *)(result + 8) = v8 + v5;
  return result;
}

_DWORD *sub_1CD551164(uint64_t a1, uint64_t a2, int *a3, void *a4)
{
  unsigned int v8 = *(_DWORD *)(a2 + 16);
  if (!v8)
  {
    uint64_t v14 = 0;
LABEL_6:
    uint64_t result = sub_1CD551254(a2, a3, v14);
    _DWORD *result = *a3;
    *((void *)result + 1) = *a4;
    uint64_t v9 = *(void *)a2;
    unsigned int v8 = *(_DWORD *)(a2 + 16);
    char v13 = 1;
    goto LABEL_4;
  }
  uint64_t v9 = *(void *)a2;
  unsigned int v10 = (37 * *a3) & (v8 - 1);
  uint64_t result = (_DWORD *)(*(void *)a2 + 16 * v10);
  int v12 = *result;
  if (*a3 != *result)
  {
    unint64_t v15 = 0;
    int v16 = 1;
    while (v12 != -1)
    {
      if (v15) {
        BOOL v17 = 0;
      }
      else {
        BOOL v17 = v12 == -2;
      }
      if (v17) {
        unint64_t v15 = result;
      }
      unsigned int v18 = v10 + v16++;
      unsigned int v10 = v18 & (v8 - 1);
      uint64_t result = (_DWORD *)(v9 + 16 * v10);
      int v12 = *result;
      if (*a3 == *result) {
        goto LABEL_3;
      }
    }
    if (v15) {
      uint64_t v14 = v15;
    }
    else {
      uint64_t v14 = result;
    }
    goto LABEL_6;
  }
LABEL_3:
  char v13 = 0;
LABEL_4:
  *(void *)a1 = result;
  *(void *)(a1 + 8) = v9 + 16 * v8;
  *(unsigned char *)(a1 + 16) = v13;
  return result;
}

_DWORD *sub_1CD551254(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    sub_1CD48BFE4(a1, 2 * v6);
    int v7 = *a2;
    int v9 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v10 = (37 * *a2) & v9;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
    int v11 = *a3;
    if (*a2 != *a3)
    {
      int v12 = 0;
      int v13 = 1;
      while (v11 != -1)
      {
        if (v12) {
          BOOL v14 = 0;
        }
        else {
          BOOL v14 = v11 == -2;
        }
        if (v14) {
          int v12 = a3;
        }
        unsigned int v15 = v10 + v13++;
        unsigned int v10 = v15 & v9;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v10);
        int v11 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
      goto LABEL_20;
    }
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      int v7 = *a3;
      goto LABEL_4;
    }
    sub_1CD48BFE4(a1, v6);
    int v7 = *a2;
    int v16 = *(_DWORD *)(a1 + 16) - 1;
    unsigned int v17 = (37 * *a2) & v16;
    a3 = (_DWORD *)(*(void *)a1 + 16 * v17);
    int v18 = *a3;
    if (*a2 != *a3)
    {
      int v12 = 0;
      int v19 = 1;
      while (v18 != -1)
      {
        if (v12) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v18 == -2;
        }
        if (v20) {
          int v12 = a3;
        }
        unsigned int v21 = v17 + v19++;
        unsigned int v17 = v21 & v16;
        a3 = (_DWORD *)(*(void *)a1 + 16 * v17);
        int v18 = *a3;
        if (v7 == *a3) {
          goto LABEL_4;
        }
      }
LABEL_20:
      if (v12) {
        a3 = v12;
      }
      goto LABEL_3;
    }
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void sub_1CD5513CC(uint64_t a1, uint64_t a2)
{
  v14[16] = *MEMORY[0x1E4F143B8];
  sub_1CC252928((uint64_t)&v11, a2);
  v8[0] = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t v10 = 0;
  memset(v7, 0, sizeof(v7));
  char v4 = (char *)v7 + 8;
  int v5 = (char *)v7 + 8;
  uint64_t v6 = 8;
  v8[1] = (char *)v9 + 8;
  DWORD1(v9[0]) = 8;
  sub_1CC3BB060((uint64_t)&v11, (uint64_t)&v4, a1, v3);
  if (v8[1] != (char *)v9 + 8) {
    free(v8[1]);
  }
  if (v5 != v4) {
    free(v5);
  }
  if (v13 != v14) {
    free(v13);
  }
  if (v12 != v11) {
    free(v12);
  }
}

_DWORD *sub_1CD5514E0(_DWORD *result, int a2)
{
  if (a2)
  {
    unint64_t v2 = (4 * a2 / 3u + 1) | ((unint64_t)(4 * a2 / 3u + 1) >> 1);
    unint64_t v3 = v2 | (v2 >> 2) | ((v2 | (v2 >> 2)) >> 4);
    unsigned int v4 = ((v3 | (v3 >> 8)) >> 16) | v3 | (v3 >> 8);
    if (result[4] <= v4) {
      return sub_1CC3B7114((uint64_t)result, v4 + 1);
    }
  }
  return result;
}

void llvm::initializeMIRAddFSDiscriminatorsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD0BA8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3BE944;
    v4[1] = &v2;
    unint64_t v3 = v4;
    std::__call_once(&qword_1EBCD0BA8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createMIRAddFSDiscriminatorsPass()
{
}

uint64_t llvm::MIRAddFSDiscriminators::runOnMachineFunction(llvm::MIRAddFSDiscriminators *this, llvm::MachineFunction *a2)
{
  if (byte_1EBD064B8 && llvm::Function::isDebugInfoForProfiling(*(llvm::Function **)a2))
  {
    v61[0] = 0;
    v61[1] = 0;
    int v62 = 0;
    v59[0] = 0;
    v59[1] = 0;
    unsigned int v60 = 0;
    int v6 = *((_DWORD *)this + 64);
    if (v6 == 31) {
      int v7 = -1;
    }
    else {
      int v7 = ~(-1 << (v6 + 1));
    }
    int v8 = *((_DWORD *)this + 65);
    if (v8 == 31) {
      int v9 = -1;
    }
    else {
      int v9 = ~(-1 << (v8 + 1));
    }
    uint64_t v10 = (llvm::MachineFunction *)((char *)a2 + 320);
    int v11 = (llvm::MachineBasicBlock *)*((void *)a2 + 41);
    if (v11 != (llvm::MachineFunction *)((char *)a2 + 320))
    {
      unsigned int v47 = a2;
      char v48 = 0;
      int v49 = v9 ^ v7;
      unsigned int v50 = (llvm::MachineFunction *)((char *)a2 + 320);
      unsigned int v51 = this;
      do
      {
        for (uint64_t i = *((void *)v11 + 7);
              (llvm::MachineBasicBlock *)i != (llvm::MachineBasicBlock *)((char *)v11 + 48);
              uint64_t i = *(void *)(i + 8))
        {
          uint64_t v13 = llvm::DebugLoc::get((llvm::DebugLoc *)(i + 56));
          if (v13)
          {
            uint64_t v14 = v13;
            int v15 = *(_DWORD *)(v13 + 4);
            if (v15)
            {
              uint64_t v27 = *(void *)(v13 - 8 * *(unsigned int *)(v13 + 8));
              int v28 = *(unsigned char *)v27 == 19 ? *(_DWORD *)(v27 + 24) : 0;
              v56[0] = sub_1CC3BE9E0(v27);
              v56[1] = v29;
              int v57 = v15;
              int v58 = v28;
              uint64_t v30 = sub_1CD551CA4((uint64_t)v61, (uint64_t)v56);
              int v55 = v11;
              sub_1CD4201D0(v30 + 24, &v55, (uint64_t)&v63);
              if (*(_DWORD *)(v30 + 32) != 1)
              {
                int v31 = v63.__r_.__value_.__s.__data_[16];
                uint64_t v32 = sub_1CD552268((uint64_t)v59, (uint64_t)v56);
                int v33 = *(_DWORD *)(v32 + 24);
                if (v31) {
                  *(_DWORD *)(v32 + 24) = ++v33;
                }
                int v52 = *((_DWORD *)this + 64);
                std::to_string(&v63, *(_DWORD *)(v14 + 4));
                if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  unsigned int v34 = (int *)&v63;
                }
                else {
                  unsigned int v34 = (int *)v63.__r_.__value_.__r.__words[0];
                }
                if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  size_t size = *((unsigned char *)&v63.__r_.__value_.__s + 23) & 0x7F;
                }
                else {
                  size_t size = v63.__r_.__value_.__l.__size_;
                }
                uint64_t v36 = sub_1CC3BEA34(v34, size);
                if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v63.__r_.__value_.__l.__data_);
                }
                uint64_t Name = (int *)llvm::MachineBasicBlock::getName(v11);
                uint64_t v39 = sub_1CC3BEA34(Name, v38);
                uint64_t Subprogram = llvm::DILocalScope::getSubprogram(*(void *)(v14 - 8 * *(unsigned int *)(v14 + 8)));
                uint64_t v41 = *(void *)(Subprogram - 8 * *(unsigned int *)(Subprogram + 8) + 24);
                int v53 = v33;
                if (v41)
                {
                  uint64_t v44 = *(void **)(v41 + 8);
                  size_t v45 = *v44;
                  uint64_t v43 = (int *)(v44 + 3);
                  size_t v42 = v45;
                }
                else
                {
                  size_t v42 = 0;
                  uint64_t v43 = 0;
                }
                uint64_t v25 = v39 ^ v36 ^ sub_1CC3BEA34(v43, v42);
                if (*(_DWORD *)(v14 + 8) == 2)
                {
                  for (uint64_t j = *(void *)(v14 - 8); j; uint64_t j = *(void *)(j - 8))
                  {
                    std::to_string(&v63, *(_DWORD *)(j + 4));
                    if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      int v16 = (int *)&v63;
                    }
                    else {
                      int v16 = (int *)v63.__r_.__value_.__r.__words[0];
                    }
                    if ((v63.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      size_t v17 = *((unsigned char *)&v63.__r_.__value_.__s + 23) & 0x7F;
                    }
                    else {
                      size_t v17 = v63.__r_.__value_.__l.__size_;
                    }
                    int v18 = sub_1CC3BEA34(v16, v17);
                    if (SHIBYTE(v63.__r_.__value_.__r.__words[2]) < 0) {
                      operator delete(v63.__r_.__value_.__l.__data_);
                    }
                    uint64_t v19 = llvm::DILocalScope::getSubprogram(*(void *)(j - 8 * *(unsigned int *)(j + 8)));
                    uint64_t v20 = *(void *)(v19 - 8 * *(unsigned int *)(v19 + 8) + 24);
                    if (v20)
                    {
                      unsigned int v21 = *(void **)(v20 + 8);
                      size_t v24 = *v21;
                      int v22 = (int *)(v21 + 3);
                      size_t v23 = v24;
                    }
                    else
                    {
                      size_t v23 = 0;
                      int v22 = 0;
                    }
                    LODWORD(v25) = v18 ^ v25 ^ sub_1CC3BEA34(v22, v23);
                    if (*(_DWORD *)(j + 8) != 2) {
                      break;
                    }
                  }
                }
                uint64_t v46 = (const llvm::DILocation *)sub_1CD5519E8(v14, ((v53 << v52) + v25) & v49 | v28);
                uint64_t v10 = v50;
                this = v51;
                if (v46)
                {
                  llvm::DebugLoc::DebugLoc((llvm::DebugLoc *)&v54, v46);
                  sub_1CB8F69CC((unsigned __int8 **)(i + 56), (unsigned __int8 **)&v54);
                  unsigned int v4 = v54;
                  if (v54) {
                    llvm::MetadataTracking::untrack((uint64_t)&v54, (unsigned __int8 *)v54);
                  }
                  char v48 = 1;
                }
              }
            }
          }
          if (!i || (*(unsigned char *)i & 4) == 0)
          {
            while ((*(_WORD *)(i + 44) & 8) != 0)
              uint64_t i = *(void *)(i + 8);
          }
        }
        int v11 = (llvm::MachineBasicBlock *)*((void *)v11 + 1);
      }
      while (v11 != v10);
      if (v48) {
        llvm::sampleprofutil::createFSDiscriminatorVariable(*(llvm::Type ***)(*(void *)v47 + 40), v4);
      }
    }
    llvm::deallocate_buffer(v59[0], (void *)(32 * v60));
  }
  return 0;
}

uint64_t sub_1CD5519E8(uint64_t a1, int a2)
{
  unsigned int v4 = *(unsigned __int8 **)(a1 - 8 * *(unsigned int *)(a1 + 8));
  int v5 = *v4;
  uint64_t v6 = (uint64_t)v4;
  if (v5 == 19)
  {
    uint64_t v6 = *(void *)(a1 - 8 * *(unsigned int *)(a1 + 8));
    do
    {
      if (!*(_DWORD *)(v6 + 24)) {
        break;
      }
      uint64_t v6 = *(void *)(v6 - 8 * *(unsigned int *)(v6 + 8) + 8);
    }
    while (*(unsigned char *)v6 == 19);
  }
  uint64_t v7 = *(void *)(a1 + 16);
  int v8 = (void *)(v7 & 0xFFFFFFFFFFFFFFF8);
  if ((v7 & 4) != 0) {
    int v8 = (void *)*v8;
  }
  if (v5 != 15) {
    unsigned int v4 = *(unsigned __int8 **)&v4[-8 * *((unsigned int *)v4 + 2)];
  }
  unint64_t Impl = llvm::DILexicalBlockFile::getImpl(v8, v6, (uint64_t)v4, a2, 0, 1);
  uint64_t v10 = *(void *)(a1 + 16);
  int v11 = (void *)(v10 & 0xFFFFFFFFFFFFFFF8);
  if ((v10 & 4) != 0) {
    int v11 = (void *)*v11;
  }
  unsigned int v12 = *(unsigned __int16 *)(a1 + 2);
  unsigned int v13 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)(a1 + 8) == 2) {
    uint64_t v14 = *(void *)(a1 - 8);
  }
  else {
    uint64_t v14 = 0;
  }

  return llvm::DILocation::getImpl(v11, v13, v12, (uint64_t)Impl, v14, 0, 0, 1);
}

void sub_1CD551ACC(llvm::Pass *a1)
{
  sub_1CBA0E6AC(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CD551B04()
{
  return "Add FS discriminators in MIR";
}

void llvm::callDefaultCtor<llvm::MIRAddFSDiscriminators>()
{
}

BOOL sub_1CD551B74(BOOL result, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = result;
    long long v6 = xmmword_1CFAC4A20;
    uint64_t v7 = -1;
    long long v4 = xmmword_1CFAC6E20;
    uint64_t v5 = 0x100000001;
    uint64_t v3 = 48 * a2;
    do
    {
      uint64_t result = sub_1CD551C1C(v2, (uint64_t)&v6);
      if (!result)
      {
        uint64_t result = sub_1CD551C1C(v2, (uint64_t)&v4);
        if (!result) {
          llvm::deallocate_buffer(*(llvm **)(v2 + 24), (void *)(8 * *(unsigned int *)(v2 + 40)));
        }
      }
      v2 += 48;
      v3 -= 48;
    }
    while (v3);
  }
  return result;
}

BOOL sub_1CD551C1C(uint64_t a1, uint64_t a2)
{
  long long v4 = *(const void **)a1;
  uint64_t v5 = *(const void **)a2;
  if (v5 == (const void *)-2)
  {
    if (v4 != (const void *)-2) {
      return 0;
    }
  }
  else
  {
    if (v5 == (const void *)-1)
    {
      if (v4 == (const void *)-1) {
        return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16) && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20);
      }
      return 0;
    }
    size_t v7 = *(void *)(a2 + 8);
    if (*(void *)(a1 + 8) != v7 || v7 && memcmp(v4, v5, v7)) {
      return 0;
    }
  }
  return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16) && *(_DWORD *)(a1 + 20) == *(_DWORD *)(a2 + 20);
}

uint64_t sub_1CD551CA4(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD551D28(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD551F48(a1, a2, v7);
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
    *(_DWORD *)(v5 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(v5 + 20) = *(_DWORD *)(a2 + 20);
    *(void *)(v5 + 32) = 0;
    *(void *)(v5 + 40) = 0;
    *(void *)(v5 + 24) = 0;
  }
  return v5;
}

uint64_t sub_1CD551D28(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  if (a2)
  {
    long long v16 = xmmword_1CFAC4A20;
    uint64_t v17 = -1;
    long long v14 = xmmword_1CFAC6E20;
    uint64_t v15 = 0x100000001;
    int v8 = a2 - 1;
    unsigned int v9 = sub_1CD551E5C(a3) & (a2 - 1);
    uint64_t v10 = a1 + 48 * v9;
    if (sub_1CD551C1C(a3, v10))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      while (!sub_1CD551C1C(v10, (uint64_t)&v16))
      {
        if (sub_1CD551C1C(v10, (uint64_t)&v14) && v11 == 0) {
          uint64_t v11 = v10;
        }
        unsigned int v9 = (v9 + v12) & v8;
        uint64_t v10 = a1 + 48 * v9;
        BOOL v13 = sub_1CD551C1C(a3, v10);
        uint64_t result = 1;
        ++v12;
        if (v13) {
          goto LABEL_5;
        }
      }
      uint64_t result = 0;
      if (v11) {
        uint64_t v10 = v11;
      }
    }
LABEL_5:
    *a4 = v10;
  }
  else
  {
    uint64_t result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1CD551E5C(uint64_t a1)
{
  unint64_t HashValue = llvm::DenseMapInfo<llvm::StringRef,void>::getHashValue(*(void **)a1, *(void *)(a1 + 8));
  unsigned int v3 = sub_1CD551ED0(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  unint64_t v4 = (v3 | (HashValue << 32)) + ~((unint64_t)v3 << 32);
  unint64_t v5 = (v4 ^ (v4 >> 22)) + ~((v4 ^ (v4 >> 22)) << 13);
  unint64_t v6 = (9 * (v5 ^ (v5 >> 8))) ^ ((9 * (v5 ^ (v5 >> 8))) >> 15);
  return ((v6 + ~(v6 << 27)) >> 31) ^ (v6 + ~(v6 << 27));
}

uint64_t sub_1CD551ED0(int a1, int a2)
{
  unint64_t v2 = (((unint64_t)(37 * a2) << 32) - 1) ^ ((((unint64_t)(37 * a2) << 32) - 1) >> 22);
  unint64_t v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  unint64_t v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  unint64_t v5 = ((v4 >> 31) ^ v4 | ((unint64_t)(37 * a1) << 32))
     + ~((unint64_t)((v4 >> 31) ^ v4) << 32);
  unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
  unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
  return ((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27));
}

uint64_t sub_1CD551F48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD552020(a1, v6);
  *(void *)&long long v9 = 0;
  sub_1CD551D28(*(void *)a1, *(_DWORD *)(a1 + 16), a2, (uint64_t *)&v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  long long v9 = xmmword_1CFAC4A20;
  uint64_t v10 = -1;
  if (!sub_1CD551C1C(a3, (uint64_t)&v9)) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

char *sub_1CD552020(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)llvm::allocate_buffer(48 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD552110(a1, (uint64_t)v4, (uint64_t)v4 + 48 * v3);
    llvm::deallocate_buffer(v4, (void *)(48 * v3));
  }
  *(void *)(a1 + 8) = 0;
  int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = &result[48 * v10];
    do
    {
      *(_OWORD *)uint64_t result = xmmword_1CFAC4A20;
      *((void *)result + 2) = -1;
      result += 48;
    }
    while (result != v11);
  }
  return result;
}

uint64_t sub_1CD552110(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  unsigned int v6 = *(_DWORD *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)result;
    uint64_t v8 = *(void *)result + 48 * v6;
    do
    {
      *(_OWORD *)uint64_t v7 = xmmword_1CFAC4A20;
      *(void *)(v7 + 16) = -1;
      v7 += 48;
    }
    while (v7 != v8);
  }
  long long v14 = xmmword_1CFAC4A20;
  uint64_t v15 = -1;
  long long v12 = xmmword_1CFAC6E20;
  uint64_t v13 = 0x100000001;
  while (a2 != a3)
  {
    uint64_t result = sub_1CD551C1C(a2, (uint64_t)&v14);
    if ((result & 1) == 0)
    {
      uint64_t result = sub_1CD551C1C(a2, (uint64_t)&v12);
      if ((result & 1) == 0)
      {
        long long v16 = 0;
        sub_1CD551D28(*(void *)v5, *(_DWORD *)(v5 + 16), a2, (uint64_t *)&v16);
        long long v9 = v16;
        _OWORD *v16 = *(_OWORD *)a2;
        *((_DWORD *)v9 + 4) = *(_DWORD *)(a2 + 16);
        *((_DWORD *)v9 + 5) = *(_DWORD *)(a2 + 20);
        *((_DWORD *)v9 + 10) = 0;
        *((void *)v9 + 3) = 0;
        *((void *)v9 + 4) = 0;
        *((void *)v9 + 3) = *(void *)(a2 + 24);
        *(void *)(a2 + 24) = 0;
        *((_DWORD *)v9 + 8) = *(_DWORD *)(a2 + 32);
        *(_DWORD *)(a2 + 32) = 0;
        int v10 = *((_DWORD *)v9 + 9);
        *((_DWORD *)v9 + 9) = *(_DWORD *)(a2 + 36);
        *(_DWORD *)(a2 + 36) = v10;
        uint64_t v11 = *((unsigned int *)v9 + 10);
        *((_DWORD *)v9 + 10) = *(_DWORD *)(a2 + 40);
        *(_DWORD *)(a2 + 40) = v11;
        ++*(_DWORD *)(v5 + 8);
        llvm::deallocate_buffer(0, (void *)(8 * v11));
      }
    }
    a2 += 48;
  }
  return result;
}

uint64_t sub_1CD552268(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD5522E4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD552410(a1, a2, v7);
    *(_OWORD *)uint64_t v5 = *(_OWORD *)a2;
    *(_DWORD *)(v5 + 16) = *(_DWORD *)(a2 + 16);
    *(void *)(v5 + 20) = *(unsigned int *)(a2 + 20);
  }
  return v5;
}

uint64_t sub_1CD5522E4(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  if (a2)
  {
    long long v16 = xmmword_1CFAC4A20;
    uint64_t v17 = -1;
    long long v14 = xmmword_1CFAC6E20;
    uint64_t v15 = 0x100000001;
    unsigned int v8 = a2 - 1;
    uint64_t v9 = sub_1CD551E5C(a3) & (a2 - 1);
    uint64_t v10 = a1 + 32 * v9;
    if (sub_1CD551C1C(a3, v10))
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 1;
      while (!sub_1CD551C1C(v10, (uint64_t)&v16))
      {
        if (sub_1CD551C1C(v10, (uint64_t)&v14) && v11 == 0) {
          uint64_t v11 = v10;
        }
        uint64_t v9 = (v9 + v12) & v8;
        uint64_t v10 = a1 + 32 * v9;
        BOOL v13 = sub_1CD551C1C(a3, v10);
        uint64_t result = 1;
        ++v12;
        if (v13) {
          goto LABEL_5;
        }
      }
      uint64_t result = 0;
      if (v11) {
        uint64_t v10 = v11;
      }
    }
LABEL_5:
    *a4 = v10;
  }
  else
  {
    uint64_t result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t sub_1CD552410(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD5524E8(a1, v6);
  *(void *)&long long v9 = 0;
  sub_1CD5522E4(*(void *)a1, *(_DWORD *)(a1 + 16), a2, (uint64_t *)&v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  long long v9 = xmmword_1CFAC4A20;
  uint64_t v10 = -1;
  if (!sub_1CD551C1C(a3, (uint64_t)&v9)) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

char *sub_1CD5524E8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)llvm::allocate_buffer(32 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD5525CC(a1, (uint64_t)v4, (uint64_t)v4 + 32 * v3);
    llvm::deallocate_buffer(v4, (void *)(32 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = &result[32 * v10];
    do
    {
      *(_OWORD *)uint64_t result = xmmword_1CFAC4A20;
      *((void *)result + 2) = -1;
      result += 32;
    }
    while (result != v11);
  }
  return result;
}

uint64_t sub_1CD5525CC(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)result;
    uint64_t v8 = *(void *)result + 32 * v6;
    do
    {
      *(_OWORD *)uint64_t v7 = xmmword_1CFAC4A20;
      *(void *)(v7 + 16) = -1;
      v7 += 32;
    }
    while (v7 != v8);
  }
  long long v12 = xmmword_1CFAC4A20;
  uint64_t v13 = -1;
  long long v10 = xmmword_1CFAC6E20;
  uint64_t v11 = 0x100000001;
  while (a2 != a3)
  {
    uint64_t result = sub_1CD551C1C(a2, (uint64_t)&v12);
    if ((result & 1) == 0)
    {
      uint64_t result = sub_1CD551C1C(a2, (uint64_t)&v10);
      if ((result & 1) == 0)
      {
        long long v14 = 0;
        uint64_t result = sub_1CD5522E4(*(void *)v5, *(_DWORD *)(v5 + 16), a2, (uint64_t *)&v14);
        long long v9 = v14;
        *long long v14 = *(_OWORD *)a2;
        uint64_t v9[4] = *(_DWORD *)(a2 + 16);
        v9[5] = *(_DWORD *)(a2 + 20);
        v9[6] = *(_DWORD *)(a2 + 24);
        ++*(_DWORD *)(v5 + 8);
      }
    }
    a2 += 32;
  }
  return result;
}

void llvm::initializeMIRProfileLoaderPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD0BB0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3BEAB8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD0BB0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createMIRProfileLoaderPass()
{
}

uint64_t *llvm::MIRProfileLoader::setBranchProbs(uint64_t *this, llvm::MachineFunction *a2)
{
  unint64_t v2 = (char *)a2 + 320;
  uint64_t v3 = (char *)*((void *)a2 + 41);
  if (v3 != (char *)a2 + 320)
  {
    char v4 = (llvm::MachineBlockFrequencyInfo **)this;
    uint64_t v5 = (uint64_t)(this + 115);
    uint64_t v6 = this + 4;
    uint64_t v7 = (uint64_t)(this + 7);
    do
    {
      uint64_t v30 = v3;
      if (((*((void *)v3 + 12) - *((void *)v3 + 11)) & 0x7FFFFFFF0) != 0)
      {
        uint64_t v29 = 0;
        uint64_t v29 = sub_1CD467E2C(v5, (uint64_t *)&v30)[1];
        this = sub_1CD4D7004(v6, &v29);
        uint64_t v8 = (uint64_t *)*((void *)v3 + 11);
        long long v9 = (uint64_t *)*((void *)v3 + 12);
        if (v8 != v9)
        {
          unint64_t v10 = 0;
          do
          {
            uint64_t v11 = *v8++;
            uint64_t v27 = v3;
            uint64_t v28 = v11;
            this = sub_1CD553BAC(v7, (uint64_t *)&v27);
            v10 += this[2];
          }
          while (v8 != v9);
          if (v10)
          {
            if (HIDWORD(v10))
            {
              unint64_t v12 = v10 / 0xFFFFFFFF + 1;
              v10 /= (v10 / 0xFFFFFFFF) + 1;
            }
            else
            {
              LODWORD(v12) = 1;
            }
            uint64_t v13 = *((void *)v3 + 11);
            uint64_t v25 = (uint64_t *)*((void *)v3 + 12);
            if ((uint64_t *)v13 != v25)
            {
              unint64_t v23 = v12;
              size_t v24 = v6;
              long long v14 = (uint64_t *)*((void *)v3 + 11);
              do
              {
                uint64_t v15 = v5;
                uint64_t v16 = *v14;
                uint64_t v27 = v3;
                uint64_t v28 = v16;
                uint64_t v17 = v7;
                int v18 = sub_1CD553BAC(v7, (uint64_t *)&v27);
                uint64_t v19 = v4;
                unint64_t v20 = v18[2] / v23;
                uint64_t MBPI = llvm::MachineBlockFrequencyInfo::getMBPI(v4[143]);
                int EdgeProbability = llvm::MachineBranchProbabilityInfo::getEdgeProbability(MBPI, v3, v13);
                this = (uint64_t *)llvm::BranchProbability::BranchProbability(&v26, v20, v10);
                if (EdgeProbability != v26) {
                  this = llvm::MachineBasicBlock::setSuccProbability(v3, v13, v26);
                }
                ++v14;
                v13 += 8;
                uint64_t v5 = v15;
                char v4 = v19;
                uint64_t v6 = v24;
                uint64_t v7 = v17;
              }
              while (v14 != v25);
            }
          }
        }
      }
      uint64_t v3 = (char *)*((void *)v3 + 1);
    }
    while (v3 != v2);
  }
  return this;
}

uint64_t llvm::MIRProfileLoader::doInitialization(llvm::MIRProfileLoader *this, const llvm::MemoryBuffer **a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  char v4 = *a2;
  uint64_t v5 = (long long *)((char *)this + 1072);
  if (*((char *)this + 1095) < 0)
  {
    sub_1CB8BDF7C((uint64_t)&v34, *((const void **)this + 134), *((void *)this + 135));
  }
  else
  {
    long long v34 = *v5;
    uint64_t v35 = *((void *)this + 136);
  }
  uint64_t v6 = *((void *)this + 140);
  if (*((char *)this + 1119) < 0)
  {
    sub_1CB8BDF7C((uint64_t)&__p, *((const void **)this + 137), *((void *)this + 138));
  }
  else
  {
    long long __p = *(_OWORD *)((char *)this + 1096);
    uint64_t v33 = *((void *)this + 139);
  }
  llvm::sampleprof::SampleProfileReader::create((uint64_t)&v34, v4, v6, (uint64_t)&__p, (uint64_t)&v36);
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v35) < 0) {
    operator delete((void *)v34);
  }
  if (v37)
  {
    uint64_t v7 = *(void *)&v36.__val_;
    std::error_code v31 = v36;
    if (v36.__val_)
    {
      std::error_code::message(&v25, &v31);
      uint64_t v8 = std::string::insert(&v25, 0, "Could not open profile: ");
      std::string::size_type v9 = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)uint64_t v29 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      std::string::size_type v30 = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v25.__r_.__value_.__l.__data_);
      }
      char v10 = *((unsigned char *)this + 1095);
      BOOL v11 = v10 < 0;
      if (v10 >= 0) {
        std::string::size_type v12 = (std::string::size_type)v5;
      }
      else {
        std::string::size_type v12 = *((void *)this + 134);
      }
      uint64_t v13 = v10 & 0x7F;
      if (v11) {
        uint64_t v13 = *((void *)this + 135);
      }
      __int16 v24 = 260;
      unint64_t v23 = v29;
      LODWORD(v25.__r_.__value_.__r.__words[1]) = 8;
      v25.__r_.__value_.__s.__data_[12] = 0;
      v25.__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_1F2616770;
      v25.__r_.__value_.__r.__words[2] = v12;
      uint64_t v26 = v13;
      int v27 = 0;
      uint64_t v28 = &v23;
      llvm::LLVMContext::diagnose((uint64_t)v4, (const llvm::DiagnosticInfo *)&v25);
      if (SHIBYTE(v30) < 0) {
        operator delete(v29[0]);
      }
      uint64_t v14 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    std::system_category();
    uint64_t v7 = *(void *)&v36.__val_;
  }
  *(void *)&v36.__val_ = 0;
  uint64_t v17 = *((void *)this + 132);
  *((void *)this + 132) = v7;
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    uint64_t v7 = *((void *)this + 132);
  }
  *(void *)(v7 + 136) = a2;
  int v18 = (llvm *)sub_1CD552D00(*((llvm::LLVMContext ***)this + 132));
  int v19 = (int)v18;
  BOOL v22 = llvm::sampleprof_category(v18) == v20 && v19 == 0;
  *((unsigned char *)this + 1164) = v22;
  uint64_t v14 = 1;
LABEL_21:
  if ((v37 & 1) == 0)
  {
    uint64_t v15 = *(void *)&v36.__val_;
    *(void *)&v36.__val_ = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
  return v14;
}

unint64_t sub_1CD552D00(llvm::LLVMContext **a1)
{
  uint64_t v2 = (*((uint64_t (**)(llvm::LLVMContext **))*a1 + 3))(a1);
  if (v2)
  {
    unint64_t v3 = v2 & 0xFFFFFFFF00000000;
  }
  else
  {
    uint64_t v5 = a1[14];
    if (v5) {
      llvm::sampleprof::SampleProfileReaderItaniumRemapper::applyRemapping(v5, a1[6]);
    }
    uint64_t v6 = (llvm *)(*((uint64_t (**)(llvm::LLVMContext **))*a1 + 9))(a1);
    llvm::sampleprof::FunctionSamples::UseMD5 = (char)v6;
    llvm::sampleprof_category(v6);
    unint64_t v3 = 0;
    LODWORD(v2) = 0;
  }
  return v2 | v3;
}

uint64_t llvm::MIRProfileLoader::runOnFunction(llvm::MIRProfileLoader *this, llvm::Function **a2)
{
  char v4 = *a2;
  sub_1CD552E88((uint64_t)this);
  uint64_t v5 = *((void *)this + 132);
  uint64_t v6 = sub_1CD553864(v4);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5 + 40))(v5, v6, v7);
  *((void *)this + 133) = v8;
  if (!v8 || !*(void *)(v8 + 56) || !sub_1CD552F00(*a2)) {
    return 0;
  }
  v11[0] = 0;
  v11[1] = 0;
  int v12 = 0;
  uint64_t v9 = sub_1CD552FE4(this, a2, (uint64_t)v11);
  llvm::MIRProfileLoader::setBranchProbs((uint64_t *)this, (llvm::MachineFunction *)a2);
  MEMORY[0x1D25D9CD0](v11[0], 8);
  return v9;
}

void sub_1CD552E88(uint64_t a1)
{
  *(_DWORD *)(a1 + 376) = 0;
  sub_1CD40B1BC(*(void **)(a1 + 904));
  *(void *)(a1 + 896) = a1 + 904;
  *(void *)(a1 + 912) = 0;
  *(void *)(a1 + 904) = 0;
  sub_1CD3C7F68((_DWORD *)(a1 + 920));
  sub_1CD553FD0((_DWORD *)(a1 + 968));
  sub_1CD553FD0((_DWORD *)(a1 + 992));
  sub_1CD5541B0((_DWORD *)(a1 + 1016));
  *(void *)(a1 + 1040) = 0;
}

uint64_t sub_1CD552F00(llvm::Function *a1)
{
  uint64_t Subprogram = llvm::Function::getSubprogram(a1);
  if (Subprogram) {
    return *(unsigned int *)(Subprogram + 24);
  }
  if (!byte_1EBD0CAD8)
  {
    uint64_t v4 = **(void **)a1;
    __int16 v9 = 1283;
    v8[0] = (uint64_t)"No debug information found in function ";
    uint64_t v8[2] = (uint64_t)llvm::Value::getName(a1);
    _OWORD v8[3] = v5;
    uint64_t v6 = ": Function profile not used";
    __int16 v7 = 259;
    sub_1CB8F1E58(v8, (uint64_t *)&v6, (uint64_t)v10);
    int v12 = 8;
    char v13 = 1;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    BOOL v11 = &unk_1F2616770;
    int v16 = 0;
    uint64_t v17 = v10;
    llvm::LLVMContext::diagnose(v4, (const llvm::DiagnosticInfo *)&v11);
  }
  return 0;
}

uint64_t sub_1CD552FE4(void *a1, llvm::Function **a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a3 + 8);
  unsigned int v7 = sub_1CD554374((uint64_t)a1, (uint64_t)a2);
  if (v6) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = v7;
  }
  if (v8 == 1)
  {
    sub_1CD55444C((uint64_t)a1, a2, a3);
    sub_1CD5544C0((uint64_t)a1, (uint64_t)a2);
    sub_1CD554724(a1, (uint64_t)a2, a3);
  }
  return v8;
}

void llvm::MIRProfileLoaderPass::MIRProfileLoaderPass(uint64_t a1, long long *a2, uint64_t a3, int a4, atomic_uint **a5)
{
  sub_1CB8483A0(a1, (uint64_t)&llvm::MIRProfileLoaderPass::ID);
  void *v9 = &unk_1F2610128;
  uint64_t v10 = (uint64_t)(v9 + 32);
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(v10, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v11 = *a2;
    *(void *)(v10 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v10 = v11;
  }
  *(_DWORD *)(a1 + 280) = a4;
  *(void *)(a1 + 296) = 0;
  int v12 = (atomic_uint **)(a1 + 312);
  *(void *)(a1 + 312) = 0;
  int v13 = 6 * a4 + 2;
  if (!a4) {
    int v13 = 0;
  }
  *(_DWORD *)(a1 + 284) = v13;
  *(_DWORD *)(a1 + 288) = 6 * a4 + 7;
  uint64_t v14 = *a5;
  if (*a5)
  {
    *a5 = 0;
  }
  else
  {
    llvm::vfs::getRealFileSystem(&v16);
    uint64_t v14 = v16;
  }
  int v16 = *v12;
  uint64_t v15 = v16;
  *int v12 = v14;
  if (v15)
  {
    if (atomic_fetch_add(v15 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v15 + 8))(v15);
    }
  }
  sub_1CC3BEB80();
}

uint64_t llvm::MIRProfileLoaderPass::runOnMachineFunction(llvm::MIRProfileLoaderPass *this, llvm::MachineFunction *a2)
{
  if (!*(unsigned char *)(*((void *)this + 37) + 1164)) {
    return 0;
  }
  int v6 = (uint64_t *)*((void *)this + 1);
  uint64_t v7 = *v6;
  uint64_t v8 = v6[1];
  if (v7 == v8)
  {
LABEL_5:
    uint64_t v9 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v7 != &llvm::MachineBlockFrequencyInfo::ID)
    {
      v7 += 16;
      if (v7 == v8) {
        goto LABEL_5;
      }
    }
    uint64_t v9 = *(void *)(v7 + 8);
  }
  *((void *)this + 38) = (*(uint64_t (**)(uint64_t, void *))(*(void *)v9 + 96))(v9, &llvm::MachineBlockFrequencyInfo::ID);
  uint64_t v10 = (uint64_t *)*((void *)this + 1);
  uint64_t v11 = *v10;
  uint64_t v12 = v10[1];
  if (v11 == v12)
  {
LABEL_7:
    uint64_t v13 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v11 != &llvm::MachineDominatorTree::ID)
    {
      v11 += 16;
      if (v11 == v12) {
        goto LABEL_7;
      }
    }
    uint64_t v13 = *(void *)(v11 + 8);
  }
  uint64_t v14 = (void *)*((void *)this + 37);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 96))(v13, &llvm::MachineDominatorTree::ID);
  int v16 = (uint64_t *)*((void *)this + 1);
  uint64_t v17 = *v16;
  uint64_t v18 = v16[1];
  if (v17 == v18)
  {
LABEL_9:
    uint64_t v19 = 0;
  }
  else
  {
    while (*(_UNKNOWN **)v17 != &llvm::MachinePostDominatorTree::ID)
    {
      v17 += 16;
      if (v17 == v18) {
        goto LABEL_9;
      }
    }
    uint64_t v19 = *(void *)(v17 + 8);
  }
  uint64_t v20 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v19 + 96))(v19, &llvm::MachinePostDominatorTree::ID);
  unsigned int v21 = (uint64_t *)*((void *)this + 1);
  uint64_t v22 = *v21;
  uint64_t v23 = v21[1];
  if (v22 == v23)
  {
LABEL_11:
    uint64_t v24 = 0;
  }
  else
  {
    while (*(char **)v22 != llvm::MachineLoopInfo::ID)
    {
      v22 += 16;
      if (v22 == v23) {
        goto LABEL_11;
      }
    }
    uint64_t v24 = *(void *)(v22 + 8);
  }
  uint64_t v25 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v24 + 96))(v24, llvm::MachineLoopInfo::ID);
  uint64_t v26 = *((void *)this + 38);
  int v27 = (uint64_t *)*((void *)this + 1);
  uint64_t v28 = *v27;
  uint64_t v29 = v27[1];
  if (v28 == v29)
  {
LABEL_13:
    uint64_t v30 = 0;
  }
  else
  {
    while (*(char **)v28 != llvm::MachineOptimizationRemarkEmitterPass::ID)
    {
      v28 += 16;
      if (v28 == v29) {
        goto LABEL_13;
      }
    }
    uint64_t v30 = *(void *)(v28 + 8);
  }
  uint64_t v31 = *(void *)((*(uint64_t (**)(uint64_t, char *))(*(void *)v30 + 96))(v30, llvm::MachineOptimizationRemarkEmitterPass::ID)+ 248);
  v14[118] = v15;
  v14[119] = v20;
  v14[120] = v25;
  v14[143] = v26;
  v14[142] = v31;
  llvm::MachineFunction::RenumberBlocks(a2, 0);
  if (byte_1EBCD0E78 && dword_1EBD05170)
  {
    uint64_t v32 = byte_1EBD02887 & 0x7F;
    if (byte_1EBD02887 < 0) {
      uint64_t v32 = qword_1EBD02878;
    }
    if (!v32) {
      goto LABEL_19;
    }
    uint64_t Name = llvm::Value::getName(*(llvm::Value **)a2);
    size_t v54 = v53;
    if (byte_1EBD02887 >= 0) {
      int v55 = &qword_1EBD02870;
    }
    else {
      int v55 = (uint64_t *)qword_1EBD02870;
    }
    uint64_t v56 = qword_1EBD02878;
    if (byte_1EBD02887 >= 0) {
      uint64_t v56 = byte_1EBD02887 & 0x7F;
    }
    if (v54 == v56 && (!v54 || !memcmp(Name, v55, v54)))
    {
LABEL_19:
      uint64_t v33 = (llvm::MachineBlockFrequencyInfo *)*((void *)this + 38);
      __int16 v60 = 1283;
      v57[0] = "MIR_Prof_loader_b.";
      int v58 = llvm::MachineFunction::getName((llvm::Value **)a2);
      uint64_t v59 = v34;
      llvm::MachineBlockFrequencyInfo::view(v33, (const llvm::Twine *)v57, 0);
    }
  }
  uint64_t v2 = llvm::MIRProfileLoader::runOnFunction(*((llvm::MIRProfileLoader **)this + 37), (llvm::Function **)a2);
  if (v2)
  {
    uint64_t v35 = (llvm::MachineBlockFrequencyInfo *)*((void *)this + 38);
    uint64_t MBPI = (const llvm::MachineBranchProbabilityInfo *)llvm::MachineBlockFrequencyInfo::getMBPI(v35);
    char v37 = (uint64_t *)*((void *)this + 1);
    uint64_t v38 = *v37;
    uint64_t v39 = v37[1];
    while (1)
    {
      if (v38 == v39)
      {
        uint64_t v40 = 0;
        goto LABEL_41;
      }
      if (*(char **)v38 == llvm::MachineLoopInfo::ID) {
        break;
      }
      v38 += 16;
    }
    uint64_t v40 = *(void *)(v38 + 8);
LABEL_41:
    uint64_t v41 = (const llvm::MachineLoopInfo *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v40 + 96))(v40, llvm::MachineLoopInfo::ID);
    llvm::MachineBlockFrequencyInfo::calculate(v35, a2, MBPI, v41);
  }
  if (byte_1EBCD0F38) {
    BOOL v42 = dword_1EBD05170 == 0;
  }
  else {
    BOOL v42 = 1;
  }
  if (!v42)
  {
    uint64_t v43 = byte_1EBD02887 & 0x7F;
    if (byte_1EBD02887 < 0) {
      uint64_t v43 = qword_1EBD02878;
    }
    if (!v43) {
      goto LABEL_57;
    }
    uint64_t v44 = llvm::Value::getName(*(llvm::Value **)a2);
    size_t v46 = v45;
    unsigned int v47 = byte_1EBD02887 >= 0 ? &qword_1EBD02870 : (uint64_t *)qword_1EBD02870;
    uint64_t v48 = qword_1EBD02878;
    if (byte_1EBD02887 >= 0) {
      uint64_t v48 = byte_1EBD02887 & 0x7F;
    }
    if (v46 == v48 && (!v46 || !memcmp(v44, v47, v46)))
    {
LABEL_57:
      int v49 = (llvm::MachineBlockFrequencyInfo *)*((void *)this + 38);
      unsigned int v50 = llvm::MachineFunction::getName((llvm::Value **)a2);
      __int16 v60 = 1283;
      v57[0] = "MIR_prof_loader_a.";
      int v58 = v50;
      uint64_t v59 = v51;
      llvm::MachineBlockFrequencyInfo::view(v49, (const llvm::Twine *)v57, 0);
    }
  }
  return v2;
}

uint64_t llvm::MIRProfileLoaderPass::doInitialization(llvm::MIRProfileLoaderPass *this, const llvm::MemoryBuffer **a2)
{
  uint64_t v2 = (llvm::MIRProfileLoader *)*((void *)this + 37);
  int v3 = *((_DWORD *)this + 70);
  *((_DWORD *)v2 + 288) = v3;
  int v4 = 6 * v3;
  if (v3) {
    int v5 = 6 * v3 + 2;
  }
  else {
    int v5 = 0;
  }
  *((_DWORD *)v2 + 289) = v5;
  *((_DWORD *)v2 + 290) = v4 + 7;
  return llvm::MIRProfileLoader::doInitialization(v2, a2);
}

void llvm::MIRProfileLoaderPass::getAnalysisUsage(llvm::MIRProfileLoaderPass *this, llvm::AnalysisUsage *a2)
{
  *((unsigned char *)a2 + 160) = 1;
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineBlockFrequencyInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachineDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredID(a2, (char *)&llvm::MachinePostDominatorTree::ID);
  llvm::AnalysisUsage::addRequiredTransitiveID(a2, llvm::MachineLoopInfo::ID);
  llvm::AnalysisUsage::addRequiredID(a2, llvm::MachineOptimizationRemarkEmitterPass::ID);

  llvm::MachineFunctionPass::getAnalysisUsage((uint64_t)this, (uint64_t)a2);
}

void sub_1CD553750(uint64_t a1)
{
  sub_1CD5538CC(a1);

  JUMPOUT(0x1D25D9CE0);
}

const char *sub_1CD553788()
{
  return "SampleFDO loader in MIR";
}

void llvm::callDefaultCtor<llvm::MIRProfileLoaderPass>()
{
}

uint64_t sub_1CD553864(llvm::Value *a1)
{
  uint64_t FnAttribute = llvm::Function::getFnAttribute((uint64_t)a1, "sample-profile-suffix-elision-policy", 0x24uLL);
  uint64_t ValueAsString = llvm::Attribute::getValueAsString((llvm::Attribute *)&FnAttribute);
  uint64_t v4 = v3;
  uint64_t Name = llvm::Value::getName(a1);
  return sub_1CC3BEC98((uint64_t)Name, v6, ValueAsString, v4);
}

void sub_1CD5538CC(uint64_t a1)
{
  *(void *)a1 = &unk_1F2610128;
  uint64_t v2 = *(atomic_uint **)(a1 + 312);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = 0;
  if (v3)
  {
    uint64_t v4 = sub_1CD555C40(v3);
    MEMORY[0x1D25D9CE0](v4, 0x10F3C40C8B5CBB6);
  }
  if (*(char *)(a1 + 279) < 0) {
    operator delete(*(void **)(a1 + 256));
  }

  sub_1CBA0E6AC((llvm::Pass *)a1);
}

void sub_1CD553994(int **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBCD0C78, 0, 0);
  dword_1EBCD0CF8 = 0;
  qword_1EBCD0D00 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD0D08 = 0;
  qword_1EBCD0C78[0] = (uint64_t)&unk_1F2643F00;
  qword_1EBCD0D10 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD0D18 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD0D30 = (uint64_t)&qword_1EBCD0D18;
  llvm::cl::Option::setArgStr(v4, "fs-profile-debug-prob-diff-threshold", 0x24uLL);
  dword_1EBCD0CF8 = **a1;
  byte_1EBCD0D0C = 1;
  dword_1EBCD0D08 = dword_1EBCD0CF8;
  xmmword_1EBCD0C98 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCD0C78);
}

void sub_1CD553AA0(int **a1, long long *a2)
{
  uint64_t v4 = sub_1CB883A14((uint64_t)qword_1EBCD0D38, 0, 0);
  dword_1EBCD0DB8 = 0;
  qword_1EBCD0DC0 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD0DC8 = 0;
  qword_1EBCD0D38[0] = (uint64_t)&unk_1F2643F00;
  qword_1EBCD0DD0 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD0DD8 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD0DF0 = (uint64_t)&qword_1EBCD0DD8;
  llvm::cl::Option::setArgStr(v4, "fs-profile-debug-bw-threshold", 0x1DuLL);
  dword_1EBCD0DB8 = **a1;
  byte_1EBCD0DCC = 1;
  dword_1EBCD0DC8 = dword_1EBCD0DB8;
  xmmword_1EBCD0D58 = *a2;

  llvm::cl::Option::addArgument((llvm::cl::Option *)qword_1EBCD0D38);
}

void *sub_1CD553BAC(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  int v5 = v7;
  if ((v4 & 1) == 0)
  {
    int v5 = sub_1CD553D0C(a1, a2, v7);
    *(_OWORD *)int v5 = *(_OWORD *)a2;
    void v5[2] = 0;
  }
  return v5;
}

uint64_t sub_1CD553C1C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((a4 >> 4) ^ (a4 >> 9) | ((unint64_t)((a3 >> 4) ^ (a3 >> 9)) << 32))
       + ~((unint64_t)((a4 >> 4) ^ (a4 >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (void *)(a1 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      uint64_t v14 = 1;
    }
    else
    {
      int v16 = 0;
      int v17 = 1;
      while (v11 != -4096 || v12 != -4096)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v12 == -8192;
        }
        if (v18 && v11 == -8192) {
          int v16 = v10;
        }
        unsigned int v20 = v9 + v17++;
        unsigned int v9 = v20 & v8;
        uint64_t v10 = (void *)(a1 + 24 * (v20 & v8));
        uint64_t v11 = *v10;
        uint64_t v12 = v10[1];
        uint64_t v14 = 1;
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_8;
        }
      }
      uint64_t v14 = 0;
      if (v16) {
        uint64_t v10 = v16;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

void *sub_1CD553D0C(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_8;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_8:
    sub_1CD553DCC(a1, v6);
    int v8 = 0;
    sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096 || a3[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD553DCC(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD553EA8(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      _OWORD *result = v12;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD553EA8(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(int64x2_t **)result;
    uint64_t v8 = 24 * v6;
    int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      int64x2_t *v7 = v9;
      int v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    uint64_t v11 = a2[1];
    if ((*a2 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
    {
      uint64_t v14 = 0;
      uint64_t result = sub_1CD553C1C(*(void *)v5, *(_DWORD *)(v5 + 16), v10, v11, &v14);
      int64x2_t v12 = v14;
      *uint64_t v14 = *a2;
      uint64_t v13 = a2[2];
      v12[1] = a2[1];
      _OWORD v12[2] = v13;
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

_DWORD *sub_1CD553F7C(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    unsigned int v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD4A0040(result);
    }
    else
    {
      if (v1)
      {
        uint64_t v2 = *(void **)result;
        uint64_t v3 = *(void *)result + 24 * v1;
        do
        {
          *uint64_t v2 = -4096;
          v2[1] = -4096;
          v2 += 3;
        }
        while (v2 != (void *)v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

void sub_1CD553FD0(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  unsigned int v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_12:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 88 * v3;
    uint64_t v5 = *(void *)a1 + 24;
    while (1)
    {
      uint64_t v6 = *(void *)(v5 - 24);
      if (v6 == -8192) {
        goto LABEL_10;
      }
      if (v6 != -4096) {
        break;
      }
LABEL_11:
      v5 += 88;
      v4 -= 88;
      if (!v4) {
        goto LABEL_12;
      }
    }
    int v7 = *(void **)(v5 - 16);
    if ((void *)v5 != v7) {
      free(v7);
    }
LABEL_10:
    *(void *)(v5 - 24) = -4096;
    goto LABEL_11;
  }

  sub_1CD554094(a1);
}

void sub_1CD554094(_DWORD *a1)
{
  int v2 = a1[2];
  sub_1CD554148((uint64_t)a1);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 0;
  }
  if (v4 == a1[4])
  {
    *((void *)a1 + 1) = 0;
    if (v4)
    {
      uint64_t v5 = *(void **)a1;
      uint64_t v6 = 88 * v4;
      do
      {
        void *v5 = -4096;
        v5 += 11;
        v6 -= 88;
      }
      while (v6);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)a1, 8);
    sub_1CC3BEE98(a1, v4);
  }
}

void sub_1CD554148(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = 88 * v1;
    uint64_t v3 = *(void *)a1 + 24;
    do
    {
      if ((*(void *)(v3 - 24) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        unsigned int v4 = *(void **)(v3 - 16);
        if ((void *)v3 != v4) {
          free(v4);
        }
      }
      v3 += 88;
      v2 -= 88;
    }
    while (v2);
  }
}

void sub_1CD5541B0(_DWORD *a1)
{
  int v2 = a1[2];
  if (!v2 && !a1[3]) {
    return;
  }
  uint64_t v3 = a1[4];
  if (v3 <= 4 * v2 || v3 < 0x41)
  {
    if (!v3)
    {
LABEL_11:
      *((void *)a1 + 1) = 0;
      return;
    }
    uint64_t v4 = 32 * v3;
    uint64_t v5 = *(void *)a1 + 8;
    while (1)
    {
      uint64_t v6 = *(void *)(v5 - 8);
      if (v6 == -8192) {
        goto LABEL_9;
      }
      if (v6 != -4096) {
        break;
      }
LABEL_10:
      v5 += 32;
      v4 -= 32;
      if (!v4) {
        goto LABEL_11;
      }
    }
    sub_1CB833A08(v5, *(void **)(v5 + 8));
LABEL_9:
    *(void *)(v5 - 8) = -4096;
    goto LABEL_10;
  }

  sub_1CD55426C(a1);
}

void sub_1CD55426C(_DWORD *a1)
{
  uint64_t v2 = a1[4];
  int v3 = a1[2];
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    uint64_t v5 = *(void *)a1 + 8;
    do
    {
      if ((*(void *)(v5 - 8) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        sub_1CB833A08(v5, *(void **)(v5 + 8));
      }
      v5 += 32;
      v4 -= 32;
    }
    while (v4);
  }
  if (v3)
  {
    int v6 = 1 << (33 - __clz(v3 - 1));
    if (v6 <= 64) {
      unsigned int v7 = 64;
    }
    else {
      unsigned int v7 = v6;
    }
    uint64_t v8 = *(void **)a1;
    if (v7 == a1[4])
    {
      *((void *)a1 + 1) = 0;
      uint64_t v9 = 32 * v7;
      do
      {
        void *v8 = -4096;
        v8 += 4;
        v9 -= 32;
      }
      while (v9);
      return;
    }
  }
  else
  {
    if (!a1[4])
    {
      *((void *)a1 + 1) = 0;
      return;
    }
    unsigned int v7 = 0;
    uint64_t v8 = *(void **)a1;
  }
  MEMORY[0x1D25D9CD0](v8, 8);

  sub_1CBC04C8C(a1, v7);
}

uint64_t sub_1CD554374(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2 + 320;
  uint64_t v3 = *(void *)(a2 + 328);
  if (v3 == a2 + 320)
  {
    char v5 = 0;
  }
  else
  {
    char v5 = 0;
    do
    {
      sub_1CD554804((uint64_t)&v9, (void *(***)(unint64_t *__return_ptr, void, uint64_t))a1, v3);
      if ((v10 & 1) == 0)
      {
        uint64_t v6 = v9;
        uint64_t v8 = v3;
        sub_1CD4D7004((uint64_t *)(a1 + 32), &v8)[1] = v6;
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)(a1 + 80), v3);
        char v5 = 1;
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
  }
  return v5 & 1;
}

void sub_1CD55444C(uint64_t a1, llvm::Function **a2, uint64_t a3)
{
  llvm::Function::setEntryCount(*a2, *(void *)(*(void *)(a1 + 1064) + 64) + 1, 0, a3);
  if (!byte_1EBD0CB98) {
    sub_1CD55492C(a1, (uint64_t)a2);
  }

  sub_1CD554AB0(a1, (uint64_t)a2);
}

void sub_1CD5544C0(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (byte_1EBD0CB98)
  {
    uint64_t v4 = a2 + 320;
    v20[0] = 0;
    v20[1] = 0;
    int v21 = 0;
    for (uint64_t i = *(void *)(a2 + 328); i != v4; uint64_t i = *(void *)(i + 8))
    {
      sub_1CD554804((uint64_t)v22, (void *(***)(unint64_t *__return_ptr, void, uint64_t))a1, i);
      if ((v23 & 1) == 0)
      {
        uint64_t v6 = v22[0];
        uint64_t v19 = i;
        sub_1CD4D7004(v20, &v19)[1] = v6;
      }
    }
    v22[0] = a2;
    v22[1] = a1 + 992;
    uint64_t v23 = v20;
    sub_1CC3BEF34(v22, (uint64_t *)(a1 + 32), (_DWORD *)(a1 + 56));
    MEMORY[0x1D25D9CD0](v20[0], 8);
  }
  else
  {
    uint64_t v7 = a2 + 320;
    uint64_t v8 = *(void *)(a2 + 328);
    if (v8 != a2 + 320)
    {
      do
      {
        uint64_t v19 = v8;
        v20[0] = 0;
        uint64_t v15 = (uint64_t *)(*(void *)(a1 + 960) + 248);
        v22[0] = v8;
        if (sub_1CB834D78(v15, v22, v20))
        {
          uint64_t v16 = *(void *)(v20[0] + 8);
          if (v16)
          {
            v22[0] = 0;
            v22[0] = **(void **)(v16 + 32);
            if (v22[0])
            {
              unint64_t v17 = sub_1CD4D7004((uint64_t *)(a1 + 32), &v19)[1];
              if (v17 > sub_1CD4D7004((uint64_t *)(a1 + 32), v22)[1])
              {
                uint64_t v18 = sub_1CD4D7004((uint64_t *)(a1 + 32), &v19)[1];
                sub_1CD4D7004((uint64_t *)(a1 + 32), v22)[1] = v18;
              }
            }
          }
        }
        uint64_t v8 = *(void *)(v8 + 8);
      }
      while (v8 != v7);
    }
    int v9 = 3;
    do
    {
      unsigned int v10 = v9;
      if (v9 - 3 >= dword_1EBD0C898) {
        break;
      }
      char v11 = sub_1CD555134(a1, a2, 0);
      int v9 = v10 + 1;
    }
    while ((v11 & 1) != 0);
    *(_DWORD *)(a1 + 376) = 0;
    sub_1CD40B1BC(*(void **)(a1 + 904));
    *(void *)(a1 + 896) = a1 + 904;
    *(void *)(a1 + 912) = 0;
    *(void *)(a1 + 904) = 0;
    while (1)
    {
      unsigned int v12 = v10;
      unsigned int v13 = dword_1EBD0C898;
      if (v10 - 2 >= dword_1EBD0C898) {
        break;
      }
      ++v10;
      if ((sub_1CD555134(a1, a2, 0) & 1) == 0)
      {
        unsigned int v13 = dword_1EBD0C898;
        break;
      }
    }
    if (v12 - 1 < v13)
    {
      do
      {
        if (!sub_1CD555134(a1, a2, 1)) {
          break;
        }
      }
      while (v12++ < dword_1EBD0C898);
    }
  }
}

void *sub_1CD554724(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (byte_1EBD0CB98)
  {
    char v5 = result;
    uint64_t v9 = *(void *)(a2 + 328);
    sub_1CD554804((uint64_t)v10, (void *(***)(unint64_t *__return_ptr, void, uint64_t))result, v9);
    uint64_t v6 = v5 + 4;
    uint64_t result = sub_1CD4D7004(v6, &v9);
    if (result[1])
    {
      if (byte_1EBD0CC58 || (v10[16] & 1) != 0)
      {
        uint64_t v7 = *(llvm::Function **)a2;
        uint64_t v8 = sub_1CD4D7004(v6, &v9);
        return (void *)llvm::Function::setEntryCount(v7, v8[1], 0, a3);
      }
    }
  }
  return result;
}

const std::error_category *sub_1CD554804(uint64_t a1, void *(***a2)(unint64_t *__return_ptr, void, uint64_t), uint64_t a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a3 + 48;
  uint64_t v5 = *(void *)(a3 + 56);
  if (v5 == a3 + 48) {
    goto LABEL_15;
  }
  char v7 = 0;
  unint64_t v8 = 0;
  do
  {
    uint64_t result = (const std::error_category *)(**a2)(&v11, a2, v5);
    unint64_t v10 = v11;
    if (v8 > v11) {
      unint64_t v10 = v8;
    }
    if ((v12 & 1) == 0) {
      unint64_t v8 = v10;
    }
    if (!v5 || (*(unsigned char *)v5 & 4) == 0)
    {
      while ((*(_WORD *)(v5 + 44) & 8) != 0)
        uint64_t v5 = *(void *)(v5 + 8);
    }
    v7 |= (v12 & 1) == 0;
    uint64_t v5 = *(void *)(v5 + 8);
  }
  while (v5 != v4);
  if ((v7 & 1) == 0)
  {
LABEL_15:
    uint64_t result = std::system_category();
    unint64_t v8 = 0;
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)(a1 + 8) = result;
  }
  else
  {
    *(unsigned char *)(a1 + 16) &= ~1u;
  }
  *(void *)a1 = v8;
  return result;
}

void sub_1CD55492C(uint64_t a1, uint64_t a2)
{
  v13[8] = *MEMORY[0x1E4F143B8];
  unint64_t v11 = v13;
  uint64_t v12 = 0x800000000;
  uint64_t v2 = a2 + 320;
  uint64_t v3 = *(void *)(a2 + 328);
  if (v3 != a2 + 320)
  {
    uint64_t v6 = a1 + 920;
    do
    {
      uint64_t v9 = v3;
      if ((sub_1CD40EA84(*(void *)(a1 + 920), *(_DWORD *)(a1 + 936), v3, &v10) & 1) == 0)
      {
        sub_1CD467E2C(v6, &v9)[1] = v3;
        LODWORD(v12) = 0;
        llvm::MachineDominatorTree::applySplitCriticalEdges(*(void ****)(a1 + 944));
        llvm::DominatorTreeBase<llvm::MachineBasicBlock,false>::getDescendants();
      }
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != v2);
    for (uint64_t i = *(void *)(a2 + 328); i != v2; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v9 = 0;
      uint64_t v10 = i;
      uint64_t v9 = sub_1CD467E2C(v6, &v10)[1];
      if (v10 != v9)
      {
        uint64_t v8 = sub_1CD4D7004((uint64_t *)(a1 + 32), &v9)[1];
        sub_1CD4D7004((uint64_t *)(a1 + 32), &v10)[1] = v8;
      }
    }
  }
  if (v11 != v13) {
    free(v11);
  }
}

void sub_1CD554AB0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a2 + 320);
  uint64_t v3 = *(void **)(a2 + 328);
  if (v3 != (void *)(a2 + 320))
  {
    uint64_t v4 = a1 + 968;
    uint64_t v5 = a1 + 992;
    do
    {
      uint64_t v23 = v3;
      uint64_t v18 = v22;
      uint64_t v19 = v22;
      uint64_t v20 = 16;
      int v21 = 0;
      sub_1CD554E30(v4, (uint64_t *)&v23);
      uint64_t v6 = (uint64_t *)v3[8];
      char v7 = (uint64_t *)v3[9];
      while (v6 != v7)
      {
        uint64_t v8 = *v6;
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v18, *v6);
        if (v9)
        {
          uint64_t v10 = sub_1CD554E30(v4, (uint64_t *)&v23);
          unint64_t v11 = *((unsigned int *)v10 + 4);
          if (v11 >= *((unsigned int *)v10 + 5)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(v10[1] + 8 * v11) = v8;
          ++*((_DWORD *)v10 + 4);
        }
        ++v6;
      }
      sub_1CBFF3560((llvm::SmallPtrSetImplBase *)&v18);
      sub_1CD554E30(v5, (uint64_t *)&v23);
      uint64_t v12 = (uint64_t *)v3[11];
      uint64_t v13 = (uint64_t *)v3[12];
      while (v12 != v13)
      {
        uint64_t v14 = *v12;
        sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v18, *v12);
        if (v15)
        {
          uint64_t v16 = sub_1CD554E30(v5, (uint64_t *)&v23);
          unint64_t v17 = *((unsigned int *)v16 + 4);
          if (v17 >= *((unsigned int *)v16 + 5)) {
            llvm::SmallVectorBase<unsigned int>::grow_pod();
          }
          *(void *)(v16[1] + 8 * v17) = v14;
          ++*((_DWORD *)v16 + 4);
        }
        ++v12;
      }
      if (v19 != v18) {
        free(v19);
      }
      uint64_t v3 = (void *)v3[1];
    }
    while (v3 != v2);
  }
}

void *sub_1CD554C68(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v11 = a2;
  uint64_t v10 = sub_1CD467E2C(a1 + 920, &v11)[1];
  uint64_t v7 = sub_1CD4D7004((uint64_t *)(a1 + 32), &v10)[1];
  if (a4)
  {
    uint64_t v9 = *a3;
    llvm::DominatorTreeBase<llvm::MachineBasicBlock,true>::dominates();
  }
  if (v10 == *(void *)(*(void *)(v10 + 32) + 328)) {
    uint64_t v7 = *(void *)(*(void *)(a1 + 1064) + 64) + 1;
  }
  uint64_t result = sub_1CD4D7004((uint64_t *)(a1 + 32), &v10);
  result[1] = v7;
  return result;
}

void *sub_1CD554E30(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = 0;
  char v4 = sub_1CD513A78(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD554EAC(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x800000000;
  }
  return v5;
}

void *sub_1CD554EAC(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD554F60(a1, v6);
  uint64_t v8 = 0;
  sub_1CD513A78(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD554F60(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(88 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD555038(a1, v4, v4 + 88 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v10 = *(_DWORD *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 88 * v10;
    do
    {
      void *result = -4096;
      result += 11;
      v11 -= 88;
    }
    while (v11);
  }
  return result;
}

void sub_1CD555038(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 88 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 11;
      v8 -= 88;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v13 = 0;
        sub_1CD513A78(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v13);
        unsigned int v10 = v13;
        *uint64_t v13 = *(void *)v4;
        void v10[2] = 0x800000000;
        v10[1] = v10 + 3;
        uint64_t v11 = (uint64_t)(v10 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CD41C56C(v11, v4 + 8);
        }
        ++*(_DWORD *)(a1 + 8);
        uint64_t v12 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v12) {
          free(v12);
        }
      }
      v4 += 88;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD555134(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 328);
  uint64_t v78 = a2 + 320;
  if (v3 != a2 + 320)
  {
    char v76 = 0;
    uint64_t v77 = a1 + 920;
    uint64_t v6 = a1 + 992;
    unsigned int v74 = (uint64_t *)(a1 + 32);
    uint64_t v75 = a1 + 992;
    uint64_t v80 = a1 + 968;
    uint64_t v81 = a1 + 80;
    while (1)
    {
      uint64_t v89 = 0;
      v90[0] = v3;
      uint64_t v89 = sub_1CD467E2C(v77, v90)[1];
      char v7 = 1;
      do
      {
        unsigned int v88 = 0;
        int64x2_t v87 = 0uLL;
        int64x2_t v86 = 0uLL;
        uint64_t v84 = 0;
        uint64_t v85 = 0;
        char v82 = v7;
        if ((v7 & 1) == 0)
        {
          int v8 = *((_DWORD *)sub_1CD554E30(v6, v90) + 4);
          uint64_t v20 = sub_1CD554E30(v6, v90);
          uint64_t v21 = *((unsigned int *)v20 + 4);
          if (v21)
          {
            unint64_t v14 = 0;
            uint64_t v22 = (unint64_t *)v20[1];
            uint64_t v23 = 8 * v21;
            do
            {
              unint64_t v24 = *v22++;
              v14 += sub_1CD5559F4(a1, v90[0], v24, &v88, (unint64_t *)&v87);
              v23 -= 8;
            }
            while (v23);
          }
          else
          {
            unint64_t v14 = 0;
          }
          if (v8 != 1)
          {
            uint64_t v13 = 0;
            goto LABEL_21;
          }
          uint64_t v48 = v90;
          uint64_t v13 = 0;
          unsigned int v47 = (uint64_t *)sub_1CD554E30(v6, v90)[1];
          goto LABEL_40;
        }
        int v8 = *((_DWORD *)sub_1CD554E30(v80, v90) + 4);
        uint64_t v9 = sub_1CD554E30(v80, v90);
        uint64_t v10 = *((unsigned int *)v9 + 4);
        if (v10)
        {
          uint64_t v79 = v3;
          uint64_t v11 = a3;
          uint64_t v12 = 0;
          uint64_t v13 = 0;
          unint64_t v14 = 0;
          char v15 = (unint64_t *)v9[1];
          uint64_t v16 = 8 * v10;
          do
          {
            unint64_t v18 = *v15++;
            unint64_t v17 = v18;
            uint64_t v19 = v90[0];
            v14 += sub_1CD5559F4(a1, v18, v90[0], &v88, (unint64_t *)&v87);
            if (v18 == v19)
            {
              uint64_t v12 = v17;
              uint64_t v13 = v17;
            }
            v16 -= 8;
          }
          while (v16);
          v86.i64[0] = v13;
          v86.i64[1] = v12;
          a3 = v11;
          uint64_t v3 = v79;
          uint64_t v6 = v75;
        }
        else
        {
          uint64_t v13 = 0;
          unint64_t v14 = 0;
        }
        if (v8 == 1)
        {
          unsigned int v47 = v90;
          uint64_t v48 = (uint64_t *)sub_1CD554E30(v80, v90)[1];
LABEL_40:
          uint64_t v38 = *v47;
          uint64_t v84 = *v48;
          uint64_t v85 = v38;
          int v8 = 1;
        }
LABEL_21:
        unsigned int v25 = v88;
        if (v88 <= 1)
        {
          uint64_t v39 = sub_1CD4D7004(v74, &v89);
          if (v25 == 1)
          {
            uint64_t v26 = (llvm::SmallPtrSetImplBase *)v81;
            int v49 = sub_1CB896AE8(v81, v89);
            uint64_t v50 = *(void *)(a1 + 88);
            uint64_t v51 = 100;
            if (v50 != *(void *)(a1 + 80)) {
              uint64_t v51 = 96;
            }
            char v33 = v82;
            if (v49 != (void *)(v50 + 8 * *(unsigned int *)(a1 + v51)))
            {
              unint64_t v52 = v39[1];
              BOOL v44 = v52 >= v14;
              unint64_t v53 = v52 - v14;
              if (v44) {
                unint64_t v54 = v53;
              }
              else {
                unint64_t v54 = 0;
              }
              sub_1CD553BAC(a1 + 56, v87.i64)[2] = v54;
              char v33 = v82;
              v83.i64[0] = 0;
              if (v82) {
                int v55 = &v87;
              }
              else {
                int v55 = (int64x2_t *)&v87.u64[1];
              }
              uint64_t v26 = (llvm::SmallPtrSetImplBase *)v81;
              v83.i64[0] = sub_1CD467E2C(v77, v55->i64)[1];
              uint64_t v56 = sub_1CB896AE8(v81, v83.i64[0]);
              uint64_t v57 = *(void *)(a1 + 88);
              uint64_t v58 = 96;
              if (v57 == *(void *)(a1 + 80)) {
                uint64_t v58 = 100;
              }
              if (v56 != (void *)(v57 + 8 * *(unsigned int *)(a1 + v58)))
              {
                unint64_t v59 = sub_1CD553BAC(a1 + 56, v87.i64)[2];
                if (v59 > sub_1CD4D7004(v74, &v83)[1])
                {
                  uint64_t v60 = sub_1CD4D7004(v74, &v83)[1];
                  sub_1CD553BAC(a1 + 56, v87.i64)[2] = v60;
                }
              }
              sub_1CD555A70(a1 + 368, &v87);
              char v76 = 1;
            }
          }
          else
          {
            char v33 = v82;
            if (v25) {
              goto LABEL_57;
            }
            uint64_t v40 = sub_1CB896AE8(v81, v89);
            uint64_t v41 = *(void *)(a1 + 88);
            uint64_t v42 = 100;
            if (v41 != *(void *)(a1 + 80)) {
              uint64_t v42 = 96;
            }
            if (v40 == (void *)(v41 + 8 * *(unsigned int *)(a1 + v42)))
            {
              uint64_t v26 = (llvm::SmallPtrSetImplBase *)v81;
              if (v14 > v39[1])
              {
                v39[1] = v14;
LABEL_55:
                char v76 = 1;
              }
            }
            else if (v8 == 1)
            {
              unint64_t v72 = sub_1CD553BAC(a1 + 56, &v84)[2];
              uint64_t v26 = (llvm::SmallPtrSetImplBase *)v81;
              if (v72 < sub_1CD4D7004(v74, &v89)[1])
              {
                uint64_t v73 = sub_1CD4D7004(v74, &v89)[1];
                sub_1CD553BAC(a1 + 56, &v84)[2] = v73;
                goto LABEL_55;
              }
            }
            else
            {
              uint64_t v26 = (llvm::SmallPtrSetImplBase *)v81;
            }
          }
        }
        else
        {
          uint64_t v26 = (llvm::SmallPtrSetImplBase *)v81;
          int v27 = sub_1CB896AE8(v81, v89);
          uint64_t v28 = *(void *)(a1 + 88);
          uint64_t v29 = 100;
          if (v28 != *(void *)(a1 + 80)) {
            uint64_t v29 = 96;
          }
          if (v27 == (void *)(v28 + 8 * *(unsigned int *)(a1 + v29)) || sub_1CD4D7004(v74, &v89)[1])
          {
            if (!v13)
            {
              char v33 = v82;
              goto LABEL_29;
            }
            uint64_t v30 = sub_1CB896AE8(v81, v89);
            uint64_t v31 = *(void *)(a1 + 88);
            uint64_t v32 = 100;
            if (v31 != *(void *)(a1 + 80)) {
              uint64_t v32 = 96;
            }
            char v33 = v82;
            if (v30 != (void *)(v31 + 8 * *(unsigned int *)(a1 + v32)))
            {
              unint64_t v43 = sub_1CD4D7004(v74, v90)[1];
              BOOL v44 = v43 >= v14;
              unint64_t v45 = v43 - v14;
              if (v44) {
                unint64_t v46 = v45;
              }
              else {
                unint64_t v46 = 0;
              }
              sub_1CD553BAC(a1 + 56, v86.i64)[2] = v46;
              sub_1CD555A70(a1 + 368, &v86);
              goto LABEL_55;
            }
          }
          else
          {
            char v33 = v82;
            if (v82)
            {
              int v62 = sub_1CD554E30(v80, v90);
              uint64_t v63 = *((unsigned int *)v62 + 4);
              if (v63)
              {
                uint64_t v64 = (uint64_t *)v62[1];
                uint64_t v65 = 8 * v63;
                do
                {
                  uint64_t v66 = *v64++;
                  v83.i64[0] = v66;
                  v83.i64[1] = v90[0];
                  sub_1CD553BAC(a1 + 56, v83.i64)[2] = 0;
                  sub_1CD555A70(a1 + 368, &v83);
                  v65 -= 8;
                }
                while (v65);
LABEL_57:
                uint64_t v26 = (llvm::SmallPtrSetImplBase *)v81;
              }
            }
            else
            {
              int v67 = sub_1CD554E30(v6, v90);
              uint64_t v68 = *((unsigned int *)v67 + 4);
              if (v68)
              {
                uint64_t v69 = (uint64_t *)v67[1];
                uint64_t v70 = 8 * v68;
                do
                {
                  uint64_t v71 = *v69++;
                  v83.i64[0] = v90[0];
                  v83.i64[1] = v71;
                  sub_1CD553BAC(a1 + 56, v83.i64)[2] = 0;
                  sub_1CD555A70(a1 + 368, &v83);
                  v70 -= 8;
                }
                while (v70);
                goto LABEL_57;
              }
            }
          }
        }
LABEL_29:
        if (a3)
        {
          uint64_t v34 = sub_1CB896AE8((uint64_t)v26, v89);
          uint64_t v35 = *(void *)(a1 + 88);
          uint64_t v36 = 100;
          if (v35 != *(void *)(a1 + 80)) {
            uint64_t v36 = 96;
          }
          if (v34 == (void *)(v35 + 8 * *(unsigned int *)(a1 + v36)) && v14 != 0)
          {
            sub_1CD4D7004(v74, &v89)[1] = v14;
            sub_1CB89694C(v26, v89);
            char v76 = 1;
          }
        }
        char v7 = 0;
      }
      while ((v33 & 1) != 0);
      uint64_t v3 = *(void *)(v3 + 8);
      if (v3 == v78) {
        return v76 & 1;
      }
    }
  }
  char v76 = 0;
  return v76 & 1;
}

void sub_1CD555750(uint64_t *a1, unint64_t a2)
{
  uint64_t v2 = (uint64_t)(a1 + 2);
  uint64_t v3 = *a1;
  if (0x2E8BA2E8BA2E8BA3 * ((a1[2] - *a1) >> 3) < a2)
  {
    if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
      abort();
    }
    uint64_t v5 = a1[1];
    uint64_t v6 = 88 * a2;
    char v7 = (char *)operator new(88 * a2);
    uint64_t v8 = (uint64_t)&v7[v5 - v3];
    uint64_t v9 = &v7[v6];
    sub_1CC3BFBC8(v2, v5, v5, v3, v3, v8, v8);
    uint64_t v11 = (void *)*a1;
    uint64_t v10 = (void *)a1[1];
    *a1 = v12;
    a1[1] = v8;
    a1[2] = (uint64_t)v9;
    while (v10 != v11)
      uint64_t v10 = sub_1CD5559B0(v10 - 11);
    if (v11)
    {
      operator delete(v11);
    }
  }
}

char *sub_1CD555858(char *result)
{
  unsigned int v1 = result;
  uint64_t v2 = (void **)(result + 8);
  uint64_t v3 = *((void *)result + 2);
  while (2)
  {
    uint64_t v4 = *(void *)(v3 - 24);
    if (!*(unsigned char *)(v3 - 8))
    {
      *(void *)(v3 - 16) = *(void *)(v4 + 64);
      *(unsigned char *)(v3 - 8) = 1;
    }
    while (1)
    {
      uint64_t v5 = *(uint64_t **)(v3 - 16);
      if (v5 == *(uint64_t **)(v4 + 72)) {
        break;
      }
      *(void *)(v3 - 16) = v5 + 1;
      uint64_t v6 = *v5;
      uint64_t result = (char *)sub_1CB89694C(*(llvm::SmallPtrSetImplBase **)v1, *v5);
      if (v7)
      {
        *(void *)&long long v11 = v6;
        BYTE8(v11) = 0;
        LOBYTE(v12) = 0;
        unint64_t v9 = *((void *)v1 + 2);
        if (v9 >= *((void *)v1 + 3))
        {
          uint64_t result = sub_1CBF56DE8(v2, (uint64_t)&v11);
        }
        else
        {
          long long v10 = v11;
          *(void *)(v9 + 16) = v12;
          *(_OWORD *)unint64_t v9 = v10;
          uint64_t result = (char *)(v9 + 24);
        }
        *((void *)v1 + 2) = result;
        return result;
      }
    }
    uint64_t v8 = *((void *)v1 + 1);
    uint64_t v3 = *((void *)v1 + 2) - 24;
    *((void *)v1 + 2) = v3;
    if (v8 != v3) {
      continue;
    }
    break;
  }
  return result;
}

uint64_t sub_1CD555940(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(unsigned char *)(a1 + 32) = *((unsigned char *)a2 + 32);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  sub_1CBFCBA2C((void *)(a1 + 40), *((const void **)a2 + 5), *((void *)a2 + 6), (uint64_t)(*((void *)a2 + 6) - *((void *)a2 + 5)) >> 3);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  sub_1CBFCBA2C((void *)(a1 + 64), *((const void **)a2 + 8), *((void *)a2 + 9), (uint64_t)(*((void *)a2 + 9) - *((void *)a2 + 8)) >> 3);
  return a1;
}

void *sub_1CD5559B0(void *a1)
{
  uint64_t v2 = (void *)a1[8];
  if (v2)
  {
    a1[9] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[5];
  if (v3)
  {
    a1[6] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t sub_1CD5559F4(uint64_t a1, unint64_t a2, unint64_t a3, _DWORD *a4, unint64_t *a5)
{
  v11[0] = a2;
  v11[1] = a3;
  uint64_t result = sub_1CD555BAC(a1 + 368, a2, a3);
  if (result) {
    return sub_1CD553BAC(a1 + 56, v11)[2];
  }
  ++*a4;
  *a5 = a2;
  a5[1] = a3;
  return result;
}

uint64_t sub_1CD555A70(uint64_t result, int64x2_t *a2)
{
  uint64_t v3 = result;
  if (*(void *)(result + 544))
  {
    uint64_t v9 = result + 528;
    unint64_t v10 = a2->i64[0];
    unint64_t v11 = a2->u64[1];
LABEL_14:
    return sub_1CD50F484(v9, v10, v11, a2);
  }
  uint64_t v4 = *(unsigned int *)(result + 8);
  if (v4)
  {
    int64x2_t v5 = *a2;
    uint64_t v6 = 16 * v4;
    char v7 = *(int64x2_t **)result;
    while (1)
    {
      int32x2_t v8 = vmovn_s64(vceqq_s64(*v7, v5));
      if (v8.i32[0] & v8.i32[1]) {
        break;
      }
      ++v7;
      v6 -= 16;
      if (!v6) {
        goto LABEL_6;
      }
    }
    if (v6) {
      return result;
    }
LABEL_6:
    if (v4 <= 0x1F) {
      goto LABEL_7;
    }
    do
    {
      sub_1CD50F484(v3 + 528, *(void *)(*(void *)v3 + 16 * v4 - 16), *(void *)(*(void *)v3 + 16 * v4 - 8), (_OWORD *)(*(void *)v3 + 16 * v4 - 16));
      LODWORD(v4) = *(_DWORD *)(v3 + 8) - 1;
      *(_DWORD *)(v3 + 8) = v4;
    }
    while (v4);
    unint64_t v10 = a2->i64[0];
    unint64_t v11 = a2->u64[1];
    uint64_t v9 = v3 + 528;
    goto LABEL_14;
  }
  int64x2_t v5 = *a2;
LABEL_7:
  if (v4 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(int64x2_t *)(*(void *)result + 16 * v4) = v5;
  ++*(_DWORD *)(result + 8);
  return result;
}

BOOL sub_1CD555BAC(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (*(void *)(a1 + 544))
  {
    uint64_t v3 = *(void **)(a1 + 536);
    if (v3)
    {
      BOOL result = 1;
      do
      {
        unint64_t v5 = v3[4];
        if (v5 <= a2)
        {
          if (v5 >= a2)
          {
            unint64_t v6 = v3[5];
            if (v6 > a3) {
              goto LABEL_5;
            }
            if (v6 >= a3) {
              return result;
            }
          }
          ++v3;
        }
LABEL_5:
        uint64_t v3 = (void *)*v3;
      }
      while (v3);
    }
    return 0;
  }
  else
  {
    char v7 = *(void **)a1;
    uint64_t v8 = *(unsigned int *)(a1 + 8);
    uint64_t v9 = *(void *)a1 + 16 * v8;
    if (v8)
    {
      uint64_t v10 = 16 * v8;
      while (*v7 != a2 || v7[1] != a3)
      {
        v7 += 2;
        v10 -= 16;
        if (!v10) {
          goto LABEL_20;
        }
      }
    }
    else
    {
LABEL_20:
      char v7 = (void *)v9;
    }
    return v7 != (void *)v9;
  }
}

uint64_t sub_1CD555C40(uint64_t a1)
{
  *(void *)a1 = &unk_1F26101E8;
  uint64_t v2 = *(atomic_uint **)(a1 + 1120);
  if (v2 && atomic_fetch_add(v2 + 2, 0xFFFFFFFF) == 1) {
    (*(void (**)(atomic_uint *))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 1119) < 0) {
    operator delete(*(void **)(a1 + 1096));
  }
  if (*(char *)(a1 + 1095) < 0) {
    operator delete(*(void **)(a1 + 1072));
  }
  uint64_t v3 = *(void *)(a1 + 1056);
  *(void *)(a1 + 1056) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_1CD555E34((uint64_t *)(a1 + 1016));
  sub_1CD554148(a1 + 992);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 992), 8);
  sub_1CD554148(a1 + 968);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 968), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 920), 8);
  sub_1CD40B1BC(*(void **)(a1 + 904));
  uint64_t v4 = *(void **)(a1 + 368);
  if (v4 != (void *)(a1 + 384)) {
    free(v4);
  }
  unint64_t v5 = *(void **)(a1 + 88);
  if (v5 != *(void **)(a1 + 80)) {
    free(v5);
  }
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 56), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 32), 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  return a1;
}

void sub_1CD555D9C(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1CD555DAC(uint64_t a1, uint64_t a2)
{
  unint64_t v6 = (llvm::sampleprof::FunctionSamples *)llvm::DebugLoc::get((llvm::DebugLoc *)(a2 + 56));
  if (!v6) {
    return *(void *)(a1 + 1064);
  }
  sub_1CD5563B4(a1 + 8, &v6, (uint64_t)&v4);
  if (!v5) {
    return *(void *)(v4 + 8);
  }
  uint64_t result = llvm::sampleprof::FunctionSamples::findFunctionSamples(*(void *)(a1 + 1064), v6, *(void *)(*(void *)(a1 + 1056) + 112));
  *(void *)(v4 + 8) = result;
  return result;
}

uint64_t *sub_1CD555E34(uint64_t *a1)
{
  uint64_t v2 = *((unsigned int *)a1 + 4);
  uint64_t v3 = *a1;
  if (v2)
  {
    uint64_t v4 = 32 * v2;
    uint64_t v5 = v3 + 8;
    do
    {
      if ((*(void *)(v5 - 8) | 0x1000) != 0xFFFFFFFFFFFFF000) {
        sub_1CB833A08(v5, *(void **)(v5 + 8));
      }
      v5 += 32;
      v4 -= 32;
    }
    while (v4);
    uint64_t v3 = *a1;
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  return a1;
}

void sub_1CD555EB0(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(void *, uint64_t))(*a2 + 8))(a2, a3);
  if (v6 && (char v7 = (const std::error_category *)v6, *(void *)(a3 + 56)))
  {
    uint64_t v9 = (unsigned int *)llvm::DebugLoc::get((llvm::DebugLoc *)(a3 + 56));
    unsigned int Offset = llvm::sampleprof::FunctionSamples::getOffset((llvm::sampleprof::FunctionSamples *)v9, v10);
    unsigned int v17 = Offset;
    if (byte_1EBD064B8)
    {
      uint64_t v14 = *(void *)&v9[-2 * v9[2]];
      if (*(unsigned char *)v14 == 19) {
        unsigned int v12 = *(_DWORD *)(v14 + 24);
      }
      else {
        unsigned int v12 = 0;
      }
    }
    else
    {
      unsigned int v12 = sub_1CD495F94((uint64_t)v9);
    }
    unsigned int v16 = v12;
    sub_1CD555FF8(v7, Offset, v12, a1);
    if ((*(unsigned char *)(a1 + 16) & 1) == 0
      && llvm::sampleprofutil::SampleCoverageTracker::markSamplesUsed((llvm::sampleprofutil::SampleCoverageTracker *)(a2 + 127), (const llvm::sampleprof::FunctionSamples *)v7, Offset, v12, *(void *)a1))
    {
      uint64_t v13 = (uint64_t ****)a2[142];
      v15[0] = a3;
      v15[1] = a1;
      void v15[2] = (uint64_t)&v17;
      unint64_t v15[3] = (uint64_t)&v16;
      sub_1CC3BFE10(v13, v15);
    }
  }
  else
  {
    uint64_t v8 = std::system_category();
    *(unsigned char *)(a1 + 16) |= 1u;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = v8;
  }
}

const std::error_category *sub_1CD555FF8@<X0>(const std::error_category *a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  char v7 = a1[10].__vftable;
  uint64_t result = a1 + 10;
  v6.__vftable = v7;
  if (!v7) {
    goto LABEL_14;
  }
  uint64_t v8 = result;
  do
  {
    unsigned int equivalent = v6.equivalent;
    if (equivalent >= a2)
    {
      if (equivalent == a2)
      {
        if (HIDWORD(v6.equivalent) < a3) {
          v6.__vftable = (std::error_category_vtbl *)((char *)v6.__vftable + 8);
        }
        else {
          uint64_t v8 = (const std::error_category *)v6.__vftable;
        }
      }
      else
      {
        uint64_t v8 = (const std::error_category *)v6.__vftable;
      }
    }
    else
    {
      v6.__vftable = (std::error_category_vtbl *)((char *)v6.__vftable + 8);
    }
    v6.__vftable = (std::error_category_vtbl *)v6.~error_category;
  }
  while (v6.__vftable);
  if (v8 == result || (unsigned int v10 = v8[4].__vftable, v10 > a2) || v10 == a2 && HIDWORD(v8[4].__vftable) > a3)
  {
LABEL_14:
    uint64_t result = std::system_category();
    *(unsigned char *)(a4 + 16) |= 1u;
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = result;
  }
  else
  {
    unint64_t v11 = v8[5].__vftable;
    *(unsigned char *)(a4 + 16) &= ~1u;
    *(void *)a4 = v11;
  }
  return result;
}

uint64_t sub_1CD5560B4(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = *(char **)a2;
    if (*(void *)a2 == a2 + 16)
    {
      uint64_t v5 = *(unsigned int *)(a2 + 8);
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6 >= v5)
      {
        uint64_t v9 = *(char **)a1;
        if (v5)
        {
          uint64_t v10 = 0;
          do
          {
            sub_1CD556328((uint64_t)&v9[v10], (long long *)&v4[v10]);
            v10 += 64;
          }
          while (v5 << 6 != v10);
          uint64_t v6 = *(unsigned int *)(a1 + 8);
          unint64_t v11 = &v9[v10];
          uint64_t v9 = *(char **)a1;
        }
        else
        {
          unint64_t v11 = *(char **)a1;
        }
        for (uint64_t i = (uint64_t)&v9[64 * v6]; (char *)i != v11; uint64_t i = sub_1CC024FB8(i - 64))
          ;
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v13 = *(unsigned int *)(a2 + 8);
        if (v13)
        {
          uint64_t v14 = v13 << 6;
          uint64_t v15 = *(void *)a2 - 64;
          do
          {
            sub_1CC024FB8(v15 + v14);
            v14 -= 64;
          }
          while (v14);
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) < v5)
        {
          if (v6)
          {
            uint64_t v16 = v6 << 6;
            uint64_t v17 = *(void *)a1 - 64;
            do
            {
              sub_1CC024FB8(v17 + v16);
              v16 -= 64;
            }
            while (v16);
          }
          *(_DWORD *)(a1 + 8) = 0;
          sub_1CD494E94();
        }
        if (v6)
        {
          uint64_t v7 = *(void *)a1;
          uint64_t v8 = v6 << 6;
          do
          {
            sub_1CD556328(v7, (long long *)v4);
            v4 += 64;
            v7 += 64;
            v8 -= 64;
          }
          while (v8);
        }
        else
        {
          uint64_t v6 = 0;
        }
        unint64_t v18 = *(char **)a2;
        uint64_t v19 = *(unsigned int *)(a2 + 8);
        if (v6 != v19)
        {
          uint64_t v20 = &v18[64 * v19];
          uint64_t v21 = *(void *)a1 + (v6 << 6);
          uint64_t v22 = &v18[64 * v6];
          do
          {
            long long v23 = *(_OWORD *)v22;
            *(void *)(v21 + 16) = *((void *)v22 + 2);
            *(_OWORD *)uint64_t v21 = v23;
            *((void *)v22 + 1) = 0;
            *((void *)v22 + 2) = 0;
            *(void *)uint64_t v22 = 0;
            long long v24 = *(_OWORD *)(v22 + 24);
            *(void *)(v21 + 40) = *((void *)v22 + 5);
            *(_OWORD *)(v21 + 24) = v24;
            *((void *)v22 + 4) = 0;
            *((void *)v22 + 5) = 0;
            *((void *)v22 + 3) = 0;
            *(_OWORD *)(v21 + 48) = *((_OWORD *)v22 + 3);
            v22 += 64;
            v21 += 64;
          }
          while (v22 != v20);
          unint64_t v18 = *(char **)a2;
        }
        *(_DWORD *)(a1 + 8) = v5;
        uint64_t v25 = *(unsigned int *)(a2 + 8);
        if (v25)
        {
          uint64_t v26 = v25 << 6;
          int v27 = v18 - 64;
          do
          {
            sub_1CC024FB8((uint64_t)&v27[v26]);
            v26 -= 64;
          }
          while (v26);
        }
      }
      *(_DWORD *)(a2 + 8) = 0;
    }
    else
    {
      sub_1CD5562AC((char **)a1, (char **)a2);
    }
  }
  return a1;
}

double sub_1CD5562AC(char **a1, char **a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *((unsigned int *)a1 + 2);
  if (v5)
  {
    uint64_t v6 = v5 << 6;
    uint64_t v7 = v4 - 64;
    do
    {
      sub_1CC024FB8((uint64_t)&v7[v6]);
      v6 -= 64;
    }
    while (v6);
    uint64_t v4 = *a1;
  }
  if (v4 != (char *)(a1 + 2)) {
    free(v4);
  }
  *a1 = *a2;
  double result = *((double *)a2 + 1);
  *((double *)a1 + 1) = result;
  *a2 = (char *)(a2 + 2);
  a2[1] = 0;
  return result;
}

uint64_t sub_1CD556328(uint64_t a1, long long *a2)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  uint64_t v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*v5);
  }
  long long v6 = *(long long *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *(_OWORD *)uint64_t v5 = v6;
  *((unsigned char *)a2 + 47) = 0;
  *((unsigned char *)a2 + 24) = 0;
  *(_OWORD *)(a1 + 48) = a2[3];
  return a1;
}

uint64_t sub_1CD5563B4@<X0>(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v10 = 0;
  uint64_t result = sub_1CD3C8538((uint64_t *)a1, a2, &v10);
  uint64_t v7 = v10;
  if (result)
  {
    char v8 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4F83B4(a1, (uint64_t)a2, a2, v10);
    uint64_t v7 = (void *)result;
    *(void *)uint64_t result = *a2;
    *(void *)(result + 8) = 0;
    char v8 = 1;
  }
  uint64_t v9 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = v7;
  *(void *)(a3 + 8) = v9;
  *(unsigned char *)(a3 + 16) = v8;
  return result;
}

uint64_t sub_1CD55643C(uint64_t a1, const std::string::value_type *a2, std::string::size_type a3, const std::string::value_type *a4, std::string::size_type a5, atomic_uint **a6)
{
  std::string::__init(&v14, a2, a3);
  std::string::__init(&v13, a4, a5);
  uint64_t v10 = *a6;
  unsigned int v12 = v10;
  if (v10)
  {
    atomic_fetch_add_explicit(v10 + 2, 1u, memory_order_relaxed);
    sub_1CD556554(a1, (long long *)&v14, (long long *)&v13, (uint64_t *)&v12);
    if (atomic_fetch_add(v10 + 2, 0xFFFFFFFF) == 1) {
      (*(void (**)(atomic_uint *))(*(void *)v10 + 8))(v10);
    }
  }
  else
  {
    sub_1CD556554(a1, (long long *)&v14, (long long *)&v13, (uint64_t *)&v12);
  }
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v14.__r_.__value_.__l.__data_);
  }
  *(void *)a1 = &unk_1F2610208;
  *(unsigned char *)(a1 + 1164) = 1;
  return a1;
}

uint64_t sub_1CD556554(uint64_t a1, long long *a2, long long *a3, uint64_t *a4)
{
  *(void *)a1 = &unk_1F26101E8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_DWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a1 + 112;
  *(void *)(a1 + 88) = a1 + 112;
  *(void *)(a1 + 96) = 32;
  *(_DWORD *)(a1 + 104) = 0;
  *(void *)(a1 + 368) = a1 + 384;
  *(_OWORD *)(a1 + 904) = 0u;
  *(void *)(a1 + 376) = 0x2000000000;
  *(void *)(a1 + 896) = a1 + 904;
  uint64_t v7 = (_OWORD *)(a1 + 920);
  char v8 = (_OWORD *)(a1 + 968);
  uint64_t v9 = (_OWORD *)(a1 + 1016);
  *(void *)(a1 + 1040) = 0;
  *(unsigned char *)(a1 + 1048) = 0;
  uint64_t v10 = a1 + 1072;
  *(_DWORD *)(a1 + 936) = 0;
  _OWORD *v7 = 0u;
  *(_DWORD *)(a1 + 984) = 0;
  _OWORD *v8 = 0u;
  *(_DWORD *)(a1 + 1008) = 0;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_DWORD *)(a1 + 1032) = 0;
  _OWORD *v9 = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(v10, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v11 = *a2;
    *(void *)(v10 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v10 = v11;
  }
  unsigned int v12 = (_OWORD *)(a1 + 1096);
  if (*((char *)a3 + 23) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v12, *(const void **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v13 = *a3;
    *(void *)(a1 + 1112) = *((void *)a3 + 2);
    *unsigned int v12 = v13;
  }
  uint64_t v14 = *a4;
  *(void *)(a1 + 1120) = *a4;
  if (v14) {
    atomic_fetch_add_explicit((atomic_uint *volatile)(v14 + 8), 1u, memory_order_relaxed);
  }
  *(_OWORD *)(a1 + 1128) = 0u;
  return a1;
}

void llvm::createRegAllocScoringPass(llvm *this)
{
}

uint64_t sub_1CD5566E4(uint64_t a1)
{
  uint64_t v2 = 504;
  do
  {
    if (*(char *)(a1 + v2 - 1) < 0) {
      operator delete(*(void **)(a1 + v2 - 24));
    }
    v2 -= 24;
  }
  while (v2);
  return a1;
}

void sub_1CD55672C(llvm::Pass *a1)
{
  sub_1CBA0E6AC(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD556764(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
  sub_1CB843600(a2, a2, (uint64_t)&llvm::RegAllocEvictionAdvisorAnalysis::ID);
  sub_1CB843600(a2, a2, (uint64_t)&llvm::MachineBlockFrequencyInfo::ID);
  sub_1CB843600(a2, a2, (uint64_t)llvm::AAResultsWrapperPass::ID);

  llvm::MachineFunctionPass::getAnalysisUsage(a1, a2);
}

uint64_t sub_1CD5567E0(uint64_t a1)
{
  sub_1CB8483A0(a1, (uint64_t)&llvm::RegAllocScoring::ID);
  *(void *)uint64_t v2 = &unk_1F2610258;
  atomic_ullong PassRegistry = llvm::PassRegistry::getPassRegistry(v2);
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD0F78, memory_order_acquire) != -1)
  {
    v6[0] = sub_1CC3C07F8;
    v6[1] = &PassRegistry;
    uint64_t v5 = v6;
    std::__call_once(&qword_1EBCD0F78, &v5, (void (__cdecl *)(void *))sub_1CB848390);
  }
  return a1;
}

void llvm::callDefaultCtor<llvm::RegAllocScoring>()
{
}

void llvm::ModuloScheduleExpander::expand(llvm::ModuloScheduleExpander *this)
{
  TopBlocint k = llvm::MachineLoop::getTopBlock(**(llvm::MachineLoop ***)this);
  *((void *)this + 6) = TopBlock;
  uint64_t v3 = (uint64_t **)TopBlock[8];
  long long v4 = *v3;
  *((void *)this + 7) = *v3;
  if (v4 == TopBlock) {
    *((void *)this + 7) = v3[1];
  }
  uint64_t v5 = *(void **)(*(void *)this + 8);
  uint64_t v30 = *(void **)(*(void *)this + 16);
  if (v30 != v5)
  {
    do
    {
      uint64_t v31 = v5;
      uint64_t v6 = *v5;
      uint64_t v7 = *(llvm::MachineLoop ***)this;
      char v8 = (uint64_t *)(*(void *)this + 56);
      uint64_t v33 = *v5;
      uint64_t v34 = 0;
      if (sub_1CD3C8538(v8, &v33, &v34)) {
        BOOL v9 = v34 == (void)v7[7] + 16 * *((unsigned int *)v7 + 18);
      }
      else {
        BOOL v9 = 1;
      }
      if (v9) {
        int v10 = -1;
      }
      else {
        int v10 = *(_DWORD *)(v34 + 8);
      }
      uint64_t v11 = *(unsigned int *)(v6 + 40);
      if (v11)
      {
        unsigned int v12 = *(_DWORD **)(v6 + 32);
        long long v13 = &v12[8 * v11];
        do
        {
          if ((*v12 & 0x10000FF) == 0x1000000)
          {
            unsigned int v32 = v12[1];
            uint64_t v14 = sub_1CBA02BCC(*((void *)this + 3), v32);
            if (v14 == v15)
            {
              char v16 = 0;
              unsigned int v17 = 0;
            }
            else
            {
              uint64_t v18 = v14;
              uint64_t v19 = v15;
              unsigned int v17 = 0;
              char v16 = 0;
              do
              {
                uint64_t v20 = *(llvm::MachineLoop ***)this;
                uint64_t v21 = (uint64_t *)(*(void *)this + 56);
                uint64_t v33 = *(void *)(v18 + 8);
                uint64_t v34 = 0;
                if (sub_1CD3C8538(v21, &v33, &v34)) {
                  BOOL v22 = v34 == (void)v20[7] + 16 * *((unsigned int *)v20 + 18);
                }
                else {
                  BOOL v22 = 1;
                }
                if (v22) {
                  int v23 = -1;
                }
                else {
                  int v23 = *(_DWORD *)(v34 + 8);
                }
                if (v23 < v10 || v23 == -1) {
                  unsigned int v25 = 0;
                }
                else {
                  unsigned int v25 = v23 - v10;
                }
                int v26 = **(unsigned __int16 **)(v6 + 16);
                if (v26 == 69 || v26 == 0)
                {
                  int isLoopCarried = llvm::ModuloScheduleExpander::isLoopCarried(this, (llvm::MachineInstr *)v6);
                  v25 += isLoopCarried;
                  if (!isLoopCarried) {
                    char v16 = 1;
                  }
                }
                if (v25 > v17) {
                  unsigned int v17 = v25;
                }
                do
                  uint64_t v18 = *(void *)(v18 + 24);
                while (v18 && (*(unsigned char *)(v18 + 3) & 1) != 0);
              }
              while (v18 != v19);
            }
            LODWORD(v34) = v32;
            uint64_t v29 = sub_1CD55B424((uint64_t **)this + 10, v32, &v34);
            *((_DWORD *)v29 + 8) = v17;
            *((unsigned char *)v29 + 36) = v16;
          }
          v12 += 8;
        }
        while (v12 != v13);
      }
      uint64_t v5 = v31 + 1;
    }
    while (v31 + 1 != v30);
  }
  llvm::ModuloScheduleExpander::generatePipelinedLoop(this);
}

BOOL llvm::ModuloScheduleExpander::isLoopCarried(llvm::ModuloScheduleExpander *this, llvm::MachineInstr *a2)
{
  int v2 = **((unsigned __int16 **)a2 + 2);
  if (v2 != 69 && v2 != 0) {
    return 0;
  }
  uint64_t v7 = *(void *)this;
  char v8 = (uint64_t *)(*(void *)this + 32);
  uint64_t v30 = a2;
  uint64_t v31 = 0;
  if (sub_1CD3C8538(v8, &v30, &v31)) {
    BOOL v9 = v31 == *(void *)(v7 + 32) + 16 * *(unsigned int *)(v7 + 48);
  }
  else {
    BOOL v9 = 1;
  }
  if (v9) {
    int v10 = -1;
  }
  else {
    int v10 = *(_DWORD *)(v31 + 8);
  }
  uint64_t v11 = *(void *)this;
  unsigned int v12 = (uint64_t *)(*(void *)this + 56);
  uint64_t v30 = a2;
  uint64_t v31 = 0;
  int v13 = -1;
  if (sub_1CD3C8538(v12, &v30, &v31) && v31 != *(void *)(v11 + 56) + 16 * *(unsigned int *)(v11 + 72)) {
    int v13 = *(_DWORD *)(v31 + 8);
  }
  int v14 = *((_DWORD *)a2 + 10);
  int v15 = v14 - 1;
  if (v14 == 1)
  {
    unsigned int v16 = 0;
  }
  else
  {
    int v17 = 0;
    unsigned int v16 = 0;
    uint64_t v18 = *((void *)a2 + 4);
    uint64_t v19 = (unsigned int *)(v18 + 36);
    do
    {
      if (*(void *)(v18 + 32 * (v17 + 2) + 16) == *((void *)a2 + 3)) {
        unsigned int v16 = *v19;
      }
      v17 += 2;
      v19 += 16;
    }
    while (v15 != v17);
  }
  uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(*((void *)this + 3), v16);
  if (!VRegDef) {
    return 1;
  }
  uint64_t v21 = (llvm::MachineInstr *)VRegDef;
  int v22 = **(unsigned __int16 **)(VRegDef + 16);
  BOOL result = 1;
  if (v22 && v22 != 69)
  {
    uint64_t v23 = *(void *)this;
    long long v24 = (uint64_t *)(*(void *)this + 32);
    uint64_t v30 = v21;
    uint64_t v31 = 0;
    int v25 = -1;
    if (sub_1CD3C8538(v24, &v30, &v31)
      && v31 != *(void *)(v23 + 32) + 16 * *(unsigned int *)(v23 + 48))
    {
      int v25 = *(_DWORD *)(v31 + 8);
    }
    uint64_t v26 = *(void *)this;
    uint64_t v30 = v21;
    uint64_t v31 = 0;
    int v27 = sub_1CD3C8538((uint64_t *)(v26 + 56), &v30, &v31);
    int v28 = -1;
    if (v27 && v31 != *(void *)(v26 + 56) + 16 * *(unsigned int *)(v26 + 72)) {
      int v28 = *(_DWORD *)(v31 + 8);
    }
    return v25 > v10 || v28 <= v13;
  }
  return result;
}

void llvm::ModuloScheduleExpander::generatePipelinedLoop(llvm::ModuloScheduleExpander *this)
{
  v5[6] = *(void **)MEMORY[0x1E4F143B8];
  (*(void (**)(void **__return_ptr))(**((void **)this + 4) + 280))(v5);
  int v2 = v5[0];
  v5[0] = 0;
  uint64_t v3 = *((void *)this + 9);
  *((void *)this + 9) = v2;
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    long long v4 = v5[0];
    v5[0] = 0;
    if (v4) {
      (*(void (**)(void *))(*(void *)v4 + 8))(v4);
    }
  }
  llvm::MachineFunction::CreateMachineBasicBlock(*((llvm::MachineFunction **)this + 1), *(const llvm::BasicBlock **)(*((void *)this + 6) + 16));
  operator new[]();
}

uint64_t llvm::ModuloScheduleExpander::generateProlog(uint64_t a1, int a2, llvm::MachineBasicBlock *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a5;
  uint64_t v7 = *(llvm::MachineBasicBlock **)(a1 + 56);
  v32[0] = 0;
  v32[1] = 0;
  int v33 = 0;
  if (a2)
  {
    unsigned int v9 = 0;
    while (1)
    {
      unint64_t MachineBasicBlock = llvm::MachineFunction::CreateMachineBasicBlock(*(llvm::MachineFunction **)(a1 + 8), *(const llvm::BasicBlock **)(*(void *)(a1 + 48) + 16));
      unint64_t v11 = *(unsigned int *)(v5 + 8);
      if (v11 >= *(unsigned int *)(v5 + 12)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *(void *)(*(void *)v5 + 8 * v11) = MachineBasicBlock;
      ++*(_DWORD *)(v5 + 8);
      unsigned int v12 = *(unint64_t **)(a1 + 48);
      llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList(*(void *)(a1 + 8) + 320, MachineBasicBlock);
      unint64_t v13 = *v12;
      *(void *)unint64_t MachineBasicBlock = *v12;
      *(void *)(MachineBasicBlock + 8) = v12;
      *(void *)(v13 + 8) = MachineBasicBlock;
      *unsigned int v12 = MachineBasicBlock;
      llvm::MachineBasicBlock::transferSuccessors((char *)MachineBasicBlock, v7);
      llvm::MachineBasicBlock::addSuccessor(v7, (void *)MachineBasicBlock, -1);
      if ((v9 & 0x80000000) == 0) {
        break;
      }
LABEL_25:
      llvm::ModuloScheduleExpander::rewritePhiValues(a1, MachineBasicBlock, v9++, a4, (uint64_t)v32);
      uint64_t v7 = (llvm::MachineBasicBlock *)MachineBasicBlock;
      uint64_t v5 = a5;
      if (v9 == a2) {
        goto LABEL_26;
      }
    }
    int v14 = (unint64_t *)(MachineBasicBlock + 48);
    int v15 = v9;
    while (1)
    {
      unsigned int v16 = *(llvm::MachineBasicBlock **)(a1 + 48);
      uint64_t v17 = *((void *)v16 + 7);
      unint64_t FirstTerminator = llvm::MachineBasicBlock::getFirstTerminator(v16);
      if (v17 != FirstTerminator) {
        break;
      }
LABEL_23:
      if (v15-- <= 0) {
        goto LABEL_25;
      }
    }
    while (1)
    {
      uint64_t v19 = *(void *)a1;
      uint64_t v20 = (uint64_t *)(*(void *)a1 + 56);
      uint64_t v34 = (unsigned __int8 *)v17;
      v31[0] = 0;
      if (sub_1CD3C8538(v20, &v34, v31)) {
        BOOL v21 = v31[0] == (void *)(*(void *)(v19 + 56) + 16 * *(unsigned int *)(v19 + 72));
      }
      else {
        BOOL v21 = 1;
      }
      if (v21) {
        int v22 = -1;
      }
      else {
        int v22 = *((_DWORD *)v31[0] + 2);
      }
      if (v22 == v15)
      {
        if (**(_WORD **)(v17 + 16) && **(_WORD **)(v17 + 16) != 69)
        {
          v31[0] = 0;
          v31[0] = llvm::ModuloScheduleExpander::cloneAndChangeInstr((llvm::ModuloScheduleExpander *)a1, (llvm::MachineInstr *)v17, v9, v15);
          llvm::ModuloScheduleExpander::updateInstruction(a1, (uint64_t)v31[0], 0, v9, v15, a4);
          long long v24 = (unint64_t *)v31[0];
          llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)(MachineBasicBlock + 40), (uint64_t)v31[0]);
          unint64_t v25 = *v14 & 0xFFFFFFFFFFFFFFF8;
          unint64_t *v24 = v25 | *v24 & 7;
          v24[1] = (unint64_t)v14;
          *(void *)(v25 + 8) = v24;
          *int v14 = *v14 & 7 | (unint64_t)v24;
          sub_1CD4F8350(v32, v31)[1] = v17;
        }
      }
      else if (!v17)
      {
        goto LABEL_21;
      }
      if ((*(unsigned char *)v17 & 4) == 0)
      {
LABEL_21:
        while ((*(_WORD *)(v17 + 44) & 8) != 0)
          uint64_t v17 = *(void *)(v17 + 8);
      }
      uint64_t v17 = *(void *)(v17 + 8);
      if (v17 == FirstTerminator) {
        goto LABEL_23;
      }
    }
  }
  unint64_t MachineBasicBlock = (unint64_t)v7;
LABEL_26:
  llvm::MachineBasicBlock::replaceSuccessor((llvm::MachineBasicBlock *)MachineBasicBlock, *(llvm::MachineBasicBlock **)(a1 + 48), a3);
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 32) + 264))())
  {
    v31[0] = v32;
    v31[1] = 0;
    uint64_t v26 = *(void *)(a1 + 32);
    uint64_t v34 = 0;
    (*(void (**)(void))(*(void *)v26 + 272))();
    if (v34) {
      llvm::MetadataTracking::untrack((uint64_t)&v34, v34);
    }
    if (v31[0] != v32) {
      free(v31[0]);
    }
  }
  return MEMORY[0x1D25D9CD0](v32[0], 8);
}

llvm::MachineInstr *llvm::ModuloScheduleExpander::cloneInstr(llvm::MachineFunction **this, llvm::MachineInstr *a2, int a3, int a4)
{
  char v8 = (llvm::MachineInstr *)llvm::MachineFunction::CloneMachineInstr(this[1], a2);
  if (**((unsigned __int16 **)a2 + 2) - 1 <= 1)
  {
    uint64_t v9 = *((unsigned int *)a2 + 10);
    if (v9)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = 32 * v9;
      do
      {
        int v14 = *(_DWORD *)(*((void *)a2 + 4) + v11);
        int v15 = v14 & 0x10000FF;
        if ((v14 & 0x10000FF) == 0) {
          break;
        }
        int v16 = v14 & 0xF00000;
        if (v15 == 0x1000000 && v16 != 0)
        {
          unsigned int TiedOperandIdx = llvm::MachineInstr::findTiedOperandIdx(a2, v12);
          llvm::MachineInstr::tieOperands((uint64_t)v8, v12, TiedOperandIdx);
        }
        v11 += 32;
        uint64_t v12 = (v12 + 1);
      }
      while (v13 != v11);
    }
  }
  llvm::ModuloScheduleExpander::updateMemOperands((llvm::ModuloScheduleExpander *)this, v8, a2, a3 - a4);
  return v8;
}

uint64_t llvm::ModuloScheduleExpander::updateInstruction(uint64_t result, uint64_t a2, int a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v6 = *(unsigned int *)(a2 + 40);
  if (v6)
  {
    int v10 = (void *)result;
    uint64_t v11 = *(_DWORD **)(a2 + 32);
    uint64_t v12 = &v11[8 * v6];
    uint64_t v13 = a6 + 24 * a4;
    do
    {
      if (!*v11)
      {
        uint64_t v14 = v11[1];
        if ((v14 & 0x80000000) != 0)
        {
          uint64_t v15 = v10[3];
          if ((*v11 & 0x1000000) != 0)
          {
            unsigned int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(v15, *(void *)(*(void *)(v15 + 24) + 16 * (v14 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
            llvm::MachineOperand::setReg((uint64_t)v11, VirtualRegister);
            LODWORD(v33) = v14;
            BOOL result = (uint64_t)sub_1CB9A74A0(v13, &v33);
            *(_DWORD *)(result + 4) = VirtualRegister;
            if (a3) {
              BOOL result = sub_1CC3C6710(v14, VirtualRegister, v10[6], *(void *)(v10[3] + 24), *(void *)(v10[3] + 272), v10[5]);
            }
          }
          else
          {
            uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(v15, v11[1]);
            uint64_t v21 = *v10;
            int v22 = (uint64_t *)(*v10 + 56);
            uint64_t v32 = VRegDef;
            uint64_t v33 = 0;
            if (sub_1CD3C8538(v22, &v32, &v33)) {
              BOOL v23 = v33 == *(void *)(v21 + 56) + 16 * *(unsigned int *)(v21 + 72);
            }
            else {
              BOOL v23 = 1;
            }
            if (v23) {
              int v28 = -1;
            }
            else {
              int v28 = *(_DWORD *)(v33 + 8);
            }
            if (v28 >= a5 || v28 == -1) {
              int v18 = 0;
            }
            else {
              int v18 = v28 - a5;
            }
            BOOL result = a6 + 24 * (v18 + a4);
            int v19 = *(_DWORD *)(result + 16);
            if (v19)
            {
              int v24 = v19 - 1;
              unsigned int v25 = v24 & (37 * v14);
              int v26 = *(_DWORD *)(*(void *)result + 8 * v25);
              if (v14 == v26)
              {
LABEL_26:
                LODWORD(v33) = v14;
                int v27 = sub_1CB9A74A0(result, &v33);
                BOOL result = llvm::MachineOperand::setReg((uint64_t)v11, v27[1]);
              }
              else
              {
                int v29 = 1;
                while (v26 != -1)
                {
                  unsigned int v30 = v25 + v29++;
                  unsigned int v25 = v30 & v24;
                  int v26 = *(_DWORD *)(*(void *)result + 8 * v25);
                  if (v14 == v26) {
                    goto LABEL_26;
                  }
                }
              }
            }
          }
        }
      }
      v11 += 8;
    }
    while (v11 != v12);
  }
  return result;
}

void llvm::ModuloScheduleExpander::generateEpilog(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t a4, uint64_t a5, void *a6)
{
  v44[16] = *MEMORY[0x1E4F143B8];
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  v43[0] = v44;
  v43[1] = (void *)0x400000000;
  if (((*(uint64_t (**)(void, uint64_t *, uint64_t *, uint64_t *, void **, void))(**(void **)(a1 + 32)
                                                                                            + 248))(*(void *)(a1 + 32), a3, &v39, &v38, v43, 0) & 1) == 0)
  {
    int v10 = *(llvm::MachineBasicBlock **)(a3[11] + 8 * (*(void *)a3[11] == (void)a3));
    v36[0] = 0;
    v36[1] = 0;
    int v37 = 0;
    uint64_t v32 = v10;
    unint64_t MachineBasicBlock = a3;
    if (a2)
    {
      unint64_t v12 = a2;
      uint64_t v29 = (uint64_t)a3;
      unsigned int v35 = a2;
      uint64_t v13 = (llvm::MachineBasicBlock *)a3;
      uint64_t v30 = a5;
      do
      {
        unint64_t MachineBasicBlock = (uint64_t *)llvm::MachineFunction::CreateMachineBasicBlock(*(llvm::MachineFunction **)(a1 + 8), 0);
        unint64_t v14 = *(unsigned int *)(a5 + 8);
        if (v14 >= *(unsigned int *)(a5 + 12)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        ++v35;
        *(void *)(*(void *)a5 + 8 * v14) = MachineBasicBlock;
        ++*(_DWORD *)(a5 + 8);
        uint64_t v15 = *(uint64_t **)(a1 + 48);
        llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList(*(void *)(a1 + 8) + 320, (uint64_t)MachineBasicBlock);
        uint64_t v16 = *v15;
        *unint64_t MachineBasicBlock = *v15;
        MachineBasicBlock[1] = (uint64_t)v15;
        *(void *)(v16 + 8) = MachineBasicBlock;
        *uint64_t v15 = (uint64_t)MachineBasicBlock;
        llvm::MachineBasicBlock::replaceSuccessor(v13, v32, (llvm::MachineBasicBlock *)MachineBasicBlock);
        llvm::MachineBasicBlock::addSuccessor(MachineBasicBlock, v32, -1);
        if (v10 == v32) {
          int v10 = (llvm::MachineBasicBlock *)MachineBasicBlock;
        }
        uint64_t v34 = v10;
        if (v12 <= a2)
        {
          uint64_t v17 = (unint64_t *)(MachineBasicBlock + 6);
          unsigned int v18 = v12;
          do
          {
            uint64_t v19 = *(void *)(a1 + 48);
            uint64_t v20 = v19 + 48;
            for (uint64_t i = *(void *)(v19 + 56); i != v20; uint64_t i = *(void *)(i + 8))
            {
              if (**(_WORD **)(i + 16) && **(_WORD **)(i + 16) != 69)
              {
                int v22 = *(llvm::MachineFunction **)a1;
                BOOL v23 = (uint64_t *)(*(void *)a1 + 56);
                uint64_t v40 = (unsigned __int8 *)i;
                v41[0] = 0;
                BOOL v24 = !sub_1CD3C8538(v23, &v40, v41)
                   || v41[0] == (void *)(*((void *)v22 + 7) + 16 * *((unsigned int *)v22 + 18));
                int v25 = v24 ? -1 : *((_DWORD *)v41[0] + 2);
                if (v25 == v18)
                {
                  v41[0] = 0;
                  v41[0] = llvm::ModuloScheduleExpander::cloneInstr((llvm::MachineFunction **)a1, (llvm::MachineInstr *)i, -1, 0);
                  llvm::ModuloScheduleExpander::updateInstruction(a1, (uint64_t)v41[0], v12 == 1, v35, 0, a4);
                  int v26 = (unint64_t *)v41[0];
                  llvm::ilist_traits<llvm::MachineInstr>::addNodeToList(MachineBasicBlock + 5, (uint64_t)v41[0]);
                  unint64_t v27 = *v17 & 0xFFFFFFFFFFFFFFF8;
                  *int v26 = v27 | *v26 & 7;
                  v26[1] = (unint64_t)v17;
                  *(void *)(v27 + 8) = v26;
                  unint64_t *v17 = *v17 & 7 | (unint64_t)v26;
                  sub_1CD4F8350(v36, v41)[1] = i;
                }
              }
              if ((*(unsigned char *)i & 4) == 0)
              {
                while ((*(_WORD *)(i + 44) & 8) != 0)
                  uint64_t i = *(void *)(i + 8);
              }
            }
            ++v18;
          }
          while (v18 <= a2);
        }
        --v12;
        llvm::ModuloScheduleExpander::generateExistingPhis(a1, (uint64_t)MachineBasicBlock, *(void *)(*a6 + 8 * v12), (uint64_t)v13, v29, a4, v36, a2, v35, v12 == 0);
        llvm::ModuloScheduleExpander::generatePhis(a1, (uint64_t)MachineBasicBlock, *(void *)(*a6 + 8 * v12), (uint64_t)v13, v29, a4, v36, a2, v35, v12 == 0);
        uint64_t v13 = (llvm::MachineBasicBlock *)MachineBasicBlock;
        a5 = v30;
        int v10 = v34;
      }
      while (v12);
    }
    llvm::MachineBasicBlock::replacePhiUsesWith((uint64_t)v32, *(llvm::MachineBasicBlock **)(a1 + 48), (llvm::MachineBasicBlock *)MachineBasicBlock);
    (*(void (**)(void))(**(void **)(a1 + 32) + 264))();
    uint64_t v28 = *(void *)(a1 + 32);
    v41[0] = 0;
    (*(void (**)(void))(*(void *)v28 + 272))();
    if (v41[0]) {
      llvm::MetadataTracking::untrack((uint64_t)v41, (unsigned __int8 *)v41[0]);
    }
    if (*(_DWORD *)(a5 + 8))
    {
      uint64_t v40 = 0;
      v41[0] = v42;
      v41[1] = (void *)0x400000000;
      (*(void (**)(void))(**(void **)(a1 + 32) + 272))();
      if (v40) {
        llvm::MetadataTracking::untrack((uint64_t)&v40, v40);
      }
      if (v41[0] != v42) {
        free(v41[0]);
      }
    }
    MEMORY[0x1D25D9CD0](v36[0], 8);
  }
  if (v43[0] != v44) {
    free(v43[0]);
  }
}

uint64_t llvm::ModuloScheduleExpander::splitLifetimes(void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1[1] + 16) + 176))(*(void *)(a1[1] + 16));
  int v37 = (void *)result;
  uint64_t v7 = a2 + 48;
  uint64_t v8 = *(void *)(a2 + 56);
  if (v8 != a2 + 48)
  {
    uint64_t v9 = *(void *)(a2 + 56);
    while (!**(_WORD **)(v9 + 16) || **(_WORD **)(v9 + 16) == 69)
    {
      uint64_t v9 = *(void *)(v9 + 8);
      if (v9 == v7)
      {
        uint64_t v9 = a2 + 48;
        break;
      }
    }
    while (v8 != v9)
    {
      uint64_t v10 = *(unsigned int *)(*(void *)(v8 + 32) + 4);
      uint64_t v11 = a1[3];
      if ((v10 & 0x80000000) != 0) {
        unint64_t v12 = (uint64_t *)(*(void *)(v11 + 24) + 16 * (v10 & 0x7FFFFFFF) + 8);
      }
      else {
        unint64_t v12 = (uint64_t *)(*(void *)(v11 + 272) + 8 * v10);
      }
      uint64_t v13 = *v12;
      if (*v12)
      {
        while ((*(unsigned char *)(v13 + 3) & 1) != 0)
        {
          uint64_t v13 = *(void *)(v13 + 24);
          if (!v13) {
            goto LABEL_13;
          }
        }
        uint64_t v14 = *(void *)(v13 + 8);
        int v15 = **(unsigned __int16 **)(v14 + 16);
        if (v15 != 69 && v15 != 0) {
          goto LABEL_73;
        }
        if (*(void *)(v14 + 24) != a2) {
          goto LABEL_73;
        }
        int v17 = *(_DWORD *)(v8 + 40);
        if (v17 == 1) {
          goto LABEL_73;
        }
LABEL_21:
        uint64_t v18 = *(void *)(v8 + 32);
        unsigned int v19 = 1;
        while (*(void *)(v18 + 32 * (v19 + 1) + 16) != a2)
        {
          v19 += 2;
          if (v17 == v19) {
            goto LABEL_27;
          }
        }
        if ((unsigned int v20 = *(_DWORD *)(v18 + 32 * v19 + 4)) != 0
          && (uint64_t result = llvm::MachineRegisterInfo::getVRegDef(a1[3], v20)) != 0
          && *(void *)(result + 24) == a2
          && **(_WORD **)(result + 16)
          && (**(_WORD **)(result + 16) != 69 ? (BOOL v29 = result == v7) : (BOOL v29 = 1), !v29))
        {
          uint64_t v22 = 0;
          uint64_t v35 = result;
          uint64_t v33 = a3;
          uint64_t v34 = (unsigned __int8 **)(result + 56);
          uint64_t v23 = result;
          do
          {
            uint64_t result = llvm::MachineInstr::findRegisterUseOperandIdx(v23, v10, 0, 0);
            if (result != -1)
            {
              if (v22)
              {
                uint64_t VirtualRegister = v22;
              }
              else
              {
                uint64_t VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(a1[3], *(void *)(*(void *)(a1[3] + 24) + 16 * (v10 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
                LODWORD(v22) = VirtualRegister;
                BOOL v24 = sub_1CB84B030(a2, v35, v34, *(void *)(a1[4] + 8) + 912, VirtualRegister);
                uint64_t v39 = 0;
                v38[0] = 0;
                v38[1] = v10;
                uint64_t v40 = 0;
                uint64_t v41 = 0;
                llvm::MachineInstr::addOperand(v25, v24, (const llvm::MachineOperand *)v38);
              }
              uint64_t result = llvm::MachineInstr::substituteRegister(v23, v10, v22, 0, v37);
              uint64_t v22 = VirtualRegister;
            }
            uint64_t v23 = *(void *)(v23 + 8);
          }
          while (v23 != v7);
          if (!v22)
          {
            uint64_t v14 = *(void *)(v13 + 8);
            a3 = v33;
            goto LABEL_27;
          }
          a3 = v33;
          uint64_t v30 = *((unsigned int *)v33 + 2);
          if (v30)
          {
            unsigned int v31 = v22;
            uint64_t v28 = *v33;
            uint64_t v36 = *v33 + 8 * v30;
            unsigned int v32 = v31;
            do
            {
              uint64_t v26 = *(void *)v28 + 48;
              for (uint64_t i = *(void *)(*(void *)v28 + 56); i != v26; uint64_t i = *(void *)(i + 8))
              {
                uint64_t result = llvm::MachineInstr::findRegisterUseOperandIdx(i, v10, 0, 0);
                if (result != -1) {
                  uint64_t result = llvm::MachineInstr::substituteRegister(i, v10, v32, 0, v37);
                }
                if (!i || (*(unsigned char *)i & 4) == 0)
                {
                  while ((*(_WORD *)(i + 44) & 8) != 0)
                    uint64_t i = *(void *)(i + 8);
                }
              }
              v28 += 8;
              a3 = v33;
            }
            while (v28 != v36);
          }
        }
        else
        {
LABEL_73:
        {
LABEL_27:
          while (1)
          {
            uint64_t v13 = *(void *)(v13 + 24);
            if (!v13) {
              break;
            }
            if ((*(unsigned char *)(v13 + 3) & 1) == 0 && *(void *)(v13 + 8) != v14)
            {
              uint64_t v14 = *(void *)(v13 + 8);
              goto LABEL_21;
            }
          }
        }
        }
LABEL_13:
        if (!v8) {
          goto LABEL_17;
        }
      }
      if ((*(unsigned char *)v8 & 4) == 0)
      {
LABEL_17:
        while ((*(_WORD *)(v8 + 44) & 8) != 0)
          uint64_t v8 = *(void *)(v8 + 8);
      }
      uint64_t v8 = *(void *)(v8 + 8);
    }
  }
  return result;
}

void llvm::ModuloScheduleExpander::addBranches(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, void *a5, uint64_t a6)
{
  uint64_t v7 = a4;
  unsigned int v9 = 0;
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t v33 = v35;
  int v24 = *(_DWORD *)(a3 + 8);
  unsigned int v10 = v24 - 1;
  uint64_t v34 = 0x400000000;
  uint64_t v11 = a4;
  unsigned int v27 = v24 - 1;
  do
  {
    unint64_t v12 = *(llvm::MachineBasicBlock **)(*(void *)a3 + 8 * v10);
    uint64_t v13 = *(char **)(*a5 + 8 * v9);
    uint64_t v30 = v32;
    uint64_t v31 = 0x400000000;
    unsigned __int16 v14 = (*(uint64_t (**)(void, void, llvm::MachineBasicBlock *, void **))(**(void **)(a1 + 72) + 24))(*(void *)(a1 + 72), v10 + 1, v12, &v30);
    if (v14 > 0xFFu)
    {
      if ((_BYTE)v14)
      {
        uint64_t v17 = *(void *)(a1 + 32);
        BOOL v29 = 0;
        int v16 = (*(uint64_t (**)(uint64_t, llvm::MachineBasicBlock *, uint64_t *, void, void *, void, unsigned __int8 **, void))(*(void *)v17 + 272))(v17, v12, v11, 0, v30, v31, &v29, 0);
        if (v29) {
          llvm::MetadataTracking::untrack((uint64_t)&v29, v29);
        }
        sub_1CC3C6850(v13, (uint64_t)v12);
      }
      else
      {
        llvm::MachineBasicBlock::addSuccessor(v12, v13, -1);
        llvm::MachineBasicBlock::removeSuccessor(v12, (llvm::MachineBasicBlock *)v11, 0);
        llvm::MachineBasicBlock::removeSuccessor((llvm::MachineBasicBlock *)v7, (llvm::MachineBasicBlock *)v13, 0);
        uint64_t v23 = *(void *)(a1 + 32);
        BOOL v29 = 0;
        int v16 = (*(uint64_t (**)(void))(*(void *)v23 + 272))();
        if (v29) {
          llvm::MetadataTracking::untrack((uint64_t)&v29, v29);
        }
        sub_1CC3C6850(v13, (uint64_t)v7);
        if (v11 != v7)
        {
          sub_1CC3C971C((uint64_t)(v7 + 5), v7[7], (uint64_t)(v7 + 6));
          llvm::MachineBasicBlock::eraseFromParent((llvm::MachineBasicBlock *)v7);
        }
        if (v11 == a4)
        {
          (*(void (**)(void))(**(void **)(a1 + 72) + 48))(*(void *)(a1 + 72));
          *(void *)(a1 + 64) = 0;
        }
        sub_1CC3C971C((uint64_t)(v11 + 5), v11[7], (uint64_t)(v11 + 6));
        llvm::MachineBasicBlock::eraseFromParent((llvm::MachineBasicBlock *)v11);
      }
    }
    else
    {
      llvm::MachineBasicBlock::addSuccessor(v12, v13, -1);
      uint64_t v15 = *(void *)(a1 + 32);
      BOOL v29 = 0;
      int v16 = (*(uint64_t (**)(void))(*(void *)v15 + 272))();
      if (v29) {
        llvm::MetadataTracking::untrack((uint64_t)&v29, v29);
      }
    }
    uint64_t v18 = (void *)(*((void *)v12 + 6) & 0xFFFFFFFFFFFFFFF8);
    if ((void *)((char *)v12 + 48) != v18 && v16 != 0)
    {
      int v20 = v16 - 1;
      do
      {
        llvm::ModuloScheduleExpander::updateInstruction(a1, (uint64_t)v18, 0, v10, 0, a6);
        uint64_t v18 = (void *)(*v18 & 0xFFFFFFFFFFFFFFF8);
        BOOL v22 = v20-- != 0;
      }
      while ((void *)((char *)v12 + 48) != v18 && v22);
    }
    if (v30 != v32) {
      free(v30);
    }
    ++v9;
    --v10;
    uint64_t v11 = (uint64_t *)v12;
    uint64_t v7 = (uint64_t *)v13;
  }
  while (v9 <= v27);
  if (*(void *)(a1 + 64))
  {
    (*(void (**)(void, void))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72), *(void *)(*(void *)a3 + 8 * v27));
    (*(void (**)(void, void))(**(void **)(a1 + 72) + 32))(*(void *)(a1 + 72), -v24);
  }
  if (v33 != v35) {
    free(v33);
  }
}

void llvm::ModuloScheduleExpander::cleanup(llvm::ModuloScheduleExpander *this)
{
  uint64_t v2 = *((void *)this + 6);
  uint64_t v3 = v2 + 48;
  uint64_t v4 = *(void *)(v2 + 56);
  if (v4 != v2 + 48)
  {
    do
    {
      llvm::SlotIndexes::removeMachineInstrFromMaps(*(int32x2_t **)(*((void *)this + 5) + 288), (llvm::MachineInstr *)v4);
      if ((*(unsigned char *)v4 & 4) == 0)
      {
        while ((*(_WORD *)(v4 + 44) & 8) != 0)
          uint64_t v4 = *(void *)(v4 + 8);
      }
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4 != v3);
    uint64_t v2 = *((void *)this + 6);
    uint64_t v4 = *(void *)(v2 + 56);
  }
  sub_1CC3C971C(v2 + 40, v4, v2 + 48);
  uint64_t v5 = (llvm::MachineBasicBlock *)*((void *)this + 6);

  llvm::MachineBasicBlock::eraseFromParent(v5);
}

uint64_t llvm::ModuloScheduleExpander::rewritePhiValues(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(result + 48);
  uint64_t v6 = *(void *)(v5 + 56);
  if (v6 != v5 + 48)
  {
    uint64_t i = (uint64_t *)result;
    uint64_t v8 = *(void *)(v5 + 56);
    while (!**(_WORD **)(v8 + 16) || **(_WORD **)(v8 + 16) == 69)
    {
      uint64_t v8 = *(void *)(v8 + 8);
      if (v8 == v5 + 48)
      {
        uint64_t v8 = v5 + 48;
        break;
      }
    }
    if (v6 != v8)
    {
      uint64_t v33 = (uint64_t **)(result + 80);
      uint64_t v35 = (uint64_t *)result;
      unsigned int v10 = (uint64_t *)result;
      do
      {
        uint64_t v11 = *(void *)(v6 + 32);
        if (*(_DWORD *)(v6 + 40) == 1)
        {
          uint64_t v12 = 0;
          unsigned int v13 = 0;
        }
        else
        {
          unsigned int v14 = 0;
          unsigned int v13 = 0;
          LODWORD(v12) = 0;
          uint64_t v15 = i[6];
          int v16 = (unsigned int *)(v11 + 36);
          do
          {
            v14 += 2;
            uint64_t v17 = *(void *)(v11 + 32 * v14 + 16);
            unsigned int v19 = *v16;
            v16 += 16;
            unsigned int v18 = v19;
            if (v17 == v15) {
              uint64_t v12 = v18;
            }
            else {
              uint64_t v12 = v12;
            }
            if (v17 != v15) {
              unsigned int v13 = v18;
            }
          }
          while (*(_DWORD *)(v6 + 40) - 1 != v14);
        }
        unsigned int v20 = *(_DWORD *)(v11 + 4);
        uint64_t v21 = *i;
        uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(i[3], v20);
        uint64_t v41 = 0;
        if (sub_1CD3C8538((uint64_t *)(v21 + 56), &VRegDef, &v41)) {
          BOOL v22 = v41 == *(void *)(v21 + 56) + 16 * *(unsigned int *)(v21 + 72);
        }
        else {
          BOOL v22 = 1;
        }
        if (v22) {
          unsigned int v23 = -1;
        }
        else {
          unsigned int v23 = *(_DWORD *)(v41 + 8);
        }
        uint64_t v24 = *i;
        uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(i[3], v12);
        uint64_t v41 = 0;
        int v25 = sub_1CD3C8538((uint64_t *)(v24 + 56), &VRegDef, &v41);
        int v26 = -1;
        if (v25 && v41 != *(void *)(v24 + 56) + 16 * *(unsigned int *)(v24 + 72)) {
          int v26 = *(_DWORD *)(v41 + 8);
        }
        int v39 = v26;
        LODWORD(v41) = v20;
        unsigned int v27 = sub_1CD55B424(v33, v20, &v41);
        unsigned int v28 = 0;
        unsigned int v29 = (*((unsigned char *)v27 + 36) & 1) + *((_DWORD *)v27 + 8) - 1;
        unsigned int v30 = a3;
        if (v29 >= a3) {
          unsigned int v29 = a3;
        }
        unsigned int v38 = v29;
        do
        {
          unsigned int PrevMapVal = llvm::ModuloScheduleExpander::getPrevMapVal((uint64_t)v10, v30, v23, v12, v39, a4, v10[6]);
          if (PrevMapVal) {
            unsigned int v32 = PrevMapVal;
          }
          else {
            unsigned int v32 = v13;
          }
          uint64_t result = llvm::ModuloScheduleExpander::rewriteScheduledInstr((llvm::ModuloScheduleExpander *)v10, a2, a5, v30--, v28++, (llvm::MachineInstr *)v6, v20, v32, 0);
        }
        while (v28 <= v38);
        if (v6 && (*(unsigned char *)v6 & 4) != 0)
        {
          uint64_t i = v35;
        }
        else
        {
          for (i = v35; (*(_WORD *)(v6 + 44) & 8) != 0; uint64_t v6 = *(void *)(v6 + 8))
            ;
        }
        uint64_t v6 = *(void *)(v6 + 8);
      }
      while (v6 != v8);
    }
  }
  return result;
}

void llvm::ModuloScheduleExpander::updateMemOperands(llvm::ModuloScheduleExpander *this, llvm::MachineInstr *a2, llvm::MachineInstr *a3, int a4)
{
  uint64_t v32[2] = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v6 = (char *)a2 + 48;
    unint64_t v5 = *((void *)a2 + 6);
    if (v5 >= 8)
    {
      if ((v5 & 7) == 0)
      {
        unsigned int v30 = v32;
        uint64_t v31 = 0x200000000;
        v5 &= 0xFFFFFFFFFFFFFFF8;
        *(void *)uint64_t v6 = v5;
        if (!v5) {
          goto LABEL_18;
        }
        goto LABEL_11;
      }
      unsigned int v10 = (_DWORD *)(v5 & 0xFFFFFFFFFFFFFFF8);
      BOOL v11 = (*((void *)a2 + 6) & 7) != 3 || v10 == 0;
      if (!v11 && *v10)
      {
        unsigned int v30 = v32;
        uint64_t v31 = 0x200000000;
LABEL_11:
        if ((v5 & 7) == 0)
        {
          *((void *)a2 + 6) = v5 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v15 = (char *)a2 + 56;
          goto LABEL_23;
        }
        uint64_t v12 = (int *)(v5 & 0xFFFFFFFFFFFFFFF8);
        if ((v5 & 7) != 3 || v12 == 0)
        {
          LODWORD(v5) = 0;
        }
        else
        {
          unint64_t v28 = *v12;
          uint64_t v6 = (char *)(v12 + 2);
          unint64_t v5 = v28;
          if (v28)
          {
            uint64_t v15 = &v6[8 * v5];
LABEL_23:
            LODWORD(v5) = 0;
            do
            {
              uint64_t v16 = *(void *)v6;
              int v17 = *(unsigned __int16 *)(*(void *)v6 + 32);
              if ((v17 & 4) == 0
                && ((~v17 & 0x30) != 0 ? (BOOL v18 = (*(_WORD *)(v16 + 36) & 0xF00) == 0) : (BOOL v18 = 0),
                    v18 && (*(void *)v16 >= 8uLL ? (BOOL v19 = (*(void *)v16 & 4) == 0) : (BOOL v19 = 0), v19)))
              {
                unsigned int v29 = 0;
                if (a4 == -1 || !llvm::ModuloScheduleExpander::computeDelta(this, a3, &v29))
                {
                  uint64_t v24 = *((void *)this + 1);
                  uint64_t v25 = v16;
                  uint64_t v26 = 0;
                  uint64_t v23 = 0;
                }
                else
                {
                  uint64_t v20 = v29 * a4;
                  uint64_t v21 = *((void *)this + 1);
                  unint64_t v22 = sub_1CB8F20C0(v16);
                  if (v22 == -1) {
                    uint64_t v23 = 0;
                  }
                  else {
                    uint64_t v23 = ((v22 & 0x1FFFFFFF) << 6) | 1;
                  }
                  uint64_t v24 = v21;
                  uint64_t v25 = v16;
                  uint64_t v26 = v20;
                }
                unint64_t MachineMemOperand = llvm::MachineFunction::getMachineMemOperand(v24, v25, v26, v23);
                if (v31 >= (unint64_t)HIDWORD(v31)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v30 + v31) = MachineMemOperand;
              }
              else
              {
                if (v5 >= HIDWORD(v31)) {
                  llvm::SmallVectorBase<unsigned int>::grow_pod();
                }
                *((void *)v30 + v5) = v16;
              }
              LODWORD(v5) = v31 + 1;
              LODWORD(v31) = v31 + 1;
              v6 += 8;
            }
            while (v6 != v15);
            unsigned int v14 = v30;
            goto LABEL_19;
          }
        }
LABEL_18:
        unsigned int v14 = v32;
LABEL_19:
        llvm::MachineInstr::setMemRefs((uint64_t)a2, *((uint64_t **)this + 1), v14, v5);
        if (v30 != v32) {
          free(v30);
        }
      }
    }
  }
}

uint64_t llvm::ModuloScheduleExpander::findDefInLoop(llvm::ModuloScheduleExpander *this, unsigned int a2)
{
  uint64_t v12 = v16;
  unsigned int v13 = v16;
  uint64_t v14 = 8;
  int v15 = 0;
  uint64_t v3 = *((void *)this + 3);
LABEL_2:
  uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(v3, a2);
LABEL_3:
  while (1)
  {
    int v5 = **(unsigned __int16 **)(VRegDef + 16);
    if (v5 != 69 && v5 != 0) {
      break;
    }
    sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v12, VRegDef);
    if (!v7) {
      break;
    }
    unsigned int v8 = *(_DWORD *)(VRegDef + 40);
    if (v8 >= 2)
    {
      uint64_t v9 = *(void *)(VRegDef + 32);
      unsigned int v10 = 1;
      while (*(void *)(v9 + 32 * (v10 + 1) + 16) != *((void *)this + 6))
      {
        v10 += 2;
        if (v10 >= v8) {
          goto LABEL_3;
        }
      }
      uint64_t v3 = *((void *)this + 3);
      a2 = *(_DWORD *)(v9 + 32 * v10 + 4);
      goto LABEL_2;
    }
  }
  if (v13 != v12) {
    free(v13);
  }
  return VRegDef;
}

uint64_t llvm::ModuloScheduleExpander::getPrevMapVal(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  int v39 = a4;
  if (a2 <= a3) {
    return 0;
  }
  uint64_t v10 = a4;
  unint64_t v12 = a2;
  uint64_t v13 = *(void *)(a1 + 24);
  while (1)
  {
    uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(v13, v10);
    if (a3 == a5)
    {
      uint64_t v15 = a6 + 24 * (v12 - 1);
      int v16 = *(_DWORD *)(v15 + 16);
      if (v16)
      {
        int v17 = v16 - 1;
        unsigned int v18 = v17 & (37 * v10);
        int v19 = *(_DWORD *)(*(void *)v15 + 8 * v18);
        if (v10 == v19) {
          goto LABEL_36;
        }
        int v37 = 1;
        while (v19 != -1)
        {
          unsigned int v38 = v18 + v37++;
          unsigned int v18 = v38 & v17;
          int v19 = *(_DWORD *)(*(void *)v15 + 8 * v18);
          if (v10 == v19) {
            goto LABEL_36;
          }
        }
      }
    }
    uint64_t v15 = a6 + 24 * v12;
    int v21 = *(_DWORD *)(v15 + 16);
    if (v21)
    {
      int v22 = v21 - 1;
      unsigned int v23 = v22 & (37 * v10);
      int v24 = *(_DWORD *)(*(void *)v15 + 8 * v23);
      if (v10 == v24)
      {
LABEL_36:
        uint64_t v34 = sub_1CB8387D8(v15, &v39) + 1;
        return *v34;
      }
      int v35 = 1;
      while (v24 != -1)
      {
        unsigned int v36 = v23 + v35++;
        unsigned int v23 = v36 & v22;
        int v24 = *(_DWORD *)(*(void *)v15 + 8 * v23);
        if (v10 == v24) {
          goto LABEL_36;
        }
      }
    }
    int v25 = **(unsigned __int16 **)(VRegDef + 16);
    BOOL v26 = v25 == 69 || v25 == 0;
    if (!v26 || *(void *)(VRegDef + 24) != a7) {
      return v10;
    }
    unint64_t v27 = a3 + 1;
    if (v12 == v27) {
      break;
    }
    if (v12 <= v27) {
      return 0;
    }
    int v28 = *(_DWORD *)(VRegDef + 40);
    if (v28 == 1)
    {
LABEL_22:
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v29 = *(void *)(VRegDef + 32);
      unsigned int v20 = 1;
      while (*(void *)(v29 + 32 * (v20 + 1) + 16) != a7)
      {
        v20 += 2;
        if (v28 == v20) {
          goto LABEL_22;
        }
      }
      uint64_t v10 = *(unsigned int *)(v29 + 32 * v20 + 4);
    }
    --v12;
    int v39 = v10;
  }
  int v30 = *(_DWORD *)(VRegDef + 40);
  if (v30 == 1) {
    return 0;
  }
  uint64_t v32 = *(void *)(VRegDef + 32);
  unsigned int v33 = 1;
  while (*(void *)(v32 + 32 * (v33 + 1) + 16) == a7)
  {
    uint64_t v10 = 0;
    v33 += 2;
    if (v30 == v33) {
      return v10;
    }
  }
  uint64_t v34 = (unsigned int *)(v32 + 32 * v33 + 4);
  return *v34;
}

void llvm::PeelingModuloScheduleExpander::peelKernel(uint64_t a1, int a2)
{
}

uint64_t sub_1CD558FB0(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v8 = a2;
  uint64_t v4 = a1 + 29;
  if (sub_1CD40EA84(a1[29], *((_DWORD *)a1 + 62), a2, &v10))
  {
    uint64_t v2 = sub_1CD4F8350(v4, &v8)[1];
    uint64_t v8 = v2;
  }
  uint64_t v5 = *a1;
  uint64_t v9 = v2;
  uint64_t v10 = 0;
  if (sub_1CD3C8538((uint64_t *)(v5 + 56), &v9, &v10)) {
    BOOL v6 = v10 == *(void *)(v5 + 56) + 16 * *(unsigned int *)(v5 + 72);
  }
  else {
    BOOL v6 = 1;
  }
  if (v6) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *(unsigned int *)(v10 + 8);
  }
}

uint64_t llvm::PeelingModuloScheduleExpander::getEquivalentRegisterIn(uint64_t a1, unsigned int a2, uint64_t a3)
{
  Uniqueuint64_t VRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(*(void *)(a1 + 24), a2);
  unsigned int RegisterDefOperandIdx = llvm::MachineInstr::findRegisterDefOperandIdx(UniqueVRegDef, a2, 0, 0, 0);
  uint64_t v7 = sub_1CD4F8350((uint64_t *)(a1 + 232), &UniqueVRegDef)[1];
  v9[0] = a3;
  v9[1] = v7;
  return *(unsigned int *)(*(void *)(sub_1CD55B4F4(a1 + 256, v9)[2] + 32) + 32 * RegisterDefOperandIdx + 4);
}

uint64_t llvm::PeelingModuloScheduleExpander::moveStageBetweenBlocks(llvm::PeelingModuloScheduleExpander *this, llvm::MachineBasicBlock *a2, llvm::MachineBasicBlock *a3, int a4)
{
  uint64_t v5 = a3;
  v73[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (char *)a2 + 48;
  uint64_t v8 = (char *)*((void *)a2 + 7);
  uint64_t v9 = (char *)a2 + 48;
  if (v8 != (char *)a2 + 48)
  {
    uint64_t v9 = (char *)*((void *)a2 + 7);
    while (!**((_WORD **)v9 + 2) || **((_WORD **)v9 + 2) == 69)
    {
      uint64_t v9 = (char *)*((void *)v9 + 1);
      if (v9 == v7)
      {
        uint64_t v9 = (char *)a2 + 48;
        break;
      }
    }
  }
  v65[0] = 0;
  v65[1] = 0;
  int v66 = 0;
  uint64_t v10 = (char *)a3 + 48;
  for (uint64_t i = *((void *)a3 + 7); (char *)i != v10; uint64_t i = *(void *)(i + 8))
  {
    if (**(_WORD **)(i + 16) && **(_WORD **)(i + 16) != 69)
    {
      if (v10 != (char *)i)
      {
        uint64_t v61 = (uint64_t *)((char *)this + 232);
        int v62 = (char *)this + 256;
        do
        {
          if (!i || (uint64_t v12 = i, (*(unsigned char *)i & 4) == 0))
          {
            uint64_t v12 = i;
            if ((*(_WORD *)(i + 44) & 8) != 0)
            {
              uint64_t v12 = i;
              do
                uint64_t v12 = *(void *)(v12 + 8);
              while ((*(_WORD *)(v12 + 44) & 8) != 0);
            }
          }
          uint64_t v13 = *(char **)(v12 + 8);
          int v14 = **(unsigned __int16 **)(i + 16);
          BOOL v15 = v14 == 69 || v14 == 0;
          if (v15 && sub_1CD558FB0((uint64_t *)this, i) != a4)
          {
            LODWORD(v69) = *(_DWORD *)(*(void *)(i + 32) + 4);
            int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(*((void *)this + 3), *(void *)(*(void *)(*((void *)this + 3) + 24) + 16 * (v69 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
            v67[0] = 0;
            int v17 = v7;
            if (*((char **)a2 + 7) != v7)
            {
              int v17 = (char *)*((void *)a2 + 7);
              while (!**((_WORD **)v17 + 2) || **((_WORD **)v17 + 2) == 69)
              {
                int v17 = (char *)*((void *)v17 + 1);
                if (v17 == v7)
                {
                  int v17 = v7;
                  break;
                }
              }
            }
            int v60 = a4;
            uint64_t v70 = 0;
            int v57 = VirtualRegister;
            unsigned int v18 = sub_1CB85AA4C((uint64_t)a2, (unint64_t *)v17, &v70, *(void *)(*((void *)this + 4) + 8), VirtualRegister);
            unsigned int v20 = v19;
            uint64_t v72 = 0;
            v73[0] = 0;
            LODWORD(v71) = 0;
            HIDWORD(v71) = v69;
            v73[1] = 0;
            llvm::MachineInstr::addOperand(v19, v18, (const llvm::MachineOperand *)&v71);
            uint64_t v72 = 0;
            v73[0] = v5;
            LODWORD(v71) = 4;
            llvm::MachineInstr::addOperand(v20, v18, (const llvm::MachineOperand *)&v71);
            if (v70) {
              llvm::MetadataTracking::untrack((uint64_t)&v70, v70);
            }
            v67[0] = (uint64_t)v20;
            uint64_t v70 = (unsigned __int8 *)i;
            uint64_t v21 = sub_1CD4F8350(v61, &v70)[1];
            uint64_t v71 = a2;
            uint64_t v72 = v21;
            sub_1CD55B4F4((uint64_t)v62, (uint64_t *)&v71)[2] = v20;
            uint64_t v71 = (void *)i;
            uint64_t v22 = sub_1CD4F8350(v61, &v71)[1];
            sub_1CD4F8350(v61, v67)[1] = v22;
            sub_1CD4145B8((uint64_t)v65, (int *)&v69)[1] = v57;
            a4 = v60;
          }
          if (sub_1CD558FB0((uint64_t *)this, i) == a4)
          {
            llvm::MachineInstr::removeFromParent((llvm::MachineInstr *)i);
            llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)a2 + 5, i);
            unint64_t v23 = *(void *)v9 & 0xFFFFFFFFFFFFFFF8;
            *(void *)uint64_t i = v23 | *(void *)i & 7;
            *(void *)(i + 8) = v9;
            *(void *)(v23 + 8) = i;
            *(void *)uint64_t v9 = *(void *)v9 & 7 | i;
            uint64_t v71 = (void *)i;
            uint64_t v24 = sub_1CD4F8350(v61, &v71)[1];
            uint64_t v71 = a2;
            uint64_t v72 = v24;
            sub_1CD55B4F4((uint64_t)v62, (uint64_t *)&v71)[2] = i;
            uint64_t v71 = 0;
            if (sub_1CD553C1C(*((void *)this + 32), *((_DWORD *)this + 68), (uint64_t)v5, v24, &v71))
            {
              int v25 = v71;
              *(void *)uint64_t v71 = -8192;
              v25[1] = -8192;
              *((int32x2_t *)this + 33) = vadd_s32(*(int32x2_t *)((char *)this + 264), (int32x2_t)0x1FFFFFFFFLL);
            }
          }
          uint64_t i = (uint64_t)v13;
        }
        while (v13 != v10);
        uint64_t v8 = (char *)*((void *)a2 + 7);
      }
      break;
    }
  }
  uint64_t v71 = v73;
  uint64_t v72 = 0x400000000;
  BOOL v26 = v7;
  if (v8 != v7)
  {
    BOOL v26 = v8;
    while (!**((_WORD **)v26 + 2) || **((_WORD **)v26 + 2) == 69)
    {
      BOOL v26 = (char *)*((void *)v26 + 1);
      if (v26 == v7)
      {
        BOOL v26 = v7;
        break;
      }
    }
  }
  if (v8 != v26)
  {
    do
    {
      uint64_t VRegDef = llvm::MachineRegisterInfo::getVRegDef(*((void *)this + 3), *(_DWORD *)(*((void *)v8 + 4) + 36));
      if (sub_1CD558FB0((uint64_t *)this, VRegDef) == a4)
      {
        uint64_t v28 = *((void *)v8 + 4);
        unsigned int v29 = *(_DWORD *)(v28 + 4);
        llvm::MachineRegisterInfo::replaceRegWith(*((void **)this + 3), v29, *(_DWORD *)(v28 + 36));
        llvm::MachineOperand::setReg(*((void *)v8 + 4), v29);
        if (v72 >= (unint64_t)HIDWORD(v72)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)v71 + v72) = v8;
        LODWORD(v72) = v72 + 1;
      }
      if ((*v8 & 4) == 0)
      {
        while ((*((_WORD *)v8 + 22) & 8) != 0)
          uint64_t v8 = (char *)*((void *)v8 + 1);
      }
      uint64_t v8 = (char *)*((void *)v8 + 1);
    }
    while (v8 != v26);
    if (v72)
    {
      int v30 = (llvm::MachineInstr **)v71;
      uint64_t v31 = 8 * v72;
      do
      {
        uint64_t v32 = *v30++;
        llvm::MachineInstr::eraseFromParent(v32);
        v31 -= 8;
      }
      while (v31);
    }
  }
  uint64_t v33 = *((void *)a2 + 7);
  if ((char *)v33 == v7) {
    goto LABEL_92;
  }
  uint64_t v34 = (char *)*((void *)a2 + 7);
  while (!**((_WORD **)v34 + 2) || **((_WORD **)v34 + 2) == 69)
  {
    uint64_t v34 = (char *)*((void *)v34 + 1);
    if (v34 == v7)
    {
      uint64_t v34 = v7;
      break;
    }
  }
  while (!**(_WORD **)(v33 + 16) || **(_WORD **)(v33 + 16) == 69)
  {
    uint64_t v33 = *(void *)(v33 + 8);
    if ((char *)v33 == v7) {
      goto LABEL_92;
    }
  }
  if (v7 == (char *)v33) {
    goto LABEL_92;
  }
  unint64_t v59 = v5;
  uint64_t v58 = (uint64_t *)((char *)this + 232);
  uint64_t v56 = (char *)this + 208;
  do
  {
    uint64_t v35 = *(void *)(v33 + 32);
    unsigned int NumExplicitDefs = llvm::MachineInstr::getNumExplicitDefs((llvm::MachineInstr *)v33);
    uint64_t v37 = *(unsigned int *)(v33 + 40);
    if (NumExplicitDefs == v37) {
      goto LABEL_69;
    }
    uint64_t v38 = v35 + 32 * v37;
    uint64_t v39 = v35 + 32 * NumExplicitDefs;
    do
    {
      if (*(unsigned char *)v39) {
        goto LABEL_73;
      }
      unsigned int v40 = *(_DWORD *)(v39 + 4);
      if (v66)
      {
        unsigned int v41 = (v66 - 1) & (37 * v40);
        int v42 = *(_DWORD *)(v65[0] + 8 * v41);
        if (v40 == v42)
        {
LABEL_77:
          LODWORD(v67[0]) = *(_DWORD *)(v39 + 4);
          unsigned int v43 = sub_1CD4145B8((uint64_t)v65, (int *)v67)[1];
          uint64_t v44 = v39;
LABEL_78:
          llvm::MachineOperand::setReg(v44, v43);
          goto LABEL_73;
        }
        int v54 = 1;
        while (v42 != -1)
        {
          unsigned int v55 = v41 + v54++;
          unsigned int v41 = v55 & (v66 - 1);
          int v42 = *(_DWORD *)(v65[0] + 8 * v41);
          if (v40 == v42) {
            goto LABEL_77;
          }
        }
      }
      Uniqueuint64_t VRegDef = llvm::MachineRegisterInfo::getUniqueVRegDef(*((void *)this + 3), v40);
      if (UniqueVRegDef)
      {
        int v46 = **(unsigned __int16 **)(UniqueVRegDef + 16);
        BOOL v47 = v46 == 69 || v46 == 0;
        if (v47 && *(llvm::MachineBasicBlock **)(UniqueVRegDef + 24) == v5)
        {
          unint64_t v69 = 0;
          uint64_t v70 = (unsigned __int8 *)UniqueVRegDef;
          unint64_t v48 = llvm::MachineFunction::CloneMachineInstr(*((llvm::MachineFunction **)this + 1), (const llvm::MachineInstr *)UniqueVRegDef);
          unint64_t v69 = v48;
          llvm::ilist_traits<llvm::MachineInstr>::addNodeToList((uint64_t *)a2 + 5, v48);
          unint64_t v49 = *(void *)v34 & 0xFFFFFFFFFFFFFFF8;
          *(void *)unint64_t v48 = v49 | *(void *)v48 & 7;
          *(void *)(v48 + 8) = v34;
          *(void *)(v49 + 8) = v48;
          *(void *)uint64_t v34 = *(void *)v34 & 7 | v48;
          unsigned int v68 = *(_DWORD *)(*((void *)v70 + 4) + 4);
          unsigned int v63 = llvm::MachineRegisterInfo::createVirtualRegister(*((void *)this + 3), *(void *)(*(void *)(*((void *)this + 3) + 24) + 16 * (v68 & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
          llvm::MachineOperand::setReg(*(void *)(v69 + 32), v63);
          llvm::MachineOperand::setReg(*(void *)(v69 + 32) + 32, v68);
          *(void *)(*(void *)(v69 + 32) + 80) = **((void **)a2 + 8);
          sub_1CD4145B8((uint64_t)v65, (int *)&v68)[1] = v63;
          uint64_t v50 = sub_1CD4F8350(v58, &v70)[1];
          sub_1CD4F8350(v58, &v69)[1] = v50;
          uint64_t v51 = v69;
          uint64_t v52 = sub_1CD4F8350(v58, &v70)[1];
          v67[0] = (uint64_t)a2;
          v67[1] = v52;
          uint64_t v5 = v59;
          sub_1CD55B4F4((uint64_t)this + 256, v67)[2] = v51;
          LODWORD(v51) = *((_DWORD *)sub_1CC308370((uint64_t)v56, (uint64_t *)&v70) + 2);
          *((_DWORD *)sub_1CC308370((uint64_t)v56, (uint64_t *)&v69) + 2) = v51;
          uint64_t v44 = v39;
          unsigned int v43 = v63;
          goto LABEL_78;
        }
      }
LABEL_73:
      v39 += 32;
    }
    while (v39 != v38);
    if (!v33) {
      goto LABEL_90;
    }
LABEL_69:
    if ((*(unsigned char *)v33 & 4) == 0)
    {
LABEL_90:
      while ((*(_WORD *)(v33 + 44) & 8) != 0)
        uint64_t v33 = *(void *)(v33 + 8);
    }
    uint64_t v33 = *(void *)(v33 + 8);
  }
  while ((char *)v33 != v7);
LABEL_92:
  if (v71 != v73) {
    free(v71);
  }
  return MEMORY[0x1D25D9CD0](v65[0], 4);
}

uint64_t llvm::PeelingModuloScheduleExpander::getPhiCanonicalReg(llvm::PeelingModuloScheduleExpander *this, llvm::MachineInstr *VRegDef, llvm::MachineInstr *a3)
{
  uint64_t v12 = a3;
  int v5 = *((_DWORD *)sub_1CC308370((uint64_t)this + 208, (uint64_t *)&v12) + 2);
  if (!v5) {
    return *(unsigned int *)(*((void *)VRegDef + 4) + 4);
  }
  uint64_t v6 = *((void *)this + 3);
  do
  {
    uint64_t v7 = *((void *)VRegDef + 4);
    if (*(void *)(v7 + 80) == *((void *)VRegDef + 3)) {
      uint64_t v8 = 32;
    }
    else {
      uint64_t v8 = 96;
    }
    uint64_t v9 = v7 + v8;
    uint64_t v10 = *(unsigned int *)(v9 + 4);
    uint64_t VRegDef = (llvm::MachineInstr *)llvm::MachineRegisterInfo::getVRegDef(v6, *(_DWORD *)(v9 + 4));
    --v5;
  }
  while (v5);
  return v10;
}

void llvm::PeelingModuloScheduleExpander::peelPrologAndEpilogs(llvm::PeelingModuloScheduleExpander *this)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (uint64_t *)((char *)this + 48);
  sub_1CB9F9A80((uint64_t)&v49, *(_DWORD *)(*(void *)this + 80), 1);
  sub_1CB9F9A80((uint64_t)v46, *(_DWORD *)(*(void *)this + 80), 1);
  uint64_t v3 = sub_1CD55B7E0((uint64_t)this + 160, v2);
  sub_1CBAF13E8((uint64_t)(v3 + 1), (uint64_t)&v49);
  *((_DWORD *)v3 + 18) = v52;
  uint64_t v4 = sub_1CD55B7E0((uint64_t)this + 184, v2);
  sub_1CBAF13E8((uint64_t)(v4 + 1), (uint64_t)v46);
  *((_DWORD *)v4 + 18) = v48;
  if (v50) {
    bzero(v49, 8 * v50);
  }
  if (*(int *)(*(void *)this + 80) >= 2)
  {
    *(void *)v49 |= 1uLL;
    llvm::PeelingModuloScheduleExpander::peelKernel((uint64_t)this, 0);
  }
  LCSSAExitingBlocint k = llvm::PeelingModuloScheduleExpander::CreateLCSSAExitingBlock(this);
  sub_1CC3C6F20((uint64_t)LCSSAExitingBlock, *((void **)this + 3), *((void *)this + 5), 1);
  if (*(int *)(*(void *)this + 80) >= 2) {
    llvm::PeelingModuloScheduleExpander::peelKernel((uint64_t)this, 1);
  }
  unint64_t v5 = *((unsigned int *)this + 30);
  if (v5)
  {
    for (unint64_t i = 0; i < v5; ++i)
    {
      uint64_t v7 = v49;
      if (v50) {
        bzero(v49, 8 * v50);
      }
      for (unint64_t j = i; j < v5; ++j)
      {
        unsigned int v9 = i - j + *(_DWORD *)(*(void *)this + 80) - 1;
        unint64_t v10 = (int)j;
        if ((int)j > i)
        {
          do
          {
            unint64_t v11 = v10 - 1;
            llvm::PeelingModuloScheduleExpander::moveStageBetweenBlocks(this, *(llvm::MachineBasicBlock **)(*((void *)this + 14) + 8 * v10 - 8), *(llvm::MachineBasicBlock **)(*((void *)this + 14) + 8 * v10), v9);
            unint64_t v10 = v11;
          }
          while (v11 > i);
          uint64_t v7 = v49;
          unint64_t v5 = *((unsigned int *)this + 30);
        }
        v7[v9 >> 6] |= 1 << v9;
      }
      uint64_t v12 = sub_1CD55B7E0((uint64_t)this + 160, (uint64_t *)(*((void *)this + 14) + 8 * i));
      sub_1CBAF13E8((uint64_t)(v12 + 1), (uint64_t)&v49);
      *((_DWORD *)v12 + 18) = v52;
      uint64_t v13 = sub_1CD55B7E0((uint64_t)this + 184, (uint64_t *)(*((void *)this + 14) + 8 * i));
      sub_1CBAF13E8((uint64_t)(v13 + 1), (uint64_t)v46);
      *((_DWORD *)v13 + 18) = v48;
      unint64_t v5 = *((unsigned int *)this + 30);
    }
  }
  if (*((_DWORD *)this + 18))
  {
    int v14 = (uint64_t *)*((void *)this + 8);
    BOOL v15 = (void **)*((void *)this + 14);
    do
    {
      uint64_t v16 = *(void *)(*v15)[8];
      llvm::MachineBasicBlock::addSuccessor((void *)*v14, *v15, -1);
      uint64_t v17 = (uint64_t)(*v15 + 6);
      uint64_t v18 = (*v15)[7];
      if (v18 != v17)
      {
        uint64_t v19 = (*v15)[7];
        while (!**(_WORD **)(v19 + 16) || **(_WORD **)(v19 + 16) == 69)
        {
          uint64_t v19 = *(void *)(v19 + 8);
          if (v19 == v17)
          {
            uint64_t v19 = (uint64_t)(*v15 + 6);
            break;
          }
        }
        while (v18 != v19)
        {
          unsigned int PhiCanonicalReg = *(_DWORD *)(*(void *)(v18 + 32) + 36);
          int v42 = 0;
          Uniqueuint64_t VRegDef = (llvm::MachineInstr *)llvm::MachineRegisterInfo::getUniqueVRegDef(*((void *)this + 3), PhiCanonicalReg);
          int v42 = UniqueVRegDef;
          if (UniqueVRegDef && *((void *)UniqueVRegDef + 3) == v16)
          {
            unint64_t v23 = (unsigned __int16 **)sub_1CD4F8350((uint64_t *)this + 29, &v42)[1];
            int v24 = *v23[2];
            if (v24 == 69 || v24 == 0) {
              unsigned int PhiCanonicalReg = llvm::PeelingModuloScheduleExpander::getPhiCanonicalReg(this, (llvm::MachineInstr *)v23, v42);
            }
            unsigned int PhiCanonicalReg = llvm::PeelingModuloScheduleExpander::getEquivalentRegisterIn((uint64_t)this, PhiCanonicalReg, *v14);
          }
          uint64_t v44 = 0;
          LODWORD(v43) = 0;
          HIDWORD(v43) = PhiCanonicalReg;
          v45[0] = 0;
          v45[1] = 0;
          llvm::MachineInstr::addOperand((llvm::MachineInstr *)v18, (const llvm::MachineOperand *)&v43);
          uint64_t v22 = *v14;
          uint64_t v44 = 0;
          v45[0] = v22;
          LODWORD(v43) = 4;
          llvm::MachineInstr::addOperand((llvm::MachineInstr *)v18, (const llvm::MachineOperand *)&v43);
          if ((*(unsigned char *)v18 & 4) == 0)
          {
            while ((*(_WORD *)(v18 + 44) & 8) != 0)
              uint64_t v18 = *(void *)(v18 + 8);
          }
          uint64_t v18 = *(void *)(v18 + 8);
        }
      }
      ++v14;
      ++v15;
    }
    while (v14 != (uint64_t *)(*((void *)this + 8) + 8 * *((unsigned int *)this + 18)));
  }
  unsigned int v43 = v45;
  uint64_t v44 = 0x800000000;
  sub_1CD55A628((void *)this + 35, (uint64_t)&v43);
  if (v44 >= HIDWORD(v44)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *((void *)v43 + v44) = *((void *)this + 6);
  LODWORD(v44) = v44 + 1;
  sub_1CD55A628((void *)this + 41, (uint64_t)&v43);
  if (v44)
  {
    BOOL v26 = (char *)v43;
    unint64_t v27 = (char *)v43 + 8 * v44;
    do
    {
      unsigned int v29 = (llvm::MachineBasicBlock *)*((void *)v27 - 1);
      v27 -= 8;
      uint64_t v28 = v29;
      FirstInstrTerminator = (llvm::MachineInstr *)llvm::MachineBasicBlock::getFirstInstrTerminator(v29);
      uint64_t v31 = (char *)v29 + 48;
      while (1)
      {
        uint64_t v32 = (char *)v28 + 48;
        if (*((char **)v28 + 7) != v31)
        {
          uint64_t v32 = (char *)*((void *)v28 + 7);
          while (!**((_WORD **)v32 + 2) || **((_WORD **)v32 + 2) == 69)
          {
            uint64_t v32 = (char *)*((void *)v32 + 1);
            if (v32 == v31)
            {
              uint64_t v32 = (char *)v28 + 48;
              break;
            }
          }
        }
        if (FirstInstrTerminator == (llvm::MachineInstr *)(*(void *)v32 & 0xFFFFFFFFFFFFFFF8)) {
          break;
        }
        unint64_t v33 = *(void *)FirstInstrTerminator & 0xFFFFFFFFFFFFFFF8;
        llvm::PeelingModuloScheduleExpander::rewriteUsesOf(this, FirstInstrTerminator);
        FirstInstrTerminator = (llvm::MachineInstr *)v33;
      }
    }
    while (v27 != v26);
  }
  uint64_t v34 = *((unsigned int *)this + 96);
  if (v34)
  {
    uint64_t v35 = (llvm::MachineInstr **)*((void *)this + 47);
    uint64_t v36 = 8 * v34;
    do
    {
      uint64_t v37 = *v35;
      uint64_t v38 = *((void *)this + 5);
      if (v38) {
        llvm::SlotIndexes::removeMachineInstrFromMaps(*(int32x2_t **)(v38 + 288), *v35);
      }
      llvm::MachineInstr::eraseFromParent(v37);
      ++v35;
      v36 -= 8;
    }
    while (v36);
  }
  *((_DWORD *)this + 96) = 0;
  if (v44)
  {
    uint64_t v39 = 8 * v44;
    unsigned int v40 = (char *)v43 - 8;
    do
    {
      sub_1CC3C6F20(*(void *)&v40[v39], *((void **)this + 3), *((void *)this + 5), 0);
      v39 -= 8;
    }
    while (v39);
  }
  sub_1CC3C6F20((uint64_t)LCSSAExitingBlock, *((void **)this + 3), *((void *)this + 5), 0);
  if (v43 != v45) {
    free(v43);
  }
  if (v46[0] != &v47) {
    free(v46[0]);
  }
  if (v49 != &v51) {
    free(v49);
  }
}

unint64_t *llvm::PeelingModuloScheduleExpander::CreateLCSSAExitingBlock(llvm::PeelingModuloScheduleExpander *this)
{
  v43[16] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 6);
  uint64_t v3 = *(llvm::MachineFunction **)(v2 + 32);
  uint64_t v4 = *(llvm::MachineBasicBlock ***)(v2 + 88);
  unint64_t v5 = *v4;
  if (*v4 == (llvm::MachineBasicBlock *)v2) {
    unint64_t v5 = v4[1];
  }
  uint64_t v34 = v5;
  unint64_t MachineBasicBlock = (unint64_t *)llvm::MachineFunction::CreateMachineBasicBlock(v3, *(const llvm::BasicBlock **)(v2 + 16));
  uint64_t v7 = *(unint64_t **)(*((void *)this + 6) + 8);
  llvm::ilist_callback_traits<llvm::MachineBasicBlock>::addNodeToList((uint64_t)v3 + 320, (uint64_t)MachineBasicBlock);
  unint64_t v8 = *v7;
  *unint64_t MachineBasicBlock = *v7;
  MachineBasicBlock[1] = (unint64_t)v7;
  *(void *)(v8 + 8) = MachineBasicBlock;
  unint64_t *v7 = (unint64_t)MachineBasicBlock;
  unsigned int v9 = (llvm::MachineBasicBlock *)*((void *)this + 6);
  uint64_t v10 = *((void *)v9 + 7);
  if ((llvm::MachineBasicBlock *)v10 != (llvm::MachineBasicBlock *)((char *)v9 + 48))
  {
    unint64_t v11 = (void *)*((void *)v9 + 7);
    while (!*(_WORD *)v11[2] || *(_WORD *)v11[2] == 69)
    {
      unint64_t v11 = (void *)v11[1];
      if (v11 == (void *)((char *)v9 + 48))
      {
        unint64_t v11 = (void *)((char *)v9 + 48);
        break;
      }
    }
    if ((void *)v10 != v11)
    {
      uint64_t v12 = v43;
      do
      {
        uint64_t v13 = *(void *)(v10 + 32);
        unsigned int v14 = *(_DWORD *)(v13 + 100);
        unsigned int VirtualRegister = llvm::MachineRegisterInfo::createVirtualRegister(*((void *)this + 3), *(void *)(*(void *)(*((void *)this + 3) + 24)+ 16 * (*(_DWORD *)(v13 + 4) & 0x7FFFFFFF)) & 0xFFFFFFFFFFFFFFF8, "", 0);
        uint64_t v16 = v12;
        unsigned int v41 = v12;
        uint64_t v42 = 0x400000000;
        uint64_t v17 = sub_1CBA02BCC(*((void *)this + 3), v14);
        if (v17 != v18)
        {
          uint64_t v19 = v17;
          do
          {
            uint64_t v20 = *(void *)(v19 + 8);
            if (*(void *)(v20 + 24) != *((void *)this + 6))
            {
              if (v42 >= (unint64_t)HIDWORD(v42)) {
                llvm::SmallVectorBase<unsigned int>::grow_pod();
              }
              *((void *)v41 + v42) = v20;
              LODWORD(v42) = v42 + 1;
              uint64_t v20 = *(void *)(v19 + 8);
            }
            do
              uint64_t v19 = *(void *)(v19 + 24);
            while (v19 && ((*(unsigned char *)(v19 + 3) & 1) != 0 || *(void *)(v19 + 8) == v20));
          }
          while (v19 != v18);
        }
        unsigned int v21 = VirtualRegister;
        if (v42)
        {
          uint64_t v22 = (uint64_t *)v41;
          uint64_t v23 = 8 * v42;
          do
          {
            uint64_t v24 = *v22++;
            uint64_t v25 = *(void *)(**((void **)this + 3) + 16);
            BOOL v26 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v25 + 176))(v25);
            llvm::MachineInstr::substituteRegister(v24, v14, v21, 0, v26);
            v23 -= 8;
          }
          while (v23);
        }
        uint64_t v35 = 0;
        uint64_t v36 = 0;
        unint64_t v27 = sub_1CB85AA4C((uint64_t)MachineBasicBlock, MachineBasicBlock + 6, &v35, *(void *)(*((void *)this + 4) + 8), v21);
        unsigned int v29 = v28;
        uint64_t v38 = 0;
        LODWORD(v37) = 0;
        HIDWORD(v37) = v14;
        uint64_t v39 = 0;
        uint64_t v40 = 0;
        llvm::MachineInstr::addOperand(v28, v27, (const llvm::MachineOperand *)&v37);
        uint64_t v30 = *((void *)this + 6);
        uint64_t v38 = 0;
        uint64_t v39 = v30;
        LODWORD(v37) = 4;
        llvm::MachineInstr::addOperand(v29, v27, (const llvm::MachineOperand *)&v37);
        if (v35) {
          llvm::MetadataTracking::untrack((uint64_t)&v35, v35);
        }
        uint64_t v36 = v29;
        uint64_t v37 = MachineBasicBlock;
        uint64_t v38 = v10;
        sub_1CD55B4F4((uint64_t)this + 256, (uint64_t *)&v37)[2] = v29;
        sub_1CD4F8350((uint64_t *)this + 29, &v36)[1] = v10;
        uint64_t v12 = v16;
        if (v41 != v16) {
          free(v41);
        }
        if (!v10 || (*(unsigned char *)v10 & 4) == 0)
        {
          while ((*(_WORD *)(v10 + 44) & 8) != 0)
            uint64_t v10 = *(void *)(v10 + 8);
        }
        uint64_t v10 = *(void *)(v10 + 8);
      }
      while ((void *)v10 != v11);
      unsigned int v9 = (llvm::MachineBasicBlock *)*((void *)this + 6);
    }
  }
  llvm::MachineBasicBlock::replaceSuccessor(v9, v34, (llvm::MachineBasicBlock *)MachineBasicBlock);
  llvm::MachineBasicBlock::replacePhiUsesWith((uint64_t)v34, *((llvm::MachineBasicBlock **)this + 6), (llvm::MachineBasicBlock *)MachineBasicBlock);
  llvm::MachineBasicBlock::addSuccessor(MachineBasicBlock, v34, -1);
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  unsigned int v41 = v43;
  uint64_t v42 = 0x400000000;
  (*(void (**)(void, void, unint64_t **, llvm::MachineInstr **, void **, void))(**((void **)this + 4) + 248))(*((void *)this + 4), *((void *)this + 6), &v37, &v36, &v41, 0);
  (*(void (**)(void))(**((void **)this + 4) + 264))();
  uint64_t v31 = *((void *)this + 4);
  uint64_t v35 = 0;
  (*(void (**)(void))(*(void *)v31 + 272))();
  if (v35) {
    llvm::MetadataTracking::untrack((uint64_t)&v35, v35);
  }
  uint64_t v32 = *((void *)this + 4);
  uint64_t v35 = 0;
  (*(void (**)(uint64_t, unint64_t *, llvm::MachineBasicBlock *, void, void, void, unsigned __int8 **, void))(*(void *)v32 + 272))(v32, MachineBasicBlock, v34, 0, 0, 0, &v35, 0);
  if (v35) {
    llvm::MetadataTracking::untrack((uint64_t)&v35, v35);
  }
  if (v41 != v43) {
    free(v41);
  }
  return MachineBasicBlock;
}

void *sub_1CD55A628(void *a1, uint64_t a2)
{
  unint64_t v3 = a1[4];
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = (void *)(v4 + 8 * (v3 >> 9));
  if (v5 == v4)
  {
    uint64_t v7 = 0;
    uint64_t v10 = 0;
    unsigned int v9 = (void **)(v4 + 8 * ((a1[5] + v3) >> 9));
  }
  else
  {
    uint64_t v7 = (void *)(*v6 + 8 * (v3 & 0x1FF));
    unint64_t v8 = a1[5] + v3;
    unsigned int v9 = (void **)(v4 + 8 * (v8 >> 9));
    uint64_t v10 = &(*v9)[v8 & 0x1FF];
  }
  uint64_t v12 = a2;
  return sub_1CC3CAB18(v6, v7, v9, v10, &v12);
}

uint64_t llvm::PeelingModuloScheduleExpander::fixupBranches(llvm::PeelingModuloScheduleExpander *this)
{
  v25[16] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((unsigned int *)this + 18);
  if (v2)
  {
    char v3 = 0;
    uint64_t v4 = *((void *)this + 8) + 8 * v2;
    LODWORD(v5) = *(_DWORD *)(*(void *)this + 80);
    uint64_t v6 = *((void *)this + 14) + 8 * *((unsigned int *)this + 30);
    do
    {
      unint64_t v8 = *(llvm::MachineBasicBlock **)(v4 - 8);
      v4 -= 8;
      uint64_t v7 = v8;
      uint64_t v5 = (v5 - 1);
      unsigned int v9 = (llvm::MachineBasicBlock *)**((void **)v8 + 11);
      unint64_t v11 = *(llvm::MachineBasicBlock **)(v6 - 8);
      v6 -= 8;
      uint64_t v10 = v11;
      uint64_t v23 = v25;
      uint64_t v24 = 0x400000000;
      (*(void (**)(void, llvm::MachineBasicBlock *, void))(**((void **)this + 4) + 264))(*((void *)this + 4), v7, 0);
      unsigned __int16 v12 = (*(uint64_t (**)(void, uint64_t, llvm::MachineBasicBlock *, void **))(**((void **)this + 53)
                                                                                           + 24))(*((void *)this + 53), v5, v7, &v23);
      if (v12 > 0xFFu)
      {
        if ((_BYTE)v12)
        {
          llvm::MachineBasicBlock::removeSuccessor(v7, v10, 0);
          unsigned int v14 = (void *)((char *)v10 + 48);
          uint64_t v15 = *((void *)v10 + 7);
          if ((void *)v15 != v14)
          {
            uint64_t v16 = (void *)v15;
            while (!*(_WORD *)v16[2] || *(_WORD *)v16[2] == 69)
            {
              uint64_t v16 = (void *)v16[1];
              if (v16 == v14)
              {
                uint64_t v16 = v14;
                break;
              }
            }
            while ((void *)v15 != v16)
            {
              llvm::MachineInstr::removeOperand((char *)v15, 4u);
              llvm::MachineInstr::removeOperand((char *)v15, 3u);
              if (!v15 || (*(unsigned char *)v15 & 4) == 0)
              {
                while ((*(_WORD *)(v15 + 44) & 8) != 0)
                  uint64_t v15 = *(void *)(v15 + 8);
              }
              uint64_t v15 = *(void *)(v15 + 8);
            }
          }
        }
        else
        {
          llvm::MachineBasicBlock::removeSuccessor(v7, v9, 0);
          uint64_t v17 = (void *)((char *)v9 + 48);
          uint64_t v18 = *((void *)v9 + 7);
          if ((void *)v18 != v17)
          {
            uint64_t v19 = (void *)v18;
            while (!*(_WORD *)v19[2] || *(_WORD *)v19[2] == 69)
            {
              uint64_t v19 = (void *)v19[1];
              if (v19 == v17)
              {
                uint64_t v19 = v17;
                break;
              }
            }
            while ((void *)v18 != v19)
            {
              llvm::MachineInstr::removeOperand((char *)v18, 2u);
              llvm::MachineInstr::removeOperand((char *)v18, 1u);
              if (!v18 || (*(unsigned char *)v18 & 4) == 0)
              {
                while ((*(_WORD *)(v18 + 44) & 8) != 0)
                  uint64_t v18 = *(void *)(v18 + 8);
              }
              uint64_t v18 = *(void *)(v18 + 8);
            }
          }
          uint64_t v20 = *((void *)this + 4);
          uint64_t v22 = 0;
          (*(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void, void, void, unsigned __int8 **, void))(*(void *)v20 + 272))(v20, v7, v10, 0, 0, 0, &v22, 0);
          if (v22) {
            llvm::MetadataTracking::untrack((uint64_t)&v22, v22);
          }
          char v3 = 1;
        }
      }
      else
      {
        uint64_t v13 = *((void *)this + 4);
        uint64_t v22 = 0;
        (*(void (**)(uint64_t, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, llvm::MachineBasicBlock *, void *, void, unsigned __int8 **, void))(*(void *)v13 + 272))(v13, v7, v10, v9, v23, v24, &v22, 0);
        if (v22) {
          llvm::MetadataTracking::untrack((uint64_t)&v22, v22);
        }
      }
      if (v23 != v25) {
        free(v23);
      }
    }
    while (v4 != *((void *)this + 8));
    if (v3) {
      return (*(uint64_t (**)(void))(**((void **)this + 53) + 48))(*((void *)this + 53));
    }
  }
  (*(void (**)(void, void))(**((void **)this + 53) + 32))(*((void *)this + 53), (1 - *(_DWORD *)(*(void *)this + 80)));
  return (*(uint64_t (**)(void, void))(**((void **)this + 53) + 40))(*((void *)this + 53), *(void *)(*((void *)this + 8) + 8 * *((unsigned int *)this + 18) - 8));
}

void llvm::PeelingModuloScheduleExpander::expand(llvm::PeelingModuloScheduleExpander *this)
{
  *((void *)this + 6) = llvm::MachineLoop::getTopBlock(**(llvm::MachineLoop ***)this);
  llvm::LoopBase<llvm::MachineBasicBlock,llvm::MachineLoop>::getLoopPreheader();
}

llvm::raw_ostream *sub_1CD55ABE0(llvm::raw_ostream *a1, uint64_t *a2)
{
  char v2 = *((unsigned char *)a2 + 23);
  BOOL v3 = v2 < 0;
  size_t v4 = a2[1];
  if (v2 < 0) {
    a2 = (uint64_t *)*a2;
  }
  size_t v5 = v2 & 0x7F;
  if (v3) {
    size_t v6 = v4;
  }
  else {
    size_t v6 = v5;
  }
  return llvm::raw_ostream::write(a1, (const char *)a2, v6);
}

void llvm::initializeModuloScheduleTestPass(llvm *this, llvm::PassRegistry *a2)
{
  char v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD1198, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3C9674;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCD1198, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::ModuloScheduleTestAnnotater::annotate(llvm::ModuloScheduleTestAnnotater *this)
{
  v34[2] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((void *)this + 1);
  char v2 = *(uint64_t **)(v1 + 8);
  uint64_t v3 = *(void *)(v1 + 16) - (void)v2;
  if (v3)
  {
    uint64_t v5 = 8 * (v3 >> 3);
    do
    {
      uint64_t v6 = *v2;
      uint64_t v32 = v34;
      long long v33 = xmmword_1CDB15990;
      int v23 = 0;
      char v27 = 0;
      uint64_t v28 = 0;
      uint64_t v22 = &unk_1F2646FA8;
      uint64_t v30 = &v32;
      int v29 = 0;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v24 = 0;
      uint64_t v7 = sub_1CB8E509C((llvm::raw_ostream *)&v22, "Stage-");
      uint64_t v8 = *((void *)this + 1);
      uint64_t v31 = v6;
      v20[0] = 0;
      int v9 = sub_1CD3C8538((uint64_t *)(v8 + 56), &v31, v20);
      int v10 = -1;
      if (v9 && v20[0] != (unsigned __int8 **)(*(void *)(v8 + 56) + 16 * *(unsigned int *)(v8 + 72))) {
        int v10 = *((_DWORD *)v20[0] + 2);
      }
      unint64_t v11 = llvm::raw_ostream::operator<<(v7, v10);
      unsigned __int16 v12 = sub_1CB8E509C(v11, "_Cycle-");
      uint64_t v13 = *((void *)this + 1);
      uint64_t v31 = v6;
      v20[0] = 0;
      int v14 = sub_1CD3C8538((uint64_t *)(v13 + 32), &v31, v20);
      int v15 = -1;
      if (v14 && v20[0] != (unsigned __int8 **)(*(void *)(v13 + 32) + 16 * *(unsigned int *)(v13 + 48))) {
        int v15 = *((_DWORD *)v20[0] + 2);
      }
      llvm::raw_ostream::operator<<(v12, v15);
      uint64_t v16 = *(llvm::MCContext **)(*(void *)this + 24);
      uint64_t v18 = (unsigned __int8 **)*v30;
      uint64_t v17 = (unsigned __int8 **)v30[1];
      __int16 v21 = 261;
      v20[0] = v18;
      v20[1] = v17;
      Symbol = (llvm::MCSymbol *)llvm::MCContext::getOrCreateSymbol(v16, v20);
      llvm::MachineInstr::setPostInstrSymbol(v6, *(llvm::MachineFunction **)this, Symbol);
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v22);
      if (v32 != v34) {
        free(v32);
      }
      ++v2;
      v5 -= 8;
    }
    while (v5);
  }
}

uint64_t sub_1CD55AE7C(uint64_t result, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)(result + 8);
  if (v2 >= *(_DWORD *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  *(void *)(*(void *)result + 8 * v2) = a2 | 0x100000000;
  ++*(_DWORD *)(result + 8);
  return result;
}

uint64_t sub_1CD55AEE4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(result + 8);
  if (v3 + a2 > (unint64_t)*(unsigned int *)(result + 12)) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  size_t v4 = (void *)(*(void *)result + 8 * v3);
  uint64_t v5 = a2;
  do
  {
    *v4++ = a3;
    --v5;
  }
  while (v5);
  *(_DWORD *)(result + 8) += a2;
  return result;
}

_DWORD *sub_1CD55AF60(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 8);
  uint64_t result = *(_DWORD **)a1;
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  uint64_t v5 = &result[3 * v4];
  if (!v2) {
    return v5;
  }
  if (v4)
  {
    uint64_t v6 = 12 * v4;
    while (1)
    {
      int v7 = result[1];
      if ((*result != -1 || v7 != -1) && (*result != -2 || v7 != -2)) {
        break;
      }
      result += 3;
      v6 -= 12;
      if (!v6) {
        return v5;
      }
    }
  }
  return result;
}

uint64_t sub_1CD55AFB8(uint64_t a1, int a2, int a3, int a4, void *a5)
{
  if (a2)
  {
    unint64_t v5 = ((37 * a4) | ((unint64_t)(37 * a3) << 32))
       + ~((unint64_t)(37 * a4) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = a2 - 1;
    unsigned int v9 = (a2 - 1) & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    int v10 = (_DWORD *)(a1 + 12 * v9);
    int v11 = *v10;
    int v12 = v10[1];
    if (*v10 == a3 && v12 == a4)
    {
      uint64_t v14 = 1;
    }
    else
    {
      uint64_t v16 = 0;
      int v17 = 1;
      while (v11 != -1 || v12 != -1)
      {
        if (v16) {
          BOOL v18 = 0;
        }
        else {
          BOOL v18 = v12 == -2;
        }
        if (v18 && v11 == -2) {
          uint64_t v16 = v10;
        }
        unsigned int v20 = v9 + v17++;
        unsigned int v9 = v20 & v8;
        int v10 = (_DWORD *)(a1 + 12 * (v20 & v8));
        int v11 = *v10;
        int v12 = v10[1];
        uint64_t v14 = 1;
        if (*v10 == a3 && v12 == a4) {
          goto LABEL_8;
        }
      }
      uint64_t v14 = 0;
      if (v16) {
        int v10 = v16;
      }
    }
  }
  else
  {
    int v10 = 0;
    uint64_t v14 = 0;
  }
LABEL_8:
  *a5 = v10;
  return v14;
}

uint64_t sub_1CD55B0A4(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4)
{
  int v12 = 0;
  uint64_t result = sub_1CD55AFB8(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, a3[1], &v12);
  unsigned int v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD55B150(a2, a3, v12);
    unsigned int v9 = (_DWORD *)result;
    *(_DWORD *)uint64_t result = *a3;
    *(_DWORD *)(result + 4) = a3[1];
    *(_DWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 12 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

_DWORD *sub_1CD55B150(uint64_t a1, int *a2, _DWORD *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD55B208(a1, v6);
  unsigned int v9 = 0;
  sub_1CD55AFB8(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v9);
  a3 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -1 || a3[1] != -1) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD55B208(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(int **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(12 * v8, (std::align_val_t)4uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD55B2E0(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 12 * v10;
    do
    {
      void *result = -1;
      uint64_t result = (void *)((char *)result + 12);
      v11 -= 12;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD55B2E0(uint64_t result, int *a2, int *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(void **)result;
    uint64_t v8 = 12 * v6;
    do
    {
      void *v7 = -1;
      int v7 = (void *)((char *)v7 + 12);
      v8 -= 12;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    int v9 = *a2;
    int v10 = a2[1];
    if ((*a2 != -1 || v10 != -1) && (v9 != -2 || v10 != -2))
    {
      uint64_t v14 = 0;
      uint64_t result = sub_1CD55AFB8(*(void *)v5, *(_DWORD *)(v5 + 16), v9, v10, &v14);
      uint64_t v13 = v14;
      *uint64_t v14 = *a2;
      v13[1] = a2[1];
      void v13[2] = a2[2];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

_DWORD *sub_1CD55B3B0(uint64_t a1, int *a2)
{
  int v7 = 0;
  char v4 = sub_1CD55AFB8(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD55B150(a1, a2, v7);
    _DWORD *v5 = *a2;
    *(void *)(v5 + 1) = a2[1];
  }
  return v5;
}

uint64_t **sub_1CD55B424(uint64_t **a1, unsigned int a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (uint64_t **)v5;
        unsigned int v8 = *((_DWORD *)v5 + 7);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v7 = a1 + 1;
LABEL_9:
    int v9 = (uint64_t *)v7;
    int v7 = (uint64_t **)operator new(0x28uLL);
    *((_DWORD *)v7 + 7) = *a3;
    *((_DWORD *)v7 + 8) = 0;
    *((unsigned char *)v7 + 36) = 0;
    _DWORD *v7 = 0;
    v7[1] = 0;
    void v7[2] = v9;
    void *v6 = (uint64_t *)v7;
    int v10 = (uint64_t *)**a1;
    uint64_t v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      uint64_t v11 = *v6;
    }
    sub_1CB8358B8(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void *sub_1CD55B4F4(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD55B568(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = a2[1];
    void v5[2] = 0;
  }
  return v5;
}

void *sub_1CD55B568(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
    goto LABEL_8;
  }
  if (v6 + ~v5 - *(_DWORD *)(a1 + 12) <= v6 >> 3)
  {
LABEL_8:
    sub_1CD55B628(a1, v6);
    unsigned int v8 = 0;
    sub_1CD553C1C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, a2[1], &v8);
    a3 = v8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096 || a3[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

_OWORD *sub_1CD55B628(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  char v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD55B704(a1, v4, &v4[3 * v3]);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 24 * v10;
    int64x2_t v12 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      _OWORD *result = v12;
      uint64_t result = (_OWORD *)((char *)result + 24);
      v11 -= 24;
    }
    while (v11);
  }
  return result;
}

uint64_t sub_1CD55B704(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  uint64_t v6 = *(unsigned int *)(result + 16);
  if (v6)
  {
    int v7 = *(int64x2_t **)result;
    uint64_t v8 = 24 * v6;
    int64x2_t v9 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    do
    {
      int64x2_t *v7 = v9;
      int v7 = (int64x2_t *)((char *)v7 + 24);
      v8 -= 24;
    }
    while (v8);
  }
  while (a2 != a3)
  {
    uint64_t v10 = *a2;
    uint64_t v11 = a2[1];
    if ((*a2 != -4096 || v11 != -4096) && (v10 != -8192 || v11 != -8192))
    {
      uint64_t v13 = 0;
      uint64_t result = sub_1CD553C1C(*(void *)v5, *(_DWORD *)(v5 + 16), v10, v11, &v13);
      int64x2_t v12 = v13;
      *uint64_t v13 = *a2;
      v12[1] = a2[1];
      _OWORD v12[2] = a2[2];
      ++*(_DWORD *)(v5 + 8);
    }
    a2 += 3;
  }
  return result;
}

void *sub_1CD55B7E0(uint64_t a1, uint64_t *a2)
{
  int v7 = 0;
  char v4 = sub_1CD4C612C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD55B860(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x600000000;
    *((_DWORD *)v5 + 18) = 0;
  }
  return v5;
}

void *sub_1CD55B860(uint64_t a1, uint64_t *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD55B914(a1, v6);
  uint64_t v8 = 0;
  sub_1CD4C612C(*(void *)a1, *(_DWORD *)(a1 + 16), *a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD55B914(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(void *)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = operator new(80 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD55B9EC(a1, v4, v4 + 80 * v3);
    JUMPOUT(0x1D25D9CD0);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 80 * v10;
    do
    {
      void *result = -4096;
      result += 10;
      v11 -= 80;
    }
    while (v11);
  }
  return result;
}

void sub_1CD55B9EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(void **)a1;
    uint64_t v8 = 80 * v6;
    do
    {
      void *v7 = -4096;
      v7 += 10;
      v8 -= 80;
    }
    while (v8);
  }
  if (a2 != a3)
  {
    do
    {
      uint64_t v9 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        int64x2_t v12 = 0;
        sub_1CD4C612C(*(void *)a1, *(_DWORD *)(a1 + 16), v9, &v12);
        uint64_t v10 = v12;
        *int64x2_t v12 = *(void *)v4;
        v10[1] = v10 + 3;
        void v10[2] = 0x600000000;
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CB837F14((uint64_t)(v10 + 1), v4 + 8);
        }
        *((_DWORD *)v10 + 18) = *(_DWORD *)(v4 + 72);
        ++*(_DWORD *)(a1 + 8);
        uint64_t v11 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v11) {
          free(v11);
        }
      }
      v4 += 80;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD55BAF0(uint64_t result, int a2)
{
  if (a2)
  {
    int v2 = a2;
    uint64_t v3 = result;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 96))(v3);
      --v2;
    }
    while (v2);
  }
  return result;
}

void llvm::initializePatchableFunctionPass(llvm *this, llvm::PassRegistry *a2)
{
  int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD11A0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3CB4A8;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD11A0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t llvm::MBFIWrapper::getBlockFreq(llvm::MBFIWrapper *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = a2;
  if (sub_1CD3C8538((uint64_t *)this + 1, &v9, &v8))
  {
    uint64_t v4 = v8;
    uint64_t v5 = *((void *)this + 1);
    uint64_t v6 = *((unsigned int *)this + 6);
  }
  else
  {
    uint64_t v5 = *((void *)this + 1);
    uint64_t v6 = *((unsigned int *)this + 6);
    uint64_t v4 = v5 + 16 * v6;
  }
  if (v4 == v5 + 16 * v6) {
    return llvm::MachineBlockFrequencyInfo::getBlockFreq(*(llvm::MachineBlockFrequencyInfo **)this, a2);
  }
  else {
    return *(void *)(v4 + 8);
  }
}

void *llvm::MBFIWrapper::setBlockFreq(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2;
  uint64_t result = sub_1CD55BD10((uint64_t *)(a1 + 8), &v5);
  result[1] = a3;
  return result;
}

uint64_t *****llvm::MBFIWrapper::getBlockProfileCount(llvm::MBFIWrapper *this, const llvm::MachineBasicBlock *a2)
{
  uint64_t v9 = 0;
  uint64_t v10 = a2;
  if (sub_1CD3C8538((uint64_t *)this + 1, &v10, &v9))
  {
    uint64_t v4 = v9;
    uint64_t v5 = *((void *)this + 1);
    uint64_t v6 = *((unsigned int *)this + 6);
  }
  else
  {
    uint64_t v5 = *((void *)this + 1);
    uint64_t v6 = *((unsigned int *)this + 6);
    uint64_t v4 = v5 + 16 * v6;
  }
  int v7 = *(llvm::MachineBlockFrequencyInfo **)this;
  if (v4 == v5 + 16 * v6) {
    return (uint64_t *****)llvm::MachineBlockFrequencyInfo::getBlockProfileCount(v7, a2);
  }
  else {
    return llvm::MachineBlockFrequencyInfo::getProfileCountFromFreq(v7, *(void *)(v4 + 8));
  }
}

void llvm::MBFIWrapper::view(llvm::MachineBlockFrequencyInfo **this, const llvm::Twine *a2, char a3)
{
}

uint64_t llvm::MBFIWrapper::getEntryFreq(llvm::MachineBlockFrequencyInfo **this)
{
  return llvm::MachineBlockFrequencyInfo::getEntryFreq(*this);
}

void *sub_1CD55BD10(uint64_t *a1, void *a2)
{
  int v7 = 0;
  char v4 = sub_1CD3C8538(a1, a2, &v7);
  uint64_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_1CD55BD70((uint64_t)a1, a2, v7);
    void *v5 = *a2;
    v5[1] = 0;
  }
  return v5;
}

void *sub_1CD55BD70(uint64_t a1, void *a2, void *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
  {
    goto LABEL_3;
  }
  sub_1CD55BE20(a1, v6);
  uint64_t v8 = 0;
  sub_1CD3C8538((uint64_t *)a1, a2, &v8);
  a3 = v8;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a3 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a3;
}

void *sub_1CD55BE20(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  char v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    sub_1CD4D71E4(a1, v4, (void *)v4 + 2 * v3);
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = *(unsigned int *)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 16 * v10;
    do
    {
      void *result = -4096;
      result += 2;
      v11 -= 16;
    }
    while (v11);
  }
  return result;
}

uint64_t llvm::MIRPrinter::print(llvm::MIRPrinter *this, const llvm::MachineFunction *a2)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  llvm::MIRPrinter::initRegisterMaskIds(this, a2);
  char v40 = 0;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  char v39 = 0;
  int v41 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  __int16 v44 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  uint64_t v47 = 0;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  memset(v61, 0, sizeof(v61));
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  int v48 = -1;
  int v62 = 5;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  memset(v66, 0, sizeof(v66));
  uint64_t v67 = 0;
  v34[0] = (uint64_t)llvm::MachineFunction::getName((llvm::Value **)a2);
  v34[1] = v4;
  LOWORD(v35) = *((unsigned __int8 *)a2 + 352) | 0x100;
  BYTE2(v35) = *((unsigned char *)a2 + 353);
  BYTE8(v35) = *((unsigned char *)a2 + 355);
  *(_DWORD *)((char *)&v35 + 9) = *((_DWORD *)a2 + 158);
  BYTE13(v35) = *((unsigned char *)a2 + 636);
  int v5 = **((_DWORD **)a2 + 45);
  BYTE3(v35) = (v5 & 0x20) != 0;
  BYTE4(v35) = (v5 & 0x40) != 0;
  BYTE5(v35) = (v5 & 0x80) != 0;
  BYTE6(v35) = (v5 & 0x10) != 0;
  BYTE14(v35) = (v5 & 0x200) != 0;
  HIBYTE(v35) = (v5 & 0x400) != 0;
  uint64_t v6 = *((void *)a2 + 5);
  uint64_t v7 = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
  llvm::MIRPrinter::convert(v7, (uint64_t)v34, v6, v7);
  unsigned int v8 = (const llvm::Function **)llvm::MachineModuleSlotTracker::MachineModuleSlotTracker((llvm::MachineModuleSlotTracker *)v74, a2, 1);
  uint64_t v9 = llvm::ModuleSlotTracker::incorporateFunction(v8, *(const llvm::Function **)a2);
  llvm::MIRPrinter::convert((uint64_t)v9, v10, (uint64_t)&v41, *((void *)a2 + 7));
  llvm::MIRPrinter::convertStackObjects((uint64_t)this, v34, (uint64_t)a2, (llvm::ModuleSlotTracker *)v74);
  llvm::MIRPrinter::convertCallSiteObjects(v11, (uint64_t)v34, (uint64_t)a2);
  unsigned int v14 = *((_DWORD *)a2 + 232);
  if (v14)
  {
    int v15 = (long long *)*((void *)a2 + 115);
    uint64_t v16 = (long long *)((char *)v15 + 20 * v14);
    int64x2_t v12 = *(char **)&v61[3];
    do
    {
      long long v68 = *v15;
      LODWORD(v69) = *((_DWORD *)v15 + 4);
      if ((unint64_t)v12 >= *(void *)&v61[5])
      {
        int64x2_t v12 = sub_1CC3CE454((void **)&v61[1], (uint64_t)&v68);
      }
      else
      {
        long long v17 = v68;
        *((_DWORD *)v12 + 4) = v69;
        *(_OWORD *)int64x2_t v12 = v17;
        v12 += 20;
      }
      *(void *)&v61[3] = v12;
      int v15 = (long long *)((char *)v15 + 20);
    }
    while (v15 != v16);
  }
  uint64_t v18 = *((void *)a2 + 8);
  if (v18) {
    llvm::MIRPrinter::convert((uint64_t)v12, (uint64_t)v34, v18);
  }
  uint64_t v19 = *((void *)a2 + 9);
  if (v19) {
    llvm::MIRPrinter::convert((uint64_t)v12, v13, &v62, v19);
  }
  uint64_t v20 = (*(uint64_t (**)(void, const llvm::MachineFunction *))(**((void **)a2 + 1) + 40))(*((void *)a2 + 1), a2);
  __int16 v21 = *(void **)((char *)&v59 + 4);
  *(void *)((char *)&v59 + 4) = v20;
  if (v21) {
    __int16 v21 = (void *)(*(uint64_t (**)(void *))(*(void *)v21 + 8))(v21);
  }
  int v26 = 0;
  char v30 = 0;
  uint64_t v31 = 0;
  long long v33 = v66;
  int v32 = 0;
  uint64_t v25 = &unk_1F2646F30;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v22 = (const llvm::MachineBasicBlock *)*((void *)a2 + 41);
  if (v22 != (const llvm::MachineFunction *)((char *)a2 + 320))
  {
    char v24 = 0;
    do
    {
      if (v24) {
        sub_1CB8E509C((llvm::raw_ostream *)&v25, "\n");
      }
      *(void *)&long long v68 = &v25;
      *((void *)&v68 + 1) = v74;
      unint64_t v69 = (char *)this + 8;
      uint64_t v70 = (char *)this + 32;
      uint64_t v71 = v73;
      uint64_t v72 = 0x800000000;
      llvm::MIPrinter::print((llvm::MIPrinter *)&v68, v22);
      __int16 v21 = v71;
      if (v71 != v73) {
        free(v71);
      }
      uint64_t v22 = (const llvm::MachineBasicBlock *)*((void *)v22 + 1);
      char v24 = 1;
    }
    while (v22 != (const llvm::MachineFunction *)((char *)a2 + 320));
    if (v29 != v27) {
      __int16 v21 = (void *)llvm::raw_ostream::flush_nonempty((llvm::raw_ostream *)&v25);
    }
  }
  llvm::MIRPrinter::convertMachineMetadataNodes((uint64_t)v21, (uint64_t)v34, (uint64_t)a2, (llvm::ModuleSlotTracker *)v74);
  llvm::yaml::Output::Output((llvm::yaml::Output *)&v68, *(llvm::raw_ostream **)this, 0, 70);
  if (!byte_1EBCD1228) {
    v73[47] = 1;
  }
  sub_1CD55D960((llvm::yaml::Output *)&v68, (uint64_t)v34);
  llvm::yaml::Output::~Output((llvm::yaml::Output *)&v68);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v25);
  llvm::MachineModuleSlotTracker::~MachineModuleSlotTracker((llvm::MachineModuleSlotTracker *)v74);
  return sub_1CD55EB2C((uint64_t)v34);
}

uint64_t llvm::MIRPrinter::initRegisterMaskIds(llvm::MIRPrinter *this, const llvm::MachineFunction *a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(**((void **)a2 + 2) + 176))(*((void *)a2 + 2));
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 72))(v3);
  if (v5)
  {
    uint64_t v6 = result;
    uint64_t v7 = 0;
    unsigned int v8 = (char *)this + 8;
    uint64_t v9 = 8 * v5;
    do
    {
      uint64_t v11 = *(void *)(v6 + 8 * v7);
      uint64_t v12 = v7;
      uint64_t result = sub_1CD40E370((uint64_t)v10, (uint64_t)v8, &v11, &v12);
      ++v7;
      v9 -= 8;
    }
    while (v9);
  }
  return result;
}

void llvm::MIRPrinter::convertStackObjects(uint64_t a1, uint64_t *a2, uint64_t a3, llvm::ModuleSlotTracker *a4)
{
  v81[16] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a3 + 56);
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a3 + 16) + 176))(*(void *)(a3 + 16));
  uint64_t v79 = (int *)v81;
  uint64_t v80 = 0x2000000000;
  uint64_t v7 = *(unsigned int *)(v5 + 32);
  if ((int)v7 > 32) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if (-(int)v7 < 0)
  {
    uint64_t v10 = 0;
    do
    {
      if (v80 >= (unint64_t)HIDWORD(v80)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      v79[v80] = -1;
      LODWORD(v80) = v80 + 1;
      unsigned int v8 = v10 - v7 + *(_DWORD *)(v5 + 32);
      uint64_t v9 = *(void *)(v5 + 8);
      if (*(void *)(v9 + 40 * v8 + 8) != -1)
      {
        BOOL v11 = 0;
        *(_WORD *)&__str[56] = 0;
        memset(&__str[32], 0, 18);
        *(_OWORD *)&__str[64] = 0u;
        long long v60 = 0u;
        *(void *)&long long v61 = 0;
        BYTE8(v61) = 1;
        long long v62 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        *(void *)&long long v69 = 0;
        *(_DWORD *)&__str[24] = 0;
        *(_DWORD *)std::string __str = v10;
        uint64_t v12 = v9 + 40 * v8;
        *(_OWORD *)&__str[8] = 0uLL;
        *(_DWORD *)&__str[24] = *(unsigned __int8 *)(v12 + 18);
        *(_OWORD *)&__str[32] = *(_OWORD *)v12;
        *(_WORD *)&__str[48] = *(unsigned __int8 *)(v12 + 16) | 0x100;
        *(_DWORD *)&__str[52] = *(unsigned __int8 *)(v12 + 20);
        if (!*(unsigned char *)(v5 + 654)) {
          BOOL v11 = *(unsigned char *)(v9 + 40 * v8 + 17) != 0;
        }
        __str[56] = v11;
        __str[57] = *(unsigned char *)(v9 + 40 * v8 + 33);
        unint64_t v13 = a2[36];
        v79[v10] = 1332920885 * ((v13 - a2[35]) >> 3);
        if (v13 >= a2[37]) {
          uint64_t v14 = sub_1CC3D0B70(a2 + 35, (long long *)__str);
        }
        else {
          uint64_t v14 = sub_1CD56310C(v13, (long long *)__str) + 232;
        }
        a2[36] = v14;
        LODWORD(v73) = v10 - v7;
        long long __p = 0;
        char v76 = 0;
        int v77 = v10;
        char v78 = 1;
        sub_1CC3CD2E4((uint64_t)v49, a1 + 32, (uint64_t)&v73);
        if (v76 < 0) {
          operator delete(__p);
        }
        sub_1CD55ED28((uint64_t)__str);
      }
      ++v10;
    }
    while (v7 != v10);
    LODWORD(v7) = *(_DWORD *)(v5 + 32);
  }
  uint64_t v73 = v75;
  long long __p = (void *)0x2000000000;
  uint64_t v15 = -858993459 * ((*(void *)(v5 + 16) - *(void *)(v5 + 8)) >> 3) - v7;
  if ((int)v15 > 32) {
    llvm::SmallVectorBase<unsigned int>::grow_pod();
  }
  if ((int)v15 >= 1)
  {
    for (uint64_t i = 0; i != v15; ++i)
    {
      if (__p >= (unint64_t)HIDWORD(__p)) {
        llvm::SmallVectorBase<unsigned int>::grow_pod();
      }
      *((_DWORD *)v73 + __p) = -1;
      LODWORD(__p) = __p + 1;
      unsigned int v17 = i + *(_DWORD *)(v5 + 32);
      uint64_t v18 = *(void *)(v5 + 8);
      if (*(void *)(v18 + 40 * v17 + 8) != -1)
      {
        *(void *)&__str[72] = 0;
        *(void *)&long long v60 = 0;
        WORD4(v60) = 0;
        long long v61 = 0u;
        long long v62 = 0u;
        *(void *)&long long v63 = 0;
        BYTE8(v63) = 1;
        LOBYTE(v64) = 0;
        BYTE8(v64) = 0;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        uint64_t v72 = 0;
        *(_DWORD *)std::string __str = i;
        memset(&__str[8], 0, 60);
        uint64_t v19 = *(llvm::Value **)(v18 + 40 * v17 + 24);
        if (v19)
        {
          if ((*((unsigned char *)v19 + 23) & 0x10) != 0)
          {
            uint64_t Name = llvm::Value::getName(v19);
            std::string::size_type v20 = v22;
          }
          else
          {
            std::string::size_type v20 = 0;
            uint64_t Name = "";
          }
          std::string::__init((std::string *)v49, Name, v20);
          if ((__str[47] & 0x80000000) != 0) {
            operator delete(*(void **)&__str[24]);
          }
          *(std::string *)&__str[24] = *(std::string *)v49;
          uint64_t v18 = *(void *)(v5 + 8);
          unsigned int v17 = i + *(_DWORD *)(v5 + 32);
        }
        uint64_t v23 = v18 + 40 * v17;
        uint64_t v24 = *(void *)(v23 + 8);
        if (*(unsigned char *)(v23 + 18)) {
          int v25 = 1;
        }
        else {
          int v25 = 2 * (v24 == 0);
        }
        *(_DWORD *)&__str[64] = v25;
        *(void *)&__str[72] = *(void *)v23;
        *(void *)&long long v60 = v24;
        WORD4(v60) = *(unsigned __int8 *)(v23 + 16) | 0x100;
        HIDWORD(v60) = *(unsigned __int8 *)(v23 + 20);
        unint64_t v26 = a2[39];
        *((_DWORD *)v73 + i) = -1963413621 * ((v26 - a2[38]) >> 3);
        if (v26 >= a2[40]) {
          uint64_t v27 = sub_1CC3D0ED0(a2 + 38, (long long *)__str);
        }
        else {
          uint64_t v27 = sub_1CD563DE4(v26, (long long *)__str) + 280;
        }
        a2[39] = v27;
        if (__str[47] >= 0) {
          uint64_t v28 = &__str[24];
        }
        else {
          uint64_t v28 = *(const std::string::value_type **)&__str[24];
        }
        if (v28)
        {
          if (__str[47] >= 0) {
            std::string::size_type v29 = __str[47] & 0x7F;
          }
          else {
            std::string::size_type v29 = *(void *)&__str[32];
          }
          std::string::__init(&v56, v28, v29);
        }
        else
        {
          memset(&v56, 0, sizeof(v56));
        }
        int v57 = i;
        char v58 = 0;
        *(_DWORD *)long long v49 = i;
        *(std::string *)&v49[8] = v56;
        memset(&v56, 0, sizeof(v56));
        LODWORD(v50) = i;
        BYTE4(v50) = 0;
        sub_1CC3CD2E4((uint64_t)v55, a1 + 32, (uint64_t)v49);
        if ((v49[31] & 0x80000000) != 0) {
          operator delete(*(void **)&v49[8]);
        }
        if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v56.__r_.__value_.__l.__data_);
        }
        sub_1CD55ED8C((uint64_t)__str);
      }
    }
  }
  uint64_t v30 = *(void *)(v5 + 80);
  for (uint64_t j = *(void *)(v5 + 88); v30 != j; v30 += 12)
  {
    uint64_t v32 = *(unsigned int *)(v30 + 4);
    if (*(unsigned char *)(v30 + 9)
      || *(void *)(*(void *)(v5 + 8) + 40 * (*(_DWORD *)(v5 + 32) + v32) + 8) != -1)
    {
      memset(__str, 0, 40);
      sub_1CC3CD1B0(*(_DWORD *)v30, (uint64_t)__str, v6);
      if (!*(unsigned char *)(v30 + 9))
      {
        if ((v32 & 0x80000000) != 0)
        {
          uint64_t v34 = a2[35] + 232 * v79[(*(_DWORD *)(v5 + 32) + v32)];
          std::string::operator=((std::string *)(v34 + 64), (const std::string *)__str);
          *(_OWORD *)(v34 + 88) = *(_OWORD *)&__str[24];
          *(unsigned char *)(v34 + 104) = *(unsigned char *)(v30 + 8);
        }
        else
        {
          uint64_t v33 = a2[38] + 280 * *((unsigned int *)v73 + v32);
          std::string::operator=((std::string *)(v33 + 96), (const std::string *)__str);
          *(_OWORD *)(v33 + 120) = *(_OWORD *)&__str[24];
          *(unsigned char *)(v33 + 136) = *(unsigned char *)(v30 + 8);
        }
      }
      if ((__str[23] & 0x80000000) != 0) {
        operator delete(*(void **)__str);
      }
    }
  }
  int v35 = *(_DWORD *)(v5 + 120);
  if (v35)
  {
    for (int k = 0; k != v35; ++k)
    {
      long long v37 = (uint64_t *)(*(void *)(v5 + 112) + 16 * k);
      uint64_t v39 = *v37;
      uint64_t v38 = v37[1];
      uint64_t v40 = a2[38] + 280 * *((unsigned int *)v73 + (int)v39);
      if (!*(unsigned char *)(v40 + 152)) {
        *(unsigned char *)(v40 + 152) = 1;
      }
      *(void *)(v40 + 144) = v38;
    }
  }
  int v41 = *(_DWORD *)(v5 + 64);
  if (v41 != -1)
  {
    *(_DWORD *)&v49[8] = 0;
    char v51 = 0;
    uint64_t v52 = 0;
    long long v54 = a2 + 18;
    int v53 = 0;
    *(void *)long long v49 = &unk_1F2646F30;
    *(void *)&v49[16] = 0;
    *(void *)&v49[24] = 0;
    uint64_t v50 = 0;
    *(void *)std::string __str = v49;
    *(void *)&__str[8] = a4;
    *(void *)&__str[16] = a1 + 8;
    *(void *)&__str[24] = a1 + 32;
    *(void *)&__str[32] = &__str[48];
    *(void *)&__str[40] = 0x800000000;
    llvm::MIPrinter::printStackObjectReference((llvm::MIPrinter *)__str, v41);
    if (*(unsigned char **)&__str[32] != &__str[48]) {
      free(*(void **)&__str[32]);
    }
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)v49);
  }
  if (*(_DWORD *)(a3 + 776))
  {
    uint64_t v42 = *(void *)(a3 + 768);
    uint64_t v43 = *(unsigned int *)(v42 + 16);
    if ((v43 & 0x80000000) == 0)
    {
      uint64_t v44 = a2[38] + 280 * *((unsigned int *)v73 + v43);
      *(void *)long long v49 = v44 + 160;
      *(void *)&v49[8] = v44 + 200;
      *(void *)&v49[16] = v44 + 240;
      *(_OWORD *)&v56.__r_.__value_.__l.__data_ = *(_OWORD *)v42;
      v56.__r_.__value_.__r.__words[2] = *(void *)(v42 + 24);
      *(_DWORD *)&__str[8] = 0;
      *(void *)&__str[48] = 0;
      *(void *)std::string __str = &unk_1F2646F30;
      *(void *)&__str[64] = v44 + 160;
      *(_DWORD *)&__str[56] = 0;
      memset(&__str[16], 0, 25);
      llvm::Metadata::printAsOperand((llvm::Metadata *)v56.__r_.__value_.__l.__data_, (llvm::raw_ostream *)__str, a4, 0);
    }
    uint64_t v45 = a2[35] + 232 * v79[(*(_DWORD *)(v5 + 32) + v43)];
    *(void *)long long v49 = v45 + 112;
    *(void *)&v49[8] = v45 + 152;
    *(void *)&v49[16] = v45 + 192;
    *(_OWORD *)&v56.__r_.__value_.__l.__data_ = *(_OWORD *)v42;
    v56.__r_.__value_.__r.__words[2] = *(void *)(v42 + 24);
    *(_DWORD *)&__str[8] = 0;
    *(void *)&__str[48] = 0;
    *(void *)std::string __str = &unk_1F2646F30;
    *(void *)&__str[64] = v45 + 112;
    *(_DWORD *)&__str[56] = 0;
    memset(&__str[16], 0, 25);
    llvm::Metadata::printAsOperand((llvm::Metadata *)v56.__r_.__value_.__l.__data_, (llvm::raw_ostream *)__str, a4, 0);
  }
  if (v73 != v75) {
    free(v73);
  }
  if (v79 != (int *)v81) {
    free(v79);
  }
}

void llvm::MIRPrinter::convertCallSiteObjects(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v35[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a3 + 16) + 176))(*(void *)(a3 + 16));
  uint64_t v6 = *(void *)(a3 + 744);
  uint64_t v7 = *(unsigned int *)(a3 + 760);
  unsigned int v8 = (uint64_t *)(v6 + 32 * v7);
  if (*(_DWORD *)(a3 + 752))
  {
    if (v7)
    {
      uint64_t v9 = 32 * v7;
      uint64_t v10 = *(uint64_t **)(a3 + 744);
      while ((*v10 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v10 += 4;
        v9 -= 32;
        if (!v9) {
          goto LABEL_6;
        }
      }
    }
    else
    {
      uint64_t v10 = *(uint64_t **)(a3 + 744);
    }
  }
  else
  {
LABEL_6:
    uint64_t v10 = (uint64_t *)(v6 + 32 * v7);
  }
  BOOL v11 = (uint64_t *)(v6 + 32 * v7);
  while (v10 != v11)
  {
    uint64_t v12 = *v10;
    uint64_t v32 = *v10;
    uint64_t v33 = v35;
    uint64_t v34 = 0x100000000;
    if (*((_DWORD *)v10 + 4))
    {
      sub_1CD532C28((uint64_t)&v33, (uint64_t)(v10 + 1));
      uint64_t v12 = v32;
    }
    memset(v31, 0, sizeof(v31));
    uint64_t v13 = *(void *)(v12 + 24);
    unsigned int v14 = *(_DWORD *)(v13 + 24);
    uint64_t v15 = *(void *)(v13 + 56);
    if (v15 == v12)
    {
      unsigned int v16 = 0;
    }
    else
    {
      unsigned int v16 = 0;
      do
      {
        ++v16;
        uint64_t v15 = *(void *)(v15 + 8);
      }
      while (v15 != v12);
    }
    unint64_t v30 = __PAIR64__(v16, v14);
    if (v34)
    {
      unsigned int v17 = (uint64_t *)v33;
      uint64_t v18 = 8 * v34;
      do
      {
        uint64_t v19 = *v17;
        unint64_t v20 = HIDWORD(*v17);
        uint64_t v28 = 0;
        *(_OWORD *)long long __p = 0u;
        long long v27 = 0u;
        __int16 v29 = v20;
        sub_1CC3CD1B0(v19, (uint64_t)__p, v5);
        sub_1CD55DAB0(v31, (uint64_t)__p);
        if (SBYTE7(v27) < 0) {
          operator delete(__p[0]);
        }
        ++v17;
        v18 -= 8;
      }
      while (v18);
    }
    sub_1CC3CD41C((uint64_t *)(a2 + 360), &v30);
    __p[0] = v31;
    sub_1CC3CE3C8((void ***)__p);
    if (v33 != v35) {
      free(v33);
    }
    __int16 v21 = v10 + 4;
    uint64_t v10 = v8;
    if (v21 != v8)
    {
      uint64_t v10 = v21;
      while ((*v10 | 0x1000) == 0xFFFFFFFFFFFFF000)
      {
        v10 += 4;
        if (v10 == v8)
        {
          uint64_t v10 = v8;
          break;
        }
      }
    }
  }
  unint64_t v22 = *(void *)(a2 + 360);
  uint64_t v23 = *(void ***)(a2 + 368);
  unint64_t v24 = 126 - 2 * __clz((uint64_t)((uint64_t)v23 - v22) >> 5);
  if (v23 == (void **)v22) {
    uint64_t v25 = 0;
  }
  else {
    uint64_t v25 = v24;
  }
  sub_1CC3D11A8(v22, v23, v25, 1);
}

void llvm::MIRPrinter::convert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 8);
  uint64_t v11 = *(void *)(a3 + 16);
  if (v3 != v11)
  {
    int v4 = 0;
    uint64_t v10 = (unint64_t *)(a2 + 328);
    do
    {
      v31[0] = 0;
      v31[1] = 0;
      uint64_t v32 = 0;
      int v23 = 0;
      char v27 = 0;
      uint64_t v28 = 0;
      unint64_t v22 = &unk_1F2646F30;
      unint64_t v30 = v31;
      int v29 = 0;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v24 = 0;
      uint64_t v5 = *(llvm::Value **)v3;
      if (*(unsigned char *)(v3 + 9)) {
        (*(void (**)(llvm::Value *, void **))(*(void *)v5 + 48))(v5, &v22);
      }
      else {
        llvm::Value::printAsOperand(v5, (llvm::raw_ostream *)&v22, 1, 0);
      }
      LODWORD(v13) = v4;
      *((void *)&v13 + 1) = 0;
      uint64_t v14 = 0;
      if (*((char *)v30 + 23) < 0)
      {
        sub_1CB8BDF7C((uint64_t)v12, *v30, (unint64_t)v30[1]);
      }
      else
      {
        long long v6 = *(_OWORD *)v30;
        *(void *)&v12[1] = v30[2];
        v12[0] = v6;
      }
      *(void *)unsigned int v16 = *((void *)&v12[0] + 1);
      uint64_t v7 = *(void **)&v12[0];
      *(void *)&v16[7] = *(void *)((char *)v12 + 15);
      int v8 = SBYTE7(v12[1]);
      memset(v12, 0, 24);
      uint64_t v15 = v7;
      char v17 = v8;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      char v9 = *(unsigned char *)(v3 + 9);
      __int16 v20 = *(unsigned __int8 *)(v3 + 8) | 0x100;
      char v21 = v9;
      sub_1CC3CD584(v10, &v13);
      if (v8 < 0) {
        operator delete(v7);
      }
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v22);
      if (SHIBYTE(v32) < 0) {
        operator delete(v31[0]);
      }
      v3 += 16;
      ++v4;
    }
    while (v3 != v11);
  }
}

void llvm::MIRPrinter::convert(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  *a3 = *(_DWORD *)a4;
  int v4 = *(uint64_t ***)(a4 + 8);
  unsigned int v16 = *(uint64_t ***)(a4 + 16);
  if (v4 != v16)
  {
    int v5 = 0;
    uint64_t v15 = (uint64_t *)(a3 + 2);
    long long v6 = (void (*)(uint64_t, llvm::raw_ostream *))off_1F260D538;
    do
    {
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      unint64_t v32 = 0;
      int64x2_t v31 = 0uLL;
      int v17 = v5;
      LODWORD(v29) = v5;
      *((void *)&v29 + 1) = 0;
      uint64_t v30 = 0;
      int v8 = *v4;
      uint64_t v7 = v4[1];
      uint64_t v18 = v4;
      if (*v4 != v7)
      {
        do
        {
          uint64_t v9 = *v8;
          int v21 = 0;
          char v25 = 0;
          uint64_t v26 = 0;
          __int16 v20 = (int64x2_t *)&unk_1F2646F30;
          uint64_t v28 = (const void **)&v33;
          int v27 = 0;
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          uint64_t v22 = 0;
          long long v37 = v36;
          *(void *)long long v36 = &unk_1F260D508;
          *(void *)&v36[8] = v9;
          v6((uint64_t)v36, (llvm::raw_ostream *)&v20);
          if (v37 == v36)
          {
            (*(void (**)(unsigned char *))(*(void *)v36 + 32))(v36);
          }
          else if (v37)
          {
            (*(void (**)(unsigned char *))(*(void *)v37 + 40))(v37);
          }
          if (*((char *)v28 + 23) < 0)
          {
            sub_1CB8BDF7C((uint64_t)__p, *v28, (unint64_t)v28[1]);
          }
          else
          {
            long long v10 = *(_OWORD *)v28;
            __p[2] = (void *)v28[2];
            *(_OWORD *)long long __p = v10;
          }
          uint64_t v11 = __p[0];
          *(void **)&v36[8] = __p[1];
          *(void **)&v36[15] = *(void **)((char *)&__p[1] + 7);
          char v12 = HIBYTE(__p[2]);
          memset(__p, 0, sizeof(__p));
          *(void *)long long v36 = v11;
          v36[23] = v12;
          long long v37 = 0;
          uint64_t v38 = 0;
          long long v13 = (void *)v31.i64[1];
          if (v31.i64[1] >= v32)
          {
            v31.i64[1] = (uint64_t)sub_1CC3D3FE4(&v31, (uint64_t)v36);
            if ((v36[23] & 0x80000000) != 0) {
              operator delete(*(void **)v36);
            }
          }
          else
          {
            *(_OWORD *)v31.i64[1] = *(_OWORD *)v36;
            uint64_t v14 = *(void *)&v36[16];
            v13[3] = 0;
            uint64_t v13[4] = 0;
            void v13[2] = v14;
            v31.i64[1] = (uint64_t)(v13 + 5);
          }
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v35) < 0)
          {
            *uint64_t v33 = 0;
            uint64_t v34 = 0;
          }
          else
          {
            LOBYTE(v33) = 0;
            HIBYTE(v35) = 0;
          }
          llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v20);
          ++v8;
        }
        while (v8 != v7);
      }
      sub_1CC3CD7D8(v15, &v29);
      __int16 v20 = &v31;
      sub_1CC3CDF68((void ***)&v20);
      if (SHIBYTE(v35) < 0) {
        operator delete(v33);
      }
      int v5 = v17 + 1;
      int v4 = v18 + 3;
    }
    while (v18 + 3 != v16);
  }
}

void llvm::MIRPrinter::convertMachineMetadataNodes(uint64_t a1, uint64_t a2, uint64_t a3, llvm::ModuleSlotTracker *a4)
{
  unsigned int v16 = 0;
  int v17 = 0;
  uint64_t v18 = 0;
  llvm::MachineModuleSlotTracker::collectMachineMDNodes((uint64_t)a4, (uint64_t)&v16);
  if (v16 != v17)
  {
    memset(v15, 0, sizeof(v15));
    int v7 = 0;
    char v11 = 0;
    uint64_t v12 = 0;
    long long v6 = &unk_1F2646F30;
    uint64_t v14 = v15;
    int v13 = 0;
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v8 = 0;
    llvm::Metadata::print(v16[1], (llvm::raw_ostream *)&v6, a4, *(const llvm::Module **)(*(void *)a3 + 40));
  }
  if (v16)
  {
    int v17 = v16;
    operator delete(v16);
  }
}

llvm::yaml::Output *sub_1CD55D960(llvm::yaml::Output *a1, uint64_t a2)
{
  if (llvm::yaml::Output::preflightDocument(a1, 0))
  {
    (*(void (**)(llvm::yaml::Output *))(*(void *)a1 + 104))(a1);
    sub_1CD55F004(a1, a2);
    (*(void (**)(llvm::yaml::Output *))(*(void *)a1 + 112))(a1);
    llvm::yaml::Output::postflightDocument(a1);
  }
  llvm::yaml::Output::endDocuments(a1);
  return a1;
}

llvm::raw_ostream *llvm::MIPrinter::printStackObjectReference(llvm::MIPrinter *this, int a2)
{
  int v2 = (uint64_t *)*((void *)this + 3);
  uint64_t v3 = *v2;
  unsigned int v4 = *((_DWORD *)v2 + 4);
  if (v4)
  {
    unsigned int v5 = (v4 - 1) & (37 * a2);
    long long v6 = (int *)(v3 + 40 * v5);
    int v7 = *v6;
    if (*v6 == a2) {
      goto LABEL_3;
    }
    int v18 = 1;
    while (v7 != 0x7FFFFFFF)
    {
      unsigned int v19 = v5 + v18++;
      unsigned int v5 = v19 & (v4 - 1);
      long long v6 = (int *)(v3 + 40 * v5);
      int v7 = *v6;
      if (*v6 == a2) {
        goto LABEL_3;
      }
    }
  }
  long long v6 = (int *)(v3 + 40 * v4);
LABEL_3:
  uint64_t v8 = *(llvm::raw_ostream **)this;
  char v11 = (int *)*((void *)v6 + 1);
  uint64_t v10 = v6 + 2;
  uint64_t v9 = v11;
  char v12 = *((unsigned char *)v10 + 23);
  int v13 = v12;
  if (v12 >= 0) {
    uint64_t v14 = v10;
  }
  else {
    uint64_t v14 = v9;
  }
  size_t v15 = v12 & 0x7F;
  if (v13 >= 0) {
    size_t v16 = v15;
  }
  else {
    size_t v16 = *((void *)v10 + 1);
  }
  return llvm::MachineOperand::printStackObjectReference(v8, v10[6], *((unsigned __int8 *)v10 + 28), v14, v16);
}

char *sub_1CD55DAB0(unint64_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[1];
  if (v4 >= a1[2])
  {
    uint64_t result = sub_1CC3D0FFC(a1, a2);
  }
  else
  {
    if (*(char *)(a2 + 23) < 0)
    {
      sub_1CB8BDF7C(a1[1], *(const void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long v5 = *(_OWORD *)a2;
      *(void *)(v4 + 16) = *(void *)(a2 + 16);
      *(_OWORD *)unint64_t v4 = v5;
    }
    *(_OWORD *)(v4 + 24) = *(_OWORD *)(a2 + 24);
    *(_WORD *)(v4 + 40) = *(_WORD *)(a2 + 40);
    uint64_t result = (char *)(v4 + 48);
  }
  a1[1] = (unint64_t)result;
  return result;
}

void llvm::guessSuccessors(llvm::MachineBasicBlock *this, uint64_t a2, char *a3)
{
  int v18 = v22;
  unsigned int v19 = v22;
  uint64_t v20 = 8;
  int v21 = 0;
  long long v5 = (char *)this + 48;
  uint64_t v6 = *((void *)this + 7);
  if ((llvm::MachineBasicBlock *)v6 != (llvm::MachineBasicBlock *)((char *)this + 48))
  {
    do
    {
      if (**(_WORD **)(v6 + 16))
      {
        if (**(_WORD **)(v6 + 16) != 69)
        {
          uint64_t v8 = *(unsigned int *)(v6 + 40);
          if (v8)
          {
            uint64_t v9 = 32 * v8;
            uint64_t v10 = (uint64_t *)(*(void *)(v6 + 32) + 16);
            do
            {
              if (*((unsigned char *)v10 - 16) == 4)
              {
                uint64_t v11 = *v10;
                sub_1CB89694C((llvm::SmallPtrSetImplBase *)&v18, *v10);
                if (v12)
                {
                  unint64_t v13 = *(unsigned int *)(a2 + 8);
                  if (v13 >= *(unsigned int *)(a2 + 12)) {
                    llvm::SmallVectorBase<unsigned int>::grow_pod();
                  }
                  *(void *)(*(void *)a2 + 8 * v13) = v11;
                  ++*(_DWORD *)(a2 + 8);
                }
              }
              v10 += 4;
              v9 -= 32;
            }
            while (v9);
            if (!v6) {
              goto LABEL_16;
            }
          }
        }
      }
      if ((*(unsigned char *)v6 & 4) == 0)
      {
LABEL_16:
        while ((*(_WORD *)(v6 + 44) & 8) != 0)
          uint64_t v6 = *(void *)(v6 + 8);
      }
      uint64_t v6 = *(void *)(v6 + 8);
    }
    while ((char *)v6 != v5);
  }
  char v14 = 1;
  uint64_t LastNonDebugInstr = llvm::MachineBasicBlock::getLastNonDebugInstr(this, 1);
  if (v5 != (char *)LastNonDebugInstr)
  {
    if ((*(_WORD *)(LastNonDebugInstr + 44) & 0xC) != 0 && (*(_WORD *)(LastNonDebugInstr + 44) & 4) == 0) {
      char hasPropertyInBundle = llvm::MachineInstr::hasPropertyInBundle(LastNonDebugInstr, 256, 1);
    }
    else {
      char hasPropertyInBundle = *(unsigned char *)(*(void *)(LastNonDebugInstr + 16) + 9) & 1;
    }
    char v14 = hasPropertyInBundle ^ 1;
  }
  *a3 = v14;
  if (v19 != v18) {
    free(v19);
  }
}

BOOL llvm::MIPrinter::canPredictBranchProbabilities(llvm::MIPrinter *this, const llvm::MachineBasicBlock *a2)
{
  _OWORD v20[4] = *MEMORY[0x1E4F143B8];
  if (((*((void *)a2 + 12) - *((void *)a2 + 11)) & 0x7FFFFFFF0) == 0) {
    return 1;
  }
  uint64_t v3 = (char *)*((void *)a2 + 14);
  unint64_t v4 = (char *)*((void *)a2 + 15);
  if (v3 == v4) {
    return 1;
  }
  int v18 = v20;
  uint64_t v19 = 0x800000000;
  sub_1CD462190((uint64_t)&v18, v3, v4);
  sub_1CD55DE24((unsigned int *)v18, (unsigned int *)v18 + v19);
  size_t v15 = v17;
  uint64_t v16 = 0x800000000;
  sub_1CBF8EBE4((uint64_t)&v15, v19, -1);
  sub_1CD55DE24((unsigned int *)v15, (unsigned int *)v15 + v16);
  int v7 = v18;
  if (v19)
  {
    uint64_t v8 = 4 * v19 - 4;
    uint64_t v9 = (int *)v15;
    uint64_t v10 = (int *)v18;
    do
    {
      int v12 = *v9++;
      int v11 = v12;
      int v13 = *v10++;
      BOOL v5 = v13 == v11;
      BOOL v14 = v13 != v11 || v8 == 0;
      v8 -= 4;
    }
    while (!v14);
  }
  else
  {
    BOOL v5 = 1;
  }
  if (v15 != v17)
  {
    free(v15);
    int v7 = v18;
  }
  if (v7 != v20) {
    free(v7);
  }
  return v5;
}

unsigned int *sub_1CD55DE24(unsigned int *result, unsigned int *a2)
{
  if (result != a2)
  {
    unint64_t v2 = 0;
    unsigned int v3 = 0;
    unint64_t v4 = result;
    do
    {
      int v6 = *v4++;
      LODWORD(v5) = v6;
      BOOL v7 = v6 == -1;
      if (v6 == -1) {
        ++v3;
      }
      if (v7) {
        uint64_t v5 = 0;
      }
      else {
        uint64_t v5 = v5;
      }
      v2 += v5;
    }
    while (v4 != a2);
    if (v3)
    {
      if (v2 >> 31) {
        unsigned int v8 = 0;
      }
      else {
        unsigned int v8 = (0x80000000 - v2) / v3;
      }
      int v12 = result;
      do
      {
        if (*v12 == -1) {
          *int v12 = v8;
        }
        ++v12;
      }
      while (v12 != a2);
      if (v2 > 0x80000000) {
        goto LABEL_25;
      }
    }
    else
    {
      if (v2)
      {
        do
        {
LABEL_25:
          char *result = ((v2 >> 1) + ((unint64_t)*result << 31)) / v2;
          ++result;
        }
        while (result != a2);
        return result;
      }
      uint64_t v9 = a2 - result;
      if (v9 == 0x80000000) {
        unsigned int v10 = 1;
      }
      else {
        unsigned int v10 = ((v9 >> 1) | 0x80000000) / v9;
      }
      if ((char *)a2 - (char *)result >= 1)
      {
        uint64_t v11 = v9 + 1;
        do
        {
          *result++ = v10;
          --v11;
        }
        while (v11 > 1);
      }
    }
  }
  return result;
}

BOOL llvm::MIPrinter::canPredictSuccessors(llvm::MIPrinter *this, const llvm::MachineBasicBlock *a2)
{
  int v15[8] = *MEMORY[0x1E4F143B8];
  __s2 = v15;
  uint64_t v14 = 0x800000000;
  char v12 = 0;
  llvm::guessSuccessors(a2, (uint64_t)&__s2, &v12);
  if (v12)
  {
    uint64_t v3 = *((void *)a2 + 1);
    int v4 = v14;
    if (v3 != *((void *)a2 + 4) + 320)
    {
      uint64_t v5 = (char *)__s2;
      if (v14)
      {
        uint64_t v6 = 8 * v14;
        uint64_t v5 = (char *)__s2;
        while (*(void *)v5 != v3)
        {
          v5 += 8;
          v6 -= 8;
          if (!v6)
          {
            uint64_t v5 = (char *)__s2 + 8 * v14;
            break;
          }
        }
      }
      if (v14 == (v5 - (unsigned char *)__s2) >> 3)
      {
        if (v14 >= HIDWORD(v14)) {
          llvm::SmallVectorBase<unsigned int>::grow_pod();
        }
        *((void *)__s2 + v14) = v3;
        int v4 = v14 + 1;
        LODWORD(v14) = v14 + 1;
      }
    }
  }
  else
  {
    int v4 = v14;
  }
  BOOL v7 = (const void *)*((void *)a2 + 11);
  size_t v8 = *((void *)a2 + 12) - (void)v7;
  uint64_t v9 = __s2;
  BOOL v10 = v4 == (v8 >> 3) && memcmp(v7, __s2, v8) == 0;
  if (v9 != v15) {
    free(v9);
  }
  return v10;
}

void ***llvm::MIPrinter::print(llvm::raw_ostream **this, const llvm::MachineInstr *a2)
{
  uint64_t v4 = *(void *)(*((void *)a2 + 3) + 32);
  uint64_t v5 = *(void *)(v4 + 40);
  uint64_t v61 = v4;
  uint64_t v6 = *(void *)(v4 + 16);
  BOOL v7 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(void *)v6 + 176))(v6);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 104))(v6);
  uint64_t v64 = 0x2000000000000001;
  int hasComplexRegisterTies = llvm::MachineInstr::hasComplexRegisterTies(a2);
  unint64_t v10 = *((unsigned int *)a2 + 10);
  if (!v10)
  {
    BOOL v62 = 0;
    goto LABEL_10;
  }
  if ((**((_DWORD **)a2 + 4) & 0x30000FF) != 0x1000000)
  {
    BOOL v62 = 1;
    unsigned int v63 = 0;
    goto LABEL_11;
  }
  unint64_t v11 = 0;
  while (1)
  {
    if (v11) {
      sub_1CB8E509C(*this, ", ");
    }
    uint64_t TypeToPrint = llvm::MachineInstr::getTypeToPrint((uint64_t)a2, v11, (unint64_t *)&v64, v5);
    llvm::MIPrinter::print((uint64_t)this, (uint64_t)a2, v11++, v7, v8, hasComplexRegisterTies, TypeToPrint, 0);
    if (v11 == v10) {
      break;
    }
    if ((*(_DWORD *)(*((void *)a2 + 4) + 32 * v11) & 0x30000FF) != 0x1000000)
    {
      unsigned int v13 = v11;
      goto LABEL_92;
    }
  }
  unsigned int v13 = v10;
LABEL_92:
  BOOL v62 = v11 < v10;
  if (!v13)
  {
LABEL_10:
    unsigned int v63 = 0;
    goto LABEL_11;
  }
  unsigned int v63 = v13;
  sub_1CB8E509C(*this, " = ");
LABEL_11:
  __int16 v14 = *((_WORD *)a2 + 22);
  if (v14)
  {
    sub_1CB8E509C(*this, "frame-setup ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 2) != 0)
  {
    sub_1CB8E509C(*this, "frame-destroy ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x10) != 0)
  {
    sub_1CB8E509C(*this, "nnan ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x20) != 0)
  {
    sub_1CB8E509C(*this, "ninf ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x40) != 0)
  {
    sub_1CB8E509C(*this, "nsz ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x80) != 0)
  {
    sub_1CB8E509C(*this, "arcp ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x100) != 0)
  {
    sub_1CB8E509C(*this, "contract ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x200) != 0)
  {
    sub_1CB8E509C(*this, "afn ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x400) != 0)
  {
    sub_1CB8E509C(*this, "reassoc ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x800) != 0)
  {
    sub_1CB8E509C(*this, "nuw ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x1000) != 0)
  {
    sub_1CB8E509C(*this, "nsw ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x2000) != 0)
  {
    sub_1CB8E509C(*this, "exact ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if ((v14 & 0x4000) != 0)
  {
    sub_1CB8E509C(*this, "nofpexcept ");
    __int16 v14 = *((_WORD *)a2 + 22);
  }
  if (v14 < 0) {
    sub_1CB8E509C(*this, "nomerge ");
  }
  uint64_t v15 = *(void *)(v8 + 24);
  if (v15)
  {
    uint64_t v16 = *this;
    int v17 = (const char *)(v15 + *(unsigned int *)(*(void *)(v8 + 16) + 4 * **((unsigned __int16 **)a2 + 2)));
    size_t v18 = strlen(v17);
    uint64_t v19 = (void *)*((void *)*this + 4);
    if (v18 <= *((void *)*this + 3) - (void)v19)
    {
      if (v18)
      {
        memcpy(v19, v17, v18);
        *((void *)v16 + 4) += v18;
      }
    }
    else
    {
      llvm::raw_ostream::write(v16, v17, v18);
    }
  }
  if (v62)
  {
    uint64_t v20 = *this;
    int v21 = (unsigned char *)*((void *)*this + 4);
    if ((unint64_t)v21 >= *((void *)*this + 3))
    {
      llvm::raw_ostream::write(v20, 32);
    }
    else
    {
      *((void *)v20 + 4) = v21 + 1;
      *int v21 = 32;
    }
  }
  if (v63 < v10)
  {
    char v22 = 0;
    uint64_t v23 = v63;
    do
    {
      if (v22) {
        sub_1CB8E509C(*this, ", ");
      }
      uint64_t v24 = llvm::MachineInstr::getTypeToPrint((uint64_t)a2, v23, (unint64_t *)&v64, v5);
      char v22 = 1;
      llvm::MIPrinter::print((uint64_t)this, (uint64_t)a2, v23, v7, v8, hasComplexRegisterTies, v24, 1);
      uint64_t v23 = (v23 + 1);
    }
    while (v10 != v23);
  }
  uint64_t v26 = (unint64_t *)((char *)a2 + 48);
  unint64_t v25 = *((void *)a2 + 6);
  if (v25 < 8)
  {
    BOOL v32 = v63 < v10;
    goto LABEL_68;
  }
  int v27 = (llvm::raw_ostream *)(v25 & 0xFFFFFFFFFFFFFFF8);
  BOOL v28 = (*((void *)a2 + 6) & 7) != 1 || v27 == 0;
  long long v29 = (llvm::raw_ostream *)(v25 & 0xFFFFFFFFFFFFFFF8);
  if (!v28
    || (*((void *)a2 + 6) & 7) == 3
    && v27
    && *((unsigned char *)v27 + 4)
    && (long long v29 = (llvm::raw_ostream *)*((void *)v27 + *(int *)v27 + 1)) != 0)
  {
    if (v63 < v10)
    {
      uint64_t v30 = *this;
      int64x2_t v31 = (unsigned char *)*((void *)*this + 4);
      if ((unint64_t)v31 >= *((void *)*this + 3))
      {
        llvm::raw_ostream::write(v30, 44);
      }
      else
      {
        *((void *)v30 + 4) = v31 + 1;
        *int64x2_t v31 = 44;
      }
    }
    sub_1CB8E509C(*this, " pre-instr-symbol ");
    llvm::MachineOperand::printSymbol(*this, v29, v53);
    unint64_t v25 = *v26;
    if (*v26 < 8) {
      goto LABEL_128;
    }
    int v27 = (llvm::raw_ostream *)(v25 & 0xFFFFFFFFFFFFFFF8);
    BOOL v32 = 1;
  }
  else
  {
    BOOL v32 = v63 < v10;
  }
  if ((v25 & 7) == 2 && v27)
  {
    long long v36 = v27;
    goto LABEL_76;
  }
  if ((v25 & 7) == 3)
  {
    if (v27)
    {
      if (*((unsigned char *)v27 + 5))
      {
        long long v36 = (llvm::raw_ostream *)*((void *)v27 + *(int *)v27 + *((unsigned __int8 *)v27 + 4) + 1);
        if (v36)
        {
LABEL_76:
          if (v32)
          {
            long long v37 = *this;
            uint64_t v38 = (unsigned char *)*((void *)*this + 4);
            if ((unint64_t)v38 >= *((void *)*this + 3))
            {
              llvm::raw_ostream::write(v37, 44);
            }
            else
            {
              *((void *)v37 + 4) = v38 + 1;
              *uint64_t v38 = 44;
            }
          }
          sub_1CB8E509C(*this, " post-instr-symbol ");
          llvm::MachineOperand::printSymbol(*this, v36, v57);
          unint64_t v25 = *v26;
          if (*v26 >= 8)
          {
            int v27 = (llvm::raw_ostream *)(v25 & 0xFFFFFFFFFFFFFFF8);
            BOOL v32 = 1;
            goto LABEL_121;
          }
LABEL_128:
          BOOL v32 = 1;
          goto LABEL_68;
        }
      }
    }
  }
LABEL_121:
  if ((v25 & 7) == 3)
  {
    if (v27)
    {
      if (*((unsigned char *)v27 + 6))
      {
        char v58 = (llvm::Metadata *)*((void *)v27
                                + *(int *)v27
                                + (*((unsigned char *)v27 + 5) + *((unsigned char *)v27 + 4))
                                + 1);
        if (v58)
        {
          if (v32)
          {
            long long v59 = *this;
            long long v60 = (unsigned char *)*((void *)*this + 4);
            if ((unint64_t)v60 >= *((void *)*this + 3))
            {
              llvm::raw_ostream::write(v59, 44);
            }
            else
            {
              *((void *)v59 + 4) = v60 + 1;
              *long long v60 = 44;
            }
          }
          sub_1CB8E509C(*this, " heap-alloc-marker ");
          llvm::Metadata::printAsOperand(v58, *this, this[1], 0);
        }
      }
    }
  }
LABEL_68:
  unsigned int v33 = *((_DWORD *)a2 + 16);
  if (v33)
  {
    if (v32)
    {
      uint64_t v34 = *this;
      uint64_t v35 = (unsigned char *)*((void *)*this + 4);
      if ((unint64_t)v35 >= *((void *)*this + 3))
      {
        llvm::raw_ostream::write(v34, 44);
      }
      else
      {
        *((void *)v34 + 4) = v35 + 1;
        *uint64_t v35 = 44;
      }
    }
    uint64_t v39 = sub_1CB8E509C(*this, " debug-instr-number ");
    llvm::raw_ostream::operator<<(v39, v33);
    BOOL v32 = 1;
  }
  if (byte_1EBCD12E8 && *((void *)a2 + 7))
  {
    if (v32)
    {
      uint64_t v40 = *this;
      int v41 = (unsigned char *)*((void *)*this + 4);
      if ((unint64_t)v41 >= *((void *)*this + 3))
      {
        llvm::raw_ostream::write(v40, 44);
      }
      else
      {
        *((void *)v40 + 4) = v41 + 1;
        *int v41 = 44;
      }
    }
    sub_1CB8E509C(*this, " debug-location ");
    uint64_t v42 = (llvm::Metadata *)llvm::DebugLoc::get((const llvm::MachineInstr *)((char *)a2 + 56));
    llvm::Metadata::printAsOperand(v42, *this, this[1], 0);
  }
  unint64_t v43 = *v26;
  if (*v26 >= 8)
  {
    if ((v43 & 7) != 0)
    {
      if ((*v26 & 7) != 3) {
        return sub_1CB9F9ED4((void ***)&v64);
      }
      uint64_t v44 = (_DWORD *)(v43 & 0xFFFFFFFFFFFFFFF8);
      if (!v44 || !*v44) {
        return sub_1CB9F9ED4((void ***)&v64);
      }
    }
    else
    {
      *uint64_t v26 = v43 & 0xFFFFFFFFFFFFFFF8;
    }
    sub_1CB8E509C(*this, " :: ");
    uint64_t Context = llvm::Function::getContext(*(llvm::Function **)v61);
    unint64_t v46 = *v26;
    if (*v26 < 8) {
      return sub_1CB9F9ED4((void ***)&v64);
    }
    uint64_t v47 = (uint64_t *)Context;
    int v48 = *(void **)(v61 + 56);
    if ((v46 & 7) != 0)
    {
      if ((*v26 & 7) != 3) {
        return sub_1CB9F9ED4((void ***)&v64);
      }
      long long v49 = (int *)(v46 & 0xFFFFFFFFFFFFFFF8);
      if ((v46 & 0xFFFFFFFFFFFFFFF8) == 0) {
        return sub_1CB9F9ED4((void ***)&v64);
      }
      uint64_t v51 = *v49;
      uint64_t v26 = (unint64_t *)(v49 + 2);
      uint64_t v50 = v51;
      if (!v51) {
        return sub_1CB9F9ED4((void ***)&v64);
      }
      uint64_t v52 = &v26[v50];
    }
    else
    {
      *((void *)a2 + 6) = v46 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v52 = (unint64_t *)((char *)a2 + 56);
    }
    char v54 = 0;
    do
    {
      long long v55 = (uint64_t *)*v26;
      if (v54) {
        sub_1CB8E509C(*this, ", ");
      }
      llvm::MachineMemOperand::print(v55, *this, this[1], (uint64_t)(this + 4), v47, v48, v8);
      ++v26;
      char v54 = 1;
    }
    while (v26 != v52);
  }
  return sub_1CB9F9ED4((void ***)&v64);
}

llvm::raw_ostream *llvm::MIRFormatter::printIRValue(llvm::MIRFormatter *this, llvm::raw_ostream *a2, llvm::SlotTracker **a3, llvm::ModuleSlotTracker *a4)
{
  unsigned int v7 = *((unsigned __int8 *)a2 + 16);
  if (v7 > 3)
  {
    if (v7 > 0x14)
    {
      sub_1CB8E509C(this, "%ir.");
      if ((*((unsigned char *)a2 + 23) & 0x10) != 0)
      {
        uint64_t Name = llvm::Value::getName(a2);
        return llvm::printLLVMNameWithoutPrefix(this, (llvm::raw_ostream *)Name, v12);
      }
      else
      {
        if (a3[4]) {
          uint64_t LocalSlot = llvm::ModuleSlotTracker::getLocalSlot(a3, a2);
        }
        else {
          uint64_t LocalSlot = 0xFFFFFFFFLL;
        }
        return llvm::MachineOperand::printIRSlotNumber(this, (llvm::raw_ostream *)LocalSlot);
      }
    }
    else
    {
      uint64_t v9 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v9 >= *((void *)this + 3))
      {
        llvm::raw_ostream::write(this, 96);
      }
      else
      {
        *((void *)this + 4) = v9 + 1;
        unsigned char *v9 = 96;
      }
      uint64_t result = (llvm::raw_ostream *)llvm::Value::printAsOperand(a2, this, 1, (llvm::ModuleSlotTracker *)a3);
      unint64_t v11 = (unsigned char *)*((void *)this + 4);
      if ((unint64_t)v11 >= *((void *)this + 3))
      {
        return llvm::raw_ostream::write(this, 96);
      }
      else
      {
        *((void *)this + 4) = v11 + 1;
        *unint64_t v11 = 96;
      }
    }
  }
  else
  {
    return (llvm::raw_ostream *)llvm::Value::printAsOperand(a2, this, 0, (llvm::ModuleSlotTracker *)a3);
  }
  return result;
}

void llvm::printMIR(llvm *this, const std::string *a2, const llvm::Module *a3)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  llvm::yaml::Output::Output((llvm::yaml::Output *)v4, this, 0, 70);
  sub_1CD55EA90((llvm::yaml::Output *)v4, a2);
  llvm::yaml::Output::~Output((llvm::yaml::Output *)v4);
}

llvm::yaml::Output *sub_1CD55EA90(llvm::yaml::Output *a1, const std::string *a2)
{
  if (llvm::yaml::Output::preflightDocument(a1, 0))
  {
    sub_1CD5674B8(a1, a2);
    llvm::yaml::Output::postflightDocument(a1);
  }
  llvm::yaml::Output::endDocuments(a1);
  return a1;
}

uint64_t llvm::printMIR(llvm *this, llvm::raw_ostream *a2, const llvm::MachineFunction *a3)
{
  v4[1] = 0;
  void v4[2] = 0;
  v4[0] = this;
  int v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  llvm::MIRPrinter::print((llvm::MIRPrinter *)v4, a2);
  return sub_1CD55EE00((uint64_t)v4);
}

uint64_t sub_1CD55EB2C(uint64_t a1)
{
  if (*(char *)(a1 + 487) < 0) {
    operator delete(*(void **)(a1 + 464));
  }
  int v5 = (void **)(a1 + 440);
  sub_1CC3CDF68(&v5);
  int v5 = (void **)(a1 + 416);
  sub_1CC3CDFF4(&v5);
  unint64_t v2 = *(void **)(a1 + 384);
  if (v2)
  {
    *(void *)(a1 + 392) = v2;
    operator delete(v2);
  }
  int v5 = (void **)(a1 + 360);
  sub_1CC3CE090(&v5);
  uint64_t v3 = *(void *)(a1 + 352);
  *(void *)(a1 + 352) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v5 = (void **)(a1 + 328);
  sub_1CC3CE12C(&v5);
  int v5 = (void **)(a1 + 304);
  sub_1CC3CE1B8(&v5);
  int v5 = (void **)(a1 + 280);
  sub_1CC3CE23C(&v5);
  sub_1CD55EC4C(a1 + 112);
  if (*(unsigned char *)(a1 + 104))
  {
    int v5 = (void **)(a1 + 80);
    sub_1CC3CDF68(&v5);
    *(unsigned char *)(a1 + 104) = 0;
  }
  int v5 = (void **)(a1 + 56);
  sub_1CC3CE2C0(&v5);
  int v5 = (void **)(a1 + 32);
  sub_1CC3CE344(&v5);
  return a1;
}

uint64_t sub_1CD55EC4C(uint64_t a1)
{
  if (*(char *)(a1 + 151) < 0) {
    operator delete(*(void **)(a1 + 128));
  }
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
  return a1;
}

uint64_t sub_1CD55ECA0(uint64_t a1)
{
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

uint64_t sub_1CD55ECE4(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1CD55ED28(uint64_t a1)
{
  if (*(char *)(a1 + 215) < 0) {
    operator delete(*(void **)(a1 + 192));
  }
  if (*(char *)(a1 + 175) < 0) {
    operator delete(*(void **)(a1 + 152));
  }
  if (*(char *)(a1 + 135) < 0) {
    operator delete(*(void **)(a1 + 112));
  }
  if (*(char *)(a1 + 87) < 0) {
    operator delete(*(void **)(a1 + 64));
  }
  return a1;
}

uint64_t sub_1CD55ED8C(uint64_t a1)
{
  if (*(char *)(a1 + 263) < 0) {
    operator delete(*(void **)(a1 + 240));
  }
  if (*(char *)(a1 + 223) < 0) {
    operator delete(*(void **)(a1 + 200));
  }
  if (*(char *)(a1 + 183) < 0) {
    operator delete(*(void **)(a1 + 160));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

uint64_t sub_1CD55EE00(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v4 = 40 * v2;
    do
    {
      if ((*(_DWORD *)v3 - 0x7FFFFFFF) >= 2 && *(char *)(v3 + 31) < 0) {
        operator delete(*(void **)(v3 + 8));
      }
      v3 += 40;
      v4 -= 40;
    }
    while (v4);
    uint64_t v3 = *(void *)(a1 + 32);
  }
  MEMORY[0x1D25D9CD0](v3, 8);
  MEMORY[0x1D25D9CD0](*(void *)(a1 + 8), 8);
  return a1;
}

void sub_1CD55EE8C(_WORD *a1, char **a2, __n128 *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD1268, 0, 0);
  byte_1EBCD12E8 = 0;
  qword_1EBCD12F0 = (uint64_t)&unk_1F25EDE58;
  *(void *)&byte_1EBCD12F8 = 0;
  qword_1EBCD1268 = (uint64_t)&unk_1F26440A0;
  qword_1EBCD1300 = (uint64_t)&unk_1F2643CC0;
  qword_1EBCD1308 = (uint64_t)&unk_1F25EDE78;
  qword_1EBCD1320 = (uint64_t)&qword_1EBCD1308;
  sub_1CD55EF7C(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD1268);
}

__n128 sub_1CD55EF7C(_WORD *a1, char **a2, __n128 *a3)
{
  llvm::cl::Option::setArgStr((uint64_t)&qword_1EBCD1268, "mir-debug-loc", 0xDuLL);
  word_1EBCD1272 = (32 * (*a1 & 3)) | word_1EBCD1272 & 0xFF9F;
  uint64_t v6 = *a2;
  byte_1EBCD12E8 = **a2;
  byte_1EBCD12F9 = 1;
  byte_1EBCD12F8 = *v6;
  __n128 result = *a3;
  xmmword_1EBCD1288 = (__int128)*a3;
  return result;
}

void sub_1CD55F004(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD55F4E4(a1, (uint64_t)"name", (void *)a2, 1);
  LOWORD(__p[0]) = 0;
  sub_1CD55F764(a1, (unsigned __int8 *)(a2 + 16), (unsigned __int8 *)__p);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"exposesReturnsTwice", (unsigned char *)(a2 + 18), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"legalized", (unsigned char *)(a2 + 19), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"regBankSelected", (unsigned char *)(a2 + 20), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"selected", (unsigned char *)(a2 + 21), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"failedISel", (unsigned char *)(a2 + 22), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"tracksRegLiveness", (unsigned char *)(a2 + 23), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasWinCFI", (unsigned char *)(a2 + 24), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"callsEHReturn", (unsigned char *)(a2 + 25), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"callsUnwindInit", (unsigned char *)(a2 + 26), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasEHCatchret", (unsigned char *)(a2 + 27), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasEHScopes", (unsigned char *)(a2 + 28), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasEHFunclets", (unsigned char *)(a2 + 29), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"failsVerification", (unsigned char *)(a2 + 30), &v15, 0);
  LOBYTE(v15) = 0;
  sub_1CD55FA64(a1, (uint64_t)"tracksDebugUserValues", (unsigned char *)(a2 + 31), &v15, 0);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v5 = 0;
  sub_1CD55FB7C(a1, (uint64_t *)(a2 + 32), (uint64_t)__p);
  uint64_t v15 = __p;
  sub_1CC3CE344(&v15);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v5 = 0;
  sub_1CD560944(a1, (uint64_t *)(a2 + 56), (uint64_t)__p);
  uint64_t v15 = __p;
  sub_1CC3CE2C0(&v15);
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CC3CED7C(a1, (int64x2_t *)(a2 + 80), (uint64_t)__p);
  if (BYTE8(v5))
  {
    uint64_t v15 = __p;
    sub_1CC3CDF68(&v15);
  }
  uint64_t v8 = 0;
  long long v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  int v9 = -1;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  memset(v14, 0, sizeof(v14));
  sub_1CD5615DC(a1, a2 + 112, (long long *)__p);
  sub_1CD55EC4C((uint64_t)__p);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v5 = 0;
  sub_1CD5620DC(a1, (uint64_t *)(a2 + 280), (long long **)__p);
  uint64_t v15 = __p;
  sub_1CC3CE23C(&v15);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v5 = 0;
  sub_1CD5632B4(a1, (uint64_t *)(a2 + 304), (long long **)__p);
  uint64_t v15 = __p;
  sub_1CC3CE1B8(&v15);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v5 = 0;
  sub_1CD563FFC(a1, (uint64_t *)(a2 + 360), (uint64_t *)__p);
  uint64_t v15 = __p;
  sub_1CC3CE090(&v15);
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v5 = 0;
  sub_1CD564EC8(a1, (char **)(a2 + 384), (char **)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  __p[0] = 0;
  __p[1] = 0;
  *(void *)&long long v5 = 0;
  sub_1CD5654A0(a1, (int64x2_t *)(a2 + 328), (uint64_t *)__p);
  uint64_t v15 = __p;
  sub_1CC3CE12C(&v15);
  sub_1CD565D90((uint64_t)a1, (void *)(a2 + 352));
  if (!(*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    || *(void *)(a2 + 416) != *(void *)(a2 + 424))
  {
    __p[0] = (void *)5;
    __p[1] = 0;
    long long v5 = 0uLL;
    sub_1CD565EB0(a1, (_DWORD *)(a2 + 408), (uint64_t)__p);
    uint64_t v15 = &__p[1];
    sub_1CC3CDFF4(&v15);
  }
  if (!(*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    || *(void *)(a2 + 440) != *(void *)(a2 + 448))
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v5 = 0;
    sub_1CD566E7C(a1, (int64x2_t *)(a2 + 440), (std::string **)__p);
    uint64_t v15 = __p;
    sub_1CC3CDF68(&v15);
  }
  *(void *)&long long v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD567184(a1, a2 + 464, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
}

uint64_t sub_1CD55F4E4(llvm::yaml::IO *a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD55F5A4(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

void sub_1CD55F5A4(llvm::yaml::IO *a1, void *a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    LODWORD(v16) = 0;
    char v20 = 0;
    uint64_t v21 = 0;
    uint64_t v23 = &v24;
    int v22 = 0;
    uint64_t v15 = &unk_1F2646F30;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    int Context = llvm::yaml::IO::getContext(a1);
    llvm::yaml::ScalarTraits<llvm::StringRef,void>::output((uint64_t)a2, Context, (llvm::raw_ostream *)&v15);
    char v10 = *((unsigned char *)v23 + 23);
    if (v10 >= 0) {
      long long v11 = (char *)v23;
    }
    else {
      long long v11 = (char *)*v23;
    }
    if (v10 >= 0) {
      uint64_t v12 = v10 & 0x7F;
    }
    else {
      uint64_t v12 = (uint64_t)v23[1];
    }
    v14[0] = v11;
    v14[1] = v12;
    uint64_t mustQuote = llvm::yaml::ScalarTraits<FlowStringRef,void>::mustQuote(v11, v12);
    (*(void (**)(llvm::yaml::IO *, void *, uint64_t))(*(void *)a1 + 216))(a1, v14, mustQuote);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
    if (SHIBYTE(v26) < 0) {
      operator delete(v24);
    }
  }
  else
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    (*(void (**)(llvm::yaml::IO *, void **, uint64_t))(*(void *)a1 + 216))(a1, &v24, 1);
    uint64_t v4 = (uint64_t)v24;
    uint64_t v5 = v25;
    uint64_t v6 = llvm::yaml::IO::getContext(a1);
    uint64_t v7 = llvm::yaml::ScalarTraits<llvm::StringRef,void>::input(v4, v5, v6, a2);
    if (v8)
    {
      LOWORD(v19) = 261;
      uint64_t v15 = (void *)v7;
      uint64_t v16 = v8;
      (*(void (**)(llvm::yaml::IO *, void **))(*(void *)a1 + 248))(a1, &v15);
    }
  }
}

uint64_t sub_1CD55F764(llvm::yaml::IO *a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    int v6 = a3[1];
    if (a2[1]) {
      BOOL v7 = v6 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    if (v7) {
      uint64_t v9 = (a2[1] == 0) ^ (v6 != 0);
    }
    else {
      uint64_t v9 = *a2 == *a3;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v11 = 0;
  char v10 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "alignment", 0, v9, &v10, &v11);
  if (result)
  {
    sub_1CD55F89C(a1, (uint64_t)a2);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v11);
  }
  else if (v10)
  {
    *(_WORD *)a2 = *(_WORD *)a3;
  }
  return result;
}

void sub_1CD55F89C(llvm::yaml::IO *a1, uint64_t a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    LODWORD(v15) = 0;
    char v19 = 0;
    uint64_t v20 = 0;
    int v22 = &v23;
    int v21 = 0;
    __int16 v14 = (const char *)&unk_1F2646F30;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    llvm::yaml::IO::getContext(a1);
    if (*(unsigned char *)(a2 + 1)) {
      unint64_t v4 = 1 << *(unsigned char *)a2;
    }
    else {
      unint64_t v4 = 0;
    }
    llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v14, v4);
    uint64_t v5 = v22;
    char v6 = *((unsigned char *)v22 + 23);
    BOOL v7 = v6 < 0;
    if (v6 < 0) {
      uint64_t v5 = *v22;
    }
    uint64_t v8 = (void *)(v6 & 0x7F);
    if (v7) {
      uint64_t v8 = v22[1];
    }
    v13[0] = v5;
    v13[1] = v8;
    (*(void (**)(llvm::yaml::IO *, void *, void))(*(void *)a1 + 216))(a1, v13, 0);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v14);
    if (SHIBYTE(v25) < 0) {
      operator delete(v23);
    }
  }
  else
  {
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    (*(void (**)(llvm::yaml::IO *, void **, void))(*(void *)a1 + 216))(a1, &v23, 0);
    uint64_t v9 = (unsigned __int8 *)v23;
    uint64_t v10 = v24;
    llvm::yaml::IO::getContext(a1);
    uint64_t v11 = sub_1CC3CE570(v9, v10, (_WORD *)a2);
    if (v12)
    {
      LOWORD(v18) = 261;
      __int16 v14 = v11;
      uint64_t v15 = v12;
      (*(void (**)(llvm::yaml::IO *, const char **))(*(void *)a1 + 248))(a1, &v14);
    }
  }
}

uint64_t sub_1CD55FA64(llvm::yaml::IO *a1, uint64_t a2, unsigned char *a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v14 = 0;
  char v13 = 0;
  unsigned int v10 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (*a3 == *a4) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a5, v11, &v13, &v14);
  if (result)
  {
    sub_1CD412A70(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v14);
  }
  else if (v13)
  {
    *a3 = *a4;
  }
  return result;
}

uint64_t sub_1CD55FB7C(llvm::yaml::IO *a1, uint64_t *a2, uint64_t a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    && (uint64_t v6 = a2[1], v6 - *a2 == *(void *)(a3 + 8) - *(void *)a3))
  {
    uint64_t v7 = sub_1CC3CE668(*a2, v6, *(void *)a3);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v10 = 0;
  char v9 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "registers", 0, v7, &v9, &v10);
  if (result)
  {
    sub_1CD55FCC0(a1, a2);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v10);
  }
  else if (a2 != (uint64_t *)a3)
  {
    if (v9) {
      return sub_1CC3CE7E0((uint64_t)a2, *(long long **)a3, *(long long **)(a3 + 8), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3));
    }
  }
  return result;
}

uint64_t sub_1CD55FCC0(llvm::yaml::IO *a1, uint64_t *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    unsigned int v4 = -991146299 * ((unint64_t)(a2[1] - *a2) >> 3);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = v4;
    do
    {
      uint64_t v11 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v6, &v11))
      {
        uint64_t v8 = *a2;
        if (0x4EC4EC4EC4EC4EC5 * ((a2[1] - *a2) >> 3) <= v6)
        {
          sub_1CD560594((uint64_t)a2, v6 + 1);
          uint64_t v8 = *a2;
        }
        uint64_t v9 = v8 + v5;
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 144))(a1);
        sub_1CD55FEBC(a1, v9);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 152))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v11);
      }
      ++v6;
      v5 += 104;
    }
    while (v7 != v6);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

void sub_1CD55FEBC(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD55FF34(a1, a2);
  sub_1CD5601B8(a1, (uint64_t)"class", a2 + 24);
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"preferred-register", a2 + 64, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
}

uint64_t sub_1CD55FF34(llvm::yaml::IO *a1, uint64_t a2)
{
  uint64_t v6 = 0;
  char v5 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, "id", 1, 0, &v5, &v6);
  if (result)
  {
    sub_1CD55FFE4(a1, a2);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v6);
  }
  return result;
}

void sub_1CD55FFE4(llvm::yaml::IO *a1, uint64_t a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    LODWORD(v18) = 0;
    char v22 = 0;
    uint64_t v23 = 0;
    uint64_t v25 = &v26;
    int v24 = 0;
    uint64_t v17 = (const char *)&unk_1F2646F30;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t Context = llvm::yaml::IO::getContext(a1);
    llvm::yaml::ScalarTraits<unsigned int,void>::output((unsigned int *)a2, Context, (llvm::raw_ostream *)&v17);
    char v5 = v25;
    char v6 = *((unsigned char *)v25 + 23);
    BOOL v7 = v6 < 0;
    if (v6 < 0) {
      char v5 = *v25;
    }
    uint64_t v8 = (void *)(v6 & 0x7F);
    if (v7) {
      uint64_t v8 = v25[1];
    }
    v16[0] = v5;
    v16[1] = v8;
    (*(void (**)(llvm::yaml::IO *, void *, void))(*(void *)a1 + 216))(a1, v16, 0);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v17);
    if (SHIBYTE(v28) < 0) {
      operator delete(v26);
    }
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    (*(void (**)(llvm::yaml::IO *, void **, void))(*(void *)a1 + 216))(a1, &v26, 0);
    uint64_t v9 = (unsigned __int8 *)v26;
    uint64_t v10 = v27;
    uint64_t v11 = llvm::yaml::IO::getContext(a1);
    uint64_t v12 = *(void *)(v11 + 296);
    if (v12)
    {
      uint64_t v13 = *(void *)(v12 + 8);
      if (v13) {
        *(_OWORD *)(a2 + 8) = *(_OWORD *)(v13 + 16);
      }
    }
    uint64_t v14 = llvm::yaml::ScalarTraits<unsigned int,void>::input(v9, v10, v11, (_DWORD *)a2);
    if (v15)
    {
      LOWORD(v21) = 261;
      uint64_t v17 = v14;
      uint64_t v18 = v15;
      (*(void (**)(llvm::yaml::IO *, const char **))(*(void *)a1 + 248))(a1, &v17);
    }
  }
}

uint64_t sub_1CD5601B8(llvm::yaml::IO *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, 1, 0, &v7, &v8);
  if (result)
  {
    double v6 = sub_1CD560260(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, double))(*(void *)a1 + 128))(a1, v8, v6);
  }
  return result;
}

double sub_1CD560260(llvm::yaml::IO *a1, uint64_t a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    v27[0] = 0;
    v27[1] = 0;
    uint64_t v28 = 0;
    LODWORD(v19) = 0;
    char v23 = 0;
    uint64_t v24 = 0;
    uint64_t v26 = v27;
    int v25 = 0;
    uint64_t v18 = (std::string::value_type *)&unk_1F2646F30;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    llvm::yaml::IO::getContext(a1);
    char v4 = *(unsigned char *)(a2 + 23);
    BOOL v5 = v4 < 0;
    if (v4 >= 0) {
      double v6 = (const char *)a2;
    }
    else {
      double v6 = *(const char **)a2;
    }
    size_t v7 = v4 & 0x7F;
    if (v5) {
      size_t v8 = *(void *)(a2 + 8);
    }
    else {
      size_t v8 = v7;
    }
    llvm::raw_ostream::write((llvm::raw_ostream *)&v18, v6, v8);
    char v9 = *((unsigned char *)v26 + 23);
    if (v9 >= 0) {
      uint64_t v10 = (char *)v26;
    }
    else {
      uint64_t v10 = (char *)*v26;
    }
    if (v9 >= 0) {
      uint64_t v11 = v9 & 0x7F;
    }
    else {
      uint64_t v11 = (uint64_t)v26[1];
    }
    v17[0] = v10;
    v17[1] = v11;
    uint64_t mustQuote = llvm::yaml::ScalarTraits<FlowStringRef,void>::mustQuote(v10, v11);
    (*(void (**)(llvm::yaml::IO *, void *, uint64_t))(*(void *)a1 + 216))(a1, v17, mustQuote);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v18);
    if (SHIBYTE(v28) < 0) {
      operator delete(v27[0]);
    }
  }
  else
  {
    uint64_t v18 = 0;
    std::string::size_type v19 = 0;
    (*(void (**)(llvm::yaml::IO *, std::string::value_type **, uint64_t))(*(void *)a1 + 216))(a1, &v18, 1);
    uint64_t v14 = v18;
    std::string::size_type v15 = v19;
    uint64_t Context = llvm::yaml::IO::getContext(a1);
    *(void *)&double result = sub_1CD5603F8(v14, v15, Context, a2).n128_u64[0];
  }
  return result;
}

__n128 sub_1CD5603F8(std::string::value_type *__s, std::string::size_type __sz, uint64_t a3, uint64_t a4)
{
  if (__s) {
    std::string::__init(&v9, __s, __sz);
  }
  else {
    memset(&v9, 0, sizeof(v9));
  }
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  result.n128_u64[0] = v9.__r_.__value_.__r.__words[0];
  *(std::string *)a4 = v9;
  uint64_t v7 = *(void *)(a3 + 296);
  if (v7)
  {
    size_t v8 = *(__n128 **)(v7 + 8);
    if (v8)
    {
      __n128 result = v8[1];
      *(__n128 *)(a4 + 24) = result;
    }
  }
  return result;
}

std::string *sub_1CD56047C(llvm::yaml::IO *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    BOOL v8 = sub_1CBAD746C((unsigned __int8 *)a3, (unsigned __int8 *)a4);
  }
  else {
    BOOL v8 = 0;
  }
  uint64_t v12 = 0;
  char v11 = 0;
  __n128 result = (std::string *)(*(uint64_t (**)(llvm::yaml::IO *, uint64_t, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, 0, v8, &v11, &v12);
  if (result)
  {
    double v10 = sub_1CD560260(a1, a3);
    return (std::string *)(*(uint64_t (**)(llvm::yaml::IO *, uint64_t, double))(*(void *)a1 + 128))(a1, v12, v10);
  }
  else if (v11)
  {
    __n128 result = std::string::operator=((std::string *)a3, (const std::string *)a4);
    *(_OWORD *)(a3 + 24) = *(_OWORD *)(a4 + 24);
  }
  return result;
}

void sub_1CD560594(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = 0x4EC4EC4EC4EC4EC5 * ((v3 - *(void *)a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD560628((char **)a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *(void *)a1 + 104 * a2;
    while (v3 != v7)
      uint64_t v3 = sub_1CD55ECA0(v3 - 104);
    *(void *)(a1 + 8) = v7;
  }
}

void sub_1CD560628(char **a1, unint64_t a2)
{
  BOOL v5 = a1[1];
  unint64_t v4 = a1[2];
  if (0x4EC4EC4EC4EC4EC5 * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      bzero(a1[1], 104 * ((104 * a2 - 104) / 0x68) + 104);
      v5 += 104 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = *a1;
    uint64_t v7 = 0x4EC4EC4EC4EC4EC5 * ((v5 - *a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x276276276276276) {
      abort();
    }
    unint64_t v9 = 0x4EC4EC4EC4EC4EC5 * ((v4 - v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x13B13B13B13B13BLL) {
      unint64_t v10 = 0x276276276276276;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x276276276276276) {
        sub_1CB833614();
      }
      char v11 = (char *)operator new(104 * v10);
    }
    else
    {
      char v11 = 0;
    }
    uint64_t v12 = &v11[104 * v7];
    uint64_t v13 = &v11[104 * v10];
    uint64_t v14 = 104 * a2;
    bzero(v12, 104 * ((v14 - 104) / 0x68uLL) + 104);
    std::string::size_type v15 = &v12[v14];
    if (v5 == v6)
    {
      *a1 = v12;
      a1[1] = v15;
      a1[2] = v13;
    }
    else
    {
      do
      {
        long long v16 = *(_OWORD *)(v5 - 104);
        *((void *)v12 - 11) = *((void *)v5 - 11);
        *(_OWORD *)(v12 - 104) = v16;
        long long v17 = *((_OWORD *)v5 - 5);
        *((void *)v12 - 8) = *((void *)v5 - 8);
        *((_OWORD *)v12 - 5) = v17;
        *((void *)v5 - 9) = 0;
        *((void *)v5 - 8) = 0;
        *((void *)v5 - 10) = 0;
        *(_OWORD *)(v12 - 56) = *(_OWORD *)(v5 - 56);
        long long v18 = *(_OWORD *)(v5 - 40);
        *((void *)v12 - 3) = *((void *)v5 - 3);
        *(_OWORD *)(v12 - 40) = v18;
        *((void *)v5 - 4) = 0;
        *((void *)v5 - 3) = 0;
        *((void *)v5 - 5) = 0;
        *((_OWORD *)v12 - 1) = *((_OWORD *)v5 - 1);
        v12 -= 104;
        v5 -= 104;
      }
      while (v5 != v6);
      BOOL v5 = *a1;
      uint64_t v19 = (uint64_t)a1[1];
      *a1 = v12;
      a1[1] = v15;
      a1[2] = v13;
      while ((char *)v19 != v5)
        uint64_t v19 = sub_1CD55ECA0(v19 - 104);
    }
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_1CD560848(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    unint64_t v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        uint64_t v3 = sub_1CD55ECA0(v3 - 104);
      while ((void *)v3 != v1);
      unint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1CD5608A8(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  uint64_t v5 = a1 + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_1CB8BDF7C(v5, *((const void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *(void *)(v5 + 16) = *((void *)a2 + 5);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(_OWORD *)(a1 + 48) = a2[3];
  uint64_t v7 = (_OWORD *)(a1 + 64);
  if (*((char *)a2 + 87) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v7, *((const void **)a2 + 8), *((void *)a2 + 9));
  }
  else
  {
    long long v8 = a2[4];
    *(void *)(a1 + 80) = *((void *)a2 + 10);
    _OWORD *v7 = v8;
  }
  *(_OWORD *)(a1 + 88) = *(long long *)((char *)a2 + 88);
  return a1;
}

std::string *sub_1CD560944(llvm::yaml::IO *a1, uint64_t *a2, uint64_t a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    uint64_t v6 = sub_1CC3CEA0C(*a2, a2[1], *(unsigned __int8 **)a3, *(void *)(a3 + 8));
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v9 = 0;
  char v8 = 0;
  __n128 result = (std::string *)(*(uint64_t (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "liveins", 0, v6, &v8, &v9);
  if (result)
  {
    sub_1CD560A70(a1, a2);
    return (std::string *)(*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v9);
  }
  else if (a2 != (uint64_t *)a3)
  {
    if (v8) {
      return sub_1CC3CEB84((uint64_t)a2, *(std::string **)a3, *(std::string **)(a3 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4));
    }
  }
  return result;
}

uint64_t sub_1CD560A70(llvm::yaml::IO *a1, uint64_t *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    unsigned int v4 = -858993459 * ((unint64_t)(a2[1] - *a2) >> 4);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = v4;
    do
    {
      uint64_t v11 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v6, &v11))
      {
        uint64_t v8 = *a2;
        if (0xCCCCCCCCCCCCCCCDLL * ((a2[1] - *a2) >> 4) <= v6)
        {
          sub_1CD560CD4((uint64_t)a2, v6 + 1);
          uint64_t v8 = *a2;
        }
        uint64_t v9 = v8 + v5;
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 144))(a1);
        sub_1CD560C64(a1, v9);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 152))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v11);
      }
      ++v6;
      v5 += 80;
    }
    while (v7 != v6);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

void sub_1CD560C64(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD5601B8(a1, (uint64_t)"reg", a2);
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"virtual-reg", a2 + 40, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1CD560CD4(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *(void *)a1) >> 4);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD560D60((char **)a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *(void *)a1 + 80 * a2;
    while (v3 != v7)
      uint64_t v3 = sub_1CD55ECE4(v3 - 80);
    *(void *)(a1 + 8) = v7;
  }
}

void sub_1CD560D60(char **a1, unint64_t a2)
{
  BOOL v5 = a1[1];
  unint64_t v4 = a1[2];
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - v5) >> 4) >= a2)
  {
    if (a2)
    {
      bzero(a1[1], 80 * ((80 * a2 - 80) / 0x50) + 80);
      v5 += 80 * a2;
    }
    a1[1] = v5;
  }
  else
  {
    unint64_t v6 = *a1;
    unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 4);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x333333333333333) {
      abort();
    }
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - v6) >> 4);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x199999999999999) {
      unint64_t v10 = 0x333333333333333;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x333333333333333) {
        sub_1CB833614();
      }
      uint64_t v11 = (char *)operator new(80 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v12 = &v11[80 * v7];
    uint64_t v13 = &v11[80 * v10];
    uint64_t v14 = 5 * a2;
    bzero(v12, 80 * ((16 * v14 - 80) / 0x50uLL) + 80);
    std::string::size_type v15 = &v12[16 * v14];
    if (v5 == v6)
    {
      *a1 = v12;
      a1[1] = v15;
      a1[2] = v13;
    }
    else
    {
      do
      {
        long long v16 = *((_OWORD *)v5 - 5);
        *((void *)v12 - 8) = *((void *)v5 - 8);
        *((_OWORD *)v12 - 5) = v16;
        *((void *)v5 - 9) = 0;
        *((void *)v5 - 8) = 0;
        *((void *)v5 - 10) = 0;
        *(_OWORD *)(v12 - 56) = *(_OWORD *)(v5 - 56);
        long long v17 = *(_OWORD *)(v5 - 40);
        *((void *)v12 - 3) = *((void *)v5 - 3);
        *(_OWORD *)(v12 - 40) = v17;
        *((void *)v5 - 4) = 0;
        *((void *)v5 - 3) = 0;
        *((void *)v5 - 5) = 0;
        *((_OWORD *)v12 - 1) = *((_OWORD *)v5 - 1);
        v12 -= 80;
        v5 -= 80;
      }
      while (v5 != v6);
      BOOL v5 = *a1;
      uint64_t v18 = (uint64_t)a1[1];
      *a1 = v12;
      a1[1] = v15;
      a1[2] = v13;
      while ((char *)v18 != v5)
        uint64_t v18 = sub_1CD55ECE4(v18 - 80);
    }
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_1CD560F60(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    unint64_t v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        uint64_t v3 = sub_1CD55ECE4(v3 - 80);
      while ((void *)v3 != v1);
      unint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1CD560FC0(uint64_t a1, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1CB8BDF7C(a1, *(const void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(a1 + 16) = *((void *)a2 + 2);
    *(_OWORD *)a1 = v4;
  }
  *(_OWORD *)(a1 + 24) = *(long long *)((char *)a2 + 24);
  BOOL v5 = (_OWORD *)(a1 + 40);
  if (*((char *)a2 + 63) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v5, *((const void **)a2 + 5), *((void *)a2 + 6));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 40);
    *(void *)(a1 + 56) = *((void *)a2 + 7);
    _OWORD *v5 = v6;
  }
  *(_OWORD *)(a1 + 64) = a2[4];
  return a1;
}

uint64_t sub_1CD56104C(llvm::yaml::IO *a1, int64x2_t *a2)
{
  int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 64))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    int v4 = -858993459 * ((unint64_t)(a2->i64[1] - a2->i64[0]) >> 3);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    for (unint64_t i = 0; i != v4; ++i)
    {
      uint64_t v10 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 72))(a1, i, &v10))
      {
        uint64_t v7 = a2->i64[0];
        if (0xCCCCCCCCCCCCCCCDLL * ((a2->i64[1] - a2->i64[0]) >> 3) <= i)
        {
          sub_1CD56130C(a2, i + 1);
          uint64_t v7 = a2->i64[0];
        }
        double v8 = sub_1CD560260(a1, v7 + v5);
        (*(void (**)(llvm::yaml::IO *, uint64_t, double))(*(void *)a1 + 80))(a1, v10, v8);
      }
      v5 += 40;
    }
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 88))(a1);
}

void sub_1CD5611E4(void **a1)
{
  uint64_t v1 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    int v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        if (*((char *)v3 - 17) < 0) {
          operator delete(*(v3 - 5));
        }
        v3 -= 5;
      }
      while (v3 != v1);
      int v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1CD561254(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    if (*(unsigned char *)(a1 + 24))
    {
      if (a1 != a2) {
        sub_1CC3CEF98((void ***)a1, *(std::string **)a2, *(std::string **)(a2 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
      }
    }
    else
    {
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      sub_1CC3CF1E0((void *)a1, *(void *)a2, *(void *)(a2 + 8), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
      *(unsigned char *)(a1 + 24) = 1;
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    int v4 = (void **)a1;
    sub_1CC3CDF68(&v4);
    *(unsigned char *)(a1 + 24) = 0;
  }
  return a1;
}

void sub_1CD56130C(int64x2_t *a1, unint64_t a2)
{
  uint64_t v3 = a1->i64[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - a1->i64[0]) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD5613AC(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = a1->i64[0] + 40 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 17) < 0) {
        operator delete(*(void **)(v3 - 40));
      }
      v3 -= 40;
    }
    a1->i64[1] = v7;
  }
}

void sub_1CD5613AC(int64x2_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[1].i64[0];
  unint64_t v5 = a1->u64[1];
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v4 - v5) >> 3) < a2)
  {
    uint64_t v6 = a1->i64[0];
    unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - a1->i64[0]) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x666666666666666) {
      abort();
    }
    if (0x999999999999999ALL * ((v4 - v6) >> 3) > v8) {
      unint64_t v8 = 0x999999999999999ALL * ((v4 - v6) >> 3);
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((v4 - v6) >> 3) >= 0x333333333333333) {
      unint64_t v9 = 0x666666666666666;
    }
    else {
      unint64_t v9 = v8;
    }
    uint64_t v20 = a1 + 1;
    if (v9)
    {
      if (v9 > 0x666666666666666) {
        sub_1CB833614();
      }
      uint64_t v10 = (char *)operator new(40 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v11 = &v10[40 * v7];
    uint64_t v12 = &v10[40 * v9];
    uint64_t v13 = 5 * a2;
    bzero(v11, 40 * ((8 * v13 - 40) / 0x28uLL) + 40);
    uint64_t v14 = &v11[8 * v13];
    if (v5 == v6)
    {
      int64x2_t v15 = vdupq_n_s64(v5);
    }
    else
    {
      do
      {
        long long v16 = *(_OWORD *)(v5 - 40);
        *((void *)v11 - 3) = *(void *)(v5 - 24);
        *(_OWORD *)(v11 - 40) = v16;
        *(void *)(v5 - 32) = 0;
        *(void *)(v5 - 24) = 0;
        *(void *)(v5 - 40) = 0;
        *((_OWORD *)v11 - 1) = *(_OWORD *)(v5 - 16);
        v11 -= 40;
        v5 -= 40;
      }
      while (v5 != v6);
      int64x2_t v15 = *a1;
      uint64_t v4 = a1[1].i64[0];
    }
    a1->i64[0] = (uint64_t)v11;
    a1->i64[1] = (uint64_t)v14;
    int64x2_t v18 = v15;
    a1[1].i64[0] = (uint64_t)v12;
    uint64_t v19 = v4;
    uint64_t v17 = v15.i64[0];
    sub_1CD561578((uint64_t)&v17);
  }
  else
  {
    if (a2)
    {
      bzero((void *)a1->i64[1], 40 * ((40 * a2 - 40) / 0x28) + 40);
      v5 += 40 * a2;
    }
    a1->i64[1] = v5;
  }
}

uint64_t sub_1CD561578(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 5;
      *(void *)(a1 + 16) = v2 - 5;
      if (*((char *)v2 - 17) < 0)
      {
        operator delete(*v4);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

std::string *sub_1CD5615DC(llvm::yaml::IO *a1, uint64_t a2, long long *a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    BOOL v6 = sub_1CD561784((unsigned __int8 *)a2, (unsigned __int8 *)a3);
  }
  else {
    BOOL v6 = 0;
  }
  uint64_t v10 = 0;
  char v9 = 0;
  __n128 result = (std::string *)(*(uint64_t (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "frameInfo", 0, v6, &v9, &v10);
  if (result)
  {
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
    sub_1CD5618F0(a1, a2);
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
    return (std::string *)(*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    long long v8 = *a3;
    *(_OWORD *)(a2 + 10) = *(long long *)((char *)a3 + 10);
    *(_OWORD *)a2 = v8;
    std::string::operator=((std::string *)(a2 + 32), (const std::string *)(a3 + 2));
    *(_OWORD *)(a2 + 56) = *(long long *)((char *)a3 + 56);
    *(_OWORD *)(a2 + 72) = *(long long *)((char *)a3 + 72);
    std::string::operator=((std::string *)(a2 + 88), (const std::string *)((char *)a3 + 88));
    *(_OWORD *)(a2 + 112) = a3[7];
    __n128 result = std::string::operator=((std::string *)(a2 + 128), (const std::string *)(a3 + 8));
    *(_OWORD *)(a2 + 152) = *(long long *)((char *)a3 + 152);
  }
  return result;
}

BOOL sub_1CD561784(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2
    || a1[1] != a2[1]
    || a1[2] != a2[2]
    || a1[3] != a2[3]
    || *((void *)a1 + 1) != *((void *)a2 + 1)
    || *((_DWORD *)a1 + 4) != *((_DWORD *)a2 + 4)
    || *((_DWORD *)a1 + 5) != *((_DWORD *)a2 + 5)
    || a1[24] != a2[24]
    || a1[25] != a2[25]
    || !sub_1CBAD746C(a1 + 32, a2 + 32)
    || *((_DWORD *)a1 + 18) != *((_DWORD *)a2 + 18)
    || *((_DWORD *)a1 + 19) != *((_DWORD *)a2 + 19)
    || a1[80] != a2[80]
    || a1[81] != a2[81]
    || a1[82] != a2[82]
    || a1[83] != a2[83]
    || *((_DWORD *)a1 + 21) != *((_DWORD *)a2 + 21)
    || !sub_1CBAD746C(a1 + 88, a2 + 88))
  {
    return 0;
  }

  return sub_1CBAD746C(a1 + 128, a2 + 128);
}

void sub_1CD5618F0(llvm::yaml::IO *a1, uint64_t a2)
{
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"isFrameAddressTaken", (unsigned char *)a2, &v7, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"isReturnAddressTaken", (unsigned char *)(a2 + 1), &v7, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasStackMap", (unsigned char *)(a2 + 2), &v7, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasPatchPoint", (unsigned char *)(a2 + 3), &v7, 0);
  __p[0] = 0;
  sub_1CD561BE8(a1, (uint64_t)"stackSize", (unint64_t *)(a2 + 8), (unint64_t *)__p);
  LODWORD(__p[0]) = 0;
  sub_1CD561EB8(a1, (int *)(a2 + 16), (int *)__p);
  LODWORD(__p[0]) = 0;
  sub_1CD561FC4(a1, (uint64_t)"maxAlignment", (unsigned int *)(a2 + 20), (unsigned int *)__p, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"adjustsStack", (unsigned char *)(a2 + 24), &v7, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasCalls", (unsigned char *)(a2 + 25), &v7, 0);
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"stackProtector", a2 + 32, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__p[0]) = -1;
  sub_1CD561FC4(a1, (uint64_t)"maxCallFrameSize", (unsigned int *)(a2 + 72), (unsigned int *)__p, 0);
  LODWORD(__p[0]) = 0;
  sub_1CD561FC4(a1, (uint64_t)"cvBytesOfCalleeSavedRegisters", (unsigned int *)(a2 + 76), (unsigned int *)__p, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasOpaqueSPAdjustment", (unsigned char *)(a2 + 80), &v7, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasVAStart", (unsigned char *)(a2 + 81), &v7, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasMustTailInVarArgFunc", (unsigned char *)(a2 + 82), &v7, 0);
  char v7 = 0;
  sub_1CD55FA64(a1, (uint64_t)"hasTailCall", (unsigned char *)(a2 + 83), &v7, 0);
  LODWORD(__p[0]) = 0;
  sub_1CD561FC4(a1, (uint64_t)"localFrameSize", (unsigned int *)(a2 + 84), (unsigned int *)__p, 0);
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"savePoint", a2 + 88, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"restorePoint", a2 + 128, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
}

uint64_t sub_1CD561BE8(llvm::yaml::IO *a1, uint64_t a2, unint64_t *a3, unint64_t *a4)
{
  uint64_t v12 = 0;
  char v11 = 0;
  unsigned int v8 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (*a3 == *a4) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, 0, v9, &v11, &v12);
  if (result)
  {
    sub_1CD561CFC(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v12);
  }
  else if (v11)
  {
    *a3 = *a4;
  }
  return result;
}

void sub_1CD561CFC(llvm::yaml::IO *a1, unint64_t *a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    LODWORD(v16) = 0;
    char v20 = 0;
    uint64_t v21 = 0;
    char v23 = &v24;
    int v22 = 0;
    int64x2_t v15 = (const char *)&unk_1F2646F30;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t Context = llvm::yaml::IO::getContext(a1);
    llvm::yaml::ScalarTraits<unsigned long long,void>::output(a2, Context, (llvm::raw_ostream *)&v15);
    long long v5 = v23;
    char v6 = *((unsigned char *)v23 + 23);
    BOOL v7 = v6 < 0;
    if (v6 < 0) {
      long long v5 = *v23;
    }
    unsigned int v8 = (void *)(v6 & 0x7F);
    if (v7) {
      unsigned int v8 = v23[1];
    }
    v14[0] = v5;
    v14[1] = v8;
    (*(void (**)(llvm::yaml::IO *, void *, void))(*(void *)a1 + 216))(a1, v14, 0);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
    if (SHIBYTE(v26) < 0) {
      operator delete(v24);
    }
  }
  else
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    (*(void (**)(llvm::yaml::IO *, void **, void))(*(void *)a1 + 216))(a1, &v24, 0);
    uint64_t v9 = (unsigned __int8 *)v24;
    uint64_t v10 = v25;
    uint64_t v11 = llvm::yaml::IO::getContext(a1);
    uint64_t v12 = llvm::yaml::ScalarTraits<unsigned long long,void>::input(v9, v10, v11, a2);
    if (v13)
    {
      LOWORD(v19) = 261;
      int64x2_t v15 = v12;
      uint64_t v16 = v13;
      (*(void (**)(llvm::yaml::IO *, const char **))(*(void *)a1 + 248))(a1, &v15);
    }
  }
}

uint64_t sub_1CD561EB8(llvm::yaml::IO *a1, int *a2, int *a3)
{
  uint64_t v10 = 0;
  char v9 = 0;
  unsigned int v6 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (*a2 == *a3) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "offsetAdjustment", 0, v7, &v9, &v10);
  if (result)
  {
    sub_1CD412CEC(a1, a2);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

uint64_t sub_1CD561FC4(llvm::yaml::IO *a1, uint64_t a2, unsigned int *a3, unsigned int *a4, uint64_t a5)
{
  uint64_t v14 = 0;
  char v13 = 0;
  unsigned int v10 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (*a3 == *a4) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a5, v11, &v13, &v14);
  if (result)
  {
    sub_1CD3EDF78(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v14);
  }
  else if (v13)
  {
    *a3 = *a4;
  }
  return result;
}

uint64_t sub_1CD5620DC(llvm::yaml::IO *a1, uint64_t *a2, long long **a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    && (uint64_t v6 = *a2, v7 = a2[1], v8 = *a3, v7 - *a2 == (char *)a3[1] - (char *)*a3))
  {
    if (v6 == v7)
    {
      BOOL v9 = 1;
    }
    else
    {
      do
      {
        BOOL v9 = sub_1CD562450(v6, (uint64_t)v8);
        if (!v9) {
          break;
        }
        v6 += 232;
        unsigned int v8 = (long long *)((char *)v8 + 232);
      }
      while (v6 != v7);
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  uint64_t v12 = 0;
  char v11 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "fixedStack", 0, v9, &v11, &v12);
  if (result)
  {
    sub_1CD562254(a1, a2);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v12);
  }
  else if (a2 != (uint64_t *)a3)
  {
    if (v11) {
      return sub_1CC3CF544(a2, *a3, a3[1], 0x34F72C234F72C235 * (((char *)a3[1] - (char *)*a3) >> 3));
    }
  }
  return result;
}

uint64_t sub_1CD562254(llvm::yaml::IO *a1, uint64_t *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    unsigned int v4 = 1332920885 * ((unint64_t)(a2[1] - *a2) >> 3);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = v4;
    do
    {
      uint64_t v11 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v6, &v11))
      {
        uint64_t v8 = *a2;
        if (0x34F72C234F72C235 * ((a2[1] - *a2) >> 3) <= v6)
        {
          sub_1CD563018(a2, v6 + 1);
          uint64_t v8 = *a2;
        }
        uint64_t v9 = v8 + v5;
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 144))(a1);
        sub_1CD562588(a1, v9);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 152))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v11);
      }
      ++v6;
      v5 += 232;
    }
    while (v7 != v6);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

BOOL sub_1CD562450(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2
    || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24)
    || *(void *)(a1 + 32) != *(void *)(a2 + 32)
    || *(void *)(a1 + 40) != *(void *)(a2 + 40))
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 49) && *(unsigned char *)(a2 + 49))
  {
    if (*(unsigned __int8 *)(a1 + 48) != *(unsigned __int8 *)(a2 + 48)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a1 + 49) == 0) == (*(unsigned char *)(a2 + 49) != 0))
  {
    return 0;
  }
  if (*(_DWORD *)(a1 + 52) != *(_DWORD *)(a2 + 52)
    || *(unsigned __int8 *)(a1 + 56) != *(unsigned __int8 *)(a2 + 56)
    || *(unsigned __int8 *)(a1 + 57) != *(unsigned __int8 *)(a2 + 57)
    || !sub_1CBAD746C((unsigned __int8 *)(a1 + 64), (unsigned __int8 *)(a2 + 64))
    || *(unsigned __int8 *)(a1 + 104) != *(unsigned __int8 *)(a2 + 104)
    || !sub_1CBAD746C((unsigned __int8 *)(a1 + 112), (unsigned __int8 *)(a2 + 112))
    || !sub_1CBAD746C((unsigned __int8 *)(a1 + 152), (unsigned __int8 *)(a2 + 152)))
  {
    return 0;
  }

  return sub_1CBAD746C((unsigned __int8 *)(a1 + 192), (unsigned __int8 *)(a2 + 192));
}

void sub_1CD562588(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD55FF34(a1, a2);
  LODWORD(__p[0]) = 0;
  sub_1CD562774((uint64_t)a1, (_DWORD *)(a2 + 24), __p);
  __p[0] = 0;
  sub_1CD5629C0(a1, (unint64_t *)(a2 + 32), (unint64_t *)__p);
  __p[0] = 0;
  sub_1CD561BE8(a1, (uint64_t)"size", (unint64_t *)(a2 + 40), (unint64_t *)__p);
  LOWORD(__p[0]) = 0;
  sub_1CD55F764(a1, (unsigned __int8 *)(a2 + 48), (unsigned __int8 *)__p);
  LODWORD(__p[0]) = 0;
  sub_1CD562C7C((uint64_t)a1, (_DWORD *)(a2 + 52), __p);
  if (*(_DWORD *)(a2 + 24) != 1)
  {
    char v7 = 0;
    sub_1CD55FA64(a1, (uint64_t)"isImmutable", (unsigned char *)(a2 + 56), &v7, 0);
    char v7 = 0;
    sub_1CD55FA64(a1, (uint64_t)"isAliased", (unsigned char *)(a2 + 57), &v7, 0);
  }
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"callee-saved-register", a2 + 64, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
  char v7 = 1;
  sub_1CD55FA64(a1, (uint64_t)"callee-saved-restored", (unsigned char *)(a2 + 104), &v7, 0);
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"debug-info-variable", a2 + 112, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"debug-info-expression", a2 + 152, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v6 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v5 = 0u;
  sub_1CD56047C(a1, (uint64_t)"debug-info-location", a2 + 192, (uint64_t)__p);
  if (SBYTE7(v5) < 0) {
    operator delete(__p[0]);
  }
}

uint64_t sub_1CD562774(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v10 = 0;
  char v9 = 0;
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == *a3) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "type", 0, v7, &v9, &v10);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
    sub_1CD5628C4(a1, a2);
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

uint64_t sub_1CD5628C4(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "default", v5)) {
    *a2 = 0;
  }
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 1) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "spill-slot", v7);
  if (result) {
    *a2 = 1;
  }
  return result;
}

uint64_t sub_1CD5629C0(llvm::yaml::IO *a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v10 = 0;
  char v9 = 0;
  unsigned int v6 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1);
  if (*a2 == *a3) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "offset", 0, v7, &v9, &v10);
  if (result)
  {
    sub_1CD562AC0(a1, a2);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

void sub_1CD562AC0(llvm::yaml::IO *a1, unint64_t *a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    LODWORD(v16) = 0;
    char v20 = 0;
    uint64_t v21 = 0;
    char v23 = &v24;
    int v22 = 0;
    int64x2_t v15 = (const char *)&unk_1F2646F30;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t Context = llvm::yaml::IO::getContext(a1);
    llvm::yaml::ScalarTraits<long long,void>::output(a2, Context, (llvm::raw_ostream *)&v15);
    uint64_t v5 = v23;
    char v6 = *((unsigned char *)v23 + 23);
    BOOL v7 = v6 < 0;
    if (v6 < 0) {
      uint64_t v5 = *v23;
    }
    uint64_t v8 = (void *)(v6 & 0x7F);
    if (v7) {
      uint64_t v8 = v23[1];
    }
    v14[0] = v5;
    v14[1] = v8;
    (*(void (**)(llvm::yaml::IO *, void *, void))(*(void *)a1 + 216))(a1, v14, 0);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
    if (SHIBYTE(v26) < 0) {
      operator delete(v24);
    }
  }
  else
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    (*(void (**)(llvm::yaml::IO *, void **, void))(*(void *)a1 + 216))(a1, &v24, 0);
    uint64_t v9 = (uint64_t)v24;
    uint64_t v10 = v25;
    uint64_t v11 = llvm::yaml::IO::getContext(a1);
    uint64_t v12 = llvm::yaml::ScalarTraits<long long,void>::input(v9, v10, v11, a2);
    if (v13)
    {
      LOWORD(v19) = 261;
      int64x2_t v15 = v12;
      uint64_t v16 = v13;
      (*(void (**)(llvm::yaml::IO *, const char **))(*(void *)a1 + 248))(a1, &v15);
    }
  }
}

uint64_t sub_1CD562C7C(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v10 = 0;
  char v9 = 0;
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == *a3) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "stack-id", 0, v7, &v9, &v10);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
    sub_1CD562DCC(a1, a2);
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

uint64_t sub_1CD562DCC(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "default", v5)) {
    *a2 = 0;
  }
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 1) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "sgpr-spill", v7)) {
    *a2 = 1;
  }
  unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 2) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "scalable-vector", v9))
  {
    *a2 = 2;
  }
  unsigned int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 3) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "wasm-local", v11)) {
    *a2 = 3;
  }
  unsigned int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 255) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "noalloc", v13);
  if (result) {
    *a2 = 255;
  }
  return result;
}

void sub_1CD563018(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0x34F72C234F72C235 * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CC3CF298(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 232 * a2;
    while (v3 != v7)
      uint64_t v3 = sub_1CD55ED28(v3 - 232);
    a1[1] = v7;
  }
}

void sub_1CD5630AC(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    unint64_t v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        uint64_t v3 = sub_1CD55ED28(v3 - 232);
      while ((void *)v3 != v1);
      unint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1CD56310C(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  long long v6 = a2[2];
  *(_OWORD *)(a1 + 42) = *(long long *)((char *)a2 + 42);
  *(_OWORD *)(a1 + 16) = v5;
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)a1 = v4;
  uint64_t v7 = a1 + 64;
  if (*((char *)a2 + 87) < 0)
  {
    sub_1CB8BDF7C(v7, *((const void **)a2 + 8), *((void *)a2 + 9));
  }
  else
  {
    long long v8 = a2[4];
    *(void *)(v7 + 16) = *((void *)a2 + 10);
    *(_OWORD *)uint64_t v7 = v8;
  }
  *(_OWORD *)(a1 + 88) = *(long long *)((char *)a2 + 88);
  *(unsigned char *)(a1 + 104) = *((unsigned char *)a2 + 104);
  uint64_t v9 = (_OWORD *)(a1 + 112);
  if (*((char *)a2 + 135) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v9, *((const void **)a2 + 14), *((void *)a2 + 15));
  }
  else
  {
    long long v10 = a2[7];
    *(void *)(a1 + 128) = *((void *)a2 + 16);
    _OWORD *v9 = v10;
  }
  *(_OWORD *)(a1 + 136) = *(long long *)((char *)a2 + 136);
  uint64_t v11 = (_OWORD *)(a1 + 152);
  if (*((char *)a2 + 175) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v11, *((const void **)a2 + 19), *((void *)a2 + 20));
  }
  else
  {
    long long v12 = *(long long *)((char *)a2 + 152);
    *(void *)(a1 + 168) = *((void *)a2 + 21);
    *uint64_t v11 = v12;
  }
  *(_OWORD *)(a1 + 176) = a2[11];
  uint64_t v13 = (_OWORD *)(a1 + 192);
  if (*((char *)a2 + 215) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v13, *((const void **)a2 + 24), *((void *)a2 + 25));
  }
  else
  {
    long long v14 = a2[12];
    *(void *)(a1 + 208) = *((void *)a2 + 26);
    *uint64_t v13 = v14;
  }
  *(_OWORD *)(a1 + 216) = *(long long *)((char *)a2 + 216);
  return a1;
}

uint64_t sub_1CD563220(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  long long v6 = a2[2];
  *(_OWORD *)(a1 + 42) = *(long long *)((char *)a2 + 42);
  *(_OWORD *)(a1 + 16) = v5;
  *(_OWORD *)(a1 + 32) = v6;
  *(_OWORD *)a1 = v4;
  std::string::operator=((std::string *)(a1 + 64), (const std::string *)(a2 + 4));
  *(_OWORD *)(a1 + 88) = *(long long *)((char *)a2 + 88);
  *(unsigned char *)(a1 + 104) = *((unsigned char *)a2 + 104);
  std::string::operator=((std::string *)(a1 + 112), (const std::string *)(a2 + 7));
  *(_OWORD *)(a1 + 136) = *(long long *)((char *)a2 + 136);
  std::string::operator=((std::string *)(a1 + 152), (const std::string *)((char *)a2 + 152));
  *(_OWORD *)(a1 + 176) = a2[11];
  std::string::operator=((std::string *)(a1 + 192), (const std::string *)a2 + 8);
  *(_OWORD *)(a1 + 216) = *(long long *)((char *)a2 + 216);
  return a1;
}

uint64_t sub_1CD5632B4(llvm::yaml::IO *a1, uint64_t *a2, long long **a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    && (uint64_t v6 = *a2, v7 = a2[1], v8 = *a3, v7 - *a2 == (char *)a3[1] - (char *)*a3))
  {
    if (v6 == v7)
    {
      BOOL v9 = 1;
    }
    else
    {
      do
      {
        BOOL v9 = sub_1CD563628(v6, (uint64_t)v8);
        if (!v9) {
          break;
        }
        v6 += 280;
        long long v8 = (long long *)((char *)v8 + 280);
      }
      while (v6 != v7);
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  uint64_t v12 = 0;
  char v11 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "stack", 0, v9, &v11, &v12);
  if (result)
  {
    sub_1CD56342C(a1, a2);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v12);
  }
  else if (a2 != (uint64_t *)a3)
  {
    if (v11) {
      return sub_1CC3CFC14(a2, *a3, a3[1], 0xAF8AF8AF8AF8AF8BLL * (((char *)a3[1] - (char *)*a3) >> 3));
    }
  }
  return result;
}

uint64_t sub_1CD56342C(llvm::yaml::IO *a1, uint64_t *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    unsigned int v4 = -1963413621 * ((unint64_t)(a2[1] - *a2) >> 3);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = v4;
    do
    {
      uint64_t v11 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v6, &v11))
      {
        uint64_t v8 = *a2;
        if (0xAF8AF8AF8AF8AF8BLL * ((a2[1] - *a2) >> 3) <= v6)
        {
          sub_1CD563CF0(a2, v6 + 1);
          uint64_t v8 = *a2;
        }
        uint64_t v9 = v8 + v5;
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 144))(a1);
        sub_1CD56378C(a1, v9);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 152))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v11);
      }
      ++v6;
      v5 += 280;
    }
    while (v7 != v6);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

BOOL sub_1CD563628(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2
    || !sub_1CBAD746C((unsigned __int8 *)(a1 + 24), (unsigned __int8 *)(a2 + 24))
    || *(_DWORD *)(a1 + 64) != *(_DWORD *)(a2 + 64)
    || *(void *)(a1 + 72) != *(void *)(a2 + 72)
    || *(void *)(a1 + 80) != *(void *)(a2 + 80))
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 89) && *(unsigned char *)(a2 + 89))
  {
    if (*(unsigned __int8 *)(a1 + 88) != *(unsigned __int8 *)(a2 + 88)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a1 + 89) == 0) == (*(unsigned char *)(a2 + 89) != 0))
  {
    return 0;
  }
  if (*(_DWORD *)(a1 + 92) != *(_DWORD *)(a2 + 92)
    || !sub_1CBAD746C((unsigned __int8 *)(a1 + 96), (unsigned __int8 *)(a2 + 96))
    || *(unsigned __int8 *)(a1 + 136) != *(unsigned __int8 *)(a2 + 136))
  {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 152) || !*(unsigned char *)(a2 + 152))
  {
    if ((*(unsigned char *)(a1 + 152) == 0) != (*(unsigned char *)(a2 + 152) != 0)) {
      goto LABEL_19;
    }
    return 0;
  }
  if (*(void *)(a1 + 144) != *(void *)(a2 + 144)) {
    return 0;
  }
LABEL_19:
  if (!sub_1CBAD746C((unsigned __int8 *)(a1 + 160), (unsigned __int8 *)(a2 + 160))
    || !sub_1CBAD746C((unsigned __int8 *)(a1 + 200), (unsigned __int8 *)(a2 + 200)))
  {
    return 0;
  }

  return sub_1CBAD746C((unsigned __int8 *)(a1 + 240), (unsigned __int8 *)(a2 + 240));
}

void sub_1CD56378C(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD55FF34(a1, a2);
  uint64_t v7 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  sub_1CD56047C(a1, (uint64_t)"name", a2 + 24, (uint64_t)__p);
  if (SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
  LODWORD(__p[0]) = 0;
  sub_1CD563974((uint64_t)a1, (_DWORD *)(a2 + 64), __p);
  __p[0] = 0;
  sub_1CD5629C0(a1, (unint64_t *)(a2 + 72), (unint64_t *)__p);
  if (*(_DWORD *)(a2 + 64) != 2) {
    sub_1CD563C30(a1, (uint64_t)"size", (unint64_t *)(a2 + 80), 1);
  }
  LOWORD(__p[0]) = 0;
  sub_1CD55F764(a1, (unsigned __int8 *)(a2 + 88), (unsigned __int8 *)__p);
  LODWORD(__p[0]) = 0;
  sub_1CD562C7C((uint64_t)a1, (_DWORD *)(a2 + 92), __p);
  uint64_t v7 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  sub_1CD56047C(a1, (uint64_t)"callee-saved-register", a2 + 96, (uint64_t)__p);
  if (SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
  char v4 = 1;
  sub_1CD55FA64(a1, (uint64_t)"callee-saved-restored", (unsigned char *)(a2 + 136), &v4, 0);
  __p[0] = 0;
  __p[1] = 0;
  sub_1CC3CF740(a1, a2 + 144, __p);
  uint64_t v7 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  sub_1CD56047C(a1, (uint64_t)"debug-info-variable", a2 + 160, (uint64_t)__p);
  if (SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  sub_1CD56047C(a1, (uint64_t)"debug-info-expression", a2 + 200, (uint64_t)__p);
  if (SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v6 = 0u;
  sub_1CD56047C(a1, (uint64_t)"debug-info-location", a2 + 240, (uint64_t)__p);
  if (SBYTE7(v6) < 0) {
    operator delete(__p[0]);
  }
}

uint64_t sub_1CD563974(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v10 = 0;
  char v9 = 0;
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == *a3) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "type", 0, v7, &v9, &v10);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
    sub_1CD563AC4(a1, a2);
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128))(a1, v10);
  }
  else if (v9)
  {
    *a2 = *a3;
  }
  return result;
}

uint64_t sub_1CD563AC4(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "default", v5)) {
    *a2 = 0;
  }
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 1) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "spill-slot", v7)) {
    *a2 = 1;
  }
  unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 2) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "variable-sized", v9);
  if (result) {
    *a2 = 2;
  }
  return result;
}

uint64_t sub_1CD563C30(llvm::yaml::IO *a1, uint64_t a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v8 = 0;
  char v7 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, uint64_t, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, a2, a4, 0, &v7, &v8);
  if (result)
  {
    sub_1CD561CFC(a1, a3);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  return result;
}

void sub_1CD563CF0(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAF8AF8AF8AF8AF8BLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CC3CF934(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 280 * a2;
    while (v3 != v7)
      uint64_t v3 = sub_1CD55ED8C(v3 - 280);
    a1[1] = v7;
  }
}

void sub_1CD563D84(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    unint64_t v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        uint64_t v3 = sub_1CD55ED8C(v3 - 280);
      while ((void *)v3 != v1);
      unint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1CD563DE4(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  uint64_t v5 = a1 + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_1CB8BDF7C(v5, *((const void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    *(void *)(v5 + 16) = *((void *)a2 + 5);
    *(_OWORD *)uint64_t v5 = v6;
  }
  *(_OWORD *)(a1 + 48) = a2[3];
  long long v7 = a2[5];
  *(_OWORD *)(a1 + 64) = a2[4];
  *(_OWORD *)(a1 + 80) = v7;
  uint64_t v8 = (_OWORD *)(a1 + 96);
  if (*((char *)a2 + 119) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v8, *((const void **)a2 + 12), *((void *)a2 + 13));
  }
  else
  {
    long long v9 = a2[6];
    *(void *)(a1 + 112) = *((void *)a2 + 14);
    _OWORD *v8 = v9;
  }
  *(_OWORD *)(a1 + 120) = *(long long *)((char *)a2 + 120);
  long long v10 = *(long long *)((char *)a2 + 136);
  *(void *)(a1 + 152) = *((void *)a2 + 19);
  *(_OWORD *)(a1 + 136) = v10;
  uint64_t v11 = (_OWORD *)(a1 + 160);
  if (*((char *)a2 + 183) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v11, *((const void **)a2 + 20), *((void *)a2 + 21));
  }
  else
  {
    long long v12 = a2[10];
    *(void *)(a1 + 176) = *((void *)a2 + 22);
    *uint64_t v11 = v12;
  }
  *(_OWORD *)(a1 + 184) = *(long long *)((char *)a2 + 184);
  uint64_t v13 = (_OWORD *)(a1 + 200);
  if (*((char *)a2 + 223) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v13, *((const void **)a2 + 25), *((void *)a2 + 26));
  }
  else
  {
    long long v14 = *(long long *)((char *)a2 + 200);
    *(void *)(a1 + 216) = *((void *)a2 + 27);
    *uint64_t v13 = v14;
  }
  *(_OWORD *)(a1 + 224) = a2[14];
  int64x2_t v15 = (_OWORD *)(a1 + 240);
  if (*((char *)a2 + 263) < 0)
  {
    sub_1CB8BDF7C((uint64_t)v15, *((const void **)a2 + 30), *((void *)a2 + 31));
  }
  else
  {
    long long v16 = a2[15];
    *(void *)(a1 + 256) = *((void *)a2 + 32);
    *int64x2_t v15 = v16;
  }
  *(_OWORD *)(a1 + 264) = *(long long *)((char *)a2 + 264);
  return a1;
}

uint64_t sub_1CD563F3C(uint64_t a1, const std::string *a2)
{
  uint64_t v2 = a2;
  long long v4 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
  *(void *)(a1 + 16) = *((void *)&a2->__r_.__value_.__l + 2);
  *(_OWORD *)a1 = v4;
  std::string::operator=((std::string *)(a1 + 24), a2 + 1);
  *(_OWORD *)(a1 + 48) = *(_OWORD *)&v2[2].__r_.__value_.__l.__data_;
  long long v5 = *(_OWORD *)&v2[3].__r_.__value_.__r.__words[1];
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v2[2].__r_.__value_.__r.__words[2];
  *(_OWORD *)(a1 + 80) = v5;
  std::string::operator=((std::string *)(a1 + 96), v2 + 4);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)&v2[5].__r_.__value_.__l.__data_;
  long long v6 = *(_OWORD *)&v2[5].__r_.__value_.__r.__words[2];
  *(void *)(a1 + 152) = v2[6].__r_.__value_.__l.__size_;
  *(_OWORD *)(a1 + 136) = v6;
  std::string::operator=((std::string *)(a1 + 160), (const std::string *)((char *)v2 + 160));
  *(_OWORD *)(a1 + 184) = *(_OWORD *)&v2[7].__r_.__value_.__r.__words[2];
  std::string::operator=((std::string *)(a1 + 200), (const std::string *)((char *)v2 + 200));
  *(_OWORD *)(a1 + 224) = *(_OWORD *)&v2[9].__r_.__value_.__r.__words[1];
  v2 += 10;
  std::string::operator=((std::string *)(a1 + 240), v2);
  *(_OWORD *)(a1 + 264) = *(_OWORD *)&v2[1].__r_.__value_.__l.__data_;
  return a1;
}

void sub_1CD563FFC(llvm::yaml::IO *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v17 = 0;
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    && (v7 = (int *)*a2, long long v6 = (int *)a2[1], v8 = (int *)*a3, (int *)((char *)v6 - *a2) == (int *)(a3[1] - *a3)))
  {
    if (v7 == v6)
    {
      BOOL v14 = 1;
    }
    else
    {
      do
      {
        int v9 = *v7;
        int v10 = v7[1];
        v7 += 8;
        int v11 = *v8;
        int v12 = v8[1];
        v8 += 8;
        BOOL v14 = v9 == v11 && v10 == v12;
      }
      while (v14 && v7 != v6);
    }
  }
  else
  {
    BOOL v14 = 0;
  }
  char v16 = 0;
  if ((*(unsigned int (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "callSites", 0, v14, &v16, &v17))
  {
    sub_1CD564154(a1, a2);
    (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v17);
  }
  else if (a2 != a3)
  {
    if (v16) {
      sub_1CC3D0308((uint64_t)a2, *a3, (void *)a3[1], (a3[1] - *a3) >> 5);
    }
  }
}

uint64_t sub_1CD564154(llvm::yaml::IO *a1, uint64_t *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    uint64_t v5 = ((unint64_t)(a2[1] - *a2) >> 5);
  }
  else {
    uint64_t v5 = v4;
  }
  if (v5)
  {
    uint64_t v6 = 0;
    for (unint64_t i = 0; i != v5; ++i)
    {
      uint64_t v11 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, i, &v11))
      {
        uint64_t v8 = *a2;
        if (i >= (a2[1] - *a2) >> 5)
        {
          sub_1CD564B5C(a2, i + 1);
          uint64_t v8 = *a2;
        }
        uint64_t v9 = v8 + v6;
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 144))(a1);
        sub_1CD564324(a1, v9);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 152))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v11);
      }
      v6 += 32;
    }
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

void sub_1CD564324(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD3EDEB8(a1, (uint64_t)"bb", (unsigned int *)a2, 1);
  sub_1CD3EDEB8(a1, (uint64_t)"offset", (unsigned int *)(a2 + 4), 1);
  memset(v4, 0, sizeof(v4));
  sub_1CD5643B4(a1, (int64x2_t *)(a2 + 8), (uint64_t)v4);
  uint64_t v5 = (void **)v4;
  sub_1CC3CE3C8(&v5);
}

void sub_1CD5643B4(llvm::yaml::IO *a1, int64x2_t *a2, uint64_t a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    uint64_t v6 = sub_1CC3CFE10(a2->i64[0], a2->i64[1], *(unsigned __int8 ***)a3, *(void *)(a3 + 8));
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v8 = 0;
  char v7 = 0;
  if ((*(unsigned int (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "fwdArgRegs", 0, v6, &v7, &v8))
  {
    sub_1CC3CFF1C(a1, a2);
    (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  else if (a2 != (int64x2_t *)a3)
  {
    if (v7) {
      sub_1CC3D0138((void ***)a2, *(std::string **)a3, *(std::string **)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4));
    }
  }
}

uint64_t sub_1CD5644E0(llvm::yaml::IO *a1, unsigned __int16 *a2)
{
  uint64_t v6 = 0;
  char v5 = 0;
  uint64_t result = (*(uint64_t (**)(llvm::yaml::IO *, const char *, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, "arg", 1, 0, &v5, &v6);
  if (result)
  {
    sub_1CD5645A4(a1, a2);
    return (*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v6);
  }
  return result;
}

void sub_1CD5645A4(llvm::yaml::IO *a1, unsigned __int16 *a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    LODWORD(v16) = 0;
    char v20 = 0;
    uint64_t v21 = 0;
    char v23 = &v24;
    int v22 = 0;
    int64x2_t v15 = (const char *)&unk_1F2646F30;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t Context = llvm::yaml::IO::getContext(a1);
    llvm::yaml::ScalarTraits<unsigned short,void>::output(a2, Context, (llvm::raw_ostream *)&v15);
    char v5 = v23;
    char v6 = *((unsigned char *)v23 + 23);
    BOOL v7 = v6 < 0;
    if (v6 < 0) {
      char v5 = *v23;
    }
    uint64_t v8 = (void *)(v6 & 0x7F);
    if (v7) {
      uint64_t v8 = v23[1];
    }
    v14[0] = v5;
    v14[1] = v8;
    (*(void (**)(llvm::yaml::IO *, void *, void))(*(void *)a1 + 216))(a1, v14, 0);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
    if (SHIBYTE(v26) < 0) {
      operator delete(v24);
    }
  }
  else
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    (*(void (**)(llvm::yaml::IO *, void **, void))(*(void *)a1 + 216))(a1, &v24, 0);
    uint64_t v9 = (unsigned __int8 *)v24;
    uint64_t v10 = v25;
    uint64_t v11 = llvm::yaml::IO::getContext(a1);
    int v12 = llvm::yaml::ScalarTraits<unsigned short,void>::input(v9, v10, v11, a2);
    if (v13)
    {
      LOWORD(v19) = 261;
      int64x2_t v15 = v12;
      uint64_t v16 = v13;
      (*(void (**)(llvm::yaml::IO *, const char **))(*(void *)a1 + 248))(a1, &v15);
    }
  }
}

void sub_1CD564760(int64x2_t *a1, unint64_t a2)
{
  uint64_t v3 = a1->i64[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - a1->i64[0]) >> 4);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD564800(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = a1->i64[0] + 48 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 25) < 0) {
        operator delete(*(void **)(v3 - 48));
      }
      v3 -= 48;
    }
    a1->i64[1] = v7;
  }
}

void sub_1CD564800(int64x2_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[1].i64[0];
  unint64_t v5 = a1->u64[1];
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v4 - v5) >> 4) < a2)
  {
    uint64_t v6 = a1->i64[0];
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - a1->i64[0]) >> 4);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x555555555555555) {
      abort();
    }
    if (0x5555555555555556 * ((v4 - v6) >> 4) > v8) {
      unint64_t v8 = 0x5555555555555556 * ((v4 - v6) >> 4);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v9 = 0x555555555555555;
    }
    else {
      unint64_t v9 = v8;
    }
    char v23 = a1 + 1;
    if (v9)
    {
      if (v9 > 0x555555555555555) {
        sub_1CB833614();
      }
      uint64_t v10 = (char *)operator new(48 * v9);
    }
    else
    {
      uint64_t v10 = 0;
    }
    uint64_t v11 = &v10[48 * v7];
    int v12 = &v10[48 * v9];
    uint64_t v13 = 3 * a2;
    bzero(v11, 48 * ((16 * v13 - 48) / 0x30uLL) + 48);
    BOOL v14 = &v11[16 * v13];
    if (v5 == v6)
    {
      int64x2_t v15 = vdupq_n_s64(v5);
    }
    else
    {
      uint64_t v16 = 0;
      do
      {
        uint64_t v17 = &v11[v16];
        uint64_t v18 = v5 + v16;
        long long v19 = *(_OWORD *)(v5 + v16 - 48);
        *((void *)v17 - 4) = *(void *)(v5 + v16 - 32);
        *((_OWORD *)v17 - 3) = v19;
        *(void *)(v18 - 40) = 0;
        *(void *)(v18 - 32) = 0;
        *(void *)(v18 - 48) = 0;
        *(_OWORD *)(v17 - 24) = *(_OWORD *)(v5 + v16 - 24);
        *((_WORD *)v17 - 4) = *(_WORD *)(v5 + v16 - 8);
        v16 -= 48;
      }
      while (v5 + v16 != v6);
      int64x2_t v15 = *a1;
      uint64_t v4 = a1[1].i64[0];
      v11 += v16;
    }
    a1->i64[0] = (uint64_t)v11;
    a1->i64[1] = (uint64_t)v14;
    int64x2_t v21 = v15;
    a1[1].i64[0] = (uint64_t)v12;
    uint64_t v22 = v4;
    uint64_t v20 = v15.i64[0];
    sub_1CD5649E0((uint64_t)&v20);
  }
  else
  {
    if (a2)
    {
      bzero((void *)a1->i64[1], 48 * ((48 * a2 - 48) / 0x30) + 48);
      v5 += 48 * a2;
    }
    a1->i64[1] = v5;
  }
}

uint64_t sub_1CD5649E0(uint64_t a1)
{
  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 6;
      *(void *)(a1 + 16) = v2 - 6;
      if (*((char *)v2 - 25) < 0)
      {
        operator delete(*v4);
        uint64_t v4 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1CD564A44(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t result = (void *)(v4 + v7);
      unint64_t v8 = (long long *)(a2 + v7);
      if (*(char *)(a2 + v7 + 23) < 0)
      {
        uint64_t result = sub_1CB8BDF7C((uint64_t)result, *(const void **)v8, *((void *)v8 + 1));
      }
      else
      {
        long long v9 = *v8;
        result[2] = *((void *)v8 + 2);
        *(_OWORD *)uint64_t result = v9;
      }
      uint64_t v10 = v4 + v7;
      *(_OWORD *)(v10 + 24) = *(_OWORD *)(a2 + v7 + 24);
      *(_WORD *)(v10 + 40) = *(_WORD *)(a2 + v7 + 40);
      v7 += 48;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  v3[1] = v4;
  return result;
}

void sub_1CD564AEC(void **a1)
{
  uint64_t v1 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        if (*((char *)v3 - 25) < 0) {
          operator delete(*(v3 - 6));
        }
        v3 -= 6;
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1CD564B5C(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 5;
  if (a2 > v4)
  {
    unint64_t v7 = a2 - v4;
    sub_1CD564C04(a1, v7);
  }
  else if (a2 < v4)
  {
    uint64_t v5 = *a1 + 32 * a2;
    if (v3 != v5)
    {
      do
      {
        uint64_t v6 = v3 - 32;
        unint64_t v8 = (void **)(v3 - 24);
        sub_1CC3CE3C8(&v8);
        uint64_t v3 = v6;
      }
      while (v6 != v5);
    }
    a1[1] = v5;
  }
}

void sub_1CD564C04(uint64_t *a1, unint64_t a2)
{
  unint64_t v4 = a1 + 2;
  uint64_t v5 = a1[2];
  uint64_t v6 = (char *)a1[1];
  if (a2 > (v5 - (uint64_t)v6) >> 5)
  {
    uint64_t v8 = (uint64_t)&v6[-*a1];
    unint64_t v9 = a2 + (v8 >> 5);
    if (v9 >> 59) {
      abort();
    }
    uint64_t v10 = v5 - *a1;
    if (v10 >> 4 > v9) {
      unint64_t v9 = v10 >> 4;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v11 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v20 = v4;
    if (v11)
    {
      if (v11 >> 59) {
        sub_1CB833614();
      }
      int v12 = (char *)operator new(32 * v11);
    }
    else
    {
      int v12 = 0;
    }
    long long __p = v12;
    uint64_t v17 = &v12[32 * (v8 >> 5)];
    long long v19 = &v12[32 * v11];
    bzero(v17, 32 * a2);
    uint64_t v18 = &v17[32 * a2];
    sub_1CD564D34(a1, &__p);
    BOOL v14 = v17;
    uint64_t v13 = v18;
    if (v18 != v17)
    {
      do
      {
        int64x2_t v15 = v13 - 32;
        int64x2_t v21 = (void **)(v13 - 24);
        sub_1CC3CE3C8(&v21);
        uint64_t v13 = v15;
      }
      while (v15 != v14);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    if (a2)
    {
      unint64_t v7 = &v6[32 * a2];
      bzero(v6, 32 * a2);
      uint64_t v6 = v7;
    }
    a1[1] = (uint64_t)v6;
  }
}

uint64_t *sub_1CD564D34(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(void *)(v6 - 32) = *(void *)(v2 + v5 - 32);
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = 0;
      *(void *)(v6 - 8) = 0;
      *(_OWORD *)(v6 - 24) = *(_OWORD *)(v2 + v5 - 24);
      *(void *)(v6 - 8) = *(void *)(v2 + v5 - 8);
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v8 = *result;
  std::string *result = v4;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void *sub_1CD564DC4(void *result, void *a2, void *a3)
{
  uint64_t v3 = result;
  uint64_t v4 = (void *)result[1];
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = *v6;
      v4[1] = 0;
      void v4[2] = 0;
      void v4[3] = 0;
      uint64_t result = sub_1CC3D0450(v4 + 1, v6[1], v6[2], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6[2] - v6[1]) >> 4));
      v4 += 4;
      v6 += 4;
    }
    while (v6 != a3);
  }
  v3[1] = v4;
  return result;
}

void sub_1CD564E4C(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = v3 - 32;
        uint64_t v6 = (void **)(v3 - 24);
        sub_1CC3CE3C8(&v6);
        uint64_t v3 = v5;
      }
      while (v5 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void *sub_1CD564EC8(llvm::yaml::IO *a1, char **a2, char **a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    uint64_t v6 = sub_1CC3D055C(*a2, a2[1], *a3, (uint64_t)a3[1]);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v9 = 0;
  char v8 = 0;
  uint64_t result = (void *)(*(uint64_t (**)(llvm::yaml::IO *, const char *, void, uint64_t, char *, uint64_t *))(*(void *)a1 + 120))(a1, "debugValueSubstitutions", 0, v6, &v8, &v9);
  if (result)
  {
    sub_1CD564FF4(a1, a2);
    return (void *)(*(uint64_t (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v9);
  }
  else if (a2 != a3)
  {
    if (v8) {
      return sub_1CC3D05D0(a2, *a3, a3[1], 0xCCCCCCCCCCCCCCCDLL * ((a3[1] - *a3) >> 2));
    }
  }
  return result;
}

uint64_t sub_1CD564FF4(llvm::yaml::IO *a1, void *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    unsigned int v4 = -858993459 * ((a2[1] - *a2) >> 2);
  }
  if (v4)
  {
    unint64_t v5 = 0;
    uint64_t v6 = v4;
    do
    {
      uint64_t v9 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v5, &v9))
      {
        uint64_t v7 = (unsigned int *)sub_1CD5651B4((uint64_t)a2, v5);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 144))(a1);
        sub_1CD565230(a1, v7);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 152))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v9);
      }
      ++v5;
    }
    while (v6 != v5);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

char *sub_1CD5651B4(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(char **)a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2);
  if (v4 <= a2)
  {
    unint64_t v7 = a2 + 1 - v4;
    if (a2 + 1 > v4)
    {
      sub_1CD5652E4((char **)a1, v7);
      uint64_t v3 = *(char **)a1;
    }
    else if (a2 + 1 < v4)
    {
      *(void *)(a1 + 8) = &v3[20 * a2 + 20];
    }
  }
  return &v3[20 * a2];
}

uint64_t sub_1CD565230(llvm::yaml::IO *a1, unsigned int *a2)
{
  return sub_1CD3EDEB8(a1, (uint64_t)"subreg", a2 + 4, 1);
}

void sub_1CD5652E4(char **a1, unint64_t a2)
{
  unint64_t v5 = a1[1];
  unint64_t v4 = a1[2];
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - v5) >> 2) >= a2)
  {
    if (a2)
    {
      size_t v16 = 20 * ((20 * a2 - 20) / 0x14) + 20;
      bzero(a1[1], v16);
      v5 += v16;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = *a1;
    uint64_t v7 = v5 - *a1;
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * (v7 >> 2) + a2;
    if (v8 > 0xCCCCCCCCCCCCCCCLL) {
      abort();
    }
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((v4 - v6) >> 2);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x666666666666666) {
      unint64_t v10 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0xCCCCCCCCCCCCCCCLL) {
        sub_1CB833614();
      }
      unint64_t v11 = (char *)operator new(20 * v10);
    }
    else
    {
      unint64_t v11 = 0;
    }
    int v12 = &v11[4 * (v7 >> 2)];
    uint64_t v13 = &v11[20 * v10];
    size_t v14 = 20 * ((20 * a2 - 20) / 0x14) + 20;
    bzero(v12, v14);
    if (v5 != v6)
    {
      do
      {
        long long v15 = *(_OWORD *)(v5 - 20);
        *((_DWORD *)v12 - 1) = *((_DWORD *)v5 - 1);
        *(_OWORD *)(v12 - 20) = v15;
        v12 -= 20;
        v5 -= 20;
      }
      while (v5 != v6);
      unint64_t v5 = *a1;
    }
    *a1 = v12;
    a1[1] = &v11[v7 + v14];
    a1[2] = v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void sub_1CD5654A0(llvm::yaml::IO *a1, int64x2_t *a2, uint64_t *a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    && (uint64_t v6 = a2->i64[0], v7 = a2->i64[1], v8 = *a3, v7 - a2->i64[0] == a3[1] - *a3))
  {
    if (v6 == v7)
    {
      BOOL v9 = 1;
    }
    else
    {
      do
      {
        BOOL v9 = sub_1CD565814(v6, v8);
        if (!v9) {
          break;
        }
        v6 += 72;
        v8 += 72;
      }
      while (v6 != v7);
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  uint64_t v11 = 0;
  char v10 = 0;
  if ((*(unsigned int (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "constants", 0, v9, &v10, &v11))
  {
    sub_1CD565618(a1, a2);
    (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v11);
  }
  else if (a2 != (int64x2_t *)a3)
  {
    if (v10) {
      sub_1CC3D0744((std::string **)a2, *a3, a3[1], 0x8E38E38E38E38E39 * ((a3[1] - *a3) >> 3));
    }
  }
}

uint64_t sub_1CD565618(llvm::yaml::IO *a1, int64x2_t *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    unsigned int v4 = 954437177 * ((unint64_t)(a2->i64[1] - a2->i64[0]) >> 3);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = v4;
    do
    {
      uint64_t v11 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v6, &v11))
      {
        uint64_t v8 = a2->i64[0];
        if (0x8E38E38E38E38E39 * ((a2->i64[1] - a2->i64[0]) >> 3) <= v6)
        {
          sub_1CD565944(a2, v6 + 1);
          uint64_t v8 = a2->i64[0];
        }
        uint64_t v9 = v8 + v5;
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
        sub_1CD5658A8(a1, v9);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v11);
      }
      ++v6;
      v5 += 72;
    }
    while (v7 != v6);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

BOOL sub_1CD565814(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return 0;
  }
  BOOL result = sub_1CBAD746C((unsigned __int8 *)(a1 + 24), (unsigned __int8 *)(a2 + 24));
  if (!result) {
    return result;
  }
  if (!*(unsigned char *)(a1 + 65) || !*(unsigned char *)(a2 + 65))
  {
    if ((*(unsigned char *)(a1 + 65) == 0) == (*(unsigned char *)(a2 + 65) != 0)) {
      return 0;
    }
    return *(unsigned __int8 *)(a1 + 66) == *(unsigned __int8 *)(a2 + 66);
  }
  if (*(unsigned __int8 *)(a1 + 64) == *(unsigned __int8 *)(a2 + 64)) {
    return *(unsigned __int8 *)(a1 + 66) == *(unsigned __int8 *)(a2 + 66);
  }
  return 0;
}

uint64_t sub_1CD5658A8(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD55FF34(a1, a2);
  uint64_t v8 = 0;
  *(_OWORD *)long long __p = 0u;
  long long v7 = 0u;
  sub_1CD56047C(a1, (uint64_t)"value", a2 + 24, (uint64_t)__p);
  if (SBYTE7(v7) < 0) {
    operator delete(__p[0]);
  }
  LOWORD(__p[0]) = 0;
  sub_1CD55F764(a1, (unsigned __int8 *)(a2 + 64), (unsigned __int8 *)__p);
  char v5 = 0;
  return sub_1CD55FA64(a1, (uint64_t)"isTargetSpecific", (unsigned char *)(a2 + 66), &v5, 0);
}

void sub_1CD565944(int64x2_t *a1, unint64_t a2)
{
  uint64_t v3 = a1->i64[1];
  unint64_t v4 = 0x8E38E38E38E38E39 * ((v3 - a1->i64[0]) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD5659EC(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = a1->i64[0] + 72 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 25) < 0) {
        operator delete(*(void **)(v3 - 48));
      }
      v3 -= 72;
    }
    a1->i64[1] = v7;
  }
}

void sub_1CD5659EC(int64x2_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[1].i64[0];
  unint64_t v5 = a1->u64[1];
  if (0x8E38E38E38E38E39 * ((uint64_t)(v4 - v5) >> 3) < a2)
  {
    uint64_t v6 = a1->i64[0];
    unint64_t v7 = 0x8E38E38E38E38E39 * ((uint64_t)(v5 - a1->i64[0]) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x38E38E38E38E38ELL) {
      abort();
    }
    if (0x1C71C71C71C71C72 * ((v4 - v6) >> 3) > v8) {
      unint64_t v8 = 0x1C71C71C71C71C72 * ((v4 - v6) >> 3);
    }
    if (0x8E38E38E38E38E39 * ((v4 - v6) >> 3) >= 0x1C71C71C71C71C7) {
      unint64_t v9 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v9 = v8;
    }
    uint64_t v22 = a1 + 1;
    if (v9)
    {
      if (v9 > 0x38E38E38E38E38ELL) {
        sub_1CB833614();
      }
      char v10 = (char *)operator new(72 * v9);
    }
    else
    {
      char v10 = 0;
    }
    uint64_t v11 = &v10[72 * v7];
    int v12 = &v10[72 * v9];
    uint64_t v13 = 9 * a2;
    bzero(v11, 72 * ((8 * v13 - 72) / 0x48uLL) + 72);
    size_t v14 = &v11[8 * v13];
    if (v5 == v6)
    {
      int64x2_t v15 = vdupq_n_s64(v5);
    }
    else
    {
      do
      {
        long long v16 = *(_OWORD *)(v5 - 72);
        *((void *)v11 - 7) = *(void *)(v5 - 56);
        *(_OWORD *)(v11 - 72) = v16;
        long long v17 = *(_OWORD *)(v5 - 48);
        *((void *)v11 - 4) = *(void *)(v5 - 32);
        *((_OWORD *)v11 - 3) = v17;
        *(void *)(v5 - 40) = 0;
        *(void *)(v5 - 32) = 0;
        *(void *)(v5 - 48) = 0;
        *(_OWORD *)(v11 - 24) = *(_OWORD *)(v5 - 24);
        __int16 v18 = *(_WORD *)(v5 - 8);
        *(v11 - 6) = *(unsigned char *)(v5 - 6);
        *((_WORD *)v11 - 4) = v18;
        v11 -= 72;
        v5 -= 72;
      }
      while (v5 != v6);
      int64x2_t v15 = *a1;
      uint64_t v4 = a1[1].i64[0];
    }
    a1->i64[0] = (uint64_t)v11;
    a1->i64[1] = (uint64_t)v14;
    int64x2_t v20 = v15;
    a1[1].i64[0] = (uint64_t)v12;
    uint64_t v21 = v4;
    uint64_t v19 = v15.i64[0];
    sub_1CD565C10((uint64_t)&v19);
  }
  else
  {
    if (a2)
    {
      bzero((void *)a1->i64[1], 72 * ((72 * a2 - 72) / 0x48) + 72);
      v5 += 72 * a2;
    }
    a1->i64[1] = v5;
  }
}

uint64_t sub_1CD565C10(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 72;
      *(void *)(a1 + 16) = v2 - 72;
      if (*(char *)(v2 - 25) < 0)
      {
        operator delete(*(void **)(v2 - 48));
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1CD565C74(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v6 = (long long *)(a2 + 24);
    do
    {
      long long v7 = *(long long *)((char *)v6 - 24);
      *(void *)(v4 + 16) = *((void *)v6 - 1);
      *(_OWORD *)uint64_t v4 = v7;
      BOOL result = (void *)(v4 + 24);
      if (*((char *)v6 + 23) < 0)
      {
        BOOL result = sub_1CB8BDF7C((uint64_t)result, *(const void **)v6, *((void *)v6 + 1));
      }
      else
      {
        long long v8 = *v6;
        *(void *)(v4 + 40) = *((void *)v6 + 2);
        *(_OWORD *)BOOL result = v8;
      }
      uint64_t v9 = (uint64_t)v6 - 24;
      *(_OWORD *)(v4 + 48) = *(long long *)((char *)v6 + 24);
      __int16 v10 = *((_WORD *)v6 + 20);
      *(unsigned char *)(v4 + 66) = *((unsigned char *)v6 + 42);
      *(_WORD *)(v4 + 64) = v10;
      v4 += 72;
      uint64_t v6 = (long long *)((char *)v6 + 72);
    }
    while (v9 + 72 != a3);
  }
  v3[1] = v4;
  return result;
}

void sub_1CD565D20(void **a1)
{
  uint64_t v1 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        if (*((char *)v3 - 25) < 0) {
          operator delete(*(v3 - 6));
        }
        v3 -= 9;
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1CD565D90(uint64_t a1, void *a2)
{
  uint64_t v6 = 0;
  char v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, void, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, "machineFunctionInfo", 0, 0, &v5, &v6);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
    if (*a2) {
      (*(void (**)(void, uint64_t))(*(void *)*a2 + 16))(*a2, a1);
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 112))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128))(a1, v6);
  }
  return result;
}

void sub_1CD565EB0(llvm::yaml::IO *a1, _DWORD *a2, uint64_t a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    BOOL v6 = sub_1CD566034((uint64_t)a2, a3);
  }
  else {
    BOOL v6 = 0;
  }
  uint64_t v8 = 0;
  char v7 = 0;
  if ((*(unsigned int (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "jumpTable", 0, v6, &v7, &v8))
  {
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
    sub_1CD56613C(a1, (uint64_t)a2);
    (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
    (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v8);
  }
  else if (v7)
  {
    *a2 = *(_DWORD *)a3;
    if (a2 != (_DWORD *)a3) {
      sub_1CC3D0964((uint64_t)(a2 + 2), *(long long **)(a3 + 8), *(long long **)(a3 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 16) - *(void *)(a3 + 8)) >> 4));
    }
  }
}

BOOL sub_1CD566034(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a2 + 8);
  if (v3 - v2 != *(void *)(a2 + 16) - v4) {
    return 0;
  }
  if (v2 == v3) {
    return 1;
  }
  do
  {
    BOOL result = sub_1CD5660B8(v2, v4);
    if (!result) {
      break;
    }
    v2 += 48;
    v4 += 48;
  }
  while (v2 != v3);
  return result;
}

BOOL sub_1CD5660B8(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2) {
    return 0;
  }
  uint64_t v2 = *(unsigned __int8 **)(a1 + 24);
  uint64_t v3 = *(unsigned __int8 **)(a1 + 32);
  uint64_t v4 = *(unsigned __int8 **)(a2 + 24);
  if (v3 - v2 != *(void *)(a2 + 32) - (void)v4) {
    return 0;
  }
  if (v2 == v3) {
    return 1;
  }
  do
  {
    BOOL result = sub_1CBAD746C(v2, v4);
    if (!result) {
      break;
    }
    v2 += 40;
    v4 += 40;
  }
  while (v2 != v3);
  return result;
}

void sub_1CD56613C(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD566194((uint64_t)a1, (_DWORD *)a2);
  memset(v4, 0, sizeof(v4));
  sub_1CD566550(a1, (uint64_t *)(a2 + 8), v4);
  char v5 = v4;
  sub_1CC3CDFF4((void ***)&v5);
}

uint64_t sub_1CD566194(uint64_t a1, _DWORD *a2)
{
  uint64_t v6 = 0;
  char v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t, void, char *, uint64_t *))(*(void *)a1 + 120))(a1, "kind", 1, 0, &v5, &v6);
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 160))(a1);
    sub_1CD566294(a1, a2);
    (*(void (**)(uint64_t))(*(void *)a1 + 184))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 128))(a1, v6);
  }
  return result;
}

uint64_t sub_1CD566294(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v4;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "block-address", v5)) {
    *a2 = 0;
  }
  unsigned int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 1) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "gp-rel64-block-address", v7))
  {
    *a2 = 1;
  }
  unsigned int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 2) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "gp-rel32-block-address", v9))
  {
    *a2 = 2;
  }
  unsigned int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 3) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "label-difference32", v11))
  {
    *a2 = 3;
  }
  unsigned int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 4) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "inline", v13)) {
    *a2 = 4;
  }
  unsigned int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (*a2 == 5) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 168))(a1, "custom32", v15);
  if (result) {
    *a2 = 5;
  }
  return result;
}

void sub_1CD566550(llvm::yaml::IO *a1, uint64_t *a2, long long **a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    && (uint64_t v6 = *a2, v7 = a2[1], v8 = *a3, v7 - *a2 == (char *)a3[1] - (char *)*a3))
  {
    if (v6 == v7)
    {
      BOOL v9 = 1;
    }
    else
    {
      do
      {
        BOOL v9 = sub_1CD5660B8(v6, (uint64_t)v8);
        if (!v9) {
          break;
        }
        v6 += 48;
        v8 += 3;
      }
      while (v6 != v7);
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  uint64_t v11 = 0;
  char v10 = 0;
  if ((*(unsigned int (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "entries", 0, v9, &v10, &v11))
  {
    sub_1CD5666C0(a1, a2);
    (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v11);
  }
  else if (a2 != (uint64_t *)a3)
  {
    if (v10) {
      sub_1CC3D0964((uint64_t)a2, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (a3[1] - *a3));
    }
  }
}

uint64_t sub_1CD5666C0(llvm::yaml::IO *a1, uint64_t *a2)
{
  unsigned int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    unsigned int v4 = -1431655765 * ((unint64_t)(a2[1] - *a2) >> 4);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    uint64_t v7 = v4;
    do
    {
      uint64_t v11 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, v6, &v11))
      {
        uint64_t v8 = *a2;
        if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 4) <= v6)
        {
          sub_1CD566A7C(a2, v6 + 1);
          uint64_t v8 = *a2;
        }
        uint64_t v9 = v8 + v5;
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 104))(a1);
        sub_1CD5668B4(a1, v9);
        (*(void (**)(llvm::yaml::IO *))(*(void *)a1 + 112))(a1);
        (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 40))(a1, v11);
      }
      ++v6;
      v5 += 48;
    }
    while (v7 != v6);
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

void sub_1CD5668B4(llvm::yaml::IO *a1, uint64_t a2)
{
  sub_1CD55FF34(a1, a2);
  memset(v4, 0, sizeof(v4));
  sub_1CD56690C(a1, (int64x2_t *)(a2 + 24), v4);
  uint64_t v5 = v4;
  sub_1CC3CDF68((void ***)&v5);
}

void sub_1CD56690C(llvm::yaml::IO *a1, int64x2_t *a2, std::string **a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    && (unint64_t v6 = (unsigned __int8 *)a2->i64[0],
        uint64_t v7 = (unsigned __int8 *)a2->i64[1],
        uint64_t v8 = *a3,
        &v7[-a2->i64[0]] == (unsigned __int8 *)((char *)a3[1] - (char *)*a3)))
  {
    if (v6 == v7)
    {
      BOOL v9 = 1;
    }
    else
    {
      do
      {
        BOOL v9 = sub_1CBAD746C(v6, (unsigned __int8 *)v8);
        if (!v9) {
          break;
        }
        v6 += 40;
        uint64_t v8 = (std::string *)((char *)v8 + 40);
      }
      while (v6 != v7);
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  uint64_t v11 = 0;
  char v10 = 0;
  if ((*(unsigned int (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "blocks", 0, v9, &v10, &v11))
  {
    sub_1CD56104C(a1, a2);
    (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v11);
  }
  else if (a2 != (int64x2_t *)a3)
  {
    if (v10) {
      sub_1CC3CEF98((void ***)a2, *a3, a3[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a3[1] - (char *)*a3) >> 3));
    }
  }
}

void sub_1CD566A7C(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 4);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1CD566B30(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 48 * a2;
    if (v3 != v7)
    {
      do
      {
        uint64_t v8 = v3 - 48;
        BOOL v9 = (void **)(v3 - 24);
        sub_1CC3CDF68(&v9);
        uint64_t v3 = v8;
      }
      while (v8 != v7);
    }
    a1[1] = v7;
  }
}

void sub_1CD566B30(uint64_t *a1, unint64_t a2)
{
  unint64_t v4 = a1 + 2;
  uint64_t v5 = a1[2];
  unint64_t v6 = (char *)a1[1];
  if (0xAAAAAAAAAAAAAAABLL * ((v5 - (uint64_t)v6) >> 4) < a2)
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v6[-*a1] >> 4);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x555555555555555) {
      abort();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 4);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v11 = 0x555555555555555;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v21 = v4;
    if (v11)
    {
      if (v11 > 0x555555555555555) {
        sub_1CB833614();
      }
      unsigned int v12 = (char *)operator new(48 * v11);
    }
    else
    {
      unsigned int v12 = 0;
    }
    long long __p = v12;
    __int16 v18 = &v12[48 * v8];
    int64x2_t v20 = &v12[48 * v11];
    uint64_t v13 = 3 * a2;
    bzero(v18, 48 * ((16 * v13 - 48) / 0x30uLL) + 48);
    uint64_t v19 = &v18[16 * v13];
    sub_1CD566CD8(a1, &__p);
    uint64_t v15 = v18;
    unsigned int v14 = v19;
    if (v19 != v18)
    {
      do
      {
        long long v16 = v14 - 48;
        uint64_t v22 = (void **)(v14 - 24);
        sub_1CC3CDF68(&v22);
        unsigned int v14 = v16;
      }
      while (v16 != v15);
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else
  {
    if (a2)
    {
      uint64_t v7 = &v6[48 * a2];
      bzero(v6, 48 * ((48 * a2 - 48) / 0x30) + 48);
      unint64_t v6 = v7;
    }
    a1[1] = (uint64_t)v6;
  }
}

uint64_t *sub_1CD566CD8(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }
  else
  {
    do
    {
      uint64_t v5 = v4 - 48;
      uint64_t v6 = *(void *)(v3 - 32);
      *(_OWORD *)(v4 - 48) = *(_OWORD *)(v3 - 48);
      *(void *)(v4 - 32) = v6;
      *(void *)(v4 - 24) = 0;
      *(void *)(v4 - 16) = 0;
      *(void *)(v4 - 8) = 0;
      *(_OWORD *)(v4 - 24) = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - 8) = *(void *)(v3 - 8);
      *(void *)(v3 - 24) = 0;
      *(void *)(v3 - 16) = 0;
      *(void *)(v3 - 8) = 0;
      v3 -= 48;
      v4 -= 48;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  uint64_t v7 = *result;
  void *result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *sub_1CD566D70(void *result, long long *a2, long long *a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[1];
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      long long v7 = *v6;
      *(void *)(v4 + 16) = *((void *)v6 + 2);
      *(_OWORD *)uint64_t v4 = v7;
      *(void *)(v4 + 24) = 0;
      *(void *)(v4 + 32) = 0;
      *(void *)(v4 + 40) = 0;
      uint64_t result = sub_1CC3CF1E0((void *)(v4 + 24), *((void *)v6 + 3), *((void *)v6 + 4), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)v6 + 4) - *((void *)v6 + 3)) >> 3));
      v4 += 48;
      v6 += 3;
    }
    while (v6 != a3);
  }
  v3[1] = v4;
  return result;
}

void sub_1CD566E00(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        uint64_t v5 = v3 - 48;
        uint64_t v6 = (void **)(v3 - 24);
        sub_1CC3CDF68(&v6);
        uint64_t v3 = v5;
      }
      while (v5 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1CD566E7C(llvm::yaml::IO *a1, int64x2_t *a2, std::string **a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)
    && (uint64_t v6 = (unsigned __int8 *)a2->i64[0],
        long long v7 = (unsigned __int8 *)a2->i64[1],
        uint64_t v8 = *a3,
        &v7[-a2->i64[0]] == (unsigned __int8 *)((char *)a3[1] - (char *)*a3)))
  {
    if (v6 == v7)
    {
      BOOL v9 = 1;
    }
    else
    {
      do
      {
        BOOL v9 = sub_1CBAD746C(v6, (unsigned __int8 *)v8);
        if (!v9) {
          break;
        }
        v6 += 40;
        uint64_t v8 = (std::string *)((char *)v8 + 40);
      }
      while (v6 != v7);
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  uint64_t v11 = 0;
  char v10 = 0;
  if ((*(unsigned int (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "machineMetadataNodes", 0, v9, &v10, &v11))
  {
    sub_1CD566FEC(a1, a2);
    (*(void (**)(llvm::yaml::IO *, uint64_t))(*(void *)a1 + 128))(a1, v11);
  }
  else if (a2 != (int64x2_t *)a3)
  {
    if (v10) {
      sub_1CC3CEF98((void ***)a2, *a3, a3[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a3[1] - (char *)*a3) >> 3));
    }
  }
}

uint64_t sub_1CD566FEC(llvm::yaml::IO *a1, int64x2_t *a2)
{
  int v4 = (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 24))(a1);
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    int v4 = -858993459 * ((unint64_t)(a2->i64[1] - a2->i64[0]) >> 3);
  }
  if (v4)
  {
    uint64_t v5 = 0;
    for (unint64_t i = 0; i != v4; ++i)
    {
      uint64_t v10 = 0;
      if ((*(unsigned int (**)(llvm::yaml::IO *, unint64_t, uint64_t *))(*(void *)a1 + 32))(a1, i, &v10))
      {
        uint64_t v7 = a2->i64[0];
        if (0xCCCCCCCCCCCCCCCDLL * ((a2->i64[1] - a2->i64[0]) >> 3) <= i)
        {
          sub_1CD56130C(a2, i + 1);
          uint64_t v7 = a2->i64[0];
        }
        double v8 = sub_1CD560260(a1, v7 + v5);
        (*(void (**)(llvm::yaml::IO *, uint64_t, double))(*(void *)a1 + 40))(a1, v10, v8);
      }
      v5 += 40;
    }
  }
  return (*(uint64_t (**)(llvm::yaml::IO *))(*(void *)a1 + 48))(a1);
}

std::string *sub_1CD567184(llvm::yaml::IO *a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1)) {
    BOOL v6 = sub_1CBAD746C((unsigned __int8 *)a2, (unsigned __int8 *)a3);
  }
  else {
    BOOL v6 = 0;
  }
  uint64_t v10 = 0;
  char v9 = 0;
  uint64_t result = (std::string *)(*(uint64_t (**)(llvm::yaml::IO *, const char *, void, BOOL, char *, uint64_t *))(*(void *)a1 + 120))(a1, "body", 0, v6, &v9, &v10);
  if (result)
  {
    double v8 = sub_1CD56729C(a1, a2);
    return (std::string *)(*(uint64_t (**)(llvm::yaml::IO *, uint64_t, double))(*(void *)a1 + 128))(a1, v10, v8);
  }
  else if (v9)
  {
    uint64_t result = std::string::operator=((std::string *)a2, (const std::string *)a3);
    *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
  }
  return result;
}

double sub_1CD56729C(llvm::yaml::IO *a1, uint64_t a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    v27[0] = 0;
    v27[1] = 0;
    uint64_t v28 = 0;
    LODWORD(v19) = 0;
    char v23 = 0;
    uint64_t v24 = 0;
    uint64_t v26 = v27;
    int v25 = 0;
    __int16 v18 = (std::string::value_type *)&unk_1F2646F30;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    llvm::yaml::IO::getContext(a1);
    char v4 = *(unsigned char *)(a2 + 23);
    BOOL v5 = v4 < 0;
    if (v4 >= 0) {
      BOOL v6 = (const char *)a2;
    }
    else {
      BOOL v6 = *(const char **)a2;
    }
    size_t v7 = v4 & 0x7F;
    if (v5) {
      size_t v8 = *(void *)(a2 + 8);
    }
    else {
      size_t v8 = v7;
    }
    llvm::raw_ostream::write((llvm::raw_ostream *)&v18, v6, v8);
    char v9 = v26;
    char v10 = *((unsigned char *)v26 + 23);
    BOOL v11 = v10 < 0;
    if (v10 < 0) {
      char v9 = *v26;
    }
    unsigned int v12 = (void *)(v10 & 0x7F);
    if (v11) {
      unsigned int v12 = v26[1];
    }
    v17[0] = v9;
    v17[1] = v12;
    (*(void (**)(llvm::yaml::IO *, void *))(*(void *)a1 + 224))(a1, v17);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v18);
    if (SHIBYTE(v28) < 0) {
      operator delete(v27[0]);
    }
  }
  else
  {
    __int16 v18 = 0;
    std::string::size_type v19 = 0;
    (*(void (**)(llvm::yaml::IO *, std::string::value_type **))(*(void *)a1 + 224))(a1, &v18);
    unsigned int v14 = v18;
    std::string::size_type v15 = v19;
    uint64_t Context = llvm::yaml::IO::getContext(a1);
    *(void *)&double result = sub_1CD5603F8(v14, v15, Context, a2).n128_u64[0];
  }
  return result;
}

uint64_t sub_1CD567428(uint64_t a1, std::string **a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    if ((std::string **)a1 != a2) {
      sub_1CC3CEF98((void ***)a1, *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 3));
    }
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    sub_1CC3CF1E0((void *)a1, (uint64_t)*a2, (uint64_t)a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 3));
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

void sub_1CD5674B8(llvm::yaml::IO *a1, const std::string *a2)
{
  if ((*(unsigned int (**)(llvm::yaml::IO *))(*(void *)a1 + 16))(a1))
  {
    v18[0] = 0;
    v18[1] = 0;
    uint64_t v19 = 0;
    LODWORD(v10) = 0;
    char v14 = 0;
    uint64_t v15 = 0;
    long long v17 = v18;
    int v16 = 0;
    char v9 = &unk_1F2646F30;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    llvm::yaml::IO::getContext(a1);
    llvm::Module::print(a2, (llvm::raw_ostream *)&v9, 0, 0, 0);
    char v4 = v17;
    char v5 = *((unsigned char *)v17 + 23);
    BOOL v6 = v5 < 0;
    if (v5 < 0) {
      char v4 = *v17;
    }
    size_t v7 = (void *)(v5 & 0x7F);
    if (v6) {
      size_t v7 = v17[1];
    }
    v8[0] = v4;
    v8[1] = v7;
    (*(void (**)(llvm::yaml::IO *, void *))(*(void *)a1 + 224))(a1, v8);
    llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v9);
    if (SHIBYTE(v19) < 0) {
      operator delete(v18[0]);
    }
  }
  else
  {
    char v9 = 0;
    uint64_t v10 = 0;
    (*(void (**)(llvm::yaml::IO *, void **))(*(void *)a1 + 224))(a1, &v9);
    llvm::yaml::IO::getContext(a1);
    __break(1u);
  }
}

void llvm::createPrintMIRPass(llvm *this, llvm::raw_ostream *a2)
{
}

void llvm::obfuscateModule(llvm *this, llvm::Module *a2, const llvm::TargetMachine *a3)
{
  v13[31] = *MEMORY[0x1E4F143B8];
  sub_1CD5678E8((uint64_t)v13, "__hidden#", 9uLL, "_", 1uLL, (uint64_t)"__ir_hidden#", 12);
  v12[0] = 0;
  v12[1] = 0;
  _OWORD v12[2] = 0x800000000;
  uint64_t v5 = qword_1EBCD1478;
  uint64_t v6 = unk_1EBCD1480;
  while (v5 != v6)
  {
    char v7 = *(unsigned char *)(v5 + 23);
    BOOL v8 = v7 < 0;
    if (v7 >= 0) {
      char v9 = (unsigned __int8 *)v5;
    }
    else {
      char v9 = *(unsigned __int8 **)v5;
    }
    size_t v10 = v7 & 0x7F;
    if (v8) {
      size_t v11 = *(void *)(v5 + 8);
    }
    else {
      size_t v11 = v10;
    }
    sub_1CC0D7F54((llvm::StringMapImpl *)v12, v9, v11);
    v5 += 24;
  }
  llvm::obfuscateModule((uint64_t)this, (uint64_t)a2, (uint64_t)v13, (uint64_t)v12);
}

void llvm::initializeObfuscateModulePass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD13F0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3D71D4;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD13F0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD5678E8(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  char v14 = (void *)sub_1CD5679F0(a1);
  *char v14 = &unk_1F2645020;
  uint64_t v15 = v14 + 1;
  int v16 = (char *)sub_1CB906F34(v14 + 1, (a3 + 1), 0);
  long long v17 = v16;
  v16[a3] = 0;
  if (a3) {
    memmove(v16, a2, a3);
  }
  *(void *)(a1 + 168) = v17;
  *(void *)(a1 + 176) = strlen(v17);
  __int16 v18 = (char *)sub_1CB906F34(v15, (a5 + 1), 0);
  uint64_t v19 = v18;
  v18[a5] = 0;
  if (a5) {
    memmove(v18, a4, a5);
  }
  *(void *)(a1 + 184) = v19;
  *(void *)(a1 + 192) = strlen(v19);
  *(void *)(a1 + 200) = a6;
  *(void *)(a1 + 208) = a7;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  return a1;
}

uint64_t sub_1CD5679F0(uint64_t a1)
{
  *(void *)a1 = &unk_1F2610720;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v2 = a1 + 8;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 24) = a1 + 40;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 36) = 4;
  *(void *)(a1 + 96) = 1;
  *(void *)(a1 + 72) = a1 + 88;
  *(void *)(a1 + 80) = 0;
  llvm::StringMapImpl::StringMapImpl(a1 + 104, 64, 24);
  *(void *)(a1 + 128) = v2;
  llvm::StringMapImpl::StringMapImpl(a1 + 136, 32, 24);
  *(void *)(a1 + 160) = v2;
  return a1;
}

uint64_t sub_1CD567A9C(uint64_t a1)
{
  *(void *)a1 = &unk_1F2645020;
  uint64_t v2 = *(void **)(a1 + 224);
  if (v2)
  {
    *(void *)(a1 + 232) = v2;
    operator delete(v2);
  }
  *(void *)a1 = &unk_1F2610720;
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 104));
  sub_1CBFFBA64(a1 + 8);
  return a1;
}

void *sub_1CD567B20(uint64_t a1, unint64_t a2)
{
  double result = (void *)sub_1CD567B90(a1, a2);
  unsigned int v4 = *(_DWORD *)(a1 + 8);
  uint64_t v5 = *(void *)a1 + 96 * v4;
  *(void *)uint64_t v5 = *result;
  *(_OWORD *)(v5 + 16) = xmmword_1CD96DBD0;
  *(void *)(v5 + 8) = v5 + 32;
  uint64_t v6 = v5 + 8;
  if (result[2])
  {
    double result = (void *)sub_1CC1B8518(v6, (uint64_t)(result + 1));
    unsigned int v4 = *(_DWORD *)(a1 + 8);
  }
  *(_DWORD *)(a1 + 8) = v4 + 1;
  return result;
}

unint64_t sub_1CD567B90(uint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v4 = *(void *)a1 + 96 * v2;
    if (*(void *)a1 > a2 || v4 <= a2) {
      sub_1CD567BFC();
    }
    sub_1CD567BFC();
  }
  return a2;
}

void sub_1CD567BFC()
{
}

void sub_1CD567C6C(uint64_t *a1, uint64_t a2)
{
  unsigned int v2 = *((_DWORD *)a1 + 2);
  if (v2)
  {
    uint64_t v4 = *a1 + 96 * v2;
    uint64_t v5 = a2 + 32;
    uint64_t v6 = *a1 + 8;
    do
    {
      uint64_t v7 = v6 - 8;
      *(void *)(v5 - 32) = *(void *)(v6 - 8);
      *(void *)(v5 - 24) = v5;
      *(_OWORD *)(v5 - 16) = xmmword_1CD96DBD0;
      if (*(void *)(v6 + 8)) {
        sub_1CC1B8518(v5 - 24, v6);
      }
      v5 += 96;
      v6 += 96;
    }
    while (v7 + 96 != v4);
    uint64_t v8 = *((unsigned int *)a1 + 2);
    if (v8)
    {
      uint64_t v9 = *a1;
      uint64_t v10 = 96 * v8;
      do
      {
        size_t v11 = *(void **)(v9 + v10 - 88);
        if ((void *)(v9 + v10 - 64) != v11) {
          free(v11);
        }
        v10 -= 96;
      }
      while (v10);
    }
  }
}

char **sub_1CD567D3C(char **a1)
{
  unsigned int v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 2);
  if (v3)
  {
    uint64_t v4 = 96 * v3;
    do
    {
      uint64_t v5 = *(char **)&v2[v4 - 88];
      if (&v2[v4 - 64] != v5) {
        free(v5);
      }
      v4 -= 96;
    }
    while (v4);
    unsigned int v2 = *a1;
  }
  if (v2 != (char *)(a1 + 2)) {
    free(v2);
  }
  return a1;
}

void sub_1CD567DB4(_WORD *a1, long long *a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD14D0, 0, 0);
  qword_1EBCD1550 = 0;
  qword_1EBCD1558 = 0;
  qword_1EBCD1578 = 0;
  unk_1EBCD1580 = 0;
  byte_1EBCD1588 = 0;
  qword_1EBCD1570 = 0;
  unk_1EBCD1560 = 0;
  unk_1EBCD1568 = &unk_1F2643C20;
  qword_1EBCD14D0 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCD1590 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCD1598 = (uint64_t)&unk_1F25F6428;
  qword_1EBCD15B0 = (uint64_t)&qword_1EBCD1598;
  llvm::cl::Option::setArgStr(v6, "obfuscation-symbol-map", 0x16uLL);
  word_1EBCD14DA = (8 * (*a1 & 3)) | word_1EBCD14DA & 0xFFE7;
  xmmword_1EBCD14F0 = *a2;
  xmmword_1EBCD1500 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD14D0);
}

void sub_1CD567ED8(_WORD *a1, _WORD *a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD13F8, 1, 0);
  qword_1EBCD1478 = 0;
  unk_1EBCD1480 = 0;
  qword_1EBCD1488 = 0;
  unk_1EBCD1490 = 0;
  qword_1EBCD13F8 = (uint64_t)&unk_1F260A070;
  qword_1EBCD1498 = 0;
  unk_1EBCD14A0 = 0;
  qword_1EBCD14A8 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCD14B0 = (uint64_t)&unk_1F260AC78;
  qword_1EBCD14C8 = (uint64_t)&qword_1EBCD14B0;
  llvm::cl::Option::setArgStr(v6, "obfuscate-preserve", 0x12uLL);
  word_1EBCD1402 = word_1EBCD1402 & 0xFFF8 | *a1 & 7;
  word_1EBCD1402 = (8 * (*a2 & 3)) | word_1EBCD1402 & 0xFFE7;
  xmmword_1EBCD1418 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD13F8);
}

void sub_1CD567FDC()
{
}

uint64_t sub_1CD568018(uint64_t result)
{
  if (result)
  {
    sub_1CC0D7CD8(result);
    JUMPOUT(0x1D25D9CE0);
  }
  return result;
}

void llvm::initializeOptimizePHIsPass(llvm *this, llvm::PassRegistry *a2)
{
  unsigned int v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD15B8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3D9380;
    v4[1] = &v2;
    uint64_t v3 = v4;
    std::__call_once(&qword_1EBCD15B8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

uint64_t sub_1CD5680CC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = a1[2];
  uint64_t v6 = 102 * ((v5 - v4) >> 3) - 1;
  if (v5 == v4) {
    uint64_t v6 = 0;
  }
  if (v6 == a1[5] + a1[4])
  {
    sub_1CD568474((uint64_t)a1);
    uint64_t v4 = a1[1];
    uint64_t v5 = a1[2];
  }
  if (v5 == v4)
  {
    unint64_t v8 = 0;
  }
  else
  {
    unint64_t v7 = a1[4] + a1[5];
    unint64_t v8 = *(void *)(v4 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
  }
  uint64_t v9 = *(void *)(a2 + 24);
  if (v9)
  {
    if (v9 == a2)
    {
      *(void *)(v8 + 24) = v8;
      (*(void (**)(void, unint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), v8);
      uint64_t v4 = a1[1];
      uint64_t v5 = a1[2];
    }
    else
    {
      *(void *)(v8 + 24) = v9;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(v8 + 24) = 0;
  }
  *(void *)(v8 + 32) = *(void *)(a2 + 32);
  uint64_t v10 = a1[4];
  uint64_t v11 = a1[5] + 1;
  a1[5] = v11;
  unint64_t v12 = v10 + v11;
  uint64_t v13 = (void *)(v4 + 8 * (v12 / 0x66));
  unint64_t v14 = *v13 + 40 * (v12 % 0x66);
  if (v5 == v4) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = v14;
  }
  if (v15 == *v13) {
    uint64_t v15 = *(v13 - 1) + 4080;
  }
  return v15 - 40;
}

void sub_1CD568238(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26109A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1CD568258(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F26109A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1D25D9CE0);
}

void sub_1CD5682AC()
{
}

void *sub_1CD5682B8(void *a1)
{
  *a1 = &unk_1F26109D8;
  sub_1CD5683A4((uint64_t)(a1 + 1));
  return a1;
}

void sub_1CD5682FC(void *a1)
{
  *a1 = &unk_1F26109D8;
  sub_1CD5683A4((uint64_t)(a1 + 1));

  JUMPOUT(0x1D25D9CE0);
}

uint64_t sub_1CD568360(uint64_t a1)
{
  return sub_1CD5683A4(a1 + 8);
}

void sub_1CD568368(void *a1)
{
  sub_1CD5683A4((uint64_t)a1 + 8);

  operator delete(a1);
}

uint64_t sub_1CD5683A4(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_1CD568474(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x66;
  unint64_t v4 = v2 - 102;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
LABEL_4:
    uint64_t v5 = *(void **)(a1 + 8);
    *(void *)&long long v18 = *v5;
    *(void *)(a1 + 8) = v5 + 1;
    sub_1CB904CD8(a1, &v18);
    return;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = v6 - *(void *)(a1 + 8);
  uint64_t v8 = *(void *)(a1 + 24);
  uint64_t v9 = v8 - *(void *)a1;
  if (v7 < v9)
  {
    if (v8 != v6)
    {
      *(void *)&long long v18 = operator new(0xFF0uLL);
      sub_1CD3F23B4(a1, &v18);
      return;
    }
    *(void *)&long long v18 = operator new(0xFF0uLL);
    sub_1CD3F24DC((void **)a1, &v18);
    goto LABEL_4;
  }
  if (v8 == *(void *)a1) {
    unint64_t v10 = 1;
  }
  else {
    unint64_t v10 = v9 >> 2;
  }
  uint64_t v20 = a1 + 24;
  if (v10 >> 61) {
    sub_1CB833614();
  }
  *(void *)&long long v18 = operator new(8 * v10);
  *((void *)&v18 + 1) = v18 + v7;
  *(void *)&long long v19 = v18 + v7;
  *((void *)&v19 + 1) = v18 + 8 * v10;
  long long v17 = operator new(0xFF0uLL);
  sub_1CD3F23B4((uint64_t)&v18, &v17);
  uint64_t v11 = *(char **)(a1 + 16);
  if (v11 == *(char **)(a1 + 8))
  {
    unint64_t v12 = *(char **)(a1 + 16);
  }
  else
  {
    do
    {
      v11 -= 8;
      sub_1CD3F24DC((void **)&v18, v11);
    }
    while (v11 != *(char **)(a1 + 8));
    unint64_t v12 = *(char **)(a1 + 16);
  }
  uint64_t v13 = *(void **)a1;
  long long v14 = v18;
  long long v15 = v19;
  *(void *)&long long v18 = *(void *)a1;
  *((void *)&v18 + 1) = v11;
  uint64_t v16 = *(void *)(a1 + 24);
  *(_OWORD *)a1 = v14;
  *(_OWORD *)(a1 + 16) = v15;
  *(void *)&long long v19 = v12;
  *((void *)&v19 + 1) = v16;
  if (v12 != v11) {
    *(void *)&long long v19 = &v12[(v11 - v12 + 7) & 0xFFFFFFFFFFFFFFF8];
  }
  if (v13) {
    operator delete(v13);
  }
}

void llvm::initializePeepholeOptimizerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD15C0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3DB418;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCD15C0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD568660(_WORD *a1, int **a2, long long *a3)
{
  uint64_t v6 = sub_1CB883A14((uint64_t)&qword_1EBCD18C8, 0, 0);
  dword_1EBCD1948 = 0;
  qword_1EBCD1950 = (uint64_t)&unk_1F25EA1B0;
  *(void *)&dword_1EBCD1958 = 0;
  qword_1EBCD18C8 = (uint64_t)&unk_1F2643F00;
  qword_1EBCD1960 = (uint64_t)&unk_1F2643DB0;
  qword_1EBCD1968 = (uint64_t)&unk_1F25EA168;
  qword_1EBCD1980 = (uint64_t)&qword_1EBCD1968;
  llvm::cl::Option::setArgStr(v6, "rewrite-phi-limit", 0x11uLL);
  word_1EBCD18D2 = (32 * (*a1 & 3)) | word_1EBCD18D2 & 0xFF9F;
  dword_1EBCD1948 = **a2;
  byte_1EBCD195C = 1;
  dword_1EBCD1958 = dword_1EBCD1948;
  xmmword_1EBCD18E8 = *a3;

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD18C8);
}

void llvm::initializePHIEliminationPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD1A48, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3E1380;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCD1A48, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD5687FC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 5;
  if (a2 > v2)
  {
    sub_1CD56882C((uint64_t **)a1, a2 - v2);
  }
  else if (a2 < v2)
  {
    sub_1CC3E4D6C((void *)a1, (void *)(*(void *)a1 + 32 * a2));
  }
}

void sub_1CD56882C(uint64_t **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (a2 <= ((char *)v4 - (char *)v5) >> 5)
  {
    if (a2)
    {
      long long v19 = &v5[4 * a2];
      do
      {
        uint64_t *v5 = (uint64_t)v5;
        v5[1] = (uint64_t)v5;
        void v5[2] = 0;
        void v5[3] = (uint64_t)v5;
        v5 += 4;
      }
      while (v5 != v19);
      uint64_t v5 = v19;
    }
    a1[1] = v5;
  }
  else
  {
    uint64_t v6 = (char *)v5 - (char *)*a1;
    unint64_t v7 = a2 + (v6 >> 5);
    if (v7 >> 59) {
      abort();
    }
    uint64_t v8 = (char *)v4 - (char *)*a1;
    if (v8 >> 4 > v7) {
      unint64_t v7 = v8 >> 4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v7;
    }
    char v23 = a1 + 2;
    if (v9)
    {
      if (v9 >> 59) {
        sub_1CB833614();
      }
      unint64_t v10 = (char *)operator new(32 * v9);
    }
    else
    {
      unint64_t v10 = 0;
    }
    uint64_t v11 = (uint64_t *)&v10[32 * (v6 >> 5)];
    uint64_t v22 = (uint64_t *)&v10[32 * v9];
    unint64_t v12 = &v11[4 * a2];
    uint64_t v13 = v11;
    do
    {
      *uint64_t v13 = (uint64_t)v13;
      v13[1] = (uint64_t)v13;
      void v13[2] = 0;
      v13[3] = (uint64_t)v13;
      v13 += 4;
    }
    while (v13 != v12);
    long long v15 = *a1;
    long long v14 = a1[1];
    v21.i64[1] = (uint64_t)v12;
    if (v14 == v15)
    {
      int64x2_t v17 = vdupq_n_s64((unint64_t)v14);
    }
    else
    {
      do
      {
        uint64_t v16 = v11;
        v14 -= 4;
        uint64_t v11 = sub_1CD46E850(v11 - 4, v14);
        *(v16 - 1) = *(v16 - 3);
      }
      while (v14 != v15);
      int64x2_t v17 = *(int64x2_t *)a1;
      unint64_t v12 = (uint64_t *)v21.i64[1];
    }
    *a1 = v11;
    a1[1] = v12;
    int64x2_t v21 = v17;
    long long v18 = a1[2];
    a1[2] = v22;
    uint64_t v22 = v18;
    long long __p = (void *)v17.i64[0];
    sub_1CC3E4CDC(&__p, v17.i64[0]);
    if (__p) {
      operator delete(__p);
    }
  }
}

BOOL sub_1CD5689A4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 248);
  unint64_t v6 = a2 & 0x7FFFFFFF;
  if (v6 >= *(unsigned int *)(a1 + 256)) {
    sub_1CD520A8C((uint64_t *)(a1 + 248), v6 + 1, a1 + 264);
  }
  BOOL result = sub_1CC30D1B0(*v5 + 56 * v6, a3);
  if (result)
  {
    uint64_t v8 = *(unsigned int *)(a3 + 40);
    if (v8)
    {
      for (unint64_t i = *(unsigned int **)(a3 + 32); ; i += 8)
      {
        unsigned int v10 = *i;
        if (!*i && ((v10 >> 26) & ~HIBYTE(v10) & 1) != 0 && i[1] == a2) {
          break;
        }
        if (!--v8) {
          return result;
        }
      }
      *unint64_t i = v10 & 0xFBFFFFFF;
    }
  }
  return result;
}

void *sub_1CD568A58(uint64_t a1, unsigned int a2, llvm::MachineInstr *this, int a4)
{
  BOOL result = (void *)llvm::MachineInstr::addRegisterKilled(this, a2, *(void *)(a1 + 376), a4);
  if (result)
  {
    unint64_t v8 = a2 & 0x7FFFFFFF;
    if (v8 >= *(unsigned int *)(a1 + 256)) {
      sub_1CD520A8C((uint64_t *)(a1 + 248), v8 + 1, a1 + 264);
    }
    uint64_t v9 = *(void *)(a1 + 248);
    long long v14 = this;
    uint64_t v10 = v9 + 56 * v8;
    uint64_t v11 = *(void **)(v10 + 40);
    unint64_t v12 = *(void *)(v10 + 48);
    uint64_t v13 = (void *)(v10 + 40);
    if ((unint64_t)v11 >= v12)
    {
      BOOL result = sub_1CBC13470((void **)(v9 + 56 * v8 + 32), &v14);
    }
    else
    {
      *uint64_t v11 = this;
      BOOL result = v11 + 1;
    }
    *uint64_t v13 = result;
  }
  return result;
}

void *sub_1CD568B08(uint64_t a1, unsigned int a2, llvm::MachineInstr *this, int a4)
{
  BOOL result = (void *)llvm::MachineInstr::addRegisterDead(this, a2, *(void *)(a1 + 376), a4);
  if (result)
  {
    unint64_t v8 = a2 & 0x7FFFFFFF;
    if (v8 >= *(unsigned int *)(a1 + 256)) {
      sub_1CD520A8C((uint64_t *)(a1 + 248), v8 + 1, a1 + 264);
    }
    uint64_t v9 = *(void *)(a1 + 248);
    long long v14 = this;
    uint64_t v10 = v9 + 56 * v8;
    uint64_t v11 = *(void **)(v10 + 40);
    unint64_t v12 = *(void *)(v10 + 48);
    uint64_t v13 = (void *)(v10 + 40);
    if ((unint64_t)v11 >= v12)
    {
      BOOL result = sub_1CBC13470((void **)(v9 + 56 * v8 + 32), &v14);
    }
    else
    {
      *uint64_t v11 = this;
      BOOL result = v11 + 1;
    }
    *uint64_t v13 = result;
  }
  return result;
}

BOOL sub_1CD568BB8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 248);
  unint64_t v6 = a2 & 0x7FFFFFFF;
  if (v6 >= *(unsigned int *)(a1 + 256)) {
    sub_1CD520A8C((uint64_t *)(a1 + 248), v6 + 1, a1 + 264);
  }
  BOOL result = sub_1CC30D1B0(*v5 + 56 * v6, a3);
  if (result)
  {
    uint64_t v8 = *(unsigned int *)(a3 + 40);
    if (v8)
    {
      for (unint64_t i = *(_DWORD **)(a3 + 32); (*i & 0x10000FF) != 0x1000000 || i[1] != a2; i += 8)
      {
        if (!--v8) {
          return result;
        }
      }
      *i &= ~0x4000000u;
    }
  }
  return result;
}

uint64_t sub_1CD568C70(uint64_t a1, uint64_t a2, int *a3, _OWORD *a4)
{
  unint64_t v12 = 0;
  uint64_t result = sub_1CD4F8538(*(void *)a2, *(_DWORD *)(a2 + 16), *a3, &v12);
  uint64_t v9 = v12;
  if (result)
  {
    char v10 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1CD4F85D4(a2, a3, v12);
    uint64_t v9 = (_DWORD *)result;
    *(_DWORD *)uint64_t result = *a3;
    *(_OWORD *)(result + 8) = *a4;
    char v10 = 1;
  }
  uint64_t v11 = *(void *)a2 + 24 * *(unsigned int *)(a2 + 16);
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 16) = v10;
  return result;
}

void llvm::initializePostRAHazardRecognizerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD1C90, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3E5830;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCD1C90, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializePostRASchedulerPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD1C98, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3E5DB4;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCD1C98, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void sub_1CD568DFC(long long *a1, const char **a2, _WORD *a3)
{
  sub_1CB883A14((uint64_t)&qword_1EBCD1EE0, 0, 0);
  qword_1EBCD1F60 = 0;
  qword_1EBCD1F68 = 0;
  qword_1EBCD1F88 = 0;
  unk_1EBCD1F90 = 0;
  byte_1EBCD1F98 = 0;
  qword_1EBCD1F80 = 0;
  unk_1EBCD1F70 = 0;
  unk_1EBCD1F78 = &unk_1F2643C20;
  qword_1EBCD1EE0 = (uint64_t)&unk_1F2643FD0;
  qword_1EBCD1FA0 = (uint64_t)&unk_1F2643EA0;
  qword_1EBCD1FA8 = (uint64_t)&unk_1F25F6428;
  qword_1EBCD1FC0 = (uint64_t)&qword_1EBCD1FA8;
  sub_1CD568EF8(a1, a2, a3);

  llvm::cl::Option::addArgument((llvm::cl::Option *)&qword_1EBCD1EE0);
}

void sub_1CD568EF8(long long *a1, const char **a2, _WORD *a3)
{
  xmmword_1EBCD1F00 = *a1;
  sub_1CD476D48(a2, (uint64_t)&qword_1EBCD1EE0);
  word_1EBCD1EEA = (32 * (*a3 & 3)) | word_1EBCD1EEA & 0xFF9F;
}

void llvm::initializePreISelIntrinsicLoweringLegacyPassPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD1FC8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3E7A74;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCD1FC8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createPreISelIntrinsicLoweringPass(llvm *this)
{
}

void llvm::initializeProcessImplicitDefsPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD1FD0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3E8BE8;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCD1FD0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::initializePEIPass(llvm *this, llvm::PassRegistry *a2)
{
  unint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD1FD8, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC3E9364;
    v4[1] = &v2;
    BOOL v3 = v4;
    std::__call_once(&qword_1EBCD1FD8, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::createPrologEpilogInserterPass(llvm *this)
{
}

uint64_t sub_1CD569164(uint64_t a1, uint64_t a2)
{
  llvm::DIExpression::getFragmentInfo(*(uint64_t **)(a1 + 24), *(uint64_t **)(a1 + 32), &v5);
  int8x16_t v3 = v5;
  llvm::DIExpression::getFragmentInfo(*(uint64_t **)(a2 + 24), *(uint64_t **)(a2 + 32), &v5);
  if (v3.i64[1] + v3.i64[0] <= (unint64_t)v5.i64[1]) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5.i64[1] + v5.i64[0] <= (unint64_t)v3.i64[1];
  }
}

void *sub_1CD5691D0(_DWORD *a1, uint64_t *a2)
{
  unint64_t v7 = 0;
  char v4 = sub_1CD569244((uint64_t)a1, *a2, &v7);
  int8x16_t v5 = v7;
  if ((v4 & 1) == 0)
  {
    int8x16_t v5 = sub_1CD5692F8(a1, a2, v7);
    void *v5 = *a2;
    v5[1] = v5 + 3;
    void v5[2] = 0x400000000;
  }
  return v5;
}

uint64_t sub_1CD569244(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v4 = 4;
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 16);
    if (!v4)
    {
      unint64_t v7 = 0;
      uint64_t result = 0;
      goto LABEL_7;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  int v5 = v4 - 1;
  unsigned int v6 = (v4 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  unint64_t v7 = (void *)(v3 + 56 * v6);
  uint64_t v8 = *v7;
  if (*v7 == a2)
  {
    uint64_t result = 1;
  }
  else
  {
    char v10 = 0;
    int v11 = 1;
    uint64_t result = 1;
    while (v8 != -4096)
    {
      if (v10) {
        BOOL v12 = 0;
      }
      else {
        BOOL v12 = v8 == -8192;
      }
      if (v12) {
        char v10 = v7;
      }
      unsigned int v13 = v6 + v11++;
      unsigned int v6 = v13 & v5;
      unint64_t v7 = (void *)(v3 + 56 * (v13 & v5));
      uint64_t v8 = *v7;
      if (*v7 == a2) {
        goto LABEL_7;
      }
    }
    uint64_t result = 0;
    if (v10) {
      unint64_t v7 = v10;
    }
  }
LABEL_7:
  *a3 = v7;
  return result;
}

void *sub_1CD5692F8(_DWORD *a1, uint64_t *a2, void *a3)
{
  int v5 = *a1 >> 1;
  if (*a1) {
    unsigned int v6 = 4;
  }
  else {
    unsigned int v6 = a1[4];
  }
  if (4 * v5 + 4 >= 3 * v6)
  {
    v6 *= 2;
  }
  else if (v6 + ~v5 - a1[1] > v6 >> 3)
  {
    goto LABEL_6;
  }
  sub_1CD5693B8((uint64_t)a1, v6);
  uint64_t v8 = 0;
  sub_1CD569244((uint64_t)a1, *a2, &v8);
  a3 = v8;
LABEL_6:
  *a1 += 2;
  if (*a3 != -4096) {
    --a1[1];
  }
  return a3;
}

void sub_1CD5693B8(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = a2;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v4 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v5 = v4 | (v4 >> 2) | ((v4 | (v4 >> 2)) >> 4);
    int v6 = ((v5 | (v5 >> 8)) >> 16) | v5 | (v5 >> 8);
    if ((v6 + 1) > 0x40) {
      unsigned int v2 = v6 + 1;
    }
    else {
      unsigned int v2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    if (v2 > 4)
    {
      *(void *)(a1 + 8) = operator new(56 * v2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v2;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    sub_1CD5695B4(a1, v7, v7 + 56 * v8);
    JUMPOUT(0x1D25D9CD0);
  }
  uint64_t v9 = 0;
  char v10 = v14;
  do
  {
    uint64_t v11 = a1 + v9;
    uint64_t v12 = *(void *)(a1 + v9 + 8);
    if ((v12 | 0x1000) != 0xFFFFFFFFFFFFF000)
    {
      *char v10 = v12;
      v10[1] = v10 + 3;
      unsigned int v13 = (const void **)(v11 + 16);
      void v10[2] = 0x400000000;
      if (*(_DWORD *)(v11 + 24)) {
        sub_1CBB08144((uint64_t)(v10 + 1), v13);
      }
      v10 += 7;
      if ((const void *)(a1 + v9 + 32) != *v13) {
        free((void *)*v13);
      }
    }
    v9 += 56;
  }
  while (v9 != 224);
  if (v2 > 4)
  {
    *(_DWORD *)a1 &= ~1u;
    *(void *)(a1 + 8) = operator new(56 * v2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v2;
  }
  sub_1CD5695B4(a1, (uint64_t)v14, (uint64_t)v10);
}

void sub_1CD5695B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  *(void *)a1 = *(_DWORD *)a1 & 1;
  if (v6)
  {
    unsigned int v8 = (void *)(a1 + 8);
    uint64_t v9 = (void *)(a1 + 232);
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (!v7) {
      goto LABEL_6;
    }
    unsigned int v8 = *(void **)(a1 + 8);
    uint64_t v9 = &v8[7 * v7];
  }
  do
  {
    void *v8 = -4096;
    v8 += 7;
  }
  while (v8 != v9);
LABEL_6:
  if (a2 != a3)
  {
    do
    {
      uint64_t v10 = *(void *)v4;
      if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        long long v14 = 0;
        sub_1CD569244(a1, v10, &v14);
        uint64_t v11 = v14;
        *long long v14 = *(void *)v4;
        uint64_t v11[2] = 0x400000000;
        v11[1] = v11 + 3;
        uint64_t v12 = (uint64_t)(v11 + 1);
        if (*(_DWORD *)(v4 + 16)) {
          sub_1CBB08144(v12, (const void **)(v4 + 8));
        }
        *(_DWORD *)a1 += 2;
        unsigned int v13 = *(void **)(v4 + 8);
        if ((void *)(v4 + 24) != v13) {
          free(v13);
        }
      }
      v4 += 56;
    }
    while (v4 != a3);
  }
}

uint64_t sub_1CD5696C0(uint64_t a1)
{
  if (*(void *)(a1 + 8) == *(void *)(a1 + 56)) {
    return 0;
  }
  else {
    return a1 + 16;
  }
}

uint64_t sub_1CD5696D8(uint64_t a1)
{
  if (*(void *)(a1 + 32) == *(void *)(a1 + 80)) {
    return 0;
  }
  else {
    return a1 + 40;
  }
}

void llvm::PseudoSourceValue::~PseudoSourceValue(llvm::PseudoSourceValue *this)
{
}

llvm::raw_ostream *llvm::PseudoSourceValue::printCustom(llvm::PseudoSourceValue *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v3 > 6)
  {
    unsigned int v7 = sub_1CB8E509C(a2, "TargetCustom");
    unint64_t v8 = *((unsigned int *)this + 2);
    return llvm::raw_ostream::operator<<(v7, v8);
  }
  else
  {
    uint64_t v4 = off_1E68304D0[v3];
    return sub_1CB8E509C(a2, v4);
  }
}

BOOL llvm::FixedStackPseudoSourceValue::isAliased(llvm::FixedStackPseudoSourceValue *this, const llvm::MachineFrameInfo *a2)
{
  return !a2
      || *(unsigned char *)(*((void *)a2 + 1) + 40 * (*((_DWORD *)a2 + 8) + *((_DWORD *)this + 4)) + 33) != 0;
}

BOOL llvm::FixedStackPseudoSourceValue::mayAlias(llvm::FixedStackPseudoSourceValue *this, const llvm::MachineFrameInfo *a2)
{
  return !a2
      || *(unsigned char *)(*((void *)a2 + 1) + 40 * (*((_DWORD *)a2 + 8) + *((_DWORD *)this + 4)) + 18) == 0;
}

llvm::raw_ostream *llvm::FixedStackPseudoSourceValue::printCustom(llvm::FixedStackPseudoSourceValue *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = sub_1CB8E509C(a2, "FixedStack");
  unint64_t v4 = *((int *)this + 4);

  return llvm::raw_ostream::operator<<(v3, v4);
}

uint64_t llvm::PseudoSourceValueManager::getConstantPool(llvm::PseudoSourceValueManager *this)
{
  return (uint64_t)this + 56;
}

uint64_t llvm::PseudoSourceValueManager::getJumpTable(llvm::PseudoSourceValueManager *this)
{
  return (uint64_t)this + 40;
}

_DWORD *sub_1CD569848(_DWORD *result)
{
  if (*((void *)result + 1))
  {
    uint64_t v1 = result[4];
    if (v1 > 4 * result[2] && v1 >= 0x41)
    {
      return sub_1CD569898(result);
    }
    else
    {
      if (v1)
      {
        unsigned int v2 = *(_DWORD **)result;
        uint64_t v3 = 16 * v1;
        do
        {
          *unsigned int v2 = -1;
          v2 += 4;
          v3 -= 16;
        }
        while (v3);
      }
      *((void *)result + 1) = 0;
    }
  }
  return result;
}

_DWORD *sub_1CD569898(_DWORD *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[4];
  int v3 = result[2];
  int v4 = 1 << (33 - __clz(v3 - 1));
  if (v4 <= 64) {
    int v4 = 64;
  }
  if (v3) {
    int v5 = v4;
  }
  else {
    int v5 = 0;
  }
  if (v5 == v2)
  {
    *((void *)result + 1) = 0;
    if (v2)
    {
      int v6 = *(_DWORD **)result;
      uint64_t v7 = 16 * v2;
      do
      {
        _DWORD *v6 = -1;
        v6 += 4;
        v7 -= 16;
      }
      while (v7);
    }
  }
  else
  {
    MEMORY[0x1D25D9CD0](*(void *)result, 8);
    return sub_1CBC04DCC(v1, v5);
  }
  return result;
}

void llvm::createBasicRegisterAllocator(llvm *this)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  operator new();
}

void llvm::initializeRABasicPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD21A0, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4108D8;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCD21A0, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void *sub_1CD569AD4(void *a1)
{
  *a1 = &unk_1F2611480;
  uint64_t v2 = (void *)a1[41];
  if (v2 != (void *)a1[40]) {
    free(v2);
  }
  int v3 = (void *)a1[39];
  if (v3 == a1 + 36)
  {
    (*(void (**)(void *))(a1[36] + 32))(a1 + 36);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  sub_1CD50C1C0(a1 + 6);
  return a1;
}

void llvm::initializeRegAllocEvictionAdvisorAnalysisPass(llvm *this, llvm::PassRegistry *a2)
{
  uint64_t v2 = this;
  if (atomic_load_explicit((atomic_ullong *volatile)&qword_1EBCD2400, memory_order_acquire) != -1)
  {
    v4[0] = sub_1CC4125D0;
    v4[1] = &v2;
    int v3 = v4;
    std::__call_once(&qword_1EBCD2400, &v3, (void (__cdecl *)(void *))sub_1CB848390);
  }
}

void llvm::callDefaultCtor<llvm::RegAllocEvictionAdvisorAnalysis>()
{
}

char *llvm::RegAllocEvictionAdvisorAnalysis::getPassName(llvm::RegAllocEvictionAdvisorAnalysis *this)
{
  return off_1E6830510[*((int *)this + 7)];
}

void sub_1CD569CAC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 160) = 1;
}

void *sub_1CD569CC4(void *a1)
{
  *a1 = &unk_1F26117A0;
  uint64_t v2 = a1 + 71;
  int v3 = (void *)a1[74];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  a1[19] = &unk_1F2611808;
  int v4 = (void *)a1[21];
  if (v4 != a1 + 23) {
    free(v4);
  }

  return sub_1CB87DD48(a1);
}

void *sub_1CD569DAC(void *a1)
{
  *a1 = &unk_1F2611808;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }
  return a1;
}

uint64_t sub_1CD569E00(uint64_t a1, __int16 a2, const void *a3, size_t a4, const void *a5, size_t a6)
{
  int v12 = 0;
  uint64_t v8 = sub_1CD42FA04(a1 + 152, (void *)a1, a3, a4, a5, a6, &v12);
  if (v8) {
    return v8;
  }
  *(_DWORD *)(a1 + 128) = v12;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 592);
  if (v9)
  {
    (*(void (**)(uint64_t, int *))(*(void *)v9 + 48))(v9, &v12);
    return v8;
  }
  sub_1CB920400();
  return sub_1CD569E94(v11);
}

uint64_t sub_1CD569E94(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 160) + 24)) {
    return 2;
  }
  else {
    return 3;
  }
}

void sub_1CD569EAC(void *a1)
{
  sub_1CD569CC4(a1);

  JUMPOUT(0x1D25D9CE0);
}

unint64_t sub_1CD569EE4(llvm::cl::Option *a1)
{
  return llvm::cl::generic_parser_base::getOptionWidth((llvm::cl::Option *)((char *)a1 + 152), a1);
}

uint64_t sub_1CD569EF0(llvm::cl::Option *a1, unsigned int a2)
{
  return llvm::cl::generic_parser_base::printOptionInfo((llvm::cl::Option *)((char *)a1 + 152), a1, a2);
}

llvm::raw_ostream *sub_1CD569F00(llvm::raw_ostream *result, int a2, int a3)
{
  if (a3)
  {
    int v3 = *((_DWORD *)result + 32);
LABEL_3:
    int v4 = &unk_1F2611858;
    char v6 = 1;
    int v5 = v3;
    return llvm::cl::generic_parser_base::printGenericOptionDiff((llvm::raw_ostream *)((char *)result + 152), result, (const llvm::cl::GenericOptionValue *)&v4, (llvm::raw_ostream *)((char *)result + 136), a2);
  }
  if (*((unsigned char *)result + 148))
  {
    int v3 = *((_DWORD *)result + 32);
    if (*((_DWORD *)result + 36) != v3) {
      goto LABEL_3;
    }
  }
  return result;
}

uint64_t sub_1CD569F84(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 148);
  if (*(unsigned char *)(result + 148)) {
    int v1 = *(_DWORD *)(result + 144);
  }
  *(_DWORD *)(result + 128) = v1;
  return result;
}

void *sub_1CD569F98(uint64_t a1, uint64_t a2)
{
  return sub_1CD42FB24((void *)(a1 + 152), a2);
}

void sub_1CD569FA0(void *a1)
{
  *a1 = &unk_1F2611808;
  uint64_t v2 = (void *)a1[2];
  if (v2 != a1 + 4) {
    free(v2);
  }

  JUMPOUT(0x1D25D9CE0);
}